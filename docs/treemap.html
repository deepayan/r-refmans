<!DOCTYPE html><html><head><title>Help for package treemap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {treemap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#business'><p>Fictitious  Business Statistics Data</p></a></li>
<li><a href='#GNI2014'><p>GNI 2014 Data</p></a></li>
<li><a href='#itreemap'><p>Interactive user interface for treemap</p></a></li>
<li><a href='#random.hierarchical.data'><p>Create random hierarchical data</p></a></li>
<li><a href='#tmPlot'><p>Create a treemap (deprecated)</p></a></li>
<li><a href='#treecolors'><p>Interactive tool to experiment with Tree Colors</p></a></li>
<li><a href='#treegraph'><p>Create a tree graph</p></a></li>
<li><a href='#treemap'><p>Create a treemap</p></a></li>
<li><a href='#treemap-package'><p>Treemap package</p></a></li>
<li><a href='#treepalette'><p>Obtain hierarchical color palettes (Tree Colors)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Treemap Visualization</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-05-25</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martijn Tennekes &lt;mtennekes@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A treemap is a space-filling visualization of hierarchical
    structures. This package offers great flexibility to draw treemaps.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>colorspace, data.table (&ge; 1.8.8), ggplot2, grid, gridBase,
igraph, methods, RColorBrewer, shiny (&ge; 0.12.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-05-25 14:24:58 UTC; mtes</td>
</tr>
<tr>
<td>Author:</td>
<td>Martijn Tennekes [aut, cre],
  Peter Ellis [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-25 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='business'>Fictitious  Business Statistics Data</h2><span id='topic+business'></span>

<h3>Description</h3>

<p>Fictitious (aggregated) business statistics data. The index variables (<code>NACE1</code> to <code>NACE4</code>) are derived from the Statistical Classification of Economic Activities in the European Community (NACE). The variables <code>turnover(.prev)</code> and <code>employees(.prev)</code> have values for NACE codes in the business economy domain only.
</p>


<h3>References</h3>

<p><a href="https://en.wikipedia.org/wiki/Statistical_Classification_of_Economic_Activities_in_the_European_Community">Statistical Classification of Economic Activities in the European Community (NACE)</a>
<a href="https://ec.europa.eu/eurostat/web/structural-business-statistics">Eurostat - Structural business statistics (SBS)</a>
</p>

<hr>
<h2 id='GNI2014'>GNI 2014 Data</h2><span id='topic+GNI2014'></span>

<h3>Description</h3>

<p>Gross national income (per capita) in dollars and population totals per country in 2014.
</p>


<h3>Details</h3>

<p>The GNI numbers from the World Bank are based on the Atlas. The population data are taken from Natural Earth Data.
</p>


<h3>References</h3>

<p><a href="https://www.worldbank.org/en/home">The World Bank - GNI per capita ranking</a>
<a href="https://www.naturalearthdata.com/">Natural Earth Data</a>
</p>

<hr>
<h2 id='itreemap'>Interactive user interface for treemap</h2><span id='topic+itreemap'></span>

<h3>Description</h3>

<p>This function is an interactive user interface for creating treemaps. Interaction is provided for the four main input arguments of (<code><a href="#topic+treemap">treemap</a></code>) besides the data.frame itself, namely <code>index</code>, <code>vSize</code>, <code>vColor</code> and <code>type</code>. Zooming in and out is possible. Command line outputs are generated in the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itreemap(
  dtf = NULL,
  index = NULL,
  vSize = NULL,
  vColor = NULL,
  type = NULL,
  height = 700,
  command.line.output = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itreemap_+3A_dtf">dtf</code></td>
<td>
<p>a data.frame (<code><a href="#topic+treemap">treemap</a></code>) If not provided, then the first data.frame in the global workspace is loaded.</p>
</td></tr>
<tr><td><code id="itreemap_+3A_index">index</code></td>
<td>
<p>index variables (up to four). See <code><a href="#topic+treemap">treemap</a></code>.</p>
</td></tr>
<tr><td><code id="itreemap_+3A_vsize">vSize</code></td>
<td>
<p>name of the variable that determine the rectangle sizes.</p>
</td></tr>
<tr><td><code id="itreemap_+3A_vcolor">vColor</code></td>
<td>
<p>name of the variable that determine the rectangle colors. See <code><a href="#topic+treemap">treemap</a></code>.</p>
</td></tr>
<tr><td><code id="itreemap_+3A_type">type</code></td>
<td>
<p>treemap type. See <code><a href="#topic+treemap">treemap</a></code>.</p>
</td></tr>
<tr><td><code id="itreemap_+3A_height">height</code></td>
<td>
<p>height of the plotted treemap in pixels. Tip: decrease this number if the treemap doesn't fit conveniently.</p>
</td></tr>
<tr><td><code id="itreemap_+3A_command.line.output">command.line.output</code></td>
<td>
<p>if <code>TRUE</code>, the command line output of the generated treemaps are provided in the console.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This interface will no longer be maintained (except for small bugs), since there is a better interactive interface available: <a href="https://github.com/d3treeR/d3treeR">https://github.com/d3treeR/d3treeR</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(business)
itreemap(business)

## End(Not run)
</code></pre>

<hr>
<h2 id='random.hierarchical.data'>Create random hierarchical data</h2><span id='topic+random.hierarchical.data'></span>

<h3>Description</h3>

<p>This function generates random hierarchical data. Experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random.hierarchical.data(
  n = NULL,
  method = "random",
  number.children = 3,
  children.root = 4,
  depth = 3,
  nodes.per.layer = NULL,
  labels = c("LETTERS", "numbers", "letters"),
  labels.prefix = NULL,
  sep = ".",
  colnames = c(paste("index", 1:depth, sep = ""), "x"),
  value.generator = rlnorm,
  value.generator.args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.hierarchical.data_+3A_n">n</code></td>
<td>
<p>number of leaf nodes. This is a shortcut argument. If specified, the method is set to <code>"random.arcs"</code> with a nodes.per.layer such that the average number of children per layer is as constant as possible.</p>
</td></tr>
<tr><td><code id="random.hierarchical.data_+3A_method">method</code></td>
<td>
<p>one of
</p>

<dl>
<dt><code>"random"</code>:</dt><dd><p>Random tree where for each node, the number of children, is determined by a random poisson generator with <code>lambda=number.children</code>, until the maximum depth specified by <code>depth</code> is reached. The number of children of the root node is set to <code>children.root</code>.</p>
</dd>
<dt><code>"random.arcs"</code>:</dt><dd><p>Random tree where the exact number of nodes in each layer must be speficied by <code>nodes.per.layer</code>. The arcs between the layers are random, with the restriction that each node is connected.</p>
</dd>
<dt><code>"full.tree"</code>:</dt><dd><p>Each node has exactly <code>number.children</code> children.</p>
</dd></dl>
</td></tr>
<tr><td><code id="random.hierarchical.data_+3A_number.children">number.children</code></td>
<td>
<p>the number of children. For <code>method="random"</code> this is the average number of children and for <code>method="full.tree"</code>, it is the exact number of children. In the latter case, it can also be a vector that specifies the number of children for each layer.</p>
</td></tr>
<tr><td><code id="random.hierarchical.data_+3A_children.root">children.root</code></td>
<td>
<p>number of children of the root node. For <code>method="random"</code> only.</p>
</td></tr>
<tr><td><code id="random.hierarchical.data_+3A_depth">depth</code></td>
<td>
<p>depth of the tree. Note that for <code>method="random"</code>, this depth may not be reached.</p>
</td></tr>
<tr><td><code id="random.hierarchical.data_+3A_nodes.per.layer">nodes.per.layer</code></td>
<td>
<p>exact number of nodes per layer, that is needed for <code>method="random.arcs"</code></p>
</td></tr>
<tr><td><code id="random.hierarchical.data_+3A_labels">labels</code></td>
<td>
<p>one of <code>"letters"</code>, <code>"LETTERS"</code>, <code>"numbers"</code>, <code>"numbers1"</code>, <code>"numbers0"</code>, <code>"hex"</code>, <code>"bits"</code>. The label set for <code>"numbers1"</code> is <code>1:9</code>, and for <code>"numbers0"</code> it is <code>0:9</code>. <code>"numbers"</code> is equal to <code>"numbers0"</code>, except that is starts from <code>1</code>.</p>
</td></tr>
<tr><td><code id="random.hierarchical.data_+3A_labels.prefix">labels.prefix</code></td>
<td>
<p>vector of label prefixes, one for each layer</p>
</td></tr>
<tr><td><code id="random.hierarchical.data_+3A_sep">sep</code></td>
<td>
<p>seperator character</p>
</td></tr>
<tr><td><code id="random.hierarchical.data_+3A_colnames">colnames</code></td>
<td>
<p>names of the columns. The first <code>depth</code> columns are the index columns (from highest to lowest hierarchical layer), and the last column is stored with random values</p>
</td></tr>
<tr><td><code id="random.hierarchical.data_+3A_value.generator">value.generator</code></td>
<td>
<p>function that determine the random values for the leaf nodes</p>
</td></tr>
<tr><td><code id="random.hierarchical.data_+3A_value.generator.args">value.generator.args</code></td>
<td>
<p>list of arguments passed to <code>value.generator</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- random.hierarchical.data(200)
treemap(d, index=names(d)[1:(ncol(d)-1)], vSize="x")

d &lt;- random.hierarchical.data(number.children=5)
treemap(d, index=names(d)[1:(ncol(d)-1)], vSize="x")

d &lt;- random.hierarchical.data(method="full.tree", number.children=3, value.generator=runif)
treemap(d, index=names(d)[1:(ncol(d)-1)], vSize="x")
</code></pre>

<hr>
<h2 id='tmPlot'>Create a treemap (deprecated)</h2><span id='topic+tmPlot'></span>

<h3>Description</h3>

<p>This function is migrated to <code><a href="#topic+treemap">treemap</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmPlot(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmPlot_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="#topic+treemap">treemap</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='treecolors'>Interactive tool to experiment with Tree Colors</h2><span id='topic+treecolors'></span>

<h3>Description</h3>

<p>Tree Colors are color palettes for tree data structures. They are used in <code><a href="#topic+treemap">treemap</a></code> by default (<code>type="index"</code>). With this tool, users can experiment with the parameters (in <code><a href="#topic+treemap">treemap</a></code> stored in <code>palette.HCL.options</code>). Tree Colors can directly be obtained by <code><a href="#topic+treepalette">treepalette</a></code> with <code>method="HCL"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treecolors(height = 700)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treecolors_+3A_height">height</code></td>
<td>
<p>height of the plotted treemap in pixels. Tip: decrease this number if the treemap doesn't fit conveniently.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
treecolors()

## End(Not run)
</code></pre>

<hr>
<h2 id='treegraph'>Create a tree graph</h2><span id='topic+treegraph'></span>

<h3>Description</h3>

<p>This function draws a tree graph. By default, a radial layout is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treegraph(
  dtf,
  index = names(dtf),
  directed = FALSE,
  palette.HCL.options,
  show.labels = FALSE,
  rootlabel = "",
  vertex.layout = "reingold.tilford",
  vertex.layout.params,
  truncate.labels = NULL,
  vertex.size = 3,
  vertex.label.dist = 0.3,
  vertex.label.cex = 0.8,
  vertex.label.family = "sans",
  vertex.label.color = "black",
  mai = c(0, 0, 0, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treegraph_+3A_dtf">dtf</code></td>
<td>
<p>a data.frame or data.table. Required.</p>
</td></tr>
<tr><td><code id="treegraph_+3A_index">index</code></td>
<td>
<p>the index variables of dtf (see <code><a href="#topic+treemap">treemap</a></code>)</p>
</td></tr>
<tr><td><code id="treegraph_+3A_directed">directed</code></td>
<td>
<p>logical that determines whether the graph is directed (<code>TRUE</code>) or undirected (<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="treegraph_+3A_palette.hcl.options">palette.HCL.options</code></td>
<td>
<p>list of advanced options to obtain Tree Colors from  the HCL space (when <code>palette="HCL"</code>). This list contains: 
</p>

<dl>
<dt><code>hue_start</code>:</dt><dd><p>number between 0 and 360 that determines the starting hue value (default: 30)</p>
</dd>
<dt><code>hue_end</code>:</dt><dd><p>number between <code>hue_start</code> and <code>hue_start + 360</code> that determines the ending hue value (default: 390)</p>
</dd>
<dt><code>hue_perm</code>:</dt><dd><p>boolean that determines whether the colors are permuted such that adjacent levels get more distinguishable colors. If <code>FALSE</code>, then the colors are equally distributed from <code>hue_start</code> to <code>hue_end</code> (default: TRUE)</p>
</dd>
<dt><code>hue_rev</code>:</dt><dd><p>boolean that determines whether the colors of even-numbered branched are reversed (to increase discrimination among branches)</p>
</dd>
<dt><code>hue_fraction</code>:</dt><dd><p>number between 0 and 1 that determines the fraction of the hue circle that is used for recursive color picking: if 1 then the full hue circle is used, which means that the hue of the colors of lower-level nodes are spread maximally. If 0, then the hue of the colors of lower-level nodes are identical of the hue of their parents. (default: .5)</p>
</dd>
<dt><code>chroma</code>:</dt><dd><p>chroma value of colors of the first-level nodes, that are determined by the first index variable (default: 60)</p>
</dd>
<dt><code>luminance</code>:</dt><dd><p>luminance value of colors of the first-level nodes, i.e. determined by the first index variable (default: 70)</p>
</dd>
<dt><code>chroma_slope</code>:</dt><dd><p>slope value for chroma of the non-first-level nodes. The chroma values for the second-level nodes are <code>chroma+chroma_slope</code>, for the third-level nodes <code>chroma+2*chroma_slope</code>, etc. (default: 5)</p>
</dd>
<dt><code>luminance_slope</code>:</dt><dd><p>slope value for luminance of the non-first-level nodes (default: -10)</p>
</dd></dl>
<p> For &quot;depth&quot; and &quot;categorical&quot; types, only the first two items are used. Use <code><a href="#topic+treecolors">treecolors</a></code> to experiment with these parameters.</p>
</td></tr>
<tr><td><code id="treegraph_+3A_show.labels">show.labels</code></td>
<td>
<p>show the labels</p>
</td></tr>
<tr><td><code id="treegraph_+3A_rootlabel">rootlabel</code></td>
<td>
<p>name of the rootlabel</p>
</td></tr>
<tr><td><code id="treegraph_+3A_vertex.layout">vertex.layout</code></td>
<td>
<p>layout algorithm name. See <code><a href="igraph.html#topic+layout">layout</a></code> for options. The name corresponds to the layout function name after the period symbol, e.g. &quot;auto&quot;, &quot;random&quot;, etc. The default is &quot;reingold.tilford&quot; with a cirular layout.</p>
</td></tr>
<tr><td><code id="treegraph_+3A_vertex.layout.params">vertex.layout.params</code></td>
<td>
<p>list of arguments passed to <code>vertex.layout</code></p>
</td></tr>
<tr><td><code id="treegraph_+3A_truncate.labels">truncate.labels</code></td>
<td>
<p>number of characters at which the levels are truncated. Either a single value for all index variables, or a vector of values for each index variable</p>
</td></tr>
<tr><td><code id="treegraph_+3A_vertex.size">vertex.size</code></td>
<td>
<p>vertex.size (see <code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code>)</p>
</td></tr>
<tr><td><code id="treegraph_+3A_vertex.label.dist">vertex.label.dist</code></td>
<td>
<p>vertex.label.dist (see <code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code>)</p>
</td></tr>
<tr><td><code id="treegraph_+3A_vertex.label.cex">vertex.label.cex</code></td>
<td>
<p>vertex.label.cex (see <code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code>)</p>
</td></tr>
<tr><td><code id="treegraph_+3A_vertex.label.family">vertex.label.family</code></td>
<td>
<p>vertex.label.family (see <code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code>)</p>
</td></tr>
<tr><td><code id="treegraph_+3A_vertex.label.color">vertex.label.color</code></td>
<td>
<p>vertex.label.color (see <code><a href="igraph.html#topic+igraph.plotting">igraph.plotting</a></code>)</p>
</td></tr>
<tr><td><code id="treegraph_+3A_mai">mai</code></td>
<td>
<p>margins see <code><a href="graphics.html#topic+par">par</a></code></p>
</td></tr>
<tr><td><code id="treegraph_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="igraph.html#topic+plot.igraph">plot.igraph</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>(invisible) igraph object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(business)
treegraph(business, index=c("NACE1", "NACE2", "NACE3", "NACE4"), show.labels=FALSE)
treegraph(business[business$NACE1=="F - Construction",], 
    index=c("NACE2", "NACE3", "NACE4"), show.labels=TRUE, truncate.labels=c(2,4,6))
treegraph(business[business$NACE1=="F - Construction",], 
    index=c("NACE2", "NACE3", "NACE4"), show.labels=TRUE, truncate.labels=c(2,4,6),
    vertex.layout="fruchterman.reingold")
</code></pre>

<hr>
<h2 id='treemap'>Create a treemap</h2><span id='topic+treemap'></span>

<h3>Description</h3>

<p>A treemap is a space-filling visualization of hierarchical structures. This function offers great flexibility to draw treemaps. Required is a data.frame (<code>dtf</code>) that contains one or more hierarchical index columns given by <code>index</code>, a column that determines the rectangle area sizes (<code>vSize</code>), and optionally a column that determines the rectangle colors (<code>vColor</code>). The way how rectangles are colored is determined by the argument <code>type</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treemap(
  dtf,
  index,
  vSize,
  vColor = NULL,
  stdErr = NULL,
  type = "index",
  fun.aggregate = "sum",
  title = NA,
  title.legend = NA,
  algorithm = "pivotSize",
  sortID = "-size",
  mirror.x = FALSE,
  mirror.y = FALSE,
  palette = NA,
  palette.HCL.options = NULL,
  range = NA,
  mapping = NA,
  n = 7,
  na.rm = TRUE,
  na.color = "#DDDDDD",
  na.text = "Missing",
  fontsize.title = 14,
  fontsize.labels = 11,
  fontsize.legend = 12,
  fontcolor.labels = NULL,
  fontface.labels = c("bold", rep("plain", length(index) - 1)),
  fontfamily.title = "sans",
  fontfamily.labels = "sans",
  fontfamily.legend = "sans",
  border.col = "black",
  border.lwds = c(length(index) + 1, (length(index) - 1):1),
  lowerbound.cex.labels = 0.4,
  inflate.labels = FALSE,
  bg.labels = NULL,
  force.print.labels = FALSE,
  overlap.labels = 0.5,
  align.labels = c("center", "center"),
  xmod.labels = 0,
  ymod.labels = 0,
  eval.labels = FALSE,
  position.legend = NULL,
  reverse.legend = FALSE,
  format.legend = NULL,
  drop.unused.levels = TRUE,
  aspRatio = NA,
  vp = NULL,
  draw = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treemap_+3A_dtf">dtf</code></td>
<td>
<p>a data.frame. Required.</p>
</td></tr>
<tr><td><code id="treemap_+3A_index">index</code></td>
<td>
<p>vector of column names in <code>dtf</code> that specify the aggregation indices. It could contain only one column name, which results in a treemap without hierarchy. If multiple column names are provided, the first name is the highest aggregation level, the second name the second-highest aggregation level, and so on. Required.</p>
</td></tr>
<tr><td><code id="treemap_+3A_vsize">vSize</code></td>
<td>
<p>name of the column in <code>dtf</code> that specifies the sizes of the rectangles. Required.</p>
</td></tr>
<tr><td><code id="treemap_+3A_vcolor">vColor</code></td>
<td>
<p>name of the column that, in combination with <code>type</code>, determines the colors of the rectangles. The variable can be scaled by the addition of &quot;*&lt;scale factor&gt;&quot; or &quot;/&lt;scale factor&gt;&quot;. Note: when omitted for <code>"value"</code> treemaps, a contant value of 1 is taken.</p>
</td></tr>
<tr><td><code id="treemap_+3A_stderr">stdErr</code></td>
<td>
<p>name of the column that contains standard errors. These are not used for the treemaps, but only aggregated accordingly and returned as item of the output list.</p>
</td></tr>
<tr><td><code id="treemap_+3A_type">type</code></td>
<td>
<p>type of the treemap, which determines how the rectangles are colored:
</p>

<dl>
<dt><code>"index"</code>:</dt><dd><p>colors are determined by the <code>index</code> variables. Different branches in the hierarchical tree get different colors. For this type, <code>vColor</code> is not needed.</p>
</dd>
<dt><code>"value"</code>:</dt><dd><p>the numeric <code>vColor</code>-column is directly mapped to a color palette. This palette is diverging, so that values of 0 are assigned to the mid color (white or yellow), and negative and positive values are assigned to color based on two different hues colors (by default reds for negative and greens for positive values). For more freedom, see <code>"manual"</code>.</p>
</dd>
<dt><code>"comp"</code>:</dt><dd><p>colors indicate change of the <code>vSize</code>-column with respect to the numeric <code>vColor</code>-column in percentages. Note: the negative scale may be different from the positive scale in order to compensate for the ratio distribution.</p>
</dd>
<dt><code>"dens"</code>:</dt><dd><p>colors indicate density. This is analogous to a population density map where <code>vSize</code>-values are area sizes, <code>vColor</code>-values are populations per area, and colors are computed as densities (i.e. population per squared km).</p>
</dd>
<dt><code>"depth"</code>:</dt><dd><p>each aggregation level (defined by <code>index</code>) has a distinct color. For this type, <code>vColor</code> is not needed.</p>
</dd>
<dt><code>"categorical"</code>:</dt><dd><p><code>vColor</code> is a factor column that determines the color.</p>
</dd>
<dt><code>"color"</code>:</dt><dd><p><code>vColor</code> is a vector of colors in the hexadecimal (#RRGGBB) format</p>
</dd>
<dt><code>"manual"</code>:</dt><dd><p>The numeric <code>vColor</code>-column is directly mapped to a color palette. Both palette and range should be provided. The palette is mapped linearly to the range.</p>
</dd></dl>
</td></tr>
<tr><td><code id="treemap_+3A_fun.aggregate">fun.aggregate</code></td>
<td>
<p>aggregation function, only used in <code>"value"</code> treemaps. This function determines how values of the lowest aggregation level are aggregated. By default, it takes the <code>sum</code>. Other sensible functions are <code>mean</code> and <code>weighted.mean</code>. In the latter case, the weights are determined by the <code>vSize</code> variable. Other arguments can be passed on. For <code>weighted.mean</code>, it is possible to assign a variable name for its <code>w</code> argument.</p>
</td></tr>
<tr><td><code id="treemap_+3A_title">title</code></td>
<td>
<p>title of the treemap.</p>
</td></tr>
<tr><td><code id="treemap_+3A_title.legend">title.legend</code></td>
<td>
<p>title of the legend.</p>
</td></tr>
<tr><td><code id="treemap_+3A_algorithm">algorithm</code></td>
<td>
<p>name of the used algorithm: <code>"squarified"</code> or <code>"pivotSize"</code>. The squarified treemap algorithm (Bruls et al., 2000) produces good aspect ratios, but ignores the sorting order of the rectangles (<code>sortID</code>). The ordered treemap, pivot-by-size, algorithm (Bederson et al., 2002) takes the sorting order (<code>sortID</code>) into account while aspect ratios are still acceptable.</p>
</td></tr>
<tr><td><code id="treemap_+3A_sortid">sortID</code></td>
<td>
<p>name of the variable that determines the order in which the rectangles are placed from top left to bottom right. Only applicable when <code>algorithm=="pivotSize"</code>. Also the values &quot;size&quot; and &quot;color&quot; can be used, which refer to <code>vSize</code> and <code>vColor</code> respectively. To inverse the sorting order, use &quot;-&quot; in the prefix. By default, large rectangles are placed top left.</p>
</td></tr>
<tr><td><code id="treemap_+3A_mirror.x">mirror.x</code></td>
<td>
<p>logical that determines whether the rectangles are mirrored horizontally</p>
</td></tr>
<tr><td><code id="treemap_+3A_mirror.y">mirror.y</code></td>
<td>
<p>logical that determines whether the rectangles are mirrored vertically</p>
</td></tr>
<tr><td><code id="treemap_+3A_palette">palette</code></td>
<td>
<p>one of the following: 
</p>

<dl>
<dt>a color palette:</dt><dd><p>i.e., a vector of hexadecimal colors (#RRGGBB)</p>
</dd>
<dt>a name of a Brewer palette:</dt><dd><p>See <code>RColorBrewer::display.brewer.all()</code> for the options. The palette can be reversed by prefixing with a &quot;-&quot;. For treemap types &quot;value&quot; and &quot;comp&quot;, a diverging palette should be chosen (default=&quot;RdYlGn&quot;), for type &quot;dens&quot; a sequential (default=&quot;OrRd&quot;). The default value for &quot;depth&quot; is &quot;Set2&quot;.</p>
</dd>
<dt>&quot;HCL&quot;:</dt><dd><p>Tree Colors are color schemes derived from the Hue-Chroma-Luminance color space model. This is only applicable for qualitative palettes, which are applied to the treemap types &quot;index&quot;, &quot;depth&quot;, and &quot;categorical&quot;. For &quot;index&quot; and &quot;categorical&quot; this is the default value.</p>
</dd></dl>
</td></tr>
<tr><td><code id="treemap_+3A_palette.hcl.options">palette.HCL.options</code></td>
<td>
<p>list of advanced options to obtain Tree Colors from  the HCL space (when <code>palette="HCL"</code>). This list contains: 
</p>

<dl>
<dt><code>hue_start</code>:</dt><dd><p>number between 0 and 360 that determines the starting hue value (default: 30)</p>
</dd>
<dt><code>hue_end</code>:</dt><dd><p>number between <code>hue_start</code> and <code>hue_start + 360</code> that determines the ending hue value (default: 390)</p>
</dd>
<dt><code>hue_perm</code>:</dt><dd><p>boolean that determines whether the colors are permuted such that adjacent levels get more distinguishable colors. If <code>FALSE</code>, then the colors are equally distributed from <code>hue_start</code> to <code>hue_end</code> (default: TRUE)</p>
</dd>
<dt><code>hue_rev</code>:</dt><dd><p>boolean that determines whether the colors of even-numbered branched are reversed (to increase discrimination among branches)</p>
</dd>
<dt><code>hue_fraction</code>:</dt><dd><p>number between 0 and 1 that determines the fraction of the hue circle that is used for recursive color picking: if 1 then the full hue circle is used, which means that the hue of the colors of lower-level nodes are spread maximally. If 0, then the hue of the colors of lower-level nodes are identical of the hue of their parents. (default: .5)</p>
</dd>
<dt><code>chroma</code>:</dt><dd><p>chroma value of colors of the first-level nodes, that are determined by the first index variable (default: 60)</p>
</dd>
<dt><code>luminance</code>:</dt><dd><p>luminance value of colors of the first-level nodes, i.e. determined by the first index variable (default: 70)</p>
</dd>
<dt><code>chroma_slope</code>:</dt><dd><p>slope value for chroma of the non-first-level nodes. The chroma values for the second-level nodes are <code>chroma+chroma_slope</code>, for the third-level nodes <code>chroma+2*chroma_slope</code>, etc. (default: 5)</p>
</dd>
<dt><code>luminance_slope</code>:</dt><dd><p>slope value for luminance of the non-first-level nodes (default: -10)</p>
</dd></dl>
<p> For &quot;depth&quot; and &quot;categorical&quot; types, only the first two items are used. Use <code><a href="#topic+treecolors">treecolors</a></code> to experiment with these parameters.</p>
</td></tr>
<tr><td><code id="treemap_+3A_range">range</code></td>
<td>
<p>range of values (so vector of two) that correspond to the color legend. By default, the range of actual values, determined by <code>vColor</code>, is used. Only applicable for numeric types, i.e. &quot;value&quot;, &quot;comp&quot;, &quot;dens&quot;, and &quot;manual&quot;. Note that the range doesn't affect the colors in the treemap itself for &quot;value&quot; and &quot;manual&quot; types; this is controlled by <code>mapping</code>.</p>
</td></tr>
<tr><td><code id="treemap_+3A_mapping">mapping</code></td>
<td>
<p>vector of three values that specifies the mapping of the actual values, determined by <code>vColor</code>, to <code>palette</code>. The three values are respectively the minimum value, the mid value, and the maximum value. The mid value is particularly useful for diverging color palettes, where it defined the middle, neutral, color which is typically white or yellow. The <code>mapping</code> should cover the <code>range</code>. By default, for &quot;value&quot; treemaps, it is <code>c(-max(abs(values)), 0, max(abs(values)))</code>, where values are the actual values defined by <code>vColor</code>. For &quot;manual&quot; treemaps, the default setting is <code>c(min(values), mean(range(values)), max(values))</code>. A vector of two can also be specified. In that case, the mid value will be the average of those.  Only applicable for &quot;value&quot; and &quot;manual&quot; type treemaps.</p>
</td></tr>
<tr><td><code id="treemap_+3A_n">n</code></td>
<td>
<p>preferred number of categories by which numeric variables are discretized.</p>
</td></tr>
<tr><td><code id="treemap_+3A_na.rm">na.rm</code></td>
<td>
<p>ignore missing vlues for the vSize variable (by default TRUE)</p>
</td></tr>
<tr><td><code id="treemap_+3A_na.color">na.color</code></td>
<td>
<p>color for missing values for the vColor variable</p>
</td></tr>
<tr><td><code id="treemap_+3A_na.text">na.text</code></td>
<td>
<p>legend label for missing values for the vColor variable</p>
</td></tr>
<tr><td><code id="treemap_+3A_fontsize.title">fontsize.title</code></td>
<td>
<p>font size of the title</p>
</td></tr>
<tr><td><code id="treemap_+3A_fontsize.labels">fontsize.labels</code></td>
<td>
<p>font size(s) of the data labels, which is either a single number that specifies the font size for all aggregation levels, or a vector that specifies the font size for each aggregation level. Use value <code>0</code> to omit the labels for the corresponding aggregation level.</p>
</td></tr>
<tr><td><code id="treemap_+3A_fontsize.legend">fontsize.legend</code></td>
<td>
<p>font size for the legend</p>
</td></tr>
<tr><td><code id="treemap_+3A_fontcolor.labels">fontcolor.labels</code></td>
<td>
<p>Specifies the label colors. Either a single color value, or a vector of color values one for each aggregation level. By default, white and black colors are used, depending on the background (<code>bg.labels</code>).</p>
</td></tr>
<tr><td><code id="treemap_+3A_fontface.labels">fontface.labels</code></td>
<td>
<p>either a single value, or a vector of values one for each aggregation level. Values can be integers  If an integer, following the R base graphics standard: 1 = plain, 2 = bold, 3 = italic, 4 = bold italic, or characters: <code>"plain"</code>, <code>"bold"</code>, <code>"italic"</code>, <code>"oblique"</code>, and <code>"bold.italic"</code>.</p>
</td></tr>
<tr><td><code id="treemap_+3A_fontfamily.title">fontfamily.title</code></td>
<td>
<p>font family of the title. Standard values are &quot;serif&quot;, &quot;sans&quot;, &quot;mono&quot;, &quot;symbol&quot;. Mapping is device dependent.</p>
</td></tr>
<tr><td><code id="treemap_+3A_fontfamily.labels">fontfamily.labels</code></td>
<td>
<p>font family of the labels in each rectangle. Standard values are &quot;serif&quot;, &quot;sans&quot;, &quot;mono&quot;, &quot;symbol&quot;. Mapping is device dependent.</p>
</td></tr>
<tr><td><code id="treemap_+3A_fontfamily.legend">fontfamily.legend</code></td>
<td>
<p>font family of the legend. Standard values are &quot;serif&quot;, &quot;sans&quot;, &quot;mono&quot;, &quot;symbol&quot;. Mapping is device dependent.</p>
</td></tr>
<tr><td><code id="treemap_+3A_border.col">border.col</code></td>
<td>
<p>color of borders drawn around each rectangle. Either one color for all rectangles or a vector of colors, or one for each aggregation level</p>
</td></tr>
<tr><td><code id="treemap_+3A_border.lwds">border.lwds</code></td>
<td>
<p>thicknesses of border lines. Either one number specifies the line thicknesses (widths) for all rectangles or a vector of line thicknesses for each aggregation level.</p>
</td></tr>
<tr><td><code id="treemap_+3A_lowerbound.cex.labels">lowerbound.cex.labels</code></td>
<td>
<p>multiplier between 0 and 1 that sets the lowerbound for the data label font sizes: 0 means draw all data labels, and 1 means only draw data labels if they fit (given <code>fontsize.labels</code>).</p>
</td></tr>
<tr><td><code id="treemap_+3A_inflate.labels">inflate.labels</code></td>
<td>
<p>logical that determines whether data labels are inflated inside the rectangles. If <code>TRUE</code>, <code>fontsize.labels</code> does not determine the fontsize anymore, but it still determines the minimum fontsize in combination with  <code>lowerbound.cex.labels</code>.</p>
</td></tr>
<tr><td><code id="treemap_+3A_bg.labels">bg.labels</code></td>
<td>
<p>background color of high aggregation labels. Either a color, or a number between 0 and 255 that determines the transparency of the labels. In the latter case, the color itself is determined by the color of the underlying rectangle. For &quot;value&quot; and &quot;categorical&quot; treemaps, the default is (slightly) transparent grey (<code>"#CCCCCCDC"</code>), and for the other types slightly transparent: <code>220</code>.</p>
</td></tr>
<tr><td><code id="treemap_+3A_force.print.labels">force.print.labels</code></td>
<td>
<p>logical that determines whether data labels are being forced to be printed if they don't fit.</p>
</td></tr>
<tr><td><code id="treemap_+3A_overlap.labels">overlap.labels</code></td>
<td>
<p>number between 0 and 1 that determines the tolerance of the overlap between labels. 0 means that labels of lower levels are not printed if higher level labels overlap, 1 means that labels are always printed. In-between values, for instance the default value .5, means that lower level labels are printed if other labels do not overlap with more than .5 times their area size.</p>
</td></tr>
<tr><td><code id="treemap_+3A_align.labels">align.labels</code></td>
<td>
<p>object that specifies the alignment of the labels. Either a character vector of two values specifying the horizontal alignment (<code>"left"</code>, <code>"center"</code>, or <code>"right"</code>) and the vertical alignment (<code>"top"</code>, <code>"center"</code>, or <code>"bottom"</code>), or a list of sush character vectors, one for each aggregation level.</p>
</td></tr>
<tr><td><code id="treemap_+3A_xmod.labels">xmod.labels</code></td>
<td>
<p>the horizontal position modification of the labels in inches. Options: a single value, a vector or a list that specifies the modification for each aggregation level. If a list is provided, each list item consists of a single value or a named vector that specify the modification per label.</p>
</td></tr>
<tr><td><code id="treemap_+3A_ymod.labels">ymod.labels</code></td>
<td>
<p>the vertical position modification of the labels in inches. Options: a single value, a vector or a list that specifies the modification for each aggregation level. If a list is provided, each list item consists of a single value or a named vector that specify the modification per label.</p>
</td></tr>
<tr><td><code id="treemap_+3A_eval.labels">eval.labels</code></td>
<td>
<p>should the text labels, i.e. the factor labels of the <code>index</code> variables, be evaluated as expressions? Useful for printing mathematical symbols or equations.</p>
</td></tr>
<tr><td><code id="treemap_+3A_position.legend">position.legend</code></td>
<td>
<p>position of the legend: <code>"bottom"</code>, <code>"right"</code>, or <code>"none"</code>. For &quot;categorical&quot; and &quot;index&quot; treemaps, <code>"right"</code> is the default value, for &quot;index&quot; treemap, <code>"none"</code>, and for the other types, <code>"bottom"</code>.</p>
</td></tr>
<tr><td><code id="treemap_+3A_reverse.legend">reverse.legend</code></td>
<td>
<p>should the legend be reversed?</p>
</td></tr>
<tr><td><code id="treemap_+3A_format.legend">format.legend</code></td>
<td>
<p>a list of additional arguments for the formatting of numbers in the legend to pass to <code>format()</code>; only applies if <code>type</code> is <code>"value"</code>, <code>"dens"</code> or <code>"manual"</code>.</p>
</td></tr>
<tr><td><code id="treemap_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>logical that determines whether unused levels (if any) are shown in the legend. Applicable for &quot;categorical&quot; treemap type.</p>
</td></tr>
<tr><td><code id="treemap_+3A_aspratio">aspRatio</code></td>
<td>
<p>preferred aspect ratio of the main rectangle, defined by width/height. When set to <code>NA</code>, the available window size is used.</p>
</td></tr>
<tr><td><code id="treemap_+3A_vp">vp</code></td>
<td>
<p><code><a href="grid.html#topic+viewport">viewport</a></code> to draw in. By default it is not specified, which means that a new plot is created. Useful when drawing small multiples, or when placing a treemap in a custom grid based plot.</p>
</td></tr>
<tr><td><code id="treemap_+3A_draw">draw</code></td>
<td>
<p>logical that determines whether to draw the treemap.</p>
</td></tr>
<tr><td><code id="treemap_+3A_...">...</code></td>
<td>
<p>arguments to be passed to other functions. Currently, only <code>fun.aggregate</code> takes optional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list is silently returned:
</p>
<table>
<tr><td><code>tm</code></td>
<td>
<p>a <code>data.frame</code> containing information about the rectangles: indices, sizes, original color values, derived color values, depth level, position (x0, y0, w, h), and color.</p>
</td></tr>
<tr><td><code>type</code></td>
<td>
<p>argument type</p>
</td></tr>
<tr><td><code>vSize</code></td>
<td>
<p>argument vSize</p>
</td></tr>
<tr><td><code>vColor</code></td>
<td>
<p>argument vColor</p>
</td></tr>
<tr><td><code>stdErr</code></td>
<td>
<p>standard errors</p>
</td></tr>
<tr><td><code>algorithm</code></td>
<td>
<p>argument algorithm</p>
</td></tr>
<tr><td><code>vpCoorX</code></td>
<td>
<p>x-coordinates of the treemap within the whole plot</p>
</td></tr>
<tr><td><code>vpCoorY</code></td>
<td>
<p>y-coordinates of the treemap within the whole plot</p>
</td></tr>
<tr><td><code>aspRatio</code></td>
<td>
<p>aspect ratio of the treemap</p>
</td></tr>
<tr><td><code>range</code></td>
<td>
<p>range of the color values scale</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bederson, B., Shneiderman, B., Wattenberg, M. (2002) Ordered and Quantum Treemaps: Making Effective Use of 2D Space to Display Hierarchies. ACM Transactions on Graphics, 21(4): 833-854.
</p>
<p>Bruls, D.M., C. Huizing, J.J. van Wijk. Squarified Treemaps. In: W. de Leeuw, R. van Liere (eds.), Data Visualization 2000, Proceedings of the joint Eurographics and IEEE TCVG Symposium on Visualization, 2000, Springer, Vienna, p. 33-42.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#########################################
### quick example with Gross National Income data
#########################################
data(GNI2014)
treemap(GNI2014,
       index=c("continent", "iso3"),
       vSize="population",
       vColor="GNI",
       type="value",
       format.legend = list(scientific = FALSE, big.mark = " "))

#########################################
### extended examples with fictive business statistics data
#########################################
data(business)

#########################################
### treemap types
#########################################

# index treemap: colors are determined by the index argument
## Not run: 
# large example which takes some time...
treemap(business, 
        index=c("NACE1", "NACE2", "NACE3"), 
        vSize="turnover", 
        type="index")

## End(Not run)
treemap(business[business$NACE1=="C - Manufacturing",],
        index=c("NACE2", "NACE3"),
        vSize=c("employees"),
        type="index")

# value treemap: colors are derived from a numeric variable given by vColor 
# (when omited, all values are set to 1 as in the following example)
treemap(business,
        index=c("NACE1", "NACE2"),
        vSize="employees",
        title.legend="number of NACE4 categories",
        type="value")

# comparisson treemaps: colors indicate change of vSize with respect to vColor
treemap(business,
        index=c("NACE1", "NACE2"),
        vSize="employees",
        vColor="employees.prev",
        type="comp")

# density treemaps: colors indicate density (like a population density map)
treemap(business,
        index=c("NACE1", "NACE2"),
        vSize="turnover",
        vColor="employees/1000",
        type="dens")

## Not run: 
# depth treemap: show depth
treemap(business,
        index=c("NACE1", "NACE2", "NACE3"), 
        vSize="turnover",
        type="depth")

## End(Not run)

# categorical treemap: colors are determined by a categorical variable
business &lt;- transform(business, data.available = factor(!is.na(turnover)), x = 1)
treemap(business,
        index=c("NACE1", "NACE2"),
        vSize="x",
        vColor="data.available",
        type="categorical")

## Not run: 
# color treemap
business$color &lt;- rainbow(nlevels(business$NACE2))[business$NACE2]
treemap(business,
        index=c("NACE1", "NACE2"), 
        vSize="x",
        vColor="color",
        type="color")

# manual
business$color &lt;- rainbow(nlevels(business$NACE2))[business$NACE2]
treemap(business,
        index=c("NACE1", "NACE2"), 
        vSize="turnover",
        vColor="employees",
        type="manual",
        palette=terrain.colors(10))

## End(Not run)

#########################################
### graphical options: control fontsizes
#########################################

## Not run: 
# draw labels of first index at fontsize 12 at the center, 
# and labels of second index at fontsize 8 top left
treemap(business, 
        index=c("NACE1", "NACE2"), 
        vSize="employees", 
        fontsize.labels=c(12, 8), 
        align.labels=list(c("center", "center"), c("left", "top")),
        lowerbound.cex.labels=1)
    
    
# draw all labels at fontsize 12 (only if they fit)
treemap(business,
        index=c("NACE1", "NACE2"),
        vSize="employees",
        fontsize.labels=12,
        lowerbound.cex.labels=1)

# draw all labels at fontsize 12, and if they don't fit, reduce to a minimum of .6*12
treemap(business,
        index=c("NACE1", "NACE2"),
        vSize="employees",
        fontsize.labels=12,
        lowerbound.cex.labels=.6)

# draw all labels at maximal fontsize
treemap(business,
        index=c("NACE1", "NACE2"),
        vSize="employees",
        lowerbound.cex.labels=0,
        inflate.labels = TRUE)

# draw all labels at fixed fontsize, even if they don't fit
treemap(business,
        index=c("NACE1", "NACE2"),
        vSize="employees",
        fontsize.labels=10,
        lowerbound.cex.labels=1,
        force.print.labels=TRUE)

#########################################
### graphical options: color palettes
#########################################

## for comp and value typed treemaps all diverging brewer palettes can be chosen
treemap(business,
        index=c("NACE1", "NACE2"),
        vSize="employees",
        vColor="employees.prev",
        type="comp",
        palette="RdBu")

## draw warm-colored index treemap
palette.HCL.options &lt;- list(hue_start=270, hue_end=360+150)
treemap(business, 
        index=c("NACE1", "NACE2"),
        vSize="employees",
        type="index",
        palette.HCL.options=palette.HCL.options)

# terrain colors
business$employees.growth &lt;- business$employees - business$employees.prev
treemap(business,
        index=c("NACE1", "NACE2"),
        vSize="employees",
        vColor="employees.growth",
        type="value",
        palette=terrain.colors(10))

# Brewer's Red-White-Grey palette reversed with predefined legend range
treemap(business,
        index=c("NACE1", "NACE2"),
        vSize="employees",
        vColor="employees.growth",
        type="value",
        palette="-RdGy",
        range=c(-20000,30000))

# More control over the color palette can be achieved with mapping
treemap(business,
        index=c("NACE1", "NACE2"),
        vSize="employees",
        vColor="employees.growth",
        type="value",
        palette="RdYlGn",
        range=c(-20000,30000),           # this is shown in the legend
        mapping=c(-30000, 10000, 40000)) # Rd is mapped to -30k, Yl to 10k, and Gn to 40k

## End(Not run)
</code></pre>

<hr>
<h2 id='treemap-package'>Treemap package</h2><span id='topic+treemap-package'></span>

<h3>Description</h3>

<p>A treemap is a space-filling visualization of hierarchical structures. This package offers great flexibility to draw treemaps.
</p>


<h3>Details</h3>

<p>The main function is <code><a href="#topic+treemap">treemap</a></code>. See also <code><a href="#topic+itreemap">itreemap</a></code> for a graphical user interface to create treemaps. By default Tree Colors are used, which are colors from the HCL color space. Use <code><a href="#topic+treecolors">treecolors</a></code> to experiment with the parameter settings.
</p>


<h3>Author(s)</h3>

<p>Martijn Tennekes <a href="mailto:mtennekes@gmail.com">mtennekes@gmail.com</a>
</p>

<hr>
<h2 id='treepalette'>Obtain hierarchical color palettes (Tree Colors)</h2><span id='topic+treepalette'></span>

<h3>Description</h3>

<p>Obtain hierarchical color palettes, either the so-called Tree Colors from the HCL color space model, or by using an existing color palette. The former method, which is recommended, is used by default in <code><a href="#topic+treemap">treemap</a></code> (type <code>"index"</code>) and <code><a href="#topic+treegraph">treegraph</a></code>. Use <code><a href="#topic+treecolors">treecolors</a></code> to experiment with this method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treepalette(
  dtf,
  index = names(dtf),
  method = "HCL",
  palette = NULL,
  palette.HCL.options,
  return.parameters = TRUE,
  prepare.dat = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="treepalette_+3A_dtf">dtf</code></td>
<td>
<p>a data.frame or data.table. Required.</p>
</td></tr>
<tr><td><code id="treepalette_+3A_index">index</code></td>
<td>
<p>the index variables of dtf</p>
</td></tr>
<tr><td><code id="treepalette_+3A_method">method</code></td>
<td>
<p>used method: either <code>"HCL"</code> (recommended), which is based on the HCL color space model, or <code>"HSV"</code>, which uses the argument <code>palette</code>.</p>
</td></tr>
<tr><td><code id="treepalette_+3A_palette">palette</code></td>
<td>
<p>color palette, which is only used for the HSV method</p>
</td></tr>
<tr><td><code id="treepalette_+3A_palette.hcl.options">palette.HCL.options</code></td>
<td>
<p>list of options to obtain Tree Colors from  the HCL space (when <code>palette="HCL"</code>). This list contains: 
</p>

<dl>
<dt><code>hue_start</code>:</dt><dd><p>number between 0 and 360 that determines the starting hue value (default: 30)</p>
</dd>
<dt><code>hue_end</code>:</dt><dd><p>number between <code>hue_start</code> and <code>hue_start + 360</code> that determines the ending hue value (default: 390)</p>
</dd>
<dt><code>hue_perm</code>:</dt><dd><p>boolean that determines whether the colors are permuted such that adjacent levels get more distinguishable colors. If <code>FALSE</code>, then the colors are equally distributed from <code>hue_start</code> to <code>hue_end</code> (default: TRUE)</p>
</dd>
<dt><code>hue_rev</code>:</dt><dd><p>boolean that determines whether the colors of even-numbered branched are reversed (to increase discrimination among branches)</p>
</dd>
<dt><code>hue_fraction</code>:</dt><dd><p>number between 0 and 1 that determines the fraction of the hue circle that is used for recursive color picking: if 1 then the full hue circle is used, which means that the hue of the colors of lower-level nodes are spread maximally. If 0, then the hue of the colors of lower-level nodes are identical of the hue of their parents. (default: .5)</p>
</dd>
<dt><code>chroma</code>:</dt><dd><p>chroma value of colors of the first-level nodes, that are determined by the first index variable (default: 60)</p>
</dd>
<dt><code>luminance</code>:</dt><dd><p>luminance value of colors of the first-level nodes, i.e. determined by the first index variable (default: 70)</p>
</dd>
<dt><code>chroma_slope</code>:</dt><dd><p>slope value for chroma of the non-first-level nodes. The chroma values for the second-level nodes are <code>chroma+chroma_slope</code>, for the third-level nodes <code>chroma+2*chroma_slope</code>, etc. (default: 5)</p>
</dd>
<dt><code>luminance_slope</code>:</dt><dd><p>slope value for luminance of the non-first-level nodes (default: -10)</p>
</dd></dl>
<p> For &quot;depth&quot; and &quot;categorical&quot; types, only the first two items are used. Use <code><a href="#topic+treecolors">treecolors</a></code> to experiment with these parameters.</p>
</td></tr>
<tr><td><code id="treepalette_+3A_return.parameters">return.parameters</code></td>
<td>
<p>should a data.frame with color values and parameter options be returned (<code>TRUE</code>), or just the vector of color values (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="treepalette_+3A_prepare.dat">prepare.dat</code></td>
<td>
<p>data is by default preprocessed, except for interal use</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a vector of colors, or a data.frame is return (see <code>return.parameters</code>).
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
