<!DOCTYPE html><html><head><title>Help for package ghcm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ghcm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ghcm'><p>ghcm: A package for Functional Conditional Independence Testing</p></a></li>
<li><a href='#ghcm_sim_data'><p>GHCM simulated data</p></a></li>
<li><a href='#ghcm_test'><p>Conditional Independence Test using the GHCM</p></a></li>
<li><a href='#inner_product_matrix_splines'><p>Computes the matrix of L2 inner products of the splines given in list_of_splines</p>
as produced by splines::interpSpline. The splines are assumed to be
functions on the interval [from, to].</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Functional Conditional Independence Testing with the GHCM</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>A statistical hypothesis test for conditional independence.
    Given residuals from a sufficiently powerful regression, it tests whether 
    the covariance of the residuals is vanishing. It can be applied to both
    discretely-observed functional data and multivariate data. 
    Details of the method can be found in Anton Rask Lundborg, Rajen D. Shah and Jonas
    Peters (2022) &lt;<a href="https://doi.org/10.1111%2Frssb.12544">doi:10.1111/rssb.12544</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>CompQuadForm, Rcpp, splines</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>graphics, stats, utils, refund, testthat, knitr, rmarkdown,
bookdown, ggplot2, reshape2, dplyr, tidyr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/arlundborg/ghcm">https://github.com/arlundborg/ghcm</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/arlundborg/ghcm/issues">https://github.com/arlundborg/ghcm/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-02 10:57:37 UTC; lundborg</td>
</tr>
<tr>
<td>Author:</td>
<td>Anton Rask Lundborg [aut, cre],
  Rajen D. Shah [aut],
  Jonas Peters [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anton Rask Lundborg &lt;arl@math.ku.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-02 13:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='ghcm'>ghcm: A package for Functional Conditional Independence Testing</h2><span id='topic+ghcm'></span>

<h3>Description</h3>

<p>To learn more about ghcm, start with the vignette:
'browseVignettes(package = &quot;ghcm&quot;)'
</p>

<hr>
<h2 id='ghcm_sim_data'>GHCM simulated data</h2><span id='topic+ghcm_sim_data'></span><span id='topic+ghcm_sim_data_irregular'></span>

<h3>Description</h3>

<p>A simulated dataset containing a combination of functional and scalar
variables. Y_1 and Y_2 are scalar random variables and are both functions
of Z. X, Z and W are functional, Z is a function of X and W is a function of Z.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghcm_sim_data

ghcm_sim_data_irregular
</code></pre>


<h3>Format</h3>

<p><code>ghcm_sim_data</code> is a data frame with 500 rows of 5 variables:
</p>

<dl>
<dt>Y_1</dt><dd><p>Numeric vector.</p>
</dd>
<dt>Y_2</dt><dd><p>Numeric vector.</p>
</dd>
<dt>Z</dt><dd><p>500 x 101 matrix.</p>
</dd>
<dt>X</dt><dd><p>500 x 101 matrix.</p>
</dd>
<dt>W</dt><dd><p>500 x 101 matrix.</p>
</dd>
</dl>

<p><code>ghcm_sim_data_irregular</code> is a list with 5 elements:
</p>

<dl>
<dt>Y_1</dt><dd><p>Numeric vector.</p>
</dd>
<dt>Y_2</dt><dd><p>Numeric vector.</p>
</dd>
<dt>Z</dt><dd><p>500 x 101 matrix.</p>
</dd>
<dt>X</dt><dd><p>A data frame with
</p>

<dl>
<dt>.obs</dt><dd><p>Integer between 1 and 500 indicating which curve the row corresponds to.</p>
</dd>
<dt>.index</dt><dd><p>Function argument that the curve is evaluated at.</p>
</dd>
<dt>.value</dt><dd><p>Value of the function.</p>
</dd>
</dl>
</dd>
<dt>W</dt><dd><p>A data frame with
</p>

<dl>
<dt>.obs</dt><dd><p>Integer between 1 and 500 indicating which curve the row corresponds to.</p>
</dd>
<dt>.index</dt><dd><p>Function argument that the curve is evaluated at.</p>
</dd>
<dt>.value</dt><dd><p>Value of the function.</p>
</dd>
</dl>
</dd>
</dl>



<h3>Details</h3>

<p>In <code>ghcm_sim_data</code> the functional variables each consists of 101 observations on
an equidistant grid on [0, 1].
</p>
<p>In <code>ghcm_sim_data_irregular</code> the functional variables X and W are instead only observed on
a subsample of the original equidistant grid.
</p>


<h3>Source</h3>

<p>The generation script can be found in the <code>data-raw</code> folder of
the package.
</p>

<hr>
<h2 id='ghcm_test'>Conditional Independence Test using the GHCM</h2><span id='topic+ghcm_test'></span>

<h3>Description</h3>

<p>Test whether X is independent of Y given Z using the Generalised Hilbertian
Covariance Measure. The function is applied to residuals from regressing
each of X and Y on Z respectively. Its validity is contingent on the performance
of the regression methods. For a more in-depth explanation see the package
vignette or the paper mentioned in the references.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ghcm_test(
  resid_X_on_Z,
  resid_Y_on_Z,
  X_limits = NULL,
  Y_limits = NULL,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ghcm_test_+3A_resid_x_on_z">resid_X_on_Z</code>, <code id="ghcm_test_+3A_resid_y_on_z">resid_Y_on_Z</code></td>
<td>
<p>Residuals from regressing X (Y) on Z with
a suitable regression method. If X (Y) is uni- or multivariate or
functional on a constant, fixed grid, the residuals should be supplied as
a vector or matrix with no missing values. If instead X (Y) is functional
and observed on varying grids or with missing values, the residuals should
be supplied as a &quot;melted&quot; data frame with
</p>

<dl>
<dt>.obs</dt><dd><p>Integer indicating which curve the row corresponds to.</p>
</dd>
<dt>.index</dt><dd><p>Function argument that the curve is evaluated at.</p>
</dd>
<dt>.value</dt><dd><p>Value of the function.</p>
</dd>
</dl>

<p>Note that in the irregular case, a minimum of 4 observations per curve is
required.</p>
</td></tr>
<tr><td><code id="ghcm_test_+3A_x_limits">X_limits</code>, <code id="ghcm_test_+3A_y_limits">Y_limits</code></td>
<td>
<p>The minimum and maximum values of the function
argument of the X (Y) curves. Ignored if X (Y) is not functional.</p>
</td></tr>
<tr><td><code id="ghcm_test_+3A_alpha">alpha</code></td>
<td>
<p>Numeric in the unit interval. Significance level of the test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ghcm</code> containing:
</p>

<dl>
<dt><code>test_statistic</code></dt><dd><p>Numeric, test statistic of the test.</p>
</dd>
<dt><code>p</code></dt><dd><p>Numeric in the unit interval, estimated p-value of
the test.</p>
</dd>
<dt><code>alpha</code></dt><dd><p>Numeric in the unit interval, significance level
of the test.</p>
</dd>
<dt><code>reject</code></dt><dd><p><code>TRUE</code> if <code>p</code> &lt; <code>alpha</code>, <code>FALSE</code> otherwise.</p>
</dd>
</dl>



<h3>References</h3>

<p>Please cite the following paper: Anton Rask Lundborg, Rajen D. Shah and
Jonas Peters: &quot;Conditional Independence Testing in Hilbert Spaces with
Applications to Functional Data Analysis&quot; Journal of the Royal Statistical
Society: Series B (Statistical Methodology) 2022 <a href="https://doi.org/10.1111/rssb.12544">doi:10.1111/rssb.12544</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(refund)) {
  set.seed(1)
  data(ghcm_sim_data)
  grid &lt;- seq(0, 1, length.out = 101)

# Test independence of two scalars given a functional variable

  m_1 &lt;- pfr(Y_1 ~ lf(Z), data=ghcm_sim_data)
  m_2 &lt;- pfr(Y_2 ~ lf(Z), data=ghcm_sim_data)
  ghcm_test(resid(m_1), resid(m_2))

# Test independence of a regularly observed functional variable and a
# scalar variable given a functional variable
  
    m_X &lt;- pffr(X ~ ff(Z), data=ghcm_sim_data, chunk.size=31000)
    ghcm_test(resid(m_X), resid(m_1))
  
# Test independence of two regularly observed functional variables given
# a functional variable
  
     m_W &lt;- pffr(W ~ ff(Z), data=ghcm_sim_data, chunk.size=31000)
    ghcm_test(resid(m_X), resid(m_W))
  


  data(ghcm_sim_data_irregular)
  n &lt;- length(ghcm_sim_data_irregular$Y_1)
  Z_df &lt;- data.frame(.obs=1:n)
  Z_df$Z &lt;- ghcm_sim_data_irregular$Z
# Test independence of an irregularly observed functional variable and a
# scalar variable given a functional variable
  
    m_1 &lt;- pfr(Y_1 ~ lf(Z), data=ghcm_sim_data_irregular)
    m_X &lt;- pffr(X ~ ff(Z), ydata = ghcm_sim_data_irregular$X,
    data=Z_df, chunk.size=31000)
    ghcm_test(resid(m_X), resid(m_1), X_limits=c(0, 1))
 
# Test independence of two irregularly observed functional variables given
# a functional variable
  
    m_W &lt;- pffr(W ~ ff(Z), ydata = ghcm_sim_data_irregular$W,
    data=Z_df, chunk.size=31000)
    ghcm_test(resid(m_X), resid(m_W), X_limits=c(0, 1), Y_limits=c(0, 1))
 
}

</code></pre>

<hr>
<h2 id='inner_product_matrix_splines'>Computes the matrix of L2 inner products of the splines given in list_of_splines
as produced by splines::interpSpline. The splines are assumed to be
functions on the interval [from, to].</h2><span id='topic+inner_product_matrix_splines'></span>

<h3>Description</h3>

<p>Computes the matrix of L2 inner products of the splines given in list_of_splines
as produced by splines::interpSpline. The splines are assumed to be
functions on the interval [from, to].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inner_product_matrix_splines(list_of_splines, from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inner_product_matrix_splines_+3A_list_of_splines">list_of_splines</code></td>
<td>
<p>list of interpSpline objects.</p>
</td></tr>
<tr><td><code id="inner_product_matrix_splines_+3A_from">from</code>, <code id="inner_product_matrix_splines_+3A_to">to</code></td>
<td>
<p>limits of integration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of inner products.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
