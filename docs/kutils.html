<!DOCTYPE html><html lang="en"><head><title>Help for package kutils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kutils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#all.equal.key'><p>An all.equal method for variable wide keys</p></a></li>
<li><a href='#all.equal.keylong'><p>An all.equal method for variable long keys</p></a></li>
<li><a href='#alphaOnly'><p>Keep only alpha-numeric symbols</p></a></li>
<li><a href='#anonomize'><p>Create unique anonymous id values</p></a></li>
<li><a href='#assignMissing'><p>Set missing values</p></a></li>
<li><a href='#assignRecode'><p>A variable is transformed in an indicated way</p></a></li>
<li><a href='#checkCoercion'><p>Check if values can be safely coerced without introduction of</p>
missing values</a></li>
<li><a href='#checkValue_old'><p>Compare observed values with the values listed</p>
(presumably from a variable key).</a></li>
<li><a href='#cleanDataFrame'><p>Check and Clean data.frame for usage with variable key functions</p></a></li>
<li><a href='#colnamesReplace'><p>Replace column names with new names from a named vector</p></a></li>
<li><a href='#deduper'><p>Removes redundant words from beginnings of character strings</p></a></li>
<li><a href='#deleteBogusColumns'><p>Remove columns in which the proportion of missing data exceeds</p>
a threshold.</a></li>
<li><a href='#deleteBogusRows'><p>Remove rows in which the proportion of missing data exceeds</p>
a threshold.</a></li>
<li><a href='#dev.create'><p>Create a graphics device</p></a></li>
<li><a href='#dir.create.unique'><p>Create a uniquely named directory. Appends number &amp; optionally date to directory</p>
name.</a></li>
<li><a href='#dms'><p>Delete multiple slashes, replace with one</p></a></li>
<li><a href='#dts'><p>Delete trailing slash</p></a></li>
<li><a href='#escape'><p>Text that is to be included as content in documents is cleaned</p>
(escaped) to prevent errors</a></li>
<li><a href='#file.backup'><p>Create a backup version of a file by renaming it.</p></a></li>
<li><a href='#importQualtrics'><p>Import Qualtrics survey files, apply clean column names</p></a></li>
<li><a href='#initProject'><p>Create project directories, initialize a git repo, create README.md</p>
ChangeLog, and R template file in R directory</a></li>
<li><a href='#is.data.frame.simple'><p>Check if a data frame is a simple collection of columns (no lists</p>
or matrices within)</a></li>
<li><a href='#isNA'><p>Check if values are R NA symbol or any one of the na.strings</p>
elements</a></li>
<li><a href='#keyApply'><p>Apply variable key to data frame (generate recoded data frame)</p></a></li>
<li><a href='#keyCheck'><p>Check a key for consistency of names, values with classes.</p></a></li>
<li><a href='#keyCrossRef'><p>keyCrossRef</p></a></li>
<li><a href='#keyDiagnostic'><p>Diagnose accuracy of result from applying variable key to data</p></a></li>
<li><a href='#keyDiff'><p>Show difference between 2 keys</p></a></li>
<li><a href='#keyImport'><p>Import/validate a key object or import/validate a key from a file.</p></a></li>
<li><a href='#keyLookup'><p>Look for old (or new) names in variable key</p></a></li>
<li><a href='#keyRead'><p>Read file after deducing file type from suffix.</p></a></li>
<li><a href='#keySave'><p>Save key as file after deducing type from suffix</p></a></li>
<li><a href='#keysPool'><p>Homogenize class values and create a long key by pooling variable</p>
keys.</a></li>
<li><a href='#keysPoolCheck'><p>Compares keys from different data sets; finds differences classes of variables.</p>
This used to check for similarity of keys from various data sets,
one precursor to either combining the keys or merging the data
sets themselves.</a></li>
<li><a href='#keyTemplate'><p>Create variable key template (in memory or in a file)</p></a></li>
<li><a href='#keyTemplateSPSS'><p>Import an SPSS file, create a key representing the numeric -&gt;</p>
factor transition</a></li>
<li><a href='#keyTemplateStata'><p>Import a Stata (version 12 or lower) file, create a key</p>
representing the numeric -&gt; factor transition</a></li>
<li><a href='#keyUpdate'><p>Update a key in light of a new data frame (add variables and</p>
values)</a></li>
<li><a href='#likert'><p>Percentage tables for Likert Scale variables</p></a></li>
<li><a href='#long2wide'><p>convert a key object from long to wide format</p></a></li>
<li><a href='#makeKeylist'><p>Convert the variable key into a list of long keys, one for each variable.</p></a></li>
<li><a href='#mergeCheck'><p>First draft of function to diagnose problems in merges and key variables</p></a></li>
<li><a href='#mgsub'><p>apply a vector of replacements, one after the other.</p></a></li>
<li><a href='#modifyVector'><p>Use new information to update a vector. Similar in concept to</p>
R's modify list</a></li>
<li><a href='#n2NA'><p>Convert nothing to R missing(NA).</p></a></li>
<li><a href='#naLast'><p>Sort key so that non missing values are first in the</p>
value vector.</a></li>
<li><a href='#natlongsurv'><p>Smoking, Happiness, and other survey responses</p></a></li>
<li><a href='#padW0'><p>Insert 0's in the front of existing digits or characters so that</p>
all elements of a vector have the same number of characters.</a></li>
<li><a href='#peek'><p>Show variables, one at a time, QUICKLY and EASILY.</p></a></li>
<li><a href='#print.keycheck'><p>Print out the result of mergeCheck function.</p></a></li>
<li><a href='#print.keyDiff'><p>Print a keyDiff object</p></a></li>
<li><a href='#print.likert'><p>print method for likert tables</p></a></li>
<li><a href='#qualtricsBlockStack'><p>Create meta data frame to align identical questions</p></a></li>
<li><a href='#removeMatches'><p>Remove elements if they are in a target vector, possibly replacing with NA</p></a></li>
<li><a href='#reverse'><p>Reverse the levels in a factor</p></a></li>
<li><a href='#safeInteger'><p>If a numeric variable has only integer values, then</p>
make it an integer.</a></li>
<li><a href='#shorten'><p>Reduce each in a vector of strings to a given length</p></a></li>
<li><a href='#sortStanza'><p>Move missing values to last row in long key block</p></a></li>
<li><a href='#starsig'><p>How many stars would we need for this p value?</p></a></li>
<li><a href='#statdatKey'><p>keyFactors: private function that does work for keyTemplateSPSS and</p>
key template Stata</a></li>
<li><a href='#stringbreak'><p>Insert &quot;\n&quot; after the k'th character in a string. This IS vectorized,</p>
so can receive just one or many character strings in a vector.</a></li>
<li><a href='#truncsmart'><p>Cuts a string at a specified linewidth, trying to align cut with a</p>
separator</a></li>
<li><a href='#updatePackages'><p>Update packages, spot new dependencies, and install them</p></a></li>
<li><a href='#varlabTemplate'><p>Create Variable Label Template</p></a></li>
<li><a href='#wide2long'><p>Convert a key object from wide to long format</p></a></li>
<li><a href='#writeCSV'><p>Write CSV files with quotes same as MS Excel 2013 or newer</p></a></li>
<li><a href='#zapspace'><p>Convert leading or trailing white space and tab characters to nothing.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Project Management Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>1.73</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-17</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Johnson &lt;pauljohn@ku.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for data importation, recoding, and inspection.
    There are functions to create new project
    folders, R code templates, create uniquely named output
    directories, and to quickly obtain a visual summary for each
    variable in a data frame.  The main feature here is the systematic
    implementation of the "variable key" framework for data
    importation and recoding.  We are eager to have community feedback
    about the variable key and the vignette about it. In version 1.7,
    the function 'semTable' is removed. It was deprecated since 1.67.
    That is provided in a separate package, 'semTable'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, methods, foreign, xtable, plyr, openxlsx, RUnit</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rockchalk</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-17 14:13:02 UTC; pauljohn</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul Johnson [aut, cre],
  Benjamin Kite [aut],
  Charles Redmon [aut],
  Jared Harpole [ctb],
  Kenna Whitley [ctb],
  Po-Yi Chen [ctb],
  Shadi Pirhosseinloo [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-17 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='all.equal.key'>An all.equal method for variable wide keys</h2><span id='topic+all.equal.key'></span>

<h3>Description</h3>

<p>Disregards attributes by defaults. Before comparing the two keys,
the values are sorted by <code>"name_new")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'key'
all.equal(target, current, ..., check.attributes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all.equal.key_+3A_target">target</code></td>
<td>
<p>A wide variable key</p>
</td></tr>
<tr><td><code id="all.equal.key_+3A_current">current</code></td>
<td>
<p>A wide variable key</p>
</td></tr>
<tr><td><code id="all.equal.key_+3A_...">...</code></td>
<td>
<p>Other arguments that are ignored</p>
</td></tr>
<tr><td><code id="all.equal.key_+3A_check.attributes">check.attributes</code></td>
<td>
<p>Default FALSE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul E. Johnson &lt;pauljohn@ku.edu&gt;
</p>

<hr>
<h2 id='all.equal.keylong'>An all.equal method for variable long keys</h2><span id='topic+all.equal.keylong'></span>

<h3>Description</h3>

<p>Disregards attributes by defaults. Before comparing the two keys,
the values are sorted by <code>"name_new")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'keylong'
all.equal(target, current, ..., check.attributes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all.equal.keylong_+3A_target">target</code></td>
<td>
<p>A long variable key</p>
</td></tr>
<tr><td><code id="all.equal.keylong_+3A_current">current</code></td>
<td>
<p>A long variable key</p>
</td></tr>
<tr><td><code id="all.equal.keylong_+3A_...">...</code></td>
<td>
<p>Other arguments that are ignored</p>
</td></tr>
<tr><td><code id="all.equal.keylong_+3A_check.attributes">check.attributes</code></td>
<td>
<p>Default FALSE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul E. Johnson &lt;pauljohn@ku.edu&gt;
</p>

<hr>
<h2 id='alphaOnly'>Keep only alpha-numeric symbols</h2><span id='topic+alphaOnly'></span>

<h3>Description</h3>

<p>From a text string, keep ASCII letters, numbers, as well as &quot;'&quot;,
&quot; &quot;, &quot;_&quot; &quot;(&quot;, &quot;)&quot;, &quot;-&quot;, and &quot;+&quot;. For maximum compatability with
the cross-platform file-naming standard. Obliterates all
characters that migth be mistaken for shell symbols, like &quot;^&quot;,
&quot;$&quot;, &quot;@&quot; and so forth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alphaOnly(x, also)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alphaOnly_+3A_x">x</code></td>
<td>
<p>text string, or vector of strings (each of which is
processed separately)</p>
</td></tr>
<tr><td><code id="alphaOnly_+3A_also">also</code></td>
<td>
<p>A named vector of other symbols that the user wants to
remove, along with replacements. For example, c(&quot; &quot; = &quot;_&quot;,
&quot;-&quot; = &quot;&quot;, &quot;+&quot; = &quot;&quot;) to replace space with underscore and minus
and plus signs with nothing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Removes trailing spaces.
</p>
<p>This version allows internal spaces in the string, by default. The
also argument can be used to eliminate spaces or other hated symbols.
</p>


<h3>Value</h3>

<p>cleaned text string
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("[]kansas(city) Missouri", "percent%slash/",
       "\back{squiggle}_under(paren)", "*star-minus+plus")
alphaOnly(x)
alphaOnly(x, also = c(" " = "_", "+" = "_"))
alphaOnly(x, also = c("(" = "[", ")" = "]"))
</code></pre>

<hr>
<h2 id='anonomize'>Create unique anonymous id values</h2><span id='topic+anonomize'></span>

<h3>Description</h3>

<p>Obscure participant id values by replacing them with &quot;anon-1&quot; and
so forth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anonomize(x, prefix = "anon")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anonomize_+3A_x">x</code></td>
<td>
<p>A column of &quot;confidential&quot; names, possibly with repeats</p>
</td></tr>
<tr><td><code id="anonomize_+3A_prefix">prefix</code></td>
<td>
<p>Character string to use as prefix in result.
Default is &quot;anon&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Caution: the true &quot;confidential&quot; names are used as names in the
output vector
</p>


<h3>Value</h3>

<p>Named character vector of anonymized id names.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
x &lt;- c(&quot;bill&quot;, &quot;bob&quot;, &quot;fred&quot;, &quot;bill&quot;)
(anonomize(x, prefix = &quot;id&quot;))
</p>

<hr>
<h2 id='assignMissing'>Set missing values</h2><span id='topic+assignMissing'></span>

<h3>Description</h3>

<p>The missings values have to be carefully written, depending on the
type of variable that is being processed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignMissing(x, missings = NULL, sep = ";")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assignMissing_+3A_x">x</code></td>
<td>
<p>A variable</p>
</td></tr>
<tr><td><code id="assignMissing_+3A_missings">missings</code></td>
<td>
<p>A string vector of semi-colon separated values,
ranges, and/or inequalities.  For strings and factors, only an
enumeration of values (or factor levels) to be excluded is
allowed. For numeric variables (integers or floating point
variables), one can specify open and double-sided intervals as
well as particular values to be marked as missing. One can
append particular values and ranges by
&quot;1;2;3;(8,10);[22,24];&gt; 99;&lt; 2&quot;. The double-sided interval is
represented in the usual mathematical way, where hard
bracketes indicate &quot;closed&quot; intervals and parentheses indicate
open intervals.</p>

<ol>
<li><p> &quot;(a,b)&quot; means values of x greater than a and smaller than b
will be set as missing.
</p>
</li>
<li><p> &quot;[a,b]&quot; is a closed interval, one which includes the
endpoints, so a &lt;= x &lt;= b will be set as NA
</p>
</li>
<li><p> &quot;(a,b]&quot; and &quot;[a,b)&quot; are acceptable.
</p>
</li>
<li><p> &quot;&lt; a&quot;  indicates all values smaller than a will be missing
</p>
</li>
<li><p>  &quot;&lt;= a&quot; means values smaller than or equal to a will be
excluded
</p>
</li>
<li><p> &quot;&gt; a&quot; and &quot;&gt;= a&quot; have comparable
interpretations.
</p>
</li>
<li><p> &quot;8;9;10&quot; Mark off specific values by
an enumeration. Be aware, however, that this is
useful only for integer variables.  As demonstrated in the
example, for floating point numbers, one must specify intervals.
</p>
</li>
<li><p> For factors and character variables, the argument missings
can be written either as &quot;lo;med;hi&quot; or &quot;c('lo','med','hi')&quot; </p>
</li></ol>
</td></tr>
<tr><td><code id="assignMissing_+3A_sep">sep</code></td>
<td>
<p>A separator symbol, &quot;;&quot; (semicolon) by default</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Version 0.95 of kutils introduced a new style for specification of
missing values.
</p>


<h3>Value</h3>

<p>A cleaned column in which R's NA symbol replaces values
that should be missing
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 1.  Integers.
x &lt;- seq.int(-2L, 22L, by = 2L)
## Exclude scores 8, 10, 18
assignMissing(x, "8;10;18")
## Specify range, 4 to 12 inclusive
missings &lt;- "[4,12]"
assignMissing(x, missings)
## Not inclusive
assignMissing(x,  "(4,12)")
## Set missing for any value smaller that 7
assignMissing(x, "&lt; 7")
assignMissing(x, "&lt;= 8")
assignMissing(x, "&gt; 11")
assignMissing(x, "&lt; -1;2;4;(7, 9);&gt; 20")


## 2. strings
x &lt;- c("low", "low", "med", "high")
missings &lt;- "low;high"
assignMissing(x, missings)
missings &lt;- "med;doesnot exist"
assignMissing(x, missings)
## Test alternate separator
assignMissing(x, "low|med", sep = "|")

## 3. factors (same as strings, really)
x &lt;- factor(c("low", "low", "med", "high"), levels = c("low", "med", "high"))
missings &lt;- "low;high"
assignMissing(x, missings)
## Previous same as
missings &lt;- c("low", "high")
assignMissing(x, missings)

missings &lt;- c("med", "doesnot exist")
assignMissing(x, missings)
## ordered factor:
x &lt;- ordered(c("low", "low", "med", "high"), levels = c("low", "med", "high"))
missings &lt;- c("low", "high")
assignMissing(x, missings)

## 4. Real-valued variable
set.seed(234234)
x &lt;- rnorm(10)
x
missings &lt;- "&lt; 0"
assignMissing(x, missings)
missings &lt;- "&gt; -0.2"
assignMissing(x, missings)
## values above 0.1 and below 0.7 are missing
missings &lt;- "(0.1,0.7)"
assignMissing(x, missings)
## Note that in floating point numbers, it is probably
## futile to specify specific values for missings. Even if we
## type out values to 7 decimals, nothing gets excluded
assignMissing(x, "-0.4879708;0.1435791")
## Can mark a range, however
assignMissing(x, "(-0.487971,-0.487970);(0.14357, 0.14358)")
x
</code></pre>

<hr>
<h2 id='assignRecode'>A variable is transformed in an indicated way</h2><span id='topic+assignRecode'></span>

<h3>Description</h3>

<p>In the variable key framework, the user might request
transformations such as the logarithm, exponential, or square
root. This is done by including strings in the recodes column,
such as &quot;log(x + 1)&quot; or &quot;3 + 1.1 * x + 0.5 * x ^ 2&quot;. This
function implements the user's request by parsing the character
string and applying the indicated re-calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignRecode(x, recode = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assignRecode_+3A_x">x</code></td>
<td>
<p>A column to be recoded</p>
</td></tr>
<tr><td><code id="assignRecode_+3A_recode">recode</code></td>
<td>
<p>A character string using placeholder &quot;x&quot;. See
examples</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the variable key framework, this is applied to the raw data,
after missings are imposed.
</p>


<h3>Value</h3>

<p>A new column
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(234234)
x &lt;- rpois(100, lambda = 3)
x &lt;- x[order(x)]
str1 &lt;- "log(x + 1)"
xlog &lt;- assignRecode(x, recode = str1)
plot(xlog ~ x, type = "l")
mean(xlog, na.rm = TRUE)
str2 &lt;- "x^2"
xsq &lt;- assignRecode(x, recode = str2)
plot(xsq ~ x, type = "l")
str3 &lt;- "sqrt(x)"
xsrt &lt;- assignRecode(x, recode = str3)
</code></pre>

<hr>
<h2 id='checkCoercion'>Check if values can be safely coerced without introduction of
missing values</h2><span id='topic+checkCoercion'></span>

<h3>Description</h3>

<p>This might be named &quot;coercesSafely&quot; or such.  If values cannot be
coerced into class specified, then values must be incorrect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkCoercion(value, targetclass, na.strings = c("\\.", "", "\\s+", "N/A"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkCoercion_+3A_value">value</code></td>
<td>
<p>Character vector of values, such as value_new or
value_old for one variable in a key.</p>
</td></tr>
<tr><td><code id="checkCoercion_+3A_targetclass">targetclass</code></td>
<td>
<p>R class name</p>
</td></tr>
<tr><td><code id="checkCoercion_+3A_na.strings">na.strings</code></td>
<td>
<p>Values that should be interpreted as R NA.
These are ignored in the coercion check.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either TRUE, or a vector of values which are not
successfully coerced
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- c("TRUE", "FALSE", FALSE, TRUE, NA, ".", "N/A", " ", "")
checkCoercion(x1, "logical")
x1 &lt;- c(x1, "TRUE.FALSE", "Has a space")
## Should fail:
checkCoercion(x1, "logical")
x2 &lt;- c(4, 5, 6, 9.2, ".", " ")
## Should fail
checkCoercion(x2, "logical")
x3 &lt;- factor(c("bob", "emily", "bob", "jane", "N/A", " ", NA, "NA"))
checkCoercion(x3, "ordered")
checkCoercion(x3, "integer")
## Should fail:
checkCoercion(x3, "logical")

</code></pre>

<hr>
<h2 id='checkValue_old'>Compare observed values with the values listed
(presumably from a variable key).</h2><span id='topic+checkValue_old'></span>

<h3>Description</h3>

<p>This is purely diagnostic. It prints warnings in
either of 2 cases. 1)  observed data has values that
are not in the value_old, or 2) that value_old has
values that are not in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkValue_old(x, value_old, xname, diagnostic = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkValue_old_+3A_x">x</code></td>
<td>
<p>a variable, either character or factor</p>
</td></tr>
<tr><td><code id="checkValue_old_+3A_value_old">value_old</code></td>
<td>
<p>a vector of old values for which we are checking</p>
</td></tr>
<tr><td><code id="checkValue_old_+3A_xname">xname</code></td>
<td>
<p>character string to use for x's name when printing output</p>
</td></tr>
<tr><td><code id="checkValue_old_+3A_diagnostic">diagnostic</code></td>
<td>
<p>prints messages about variables if TRUE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>

<hr>
<h2 id='cleanDataFrame'>Check and Clean data.frame for usage with variable key functions</h2><span id='topic+cleanDataFrame'></span>

<h3>Description</h3>

<p>Checks that the data.frame is made up of simple individual
columns. Checks numeric columns to find out if they are acceptable
to treat as integers. If they are acceptable to treat as integers,
then convert those numeric to integer class variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanDataFrame(dframe, safeNumericToInteger = TRUE, trimws = "both")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cleanDataFrame_+3A_dframe">dframe</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="cleanDataFrame_+3A_safenumerictointeger">safeNumericToInteger</code></td>
<td>
<p>Default TRUE: Should we treat values
which appear to be integers as integers? If a column is
numeric, it might be safe to treat it as an integer.  In many
csv data sets, the values coded c(1, 2, 3) are really
integers, not floats c(1.0, 2.0, 3.0). See <code>safeInteger</code>.</p>
</td></tr>
<tr><td><code id="cleanDataFrame_+3A_trimws">trimws</code></td>
<td>
<p>Defaults as &quot;both&quot;, in meaning of <code>which</code>
argument in <code>trimws</code> function.  Set as NULL if character
variables must not be trimmed to eliminate white
space. Otherwise, value should be one of <code>c("left",
"right", "both")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A checked and cleaned data frame
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>

<hr>
<h2 id='colnamesReplace'>Replace column names with new names from a named vector</h2><span id='topic+colnamesReplace'></span>

<h3>Description</h3>

<p>A convenience function to alter column names. Can be called from
code cleanup in the variable key system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colnamesReplace(
  dat,
  newnames,
  oldnames = NULL,
  ...,
  lowercase = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colnamesReplace_+3A_dat">dat</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="colnamesReplace_+3A_newnames">newnames</code></td>
<td>
<p>Can be a named vector of the form c(oldname1 =
&quot;newname1&quot;, oldname2 = &quot;newname&quot;) or it may be simply
c(&quot;newname1&quot;, &quot;newname2&quot;) to correspond with the oldname
vector.</p>
</td></tr>
<tr><td><code id="colnamesReplace_+3A_oldnames">oldnames</code></td>
<td>
<p>Optional. If supplied, must be same length as
newnames.</p>
</td></tr>
<tr><td><code id="colnamesReplace_+3A_...">...</code></td>
<td>
<p>Additional arguments that will be passed to R's
<code>gsub</code> function, which is used term-by-term inside this
function.</p>
</td></tr>
<tr><td><code id="colnamesReplace_+3A_lowercase">lowercase</code></td>
<td>
<p>Default FALSE. Should all column names be
converted to lower case.</p>
</td></tr>
<tr><td><code id="colnamesReplace_+3A_verbose">verbose</code></td>
<td>
<p>Default FALSE. Want diagnostic output about column
name changes?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(234234)
N &lt;- 200
mydf &lt;- data.frame(x5 = rnorm(N), x4 = rnorm(N), x3 = rnorm(N),
                   x2 = letters[sample(1:24, 200, replace = TRUE)],
                   x1 = factor(sample(c("cindy", "bobby", "marsha",
                                        "greg", "chris"), 200, replace = TRUE)),
                   x11 = 7,
                   x12 = 18,
                   x13 = 33,
                   stringsAsFactors = FALSE)
mydf2 &lt;- colnamesReplace(mydf, newnames = c("x4" = "GLOPPY"))
mydf2 &lt;- colnamesReplace(mydf, newnames = c("x4" = "GLOPPY", "USA" = "Interesting"), verbose = TRUE)
colnames(mydf2)
head(mydf3 &lt;- colnamesReplace(mydf, newnames = c(x11 = "x12", x12 = "x13", x13 = "x20")))
head(mydf4 &lt;- colnamesReplace(mydf, newnames = c(x12 = "x11", x11 = "x99", x13 = "x20")))
</code></pre>

<hr>
<h2 id='deduper'>Removes redundant words from beginnings of character strings</h2><span id='topic+deduper'></span>

<h3>Description</h3>

<p>In Qualtrix data, we sometimes find repeated words in column
names. For whatever reason, the variable names have repeated words
like &quot;Philadelphia_Philadelphia_3&quot;.  This function changes a
vector c(&quot;Philadelphia_Philadelphia_3&quot;, &quot;Denver_Denver_4&quot;) to
c(&quot;Philadelphia_3&quot;, &quot;Denver_4&quot;). It is non destructive, so that
other values will not be altered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deduper(x, sep = ",_\\s-", n = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deduper_+3A_x">x</code></td>
<td>
<p>Character vector</p>
</td></tr>
<tr><td><code id="deduper_+3A_sep">sep</code></td>
<td>
<p>Delimiter. A regular expression indicating the point at
which to split the strings before checking for
duplicates. Default will look for repeat separated by comma,
underscore, or one space character.</p>
</td></tr>
<tr><td><code id="deduper_+3A_n">n</code></td>
<td>
<p>Limit on number of duplicates to remove. Default, NULL,
means delete all duplicates at the beginning of a string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://stackoverflow.com/questions/43711240/r-regular-expression-match-omit-several-repeats">https://stackoverflow.com/questions/43711240/r-regular-expression-match-omit-several-repeats</a>
</p>


<h3>Value</h3>

<p>Cleaned up vector.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("Philadelphia_Philadelphia_3", "Denver_Denver_4",
        "Den_Den_Den_Den_Den_Den_Den_5")
deduper(x)
deduper(x, n = 2)
deduper(x, n = 3)
deduper(x, n = 4)
x &lt;- c("Philadelphia,Philadelphia_3", "Denver Denver_4")
## Shows comma also detected by default
deduper(x)
## Works even if delimiter is inside matched string,
## or separators vary
 x &lt;- c("Den_5_Den_5_Den_5,Den_5 Den_5")
deduper(x)
## generate vector
x &lt;- replicate(10, paste(sample(letters, 5), collapse = ""))
n &lt;- c(paste0("_", sample(1:10, 5)), rep("", 5))
x &lt;- paste0(x, "_", x, n, n)
x
deduper(x)

</code></pre>

<hr>
<h2 id='deleteBogusColumns'>Remove columns in which the proportion of missing data exceeds
a threshold.</h2><span id='topic+deleteBogusColumns'></span>

<h3>Description</h3>

<p>This is a column version of <code>deleteBogusRows</code>. Use the pm
argument to set the proportion of missing required before a column
is flagged for deletion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteBogusColumns(dframe, pm = 0.9, drop = FALSE, verbose = TRUE, n = 25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deleteBogusColumns_+3A_dframe">dframe</code></td>
<td>
<p>A data frame or matrix</p>
</td></tr>
<tr><td><code id="deleteBogusColumns_+3A_pm">pm</code></td>
<td>
<p>&quot;proportion missing data&quot; to be tolerated.</p>
</td></tr>
<tr><td><code id="deleteBogusColumns_+3A_drop">drop</code></td>
<td>
<p>Default FALSE: if data frame result is reduced to one
column, should R's default drop behavior &quot;demote&quot; this to a
column vector.</p>
</td></tr>
<tr><td><code id="deleteBogusColumns_+3A_verbose">verbose</code></td>
<td>
<p>Default TRUE. Should a report be printed
summarizing information to be delted?</p>
</td></tr>
<tr><td><code id="deleteBogusColumns_+3A_n">n</code></td>
<td>
<p>Default 25: limit on number of values to print in
diagnostic output. If set to NULL or NA, then all of the
column values will be printed for the bogus rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame, invisibly
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>See Also</h3>

<p><code>deleteBogusRows</code>
</p>

<hr>
<h2 id='deleteBogusRows'>Remove rows in which the proportion of missing data exceeds
a threshold.</h2><span id='topic+deleteBogusRows'></span>

<h3>Description</h3>

<p>If cases are mostly missing, delete them. It often happens that
when data is imported from other sources, some noise rows exist at
the bottom of the input.  Anything that is missing in more than,
say, 90% of cases is probably useless information.  We invented
this to deal with problem that MS Excel users often include a
marginal note at the bottom of a spread sheet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deleteBogusRows(dframe, pm = 0.9, drop = FALSE, verbose = TRUE, n = 25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deleteBogusRows_+3A_dframe">dframe</code></td>
<td>
<p>A data frame or matrix</p>
</td></tr>
<tr><td><code id="deleteBogusRows_+3A_pm">pm</code></td>
<td>
<p>&quot;proportion missing data&quot; to be tolerated.</p>
</td></tr>
<tr><td><code id="deleteBogusRows_+3A_drop">drop</code></td>
<td>
<p>Default FALSE: if data frame result is reduced to one
row, should R's default drop behavior &quot;demote&quot; this to a
column vector.</p>
</td></tr>
<tr><td><code id="deleteBogusRows_+3A_verbose">verbose</code></td>
<td>
<p>Default TRUE. Should a report be printed
summarizing information to be delted?</p>
</td></tr>
<tr><td><code id="deleteBogusRows_+3A_n">n</code></td>
<td>
<p>Default 25: limit on number of values to print in verbose
diagnostic output. If set to NULL or NA, then all of the
column values will be printed for the bogus rows.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame, invisibly
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mymat &lt;- matrix(rnorm(10*100), nrow = 10, ncol = 100,
               dimnames = list(1:10, paste0("x", 1:100)))
mymat &lt;- rbind(mymat, c(32, rep(NA, 99)))
mymat2 &lt;- deleteBogusRows(mymat)
mydf &lt;- as.data.frame(mymat)
mydf$someFactor &lt;- factor(sample(c("A", "B"), size = NROW(mydf), replace = TRUE))
mydf2 &lt;- deleteBogusRows(mydf, n = "all")
</code></pre>

<hr>
<h2 id='dev.create'>Create a graphics device</h2><span id='topic+dev.create'></span>

<h3>Description</h3>

<p>This is a way to create a graphic device on screen that can
display R plots. It is performing the same purpose as R's dev.new,
but it overcomes the limitations of RStudio.  It is needed because
RStudio does not implement fully the functionality of
dev.new. This is suitable for Windows, Linux, and
Macintosh operating systems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dev.create(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dev.create_+3A_...">...</code></td>
<td>
<p>Currently, height and width parameters that would be
suitable with dev.new</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument in dev.new named noRStudioGD seems to be aimed at same
purpose. But it does not do what I want and documentation is too
sparse.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(interactive()) dev.create(height = 7, width = 3)
dev.off()

</code></pre>

<hr>
<h2 id='dir.create.unique'>Create a uniquely named directory. Appends number &amp; optionally date to directory
name.</h2><span id='topic+dir.create.unique'></span>

<h3>Description</h3>

<p>Checks if the requested directory exists. If so, will create new
directory name. My favorite method is to have the target directory
with a date-based subdirectory, but set usedate as FALSE if you
don't like that. Arguments showWarnings, recursive, and mode are
passed along to R's dir.create, which does the actual work here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dir.create.unique(
  path,
  usedate = TRUE,
  showWarnings = TRUE,
  recursive = TRUE,
  mode = "0777"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dir.create.unique_+3A_path">path</code></td>
<td>
<p>A character string for the base name of the directory.</p>
</td></tr>
<tr><td><code id="dir.create.unique_+3A_usedate">usedate</code></td>
<td>
<p>TRUE or FALSE: Insert YYYYMMDD information?</p>
</td></tr>
<tr><td><code id="dir.create.unique_+3A_showwarnings">showWarnings</code></td>
<td>
<p>default TRUE. Show warnings? Will be passed on
to dir.create</p>
</td></tr>
<tr><td><code id="dir.create.unique_+3A_recursive">recursive</code></td>
<td>
<p>default TRUE. Will be passed on to dir.create</p>
</td></tr>
<tr><td><code id="dir.create.unique_+3A_mode">mode</code></td>
<td>
<p>Default permissions on unix-alike systems. Will be
passed on to dir.create</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Default response to dir = &quot;../output/&quot; fixes the directory name
like this, &quot;../output/20151118-1/&quot; because usedate is assumed
TRUE. If usedate = FALSE, then output names will be like
&quot;../output-1/&quot;, &quot;../output-2/&quot;, and so forth.
</p>


<h3>Value</h3>

<p>a character string with the directory name
</p>


<h3>Author(s)</h3>

<p>Paul E Johnson &lt;pauljohn@ku.edu&gt;
</p>

<hr>
<h2 id='dms'>Delete multiple slashes, replace with one</h2><span id='topic+dms'></span>

<h3>Description</h3>

<p>Sometimes paths end up with &quot;/too//many//slashes&quot;.
While harmless, this is untidy. Clean it up.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dms(name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dms_+3A_name">name</code></td>
<td>
<p>A character string to clean</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>

<hr>
<h2 id='dts'>Delete trailing slash</h2><span id='topic+dts'></span>

<h3>Description</h3>

<p>This function cleans up a path string by removing the trailing
slash.  This is necessary on MS Windows, <code>file.exists(fn)</code> fails
if &quot;/&quot; is on end of file name. Deleting the trailing slash is thus
required on Windows and it is not harmful on other platforms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dts(name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dts_+3A_name">name</code></td>
<td>
<p>A path</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All usages of <code>file.exists(fn)</code> in R should be revised
to be multi-platform safe by writing <code>file.exists(dts(fn))</code>.
</p>
<p>This version also removes repeated adjacent slashes, so that
<code>"/tmp///paul//test/"</code> becomes <code>"/tmp/paul/test"</code>.
</p>


<h3>Value</h3>

<p>Same path with trailing &quot;/&quot; removed.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>

<hr>
<h2 id='escape'>Text that is to be included as content in documents is cleaned
(escaped) to prevent errors</h2><span id='topic+escape'></span>

<h3>Description</h3>

<p>This is for fixing up &quot;untrusted text&quot; that is to be passed into a
file as content. It protects against &quot;bad&quot; text strings in 3
contexts, 1) LaTeX documents, 2) HTML documents, or 3) text in a
file name. It converts content text to an improved string that
will not cause failures in the eventual document.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>escape(x, type = "tex")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="escape_+3A_x">x</code></td>
<td>
<p>a string, or vector of strings (each of which is
processed separately)</p>
</td></tr>
<tr><td><code id="escape_+3A_type">type</code></td>
<td>
<p>&quot;tex&quot; is default, could be &quot;filename&quot; or &quot;html&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The special in-document LaTeX symbols like percent sign or dollar sign
are &quot;
session, these will appear as double-backslashed symbols, while in
a saved text file, there will only be the one desired slash.
</p>
<p>If type = &quot;html&quot;, we only clean up &lt;, &gt;, / and &amp;, and quote
characters.  If document is in unicode, we don't need to do the
gigantic set anymore.
</p>
<p>If type = &quot;filename&quot;, then symbols that are not allowed in file
names, such as &quot;\&quot;, &quot;*&quot;, are replaced. Do not use this on a
full path, since it will obliterate path separators.
</p>


<h3>Value</h3>

<p>corrected character vector
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- c("_asdf&amp;_&amp;$", "asd adf asd_", "^ % &amp; $asdf_")
escape(x1)
x2 &lt;- c("a&gt;b", "a&lt;b", "a &lt; c", 'Paul "pj" Johnson')
escape(x2, type = "tex")
escape(x2, type = "html")
escape(x2, type = "filename")
</code></pre>

<hr>
<h2 id='file.backup'>Create a backup version of a file by renaming it.</h2><span id='topic+file.backup'></span>

<h3>Description</h3>

<p>Inserts the date-time of the most recent modification at the
end of the file name, before the extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file.backup(name, fullpath = FALSE, keep.old = FALSE, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="file.backup_+3A_name">name</code></td>
<td>
<p>A character string for the name of the file.</p>
</td></tr>
<tr><td><code id="file.backup_+3A_fullpath">fullpath</code></td>
<td>
<p>Return the full directory path to the
file. Default FALSE, return only the file name.</p>
</td></tr>
<tr><td><code id="file.backup_+3A_keep.old">keep.old</code></td>
<td>
<p>If FALSE (default), rename the file. Otherwise, keep old copy.</p>
</td></tr>
<tr><td><code id="file.backup_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, output warnings and list the files in the output directory when done.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Return is the new file name that was created, using whatever
path information was provided in the file's original name. However,
the fullpath argument can be set to TRUE, so a path with the
full directory name will be created and returned.
</p>


<h3>Value</h3>

<p>The name of the newly created file.
</p>


<h3>Author(s)</h3>

<p>Shadi Pirhosseinloo &lt;shadi@ku.edu&gt; Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tdir &lt;- tempdir()
owd &lt;- getwd()

setwd(tdir)
system("touch test.1.txt")
system("touch test.2.txt")
system("touch test.3.txt")
system("touch test.4.txt")
system("touch test.5.txt")
## note: no extension next
system("touch test.6")
list.files()
file.backup("test.1.txt")
file.backup("test.2.txt", fullpath=TRUE)
list.files()
setwd(owd)
file.backup(file.path(tdir, "test.3.txt"))
## Next should be same path because input had a full path
file.backup(file.path(tdir, "test.4.txt"), fullpath=TRUE)
file.backup(file.path(tdir, "test.5.txt"), fullpath = TRUE, verbose = TRUE)
file.backup(file.path(tdir, "test.6"))
</code></pre>

<hr>
<h2 id='importQualtrics'>Import Qualtrics survey files, apply clean column names</h2><span id='topic+importQualtrics'></span>

<h3>Description</h3>

<p>Defaults are based on most common format received from Qualtrics
downloads to CSV or XLSX (MS Excel) formats.  We assume that the
file has the column names in row 1 and that 3 rows are skipped
before the real data begins. If the parameter questrow is used, it
designates a row that is interpreted as the survey questions
themselves.  Often, this is in row 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importQualtrics(
  file,
  namerow = 1,
  questionrow = 2,
  importidrow = 3,
  skip = 3,
  dropTEXT = TRUE,
  stringsAsFactors = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="importQualtrics_+3A_file">file</code></td>
<td>
<p>file name (including path if in another directory) of
a CSV or XLSX file from Qualtrics.</p>
</td></tr>
<tr><td><code id="importQualtrics_+3A_namerow">namerow</code></td>
<td>
<p>Row number for variable names.  Default 1, the
information to be used as column names (same as HEADER row in
R's read.table function)</p>
</td></tr>
<tr><td><code id="importQualtrics_+3A_questionrow">questionrow</code></td>
<td>
<p>Row number to be treated as the questions in the
survey. Default is 2. If questions do not seem to be present
in this row, there will be a warning.</p>
</td></tr>
<tr><td><code id="importQualtrics_+3A_importidrow">importidrow</code></td>
<td>
<p>Row number to be treated as Qualtrics meta
data. Default is 3. Many CSV created by Qualtrics will have
row 3 with a character string such as
<code>"{""ImportId"":""QID1303_4""}"</code>.  If importids are not
present in this row, there will be a warning.</p>
</td></tr>
<tr><td><code id="importQualtrics_+3A_skip">skip</code></td>
<td>
<p>Number of rows that are meta data. Current Qualtrics
CSV files will usually have 3 metadata rows, 1 = name, 2 =
question, 3 = ImportId. This function will try to guess how
many rows of metadata are present. skip should be at least
as large as <code>max(namerow, questions, and importids)</code></p>
</td></tr>
<tr><td><code id="importQualtrics_+3A_droptext">dropTEXT</code></td>
<td>
<p>Default TRUE, columns ending in &quot;_TEXT&quot; are
omitted.</p>
</td></tr>
<tr><td><code id="importQualtrics_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>Default FALSE, same meaning as R's
read.csv. Does not affect importation of Excel files.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame that has attribute &quot;meta&quot;
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>

<hr>
<h2 id='initProject'>Create project directories, initialize a git repo, create README.md
ChangeLog, and R template file in R directory</h2><span id='topic+initProject'></span>

<h3>Description</h3>

<p>This creates folders for the separate parts of a project. It tries
to be clever about which directories are created and where they are
placed. Please see details for 3 scenarios for which we have
planned. If a directory already exists, it will not be damaged or
re-created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>initProject(
  dir = NULL,
  ddir = "data",
  wdir = "workingdata",
  odir = "output",
  tdir = "tmp",
  ldir = "lit",
  writedir = "writeup",
  rdir = "R",
  ...,
  gitArgs = "--shared=group"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="initProject_+3A_dir">dir</code></td>
<td>
<p>Default NULL, otherwise a legal directory name to serve
as the top level directory for this project</p>
</td></tr>
<tr><td><code id="initProject_+3A_ddir">ddir</code></td>
<td>
<p>Data directory, place where &quot;read only&quot; unadjusted
data files are kept. Default is &quot;data&quot;. If user sets it as NA
or NULL, the directory will not be created.</p>
</td></tr>
<tr><td><code id="initProject_+3A_wdir">wdir</code></td>
<td>
<p>Working data directory, where recorded, revised, and
cleaned data files are kept. Default is &quot;workingdata&quot;.</p>
</td></tr>
<tr><td><code id="initProject_+3A_odir">odir</code></td>
<td>
<p>Output directory. Default is &quot;output&quot;.</p>
</td></tr>
<tr><td><code id="initProject_+3A_tdir">tdir</code></td>
<td>
<p>Temporary directory, where trash files can be kept for
safe keeping. Default is &quot;tmp&quot;.</p>
</td></tr>
<tr><td><code id="initProject_+3A_ldir">ldir</code></td>
<td>
<p>Literature directory, where material about the project
can be stored. Default is &quot;lit&quot;.</p>
</td></tr>
<tr><td><code id="initProject_+3A_writedir">writedir</code></td>
<td>
<p>The folder where the project writeup will be
stored. Default is &quot;writeup&quot;.</p>
</td></tr>
<tr><td><code id="initProject_+3A_rdir">rdir</code></td>
<td>
<p>The name to be used for the R files. Defaults to &quot;R&quot;.</p>
</td></tr>
<tr><td><code id="initProject_+3A_...">...</code></td>
<td>
<p>A list of other directories that the user would like to
create. For example, <code>adir = "admin"</code>, <code>cdir =
"client_provided"</code>, <code>bdir = "codebooks"</code>, <code>sdir =
"Stata"</code>, <code>mdir = "Mplus"</code>. These may be grouped in a
named vector or list, if user convenience dictates.</p>
</td></tr>
<tr><td><code id="initProject_+3A_gitargs">gitArgs</code></td>
<td>
<p>This function tries to run &quot;git init&quot; and in our
center we add &quot;&ndash;shared=group&quot; on a network file server. If
that is undesirable in a user's context, put the argument
gitArgs as &quot;&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the dir argument is NULL, as default, then the current working
directory will be the place where new directories and the git
repository will be created.  Assuming the current working
directory's base name is not &quot;R&quot;, then folders named &quot;R&quot;, &quot;data&quot;,
and so forth will be created in the current working directory.
</p>
<p>If one has a current R working directory with a basename &quot;R&quot;
(suppose it is <code>"/tmp/whatever/R"</code>), and the user runs
<code>initProject()</code>, something different happens. The function
assumes we don't want to create subdirectories inside R. We don't
want to end up with <code>"/tmp/whatever/R/R"</code>. We don't
want <code>"/tmp/whatever/R/data"</code> either.  Instead, it assumes we
want the new directories created on same level as R, so it creates
<code>"/tmp/whatever/data"</code>, <code>"/tmp/whatever/workingdata"</code>,
and so forth.  From within the R directory, these new directories
are seen as <code>"../data"</code>, <code>"../workingdata"</code>, and so
forth. That is, we should end up with directories and a git repo
in <code>"/tmp/whatever"</code>.
</p>
<p>If the <code>dir</code> argument is provided by the user, then that is
used as the folder in which directories <code>"R"</code>, <code>"data"</code>,
<code>"workingdate"</code>, and so forth are created.  All materials are
created in <code>dir</code>, no matter what the current working
directory is named (even if it is <code>"R"</code>).
</p>
<p>The examples demonstrate all three of these scenarios.
</p>


<h3>Value</h3>

<p>Name of project top level directory. Leaves the R
working directory unchanged.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>projdir1 &lt;- file.path(tempdir(), "test1")
dir.create(projdir1, recursive = TRUE)
initProject(dir = projdir1)
list.files(projdir1, all.files = TRUE)
projdir2 &lt;- file.path(tempdir(), "test2")
dir.create(projdir2, recursive = TRUE)
## demonstrate ability to create other directories
initProject(dir = projdir2, admin = "admin", clientfiles = "client")
list.files(projdir2, all.files = TRUE)
## demonstrate ability to nullify standard directories
projdir3 &lt;- file.path(tempdir(), "test3")
dir.create(projdir3, recursive = TRUE)
initProject(projdir3, odir = NA, tdir = NA, writedir = NA)
list.files(projdir3, all.files = TRUE)
unlink(c("projdir1", "projdir2", "projdir3"), recursive = TRUE)
</code></pre>

<hr>
<h2 id='is.data.frame.simple'>Check if a data frame is a simple collection of columns (no lists
or matrices within)</h2><span id='topic+is.data.frame.simple'></span>

<h3>Description</h3>

<p>Checks for the existence of dimensions within the data
frame. Returns FALSE if any object within dframe has non-null dim
value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.data.frame.simple(dframe)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.data.frame.simple_+3A_dframe">dframe</code></td>
<td>
<p>A data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See: http://stackoverflow.com/questions/38902880/data-frame-in-which-elements-are-not-single-columns
</p>


<h3>Value</h3>

<p>Boolean, TRUE or FALSE. An attribute &quot;not_a_simple_column&quot;
is created, indicating which of the elements in the dframe
have dimensions
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
mydf &lt;- data.frame(x5 = rnorm(N),
                   x4 = rpois(N, lambda = 3),
                   x3 = ordered(sample(c("lo", "med", "hi"),
                   size = N, replace=TRUE)))
is.data.frame.simple(mydf)
mydf$amatr &lt;- matrix(0, ncol = 2, nrow = NROW(mydf))
is.data.frame.simple(mydf)
mydf$amatr &lt;- NULL
is.data.frame.simple(mydf)
mydf$adf &lt;- mydf
is.data.frame.simple(mydf)
</code></pre>

<hr>
<h2 id='isNA'>Check if values are R NA symbol or any one of the na.strings
elements</h2><span id='topic+isNA'></span>

<h3>Description</h3>

<p>A value vector in the key will generally be a character
vector.  This utility is used to check if the characters
are either R missing or values in a list of characters that
represent missings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isNA(x, na.strings = c("\\.", "", "\\s+", "N/A"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isNA_+3A_x">x</code></td>
<td>
<p>Input data vector</p>
</td></tr>
<tr><td><code id="isNA_+3A_na.strings">na.strings</code></td>
<td>
<p>Vector of string values to be considered as
missing. Defaults will match values that are equal to ., empty
string, any number of white space elements, or charcter
string N/A. We do not include 'NA' by default because some
projects use NA to mean &quot;not appropriate&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector, TRUE if a value is either NA or in
na.strings.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- c("TRUE", "FALSE", FALSE, TRUE, NA, "NA", ".", "N/A", " ", "")
x1na &lt;- kutils:::isNA(x1)
cbind(x1, x1na)
</code></pre>

<hr>
<h2 id='keyApply'>Apply variable key to data frame (generate recoded data frame)</h2><span id='topic+keyApply'></span>

<h3>Description</h3>

<p>This is the main objective of the variable key system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keyApply(
  dframe,
  key,
  diagnostic = TRUE,
  safeNumericToInteger = TRUE,
  trimws = "both",
  ignoreCase = TRUE,
  drop = TRUE,
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keyApply_+3A_dframe">dframe</code></td>
<td>
<p>An R data frame</p>
</td></tr>
<tr><td><code id="keyApply_+3A_key">key</code></td>
<td>
<p>A variable key object, of class either &quot;key&quot; or
&quot;keylong&quot;</p>
</td></tr>
<tr><td><code id="keyApply_+3A_diagnostic">diagnostic</code></td>
<td>
<p>Default TRUE: Compare the old and new data
frames carefully with the keyDiagnostic function.</p>
</td></tr>
<tr><td><code id="keyApply_+3A_safenumerictointeger">safeNumericToInteger</code></td>
<td>
<p>Default TRUE: Should we treat values
which appear to be integers as integers? If a column is
numeric, it might be safe to treat it as an integer.  In many
csv data sets, the values coded c(1, 2, 3) are really
integers, not floats c(1.0, 2.0, 3.0). See <code>safeInteger</code>.</p>
</td></tr>
<tr><td><code id="keyApply_+3A_trimws">trimws</code></td>
<td>
<p>Default is &quot;both&quot;, can change to &quot;left&quot;, &quot;right&quot;, or
set as NULL to avoid any trimming.</p>
</td></tr>
<tr><td><code id="keyApply_+3A_ignorecase">ignoreCase</code></td>
<td>
<p>Default TRUE. If column name is capitalized
differently than name_old in the key, but the two are
otherwise identical, then the difference in capitalization
will be ignored.</p>
</td></tr>
<tr><td><code id="keyApply_+3A_drop">drop</code></td>
<td>
<p>Default TRUE. True implies drop = c(&quot;vars&quot;,
&quot;vals&quot;). TRUE applies to both variables (&quot;vars&quot;) and values
(&quot;vals&quot;). &quot;vars&quot; means that a column will be omitted from data
if it is not in the key &quot;name_old&quot;. Similarly, if anything
except &quot;.&quot; appears in value_old, then setting drop=&quot;vals&quot;
means omission of a value from key &quot;value_old&quot; causes
observations with those values to become NA.  This is the
original variable key behavior.  The drop argument allows
&quot;partial keys&quot;, beginning with kutils version 1.12. drop =
FALSE means that neither values nor variables are omitted.
Rather than TRUE, one can specify either drop = &quot;vars&quot;, or
drop = &quot;vals&quot;.</p>
</td></tr>
<tr><td><code id="keyApply_+3A_debug">debug</code></td>
<td>
<p>Default FALSE. If TRUE, emit some warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new data.frame object, with renamed and recoded variables
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydf.key.path &lt;- system.file("extdata", "mydf.key.csv", package = "kutils")
mydf.key &lt;-  keyImport(mydf.key.path)
mydf.path &lt;- system.file("extdata", "mydf.csv", package = "kutils")

mydf &lt;- read.csv(mydf.path, stringsAsFactors = FALSE)
mydf2 &lt;- keyApply(mydf, mydf.key)

nls.keylong.path &lt;- system.file("extdata", "natlongsurv.key_long.csv", package = "kutils")
nls.keylong &lt;- keyImport(nls.keylong.path, long = TRUE)
data(natlongsurv)
nls.dat &lt;- keyApply(natlongsurv, nls.keylong)

</code></pre>

<hr>
<h2 id='keyCheck'>Check a key for consistency of names, values with classes.</h2><span id='topic+keyCheck'></span>

<h3>Description</h3>

<p>Split the key into blocks of rows defined by &quot;name_new&quot;. Within
these blocks, Perform these checks: 1. name_old must be
homogeneous (identical) within a block of rows. class_old and
class_new must also be identical.
2. elements in &quot;value_new&quot; must be consistent with &quot;class_new&quot;.
If values cannot be coerced to match the class specified by
class_new, there must be user error.
Same for &quot;value_old&quot; and &quot;class_old&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keyCheck(
  key,
  colname = c("name_new", "class_old", "class_new"),
  na.strings = c("\\.", "", "\\s+", "N/A")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keyCheck_+3A_key">key</code></td>
<td>
<p>A variable key object.</p>
</td></tr>
<tr><td><code id="keyCheck_+3A_colname">colname</code></td>
<td>
<p>Leave as default to check consistency between classes, values, and names.
One can specify a check only on &quot;class_old&quot; or &quot;class_new&quot;, for example.  But now that
all work correctly, I suggest you leave the default.</p>
</td></tr>
<tr><td><code id="keyCheck_+3A_na.strings">na.strings</code></td>
<td>
<p>A regular expression of allowed text strings that represent missings.
Now it amounts to any of these: &quot;.&quot;, &quot;NA&quot;, &quot;N/A&quot;, or any white space or tab as signified by \s+.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Profuse warnings and a list of failed key blocks.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt; and Ben Kite &lt;bakite@ku.edu&gt;
</p>

<hr>
<h2 id='keyCrossRef'>keyCrossRef</h2><span id='topic+keyCrossRef'></span>

<h3>Description</h3>

<p>Checks a key for dangerous matches of old and new values in a key
for different levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keyCrossRef(key, ignoreClass = NULL, verbose = FALSE, lowercase = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keyCrossRef_+3A_key">key</code></td>
<td>
<p>A variable key, ideally a long key. If a wide key is
provided it is converted to long.</p>
</td></tr>
<tr><td><code id="keyCrossRef_+3A_ignoreclass">ignoreClass</code></td>
<td>
<p>Classes that should be excluded from
check. Useful when many integer variables are being reverse-
coded. Takes a string or vector.</p>
</td></tr>
<tr><td><code id="keyCrossRef_+3A_verbose">verbose</code></td>
<td>
<p>Should a statement about the number of issues
detected be returned? Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="keyCrossRef_+3A_lowercase">lowercase</code></td>
<td>
<p>Should old and new values be passed through
tolower function? Defaults to FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Positions in a long key are referred to as levels. If a value is
mismatched at levels 1 and 3, this means that issues are in rows 1
and 3 of the section of the given variable in a long key.
</p>


<h3>Value</h3>

<p>Presents a warning for potentially problematic key
sections. Return is dependent on verbose argument.
</p>


<h3>Author(s)</h3>

<p>Ben Kite &lt;bakite@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame(x1 = sample(c("a", "b", "c", "d"), 100, replace = TRUE),
                  x2 = sample(c("Apple", "Orange"), 100, replace = TRUE),
                  x3 = ordered(sample(c("low", "medium", "high"), 100, replace = TRUE),
                  levels = c("low", "medium", "high")),
                  stringsAsFactors = FALSE)
key &lt;- keyTemplate(dat, long = TRUE)
## No errors with a fresh key.
kutils:::keyCrossRef(key, verbose = TRUE)
key[1:2, "value_new"] &lt;- c("b", "a")
key[5, "value_new"]
key[7:9, "value_new"] &lt;- c("high", "medium", "low")
kutils:::keyCrossRef(key)
kutils:::keyCrossRef(key, ignoreClass = c("ordered", "character"), verbose = TRUE)
</code></pre>

<hr>
<h2 id='keyDiagnostic'>Diagnose accuracy of result from applying variable key to data</h2><span id='topic+keyDiagnostic'></span>

<h3>Description</h3>

<p>Compare the old and new data frames, checking for accuracy of
calculations in various ways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keyDiagnostic(
  dfold,
  dfnew,
  keylist,
  max.values = 20,
  nametrunc = 18,
  wide = 200,
  confidential = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keyDiagnostic_+3A_dfold">dfold</code></td>
<td>
<p>Original data frame</p>
</td></tr>
<tr><td><code id="keyDiagnostic_+3A_dfnew">dfnew</code></td>
<td>
<p>The new recoded data frame</p>
</td></tr>
<tr><td><code id="keyDiagnostic_+3A_keylist">keylist</code></td>
<td>
<p>The imported variable key that was used to
transform dfold into dfnew.</p>
</td></tr>
<tr><td><code id="keyDiagnostic_+3A_max.values">max.values</code></td>
<td>
<p>Show up to this number of values for the old
variable</p>
</td></tr>
<tr><td><code id="keyDiagnostic_+3A_nametrunc">nametrunc</code></td>
<td>
<p>Truncate column and row names. Needed if there
are long factor labels and we want to fit more information on
table. Default = 18 for new name, old name is 10 more
characters (18 + 10 = 28).</p>
</td></tr>
<tr><td><code id="keyDiagnostic_+3A_wide">wide</code></td>
<td>
<p>Number of characters per row in printed
output. Suggest very wide screen, default = 200.</p>
</td></tr>
<tr><td><code id="keyDiagnostic_+3A_confidential">confidential</code></td>
<td>
<p>Should numbers in table be rounded to nearest
&quot;10&quot; to comply with security standard enforced by some
American research departments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CAUTION: This can print WIDE matrices.  Because the on-screen
output will be WIDE, make the display window WIDE!
</p>
<p>Crosstabulate new variable versus old variable to see the coding
mismatches.  For tables of up to 10 values or so, that will be
satisfactory.
</p>
<p>For numeric variables, it appears there is no good thing to do
except possibly to re-apply any transformations.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>

<hr>
<h2 id='keyDiff'>Show difference between 2 keys</h2><span id='topic+keyDiff'></span>

<h3>Description</h3>

<p>Show difference between 2 keys
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keyDiff(oldkey, newkey)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keyDiff_+3A_oldkey">oldkey</code></td>
<td>
<p>key, original</p>
</td></tr>
<tr><td><code id="keyDiff_+3A_newkey">newkey</code></td>
<td>
<p>key, possibly created by keyUpdate or by user edits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL, or list with as many as 2 key difference data.frames,
named &quot;deleted&quot; and &quot;neworaltered&quot;
</p>


<h3>Author(s)</h3>

<p>Ben Kite &lt;bakite@ku.edu&gt; and Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dat1 &lt;- data.frame("Score" = c(1, 2, 3, 42, 4, 2),
                   "Gender" = c("M", "M", "M", "F", "F", "F"))
## First try with a long key
key1 &lt;- keyTemplate(dat1, long = TRUE)
key1$value_new &lt;- gsub("42", "10", key1$value_new)
key1$value_new[key1$name_new == "Gender"] &lt;-
       mgsub(c("F", "M"), c("female", "male"),
       key1$value_new[key1$name_new == "Gender"])  
key1[key1$name_old == "Score", "name_new"] &lt;- "NewScore"
dat2 &lt;- data.frame("Score" = 7, "Gender" = "other", "Weight" = rnorm(3))
dat2 &lt;- plyr::rbind.fill(dat1, dat2)
dat2 &lt;- dat2[-1,]
key2 &lt;- keyUpdate(key1, dat2, append = TRUE)
(kdiff &lt;- keyDiff(key1, key2))
</code></pre>

<hr>
<h2 id='keyImport'>Import/validate a key object or import/validate a key from a file.</h2><span id='topic+keyImport'></span>

<h3>Description</h3>

<p>After the researcher has updated the key by filling in new names
and values, we import that key file. This function can import the
file by its name, after deducing the file type from the suffix, or
it can receive a key object from memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keyImport(
  key,
  ignoreCase = TRUE,
  sep = c(character = "\\|", logical = "\\|", integer = "\\|", factor = "\\|",
    ordered = "[\\|&lt;]", numeric = "\\|"),
  na.strings = c("\\.", "", "\\s+", "N/A"),
  missSymbol = ".",
  ...,
  keynames = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keyImport_+3A_key">key</code></td>
<td>
<p>A key object (class key or keylong) or a file name
character string (ending in csv, xlsx or rds).</p>
</td></tr>
<tr><td><code id="keyImport_+3A_ignorecase">ignoreCase</code></td>
<td>
<p>In the use of this key, should we ignore
differences in capitalization of the &quot;name_old&quot; variable?
Sometimes there are inadvertent misspellings due to changes in
capitalization. Columns named &quot;var01&quot; and &quot;Var01&quot; and &quot;VAR01&quot;
probably should receive the same treatment, even if the key
has name_old equal to &quot;Var01&quot;.</p>
</td></tr>
<tr><td><code id="keyImport_+3A_sep">sep</code></td>
<td>
<p>Character separator in <code>value_old</code> and
<code>value_new</code> strings in a wide key. Default is are &quot;|&quot;.
It is also allowed to use &quot;&lt;&quot; for ordered variables. Use
regular expressions in supplying separator values.</p>
</td></tr>
<tr><td><code id="keyImport_+3A_na.strings">na.strings</code></td>
<td>
<p>Values that should be converted to missing data.
This is relevant in <code>name_new</code> as well as
<code>value_new</code>. In spreadsheet cells, we treat &quot;empty&quot; cells
(the string &quot;&quot;), or values like &quot;.&quot; or &quot;N/A&quot;, as missing with
defaults &quot;.&quot;, &quot;&quot;, &quot;\s&quot; (white space), and &quot;N/A&quot;. Change that
if those are not to be treated as missings.</p>
</td></tr>
<tr><td><code id="keyImport_+3A_misssymbol">missSymbol</code></td>
<td>
<p>Defaults to period &quot;.&quot; as missing value
indicator.</p>
</td></tr>
<tr><td><code id="keyImport_+3A_...">...</code></td>
<td>
<p>additional arguments for read.csv or read.xlsx.</p>
</td></tr>
<tr><td><code id="keyImport_+3A_keynames">keynames</code></td>
<td>
<p>Don't use this unless you are very careful. In our
current scheme, the column names in a key should be
c(&quot;name_old&quot;, &quot;name_new&quot;, &quot;class_old&quot;, &quot;class_new&quot;,
&quot;value_old&quot;, &quot;value_new&quot;, &quot;missings&quot;, &quot;recodes&quot;). If your key
does not use those column names, it is necessary to provide
keynames in a format &quot;our_name&quot;=&quot;your_name&quot;. For example,
keynames = c(name_old = &quot;oldvar&quot;, name_new = &quot;newname&quot;,
class_old = &quot;vartype&quot;, class_new = &quot;class&quot;, value_old =
&quot;score&quot;, value_new = &quot;val&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This can be either a wide or long format key file.
</p>
<p>This cleans up variables in following ways.  1) <code>name_old</code>
and <code>name_new</code> have leading and trailing spaces removed 2)
<code>value_old</code> and <code>value_new</code> have leading and trailing
spaces removed, and if they are empty or blank spaces, then new
values are set as NA.
</p>
<p>Policy change concerning empty &quot;value_new&quot; cells in input keys
(20170929).
</p>
<p>There is confusion about what ought to happen in a wide key when
the user leaves value_new as empty or missing. Literally, this
means all values are converted to missing, which does not seem
reasonable. Hence, when a key is wide, and value_new is one of the
na.strings elements, we assume the value_new is to be copied
from value_old. That is to say, if value_new is not supplied,
the values remain same as in old data.
</p>
<p>In a long key, the behavior is different.  Since the user can
specify each value for a variable in a separate row, the na.strings
appearing in value_new are treated as missing scores in the new
data set to be created.
</p>


<h3>Value</h3>

<p>key object, should be same &quot;wide&quot; or &quot;long&quot; as the input
Missing symbols in value_old and value_new converted to &quot;.&quot;.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydf.key.path &lt;- system.file("extdata", "mydf.key.csv", package = "kutils")
mydf.key &lt;-  keyImport(mydf.key.path)
## Create some dupes
mydf.key &lt;- rbind(mydf.key, mydf.key[c(1,7), ])
mydf.key2 &lt;- keyImport(mydf.key)
mydf.key2
## create some empty value_new cells
mydf.key[c(3, 5, 7) , "value_new"] &lt;- ""
mydf.key3 &lt;- keyImport(mydf.key)
mydf.key3
mydf.keylong.path &lt;- system.file("extdata", "mydf.key_long.csv", package = "kutils")
mydf.keylong &lt;- keyImport(mydf.keylong.path)

## testDF is a slightly more elaborate version created for unit testing:
testdf.path &lt;- system.file("extdata", "testDF.csv", package = "kutils")
testdf &lt;- read.csv(testdf.path, header = TRUE)
keytemp &lt;- keyTemplate(testdf, long = TRUE)
## A "hand edited key file"
keyPath &lt;- system.file("extdata", "testDF-key.csv", package="kutils")
key &lt;- keyImport(keyPath)
keydiff &lt;- keyDiff(keytemp, key)
key2 &lt;- rbind(key, keydiff$neworaltered)
key2 &lt;- unique(key)
if(interactive())View(key2)

</code></pre>

<hr>
<h2 id='keyLookup'>Look for old (or new) names in variable key</h2><span id='topic+keyLookup'></span>

<h3>Description</h3>

<p>Use the key to find the original name of a variable that has been
renamed, or find the new name of an original variable.  The
<code>get</code> argument indicates if the <code>name_old</code> or
<code>name_new</code> is desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keyLookup(x, key, get = "name_old")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keyLookup_+3A_x">x</code></td>
<td>
<p>A variable name. If <code>get = "name_old"</code>, then
<code>x</code> is a value for <code>name_new</code>. If <code>get =
"name_new"</code>, <code>x</code> should be a value for <code>name_old</code>.</p>
</td></tr>
<tr><td><code id="keyLookup_+3A_key">key</code></td>
<td>
<p>Which key should be used</p>
</td></tr>
<tr><td><code id="keyLookup_+3A_get">get</code></td>
<td>
<p>Either &quot;name_old&quot; (to retrieve the original name) or
&quot;name_new&quot; (to get the new name)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>get = "name_old"</code>, the return is a character vector, with
one element per value of <code>x</code>.  If there is no match for a
value of <code>x</code>, the value NA is returned for that
value. However, if <code>get = "name_new"</code>, the return might be
either a vector (one element per value of <code>x</code>) or a list with
one element for each value of <code>x</code>.  The list is returned when
a value of <code>x</code> corresponds to more than one element in
<code>name_old</code>.
</p>


<h3>Value</h3>

<p>A vector or list of matches between x and either name_new
or name_old elements in the key.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydf.key.path &lt;- system.file("extdata", "mydf.key.csv", package = "kutils")
mydf.key &lt;-  keyImport(mydf.key.path)
mydf.key$name_new &lt;- paste0("new_", mydf.key$name_new)
keyLookup("new_x5", mydf.key, get = "name_old")
keyLookup(c("new_x6", "new_x1"), mydf.key, get = "name_old")
keyLookup(c("x6", "x1"), mydf.key, get = "name_new")
keyLookup(c("asdf", "new_x1"), mydf.key, get = "name_old")

mydf.key &lt;- rbind(mydf.key,
                 c("x3", "x3f",  "ordered", "factor", "","","",""))
keyLookup(c("x3"), mydf.key, get = "name_new")
keyLookup(c("x1", "x3", "x5"), mydf.key, get = "name_new")
</code></pre>

<hr>
<h2 id='keyRead'>Read file after deducing file type from suffix.</h2><span id='topic+keyRead'></span>

<h3>Description</h3>

<p>If the input is XLSX, sheets named &quot;key&quot; and &quot;varlab&quot; are
imported if the exist. If input is CSV, then the key
CSV file is imported and another file suffixed with &quot;-varlab&quot; is
imported if it exists.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keyRead(file, ..., na.strings = c("\\s+"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keyRead_+3A_file">file</code></td>
<td>
<p>name of file to be imported, including path to
file. file name must end in &quot;csv&quot;, &quot;xlsx&quot; or &quot;rds&quot;</p>
</td></tr>
<tr><td><code id="keyRead_+3A_...">...</code></td>
<td>
<p>additional arguments for read.csv or read.xlsx.</p>
</td></tr>
<tr><td><code id="keyRead_+3A_na.strings">na.strings</code></td>
<td>
<p>Values to be converted to R missing symbol
NA. Default is white space, &quot;\s+&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variable lables are a named vector saved as an attribute of
the key object.
</p>


<h3>Value</h3>

<p>A data frame or matrix.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>

<hr>
<h2 id='keySave'>Save key as file after deducing type from suffix</h2><span id='topic+keySave'></span>

<h3>Description</h3>

<p>This is specialized to saving of key objects, it is not a
general purpose function for saving things.  It scans the
suffix of the file name and then does the right thing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keySave(obj, file, na_ = ".", varlab)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keySave_+3A_obj">obj</code></td>
<td>
<p>a variable key object</p>
</td></tr>
<tr><td><code id="keySave_+3A_file">file</code></td>
<td>
<p>file name. must end in &quot;csv&quot;, &quot;xlsx&quot; or &quot;rds&quot;</p>
</td></tr>
<tr><td><code id="keySave_+3A_na_">na_</code></td>
<td>
<p>Value to insert to represent a missing score. Default
&quot;.&quot;.</p>
</td></tr>
<tr><td><code id="keySave_+3A_varlab">varlab</code></td>
<td>
<p>FALSE or TRUE. Default is FALSE, no new labels will
be created. If a key object has a varlab already, it is saved
with the key, always. This parameter controls whether a new
varlab template should be created when the object is saved.
If TRUE and obj has no varlab attribute, a new varlab template
is created by the <code>varlabTemplate</code> function. If TRUE and
a varlab attribute currently exists, but some variables are
missing labels, then <code>varlabTemplate</code> is called to fill
in new variable labels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In updates 2017-09, a varlab element was introduced.  The varlab
attribute of the object is saved.  The files created incorporate
the variable labels object in different ways. 1) XLSX: variable
labels a worksheet named &quot;varlab&quot; 2) CSV: variable labels saved in
a separate file suffixed &quot;-varlab.csv&quot;. 3) RDS: varlab is an
attribute of the key object.
</p>


<h3>Value</h3>

<p>NULL if no file is created. Otherwise, a key object with
an attribute varlab is returned.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>

<hr>
<h2 id='keysPool'>Homogenize class values and create a long key by pooling variable
keys.</h2><span id='topic+keysPool'></span>

<h3>Description</h3>

<p>For long-format keys, this is one way to correct for errors in
&quot;class_old&quot; or &quot;class_new&quot; for common variables. For a long key
created by stacking together several long keys, or for a list of
long keys, this will try to homogenize the classes by using a
&quot;highest common denominator&quot; approach.  If one key has x1 as a
floating point, but another block of rows in the key has x1 as
integer, then class must be changed to floating point
(numeric). If another section of a key has x1 as a character, then
character becomes the class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keysPool(
  keylong = NULL,
  keysplit = NULL,
  classes = list(c("logical", "integer"), c("integer", "numeric"), c("ordered",
    "factor"), c("factor", "character")),
  colnames = c("class_old", "class_new"),
  textre = "TEXT$"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keysPool_+3A_keylong">keylong</code></td>
<td>
<p>A list of long keys, or just one long key,
presumably a result of rbinding several long keys.</p>
</td></tr>
<tr><td><code id="keysPool_+3A_keysplit">keysplit</code></td>
<td>
<p>Not often needed for user-level code. A list of
key blocks, each of which is to be inspected and
homogenized. Not used if a keylong argument is provided.</p>
</td></tr>
<tr><td><code id="keysPool_+3A_classes">classes</code></td>
<td>
<p>A list of vectors specifying legal promotions.</p>
</td></tr>
<tr><td><code id="keysPool_+3A_colnames">colnames</code></td>
<td>
<p>Either c(&quot;class_old&quot;,&quot;class_new), &quot;&quot;class_old&quot;, or
&quot;class_new&quot;.  The former is the default.</p>
</td></tr>
<tr><td><code id="keysPool_+3A_textre">textre</code></td>
<td>
<p>A regular expression matching a column name to be
treated as character. Default matches any variable name ending
in &quot;TEXT&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users might run keyTemplate on several data sets, arriving
at keys that need to be combined.  The long versions of the
keys can be stacked together by a function like <code>rbind</code>.
If the values class_old and class_new for a single variable are
inconsistent, then the &quot;key stack&quot; will fail the tests in keyCheck.
This function automates the process of fixing the class variables by
&quot;promoting&quot; classes where possible.
</p>
<p>Begin with a simple example.  In one data set, the value of x is
drawn from integers 1L, 2L, 3L, while in another set it is
floating values like 1.1, 2.2. After creating long format keys,
and stacking them together, the values of class_old will clash.
For x, we will observe both &quot;integer&quot; and &quot;numeric&quot; in the
class_old column.  In that situation, the class_old for all of the
rows under consideration should be set as &quot;numeric&quot;.
</p>
<p>The promotion schemes are described by the variable classes, where
we have the most conservative changes first. The most destructive
change is when variables are converted from integer to character,
for example. The conservative conversion strategies are specified
in the classes variable, in which the last element in a vector
will be used to replace the preceeding classes.  For example,
c(&quot;ordered&quot;, &quot;factor&quot;, &quot;character&quot;) means that the class_old
values of &quot;ordered&quot; and &quot;factor&quot; will be replaced by &quot;character&quot;.
</p>
<p>The conversions specified by classes are tried, in order.
1. logical -&gt; integer
2. integer -&gt; numeric
3. ordered -&gt; factor
</p>
<p>If their application fails to homogenize a vector, then class is
changed to &quot;character&quot;. For example, when the value of class_old
observed is c(&quot;ordered&quot;, &quot;numeric&quot;, &quot;character&quot;). In that case,
the class is promoted to &quot;character&quot;, it is the least common
denominator.
</p>


<h3>Value</h3>

<p>A class-corrected version of the same format as the input,
either a long key or a list of key elements.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat1 &lt;- data.frame(x1 = as.integer(rnorm(100)), x2 = sample(c("Apple", "Orange"),
                   100, replace = TRUE), x3 = ifelse(rnorm(100) &lt; 0, TRUE, FALSE))
dat2 &lt;- data.frame(x1 = rnorm(100), x2 = ordered(sample(c("Apple", "Orange"),
                   100, replace = TRUE)), x3 = rbinom(100, 1, .5),
                   stringsAsFactors = FALSE)
key1 &lt;- keyTemplate(dat1, long = TRUE)
key2 &lt;- keyTemplate(dat2, long = TRUE)
keys2stack &lt;- rbind(key1, key2)
keys2stack.fix &lt;- keysPool(keys2stack)
keys2stack.fix2 &lt;- keysPool(keys2stack.fix, colname = "class_new")
## Sometimes this will not be able to homogenize
dat1 &lt;- data.frame(x1 = as.integer(rnorm(100)),
                   x2 = sample(c("Apple", "Orange"), 100, replace = TRUE))
dat2 &lt;- data.frame(x1 = rnorm(100),
                   x2 = sample(c("Apple", "Orange"), 100, replace = TRUE),
                   stringsAsFactors = FALSE)
key1 &lt;- keyTemplate(dat1, long = TRUE)
key2 &lt;- keyTemplate(dat2, long = TRUE)
## Create a stack of keys for yourself
keys2stack &lt;- rbind(key1, key2)
keys.fix &lt;- keysPool(keys2stack)
## We will create stack of keys for you
keys.fix2 &lt;- keysPool(list(key1, key2)) 
## View(keys.fix)
## View(keys.fix2)


## If you have wide keys, convert them with wide2long, either by
key1 &lt;- keyTemplate(dat1)
key2 &lt;- keyTemplate(dat2)
keysstack.wide &lt;- rbind(wide2long(key1), wide2long(key2))
keys.fix &lt;- keysPool(keysstack.wide)
## or
keysPool(list(wide2long(key1), wide2long(key2)))
</code></pre>

<hr>
<h2 id='keysPoolCheck'>Compares keys from different data sets; finds differences classes of variables.
This used to check for similarity of keys from various data sets,
one precursor to either combining the keys or merging the data
sets themselves.</h2><span id='topic+keysPoolCheck'></span>

<h3>Description</h3>

<p>When several supposedly &quot;equivalent&quot; data sets are used
to generate variable keys, there may be trouble. If variables
with same name have different classes, keyApply might fail
when applied to one of the data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keysPoolCheck(keys, col = "class_old", excludere = "TEXT$")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keysPoolCheck_+3A_keys">keys</code></td>
<td>
<p>A list with variable keys.</p>
</td></tr>
<tr><td><code id="keysPoolCheck_+3A_col">col</code></td>
<td>
<p>Name of key column to check for equivalence. Default is &quot;class_old&quot;, but
&quot;class_new&quot; can be checked as well.</p>
</td></tr>
<tr><td><code id="keysPoolCheck_+3A_excludere">excludere</code></td>
<td>
<p>Exclude variables matching a regular expression
(re). Default example shows exclusion of variables that end in
the symbol &quot;TEXT&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This reports on differences in classes among keys. By default, it
looks for differences in &quot;class_old&quot;, because that's where we
usually see trouble.
</p>
<p>The output here is diagnostic. The keys can be fixed manually, or the
function keysPool can implement an automatic correction.
</p>


<h3>Value</h3>

<p>Data.frame summarizing class differences among keys
</p>


<h3>Author(s)</h3>

<p>Paul Johnson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(234)
dat1 &lt;- data.frame(x1 = rnorm(100),
                   x2 = sample(c("Male", "Female"), 100, replace = TRUE),
                   x3_TEXT = "A", x4 = sample(1:10000, 100))
dat2 &lt;- data.frame(x1 = rnorm(100), x2 = sample(c("Male", "Female"),
                   100, replace = TRUE),
                   x3_TEXT = sample(1:100, 100),
                   stringsAsFactors = FALSE)
key1 &lt;- keyTemplate(dat1)
key2 &lt;- keyTemplate(dat2)
keys &lt;- list(key1, key2)
keysPoolCheck(keys)
## See problem in class_old
keysPoolCheck(keys, col = "class_old")
## problems in class_new
keysPoolCheck(keys, col = "class_new")
keysPoolCheck(keys, excludere = "TEXT$")
</code></pre>

<hr>
<h2 id='keyTemplate'>Create variable key template (in memory or in a file)</h2><span id='topic+keyTemplate'></span>

<h3>Description</h3>

<p>A variable key is a human readable document that describes the
variables in a data set. A key can be revised and re-imported by R
to recode data. This might also be referred to as a
&quot;programmable codebook.&quot;  This function inspects a data frame,
takes notice of its variable names, their classes, and legal
values, and then it creates a table summarizing that
information. The aim is to create a document that principal
investigators and research assistants can use to keep a project
well organized.  Please see the vignette in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keyTemplate(
  dframe,
  long = FALSE,
  sort = FALSE,
  file = NULL,
  max.levels = 15,
  missings = NULL,
  missSymbol = ".",
  safeNumericToInteger = TRUE,
  trimws = "both",
  varlab = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keyTemplate_+3A_dframe">dframe</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="keyTemplate_+3A_long">long</code></td>
<td>
<p>Default FALSE.</p>
</td></tr>
<tr><td><code id="keyTemplate_+3A_sort">sort</code></td>
<td>
<p>Default FALSE. Should the rows representing the
variables be sorted alphabetically? Otherwise, they appear in
the order in which they were included in the original dataset.</p>
</td></tr>
<tr><td><code id="keyTemplate_+3A_file">file</code></td>
<td>
<p>DEFAULT NULL, meaning no file is produced. Choose a
file name ending in either &quot;csv&quot; (for comma separated
variables), &quot;xlsx&quot; (compatible with Microsoft Excel), or &quot;rds&quot;
(R serialization data). The file name will be used to select
among the 3 storage formats. XLSX output requires the openxlsx
package.</p>
</td></tr>
<tr><td><code id="keyTemplate_+3A_max.levels">max.levels</code></td>
<td>
<p>How high is the limit on the number of values
for discrete (integer, character, and Date) variables?
Default = 15. If observed number exceeds max.levels, we
conclude the author should not assign new values in the key
and only the missing value will be included in the key as a
&quot;placeholder&quot;. This does not affect variables declared as
factor or ordered variables, for which all levels are included
in all cases.</p>
</td></tr>
<tr><td><code id="keyTemplate_+3A_missings">missings</code></td>
<td>
<p>Values in exising data which should be treated as
missing in the new key. Character string in format acceptable
to the <code>assignMissing</code> function. Can be a string with
several missing indicators&quot;1;2;3;(8,10);[22,24];&gt; 99;&lt; 2&quot;.</p>
</td></tr>
<tr><td><code id="keyTemplate_+3A_misssymbol">missSymbol</code></td>
<td>
<p>Default &quot;.&quot;.  A character string used to
represent missing values in the key that is created.  Relevant
(mostly) for the key's <code>value_new</code> column. Default is the
period, &quot;.&quot;. Because R's symbol <code>NA</code> can be mistaken for
the character string <code>"NA"</code>, we use a different
(hopefully unmistakable) symbol in the key.</p>
</td></tr>
<tr><td><code id="keyTemplate_+3A_safenumerictointeger">safeNumericToInteger</code></td>
<td>
<p>Default TRUE: Should we treat values
which appear to be integers as integers? If a column is
numeric, it might be safe to treat it as an integer.  In many
csv data sets, the values coded c(1, 2, 3) are really
integers, not floats c(1.0, 2.0, 3.0). See <code>safeInteger</code>.</p>
</td></tr>
<tr><td><code id="keyTemplate_+3A_trimws">trimws</code></td>
<td>
<p>Default is &quot;both&quot;, user can change to &quot;left&quot;, &quot;right&quot;, or
set as NULL to avoid any trimming.</p>
</td></tr>
<tr><td><code id="keyTemplate_+3A_varlab">varlab</code></td>
<td>
<p>A key can have a companion data structure for
variable labels. Default is FALSE, but the value may also be
TRUE or a named vector of variable labels, such as
<code>c("x1" = "happiness", "x2" = "wealth")</code>. The labels
become an attribute of the key object. See Details for
information on storage of varlabs in saved key files.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variable key can be created in two formats, wide and long.
The original style of the variable key, wide, has one row per
variable. It has a style for compact notation about current values
and required recodes.  That is more compact, probably easier for
experts to read, but perhaps more difficult to edit. The long
style variable key has one row per value per variable.  Thus, in a
larger project, the long key can have many rows. However, in a
larger project, the long style key is easier to edit with a spread
sheet program.
</p>
<p>After a key is created, it should be re-imported into R with the
<code>kutils::keyImport</code> function.  Then the key structure can
guide the importation and recoding of the data set.
</p>
<p>Concerning the varlab attribute. Run <code>attr(key, "varlab"</code> to
review existing labels, if any.
</p>
<p>Storing the variable labels in files requires some care because
the <code>rds</code>, <code>xlsx</code>, and <code>csv</code> formats have different
capabilities.  The <code>rds</code> storage format saves all attributes without
difficulty. In contrast, because <code>csv</code> and <code>xlsx</code> do not save
attributes, the varlabs are stored as separate character
matrices. For <code>xlsx</code> files, the varlab object is saved as a second
sheet in <code>xlsx</code> file, while in <code>csv</code> a second file suffixed
&quot;-varlab.csv&quot; is created.
</p>


<h3>Value</h3>

<p>A key in the form of a data frame. May also be saved on
disk if the file argument is supplied. The key may have an
attribute &quot;varlab&quot;, variable labels.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(234234)
N &lt;- 200
mydf &lt;- data.frame(x5 = rnorm(N),
                   x4 = rpois(N, lambda = 3),
                   x3 = ordered(sample(c("lo", "med", "hi"),
                   size = N, replace=TRUE),
                   levels = c("med", "lo", "hi")),
                   x2 = letters[sample(c(1:4,6), N, replace = TRUE)],
                   x1 = factor(sample(c("cindy", "bobby", "marcia",
                                        "greg", "peter"), N,
                   replace = TRUE)),
                   x7 = ordered(letters[sample(c(1:4,6), N, replace = TRUE)]),
                   x6 = sample(c(1:5), N, replace = TRUE),
                   stringsAsFactors = FALSE)
mydf$x4[sample(1:N, 10)] &lt;- 999
mydf$x5[sample(1:N, 10)] &lt;- -999

## Note: If we change this example data, we need to save a copy in
## "../inst/extdata" for packacing
dn &lt;- tempdir()
write.csv(mydf, file = file.path(dn, "mydf.csv"), row.names = FALSE)
mydf.templ &lt;- keyTemplate(mydf, file = file.path(dn, "mydf.templ.csv"),
                          varlab = TRUE)
mydf.templ_long &lt;- keyTemplate(mydf, long = TRUE,
                            file = file.path(dn, "mydf.templlong.csv"),
                            varlab = TRUE)

mydf.templx &lt;- keyTemplate(mydf, file = file.path(dn, "mydf.templ.xlsx"),
                            varlab = TRUE)
mydf.templ_longx &lt;- keyTemplate(mydf, long = TRUE,
                             file = file.path(dn, "mydf.templ_long.xlsx"),
                             varlab = TRUE)
## Check the varlab attribute
attr(mydf.templ, "varlab")
mydf.tmpl2 &lt;- keyTemplate(mydf,
                         varlab = c(x5 = "height", x4 = "age",
                         x3 = "intelligence", x1 = "Name"))
## Check the varlab attribute
attr(mydf.tmpl2, "varlab")

## Try with the national longitudinal study data
data(natlongsurv)
natlong.templ &lt;- keyTemplate(natlongsurv,
                          file = file.path(dn, "natlongsurv.templ.csv"),
                          max.levels = 15, varlab = TRUE, sort = TRUE)

natlong.templlong &lt;- keyTemplate(natlongsurv, long = TRUE,
                   file = file.path(dn, "natlongsurv.templ_long.csv"), sort = TRUE)
if(interactive()) View(natlong.templlong)
natlong.templlong2 &lt;- keyTemplate(natlongsurv, long = TRUE,
                      missings = "&lt;0", max.levels = 50, sort = TRUE,
                      varlab = TRUE)
if(interactive()) View(natlong.templlong2)

natlong.templwide2 &lt;- keyTemplate(natlongsurv, long = FALSE,
                      missings = "&lt;0", max.levels = 50, sort = TRUE)
if(interactive()) View(natlong.templwide2)

all.equal(wide2long(natlong.templwide2), natlong.templlong2)

head(keyTemplate(natlongsurv, file = file.path(dn, "natlongsurv.templ.xlsx"),
             max.levels = 15, varlab = TRUE, sort = TRUE), 10)
head(keyTemplate(natlongsurv, file = file.path(dn, "natlongsurv.templ.xlsx"),
             long = TRUE, max.levels = 15, varlab = TRUE, sort = TRUE), 10)

list.files(dn)

</code></pre>

<hr>
<h2 id='keyTemplateSPSS'>Import an SPSS file, create a key representing the numeric -&gt;
factor transition</h2><span id='topic+keyTemplateSPSS'></span>

<h3>Description</h3>

<p>This is a way to keep track of the scores that are used in the SPSS file.
It is also an easy way to start a new variable key that makes it convenient
to work on the value_new column with R text functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keyTemplateSPSS(dat, long = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keyTemplateSPSS_+3A_dat">dat</code></td>
<td>
<p>A character string path to the SPSS file</p>
</td></tr>
<tr><td><code id="keyTemplateSPSS_+3A_long">long</code></td>
<td>
<p>TRUE returns a long key, otherwise a wide key</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variable key (long or wide)
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>

<hr>
<h2 id='keyTemplateStata'>Import a Stata (version 12 or lower) file, create a key
representing the numeric -&gt; factor transition</h2><span id='topic+keyTemplateStata'></span>

<h3>Description</h3>

<p>This is a way to keep track of the scores that are used in the Stata file.
It is also an easy way to start a new variable key that makes it convenient
to work on the value_new column with R text functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keyTemplateStata(dat, long = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keyTemplateStata_+3A_dat">dat</code></td>
<td>
<p>A character string path to the Stata file</p>
</td></tr>
<tr><td><code id="keyTemplateStata_+3A_long">long</code></td>
<td>
<p>TRUE returns a long key, otherwise a wide key</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A variable key (long or wide)
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>

<hr>
<h2 id='keyUpdate'>Update a key in light of a new data frame (add variables and
values)</h2><span id='topic+keyUpdate'></span>

<h3>Description</h3>

<p>The following chores must be handled.
1. If the data.frame has variables which are not currently
listed in the variable key's &quot;name_old&quot; variable, then new
variables are added to the key.
2. If the data.frame has new values for the previously
existing variables, then those values must be added to the
keys.
3. If the old key has &quot;name_new&quot; or &quot;class_new&quot; designated
for variables, those MUST be preserved in the new key
for all new values of those variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keyUpdate(key, dframe, append = TRUE, safeNumericToInteger = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keyUpdate_+3A_key">key</code></td>
<td>
<p>A variable key</p>
</td></tr>
<tr><td><code id="keyUpdate_+3A_dframe">dframe</code></td>
<td>
<p>A data.frame object.</p>
</td></tr>
<tr><td><code id="keyUpdate_+3A_append">append</code></td>
<td>
<p>If long key, should new rows be added to the end of
the updated key? Default is TRUE. If FALSE, new rows will be
sorted with the original values.</p>
</td></tr>
<tr><td><code id="keyUpdate_+3A_safenumerictointeger">safeNumericToInteger</code></td>
<td>
<p>Default TRUE: Should we treat
variables which appear to be integers as integers? In many csv
data sets, the values coded <code>c(1, 2, 3)</code> are really
integers, not floats <code>c(1.0, 2.0, 3.0)</code>. See
<code>safeInteger</code>.
## Need to consider implementing this:
## @param ignoreCase</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will not alter key values for &quot;class_old&quot;,
&quot;value_old&quot; or &quot;value_new&quot; for variables that have no new
information.
</p>
<p>This function deduces if the key provided is in the wide or long
format from the class of the object.
</p>


<h3>Value</h3>

<p>Updated variable key.
</p>


<h3>Author(s)</h3>

<p>Ben Kite &lt;bakite@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Original data frame has 2 variables
dat1 &lt;- data.frame("Score" = c(1, 2, 3, 42, 4, 2),
                   "Gender" = c("M", "M", "M", "F", "F", "F"))
## New data has all of original dat1, plus a new variable "Weight"
#and has new values for "Gender" and "Score"
dat2 &lt;- plyr::rbind.fill(dat1, data.frame("Score" = 7,
           "Gender" = "other", "Weight" = rnorm(3)))
## Create a long key for the original data, specify some
## recodes for Score and Gender in value_new
key1.long &lt;- keyTemplate(dat1, long = TRUE, varlab = TRUE)

key1.long$value_new &lt;- gsub("42", "10", key1.long$value_new)
key1.long$value_new[key1.long$name_new == "Gender"] &lt;-
       mgsub(c("F", "M"), c("female", "male"),
       key1.long$value_new[key1.long$name_new == "Gender"])  
key1.long[key1.long$name_old == "Score", "name_new"] &lt;- "NewScore"
keyUpdate(key1.long, dat2, append = TRUE)
## Throw away one row, make sure key still has Score values
dat2 &lt;- dat2[-1,]
(key1.long.u &lt;- keyUpdate(key1.long, dat2, append = FALSE))
## Key change Score to character variable
key1.longc &lt;- key1.long
key1.longc[key1.longc$name_old == "Score", "class_new"] &lt;- "character"
keyUpdate(key1.longc, dat2, append = TRUE)
str(dat3 &lt;- keyApply(dat2, key1.longc))
## Now try a wide key
key1.wide &lt;- keyTemplate(dat1)
## Put in new values, same as in key1.long
key1.wide[key1.wide$name_old == "Score", c("name_new", "value_new")] &lt;-
                            c("NewScore", "1|2|3|4|10|.")
key1.wide[key1.wide$name_old == "Gender", "value_new"] &lt;- "female|male|."
## Make sure key1.wide equivalent to key1.long:
## If this is not true, it is a fail
all.equal(long2wide(key1.long), key1.wide, check.attributes = FALSE)
(key1.wide.u &lt;- keyUpdate(key1.wide, dat2))
key1.long.to.wide &lt;- long2wide(key1.long.u)
all.equal(key1.long.to.wide, key1.wide.u, check.attributes = FALSE)
str(keyApply(dat2, key1.wide.u))

mydf.key.path &lt;- system.file("extdata", "mydf.key.csv", package = "kutils")
mydf.key &lt;-  keyImport(mydf.key.path)
##'
set.seed(112233)
N &lt;- 20
## The new Jan data arrived!
mydf2 &lt;- data.frame(x5 = rnorm(N),
                    x4 = rpois(N, lambda = 3),
                    x3 = ordered(sample(c("lo", "med", "hi"),
                                       size = N, replace=TRUE),
                                levels = c("med", "lo", "hi")),
                    x2 = letters[sample(c(1:4,6), N, replace = TRUE)],
                    x1 = factor(sample(c("jan"), N, replace = TRUE)),
                    x7 = ordered(letters[sample(c(1:4,6), N, replace = TRUE)]),
                    x6 = sample(c(1:5), N, replace = TRUE),
                    stringsAsFactors = FALSE)
mydf.key2 &lt;- keyUpdate(mydf.key, mydf2)
mydf.key2
mydf.key2["x1", "value_old"] &lt;- "cindy|bobby|jan|peter|marcia|greg|."
mydf.key2["x1", "value_new"] &lt;- "Cindy&lt;Bobby&lt;Jan&lt;Peter&lt;Marcia&lt;Greg&lt;."
##'
mydf.key.path &lt;- system.file("extdata", "mydf.key.csv", package = "kutils")
mydf.path &lt;- system.file("extdata", "mydf.csv", package = "kutils")
mydf &lt;- read.csv(mydf.path, stringsAsFactors=FALSE)
mydf3 &lt;- rbind(mydf, mydf2)
## Now recode with revised key
mydf4 &lt;- keyApply(mydf3, mydf.key2)
rockchalk::summarize(mydf4)
</code></pre>

<hr>
<h2 id='likert'>Percentage tables for Likert Scale variables</h2><span id='topic+likert'></span>

<h3>Description</h3>

<p>Creates a table with columns for allowed values and rows for
variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likert(data, vlist, columnlabels, valuelabels, rows = FALSE, digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="likert_+3A_data">data</code></td>
<td>
<p>A data frame. Function will try to include all
variables in data, unless vlist is provided.</p>
</td></tr>
<tr><td><code id="likert_+3A_vlist">vlist</code></td>
<td>
<p>A vector of column names in data that should be
displayed</p>
</td></tr>
<tr><td><code id="likert_+3A_columnlabels">columnlabels</code></td>
<td>
<p>Column labels, optional to beautify variable
names. If not supplied, column names will be used as column
labels. Provide either 1) A named vector that replaces one or
more columns, <code>c(oldname1 = "newlabel1", oldname2 =
"newlabel2")</code> where oldnames are in colnames(data), or 2) a
vector of same length as vlist (or data if vlist is not
supplied) that will replace them one for one.</p>
</td></tr>
<tr><td><code id="likert_+3A_valuelabels">valuelabels</code></td>
<td>
<p>A vector of values to beautify existing
levels. If not supplied, factor levels will be used as row
labels</p>
</td></tr>
<tr><td><code id="likert_+3A_rows">rows</code></td>
<td>
<p>Should output be transposed. This may help if there
are many variables that need to fit on the page.  Percentages
will appear on the rows, rather than columns.</p>
</td></tr>
<tr><td><code id="likert_+3A_digits">digits</code></td>
<td>
<p>Number of decimals to display in percentages</p>
</td></tr>
<tr><td><code id="likert_+3A_...">...</code></td>
<td>
<p>Arguments to pass to R's table function. We suggest
<code>useNA = "always"</code> to add missing value information and
<code>exclude = original.value.label</code> to exclude values
observed. Currently, <code>useNA = "ifany"</code> does not work as
expected, the number of missings will be displayed, even if
there are none.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, including a frequency table (called &quot;freqTab&quot;),
column counts (&quot;counts&quot;), column sums (&quot;sums&quot;), and
column percents (&quot;pcts&quot;).
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vvector &lt;- c("Strongly Disagree", "Disagree", "Neutral",
              "Agree", "Strongly Agree")
set.seed(2342234)
N &lt;- 28
scales &lt;-
    data.frame(Vegas = factor(sample(1:5, N, replace = TRUE),
        levels = 1:5, labels = vvector),
               NewYork = factor(sample(1:5, N, replace = TRUE),
        levels = 1:5, labels = vvector),
               Paris = factor(sample(1:5, N, replace = TRUE),
        levels = 1:5, labels = vvector),
               Berlin = factor(sample(1:5, N, replace = TRUE),
        levels = 1:5, labels = vvector))

likert(scales)

likert(scales, exclude = "Disagree")

likert(scales, exclude = "Strongly Disagree", useNA = "ifany")

(mySummary1 &lt;- likert(data = scales, vlist = c("Vegas", "NewYork", "Paris")))
mySummary1[["pcts"]]

(mySummary2 &lt;- likert(scales, vlist = c("Vegas", "NewYork", "Paris"),
                    valuelabels = c("SD", "D", "N", "A", "SA")))
(mySummary3 &lt;- likert(scales, vlist = c("Vegas", "NewYork", "Paris"),
                    valuelabels = c("Strongly Disagree" = "Strong Disagreement")))

(mySummary5 &lt;- likert(scales, vlist = c("Vegas", "NewYork", "Paris"),
      valuelabels = c("SD", "D", "N", "A", "SA"),
      columnlabels = c("Vegas" = "Sin City"), rows = TRUE))

 ## Example of how one might write this in a file. 
 ## print(xtable::xtable(mySummary1[[1]], digits = 1),
 ##       type = "html", file = "varCount-1.html")       
  
</code></pre>

<hr>
<h2 id='long2wide'>convert a key object from long to wide format</h2><span id='topic+long2wide'></span>

<h3>Description</h3>

<p>##' This is not flexible, assumes columns are named in our canonical
style, which means the columns are named c(&quot;name_old&quot;, &quot;name_new&quot;,
&quot;class_old&quot;, &quot;class_new&quot;, &quot;value_old&quot;, &quot;value_new&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>long2wide(
  keylong,
  na.strings = c("\\.", "", "\\s+", "N/A"),
  missSymbol = "."
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="long2wide_+3A_keylong">keylong</code></td>
<td>
<p>A variable key in the long format</p>
</td></tr>
<tr><td><code id="long2wide_+3A_na.strings">na.strings</code></td>
<td>
<p>Strings to be treated as missings in value_new</p>
</td></tr>
<tr><td><code id="long2wide_+3A_misssymbol">missSymbol</code></td>
<td>
<p>Default is &quot;.&quot;, character to insert in value when R NA is found.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A wide format variable key
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydf.path &lt;- system.file("extdata", "mydf.csv", package = "kutils")
mydf &lt;- read.csv(mydf.path, stringsAsFactors=FALSE)
## A wide key we are trying to match:
mydf.key &lt;- keyTemplate(mydf, long = FALSE, sort = TRUE)
mydf.key["x4", "missings"] &lt;- "999"
## A long key we will convert next
mydf.keylong &lt;- keyTemplate(mydf, long = TRUE, sort = TRUE)
mydf.keylong[mydf.keylong[ , "name_old"] == "x4" &amp;
    mydf.keylong[ , "value_old"] == "999", "missings"] &lt;- "999"
mydf.long2wide &lt;- long2wide(mydf.keylong)
all.equal(mydf.key, mydf.long2wide)

mydf.keylong.path &lt;- system.file("extdata", "mydf.key_long.csv", package = "kutils")
mydf.keylong &lt;- keyImport(mydf.keylong.path)
mydf.keywide &lt;- long2wide(mydf.keylong)
mydf.keylong2 &lt;- wide2long(mydf.keywide)
## Is error if following not TRUE
all.equal(mydf.keylong2, mydf.keylong)

</code></pre>

<hr>
<h2 id='makeKeylist'>Convert the variable key into a list of long keys, one for each variable.</h2><span id='topic+makeKeylist'></span>

<h3>Description</h3>

<p>A keylist element is a long key for one new variable. The new
variables are named by &quot;name_old.name_new&quot; for uniqueness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeKeylist(
  key,
  sep = c(character = "\\|", logical = "\\|", integer = "\\|", factor = "\\|",
    ordered = "[\\|&lt;]", numeric = "\\|"),
  na.strings = c("\\.", "", "\\s+", "N/A")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeKeylist_+3A_key">key</code></td>
<td>
<p>A key object or a file name, csv, xlsx or rds.</p>
</td></tr>
<tr><td><code id="makeKeylist_+3A_sep">sep</code></td>
<td>
<p>Separator regular expressions</p>
</td></tr>
<tr><td><code id="makeKeylist_+3A_na.strings">na.strings</code></td>
<td>
<p>Strings that will be treated as NA. This will be
used only if the key object does not have an na.strings
attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the key has one old variable being recoded 6 ways, that begets
6 elements in the resulting list. Attributes including the classes
of the old and new variables are included.
</p>


<h3>Value</h3>

<p>A list with one element per variable name, along with some
attributes like class_old and class_new. The class is set as
well, &quot;keylist&quot;
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>

<hr>
<h2 id='mergeCheck'>First draft of function to diagnose problems in merges and key variables</h2><span id='topic+mergeCheck'></span>

<h3>Description</h3>

<p>This is a first effort. It works with 2 data frames and 1 key
variable in each. It does not work if the by parameter includes
more than one column name (but may work in future). The return is
a list which includes full copies of the rows from the data frames
in which trouble is observed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeCheck(
  x,
  y,
  by,
  by.x = by,
  by.y = by,
  incomparables = c(NULL, NA, NaN, Inf, "\\s+", "")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mergeCheck_+3A_x">x</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_y">y</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_by">by</code></td>
<td>
<p>Commonly called the &quot;key&quot; variable. A column name to be
used for merging (common to both <code>x</code> and <code>y</code>)</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_by.x">by.x</code></td>
<td>
<p>Column name in <code>x</code> to be used for merging. If not
supplied, then <code>by.x</code> is assumed to be same as <code>by</code>.</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_by.y">by.y</code></td>
<td>
<p>Column name in <code>y</code> to be used for merging. If not
supplied, then <code>by.y</code> is assumed to be same as <code>by</code>.</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_incomparables">incomparables</code></td>
<td>
<p>values in the key (by) variable that are
ignored for matching. We default to include these values as
incomparables: c(NULL, NA, NaN, Inf, &quot;\s+&quot;, &quot;&quot;). Note this is
a larger list of incomparables than assumed by R merge (which
assumes only NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data structures that are displayed for keys and
data sets.  The return is <code>list(keysBad, keysDuped,
    unmatched)</code>. <code>unmatched</code> is a list with 2 elements, the
unmatched cases from <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(id = 1:7, x = rnorm(7))
df2 &lt;- data.frame(id = c(2:6, 9:10), x = rnorm(7))
mc1 &lt;- mergeCheck(df1, df2, by = "id")
## Use mc1 objects mc1$keysBad, mc1$keysDuped, mc1$unmatched
df1 &lt;- data.frame(id = c(1:3, NA, NaN, "", " "), x = rnorm(7))
df2 &lt;- data.frame(id = c(2:6, 5:6), x = rnorm(7))
mergeCheck(df1, df2, by = "id")
df1 &lt;- data.frame(idx = c(1:5, NA, NaN), x = rnorm(7))
df2 &lt;- data.frame(idy = c(2:6, 9:10), x = rnorm(7))
mergeCheck(df1, df2, by.x = "idx", by.y = "idy")
</code></pre>

<hr>
<h2 id='mgsub'>apply a vector of replacements, one after the other.</h2><span id='topic+mgsub'></span>

<h3>Description</h3>

<p>This is multi-gsub.  Use it when it is necessary to process
many patterns and replacements in a given order on a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mgsub(pattern, replacement, x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mgsub_+3A_pattern">pattern</code></td>
<td>
<p>vector of values to be replaced. A vector filled
with patterns as documented in the <code>gsub</code> pattern
argument</p>
</td></tr>
<tr><td><code id="mgsub_+3A_replacement">replacement</code></td>
<td>
<p>vector of replacements, otherwise same as
<code>gsub</code>.  Length of replacement must be either 1 or same
as pattern, otherwise an error results.</p>
</td></tr>
<tr><td><code id="mgsub_+3A_x">x</code></td>
<td>
<p>the vector in which elements are to be replaced, same as
<code>gsub</code></p>
</td></tr>
<tr><td><code id="mgsub_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to gsub</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with pattern replaced by replacement
</p>


<h3>Author(s)</h3>

<p>Jared Harpole &lt;jared.harpole@gmail.com&gt; and Paul Johnson
&lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("Tom", "Jerry", "Elmer", "Bugs")
pattern &lt;- c("Tom", "Bugs")
replacement &lt;- c("Thomas", "Bugs Bunny")
(y &lt;- mgsub(pattern, replacement, x))
x[1] &lt;- "tom"
(y &lt;- mgsub(pattern, replacement, x, ignore.case = TRUE))
(y &lt;- mgsub(c("Elmer", "Bugs"), c("Looney Characters"), x, ignore.case = TRUE))
</code></pre>

<hr>
<h2 id='modifyVector'>Use new information to update a vector. Similar in concept to
R's modify list</h2><span id='topic+modifyVector'></span>

<h3>Description</h3>

<p>Original purpose was to receive 2 named vectors, x and y, and copy
&quot;updated&quot; named values from y into x. If x or y are not named,
however, this will do something useful.
</p>

<ul>
<li><p> Both vectors are named: values in x for which y names match will be
updated with values from y. If <code>augment</code> is true, then named
values in y that are not present in x will be added to x.
</p>
</li>
<li><p> If neither vector is named: returns a new vector with x as the values
and y as the names. Same as returning <code>names(x) &lt;- y</code>.
</p>
</li>
<li><p> If x is not named, y is named: replaces elements in x with values of y
where suitable (x matches names(y)). For matches, returns x = y[x]
if names(y) include x.
</p>
</li>
<li><p> If x is named, y is not named: returns y, but with names from x. Lengths
of x and y must be identical.
</p>
</li>
<li><p> If y is NULL or not provided, x is returned unaltered.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>modifyVector(x, y, augment = FALSE, warnings = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modifyVector_+3A_x">x</code></td>
<td>
<p>vector to be updated, may be named or not.</p>
</td></tr>
<tr><td><code id="modifyVector_+3A_y">y</code></td>
<td>
<p>possibly a named vector. If unnamed, must match
length of x. If named, and length is shorter than x, then
name-value pairs in x will be replaced with name-value pairs
with y. If names in y are not in x, the augment argument
determines the result.</p>
</td></tr>
<tr><td><code id="modifyVector_+3A_augment">augment</code></td>
<td>
<p>If TRUE, add new items in x from y. Otherwise,
ignore named items in y that are not in x.</p>
</td></tr>
<tr><td><code id="modifyVector_+3A_warnings">warnings</code></td>
<td>
<p>Defaults as FALSE. Show warnings about augmentation
of the target vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an updated vector
</p>


<h3>Author(s)</h3>

<p>Paul Johnson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(a = 1, b = 2, c = 3)
y &lt;- c(b = 22)
modifyVector(x, y)
y &lt;- c(c = 7, a = 13, e = 8)
## If augment = TRUE, will add more elements to x
modifyVector(x, y, augment = TRUE)
modifyVector(x, y)
x &lt;- c("a", "b", "c")
y &lt;- c("income", "education", "sei")
## Same as names(x) &lt;- y
modifyVector(x, y)
x &lt;- c("a", "b", "c")
y &lt;- c(a = "happy")
modifyVector(x, y)
y &lt;- c(a = "happy", g = "glum")
## Will give error unless augment = TRUE
modifyVector(x, y, augment = TRUE)
</code></pre>

<hr>
<h2 id='n2NA'>Convert nothing to R missing(NA).</h2><span id='topic+n2NA'></span>

<h3>Description</h3>

<p>By &quot;nothing&quot;, we mean white space or other indications of
nothingness.  Goal is to find character strings that users
might insert in a key to indicate missing values. Those things,
which are given default values in the argument nothings, will be
changed to NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n2NA(x, nothings = c("\\.", "\\s"), zapspace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n2NA_+3A_x">x</code></td>
<td>
<p>A character vector. If x is not a character vector, it is
returned unaltered without warning.</p>
</td></tr>
<tr><td><code id="n2NA_+3A_nothings">nothings</code></td>
<td>
<p>A vector of values to be matched by regular
expressions as missing.  The default vector is c(&quot;\.&quot;,
&quot;\s&quot;), where &quot;\.&quot; means a literal period (backslashes needed
to escape the symbol which would otherwise match anything in a
regular expression).</p>
</td></tr>
<tr><td><code id="n2NA_+3A_zapspace">zapspace</code></td>
<td>
<p>Should leading and trailing white space be
ignored, so that, for example &quot; . &quot; and &quot;.&quot; are both treated
as missing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using regular expression matching, any value that has nothing
except for the indicated &quot;nothing&quot; values is converted to NA.  The
&quot;nothing&quot; values included by default are a period by itself (A SAS
missing value), an empty string, or white space, meaning &quot; &quot;, or
any number of spaces, or a tab.
</p>


<h3>Value</h3>

<p>A vector with &quot;nothing&quot; values replaced by R's NA symbol.
Does not alter other values in the vector. Previous version
had applied zapspace to non-missing values, but it no longer
does so.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gg &lt;- c("", " ", "   ", "\t", "\t some", "some\t", " space first", ".",
       " . ")
n2NA(x = gg)
n2NA(x = gg, zapspace = FALSE)
n2NA(x = gg, nothings = c("\\s"), zapspace = FALSE)
n2NA(x = gg, nothings = c("\\."), zapspace = TRUE)
n2NA(x = gg, nothings = c("\\."), zapspace = FALSE)
</code></pre>

<hr>
<h2 id='naLast'>Sort key so that non missing values are first in the
value vector.</h2><span id='topic+naLast'></span>

<h3>Description</h3>

<p>Sort key so that non missing values are first in the
value vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naLast(
  key,
  byvar = "name_new",
  valvar = "value_new",
  na.strings = c("\\.", "", "\\s+", "N/A")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="naLast_+3A_key">key</code></td>
<td>
<p>key, long or wide</p>
</td></tr>
<tr><td><code id="naLast_+3A_byvar">byvar</code></td>
<td>
<p>Default is &quot;name_new&quot;, the column for sorting into blocks.</p>
</td></tr>
<tr><td><code id="naLast_+3A_valvar">valvar</code></td>
<td>
<p>The value variable on which sorting is to be done, &quot;value_new&quot;.</p>
</td></tr>
<tr><td><code id="naLast_+3A_na.strings">na.strings</code></td>
<td>
<p>vector of characters to be treated as NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sorted key, with blocks that have the missings last
</p>

<hr>
<h2 id='natlongsurv'>Smoking, Happiness, and other survey responses</h2><span id='topic+natlongsurv'></span>

<h3>Description</h3>

<p>An idiosyncratic selection of 29 variables from the Original
Cohort-Young Women 1968-2003 edition of the US National
Longitudinal Survey.  This originally included 5159 rows, but
subset includes only 2867 rows, so sample frequencies will not
match the values listed in the codebook.  A snapshot of the
codebook, &quot;natlongsurv.cdb.txt&quot;, which we have trimmed down, is
included in the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(natlongsurv)
</code></pre>


<h3>Format</h3>

<p>A data frame with 2867 rows and 29 variables:
</p>

<ul>
<li><p>	R0000100	IDENTIFICATION CODE
</p>
</li>
<li><p>	R0003300	MARITAL STATUS, 1968
</p>
</li>
<li><p>	R0005700	AGE WHEN STOPPED ATTENDING SCHOOL, 1968
</p>
</li>
<li><p>	R0060300	IQ SCORE, 1968
</p>
</li>
<li><p>	R1051600	HIGHEST GRADE COMPLETED
</p>
</li>
<li><p>	R1302000	SMOKING - DOES R SMOKE, 1991
</p>
</li>
<li><p>	R1302100	SMOKING - NUMBER OF CIGARETTES R SMOKES PER DAY, 91 (PRESENT SMOKER)
</p>
</li>
<li><p>	R6235600	HIGHEST GRADE COMPLETED
</p>
</li>
<li><p>	R6502300	IS RESIDENCE/LIVING QUARTERS HOME/APARTMENT/OTHER?
</p>
</li>
<li><p>	R6513700	HOUSEHOLD RECORD - HOUSEHOLD MEMBER - AGE CALCULATED FROM BIRTH DATE
</p>
</li>
<li><p>	R6516200	CURRENT MARITAL STATUS
</p>
</li>
<li><p>	R6520300	HIGHEST GRADE COMPLETED OF HUSBAND
</p>
</li>
<li><p>	R6553600	HIGHEST GRADE COMPLETED OF PARTNER
</p>
</li>
<li><p>	R7289200	SMOKING - CURRENTLY SMOKE CIGARETTES
</p>
</li>
<li><p>	R7289400	ALCOHOL USE - HAS R CONSUMED ANY ALCOHOLIC BEVERAGES IN PAST MONTH?
</p>
</li>
<li><p>	R7293430	YOUNG WOMEN 20-ITEM CES-D ITEM RESPONSE SCORE
</p>
</li>
<li><p>	R7312300	INCOME FROM WAGES/SALARY IN PAST YEAR
</p>
</li>
<li><p>	R7329900	INCOME ADEQUACY: R OPINION OF HER HAPPINESS WITH HER/FAMILY INCOME
</p>
</li>
<li><p>	R7330000	INCOME ADEQUACY: R OPINION OF AMOUNT NEEDED TO MAKE ENDS MEET $ AMOUNT
</p>
</li>
<li><p>	R7337600	R HAS ATTENDED/COMPLETED TWO/MORE YEARS OF COLLEGE
</p>
</li>
<li><p>	R7344600	ATTITUDE TOWARD FEELINGS OVERALL
</p>
</li>
<li><p>	R7344700	DID R DO ANY UNPAID VOLUNTEER WORK IN PAST YEAR?
</p>
</li>
<li><p>	R7347500	ATTITUDE TOWARD SOCIAL SECURITY - PERCENT WOULD INVEST IN STOCKS? 2004
</p>
</li>
<li><p>	R7347600	ATTITUDE TOWARD SOCIAL SECURITY - PERCENT WOULD INVEST IN BONDS OF PRIVATE COMPANIES? 2004
</p>
</li>
<li><p>	R7347700	ATTITUDE TOWARD SOCIAL SECURITY - PERCENT WOULD INVEST IN U.S. GOVERNMENT BONDS? 2004
</p>
</li>
<li><p>	R7477700	TOTAL CHILDREN IN ROSTER
</p>
</li>
<li><p>	R7477800	COUNT ELIGIBLE HOUSEHOLD CHILDREN
</p>
</li>
<li><p>	R7610300	REGION OF RESIDENCE
</p>
</li></ul>



<h3>Details</h3>

<p>All variables are for the 2003 year, except where otherwise noted.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Source</h3>

<p>National Longitudinal Surveys public-use data set (Bureau of Labor Statistics, 2018).
</p>


<h3>References</h3>

<p>Bureau of Labor Statistics. 2018.  NLS Original Cohort: Mature and Young Women, US National Longitudinal Surveys Public Use Data Sets (www.bls.gov/nls/home.htm).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(natlongsurv)
peek(natlongsurv, ask = FALSE, file = paste0(tempdir(), "/","peek.pdf"))
</code></pre>

<hr>
<h2 id='padW0'>Insert 0's in the front of existing digits or characters so that
all elements of a vector have the same number of characters.</h2><span id='topic+padW0'></span>

<h3>Description</h3>

<p>The main purpose was to correct ID numbers in studies that are
entered as integers with leading 0's as in 000001 or 034554.  R's
default coercion of integers will throw away the preceding 0's,
and reduce that to 1 or 34554. The user might want to re-insert
the 0's, thereby creating a character vector with values &quot;000001&quot;
and &quot;045665&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>padW0(x, n = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="padW0_+3A_x">x</code></td>
<td>
<p>vector to be converted to a character variable by
inserting 0's at the front. Should be integer or character,
floating point numbers will be rounded down. All other
variable types will return errors.</p>
</td></tr>
<tr><td><code id="padW0_+3A_n">n</code></td>
<td>
<p>Optional parameter.  The desired final length of
character vector.  This parameter is a guideline to determine
how many 0's must be inserted.  This will be ignored if
<code>n</code> is smaller than the number of characters in the
longest element of <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If x is an integer or a character vector, the result is the
more-or-less expected outcome (see examples). If x is numeric,
but not an integer, then x will be rounded to the lowest integer.
</p>
<p>The previous versions of this function failed when there were
missing values (NA) in the vector x.  This version returns NA for
those values.
</p>
<p>One of the surprises in this development was that sprintf() in R
does not have a known consequence when applied to a character
variable. It is platform-dependent (unredictable). On Ubuntu Linux
16.04, for example <code>sprintf("%05s", 2)</code> gives back
<code>" 2"</code>, rather than (what I expected) <code>"00002"</code>. The
problem is mentioned in the documentation for <code>sprintf</code>. The
examples show this does work now, but please test your results.
</p>


<h3>Value</h3>

<p>A character vector
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- c(0001, 0022, 3432, NA)
padW0(x1)
padW0(x1, n = 10)
x2 &lt;- c("1", "22", "3432", NA)
padW0(x2)
## There's been a problem with strings, but this works now.
## It even preserves non-leading spaces. Hope that's what you want.
x3 &lt;- c("1", "22 4", "34323  42", NA)
padW0(x3)
x4 &lt;- c(1.1, 334.52, NA)
padW0(x4)
</code></pre>

<hr>
<h2 id='peek'>Show variables, one at a time, QUICKLY and EASILY.</h2><span id='topic+peek'></span><span id='topic+histOMatic'></span>

<h3>Description</h3>

<p>This makes it easy to quickly scan through all of the columns in a
data frame to spot unexpected patterns or data entry errors.  Numeric variables are depicted as
histograms, while factor and character variables are summarized by
the R table function and then presented as barplots. This is most
useful with a large screen graphic device (try running the function
provided with this package, <code>dev.create(height=7, width=7)</code>)
or any other method you prefer to create a large device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peek(
  dat,
  sort = TRUE,
  file = NULL,
  textout = FALSE,
  ask,
  ...,
  xlabstub = "kutils peek: ",
  freq = FALSE,
  histargs = list(probability = !freq),
  barargs = list(horiz = TRUE, las = 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="peek_+3A_dat">dat</code></td>
<td>
<p>An R data frame or something that can be coerced to a
data frame by <code>as.data.frame</code></p>
</td></tr>
<tr><td><code id="peek_+3A_sort">sort</code></td>
<td>
<p>Default TRUE. Do you want display of the columns in
alphabetical order?</p>
</td></tr>
<tr><td><code id="peek_+3A_file">file</code></td>
<td>
<p>Should output go in file rather than to the screen.
Default is NULL, meaning show on screen. If you supply a file
name, we will write PDF output into it.</p>
</td></tr>
<tr><td><code id="peek_+3A_textout">textout</code></td>
<td>
<p>If TRUE, counts from histogram bins and tables will
appear in the console.</p>
</td></tr>
<tr><td><code id="peek_+3A_ask">ask</code></td>
<td>
<p>As in the old style R <code>par(ask = TRUE)</code>: should
keyboard interaction advance to the next plot.  Will default
to false if the file argument is non-null.  If file is null,
setting ask = FALSE will cause graphs to whir bye without
pausing.</p>
</td></tr>
<tr><td><code id="peek_+3A_...">...</code></td>
<td>
<p>Additional arguments for the pdf, histogram, table, or
barplot functions. Please see Details below.</p>
</td></tr>
<tr><td><code id="peek_+3A_xlabstub">xlabstub</code></td>
<td>
<p>A text stub that will appear in the x axis
label. Currently it includes advertising for this package.</p>
</td></tr>
<tr><td><code id="peek_+3A_freq">freq</code></td>
<td>
<p>As in the histogram frequency argument. Should graphs
show counts (freq = TRUE) or proportions (AKA densities) (freq
= FALSE)</p>
</td></tr>
<tr><td><code id="peek_+3A_histargs">histargs</code></td>
<td>
<p>A list of arguments to be passed to the
<code>hist</code> function.</p>
</td></tr>
<tr><td><code id="peek_+3A_barargs">barargs</code></td>
<td>
<p>A list of arguments to be passed to the
<code>barplot</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of column names that were plotted
</p>


<h3>Try the Defaults</h3>

<p>Every effort has been made to make this
simple and easy to use. Please run the examples as they are
before becoming too concerned about customization.  This
function is intended for getting a quick look at each
variable, one-by-one, it is not intended to create publication
quality histograms.  For sake of the fastidious users, a lot
of settings can be adjusted. Users can control the parameters
for presentation of histograms (parameters for <code>hist</code>)
and barplots (parameters for <code>barplot</code>). The function also
can create frequency tables (which users can control by providing
additional named arguments).
</p>


<h3>Style</h3>

<p>The histograms are standard, upright histograms.
The barplots are horizontal. I chose to make the bars
horizontal because long value labels are more easily
accomodated on the left axis.  The code measures the length
(in inches) for strings and the margin is increased
accordingly.  The examples have a demonstration of that
effect.
</p>


<h3>Dealing with Dots</h3>

<p>additional named arguments,
<code>...</code>, are inspected and sorted into groups intended to
control use of R functions <code>hist</code>, <code>barplot</code>,
<code>table</code> and <code>pdf</code>.  <br /> <br /> The parameters
c(&quot;exclude&quot;, &quot;dnn&quot;, &quot;useNA&quot;, &quot;deparse.level&quot;) and will go to
the <code>table</code> function, which is used to make barplots for
factor and character variables. These named arguments are
extracted and sent to the pdf function: c(&quot;width&quot;, &quot;height&quot;,
&quot;onefile&quot;, &quot;family&quot;, &quot;title&quot;, &quot;fonts&quot;, &quot;version&quot;, &quot;paper&quot;,
&quot;encoding&quot;, &quot;bg&quot;, &quot;fg&quot;, &quot;pointsize&quot;, &quot;pagecentre&quot;,
&quot;colormodel&quot;, &quot;useDingbats&quot;, &quot;useKerning&quot;, &quot;fillOddEven&quot;,
&quot;compress&quot;). Any other arguments that are unique to
<code>hist</code> or <code>barplot</code> are sorted out and sent only to
those functions.  <br /> <br /> Any other arguments, including
graphical parameters will be sent to both the histogram and
barplot functions, so it is a convenient way to obtain uniform
appearance. Additional arguments that are common to
<code>barplot</code> and <code>hist</code> will work, and so will any
graphics parameters (named arguments of <code>par</code>, for
example). However, if one wants to target some arguments to
<code>hist</code>, but not <code>barplot</code>, then the <code>histargs</code>
list argument should be used. Similarly, <code>barargs</code> should
be used to send argument to the <code>barplot</code>
function. Warning: the defaults for <code>histargs</code> and
<code>barargs</code> include some settings that are needed for the
existing design.  If new lists for <code>histargs</code> or
<code>barargs</code> are supplied, the previously specified defaults
are lost.  Hence, users should include the existing members of
those lists, possibly with revised values.  <br /> <br /> All of
this argument sorting effort is done in order to reduce a
prolific number of warnings that were observed in previous
editions of this function.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(234234)
N &lt;- 200
mydf &lt;- data.frame(x5 = rnorm(N), x4 = rnorm(N), x3 = rnorm(N),
                   x2 = letters[sample(1:24, 200, replace = TRUE)],
                   x1 = factor(sample(c("cindy", "bobby", "marsha",
                                        "greg", "chris"), 200, replace = TRUE)),
                   stringsAsFactors = FALSE)
## Insert 16 missings
mydf$x1[sample(1:150, 16,)] &lt;- NA
mydf$adate &lt;- as.Date(c("1jan1960", "2jan1960", "31mar1960", "30jul1960"), format = "%d%b%y")
peek(mydf)
peek(mydf, sort = FALSE)
## Demonstrate the dot-dot-dot usage to pass in hist params
peek(mydf, breaks = 30, ylab = "These are Counts, not Densities", freq = TRUE)
## Not Run: file output
## peek(mydf, sort = FALSE, file = "three_histograms.pdf")
## Use some objects from the datasets package
library(datasets)
peek(cars, xlabstub = "R cars data: ")
peek(EuStockMarkets, xlabstub = "Euro Market Data: ")
peek(EuStockMarkets, xlabstub = "Euro Market Data: ", breaks = 50,
     freq = TRUE)
## Not run: file output
## peek(EuStockMarkets, breaks = 50, file = "myeuro.pdf",
##      height = 4, width=3, family = "Times")
## peek(EuStockMarkets, breaks = 50, file = "myeuro-%d3.pdf",
##      onefile = FALSE, family = "Times", textout = TRUE)
## xlab goes into "..." and affects both histograms and barplots
peek(mydf, breaks = 30, ylab = "These are Counts, not Densities",
    freq = TRUE)
## xlab is added in the barargs list.
peek(mydf, breaks = 30, ylab = "These are Counts, not Densities",
    freq = TRUE, barargs = list(horiz = TRUE, las = 1, xlab = "I'm in barargs"))
peek(mydf, breaks = 30, ylab = "These are Counts, not Densities", freq = TRUE,
     barargs = list(horiz = TRUE, las = 1, xlim = c(0, 100),
     xlab = "I'm in barargs, not in histargs"))
levels(mydf$x1) &lt;- c(levels(mydf$x1), "arthur philpot smythe")
mydf$x1[4] &lt;- "arthur philpot smythe"
mydf$x2[1] &lt;- "I forgot what letter"
peek(mydf, breaks = 30,
     barargs = list(horiz = TRUE, las = 1))

</code></pre>

<hr>
<h2 id='print.keycheck'>Print out the result of mergeCheck function.</h2><span id='topic+print.keycheck'></span>

<h3>Description</h3>

<p>This is a placeholder for a more elaborate print method
to be prepared in the future. Please advise us what might
be most helpful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'keycheck'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.keycheck_+3A_x">x</code></td>
<td>
<p>keycheck output from mergeCheck</p>
</td></tr>
<tr><td><code id="print.keycheck_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, side effect if print to screen
</p>


<h3>Author(s)</h3>

<p>Paul Johnson
</p>

<hr>
<h2 id='print.keyDiff'>Print a keyDiff object</h2><span id='topic+print.keyDiff'></span>

<h3>Description</h3>

<p>Print a keyDiff object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'keyDiff'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.keyDiff_+3A_x">x</code></td>
<td>
<p>A keyDiff object</p>
</td></tr>
<tr><td><code id="print.keyDiff_+3A_...">...</code></td>
<td>
<p>Other arguments passed through to print</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ben Kite &lt;bakite@ku.edu&gt;
</p>

<hr>
<h2 id='print.likert'>print method for likert tables</h2><span id='topic+print.likert'></span>

<h3>Description</h3>

<p>Nothing fancy here. <code>cat</code> is called on first item in list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'likert'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.likert_+3A_x">x</code></td>
<td>
<p>likert object, 1st item will be printed</p>
</td></tr>
<tr><td><code id="print.likert_+3A_...">...</code></td>
<td>
<p>Arguments passed to print method</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>

<hr>
<h2 id='qualtricsBlockStack'>Create meta data frame to align identical questions</h2><span id='topic+qualtricsBlockStack'></span>

<h3>Description</h3>

<p>Qualtrics returns a data frame that has vertical &quot;blocks&quot;, one for
each &quot;treatment condition&quot; in an experimental condition.
Researchers often want to align the questions from the blocks
vertically, essentially converting the Qualtrics &quot;wide&quot; format to
a &quot;long&quot; format. This is a helper function that identifies
questions that may need to be stacked together.  The input is a
meta data structure (can be retrieved as an attribute from
importQualtrics). It will find out which questions are identical
and prepare to re-align (&quot;stack&quot;) the columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qualtricsBlockStack(meta, questionname = "question")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qualtricsBlockStack_+3A_meta">meta</code></td>
<td>
<p>A meta data structure retrieved from importQualtrics</p>
</td></tr>
<tr><td><code id="qualtricsBlockStack_+3A_questionname">questionname</code></td>
<td>
<p>Character string for name of column in meta data that holds the questions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new meta data table that horizontally aligns equivalent questions.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson
</p>

<hr>
<h2 id='removeMatches'>Remove elements if they are in a target vector, possibly replacing with NA</h2><span id='topic+removeMatches'></span>

<h3>Description</h3>

<p>If a vector has c(&quot;A&quot;, &quot;b&quot;, &quot;c&quot;) and we want to remove &quot;b&quot; and
&quot;c&quot;, this function can do the work. It can also replace &quot;b&quot; and
&quot;c&quot; with the NA symbol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeMatches(x, y, padNA = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removeMatches_+3A_x">x</code></td>
<td>
<p>vector from which elements are to be removed</p>
</td></tr>
<tr><td><code id="removeMatches_+3A_y">y</code></td>
<td>
<p>shorter vector of elements to be removed</p>
</td></tr>
<tr><td><code id="removeMatches_+3A_padna">padNA</code></td>
<td>
<p>Default FALSE, Should removed items be replaced with NA values?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If elements in y are not members of x, they are silently ignored.
</p>
<p>The code for this is not complicated, but it is
difficult to remember.  Here's the recipe to remove
elements y from x: <code>x &lt;- x[!x %in% y[y %in% x]]</code>. It is
easy to get that wrong when in a hurry, so we use this function
instead.  The <code>padNA</code> was an afterthought, but it helps sometimes.
</p>


<h3>Value</h3>

<p>a vector with elements in y removed
</p>


<h3>Author(s)</h3>

<p>Ben Kite &lt;bakite@ku.edu&gt; and Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("a", "b", "c", "d", "e", "f")
y &lt;- c("e", "a")
removeMatches(x, y)
y &lt;- c("q", "r", "s")
removeMatches(x, y)
</code></pre>

<hr>
<h2 id='reverse'>Reverse the levels in a factor</h2><span id='topic+reverse'></span>

<h3>Description</h3>

<p>Simple literal reversal. Will stop with an error message if x is
not a factor (or ordered) variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reverse(x, eol = c("Skip", "DNP"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reverse_+3A_x">x</code></td>
<td>
<p>a factor variable</p>
</td></tr>
<tr><td><code id="reverse_+3A_eol">eol</code></td>
<td>
<p>values to be kept at the end of the list. Does not
accept regular expresssions, just literal text strings
representing values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes people want to
reverse some levels, excluding others and leaving them at the end
of the list. The &quot;eol&quot; argument sets aside some levels and puts
them at the end of the list of levels.
</p>
<p>The use case for the <code>eol</code> argument is a factor
with several missing value labels, as appears in SPSS. With
up to 18 different missing codes, we want to leave them
at the end. In the case for which this was designed, the
researcher did not want to designate those values as
missing before inspecting the pattern of observed values.
</p>


<h3>Value</h3>

<p>a new factor variable with reversed values
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Consider alphabetication of upper and lower
x &lt;- factor(c("a", "b", "c", "C", "a", "c"))
levels(x)
xr1 &lt;- reverse(x)
xr1
## Keep "C" at end of list, after reverse others
xr2 &lt;- reverse(x, eol = "C")
xr2
y &lt;- ordered(x, levels = c("a", "b", "c", "C"))
yr1 &lt;- reverse(y)
class(yr1)[1] == "ordered"
yr1
## Hmm. end of list amounts to being "maximal".
## Unintended side-effect, but interesting.
yr2 &lt;- reverse(y, eol = "C")
yr2
## What about a period as a value (SAS missing)
z &lt;- factor(c("a", "b", "c", "b", "c", "."))
reverse(z)
z &lt;- factor(c(".", "a", "b", "c", "b", "c", "."))
reverse(z)
## How about R NA's
z &lt;- factor(c(".", "a", NA, "b", "c", "b", NA, "c", "."))
z
reverse(z)
z &lt;- ordered(c(".", "a", NA, "b", "c", "b", NA, "c", "."))
z
str(z)
## Put "." at end of list
zr &lt;- reverse(z, eol = ".")
zr
str(zr)
z &lt;- ordered(c(".", "c", NA, "e", "a", "c", NA, "e", "."),
         levels = c(".", "c", "e", "a"))
reverse(z, eol = ".")
reverse(z, eol = c("a", "."))
</code></pre>

<hr>
<h2 id='safeInteger'>If a numeric variable has only integer values, then
make it an integer.</h2><span id='topic+safeInteger'></span>

<h3>Description</h3>

<p>Users often accidentally create floating point numeric variables
when they really mean integers, such as c(1, 2, 3), when they
should have done c(1L, 2L, 3L). Before running <code>as.integer()</code>
to coerce the variable, we'd rather be polite and ask the variable
&quot;do you mind being treated as if you are an integer?&quot;  This
function checks to see if the variable is &quot;close enough&quot; to being
an integer, and then coerces as integer. Otherwise, it returns
NULL. And issues a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>safeInteger(
  x,
  tol = .Machine$double.eps,
  digits = 7,
  vmax = .Machine$integer.max,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="safeInteger_+3A_x">x</code></td>
<td>
<p>a numeric variable</p>
</td></tr>
<tr><td><code id="safeInteger_+3A_tol">tol</code></td>
<td>
<p>Tolerance value. Defaults to Machine$double.eps. See
details.</p>
</td></tr>
<tr><td><code id="safeInteger_+3A_digits">digits</code></td>
<td>
<p>Digits value passed to the zapsmall
function. Defaults to 7.</p>
</td></tr>
<tr><td><code id="safeInteger_+3A_vmax">vmax</code></td>
<td>
<p>Maximum value allowed for an integer. Defaults to
Machine$integer.max.</p>
</td></tr>
<tr><td><code id="safeInteger_+3A_verbose">verbose</code></td>
<td>
<p>Default FALSE: print warnings about x</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, calculate absolute value of differences between <code>x</code>
and <code>as.integer(x)</code>. Second, find out if the sum of those
differences is smaller than <code>tol</code>. If so, then x can
reasonably be coerced to an integer.
</p>
<p>Be careful with the return. The correct return value for variables
that should not be coerced as integer is uncertain at this
point. We've tested various strategies, sometimes returning FALSE,
NULL, or just the original variable.
</p>


<h3>Value</h3>

<p>Either an integer vector or the original variable
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt; and Ben Kite
&lt;bakite@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- c(1, 2, 3, 4, 5, 6)
is.integer(x1)
is.double(x1)
is.numeric(x1)
(x1int &lt;- safeInteger(x1))
is.integer(x1int)
is.double(x1int)
is.numeric(x1int)
x2 &lt;- rnorm(100)
x2int &lt;- safeInteger(x2)
head(x2int)
x3 &lt;- factor(x1, labels = c(LETTERS[1:6]))
x3int &lt;- safeInteger(x3)

</code></pre>

<hr>
<h2 id='shorten'>Reduce each in a vector of strings to a given length</h2><span id='topic+shorten'></span>

<h3>Description</h3>

<p>This is a simple &quot;chop&quot; at k characters, no fancy truncation at
spaces or such. Optionally, this will make unique the resulting
truncated strings. That way, truncation at character 4 of
&quot;Washington&quot; and &quot;Wash&quot; and &quot;Washingham&quot; will not result in 3
values of &quot;Wash&quot;, but rather &quot;Wash&quot;, &quot;Wash.1&quot;, and &quot;Wash.2&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shorten(x, k = 20, unique = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shorten_+3A_x">x</code></td>
<td>
<p>character string</p>
</td></tr>
<tr><td><code id="shorten_+3A_k">k</code></td>
<td>
<p>integer limit on length of string. Default is 20</p>
</td></tr>
<tr><td><code id="shorten_+3A_unique">unique</code></td>
<td>
<p>Default FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of character variables no longer than k
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c("Washington", "Washingham", "Washmylaundry")
shorten(x, 4)
shorten(x, 4, unique = TRUE)
</code></pre>

<hr>
<h2 id='sortStanza'>Move missing values to last row in long key block</h2><span id='topic+sortStanza'></span>

<h3>Description</h3>

<p>Receive key stanza and sort the rows so that the missing
values are last in the list. Leaves ordering of other rows
unchanged otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortStanza(
  keyblock,
  valvar = "value_new",
  na.strings = c("\\.", "", "\\s+", "N/A")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sortStanza_+3A_keyblock">keyblock</code></td>
<td>
<p>a variable key, or section of rows</p>
</td></tr>
<tr><td><code id="sortStanza_+3A_valvar">valvar</code></td>
<td>
<p>Default is &quot;value_new&quot;, the column for sorting.</p>
</td></tr>
<tr><td><code id="sortStanza_+3A_na.strings">na.strings</code></td>
<td>
<p>Stings to be treated as missing, along with R's
NA symbol</p>
</td></tr>
</table>


<h3>Value</h3>

<p>keyblock, row re-arranged with missings last
</p>

<hr>
<h2 id='starsig'>How many stars would we need for this p value?</h2><span id='topic+starsig'></span>

<h3>Description</h3>

<p>Regression table makers need to know how many stars
to attach to parameter estimates. This takes
p values and a vector which indicates how many stars
are deserved.  It returns a required number of asterixes.
Was named &quot;stars&quot; in previous version, but renamed due to
conflict with R base function <code>stars</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>starsig(pval, alpha = c(0.05, 0.01, 0.001), symbols = c("*", "**", "***"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="starsig_+3A_pval">pval</code></td>
<td>
<p>P value</p>
</td></tr>
<tr><td><code id="starsig_+3A_alpha">alpha</code></td>
<td>
<p>alpha vector, defaults as c(0.05, 0.01, 0.001).</p>
</td></tr>
<tr><td><code id="starsig_+3A_symbols">symbols</code></td>
<td>
<p>The default is c(&quot;*&quot;, &quot;**&quot;, &quot;***&quot;), corresponding
to mean that p values smaller than 0.05 receive one star,
values smaller than 0.01 get two stars, and so forth.  Must be
same number of elements as alpha. These need not be asterixes,
could be any character strings that users desire. See example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Recently, we have requests for different symbols. Some people want
a &quot;+&quot; symbol if the p value is smaller than 0.10 but greater than
0.05, while some want tiny smiley faces if p is smaller than
0.001. We accomodate that by allowing a user specified vector of
symbols, which defaults to c(&quot;*&quot;, &quot;**&quot;, &quot;***&quot;)
</p>


<h3>Value</h3>

<p>a character vector of symbols (eg asterixes), same length as pval
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>starsig(0.06)
starsig(0.021)
starsig(0.001)
alpha.ex &lt;- c(0.10, 0.05, 0.01, 0.001)
symb.ex &lt;- c("+", "*", "**", ":)!")
starsig(0.07, alpha = alpha.ex, symbols = symb.ex)
starsig(0.04, alpha = alpha.ex, symbols = symb.ex)
starsig(0.009, alpha = alpha.ex, symbols = symb.ex)
starsig(0.0009, alpha = alpha.ex, symbols = symb.ex)

</code></pre>

<hr>
<h2 id='statdatKey'>keyFactors: private function that does work for keyTemplateSPSS and
key template Stata</h2><span id='topic+statdatKey'></span>

<h3>Description</h3>

<p>keyFactors: private function that does work for keyTemplateSPSS and
key template Stata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statdatKey(datf, datn, long = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="statdatKey_+3A_datf">datf</code></td>
<td>
<p>Data frame with factors</p>
</td></tr>
<tr><td><code id="statdatKey_+3A_datn">datn</code></td>
<td>
<p>Numeric data frame</p>
</td></tr>
<tr><td><code id="statdatKey_+3A_long">long</code></td>
<td>
<p>Should the result be a long or wide key</p>
</td></tr>
</table>

<hr>
<h2 id='stringbreak'>Insert &quot;\n&quot; after the k'th character in a string. This IS vectorized,
so can receive just one or many character strings in a vector.</h2><span id='topic+stringbreak'></span>

<h3>Description</h3>

<p>If a string is long, insert linebreak &quot;\n&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stringbreak(x, k = 20)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stringbreak_+3A_x">x</code></td>
<td>
<p>Character string.</p>
</td></tr>
<tr><td><code id="stringbreak_+3A_k">k</code></td>
<td>
<p>Number of characters after which to insert &quot;\n&quot;. Default is 20</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If x is not a character string, x is returned without alteration. And
without a warning
</p>


<h3>Value</h3>

<p>Character with &quot;\n&quot; inserted
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "abcdef ghijkl mnopqrs tuvwxyz abc def ghi jkl mno pqr stv"
stringbreak(x, 10)
stringbreak(x, 20)
stringbreak(x, 25)
x &lt;- c("asdf asdfjl asfdjkl asdfjklasdfasd", "qrweqwer qwerqwerjklqw erjqwe")
stringbreak(x, 5)
</code></pre>

<hr>
<h2 id='truncsmart'>Cuts a string at a specified linewidth, trying to align cut with a
separator</h2><span id='topic+truncsmart'></span>

<h3>Description</h3>

<p>Some strings are simply too long. We don't want to chop them
exactly at, say, 40 characters, if we could allow 42 and chop on a
space or other separator. We'd rather chop at 37 if there is a
separator, rather than terminate a word exactly at 40. This function
shortens them and attempt to cut at a separator, allowing for a
user specified fudge-factor (the tol parameter).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truncsmart(
  x,
  target = 20,
  tol = c(5, 3),
  separators = c(" ", "_", ";", ","),
  capwidth = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="truncsmart_+3A_x">x</code></td>
<td>
<p>character or vector of characters</p>
</td></tr>
<tr><td><code id="truncsmart_+3A_target">target</code></td>
<td>
<p>Goal for result length, in characters</p>
</td></tr>
<tr><td><code id="truncsmart_+3A_tol">tol</code></td>
<td>
<p>number of characters forward/back to check; if single
value then only backwards checking</p>
</td></tr>
<tr><td><code id="truncsmart_+3A_separators">separators</code></td>
<td>
<p>characters at which truncation is preferred,
such as space or underscore.</p>
</td></tr>
<tr><td><code id="truncsmart_+3A_capwidth">capwidth</code></td>
<td>
<p>penalty for capital characters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default capwidth value is 1, so the calculations treat all
letters equally. In practice, we notice trouble when some strings
are written in ALL CAPS and they are longer than the same
information in lower case letters.  We have decided to allow a
user-specified penalty for capital letters. If each capital
counts for, say 1.2 ordinary letters, then we may end up truncating
the string on an earlier separator.
</p>
<p>There's some approximation here. The capital-penalized widths are
calculated for all characters and then we left-shift the target
value so that it is equal to the last penalized value that is
under the target length. Then the &quot;look to the left&quot; and &quot;look
to the right&quot; logic begins.  That looking logic ignores the
capital letter penalty, it is treating all letters the same.
</p>


<h3>Value</h3>

<p>shorter string truncated at acceptable separators when
found
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- "Aasdf asdIasdf fW_asd asd aasjdf_as fasdasdfasdfasd"
truncsmart(x, target = 10, tol = c(5, 2))
truncsmart(x, target = 10, tol = c(1, 4))
truncsmart(x, target = 10, tol = c(5, 2), capwidth = 1.2)
truncsmart(x, target = 20, tol = c(5, 2))
truncsmart(x, target = 20, tol = c(10,10), capwidth = 2)
truncsmart(x, target = 20, tol = c(10,10), capwidth = 3)
truncsmart(x, target = 20, tol = c(10,10), capwidth = 4)
truncsmart(x, target = 20, tol = c(10,10), capwidth = 6)
</code></pre>

<hr>
<h2 id='updatePackages'>Update packages, spot new dependencies, and install them</h2><span id='topic+updatePackages'></span>

<h3>Description</h3>

<p>Addresses the problem that updates for previously installed R
packages may insert new dependencies. R's update.packages does not
trigger the installation of packages that are added as new
requirements in existing packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updatePackages(
  ask = FALSE,
  checkBuilt = TRUE,
  dependencies = c("Depends", "Imports", "LinkingTo"),
  libnew = "/usr/share/R/library/",
  repos = options("repos"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updatePackages_+3A_ask">ask</code></td>
<td>
<p>If TRUE, asks user to select packages to update</p>
</td></tr>
<tr><td><code id="updatePackages_+3A_checkbuilt">checkBuilt</code></td>
<td>
<p>If TRUE, packages built under earlier versions
of R are to be considered 'old'</p>
</td></tr>
<tr><td><code id="updatePackages_+3A_dependencies">dependencies</code></td>
<td>
<p>A vector specifying which type of dependencies
need to be taken into account. We default to c(&quot;Depends&quot;,
&quot;Imports&quot;, &quot;LinkingTo&quot;).</p>
</td></tr>
<tr><td><code id="updatePackages_+3A_libnew">libnew</code></td>
<td>
<p>The R library folder into which the new packages
must be installed.  Defaults to &quot;/usr/share/R/library&quot;, which
is where EL7 likes those things.  To install packages in
personal user directory, put libnew = NULL.</p>
</td></tr>
<tr><td><code id="updatePackages_+3A_repos">repos</code></td>
<td>
<p>A vector of repositories on which to search for
packages. Same definition as in R's install.packages or
install.packages.</p>
</td></tr>
<tr><td><code id="updatePackages_+3A_...">...</code></td>
<td>
<p>additional arguments passed to update.packages and
install.packages</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks for existence of updates, ascertains whether
those packages impose new requirements, and installs any new
requirements. Then it conducts the update.
</p>
<p>This function is valuable in system maintenance because sometimes
existing packages adopt new requirements and the update.packages
function does not notice.  Another possible case would be that a user
accidentally deletes some packages without realizing other packages
depend on them.
</p>
<p>If this is run as the root/administrator privileged, then base R
packages may be updated, but if user is not root/administrator,
there will be a warning that packages were not updated because
permissions were lacking. For example
</p>
<p>&quot;Warning: package 'boot' in library '/usr/lib/R/library' will not
be updated.
</p>
<p>This warning does not interfere with rest of purpose of this
function, since the new dependencies can be installed in a place
where the user has privileges, either by specifying libnew as a
full directory name or by setting it to NULL, which puts new
packages in $R_LIBS_USER
</p>


<h3>Value</h3>

<p>A vector of new packages being installed
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
myrepos &lt;- c("http://rweb.crmda.ku.edu/cran",
             "http://www.bioconductor.org/packages/3.3/bioc")
updatePackages(repos = myrepos)
## libnew defaults to "/usr/share/R/library". Specify NULL
## so that new packages will go to user's directory
updatePackages(libnew = NULL)

## End(Not run)
</code></pre>

<hr>
<h2 id='varlabTemplate'>Create Variable Label Template</h2><span id='topic+varlabTemplate'></span>

<h3>Description</h3>

<p>Receive a key, create a varlab object, with columns
<code>name_old</code> <code>name_new</code>, and <code>varlab</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varlabTemplate(obj, varlab = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varlabTemplate_+3A_obj">obj</code></td>
<td>
<p>A variable key</p>
</td></tr>
<tr><td><code id="varlabTemplate_+3A_varlab">varlab</code></td>
<td>
<p>Default NULL, function will start from clean slate,
a set of column labels that match <code>name_new</code>. User can
specify values by providing a named vector of labels, e.g.,
<code>c("x1" = "happiness", "x2" = "wealth")</code>, where the names
are values to be matched against &quot;name_new&quot; in key.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If not specified, a matrix is created with empty variable labels.
</p>


<h3>Value</h3>

<p>Character matrix with columns <code>name_new</code> and <code>varlab</code>.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydf.path &lt;- system.file("extdata", "mydf.csv", package = "kutils")
mydf &lt;- read.csv(mydf.path, stringsAsFactors=FALSE)
mydf.keywide1 &lt;- keyTemplate(mydf, long = FALSE, sort = FALSE,
                    varlab = TRUE)
attr(mydf.keywide1, "varlab")
mydf.keywide2 &lt;- keyTemplate(mydf, long = FALSE, sort = FALSE,
                    varlab = c("x3" = "fun"))
attr(mydf.keywide2, "varlab")
attr(mydf.keywide2, "varlab") &lt;- varlabTemplate(mydf.keywide2,
                  varlab = c("x5" = "wealth", "x10" = "happy"))
attr(mydf.keywide2, "varlab")
attr(mydf.keywide2, "varlab") &lt;- varlabTemplate(mydf.keywide2,
                  varlab = TRUE)
attr(mydf.keywide2, "varlab")
## Target we are trying to match:
mydf.keylong &lt;- keyTemplate(mydf, long = TRUE, sort = FALSE, varlab = TRUE)
attr(mydf.keylong, "varlab")
attr(mydf.keylong, "varlab") &lt;- NULL
varlabTemplate(mydf.keylong)
attr(mydf.keylong, "varlab") &lt;- varlabTemplate(mydf.keylong,
                   varlab = c("x3" = "wealth", "x10" = "happy"))
attr(mydf.keylong, "varlab")
attr(mydf.keylong, "varlab") &lt;- varlabTemplate(mydf.keylong, varlab = TRUE)
attr(mydf.keylong, "varlab")
</code></pre>

<hr>
<h2 id='wide2long'>Convert a key object from wide to long format</h2><span id='topic+wide2long'></span>

<h3>Description</h3>

<p>This is not flexible, assumes columns are named in our canonical
style, which means the columns are named c(&quot;name_old&quot;, &quot;name_new&quot;,
&quot;class_old&quot;, &quot;class_new&quot;, &quot;value_old&quot;, &quot;value_new&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wide2long(
  key,
  sep = c(character = "\\|", logical = "\\|", integer = "\\|", factor = "\\|",
    ordered = "[\\|&lt;]", numeric = "\\|")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wide2long_+3A_key">key</code></td>
<td>
<p>A variable key in the wide format</p>
</td></tr>
<tr><td><code id="wide2long_+3A_sep">sep</code></td>
<td>
<p>Default separator is the pipe, &quot;\|&quot; for most
variables, while ordered accepts pipe or less than, &quot;\|&lt;&quot;. If
the key did not follow those customs, other sep values may be
specified for each variable class.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A long format variable key
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mydf.path &lt;- system.file("extdata", "mydf.csv", package = "kutils")
mydf &lt;- read.csv(mydf.path, stringsAsFactors=FALSE)
## Target we are trying to match:
mydf.keylong &lt;- keyTemplate(mydf, long = TRUE, sort = FALSE)

mydf.key &lt;- keyTemplate(mydf)
mydf.keywide2long &lt;- wide2long(mydf.key)

## rownames not meaningful in long key, so remove in both versions
row.names(mydf.keywide2long) &lt;- NULL
row.names(mydf.keylong) &lt;- NULL
all.equal(mydf.keylong, mydf.keywide2long)
</code></pre>

<hr>
<h2 id='writeCSV'>Write CSV files with quotes same as MS Excel 2013 or newer</h2><span id='topic+writeCSV'></span>

<h3>Description</h3>

<p>R's write.csv inserts quotes around all elements in a character
vector (if quote = TRUE).  In contrast, MS Excel CSV export no
longer inserts quotation marks on all elements in character
variables, except when the cells include commas or quotation
marks.  This function generates CSV files that are, so far as we
know, exactly the same &quot;quoted style&quot; as MS Excel CSV export
files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeCSV(x, file, row.names = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeCSV_+3A_x">x</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="writeCSV_+3A_file">file</code></td>
<td>
<p>character string for file name</p>
</td></tr>
<tr><td><code id="writeCSV_+3A_row.names">row.names</code></td>
<td>
<p>Default FALSE for row.names</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This works by manually inserting quotation marks where necessary and
turning FALSE R's own method to insert quotation marks.
</p>


<h3>Value</h3>

<p>the return from write.table, using revised quotes
</p>


<h3>Author(s)</h3>

<p>Paul Johnson
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(234)
x1 &lt;- data.frame(x1 = c("a", "b,c", "b", "The \"Washington, DC\""),
      x2 = rnorm(4), stringsAsFactors = FALSE)
x1
fn &lt;- tempfile(pattern = "testcsv", fileext = ".csv")
writeCSV(x1, file = fn)
readLines(fn)
x2 &lt;- read.table(fn, sep = ",", header = TRUE, stringsAsFactors = FALSE)
all.equal(x1,x2)
</code></pre>

<hr>
<h2 id='zapspace'>Convert leading or trailing white space and tab characters to nothing.</h2><span id='topic+zapspace'></span>

<h3>Description</h3>

<p>This eliminates any characters matched by the regular expression
'\s' if they appear at the beginning of a string or at its
end. It does not alter spaces in the interior of a string. This
was created when I was not aware of R's <code>trimws</code> and the purpose
is the same. On our TODO list, we intend to eliminate this function
and replace its use with <code>trimws</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zapspace(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zapspace_+3A_x">x</code></td>
<td>
<p>A character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If x is a character vector, return is a character vector
with leading and trailing white space values removed. If x is
not a character vector, an unaltered x is returned.
</p>


<h3>Author(s)</h3>

<p>Paul Johnson &lt;pauljohn@ku.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;-  c("", " ", "   ", "\t", "\t some", "some\t", " space first")
zapspace(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
