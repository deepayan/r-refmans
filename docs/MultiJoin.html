<!DOCTYPE html><html><head><title>Help for package MultiJoin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MultiJoin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ArtificialData'><p>create artificial data for testing</p></a></li>
<li><a href='#CountColumns'><p>count columns of files</p></a></li>
<li><a href='#FullJoin'><p>create command to fully join multiple (more than 2) files</p></a></li>
<li><a href='#FullJoinPairs'><p>create command to fully join lines of two files on a common field</p></a></li>
<li><a href='#LeftJoinPairs'><p>create command to left join lines of two files on a common field with no further options</p></a></li>
<li><a href='#MakeFIFOs'><p>creates named Unix pipes, which gzipped files can be streamed to for e.g. further joins</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Enables Efficient Joining of Data File on Common Fields using
the Unix Utility Join</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-11-10</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), graphics, stats, utils</td>
</tr>
<tr>
<td>Author:</td>
<td>"Markus Loecher, Berlin School of Economics and Law (BSEL)" &lt;markus.loecher@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>"Markus Loecher" &lt;markus.loecher@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Wrapper around the Unix join facility which is more efficient than the built-in R routine merge().
 The package enables the joining of multiple files on disk at once. 
 The files can be compressed and various filters can be deployed before joining.
 Compiles only under Unix.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-11-15 14:10:12 UTC; loecherm</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-11-15 22:10:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='ArtificialData'>create artificial data for testing</h2><span id='topic+ArtificialData'></span>

<h3>Description</h3>

<p>This function allows quick generation of a test data set which can be used with the majority of the Join functions</p>


<h3>Usage</h3>

<pre><code class='language-R'>ArtificialData(fakeDataDir = "~/fakeData2/", joinKey = letters[1:20], 


    numFiles = 4, N = rep(15, numFiles), SORT = 1, GZIP = 0, 


    sep = c(" ", ",", "\t", "|")[1], prefix = "file", suffix = ".txt", 


    daten = month.abb, NCOL = rep(3, numFiles), chunkSize = 1000, 


    verbose = 0)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ArtificialData_+3A_fakedatadir">fakeDataDir</code></td>
<td>
<p>directory to put the data</p>
</td></tr>
<tr><td><code id="ArtificialData_+3A_joinkey">joinKey</code></td>
<td>
<p>set of join keys to choose from (has to be longer than N) - this column will be the key for join</p>
</td></tr>
<tr><td><code id="ArtificialData_+3A_numfiles">numFiles</code></td>
<td>
<p>number of files to split the data across</p>
</td></tr>
<tr><td><code id="ArtificialData_+3A_n">N</code></td>
<td>
<p>number of rows in each file created, e.g. N = c(15,20,10,30)</p>
</td></tr>
<tr><td><code id="ArtificialData_+3A_sort">SORT</code></td>
<td>
<p>should the join key be sorted?</p>
</td></tr>
<tr><td><code id="ArtificialData_+3A_gzip">GZIP</code></td>
<td>
<p>should the data files created by gzipped?</p>
</td></tr>
<tr><td><code id="ArtificialData_+3A_sep">sep</code></td>
<td>
<p>column delimiter; default white space</p>
</td></tr>
<tr><td><code id="ArtificialData_+3A_prefix">prefix</code></td>
<td>
<p>file name prefix</p>
</td></tr>
<tr><td><code id="ArtificialData_+3A_suffix">suffix</code></td>
<td>
<p>file name suffix</p>
</td></tr>
<tr><td><code id="ArtificialData_+3A_daten">daten</code></td>
<td>
<p>data to sample from</p>
</td></tr>
<tr><td><code id="ArtificialData_+3A_ncol">NCOL</code></td>
<td>
<p>number of data columns per file</p>
</td></tr>
<tr><td><code id="ArtificialData_+3A_chunksize">chunkSize</code></td>
<td>
<p>write that many lines to the file at once</p>
</td></tr>
<tr><td><code id="ArtificialData_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisibly return data and file names</p>


<h3>Author(s)</h3>

<p>&quot;Markus Loecher, Berlin School of Economics and Law (BSEL)&quot; &lt;markus.loecher@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (0){


  ArtificialData("fakeData2",verbose=1)


  ArtificialData("fakeData2",joinKey = 1:2000, N = rep(1500,4) ,verbose=0)


  


  ret = ArtificialData(fakeDataDir="/tmp/fakeData")


  ret = ArtificialData(fakeDataDir="./fakeData", joinKey=letters[1:10], numFiles = 6, N = rep(5,6))


  ret = ArtificialData(SORT = 1, GZIP = 1)





  ret = ArtificialData(fakeDataDir="fakeData", joinKey = 0:9, N = rep(6, 4), verbose=1)


  #on allegro:


  ret = ArtificialData(fakeDataDir="./fakeData", joinKey=letters, numFiles = 10, 


                       N = rep(18,10), NCOL=rep(5,10))


}


</code></pre>

<hr>
<h2 id='CountColumns'>count columns of files</h2><span id='topic+CountColumns'></span>

<h3>Description</h3>

<p>small helper function that attempts to count how many columns there are in a file</p>


<h3>Usage</h3>

<pre><code class='language-R'>CountColumns(files = c("ftr1.txt", "ftr2.txt"), sep = c(" ", 


    ",", "\t", "|")[1], mycat = c("", "gunzip -cf ", "cat ")[1], 


    filterStr = "", verbose = 0, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CountColumns_+3A_files">files</code></td>
<td>
<p>which files to inspect</p>
</td></tr>
<tr><td><code id="CountColumns_+3A_sep">sep</code></td>
<td>
<p>column delimiter; default white space</p>
</td></tr>
<tr><td><code id="CountColumns_+3A_mycat">mycat</code></td>
<td>
<p>effective cat command, if empty do NOT use FIFos</p>
</td></tr>
<tr><td><code id="CountColumns_+3A_filterstr">filterStr</code></td>
<td>
<p>various inline filters that act locally and do not need an input file,</p>
</td></tr>
<tr><td><code id="CountColumns_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
<tr><td><code id="CountColumns_+3A_...">...</code></td>
<td>
<p>further arguments to myjoin such as missingValue or extraARGS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns number of columns of each file</p>


<h3>Author(s)</h3>

<p>&quot;Markus Loecher, Berlin School of Economics and Law (BSEL)&quot; &lt;markus.loecher@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (0){


  ret = ArtificialData(fakeDataDir="fakeData2", joinKey = 0:9, N = rep(6, 4), verbose=1)


  CountColumns(paste0("fakeData2/file",1:4,".txt"))


  #gzipped data:


  ret = ArtificialData(fakeDataDir="fakeData2", joinKey = 0:9, N = rep(6, 4), GZIP=1, verbose=1)


  CountColumns(paste0("fakeData2/file",1:4,".txt.gz"),mycat ="gunzip -cf ")


  #gzipped and selected columns:  


  ret = ArtificialData(fakeDataDir="fakeData2", joinKey = 0:9, N = rep(6, 4), GZIP=1, verbose=1)


  CountColumns(paste0("fakeData2/file",1:4,".txt.gz"),mycat ="gunzip -cf ", 


               filterStr=" | cut -f1,3 -d\" \" ")


}


</code></pre>

<hr>
<h2 id='FullJoin'>create command to fully join multiple (more than 2) files</h2><span id='topic+FullJoin'></span>

<h3>Description</h3>

<p>Iteratively calls the function FullJoinPairs() to join lines of two files on a common field</p>


<h3>Usage</h3>

<pre><code class='language-R'>FullJoin(files = c("ftr1.txt", "ftr2.txt"), prefix = " time ", 


    suffix = " &gt; joined.txt", myjoin = FullJoinPairs, NumFields = rep(2, 


        length(files)), sep = c(" ", ",", "\t", "|")[1], mycat = c("", 


        "gunzip -cf ", "cat ")[1], filterStr = "", ReturnData = FALSE, 


    verbose = 2, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FullJoin_+3A_files">files</code></td>
<td>
<p>which files to join</p>
</td></tr>
<tr><td><code id="FullJoin_+3A_prefix">prefix</code></td>
<td>
<p>any convenience prefix command to be passed to the beginning of the Unix command to be executed</p>
</td></tr>
<tr><td><code id="FullJoin_+3A_suffix">suffix</code></td>
<td>
<p>any convenience suffix command to be passed to the end of the Unix command to be executed</p>
</td></tr>
<tr><td><code id="FullJoin_+3A_myjoin">myjoin</code></td>
<td>
<p>the particular Join function from the package to use</p>
</td></tr>
<tr><td><code id="FullJoin_+3A_numfields">NumFields</code></td>
<td>
<p>this includes the userid column</p>
</td></tr>
<tr><td><code id="FullJoin_+3A_sep">sep</code></td>
<td>
<p>column delimiter; default white space</p>
</td></tr>
<tr><td><code id="FullJoin_+3A_mycat">mycat</code></td>
<td>
<p>effective cat command, if empty do NOT use FIFos</p>
</td></tr>
<tr><td><code id="FullJoin_+3A_filterstr">filterStr</code></td>
<td>
<p>various inline filters that act locally and do not need an input file,</p>
</td></tr>
<tr><td><code id="FullJoin_+3A_returndata">ReturnData</code></td>
<td>
<p>should the result of the join command be read into R and returned as a dataframe?</p>
</td></tr>
<tr><td><code id="FullJoin_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
<tr><td><code id="FullJoin_+3A_...">...</code></td>
<td>
<p>further arguments to myjoin such as missingValue or extraARGS</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns command only</p>


<h3>Author(s)</h3>

<p>&quot;Markus Loecher, Berlin School of Economics and Law (BSEL)&quot; &lt;markus.loecher@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (0){


  #no FIFOs:


  FullJoin(NumFields = rep(4,2))


  FullJoin(paste0("ftr",1:4,".txt"), NumFields = rep(4, 4), suffix = " | gzip &gt; joined.txt.gz")


  FullJoin(paste0("ftr",1:4,".txt"), NumFields = rep(3, 4),missingValue="0", suffix = "")


  #with FIFOs:


  FullJoin(paste0("ftr",1:4,".txt"), mycat = "cat ", NumFields = rep(3, 4),missingValue="0", 


           suffix = "", verbose=2)


  FullJoin(paste0("ftr",1:3,".txt.gz"), mycat = "gunzip -cf ", filterStr = " | cut -f1,3", 


           NumFields = rep(2, 3), verbose=2)


  #selected columns only:


  FullJoin(paste0("ftr",1:3,".txt"), mycat = "cat ", filterStr = "cut -f1,3",  


           NumFields = rep(2, 3),missingValue="0", suffix = "", verbose=2)


  


  ret = ArtificialData(fakeDataDir="./fakeData2", joinKey=letters, numFiles = 10, 


                       N = rep(18,10), NCOL=rep(5,10))


  FullJoin(paste0("./fakeData2/file",1:10,".txt"),missingValue="0", suffix = "", verbose=2)


  


  # let's try FIFOs:


  #small:


  cmd = FullJoin(paste0("file",1:2,".txt"), mycat = "cat ", NumFields = rep(5, 2),


                 missingValue="0", suffix = " &gt; joined.txt", verbose=2)


  


  cmd = FullJoin(paste0("file",1:3,".txt"), mycat = "cat ", NumFields = rep(5, 3),


                 missingValue="0", suffix = " &gt; joined.txt", verbose=2)


  


  # and now gzipped files:


  ret = ArtificialData(fakeDataDir="./fakeData", joinKey=letters, numFiles = 10,GZIP =1, 


                       N = rep(18,10), NCOL=rep(5,10))


  cmd = FullJoin(paste0("./fakeData/file",1:10,".txt.gz"), mycat = "gunzip -c ",  


                 NumFields = rep(3, 10),missingValue="NA",


                 filterStr = " | cut -f1,2,3",


                 suffix = "  &gt; joined.txt", verbose=2)


  


  x = FullJoin(paste0("./fakeData/file",1:10,".txt.gz"), mycat = "gunzip -c ",  


               NumFields = rep(3, 10),missingValue="NA",


               filterStr = " | cut -f1,2,3",ReturnData=TRUE,


               suffix = "", verbose=0)


}


#let us try a laarge example





#uids = sort(paste0(sample(LETTERS,10^7,replace=TRUE), sample(10^8,10^7)))


#uids = paste0(LETTERS, (10^7):(10^8))


#tmp=expand.grid(LETTERS,LETTERS,LETTERS,0:9,0:9);str(tmp)


#uids=apply(expand.grid(LETTERS[1:3],LETTERS[1:3],0:2,0:3),1,paste0,collapse="")


#uids=apply(expand.grid(LETTERS,LETTERS,LETTERS,0:9,0:9),1,paste0,collapse="")


if (0) {


  uids = scan("uids.txt",what="")


  Nfiles=100          


  ret = ArtificialData(fakeDataDir="./fakeData", joinKey=uids, 


                 numFiles = Nfiles, GZIP =1, N = rep(10^5,Nfiles), NCOL=rep(10,Nfiles))


  cmd = FullJoin(paste0("fakeData/file",1:10,".txt.gz"), mycat = "gunzip -c ",  


                 NumFields = rep(3, 10),missingValue="NA",


                 filterStr = " | cut -f1,2,3",


                 suffix = " | gzip &gt; ./fakeData/joined.txt.gz", verbose=2)


  system("rm /tmp/fifo*")


  for (go in cmd) system(go)


  


  x = FullJoin(paste0("./fakeData/file",1:10,".txt.gz"), mycat = "gunzip -c ",  


               NumFields = rep(3, 10),missingValue="NA",


               filterStr = " | cut -f1,2,3",ReturnData=TRUE,


               suffix = "", prefix="", verbose=0)


}





</code></pre>

<hr>
<h2 id='FullJoinPairs'>create command to fully join lines of two files on a common field</h2><span id='topic+FullJoinPairs'></span>

<h3>Description</h3>

<p>Calls the Unix utilitiy join to join lines of two files on a common field
</p>
<p>The -a option is set for both files such that also unpairable lines are printed.</p>


<h3>Usage</h3>

<pre><code class='language-R'>FullJoinPairs(f1, f2, j1 = 1, j2 = 1, o1 = 2:4, o2 = 2:4, missingValue = "NA", 


    sep = c(" ", ",", "\t", "|")[1], extraARGS = "")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FullJoinPairs_+3A_f1">f1</code></td>
<td>
<p>filename of first file</p>
</td></tr>
<tr><td><code id="FullJoinPairs_+3A_f2">f2</code></td>
<td>
<p>filename of second file</p>
</td></tr>
<tr><td><code id="FullJoinPairs_+3A_j1">j1</code></td>
<td>
<p>join on this FIELD of file 1</p>
</td></tr>
<tr><td><code id="FullJoinPairs_+3A_j2">j2</code></td>
<td>
<p>join on this FIELD of file 2</p>
</td></tr>
<tr><td><code id="FullJoinPairs_+3A_o1">o1</code></td>
<td>
<p>obey this FORMAT while constructing output line from file 1 (NCOL1 would be the number of columns of file 1)</p>
</td></tr>
<tr><td><code id="FullJoinPairs_+3A_o2">o2</code></td>
<td>
<p>obey this FORMAT while constructing output line from file 2 (NCOL2 would be the number of columns of file 2)</p>
</td></tr>
<tr><td><code id="FullJoinPairs_+3A_missingvalue">missingValue</code></td>
<td>
<p>replace missing input fields with missingValue</p>
</td></tr>
<tr><td><code id="FullJoinPairs_+3A_sep">sep</code></td>
<td>
<p>column delimiter; default white space</p>
</td></tr>
<tr><td><code id="FullJoinPairs_+3A_extraargs">extraARGS</code></td>
<td>
<p>extra (optional) arguments to be passed to the join function (such as &ndash;check-order or &ndash;header or &ndash;ignore-case)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each output line is constructed according to the FORMAT in the -o option. Each element in FIELD-LIST is either the single
</p>
<p>character 0 or has the form M.N where the file number, M, is 1 or 2 and N is a positive field number.
</p>
<p>A field specification of 0 denotes the join field.  In most
</p>
<p>cases, the functionality of the 0 field spec may be reproduced
</p>
<p>using the explicit M.N that corresponds to the join field.
</p>
<p>However, when printing unpairable lines (using either of the -a
</p>
<p>or -v options), there is no way to specify the join field using
</p>
<p>M.N in FIELD-LIST if there are unpairable lines in both files.  To
</p>
<p>give join that functionality, POSIX invented the 0 field
</p>
<p>specification notation.
</p>
<p>The elements in FIELD-LIST are separated by commas or blanks.
</p>
<p>Blank separators typically need to be quoted for the shell.  For
</p>
<p>example, the commands join -o 1.2,2.2 and join -o 1.2 2.2
</p>
<p>are equivalent.</p>


<h3>Value</h3>

<p>returns command</p>


<h3>Note</h3>

<p>Important:  FILE1  and  FILE2 must be sorted on the join fields. If you are unsure, pass the &ndash;check-order flag
</p>
<p>Note, comparisons honor the rules specified by LC_COLLATE.</p>


<h3>Author(s)</h3>

<p>&quot;Markus Loecher, Berlin School of Economics and Law (BSEL)&quot; &lt;markus.loecher@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (0){


  ret = ArtificialData(fakeDataDir=tempdir(), numFiles=2,NCOL = rep(4,2))


  FullJoinPairs(ret$fnames[[1]][1], ret$fnames[[2]][1], o1=2:4, o2 = 2:4)


}


</code></pre>

<hr>
<h2 id='LeftJoinPairs'>create command to left join lines of two files on a common field with no further options</h2><span id='topic+LeftJoinPairs'></span>

<h3>Description</h3>

<p>Calls the Unix utilitiy join to join lines of two files on a common field. No unpairable lines are printed</p>


<h3>Usage</h3>

<pre><code class='language-R'>LeftJoinPairs(f1, f2, j1 = 1, j2 = 1, missingValue = "NA", sep = c(" ", 


    ",", "\t", "|")[1], extraARGS = "")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LeftJoinPairs_+3A_f1">f1</code></td>
<td>
<p>filename of first file</p>
</td></tr>
<tr><td><code id="LeftJoinPairs_+3A_f2">f2</code></td>
<td>
<p>filename of second file</p>
</td></tr>
<tr><td><code id="LeftJoinPairs_+3A_j1">j1</code></td>
<td>
<p>join on this FIELD of file 1</p>
</td></tr>
<tr><td><code id="LeftJoinPairs_+3A_j2">j2</code></td>
<td>
<p>join on this FIELD of file 2</p>
</td></tr>
<tr><td><code id="LeftJoinPairs_+3A_missingvalue">missingValue</code></td>
<td>
<p>replace missing input fields with missingValue</p>
</td></tr>
<tr><td><code id="LeftJoinPairs_+3A_sep">sep</code></td>
<td>
<p>column delimiter; default white space</p>
</td></tr>
<tr><td><code id="LeftJoinPairs_+3A_extraargs">extraARGS</code></td>
<td>
<p>extra (optional) arguments to be passed to the join function (such as &ndash;check-order or &ndash;header or &ndash;ignore-case)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each output line is constructed according to the FORMAT in the -o option. Each element in FIELD-LIST is either the single
</p>
<p>character 0 or has the form M.N where the file number, M, is 1 or 2 and N is a positive field number.
</p>
<p>A field specification of 0 denotes the join field.  In most
</p>
<p>cases, the functionality of the 0 field spec may be reproduced
</p>
<p>using the explicit M.N that corresponds to the join field.
</p>
<p>However, when printing unpairable lines (using either of the -a
</p>
<p>or -v options), there is no way to specify the join field using
</p>
<p>M.N in FIELD-LIST if there are unpairable lines in both files.  To
</p>
<p>give join that functionality, POSIX invented the 0 field
</p>
<p>specification notation.
</p>
<p>The elements in FIELD-LIST are separated by commas or blanks.
</p>
<p>Blank separators typically need to be quoted for the shell.  For
</p>
<p>example, the commands join -o 1.2,2.2 and join -o 1.2 2.2
</p>
<p>are equivalent.</p>


<h3>Value</h3>

<p>Unix command to be executed</p>


<h3>Note</h3>

<p>Important:  FILE1  and  FILE2 must be sorted on the join fields. If you are unsure, pass the &ndash;check-order flag
</p>
<p>Note, comparisons honor the rules specified by LC_COLLATE.</p>


<h3>Author(s)</h3>

<p>&quot;Markus Loecher, Berlin School of Economics and Law (BSEL)&quot; &lt;markus.loecher@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (0){


  LeftJoinPairs("f1.txt","f2.txt")


  


  #tab delimiter:


  ret = ArtificialData(fakeDataDir="/tmp/fakeData2",sep = "\t")


  cmd = LeftJoinPairs("/tmp/fakeData2/file1.txt","/tmp/fakeData2/file2.txt",sep = "\t")


 # cat(cmd, file = "/tmp/tmp.sh")


#  system("bash /tmp/tmp.sh")


}


</code></pre>

<hr>
<h2 id='MakeFIFOs'>creates named Unix pipes, which gzipped files can be streamed to for e.g. further joins</h2><span id='topic+MakeFIFOs'></span>

<h3>Description</h3>

<p>Additional filters can be implemented based upon the input arguments.
</p>
<p>This string is typically used in between pipes. </p>


<h3>Usage</h3>

<pre><code class='language-R'>MakeFIFOs(file = "file1.txt.gz", FIFO = "/tmp/fifo1", path = ".", 


    filterStr = " | cut -f2,3 -d\" \" --complement", mycat = "gunzip -cf ", 


    verbose = 2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MakeFIFOs_+3A_file">file</code></td>
<td>
<p>Name of the file that contains the data to uncompress and filter on</p>
</td></tr>
<tr><td><code id="MakeFIFOs_+3A_fifo">FIFO</code></td>
<td>
<p>Name of the FIFO to create</p>
</td></tr>
<tr><td><code id="MakeFIFOs_+3A_path">path</code></td>
<td>
<p>Directory to find the files in</p>
</td></tr>
<tr><td><code id="MakeFIFOs_+3A_filterstr">filterStr</code></td>
<td>
<p>various inline filters that act locally and do not need an input file,</p>
</td></tr>
<tr><td><code id="MakeFIFOs_+3A_mycat">mycat</code></td>
<td>
<p>effective cat command</p>
</td></tr>
<tr><td><code id="MakeFIFOs_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>filter string</p>


<h3>Author(s)</h3>

<p>&quot;Markus Loecher, Berlin School of Economics and Law (BSEL)&quot; &lt;markus.loecher@gmail.com&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (0){


  MakeFIFOs(verbose=2)


  MakeFIFOs(filterStr=" | awk '$2 &gt; 100 &amp;&amp; $3 &gt; 5' | 


          cut -f2,3 -d\" \" --complement | head -n 10000 | sort -k1,1")


}


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
