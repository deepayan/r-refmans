<!DOCTYPE html><html><head><title>Help for package enmpa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {enmpa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cal_res'><p>Example of results obtained from GLM calibration using enmpa</p></a></li>
<li><a href='#calibration_glm'><p>GLM calibration with presence-absence data</p></a></li>
<li><a href='#enm_data'><p>Example data used to run model calibration exercises</p></a></li>
<li><a href='#enmpa'><p>enmpa: Ecological Niche Modeling using Presence-Absence Data</p></a></li>
<li><a href='#evaluation_stats'><p>Summary of evaluation statistics for candidate models</p></a></li>
<li><a href='#fit_selected'><p>Fitting selected GLMs models</p></a></li>
<li><a href='#get_formulas'><p>Get GLM formulas according to defined response types</p></a></li>
<li><a href='#independent_eval1'><p>Evaluate final models using independent data</p></a></li>
<li><a href='#kfold_partition'><p>K-fold data partitioning</p></a></li>
<li><a href='#model_selection'><p>Selection of best candidate models considering various criteria</p></a></li>
<li><a href='#model_validation'><p>Model validation options</p></a></li>
<li><a href='#niche_signal'><p>Niche Signal detection using one or multiple variables</p></a></li>
<li><a href='#optimize_metrics'><p>Find threshold values to produce three optimal metrics</p></a></li>
<li><a href='#plot_importance'><p>Plot variable importance</p></a></li>
<li><a href='#plot_niche_signal'><p>Plot Niche Signal results</p></a></li>
<li><a href='#predict_glm'><p>Extension of glm predict to generate predictions of different types</p></a></li>
<li><a href='#predict_selected'><p>Predictions for the models selected after calibration</p></a></li>
<li><a href='#proc_enm'><p>Partial ROC calculation</p></a></li>
<li><a href='#response_curve'><p>Variable response curves for GLMs</p></a></li>
<li><a href='#sel_fit'><p>Example of selected models fitted</p></a></li>
<li><a href='#test'><p>Example data used to test models</p></a></li>
<li><a href='#var_importance'><p>Variable importance for GLMs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Ecological Niche Modeling using Presence-Absence Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luis F. Arias-Giraldo &lt;lfarias.giraldo@gmail.com&gt;</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-30</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of tools to perform Ecological Niche Modeling with
    presence-absence data. It includes algorithms for data partitioning, 
    model fitting, calibration, evaluation, selection, and prediction. 
    Other functions help to explore signals of ecological niche using univariate
    and multivariate analyses, and model features such as variable response 
    curves and variable importance. Unique characteristics of this package are
    the ability to exclude models with concave quadratic responses, and the
    option to clamp model predictions to specific variables. These tools are
    implemented following principles proposed in
    Cobos et al., (2022) &lt;<a href="https://doi.org/10.17161%2Fbi.v17i.15985">doi:10.17161/bi.v17i.15985</a>&gt;, 
    Cobos et al., (2019) &lt;<a href="https://doi.org/10.7717%2Fpeerj.6281">doi:10.7717/peerj.6281</a>&gt;, 
    and Peterson et al., (2008) &lt;<a href="https://doi.org/10.1016%2Fj.ecolmodel.2007.11.008">doi:10.1016/j.ecolmodel.2007.11.008</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Luisagi/enmpa">https://github.com/Luisagi/enmpa</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Luisagi/enmpa/issues">https://github.com/Luisagi/enmpa/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>doSNOW, ellipse, foreach, graphics, methods, mgcv, parallel,
Rcpp, snow, stats, terra, utils, vegan</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-01 08:27:52 UTC; luisagi</td>
</tr>
<tr>
<td>Author:</td>
<td>Luis F. Arias-Giraldo
    <a href="https://orcid.org/0000-0003-4861-8064"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Marlon E. Cobos <a href="https://orcid.org/0000-0002-2611-1767"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  A. Townsend Peterson
    <a href="https://orcid.org/0000-0003-0243-2379"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-01 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cal_res'>Example of results obtained from GLM calibration using enmpa</h2><span id='topic+cal_res'></span>

<h3>Description</h3>

<p>A list of results from GLM calibration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cal_res
</code></pre>


<h3>Format</h3>

<p>A list with results from the function <code style="white-space: pre;">&#8288;\link{calibration_glm}&#8288;</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("cal_res", package = "enmpa")

str(cal_res)
</code></pre>

<hr>
<h2 id='calibration_glm'>GLM calibration with presence-absence data</h2><span id='topic+calibration_glm'></span>

<h3>Description</h3>

<p>Creates candidate models based on distinct parameter settings, evaluates
models, and selects the ones that perform the best.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calibration_glm(data, dependent, independent, weights = NULL,
                response_type = "l", formula_mode = "moderate",
                minvar = 1, maxvar = NULL, user_formulas = NULL,
                cv_kfolds = 5, partition_index = NULL, seed = 1,
                n_threshold = 100, selection_criterion = "TSS",
                exclude_bimodal = FALSE, tolerance = 0.01,
                out_dir = NULL, parallel = FALSE,
                n_cores = NULL, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calibration_glm_+3A_data">data</code></td>
<td>
<p>data.frame or matrix of data to be used in model calibration.
Columns represent dependent and independent variables.</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_dependent">dependent</code></td>
<td>
<p>(character) name of dependent variable.</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_independent">independent</code></td>
<td>
<p>(character) vector of name(s) of independent variable(s).</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_weights">weights</code></td>
<td>
<p>(numeric) a vector with the weights for observations.</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_response_type">response_type</code></td>
<td>
<p>(character) a character string that must contain &quot;l&quot;,
&quot;p&quot;, &quot;q&quot; or a combination of them. l = lineal, q = quadratic,
p = interaction between two variables. Default = &quot;l&quot;.</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_formula_mode">formula_mode</code></td>
<td>
<p>(character) a character string to indicate the strategy to
create the formulas for candidate models. Options are: &quot;light&quot;, &quot;moderate&quot;,
&quot;intensive&quot;, or &quot;complex&quot;. Default = &quot;moderate&quot;. &quot;complex&quot; returns only the
most complex formula defined in <code>response_type</code>.</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_minvar">minvar</code></td>
<td>
<p>(numeric) minimum number of independent variables in formulas.</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_maxvar">maxvar</code></td>
<td>
<p>(numeric) maximum number of independent variables in formulas.</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_user_formulas">user_formulas</code></td>
<td>
<p>(character) vector  with formula(s) to test.
Default = NULL.</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_cv_kfolds">cv_kfolds</code></td>
<td>
<p>(numeric) number of folds to use for k-fold
cross-validation exercises. Default = 5. Ignored if <code>partition_index</code>
is defined.</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_partition_index">partition_index</code></td>
<td>
<p>list of indices for cross-validation in k-fold. The
default, NULL, uses the function <code><a href="#topic+kfold_partition">kfold_partition</a></code>.</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_seed">seed</code></td>
<td>
<p>(numeric) a seed for k-fold partitioning.</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_n_threshold">n_threshold</code></td>
<td>
<p>(logical) number of threshold values to produce
evaluation metrics. Default = 100.</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_selection_criterion">selection_criterion</code></td>
<td>
<p>(character) criterion used to select best models,
options are &quot;TSS&quot; and &quot;ESS&quot;. Default = &quot;TSS&quot;.</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_exclude_bimodal">exclude_bimodal</code></td>
<td>
<p>(logical) whether to filter out models with one or
more variables presenting concave responses. Default = FALSE.</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_tolerance">tolerance</code></td>
<td>
<p>(numeric) value to modify the limit value of the metric
used to filter models during model selection if none of the models meet
initial considerations. Default = 0.01</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_out_dir">out_dir</code></td>
<td>
<p>(character) output directory name to save the main calibration
results. Default = NULL.</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_parallel">parallel</code></td>
<td>
<p>(logical) whether to run on parallel or sequential.
Default = FALSE.</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_n_cores">n_cores</code></td>
<td>
<p>(numeric) number of cores to use. Default = number of free
processors - 1.</p>
</td></tr>
<tr><td><code id="calibration_glm_+3A_verbose">verbose</code></td>
<td>
<p>(logical) whether to print messages and show progress bar.
Default = TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Model evaluation is done considering the ability to predict presences and
absences,as well as model fitting and complexity. Model selection consists
of three steps: 1) a first filter to keep the models with ROC AUC &gt;= 0.5
(statistically significant models), 2) a second filter to maintain only
models that meet the <code>selection_criterion</code> (&quot;TSS&quot;: TSS &gt;= 0.4; or &quot;ESS&quot;:
maximum Accuracy - <code>tolerance</code>), and 3) from those, pick the ones with
delta AIC &lt;= 2.
</p>
<p><code>formula_mode</code> options determine what strategy to iterate the predictors
defined in <code>type</code> for creating models:
</p>

<ul>
<li> <p><strong>light</strong>.&ndash; returns simple iterations of complex formulas.
</p>
</li>
<li> <p><strong>moderate</strong>.&ndash; returns a comprehensive number of iterations.
</p>
</li>
<li> <p><strong>intensive</strong>.&ndash; returns all possible combination. Very time-consuming for
6 or more independent variables.
</p>
</li>
<li> <p><strong>complex</strong>.&ndash; returns only the most complex formula.
</p>
</li></ul>



<h3>Value</h3>

<p>A list containing: selected models, a summary of statistics for all models,
results obtained in cross-validation for all models, original data used,
weights, and data-partition indices used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load species occurrences and environmental data.
data("enm_data", package = "enmpa")
head(enm_data)

# Calibration using linear (l), quadratic (q), products(p) responses.
cal_res &lt;- calibration_glm(data = enm_data, dependent = "Sp",
                           independent = c("bio_1", "bio_12"),
                           response_type = "lpq", formula_mode = "moderate",
                           selection_criterion = "TSS", cv_kfolds = 3,
                           exclude_bimodal = TRUE, verbose = FALSE)

head(cal_res$calibration_results)
head(cal_res$summary)
head(cal_res$selected)
head(cal_res$data)

</code></pre>

<hr>
<h2 id='enm_data'>Example data used to run model calibration exercises</h2><span id='topic+enm_data'></span>

<h3>Description</h3>

<p>A dataset containing information on presence and absence, and
independent variables used to fit GLM models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enm_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 5627 rows and 3 columns.
</p>

<dl>
<dt>Sp</dt><dd><p>numeric, values of 0 = absence and 1 = presence.</p>
</dd>
<dt>bio_1</dt><dd><p>numeric, temperature values.</p>
</dd>
<dt>bio_12</dt><dd><p>numeric, precipitation values.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("enm_data", package = "enmpa")
head(enm_data)
</code></pre>

<hr>
<h2 id='enmpa'>enmpa: Ecological Niche Modeling using Presence-Absence Data</h2><span id='topic+enmpa'></span>

<h3>Description</h3>

<p><code>enmpa</code> contains a set of tools to perform detailed Ecological Niche Modeling
using presence-absence data.
</p>


<h3>Details</h3>

<p>It includes algorithms for data partitioning, model fitting, calibration,
evaluation, selection, and prediction. Other functions help to explore model
features as such variable response curves and variable importance.
</p>


<h3>Main functions in <code>enmpa</code></h3>

<p><code><a href="#topic+calibration_glm">calibration_glm</a></code>, <code><a href="#topic+evaluation_stats">evaluation_stats</a></code>,
<code><a href="#topic+fit_glms">fit_glms</a></code>, <code><a href="#topic+fit_selected">fit_selected</a></code>,
<code><a href="#topic+get_formulas">get_formulas</a></code>, <code><a href="#topic+independent_eval1">independent_eval1</a></code>,
<code><a href="#topic+kfold_partition">kfold_partition</a></code>, <code><a href="#topic+model_selection">model_selection</a></code>
<code><a href="#topic+model_validation">model_validation</a></code>, <code><a href="#topic+niche_signal">niche_signal</a></code>,
<code><a href="#topic+optimize_metrics">optimize_metrics</a></code>, <code><a href="#topic+predict_glm">predict_glm</a></code>,
<code><a href="#topic+predict_selected">predict_selected</a></code>, <code><a href="#topic+response_curve">response_curve</a></code>,
<code><a href="#topic+var_importance">var_importance</a></code>
</p>

<hr>
<h2 id='evaluation_stats'>Summary of evaluation statistics for candidate models</h2><span id='topic+evaluation_stats'></span>

<h3>Description</h3>

<p>Calculate median and standard deviation of evaluation results for all
candidate models considering cross-validation kfolds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluation_stats(evaluation_results, bimodal_toexclude = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluation_stats_+3A_evaluation_results">evaluation_results</code></td>
<td>
<p>data.frame model evaluation results. These results
are the output of the function <code><a href="#topic+model_validation">model_validation</a></code>.</p>
</td></tr>
<tr><td><code id="evaluation_stats_+3A_bimodal_toexclude">bimodal_toexclude</code></td>
<td>
<p>(logical) whether models in which binomial variable
response curves were detected will be excluded during selection processes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the mean and standard deviation for all metrics considering
cross-validation kfolds.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data
data("cal_res", package = "enmpa")
all_res &lt;- cal_res$calibration_results[, -1]

# statistics for all evaluation results
eval_stats &lt;- evaluation_stats(all_res, bimodal_toexclude = TRUE)
</code></pre>

<hr>
<h2 id='fit_selected'>Fitting selected GLMs models</h2><span id='topic+fit_selected'></span><span id='topic+fit_glms'></span>

<h3>Description</h3>

<p>Functions to facilitate fitting multiple GLMs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_selected(glm_calibration)

fit_glms(formulas, data, weights = NULL, id = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_selected_+3A_glm_calibration">glm_calibration</code></td>
<td>
<p>a list resulting from <code><a href="#topic+calibration_glm">calibration_glm</a></code>.
Models fitted are those in the slot &quot;selected&quot;.</p>
</td></tr>
<tr><td><code id="fit_selected_+3A_formulas">formulas</code></td>
<td>
<p>(character) a vector containing the formula(s) for GLM(s).</p>
</td></tr>
<tr><td><code id="fit_selected_+3A_data">data</code></td>
<td>
<p>data.frame with the dependent and independent variables.</p>
</td></tr>
<tr><td><code id="fit_selected_+3A_weights">weights</code></td>
<td>
<p>(numeric) a vector with the weights for observations.
Default = NULL.</p>
</td></tr>
<tr><td><code id="fit_selected_+3A_id">id</code></td>
<td>
<p>(character) id code for models fitted. Default = NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of fitted GLMs.
</p>
<p>For <code>fit_selected</code>, the data.frame with results from model evaluation for
selected models is added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># GLM calibration results
data(cal_res, package = "enmpa")

# Fitting selected models
sel_fit &lt;- fit_selected(cal_res)

sel_fit

# Custom formulas
forms &lt;- c("Sp ~ bio_1 + I(bio_1^2) + I(bio_12^2)",
           "Sp ~ bio_12 + I(bio_1^2) + I(bio_12^2)")

# Fitting models
fits &lt;- fit_glms(forms, data = cal_res$data)

fits$Model_ID_1
</code></pre>

<hr>
<h2 id='get_formulas'>Get GLM formulas according to defined response types</h2><span id='topic+get_formulas'></span><span id='topic+get_formulas_main'></span><span id='topic+aux_var_comb'></span><span id='topic+aux_string_comb'></span>

<h3>Description</h3>

<p>Generate GLM formulas for independent variables predicting a dependent
variable, taking into account response types required. All possible
combinations of variables can be created using arguments of the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_formulas(dependent, independent, type = "l", mode = "moderate",
             minvar = 1, maxvar = NULL)

get_formulas_main(dependent, independent, type = "l",
                  complex = FALSE, minvar = 1, maxvar = NULL)

aux_var_comb(var_names, minvar = 2, maxvar = NULL)

aux_string_comb(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_formulas_+3A_dependent">dependent</code></td>
<td>
<p>(character) name of dependent variable.</p>
</td></tr>
<tr><td><code id="get_formulas_+3A_independent">independent</code></td>
<td>
<p>(character) vector of name(s) of independent variable(s).</p>
</td></tr>
<tr><td><code id="get_formulas_+3A_type">type</code></td>
<td>
<p>(character) a character string that must contain &quot;l&quot;,
&quot;p&quot;, &quot;q&quot; or a combination of them. l = lineal, q = quadratic,
p = interaction between two variables. Default = &quot;l&quot;.</p>
</td></tr>
<tr><td><code id="get_formulas_+3A_mode">mode</code></td>
<td>
<p>(character) (character) a character string to indicate the strategy to
create the formulas for candidate models. Options are: &quot;light&quot;, &quot;moderate&quot;,
&quot;intensive&quot;, or &quot;complex&quot;. Default = &quot;moderate&quot;.</p>
</td></tr>
<tr><td><code id="get_formulas_+3A_minvar">minvar</code></td>
<td>
<p>(numeric) minimum number of independent variables in formulas.</p>
</td></tr>
<tr><td><code id="get_formulas_+3A_maxvar">maxvar</code></td>
<td>
<p>(numeric) maximum number of independent variables in formulas.</p>
</td></tr>
<tr><td><code id="get_formulas_+3A_complex">complex</code></td>
<td>
<p>(logical) whether to return the most complex formula.</p>
</td></tr>
<tr><td><code id="get_formulas_+3A_var_names">var_names</code></td>
<td>
<p>sames as <code>independent</code>.</p>
</td></tr>
<tr><td><code id="get_formulas_+3A_string">string</code></td>
<td>
<p>same as <code>type</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mode</code> options determine what strategy to iterate the predictors
defined in <code>type</code> for creating models:
</p>

<ul>
<li> <p><strong>light</strong>.&ndash; returns simple iterations of complex formulas.
</p>
</li>
<li> <p><strong>moderate</strong>.&ndash; returns a comprehensive number of iterations.
</p>
</li>
<li> <p><strong>intensive</strong>.&ndash; returns all possible combination. Very time-consuming for
6 or more independent variables.
</p>
</li>
<li> <p><strong>complex</strong>.&ndash; returns only the most complex formula.
</p>
</li></ul>



<h3>Value</h3>

<p>A character vector containing the resulting formula(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example variables
dep &lt;- "sp"
ind &lt;- c("temp", "rain", "slope")

# The most complex formula according to "type"
get_formulas(dep, ind, type = "lqp", mode = "complex")

# mode = 'light', combinations according to type
get_formulas(dep, ind, type = "lqp", mode = "light")

# mode = 'light', combinations according to type
get_formulas(dep, ind, type = "lqp", mode = "intensive")
</code></pre>

<hr>
<h2 id='independent_eval1'>Evaluate final models using independent data</h2><span id='topic+independent_eval1'></span><span id='topic+independent_eval01'></span>

<h3>Description</h3>

<p>Final evaluation steps for model predictions using an independent dataset
(not used in model calibration).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>independent_eval1(prediction, threshold, test_prediction = NULL,
                  lon_lat = NULL)

independent_eval01(prediction, observation, lon_lat = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="independent_eval1_+3A_prediction">prediction</code></td>
<td>
<p>(numeric) vector or <code>SpatRaster</code> object. If numeric,
predicted values in independent data (for <code><a href="#topic+independent_eval01">independent_eval01</a></code>),
or the entire area of prediction (for <code><a href="#topic+independent_eval1">independent_eval1</a></code>).
If <code>SpatRaster</code> prediction over the area of interest.</p>
</td></tr>
<tr><td><code id="independent_eval1_+3A_threshold">threshold</code></td>
<td>
<p>(numeric) the lowest predicted probability value for an
occurrence point. This value must be defined for presences-only data.
Default = NULL.</p>
</td></tr>
<tr><td><code id="independent_eval1_+3A_test_prediction">test_prediction</code></td>
<td>
<p>(numeric) vector of predictions for independent data.
Default = NULL.</p>
</td></tr>
<tr><td><code id="independent_eval1_+3A_lon_lat">lon_lat</code></td>
<td>
<p>matrix or data.frame of coordinates (longitude and latitude,
in that order) of independent data. Points must be located within the valid
area of <code>prediction</code>. For <code><a href="#topic+independent_eval01">independent_eval01</a></code> they
must correspond with values in observation.</p>
</td></tr>
<tr><td><code id="independent_eval1_+3A_observation">observation</code></td>
<td>
<p>(numeric) vector of observed (known) values of presence
or absence to test against <code>prediction</code> (if numeric) or values of prediction
in <code>lon_lat</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame or list containing evaluation results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Independent test data based on coordinates (lon/lat WGS 84) from presence
# and absences records
data("test", package = "enmpa")
head(test)

# Loading a model prediction
pred &lt;- terra::rast(system.file("extdata", "proj_out_wmean.tif",
                                package = "enmpa"))
terra::plot(pred)

# Evaluation using presence-absence data
independent_eval01(prediction = pred, observation = test$Sp,
                   lon_lat = test[, 2:3])

# Evaluation using presence-only data
test_p_only &lt;- test[test$Sp == 1, ]
th_maxTSS   &lt;- 0.1274123            # threshold based on the maxTSS

independent_eval1(prediction = pred, threshold = th_maxTSS,
                  lon_lat = test_p_only[, 2:3])
</code></pre>

<hr>
<h2 id='kfold_partition'>K-fold data partitioning</h2><span id='topic+kfold_partition'></span>

<h3>Description</h3>

<p>Creates indices to partition available data into k equal-sized
subsets or folds, maintaining the global proportion of presence-absences
in each fold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kfold_partition(data, dependent, k = 2, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kfold_partition_+3A_data">data</code></td>
<td>
<p>data.frame or matrix containing at least two columns.</p>
</td></tr>
<tr><td><code id="kfold_partition_+3A_dependent">dependent</code></td>
<td>
<p>(character) name of column that contains the
presence-absence records (1-0).</p>
</td></tr>
<tr><td><code id="kfold_partition_+3A_k">k</code></td>
<td>
<p>(numeric) the number of groups that the given data is to be split
into.</p>
</td></tr>
<tr><td><code id="kfold_partition_+3A_seed">seed</code></td>
<td>
<p>(numeric) integer value to specify an initial seed. Default = 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of vectors with the indices of rows corresponding to each fold.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example data
data &lt;- data.frame(species = c(rep(0, 80), rep (1,20)),
                   variable1 = rnorm(100),
                   variable2 = rpois(100, 2))

# create partition indices
kfolds &lt;- kfold_partition(data, dependent = "species", k = 2)

# data for partition 1
data[kfolds$Fold_1, ]
</code></pre>

<hr>
<h2 id='model_selection'>Selection of best candidate models considering various criteria</h2><span id='topic+model_selection'></span>

<h3>Description</h3>

<p>Applies a series of criteria to select best candidate models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_selection(evaluation_stats, criterion = "TSS", exclude_bimodal = FALSE,
                tolerance = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_selection_+3A_evaluation_stats">evaluation_stats</code></td>
<td>
<p>data.frame with the statistics of model evaluation
results. These results are the output of the function
<code><a href="#topic+evaluation_stats">evaluation_stats</a></code>.</p>
</td></tr>
<tr><td><code id="model_selection_+3A_criterion">criterion</code></td>
<td>
<p>(character) metric used as the predictive criterion for
model selection.</p>
</td></tr>
<tr><td><code id="model_selection_+3A_exclude_bimodal">exclude_bimodal</code></td>
<td>
<p>(logical) whether to exclude models in which binomial
variable response curves were detected.</p>
</td></tr>
<tr><td><code id="model_selection_+3A_tolerance">tolerance</code></td>
<td>
<p>(numeric)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with one or more selected models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data
data("cal_res", package = "enmpa")
eval_stats &lt;- cal_res$summary[, -1]

# selecting best model
selected_mod &lt;- model_selection(eval_stats, exclude_bimodal = TRUE)
</code></pre>

<hr>
<h2 id='model_validation'>Model validation options</h2><span id='topic+model_validation'></span>

<h3>Description</h3>

<p>Model evaluation using entire set of data and a k-fold cross validation
approach. Models are assessed based on discrimination power (ROC-AUC),
classification ability (accuracy, sensitivity, specificity, TSS, etc.),
and the balance between fitting and complexity (AIC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_validation(formula, data, family = binomial(link = "logit"),
                 weights = NULL, cv = FALSE, partition_index = NULL,
                 k = NULL, dependent = NULL, n_threshold = 100,
                 keep_coefficients = FALSE, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_validation_+3A_formula">formula</code></td>
<td>
<p>(character) <code>expression</code> to be used as a glm <code>formula</code>.</p>
</td></tr>
<tr><td><code id="model_validation_+3A_data">data</code></td>
<td>
<p>data.frame with dependent and independent variables.</p>
</td></tr>
<tr><td><code id="model_validation_+3A_family">family</code></td>
<td>
<p>a <code>family</code> object for models used by functions such as <code>glm</code>.
Default = binomial(link = &quot;logit&quot;).</p>
</td></tr>
<tr><td><code id="model_validation_+3A_weights">weights</code></td>
<td>
<p>(numeric) vector with weights for observations. Default = NULL.</p>
</td></tr>
<tr><td><code id="model_validation_+3A_cv">cv</code></td>
<td>
<p>(logical) whether to use a k-fold cross validation for evaluation.
Default = FALSE.</p>
</td></tr>
<tr><td><code id="model_validation_+3A_partition_index">partition_index</code></td>
<td>
<p>list of indices for cross validation in k-fold.
Obtained with the function <code><a href="#topic+kfold_partition">kfold_partition</a></code>. Default = NULL.</p>
</td></tr>
<tr><td><code id="model_validation_+3A_k">k</code></td>
<td>
<p>(numeric) number of folds for a new k-fold index preparation.
Ignored if <code>partition_index</code> is defined or if <code>cv</code> = FALSE. Default = NULL.</p>
</td></tr>
<tr><td><code id="model_validation_+3A_dependent">dependent</code></td>
<td>
<p>(character) name of dependent variable. Ignore if
<code>cv</code> = FALSE. Default = NULL.</p>
</td></tr>
<tr><td><code id="model_validation_+3A_n_threshold">n_threshold</code></td>
<td>
<p>(numeric) number of threshold values to be used for ROC.
Default = 100.</p>
</td></tr>
<tr><td><code id="model_validation_+3A_keep_coefficients">keep_coefficients</code></td>
<td>
<p>(logical) whether to keep model coefficients.
Default = FALSE.</p>
</td></tr>
<tr><td><code id="model_validation_+3A_seed">seed</code></td>
<td>
<p>(numeric) a seed number. Default = 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with results from evaluation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load species occurrences and environmental data.
data("enm_data", package = "enmpa")
head(enm_data)

# Custom formula
form &lt;- c("Sp ~ bio_1 + I(bio_1^2) + I(bio_12^2)")

# Model evaluation using the entire set of records
model_validation(form, data = enm_data)

# Model evaluation using a k-fold cross-validation (k = 3)
model_validation(form, data = enm_data, cv = TRUE, k = 3, dependent = "Sp")
</code></pre>

<hr>
<h2 id='niche_signal'>Niche Signal detection using one or multiple variables</h2><span id='topic+niche_signal'></span><span id='topic+niche_signal_univariate'></span><span id='topic+niche_signal_permanova'></span>

<h3>Description</h3>

<p>Identifies whether a signal of niche can be detected using one or multiple
variables. This is an implementation of the methods developed by
Cobos &amp; Peterson (2022) <a href="doi:10.17161/bi.v17i.15985">doi:10.17161/bi.v17i.15985</a> that
focuses on identifying niche signals in presence-absence data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niche_signal(data, condition, variables, method = "univariate",
             permanova_method = "mahalanobis", iterations = 1000,
             set_seed = 1, verbose = TRUE, ...)

niche_signal_univariate(data, condition, variable, iterations = 1000,
                        set_seed = 1, verbose = TRUE)

niche_signal_permanova(data, condition, variables, permutations = 999,
                       permanova_method = "mahalanobis", verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niche_signal_+3A_data">data</code></td>
<td>
<p>matrix or data.frame containing at least the following
information: a column representing <code>condition</code> (positive = 1 or
negative = 0), and one or more columns representing environmental variables.</p>
</td></tr>
<tr><td><code id="niche_signal_+3A_condition">condition</code></td>
<td>
<p>(character) name of the column with numeric information
about detection (positive = 1 or negative = 0).</p>
</td></tr>
<tr><td><code id="niche_signal_+3A_variables">variables</code></td>
<td>
<p>(character) vector of one or more names of columns to be
used as environmental variables. If <code>method</code> = &quot;univariate&quot;, only one
variable is used; for <code>method</code> = &quot;permanova&quot;, multiple variables can
be used.</p>
</td></tr>
<tr><td><code id="niche_signal_+3A_method">method</code></td>
<td>
<p>(character) name of the method to be used for niche comparison.
Default = &quot;univariate&quot;.</p>
</td></tr>
<tr><td><code id="niche_signal_+3A_permanova_method">permanova_method</code></td>
<td>
<p>(character) name of the dissimilarity index to be
used as <code>method</code> in <code><a href="vegan.html#topic+adonis2">adonis2</a></code>. See all options in
<code><a href="vegan.html#topic+vegdist">vegdist</a></code>. Default = &quot;mahalanobis&quot;.</p>
</td></tr>
<tr><td><code id="niche_signal_+3A_iterations">iterations</code></td>
<td>
<p>(numeric) number of iterations to be used in analysis.
Default = 1000. If <code>method</code> = &quot;permanova&quot;, permutations = iterations - 1.</p>
</td></tr>
<tr><td><code id="niche_signal_+3A_set_seed">set_seed</code></td>
<td>
<p>(numeric) integer value to specify a initial seed.
Default = 1.</p>
</td></tr>
<tr><td><code id="niche_signal_+3A_verbose">verbose</code></td>
<td>
<p>(logical) whether or not to print messages about the process.
Default = TRUE.</p>
</td></tr>
<tr><td><code id="niche_signal_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to <code><a href="vegan.html#topic+adonis2">adonis2</a></code>.</p>
</td></tr>
<tr><td><code id="niche_signal_+3A_variable">variable</code></td>
<td>
<p>(character) name of the column containing data to be used
as environmental variable.</p>
</td></tr>
<tr><td><code id="niche_signal_+3A_permutations">permutations</code></td>
<td>
<p>number of permutations to be performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with results from analysis depending on <code>method</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load species occurrences and environmental data.
data("enm_data", package = "enmpa")
head(enm_data)

# Detection of niche signal using an univariate non-parametric test
sn_bio1 &lt;- niche_signal(data = enm_data, variables = "bio_1",
                        condition = "Sp", method = "univariate")
sn_bio1

sn_bio12 &lt;- niche_signal(data = enm_data, variables = "bio_12",
                         condition = "Sp", method = "univariate")
sn_bio12
</code></pre>

<hr>
<h2 id='optimize_metrics'>Find threshold values to produce three optimal metrics</h2><span id='topic+optimize_metrics'></span>

<h3>Description</h3>

<p>The metrics true skill statistic (TSS), sensitivity, specificity are explored
by comparing actual vs predicted values to find threshold values that produce
sensitivity = specificity, maximum TSS, and a sensitivity value of 0.9.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimize_metrics(actual, predicted, n_threshold = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimize_metrics_+3A_actual">actual</code></td>
<td>
<p>(numeric) vector of actual values (0, 1) to be compared to
<code>predicted</code> values after applying a threshold.</p>
</td></tr>
<tr><td><code id="optimize_metrics_+3A_predicted">predicted</code></td>
<td>
<p>(numeric) vector of predicted probability values to be
thresholded and compared to <code>actual</code>.</p>
</td></tr>
<tr><td><code id="optimize_metrics_+3A_n_threshold">n_threshold</code></td>
<td>
<p>(numeric) number of threshold values to be used.
Default = 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing a data.frame with the resulting metrics for all threshold
values tested, and a second data.frame with the results for the threshold
values that produce sensitivity = specificity (ESS), maximum TSS (maxTSS),
and a sensitivity value of 0.9 (SEN90).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example data
act &lt;- c(rep(1, 20), rep(0, 80))
pred &lt;- c(runif(20, min = 0.4, max = 0.7), runif(80, min = 0, max = 0.5))

# run example
om &lt;- optimize_metrics(actual = act, predicted = pred)
om$optimized
</code></pre>

<hr>
<h2 id='plot_importance'>Plot variable importance</h2><span id='topic+plot_importance'></span>

<h3>Description</h3>

<p>Visualization of the results obtained with the function
<code><a href="#topic+var_importance">var_importance</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_importance(x, xlab = NULL, ylab = "Relative contribution",
                main = "Variable importance", extra_info = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_importance_+3A_x">x</code></td>
<td>
<p>data.frame output from <code><a href="#topic+var_importance">var_importance</a></code>.</p>
</td></tr>
<tr><td><code id="plot_importance_+3A_xlab">xlab</code></td>
<td>
<p>(character) a label for the x axis.</p>
</td></tr>
<tr><td><code id="plot_importance_+3A_ylab">ylab</code></td>
<td>
<p>(character) a label for the y axis.</p>
</td></tr>
<tr><td><code id="plot_importance_+3A_main">main</code></td>
<td>
<p>(character) main title for the plot.</p>
</td></tr>
<tr><td><code id="plot_importance_+3A_extra_info">extra_info</code></td>
<td>
<p>(logical) when results are from more than one model, it
adds information about the number of models using each predictor and the mean
contribution found.</p>
</td></tr>
<tr><td><code id="plot_importance_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="graphics.html#topic+barplot">barplot</a></code> or
<code><a href="graphics.html#topic+boxplot">boxplot</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load species occurrences and environmental data.
data("enm_data", package = "enmpa")

# Custom formulas
forms &lt;- c("Sp ~ bio_1 + I(bio_1^2) + I(bio_12^2)",
           "Sp ~ bio_12 + I(bio_1^2) + I(bio_12^2)")

# Fitting models
fits &lt;- fit_glms(forms, data = enm_data)

# Variable importance for single models
vi_1 &lt;- var_importance(fits$ModelID_1)
plot_importance(x = vi_1)

vi_2 &lt;- var_importance(fits$ModelID_2)
plot_importance(x = vi_2)

# Variable importance for multiple models
vi_c &lt;- var_importance(fits)
plot_importance(x = vi_c)
</code></pre>

<hr>
<h2 id='plot_niche_signal'>Plot Niche Signal results</h2><span id='topic+plot_niche_signal'></span><span id='topic+plot_niche_signal_univariate'></span><span id='topic+plot_niche_signal_permanova'></span>

<h3>Description</h3>

<p>Plots to interpret results from niche_signal tests
(Cobos &amp; Peterson (2022) <a href="doi:10.17161/bi.v17i.15985">doi:10.17161/bi.v17i.15985</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_niche_signal(niche_signal_list, statistic = "mean",
                  variables = NULL, ellipses = FALSE, level = 0.99,
                  breaks = "Sturges", main = "", xlab = NULL, ylab = NULL,
                  h_col = "lightgray", h_cex = 0.8, lty = 2, lwd = 1,
                  l_col = c("blue", "black"), e_col = c("black", "red"),
                  pch = 19, pt_cex = c(1.3, 0.8), pt_col = c("black", "red"),
                  ...)

plot_niche_signal_univariate(niche_signal_univariate_list, statistic = "mean",
                             breaks = "Sturges", main = "", xlab = NULL,
                             ylab = "Frequency", h_col = "lightgray",
                             h_cex = 0.8, lty = 2, lwd = 1,
                             l_col = c("blue", "black"), ...)

plot_niche_signal_permanova(niche_signal_permanova_list, variables = NULL,
                           ellipses = FALSE, level = 0.99, main = "",
                           xlab = NULL, ylab = NULL,
                           e_col = c("black", "red"), lty = 2, lwd = 1,
                           pch = 19, pt_cex = c(1.3, 0.8),
                           pt_col = c("black", "red"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_niche_signal_+3A_niche_signal_list">niche_signal_list</code></td>
<td>
<p>list of results from niche_signal.</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_statistic">statistic</code></td>
<td>
<p>(character) name of the statistic for which results will be
explored when results come for univariate analysis. Default = &quot;mean&quot;. Options
are: &quot;mean&quot;, &quot;median&quot;, &quot;SD&quot;, and &quot;range&quot;.</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_variables">variables</code></td>
<td>
<p>(character) name of variables to used in plots when
results come from analysis using the <code>permanova</code> method. The default, NULL,
uses the first two variables.</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_ellipses">ellipses</code></td>
<td>
<p>(logical) whether to use ellipses to represent all and
positive data when results come from PERMANOVA. The default, FALSE, plots
points instead.</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_level">level</code></td>
<td>
<p>(numeric) value from 0 to 1 representing the limit of
the ellipse to be plotted. Default = 0.99.</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_breaks">breaks</code></td>
<td>
<p>breaks in the histogram as in <code><a href="graphics.html#topic+hist">hist</a></code>.
Default = &quot;Sturges&quot;.</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_main">main</code></td>
<td>
<p>(character) title for plot. Default = &quot;&quot;.</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_xlab">xlab</code></td>
<td>
<p>(character) x axis label. Default = NULL. For results from
PERMANOVA, appropriate variable names are used.</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_ylab">ylab</code></td>
<td>
<p>(character) y axis label. Default = NULL. For univariate
results, the default turn into &quot;Frequency&quot;. For results from PERMANOVA,
appropriate variable names are used.</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_h_col">h_col</code></td>
<td>
<p>a color to be used to fill the bars of histograms.
Default = &quot;lightgray&quot;.</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_h_cex">h_cex</code></td>
<td>
<p>(numeric) value by which plotting text and symbols should be
magnified relative to the default in histograms. Default = 0.8.</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_lty">lty</code></td>
<td>
<p>(numeric) line type. See options in <code><a href="graphics.html#topic+par">par</a></code>.
Default = 2. A vector of length = 2 can be used, in order, all and positive.</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_lwd">lwd</code></td>
<td>
<p>(numeric) line width. See options in <code><a href="graphics.html#topic+par">par</a></code>.
Default = 1. A vector of length = 2 can be used, in order, all and positive.</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_l_col">l_col</code></td>
<td>
<p>line color for observed value of positives and confidence
intervals. Default = c(&quot;blue&quot;, &quot;black&quot;).</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_e_col">e_col</code></td>
<td>
<p>color of ellipse lines for all and positive data.
Default = c(&quot;black&quot;, &quot;red&quot;).</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_pch">pch</code></td>
<td>
<p>point type. See options in <code><a href="graphics.html#topic+points">points</a></code>.
Default = 19. A vector of length = 2 can be used, in order, all and positive.</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_pt_cex">pt_cex</code></td>
<td>
<p>(numeric) value by which points will be magnified. Values
for all and positive points are recommended. Default = c(1.3, 0.8).</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_pt_col">pt_col</code></td>
<td>
<p>color for points. Values for all and positive points are
recommended. Default = c(&quot;black&quot;, &quot;red&quot;).</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_...">...</code></td>
<td>
<p>other plotting arguments to be used.</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_niche_signal_univariate_list">niche_signal_univariate_list</code></td>
<td>
<p>list of results from niche_signal_univariate.</p>
</td></tr>
<tr><td><code id="plot_niche_signal_+3A_niche_signal_permanova_list">niche_signal_permanova_list</code></td>
<td>
<p>list of results from niche_signal_permanova.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load species occurrences and environmental data.
data("enm_data", package = "enmpa")
head(enm_data)

# Detection of niche signal using an univariate non-parametric test
sn_bio1 &lt;- niche_signal(data = enm_data,
                        variables = "bio_1",
                        condition = "Sp",
                        method = "univariate")

plot_niche_signal(sn_bio1, variables = "bio_1")

sn_bio12 &lt;- niche_signal(data = enm_data,
                         variables = "bio_12",
                         condition = "Sp",
                         method = "univariate")

plot_niche_signal(sn_bio12, variables = "bio_12")
</code></pre>

<hr>
<h2 id='predict_glm'>Extension of glm predict to generate predictions of different types</h2><span id='topic+predict_glm'></span>

<h3>Description</h3>

<p>Obtains predictions from a fitted generalized linear model objects. It also
allows the clamping option to restrict extrapolation in areas outside the
calibration area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_glm(
  model,
  newdata,
  clamping = FALSE,
  var_to_clamp = NULL,
  type = "response"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_glm_+3A_model">model</code></td>
<td>
<p>a <code>glm</code> object.</p>
</td></tr>
<tr><td><code id="predict_glm_+3A_newdata">newdata</code></td>
<td>
<p>a data.frame or matrix with the new data to project the
predictions.</p>
</td></tr>
<tr><td><code id="predict_glm_+3A_clamping">clamping</code></td>
<td>
<p>(logical) whether to clamp values to a minimum and maximum
value, that are established for the max and min values within calibration
values. Default = FALSE.</p>
</td></tr>
<tr><td><code id="predict_glm_+3A_var_to_clamp">var_to_clamp</code></td>
<td>
<p>(character) a vector containing the names of the variables
that will undergo clamping. By default, if no specific names are provided,
the value is set to NULL, which indicates that clamping will be applied to
all variables. Ignore if clamping = FALSE.</p>
</td></tr>
<tr><td><code id="predict_glm_+3A_type">type</code></td>
<td>
<p>(character) the type of prediction required. For a default
binomial model the default predictions are of log-odds (probabilities on
logit scale). The default, &quot;response&quot;, returns predicted probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatRaster</code> object or a vector with predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load fitted model
data("sel_fit", package = "enmpa")

# Load raster layers to be projected
env_vars &lt;- terra::rast(system.file("extdata", "vars.tif", package = "enmpa"))

# Prediction
pred &lt;- predict_glm(sel_fit$ModelID_7, newdata = env_vars)
terra::plot(pred)
</code></pre>

<hr>
<h2 id='predict_selected'>Predictions for the models selected after calibration</h2><span id='topic+predict_selected'></span>

<h3>Description</h3>

<p>Wrapper function that facilitates the prediction of those models
selected as the most robust. In addition, it allows the calculation of
consensus models, when more than one model are selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predict_selected(fitted, newdata, clamping = FALSE, var_to_clamp = NULL,
                 type = "response", consensus = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_selected_+3A_fitted">fitted</code></td>
<td>
<p>a list of GLMs obtained using the
functions <code><a href="#topic+fit_selected">fit_selected</a></code> or <code><a href="#topic+fit_glms">fit_glms</a></code>.</p>
</td></tr>
<tr><td><code id="predict_selected_+3A_newdata">newdata</code></td>
<td>
<p>a <code>SpatRaster</code>, data.frame, or matrix with the new data on
which to predict.</p>
</td></tr>
<tr><td><code id="predict_selected_+3A_clamping">clamping</code></td>
<td>
<p>(logical) this option controls extrapolation when making
predictions for environmental conditions beyond the calibration data.
Default = FALSE.</p>
</td></tr>
<tr><td><code id="predict_selected_+3A_var_to_clamp">var_to_clamp</code></td>
<td>
<p>(character) a vector containing the names of the variables
that will undergo clamping. By default, if no specific names are provided,
the value is set to NULL, which indicates that clamping will be applied to
all variables. Ignore if clamping = FALSE.</p>
</td></tr>
<tr><td><code id="predict_selected_+3A_type">type</code></td>
<td>
<p>(character) the type of prediction required. For a default
binomial model the default predictions are of log-odds (probabilities on
logit scale). The default, &quot;response&quot;, returns predicted probabilities.</p>
</td></tr>
<tr><td><code id="predict_selected_+3A_consensus">consensus</code></td>
<td>
<p>(logical) valid if <code>newdata</code> is a <code>SpatRaster</code>, whether to
produce consensus results obtained by combining the predictions from the
collection of selected models. By default consensuses are calculated using
the mean, median, a weighted average using the AIC weights, and variance.
Default = TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with predictions of selected models on the <code>newdata</code> and fitted
selected model(s). Consensus predictions are added if multiple selected
models exits and if <code>newdata</code> is a <code>SpatRaster</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a fitted selected model
data(sel_fit, package = "enmpa")

# Load raster layers to be projected
env_vars &lt;- terra::rast(system.file("extdata", "vars.tif", package = "enmpa"))

# Predictions (only one selected mode, no consensus required)
preds &lt;- predict_selected(sel_fit, newdata = env_vars, consensus = FALSE)

# Plot prediction
terra::plot(preds$predictions)
</code></pre>

<hr>
<h2 id='proc_enm'>Partial ROC calculation</h2><span id='topic+proc_enm'></span>

<h3>Description</h3>

<p>proc applies partial ROC tests to model predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proc_enm(test_prediction, prediction, threshold = 5, sample_percentage = 50,
         iterations = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proc_enm_+3A_test_prediction">test_prediction</code></td>
<td>
<p>(numeric) vector of model predictions for testing
data.</p>
</td></tr>
<tr><td><code id="proc_enm_+3A_prediction">prediction</code></td>
<td>
<p><code>SpatRaster</code> or numeric vector of model predictions to be
evaluated.</p>
</td></tr>
<tr><td><code id="proc_enm_+3A_threshold">threshold</code></td>
<td>
<p>(numeric) value from 0 to 100 to represent the percentage of
potential error (E) that the data could have due to any source of uncertainty.
Default = 5.</p>
</td></tr>
<tr><td><code id="proc_enm_+3A_sample_percentage">sample_percentage</code></td>
<td>
<p>(numeric) percentage of testing data to be used in each
bootstrapped process for calculating the partial ROC. Default = 50.</p>
</td></tr>
<tr><td><code id="proc_enm_+3A_iterations">iterations</code></td>
<td>
<p>(numeric) number of bootstrap iterations to be performed;
default = 500.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Partial ROC is calculated following Peterson et al. (2008)
<a href="doi:10.1016/j.ecolmodel.2007.11.008">doi:10.1016/j.ecolmodel.2007.11.008</a>.
</p>


<h3>Value</h3>

<p>A list with the summary of the results and a data.frame containing
the AUC values and AUC ratios calculated for all iterations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Loading a model prediction
pred &lt;- terra::rast(system.file("extdata", "proj_out_wmean.tif",
                                package = "enmpa"))

# Simulated data
test &lt;- runif(100, min = 0.3, max = 0.8)

# partial ROC calculation
pr &lt;- proc_enm(test, pred, threshold = 5, sample_percentage = 50,
               iterations = 500)
</code></pre>

<hr>
<h2 id='response_curve'>Variable response curves for GLMs</h2><span id='topic+response_curve'></span>

<h3>Description</h3>

<p>A view of variable responses in models. Responses based on single or multiple
models can be provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>response_curve(fitted, variable, n = 100, new_data = NULL, extrapolate = TRUE,
               xlab = NULL, ylab = "Probability", col = "red", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="response_curve_+3A_fitted">fitted</code></td>
<td>
<p>an object of class <code>glm</code> or a list of GLMs obtained using the
functions <code><a href="#topic+fit_selected">fit_selected</a></code> or <code><a href="#topic+fit_glms">fit_glms</a></code>.</p>
</td></tr>
<tr><td><code id="response_curve_+3A_variable">variable</code></td>
<td>
<p>(character) name of the variables to be plotted.</p>
</td></tr>
<tr><td><code id="response_curve_+3A_n">n</code></td>
<td>
<p>(numeric) an integer guiding the number of breaks. Default = 100</p>
</td></tr>
<tr><td><code id="response_curve_+3A_new_data">new_data</code></td>
<td>
<p>a <code>SpatRaster</code>, data.frame, or  matrix of variables
representing the range of variable values in an area of interest.
Default = NULL.</p>
</td></tr>
<tr><td><code id="response_curve_+3A_extrapolate">extrapolate</code></td>
<td>
<p>(logical) whether to allow extrapolation to study the
behavior of the response outside the calibration limits. Ignored if
<code>new_data</code> is defined. Default = TRUE.</p>
</td></tr>
<tr><td><code id="response_curve_+3A_xlab">xlab</code></td>
<td>
<p>(character) a label for the x axis. The default, NULL, uses the
name defined in <code>variable</code>.</p>
</td></tr>
<tr><td><code id="response_curve_+3A_ylab">ylab</code></td>
<td>
<p>(character) a label for the y axis. Default = &quot;Probability&quot;.</p>
</td></tr>
<tr><td><code id="response_curve_+3A_col">col</code></td>
<td>
<p>(character) color for lines. Default = &quot;red&quot;.</p>
</td></tr>
<tr><td><code id="response_curve_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates these probabilities by focusing on a single
environmental variable while keeping all other variables constant at their
mean values.
</p>
<p>When responses for multiple models are to be plotted, the mean and confidence
intervals for the set of responses are calculated using a GAM.
</p>


<h3>Value</h3>

<p>A plot with the response curve for a <code>variable</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a fitted selected model
data(sel_fit, package = "enmpa")

# Response curve for single models
response_curve(sel_fit$ModelID_7, variable = "bio_1")

# Response curve when model(s) are in a list (only one model in this one)
response_curve(sel_fit, variable = "bio_12")
</code></pre>

<hr>
<h2 id='sel_fit'>Example of selected models fitted</h2><span id='topic+sel_fit'></span>

<h3>Description</h3>

<p>A list containing fitted selected model(s) and the information
from model evaluation for such model(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sel_fit
</code></pre>


<h3>Format</h3>

<p>A list with two elements.
</p>

<dl>
<dt>ModelID_7</dt><dd><p>a fitted glm.</p>
</dd>
<dt>selected</dt><dd><p>a data.frame with results from evaluation of ModelID_7</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("sel_fit", package = "enmpa")
</code></pre>

<hr>
<h2 id='test'>Example data used to test models</h2><span id='topic+test'></span>

<h3>Description</h3>

<p>A dataset containing information on presence and absence, and
independent variables used to fit GLM models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows and 3 columns.
</p>

<dl>
<dt>Sp</dt><dd><p>numeric, values of 0 = absence and 1 = presence.</p>
</dd>
<dt>lon</dt><dd><p>numeric, longitude values.</p>
</dd>
<dt>lat</dt><dd><p>numeric, latitude values.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data("test", package = "enmpa")
head(test)
</code></pre>

<hr>
<h2 id='var_importance'>Variable importance for GLMs</h2><span id='topic+var_importance'></span>

<h3>Description</h3>

<p>Calculates the relative importance of predictor variables based on the
concept of explained deviance. This is achieved by fitting a GLMs multiple
times, each time leaving out a different predictor variable to observe its
impact on the model's performance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_importance(fitted)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_importance_+3A_fitted">fitted</code></td>
<td>
<p>an object of class <code>glm</code> or a list of GLMs obtained using the
functions <code><a href="#topic+fit_selected">fit_selected</a></code> or <code><a href="#topic+fit_glms">fit_glms</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The process begins by fitting the full GLM model, which includes all predictor
variables. Subsequently, separate GLM models are fitted, excluding one
variable at a time to assess the influence of its absence on the model's
performance. By systematically evaluating the effect of removing each
predictor variable, the function provides valuable insights into their
individual contributions to the model's overall performance and explanatory
power.
</p>


<h3>Value</h3>

<p>A data.frame containing the relative contribution of each variable. An
identification for distinct models is added if <code>fitted</code> contains multiple
models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load a fitted selected model
data(sel_fit, package = "enmpa")

# Variable importance for single models
var_importance(sel_fit$ModelID_7)

# Variable importance for multiple models (only one model in this list)
var_importance(sel_fit)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
