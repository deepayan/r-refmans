<!DOCTYPE html><html lang="en"><head><title>Help for package recolorize</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {recolorize}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#recolorize-package'><p>recolorize: Color-Based Image Segmentation</p></a></li>
<li><a href='#absorbLayer'><p>Absorb a layer into its surrounding color patches</p></a></li>
<li><a href='#add_image'><p>Add a raster image to a plot</p></a></li>
<li><a href='#adjust_color'><p>Adjust the saturation and brightness of a color</p></a></li>
<li><a href='#apply_imager_operation'><p>Apply imager operations to layers of an image</p></a></li>
<li><a href='#array_to_cimg'><p>Converts from a raster array to a cimg object</p></a></li>
<li><a href='#array_to_RasterStack'><p>Convert from an array to a raster stack</p></a></li>
<li><a href='#assignPixels'><p>Assign a 2D matrix of pixels to specified colors</p></a></li>
<li><a href='#backgroundCondition'><p>Generate a background condition for masking</p></a></li>
<li><a href='#backgroundIndex'><p>Index and remove background pixels for color clustering</p></a></li>
<li><a href='#blurImage'><p>Blur an image</p></a></li>
<li><a href='#brick_to_array'><p>Convert from a RasterBrick to an array</p></a></li>
<li><a href='#cielab_coldist'><p>Generate a 'coldist' object for CIE Lab colors</p></a></li>
<li><a href='#cimg_to_array'><p>Converts from cimg to raster array</p></a></li>
<li><a href='#classify_recolorize'><p>Convert a <code>recolorize</code> object to a <code>classify</code> object</p></a></li>
<li><a href='#clean_merge_params'><p>Clean up parameters passed to mergeLayers</p></a></li>
<li><a href='#col2col'><p>Modified convertColor</p></a></li>
<li><a href='#colorClusters'><p>Generate color clusters from an image</p></a></li>
<li><a href='#colorClustersHist'><p>Cluster pixel colors using histogram binning</p></a></li>
<li><a href='#colorClustersKMeans'><p>Cluster pixel colors using K-means clustering</p></a></li>
<li><a href='#colorResiduals'><p>Calculate squared residuals for color centers</p></a></li>
<li><a href='#constructImage'><p>Generate an image from pixel assignments and color matrix</p></a></li>
<li><a href='#editLayer'><p>Edit a color patch using morphological operations</p></a></li>
<li><a href='#editLayers'><p>Edit multiple color patches using morphological operations</p></a></li>
<li><a href='#expand_recolorize'><p>Expand aspects of a recolorize object for other functions</p></a></li>
<li><a href='#hclust_color'><p>Plot and group colors by similarity</p></a></li>
<li><a href='#imDist'><p>Calculates the distance between non-transparent pixels in images</p></a></li>
<li><a href='#imHeatmap'><p>Plot a heatmap of a matrix of color distances</p></a></li>
<li><a href='#imposeColors'><p>Recolor an image to a provided set of colors</p></a></li>
<li><a href='#labelCol'><p>Change colors of dendrogram tips</p></a></li>
<li><a href='#match_colors'><p>Reorder a color palette to best match a reference palette</p></a></li>
<li><a href='#medianColors'><p>Change color centers to median color of all pixels assigned to it</p></a></li>
<li><a href='#mergeLayers'><p>Merge layers in a recolorized image</p></a></li>
<li><a href='#pixelAssignMatrix'><p>Make pixel assignment matrix for recoloring</p></a></li>
<li><a href='#plot.recolorize'><p>Plot recolorized image results</p></a></li>
<li><a href='#plot.recolorizeVector'><p>Plot a <code>recolorizeVector</code> object</p></a></li>
<li><a href='#plotColorClusters'><p>Plot color clusters in a color space</p></a></li>
<li><a href='#plotColorPalette'><p>Plot a color palette</p></a></li>
<li><a href='#plotImageArray'><p>Plot a 3D array as an RGB image</p></a></li>
<li><a href='#raster_to_array'><p>Convert from a (small-r) raster object to an RGB array</p></a></li>
<li><a href='#readImage'><p>Read in an image as a 3D array</p></a></li>
<li><a href='#recluster'><p>Recluster color centers based on color similarity</p></a></li>
<li><a href='#recoloredImage'><p>Get recolored image from a recolorize object</p></a></li>
<li><a href='#recolorize'><p>Simplify the colors of an image</p></a></li>
<li><a href='#recolorize_adjacency'><p>Run <code>pavo</code>'s adjacency and boundary strength analysis on a <code>recolorize</code></p>
object</a></li>
<li><a href='#recolorize_to_patternize'><p>Convert a recolorize object to a raster object</p></a></li>
<li><a href='#recolorize_to_png'><p>Save a recolored image as a PNG</p></a></li>
<li><a href='#recolorize2'><p>Recolorize with automatic thresholding</p></a></li>
<li><a href='#recolorizeVector'><p>Convert a recolorize object to a vector</p></a></li>
<li><a href='#reorder_colors'><p>Reorder colors in a recolorize object</p></a></li>
<li><a href='#rerun_recolorize'><p>Rerun the sequence of calls used to produce a recolorize object</p></a></li>
<li><a href='#rgb2hsl'><p>Convert RGB colors to HSL</p></a></li>
<li><a href='#splitByColor'><p>Split color clusters in a recolorize object into layers</p></a></li>
<li><a href='#thresholdRecolor'><p>Drop minor colors from a recolorize object</p></a></li>
<li><a href='#werner'><p>Werner's nomenclature of colors</p></a></li>
<li><a href='#wernerColor'><p>Remap an image to Werner's nomenclature</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Color-Based Image Segmentation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Automatic, semi-automatic, and manual functions for
    generating color maps from images. The idea is to simplify
    the colors of an image according to a metric that is useful for
    the user, using deterministic methods whenever possible.
    Many images will be clustered well using the out-of-the-box
    functions, but the package also includes a toolbox of functions
    for making manual adjustments (layer merging/isolation, blurring,
    fitting to provided color clusters or those from another image, etc).
    Also includes export methods for other color/pattern analysis packages
    (pavo, patternize, colordistance).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/licenses/by/4.0">CC BY 4.0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>imager, stats, png, pavo, grDevices, graphics, mgcv,
colorRamps, plotfunctions, abind, raster, plot3D</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, sf, smoothr, clue, spatstat.geom, methods</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://hiweller.github.io/recolorize/">https://hiweller.github.io/recolorize/</a>,
<a href="https://github.com/hiweller/recolorize">https://github.com/hiweller/recolorize</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/hiweller/recolorize/issues">https://github.com/hiweller/recolorize/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-03 19:39:20 UTC; hannahwe</td>
</tr>
<tr>
<td>Author:</td>
<td>Hannah Weller <a href="https://orcid.org/0000-0002-5252-4282"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hannah Weller &lt;hannahiweller@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-03 21:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='recolorize-package'>recolorize: Color-Based Image Segmentation</h2><span id='topic+recolorize-package'></span>

<h3>Description</h3>

<p>Automatic, semi-automatic, and manual functions for generating color maps from images. The idea is to simplify the colors of an image according to a metric that is useful for the user, using deterministic methods whenever possible. Many images will be clustered well using the out-of-the-box functions, but the package also includes a toolbox of functions for making manual adjustments (layer merging/isolation, blurring, fitting to provided color clusters or those from another image, etc). Also includes export methods for other color/pattern analysis packages (pavo, patternize, colordistance).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hannah Weller <a href="mailto:hannahiweller@gmail.com">hannahiweller@gmail.com</a> (<a href="https://orcid.org/0000-0002-5252-4282">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://hiweller.github.io/recolorize/">https://hiweller.github.io/recolorize/</a>
</p>
</li>
<li> <p><a href="https://github.com/hiweller/recolorize">https://github.com/hiweller/recolorize</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/hiweller/recolorize/issues">https://github.com/hiweller/recolorize/issues</a>
</p>
</li></ul>


<hr>
<h2 id='absorbLayer'>Absorb a layer into its surrounding color patches</h2><span id='topic+absorbLayer'></span>

<h3>Description</h3>

<p>Absorb a layer into its surrounding color patches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absorbLayer(
  recolorize_obj,
  layer_idx,
  size_condition = function(s) s &lt;= Inf,
  x_range = c(0, 1),
  y_range = c(0, 1),
  remove_empty_layers = TRUE,
  plotting = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="absorbLayer_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>A <code>recolorize</code> object.</p>
</td></tr>
<tr><td><code id="absorbLayer_+3A_layer_idx">layer_idx</code></td>
<td>
<p>The numeric index of the layer to absorb.</p>
</td></tr>
<tr><td><code id="absorbLayer_+3A_size_condition">size_condition</code></td>
<td>
<p>A condition for determining which components to absorb,
written as a function. The default (<code>function(l) l &lt;= Inf</code>) will affect
all components, since they all have fewer than infinity pixels.</p>
</td></tr>
<tr><td><code id="absorbLayer_+3A_x_range">x_range</code>, <code id="absorbLayer_+3A_y_range">y_range</code></td>
<td>
<p>The rectangular bounding box (as proportions of the
image width and length) for selecting patches. Patches with at least
partial overlap are counted. Defaults (0-1) include the entire image.
See details.</p>
</td></tr>
<tr><td><code id="absorbLayer_+3A_remove_empty_layers">remove_empty_layers</code></td>
<td>
<p>Logical. If the layer is completely absorbed,
remove it from the layer indices and renumber the existing patches? (Example:
if you completely absorb layer 3, then layer 4 -&gt; 3 and 5 -&gt; 4, and so on).</p>
</td></tr>
<tr><td><code id="absorbLayer_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Plot results?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function works by splitting a layer into spatially distinct
'components' using <a href="imager.html#topic+split_connected">imager::split_connected</a>. A contiguous region of pixels
is considered a single component. Only components which satisfy
both the <code>size_condition</code> and the location condition (specified via <code>x_range</code>
and <code>y_range</code>) are absorbed, so you can be target specific regions with
(ideally) a minimum of fuss.
</p>
<p>The <code>size_condition</code> is passed as a function which must have a logical
vector output (<code>TRUE</code> and <code>FALSE</code>) when applied to a vector of sizes.
Usually this will be some combination of greater and less than statements,
combined with logical operators like <code>&amp;</code> and <code>|</code>. For example,
<code>size_condition = function(x) x &gt; 100 | x &lt; 10</code> would affect components of
greater than 100 pixels and fewer than 10 pixels, but not those with 10-100
pixels.
</p>
<p>The <code>x_range</code> and <code>y_range</code> values set the bounding box of a rectangular
region as proportions of the image axes, with the origin (0, 0) in the bottom
left corner. Any patch which has at least partial overlap with this bounding
box will be considered to satisfy the condition. When selecting this region,
it can be helpful to plot a grid on the image first to narrow down an
approximate region (see examples).
</p>


<h3>Value</h3>

<p>A <code>recolorize</code> object.
</p>


<h3>See Also</h3>

<p><a href="#topic+editLayers">editLayers</a> for editing layers using morphological operations;
<a href="#topic+thresholdRecolor">thresholdRecolor</a> for re-fitting the entire image without minor colors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

img &lt;- system.file("extdata/fulgidissima.png", package = "recolorize")

# get an initial fit using recolorize + recluster:
fit1 &lt;- recolorize2(img, bins = 3, cutoff = 65, plotting = FALSE)
# this looks okay, but the brown patch (3) has some speckling
# in the upper right elytron due to reflection, and the orange
# patch (4) has the same issue

# the brown patch is easier to deal with, since size thresholding alone is
# sufficient; we want to leave the stripes intact, so we'll absorb components
# that are 50-250 pixels OR fewer than 20 pixels (to get the tiny speckles),
# leaving the eyes intact
fit2 &lt;- absorbLayer(fit1, layer_idx = 3,
                    size_condition = function(x) x &lt;= 250 &amp;
                      x &gt;= 50 |
                      x &lt; 20)

# what about the orange speckles? this is more difficult, because
# we want to retain the border around the brown stripes, but those patches
# are quite small, so size thresholding won't work

# but we just want to target pixels in that one region, so we can first
# determine a bounding box for it by plotting a grid:
plotImageArray(constructImage(fit2$pixel_assignments,
                    fit2$centers))
axis(1, line = 3); axis(2, line = 1)
abline(v = seq(0, 1, by = 0.1),
       h = seq(0, 1, by = 0.1),
       col = grey(0.2),
       lty = 2)
# x-axis range: 0.5-0.7
# y-axis range: 0.55-0.75
# let's try it:
fit3 &lt;- absorbLayer(fit2, layer_idx = 4,
                    size_condition = function(x) x &lt; 100,
                    x_range = c(0.5, 0.7),
                    y_range = c(0.55, 0.75))
# looks pretty good

</code></pre>

<hr>
<h2 id='add_image'>Add a raster image to a plot</h2><span id='topic+add_image'></span>

<h3>Description</h3>

<p>Adds a raster image (a 3D array) to an existing plot as an image.
A silly, generic function, but nice for visualization. Sort of like
<a href="graphics.html#topic+points">graphics::points</a>, but for images.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_image(obj, x = NULL, y = NULL, width = NULL, interpolate = TRUE, angle = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_image_+3A_obj">obj</code></td>
<td>
<p>An array of the dimensions height x width x channels,
such as read in by <a href="png.html#topic+readPNG">png::readPNG</a> or <a href="#topic+readImage">readImage</a>, or the <code>original_img</code>
and <code>recolored_img</code> elements of a <code>recolorize</code> object.</p>
</td></tr>
<tr><td><code id="add_image_+3A_x">x</code>, <code id="add_image_+3A_y">y</code></td>
<td>
<p>The x and y coordinates on which the image should be centered.</p>
</td></tr>
<tr><td><code id="add_image_+3A_width">width</code></td>
<td>
<p>Image width, in x-axis units.</p>
</td></tr>
<tr><td><code id="add_image_+3A_interpolate">interpolate</code></td>
<td>
<p>Passed to <a href="graphics.html#topic+rasterImage">graphics::rasterImage</a>. Use linear
interpolation when scaling the image?</p>
</td></tr>
<tr><td><code id="add_image_+3A_angle">angle</code></td>
<td>
<p>Passed to <a href="graphics.html#topic+rasterImage">graphics::rasterImage</a>. The angle (in degrees)
for rotating the image.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing; adds an image to the existing plot window.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>images &lt;- dir(system.file("extdata", package = "recolorize"),
              ".png", full.names = TRUE)
x &lt;- runif(5)
y &lt;- runif(5)
plot(x, y,
     xlim = range(x) + c(-0.2, 0.2),
     ylim = range(y) + c(-0.2, 0.2))
for (i in 1:length(images)) {
  img &lt;- readImage(images[i])
  add_image(img, x[i], y[i], width = 0.1)
}

</code></pre>

<hr>
<h2 id='adjust_color'>Adjust the saturation and brightness of a color</h2><span id='topic+adjust_color'></span>

<h3>Description</h3>

<p>Adjusts the saturation and brightness of RGB colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjust_color(
  rgb_color,
  which_colors = "all",
  saturation = 1,
  brightness = 1,
  plotting = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adjust_color_+3A_rgb_color">rgb_color</code></td>
<td>
<p>Matrix of RGB colors (0-1 scale).</p>
</td></tr>
<tr><td><code id="adjust_color_+3A_which_colors">which_colors</code></td>
<td>
<p>The indices of the colors to change. Can be a numeric
vector or &quot;all&quot; to adjust all colors.</p>
</td></tr>
<tr><td><code id="adjust_color_+3A_saturation">saturation</code></td>
<td>
<p>Factor by which to multiply saturation. &gt; 1 = more saturated,
&lt; 1 = less saturated.</p>
</td></tr>
<tr><td><code id="adjust_color_+3A_brightness">brightness</code></td>
<td>
<p>Factor by which to multiply brightness.</p>
</td></tr>
<tr><td><code id="adjust_color_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Plot resulting color palettes?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of adjusted RGB colors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate a palette:
p &lt;- grDevices::palette.colors()

# convert to RGB using col2rgb, then divide by 255 to get it into a
# 0-1 range:
p &lt;- t(col2rgb(p)/ 255 )

# we can adjust the saturation and brightness by the same factor:
p_1 &lt;- adjust_color(p, saturation = 2,
                    brightness = 1.5,
                    plotting = TRUE)

# or we can pass a vector for the factors:
p_2 &lt;- adjust_color(p,
                    saturation = seq(0, 2, length.out = 9),
                    plotting = TRUE)

# or we can target a single color:
p_3 &lt;- adjust_color(p, which_colors = 4,
                    saturation = 2, brightness = 2,
                    plotting = TRUE)

</code></pre>

<hr>
<h2 id='apply_imager_operation'>Apply imager operations to layers of an image</h2><span id='topic+apply_imager_operation'></span>

<h3>Description</h3>

<p>Internal wrapper function for applying any of several
<code>imager</code> morphological operations for cleaning pixsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_imager_operation(pixset, imager_function, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_imager_operation_+3A_pixset">pixset</code></td>
<td>
<p>An object of class <code>pixset</code>. Usually a layer from
<code><a href="#topic+splitByColor">splitByColor()</a></code> that has been converted to a <code>pixset</code>
object.</p>
</td></tr>
<tr><td><code id="apply_imager_operation_+3A_imager_function">imager_function</code></td>
<td>
<p>The name of an imager morphological operation that can
be performed on a pixset, passed as a string. See details.</p>
</td></tr>
<tr><td><code id="apply_imager_operation_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the imager function being used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Current imager operations are:
</p>

<ul>
<li> <p><code><a href="imager.html#topic+grow">imager::grow()</a></code>: Grow a pixset
</p>
</li>
<li> <p><code><a href="imager.html#topic+grow">imager::shrink()</a></code>: Shrink a pixset
</p>
</li>
<li> <p><code><a href="imager.html#topic+clean">imager::fill()</a></code>: Remove holes in an pixset. Accomplished by
growing and then shrinking a pixset.
</p>
</li>
<li> <p><code><a href="imager.html#topic+clean">imager::clean()</a></code>: Remove small isolated elements (speckle).
Accomplished by shrinking and then growing a pixset.
</p>
</li></ul>



<h3>Value</h3>

<p>The resulting pixset after applying the specified morphological
operation.
</p>

<hr>
<h2 id='array_to_cimg'>Converts from a raster array to a cimg object</h2><span id='topic+array_to_cimg'></span>

<h3>Description</h3>

<p>What it says it does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array_to_cimg(x, flatten_alpha = TRUE, bg = "white", rm_alpha = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="array_to_cimg_+3A_x">x</code></td>
<td>
<p>An image array, i.e. as read in by readPNG.</p>
</td></tr>
<tr><td><code id="array_to_cimg_+3A_flatten_alpha">flatten_alpha</code></td>
<td>
<p>Logical. Flatten the alpha channel?</p>
</td></tr>
<tr><td><code id="array_to_cimg_+3A_bg">bg</code></td>
<td>
<p>Passed to <code><a href="imager.html#topic+flatten.alpha">imager::flatten.alpha()</a></code>. Pixel color for
previously transparent pixels.</p>
</td></tr>
<tr><td><code id="array_to_cimg_+3A_rm_alpha">rm_alpha</code></td>
<td>
<p>Logical. Remove the alpha channel?
Note this will &quot;reveal&quot; whatever is hidden behind
the transparent pixels, rather than turn them white.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>cimg</code> object.
</p>

<hr>
<h2 id='array_to_RasterStack'>Convert from an array to a raster stack</h2><span id='topic+array_to_RasterStack'></span>

<h3>Description</h3>

<p>Convert from an image array to a raster stack, optionally using the alpha
channel as a mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array_to_RasterStack(
  img_array,
  type = c("stack", "brick"),
  alpha_mask = TRUE,
  return_alpha = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="array_to_RasterStack_+3A_img_array">img_array</code></td>
<td>
<p>An RGB array.</p>
</td></tr>
<tr><td><code id="array_to_RasterStack_+3A_type">type</code></td>
<td>
<p>Type of Raster* object to return. One of either &quot;stack&quot;
(<a href="raster.html#topic+stack">raster::stack</a>) or &quot;brick&quot; (<a href="raster.html#topic+brick">raster::brick</a>).</p>
</td></tr>
<tr><td><code id="array_to_RasterStack_+3A_alpha_mask">alpha_mask</code></td>
<td>
<p>Logical. Use the alpha channel as a background mask?</p>
</td></tr>
<tr><td><code id="array_to_RasterStack_+3A_return_alpha">return_alpha</code></td>
<td>
<p>Logical. Return the alpha channel as a layer?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Raster* object, either <code>RasterStack</code> or <code>RasterBrick</code> depending
on the <code>type</code> argument.
</p>

<hr>
<h2 id='assignPixels'>Assign a 2D matrix of pixels to specified colors</h2><span id='topic+assignPixels'></span>

<h3>Description</h3>

<p>Assign a 2D matrix of pixels to specified colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignPixels(
  centers,
  pixel_matrix,
  color_space = "Lab",
  ref_white = "D65",
  adjust_centers = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assignPixels_+3A_centers">centers</code></td>
<td>
<p>Matrix of color centers (rows = colors, columns = channels).</p>
</td></tr>
<tr><td><code id="assignPixels_+3A_pixel_matrix">pixel_matrix</code></td>
<td>
<p>Matrix of pixel colors (rows = pixels, columns = channels).</p>
</td></tr>
<tr><td><code id="assignPixels_+3A_color_space">color_space</code></td>
<td>
<p>Color space in which to minimize distances, passed to
<code>[grDevices]{convertColor}</code>. One of &quot;sRGB&quot;, &quot;Lab&quot;, &quot;Luv&quot;, or
&quot;XYZ&quot;. Default is &quot;Lab&quot;, a perceptually uniform (for humans) color space.</p>
</td></tr>
<tr><td><code id="assignPixels_+3A_ref_white">ref_white</code></td>
<td>
<p>Reference white for converting to different color spaces.
D65 (the default) corresponds to standard daylight.</p>
</td></tr>
<tr><td><code id="assignPixels_+3A_adjust_centers">adjust_centers</code></td>
<td>
<p>Logical. Should the returned color clusters be the
average value of the pixels assigned to that cluster? See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a largely internal function called by <code><a href="#topic+imposeColors">imposeColors()</a></code>
for recoloring an image based on extrinsic colors. If <code>adjust_centers = TRUE</code>,
then after assigning pixels to given color centers, the location of each color center
is replaced by the average color of all the pixels assigned to that center.
</p>


<h3>Value</h3>

<p>A list of class <code>color_clusters</code>, containing:
</p>

<ol>
<li> <p><code>pixel_assignments</code>: The color center assignment for each pixel.
</p>
</li>
<li> <p><code>centers</code>: A matrix of color centers. If <code>adjust_centers = FALSE</code>, this will be identical to the input of <code>centers</code>.
</p>
</li>
<li> <p><code>sizes</code>: The number of pixels assigned to each cluster.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
# RGB extremes (white, black, red, green, blue, yellow, magenta, cyan)
ctrs &lt;- matrix(c(1, 1, 1,
                 0, 0, 0,
                 1, 0, 0,
                 0, 1, 0,
                 0, 0, 1,
                 1, 1, 0,
                 1, 0, 1,
                 0, 1, 1), byrow = TRUE, ncol = 3)

# plot it
recolorize::plotColorPalette(ctrs)

# create a pixel matrix of random colors
pixel_matrix &lt;- matrix(runif(3000), ncol = 3)

# assign pixels
reassigned &lt;- recolorize::assignPixels(ctrs, pixel_matrix, adjust_centers = TRUE)
recolorize::plotColorPalette(reassigned$centers)

# if we turn off adjust_centers, the colors remain the same as the inputs:
keep.centers &lt;- recolorize::assignPixels(ctrs, pixel_matrix, adjust_centers = FALSE)
recolorize::plotColorPalette(keep.centers$centers)

</code></pre>

<hr>
<h2 id='backgroundCondition'>Generate a background condition for masking</h2><span id='topic+backgroundCondition'></span>

<h3>Description</h3>

<p>Internal function for parsing potential background conditions. Prioritizes
transparency masking if conflicting options are provided. See details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backgroundCondition(
  lower = NULL,
  upper = NULL,
  center = NULL,
  radius = NULL,
  transparent = NULL,
  alpha_channel = FALSE,
  quietly = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="backgroundCondition_+3A_lower">lower</code>, <code id="backgroundCondition_+3A_upper">upper</code></td>
<td>
<p>RGB triplet ranges for setting a bounding box of pixels to mask.</p>
</td></tr>
<tr><td><code id="backgroundCondition_+3A_center">center</code>, <code id="backgroundCondition_+3A_radius">radius</code></td>
<td>
<p>RGB triplet and radius (as a proportion) for masking
pixels within a spherical range.</p>
</td></tr>
<tr><td><code id="backgroundCondition_+3A_transparent">transparent</code></td>
<td>
<p>Logical or <code>NULL</code>. Use transparency to mask? Requires an
alpha channel.</p>
</td></tr>
<tr><td><code id="backgroundCondition_+3A_alpha_channel">alpha_channel</code></td>
<td>
<p>Logical. Is there an alpha channel?</p>
</td></tr>
<tr><td><code id="backgroundCondition_+3A_quietly">quietly</code></td>
<td>
<p>Logical. Print a message about background masking parameters?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prioritizes transparency. If <code>transparency = TRUE</code> but other options (such as
<code>lower</code> and <code>upper</code>) are specified, then only transparent pixels will be masked.
If <code>transparency = TRUE</code> but there is no alpha channel (as in a JPEG image),
this flag is ignored and other options (<code>lower</code> and <code>upper</code> or <code>center</code> and <code>radius</code>)
are used instead.
</p>
<p>This is an internal convenience function sourced by <code><a href="#topic+backgroundIndex">backgroundIndex()</a></code>.
</p>


<h3>Value</h3>

<p>A list with background masking parameters. Can be one of 4 classes:
</p>

<ol>
<li> <p><code>bg_rect</code>: If <code>lower</code> and <code>upper</code> are specified.
</p>
</li>
<li> <p><code>bg_sphere</code>: If <code>center</code> and <code>radius</code> are specified.
</p>
</li>
<li> <p><code>bg_t</code>: If <code>transparent</code> is <code>TRUE</code> and there is an alpha channel
with transparent pixels.
</p>
</li>
<li> <p><code>bg_none</code>: If no background masking is specified (or transparency
was specified but there are no transparent pixels).
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
# masking a white background:
backgroundCondition(lower = rep(0.9, 3), upper = rep(1, 3), quietly = FALSE)

# masking transparent pixels:
backgroundCondition(transparent = TRUE, alpha_channel = TRUE, quietly = FALSE)

# oops, no alpha channel:
backgroundCondition(transparent = TRUE, alpha_channel = FALSE, quietly = FALSE)

# oops, no alpha channel, but with white background as a fallback:
backgroundCondition(lower = rep(0.9, 3), upper = rep(1, 3),
                    transparent = TRUE, alpha_channel = FALSE,
                    quietly = FALSE)

</code></pre>

<hr>
<h2 id='backgroundIndex'>Index and remove background pixels for color clustering</h2><span id='topic+backgroundIndex'></span>

<h3>Description</h3>

<p>Largely internal function for identifying, indexing, and removing background
pixels from an image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backgroundIndex(img, bg_condition)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="backgroundIndex_+3A_img">img</code></td>
<td>
<p>An image array, preferably the output of <code><a href="png.html#topic+readPNG">png::readPNG()</a></code>,
<code><a href="jpeg.html#topic+readJPEG">jpeg::readJPEG()</a></code>, or <code>link[recolorize]{readImage}</code>.</p>
</td></tr>
<tr><td><code id="backgroundIndex_+3A_bg_condition">bg_condition</code></td>
<td>
<p>Background condition, output of
<code><a href="#topic+backgroundCondition">backgroundCondition()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function flattens a 3-channel image into a 2D matrix before indexing and
removing background pixels to take advantage of faster indexing procedures.
The <code>idx</code>, <code>idx_flat</code>, and <code>img_dims</code> elements are used to reconstruct the
original and recolored images by other functions.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ol>
<li> <p><code>flattened_img</code>: The original image, flattened into a 2D matrix
(rows = pixels, columns = channels).
</p>
</li>
<li> <p><code>img_dims</code>: Dimensions of the original image.
</p>
</li>
<li> <p><code>non_bg</code>: Pixels from <code>flattened_img</code> that fall outside the
background masking conditions. Used for further color clustering and
analysis.
</p>
</li>
<li> <p><code>idx</code>: 2D (row-column) indices for background pixels.
</p>
</li>
<li> <p><code>idx_flat</code>: Same as <code>idx</code>, but flattened to vector order.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># get image path and read in image
img_path &lt;- system.file("extdata/chongi.png", package = "recolorize")
img &lt;- png::readPNG(img_path)
recolorize::plotImageArray(img)

# generate a white background condition
bg_condition &lt;- backgroundCondition(lower = rep(0.9, 3),
                                    upper = rep(1, 3))

# index background pixels
bg_indexed &lt;- backgroundIndex(img, bg_condition)

# we can reconstruct the original image from the flattened array
img2 &lt;- bg_indexed$flattened_img
dim(img2) &lt;- bg_indexed$img_dims

# notice the original background color (light gray) now shows
recolorize::plotImageArray(img2)

</code></pre>

<hr>
<h2 id='blurImage'>Blur an image</h2><span id='topic+blurImage'></span>

<h3>Description</h3>

<p>Blurs an image using the one of five blur functions in <code>imager</code>.
Useful for decreasing image noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blurImage(
  img,
  blur_function = c("medianblur", "isoblur", "blur_anisotropic", "boxblur", "boxblur_xy"),
  ...,
  plotting = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blurImage_+3A_img">img</code></td>
<td>
<p>An image array, as read in by <a href="png.html#topic+readPNG">png::readPNG</a> or <a href="#topic+readImage">readImage</a>.</p>
</td></tr>
<tr><td><code id="blurImage_+3A_blur_function">blur_function</code></td>
<td>
<p>A string matching the name of an imager blur function.
One of c(&quot;isoblur&quot;, &quot;medianblur&quot;, &quot;blur_anisotropic&quot;, &quot;boxblur&quot;,
&quot;boxblur_xy&quot;).</p>
</td></tr>
<tr><td><code id="blurImage_+3A_...">...</code></td>
<td>
<p>Parameters passed to whichever <code>blur_function</code> is called.</p>
</td></tr>
<tr><td><code id="blurImage_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Plot the blurred image next to the input
for comparison?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters passed with the <code>...</code> argument are specific
to each of the five blur functions; see their documentation for what to
specify: <a href="imager.html#topic+isoblur">imager::isoblur</a>, <a href="imager.html#topic+medianblur">imager::medianblur</a>, <a href="imager.html#topic+boxblur">imager::boxblur</a>,
<a href="imager.html#topic+blur_anisotropic">imager::blur_anisotropic</a>, <a href="imager.html#topic+boxblur_xy">imager::boxblur_xy</a>. The <code>medianblur</code> and
<code>blur_anisotropic</code> functions are best for preserving edges.
</p>


<h3>Value</h3>

<p>An image array of the blurred image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

img_path &lt;- system.file("extdata/fulgidissima.png", package = "recolorize")
img &lt;- readImage(img_path)
median_img &lt;- blurImage(img, "medianblur", n = 5, threshold = 0.5)
anisotropic_img &lt;- blurImage(img, "blur_anisotropic",
                             amplitude = 5, sharpness = 0.1)

# save current graphical parameters:
current_par &lt;- graphics::par(no.readonly = TRUE)
graphics::layout(matrix(1:3, nrow = 1))

plotImageArray(img, "original")
plotImageArray(median_img, "median")
plotImageArray(anisotropic_img, "anisotropic")

# and reset:
graphics::par(current_par)

</code></pre>

<hr>
<h2 id='brick_to_array'>Convert from a RasterBrick to an array</h2><span id='topic+brick_to_array'></span>

<h3>Description</h3>

<p>Converts from a RasterBrick to a numeric array. Useful
in going from patternize to recolorize.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>brick_to_array(raster_brick)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="brick_to_array_+3A_raster_brick">raster_brick</code></td>
<td>
<p>An object of RasterBrick class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is provided to convert from the RasterBrick objects provided
by the alignment functions in the patternize package, e.g. <code>alignLan</code>.
</p>


<h3>Value</h3>

<p>An image array (probably 1, 3, or 4 channels).
</p>

<hr>
<h2 id='cielab_coldist'>Generate a 'coldist' object for CIE Lab colors</h2><span id='topic+cielab_coldist'></span>

<h3>Description</h3>

<p>A stopgap function for generating a <a href="pavo.html#topic+coldist">pavo::coldist</a> object
from CIE Lab colors. This a pretty serious abstraction of the
original intention of a <code>coldist</code> object, which is to use
a combination of spectra data, visual model, and/or receptor-noise
model to calculate perceived chromatic and achromatic distances
between colors. Because CIE Lab color space is an approximately
perceptually uniform color space for human vision, we can calculate
a version of those distances for a human viewer directly from
CIE Lab. A decent option if you want preliminary results,
if you only care about human perception, or if you don't have access
to spectral data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cielab_coldist(rgbcols)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cielab_coldist_+3A_rgbcols">rgbcols</code></td>
<td>
<p>An nx3 matrix of RGB colors (rows are colors and
columns are R, G, and B channels).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>I have mixed feelings about this function and would like to
replace it with something a little less hand-wavey.
</p>


<h3>Value</h3>

<p>A <a href="pavo.html#topic+coldist">pavo::coldist</a> object with four columns: the patches
being contrasted (columns 1-2), the chromatic contrast (<code>dS</code>),
and the achromatic contrast (<code>dL</code>), all in units of Euclidean
distance in CIE Lab space.
</p>

<hr>
<h2 id='cimg_to_array'>Converts from cimg to raster array</h2><span id='topic+cimg_to_array'></span>

<h3>Description</h3>

<p>What it says it does.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cimg_to_array(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cimg_to_array_+3A_x">x</code></td>
<td>
<p>A <code>cimg</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3D array.
</p>

<hr>
<h2 id='classify_recolorize'>Convert a <code>recolorize</code> object to a <code>classify</code> object</h2><span id='topic+classify_recolorize'></span>

<h3>Description</h3>

<p>Converts a <a href="#topic+recolorize">recolorize</a> object to a <a href="pavo.html#topic+classify">pavo::classify</a> object for
use in pavo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classify_recolorize(recolorize_obj, imgname = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classify_recolorize_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>A <code>recolorize</code> object.</p>
</td></tr>
<tr><td><code id="classify_recolorize_+3A_imgname">imgname</code></td>
<td>
<p>Name of the image (a string).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is mostly for internal use, and hasn't been tested much.
</p>


<h3>Value</h3>

<p>A <a href="pavo.html#topic+classify">pavo::classify</a> object. The background patch will always
be the first color (patch 1), and will be white by default.
</p>

<hr>
<h2 id='clean_merge_params'>Clean up parameters passed to mergeLayers</h2><span id='topic+clean_merge_params'></span>

<h3>Description</h3>

<p>Internal function for tidiness.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_merge_params(recolorize_obj, merge_list, color_to)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_merge_params_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>Object of <code>recolorize</code> class.</p>
</td></tr>
<tr><td><code id="clean_merge_params_+3A_merge_list">merge_list</code></td>
<td>
<p>List of layers to merge.</p>
</td></tr>
<tr><td><code id="clean_merge_params_+3A_color_to">color_to</code></td>
<td>
<p>Argument for coloring new layers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>mergeLayers</code> parameters in a standardized format.
</p>

<hr>
<h2 id='col2col'>Modified convertColor</h2><span id='topic+col2col'></span>

<h3>Description</h3>

<p>Just like <a href="grDevices.html#topic+convertColor">grDevices::convertColor</a>, but with HSV as an option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>col2col(
  pixel_matrix,
  from = c("sRGB", "Lab", "Luv", "HSV"),
  to = c("sRGB", "Lab", "Luv", "HSV"),
  ref_white = "D65"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="col2col_+3A_pixel_matrix">pixel_matrix</code></td>
<td>
<p>A matrix of pixel colors, rows are pixels and columns
are channels.</p>
</td></tr>
<tr><td><code id="col2col_+3A_from">from</code></td>
<td>
<p>Color space to convert from.</p>
</td></tr>
<tr><td><code id="col2col_+3A_to">to</code></td>
<td>
<p>Color space to convert to.</p>
</td></tr>
<tr><td><code id="col2col_+3A_ref_white">ref_white</code></td>
<td>
<p>Reference white.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As my mother used to say: good enough for government work.
</p>


<h3>Value</h3>

<p>A pixel matrix in the specified <code>to</code> color space.
</p>

<hr>
<h2 id='colorClusters'>Generate color clusters from an image</h2><span id='topic+colorClusters'></span>

<h3>Description</h3>

<p>Clusters all the pixels in an image according to the specified method and
returns color centers, cluster assignments, and cluster sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorClusters(
  bg_indexed,
  method = c("histogram", "kmeans"),
  n = 10,
  bins = 3,
  color_space = "Lab",
  ref_white = "D65",
  bin_avg = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colorClusters_+3A_bg_indexed">bg_indexed</code></td>
<td>
<p>A list returned by <code><a href="#topic+backgroundIndex">backgroundIndex()</a></code>.</p>
</td></tr>
<tr><td><code id="colorClusters_+3A_method">method</code></td>
<td>
<p>Binning scheme to use, one of either <code>kmeans</code> or <code>histogram</code>.
Produce very different results (see details).</p>
</td></tr>
<tr><td><code id="colorClusters_+3A_n">n</code></td>
<td>
<p>If <code>method = "kmeans"</code>, the number of colors to fit.</p>
</td></tr>
<tr><td><code id="colorClusters_+3A_bins">bins</code></td>
<td>
<p>If <code>method = "histogram"</code>, either the number of bins per color
channel (if a single number is provided) OR a vector of length 3 with the
number of bins for each channel.</p>
</td></tr>
<tr><td><code id="colorClusters_+3A_color_space">color_space</code></td>
<td>
<p>Color space in which to cluster colors, passed to
<code>[grDevices]{convertColor}</code>. One of &quot;sRGB&quot;, &quot;Lab&quot;, or &quot;Luv&quot;.
Default is &quot;Lab&quot;, a perceptually uniform (for humans) color space.</p>
</td></tr>
<tr><td><code id="colorClusters_+3A_ref_white">ref_white</code></td>
<td>
<p>Reference white for converting to different color spaces.
D65 (the default) corresponds to standard daylight.</p>
</td></tr>
<tr><td><code id="colorClusters_+3A_bin_avg">bin_avg</code></td>
<td>
<p>Logical. Return the color centers as the average of the pixels
assigned to the bin (the default), or the geometric center of the bin?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code> clustering tries to find the set of <code>n</code> clusters
that minimize overall distances. Histogram binning divides up color space
according to set breaks; for example, bins = 2 would divide the red, green,
and blue channels into 2 bins each (&gt; 0.5 and &lt; 0 .5), resulting in 8
possible ranges. A white pixel (RGB = 1, 1, 1) would fall into the R \&gt; 0.5, G
\&gt; 0.5, B \&gt; 0.5 bin. The resulting centers represent the average color of all
the pixels assigned to that bin.
</p>
<p>K-means clustering can produce more intuitive results, but because it is
iterative, it will find slightly different clusters each time it is run, and
their order will be arbitrary. It also tends to divide up similar colors that
make up the majority of the image. Histogram binning will produce the same
results every time, in the same order, and because it forces the bins to be
dispersed throughout color space, tends to better pick up small color
details. Bins are also comparable across images. However, this sometimes
means returning empty bins (i.e. the white bin will be empty if clustering a
very dark image).
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ol>
<li> <p><code>pixel_assignments</code>: A vector of color center assignments for
each pixel.
</p>
</li>
<li> <p><code>centers</code>: A matrix of color centers, in RGB color space.
</p>
</li>
<li> <p><code>sizes</code>: The number of pixels assigned to each cluster.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
# make a 100x100 'image' of random colors
img &lt;- array(runif(30000), dim = c(100, 100, 3))
plotImageArray(img)

# make a background index object:
bg_indexed &lt;- backgroundIndex(img, backgroundCondition())

# histogram clustering
hist_clusters &lt;- colorClusters(bg_indexed, method = "hist", bins = 2)
plotColorPalette(hist_clusters$centers)

# we can use a different number of bins for each channel
uneven_clusters &lt;- colorClusters(bg_indexed, method = "hist",
                                 bins = c(3, 2, 1))
plotColorPalette(uneven_clusters$centers)

# using kmeans
kmeans_clusters &lt;- colorClusters(bg_indexed, method = "kmeans",
                                 n = 5)
plotColorPalette(kmeans_clusters$centers)

</code></pre>

<hr>
<h2 id='colorClustersHist'>Cluster pixel colors using histogram binning</h2><span id='topic+colorClustersHist'></span>

<h3>Description</h3>

<p>Clusters pixel colors by dividing color space up into specified bins,
then taking the average color of all the pixels within that bin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorClustersHist(
  pixel_matrix,
  bins = 3,
  color_space = c("Lab", "sRGB", "Luv", "HSV"),
  ref_white = "D65",
  bin_avg = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colorClustersHist_+3A_pixel_matrix">pixel_matrix</code></td>
<td>
<p>2D matrix of pixels to classify (rows = pixels, columns =
channels).</p>
</td></tr>
<tr><td><code id="colorClustersHist_+3A_bins">bins</code></td>
<td>
<p>Number of bins for each channel OR a vector of length 3 with bins
for each channel. <code>bins = 3</code> will result in 3^3 = 27 bins; <code>bins = c(2, 2, 3)</code>
will result in 2<em>2</em>3 = 12 bins (2 red, 2 green, 3 blue if you're in RGB
color space), etc.</p>
</td></tr>
<tr><td><code id="colorClustersHist_+3A_color_space">color_space</code></td>
<td>
<p>Color space in which to cluster colors, passed to
<code>[grDevices]{convertColor}</code>. One of &quot;sRGB&quot;, &quot;Lab&quot;, or &quot;Luv&quot;.
Default is &quot;Lab&quot;, a perceptually uniform (for humans) color space.</p>
</td></tr>
<tr><td><code id="colorClustersHist_+3A_ref_white">ref_white</code></td>
<td>
<p>Reference white for converting to different color spaces.
D65 (the default) corresponds to standard daylight.</p>
</td></tr>
<tr><td><code id="colorClustersHist_+3A_bin_avg">bin_avg</code></td>
<td>
<p>Logical. Return the color centers as the average of the pixels
assigned to the bin (the default), or the geometric center of the bin?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Called by <code><a href="#topic+colorClusters">colorClusters()</a></code>. See that documentation for
examples.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ol>
<li> <p><code>pixel_assignments</code>: A vector of color center assignments for
each pixel.
</p>
</li>
<li> <p><code>centers</code>: A matrix of color centers.
</p>
</li>
<li> <p><code>sizes</code>: The number of pixels assigned to each cluster.
</p>
</li></ol>


<hr>
<h2 id='colorClustersKMeans'>Cluster pixel colors using K-means clustering</h2><span id='topic+colorClustersKMeans'></span>

<h3>Description</h3>

<p>Clusters pixel colors using <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorClustersKMeans(
  pixel_matrix,
  n = 10,
  color_space = "Lab",
  ref_white = "D65"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colorClustersKMeans_+3A_pixel_matrix">pixel_matrix</code></td>
<td>
<p>2D matrix of pixels to classify (rows = pixels, columns =
channels).</p>
</td></tr>
<tr><td><code id="colorClustersKMeans_+3A_n">n</code></td>
<td>
<p>Number of clusters to fit.</p>
</td></tr>
<tr><td><code id="colorClustersKMeans_+3A_color_space">color_space</code></td>
<td>
<p>Color space in which to cluster colors, passed to
<code>[grDevices]{convertColor}</code>. One of &quot;sRGB&quot;, &quot;Lab&quot;, &quot;Luv&quot;, or
&quot;XYZ&quot;. Default is &quot;Lab&quot;, a perceptually uniform (for humans) color space.</p>
</td></tr>
<tr><td><code id="colorClustersKMeans_+3A_ref_white">ref_white</code></td>
<td>
<p>Reference white for converting to different color spaces.
D65 (the default) corresponds to standard daylight.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Called by <code><a href="#topic+colorClusters">colorClusters()</a></code>. See that documentation for
examples.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ol>
<li> <p><code>pixel_assignments</code>: A vector of color center assignments for each pixel.
</p>
</li>
<li> <p><code>centers</code>: A matrix of color centers.
</p>
</li>
<li> <p><code>sizes</code>: The number of pixels assigned to each cluster.
</p>
</li></ol>


<hr>
<h2 id='colorResiduals'>Calculate squared residuals for color centers</h2><span id='topic+colorResiduals'></span>

<h3>Description</h3>

<p>Calculates the squared distance between each pixel and its assigned color
center.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorResiduals(
  pixel_matrix,
  pixel_assignments,
  centers,
  color_space = "Lab",
  metric = "euclidean",
  ref_white = "D65"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="colorResiduals_+3A_pixel_matrix">pixel_matrix</code></td>
<td>
<p>2D matrix of pixels to classify (rows = pixels, columns =
channels).</p>
</td></tr>
<tr><td><code id="colorResiduals_+3A_pixel_assignments">pixel_assignments</code></td>
<td>
<p>A vector of color center assignments for each
pixel. Must match the order of <code>pixel_matrix</code>.</p>
</td></tr>
<tr><td><code id="colorResiduals_+3A_centers">centers</code></td>
<td>
<p>A matrix of color centers, with rows as centers and
columns as color channels. Rows are assumed to match the index values of
<code>pixel_assignments</code>, e.g. a pixel assigned <code>1</code> in the assignment vector
is assigned to the color in the first row of <code>centers</code>.</p>
</td></tr>
<tr><td><code id="colorResiduals_+3A_color_space">color_space</code></td>
<td>
<p>Color space in which to calculate distances. One of
&quot;sRGB&quot;, &quot;Lab&quot;, &quot;Luv&quot;, or &quot;XYZ&quot;. Passed to
<code><a href="grDevices.html#topic+convertColor">grDevices::convertColor()</a></code>.</p>
</td></tr>
<tr><td><code id="colorResiduals_+3A_metric">metric</code></td>
<td>
<p>Distance metric to be used for calculating pairwise pixel
distances in the given color space; passed to <code><a href="stats.html#topic+dist">stats::dist()</a></code>.</p>
</td></tr>
<tr><td><code id="colorResiduals_+3A_ref_white">ref_white</code></td>
<td>
<p>Passed to <code><a href="grDevices.html#topic+convertColor">grDevices::convertColor()</a></code> if
<code style="white-space: pre;">&#8288;color_space = "Lab&#8288;</code>. Reference white for CIE Lab space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following attributes:
</p>

<ol>
<li> <p><code>sq_residuals</code>: The squared residual for every pixel in pixel_matrix.
</p>
</li>
<li> <p><code>tot_residuals</code>: The sum of all squared residuals.
</p>
</li>
<li> <p><code>avg_residual</code>: The average squared residual.
</p>
</li>
<li> <p><code>residuals_by_center</code>: A list of squared residuals for every color center.
</p>
</li>
<li> <p><code>avg_by_center</code>: The average squared residual for every color center.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'># RGB extremes (white, black, red, green, blue, yellow, magenta, cyan)
ctrs &lt;- matrix(c(1, 1, 1,
                 0, 0, 0,
                 1, 0, 0,
                 0, 1, 0,
                 0, 0, 1,
                 1, 1, 0,
                 1, 0, 1,
                 0, 1, 1), byrow = TRUE, ncol = 3)

# plot it
recolorize::plotColorPalette(ctrs)

# create a pixel matrix of random colors
pixel_matrix &lt;- matrix(runif(3000), ncol = 3)

# assign pixels
# see `assignPixels` function for details
reassigned &lt;- assignPixels(ctrs, pixel_matrix, adjust_centers = TRUE)

# find residuals from original color centers
color_residuals &lt;- colorResiduals(pixel_matrix = pixel_matrix,
                                  pixel_assignments = reassigned$pixel_assignments,
                                  centers = ctrs)

# compare to residuals from adjusted color centers
color_residuals_adjust &lt;- colorResiduals(pixel_matrix = pixel_matrix,
                                  pixel_assignments = reassigned$pixel_assignments,
                                  centers = reassigned$centers)
# to reset graphical parameters:
current_par &lt;- graphics::par(no.readonly = TRUE)

layout(matrix(1:2, nrow = 2))
hist(color_residuals$sq_residuals,
 breaks = 30, border = NA, col = "tomato",
 xlim = c(0, 1), xlab = "Squared residual",
 main = "Original centers")

hist(color_residuals_adjust$sq_residuals,
breaks = 30, border = NA, col = "cornflowerblue",
xlim = c(0, 1), xlab = "Squared residual",
main = "Adjusted centers")

graphics::par(current_par)
</code></pre>

<hr>
<h2 id='constructImage'>Generate an image from pixel assignments and color matrix</h2><span id='topic+constructImage'></span>

<h3>Description</h3>

<p>Combines a matrix of pixel assignments and a corresponding
matrix of colors to make a recolored RGB image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>constructImage(pixel_assignments, centers, background_color = "white")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constructImage_+3A_pixel_assignments">pixel_assignments</code></td>
<td>
<p>A matrix of index values for each pixel which
corresponds to <code>centers</code> (e.g. a <code>1</code> indicates that pixel is the
color of the first row of <code>centers</code>). Pixels with an index value of 0
are considered background.</p>
</td></tr>
<tr><td><code id="constructImage_+3A_centers">centers</code></td>
<td>
<p>An n x 3 matrix of color centers where rows are colors
and columns are R, G, and B channels.</p>
</td></tr>
<tr><td><code id="constructImage_+3A_background_color">background_color</code></td>
<td>
<p>A numeric RGB triplet, a hex code, or a named
R color for the background. Will be masked by alpha channel (and appear
white in the plot window), but will be revealed if the alpha
channel is removed. If the alpha channel is a background mask,
this is the 'baked in' background color.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An image (raster) array of the recolored image,
with four channels (R, G, B, and alpha).
</p>

<hr>
<h2 id='editLayer'>Edit a color patch using morphological operations</h2><span id='topic+editLayer'></span>

<h3>Description</h3>

<p>Applies one of several morphological operations from <code>imager</code> to a layer of a
recolorize object. Convenient for cleaning up a color patch without affecting
other layers of the recolorized image. This can be used to despeckle, fill in
holes, or uniformly grow or shrink a color patch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editLayer(
  recolorize_obj,
  layer_idx,
  operation = "clean",
  px_size = 2,
  plotting = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="editLayer_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>A recolorize object from <code><a href="#topic+recolorize">recolorize()</a></code>,
<code><a href="#topic+recluster">recluster()</a></code>, or <code><a href="#topic+imposeColors">imposeColors()</a></code>.</p>
</td></tr>
<tr><td><code id="editLayer_+3A_layer_idx">layer_idx</code></td>
<td>
<p>A single index value (numeric) indicating which
layer to edit. Corresponds to the order of the colors in the <code>centers</code>
attribute of the recolorize object, and to the indices in the
<code>pixel_assignments</code> attribute of the same.</p>
</td></tr>
<tr><td><code id="editLayer_+3A_operation">operation</code></td>
<td>
<p>The name of an imager morphological operation to perform on
the layer, passed as a string. See details.</p>
</td></tr>
<tr><td><code id="editLayer_+3A_px_size">px_size</code></td>
<td>
<p>The size (in pixels) of the elements to filter. If
<code>operation = "shrink"</code> and <code>px_size = 2</code>, for example, the color
patch will be shrunk by a 2-pixel radius.</p>
</td></tr>
<tr><td><code id="editLayer_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Plot results?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Current imager operations are:
</p>

<ul>
<li> <p><code><a href="imager.html#topic+grow">imager::grow()</a></code>: Grow a pixset
</p>
</li>
<li> <p><code><a href="imager.html#topic+grow">imager::shrink()</a></code>: Shrink a pixset
</p>
</li>
<li> <p><code><a href="imager.html#topic+clean">imager::fill()</a></code>: Remove holes in an pixset. Accomplished by
growing and then shrinking a pixset.
</p>
</li>
<li> <p><code><a href="imager.html#topic+clean">imager::clean()</a></code>: Remove small isolated elements (speckle).
Accomplished by shrinking and then growing a pixset.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>recolorize</code> object. The <code>sizes</code>, <code style="white-space: pre;">&#8288;pixel_assignments,&#8288;</code>, and
<code>recolored_img</code> attributes will differ from the input object for the
relevant color patch (layer) to reflect the edited layer.
</p>


<h3>See Also</h3>

<p><a href="#topic+editLayers">editLayers</a> for editing multiple layers (with multiple operations)
at once; a wrapper for this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load image and recolorize it
img &lt;- system.file("extdata/corbetti.png", package = "recolorize")

# first do a standard color binning
init_fit &lt;- recolorize(img, bins = 2, plotting = FALSE)

# then cluster patches by similarity
re_fit &lt;- recluster(init_fit, cutoff = 40)

# to reset graphical parameters:
current_par &lt;- graphics::par(no.readonly = TRUE)

# examine individual layers:
layout(matrix(1:6, nrow = 2))
layers &lt;- splitByColor(re_fit, plot_method = "color")

# notice patch 2 (cream) - lots of stray pixels
edit_cream_layer &lt;- editLayer(re_fit,
                              layer_idx = 2,
                              operation = "clean",
                              px_size = 3)

# shrinking and growing by the same element size gives us less flexibility, so
# we can also shrink and then grow, using different px_size arguments:
edit_green_1 &lt;- editLayer(re_fit,
                          layer_idx = 4,
                          operation = "shrink",
                          px_size = 2)
edit_green_2 &lt;- editLayer(edit_green_1,
                          layer_idx = 4,
                          operation = "grow",
                          px_size = 3)

# we can get pleasingly mondrian about it:
new_fit &lt;- re_fit
for (i in 1:nrow(new_fit$centers)) {
  new_fit &lt;- editLayer(new_fit,
                       layer_idx = i,
                       operation = "fill",
                       px_size = 5, plotting = FALSE)
}
plot(new_fit)

graphics::par(current_par)

</code></pre>

<hr>
<h2 id='editLayers'>Edit multiple color patches using morphological operations</h2><span id='topic+editLayers'></span>

<h3>Description</h3>

<p>A wrapper for <a href="#topic+editLayer">editLayer</a>, allowing for multiple layers
to be edited at once, either with the same morphological operation
or specified for each layer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editLayers(
  recolorize_obj,
  layer_idx = "all",
  operations = "clean",
  px_sizes = 2,
  plotting = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="editLayers_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>A recolorize object from <code><a href="#topic+recolorize">recolorize()</a></code>,
<code><a href="#topic+recluster">recluster()</a></code>, or <code><a href="#topic+imposeColors">imposeColors()</a></code>.</p>
</td></tr>
<tr><td><code id="editLayers_+3A_layer_idx">layer_idx</code></td>
<td>
<p>A numeric vector of layer indices to be edited, or <code>"all"</code>
(in which case all layers are edited). Corresponds to the order of the
colors in the <code>centers</code> attribute of the recolorize object, and to the
indices in the <code>pixel_assignments</code> attribute of the same.</p>
</td></tr>
<tr><td><code id="editLayers_+3A_operations">operations</code></td>
<td>
<p>Either a single string OR a character vector of imager
morphological operation(s) to perform on the specified layer(s). If this is
shorter than <code>layer_idx</code>, it is repeated to match the length of
<code>layer_idx</code>.</p>
</td></tr>
<tr><td><code id="editLayers_+3A_px_sizes">px_sizes</code></td>
<td>
<p>The size(s) (in pixels) of the elements to filter. Either a
single number OR a numeric vector. If shorter than <code>layer_idx</code>, it is
repeated to match the length of <code>layer_idx</code>. If <code>operation = "shrink"</code> and
<code>px_size = 2</code>, for example, the color patch will be shrunk by a 2-pixel
radius.</p>
</td></tr>
<tr><td><code id="editLayers_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Plot results?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Current imager operations are:
</p>

<ul>
<li> <p><code><a href="imager.html#topic+grow">imager::grow()</a></code>: Grow a pixset
</p>
</li>
<li> <p><code><a href="imager.html#topic+grow">imager::shrink()</a></code>: Shrink a pixset
</p>
</li>
<li> <p><code><a href="imager.html#topic+clean">imager::fill()</a></code>: Remove holes in an pixset. Accomplished by
growing and then shrinking a pixset.
</p>
</li>
<li> <p><code><a href="imager.html#topic+clean">imager::clean()</a></code>: Remove small isolated elements (speckle).
Accomplished by shrinking and then growing a pixset.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>recolorize</code> object. The <code>sizes</code>, <code style="white-space: pre;">&#8288;pixel_assignments,&#8288;</code>, and
<code>recolored_img</code> attributes will differ from the input object for the
relevant color patches (layers) to reflect their changes.
</p>


<h3>See Also</h3>

<p><a href="#topic+editLayer">editLayer</a> for editing a single layer at a time.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load image and recolorize it
img &lt;- system.file("extdata/corbetti.png", package = "recolorize")

# first do a standard color binning
init_fit &lt;- recolorize(img, bins = 2, plotting = FALSE)

# then cluster patches by similarity
re_fit &lt;- recluster(init_fit, cutoff = 40)

# to reset graphical parameters:
current_par &lt;- graphics::par(no.readonly = TRUE)

# examine individual layers:
layout(matrix(1:6, nrow = 2))
layers &lt;- splitByColor(re_fit, plot_method = "color")

# we can clean them all using the same parameters...
edited_fit &lt;- editLayers(re_fit, layer_idx = "all",
                         operations = "clean",
                         px_sizes = 2, plotting = TRUE)
# ...but some of those patches don't look so good

# we can use different px_sizes for each layer:
edited_fit_2 &lt;- editLayers(re_fit, layer_idx = "all",
                           operations = "clean",
                           px_sizes = c(1, 3, 1,
                                        2, 1, 2),
                           plotting = TRUE)

# better yet, we can fill some layers and clean others:
edited_fit_3 &lt;- editLayers(re_fit, layer_idx = "all",
                           operations = c("fill", "clean",
                                          "fill", "fill",
                                          "fill", "clean"),
                           px_sizes = c(2, 3,
                                        2, 2,
                                        4, 2))

# or you could just get weird:
edited_fit_3 &lt;- editLayers(re_fit, layer_idx = c(1:6),
                           operations = c("fill", "clean"),
                           px_sizes = c(10, 20))

# reset graphical parameters:
graphics::par(current_par)

</code></pre>

<hr>
<h2 id='expand_recolorize'>Expand aspects of a recolorize object for other functions</h2><span id='topic+expand_recolorize'></span>

<h3>Description</h3>

<p>Expand aspects of a recolorize object for other functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_recolorize(
  recolorize_obj,
  original_img = FALSE,
  recolored_img = FALSE,
  sizes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expand_recolorize_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>A <code>recolorize</code> object.</p>
</td></tr>
<tr><td><code id="expand_recolorize_+3A_original_img">original_img</code></td>
<td>
<p>Logical. Return original image as numeric array?</p>
</td></tr>
<tr><td><code id="expand_recolorize_+3A_recolored_img">recolored_img</code></td>
<td>
<p>Logical. Return recolored image as numeric array?</p>
</td></tr>
<tr><td><code id="expand_recolorize_+3A_sizes">sizes</code></td>
<td>
<p>Logical. Return cluster sizes (as number of pixels)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>recolorize</code> object with the indicated additional elements,
as well as the original elements.
</p>

<hr>
<h2 id='hclust_color'>Plot and group colors by similarity</h2><span id='topic+hclust_color'></span>

<h3>Description</h3>

<p>A wrapper for <a href="stats.html#topic+hclust">stats::hclust</a> for clustering colors by similarity.
This works by converting a matrix of RGB centers to a given color space
(CIE Lab is the default), generating a distance matrix for those colors
in that color space (or a subset of channels of that color space),
clustering them, and plotting them with labels and colors. If either a
cutoff or a final number of colors is provided and <code>return_list = TRUE</code>,
function also returns a list of which color centers to combine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hclust_color(
  rgb_centers,
  dist_method = "euclidean",
  hclust_method = "complete",
  channels = 1:3,
  color_space = "Lab",
  ref_white = "D65",
  cutoff = NULL,
  n_final = NULL,
  return_list = TRUE,
  plotting = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hclust_color_+3A_rgb_centers">rgb_centers</code></td>
<td>
<p>A matrix of RGB centers. Rows are centers and columns
are R, G, and B values.</p>
</td></tr>
<tr><td><code id="hclust_color_+3A_dist_method">dist_method</code></td>
<td>
<p>Method passed to <a href="stats.html#topic+dist">stats::dist</a>. One of  &quot;euclidean&quot;,
&quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot; or &quot;minkowski&quot;.</p>
</td></tr>
<tr><td><code id="hclust_color_+3A_hclust_method">hclust_method</code></td>
<td>
<p>Method passed to <a href="stats.html#topic+hclust">stats::hclust</a>. One of &quot;ward.D&quot;,
&quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot; (= UPGMA), &quot;mcquitty&quot; (= WPGMA),
&quot;median&quot; (= WPGMC) or &quot;centroid&quot; (= UPGMC).</p>
</td></tr>
<tr><td><code id="hclust_color_+3A_channels">channels</code></td>
<td>
<p>Numeric: which color channels to use for clustering. Probably
some combination of 1, 2, and 3, e.g., to consider only luminance and
blue-yellow (b-channel) distance in CIE Lab space, <code style="white-space: pre;">&#8288;channels = c(1, 3&#8288;</code> (L
and b).</p>
</td></tr>
<tr><td><code id="hclust_color_+3A_color_space">color_space</code></td>
<td>
<p>Color space in which to do the clustering.</p>
</td></tr>
<tr><td><code id="hclust_color_+3A_ref_white">ref_white</code></td>
<td>
<p>Reference white for converting to different color spaces.
D65 (the default) corresponds to standard daylight. See
<a href="grDevices.html#topic+convertColor">grDevices::convertColor</a>.</p>
</td></tr>
<tr><td><code id="hclust_color_+3A_cutoff">cutoff</code></td>
<td>
<p>Either <code>NULL</code> or a numeric cutoff passed to <a href="stats.html#topic+cutree">stats::cutree</a>.
Distance below which to combine clusters, i.e. height at which the tree
should be cut.</p>
</td></tr>
<tr><td><code id="hclust_color_+3A_n_final">n_final</code></td>
<td>
<p>Numeric. Desired number of groups. Overrides <code>cutoff</code> if
both are provided.</p>
</td></tr>
<tr><td><code id="hclust_color_+3A_return_list">return_list</code></td>
<td>
<p>Logical. Return a list of new group assignments from
the <code>cutoff</code> or <code>n_final</code> values?</p>
</td></tr>
<tr><td><code id="hclust_color_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Plot a colored dendrogram?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is mostly useful in deciding where and in which color space
to place a cutoff for a <code>recolorize</code> object, since it is very fast. It
is called by <a href="#topic+recluster">recluster</a> when combining layers by similarity.
</p>


<h3>Value</h3>

<p>A list of group assignments (i.e. which centers belong to which
groups), if <code>return_list = TRUE</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+recluster">recluster</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# 50 random RGB colors
rgb_random &lt;- matrix(runif(150), nrow = 50, ncol = 3)

# default clustering (Lab space):
hclust_color(rgb_random, return_list = FALSE)

# clustering in RGB space (note change in Y-axis scale):
hclust_color(rgb_random, color_space = "sRGB", return_list = FALSE)

# clustering using only luminance:
hclust_color(rgb_random, channels = 1, return_list = FALSE)

# or only red-green ('a' channel):
hclust_color(rgb_random, channels = 2, return_list = FALSE)

# or only blue-yellow ('b' channel(:
hclust_color(rgb_random, channels = 3, return_list = FALSE)

# use a cutoff to get groups:
groups &lt;- hclust_color(rgb_random, cutoff = 100)
print(groups)

</code></pre>

<hr>
<h2 id='imDist'>Calculates the distance between non-transparent pixels in images</h2><span id='topic+imDist'></span>

<h3>Description</h3>

<p>Compares two versions of the same image (probably original and recolored)
by calculating the color distance between the colors of each pair of pixels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imDist(
  im1,
  im2,
  color_space = c("Lab", "sRGB", "XYZ", "Luv"),
  ref_white = "D65",
  metric = "euclidean",
  plotting = TRUE,
  palette = "default",
  main = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imDist_+3A_im1">im1</code>, <code id="imDist_+3A_im2">im2</code></td>
<td>
<p>Images to compare; must have the same dimensions. Distances
will be calculated between each pair of non-transparent pixels.</p>
</td></tr>
<tr><td><code id="imDist_+3A_color_space">color_space</code></td>
<td>
<p>Color space in which to calculate distances. One of
&quot;sRGB&quot;, &quot;Lab&quot;, &quot;Luv&quot;, or &quot;XYZ&quot;. Passed to
<code><a href="grDevices.html#topic+convertColor">grDevices::convertColor()</a></code>.</p>
</td></tr>
<tr><td><code id="imDist_+3A_ref_white">ref_white</code></td>
<td>
<p>Passed to <code><a href="grDevices.html#topic+convertColor">grDevices::convertColor()</a></code> if
<code style="white-space: pre;">&#8288;color_space = "Lab&#8288;</code>. Reference white for CIE Lab space.</p>
</td></tr>
<tr><td><code id="imDist_+3A_metric">metric</code></td>
<td>
<p>Distance metric to be used for calculating pairwise pixel
distances in the given color space; passed to <code><a href="stats.html#topic+dist">stats::dist()</a></code>.</p>
</td></tr>
<tr><td><code id="imDist_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Plot heatmap of color distances?</p>
</td></tr>
<tr><td><code id="imDist_+3A_palette">palette</code></td>
<td>
<p>If plotting, the color palette to be used. Default is blue to
red (<code>colorRamps::blue2red(100)</code>).</p>
</td></tr>
<tr><td><code id="imDist_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="imDist_+3A_...">...</code></td>
<td>
<p>Parameters passed to <code><a href="graphics.html#topic+image">graphics::image()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the same dimensions as the original images,
with the distance between non-transparent pixels at each pixel coordinate.
Transparent pixels are returned as <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fulgidissima &lt;- system.file("extdata/fulgidissima.png",
                             package = "recolorize")
fulgidissima &lt;- png::readPNG(fulgidissima)
# make an initial histogram fit
# this doesn't look great:
fulgidissima_2bin &lt;- recolorize(fulgidissima, "hist", bins = 2)

# we can compare with the original image by creating the recolored
# image from the colormap
recolored_2bin &lt;- constructImage(fulgidissima_2bin$pixel_assignments,
                                fulgidissima_2bin$centers)
dist_2bin &lt;- imDist(im1 = fulgidissima,
                    im2 = recolored_2bin)

# using 3 bins/channel looks much better:
fulgidissima_3bin &lt;- recolorize(fulgidissima, "hist", bins = 3)

# and we can see that on the heatmap:
recolored_3bin &lt;- constructImage(fulgidissima_3bin$pixel_assignments,
                                fulgidissima_3bin$centers)
dist_3bin &lt;- imDist(im1 = fulgidissima,
                    im2 = recolored_3bin)

# default behavior is to set the color range to the range of distances
# in a single matrix; to compare two different fits, we have to provide
# the same `zlim` scale for both
r &lt;- range(c(dist_2bin, dist_3bin), na.rm = TRUE)

# to reset graphical parameters:
current_par &lt;- graphics::par(no.readonly = TRUE)

# now we can plot them to compare the fits:
layout(matrix(1:2, nrow = 1))
imHeatmap(dist_2bin, range = r)
imHeatmap(dist_3bin, range = r)

# we can also use other color spaces:
rgb_3bin &lt;- imDist(fulgidissima,
                   recolored_3bin,
                   color_space = "sRGB")

# looks oddly worse, but to keep things in perspective,
# you can set the range to the maximum color distance in RGB space:
imHeatmap(rgb_3bin, range = c(0, sqrt(3)))
# not useful for troubleshooting, but broadly reassuring!

# reset:
graphics::par(current_par)
</code></pre>

<hr>
<h2 id='imHeatmap'>Plot a heatmap of a matrix of color distances</h2><span id='topic+imHeatmap'></span>

<h3>Description</h3>

<p>Plots the output of <code><a href="#topic+imDist">imDist()</a></code> as a heatmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imHeatmap(
  mat,
  palette = "default",
  main = "",
  range = NULL,
  legend = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imHeatmap_+3A_mat">mat</code></td>
<td>
<p>A color distance matrix, preferably output of
<code><a href="#topic+imDist">imDist()</a></code>.</p>
</td></tr>
<tr><td><code id="imHeatmap_+3A_palette">palette</code></td>
<td>
<p>The color palette to be used. Default is blue to
red (<code>colorRamps::blue2red(100)</code>).</p>
</td></tr>
<tr><td><code id="imHeatmap_+3A_main">main</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="imHeatmap_+3A_range">range</code></td>
<td>
<p>Range for heatmap values. Defaults to the range of values in the
matrix, but should be set to the same range for all images if comparing
heatmaps.</p>
</td></tr>
<tr><td><code id="imHeatmap_+3A_legend">legend</code></td>
<td>
<p>Logical. Add a continuous color legend?</p>
</td></tr>
<tr><td><code id="imHeatmap_+3A_...">...</code></td>
<td>
<p>Parameters passed to <code><a href="graphics.html#topic+image">graphics::image()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing; plots a heatmap of the color residuals.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chongi &lt;- system.file("extdata/chongi.png", package = "recolorize")
chongi &lt;- png::readPNG(chongi)
chongi_k &lt;- recolorize(chongi, "k", n = 5)

recolored_chongi &lt;- constructImage(chongi_k$pixel_assignments,
                                   chongi_k$centers)
d &lt;- imDist(chongi,
            recolored_chongi, plotting = FALSE)

# original flavor
imHeatmap(d)

# bit offputting
imHeatmap(d, palette = colorRamps::ygobb(100))

# just dreadful
imHeatmap(d, palette = colorRamps::primary.colors(100))
</code></pre>

<hr>
<h2 id='imposeColors'>Recolor an image to a provided set of colors</h2><span id='topic+imposeColors'></span>

<h3>Description</h3>

<p>Takes an image and a set of color centers, and assigns each pixel to the most
similar provided color. Useful for producing a set of images with identical colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imposeColors(
  img,
  centers,
  adjust_centers = TRUE,
  color_space = "sRGB",
  ref_white = "D65",
  lower = NULL,
  upper = NULL,
  transparent = TRUE,
  resid = FALSE,
  resize = NULL,
  rotate = NULL,
  plotting = TRUE,
  horiz = TRUE,
  cex_text = 1.5,
  scale_palette = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="imposeColors_+3A_img">img</code></td>
<td>
<p>Path to the image (a character vector) or a 3D image array as read
in by <code><a href="png.html#topic+readPNG">png::readPNG()</a></code> <code>{readImage}</code>.</p>
</td></tr>
<tr><td><code id="imposeColors_+3A_centers">centers</code></td>
<td>
<p>Colors to map to, as an n x 3 matrix (rows = colors,
columns = channels).</p>
</td></tr>
<tr><td><code id="imposeColors_+3A_adjust_centers">adjust_centers</code></td>
<td>
<p>Logical. After pixel assignment, should the returned
colors be the average color of the pixels assigned to that cluster, or the
original colors?</p>
</td></tr>
<tr><td><code id="imposeColors_+3A_color_space">color_space</code></td>
<td>
<p>Color space in which to minimize distances. One of &quot;sRGB&quot;,
&quot;Lab&quot;, &quot;Luv&quot;, &quot;HSV&quot;, or &quot;XYZ&quot;. Default is &quot;Lab&quot;, a perceptually uniform
(for humans) color space.</p>
</td></tr>
<tr><td><code id="imposeColors_+3A_ref_white">ref_white</code></td>
<td>
<p>Reference white for converting to different color spaces.
D65 (the default) corresponds to standard daylight.</p>
</td></tr>
<tr><td><code id="imposeColors_+3A_lower">lower</code>, <code id="imposeColors_+3A_upper">upper</code></td>
<td>
<p>RGB triplet ranges for setting a bounding box of pixels to
mask. See details.</p>
</td></tr>
<tr><td><code id="imposeColors_+3A_transparent">transparent</code></td>
<td>
<p>Logical. Treat transparent pixels as background? Requires
an alpha channel (PNG).</p>
</td></tr>
<tr><td><code id="imposeColors_+3A_resid">resid</code></td>
<td>
<p>Logical. Return a list of different residual metrics to
describe the goodness of fit?</p>
</td></tr>
<tr><td><code id="imposeColors_+3A_resize">resize</code></td>
<td>
<p>A value between 0 and 1 for resizing the image (ex. <code>resize = 0.5</code> will reduce image size by 50%). Recommended for large images as it can
speed up analysis considerably. See details.</p>
</td></tr>
<tr><td><code id="imposeColors_+3A_rotate">rotate</code></td>
<td>
<p>Degrees to rotate the image clockwise.</p>
</td></tr>
<tr><td><code id="imposeColors_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Plot recolored image &amp; color palette?</p>
</td></tr>
<tr><td><code id="imposeColors_+3A_horiz">horiz</code></td>
<td>
<p>Logical for plotting. Plot output image and color palette side
by side (<code>TRUE</code>) or stacked vertically (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="imposeColors_+3A_cex_text">cex_text</code></td>
<td>
<p>If <code>plotting = TRUE</code> and <code>scale_palette = FALSE</code>, size of
text to display on the color palette numbers.</p>
</td></tr>
<tr><td><code id="imposeColors_+3A_scale_palette">scale_palette</code></td>
<td>
<p>Logical. If plotting, plot colors in the color palette
proportional to the size of each cluster?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Background masking: <code>lower</code>, <code>upper</code>, and <code>transparent</code> are all background
masking conditions. Transparency is unambiguous and so tends to produce
cleaner results, but the <code>lower</code> and <code>upper</code> bounds can be used instead to
treat pixels in a specific color range as the background. For example, to
ignore white pixels (RGB = 1, 1, 1), you might want to mask all pixels whose
R, G, and B values exceed 0.9. In that case, <code>lower = c(0.9, 0.9, 0.9)</code> and
<code>upper = c(1, 1, 1)</code>. Regardless of input background, recolored images are
returned with transparent backgrounds by adding an alpha channel if one does
not already exist.
</p>
<p>Resizing: The speed benefits of downsizing images are fairly obvious (fewer
pixels = fewer operations). Because recoloring the images simplifies their
detail anyways, downsizing prior to recoloring doesn't run a very high risk
of losing important information. A general guideline for resizing is that any
distinguishable features of interest should still take up at least 2 pixels
(preferably with a margin of error) in the resized image.
</p>


<h3>Value</h3>

<p>A list with the following attributes:
</p>

<ol>
<li> <p><code>original_img</code>: The original image, as a raster.
</p>
</li>
<li> <p><code>centers</code>: A matrix of color centers. If <code>adjust_centers = FALSE</code>, this will be identical to the input <code>centers</code>.
</p>
</li>
<li> <p><code>sizes</code>: The number of pixels assigned to each color cluster.
</p>
</li>
<li> <p><code>pixel_assignments</code>: A vector of color center assignments for each pixel.
</p>
</li>
<li> <p><code>call</code>: The call(s) used to generate the <code>recolorize</code> object.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>

# RGB extremes (white, black, red, green, blue, yellow, magenta, cyan)
ctrs &lt;- matrix(c(1, 1, 1,
                 0, 0, 0,
                 1, 0, 0,
                 0, 1, 0,
                 0, 0, 1,
                 1, 1, 0,
                 1, 0, 1,
                 0, 1, 1), byrow = TRUE, ncol = 3)

# plot it
recolorize::plotColorPalette(ctrs)

# get image paths
ocellata &lt;- system.file("extdata/ocellata.png", package = "recolorize")

# map to rgb extremes
ocellata_fixed &lt;- recolorize::imposeColors(ocellata, ctrs,
                                            adjust_centers = FALSE)

# looks much better if we recalculate the centers from the image
ocellata_adjusted &lt;- recolorize::imposeColors(ocellata, ctrs,
                                           adjust_centers = TRUE)

# we can map one image to extracted colors from another image
# extract ocellata colors
ocellata_colors &lt;- recolorize(ocellata)

# map fulgidissima to ocellata colors
fulgidissima &lt;- system.file("extdata/fulgidissima.png",
                             package = "recolorize")

fulgidissma_ocellata &lt;- recolorize::imposeColors(fulgidissima,
                       ocellata_colors$centers,
                       adjust_centers = FALSE)

</code></pre>

<hr>
<h2 id='labelCol'>Change colors of dendrogram tips</h2><span id='topic+labelCol'></span>

<h3>Description</h3>

<p>Internal function for <a href="#topic+recluster">recluster</a> plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>labelCol(x, hex_cols, pch = 20, cex = 2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="labelCol_+3A_x">x</code></td>
<td>
<p>Leaf of a dendrogram.</p>
</td></tr>
<tr><td><code id="labelCol_+3A_hex_cols">hex_cols</code></td>
<td>
<p>Hex color codes for colors to change to.</p>
</td></tr>
<tr><td><code id="labelCol_+3A_pch">pch</code></td>
<td>
<p>The type of point to draw.</p>
</td></tr>
<tr><td><code id="labelCol_+3A_cex">cex</code></td>
<td>
<p>The size of the point.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>hclust</code> object with colored tips.
</p>

<hr>
<h2 id='match_colors'>Reorder a color palette to best match a reference palette</h2><span id='topic+match_colors'></span>

<h3>Description</h3>

<p>Often for batch processing purposes, it is important to ensure
that color centers fit using different methods are in the same
order. This function reorders a provided color palette (<code>match_palette</code>)
according a provided reference palette (<code>reference_palette</code>) by minimizing
their overall distance using the
<a href="https://en.wikipedia.org/wiki/Hungarian_algorithm">Hungarian algorithm</a>
as implemented by <a href="clue.html#topic+solve_LSAP">clue::solve_LSAP</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_colors(reference_palette, match_palette, plotting = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match_colors_+3A_reference_palette">reference_palette</code></td>
<td>
<p>The palette whose order to match. Either a character
vector of colors (hex codes or color names) or an nx3 matrix in <strong>sRGB
color space</strong>.</p>
</td></tr>
<tr><td><code id="match_colors_+3A_match_palette">match_palette</code></td>
<td>
<p>The palette to reorder, same formats as
<code>reference_palette</code></p>
</td></tr>
<tr><td><code id="match_colors_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Plot the ordered palettes?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the color palettes are wildly different, the returned order may not be
especially meaningful.
</p>


<h3>Value</h3>

<p>A vector of color orders for <code>match_palette</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+reorder_colors">reorder_colors</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ref_palette &lt;- c("mediumblue", "olivedrab", "tomato2", "beige", "chocolate4")
match_palette &lt;- c("#362C34", "#E4D3A9", "#AA4E47", "#809C35", "#49468E")
match_colors(ref_palette, match_palette, plotting = TRUE)

</code></pre>

<hr>
<h2 id='medianColors'>Change color centers to median color of all pixels assigned to it</h2><span id='topic+medianColors'></span>

<h3>Description</h3>

<p>By default, recolorize sets the centers of each color patch to the average
(mean) color of all pixels assigned to it. This can sometimes result in colors
that look washed out, especially in cases where a region is very shiny (e.g.
black with white reflective highlights will average to grey). In these cases,
switching to median colors may be either more accurate or more visually
pleasing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>medianColors(recolorize_obj, plotting = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="medianColors_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>A <code>recolorize</code> class object.</p>
</td></tr>
<tr><td><code id="medianColors_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Plot results?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>recolorize</code> object, with median colors instead of average colors
in the <code>centers</code> attribute.
</p>

<hr>
<h2 id='mergeLayers'>Merge layers in a recolorized image</h2><span id='topic+mergeLayers'></span>

<h3>Description</h3>

<p>Merges specified layers in a recolorized image. This is a good option if you
want to manually specify which layers to merge (and what color to make the
resulting merged layer); it's also called on by other <code>recolorize</code> functions
like <code><a href="#topic+recluster">recluster()</a></code> to merge layers that have been identified
as highly similar in color using a given distance metric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeLayers(
  recolorize_obj,
  merge_list = NULL,
  color_to = "weighted average",
  plotting = TRUE,
  remove_empty_centers = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mergeLayers_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>An object of class &quot;recolorize&quot;, such as from
<code><a href="#topic+recolorize">recolorize()</a></code>, <code><a href="#topic+recluster">recluster()</a></code>, or
<code><a href="#topic+imposeColors">imposeColors()</a></code>.</p>
</td></tr>
<tr><td><code id="mergeLayers_+3A_merge_list">merge_list</code></td>
<td>
<p>A list of numeric vectors specifying which layers
to merge. Layers not included in this list are unchanged. See examples.</p>
</td></tr>
<tr><td><code id="mergeLayers_+3A_color_to">color_to</code></td>
<td>
<p>Color(s) for the merged layers. See examples.</p>
</td></tr>
<tr><td><code id="mergeLayers_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Plot the results of the layer merging next
to the original color fit for comparison?</p>
</td></tr>
<tr><td><code id="mergeLayers_+3A_remove_empty_centers">remove_empty_centers</code></td>
<td>
<p>Logical. Remove empty centers with size = 0?
Retaining empty color centers can be helpful when batch processing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Colors can be supplied as numeric RGB triplets (e.g. <code>c(1, 1, 1)</code> for
white), a valid R color name (<code>"white"</code>), or a hex code (<code style="white-space: pre;">&#8288;"#FFFFFF&#8288;</code>).
Alternatively, <code>color_to = "weighted average"</code> will set the merged layer to
the average color of the layers being merged, weighted by their relative
size. Must be either a single value or a vector the same length as
<code>merge_list</code>. If a single color is supplied, then all merged layers
will be set to that color (so this really is only useful if you're
already merging those layers into a single layer).
</p>


<h3>Value</h3>

<p>A <code>recolorize</code> class object with merged layers. The order of the returned
layers depends on <code>merge_list</code>: the first layers will be any not included
in the list, followed by the new merged layers. If you start with layers
1-8 and merge layers 4 &amp; 5 and 7 &amp; 8, the returned 5 layers will be, in
order and in terms of the original layers: 1, 2, 3, 6, 4 &amp; 5 (merged), 7 &amp; 8
(merged). This is probably easiest to see in the examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># image path:
img &lt;- system.file("extdata/corbetti.png", package = "recolorize")

# initial fit, 8 bins:
init_fit &lt;- recolorize(img)
# redundant green, red, and blue clusters

# to make it easier to see, we can plot the numbered palette:
plot(init_fit)

# based on visual inspection, we should merge:
mlist &lt;- list(c(3, 5),
              c(4, 7),
              c(6, 8))

# we can merge with that list, leaving layers 1 &amp; 2 intact:
vis_merge &lt;- mergeLayers(init_fit,
                         merge_list = mlist)

# we can include layers 1 &amp; 2 as their own list elements,
# leaving them intact (result is identical to above):
mlist2 &lt;- list(1, 2,
               c(3, 5),
               c(4, 7),
               c(6, 8))
redundant_merge &lt;- mergeLayers(init_fit,
                               merge_list = mlist2)

# we can also swap layer order this way without actually merging layers:
swap_list &lt;- list(2, 5, 3, 4, 1)
swap_layers &lt;- mergeLayers(redundant_merge,
                           merge_list = swap_list)

# merging everything but the first layer into a single layer,
# and making that merged layer orange (result looks
# a bit like a milkweed bug):
milkweed_impostor &lt;- mergeLayers(init_fit,
                                 merge_list = list(c(2:8)),
                                 color_to = "orange")

# we can also shuffle all the layer colors while
# leaving their geometry intact:
centers &lt;- vis_merge$centers
centers &lt;- centers[sample(1:nrow(centers), nrow(centers)), ]
shuffle_layers &lt;- mergeLayers(vis_merge,
                              merge_list = as.list(1:5),
                              color_to = centers)
# (this is not really the intended purpose of this function)

</code></pre>

<hr>
<h2 id='pixelAssignMatrix'>Make pixel assignment matrix for recoloring</h2><span id='topic+pixelAssignMatrix'></span>

<h3>Description</h3>

<p>Internal function. Generates a sort of 'paint-by-numbers' matrix, where each
cell is the index of the color in the color centers matrix to which that
pixel is assigned. An index of 0 indicates a background pixel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pixelAssignMatrix(bg_indexed, color_clusters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pixelAssignMatrix_+3A_bg_indexed">bg_indexed</code></td>
<td>
<p>An object returned by <code><a href="#topic+backgroundIndex">backgroundIndex()</a></code>.</p>
</td></tr>
<tr><td><code id="pixelAssignMatrix_+3A_color_clusters">color_clusters</code></td>
<td>
<p>An object returned by <code><a href="#topic+colorClusters">colorClusters()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of pixel color assignments (<code>pixel_assignments</code>)
and a corresponding dataframe of color centers (<code>centers</code>).
</p>

<hr>
<h2 id='plot.recolorize'>Plot recolorized image results</h2><span id='topic+plot.recolorize'></span>

<h3>Description</h3>

<p>S3 plotting method for objects of class <code>recolorize</code>. Plots a side-by-side
comparison of an original image and its recolorized version, plus the color
palette used for recoloring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'recolorize'
plot(x, ..., plot_original = TRUE, horiz = TRUE, cex_text = 2, sizes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.recolorize_+3A_x">x</code></td>
<td>
<p>An object of class <code>recolorize</code>, such as
returned by <code><a href="#topic+recolorize">recolorize()</a></code>, <code><a href="#topic+recluster">recluster()</a></code>,
<code><a href="#topic+imposeColors">imposeColors()</a></code>, etc.</p>
</td></tr>
<tr><td><code id="plot.recolorize_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>plot</code>.</p>
</td></tr>
<tr><td><code id="plot.recolorize_+3A_plot_original">plot_original</code></td>
<td>
<p>Logical. Plot the original image for comparison?</p>
</td></tr>
<tr><td><code id="plot.recolorize_+3A_horiz">horiz</code></td>
<td>
<p>Logical. Should plots be stacked vertically or horizontally?</p>
</td></tr>
<tr><td><code id="plot.recolorize_+3A_cex_text">cex_text</code></td>
<td>
<p>Text size for printing color indices. Plotting parameters
passed to <code>[recolorize]{plotColorPalette}</code>.</p>
</td></tr>
<tr><td><code id="plot.recolorize_+3A_sizes">sizes</code></td>
<td>
<p>Logical. If <code>TRUE</code>, color palette is plotted proportional
to the size of each color. If <code>FALSE</code>, all colors take up an equal
amount of space, and their indices are printed for reference.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value; plots the original image, recolored image, and
color palette.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corbetti &lt;- system.file("extdata/corbetti.png",
                         package = "recolorize")

corbetti_recolor &lt;- recolorize(corbetti, method = "hist",
                                         bins = 2, plotting = FALSE)

# unscaled color palette
plot(corbetti_recolor)

# scaled color palette
plot(corbetti_recolor, sizes = TRUE)

</code></pre>

<hr>
<h2 id='plot.recolorizeVector'>Plot a <code>recolorizeVector</code> object</h2><span id='topic+plot.recolorizeVector'></span>

<h3>Description</h3>

<p>Plots an object generated by <a href="#topic+recolorizeVector">recolorizeVector</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'recolorizeVector'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.recolorizeVector_+3A_x">x</code></td>
<td>
<p>Object returned by <a href="#topic+recolorizeVector">recolorizeVector</a>.</p>
</td></tr>
<tr><td><code id="plot.recolorizeVector_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <a href="graphics.html#topic+plot.default">graphics::plot</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value; plots <code>recolorizeVector</code> as polygons.
</p>

<hr>
<h2 id='plotColorClusters'>Plot color clusters in a color space</h2><span id='topic+plotColorClusters'></span>

<h3>Description</h3>

<p>Plots color clusters in a 3D color space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotColorClusters(
  centers,
  sizes,
  scaling = 10,
  plus = 0,
  color_space = "sRGB",
  phi = 35,
  theta = 60,
  alpha = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotColorClusters_+3A_centers">centers</code></td>
<td>
<p>A matrix of color centers, with rows for centers and columns
as channels. These are interpreted as coordinates.</p>
</td></tr>
<tr><td><code id="plotColorClusters_+3A_sizes">sizes</code></td>
<td>
<p>A vector of color sizes. Can be relative or absolute; it's going
to be scaled for plotting.</p>
</td></tr>
<tr><td><code id="plotColorClusters_+3A_scaling">scaling</code></td>
<td>
<p>Factor for scaling the cluster sizes. If your clusters are
way too big or small on the plot, tinker with this.</p>
</td></tr>
<tr><td><code id="plotColorClusters_+3A_plus">plus</code></td>
<td>
<p>Value to add to each scaled cluster size; can be helpful for
seeing small or empty bins when they are swamped by larger clusters.</p>
</td></tr>
<tr><td><code id="plotColorClusters_+3A_color_space">color_space</code></td>
<td>
<p>The color space of the centers. Important for setting the
axis ranges and for converting the colors into hex codes for plotting. The
function assumes that the <code>centers</code> argument is already in this color space.</p>
</td></tr>
<tr><td><code id="plotColorClusters_+3A_phi">phi</code>, <code id="plotColorClusters_+3A_theta">theta</code></td>
<td>
<p>Viewing angles (in degrees).</p>
</td></tr>
<tr><td><code id="plotColorClusters_+3A_alpha">alpha</code></td>
<td>
<p>Transparency (0-1 range).</p>
</td></tr>
<tr><td><code id="plotColorClusters_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <a href="plot3D.html#topic+scatter">plot3D::scatter3D</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function does very little on your behalf (e.g. labeling the
axes, setting the axis ranges, trying to find nice scaling parameters,
etc). You can pass those parameters using the <code>...</code> function to
<a href="plot3D.html#topic+scatter">plot3D::scatter3D</a>, which is probably a good idea.
</p>


<h3>Value</h3>

<p>Nothing; plots a 3D scatterplot of color clusters, with corresponding
colors and sizes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corbetti &lt;- system.file("extdata/corbetti.png", package = "recolorize")
init_fit &lt;- recolorize(corbetti,
                       color_space = "Lab",
                       method = "k",
                       n = 30)

# we still have to convert to Lab color space first, since the centers are always RGB:
centers &lt;- grDevices::convertColor(init_fit$centers, "sRGB", "Lab")
plotColorClusters(centers, init_fit$sizes,
                  scaling = 25,
                  color_space = "Lab",
                  xlab = "Luminance",
                  ylab = "a (red-green)",
                  zlab = "b (blue-yellow)",
                  cex.lab = 0.5)
</code></pre>

<hr>
<h2 id='plotColorPalette'>Plot a color palette</h2><span id='topic+plotColorPalette'></span>

<h3>Description</h3>

<p>Plots a color palette as a single bar, optionally scaling each color to a
vector of sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotColorPalette(centers, sizes = NULL, cex_text = 2, horiz = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotColorPalette_+3A_centers">centers</code></td>
<td>
<p>Colors to plot in palette. Accepts either a character
vector of hex codes or an n x 3 matrix (rows = colors, columns =
channels). Assumes RGB in 0-1 range.</p>
</td></tr>
<tr><td><code id="plotColorPalette_+3A_sizes">sizes</code></td>
<td>
<p>An optional numeric vector of sizes for scaling each color. If
no sizes are provided, colors are plotted in equal proportions.</p>
</td></tr>
<tr><td><code id="plotColorPalette_+3A_cex_text">cex_text</code></td>
<td>
<p>Size of the numbers displayed on each color, relative to the
default. Passed to <code><a href="graphics.html#topic+barplot">graphics::barplot()</a></code>. Text is only plotted if
<code>sizes = NULL</code>. <code>cex_text = 0</code> will remove numbering.</p>
</td></tr>
<tr><td><code id="plotColorPalette_+3A_horiz">horiz</code></td>
<td>
<p>Logical. Should the palette be plotted vertically or
horizontally?</p>
</td></tr>
<tr><td><code id="plotColorPalette_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="graphics.html#topic+barplot">graphics::barplot()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotColorPalette</code> does not reorder or convert colors between color spaces,
so users working in other colorspaces should convert to RGB before plotting.
</p>


<h3>Value</h3>

<p>No return value; plots a rectangular color palette.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># plot 10 random colors
rand_colors &lt;- matrix(runif(30), ncol = 3)
plotColorPalette(rand_colors)

# plot 10 random colors with arbitrary sizes
sizes &lt;- runif(10, max = 1000)
plotColorPalette(rand_colors, sizes = sizes)

# reorder to plot smallest to largest
size_order &lt;- order(sizes)
plotColorPalette(rand_colors[size_order, ],
                 sizes[size_order])

# plot a vector of hex colors, turn off numbering
hex_colors &lt;- rgb(rand_colors)
plotColorPalette(hex_colors, cex_text = 0)

</code></pre>

<hr>
<h2 id='plotImageArray'>Plot a 3D array as an RGB image</h2><span id='topic+plotImageArray'></span>

<h3>Description</h3>

<p>Does what it says on the tin. An extremely simple wrapper for
<code><a href="graphics.html#topic+rasterImage">graphics::rasterImage()</a></code>, but maintains aspect ratio, removes
axes, and reduces margins for cleaner plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotImageArray(rgb_array, main = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotImageArray_+3A_rgb_array">rgb_array</code></td>
<td>
<p>A 3D array of RGB values. Preferably output from
<code><a href="png.html#topic+readPNG">png::readPNG()</a></code>, <code><a href="jpeg.html#topic+readJPEG">jpeg::readJPEG()</a></code>,
<a href="#topic+recoloredImage">recoloredImage</a>, <a href="#topic+constructImage">constructImage</a>, or <a href="#topic+raster_to_array">raster_to_array</a>.</p>
</td></tr>
<tr><td><code id="plotImageArray_+3A_main">main</code></td>
<td>
<p>Optional title for plot.</p>
</td></tr>
<tr><td><code id="plotImageArray_+3A_...">...</code></td>
<td>
<p>Parameters passed to <a href="graphics.html#topic+plot.default">graphics::plot</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value; plots image.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># make a 100x100 image of random colors
random_colors &lt;- array(runif(100 * 100 * 3),
                       dim = c(100, 100, 3))
recolorize::plotImageArray(random_colors)

# we can also plot...a real image
corbetti &lt;- system.file("extdata/corbetti.png",
                       package = "recolorize")
img &lt;- png::readPNG(corbetti)
plotImageArray(img)
</code></pre>

<hr>
<h2 id='raster_to_array'>Convert from a (small-r) raster object to an RGB array</h2><span id='topic+raster_to_array'></span>

<h3>Description</h3>

<p>Recreates the original numeric array from a <code>raster</code> object created
by <a href="grDevices.html#topic+as.raster">grDevices::as.raster</a>. Not to be confused with the <code style="white-space: pre;">&#8288;Raster*&#8288;</code> classes
used by the <code>raster</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>raster_to_array(raster_obj, alpha = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="raster_to_array_+3A_raster_obj">raster_obj</code></td>
<td>
<p>A matrix of hex codes as output by <a href="grDevices.html#topic+as.raster">grDevices::as.raster</a>.</p>
</td></tr>
<tr><td><code id="raster_to_array_+3A_alpha">alpha</code></td>
<td>
<p>Logical. If there is an alpha channel, retain it in the array?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric RGB array (0-1 range).
</p>

<hr>
<h2 id='readImage'>Read in an image as a 3D array</h2><span id='topic+readImage'></span>

<h3>Description</h3>

<p>Reads in and processes an image as a 3D array. Extremely simple wrapper for
<code><a href="imager.html#topic+load.image">imager::load.image()</a></code>, but it strips the depth channel (resulting
in a 3D, not 4D, array). This will probably change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readImage(img_path, resize = NULL, rotate = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readImage_+3A_img_path">img_path</code></td>
<td>
<p>Path to the image (a string).</p>
</td></tr>
<tr><td><code id="readImage_+3A_resize">resize</code></td>
<td>
<p>Fraction by which to reduce image size. Important for speed.</p>
</td></tr>
<tr><td><code id="readImage_+3A_rotate">rotate</code></td>
<td>
<p>Number of degrees to rotate the image.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 3D RGB array (pixel rows x pixel columns x color channels). RGB channels
are all scaled 0-1, not 0-255.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>corbetti &lt;- system.file("extdata/corbetti.png", package = "recolorize")
img &lt;- readImage(corbetti)
plotImageArray(img)

</code></pre>

<hr>
<h2 id='recluster'>Recluster color centers based on color similarity</h2><span id='topic+recluster'></span>

<h3>Description</h3>

<p>Color mapping (as with k-means or binning) often requires over-clustering in
order to recover details in an image. This can result in larger areas of
relatively uniform color being split into multiple colors, or in regions with
greater variation (due to lighting, shape, reflection, etc) being split into
multiple colors. This function clusters the color centers by visual
similarity (in CIE Lab space), then returns the re-clustered object. Users
can either set a similarity cutoff or a final number of colors. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recluster(
  recolorize_obj,
  dist_method = "euclidean",
  hclust_method = "complete",
  channels = 1:3,
  color_space = "Lab",
  ref_white = "D65",
  cutoff = 60,
  n_final = NULL,
  plot_hclust = TRUE,
  refit_method = c("imposeColors", "mergeLayers"),
  resid = FALSE,
  plot_final = TRUE,
  color_space_fit = "sRGB"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recluster_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>A recolorize object from <code><a href="#topic+recolorize">recolorize()</a></code>,
<code><a href="#topic+recluster">recluster()</a></code>, or <code><a href="#topic+imposeColors">imposeColors()</a></code>.</p>
</td></tr>
<tr><td><code id="recluster_+3A_dist_method">dist_method</code></td>
<td>
<p>Method passed to <a href="stats.html#topic+dist">stats::dist</a> for calculating distances
between colors. One of &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;,
&quot;binary&quot; or &quot;minkowski&quot;.</p>
</td></tr>
<tr><td><code id="recluster_+3A_hclust_method">hclust_method</code></td>
<td>
<p>Method passed to <a href="stats.html#topic+hclust">stats::hclust</a> for clustering colors
by similarity. One of &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;
(= UPGMA), &quot;mcquitty&quot; (= WPGMA), &quot;median&quot; (= WPGMC) or &quot;centroid&quot; (=
UPGMC).</p>
</td></tr>
<tr><td><code id="recluster_+3A_channels">channels</code></td>
<td>
<p>Numeric: which color channels to use for clustering. Probably
some combination of 1, 2, and 3, e.g., to consider only luminance and
blue-yellow (b-channel) distance in CIE Lab space, channels = c(1, 3) (L
and b).</p>
</td></tr>
<tr><td><code id="recluster_+3A_color_space">color_space</code></td>
<td>
<p>Color space in which to cluster centers, passed to
<code>[grDevices]{convertColor}</code>. One of &quot;sRGB&quot;, &quot;Lab&quot;, or &quot;Luv&quot;.
Default is &quot;Lab&quot;, a perceptually uniform (for humans) color space.</p>
</td></tr>
<tr><td><code id="recluster_+3A_ref_white">ref_white</code></td>
<td>
<p>Reference white for converting to different color spaces.
D65 (the default) corresponds to standard daylight.</p>
</td></tr>
<tr><td><code id="recluster_+3A_cutoff">cutoff</code></td>
<td>
<p>Numeric similarity cutoff for grouping color centers
together. The range and value will depend on the chosen color space (see
below), but the default is in absolute Euclidean distance in CIE Lab space,
which means it is greater than 0-100, but cutoff values between 20 and 80
will usually work best. See details.</p>
</td></tr>
<tr><td><code id="recluster_+3A_n_final">n_final</code></td>
<td>
<p>Final number of desired colors; alternative to specifying
a similarity cutoff. Overrides <code>cutoff</code> if provided.</p>
</td></tr>
<tr><td><code id="recluster_+3A_plot_hclust">plot_hclust</code></td>
<td>
<p>Logical. Plot the hierarchical clustering tree for
color similarity? Helpful for troubleshooting a cutoff.</p>
</td></tr>
<tr><td><code id="recluster_+3A_refit_method">refit_method</code></td>
<td>
<p>Method for refitting the image with the new color
centers. One of either &quot;imposeColors&quot; or &quot;mergeLayers&quot;. <code><a href="#topic+imposeColors">imposeColors()</a></code>
refits the original image using the new colors (slow but often better
results). <code><a href="#topic+mergeLayers">mergeLayers()</a></code> merges the layers of the existing
recolored image. This is faster since it doesn't require a new fit, but can
produce messier results.</p>
</td></tr>
<tr><td><code id="recluster_+3A_resid">resid</code></td>
<td>
<p>Logical. Get final color fit residuals with
<code><a href="#topic+colorResiduals">colorResiduals()</a></code>?</p>
</td></tr>
<tr><td><code id="recluster_+3A_plot_final">plot_final</code></td>
<td>
<p>Logical. Plot the final color fit?</p>
</td></tr>
<tr><td><code id="recluster_+3A_color_space_fit">color_space_fit</code></td>
<td>
<p>Passed to <code><a href="#topic+imposeColors">imposeColors()</a></code>. What
color space should the image be reclustered in?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is fairly straightforward: the RGB color centers of the
recolorize object are converted to CIE Lab color space (which is
approximately perceptually uniform for human vision), clustered using
<code><a href="stats.html#topic+hclust">stats::hclust()</a></code>, then grouped using <code><a href="stats.html#topic+cutree">stats::cutree()</a></code>.
The resulting groups are then passed as the assigned color centers to
<code><a href="#topic+imposeColors">imposeColors()</a></code>, which re-fits the <em>original</em> image using the new
centers.
</p>
<p>The similarity cutoff does not require the user to specify the final number
of colors, unlike k-means or <code>n_final</code>, meaning that the same cutoff could be
used for multiple images (with different numbers of colors) and produce
relatively good fits. Because the cutoff is in absolute Euclidean distance in
CIE Lab space for sRGB colors, the possible range of distances (and therefore
cutoffs) is from 0 to &gt;200. The higher the cutoff, the more dissimilar colors
will be grouped together. There is no universally recommended cutoff; the
same degree of color variation due to lighting in one image might be
biologically relevant in another.
</p>


<h3>Value</h3>

<p>A <code>recolorize</code> object with the re-fit color centers.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get an image
corbetti &lt;- system.file("extdata/corbetti.png", package = "recolorize")

# too many color centers
recolored_corbetti &lt;- recolorize(corbetti, bins = 2)

# just enough!
# check previous plot for clustering cutoff
recluster_obj &lt;- recluster(recolored_corbetti,
                           cutoff = 45,
                           plot_hclust = TRUE,
                           refit_method = "impose")

# we get the same result by specifying n_final = 5
recluster_obj &lt;- recluster(recolored_corbetti,
                           n_final = 5,
                           plot_hclust = TRUE)
</code></pre>

<hr>
<h2 id='recoloredImage'>Get recolored image from a recolorize object</h2><span id='topic+recoloredImage'></span>

<h3>Description</h3>

<p><code>recolorize</code> objects use a numeric color map and a matrix of
color centers to make recolored images, since this is a lighter weight
and more flexible format. This function generates a colored image
from those values for plotting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recoloredImage(recolorize_obj, type = c("array", "raster"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recoloredImage_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>An object of class <code>recolorize</code>. Must include
a pixel assignment matrix and matrix of color centers.</p>
</td></tr>
<tr><td><code id="recoloredImage_+3A_type">type</code></td>
<td>
<p>Type of image to return. One of either &quot;array&quot; or &quot;raster&quot;.
Arrays are numeric RGB arrays (larger, but easier to do operations on),
rasters are matrices of hex codes (smaller, only really good for plotting).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric image array (if <code>type = array</code>) or a matrix of hex codes (
if <code>type = raster</code>).
</p>

<hr>
<h2 id='recolorize'>Simplify the colors of an image</h2><span id='topic+recolorize'></span>

<h3>Description</h3>

<p>Clusters the colors in an RGB image according to a specified method,
then recolors that image to the simplified color scheme.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recolorize(
  img,
  method = c("histogram", "kmeans"),
  bins = 2,
  n = 5,
  color_space = "sRGB",
  ref_white = "D65",
  lower = NULL,
  upper = NULL,
  transparent = TRUE,
  resid = FALSE,
  resize = NULL,
  rotate = NULL,
  plotting = TRUE,
  horiz = TRUE,
  cex_text = 1.5,
  scale_palette = TRUE,
  bin_avg = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recolorize_+3A_img">img</code></td>
<td>
<p>Path to the image (a character vector) or a 3D image array as read
in by <code><a href="png.html#topic+readPNG">png::readPNG()</a></code> <code>{readImage}</code>.</p>
</td></tr>
<tr><td><code id="recolorize_+3A_method">method</code></td>
<td>
<p>Method for clustering image colors. One of either <code>histogram</code>
or <code>kmeans</code>. See details.</p>
</td></tr>
<tr><td><code id="recolorize_+3A_bins">bins</code></td>
<td>
<p>If <code>method = "histogram"</code>, either the number of bins per color
channel (if a single number is provided) OR a vector of length 3 with the
number of bins for each channel.</p>
</td></tr>
<tr><td><code id="recolorize_+3A_n">n</code></td>
<td>
<p>If <code>method = "kmeans"</code>, the number of color clusters to fit.</p>
</td></tr>
<tr><td><code id="recolorize_+3A_color_space">color_space</code></td>
<td>
<p>Color space in which to minimize distances, passed to
<code>[grDevices]{convertColor}</code>. One of &quot;sRGB&quot;, &quot;Lab&quot;, or &quot;Luv&quot;.
Default is &quot;Lab&quot;, a perceptually uniform (for humans) color space.</p>
</td></tr>
<tr><td><code id="recolorize_+3A_ref_white">ref_white</code></td>
<td>
<p>Reference white for converting to different color spaces.
D65 (the default) corresponds to standard daylight.</p>
</td></tr>
<tr><td><code id="recolorize_+3A_lower">lower</code>, <code id="recolorize_+3A_upper">upper</code></td>
<td>
<p>RGB triplet ranges for setting a bounding box of pixels to
mask. See details.</p>
</td></tr>
<tr><td><code id="recolorize_+3A_transparent">transparent</code></td>
<td>
<p>Logical. Treat transparent pixels as background? Requires
an alpha channel (PNG).</p>
</td></tr>
<tr><td><code id="recolorize_+3A_resid">resid</code></td>
<td>
<p>Logical. Return a list of different residual metrics to
describe the goodness of fit?</p>
</td></tr>
<tr><td><code id="recolorize_+3A_resize">resize</code></td>
<td>
<p>A value between 0 and 1 for resizing the image (ex. <code>resize = 0.5</code> will reduce image size by 50%). Recommended for large images as it can
speed up analysis considerably. See details.</p>
</td></tr>
<tr><td><code id="recolorize_+3A_rotate">rotate</code></td>
<td>
<p>Degrees to rotate the image clockwise.</p>
</td></tr>
<tr><td><code id="recolorize_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Plot recolored image &amp; color palette?</p>
</td></tr>
<tr><td><code id="recolorize_+3A_horiz">horiz</code></td>
<td>
<p>Logical for plotting. Plot output image and color palette side
by side (<code>TRUE</code>) or stacked vertically (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="recolorize_+3A_cex_text">cex_text</code></td>
<td>
<p>If <code>plotting = TRUE</code> and <code>scale_palette = FALSE</code>, size of
text to display on the color palette numbers.</p>
</td></tr>
<tr><td><code id="recolorize_+3A_scale_palette">scale_palette</code></td>
<td>
<p>Logical. If plotting, plot colors in the color palette
proportional to the size of each cluster?</p>
</td></tr>
<tr><td><code id="recolorize_+3A_bin_avg">bin_avg</code></td>
<td>
<p>Logical. Return the color centers as the average of the pixels
assigned to the bin (the default), or the geometric center of the bin?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Method for color clustering: <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code> clustering tries to
find the set of <code>n</code> clusters that minimize overall distances. Histogram
binning divides up color space according to set breaks; for example, bins = 2
would divide the red, green, and blue channels into 2 bins each (&gt; 0.5 and &lt;
0 .5), resulting in 8 possible ranges. A white pixel (RGB = 1, 1, 1) would
fall into the R &gt; 0.5, G &gt; 0.5, B &gt; 0.5 bin. The resulting centers represent
the average color of all the pixels assigned to that bin.
</p>
<p>K-means clustering can produce more intuitive results, but because it is
iterative, it will find slightly different clusters each time it is run, and
their order will be arbitrary. It also tends to divide up similar colors that
make up the majority of the image. Histogram binning will produce the same
results every time, in the same order, and because it forces the bins to be
dispersed throughout color space, tends to better pick up small color
details. Bins are also comparable across images. However, this sometimes
means returning empty bins (i.e. the white bin will be empty if clustering a
very dark image).
</p>
<p>Background masking: <code>lower</code>, <code>upper</code>, and <code>transparent</code> are all background
masking conditions. Transparency is unambiguous and so tends to produce
cleaner results, but the <code>lower</code> and <code>upper</code> bounds can be used instead to
treat pixels in a specific color range as the background. For example, to
ignore white pixels (RGB = 1, 1, 1), you might want to mask all pixels whose
R, G, and B values exceed 0.9. In that case, <code>lower = c(0.9, 0.9, 0.9)</code> and
<code>upper = c(1, 1, 1)</code>. Regardless of input background, recolored images are
returned with transparent backgrounds by adding an alpha channel if one does
not already exist.
</p>
<p>Resizing: The speed benefits of downsizing images are fairly obvious (fewer
pixels = fewer operations). Because recoloring the images simplifies their
detail anyways, downsizing prior to recoloring doesn't run a very high risk
of losing important information. A general guideline for resizing is that
any distinguishable features of interest should still take up at least 2
pixels (preferably with a margin of error) in the resized image.
</p>


<h3>Value</h3>

<p>An object of S3 class <code>recolorize</code> with the following attributes:
</p>

<ol>
<li> <p><code>original_img</code>: The original image, as a raster array.
</p>
</li>
<li> <p><code>centers</code>: A matrix of color centers in RGB (0-1 range).
</p>
</li>
<li> <p><code>sizes</code>: The number of pixels assigned to each color cluster.
</p>
</li>
<li> <p><code>pixel_assignments</code>: A matrix of color center assignments for each
pixel.
</p>
</li>
<li> <p><code>call</code>: The call(s) used to generate the <code>recolorize</code> object.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
# filepath to image
img &lt;- system.file("extdata/chongi.png", package = "recolorize")

# default: histogram, 2 bins/channel
rc &lt;- recolorize(img)

# we can also have different numbers of bins per channel
rc &lt;- recolorize(img, bins = c(4, 1, 1)) # mostly red
rc &lt;- recolorize(img, bins = c(1, 4, 1)) # mostly green
rc &lt;- recolorize(img, bins = c(1, 1, 4)) # mostly blue

# kmeans can produce a better fit with fewer colors
rc &lt;- recolorize(img, method = "kmeans", n = 8)

# increasing numbers of kmean colors
recolored_images &lt;- setNames(vector("list", length = 10), c(1:10))
for (i in 1:10) {
  kmeans_recolor &lt;- recolorize(img, method = "kmeans",
                               n = i)
}

# kmeans, 10 colors
kmeans_recolor &lt;- recolorize(img, method = "kmeans",
                             n = 8, plotting = FALSE)
hist_recolor &lt;- recolorize(img, method = "hist",
                           bins = 2, plotting = FALSE)
# to reset graphical parameters:
current_par &lt;- graphics::par(no.readonly = TRUE)

# compare binning vs. kmeans clustering
layout(matrix(c(1, 2, 3), ncol = 3))
plot(kmeans_recolor$original_img); title("original")
plot(recoloredImage(kmeans_recolor, type = "raster")); title("kmeans")
plot(recoloredImage(hist_recolor, type = "raster")); title("binning")

graphics::par(current_par)
</code></pre>

<hr>
<h2 id='recolorize_adjacency'>Run <code>pavo</code>'s adjacency and boundary strength analysis on a <code>recolorize</code>
object</h2><span id='topic+recolorize_adjacency'></span>

<h3>Description</h3>

<p>Run adjacency (Endler 2012) and boundary strength (Endler et al. 2018)
analysis directly on a <code>recolorize</code> object, assuming a human viewer
(i.e. using CIE Lab and HSL color distances that correspond to
perceptual distances of human vision). This is achieved by
converting the <code>recolorize</code> object to a <a href="pavo.html#topic+classify">pavo::classify</a> object,
converting the colors to HSL space, and calculating a <a href="pavo.html#topic+coldist">pavo::coldist</a> object
for CIE Lab color space before running <a href="pavo.html#topic+adjacent">pavo::adjacent</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recolorize_adjacency(
  recolorize_obj,
  xscale = 1,
  coldist = "default",
  hsl = "default",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recolorize_adjacency_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>A <code>recolorize</code> object.</p>
</td></tr>
<tr><td><code id="recolorize_adjacency_+3A_xscale">xscale</code></td>
<td>
<p>The length of the x-axis, in preferred units. Passed to
<a href="pavo.html#topic+adjacent">pavo::adjacent</a>.</p>
</td></tr>
<tr><td><code id="recolorize_adjacency_+3A_coldist">coldist</code></td>
<td>
<p>A <a href="pavo.html#topic+coldist">pavo::coldist</a> object; otherwise, this argument
is ignored and a <code>coldist</code> object for human vision is calculated from
RGB colors converted to CIE Lab using <a href="#topic+cielab_coldist">cielab_coldist</a>.</p>
</td></tr>
<tr><td><code id="recolorize_adjacency_+3A_hsl">hsl</code></td>
<td>
<p>A dataframe with <code>patch</code>, <code>hue</code>, <code>sat</code> and <code>lum</code> columns
specifying the HSL values for each color patch, to be
passed to <a href="pavo.html#topic+adjacent">pavo::adjacent</a>. Otherwise, this argument
is ignored and HSL values are calculated for human vision from the RGB
colors in the <code>recolorize</code> object.</p>
</td></tr>
<tr><td><code id="recolorize_adjacency_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <a href="pavo.html#topic+adjacent">pavo::adjacent</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Eventually, the plan is to incorporate more sophisticated
color models than using human perceptual color distances, i.e.
by allowing users to match color patches to spectra. However,
this does return reasonable and informative results so long as
human vision is an appropriate assumption for the image data.
</p>


<h3>Value</h3>

<p>The results of <a href="pavo.html#topic+adjacent">pavo::adjacent</a>; see that documentation
for the meaning of each specific value.
</p>


<h3>See Also</h3>

<p><a href="pavo.html#topic+adjacent">pavo::adjacent</a>, <a href="#topic+classify_recolorize">classify_recolorize</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>img &lt;- system.file("extdata/chongi.png", package = "recolorize")
recolorize_obj &lt;- recolorize(img, method = "k", n = 2)
recolorize_adjacency(recolorize_obj)

</code></pre>

<hr>
<h2 id='recolorize_to_patternize'>Convert a recolorize object to a raster object</h2><span id='topic+recolorize_to_patternize'></span>

<h3>Description</h3>

<p>Convert from a <code>recolorize</code> object to a list of RasterLayer objects, the
format required by the <code>patternize</code> package. Note that most of the downstream
<code>patternize</code> functions that require lists of RasterLayer objects mostly
require lists of these lists, so you will probably need to use this function
on a list of <code>recolorize</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recolorize_to_patternize(recolorize_obj, return_background = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recolorize_to_patternize_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>A <code>recolorize</code> object.</p>
</td></tr>
<tr><td><code id="recolorize_to_patternize_+3A_return_background">return_background</code></td>
<td>
<p>Logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function does not retain the colors of the layers &ndash;
you won't be able to convert back to a recolorize object from this object.
</p>


<h3>Value</h3>

<p>A list of RasterLayer objects, one per color class.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# fit recolorize object:
img &lt;- system.file("extdata/ephippigera.png", package = "recolorize")
rc &lt;- recolorize2(img)

# takes ~10 sec to run:
# convert to a raster list:
as_raster_list &lt;- recolorize_to_patternize(rc)


</code></pre>

<hr>
<h2 id='recolorize_to_png'>Save a recolored image as a PNG</h2><span id='topic+recolorize_to_png'></span>

<h3>Description</h3>

<p>Saves a recolored image from a recolorize object to a PNG. This is
done by calling <a href="#topic+recoloredImage">recoloredImage</a> and <a href="png.html#topic+writePNG">png::writePNG</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recolorize_to_png(recolorize_obj, filename = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recolorize_to_png_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>A recolorize object.</p>
</td></tr>
<tr><td><code id="recolorize_to_png_+3A_filename">filename</code></td>
<td>
<p>Filename for saving the PNG.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function saves a png with the same dimensions (in pixels) as the
image that was originally provided to recolorize (meaning if you resized your original
image, the resulting PNG will also be smaller). Anything more complicated can be
created with custom scripts: for example, you could create a vector image using
<a href="#topic+recolorizeVector">recolorizeVector</a>, and then save this as a PNG of any resolution/size.
</p>


<h3>Value</h3>

<p>No return value; saves a PNG file to the specified location.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
img &lt;- system.file("extdata/corbetti.png", package = "recolorize")
rc &lt;- recolorize2(img, cutoff = 45)

# save a PNG:
recolorize_to_png(rc, "corbetti_recolored.png")

# remove the PNG (so this example doesn't spam your working directory)
file.remove("corbetti_recolored.png")


</code></pre>

<hr>
<h2 id='recolorize2'>Recolorize with automatic thresholding</h2><span id='topic+recolorize2'></span>

<h3>Description</h3>

<p>Calls <a href="#topic+recolorize">recolorize</a> and <a href="#topic+recluster">recluster</a> in sequence, since these are often
very effective in combination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recolorize2(
  img,
  method = "histogram",
  bins = 2,
  n = 5,
  cutoff = 20,
  channels = 1:3,
  n_final = NULL,
  color_space = "sRGB",
  recluster_color_space = "Lab",
  refit_method = "impose",
  ref_white = "D65",
  lower = NULL,
  upper = NULL,
  transparent = TRUE,
  resize = NULL,
  rotate = NULL,
  plotting = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recolorize2_+3A_img">img</code></td>
<td>
<p>Path to the image (a character vector) or a 3D image array as read
in by <code><a href="png.html#topic+readPNG">png::readPNG()</a></code> <code>{readImage}</code>.</p>
</td></tr>
<tr><td><code id="recolorize2_+3A_method">method</code></td>
<td>
<p>Method for clustering image colors. One of either <code>histogram</code>
or <code>kmeans</code>. See details.</p>
</td></tr>
<tr><td><code id="recolorize2_+3A_bins">bins</code></td>
<td>
<p>If <code>method = "histogram"</code>, either the number of bins per color
channel (if a single number is provided) OR a vector of length 3 with the
number of bins for each channel.</p>
</td></tr>
<tr><td><code id="recolorize2_+3A_n">n</code></td>
<td>
<p>If <code>method = "kmeans"</code>, the number of color clusters to fit.</p>
</td></tr>
<tr><td><code id="recolorize2_+3A_cutoff">cutoff</code></td>
<td>
<p>Numeric similarity cutoff for grouping color centers
together. The range is in absolute Euclidean distance. In CIE Lab space,
it is greater than 0-100, but cutoff values between 20 and 80
will usually work best. In RGB space, range is 0-sqrt(3).
See <a href="#topic+recluster">recluster</a> details.</p>
</td></tr>
<tr><td><code id="recolorize2_+3A_channels">channels</code></td>
<td>
<p>Numeric: which color channels to use for clustering.
Probably some combination of 1, 2, and 3, e.g., to consider only luminance
and blue-yellow (b-channel) distance in CIE Lab space, channels = c(1, 3
(L and b).</p>
</td></tr>
<tr><td><code id="recolorize2_+3A_n_final">n_final</code></td>
<td>
<p>Final number of desired colors; alternative to specifying
a similarity cutoff. Overrides <code>similarity_cutoff</code> if provided.</p>
</td></tr>
<tr><td><code id="recolorize2_+3A_color_space">color_space</code></td>
<td>
<p>Color space in which to minimize distances, passed to
<code>[grDevices]{convertColor}</code>. One of &quot;sRGB&quot;, &quot;Lab&quot;, or &quot;Luv&quot;.
Default is &quot;sRGB&quot;.</p>
</td></tr>
<tr><td><code id="recolorize2_+3A_recluster_color_space">recluster_color_space</code></td>
<td>
<p>Color space in which to group colors for
reclustering. Default is CIE Lab.</p>
</td></tr>
<tr><td><code id="recolorize2_+3A_refit_method">refit_method</code></td>
<td>
<p>Method for refitting the image with the new color
centers. One of either &quot;impose&quot; or &quot;merge&quot;. <code><a href="#topic+imposeColors">imposeColors()</a></code>
refits the original image using the new colors (slow but often better
results). <code><a href="#topic+mergeLayers">mergeLayers()</a></code> merges the layers of the existing
recolored image. This is faster since it doesn't require a new fit, but can
produce messier results.</p>
</td></tr>
<tr><td><code id="recolorize2_+3A_ref_white">ref_white</code></td>
<td>
<p>Reference white for converting to different color spaces.
D65 (the default) corresponds to standard daylight.</p>
</td></tr>
<tr><td><code id="recolorize2_+3A_lower">lower</code>, <code id="recolorize2_+3A_upper">upper</code></td>
<td>
<p>RGB triplet ranges for setting a bounding box of pixels to
mask. See details.</p>
</td></tr>
<tr><td><code id="recolorize2_+3A_transparent">transparent</code></td>
<td>
<p>Logical. Treat transparent pixels as background? Requires
an alpha channel (PNG).</p>
</td></tr>
<tr><td><code id="recolorize2_+3A_resize">resize</code></td>
<td>
<p>A value between 0 and 1 for resizing the image (ex. <code>resize = 0.5</code> will reduce image size by 50%). Recommended for large images as it can
speed up analysis considerably. See details.</p>
</td></tr>
<tr><td><code id="recolorize2_+3A_rotate">rotate</code></td>
<td>
<p>Degrees to rotate the image clockwise.</p>
</td></tr>
<tr><td><code id="recolorize2_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Plot final results?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S3 class <code>recolorize</code> with the following attributes:
</p>

<ol>
<li> <p><code>original_img</code>: The original image, as a raster array.
</p>
</li>
<li> <p><code>centers</code>: A matrix of color centers in RGB (0-1 range).
</p>
</li>
<li> <p><code>sizes</code>: The number of pixels assigned to each color cluster.
</p>
</li>
<li> <p><code>pixel_assignments</code>: A matrix of color center assignments for each
pixel.
</p>
</li>
<li> <p><code>call</code>: The call(s) used to generate the <code>recolorize</code> object.
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+recolorize">recolorize</a>, <a href="#topic+recluster">recluster</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get image path
img &lt;- system.file("extdata/corbetti.png", package = "recolorize")

# fit recolorize:
rc &lt;- recolorize2(img, bins = 2, cutoff = 45)

</code></pre>

<hr>
<h2 id='recolorizeVector'>Convert a recolorize object to a vector</h2><span id='topic+recolorizeVector'></span>

<h3>Description</h3>

<p>Converts a <code>recolorize</code> color map to a set of polygons, which
can be plotted at any scale without losing quality (as opposed to
the pixel-based bitmap format). Requires the <code>raster</code>, <code>rgeos</code>, and
<code>sp</code> packages to be installed. Useful for creating nice visualizations;
slow on large images. It's recommended to fit a <code>recolorize</code> object
by reducing the original image first, rather than the <code>resize</code> argument
here, which reduces the color map itself (to mixed results).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recolorizeVector(
  recolorize_obj,
  size_filter = 0.1,
  smoothness = 1,
  base_color = "default",
  plotting = FALSE,
  resize = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recolorizeVector_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>An object of class <code>recolorize</code>, as generated
by <a href="#topic+recolorize">recolorize</a>, <a href="#topic+recolorize2">recolorize2</a>, <a href="#topic+imposeColors">imposeColors</a>, or <a href="#topic+wernerColor">wernerColor</a>.</p>
</td></tr>
<tr><td><code id="recolorizeVector_+3A_size_filter">size_filter</code></td>
<td>
<p>The size (as a proportion of the shortest dimension of the
image) of the color patch elements to absorb before vectorizing. Small
details (e.g. stray pixels) tend to look very strange after vectorizing,
so removing these beforehand can improve results.</p>
</td></tr>
<tr><td><code id="recolorizeVector_+3A_smoothness">smoothness</code></td>
<td>
<p>Passed to <a href="smoothr.html#topic+smooth">smoothr::smooth</a> using the <code>"ksmooth"</code>
method for smoothing the jagged lines that result from converting
pixel coordinates to polygon vertices. Higher values = more smoothing.</p>
</td></tr>
<tr><td><code id="recolorizeVector_+3A_base_color">base_color</code></td>
<td>
<p>The color to use to fill in the gaps that can result from
smoothing. If <code>base_color = "default"</code>, defaults to the darkest color
in the palette. Otherwise, should be the numeric index of one of the colors
in <code>recolorize_obj$centers</code> to use.</p>
</td></tr>
<tr><td><code id="recolorizeVector_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Plot results while computing?</p>
</td></tr>
<tr><td><code id="recolorizeVector_+3A_resize">resize</code></td>
<td>
<p>Proportion by which to resize the color map before turning
into a polygon, e.g. <code>resize = 0.5</code> will reduce color map size by 50%.
Speeds up the function, but you will almost always get better results
by resizing the initial image when fitting the <code>recolorize</code> object.</p>
</td></tr>
<tr><td><code id="recolorizeVector_+3A_...">...</code></td>
<td>
<p>Plotting parameters, passed on to <a href="graphics.html#topic+plot.default">graphics::plot</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Although vector objects will typically be smaller than <code>recolorize</code> objects,
because they only need to specify the XY coordinates of the perimeters of
each polygon, they can still be fairly large (and take a long time to
calculate). Users can try a few things to speed this up: using lower
smoothness values; setting <code>plotting = FALSE</code>; resizing the image
(preferably when fitting the initial <code>recolorize</code> object); and
reducing the complexity of the color patches using <a href="#topic+absorbLayer">absorbLayer</a> or
<a href="#topic+editLayer">editLayer</a> (e.g. by absorbing all components &lt; 10 pixels in size). Still,
expect this function to take several minutes on even moderately sized
images&ndash;it takes about 7-10 seconds for the ~200x100 pixel images in the
examples! Once the function finishes running, however, plotting is
quite fast, and the objects themselves are smaller than the  <code>recolorize</code>
objects.
</p>


<h3>Value</h3>

<p>A <code>vector_recolorize</code> object, which is a list with the following
elements:
</p>

<ol>
<li> <p><code>base_layer</code>: The base polygon, essentially the image silhouette.
</p>
</li>
<li> <p><code>layers</code>: A list of <a href="sp.html#topic+SpatialPolygons">sp::SpatialPolygonsDataFrame</a> polygons, one per
color patch.
</p>
</li>
<li> <p><code>layer_colors</code>: The colors (as hex codes) for each polygon.
</p>
</li>
<li> <p><code>base_color</code>: The color (as hex code) for the base polygon.
</p>
</li>
<li> <p><code>asp</code>: The original image aspect ratio, important for plotting.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
img &lt;- system.file("extdata/corbetti.png", package = "recolorize")
rc &lt;- recolorize2(img, cutoff = 45)

# to reset graphical parameters:
current_par &lt;- graphics::par(no.readonly = TRUE)

# takes ~10 seconds
as_vector &lt;- recolorizeVector(rc, smoothness = 5,
                              size_filter = 0.05)

# to save as an SVG with a transparent background and
# no margins (e.g. for an illustration figure):
grDevices::svg("recolorize_vector.svg",
height = 4, width = 2, bg = "transparent")
par(mar = rep(0, 4))
plot(as_vector)
dev.off()

# and to avoid spamming your working directory, run this line to remove
# the file we just wrote:
file.remove("recolorize_vector.svg")

graphics::par(current_par)

</code></pre>

<hr>
<h2 id='reorder_colors'>Reorder colors in a recolorize object</h2><span id='topic+reorder_colors'></span>

<h3>Description</h3>

<p>Often for batch processing purposes, it is important to ensure
that color centers fit using different methods are in the same
order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorder_colors(recolorize_obj, col_order, plotting = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reorder_colors_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>An object of class <code>recolorize</code>.</p>
</td></tr>
<tr><td><code id="reorder_colors_+3A_col_order">col_order</code></td>
<td>
<p>A numeric vector of the length of the number of color
centers in the <code>recolorize</code> object specifying the order of the colors.</p>
</td></tr>
<tr><td><code id="reorder_colors_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Plot the results?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>While you can manually specify the <code>col_order</code> vector, one way to
automatically order the colors according to an external color palette (as
might be needed for batch processing) is to use the <a href="#topic+match_colors">match_colors</a> function,
although it is recommended to double-check the results.
</p>


<h3>Value</h3>

<p>A <code>recolorize</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>img &lt;- system.file("extdata/corbetti.png", package = "recolorize")
rc &lt;- recolorize2(img, cutoff = 45)
ref_palette &lt;- c("mediumblue", "olivedrab", "tomato2", "beige", "grey10")
col_order &lt;- match_colors(ref_palette, rc$centers, plotting = TRUE)
rc2 &lt;- reorder_colors(rc, col_order, plotting = FALSE)

# the colors are reordered, but not changed to match the reference palette:
plot(rc2)

# you can also change them to the reference palette:
rc2$centers &lt;- t(grDevices::col2rgb(ref_palette) / 255)
plot(rc2)
</code></pre>

<hr>
<h2 id='rerun_recolorize'>Rerun the sequence of calls used to produce a recolorize object</h2><span id='topic+rerun_recolorize'></span>

<h3>Description</h3>

<p>Evaluates the series of calls in the 'call' element of a recolorize object,
either on the original image (default) or on another image. It will almost
always be easier (and better practice) to define a new function that calls a
series of recolorize function in order than to use this function!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rerun_recolorize(recolorize_obj, img = "original")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rerun_recolorize_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>An object of S3 class 'recolorize'.</p>
</td></tr>
<tr><td><code id="rerun_recolorize_+3A_img">img</code></td>
<td>
<p>The image on which to call the recolorize functions. If left as
&quot;original&quot; (the default), functions are called on the original image stored
in the recolorize object. Otherwise can be an object taken by the <code>img</code>
argument of recolorize functions (a path to an image or an image array).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function utilizes <code>eval</code> statements to evaluate the calls
that were stored in the <code>call</code> element of the specified recolorize object.
This makes it potentially more unpredictable than simply defining your own
function, which is preferable.
</p>


<h3>Value</h3>

<p>A <code>recolorize</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# list images
corbetti &lt;- system.file("extdata/corbetti.png", package = "recolorize")
chongi &lt;- system.file("extdata/chongi.png", package = "recolorize")

# fit a recolorize object by running two functions in a row:
rc &lt;- recolorize(corbetti, bins = 2, plotting = FALSE)
rc &lt;- recluster(rc, cutoff = 45)

# check out the call structure (a list of commands that were run):
rc$call

# we can rerun the analysis on the same image (bit pointless):
rerun &lt;- rerun_recolorize(rc)

# or, we can rerun it on a new image:
rerun_chongi &lt;- rerun_recolorize(rc, img = chongi)

</code></pre>

<hr>
<h2 id='rgb2hsl'>Convert RGB colors to HSL</h2><span id='topic+rgb2hsl'></span>

<h3>Description</h3>

<p>Convert RGB colors (0-1 range) to HSL (hue-saturation-luminance)
space. Used for passing RGB colors to <a href="pavo.html#topic+adjacent">pavo::adjacent</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgb2hsl(rgb_matrix, radians = TRUE, pavo_hsl = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rgb2hsl_+3A_rgb_matrix">rgb_matrix</code></td>
<td>
<p>RGB colors in an nx3 matrix (rows = colors,
columns = channels).</p>
</td></tr>
<tr><td><code id="rgb2hsl_+3A_radians">radians</code></td>
<td>
<p>Logical. Return HSL colors in units of radians
(<code>TRUE</code>) or degrees (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="rgb2hsl_+3A_pavo_hsl">pavo_hsl</code></td>
<td>
<p>Logical. Return HSL matrix in a format that
can be passed directly to <a href="pavo.html#topic+adjacent">pavo::adjacent</a> as the <code>hsl</code> parameter?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with <code>patch</code>, <code>hue</code>, <code>sat</code>, and <code>lum</code> columns
and one row per color (if <code>pavo_hsl = TRUE</code>) or a matrix of the HSL
coordinates (if <code>pavo_hsl = FALSE</code>).
</p>

<hr>
<h2 id='splitByColor'>Split color clusters in a recolorize object into layers</h2><span id='topic+splitByColor'></span>

<h3>Description</h3>

<p>Separates color clusters from a <code><a href="#topic+recolorize">recolorize()</a></code>,
<code><a href="#topic+recluster">recluster()</a></code>, or <code><a href="#topic+imposeColors">imposeColors()</a></code> object
into binary masks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitByColor(
  recolorize_obj,
  layers = "all",
  plot_method = c("overlay", "binary", "colormask", "none")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitByColor_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>A recolorize object from <code><a href="#topic+recolorize">recolorize()</a></code>,
<code><a href="#topic+recluster">recluster()</a></code>, or <code><a href="#topic+imposeColors">imposeColors()</a></code>.</p>
</td></tr>
<tr><td><code id="splitByColor_+3A_layers">layers</code></td>
<td>
<p>Either <code>"all"</code> or a numeric vector of which color centers to
return.</p>
</td></tr>
<tr><td><code id="splitByColor_+3A_plot_method">plot_method</code></td>
<td>
<p>Plotting method for plotting the color layers. Options
are<code>"overlay"</code>, <code>"binary"</code>, <code>"colormask"</code>, or <code>"none"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of binary matrices (1/white = color presence, 0/black = color
absence), one per color center.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get original fit
corbetti &lt;- system.file("extdata/corbetti.png", package = "recolorize")
recolored_corbetti &lt;- recolorize::recolorize(corbetti, plotting = TRUE)

# to reset graphical parameters:
current_par &lt;- graphics::par(no.readonly = TRUE)

# make a layout
layout(matrix(c(1, 1:9), nrow = 2))
par(mar = c(0, 0, 2, 0))
# plot original
plotImageArray(recolored_corbetti$original_img)

# plot layers
corbetti_layers &lt;- splitByColor(recolored_corbetti, plot_method = "over")

# plot binary maps
plotImageArray(recolored_corbetti$original_img)
for (i in 1:length(corbetti_layers)) {
  plotImageArray(corbetti_layers[[i]])
}

graphics::par(current_par)
</code></pre>

<hr>
<h2 id='thresholdRecolor'>Drop minor colors from a recolorize object</h2><span id='topic+thresholdRecolor'></span>

<h3>Description</h3>

<p>Drops color patches whose cumulative sum (as a proportion of total pixels
assigned) is equal to or less than <code>pct</code>, so that only the dominant
color patches remain, and refits the object with the reduced set of
color centers Useful for dropping spurious detail colors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thresholdRecolor(recolorize_obj, pct = 0.05, plotting = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="thresholdRecolor_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>An object of class <code>recolorize</code>.</p>
</td></tr>
<tr><td><code id="thresholdRecolor_+3A_pct">pct</code></td>
<td>
<p>The proportion cutoff (0-1) for dropping color patches. The
higher this value is, the more/larger color centers will be dropped.</p>
</td></tr>
<tr><td><code id="thresholdRecolor_+3A_plotting">plotting</code></td>
<td>
<p>Logical. Plot the results?</p>
</td></tr>
<tr><td><code id="thresholdRecolor_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <a href="#topic+imposeColors">imposeColors</a>, which is
called for refitting a new recolorize object for the reduced set of
clusters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is fairly simple in execution: the color centers are
arranged by their sizes, largest to smallest, and their cumulative sum is
calculated. The minimum number of color centers to reach a cumulative sum
equal to or greater than the cutoff (<code>1 - pct</code>) is retained, and these
dominant colors are used to re-fit the image. Despite being
straightforward, this can be a surprisingly useful function.
</p>


<h3>Value</h3>

<p>A <code>recolorize</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
img &lt;- system.file("extdata/fulgidissima.png", package = "recolorize")
init_fit &lt;- recolorize(img, bins = 3)
thresh_fit &lt;- thresholdRecolor(init_fit, pct = 0.1)

# if you take it too far, you just get one color back:
thresh_fit_oops &lt;- thresholdRecolor(init_fit, pct = 1)

</code></pre>

<hr>
<h2 id='werner'>Werner's nomenclature of colors</h2><span id='topic+werner'></span>

<h3>Description</h3>

<p>A table of the 110 colors described in &quot;Werner's Nomenclature of Colors&quot;, the
1821 color reference by Patrick Syme (building on work by Abraham Gottlob
Werner), notably used by Charles Darwin. Colors represent the average pixel
color of each scanned swatch.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>werner
</code></pre>


<h3>Format</h3>

<p>A data frame with 110 rows and 13 variables:
</p>

<dl>
<dt>index</dt><dd><p>The color index.</p>
</dd>
<dt>family</dt><dd><p>The broad color category (white, red, etc).</p>
</dd>
<dt>name</dt><dd><p>The original color name.</p>
</dd>
<dt>hex</dt><dd><p>Color hex code.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.c82.net/werner/#colors">https://www.c82.net/werner/#colors</a>
</p>

<hr>
<h2 id='wernerColor'>Remap an image to Werner's nomenclature</h2><span id='topic+wernerColor'></span>

<h3>Description</h3>

<p>Remaps a recolorize object to the colors in Werner's Nomenclature of Colors
by Patrick Syme (1821), one of the first attempts at an objective color
reference in western science, notably used by Charles Darwin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wernerColor(
  recolorize_obj,
  which_img = c("original", "recolored"),
  n_colors = 5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="wernerColor_+3A_recolorize_obj">recolorize_obj</code></td>
<td>
<p>A recolorize object as returned by
<code><a href="#topic+recolorize">recolorize()</a></code>, <code><a href="#topic+recluster">recluster()</a></code>, or
<code><a href="#topic+imposeColors">imposeColors()</a></code>.</p>
</td></tr>
<tr><td><code id="wernerColor_+3A_which_img">which_img</code></td>
<td>
<p>Which image to recolor; one of either &quot;original&quot; or
&quot;recolored&quot;.</p>
</td></tr>
<tr><td><code id="wernerColor_+3A_n_colors">n_colors</code></td>
<td>
<p>Number of colors to list out in plotting, in order of
size. Ex: <code>n_colors = 5</code> will plot the 5 largest colors and their names.
All colors are returned as a normal recolorize object regardless of
<code>n_colors</code>; this only affects the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="https://www.c82.net/werner/">https://www.c82.net/werner/</a> to check out the original colors.
</p>


<h3>Value</h3>

<p>A <code>recolorize</code> object with an additional list element, <code>werner_names</code>,
listing the Werner color names for each center.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# get an initial fit:
corbetti &lt;- system.file("extdata/corbetti.png", package = "recolorize")
recolored_corbetti &lt;- recolorize(corbetti, plotting = FALSE)

# recolor original image
corbetti_werner &lt;- wernerColor(recolored_corbetti,
                               which_img = "original",
                               n_colors = 6)

# we can simplify the colors and then do it again:
corbetti_recluster &lt;- recluster(recolored_corbetti,
                                cutoff = 45,
                                plot_hclust = FALSE)
corbetti_werner &lt;- wernerColor(corbetti_recluster,
                               which_img = "recolored")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
