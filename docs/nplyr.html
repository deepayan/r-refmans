<!DOCTYPE html><html><head><title>Help for package nplyr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nplyr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#job_survey'><p>Example survey data regarding job satisfaction</p></a></li>
<li><a href='#nest_arrange'><p>Arrange rows within a nested data frames by column values</p></a></li>
<li><a href='#nest_count'><p>Count observations in a nested data frame by group</p></a></li>
<li><a href='#nest_distinct'><p>Subset distinct/unique rows within a nested data frame</p></a></li>
<li><a href='#nest_drop_na'><p>Drop rows containing missing values in a column of nested data frames</p></a></li>
<li><a href='#nest_extract'><p>Extract a character column into multiple columns using regex groups in a column of nested data frames</p></a></li>
<li><a href='#nest_fill'><p>Fill missing values in a column of nested data frames</p></a></li>
<li><a href='#nest_filter'><p>Subset rows in nested data frames using column values.</p></a></li>
<li><a href='#nest_group_by'><p>Group nested data frames by one or more variables</p></a></li>
<li><a href='#nest_mutate'><p>Create, modify, and delete columns in nested data frames</p></a></li>
<li><a href='#nest_nest_join'><p>Nested nest join</p></a></li>
<li><a href='#nest_relocate'><p>Change column order within a nested data frame</p></a></li>
<li><a href='#nest_rename'><p>Rename columns in nested data frames</p></a></li>
<li><a href='#nest_replace_na'><p>Replace NAs with specified values in a column of nested data frames</p></a></li>
<li><a href='#nest_select'><p>Subset columns in nested data frames using their names and types</p></a></li>
<li><a href='#nest_separate'><p>Separate a character column into multiple columns in a column of nested data frames</p></a></li>
<li><a href='#nest_slice'><p>Subset rows in nested data frames using their positions.</p></a></li>
<li><a href='#nest_summarise'><p>Summarise each group in nested data frames to fewer rows</p></a></li>
<li><a href='#nest_unite'><p>Unite multiple columns into one in a column of nested data frames</p></a></li>
<li><a href='#nest-filter-joins'><p>Nested filtering joins</p></a></li>
<li><a href='#nest-mutate-joins'><p>Nested Mutating joins</p></a></li>
<li><a href='#personal_survey'><p>Example survey data regarding personal life satisfaction</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Grammar of Nested Data Manipulation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for manipulating nested data frames in a 
    list-column using 'dplyr' <a href="https://dplyr.tidyverse.org/">https://dplyr.tidyverse.org/</a> syntax. Rather than 
    unnesting, then manipulating a data frame, 'nplyr' allows users to 
    manipulate each nested data frame directly. 'nplyr' is a wrapper for 'dplyr'
    functions that provide tools for common data manipulation steps: filtering 
    rows, selecting columns, summarising grouped data, among others.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/markjrieke/nplyr">https://github.com/markjrieke/nplyr</a>,
<a href="https://markjrieke.github.io/nplyr/">https://markjrieke.github.io/nplyr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/markjrieke/nplyr/issues">https://github.com/markjrieke/nplyr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>dplyr, tidyr, R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, purrr, rlang</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gapminder, knitr, readr, rmarkdown, stringr, testthat (&ge;
3.0.0), tibble</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-14 17:18:00 UTC; E1735399</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark Rieke [aut, cre],
  Joran Elias [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mark Rieke &lt;markjrieke@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-14 17:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='job_survey'>Example survey data regarding job satisfaction</h2><span id='topic+job_survey'></span>

<h3>Description</h3>

<p>A toy dataset containing 500 responses to a job satisfaction survey. The
responses were randomly generated using the Qualtrics survey platform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>job_survey
</code></pre>


<h3>Format</h3>

<p>A data frame with 500 rows and 6 variables:
</p>

<dl>
<dt>survey_name</dt><dd><p>name of survey</p>
</dd>
<dt>Q1</dt><dd><p>respondent age</p>
</dd>
<dt>Q2</dt><dd><p>city the respondent resides in</p>
</dd>
<dt>Q3</dt><dd><p>field that the respondent that works in</p>
</dd>
<dt>Q4</dt><dd><p>respondent's job satisfaction (on a scale from extremely satisfied to extremely dissatisfied)</p>
</dd>
<dt>Q5</dt><dd><p>respondent's annual salary, in thousands of dollars</p>
</dd>
</dl>


<hr>
<h2 id='nest_arrange'>Arrange rows within a nested data frames by column values</h2><span id='topic+nest_arrange'></span>

<h3>Description</h3>

<p><code>nest_arrange()</code> orders the rows of nested data frames by the values of
selected columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_arrange(.data, .nest_data, ..., .by_group = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_arrange_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_arrange_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_arrange_+3A_...">...</code></td>
<td>
<p>Variables, or functions of variables. Use <code><a href="dplyr.html#topic+desc">dplyr::desc()</a></code> to sort
a variable in descending order.</p>
</td></tr>
<tr><td><code id="nest_arrange_+3A_.by_group">.by_group</code></td>
<td>
<p>If <code>TRUE</code>, will sort first by grouping variable. Applies to
grouped data frames only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_arrange()</code> is largely a wrapper for <code><a href="dplyr.html#topic+arrange">dplyr::arrange()</a></code> and maintains
the functionality of <code>arrange()</code> within each nested data frame. For more
information on <code>arrange()</code>, please refer to the documentation in
<a href="https://dplyr.tidyverse.org/"><code>dplyr</code></a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will be also of the same type as the input. Each object in <code>.nest_data</code> has
the following properties:
</p>

<ul>
<li><p> All rows appear in the output, but (usually) in a different place.
</p>
</li>
<li><p> Columns are not modified.
</p>
</li>
<li><p> Groups are not modified.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="#topic+nest_filter">nest_filter</a>()</code>,
<code><a href="#topic+nest_mutate">nest_mutate</a>()</code>,
<code><a href="#topic+nest_rename">nest_rename</a>()</code>,
<code><a href="#topic+nest_select">nest_select</a>()</code>,
<code><a href="#topic+nest_slice">nest_slice</a>()</code>,
<code><a href="#topic+nest_summarise">nest_summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm_nest &lt;- gapminder::gapminder %&gt;% tidyr::nest(country_data = -continent)

gm_nest %&gt;% 
  nest_arrange(country_data, pop)

gm_nest %&gt;%
  nest_arrange(country_data, desc(pop))
</code></pre>

<hr>
<h2 id='nest_count'>Count observations in a nested data frame by group</h2><span id='topic+nest_count'></span><span id='topic+nest_add_count'></span>

<h3>Description</h3>

<p><code>nest_count()</code> lets you quickly count the unique values of one or more
variables within each nested data frame. <code>nest_count()</code> results in a summary
with one row per each set of variables to count by. <code>nest_add_count()</code> is
equivalent with the exception that it retains all rows and adds a new column
with group-wise counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_count(.data, .nest_data, ..., wt = NULL, sort = FALSE, name = NULL)

nest_add_count(.data, .nest_data, ..., wt = NULL, sort = FALSE, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_count_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_count_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_count_+3A_...">...</code></td>
<td>
<p>Variables to group by.</p>
</td></tr>
<tr><td><code id="nest_count_+3A_wt">wt</code></td>
<td>
<p>Frequency weights.
Can be <code>NULL</code> or a variable:
</p>

<ul>
<li><p> If <code>NULL</code> (the default), counts the number of rows in each group.
</p>
</li>
<li><p> If a variable, computes <code>sum(wt)</code> for each group.
</p>
</li></ul>
</td></tr>
<tr><td><code id="nest_count_+3A_sort">sort</code></td>
<td>
<p>If <code>TRUE</code>, will show the largest groups at the top.</p>
</td></tr>
<tr><td><code id="nest_count_+3A_name">name</code></td>
<td>
<p>The name of the new column in the output.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_count()</code> and <code>nest_add_count()</code> are largely wrappers for
<code><a href="dplyr.html#topic+count">dplyr::count()</a></code> and <code><a href="dplyr.html#topic+count">dplyr::add_count()</a></code> and maintain the functionality of
<code>count()</code> and <code>add_count()</code> within each nested data frame. For more
information on <code>count()</code> and <code>add_count()</code>, please refer to the documentation
in <a href="https://dplyr.tidyverse.org/"><code>dplyr</code></a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will also be of the same type as the input. <code>nest_count()</code> and
<code>nest_add_count()</code> group each object in <code>.nest_data</code> transiently, so the
output returned in <code>.nest_data</code> will have the same groups as the input.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm_nest &lt;- gapminder::gapminder %&gt;% tidyr::nest(country_data = -continent)

# count the number of times each country appears in each nested tibble
gm_nest %&gt;% nest_count(country_data, country)
gm_nest %&gt;% nest_add_count(country_data, country)

# count the sum of population for each country in each nested tibble
gm_nest %&gt;% nest_count(country_data, country, wt = pop)
gm_nest %&gt;% nest_add_count(country_data, country, wt = pop)
</code></pre>

<hr>
<h2 id='nest_distinct'>Subset distinct/unique rows within a nested data frame</h2><span id='topic+nest_distinct'></span>

<h3>Description</h3>

<p><code>nest_distinct()</code> selects only unique/distinct rows in a nested data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_distinct(.data, .nest_data, ..., .keep_all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_distinct_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_distinct_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_distinct_+3A_...">...</code></td>
<td>
<p>Optional variables to use when determining uniqueness. If there
are multiple rows for a given combination of inputs, only the first row
will be preserved. If omitted, will use all variables.</p>
</td></tr>
<tr><td><code id="nest_distinct_+3A_.keep_all">.keep_all</code></td>
<td>
<p>If <code>TRUE</code>, keep all variables in <code>.nest_data</code>. If a
combination of <code>...</code> is not distinct, this keeps the first row of values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_distinct()</code> is largely a wrapper for <code><a href="dplyr.html#topic+distinct">dplyr::distinct()</a></code> and maintains
the functionality of <code>distinct()</code> within each nested data frame. For more
information on <code>distinct()</code>, please refer to the documentation in
<a href="https://dplyr.tidyverse.org/"><code>dplyr</code></a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will also be of the same type as the input. Each object in <code>.nest_data</code> has
the following properties:
</p>

<ul>
<li><p> Rows are a subset of the input but appear in the same order.
</p>
</li>
<li><p> Columns are not modified if <code>...</code> is empty or <code>.keep_all</code> is <code>TRUE</code>.
Otherwise, <code>nest_distinct()</code> first calls <code>dplyr::mutate()</code> to create new
columns within each object in <code>.nest_data</code>.
</p>
</li>
<li><p> Groups are not modified.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>gm_nest &lt;- gapminder::gapminder %&gt;% tidyr::nest(country_data = -continent)

gm_nest %&gt;% nest_distinct(country_data, country)
gm_nest %&gt;% nest_distinct(country_data, country, year)
</code></pre>

<hr>
<h2 id='nest_drop_na'>Drop rows containing missing values in a column of nested data frames</h2><span id='topic+nest_drop_na'></span>

<h3>Description</h3>

<p><code>nest_drop_na()</code> is used to drop rows from each data frame in a column of
nested data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_drop_na(.data, .nest_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_drop_na_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_drop_na_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_drop_na_+3A_...">...</code></td>
<td>
<p>Columns within <code>.nest_data</code> to inspect for missing values. If empty,
all columns within each dataframe in <code>.nest_data</code> are used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_drop_na()</code> is a wrapper for <code><a href="tidyr.html#topic+drop_na">tidyr::drop_na()</a></code> and maintains the functionality
of <code>drop_na()</code> within each nested data frame. For more information on <code>drop_na()</code>
please refer to the documentation in <a href="https://tidyr.tidyverse.org/">'tidyr'</a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will have rows dropped according to the presence of NAs.
</p>


<h3>See Also</h3>

<p>Other tidyr verbs: 
<code><a href="#topic+nest_extract">nest_extract</a>()</code>,
<code><a href="#topic+nest_fill">nest_fill</a>()</code>,
<code><a href="#topic+nest_replace_na">nest_replace_na</a>()</code>,
<code><a href="#topic+nest_separate">nest_separate</a>()</code>,
<code><a href="#topic+nest_unite">nest_unite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm &lt;- gapminder::gapminder 

# randomly insert NAs into the dataframe &amp; nest
set.seed(123) 
gm &lt;- gm %&gt;% mutate(pop = if_else(runif(nrow(gm)) &gt;= 0.9, NA_integer_, pop))
gm_nest &lt;- gm %&gt;% tidyr::nest(country_data = -continent)

# drop rows where an NA exists in column `pop`
gm_nest %&gt;% nest_drop_na(.nest_data = country_data,pop)
</code></pre>

<hr>
<h2 id='nest_extract'>Extract a character column into multiple columns using regex groups in a column of nested data frames</h2><span id='topic+nest_extract'></span>

<h3>Description</h3>

<p><code>nest_extract()</code> is used to extract capturing groups from a column in a nested
data frame using regular expressions into a new column. If the groups don't
match, or the input is NA, the output will be NA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_extract(
  .data,
  .nest_data,
  col,
  into,
  regex = "([[:alnum:]]+)",
  remove = TRUE,
  convert = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_extract_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_extract_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_extract_+3A_col">col</code></td>
<td>
<p>Column name or position within <code>.nest_data</code> (must be present within
all nested data frames in <code>.nest_data</code>). This is passed to <code>tidyselect::vars_pull()</code>.
</p>
<p>This argument is passed by expression and supports quasiquotation (you can
unquote column names or column positions).</p>
</td></tr>
<tr><td><code id="nest_extract_+3A_into">into</code></td>
<td>
<p>Names of new variables to create as character vector.
Use <code>NA</code> to omit the variable in the output.</p>
</td></tr>
<tr><td><code id="nest_extract_+3A_regex">regex</code></td>
<td>
<p>A string representing a regular expression used to extract the
desired values. There should be one group (defined by <code style="white-space: pre;">&#8288;()&#8288;</code>) for each
element of <code>into</code>.</p>
</td></tr>
<tr><td><code id="nest_extract_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input column from output data frame.</p>
</td></tr>
<tr><td><code id="nest_extract_+3A_convert">convert</code></td>
<td>
<p>If <code>TRUE</code>, will run <code><a href="utils.html#topic+type.convert">type.convert()</a></code> with
<code>as.is = TRUE</code> on new columns. This is useful if the component
columns are integer, numeric or logical.
</p>
<p>NB: this will cause string <code>"NA"</code>s to be converted to <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="nest_extract_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="tidyr.html#topic+extract">tidyr::extract()</a></code> methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_extract()</code> is a wrapper for <code><a href="tidyr.html#topic+extract">tidyr::extract()</a></code> and maintains the functionality
of <code>extract()</code> within each nested data frame. For more information on <code>extract()</code>
please refer to the documentation in <a href="https://tidyr.tidyverse.org/">'tidyr'</a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will have new columns created according to the capture groups specified in
the regular expression.
</p>


<h3>See Also</h3>

<p>Other tidyr verbs: 
<code><a href="#topic+nest_drop_na">nest_drop_na</a>()</code>,
<code><a href="#topic+nest_fill">nest_fill</a>()</code>,
<code><a href="#topic+nest_replace_na">nest_replace_na</a>()</code>,
<code><a href="#topic+nest_separate">nest_separate</a>()</code>,
<code><a href="#topic+nest_unite">nest_unite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
gm &lt;- gapminder::gapminder 
gm &lt;- gm %&gt;% mutate(comb = sample(c(NA, "a-b", "a-d", "b-c", "d-e"),size = nrow(gm),replace = TRUE))
gm_nest &lt;- gm %&gt;% tidyr::nest(country_data = -continent)

gm_nest %&gt;% 
  nest_extract(.nest_data = country_data,
               col = comb,
               into = c("var1","var2"),
               regex = "([[:alnum:]]+)-([[:alnum:]]+)")
</code></pre>

<hr>
<h2 id='nest_fill'>Fill missing values in a column of nested data frames</h2><span id='topic+nest_fill'></span>

<h3>Description</h3>

<p><code>nest_fill()</code> is used to fill missing values in selected columns of nested data
frames using the next or previous entries in a column of nested data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_fill(
  .data,
  .nest_data,
  ...,
  .direction = c("down", "up", "downup", "updown")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_fill_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_fill_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_fill_+3A_...">...</code></td>
<td>
<p>&lt;<code><a href="tidyr.html#topic+tidyr_tidy_select">tidy-select</a></code>&gt; Columns to fill.</p>
</td></tr>
<tr><td><code id="nest_fill_+3A_.direction">.direction</code></td>
<td>
<p>Direction in which to fill missing values. Currently either
&quot;down&quot; (the default), &quot;up&quot;, &quot;downup&quot; (i.e. first down and then up) or &quot;updown&quot;
(first up and then down).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_fill()</code> is a wrapper for <code><a href="tidyr.html#topic+fill">tidyr::fill()</a></code> and maintains the functionality
of <code>fill()</code> within each nested data frame. For more information on <code>fill()</code>
please refer to the documentation in <a href="https://tidyr.tidyverse.org/">'tidyr'</a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will have the chosen columns filled in the direction specified by <code>.direction</code>.
</p>


<h3>See Also</h3>

<p>Other tidyr verbs: 
<code><a href="#topic+nest_drop_na">nest_drop_na</a>()</code>,
<code><a href="#topic+nest_extract">nest_extract</a>()</code>,
<code><a href="#topic+nest_replace_na">nest_replace_na</a>()</code>,
<code><a href="#topic+nest_separate">nest_separate</a>()</code>,
<code><a href="#topic+nest_unite">nest_unite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
gm &lt;- gapminder::gapminder %&gt;% mutate(pop = if_else(runif(n()) &gt;= 0.9,NA_integer_,pop))
gm_nest &lt;- gm %&gt;% tidyr::nest(country_data = -continent)

gm_nest %&gt;% nest_fill(.nest_data = country_data,pop,.direction = "down")
</code></pre>

<hr>
<h2 id='nest_filter'>Subset rows in nested data frames using column values.</h2><span id='topic+nest_filter'></span>

<h3>Description</h3>

<p><code>nest_filter()</code> is used to subset nested data frames, retaining all rows that
satisfy your conditions. To be retained, the row must produce a value of
<code>TRUE</code> for all conditions. Note that when a condition evaluates to <code>NA</code> the
row will be dropped, unlike base subsetting with <code>[</code>.
</p>
<p><code>nest_filter()</code> subsets the rows within <code>.nest_data</code>, applying the
expressions in <code>...</code> to the column values to determine which rows should be
retained. It can be applied to both grouped and ungrouped data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_filter(.data, .nest_data, ..., .preserve = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_filter_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_filter_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_filter_+3A_...">...</code></td>
<td>
<p>Expressions that return a logical value, and are defined in terms
of the variables in <code>.nest_data</code>. If multiple expressions are included,
they are combined with the <code>&amp;</code> operator. Only rows for which all conditions
evaluate to <code>TRUE</code> are kept.</p>
</td></tr>
<tr><td><code id="nest_filter_+3A_.preserve">.preserve</code></td>
<td>
<p>Relevant when <code>.nest_data</code> is grouped. If
<code>.preserve = FALSE</code> (the default), the grouping structure is recalculated
based on the resulting data, otherwise the grouping is kept as is.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_filter()</code> is largely a wrapper for <code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code> and maintains the
functionality of <code>filter()</code> within each nested data frame. For more
information on <code>filter()</code>, please refer to the documentation in
<a href="https://dplyr.tidyverse.org/"><code>dplyr</code></a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will also be of the same type as the input. Each object in <code>.nest_data</code> has
the following properties:
</p>

<ul>
<li><p> Rows are a subset of the input, but appear in the same order.
</p>
</li>
<li><p> Columns are not modified.
</p>
</li>
<li><p> The number of groups may be reduced (if <code>.preserve</code> is not <code>TRUE</code>).
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="#topic+nest_arrange">nest_arrange</a>()</code>,
<code><a href="#topic+nest_mutate">nest_mutate</a>()</code>,
<code><a href="#topic+nest_rename">nest_rename</a>()</code>,
<code><a href="#topic+nest_select">nest_select</a>()</code>,
<code><a href="#topic+nest_slice">nest_slice</a>()</code>,
<code><a href="#topic+nest_summarise">nest_summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm_nest &lt;- gapminder::gapminder %&gt;% tidyr::nest(country_data = -continent)

# apply a filter
gm_nest %&gt;%
  nest_filter(country_data, year &gt; 1972)

# apply multiple filters
gm_nest %&gt;%
  nest_filter(country_data, year &gt; 1972, pop &lt; 10000000)
  
# apply a filter on grouped data
gm_nest %&gt;%
  nest_group_by(country_data, country) %&gt;%
  nest_filter(country_data, pop &gt; mean(pop))
</code></pre>

<hr>
<h2 id='nest_group_by'>Group nested data frames by one or more variables</h2><span id='topic+nest_group_by'></span><span id='topic+nest_ungroup'></span>

<h3>Description</h3>

<p><code>nest_group_by()</code> takes a set of nested tbls and converts it to a set of
nested grouped tbls where operations are performed &quot;by group&quot;.
<code>nest_ungroup()</code> removes grouping.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_group_by(.data, .nest_data, ..., .add = FALSE, .drop = TRUE)

nest_ungroup(.data, .nest_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_group_by_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_group_by_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_group_by_+3A_...">...</code></td>
<td>
<p>In <code>nest_group_by()</code>, variables or computations to group by.
Computations are always done on the ungrouped data frames. To perform
computations on the grouped data, you need to use a separate <code>mutate()</code>
step after the <code>group_by()</code>.
In <code>nest_ungroup()</code>, variables to remove from the grouping.</p>
</td></tr>
<tr><td><code id="nest_group_by_+3A_.add">.add</code></td>
<td>
<p>When <code>FALSE</code> (the default), <code>nest_group_by()</code> will override the
existing groups. To add to the existing groups, use <code>.add = TRUE</code>.</p>
</td></tr>
<tr><td><code id="nest_group_by_+3A_.drop">.drop</code></td>
<td>
<p>Drop groups formed by factor levels that don't appear in the
data? The default is <code>TRUE</code> except when <code>.nest_data</code> has been previously
grouped with <code>.drop = FALSE</code>. See <code><a href="dplyr.html#topic+group_by_drop_default">dplyr::group_by_drop_default()</a></code> for
details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_group_by()</code> and <code>nest_ungroup()</code> are largely wrappers for
<code><a href="dplyr.html#topic+group_by">dplyr::group_by()</a></code> and <code><a href="dplyr.html#topic+group_by">dplyr::ungroup()</a></code> and maintain the functionality of
<code>group_by()</code> and <code>ungroup()</code> within each nested data frame. For more
information on <code>group_by()</code> or <code>ungroup()</code>, please refer to the documentation
in <a href="https://dplyr.tidyverse.org/"><code>dplyr</code></a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will be returned as a grouped data frame with class <code>grouped_df</code>, unless the
combination of <code>...</code> and <code>.add</code> yields an empty set of grouping columns, in
which case a tibble will be returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm_nest &lt;- gapminder::gapminder %&gt;% tidyr::nest(country_data = -continent)

# grouping doesn't change .nest_data, just .nest_data class:
gm_nest_grouped &lt;-
  gm_nest %&gt;%
  nest_group_by(country_data, year)

gm_nest_grouped

# It changes how it acts with other nplyr verbs:
gm_nest_grouped %&gt;%
  nest_summarise(
    country_data,
    lifeExp = mean(lifeExp),
    pop = mean(pop),
    gdpPercap = mean(gdpPercap)
  )

# ungrouping removes variable groups:
gm_nest_grouped %&gt;% nest_ungroup(country_data)
</code></pre>

<hr>
<h2 id='nest_mutate'>Create, modify, and delete columns in nested data frames</h2><span id='topic+nest_mutate'></span><span id='topic+nest_transmute'></span>

<h3>Description</h3>

<p><code>nest_mutate()</code> adds new variables to and preserves existing ones within
the nested data frames in <code>.nest_data</code>.
<code>nest_transmute()</code> adds new variables to and drops existing ones from the
nested data frames in <code>.nest_data</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_mutate(.data, .nest_data, ...)

nest_transmute(.data, .nest_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_mutate_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_mutate_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_mutate_+3A_...">...</code></td>
<td>
<p>Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_mutate()</code> and <code>nest_transmute()</code> are largely wrappers for
<code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code> and <code><a href="dplyr.html#topic+transmute">dplyr::transmute()</a></code> and maintain the functionality of
<code>mutate()</code> and <code>transmute()</code> within each nested data frame. For more
information on <code>mutate()</code> or <code>transmute()</code>, please refer to the documentation
in <a href="https://dplyr.tidyverse.org/"><code>dplyr</code></a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will also be of the same type as the input. Each object in <code>.nest_data</code> has
the following properties:
</p>

<ul>
<li><p> For <code>nest_mutate()</code>:
</p>

<ul>
<li><p> Columns from each object in <code>.nest_data</code> will be preserved according to
the <code>.keep</code> argument.
</p>
</li>
<li><p> Existing columns that are modified by <code>...</code> will always be returned in
their original location.
</p>
</li>
<li><p> New columns created through <code>...</code> will be placed according to the
<code>.before</code> and <code>.after</code> arguments.
</p>
</li></ul>

</li>
<li><p> For <code>nest_transmute()</code>:
</p>

<ul>
<li><p> Columns created or modified through <code>...</code> will be returned in the order
specified by <code>...</code>.
</p>
</li>
<li><p> Unmodified grouping columns will be placed at the front.
</p>
</li></ul>

</li>
<li><p> The number of rows is not affected.
</p>
</li>
<li><p> Columns given the value <code>NULL</code> will be removed.
</p>
</li>
<li><p> Groups will be recomputed if a grouping variable is mutated.
</p>
</li>
<li><p> Data frame attributes will be preserved.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="#topic+nest_arrange">nest_arrange</a>()</code>,
<code><a href="#topic+nest_filter">nest_filter</a>()</code>,
<code><a href="#topic+nest_rename">nest_rename</a>()</code>,
<code><a href="#topic+nest_select">nest_select</a>()</code>,
<code><a href="#topic+nest_slice">nest_slice</a>()</code>,
<code><a href="#topic+nest_summarise">nest_summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm_nest &lt;- gapminder::gapminder %&gt;% tidyr::nest(country_data = -continent)

# add or modify columns:
gm_nest %&gt;%
  nest_mutate(
    country_data,
    lifeExp = NULL,
    gdp = gdpPercap * pop,
    pop = pop/1000000
  )
  
# use dplyr::across() to apply transformation to multiple columns 
gm_nest %&gt;%
  nest_mutate(
    country_data,
    across(c(lifeExp:gdpPercap), mean)
  )

# nest_transmute() drops unused columns when mutating:
gm_nest %&gt;%
  nest_transmute(
    country_data,
    country = country,
    year = year,
    pop = pop/1000000
  )
</code></pre>

<hr>
<h2 id='nest_nest_join'>Nested nest join</h2><span id='topic+nest_nest_join'></span>

<h3>Description</h3>

<p><code>nest_nest_join()</code> returns all rows and columns in <code>.nest_data</code> with a new
nested-df column that contains all matches from <code>y</code>. When there is no match,
the list contains a 0-row tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_nest_join(
  .data,
  .nest_data,
  y,
  by = NULL,
  copy = FALSE,
  keep = FALSE,
  name = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_nest_join_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_nest_join_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_nest_join_+3A_y">y</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy data
frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_nest_join_+3A_by">by</code></td>
<td>
<p>A character vector of variables to join by or a join specification
created with <code>join_by()</code>.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;nest_*_join()&#8288;</code> will perform a natural join, using
all variables in common across each object in <code>.nest_data</code> and <code>y</code>. A
message lists the variables so you can check they're correct; suppress the
message by supplying <code>by</code> explicitly.
</p>
<p>To join on different variables between the objects in <code>.nest_data</code> and <code>y</code>,
use a named vector. For example, <code>by = c("a" = "b")</code> will match
<code>.nest_data$a</code> to <code>y$b</code> for each object in <code>.nest_data</code>.
</p>
<p>To join by multiple variables, use a vector with length &gt;1. For example,
<code>by = c("a", "b")</code> will match <code>.nest_data$a</code> to <code>y$a</code> and <code>.nest_data$b</code> to
<code>y$b</code> for each object in <code>.nest_data</code>. Use a named vector to match
different variables in <code>.nest_data</code> and <code>y</code>. For example,
<code>by = c("a" = "b", "c" = "d")</code> will match <code>.nest_data$a</code> to <code>y$b</code> and
<code>.nest_data$c</code> to <code>y$d</code> for each object in <code>.nest_data</code>.
</p>
<p>To perform a cross-join, generating all combinations of each object in
<code>.nest_data</code> and <code>y</code>, use <code>by = character()</code>.</p>
</td></tr>
<tr><td><code id="nest_nest_join_+3A_copy">copy</code></td>
<td>
<p>If <code>.nest_data</code> and <code>y</code> are not from the same data source and
<code>copy = TRUE</code> then <code>y</code> will be copied into the same src as <code>.nest_data</code>.
<em>(Need to review this parameter in more detail for applicability with nplyr)</em></p>
</td></tr>
<tr><td><code id="nest_nest_join_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>.nest_data</code> and <code>y</code> be preserved
in the output?</p>
</td></tr>
<tr><td><code id="nest_nest_join_+3A_name">name</code></td>
<td>
<p>The name of the list column nesting joins create. If <code>NULL</code>, the
name of <code>y</code> is used.</p>
</td></tr>
<tr><td><code id="nest_nest_join_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions separated by commas. Variable
names can be used if they were positions in the data frame, so expressions
like <code>x:y</code> can be used to select a range of variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_nest_join()</code> is largely a wrapper around <code><a href="dplyr.html#topic+nest_join">dplyr::nest_join()</a></code> and
maintains the functionality of <code>nest_join()</code> within east nested data frame.
For more information on <code>nest_join()</code>, please refer to the documentation in
<a href="https://dplyr.tidyverse.org/"><code>dplyr</code></a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will also be of the same type as the input.
</p>


<h3>See Also</h3>

<p>Other joins: 
<code><a href="#topic+nest-filter-joins">nest-filter-joins</a></code>,
<code><a href="#topic+nest-mutate-joins">nest-mutate-joins</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm_nest &lt;- gapminder::gapminder %&gt;% tidyr::nest(country_data = -continent)
gm_codes &lt;- gapminder::country_codes

gm_nest %&gt;% nest_nest_join(country_data, gm_codes, by = "country")
</code></pre>

<hr>
<h2 id='nest_relocate'>Change column order within a nested data frame</h2><span id='topic+nest_relocate'></span>

<h3>Description</h3>

<p><code>nest_relocate()</code> changes column positions within a nested data frame, using
the same syntax as <code><a href="#topic+nest_select">nest_select()</a></code> or <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> to make it easy to
move blocks of columns at once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_relocate(.data, .nest_data, ..., .before = NULL, .after = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_relocate_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_relocate_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_relocate_+3A_...">...</code></td>
<td>
<p>Columns to move.</p>
</td></tr>
<tr><td><code id="nest_relocate_+3A_.before">.before</code>, <code id="nest_relocate_+3A_.after">.after</code></td>
<td>
<p>Destination of columns selected by <code>...</code>. Supplying
neither will move columns to the left-hand side; specifying both is an
error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_relocate()</code> is largely a wrapper for <code><a href="dplyr.html#topic+relocate">dplyr::relocate()</a></code> and maintains
the functionality of <code>relocate()</code> within each nested data frame. For more
information on <code>relocate()</code>, please refer to the documentation in
<a href="https://dplyr.tidyverse.org/"><code>dplyr</code></a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will also be of the same type as the input. Each object in <code>.nest_data</code> has
the following properties:
</p>

<ul>
<li><p> Rows are not affected.
</p>
</li>
<li><p> The same columns appear in the output, but (usually) in a different place.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li>
<li><p> Groups are not affected.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>gm_nest &lt;- gapminder::gapminder %&gt;% tidyr::nest(country_data = -continent)

gm_nest %&gt;% nest_relocate(country_data, year)
gm_nest %&gt;% nest_relocate(country_data, pop, .after = year)
</code></pre>

<hr>
<h2 id='nest_rename'>Rename columns in nested data frames</h2><span id='topic+nest_rename'></span><span id='topic+nest_rename_with'></span>

<h3>Description</h3>

<p><code>nest_rename()</code> changes the names of individual variables using
<code>new_name = old_name</code> syntax; <code>nest_rename_with()</code> renames columns using a
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_rename(.data, .nest_data, ...)

nest_rename_with(.data, .nest_data, .fn, .cols = dplyr::everything(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_rename_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_rename_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_rename_+3A_...">...</code></td>
<td>
<p>For <code>nest_rename()</code>: Use <code>new_name = old_name</code> to rename selected variables.
</p>
<p>For <code>nest_rename_with()</code>: additional arguments passed onto <code>.fn</code>.</p>
</td></tr>
<tr><td><code id="nest_rename_+3A_.fn">.fn</code></td>
<td>
<p>A function used to transform the selected <code>.cols</code>. Should return a
character vector the same length as the input.</p>
</td></tr>
<tr><td><code id="nest_rename_+3A_.cols">.cols</code></td>
<td>
<p>Columns to rename; defaults to all columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_rename()</code> and <code>nest_rename_with()</code> are largely wrappers for
<code><a href="dplyr.html#topic+rename">dplyr::rename()</a></code> and <code><a href="dplyr.html#topic+rename">dplyr::rename_with()</a></code> and maintain the functionality
of <code>rename()</code> and <code>rename_with()</code> within each nested data frame. For more
information on <code>rename()</code> or <code>rename_with()</code>, please refer to the
documentation in <a href="https://dplyr.tidyverse.org/"><code>dplyr</code></a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will also be of the same type as the input. Each object in <code>.nest_data</code> has
the following properties:
</p>

<ul>
<li><p> Rows are not affected.
</p>
</li>
<li><p> Column names are changed; column order is preserved.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li>
<li><p> Groups are updated to reflect new names.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="#topic+nest_arrange">nest_arrange</a>()</code>,
<code><a href="#topic+nest_filter">nest_filter</a>()</code>,
<code><a href="#topic+nest_mutate">nest_mutate</a>()</code>,
<code><a href="#topic+nest_select">nest_select</a>()</code>,
<code><a href="#topic+nest_slice">nest_slice</a>()</code>,
<code><a href="#topic+nest_summarise">nest_summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm_nest &lt;- gapminder::gapminder %&gt;% tidyr::nest(country_data = -continent)

gm_nest %&gt;% nest_rename(country_data, population = pop)
gm_nest %&gt;% nest_rename_with(country_data, stringr::str_to_lower)
</code></pre>

<hr>
<h2 id='nest_replace_na'>Replace NAs with specified values in a column of nested data frames</h2><span id='topic+nest_replace_na'></span>

<h3>Description</h3>

<p><code>nest_replace_na()</code> is used to replace missing values in selected columns of
nested data frames using values specified by column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_replace_na(.data, .nest_data, replace, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_replace_na_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_replace_na_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_replace_na_+3A_replace">replace</code></td>
<td>
<p>A list of values, with one value for each column in that has <code>NA</code> values
to be replaced.</p>
</td></tr>
<tr><td><code id="nest_replace_na_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code><a href="tidyr.html#topic+replace_na">tidyr::replace_na()</a></code> methods. Currently unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_replace_na()</code> is a wrapper for <code><a href="tidyr.html#topic+replace_na">tidyr::replace_na()</a></code> and maintains the functionality
of <code>replace_na()</code> within each nested data frame. For more information on <code>replace_na()</code>
please refer to the documentation in <a href="https://tidyr.tidyverse.org/">'tidyr'</a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will have NAs replaced in the specified columns.
</p>


<h3>See Also</h3>

<p>Other tidyr verbs: 
<code><a href="#topic+nest_drop_na">nest_drop_na</a>()</code>,
<code><a href="#topic+nest_extract">nest_extract</a>()</code>,
<code><a href="#topic+nest_fill">nest_fill</a>()</code>,
<code><a href="#topic+nest_separate">nest_separate</a>()</code>,
<code><a href="#topic+nest_unite">nest_unite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
gm &lt;- gapminder::gapminder %&gt;% mutate(pop = if_else(runif(n()) &gt;= 0.9,NA_integer_,pop))
gm_nest &lt;- gm %&gt;% tidyr::nest(country_data = -continent)

gm_nest %&gt;% 
  nest_replace_na(.nest_data = country_data,
                  replace = list(pop = -500))
</code></pre>

<hr>
<h2 id='nest_select'>Subset columns in nested data frames using their names and types</h2><span id='topic+nest_select'></span>

<h3>Description</h3>

<p><code>nest_select()</code> selects (and optionally renames) variables in nested data
frames, using a concise mini-language that makes it easy to refer to
variables based on their name (e.g., <code>a:f</code> selects all columns from <code>a</code> on
the left to <code>f</code> on the right). You can also use predicate functions like
<a href="base.html#topic+is.numeric">is.numeric</a> to select variables based on their properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_select(.data, .nest_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_select_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_select_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_select_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions separated by commas. Variable
names can be used if they were positions in the data frame, so expressions
like <code>x:y</code> can be used to select a range of variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_select()</code> is largely a wrapper for <code><a href="dplyr.html#topic+select">dplyr::select()</a></code> and maintains the
functionality of <code>select()</code> within each nested data frame. For more
information on <code>select()</code>, please refer to the documentation in
<a href="https://dplyr.tidyverse.org/"><code>dplyr</code></a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will also be of the same type as the input. Each object in <code>.nest_data</code> has
the following properties:
</p>

<ul>
<li><p> Rows are not affect.
</p>
</li>
<li><p> Output columns are a subset of input columns, potentially with a different
order. Columns will be renamed if <code>new_name = old_name</code> form is used.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li>
<li><p> Groups are maintained; you can't select off grouping variables.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="#topic+nest_arrange">nest_arrange</a>()</code>,
<code><a href="#topic+nest_filter">nest_filter</a>()</code>,
<code><a href="#topic+nest_mutate">nest_mutate</a>()</code>,
<code><a href="#topic+nest_rename">nest_rename</a>()</code>,
<code><a href="#topic+nest_slice">nest_slice</a>()</code>,
<code><a href="#topic+nest_summarise">nest_summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm_nest &lt;- gapminder::gapminder %&gt;% tidyr::nest(country_data = -continent)

gm_nest %&gt;% nest_select(country_data, country, year, pop)
gm_nest %&gt;% nest_select(country_data, where(is.numeric))
</code></pre>

<hr>
<h2 id='nest_separate'>Separate a character column into multiple columns in a column of nested data frames</h2><span id='topic+nest_separate'></span>

<h3>Description</h3>

<p><code>nest_separate()</code> is used to separate a single character column into multiple
columns using a regular expression or a vector of character positions in a
list of nested data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_separate(
  .data,
  .nest_data,
  col,
  into,
  sep = "[^[:alnum:]]+",
  remove = TRUE,
  convert = FALSE,
  extra = "warn",
  fill = "warn",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_separate_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_separate_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_separate_+3A_col">col</code></td>
<td>
<p>Column name or position within. Must be present in all data frames
in <code>.nest_data</code>. This is passed to <code><a href="tidyselect.html#topic+vars_pull">tidyselect::vars_pull()</a></code>.
</p>
<p>This argument is passed by expression and supports quasiquotation (you can
unquote column names or column positions).</p>
</td></tr>
<tr><td><code id="nest_separate_+3A_into">into</code></td>
<td>
<p>Names of new variables to create as character vector.
Use <code>NA</code> to omit the variable in the output.</p>
</td></tr>
<tr><td><code id="nest_separate_+3A_sep">sep</code></td>
<td>
<p>Separator between columns.
</p>
<p>If character, <code>sep</code> is interpreted as a regular expression. The default
value is a regular expression that matches any sequence of
non-alphanumeric values.
</p>
<p>If numeric, <code>sep</code> is interpreted as character positions to split at. Positive
values start at 1 at the far-left of the string; negative value start at -1 at
the far-right of the string. The length of <code>sep</code> should be one less than
<code>into</code>.</p>
</td></tr>
<tr><td><code id="nest_separate_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input column from output data frame.</p>
</td></tr>
<tr><td><code id="nest_separate_+3A_convert">convert</code></td>
<td>
<p>If <code>TRUE</code>, will run <code><a href="utils.html#topic+type.convert">type.convert()</a></code> with
<code>as.is = TRUE</code> on new columns. This is useful if the component
columns are integer, numeric or logical.
</p>
<p>NB: this will cause string <code>"NA"</code>s to be converted to <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="nest_separate_+3A_extra">extra</code></td>
<td>
<p>If <code>sep</code> is a character vector, this controls what
happens when there are too many pieces. There are three valid options:
</p>

<ul>
<li> <p><code>"warn"</code> (the default): emit a warning and drop extra values.
</p>
</li>
<li> <p><code>"drop"</code>: drop any extra values without a warning.
</p>
</li>
<li> <p><code>"merge"</code>: only splits at most <code>length(into)</code> times
</p>
</li></ul>
</td></tr>
<tr><td><code id="nest_separate_+3A_fill">fill</code></td>
<td>
<p>If <code>sep</code> is a character vector, this controls what
happens when there are not enough pieces. There are three valid options:
</p>

<ul>
<li> <p><code>"warn"</code> (the default): emit a warning and fill from the right
</p>
</li>
<li> <p><code>"right"</code>: fill with missing values on the right
</p>
</li>
<li> <p><code>"left"</code>: fill with missing values on the left
</p>
</li></ul>
</td></tr>
<tr><td><code id="nest_separate_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code><a href="tidyr.html#topic+separate">tidyr::separate()</a></code> methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_separate()</code> is a wrapper for <code><a href="tidyr.html#topic+separate">tidyr::separate()</a></code> and maintains the functionality
of <code>separate()</code> within each nested data frame. For more information on <code>separate()</code>
please refer to the documentation in <a href="https://tidyr.tidyverse.org/">'tidyr'</a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will have the specified column split according to the regular expression or
the vector of character positions.
</p>


<h3>See Also</h3>

<p>Other tidyr verbs: 
<code><a href="#topic+nest_drop_na">nest_drop_na</a>()</code>,
<code><a href="#topic+nest_extract">nest_extract</a>()</code>,
<code><a href="#topic+nest_fill">nest_fill</a>()</code>,
<code><a href="#topic+nest_replace_na">nest_replace_na</a>()</code>,
<code><a href="#topic+nest_unite">nest_unite</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
gm &lt;- gapminder::gapminder %&gt;% mutate(comb = paste(continent,year,sep = "-"))
gm_nest &lt;- gm %&gt;% tidyr::nest(country_data = -continent)

gm_nest %&gt;% 
  nest_separate(.nest_data = country_data,
                col = comb,
                into = c("var1","var2"),
                sep = "-")
</code></pre>

<hr>
<h2 id='nest_slice'>Subset rows in nested data frames using their positions.</h2><span id='topic+nest_slice'></span><span id='topic+nest_slice_head'></span><span id='topic+nest_slice_tail'></span><span id='topic+nest_slice_min'></span><span id='topic+nest_slice_max'></span><span id='topic+nest_slice_sample'></span>

<h3>Description</h3>

<p><code>nest_slice()</code> lets you index rows in nested data frames by their (integer)
locations. It allows you to select, remove, and duplicate rows. It is
accompanied by a number of helpers for common use cases:
</p>

<ul>
<li> <p><code>nest_slice_head()</code> and <code>nest_slice_tail()</code> select the first or last rows
of each nested data frame in <code>.nest_data</code>.
</p>
</li>
<li> <p><code>nest_slice_sample()</code> randomly selects rows from each data frame in
<code>.nest_data</code>.
</p>
</li>
<li> <p><code>nest_slice_min()</code> and <code>nest_slice_max()</code> select the rows with the highest
or lowest values of a variable within each nested data frame in
<code>.nest_data</code>.
</p>
</li></ul>

<p>If <code>.nest_data</code> is a grouped data frame, the operation will be performed on
each group, so that (e.g.) <code>nest_slice_head(df, nested_dfs, n = 5)</code> will
return the first five rows in each group for each nested data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_slice(.data, .nest_data, ..., .preserve = FALSE)

nest_slice_head(.data, .nest_data, ...)

nest_slice_tail(.data, .nest_data, ...)

nest_slice_min(.data, .nest_data, order_by, ..., with_ties = TRUE)

nest_slice_max(.data, .nest_data, order_by, ..., with_ties = TRUE)

nest_slice_sample(.data, .nest_data, ..., weight_by = NULL, replace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_slice_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_slice_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_slice_+3A_...">...</code></td>
<td>
<p>For <code>nest_slice()</code>: Integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop. The
values provided must be either all positive or all negative. Indices beyond
the number of rows in the input are silently ignored.
</p>
<p>For <code>nest_slice_helpers()</code>, these arguments are passed on to methods.
</p>
<p>Additionally:
</p>

<ul>
<li> <p><code>n</code>,<code>prop</code> Provide either <code>n</code>, the number of rows, or <code>prop</code>, the
proportion of rows to select. If neither are supplied, <code>n = 1</code> will be
used.
</p>
<p>If a negative value of <code>n</code> or <code>prop</code> is provided, the specified number or
proportion of rows will be removed.
</p>
<p>If <code>n</code> is greater than the number of rows in the group (or <code>prop &gt; 1</code>), the
result will be silently truncated to the group size. If the proportion of a
group size does not yield an integer number of rows, the absolute value of
<code>prop*nrow(.nest_data)</code> is rounded down.
</p>
</li></ul>
</td></tr>
<tr><td><code id="nest_slice_+3A_.preserve">.preserve</code></td>
<td>
<p>Relevant when <code>.nest_data</code> is grouped.
If <code>.preserve = FALSE</code> (the default), the grouping structure is
recalculated based on the resulting data, otherwise the grouping data is
kept as is.</p>
</td></tr>
<tr><td><code id="nest_slice_+3A_order_by">order_by</code></td>
<td>
<p>Variable or function of variables to order by.</p>
</td></tr>
<tr><td><code id="nest_slice_+3A_with_ties">with_ties</code></td>
<td>
<p>Should ties be kept together? The default, <code>TRUE</code>, may
return more rows than you request. Use <code>FALSE</code> to ignore ties and return
the first <code>n</code> rows.</p>
</td></tr>
<tr><td><code id="nest_slice_+3A_weight_by">weight_by</code></td>
<td>
<p>Sampling weights. This must evaluate to a vector of
non-negative numbers the same length as the input. Weights are automatically
standardised to sum to 1.</p>
</td></tr>
<tr><td><code id="nest_slice_+3A_replace">replace</code></td>
<td>
<p>Should sampling be performed with (<code>TRUE</code>) or without (<code>FALSE</code>,
the default) replacement?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_slice()</code> and its helpers are largely wrappers for <code><a href="dplyr.html#topic+slice">dplyr::slice()</a></code> and
its helpers and maintains the functionality of <code>slice()</code> and its helpers
within each nested data frame. For more information on <code>slice()</code> or its
helpers, please refer to the documentation in
<a href="https://dplyr.tidyverse.org/"><code>dplyr</code></a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will also be of the same type as the input. Each object in <code>.nest_data</code> has
the following properties:
</p>

<ul>
<li><p> Each row may appear 0, 1, or many times in the output.
</p>
</li>
<li><p> Columns are not modified.
</p>
</li>
<li><p> Groups are not modified.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="#topic+nest_arrange">nest_arrange</a>()</code>,
<code><a href="#topic+nest_filter">nest_filter</a>()</code>,
<code><a href="#topic+nest_mutate">nest_mutate</a>()</code>,
<code><a href="#topic+nest_rename">nest_rename</a>()</code>,
<code><a href="#topic+nest_select">nest_select</a>()</code>,
<code><a href="#topic+nest_summarise">nest_summarise</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm_nest &lt;- gapminder::gapminder %&gt;% tidyr::nest(country_data = -continent)

# select the 1st, 3rd, and 5th rows in each data frame in country_data
gm_nest %&gt;% nest_slice(country_data, 1, 3, 5)

# or select all but the 1st, 3rd, and 5th rows:
gm_nest %&gt;% nest_slice(country_data, -1, -3, -5)

# first and last rows based on existing order:
gm_nest %&gt;% nest_slice_head(country_data, n = 5)
gm_nest %&gt;% nest_slice_tail(country_data, n = 5)

# rows with minimum and maximum values of a variable:
gm_nest %&gt;% nest_slice_min(country_data, lifeExp, n = 5)
gm_nest %&gt;% nest_slice_max(country_data, lifeExp, n = 5)

# randomly select rows with or without replacement:
gm_nest %&gt;% nest_slice_sample(country_data, n = 5)
gm_nest %&gt;% nest_slice_sample(country_data, n = 5, replace = TRUE)
</code></pre>

<hr>
<h2 id='nest_summarise'>Summarise each group in nested data frames to fewer rows</h2><span id='topic+nest_summarise'></span><span id='topic+nest_summarize'></span>

<h3>Description</h3>

<p><code>nest_summarise()</code> creates a new set of nested data frames. Each will have
one (or more) rows for each combination of grouping variables; if there are
no grouping variables, the output will have a single row summarising all
observations in <code>.nest_data</code>. Each nested data frame will contain one column
for each grouping variable and one column for each of the summary statistics
that you have specified.
</p>
<p><code>nest_summarise()</code> and <code>nest_summarize()</code> are synonyms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_summarise(.data, .nest_data, ..., .groups = NULL)

nest_summarize(.data, .nest_data, ..., .groups = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_summarise_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_summarise_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_summarise_+3A_...">...</code></td>
<td>
<p>Name-value pairs of functions. The name will be the name of the
variable in the result.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, e.g. <code>min(x)</code>, <code>n()</code>, or <code>sum(is.na(y))</code>.
</p>
</li>
<li><p> A vector of length <code>n</code>, e.g., <code>quantile()</code>.
</p>
</li>
<li><p> A data frame, to add multiple columns from a single expression.
</p>
</li></ul>
</td></tr>
<tr><td><code id="nest_summarise_+3A_.groups">.groups</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#experimental"><img src="../help/figures/lifecycle-experimental.svg" alt='[Experimental]' /></a> Grouping structure of the
result. Refer to <code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code> for more up-to-date information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_summarise()</code> is largely a wrapper for <code><a href="dplyr.html#topic+summarise">dplyr::summarise()</a></code> and
maintains the functionality of <code>summarise()</code> within each nested data frame.
For more information on <code>summarise()</code>, please refer to the documentation in
<a href="https://dplyr.tidyverse.org/"><code>dplyr</code></a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will <em>usually</em> be of the same type as the input. Each object in <code>.nest_data</code> has
the following properties:
</p>

<ul>
<li><p> The rows come from the underlying <a href="https://dplyr.tidyverse.org/reference/group_data.html"><code>group_keys()</code></a>
</p>
</li>
<li><p> The columns are a combination of the grouping keys and the summary
expressions that you provide.
</p>
</li>
<li><p> The grouping structure is controlled by the <code>.groups</code> argument, the output
may be another grouped_df, a tibble, or a rowwise data frame.
</p>
</li>
<li><p> Data frame attributes are <strong>not</strong> preserved, because <code>nest_summarise()</code>
fundamentally creates a new data frame for each object in <code>.nest_data</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other single table verbs: 
<code><a href="#topic+nest_arrange">nest_arrange</a>()</code>,
<code><a href="#topic+nest_filter">nest_filter</a>()</code>,
<code><a href="#topic+nest_mutate">nest_mutate</a>()</code>,
<code><a href="#topic+nest_rename">nest_rename</a>()</code>,
<code><a href="#topic+nest_select">nest_select</a>()</code>,
<code><a href="#topic+nest_slice">nest_slice</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm_nest &lt;- gapminder::gapminder %&gt;% tidyr::nest(country_data = -continent)

# a summary applied to an ungrouped tbl returns a single row
gm_nest %&gt;%
  nest_summarise(
    country_data,
    n = n(),
    median_pop = median(pop)
  )

# usually, you'll want to group first
gm_nest %&gt;%
  nest_group_by(country_data, country) %&gt;%
  nest_summarise(
    country_data,
    n = n(),
    median_pop = median(pop)
  )
</code></pre>

<hr>
<h2 id='nest_unite'>Unite multiple columns into one in a column of nested data frames</h2><span id='topic+nest_unite'></span>

<h3>Description</h3>

<p><code>nest_unite()</code> is used to combine multiple columns into one in a column of
nested data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nest_unite(
  .data,
  .nest_data,
  col,
  ...,
  sep = "_",
  remove = TRUE,
  na.rm = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest_unite_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest_unite_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest_unite_+3A_col">col</code></td>
<td>
<p>The name of the new column, as a string or symbol.
</p>
<p>This argument is passed by expression and supports
<a href="rlang.html#topic+topic-inject">quasiquotation</a> (you can unquote strings
and symbols). The name is captured from the expression with
<code><a href="rlang.html#topic+defusing-advanced">rlang::ensym()</a></code> (note that this kind of interface where
symbols do not represent actual objects is now discouraged in the
tidyverse; we support it here for backward compatibility).</p>
</td></tr>
<tr><td><code id="nest_unite_+3A_...">...</code></td>
<td>
<p>Columns to unite.</p>
</td></tr>
<tr><td><code id="nest_unite_+3A_sep">sep</code></td>
<td>
<p>Separator to use between values.</p>
</td></tr>
<tr><td><code id="nest_unite_+3A_remove">remove</code></td>
<td>
<p>If <code>TRUE</code>, remove input columns from output data frame.</p>
</td></tr>
<tr><td><code id="nest_unite_+3A_na.rm">na.rm</code></td>
<td>
<p>If <code>TRUE</code>, missing values will be removed prior to uniting
each value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_unite()</code> is a wrapper for <code><a href="tidyr.html#topic+unite">tidyr::unite()</a></code> and maintains the functionality
of <code>unite()</code> within each nested data frame. For more information on <code>unite()</code>
please refer to the documentation in <a href="https://tidyr.tidyverse.org/">'tidyr'</a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will have a new column created as a combination of existing columns.
</p>


<h3>See Also</h3>

<p>Other tidyr verbs: 
<code><a href="#topic+nest_drop_na">nest_drop_na</a>()</code>,
<code><a href="#topic+nest_extract">nest_extract</a>()</code>,
<code><a href="#topic+nest_fill">nest_fill</a>()</code>,
<code><a href="#topic+nest_replace_na">nest_replace_na</a>()</code>,
<code><a href="#topic+nest_separate">nest_separate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
gm &lt;- gapminder::gapminder 
gm_nest &lt;- gm %&gt;% tidyr::nest(country_data = -continent)

gm_nest %&gt;% 
  nest_unite(.nest_data = country_data, 
             col = comb, 
             year, 
             pop)
</code></pre>

<hr>
<h2 id='nest-filter-joins'>Nested filtering joins</h2><span id='topic+nest-filter-joins'></span><span id='topic+nest_semi_join'></span><span id='topic+nest_anti_join'></span>

<h3>Description</h3>

<p>Nested filtering joins filter rows from <code>.nest_data</code> based on the presence or
absence of matches in <code>y</code>:
</p>

<ul>
<li> <p><code>nest_semi_join()</code> returns all rows from <code>.nest_data</code> with a match in <code>y</code>.
</p>
</li>
<li> <p><code>nest_anti_join()</code> returns all rows from <code>.nest_data</code> with<em>out</em> a match in <code>y</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>nest_semi_join(.data, .nest_data, y, by = NULL, copy = FALSE, ...)

nest_anti_join(.data, .nest_data, y, by = NULL, copy = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest-filter-joins_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest-filter-joins_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest-filter-joins_+3A_y">y</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy data
frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest-filter-joins_+3A_by">by</code></td>
<td>
<p>A character vector of variables to join by or a join specification
created with <code>join_by()</code>.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;nest_*_join()&#8288;</code> will perform a natural join, using
all variables in common across each object in <code>.nest_data</code> and <code>y</code>. A
message lists the variables so you can check they're correct; suppress the
message by supplying <code>by</code> explicitly.
</p>
<p>To join on different variables between the objects in <code>.nest_data</code> and <code>y</code>,
use a named vector. For example, <code>by = c("a" = "b")</code> will match
<code>.nest_data$a</code> to <code>y$b</code> for each object in <code>.nest_data</code>.
</p>
<p>To join by multiple variables, use a vector with length &gt;1. For example,
<code>by = c("a", "b")</code> will match <code>.nest_data$a</code> to <code>y$a</code> and <code>.nest_data$b</code> to
<code>y$b</code> for each object in <code>.nest_data</code>. Use a named vector to match
different variables in <code>.nest_data</code> and <code>y</code>. For example,
<code>by = c("a" = "b", "c" = "d")</code> will match <code>.nest_data$a</code> to <code>y$b</code> and
<code>.nest_data$c</code> to <code>y$d</code> for each object in <code>.nest_data</code>.
</p>
<p>To perform a cross-join, generating all combinations of each object in
<code>.nest_data</code> and <code>y</code>, use <code>by = character()</code>.</p>
</td></tr>
<tr><td><code id="nest-filter-joins_+3A_copy">copy</code></td>
<td>
<p>If <code>.nest_data</code> and <code>y</code> are not from the same data source and
<code>copy = TRUE</code> then <code>y</code> will be copied into the same src as <code>.nest_data</code>.
<em>(Need to review this parameter in more detail for applicability with nplyr)</em></p>
</td></tr>
<tr><td><code id="nest-filter-joins_+3A_...">...</code></td>
<td>
<p>One or more unquoted expressions separated by commas. Variable
names can be used if they were positions in the data frame, so expressions
like <code>x:y</code> can be used to select a range of variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_semi_join()</code> and <code>nest_anti_join()</code> are largely wrappers for
<code><a href="dplyr.html#topic+filter-joins">dplyr::semi_join()</a></code> and <code><a href="dplyr.html#topic+filter-joins">dplyr::anti_join()</a></code> and maintain the functionality
of <code>semi_join()</code> and <code>anti_join()</code> within each nested data frame. For more
information on <code>semi_join()</code> or <code>anti_join()</code>, please refer to the
documentation in <a href="https://dplyr.tidyverse.org/"><code>dplyr</code></a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will also be of the same type as the input. Each object in <code>.nest_data</code> has
the following properties:
</p>

<ul>
<li><p> Rows are a subset of the input, but appear in the same order.
</p>
</li>
<li><p> Columns are not modified.
</p>
</li>
<li><p> Data frame attributes are preserved.
</p>
</li>
<li><p> Groups are taken from <code>.nest_data</code>. The number of groups may be reduced.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other joins: 
<code><a href="#topic+nest-mutate-joins">nest-mutate-joins</a></code>,
<code><a href="#topic+nest_nest_join">nest_nest_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm_nest &lt;- gapminder::gapminder %&gt;% tidyr::nest(country_data = -continent)
gm_codes &lt;- gapminder::country_codes %&gt;% dplyr::slice_sample(n = 10)

gm_nest %&gt;% nest_semi_join(country_data, gm_codes, by = "country")
gm_nest %&gt;% nest_anti_join(country_data, gm_codes, by = "country")

</code></pre>

<hr>
<h2 id='nest-mutate-joins'>Nested Mutating joins</h2><span id='topic+nest-mutate-joins'></span><span id='topic+nest_inner_join'></span><span id='topic+nest_left_join'></span><span id='topic+nest_right_join'></span><span id='topic+nest_full_join'></span>

<h3>Description</h3>

<p>Nested mutating joins add columns from <code>y</code> to each of the nested data frames
in <code>.nest_data</code>, matching observations based on the keys. There are four
nested mutating joins:
</p>


<h4>Inner join</h4>

<p><code>nest_inner_join()</code> only keeps observations from <code>.nest_data</code> that have a
matching key in <code>y</code>.
</p>
<p>The most important property of an inner join is that unmatched rows in either
input are not included in the result.
</p>



<h4>Outer joins</h4>

<p>There are three outer joins that keep observations that appear in at least
one of the data frames:
</p>

<ul>
<li> <p><code>nest_left_join()</code> keeps all observations in <code>.nest_data</code>.
</p>
</li>
<li> <p><code>nest_right_join()</code> keeps all observations in <code>y</code>.
</p>
</li>
<li> <p><code>nest_full_join()</code> keeps all observations in <code>.nest_data</code> and <code>y</code>.
</p>
</li></ul>




<h3>Usage</h3>

<pre><code class='language-R'>nest_inner_join(
  .data,
  .nest_data,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE
)

nest_left_join(
  .data,
  .nest_data,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE
)

nest_right_join(
  .data,
  .nest_data,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE
)

nest_full_join(
  .data,
  .nest_data,
  y,
  by = NULL,
  copy = FALSE,
  suffix = c(".x", ".y"),
  ...,
  keep = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nest-mutate-joins_+3A_.data">.data</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy
data frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest-mutate-joins_+3A_.nest_data">.nest_data</code></td>
<td>
<p>A list-column containing data frames</p>
</td></tr>
<tr><td><code id="nest-mutate-joins_+3A_y">y</code></td>
<td>
<p>A data frame, data frame extension (e.g., a tibble), or a lazy data
frame (e.g., from dbplyr or dtplyr).</p>
</td></tr>
<tr><td><code id="nest-mutate-joins_+3A_by">by</code></td>
<td>
<p>A character vector of variables to join by or a join specification
created with <code>join_by()</code>.
</p>
<p>If <code>NULL</code>, the default, <code style="white-space: pre;">&#8288;nest_*_join()&#8288;</code> will perform a natural join, using
all variables in common across each object in <code>.nest_data</code> and <code>y</code>. A
message lists the variables so you can check they're correct; suppress the
message by supplying <code>by</code> explicitly.
</p>
<p>To join on different variables between the objects in <code>.nest_data</code> and <code>y</code>,
use a named vector. For example, <code>by = c("a" = "b")</code> will match
<code>.nest_data$a</code> to <code>y$b</code> for each object in <code>.nest_data</code>.
</p>
<p>To join by multiple variables, use a vector with length &gt;1. For example,
<code>by = c("a", "b")</code> will match <code>.nest_data$a</code> to <code>y$a</code> and <code>.nest_data$b</code> to
<code>y$b</code> for each object in <code>.nest_data</code>. Use a named vector to match
different variables in <code>.nest_data</code> and <code>y</code>. For example,
<code>by = c("a" = "b", "c" = "d")</code> will match <code>.nest_data$a</code> to <code>y$b</code> and
<code>.nest_data$c</code> to <code>y$d</code> for each object in <code>.nest_data</code>.
</p>
<p>To perform a cross-join, generating all combinations of each object in
<code>.nest_data</code> and <code>y</code>, use <code>by = character()</code>.</p>
</td></tr>
<tr><td><code id="nest-mutate-joins_+3A_copy">copy</code></td>
<td>
<p>If <code>.nest_data</code> and <code>y</code> are not from the same data source and
<code>copy = TRUE</code> then <code>y</code> will be copied into the same src as <code>.nest_data</code>.
<em>(Need to review this parameter in more detail for applicability with nplyr)</em></p>
</td></tr>
<tr><td><code id="nest-mutate-joins_+3A_suffix">suffix</code></td>
<td>
<p>If there are non-joined duplicate variables in <code>.nest_data</code> and
<code>y</code>, these suffixes will be added to the output to disambiguate them.
Should be a character vector of length 2.</p>
</td></tr>
<tr><td><code id="nest-mutate-joins_+3A_...">...</code></td>
<td>
<p>Other parameters passed onto methods. Includes:
</p>

<ul>
<li> <p><code>na_matches</code> : Should two <code>NA</code> or two <code>NaN</code> values match?
</p>

<ul>
<li> <p><code>"na"</code>, the default, treats two <code>NA</code> or two <code>NaN</code> values as equal.
</p>
</li>
<li> <p><code>"never"</code> treats two <code>NA</code> or two <code>NaN</code> values as different, and will
never match them together or to any other values.
</p>
</li></ul>

</li>
<li> <p><code>multiple</code> : Handling of rows in <code>.nest_data</code> with multiple matches in <code>y</code>.
</p>

<ul>
<li> <p><code>"all"</code> returns every match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"any"</code> returns one match detected in <code>y</code>, with no guarantees on which
match will be returned. It is often faster than <code>"first"</code> and <code>"last"</code> if
you just need to detect if there is at least one match.
</p>
</li>
<li> <p><code>"first"</code> returns the first match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"last"</code> returns the last match detected in <code>y</code>.
</p>
</li>
<li> <p><code>"warning"</code> throws a warning if multiple matches are detected, and then
falls back to <code>"all"</code>.
</p>
</li>
<li> <p><code>"error"</code> throws an error if multiple matches are detected.
</p>
</li></ul>

</li>
<li> <p><code>unmatched</code> : How should unmatched keys that would result in dropped rows
be handled?
</p>

<ul>
<li> <p><code>"drop"</code> drops unmatched keys from the result.
</p>
</li>
<li> <p><code>"error"</code> throws an error if unmatched keys are detected.
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="nest-mutate-joins_+3A_keep">keep</code></td>
<td>
<p>Should the join keys from both <code>.nest_data</code> and <code>y</code> be preserved
in the output?</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>nest_inner_join()</code>, <code>nest_left_join()</code>, <code>nest_right_join()</code>, and
<code>nest_full_join()</code> are largely wrappers for <code><a href="dplyr.html#topic+mutate-joins">dplyr::inner_join()</a></code>,
<code><a href="dplyr.html#topic+mutate-joins">dplyr::left_join()</a></code>, <code><a href="dplyr.html#topic+mutate-joins">dplyr::right_join()</a></code>, and <code><a href="dplyr.html#topic+mutate-joins">dplyr::full_join()</a></code> and
maintain the functionality of these verbs within each nested data frame. For
more information on <code>inner_join()</code>, <code>left_join()</code>, <code>right_join()</code>, or
<code>full_join()</code>, please refer to the documentation in
<a href="https://dplyr.tidyverse.org/"><code>dplyr</code></a>.
</p>


<h3>Value</h3>

<p>An object of the same type as <code>.data</code>. Each object in the column <code>.nest_data</code>
will also be of the same type as the input. The order of the rows and columns
of each object in <code>.nest_data</code> is preserved as much as possible. Each object
in <code>.nest_data</code> has the following properties:
</p>

<ul>
<li><p> For <code>nest_inner_join()</code>, a subset of rows in each object in <code>.nest_data</code>.
For <code>nest_left_join()</code>, all rows in each object in <code>.nest_data</code>.
For <code>nest_right_join()</code>, a subset of rows in each object in <code>.nest_data</code>,
followed by unmatched <code>y</code> rows.
For <code>nest_full_join()</code>, all rows in each object in <code>.nest_data</code>, followed
by unmatched <code>y</code> rows.
</p>
</li>
<li><p> Output columns include all columns from each <code>.nest_data</code> and all non-key
columns from <code>y</code>. If <code>keep = TRUE</code>, the key columns from <code>y</code> are included
as well.
</p>
</li>
<li><p> If non-key columns in any object in <code>.nest_data</code> and <code>y</code> have the same name,
<code>suffix</code>es are added to disambiguate. If <code>keep = TRUE</code> and key columns in
<code>.nest_data</code> and <code>y</code> have the same name, <code>suffix</code>es are added to
disambiguate these as well.
</p>
</li>
<li><p> If <code>keep = FALSE</code>, output columns included in <code>by</code> are coerced to their
common type between the objects in <code>.nest_data</code> and <code>y</code>.
</p>
</li>
<li><p> Groups are taken from <code>.nest_data</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other joins: 
<code><a href="#topic+nest-filter-joins">nest-filter-joins</a></code>,
<code><a href="#topic+nest_nest_join">nest_nest_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gm_nest &lt;- gapminder::gapminder %&gt;% tidyr::nest(country_data = -continent)
gm_codes &lt;- gapminder::country_codes

gm_nest %&gt;% nest_inner_join(country_data, gm_codes, by = "country")
gm_nest %&gt;% nest_left_join(country_data, gm_codes, by = "country")
gm_nest %&gt;% nest_right_join(country_data, gm_codes, by = "country")
gm_nest %&gt;% nest_full_join(country_data, gm_codes, by = "country")

</code></pre>

<hr>
<h2 id='personal_survey'>Example survey data regarding personal life satisfaction</h2><span id='topic+personal_survey'></span>

<h3>Description</h3>

<p>A toy dataset containing 750 responses to a personal satisfaction survey. The
responses were randomly generated using the Qualtrics survey platform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>personal_survey
</code></pre>


<h3>Format</h3>

<p>A data frame with 750 rows and 6 variables
</p>

<dl>
<dt>survey_name</dt><dd><p>name of survey</p>
</dd>
<dt>Q1</dt><dd><p>respondent age</p>
</dd>
<dt>Q2</dt><dd><p>city the respondent resides in</p>
</dd>
<dt>Q3</dt><dd><p>field that the respondent that works in</p>
</dd>
<dt>Q4</dt><dd><p>respondent's personal life satisfaction (on a scale from extremely satisfied to extremely dissatisfied)</p>
</dd>
<dt>Q5</dt><dd><p>open text response elaborating on personal life satisfaction</p>
</dd>
</dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
