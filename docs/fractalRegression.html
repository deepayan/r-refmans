<!DOCTYPE html><html><head><title>Help for package fractalRegression</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fractalRegression}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#dcca'><p>Detrended Cross-Correlation Analysis</p></a></li>
<li><a href='#dcca.plot'><p>Detrended Cross Correlation Plot</p></a></li>
<li><a href='#detrend_cov'><p>Detrended Covariance</p>
Functional that returns the detrended covariance between two vectors</a></li>
<li><a href='#dfa'><p>Detrended Fluctuation Analysis</p></a></li>
<li><a href='#dfa.plot'><p>Detrended Fluctuation Plot</p></a></li>
<li><a href='#dlcca'><p>Multiscale Lagged Regression Anlaysis</p>
Fast function for computing MLRA on long time series</a></li>
<li><a href='#fgn_sim'><p>Simulate fractional Gaussian Noise.</p></a></li>
<li><a href='#fractaldata'><p>A whitenoise, monofractal, and multifractal timeseries</p></a></li>
<li><a href='#iaafft'><p>Iterated Amplitude Adjusted Fourier Transform</p></a></li>
<li><a href='#lm_c'><p>Simplef bivariate regression written in c++</p></a></li>
<li><a href='#logscale'><p>logscale</p></a></li>
<li><a href='#mBm_mGn'><p>Multifractional Brownian motion and multifractional Gaussian noise</p></a></li>
<li><a href='#mc_ARFIMA'><p>Mixed-correlated ARFIMA processes</p></a></li>
<li><a href='#mfdfa'><p>Multifractal Detrended Fluctuation Analysis</p></a></li>
<li><a href='#mfdfa_cj'><p>Multifractal Analysis Chhabra-Jensen Method</p></a></li>
<li><a href='#mfdfa.plot'><p>Multifractal Spectrum Plot</p></a></li>
<li><a href='#mlra'><p>Multiscale Lagged Regression Analysis</p></a></li>
<li><a href='#mra'><p>Multiscale Regression Analysis (MRA)</p></a></li>
<li><a href='#mra.plot'><p>Multiscale Regression Plot</p></a></li>
<li><a href='#poly_residuals'><p>Polynomial Residuals</p>
Function that fits a polynomial and returns the residuals</a></li>
<li><a href='#seq_int'><p>Integer Sequence</p>
Function that produces a sequence of integers from 1 to N</a></li>
<li><a href='#seq_int_range'><p>Sequence of Integer ranges</p>
Function that produces a sequece of integers that span a specific range</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Performs Fractal Analysis and Fractal Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-19</td>
</tr>
<tr>
<td>Description:</td>
<td>Various functions for performing fractal and multifractal analysis including performing fractal regression. Please refer to Peng and colleagues (1994) &lt;<a href="https://doi.org/10.1103%2Fphysreve.49.1685">doi:10.1103/physreve.49.1685</a>&gt;, Kantelhardt and colleagues (2002)&lt;<a href="https://doi.org/10.1016%2FS0378-4371%2802%2901383-3">doi:10.1016/S0378-4371(02)01383-3</a>&gt;, and Likens and colleagues (2019) &lt;<a href="https://doi.org/10.1016%2Fj.physa.2019.121580">doi:10.1016/j.physa.2019.121580</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, markdown, rmarkdown, ggplot2, crqa, MFDFA, fracdiff,
tseries, fields, gridExtra, qpdf</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.0), colorRamps</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 19:47:54 UTC; alikens</td>
</tr>
<tr>
<td>Author:</td>
<td>Aaron Likens <a href="https://orcid.org/0000-0002-6535-5772"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Travis Wiltshire <a href="https://orcid.org/0000-0001-7630-2695"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aaron Likens &lt;alikens@unomaha.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-19 20:52:33 UTC</td>
</tr>
</table>
<hr>
<h2 id='dcca'>Detrended Cross-Correlation Analysis</h2><span id='topic+dcca'></span>

<h3>Description</h3>

<p>Fast function for computing detrended cross-correlation analysis (DCCA) on long time series, which is a 
bivariate extension of detrended fluctuation analysis (DFA).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcca(x, y, order, scales)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcca_+3A_x">x</code></td>
<td>
<p>A real valued vector (i.e., time series data) to be analyzed.</p>
</td></tr>
<tr><td><code id="dcca_+3A_y">y</code></td>
<td>
<p>A real valued vector (i.e., time series data) to be analyzed.</p>
</td></tr>
<tr><td><code id="dcca_+3A_order">order</code></td>
<td>
<p>is an integer indicating the polynomial order used for 
detrending the local windows (e.g, 1 = linear, 2 = quadratic, etc.). There 
is not a pre-determined limit on the order of the polynomial order but the 
user should avoid using a large polynomial on small windows. This can result
in overfitting and non-meaningful estimates.</p>
</td></tr>
<tr><td><code id="dcca_+3A_scales">scales</code></td>
<td>
<p>An integer vector of scales over which to compute correlation. 
Unlike univariate DFA, MRA does not require that scales be in log units.
Scale intervals can be sequential, for example, when the analysis is 
exploratory and no a priori hypotheses have been made about the scale of 
correlation. A small subset of targeted scales may also be investigated 
where scale-specific research questions exist. We have found that windows
smaller than say 8 observations create stability problems due to 
overfitting. This is espcially when the order of the fitting polynomial is 
large.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details of the algorithm are specified in Podobnik and Stanley (2008) and in Zebende (2011).
In general, the output of the algorithm are estimates of <code class="reqn">\rho</code>DCCA, which range from -1 to 1 and can generally be interpreted as follows: 
</p>

<ul>
<li> <p><code class="reqn">\rho DCCA = -1.0 -&gt;</code> perfect anti-cross-correlation
</p>
</li>
<li> <p><code class="reqn">\rho DCCA =  0.0 -&gt;</code> no cross-correlation
</p>
</li>
<li> <p><code class="reqn">\rho DCCA =  1.0 -&gt;</code> perfect cross-correlation
</p>
</li></ul>



<h3>Value</h3>

<p>The object returned from the function is a list including the following:
</p>
 
<ul>
<li> <p><code>scales</code> indicates the values of the scales used for estimates <code class="reqn">\rho</code>DCCA
</p>
</li>
<li> <p><code>rho</code> includes the scale-wise estimates of <code class="reqn">\rho</code>DCCA
</p>
</li></ul>



<h3>References</h3>

<p>Podobnik, B., &amp; Stanley, H. E. (2008). Detrended cross-correlation analysis: a new method for analyzing two nonstationary time series. Physical review letters, 100(8), 084102.
</p>
<p>Zebende, G. F. (2011). DCCA cross-correlation coefficient: Quantifying level of cross-correlation. Physica A: Statistical Mechanics and its Applications, 390(4), 614-618.
</p>
<p>//'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# Here is a simple example for running DCCA using a white noise and pink noise time series.
# For more detailed examples, see the vignette. 

noise &lt;- rnorm(5000)

pink.noise &lt;- fgn_sim(n = 5000, H = 0.9)

scales &lt;- logscale(scale_min = 10, scale_max = 1250, scale_ratio = 1.1)

dcca.out &lt;- dcca(noise, pink.noise, order = 1, scales = scales)



</code></pre>

<hr>
<h2 id='dcca.plot'>Detrended Cross Correlation Plot</h2><span id='topic+dcca.plot'></span>

<h3>Description</h3>

<p>A plotting method for constructing scalewise correlation plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dcca.plot(
  rhos,
  order = 1,
  ci = FALSE,
  iterations = NULL,
  return.ci = FALSE,
  loess.rho = FALSE,
  loess.ci = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dcca.plot_+3A_rhos">rhos</code></td>
<td>
<p>an object containing  results from detrended cross correlation
analysis. The object should be returned from the <code>dcca</code> function of this
package.</p>
</td></tr>
<tr><td><code id="dcca.plot_+3A_order">order</code></td>
<td>
<p>integer representing the detrending order used in the dcca 
calculation. Default is 1.</p>
</td></tr>
<tr><td><code id="dcca.plot_+3A_ci">ci</code></td>
<td>
<p>a logical indicating whether confidence intervals should be 
computed using the <code>iaafft</code> function from this package. NOTE: with long 
time series (&gt;&gt; than N = 1,000), this can greatly reduce processing speed. 
Confidence intervals can be used for conventional significance testing of 
scale-wise correlation coefficients.</p>
</td></tr>
<tr><td><code id="dcca.plot_+3A_iterations">iterations</code></td>
<td>
<p>integer that specifies the the number of surrogate time 
series to be generated for the purpose of confidence intervals. 
Default = 19. Larger number of surrogates will slow computational speed but
produce better confidence interval estimates.</p>
</td></tr>
<tr><td><code id="dcca.plot_+3A_return.ci">return.ci</code></td>
<td>
<p>logical indicating whether the confidence intervals 
should be returned</p>
</td></tr>
<tr><td><code id="dcca.plot_+3A_loess.rho">loess.rho</code></td>
<td>
<p>logical indicating whether a loess fit should be used for 
displaying multiscale regression coefficient trajectories</p>
</td></tr>
<tr><td><code id="dcca.plot_+3A_loess.ci">loess.ci</code></td>
<td>
<p>logical indicating whether a loess fit should be used to smooth 
confidence intervals</p>
</td></tr>
</table>

<hr>
<h2 id='detrend_cov'>Detrended Covariance
Functional that returns the detrended covariance between two vectors</h2><span id='topic+detrend_cov'></span>

<h3>Description</h3>

<p>Detrended Covariance
Functional that returns the detrended covariance between two vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detrend_cov(x, y, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detrend_cov_+3A_x">x</code></td>
<td>
<p>a real valued column vector</p>
</td></tr>
<tr><td><code id="detrend_cov_+3A_y">y</code></td>
<td>
<p>is a real valued column vector</p>
</td></tr>
<tr><td><code id="detrend_cov_+3A_m">m</code></td>
<td>
<p>is the detrending order</p>
</td></tr>
</table>

<hr>
<h2 id='dfa'>Detrended Fluctuation Analysis</h2><span id='topic+dfa'></span>

<h3>Description</h3>

<p>Fast function for computing detrended fluctuation analysis (DFA), a widely used method for estimating long-range temporal correlations in time series data. 
DFA is also a form of mono-fractal analysis that indicates the degree of self-similarity across temporal scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfa(x, order, verbose, scales, scale_ratio = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfa_+3A_x">x</code></td>
<td>
<p>A real valued vector (i.e., time series data) to be analyzed.</p>
</td></tr>
<tr><td><code id="dfa_+3A_order">order</code></td>
<td>
<p>An integer indicating the polynomial order used for 
detrending the local windows (e.g, 1 = linear, 2 = quadratic, etc.). There 
is not a pre-determined limit on the order of the polynomial order but the 
user should avoid using a large polynomial on small windows. This can result
in overfitting and non-meaningful estimates.</p>
</td></tr>
<tr><td><code id="dfa_+3A_verbose">verbose</code></td>
<td>
<p>If the value of verbose = 1, then a list object is returned 
that includes: <code>log_scales</code> the log of all included scales, 
<code>log_rms</code> the log root mean square error (RMS) per scale, 
and <code>alpha</code> the overall <code class="reqn">\alpha</code> estimate. If the value of 
verbose = 0, then a list containing only 'alpha' will be returned.</p>
</td></tr>
<tr><td><code id="dfa_+3A_scales">scales</code></td>
<td>
<p>An integer valued vector indicating the scales one wishes to resolve
in the analysis. Best practice is to use scales which are evenly spaced in 
the logarithmic domain e.g., <code>scales = 2^(4:(N/4))</code>, where N is the length of the
time series. Other, logarithmic bases may also be used to give finer 
resolution of scales while maintaining ~= spacing in the log domain e.g, 
<code>scales = unique(floor(1.1^(30:(N/4))))</code>. Note that fractional bases may 
produce duplicate values after the necessary floor function.</p>
</td></tr>
<tr><td><code id="dfa_+3A_scale_ratio">scale_ratio</code></td>
<td>
<p>A scaling factor by which successive window sizes
were created. The default is 2 but should be addressed according to how 
scales were generated for example using <code>logscale(16, 100, 1.1)</code>, 
where 1.1 is the scale ratio.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details of the algorithm are specified in detail in Peng et al. 
(1994) and visualized nicely in Kelty-Stephen et al. (2016). The output of 
the algorithm is an <code class="reqn">\alpha</code> (alpha) estimate which is a generalization
of the Hurst Exponent. Conventional interpretation of <code class="reqn">\alpha</code> is:
</p>

<ul>
<li> <p><code class="reqn">\alpha &lt; 0.5 =</code> anti-correlated
</p>
</li>
<li> <p><code class="reqn">\alpha ~= 0.5 =</code> uncorrelated, white noise
</p>
</li>
<li> <p><code class="reqn">\alpha &gt; 0.5 =</code> temporally correlated
</p>
</li>
<li> <p><code class="reqn">\alpha ~= 1 =</code> 1/f-noise, pink noise
</p>
</li>
<li> <p><code class="reqn">\alpha &gt; 1 =</code> non-stationary and unbounded
</p>
</li>
<li> <p><code class="reqn">\alpha ~= 1.5 =</code> fractional brownian motion
</p>
</li></ul>
 
<p>We recommend a few points of consideration here in using this function. 
One is to be sure to verify there are not cross-over points in the logScale-
logFluctuation plots (Peng et al., 1995; Perakakis et al ., 2009). Cross-
over points (or a visible change in the slope as a function of of scale)
indicate that a mono-fractal characterization does not sufficiently 
characterize the data. If cross-over points are evident, we recommend 
proceeding to using the mfdfa() to estimate the multi-fractal
fluctuation dynamics across scales.
</p>
<p>While it is common to use only linear detrending with DFA, it is important to inspect the trends in the data to determine
if it would be more appropriate to use a higher order polynomial for detrending, and/or compare the DFA output for different polynomial orders (see Kantelhardt et al., 2001).
</p>
<p>General recommendations for choosing the min and max scale are an sc_min = 10 and sc_max = (N/4), where N is the number of observations.
See Eke et al. (2002) and Gulich and Zunino (2014) for additional considerations.
</p>


<h3>Value</h3>

<p>The object returned can take the following forms:
</p>
 
<ul>
<li><p> If the value of verbose = 1, then a list object is returned that includes: <code>log_scales</code>
the log of all included scales, <code>log_rms</code> the log root mean square error (RMS) per scale, and <code>alpha</code> the overall <code class="reqn">\alpha</code> estimate.
</p>
</li>
<li><p> If the value of verbose = 0, then a list containing only 'alpha' the estimated scaling exponent <code class="reqn">\alpha</code> will be returned.
</p>
</li></ul>



<h3>References</h3>

<p>Eke, A., Herman, P., Kocsis, L., &amp; Kozak, L. R. (2002). Fractal characterization of complexity in temporal physiological signals. Physiological measurement, 23(1), R1-R38.
</p>
<p>Gulich, D., &amp; Zunino, L. (2014). A criterion for the determination of optimal scaling ranges in DFA and MF-DFA. Physica A: Statistical Mechanics and its Applications, 397, 17-30.
</p>
<p>Kantelhardt, J. W., Koscielny-Bunde, E., Rego, H. H., Havlin, S., &amp; Bunde, A. (2001). Detecting long-range correlations with detrended fluctuation analysis. Physica A: Statistical Mechanics and its Applications, 295(3-4), 441-454.
</p>
<p>Kelty-Stephen, D. G., Stirling, L. A., &amp; Lipsitz, L. A. (2016). Multifractal temporal correlations in circle-tracing behaviors are associated with the executive function of rule-switching assessed by the Trail Making Test. Psychological assessment, 28(2), 171-180.
</p>
<p>Peng C-K, Buldyrev SV, Havlin S, Simons M, Stanley HE, and Goldberger AL (1994), Mosaic organization of DNA nucleotides, Physical Review E, 49, 1685-1689.
</p>
<p>Peng C-K, Havlin S, Stanley HE, and Goldberger AL (1995), Quantification of scaling exponents and crossover phenomena in nonstationary heartbeat time series, Chaos, 5, 82-87.
</p>
<p>Perakakis, P., Taylor, M., Martinez-Nieto, E., Revithi, I., &amp; Vila, J. (2009). Breathing frequency bias in fractal analysis of heart rate variability. Biological psychology, 82(1), 82-88.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>noise &lt;- rnorm(5000)

scales &lt;- c(16,32,64,128,256,512,1024)

dfa.noise.out &lt;- dfa(
    x = noise, 
    order = 1, 
    verbose = 1, 
    scales = scales,
    scale_ratio = 2)

pink.noise &lt;- fgn_sim(n = 5000, H = 0.9)

dfa.pink.out &lt;- dfa(
    x = pink.noise, 
    order = 1, 
    verbose = 1, 
    scales = scales, 
    scale_ratio = 2)

anticorr.noise &lt;- fgn_sim(n = 5000, H = 0.25)

dfa.anticorr.out &lt;- dfa(
    x = anticorr.noise, 
    order = 1, 
    verbose = 1, 
    scales = scales, 
    scale_ratio = 2)
    
</code></pre>

<hr>
<h2 id='dfa.plot'>Detrended Fluctuation Plot</h2><span id='topic+dfa.plot'></span>

<h3>Description</h3>

<p>Plot method for monofractal detrended fluctuation analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfa.plot(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dfa.plot_+3A_x">x</code></td>
<td>
<p>is an object returned from the <code>dfa</code> function of this package.
Plot parameters are chosen automatically,</p>
</td></tr>
</table>

<hr>
<h2 id='dlcca'>Multiscale Lagged Regression Anlaysis
Fast function for computing MLRA on long time series</h2><span id='topic+dlcca'></span>

<h3>Description</h3>

<p>Multiscale Lagged Regression Anlaysis
Fast function for computing MLRA on long time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlcca(x, y, order, scales, lags, direction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlcca_+3A_x">x</code></td>
<td>
<p>is a real valued vector of time series data</p>
</td></tr>
<tr><td><code id="dlcca_+3A_y">y</code></td>
<td>
<p>is a real valued vector of time series data</p>
</td></tr>
<tr><td><code id="dlcca_+3A_order">order</code></td>
<td>
<p>is an integer indicating the polynomial order used for 
detrending the local windows</p>
</td></tr>
<tr><td><code id="dlcca_+3A_scales">scales</code></td>
<td>
<p>integer vector of scales over which to compute correlation. 
Performance is best when scales are evenly spaced in log units. Choosing a
logarithm base between 1 and 2 may also improve performance of regression.</p>
</td></tr>
<tr><td><code id="dlcca_+3A_lags">lags</code></td>
<td>
<p>integer indicating the maximum number of lags to include</p>
</td></tr>
<tr><td><code id="dlcca_+3A_direction">direction</code></td>
<td>
<p>string indicating a positive ('p') or negative ('n') lag</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object returned from the dlcca() function is a list containing rho coefficients for each lag at each of the scales.
</p>

<hr>
<h2 id='fgn_sim'>Simulate fractional Gaussian Noise.</h2><span id='topic+fgn_sim'></span>

<h3>Description</h3>

<p>Simulate fractional Gaussian Noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fgn_sim(n = 1000, H = 0.7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fgn_sim_+3A_n">n</code></td>
<td>
<p>integer indicating length of desired series</p>
</td></tr>
<tr><td><code id="fgn_sim_+3A_h">H</code></td>
<td>
<p>Hurst exponent ranges between 0 and 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of length n.
</p>

<hr>
<h2 id='fractaldata'>A whitenoise, monofractal, and multifractal timeseries</h2><span id='topic+fractaldata'></span>

<h3>Description</h3>

<p>These data include three simulated data to be used for understanding the differences between the various univariate
methods in the dataset to compare whitenoise, monofractal, and multifractal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fractaldata)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 8000 rows and 4 columns.
</p>


<h3>Source</h3>

<p><a href="https://www.ntnu.edu/inb/geri/software">https://www.ntnu.edu/inb/geri/software</a>
</p>


<h3>References</h3>

<p>Ihlen, E. A. F. (2012). Introduction to Multifractal Detrended Fluctuation Analysis in Matlab. Frontiers in Physiology, 3. https://doi.org/10.3389/fphys.2012.00141
</p>

<hr>
<h2 id='iaafft'>Iterated Amplitude Adjusted Fourier Transform</h2><span id='topic+iaafft'></span>

<h3>Description</h3>

<p>Iterated Amplitude Adjusted Fourier Transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iaafft(signal, N = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iaafft_+3A_signal">signal</code></td>
<td>
<p>is a real valued time serires</p>
</td></tr>
<tr><td><code id="iaafft_+3A_n">N</code></td>
<td>
<p>is the number of desired surrogates. Default is 1</p>
</td></tr>
</table>

<hr>
<h2 id='lm_c'>Simplef bivariate regression written in c++</h2><span id='topic+lm_c'></span>

<h3>Description</h3>

<p>Simplef bivariate regression written in c++
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm_c(xs, yr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_c_+3A_xs">xs</code></td>
<td>
<p>a real valued column vector</p>
</td></tr>
<tr><td><code id="lm_c_+3A_yr">yr</code></td>
<td>
<p>is a real valued column vector</p>
</td></tr>
</table>

<hr>
<h2 id='logscale'>logscale</h2><span id='topic+logscale'></span>

<h3>Description</h3>

<p>Create logarithmically spaced scales
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logscale(scale_min, scale_max, scale_ratio)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logscale_+3A_scale_min">scale_min</code></td>
<td>
<p>an integer indicating the minimum scale to be resovled</p>
</td></tr>
<tr><td><code id="logscale_+3A_scale_max">scale_max</code></td>
<td>
<p>an integer indicating the maximum scale to be resolved</p>
</td></tr>
<tr><td><code id="logscale_+3A_scale_ratio">scale_ratio</code></td>
<td>
<p>a double indicating the ratio by which scale successive 
scales. For example, scale_ratio = 2 would create a scales increasing by 
a power of 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of of logarithmically spaced scales.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>scales &lt;- logscale(scale_min = 16, scale_max = 1024, scale_ratio = 2)

</code></pre>

<hr>
<h2 id='mBm_mGn'>Multifractional Brownian motion and multifractional Gaussian noise</h2><span id='topic+mBm_mGn'></span>

<h3>Description</h3>

<p>Simulate multifractional Brownian motion and multifractional Gaussian noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mBm_mGn(N, Ht)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mBm_mGn_+3A_n">N</code></td>
<td>
<p>The length of sample time series to simulate.</p>
</td></tr>
<tr><td><code id="mBm_mGn_+3A_ht">Ht</code></td>
<td>
<p>The N by 1 vector of the time evolving H(t).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an algorithm that simulates discrete time multifractional 
Brownian motion and multifractional Gaussian noise, which can useful for 
testing various functions within the 'fractalRegression' package. H(t) 
should take on any values between 0 and 1. It is meant to capture time 
varying fractal properties. The example code given below shows a slow 
evolving Hurst exponent involving a sinusoidal change.
</p>


<h3>Value</h3>

<p>The object returned from the function includes:
</p>

<ul>
<li><p> mBm: multifractional Brownian motion
</p>
</li>
<li><p> mGn: multifractional Gaussian noise
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
t &lt;- 1:1024
Ht &lt;- 0.5+0.5*(sin(0.0025*pi*t))
sim &lt;- mBm_mGn(1024,Ht)



</code></pre>

<hr>
<h2 id='mc_ARFIMA'>Mixed-correlated ARFIMA processes</h2><span id='topic+mc_ARFIMA'></span>

<h3>Description</h3>

<p>Simulate various types of correlated noise processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mc_ARFIMA(
  process,
  n,
  rho,
  d1 = NULL,
  d2 = NULL,
  d3 = NULL,
  d4 = NULL,
  alpha = NULL,
  beta = NULL,
  delta = NULL,
  gamma = NULL,
  theta = NULL,
  theta1 = NULL,
  theta2 = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mc_ARFIMA_+3A_process">process</code></td>
<td>
<p>specifies the type of correlated noise process to simulate
and includes 'Noise_rho', 'ARFIMA_rho','ARFIMA_AR','AR_rho',
'Mixed_ARFIMA_ARFIMA','Mixed_ARFIMA_AR',and 'Mixed_ARFIMA_noise'.</p>
</td></tr>
<tr><td><code id="mc_ARFIMA_+3A_n">n</code></td>
<td>
<p>is a numeric value specifying the length of the time-series.</p>
</td></tr>
<tr><td><code id="mc_ARFIMA_+3A_rho">rho</code></td>
<td>
<p>specifies the strength of the correlation with values -1 - 1.</p>
</td></tr>
<tr><td><code id="mc_ARFIMA_+3A_d1">d1</code></td>
<td>
<p>is a numeric fractional difference parameter for x specifying long term 
memory.</p>
</td></tr>
<tr><td><code id="mc_ARFIMA_+3A_d2">d2</code></td>
<td>
<p>is a numeric fractional difference parameter for x specifying long term 
memory.</p>
</td></tr>
<tr><td><code id="mc_ARFIMA_+3A_d3">d3</code></td>
<td>
<p>is a numeric fractional difference parameter for y specifying long term 
memory.</p>
</td></tr>
<tr><td><code id="mc_ARFIMA_+3A_d4">d4</code></td>
<td>
<p>is a numeric fractional difference parameter for y specifying long term 
memory.</p>
</td></tr>
<tr><td><code id="mc_ARFIMA_+3A_alpha">alpha</code></td>
<td>
<p>see Kristoufek (2013) for details.</p>
</td></tr>
<tr><td><code id="mc_ARFIMA_+3A_beta">beta</code></td>
<td>
<p>see Kristoufek (2013) for details.</p>
</td></tr>
<tr><td><code id="mc_ARFIMA_+3A_delta">delta</code></td>
<td>
<p>see Kristoufek (2013) for details.</p>
</td></tr>
<tr><td><code id="mc_ARFIMA_+3A_gamma">gamma</code></td>
<td>
<p>see Kristoufek (2013) for details.</p>
</td></tr>
<tr><td><code id="mc_ARFIMA_+3A_theta">theta</code></td>
<td>
<p>see Kristoufek (2013) for details.</p>
</td></tr>
<tr><td><code id="mc_ARFIMA_+3A_theta1">theta1</code></td>
<td>
<p>see Kristoufek (2013) for details.</p>
</td></tr>
<tr><td><code id="mc_ARFIMA_+3A_theta2">theta2</code></td>
<td>
<p>see Kristoufek (2013) for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function includes multiple options simulating various
types of correlated noise processes including mixed-correlated ARFIMA
processes with power-law cross-correlations, These functions were originally
written by Ladislav Kristoufek and posted on his website. They go with
the paper presented in Kristoufek (2013). The 'process' argument specifies
the type of noise to be generated.
</p>

<ul>
<li><p> 'Noise_rho' - Generates two correlated noise series and requires
arguments: n, rho.
</p>
</li>
<li><p> 'ARFIMA_rho' - Generates two ARFIMA processes with correlated
innovations and requires arguments: n, d1, d2, rho.
</p>
</li>
<li><p> 'ARFIMA_AR'  - Generates ARFIMA and AR(1) processes with correlated
innovations and requires arguments: n, d1, theta, rho.
</p>
</li>
<li><p> 'AR_rho' - Generates two AR(1) processes with correlated innovations
and requires arguments: n, theta1, theta2, rho.
</p>
</li>
<li><p> 'Mixed_ARFIMA_ARFIMA' - Generates MC-ARFIMA process with long-range
correlation and long-range cross-correlation (Kristoufec, 2013 Model 1) and
requires arguments: alpha, beta, gamma, delta, n, d1, d2, d3, d4, rho.
</p>
</li>
<li><p> 'Mixed_ARFIMA_AR' - Generates MC-ARFIMA process with long-range
correlation and short-range cross-correlation (Kristoufec, 2013 Model 2)
and requires arguments: alpha, beta, gamma, delta, n, d1, d2, theta, rho.
</p>
</li>
<li><p> 'Mixed_ARFIMA_noise' - Generates MC-ARFIMA process with long-range
correlation and simple correlation (Kristoufec, 2013 Model 3) and requires
arguments: alpha, beta, gamma, delta, n, d1, d2, rho.
</p>
</li></ul>



<h3>Value</h3>

<p>The object returned is a matrix of length n with a time series (x,y)
in column 1 and 2.
</p>


<h3>References</h3>

<p>Kristoufek, L. (2013). Mixed-correlated ARFIMA processes for power-law
cross-correlations. Physica A: Statistical Mechanics and its Applications,
392(24), 6484-6493.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(987345757)

sim1 &lt;- mc_ARFIMA(process='Mixed_ARFIMA_ARFIMA', alpha = 0.2,
beta = 1, gamma = 1, delta = 0.2, n = 10000, d1 = 0.4, d2 = 0.3,
d3 = 0.3, d4=0.4, rho=0.9)

plot(sim1[,1],type='l', ylab= "Signal Amplitude", xlab='Time',
main = "MC-ARFIMA with LRC and LRCC")

lines(sim1[,2], col='blue')

</code></pre>

<hr>
<h2 id='mfdfa'>Multifractal Detrended Fluctuation Analysis</h2><span id='topic+mfdfa'></span>

<h3>Description</h3>

<p>Fast function for computing multifractal detrended fluctuation analysis 
(MF-DFA), a widely used method for estimating the family of long-range 
temporal correlations or scaling exponents in time series data. 
MF-DFA is also a form of multifractal analysis that indicates the degree 
of interaction across temporal scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfdfa(x, q, order, scales, scale_ratio)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfdfa_+3A_x">x</code></td>
<td>
<p>A real valued vector (i.e., time series data) to be analyzed.</p>
</td></tr>
<tr><td><code id="mfdfa_+3A_q">q</code></td>
<td>
<p>A real valued vector indicating the statistical moments (q) to use 
in the analysis. q must span negative and positive values e.g., -3:3, 
otherwise and error may be produced.</p>
</td></tr>
<tr><td><code id="mfdfa_+3A_order">order</code></td>
<td>
<p>is an integer indicating the polynomial order used for 
detrending the local windows (e.g, 1 = linear, 2 = quadratic, etc.). There 
is not pre-determined limit on the order of the polynomial order but the 
user should avoid using a large polynomial on small windows. This can result
in overfitting and non-meaningful estimates.</p>
</td></tr>
<tr><td><code id="mfdfa_+3A_scales">scales</code></td>
<td>
<p>An integer valued vector indicating the scales one wishes to resolve
in the analysis. Best practice is to use scales which are evenly spaced in 
the logarithmic domain e.g., <code>scales = 2^(4:(N/4))</code>, where N is the length of the
time series. Other, logarithmic bases may also be used to give finer 
resolution of scales while maintaining ~= spacing in the log domain e.g, 
<code>scales = unique(floor(1.1^(30:(N/4))))</code>. Note that fractional bases may 
produce duplicate values after the necessary floor function.</p>
</td></tr>
<tr><td><code id="mfdfa_+3A_scale_ratio">scale_ratio</code></td>
<td>
<p>A scaling factor by which successive window sizes 
were created. The default is 2 but should be addressed according to how 
scales were generated for example using <code>logscale(16, 100, 1.1)</code>, 
where 1.1 is the scale ratio.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details of the algorithm are specified in detail in Kantelhardt et al. (2001; 2002) and visualized nicely in Kelty-Stephen et al. (2016).
</p>
<p>Selecting the range of values for q is important. Note that MF-DFA estimates for q = 2 are equivalent to DFA. Larger values of q (q &gt; 2) emphasize larger residuals and smaller values of q
(q &lt; 2) emphasis smaller residuals (Kelty-Stephen et al., 2016). For most biomedical signals such as physiological and kinematic, a q range of -5 to 5 is common (Ihlen, 2010). However, in some cases, 
such as when time series are short (&lt; 3000), it can be appropriate to limit the range of q to positive only. Kelty-Stephen et al. (2016) recommend a 
positive q range of 0.5 to 10 with an increment of 0.5. 
</p>
<p>While it is common to use only linear detrending with DFA and MF-DFA, it is important to inspect the trends in the data to determine
if it would be more appropriate to use a higher order polynomial for detrending, and/or compare the DFA and MF-DFA output for different polynomial orders (see Ihlen, 2012; Kantelhardt et al., 2001).
</p>
<p>General recommendations for choosing the min and max scale are a scale_min = 10 and scale_max = (N/4), where N is the number of observations.
See Eke et al. (2002), Gulich and Zunino (2014), Ihlen (2012), and  for additional considerations and information on choosing the correct parameters.
</p>


<h3>Value</h3>

<p>The output of the algorithm is a list that includes:
</p>
 
<ul>
<li> <p><code>log_scale</code> The log scales used for the analysis
</p>
</li>
<li> <p><code>log_fq</code> The log of the fluctuation functions for each scale and q 
</p>
</li>
<li> <p><code>Hq</code> The q-order Hurst exponent (generalized Hurst exponent)
</p>
</li>
<li> <p><code>Tau</code> The q-order mass exponent
</p>
</li>
<li> <p><code>q</code> The q-order statistical moments
</p>
</li>
<li> <p><code>h</code> The q-order singularity exponent
</p>
</li>
<li> <p><code>Dh</code> The dimension of the q-order singularity exponent
</p>
</li></ul>



<h3>References</h3>

<p>Ihlen, E. A. F. (2012). Introduction to Multifractal Detrended Fluctuation Analysis in Matlab. Frontiers in Physiology, 3. https://doi.org/10.3389/fphys.2012.00141
</p>
<p>Kantelhardt, J. W., Koscielny-Bunde, E., Rego, H. H., Havlin, S., &amp; Bunde, A. (2001). Detecting long-range correlations with detrended fluctuation analysis. Physica A: Statistical Mechanics and its Applications, 295(3-4), 441-454.
</p>
<p>Kantelhardt, J. W., Zschiegner, S. A., Koscielny-Bunde, E., Havlin, S., Bunde, A., &amp; Stanley, H. E. (2002). Multifractal detrended fluctuation analysis of nonstationary time series. Physica A: Statistical Mechanics and its Applications, 316(1-4), 87-114.
</p>
<p>Kelty-Stephen, D. G., Palatinus, K., Saltzman, E., &amp; Dixon, J. A. (2013). A Tutorial on Multifractality, Cascades, and Interactivity for Empirical Time Series in Ecological Science. Ecological Psychology, 25(1), 1-62. https://doi.org/10.1080/10407413.2013.753804
</p>
<p>Kelty-Stephen, D. G., Stirling, L. A., &amp; Lipsitz, L. A. (2016). Multifractal temporal correlations in circle-tracing behaviors are associated with the executive function of rule-switching assessed by the Trail Making Test. Psychological Assessment, 28(2), 171-180. https://doi.org/10.1037/pas0000177
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


noise &lt;- rnorm(5000)

scales &lt;- c(16,32,64,128,256,512,1024)

mf.dfa.white.out &lt;- mfdfa(
    x = noise, q = c(-5:5), 
    order = 1, 
    scales = scales, 
    scale_ratio = 2) 
 
pink.noise &lt;- fgn_sim(n = 5000, H = 0.9)

mf.dfa.pink.out &lt;- mfdfa(
    x = pink.noise, 
    q = c(-5:5), 
    order = 1, 
    scales = scales, 
    scale_ratio = 2)



</code></pre>

<hr>
<h2 id='mfdfa_cj'>Multifractal Analysis Chhabra-Jensen Method</h2><span id='topic+mfdfa_cj'></span>

<h3>Description</h3>

<p>Fast function for computing multifractal analysis using a lesser-known method
for estimating the family of long-range temporal correlations or scaling 
exponents in time series data. This is also a form of multifractal 
analysis that indicates the degree of interaction across temporal scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfdfa_cj(Timeseries, qValues, scales)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfdfa_cj_+3A_timeseries">Timeseries</code></td>
<td>
<p>is a real valued time series</p>
</td></tr>
<tr><td><code id="mfdfa_cj_+3A_qvalues">qValues</code></td>
<td>
<p>real valued vector of q-orders</p>
</td></tr>
<tr><td><code id="mfdfa_cj_+3A_scales">scales</code></td>
<td>
<p>unsigned integer vector of scales to be resolved</p>
</td></tr>
</table>

<hr>
<h2 id='mfdfa.plot'>Multifractal Spectrum Plot</h2><span id='topic+mfdfa.plot'></span>

<h3>Description</h3>

<p>Method for plotting various forms of the multifractal spectrum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfdfa.plot(mf, do.surrogate, nsurrogates = 19, return.ci = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfdfa.plot_+3A_mf">mf</code></td>
<td>
<p>an object containing elements related to the mutlifractal 
spectrum derived from Multifractal Detrended Fluctuation Analysis</p>
</td></tr>
<tr><td><code id="mfdfa.plot_+3A_do.surrogate">do.surrogate</code></td>
<td>
<p>logical indicating whether surrogation should be 
performed on the time series</p>
</td></tr>
<tr><td><code id="mfdfa.plot_+3A_nsurrogates">nsurrogates</code></td>
<td>
<p>integer indicating the number of surrogates to be 
constructed. Default is 19 for 95
surrogates ore more precise but increase computational time.</p>
</td></tr>
<tr><td><code id="mfdfa.plot_+3A_return.ci">return.ci</code></td>
<td>
<p>logical indicating if confidence intervals derived from 
surrogate analysis should be returned.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Aaron D. Likens (2022)
</p>


<h3>References</h3>

<p>Kantelhardt et al. (2002). Multifractal detrended fluctuation
analys of nonstationary time series. Physica A: Statistical Mechanics and 
its Applications, 87
</p>

<hr>
<h2 id='mlra'>Multiscale Lagged Regression Analysis</h2><span id='topic+mlra'></span>

<h3>Description</h3>

<p>Fast function for computing multiscale lagged regression analysis (MLRA) on long time series. Combining DFA with ordinary least square regression, MLRA
is a form of fractal regression that can be used to estimate asymmetric and multiscale regression coefficients between two variables at different time-scales and temporal lags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mlra(x, y, order, scales, lags, direction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mlra_+3A_x">x</code></td>
<td>
<p>A real valued vector (i.e., time series data) to be analyzed.</p>
</td></tr>
<tr><td><code id="mlra_+3A_y">y</code></td>
<td>
<p>A real valued vector (i.e., time series data) to be analyzed.</p>
</td></tr>
<tr><td><code id="mlra_+3A_order">order</code></td>
<td>
<p>is an integer indicating the polynomial order used for 
detrending the local windows (e.g, 1 = linear, 2 = quadratic, etc.). There 
is a not pre-determined limit on the order of the polynomial order but the 
user should avoid using a large polynomial on small windows. This can result
in overfitting and non-meaningful estimates.</p>
</td></tr>
<tr><td><code id="mlra_+3A_scales">scales</code></td>
<td>
<p>An integer vector of scales over which to compute correlation. 
Unlike univariate DFA, MRA does not require that scales be in log units.
Scale intervals can be sequential, for example, when the analysis is 
exploratory and no a priori hypotheses have been made about the scale of 
correlation. A small subset of targeted scales may also be investigated 
where scale-specific research questions exist. We have found that windows
smaller than say 8 observations create stability problems due to 
overfitting. This is espcially when the order of the fitting polynomial is 
large.</p>
</td></tr>
<tr><td><code id="mlra_+3A_lags">lags</code></td>
<td>
<p>An integer indicating the maximum number of lags to include in the analysis.</p>
</td></tr>
<tr><td><code id="mlra_+3A_direction">direction</code></td>
<td>
<p>A character string indicating a positive ('p') or negative ('n') lag.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mathematical treatment of the MLRA algorithm and its performance can be found in Kristoufek (2015) and Likens et al. (2019).
</p>
<p>Use of the direction parameter specifies whether the scale-wise <code class="reqn">\beta</code> coefficients for positive or negative lags will be estimated.  
</p>
<p>Note that under conditions with linear and quadratic trends, Likens et al. (2019) found that there was a systematic positive bias in the <code class="reqn">\beta</code> estimates for larger scales.
Using a polynomial detrending order of 2 or greater was shown to attenuate this bias.
</p>


<h3>Value</h3>

<p>The object returned from the mlra() function is a list containing <code>betas</code> the <code class="reqn">\beta</code> coefficients for each lag at each of the scales.
</p>


<h3>References</h3>

<p>Kristoufek, L. (2015). Detrended fluctuation analysis as a regression framework: Estimating dependence at different scales. Physical Review E, 91(2), 022802.
</p>
<p>Likens, A. D., Amazeen, P. G., West, S. G., &amp; Gibbons, C. T. (2019). Statistical properties of Multiscale Regression Analysis: Simulation and application to human postural control. Physica A: Statistical Mechanics and its Applications, 532, 121580.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Here is a simple example for running MLRA using a white noise and pink noise time series.
# For more detailed examples, see the vignette. 

noise &lt;- rnorm(5000)

pink.noise &lt;- fgn_sim(n = 5000, H = 0.9)

scales &lt;- logscale(scale_min = 10, scale_max = 1250, scale_ratio = 1.1)

mlra.out &lt;- mlra(
    x = noise, 
    y = pink.noise, 
    order = 1, 
    scales = scales, 
    lags = 100, direction = 'p')




</code></pre>

<hr>
<h2 id='mra'>Multiscale Regression Analysis (MRA)</h2><span id='topic+mra'></span>

<h3>Description</h3>

<p>Fast function for computing multiscale regression analysis (MRA) on long time series. Combining DFA with ordinary least square regression, MRA
is a form of fractal regression that can be used to estimate asymmetric and multiscale regression coefficients between two variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mra(x, y, order, scales)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mra_+3A_x">x</code></td>
<td>
<p>A real valued vector (i.e., time series data) to be analyzed. A key
difference between DCCA and MRA is that MRA produces asymmetric estiamtes. 
That is, x is assumed to be an independent variable and y is assumed to be 
a dependent variable. MRA should be used when one of the time series in 
question is usefully cast as the independent variable. That is, x is assumed
to effect change in y. If no such causal relationship is anticipated, use
DCCA instead.</p>
</td></tr>
<tr><td><code id="mra_+3A_y">y</code></td>
<td>
<p>A real valued vector (i.e., time series data) to be analyzed.</p>
</td></tr>
<tr><td><code id="mra_+3A_order">order</code></td>
<td>
<p>is an integer indicating the polynomial order used for 
detrending the local windows (e.g, 1 = linear, 2 = quadratic, etc.). There 
is not a pre-determined limit on the order of the polynomial order but the 
user should avoid using a large polynomial on small windows. This can result
in overfitting and non-meaningful estimates.</p>
</td></tr>
<tr><td><code id="mra_+3A_scales">scales</code></td>
<td>
<p>An integer vector of scales over which to compute correlation. 
Unlike univariate DFA, MRA does not require that scales be in log units.
Scale intervals can be sequential, for example, when the analysis is 
exploratory and no a priori hypotheses have been made about the scale of 
correlation. A small subset of targeted scales may also be investigated 
where scale-specific research questions exist. We have found that windows
smaller than say 8 observations create stability problems due to 
overfitting. This is espcially when the order of the fitting polynomial is 
large.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Mathematical treatment of the MRA algorithm and its performance can be found in Kristoufek (2015) and Likens et al. (2019).
</p>
<p>Note that under conditions with linear and quadratic trends, Likens et al. (2019) found that there was a systematic positive bias in the <code class="reqn">\beta</code> estimates for larger scales.
Using a polynomial detrending order of 2 or greater was shown to attenuate this bias.
</p>


<h3>Value</h3>

<p>The object returned from the mra() function is a list including the following:
</p>
 
<ul>
<li> <p><code>scales</code> indicates the values of the scales used for estimates
</p>
</li>
<li> <p><code>betas</code> are the scale specific <code class="reqn">\beta</code> estimates of the influence of x on y
</p>
</li>
<li> <p><code>r2</code> is the scale specific r-squared value of the model fit (i.e., variance in y accounted for by x at that scale)
</p>
</li>
<li> <p><code>t_observed</code> is the estimated t-statistic for a given <code class="reqn">\beta</code> at a given scale. 
</p>
</li></ul>



<h3>References</h3>

<p>Kristoufek, L. (2015). Detrended fluctuation analysis as a regression framework: Estimating dependence at different scales. Physical Review E, 91(2), 022802.
</p>
<p>Likens, A. D., Amazeen, P. G., West, S. G., &amp; Gibbons, C. T. (2019). Statistical properties of Multiscale Regression Analysis: Simulation and application to human postural control. Physica A: Statistical Mechanics and its Applications, 532, 121580.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Here is a simple example for running MRA using a white noise and pink noise time series.
# For more detailed examples, see the vignette. 

noise &lt;- rnorm(5000)

pink.noise &lt;- fgn_sim(n = 5000, H = 0.9)

scales &lt;- logscale(scale_min = 10, scale_max = 1250, scale_ratio = 1.1)

mra.out &lt;- mra(x = noise, y = pink.noise, order = 1, scales = scales)



</code></pre>

<hr>
<h2 id='mra.plot'>Multiscale Regression Plot</h2><span id='topic+mra.plot'></span>

<h3>Description</h3>

<p>A plotting method for constructing scalewise regression plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mra.plot(
  betas,
  order = 1,
  ci = FALSE,
  iterations = NULL,
  return.ci = FALSE,
  loess.beta = FALSE,
  loess.ci = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mra.plot_+3A_betas">betas</code></td>
<td>
<p>an object containing modeling results from multiscale regression
analysis. The object should be returned from the <code>mra</code> function of this
package.</p>
</td></tr>
<tr><td><code id="mra.plot_+3A_order">order</code></td>
<td>
<p>integer representing the detrending order used in the <code>mra</code> 
calculation. Default is 1.</p>
</td></tr>
<tr><td><code id="mra.plot_+3A_ci">ci</code></td>
<td>
<p>a logical indicating whether confidence intervals should be 
computed using the <code>iaafft</code> function from this package. NOTE: with long 
time series (&gt;&gt; than N = 1,000), this can greatly reduce processing speed. 
Confidence intervals can be used for conventional significance testing of 
scale-wise correlation coefficients.</p>
</td></tr>
<tr><td><code id="mra.plot_+3A_iterations">iterations</code></td>
<td>
<p>integer that specifies the the number of surrogate time 
series to be generated for the purpose of confidence intervals. 
Default = 19. Larger number of surrogates will slow computational speed but
produce better confidence interval estimates.</p>
</td></tr>
<tr><td><code id="mra.plot_+3A_return.ci">return.ci</code></td>
<td>
<p>logical indicating whether the confidence intervals 
should be returned</p>
</td></tr>
<tr><td><code id="mra.plot_+3A_loess.beta">loess.beta</code></td>
<td>
<p>logical indicating whether a loess fit should be used for 
displaying multiscale regression coefficient trajectories</p>
</td></tr>
<tr><td><code id="mra.plot_+3A_loess.ci">loess.ci</code></td>
<td>
<p>logical indicating whether a loess fit should be used to smooth 
confidence intervals</p>
</td></tr>
</table>

<hr>
<h2 id='poly_residuals'>Polynomial Residuals
Function that fits a polynomial and returns the residuals</h2><span id='topic+poly_residuals'></span>

<h3>Description</h3>

<p>Polynomial Residuals
Function that fits a polynomial and returns the residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly_residuals(yr, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly_residuals_+3A_yr">yr</code></td>
<td>
<p>is a real valued vector</p>
</td></tr>
<tr><td><code id="poly_residuals_+3A_m">m</code></td>
<td>
<p>is the detrending order</p>
</td></tr>
</table>

<hr>
<h2 id='seq_int'>Integer Sequence
Function that produces a sequence of integers from 1 to N</h2><span id='topic+seq_int'></span>

<h3>Description</h3>

<p>Integer Sequence
Function that produces a sequence of integers from 1 to N
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_int(length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_int_+3A_length">length</code></td>
<td>
<p>is a positive integer that will produce a sequence from 1:length</p>
</td></tr>
</table>

<hr>
<h2 id='seq_int_range'>Sequence of Integer ranges
Function that produces a sequece of integers that span a specific range</h2><span id='topic+seq_int_range'></span>

<h3>Description</h3>

<p>Sequence of Integer ranges
Function that produces a sequece of integers that span a specific range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_int_range(start, stop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_int_range_+3A_start">start</code></td>
<td>
<p>is a positive integer and gives the smallest value in the sequence</p>
</td></tr>
<tr><td><code id="seq_int_range_+3A_stop">stop</code></td>
<td>
<p>is a positive integer and gives the largest value in a sequence</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
