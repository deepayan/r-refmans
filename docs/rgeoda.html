<!DOCTYPE html><html><head><title>Help for package rgeoda</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rgeoda}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as.data.frame.geoda'><p>convert rgeoda instance to data.frame</p></a></li>
<li><a href='#as.geoda'><p>Create an instance of geoda-class from either an 'sf' or 'sp' object</p></a></li>
<li><a href='#as.matrix.Weight'><p>spatial weights to matrix</p></a></li>
<li><a href='#azp_greedy'><p>A greedy algorithm to solve the AZP problem</p></a></li>
<li><a href='#azp_sa'><p>A simulated annealing algorithm to solve the AZP problem</p></a></li>
<li><a href='#azp_tabu'><p>A tabu algorithm to solve the AZP problem</p></a></li>
<li><a href='#create_weights'><p>Create an empty weights</p></a></li>
<li><a href='#distance_weights'><p>Distance-based Spatial Weights</p></a></li>
<li><a href='#eb_rates'><p>Empirical Bayes(EB) Rate</p></a></li>
<li><a href='#gda_distance_weights'><p>(For internally use and test only) Distance-based Spatial Weights</p></a></li>
<li><a href='#gda_kernel_knn_weights'><p>(For internally use and test only) K-NN Kernel Spatial Weights</p></a></li>
<li><a href='#gda_kernel_weights'><p>(For internally use and test only) Distance-based Kernel Spatial</p>
Weights</a></li>
<li><a href='#gda_knn_weights'><p>(For internally use and test only) K-Nearest Neighbors-based Spatial</p>
Weights</a></li>
<li><a href='#gda_min_distthreshold'><p>(For internally use and test only) Minimum Distance Threshold for</p>
Distance-based Weights</a></li>
<li><a href='#gda_queen_weights'><p>(For internally use and test only) Queen Contiguity Spatial Weights</p></a></li>
<li><a href='#gda_rook_weights'><p>(For internally use and test only) Rook Contiguity Spatial Weights</p></a></li>
<li><a href='#geoda_open'><p>Create an instance of geoda-class by reading from an ESRI Shapefile</p>
dataset</a></li>
<li><a href='#geoda-class'><p>'geoda' class</p></a></li>
<li><a href='#get_neighbors'><p>Neighbors of one observation</p></a></li>
<li><a href='#get_neighbors_weights'><p>Weights values of the neighbors of one observation</p></a></li>
<li><a href='#has_isolates'><p>Isolation/Island in Spatial Weights</p></a></li>
<li><a href='#hinge15_breaks'><p>(Box) Hinge15 Breaks</p></a></li>
<li><a href='#hinge30_breaks'><p>(Box) Hinge30 Breaks</p></a></li>
<li><a href='#is_symmetric'><p>Symmetry of Weights Matrix</p></a></li>
<li><a href='#join_count_ratio'><p>Join Count Ratio</p></a></li>
<li><a href='#kernel_knn_weights'><p>K-NN Kernel Spatial Weights</p></a></li>
<li><a href='#kernel_weights'><p>Distance-based Kernel Spatial Weights</p></a></li>
<li><a href='#knn_weights'><p>K-Nearest Neighbors-based Spatial Weights</p></a></li>
<li><a href='#lisa_bo'><p>Bonferroni bound value of local spatial autocorrelation</p></a></li>
<li><a href='#lisa_clusters'><p>Get local cluster indicators</p></a></li>
<li><a href='#lisa_colors'><p>Get cluster colors</p></a></li>
<li><a href='#lisa_fdr'><p>False Discovery Rate value of local spatial autocorrelation</p></a></li>
<li><a href='#lisa_labels'><p>Get cluster labels</p></a></li>
<li><a href='#lisa_num_nbrs'><p>Get numbers of neighbors for all observations</p></a></li>
<li><a href='#lisa_pvalues'><p>Get pseudo-p values of LISA</p></a></li>
<li><a href='#lisa_values'><p>Get LISA values</p></a></li>
<li><a href='#LISA-class'><p>LISA class (Internally Used)</p></a></li>
<li><a href='#local_bijoincount'><p>Bivariate Local Join Count Statistics</p></a></li>
<li><a href='#local_bimoran'><p>Bivariate Local Moran Statistics</p></a></li>
<li><a href='#local_g'><p>Local Getis-Ord's G Statistics</p></a></li>
<li><a href='#local_geary'><p>Local Geary Statistics</p></a></li>
<li><a href='#local_gstar'><p>Local Getis-Ord's G* Statistics</p></a></li>
<li><a href='#local_joincount'><p>Local Join Count Statistics</p></a></li>
<li><a href='#local_moran'><p>Local Moran Statistics</p></a></li>
<li><a href='#local_moran_eb'><p>Local Moran with Empirical Bayes(EB) Rate</p></a></li>
<li><a href='#local_multigeary'><p>Local Multivariate Geary Statistics</p></a></li>
<li><a href='#local_multijoincount'><p>(Multivariate) Colocation Local Join Count Statistics</p></a></li>
<li><a href='#local_multiquantilelisa'><p>Multivariate Quantile LISA Statistics</p></a></li>
<li><a href='#local_quantilelisa'><p>Quantile LISA Statistics</p></a></li>
<li><a href='#make_spatial'><p>Make Spatial</p></a></li>
<li><a href='#max_neighbors'><p>Maximum Neighbors of Spatial Weights</p></a></li>
<li><a href='#maxp_greedy'><p>A greedy algorithm to solve the max-p-region problem</p></a></li>
<li><a href='#maxp_sa'><p>A simulated annealing algorithm to solve the max-p-region problem</p></a></li>
<li><a href='#maxp_tabu'><p>A tabu-search algorithm to solve the max-p-region problem</p></a></li>
<li><a href='#mean_neighbors'><p>Mean Neighbors of Spatial Weights</p></a></li>
<li><a href='#median_neighbors'><p>Median Neighbors of Spatial Weights</p></a></li>
<li><a href='#min_distthreshold'><p>Minimum Distance Threshold for Distance-based Weights</p></a></li>
<li><a href='#min_neighbors'><p>Minimum Neighbors of Spatial Weights</p></a></li>
<li><a href='#natural_breaks'><p>Natural Breaks (Jenks)</p></a></li>
<li><a href='#neighbor_match_test'><p>Local Neighbor Match Test</p></a></li>
<li><a href='#p_GeoDa-class'><p>p_GeoDa</p></a></li>
<li><a href='#p_GeoDaTable-class'><p>p_GeoDaTable</p></a></li>
<li><a href='#p_GeoDaWeight-class'><p>p_GeoDaWeight</p></a></li>
<li><a href='#p_LISA-class'><p>p_LISA</p></a></li>
<li><a href='#percentile_breaks'><p>Percentile Breaks</p></a></li>
<li><a href='#quantile_breaks'><p>Quantile Breaks</p></a></li>
<li><a href='#queen_weights'><p>Queen Contiguity Spatial Weights</p></a></li>
<li><a href='#read_gal'><p>Read a .GAL file</p></a></li>
<li><a href='#read_gwt'><p>Read a .GWT file</p></a></li>
<li><a href='#read_swm'><p>Read a .SWM file</p></a></li>
<li><a href='#redcap'><p>Regionalization with dynamically constrained agglomerative clustering and partitioning</p></a></li>
<li><a href='#rook_weights'><p>Rook Contiguity Spatial Weights</p></a></li>
<li><a href='#save_weights'><p>Save Spatial Weights</p></a></li>
<li><a href='#schc'><p>Spatially Constrained Hierarchical Clucstering (SCHC)</p></a></li>
<li><a href='#set_neighbors'><p>Set neighbors of an observation</p></a></li>
<li><a href='#set_neighbors_with_weights'><p>Set neighbors and weights values of an observation</p></a></li>
<li><a href='#sf_to_geoda'><p>Create an instance of geoda-class from a 'sf' object</p></a></li>
<li><a href='#skater'><p>Spatial C(K)luster Analysis by Tree Edge Removal</p></a></li>
<li><a href='#sp_to_geoda'><p>Create an instance of geoda-class from a 'sp' object</p></a></li>
<li><a href='#spatial_lag'><p>Spatial Lag</p></a></li>
<li><a href='#spatial_validation'><p>Spatial Validation</p></a></li>
<li><a href='#stddev_breaks'><p>Standard Deviation Breaks</p></a></li>
<li><a href='#summary.Weight'><p>Summary of Spatial Weights</p></a></li>
<li><a href='#update_weights'><p>Update meta data of a spatial weights</p></a></li>
<li><a href='#Weight-class'><p>Weight class (Internally Used)</p></a></li>
<li><a href='#weights_sparsity'><p>Sparsity of Spatial Weights</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>R Library for Spatial Data Analysis</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.10-4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-01</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xun Li &lt;lixun910@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides spatial data analysis functionalities including Exploratory Spatial Data Analysis, 
    Spatial Cluster Detection and Clustering Analysis, Regionalization, etc. based on the C++ source code 
    of 'GeoDa', which is an open-source software tool that serves as an introduction to spatial data analysis.
    The 'GeoDa' software and its documentation are available at <a href="https://geodacenter.github.io">https://geodacenter.github.io</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/geodacenter/rgeoda/">https://github.com/geodacenter/rgeoda/</a>,
<a href="https://geodacenter.github.io/rgeoda/">https://geodacenter.github.io/rgeoda/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/geodacenter/rgeoda/issues/">https://github.com/geodacenter/rgeoda/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), methods, digest</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Collate:</td>
<td>init.R rgeoda.R sf_geoda.R RcppExports.R read_geoda.R
weights.R utils.R lisa.R clustering.R</td>
</tr>
<tr>
<td>Imports:</td>
<td>sf, Rcpp (&ge; 1.0.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, BH</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>wkb, sp</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++17</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-01 18:45:47 UTC; xun</td>
</tr>
<tr>
<td>Author:</td>
<td>Xun Li [aut, cre],
  Luc Anselin [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-01 20:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as.data.frame.geoda'>convert rgeoda instance to data.frame</h2><span id='topic+as.data.frame.geoda'></span>

<h3>Description</h3>

<p>Override the as.data.frame function for rgeoda instance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'geoda'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.geoda_+3A_x">x</code></td>
<td>
<p>A rgeoda object</p>
</td></tr>
<tr><td><code id="as.data.frame.geoda_+3A_row.names">row.names</code></td>
<td>
<p>NULL or a character vector giving the row names for the data
frame. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="as.data.frame.geoda_+3A_optional">optional</code></td>
<td>
<p>optional parameters</p>
</td></tr>
<tr><td><code id="as.data.frame.geoda_+3A_...">...</code></td>
<td>
<p>other arguments passed to methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame object
</p>

<hr>
<h2 id='as.geoda'>Create an instance of geoda-class from either an 'sf' or 'sp' object</h2><span id='topic+as.geoda'></span>

<h3>Description</h3>

<p>Create an instance of geoda-class from an 'sf' object returned
from 'st_read()' function,
or a 'sp' object returned from 'readOGR()' function.
NOTE: The table content is NOT used to create an instance of geoda-class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.geoda(obj, with_table = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.geoda_+3A_obj">obj</code></td>
<td>
<p>An instance of 'sf' or 'sp' object</p>
</td></tr>
<tr><td><code id="as.geoda_+3A_with_table">with_table</code></td>
<td>
<p>A boolean flag indicates if table is copied from sf object
to create geoda object. Default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of geoda-class
</p>

<hr>
<h2 id='as.matrix.Weight'>spatial weights to matrix</h2><span id='topic+as.matrix.Weight'></span>

<h3>Description</h3>

<p>Convert a GeoDa spatial weights object to a Matrix object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Weight'
as.matrix(x, rownames = NULL, rownames.value = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.Weight_+3A_x">x</code></td>
<td>
<p>A weights object</p>
</td></tr>
<tr><td><code id="as.matrix.Weight_+3A_rownames">rownames</code></td>
<td>
<p>optional, a single column name or column number to use as the
rownames in the returned matrix. If TRUE the key of the data.table will be
used if it is a single column, otherwise the first column in the data.table
will be used.</p>
</td></tr>
<tr><td><code id="as.matrix.Weight_+3A_rownames.value">rownames.value</code></td>
<td>
<p>optional, a vector of values to be used as the rownames
in the returned matrix. It must be the same length as nrow(x).</p>
</td></tr>
<tr><td><code id="as.matrix.Weight_+3A_...">...</code></td>
<td>
<p>Required to be present because the generic 'as.matrix' generic
has it. Arguments here are not currently used or passed on by this method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix object
</p>

<hr>
<h2 id='azp_greedy'>A greedy algorithm to solve the AZP problem</h2><span id='topic+azp_greedy'></span>

<h3>Description</h3>

<p>The automatic zoning procedure (AZP) was initially outlined in Openshaw (1977) as a way to address some of the consequences of the modifiable areal unit problem (MAUP). In essence, it consists of a heuristic to find the best set of combinations of contiguous spatial units into p regions, minimizing the within sum of squares as a criterion of homogeneity. The number of regions needs to be specified beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>azp_greedy(
  p,
  w,
  df,
  bound_variable = data.frame(),
  min_bound = 0,
  inits = 0,
  initial_regions = vector("numeric"),
  scale_method = "standardize",
  distance_method = "euclidean",
  random_seed = 123456789,
  rdist = numeric()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="azp_greedy_+3A_p">p</code></td>
<td>
<p>The number of spatially constrained clusters</p>
</td></tr>
<tr><td><code id="azp_greedy_+3A_w">w</code></td>
<td>
<p>An instance of Weight class</p>
</td></tr>
<tr><td><code id="azp_greedy_+3A_df">df</code></td>
<td>
<p>A data frame with selected variables only. E.g. guerry[c(&quot;Crm_prs&quot;, &quot;Crm_prp&quot;, &quot;Litercy&quot;)]</p>
</td></tr>
<tr><td><code id="azp_greedy_+3A_bound_variable">bound_variable</code></td>
<td>
<p>(optional) A data frame with selected bound variabl</p>
</td></tr>
<tr><td><code id="azp_greedy_+3A_min_bound">min_bound</code></td>
<td>
<p>(optional) A minimum bound value that applies to all clusters</p>
</td></tr>
<tr><td><code id="azp_greedy_+3A_inits">inits</code></td>
<td>
<p>(optional) The number of construction re-runs, which is for ARiSeL &quot;automatic regionalization with initial seed location&quot;</p>
</td></tr>
<tr><td><code id="azp_greedy_+3A_initial_regions">initial_regions</code></td>
<td>
<p>(optional) The initial regions that the local search starts with. Default is empty. means the local search starts with a random process to &quot;grow&quot; clusters</p>
</td></tr>
<tr><td><code id="azp_greedy_+3A_scale_method">scale_method</code></td>
<td>
<p>(optional) One of the scaling methods 'raw', 'standardize', 'demean', 'mad', 'range_standardize', 'range_adjust' to apply on input data. Default is 'standardize' (Z-score normalization).</p>
</td></tr>
<tr><td><code id="azp_greedy_+3A_distance_method">distance_method</code></td>
<td>
<p>(optional) The distance method used to compute the distance betwen observation i and j. Defaults to &quot;euclidean&quot;. Options are &quot;euclidean&quot; and &quot;manhattan&quot;</p>
</td></tr>
<tr><td><code id="azp_greedy_+3A_random_seed">random_seed</code></td>
<td>
<p>(optional) The seed for random number generator. Defaults to 123456789.</p>
</td></tr>
<tr><td><code id="azp_greedy_+3A_rdist">rdist</code></td>
<td>
<p>(optional) The distance matrix (lower triangular matrix, column wise storage)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A names list with names &quot;Clusters&quot;, &quot;Total sum of squares&quot;, &quot;Within-cluster sum of squares&quot;, &quot;Total within-cluster sum of squares&quot;, and &quot;The ratio of between to total sum of squares&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
data &lt;- guerry[c('Crm_prs','Crm_prp','Litercy','Donatns','Infants','Suicids')]
azp_clusters &lt;- azp_greedy(5, queen_w, data)
azp_clusters

## End(Not run)
</code></pre>

<hr>
<h2 id='azp_sa'>A simulated annealing algorithm to solve the AZP problem</h2><span id='topic+azp_sa'></span>

<h3>Description</h3>

<p>The automatic zoning procedure (AZP) was initially outlined in Openshaw (1977) as a way to address some of the consequences of the modifiable areal unit problem (MAUP). In essence, it consists of a heuristic to find the best set of combinations of contiguous spatial units into p regions, minimizing the within sum of squares as a criterion of homogeneity. The number of regions needs to be specified beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>azp_sa(
  p,
  w,
  df,
  cooling_rate,
  sa_maxit = 1,
  bound_variable = data.frame(),
  min_bound = 0,
  inits = 0,
  initial_regions = vector("numeric"),
  scale_method = "standardize",
  distance_method = "euclidean",
  random_seed = 123456789,
  rdist = numeric()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="azp_sa_+3A_p">p</code></td>
<td>
<p>The number of spatially constrained clusters</p>
</td></tr>
<tr><td><code id="azp_sa_+3A_w">w</code></td>
<td>
<p>An instance of Weight class</p>
</td></tr>
<tr><td><code id="azp_sa_+3A_df">df</code></td>
<td>
<p>A data frame with selected variables only. E.g. guerry[c(&quot;Crm_prs&quot;, &quot;Crm_prp&quot;, &quot;Litercy&quot;)]</p>
</td></tr>
<tr><td><code id="azp_sa_+3A_cooling_rate">cooling_rate</code></td>
<td>
<p>The cooling rate of a simulated annealing algorithm. Defaults to 0.85</p>
</td></tr>
<tr><td><code id="azp_sa_+3A_sa_maxit">sa_maxit</code></td>
<td>
<p>(optional): The number of iterations of simulated annealing. Defaults to 1</p>
</td></tr>
<tr><td><code id="azp_sa_+3A_bound_variable">bound_variable</code></td>
<td>
<p>(optional) A data frame with selected bound variabl</p>
</td></tr>
<tr><td><code id="azp_sa_+3A_min_bound">min_bound</code></td>
<td>
<p>(optional) A minimum bound value that applies to all clusters</p>
</td></tr>
<tr><td><code id="azp_sa_+3A_inits">inits</code></td>
<td>
<p>(optional) The number of construction re-runs, which is for ARiSeL &quot;automatic regionalization with initial seed location&quot;</p>
</td></tr>
<tr><td><code id="azp_sa_+3A_initial_regions">initial_regions</code></td>
<td>
<p>(optional) The initial regions that the local search starts with. Default is empty. means the local search starts with a random process to &quot;grow&quot; clusters</p>
</td></tr>
<tr><td><code id="azp_sa_+3A_scale_method">scale_method</code></td>
<td>
<p>(optional) One of the scaling methods 'raw', 'standardize', 'demean', 'mad', 'range_standardize', 'range_adjust' to apply on input data. Default is 'standardize' (Z-score normalization).</p>
</td></tr>
<tr><td><code id="azp_sa_+3A_distance_method">distance_method</code></td>
<td>
<p>(optional) The distance method used to compute the distance betwen observation i and j. Defaults to &quot;euclidean&quot;. Options are &quot;euclidean&quot; and &quot;manhattan&quot;</p>
</td></tr>
<tr><td><code id="azp_sa_+3A_random_seed">random_seed</code></td>
<td>
<p>(optional) The seed for random number generator. Defaults to 123456789.</p>
</td></tr>
<tr><td><code id="azp_sa_+3A_rdist">rdist</code></td>
<td>
<p>(optional) The distance matrix (lower triangular matrix, column wise storage)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A names list with names &quot;Clusters&quot;, &quot;Total sum of squares&quot;, &quot;Within-cluster sum of squares&quot;, &quot;Total within-cluster sum of squares&quot;, and &quot;The ratio of between to total sum of squares&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
data &lt;- guerry[c('Crm_prs','Crm_prp','Litercy','Donatns','Infants','Suicids')]
azp_clusters &lt;- azp_sa(5, queen_w, data, cooling_rate = 0.85)
azp_clusters

## End(Not run)
</code></pre>

<hr>
<h2 id='azp_tabu'>A tabu algorithm to solve the AZP problem</h2><span id='topic+azp_tabu'></span>

<h3>Description</h3>

<p>The automatic zoning procedure (AZP) was initially outlined in Openshaw (1977) as a way to address some of the consequences of the modifiable areal unit problem (MAUP). In essence, it consists of a heuristic to find the best set of combinations of contiguous spatial units into p regions, minimizing the within sum of squares as a criterion of homogeneity. The number of regions needs to be specified beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>azp_tabu(
  p,
  w,
  df,
  tabu_length = 10,
  conv_tabu = 10,
  bound_variable = data.frame(),
  min_bound = 0,
  inits = 0,
  initial_regions = vector("numeric"),
  scale_method = "standardize",
  distance_method = "euclidean",
  random_seed = 123456789,
  rdist = numeric()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="azp_tabu_+3A_p">p</code></td>
<td>
<p>The number of spatially constrained clusters</p>
</td></tr>
<tr><td><code id="azp_tabu_+3A_w">w</code></td>
<td>
<p>An instance of Weight class</p>
</td></tr>
<tr><td><code id="azp_tabu_+3A_df">df</code></td>
<td>
<p>A data frame with selected variables only. E.g. guerry[c(&quot;Crm_prs&quot;, &quot;Crm_prp&quot;, &quot;Litercy&quot;)]</p>
</td></tr>
<tr><td><code id="azp_tabu_+3A_tabu_length">tabu_length</code></td>
<td>
<p>The length of a tabu search heuristic of tabu algorithm. e.g. 10.</p>
</td></tr>
<tr><td><code id="azp_tabu_+3A_conv_tabu">conv_tabu</code></td>
<td>
<p>(optional): The number of non-improving moves. Defaults to 10.</p>
</td></tr>
<tr><td><code id="azp_tabu_+3A_bound_variable">bound_variable</code></td>
<td>
<p>(optional) A data frame with selected bound variabl</p>
</td></tr>
<tr><td><code id="azp_tabu_+3A_min_bound">min_bound</code></td>
<td>
<p>(optional) A minimum bound value that applies to all clusters</p>
</td></tr>
<tr><td><code id="azp_tabu_+3A_inits">inits</code></td>
<td>
<p>(optional) The number of construction re-runs, which is for ARiSeL &quot;automatic regionalization with initial seed location&quot;</p>
</td></tr>
<tr><td><code id="azp_tabu_+3A_initial_regions">initial_regions</code></td>
<td>
<p>(optional) The initial regions that the local search starts with. Default is empty. means the local search starts with a random process to &quot;grow&quot; clusters</p>
</td></tr>
<tr><td><code id="azp_tabu_+3A_scale_method">scale_method</code></td>
<td>
<p>(optional) One of the scaling methods 'raw', 'standardize', 'demean', 'mad', 'range_standardize', 'range_adjust' to apply on input data. Default is 'standardize' (Z-score normalization).</p>
</td></tr>
<tr><td><code id="azp_tabu_+3A_distance_method">distance_method</code></td>
<td>
<p>(optional) The distance method used to compute the distance betwen observation i and j. Defaults to &quot;euclidean&quot;. Options are &quot;euclidean&quot; and &quot;manhattan&quot;</p>
</td></tr>
<tr><td><code id="azp_tabu_+3A_random_seed">random_seed</code></td>
<td>
<p>(optional) The seed for random number generator. Defaults to 123456789.</p>
</td></tr>
<tr><td><code id="azp_tabu_+3A_rdist">rdist</code></td>
<td>
<p>(optional) The distance matrix (lower triangular matrix, column wise storage)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A names list with names &quot;Clusters&quot;, &quot;Total sum of squares&quot;, &quot;Within-cluster sum of squares&quot;, &quot;Total within-cluster sum of squares&quot;, and &quot;The ratio of between to total sum of squares&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
data &lt;- guerry[c('Crm_prs','Crm_prp','Litercy','Donatns','Infants','Suicids')]
azp_clusters &lt;- azp_tabu(5, queen_w, data, tabu_length=10, conv_tabu=10)
azp_clusters

## End(Not run)
</code></pre>

<hr>
<h2 id='create_weights'>Create an empty weights</h2><span id='topic+create_weights'></span>

<h3>Description</h3>

<p>Create an empty weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_weights(num_obs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_weights_+3A_num_obs">num_obs</code></td>
<td>
<p>The number of observations for this empty weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of Weight-class
</p>

<hr>
<h2 id='distance_weights'>Distance-based Spatial Weights</h2><span id='topic+distance_weights'></span>

<h3>Description</h3>

<p>Create a distance-based weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_weights(
  sf_obj,
  dist_thres,
  power = 1,
  is_inverse = FALSE,
  is_arc = FALSE,
  is_mile = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_weights_+3A_sf_obj">sf_obj</code></td>
<td>
<p>An sf (simple feature) object</p>
</td></tr>
<tr><td><code id="distance_weights_+3A_dist_thres">dist_thres</code></td>
<td>
<p>A positive numeric value of distance threshold</p>
</td></tr>
<tr><td><code id="distance_weights_+3A_power">power</code></td>
<td>
<p>(optional) The power (or exponent) of a number indicates how
many times to use the number in a multiplication.</p>
</td></tr>
<tr><td><code id="distance_weights_+3A_is_inverse">is_inverse</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, apply inverse on
distance value</p>
</td></tr>
<tr><td><code id="distance_weights_+3A_is_arc">is_arc</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, compute arc distance
between two observations</p>
</td></tr>
<tr><td><code id="distance_weights_+3A_is_mile">is_mile</code></td>
<td>
<p>(optional) TRUE (default) or FALSE, convert distance unit from
mile to km.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of Weight-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
dist_thres &lt;- min_distthreshold(guerry)
dist_w &lt;- distance_weights(guerry, dist_thres)
summary(dist_w)
</code></pre>

<hr>
<h2 id='eb_rates'>Empirical Bayes(EB) Rate</h2><span id='topic+eb_rates'></span>

<h3>Description</h3>

<p>The function to compute EB Rate from an event variable and a
base variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eb_rates(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eb_rates_+3A_df">df</code></td>
<td>
<p>A data frame with two selected variable: one is &quot;event&quot;, anothor is
&quot;base&quot; variable. E.g. guerry[c(&quot;hr60&quot;, &quot;po60&quot;)]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with two columns &quot;EB Rate&quot; and &quot;IsNull&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
nat &lt;- st_read("natregimes.shp")
ebr &lt;- eb_rates(nat[c("HR60", "PO60")])
ebr

## End(Not run)
</code></pre>

<hr>
<h2 id='gda_distance_weights'>(For internally use and test only) Distance-based Spatial Weights</h2><span id='topic+gda_distance_weights'></span>

<h3>Description</h3>

<p>Create a distance-based weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gda_distance_weights(
  geoda_obj,
  dist_thres,
  power = 1,
  is_inverse = FALSE,
  is_arc = FALSE,
  is_mile = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gda_distance_weights_+3A_geoda_obj">geoda_obj</code></td>
<td>
<p>An instance of geoda-class</p>
</td></tr>
<tr><td><code id="gda_distance_weights_+3A_dist_thres">dist_thres</code></td>
<td>
<p>A positive numeric value of distance threshold</p>
</td></tr>
<tr><td><code id="gda_distance_weights_+3A_power">power</code></td>
<td>
<p>(optional) The power (or exponent) of a number indicates how
many times to use the number in a multiplication.</p>
</td></tr>
<tr><td><code id="gda_distance_weights_+3A_is_inverse">is_inverse</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, apply inverse on
distance value</p>
</td></tr>
<tr><td><code id="gda_distance_weights_+3A_is_arc">is_arc</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, compute arc distance
between two observations</p>
</td></tr>
<tr><td><code id="gda_distance_weights_+3A_is_mile">is_mile</code></td>
<td>
<p>(optional) TRUE (default) or FALSE, convert distance unit from
mile to km.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of Weight-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- geoda_open(guerry_path)
dist_thres &lt;- gda_min_distthreshold(guerry)
dist_w &lt;- gda_distance_weights(guerry, dist_thres)
summary(dist_w)

## End(Not run)
</code></pre>

<hr>
<h2 id='gda_kernel_knn_weights'>(For internally use and test only) K-NN Kernel Spatial Weights</h2><span id='topic+gda_kernel_knn_weights'></span>

<h3>Description</h3>

<p>Create a kernel weights by specifying k-nearest neighbors and a
kernel method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gda_kernel_knn_weights(
  geoda_obj,
  k,
  kernel_method,
  adaptive_bandwidth = TRUE,
  use_kernel_diagonals = FALSE,
  power = 1,
  is_inverse = FALSE,
  is_arc = FALSE,
  is_mile = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gda_kernel_knn_weights_+3A_geoda_obj">geoda_obj</code></td>
<td>
<p>An instance of geoda</p>
</td></tr>
<tr><td><code id="gda_kernel_knn_weights_+3A_k">k</code></td>
<td>
<p>a positive integer number for k-nearest neighbors</p>
</td></tr>
<tr><td><code id="gda_kernel_knn_weights_+3A_kernel_method">kernel_method</code></td>
<td>
<p>a string value, which has to be one of 'triangular',
'uniform', 'epanechnikov', 'quartic', 'gaussian'</p>
</td></tr>
<tr><td><code id="gda_kernel_knn_weights_+3A_adaptive_bandwidth">adaptive_bandwidth</code></td>
<td>
<p>(optional) TRUE (default) or FALSE: TRUE use
adaptive bandwidth calculated using distance of k-nearest neithbors,
FALSE use max distance of all observation to their k-nearest neighbors</p>
</td></tr>
<tr><td><code id="gda_kernel_knn_weights_+3A_use_kernel_diagonals">use_kernel_diagonals</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, apply kernel
on the diagonal of weights matrix</p>
</td></tr>
<tr><td><code id="gda_kernel_knn_weights_+3A_power">power</code></td>
<td>
<p>(optional) The power (or exponent) of a number says how many
times to use the number in a multiplication.</p>
</td></tr>
<tr><td><code id="gda_kernel_knn_weights_+3A_is_inverse">is_inverse</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, apply inverse on
distance value</p>
</td></tr>
<tr><td><code id="gda_kernel_knn_weights_+3A_is_arc">is_arc</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, compute arc distance
between two observations</p>
</td></tr>
<tr><td><code id="gda_kernel_knn_weights_+3A_is_mile">is_mile</code></td>
<td>
<p>(optional) TRUE (default) or FALSE, convert distance unit from
mile to km.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of Weight-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- geoda_open(guerry_path)
adptkernel_w = gda_kernel_knn_weights(guerry, 6, "uniform")
summary(adptkernel_w)

## End(Not run)
</code></pre>

<hr>
<h2 id='gda_kernel_weights'>(For internally use and test only) Distance-based Kernel Spatial
Weights</h2><span id='topic+gda_kernel_weights'></span>

<h3>Description</h3>

<p>Create a kernel weights by specifying a bandwidth and a kernel
method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gda_kernel_weights(
  geoda_obj,
  bandwidth,
  kernel_method,
  use_kernel_diagonals = FALSE,
  power = 1,
  is_inverse = FALSE,
  is_arc = FALSE,
  is_mile = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gda_kernel_weights_+3A_geoda_obj">geoda_obj</code></td>
<td>
<p>An instance of geoda-class</p>
</td></tr>
<tr><td><code id="gda_kernel_weights_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive numeric value of bandwidth</p>
</td></tr>
<tr><td><code id="gda_kernel_weights_+3A_kernel_method">kernel_method</code></td>
<td>
<p>a string value, which has to be one of 'triangular',
'uniform', 'epanechnikov', 'quartic', 'gaussian'</p>
</td></tr>
<tr><td><code id="gda_kernel_weights_+3A_use_kernel_diagonals">use_kernel_diagonals</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, apply kernel
on the diagonal of weights matrix</p>
</td></tr>
<tr><td><code id="gda_kernel_weights_+3A_power">power</code></td>
<td>
<p>(optional) The power (or exponent) of a number says how many
times to use the number in a multiplication.</p>
</td></tr>
<tr><td><code id="gda_kernel_weights_+3A_is_inverse">is_inverse</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, apply inverse on
distance value</p>
</td></tr>
<tr><td><code id="gda_kernel_weights_+3A_is_arc">is_arc</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, compute arc distance
between two observations</p>
</td></tr>
<tr><td><code id="gda_kernel_weights_+3A_is_mile">is_mile</code></td>
<td>
<p>(optional) TRUE (default) or FALSE, convert distance unit from
mile to km.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of Weight-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- geoda_open(guerry_path)
bandwidth &lt;- gda_min_distthreshold(guerry)
kernel_w &lt;- gda_kernel_weights(guerry, bandwidth, kernel_method = "uniform")
summary(kernel_w)

## End(Not run)
</code></pre>

<hr>
<h2 id='gda_knn_weights'>(For internally use and test only) K-Nearest Neighbors-based Spatial
Weights</h2><span id='topic+gda_knn_weights'></span>

<h3>Description</h3>

<p>Create a k-nearest neighbors based spatial weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gda_knn_weights(
  geoda_obj,
  k,
  power = 1,
  is_inverse = FALSE,
  is_arc = FALSE,
  is_mile = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gda_knn_weights_+3A_geoda_obj">geoda_obj</code></td>
<td>
<p>An instance of geoda</p>
</td></tr>
<tr><td><code id="gda_knn_weights_+3A_k">k</code></td>
<td>
<p>a positive integer number for k-nearest neighbors</p>
</td></tr>
<tr><td><code id="gda_knn_weights_+3A_power">power</code></td>
<td>
<p>(optional) The power (or exponent) of a number says how many
times to use the number in a multiplication.</p>
</td></tr>
<tr><td><code id="gda_knn_weights_+3A_is_inverse">is_inverse</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, apply inverse on
distance value</p>
</td></tr>
<tr><td><code id="gda_knn_weights_+3A_is_arc">is_arc</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, compute arc distance
between two observations</p>
</td></tr>
<tr><td><code id="gda_knn_weights_+3A_is_mile">is_mile</code></td>
<td>
<p>(optional) TRUE (default) or FALSE, convert distance unit
from mile to km.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of Weight-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- geoda_open(guerry_path)
knn6_w &lt;- gda_knn_weights(guerry, 6)
summary(knn6_w)

## End(Not run)
</code></pre>

<hr>
<h2 id='gda_min_distthreshold'>(For internally use and test only) Minimum Distance Threshold for
Distance-based Weights</h2><span id='topic+gda_min_distthreshold'></span>

<h3>Description</h3>

<p>Get minimum threshold of distance that makes sure each
observation has at least one neighbor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gda_min_distthreshold(geoda_obj, is_arc = FALSE, is_mile = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gda_min_distthreshold_+3A_geoda_obj">geoda_obj</code></td>
<td>
<p>An instance of geoda-class</p>
</td></tr>
<tr><td><code id="gda_min_distthreshold_+3A_is_arc">is_arc</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, compute arc distance
between two observations</p>
</td></tr>
<tr><td><code id="gda_min_distthreshold_+3A_is_mile">is_mile</code></td>
<td>
<p>(optional) TRUE (default) or FALSE, if 'is_arc' option is
TRUE, then 'is_mile' will set distance unit to 'mile' or 'km'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value of minimum threshold of distance
</p>

<hr>
<h2 id='gda_queen_weights'>(For internally use and test only) Queen Contiguity Spatial Weights</h2><span id='topic+gda_queen_weights'></span>

<h3>Description</h3>

<p>Create a Queen contiguity weights with options of &quot;order&quot;,
&quot;include lower order&quot; and &quot;precision threshold&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gda_queen_weights(
  geoda_obj,
  order = 1,
  include_lower_order = FALSE,
  precision_threshold = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gda_queen_weights_+3A_geoda_obj">geoda_obj</code></td>
<td>
<p>An object of [geoda] class</p>
</td></tr>
<tr><td><code id="gda_queen_weights_+3A_order">order</code></td>
<td>
<p>(Optional) Order of contiguity</p>
</td></tr>
<tr><td><code id="gda_queen_weights_+3A_include_lower_order">include_lower_order</code></td>
<td>
<p>(Optional)  Whether or not the lower order
neighbors should be included in the weights structure</p>
</td></tr>
<tr><td><code id="gda_queen_weights_+3A_precision_threshold">precision_threshold</code></td>
<td>
<p>(Optional) The precision of the underlying shape
file is insufficient to allow for an exact match of coordinates to determine
which polygons are neighbors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of Weight-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- geoda_open(guerry_path)
queen_w &lt;- gda_queen_weights(guerry)
summary(queen_w)

## End(Not run)
</code></pre>

<hr>
<h2 id='gda_rook_weights'>(For internally use and test only) Rook Contiguity Spatial Weights</h2><span id='topic+gda_rook_weights'></span>

<h3>Description</h3>

<p>Create a Rook contiguity weights with options of &quot;order&quot;,
&quot;include lower order&quot; and &quot;precision threshold&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gda_rook_weights(
  geoda_obj,
  order = 1,
  include_lower_order = FALSE,
  precision_threshold = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gda_rook_weights_+3A_geoda_obj">geoda_obj</code></td>
<td>
<p>An object of [geoda] class</p>
</td></tr>
<tr><td><code id="gda_rook_weights_+3A_order">order</code></td>
<td>
<p>(Optional) Order of contiguity</p>
</td></tr>
<tr><td><code id="gda_rook_weights_+3A_include_lower_order">include_lower_order</code></td>
<td>
<p>(Optional)  Whether or not the lower order
neighbors should be included in the weights structure</p>
</td></tr>
<tr><td><code id="gda_rook_weights_+3A_precision_threshold">precision_threshold</code></td>
<td>
<p>(Optional) The precision of the underlying shape
file is insufficient to allow for an exact match of coordinates to determine
which polygons are neighbors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of Weight-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- geoda_open(guerry_path)
rook_w &lt;- gda_rook_weights(guerry)
summary(rook_w)

## End(Not run)
</code></pre>

<hr>
<h2 id='geoda_open'>Create an instance of geoda-class by reading from an ESRI Shapefile
dataset</h2><span id='topic+geoda_open'></span>

<h3>Description</h3>

<p>Create an instance of geoda-class by reading from an ESRI
Shapefile dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geoda_open(ds_path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geoda_open_+3A_ds_path">ds_path</code></td>
<td>
<p>(character) The path of the spatial dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of geoda-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- geoda_open(guerry_path)
guerry_df &lt;- as.data.frame(guerry) # access as a data.frame
head(guerry_df)

## End(Not run)
</code></pre>

<hr>
<h2 id='geoda-class'>'geoda' class</h2><span id='topic+geoda-class'></span><span id='topic+geoda'></span>

<h3>Description</h3>

<p>'geoda' is a RefClass that wraps the C++ GeoDa class
(via p_GeoDa defines in rgeoda.R)
</p>


<h3>Fields</h3>


<dl>
<dt><code>gda</code></dt><dd><p>The pointer to the instance of p_GeoDa-class</p>
</dd>
<dt><code>map_type</code></dt><dd><p>The map type, could be either Point or Polygon</p>
</dd>
<dt><code>n_cols</code></dt><dd><p>The number of columns</p>
</dd>
<dt><code>n_obs</code></dt><dd><p>The number of observations</p>
</dd>
<dt><code>field_names</code></dt><dd><p>A string vector of field names</p>
</dd>
<dt><code>field_types</code></dt><dd><p>A string vector of field types  (integer, real, string)</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>GetFieldNames(...)</code></dt><dd><p>Get the field names of all columns</p>
</dd>
<dt><code>GetFieldTypes(...)</code></dt><dd><p>Get the field types (integer, real, string) of all columns</p>
</dd>
<dt><code>GetIntegerCol(col_name)</code></dt><dd><p>Get the integer values from a column</p>
</dd>
<dt><code>GetMapType(...)</code></dt><dd><p>Get the map type</p>
</dd>
<dt><code>GetNumCols(...)</code></dt><dd><p>Get the number of columns</p>
</dd>
<dt><code>GetNumObs(...)</code></dt><dd><p>Get the number of observations</p>
</dd>
<dt><code>GetPointer()</code></dt><dd><p>Get the C++ object pointer (internally used)</p>
</dd>
<dt><code>GetRealCol(col_name)</code></dt><dd><p>Get the real values from a column</p>
</dd>
<dt><code>GetUndefinedVals(col_name)</code></dt><dd><p>Get the undefined flags from a column</p>
</dd>
<dt><code>initialize(o_gda)</code></dt><dd><p>Constructor with a geoda object (internally used)</p>
</dd>
</dl>

<hr>
<h2 id='get_neighbors'>Neighbors of one observation</h2><span id='topic+get_neighbors'></span>

<h3>Description</h3>

<p>Get neighbors for idx-th observation, idx starts from 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_neighbors(gda_w, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_neighbors_+3A_gda_w">gda_w</code></td>
<td>
<p>A Weight object</p>
</td></tr>
<tr><td><code id="get_neighbors_+3A_idx">idx</code></td>
<td>
<p>A value indicates idx-th observation, idx start from 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the neighbor indices, which start from 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
nbrs &lt;- get_neighbors(queen_w, idx = 1)
cat("\nNeighbors of the 1-st observation are:", nbrs)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_neighbors_weights'>Weights values of the neighbors of one observation</h2><span id='topic+get_neighbors_weights'></span>

<h3>Description</h3>

<p>Get the associated weights values of neighbors for idx-th
observation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_neighbors_weights(gda_w, idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_neighbors_weights_+3A_gda_w">gda_w</code></td>
<td>
<p>A Weight object</p>
</td></tr>
<tr><td><code id="get_neighbors_weights_+3A_idx">idx</code></td>
<td>
<p>A value indicates idx-th observation, idx start from 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the neighbor indices, which start from 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
nbrs &lt;- get_neighbors_weights(queen_w, idx = 1)
cat("\nNeighbors of the 1-st observation are:", nbrs)

## End(Not run)
</code></pre>

<hr>
<h2 id='has_isolates'>Isolation/Island in Spatial Weights</h2><span id='topic+has_isolates'></span>

<h3>Description</h3>

<p>Check if weights matrix has isolates, or if any observation has
no neighbors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_isolates(gda_w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_isolates_+3A_gda_w">gda_w</code></td>
<td>
<p>A Weight object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean value indicates if weights matrix is symmetric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
has_isolates(queen_w)

## End(Not run)
</code></pre>

<hr>
<h2 id='hinge15_breaks'>(Box) Hinge15 Breaks</h2><span id='topic+hinge15_breaks'></span>

<h3>Description</h3>

<p>Hinge15 breaks data into 6 groups like box plot groups
(Lower outlier, &lt; 25
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hinge15_breaks(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hinge15_breaks_+3A_df">df</code></td>
<td>
<p>A data frame with selected variable. E.g. guerry[&quot;Crm_prs&quot;]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numeric values of computed breaks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
hinge15_breaks(guerry['Crm_prs'])
</code></pre>

<hr>
<h2 id='hinge30_breaks'>(Box) Hinge30 Breaks</h2><span id='topic+hinge30_breaks'></span>

<h3>Description</h3>

<p>Hinge30 breaks data into 6 groups like box plot groups
(Lower outlier, &lt; 25
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hinge30_breaks(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hinge30_breaks_+3A_df">df</code></td>
<td>
<p>A data frame with selected variable. E.g. guerry[&quot;Crm_prs&quot;]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numeric values of computed breaks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
hinge30_breaks(guerry['Crm_prs'])
</code></pre>

<hr>
<h2 id='is_symmetric'>Symmetry of Weights Matrix</h2><span id='topic+is_symmetric'></span>

<h3>Description</h3>

<p>Check if weights matrix is symmetric
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_symmetric(gda_w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_symmetric_+3A_gda_w">gda_w</code></td>
<td>
<p>A Weight object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean value indicates if weights matrix is symmetric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
is_symmetric(queen_w)

## End(Not run)
</code></pre>

<hr>
<h2 id='join_count_ratio'>Join Count Ratio</h2><span id='topic+join_count_ratio'></span>

<h3>Description</h3>

<p>Join count ratio is the join counts, the number of times a category is surrounded
by neighbors of the same category, over the total number of neighbors after converting
each category to a dummy variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>join_count_ratio(clusters, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="join_count_ratio_+3A_clusters">clusters</code></td>
<td>
<p>A cluster classification variable (categorical values from a dataframe or values returned from cluster functions)</p>
</td></tr>
<tr><td><code id="join_count_ratio_+3A_w">w</code></td>
<td>
<p>An instance of Weight class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with names &quot;Cluster&quot;, &quot;N&quot;, &quot;Neighbors&quot;, &quot;Join Count&quot;, &quot;Ratio&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
data &lt;- guerry[c('Crm_prs','Crm_prp','Litercy','Donatns','Infants','Suicids')]
clusters &lt;- skater(5, queen_w, data)
results &lt;- join_count_ratio(clusters, queen_w)
results

## End(Not run)
</code></pre>

<hr>
<h2 id='kernel_knn_weights'>K-NN Kernel Spatial Weights</h2><span id='topic+kernel_knn_weights'></span>

<h3>Description</h3>

<p>Create a kernel weights by specifying k-nearest neighbors and a
kernel method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_knn_weights(
  sf_obj,
  k,
  kernel_method,
  adaptive_bandwidth = TRUE,
  use_kernel_diagonals = FALSE,
  power = 1,
  is_inverse = FALSE,
  is_arc = FALSE,
  is_mile = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_knn_weights_+3A_sf_obj">sf_obj</code></td>
<td>
<p>An sf (simple feature) object</p>
</td></tr>
<tr><td><code id="kernel_knn_weights_+3A_k">k</code></td>
<td>
<p>a positive integer number for k-nearest neighbors</p>
</td></tr>
<tr><td><code id="kernel_knn_weights_+3A_kernel_method">kernel_method</code></td>
<td>
<p>a string value, which has to be one of 'triangular',
'uniform', 'epanechnikov', 'quartic', 'gaussian'</p>
</td></tr>
<tr><td><code id="kernel_knn_weights_+3A_adaptive_bandwidth">adaptive_bandwidth</code></td>
<td>
<p>(optional) TRUE (default) or FALSE: TRUE use
adaptive bandwidth calculated using distance of k-nearest neithbors,
FALSE use max distance of all observation to their k-nearest neighbors</p>
</td></tr>
<tr><td><code id="kernel_knn_weights_+3A_use_kernel_diagonals">use_kernel_diagonals</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, apply kernel
on the diagonal of weights matrix</p>
</td></tr>
<tr><td><code id="kernel_knn_weights_+3A_power">power</code></td>
<td>
<p>(optional) The power (or exponent) of a number says how many
times to use the number in a multiplication.</p>
</td></tr>
<tr><td><code id="kernel_knn_weights_+3A_is_inverse">is_inverse</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, apply inverse on
distance value</p>
</td></tr>
<tr><td><code id="kernel_knn_weights_+3A_is_arc">is_arc</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, compute arc distance
between two observations</p>
</td></tr>
<tr><td><code id="kernel_knn_weights_+3A_is_mile">is_mile</code></td>
<td>
<p>(optional) TRUE (default) or FALSE, convert distance unit from
mile to km.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of Weight-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
adptkernel_w = kernel_knn_weights(guerry, 6, "uniform")
summary(adptkernel_w)
</code></pre>

<hr>
<h2 id='kernel_weights'>Distance-based Kernel Spatial Weights</h2><span id='topic+kernel_weights'></span>

<h3>Description</h3>

<p>Create a kernel weights by specifying a bandwidth and a kernel
method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_weights(
  sf_obj,
  bandwidth,
  kernel_method,
  use_kernel_diagonals = FALSE,
  power = 1,
  is_inverse = FALSE,
  is_arc = FALSE,
  is_mile = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_weights_+3A_sf_obj">sf_obj</code></td>
<td>
<p>An sf (simple feature) object</p>
</td></tr>
<tr><td><code id="kernel_weights_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive numeric value of bandwidth</p>
</td></tr>
<tr><td><code id="kernel_weights_+3A_kernel_method">kernel_method</code></td>
<td>
<p>a string value, which has to be one of 'triangular',
'uniform', 'epanechnikov', 'quartic', 'gaussian'</p>
</td></tr>
<tr><td><code id="kernel_weights_+3A_use_kernel_diagonals">use_kernel_diagonals</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, apply kernel
on the diagonal of weights matrix</p>
</td></tr>
<tr><td><code id="kernel_weights_+3A_power">power</code></td>
<td>
<p>(optional) The power (or exponent) of a number says how many
times to use the number in a multiplication.</p>
</td></tr>
<tr><td><code id="kernel_weights_+3A_is_inverse">is_inverse</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, apply inverse on
distance value</p>
</td></tr>
<tr><td><code id="kernel_weights_+3A_is_arc">is_arc</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, compute arc distance
between two observations</p>
</td></tr>
<tr><td><code id="kernel_weights_+3A_is_mile">is_mile</code></td>
<td>
<p>(optional) TRUE (default) or FALSE, convert distance unit from
mile to km.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of Weight-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
bandwidth &lt;- min_distthreshold(guerry)
kernel_w &lt;- kernel_weights(guerry, bandwidth, kernel_method = "uniform")
summary(kernel_w)
</code></pre>

<hr>
<h2 id='knn_weights'>K-Nearest Neighbors-based Spatial Weights</h2><span id='topic+knn_weights'></span>

<h3>Description</h3>

<p>Create a k-nearest neighbors based spatial weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knn_weights(
  sf_obj,
  k,
  power = 1,
  is_inverse = FALSE,
  is_arc = FALSE,
  is_mile = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knn_weights_+3A_sf_obj">sf_obj</code></td>
<td>
<p>An sf (simple feature) object</p>
</td></tr>
<tr><td><code id="knn_weights_+3A_k">k</code></td>
<td>
<p>a positive integer number for k-nearest neighbors</p>
</td></tr>
<tr><td><code id="knn_weights_+3A_power">power</code></td>
<td>
<p>(optional) The power (or exponent) of a number says how many
times to use the number in a multiplication.</p>
</td></tr>
<tr><td><code id="knn_weights_+3A_is_inverse">is_inverse</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, apply inverse on
distance value</p>
</td></tr>
<tr><td><code id="knn_weights_+3A_is_arc">is_arc</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, compute arc distance
between two observations</p>
</td></tr>
<tr><td><code id="knn_weights_+3A_is_mile">is_mile</code></td>
<td>
<p>(optional) TRUE (default) or FALSE, convert distance unit from
mile to km.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of Weight-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
knn6_w &lt;- knn_weights(guerry, 6)
summary(knn6_w)
</code></pre>

<hr>
<h2 id='lisa_bo'>Bonferroni bound value of local spatial autocorrelation</h2><span id='topic+lisa_bo'></span>

<h3>Description</h3>

<p>Get Bonferroni bound value based on current LISA computation
and current significat p-value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lisa_bo(gda_lisa, current_p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lisa_bo_+3A_gda_lisa">gda_lisa</code></td>
<td>
<p>An instance of LISA object</p>
</td></tr>
<tr><td><code id="lisa_bo_+3A_current_p">current_p</code></td>
<td>
<p>A value of current siginificant p-value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value of Bonferroni bound
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
lisa &lt;- local_moran(queen_w, guerry["Crm_prs"])
bo &lt;- lisa_bo(lisa, 0.05)
bo

## End(Not run)
</code></pre>

<hr>
<h2 id='lisa_clusters'>Get local cluster indicators</h2><span id='topic+lisa_clusters'></span>

<h3>Description</h3>

<p>Get the local cluster indicators returned from LISA computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lisa_clusters(gda_lisa, cutoff = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lisa_clusters_+3A_gda_lisa">gda_lisa</code></td>
<td>
<p>An instance of LISA object</p>
</td></tr>
<tr><td><code id="lisa_clusters_+3A_cutoff">cutoff</code></td>
<td>
<p>A value of cutoff for significance p-values to filter
not-significant clusters, default=0.0, means not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of LISA cluster indicator
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
lisa &lt;- local_moran(queen_w, guerry["Crm_prs"])
clsts &lt;- lisa_clusters(lisa)
clsts

## End(Not run)
</code></pre>

<hr>
<h2 id='lisa_colors'>Get cluster colors</h2><span id='topic+lisa_colors'></span>

<h3>Description</h3>

<p>Get the cluster colors of LISA computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lisa_colors(gda_lisa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lisa_colors_+3A_gda_lisa">gda_lisa</code></td>
<td>
<p>An instance of LISA object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string vector of cluster colors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
lisa &lt;- local_moran(queen_w, guerry["Crm_prs"])
clrs &lt;- lisa_colors(lisa)
clrs

## End(Not run)
</code></pre>

<hr>
<h2 id='lisa_fdr'>False Discovery Rate value of local spatial autocorrelation</h2><span id='topic+lisa_fdr'></span>

<h3>Description</h3>

<p>Get False Discovery Rate value based on current LISA
computation and current significant p-value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lisa_fdr(gda_lisa, current_p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lisa_fdr_+3A_gda_lisa">gda_lisa</code></td>
<td>
<p>An instance of LISA object</p>
</td></tr>
<tr><td><code id="lisa_fdr_+3A_current_p">current_p</code></td>
<td>
<p>A value of current siginificant p-value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of False Discovery Rate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
lisa &lt;- local_moran(queen_w, guerry["Crm_prs"])
fdr &lt;- lisa_fdr(lisa, 0.05)
fdr

## End(Not run)
</code></pre>

<hr>
<h2 id='lisa_labels'>Get cluster labels</h2><span id='topic+lisa_labels'></span>

<h3>Description</h3>

<p>Get cluster labels of LISA computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lisa_labels(gda_lisa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lisa_labels_+3A_gda_lisa">gda_lisa</code></td>
<td>
<p>An instance of LISA object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string vector of cluster labels
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
lisa &lt;- local_moran(queen_w, guerry["Crm_prs"])
lbls &lt;- lisa_labels(lisa)
lbls

## End(Not run)
</code></pre>

<hr>
<h2 id='lisa_num_nbrs'>Get numbers of neighbors for all observations</h2><span id='topic+lisa_num_nbrs'></span>

<h3>Description</h3>

<p>Get numbers of neighbors for all observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lisa_num_nbrs(gda_lisa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lisa_num_nbrs_+3A_gda_lisa">gda_lisa</code></td>
<td>
<p>An instance of LISA object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the number of neighbors
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
lisa &lt;- local_moran(queen_w, guerry["Crm_prs"])
nn &lt;- lisa_num_nbrs(lisa)
nn

## End(Not run)
</code></pre>

<hr>
<h2 id='lisa_pvalues'>Get pseudo-p values of LISA</h2><span id='topic+lisa_pvalues'></span>

<h3>Description</h3>

<p>Get the local pseudo-p values of significance returned from
LISA computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lisa_pvalues(gda_lisa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lisa_pvalues_+3A_gda_lisa">gda_lisa</code></td>
<td>
<p>An instance of LISA object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of pseudo-p values of local spatial autocorrelation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
lisa &lt;- local_moran(queen_w, guerry["Crm_prs"])
pvals &lt;- lisa_pvalues(lisa)
pvals

## End(Not run)
</code></pre>

<hr>
<h2 id='lisa_values'>Get LISA values</h2><span id='topic+lisa_values'></span>

<h3>Description</h3>

<p>Get the local spatial autocorrelation values returned from
LISA computation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lisa_values(gda_lisa)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lisa_values_+3A_gda_lisa">gda_lisa</code></td>
<td>
<p>An instance of LISA object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of local spatial autocorrelation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
lisa &lt;- local_moran(queen_w, guerry["Crm_prs"])
lms &lt;- lisa_values(lisa)
lms

## End(Not run)
</code></pre>

<hr>
<h2 id='LISA-class'>LISA class (Internally Used)</h2><span id='topic+LISA-class'></span><span id='topic+LISA'></span>

<h3>Description</h3>

<p>A LISA-class that wrappers the statistics of LISA computation
</p>


<h3>Fields</h3>


<dl>
<dt><code>gda_lisa</code></dt><dd><p>An object of GeoDaLISA</p>
</dd>
<dt><code>p_vals</code></dt><dd><p>The pseudo-p values of significance of LISA computation</p>
</dd>
<dt><code>c_vals</code></dt><dd><p>The cluster indicators of LISA computation</p>
</dd>
<dt><code>lisa_vals</code></dt><dd><p>The local spatial autocorrelation values of LISA computation</p>
</dd>
<dt><code>nn_vals</code></dt><dd><p>The number of neighbors of every observations in LISA
computation</p>
</dd>
<dt><code>labels</code></dt><dd><p>The cluster labels of LISA</p>
</dd>
<dt><code>colors</code></dt><dd><p>The cluster colors (HEX format) of LISA</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>GetBO(current_p)</code></dt><dd><p>Get the Bonferroni bound value</p>
</dd>
<dt><code>GetClusterIndicators()</code></dt><dd><p>Get the local cluster indicators returned from LISA computation.</p>
</dd>
<dt><code>GetColors()</code></dt><dd><p>Get the cluster colors of LISA computation.</p>
</dd>
<dt><code>GetFDR(current_p)</code></dt><dd><p>Get the False Discovery Rate value</p>
</dd>
<dt><code>GetLISAValues()</code></dt><dd><p>Get the local spatial autocorrelation values returned from LISA
computation.</p>
</dd>
<dt><code>GetLabels()</code></dt><dd><p>Get the cluster labels of LISA computation.</p>
</dd>
<dt><code>GetLocalSignificanceValues()</code></dt><dd><p>Get the local pseudo-p values of significance returned from LISA
computation.</p>
</dd>
<dt><code>GetNumNeighbors()</code></dt><dd><p>Get the number of neighbors of every observations in LISA computation.</p>
</dd>
<dt><code>Run()</code></dt><dd><p>Call to run LISA computation</p>
</dd>
<dt><code>SetPermutations(num_perm)</code></dt><dd><p>Set the number of permutations for the LISA computation</p>
</dd>
<dt><code>SetSignificanceCutoff(cutoff)</code></dt><dd><p>Set the cutoff value of significance values</p>
</dd>
<dt><code>SetThreads(num_threads)</code></dt><dd><p>Set the number of CPU threads for the LISA computation</p>
</dd>
<dt><code>initialize(lisa_obj)</code></dt><dd><p>Constructor with a LISA object (internally used)</p>
</dd>
</dl>

<hr>
<h2 id='local_bijoincount'>Bivariate Local Join Count Statistics</h2><span id='topic+local_bijoincount'></span>

<h3>Description</h3>

<p>The function to apply local Bivariate Join Count statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_bijoincount(
  w,
  df,
  permutations = 999,
  permutation_method = "complete",
  significance_cutoff = 0.05,
  cpu_threads = 6,
  seed = 123456789
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_bijoincount_+3A_w">w</code></td>
<td>
<p>An instance of Weight object</p>
</td></tr>
<tr><td><code id="local_bijoincount_+3A_df">df</code></td>
<td>
<p>A data frame with two selected variable.
E.g. guerry[c(&quot;TopCrm&quot;, &quot;InvCrm&quot;)]</p>
</td></tr>
<tr><td><code id="local_bijoincount_+3A_permutations">permutations</code></td>
<td>
<p>(optional) The number of permutations for the LISA
computation</p>
</td></tr>
<tr><td><code id="local_bijoincount_+3A_permutation_method">permutation_method</code></td>
<td>
<p>(optional) The permutation method used for the
LISA computation. Options are 'complete', 'lookup'. Default is 'complete'.</p>
</td></tr>
<tr><td><code id="local_bijoincount_+3A_significance_cutoff">significance_cutoff</code></td>
<td>
<p>(optional) A cutoff value for significance
p-values to filter not-significant clusters</p>
</td></tr>
<tr><td><code id="local_bijoincount_+3A_cpu_threads">cpu_threads</code></td>
<td>
<p>(optional) The number of cpu threads used for parallel
LISA computation</p>
</td></tr>
<tr><td><code id="local_bijoincount_+3A_seed">seed</code></td>
<td>
<p>(optional) The seed for random number generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of LISA-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
guerry["InvCrm"] &lt;-  1 - guerry[["TopCrm"]]
lisa &lt;- local_bijoincount(queen_w, guerry[c("TopCrm", "InvCrm")])
clsts&lt;- lisa_clusters(lisa)
clsts
</code></pre>

<hr>
<h2 id='local_bimoran'>Bivariate Local Moran Statistics</h2><span id='topic+local_bimoran'></span>

<h3>Description</h3>

<p>The function to apply bivariate local Moran statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_bimoran(
  w,
  df,
  permutations = 999,
  permutation_method = "complete",
  significance_cutoff = 0.05,
  cpu_threads = 6,
  seed = 123456789
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_bimoran_+3A_w">w</code></td>
<td>
<p>An instance of Weight object</p>
</td></tr>
<tr><td><code id="local_bimoran_+3A_df">df</code></td>
<td>
<p>A data frame with two selected variable. E.g. guerry[c('Crm_prs','Litercy')]</p>
</td></tr>
<tr><td><code id="local_bimoran_+3A_permutations">permutations</code></td>
<td>
<p>(optional) The number of permutations for the LISA
computation</p>
</td></tr>
<tr><td><code id="local_bimoran_+3A_permutation_method">permutation_method</code></td>
<td>
<p>(optional) The permutation method used for the
LISA computation. Options are 'complete', 'lookup'. Default is 'complete'.</p>
</td></tr>
<tr><td><code id="local_bimoran_+3A_significance_cutoff">significance_cutoff</code></td>
<td>
<p>(optional) A cutoff value for significance
p-values to filter not-significant clusters</p>
</td></tr>
<tr><td><code id="local_bimoran_+3A_cpu_threads">cpu_threads</code></td>
<td>
<p>(optional) The number of cpu threads used for parallel
LISA computation</p>
</td></tr>
<tr><td><code id="local_bimoran_+3A_seed">seed</code></td>
<td>
<p>(optional) The seed for random number generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of LISA-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
lisa &lt;- local_bimoran(queen_w, guerry[c('Crm_prs','Litercy')])
lms &lt;- lisa_values(lisa)
lms
</code></pre>

<hr>
<h2 id='local_g'>Local Getis-Ord's G Statistics</h2><span id='topic+local_g'></span>

<h3>Description</h3>

<p>The function to apply Getis-Ord's local G statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_g(
  w,
  df,
  permutations = 999,
  permutation_method = "complete",
  significance_cutoff = 0.05,
  cpu_threads = 6,
  seed = 123456789
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_g_+3A_w">w</code></td>
<td>
<p>An instance of Weight object</p>
</td></tr>
<tr><td><code id="local_g_+3A_df">df</code></td>
<td>
<p>A data frame with selected variable only. E.g. guerry[&quot;Crm_prs&quot;]</p>
</td></tr>
<tr><td><code id="local_g_+3A_permutations">permutations</code></td>
<td>
<p>(optional) The number of permutations for the LISA
computation</p>
</td></tr>
<tr><td><code id="local_g_+3A_permutation_method">permutation_method</code></td>
<td>
<p>(optional) The permutation method used for the
LISA computation. Options are 'complete', 'lookup'. Default is 'complete'.</p>
</td></tr>
<tr><td><code id="local_g_+3A_significance_cutoff">significance_cutoff</code></td>
<td>
<p>(optional) A cutoff value for significance
p-values to filter not-significant clusters</p>
</td></tr>
<tr><td><code id="local_g_+3A_cpu_threads">cpu_threads</code></td>
<td>
<p>(optional) The number of cpu threads used for parallel
LISA computation</p>
</td></tr>
<tr><td><code id="local_g_+3A_seed">seed</code></td>
<td>
<p>(optional) The seed for random number generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of LISA-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
lisa &lt;- local_g(queen_w, guerry["Crm_prs"])
lms &lt;- lisa_values(lisa)
lms
</code></pre>

<hr>
<h2 id='local_geary'>Local Geary Statistics</h2><span id='topic+local_geary'></span>

<h3>Description</h3>

<p>The function to apply local Geary statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_geary(
  w,
  df,
  permutations = 999,
  permutation_method = "complete",
  significance_cutoff = 0.05,
  cpu_threads = 6,
  seed = 123456789
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_geary_+3A_w">w</code></td>
<td>
<p>An instance of Weight object</p>
</td></tr>
<tr><td><code id="local_geary_+3A_df">df</code></td>
<td>
<p>A data frame with selected variable only. E.g. guerry[&quot;Crm_prs&quot;]</p>
</td></tr>
<tr><td><code id="local_geary_+3A_permutations">permutations</code></td>
<td>
<p>(optional) The number of permutations for the LISA
computation</p>
</td></tr>
<tr><td><code id="local_geary_+3A_permutation_method">permutation_method</code></td>
<td>
<p>(optional) The permutation method used for the
LISA computation. Options are 'complete', 'lookup'. Default is 'complete'.</p>
</td></tr>
<tr><td><code id="local_geary_+3A_significance_cutoff">significance_cutoff</code></td>
<td>
<p>(optional) A cutoff value for significance
p-values to filter not-significant clusters</p>
</td></tr>
<tr><td><code id="local_geary_+3A_cpu_threads">cpu_threads</code></td>
<td>
<p>(optional) The number of cpu threads used for parallel
LISA computation</p>
</td></tr>
<tr><td><code id="local_geary_+3A_seed">seed</code></td>
<td>
<p>(optional) The seed for random number generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of LISA-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
lisa &lt;- local_geary(queen_w, guerry["Crm_prs"])
lms &lt;- lisa_values(lisa)
lms
</code></pre>

<hr>
<h2 id='local_gstar'>Local Getis-Ord's G* Statistics</h2><span id='topic+local_gstar'></span>

<h3>Description</h3>

<p>The function to apply Getis-Ord's local G* statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_gstar(
  w,
  df,
  permutations = 999,
  permutation_method = "complete",
  significance_cutoff = 0.05,
  cpu_threads = 6,
  seed = 123456789
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_gstar_+3A_w">w</code></td>
<td>
<p>An instance of Weight object</p>
</td></tr>
<tr><td><code id="local_gstar_+3A_df">df</code></td>
<td>
<p>A data frame with selected variable only. E.g. guerry[&quot;Crm_prs&quot;]</p>
</td></tr>
<tr><td><code id="local_gstar_+3A_permutations">permutations</code></td>
<td>
<p>(optional) The number of permutations for the LISA
computation</p>
</td></tr>
<tr><td><code id="local_gstar_+3A_permutation_method">permutation_method</code></td>
<td>
<p>(optional) The permutation method used for the
LISA computation. Options are 'complete', 'lookup'. Default is 'complete'.</p>
</td></tr>
<tr><td><code id="local_gstar_+3A_significance_cutoff">significance_cutoff</code></td>
<td>
<p>(optional) A cutoff value for significance
p-values to filter not-significant clusters</p>
</td></tr>
<tr><td><code id="local_gstar_+3A_cpu_threads">cpu_threads</code></td>
<td>
<p>(optional) The number of cpu threads used for parallel
LISA computation</p>
</td></tr>
<tr><td><code id="local_gstar_+3A_seed">seed</code></td>
<td>
<p>(optional) The seed for random number generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of LISA-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
lisa &lt;- local_gstar(queen_w,  guerry["Crm_prs"])
lms &lt;- lisa_values(lisa)
lms
</code></pre>

<hr>
<h2 id='local_joincount'>Local Join Count Statistics</h2><span id='topic+local_joincount'></span>

<h3>Description</h3>

<p>The function to apply local Join Count statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_joincount(
  w,
  df,
  permutations = 999,
  permutation_method = "complete",
  significance_cutoff = 0.05,
  cpu_threads = 6,
  seed = 123456789
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_joincount_+3A_w">w</code></td>
<td>
<p>An instance of Weight object</p>
</td></tr>
<tr><td><code id="local_joincount_+3A_df">df</code></td>
<td>
<p>A data frame with selected variable only. E.g. guerry[&quot;Crm_prs&quot;]</p>
</td></tr>
<tr><td><code id="local_joincount_+3A_permutations">permutations</code></td>
<td>
<p>(optional) The number of permutations for the LISA
computation</p>
</td></tr>
<tr><td><code id="local_joincount_+3A_permutation_method">permutation_method</code></td>
<td>
<p>(optional) The permutation method used for the
LISA computation. Options are 'complete', 'lookup'. Default is 'complete'.</p>
</td></tr>
<tr><td><code id="local_joincount_+3A_significance_cutoff">significance_cutoff</code></td>
<td>
<p>(optional) A cutoff value for significance
p-values to filter not-significant clusters</p>
</td></tr>
<tr><td><code id="local_joincount_+3A_cpu_threads">cpu_threads</code></td>
<td>
<p>(optional) The number of cpu threads used for parallel
LISA computation</p>
</td></tr>
<tr><td><code id="local_joincount_+3A_seed">seed</code></td>
<td>
<p>(optional) The seed for random number generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of LISA-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
lisa &lt;- local_joincount(queen_w, guerry['TopCrm'])
clsts&lt;- lisa_clusters(lisa)
clsts
</code></pre>

<hr>
<h2 id='local_moran'>Local Moran Statistics</h2><span id='topic+local_moran'></span>

<h3>Description</h3>

<p>The function to apply local Moran statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_moran(
  w,
  df,
  permutations = 999,
  permutation_method = "complete",
  significance_cutoff = 0.05,
  cpu_threads = 6,
  seed = 123456789
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_moran_+3A_w">w</code></td>
<td>
<p>An instance of Weight object</p>
</td></tr>
<tr><td><code id="local_moran_+3A_df">df</code></td>
<td>
<p>A data frame with only selected variable. E.g. guerry[&quot;Crm_prs&quot;]</p>
</td></tr>
<tr><td><code id="local_moran_+3A_permutations">permutations</code></td>
<td>
<p>(optional) The number of permutations for the LISA
computation</p>
</td></tr>
<tr><td><code id="local_moran_+3A_permutation_method">permutation_method</code></td>
<td>
<p>(optional) The permutation method used for the
LISA computation. Options are 'complete', 'lookup'. Default is 'complete'.</p>
</td></tr>
<tr><td><code id="local_moran_+3A_significance_cutoff">significance_cutoff</code></td>
<td>
<p>(optional) A cutoff value for significance
p-values to filter not-significant clusters</p>
</td></tr>
<tr><td><code id="local_moran_+3A_cpu_threads">cpu_threads</code></td>
<td>
<p>(optional) The number of cpu threads used for parallel
LISA computation</p>
</td></tr>
<tr><td><code id="local_moran_+3A_seed">seed</code></td>
<td>
<p>(optional) The seed for random number generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of LISA-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
lisa &lt;- local_moran(queen_w, guerry["Crm_prs"])
lms &lt;- lisa_values(lisa)
lms
</code></pre>

<hr>
<h2 id='local_moran_eb'>Local Moran with Empirical Bayes(EB) Rate</h2><span id='topic+local_moran_eb'></span>

<h3>Description</h3>

<p>The function to apply local Moran with EB Rate statistics. The
EB rate is first computed from &quot;event&quot; and &quot;base&quot; variables, and then used
in local moran statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_moran_eb(
  w,
  df,
  permutations = 999,
  permutation_method = "complete",
  significance_cutoff = 0.05,
  cpu_threads = 6,
  seed = 123456789
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_moran_eb_+3A_w">w</code></td>
<td>
<p>An instance of Weight object</p>
</td></tr>
<tr><td><code id="local_moran_eb_+3A_df">df</code></td>
<td>
<p>A data frame with two selected variable: one is &quot;event&quot;, anothor
is &quot;base&quot; variable. E.g. guerry[c(&quot;hr60&quot;, &quot;po60&quot;)]</p>
</td></tr>
<tr><td><code id="local_moran_eb_+3A_permutations">permutations</code></td>
<td>
<p>(optional) The number of permutations for the LISA
computation</p>
</td></tr>
<tr><td><code id="local_moran_eb_+3A_permutation_method">permutation_method</code></td>
<td>
<p>(optional) The permutation method used for the LISA
computation. Options are 'complete', 'lookup'. Default is 'complete'.</p>
</td></tr>
<tr><td><code id="local_moran_eb_+3A_significance_cutoff">significance_cutoff</code></td>
<td>
<p>(optional) A cutoff value for significance
p-values to filter not-significant clusters</p>
</td></tr>
<tr><td><code id="local_moran_eb_+3A_cpu_threads">cpu_threads</code></td>
<td>
<p>(optional) The number of cpu threads used for parallel
LISA computation</p>
</td></tr>
<tr><td><code id="local_moran_eb_+3A_seed">seed</code></td>
<td>
<p>(optional) The seed for random number generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of LISA-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
nat &lt;- st_read("natregimes.shp")
nat_w &lt;- queen_weights(nat)
lisa &lt;- local_moran_eb(queen_w, guerry[c("hr60", "po60")])
lms &lt;- lisa_values(lisa)
lms

## End(Not run)
</code></pre>

<hr>
<h2 id='local_multigeary'>Local Multivariate Geary Statistics</h2><span id='topic+local_multigeary'></span>

<h3>Description</h3>

<p>The function to apply local Multivariate Geary statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_multigeary(
  w,
  df,
  permutations = 999,
  permutation_method = "complete",
  significance_cutoff = 0.05,
  cpu_threads = 6,
  seed = 123456789
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_multigeary_+3A_w">w</code></td>
<td>
<p>An instance of Weight object</p>
</td></tr>
<tr><td><code id="local_multigeary_+3A_df">df</code></td>
<td>
<p>A data frame with selected variables only. E.g. guerry[&quot;Crm_prs&quot;]</p>
</td></tr>
<tr><td><code id="local_multigeary_+3A_permutations">permutations</code></td>
<td>
<p>(optional) The number of permutations for the LISA
computation</p>
</td></tr>
<tr><td><code id="local_multigeary_+3A_permutation_method">permutation_method</code></td>
<td>
<p>(optional) The permutation method used for the
LISA computation. Options are 'complete', 'lookup'. Default is 'complete'.</p>
</td></tr>
<tr><td><code id="local_multigeary_+3A_significance_cutoff">significance_cutoff</code></td>
<td>
<p>(optional) A cutoff value for significance
p-values to filter not-significant clusters</p>
</td></tr>
<tr><td><code id="local_multigeary_+3A_cpu_threads">cpu_threads</code></td>
<td>
<p>(optional) The number of cpu threads used for parallel
LISA computation</p>
</td></tr>
<tr><td><code id="local_multigeary_+3A_seed">seed</code></td>
<td>
<p>(optional) The seed for random number generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of LISA-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
data &lt;- guerry[c('Crm_prs','Crm_prp','Litercy','Donatns','Infants',
'Suicids')]
lisa &lt;- local_multigeary(queen_w, data)
lms &lt;- lisa_clusters(lisa)
lms
</code></pre>

<hr>
<h2 id='local_multijoincount'>(Multivariate) Colocation Local Join Count Statistics</h2><span id='topic+local_multijoincount'></span>

<h3>Description</h3>

<p>The function to apply (multivariate) colocation local Join Count
statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_multijoincount(
  w,
  df,
  permutations = 999,
  permutation_method = "complete",
  significance_cutoff = 0.05,
  cpu_threads = 6,
  seed = 123456789
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_multijoincount_+3A_w">w</code></td>
<td>
<p>An instance of Weight object</p>
</td></tr>
<tr><td><code id="local_multijoincount_+3A_df">df</code></td>
<td>
<p>A data frame with selected variables only.
E.g. guerry[c(&quot;TopCrm&quot;, &quot;TopWealth&quot;, &quot;TopLit&quot;)]</p>
</td></tr>
<tr><td><code id="local_multijoincount_+3A_permutations">permutations</code></td>
<td>
<p>(optional) The number of permutations for the LISA
computation</p>
</td></tr>
<tr><td><code id="local_multijoincount_+3A_permutation_method">permutation_method</code></td>
<td>
<p>(optional) The permutation method used for the
LISA computation. Options are 'complete', 'lookup'. Default is 'complete'.</p>
</td></tr>
<tr><td><code id="local_multijoincount_+3A_significance_cutoff">significance_cutoff</code></td>
<td>
<p>(optional) A cutoff value for significance
p-values to filter not-significant clusters</p>
</td></tr>
<tr><td><code id="local_multijoincount_+3A_cpu_threads">cpu_threads</code></td>
<td>
<p>(optional) The number of cpu threads used for parallel
LISA computation</p>
</td></tr>
<tr><td><code id="local_multijoincount_+3A_seed">seed</code></td>
<td>
<p>(optional) The seed for random number generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of LISA-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
lisa &lt;- local_multijoincount(queen_w,
guerry[c('TopWealth','TopWealth', 'TopLit')])
clsts &lt;- lisa_clusters(lisa)
clsts
</code></pre>

<hr>
<h2 id='local_multiquantilelisa'>Multivariate Quantile LISA Statistics</h2><span id='topic+local_multiquantilelisa'></span>

<h3>Description</h3>

<p>The function to apply multivariate quantile LISA statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_multiquantilelisa(
  w,
  df,
  k,
  q,
  permutations = 999,
  permutation_method = "complete",
  significance_cutoff = 0.05,
  cpu_threads = 6,
  seed = 123456789
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_multiquantilelisa_+3A_w">w</code></td>
<td>
<p>An instance of Weight object</p>
</td></tr>
<tr><td><code id="local_multiquantilelisa_+3A_df">df</code></td>
<td>
<p>A data frame with selected variables only.
E.g. guerry[c(&quot;TopCrm&quot;, &quot;TopWealth&quot;, &quot;TopLit&quot;)]</p>
</td></tr>
<tr><td><code id="local_multiquantilelisa_+3A_k">k</code></td>
<td>
<p>A vector of &quot;k&quot; values indicate the number of quantiles for each
variable. Value range e.g. [1, 10]</p>
</td></tr>
<tr><td><code id="local_multiquantilelisa_+3A_q">q</code></td>
<td>
<p>A vector of &quot;q&quot; values indicate which quantile or interval for each
variable used in local join count statistics. Value stars from 1.</p>
</td></tr>
<tr><td><code id="local_multiquantilelisa_+3A_permutations">permutations</code></td>
<td>
<p>(optional) The number of permutations for the LISA
computation</p>
</td></tr>
<tr><td><code id="local_multiquantilelisa_+3A_permutation_method">permutation_method</code></td>
<td>
<p>(optional) The permutation method used for the LISA
computation. Options are 'complete', 'lookup'. Default is 'complete'.</p>
</td></tr>
<tr><td><code id="local_multiquantilelisa_+3A_significance_cutoff">significance_cutoff</code></td>
<td>
<p>(optional) A cutoff value for significance
p-values to filter not-significant clusters</p>
</td></tr>
<tr><td><code id="local_multiquantilelisa_+3A_cpu_threads">cpu_threads</code></td>
<td>
<p>(optional) The number of cpu threads used for parallel
LISA computation</p>
</td></tr>
<tr><td><code id="local_multiquantilelisa_+3A_seed">seed</code></td>
<td>
<p>(optional) The seed for random number generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of LISA-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
lisa &lt;- local_multiquantilelisa(queen_w, guerry[c("Crm_prp", "Litercy")],
k=c(4,4), q=c(1,1))
clsts &lt;- lisa_clusters(lisa)
clsts
</code></pre>

<hr>
<h2 id='local_quantilelisa'>Quantile LISA Statistics</h2><span id='topic+local_quantilelisa'></span>

<h3>Description</h3>

<p>The function to apply quantile LISA statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>local_quantilelisa(
  w,
  df,
  k,
  q,
  permutations = 999,
  permutation_method = "complete",
  significance_cutoff = 0.05,
  cpu_threads = 6,
  seed = 123456789
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="local_quantilelisa_+3A_w">w</code></td>
<td>
<p>An instance of Weight object</p>
</td></tr>
<tr><td><code id="local_quantilelisa_+3A_df">df</code></td>
<td>
<p>A data frame with selected variable only. E.g. guerry[&quot;Crm_prs&quot;]</p>
</td></tr>
<tr><td><code id="local_quantilelisa_+3A_k">k</code></td>
<td>
<p>A value indicates the number of quantiles. Value range e.g. [1, 10]</p>
</td></tr>
<tr><td><code id="local_quantilelisa_+3A_q">q</code></td>
<td>
<p>A value indicates which quantile or interval used in local join
count statistics. Value stars from 1.</p>
</td></tr>
<tr><td><code id="local_quantilelisa_+3A_permutations">permutations</code></td>
<td>
<p>(optional) The number of permutations for the LISA
computation</p>
</td></tr>
<tr><td><code id="local_quantilelisa_+3A_permutation_method">permutation_method</code></td>
<td>
<p>(optional) The permutation method used for the LISA
computation. Options are 'complete', 'lookup'. Default is 'complete'.</p>
</td></tr>
<tr><td><code id="local_quantilelisa_+3A_significance_cutoff">significance_cutoff</code></td>
<td>
<p>(optional) A cutoff value for significance
p-values to filter not-significant clusters</p>
</td></tr>
<tr><td><code id="local_quantilelisa_+3A_cpu_threads">cpu_threads</code></td>
<td>
<p>(optional) The number of cpu threads used for parallel
LISA computation</p>
</td></tr>
<tr><td><code id="local_quantilelisa_+3A_seed">seed</code></td>
<td>
<p>(optional) The seed for random number generator</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of LISA-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
lisa &lt;- local_quantilelisa(queen_w, guerry["Crm_prs"], k=4, q=1)
clsts &lt;- lisa_clusters(lisa)
clsts
</code></pre>

<hr>
<h2 id='make_spatial'>Make Spatial</h2><span id='topic+make_spatial'></span>

<h3>Description</h3>

<p>Make spatially constrained clusters from spatially non-constrained clusters
using the contiguity information from the input weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_spatial(clusters, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_spatial_+3A_clusters">clusters</code></td>
<td>
<p>A cluster classification variable (categorical values from a dataframe or values returned from cluster functions)</p>
</td></tr>
<tr><td><code id="make_spatial_+3A_w">w</code></td>
<td>
<p>An instance of Weight class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of categorical values (cluster classification)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
data &lt;- guerry[c('Crm_prs','Crm_prp','Litercy','Donatns','Infants','Suicids')]
clusters &lt;- kmeans(5, data)
queen_w &lt;- queen_weights(guerry)
results &lt;- make_spatial(clusters, queen_w)
results

## End(Not run)
</code></pre>

<hr>
<h2 id='max_neighbors'>Maximum Neighbors of Spatial Weights</h2><span id='topic+max_neighbors'></span>

<h3>Description</h3>

<p>Get the number of maximum neighbors of spatial weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_neighbors(gda_w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_neighbors_+3A_gda_w">gda_w</code></td>
<td>
<p>A Weight object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of maximum neighbors of spatial weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
max_neighbors(queen_w)

## End(Not run)
</code></pre>

<hr>
<h2 id='maxp_greedy'>A greedy algorithm to solve the max-p-region problem</h2><span id='topic+maxp_greedy'></span>

<h3>Description</h3>

<p>The max-p-region problem is a special case of constrained
clustering where a finite number of geographical areas are aggregated into
the maximum number of regions (max-p-regions), such that each region is
geographically connected and the clusters could maximize internal homogeneity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxp_greedy(
  w,
  df,
  bound_variable,
  min_bound,
  iterations = 99,
  initial_regions = vector("numeric"),
  scale_method = "standardize",
  distance_method = "euclidean",
  random_seed = 123456789,
  cpu_threads = 6,
  rdist = numeric()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxp_greedy_+3A_w">w</code></td>
<td>
<p>An instance of Weight class</p>
</td></tr>
<tr><td><code id="maxp_greedy_+3A_df">df</code></td>
<td>
<p>A data frame with selected variables only. E.g. guerry[c(&quot;Crm_prs&quot;, &quot;Crm_prp&quot;, &quot;Litercy&quot;)]</p>
</td></tr>
<tr><td><code id="maxp_greedy_+3A_bound_variable">bound_variable</code></td>
<td>
<p>A numeric vector of selected bounding variable</p>
</td></tr>
<tr><td><code id="maxp_greedy_+3A_min_bound">min_bound</code></td>
<td>
<p>A minimum value that the sum value of bounding variable int each cluster should be greater than</p>
</td></tr>
<tr><td><code id="maxp_greedy_+3A_iterations">iterations</code></td>
<td>
<p>(optional): The number of iterations of greedy algorithm. Defaults to 99.</p>
</td></tr>
<tr><td><code id="maxp_greedy_+3A_initial_regions">initial_regions</code></td>
<td>
<p>(optional): The initial regions that the local search starts with. Default is empty. means the local search starts with a random process to &quot;grow&quot; clusters</p>
</td></tr>
<tr><td><code id="maxp_greedy_+3A_scale_method">scale_method</code></td>
<td>
<p>(optional) One of the scaling methods 'raw', 'standardize', 'demean', 'mad', 'range_standardize', 'range_adjust' to apply on input data. Default is 'standardize' (Z-score normalization).</p>
</td></tr>
<tr><td><code id="maxp_greedy_+3A_distance_method">distance_method</code></td>
<td>
<p>(optional) The distance method used to compute the distance betwen observation i and j. Defaults to &quot;euclidean&quot;. Options are &quot;euclidean&quot; and &quot;manhattan&quot;</p>
</td></tr>
<tr><td><code id="maxp_greedy_+3A_random_seed">random_seed</code></td>
<td>
<p>(optional) The seed for random number generator. Defaults to 123456789.</p>
</td></tr>
<tr><td><code id="maxp_greedy_+3A_cpu_threads">cpu_threads</code></td>
<td>
<p>(optional) The number of cpu threads used for parallel computation</p>
</td></tr>
<tr><td><code id="maxp_greedy_+3A_rdist">rdist</code></td>
<td>
<p>(optional) The distance matrix (lower triangular matrix, column wise storage)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A names list with names &quot;Clusters&quot;, &quot;Total sum of squares&quot;, &quot;Within-cluster sum of squares&quot;, &quot;Total within-cluster sum of squares&quot;, and &quot;The ratio of between to total sum of squares&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
data &lt;- guerry[c('Crm_prs','Crm_prp','Litercy','Donatns','Infants','Suicids')]
bound_variable &lt;- guerry['Pop1831']
min_bound &lt;- 3236.67 # 10% of Pop1831
maxp_clusters &lt;- maxp_greedy(queen_w, data, bound_variable, min_bound, iterations=99)
maxp_clusters

## End(Not run)
</code></pre>

<hr>
<h2 id='maxp_sa'>A simulated annealing algorithm to solve the max-p-region problem</h2><span id='topic+maxp_sa'></span>

<h3>Description</h3>

<p>The max-p-region problem is a special case of constrained
clustering where a finite number of geographical areas are aggregated into
the maximum number of regions (max-p-regions), such that each region is
geographically connected and the clusters could maximize internal homogeneity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxp_sa(
  w,
  df,
  bound_variable,
  min_bound,
  cooling_rate,
  sa_maxit = 1,
  iterations = 99,
  initial_regions = vector("numeric"),
  scale_method = "standardize",
  distance_method = "euclidean",
  random_seed = 123456789,
  cpu_threads = 6,
  rdist = numeric()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxp_sa_+3A_w">w</code></td>
<td>
<p>An instance of Weight class</p>
</td></tr>
<tr><td><code id="maxp_sa_+3A_df">df</code></td>
<td>
<p>A data frame with selected variables only. E.g. guerry[c(&quot;Crm_prs&quot;, &quot;Crm_prp&quot;, &quot;Litercy&quot;)]</p>
</td></tr>
<tr><td><code id="maxp_sa_+3A_bound_variable">bound_variable</code></td>
<td>
<p>A numeric vector of selected bounding variable</p>
</td></tr>
<tr><td><code id="maxp_sa_+3A_min_bound">min_bound</code></td>
<td>
<p>A minimum value that the sum value of bounding variable int each cluster should be greater than</p>
</td></tr>
<tr><td><code id="maxp_sa_+3A_cooling_rate">cooling_rate</code></td>
<td>
<p>The cooling rate of a simulated annealing algorithm. Defaults to 0.85</p>
</td></tr>
<tr><td><code id="maxp_sa_+3A_sa_maxit">sa_maxit</code></td>
<td>
<p>(optional): The number of iterations of simulated annealing. Defaults to 1</p>
</td></tr>
<tr><td><code id="maxp_sa_+3A_iterations">iterations</code></td>
<td>
<p>(optional): The number of iterations of SA algorithm. Defaults to 99.</p>
</td></tr>
<tr><td><code id="maxp_sa_+3A_initial_regions">initial_regions</code></td>
<td>
<p>(optional): The initial regions that the local search starts with. Default is empty. means the local search starts with a random process to &quot;grow&quot; clusters</p>
</td></tr>
<tr><td><code id="maxp_sa_+3A_scale_method">scale_method</code></td>
<td>
<p>(optional) One of the scaling methods 'raw', 'standardize', 'demean', 'mad', 'range_standardize', 'range_adjust' to apply on input data. Default is 'standardize' (Z-score normalization).</p>
</td></tr>
<tr><td><code id="maxp_sa_+3A_distance_method">distance_method</code></td>
<td>
<p>(optional) The distance method used to compute the distance betwen observation i and j. Defaults to &quot;euclidean&quot;. Options are &quot;euclidean&quot; and &quot;manhattan&quot;</p>
</td></tr>
<tr><td><code id="maxp_sa_+3A_random_seed">random_seed</code></td>
<td>
<p>(optional) The seed for random number generator. Defaults to 123456789.</p>
</td></tr>
<tr><td><code id="maxp_sa_+3A_cpu_threads">cpu_threads</code></td>
<td>
<p>(optional) The number of cpu threads used for parallel computation</p>
</td></tr>
<tr><td><code id="maxp_sa_+3A_rdist">rdist</code></td>
<td>
<p>(optional) The distance matrix (lower triangular matrix, column wise storage)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A names list with names &quot;Clusters&quot;, &quot;Total sum of squares&quot;, &quot;Within-cluster sum of squares&quot;, &quot;Total within-cluster sum of squares&quot;, and &quot;The ratio of between to total sum of squares&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
data &lt;- guerry[c('Crm_prs','Crm_prp','Litercy','Donatns','Infants','Suicids')]
bound_variable &lt;- guerry['Pop1831']
min_bound &lt;- 3236.67 # 10% of Pop1831
maxp_clusters &lt;- maxp_sa(queen_w, data, bound_variable, min_bound, cooling_rate=0.85, sa_maxit=1)
maxp_clusters

## End(Not run)
</code></pre>

<hr>
<h2 id='maxp_tabu'>A tabu-search algorithm to solve the max-p-region problem</h2><span id='topic+maxp_tabu'></span>

<h3>Description</h3>

<p>The max-p-region problem is a special case of constrained
clustering where a finite number of geographical areas are aggregated into
the maximum number of regions (max-p-regions), such that each region is
geographically connected and the clusters could maximize internal homogeneity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxp_tabu(
  w,
  df,
  bound_variable,
  min_bound,
  tabu_length = 10,
  conv_tabu = 10,
  iterations = 99,
  initial_regions = vector("numeric"),
  scale_method = "standardize",
  distance_method = "euclidean",
  random_seed = 123456789,
  cpu_threads = 6,
  rdist = numeric()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maxp_tabu_+3A_w">w</code></td>
<td>
<p>An instance of Weight class</p>
</td></tr>
<tr><td><code id="maxp_tabu_+3A_df">df</code></td>
<td>
<p>A data frame with selected variables only. E.g. guerry[c(&quot;Crm_prs&quot;, &quot;Crm_prp&quot;, &quot;Litercy&quot;)]</p>
</td></tr>
<tr><td><code id="maxp_tabu_+3A_bound_variable">bound_variable</code></td>
<td>
<p>A numeric vector of selected bounding variable</p>
</td></tr>
<tr><td><code id="maxp_tabu_+3A_min_bound">min_bound</code></td>
<td>
<p>A minimum value that the sum value of bounding variable int each cluster should be greater than</p>
</td></tr>
<tr><td><code id="maxp_tabu_+3A_tabu_length">tabu_length</code></td>
<td>
<p>(optional): The length of a tabu search heuristic of tabu algorithm. Defaults to 10.</p>
</td></tr>
<tr><td><code id="maxp_tabu_+3A_conv_tabu">conv_tabu</code></td>
<td>
<p>(optional): The number of non-improving moves. Defaults to 10.</p>
</td></tr>
<tr><td><code id="maxp_tabu_+3A_iterations">iterations</code></td>
<td>
<p>(optional): The number of iterations of Tabu algorithm. Defaults to 99.</p>
</td></tr>
<tr><td><code id="maxp_tabu_+3A_initial_regions">initial_regions</code></td>
<td>
<p>(optional): The initial regions that the local search starts with. Default is empty. means the local search starts with a random process to &quot;grow&quot; clusters</p>
</td></tr>
<tr><td><code id="maxp_tabu_+3A_scale_method">scale_method</code></td>
<td>
<p>(optional) One of the scaling methods 'raw', 'standardize', 'demean', 'mad', 'range_standardize', 'range_adjust' to apply on input data. Default is 'standardize' (Z-score normalization).</p>
</td></tr>
<tr><td><code id="maxp_tabu_+3A_distance_method">distance_method</code></td>
<td>
<p>(optional) The distance method used to compute the distance betwen observation i and j. Defaults to &quot;euclidean&quot;. Options are &quot;euclidean&quot; and &quot;manhattan&quot;</p>
</td></tr>
<tr><td><code id="maxp_tabu_+3A_random_seed">random_seed</code></td>
<td>
<p>(optional) The seed for random number generator. Defaults to 123456789.</p>
</td></tr>
<tr><td><code id="maxp_tabu_+3A_cpu_threads">cpu_threads</code></td>
<td>
<p>(optional) The number of cpu threads used for parallel computation</p>
</td></tr>
<tr><td><code id="maxp_tabu_+3A_rdist">rdist</code></td>
<td>
<p>(optional) The distance matrix (lower triangular matrix, column wise storage)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A names list with names &quot;Clusters&quot;, &quot;Total sum of squares&quot;, &quot;Within-cluster sum of squares&quot;, &quot;Total within-cluster sum of squares&quot;, and &quot;The ratio of between to total sum of squares&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
data &lt;- guerry[c('Crm_prs','Crm_prp','Litercy','Donatns','Infants','Suicids')]
bound_variable &lt;- guerry['Pop1831']
min_bound &lt;- 3236.67 # 10% of Pop1831
maxp_clusters &lt;- maxp_tabu(queen_w, data, bound_variable, min_bound, tabu_length=10, conv_tabu=10)
maxp_clusters

## End(Not run)
</code></pre>

<hr>
<h2 id='mean_neighbors'>Mean Neighbors of Spatial Weights</h2><span id='topic+mean_neighbors'></span>

<h3>Description</h3>

<p>Get the number of mean neighbors of spatial weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_neighbors(gda_w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_neighbors_+3A_gda_w">gda_w</code></td>
<td>
<p>A Weight object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of mean neighbors of spatial weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
mean_neighbors(queen_w)

## End(Not run)
</code></pre>

<hr>
<h2 id='median_neighbors'>Median Neighbors of Spatial Weights</h2><span id='topic+median_neighbors'></span>

<h3>Description</h3>

<p>Get the number of median neighbors of spatial weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>median_neighbors(gda_w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="median_neighbors_+3A_gda_w">gda_w</code></td>
<td>
<p>A Weight object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of median neighbors of spatial weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
median_neighbors(queen_w)

## End(Not run)
</code></pre>

<hr>
<h2 id='min_distthreshold'>Minimum Distance Threshold for Distance-based Weights</h2><span id='topic+min_distthreshold'></span>

<h3>Description</h3>

<p>Get minimum threshold of distance that makes sure each
observation has at least one neighbor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_distthreshold(sf_obj, is_arc = FALSE, is_mile = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_distthreshold_+3A_sf_obj">sf_obj</code></td>
<td>
<p>An sf (simple feature) object</p>
</td></tr>
<tr><td><code id="min_distthreshold_+3A_is_arc">is_arc</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, compute arc distance
between two observations</p>
</td></tr>
<tr><td><code id="min_distthreshold_+3A_is_mile">is_mile</code></td>
<td>
<p>(optional) TRUE (default) or FALSE, if 'is_arc' option is
TRUE, then 'is_mile' will set distance unit to 'mile' or 'km'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value of minimum threshold of distance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
dist_thres &lt;- min_distthreshold(guerry)
dist_thres

## End(Not run)
</code></pre>

<hr>
<h2 id='min_neighbors'>Minimum Neighbors of Spatial Weights</h2><span id='topic+min_neighbors'></span>

<h3>Description</h3>

<p>Get the number of minimum neighbors of spatial weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_neighbors(gda_w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_neighbors_+3A_gda_w">gda_w</code></td>
<td>
<p>A Weight object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The number of minimum neighbors of spatial weights
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
min_neighbors(queen_w)

## End(Not run)
</code></pre>

<hr>
<h2 id='natural_breaks'>Natural Breaks (Jenks)</h2><span id='topic+natural_breaks'></span>

<h3>Description</h3>

<p>Natural Breaks group data whose boundaries are set where there
are relatively big differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>natural_breaks(k, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="natural_breaks_+3A_k">k</code></td>
<td>
<p>A numeric value indicates how many breaks</p>
</td></tr>
<tr><td><code id="natural_breaks_+3A_df">df</code></td>
<td>
<p>A data frame with selected variable. E.g. guerry[&quot;Crm_prs&quot;]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numeric values of computed breaks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
natural_breaks(k=5, guerry['Crm_prs'])
</code></pre>

<hr>
<h2 id='neighbor_match_test'>Local Neighbor Match Test</h2><span id='topic+neighbor_match_test'></span>

<h3>Description</h3>

<p>The local neighbor match test is to assess the extent of overlap
between k-nearest neighbors in geographical space and k-nearest neighbors in
multi-attribute space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neighbor_match_test(
  df,
  k,
  scale_method = "standardize",
  distance_method = "euclidean",
  power = 1,
  is_inverse = FALSE,
  is_arc = FALSE,
  is_mile = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighbor_match_test_+3A_df">df</code></td>
<td>
<p>A subset of sf object with selected variables.
E.g. guerry[c(&quot;Crm_prs&quot;, &quot;Crm_prp&quot;, &quot;Litercy&quot;)]</p>
</td></tr>
<tr><td><code id="neighbor_match_test_+3A_k">k</code></td>
<td>
<p>a positive integer number for k-nearest neighbors searching.</p>
</td></tr>
<tr><td><code id="neighbor_match_test_+3A_scale_method">scale_method</code></td>
<td>
<p>(optional) One of the scaling methods 'raw',
'standardize', 'demean', 'mad', 'range_standardize', 'range_adjust' to apply
on input data. Default is 'standardize' (Z-score normalization).</p>
</td></tr>
<tr><td><code id="neighbor_match_test_+3A_distance_method">distance_method</code></td>
<td>
<p>(optional) The type of distance metrics used to
measure the distance between input data. Options are 'euclidean', 'manhattan'. Default is 'euclidean'.</p>
</td></tr>
<tr><td><code id="neighbor_match_test_+3A_power">power</code></td>
<td>
<p>(optional) The power (or exponent) of a number says how many
times to use the number in a multiplication.</p>
</td></tr>
<tr><td><code id="neighbor_match_test_+3A_is_inverse">is_inverse</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, apply inverse on
distance value.</p>
</td></tr>
<tr><td><code id="neighbor_match_test_+3A_is_arc">is_arc</code></td>
<td>
<p>(optional) FALSE (default) or TRUE, compute arc distance
between two observations.</p>
</td></tr>
<tr><td><code id="neighbor_match_test_+3A_is_mile">is_mile</code></td>
<td>
<p>(optional) TRUE (default) or FALSE, convert distance unit from
mile to km.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with two columns &quot;Cardinality&quot; and &quot;Probability&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
data &lt;- guerry[c('Crm_prs','Crm_prp','Litercy','Donatns','Infants','Suicids')]
nbr_test &lt;- neighbor_match_test(data, 6)
nbr_test
</code></pre>

<hr>
<h2 id='p_GeoDa-class'>p_GeoDa</h2><span id='topic+p_GeoDa-class'></span><span id='topic+p_GeoDa'></span><span id='topic++24+2Cp_GeoDa-method'></span>

<h3>Description</h3>

<p>p_GeoDa class is a RefClass that wraps the C++ 'GeoDa' class.
See C++ functions in rcpp_rgeoda.cpp
</p>

<hr>
<h2 id='p_GeoDaTable-class'>p_GeoDaTable</h2><span id='topic+p_GeoDaTable-class'></span><span id='topic+p_GeoDaTable'></span><span id='topic++24+2Cp_GeoDaTable-method'></span>

<h3>Description</h3>

<p>p_GeoDaTable class is a RefClass that wraps the C++ 'GeoDaTable'
class.
See C++ functions in rcpp_rgeoda.cpp
</p>

<hr>
<h2 id='p_GeoDaWeight-class'>p_GeoDaWeight</h2><span id='topic+p_GeoDaWeight-class'></span><span id='topic+p_GeoDaWeight'></span><span id='topic++24+2Cp_GeoDaWeight-method'></span>

<h3>Description</h3>

<p>p_GeoDaWeight class is a RefClass that wraps the C++ GeoDaWeight
class.
See C++ functions in rcpp_weights.cpp
</p>

<hr>
<h2 id='p_LISA-class'>p_LISA</h2><span id='topic+p_LISA-class'></span><span id='topic+p_LISA'></span><span id='topic++24+2Cp_LISA-method'></span>

<h3>Description</h3>

<p>p_LISA class is a RefClass that wraps the C++ LISA class.
See C++ functions in rcpp_lisa.cpp
</p>

<hr>
<h2 id='percentile_breaks'>Percentile Breaks</h2><span id='topic+percentile_breaks'></span>

<h3>Description</h3>

<p>Percentile breaks data into 6 groups: the lowest 1
10-50
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percentile_breaks(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="percentile_breaks_+3A_df">df</code></td>
<td>
<p>A data frame with selected variable. E.g. guerry[&quot;Crm_prs&quot;]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numeric values of computed breaks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
percentile_breaks(guerry['Crm_prs'])
</code></pre>

<hr>
<h2 id='quantile_breaks'>Quantile Breaks</h2><span id='topic+quantile_breaks'></span>

<h3>Description</h3>

<p>Quantile breaks data into groups that each have the same number
of observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantile_breaks(k, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantile_breaks_+3A_k">k</code></td>
<td>
<p>A numeric value indicates how many breaks</p>
</td></tr>
<tr><td><code id="quantile_breaks_+3A_df">df</code></td>
<td>
<p>A data frame with selected variable. E.g. guerry[&quot;Crm_prs&quot;]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numeric values of computed breaks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
quantile_breaks(k=5, guerry['Crm_prs'])
</code></pre>

<hr>
<h2 id='queen_weights'>Queen Contiguity Spatial Weights</h2><span id='topic+queen_weights'></span>

<h3>Description</h3>

<p>Create a Queen contiguity weights with options of &quot;order&quot;,
&quot;include lower order&quot; and &quot;precision threshold&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>queen_weights(
  sf_obj,
  order = 1,
  include_lower_order = FALSE,
  precision_threshold = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="queen_weights_+3A_sf_obj">sf_obj</code></td>
<td>
<p>An sf (simple feature) object</p>
</td></tr>
<tr><td><code id="queen_weights_+3A_order">order</code></td>
<td>
<p>(Optional) Order of contiguity</p>
</td></tr>
<tr><td><code id="queen_weights_+3A_include_lower_order">include_lower_order</code></td>
<td>
<p>(Optional)  Whether or not the lower order
neighbors should be included in the weights structure</p>
</td></tr>
<tr><td><code id="queen_weights_+3A_precision_threshold">precision_threshold</code></td>
<td>
<p>(Optional) The precision of the underlying shape
file is insufficient to allow for an exact match of coordinates to determine
which polygons are neighbors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of Weight-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
summary(queen_w)
</code></pre>

<hr>
<h2 id='read_gal'>Read a .GAL file</h2><span id='topic+read_gal'></span>

<h3>Description</h3>

<p>Create a spatial weights object from a .GAL file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_gal(file_path, id_vec = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_gal_+3A_file_path">file_path</code></td>
<td>
<p>The file paht of the .GAL file</p>
</td></tr>
<tr><td><code id="read_gal_+3A_id_vec">id_vec</code></td>
<td>
<p>The id_vec is the id values used in the .GAL file.
Default is empty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A weights object
</p>

<hr>
<h2 id='read_gwt'>Read a .GWT file</h2><span id='topic+read_gwt'></span>

<h3>Description</h3>

<p>Create a spatial weights object from a .GWT file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_gwt(file_path, id_vec = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_gwt_+3A_file_path">file_path</code></td>
<td>
<p>The file paht of the .GWT file</p>
</td></tr>
<tr><td><code id="read_gwt_+3A_id_vec">id_vec</code></td>
<td>
<p>The id_vec is the id values used in the .GWT file.
Default is empty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A weights object
</p>

<hr>
<h2 id='read_swm'>Read a .SWM file</h2><span id='topic+read_swm'></span>

<h3>Description</h3>

<p>Create a spatial weights object from a .SWM file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_swm(file_path, id_vec = numeric())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_swm_+3A_file_path">file_path</code></td>
<td>
<p>The file paht of the .SWM file</p>
</td></tr>
<tr><td><code id="read_swm_+3A_id_vec">id_vec</code></td>
<td>
<p>The id_vec is the id values used in the .SWM file.
e.g. c(0,1,2,3,...)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A weights object
</p>

<hr>
<h2 id='redcap'>Regionalization with dynamically constrained agglomerative clustering and partitioning</h2><span id='topic+redcap'></span>

<h3>Description</h3>

<p>REDCAP (Regionalization with dynamically constrained agglomerative
clustering and partitioning) is developed by D. Guo (2008). Like SKATER, REDCAP
starts from building a spanning tree with 4 different ways (single-linkage, average-linkage, ward-linkage
and the complete-linkage). The single-linkage way leads to build a minimum spanning tree.
Then,REDCAP provides 2 different ways (first-order and full-order constraining) to
prune the tree to find clusters. The first-order approach with a minimum spanning tree is
exactly the same with SKATER. In GeoDa and pygeoda, the following methods are provided:
\* First-order and Single-linkage
\* Full-order and Complete-linkage
\* Full-order and Average-linkage
\* Full-order and Single-linkage
\* Full-order and Ward-linkage
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redcap(
  k,
  w,
  df,
  method = "fullorder-averagelinkage",
  bound_variable = data.frame(),
  min_bound = 0,
  scale_method = "standardize",
  distance_method = "euclidean",
  random_seed = 123456789,
  cpu_threads = 6,
  rdist = numeric()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redcap_+3A_k">k</code></td>
<td>
<p>The number of clusters</p>
</td></tr>
<tr><td><code id="redcap_+3A_w">w</code></td>
<td>
<p>An instance of Weight class</p>
</td></tr>
<tr><td><code id="redcap_+3A_df">df</code></td>
<td>
<p>A data frame with selected variables only. E.g. guerry[c(&quot;Crm_prs&quot;, &quot;Crm_prp&quot;, &quot;Litercy&quot;)]</p>
</td></tr>
<tr><td><code id="redcap_+3A_method">method</code></td>
<td>
<p>&quot;firstorder-singlelinkage&quot;, &quot;fullorder-completelinkage&quot;, &quot;fullorder-averagelinkage&quot;,&quot;fullorder-singlelinkage&quot;, &quot;fullorder-wardlinkage&quot;</p>
</td></tr>
<tr><td><code id="redcap_+3A_bound_variable">bound_variable</code></td>
<td>
<p>(optional) A data frame with selected bound variabl</p>
</td></tr>
<tr><td><code id="redcap_+3A_min_bound">min_bound</code></td>
<td>
<p>(optional) A minimum bound value that applies to all clusters</p>
</td></tr>
<tr><td><code id="redcap_+3A_scale_method">scale_method</code></td>
<td>
<p>(optional) One of the scaling methods 'raw', 'standardize', 'demean', 'mad', 'range_standardize', 'range_adjust' to apply on input data. Default is 'standardize' (Z-score normalization).</p>
</td></tr>
<tr><td><code id="redcap_+3A_distance_method">distance_method</code></td>
<td>
<p>(optional) The distance method used to compute the distance betwen observation i and j. Defaults to &quot;euclidean&quot;. Options are &quot;euclidean&quot; and &quot;manhattan&quot;</p>
</td></tr>
<tr><td><code id="redcap_+3A_random_seed">random_seed</code></td>
<td>
<p>(int,optional) The seed for random number generator. Defaults to 123456789.</p>
</td></tr>
<tr><td><code id="redcap_+3A_cpu_threads">cpu_threads</code></td>
<td>
<p>(optional) The number of cpu threads used for parallel computation</p>
</td></tr>
<tr><td><code id="redcap_+3A_rdist">rdist</code></td>
<td>
<p>(optional) The distance matrix (lower triangular matrix, column wise storage)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A names list with names &quot;Clusters&quot;, &quot;Total sum of squares&quot;, &quot;Within-cluster sum of squares&quot;, &quot;Total within-cluster sum of squares&quot;, and &quot;The ratio of between to total sum of squares&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
data &lt;- guerry[c('Crm_prs','Crm_prp','Litercy','Donatns','Infants','Suicids')]
guerry_clusters &lt;- redcap(4, queen_w, data, "fullorder-completelinkage")
guerry_clusters

## End(Not run)
</code></pre>

<hr>
<h2 id='rook_weights'>Rook Contiguity Spatial Weights</h2><span id='topic+rook_weights'></span>

<h3>Description</h3>

<p>Create a Rook contiguity weights with options of &quot;order&quot;,
&quot;include lower order&quot; and &quot;precision threshold&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rook_weights(
  sf_obj,
  order = 1,
  include_lower_order = FALSE,
  precision_threshold = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rook_weights_+3A_sf_obj">sf_obj</code></td>
<td>
<p>An sf (simple feature) object</p>
</td></tr>
<tr><td><code id="rook_weights_+3A_order">order</code></td>
<td>
<p>(Optional) Order of contiguity</p>
</td></tr>
<tr><td><code id="rook_weights_+3A_include_lower_order">include_lower_order</code></td>
<td>
<p>(Optional)  Whether or not the lower order
neighbors should be included in the weights structure</p>
</td></tr>
<tr><td><code id="rook_weights_+3A_precision_threshold">precision_threshold</code></td>
<td>
<p>(Optional) The precision of the underlying shape
file is insufficient to allow for an exact match of coordinates to determine
which polygons are neighbors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of Weight-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
rook_w &lt;- rook_weights(guerry)
summary(rook_w)
</code></pre>

<hr>
<h2 id='save_weights'>Save Spatial Weights</h2><span id='topic+save_weights'></span>

<h3>Description</h3>

<p>Save spatial weights to a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>save_weights(gda_w, id_variable, out_path, layer_name = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="save_weights_+3A_gda_w">gda_w</code></td>
<td>
<p>A Weight object</p>
</td></tr>
<tr><td><code id="save_weights_+3A_id_variable">id_variable</code></td>
<td>
<p>The id variable (a data.frame) that defines the unique
value of each observation when saving a weights file</p>
</td></tr>
<tr><td><code id="save_weights_+3A_out_path">out_path</code></td>
<td>
<p>The path of an output weights file</p>
</td></tr>
<tr><td><code id="save_weights_+3A_layer_name">layer_name</code></td>
<td>
<p>(optional) The name of the layer of input dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean value indicates if save successfully or failed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
save_weights(quen_w, guerry_df['CODE_DE'], out_path = '/path/Guerry_r.gal')

## End(Not run)
</code></pre>

<hr>
<h2 id='schc'>Spatially Constrained Hierarchical Clucstering (SCHC)</h2><span id='topic+schc'></span>

<h3>Description</h3>

<p>Spatially constrained hierarchical clustering is a special form of constrained clustering, where the constraint is based on contiguity (common borders).
The method builds up the clusters using agglomerative hierarchical clustering methods:
single linkage, complete linkage, average linkage and Ward's method (a special form of centroid linkage).
Meanwhile, it also maintains the spatial contiguity when merging two clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>schc(
  k,
  w,
  df,
  method = "average",
  bound_variable = data.frame(),
  min_bound = 0,
  scale_method = "standardize",
  distance_method = "euclidean",
  rdist = numeric()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="schc_+3A_k">k</code></td>
<td>
<p>The number of clusters</p>
</td></tr>
<tr><td><code id="schc_+3A_w">w</code></td>
<td>
<p>An instance of Weight class</p>
</td></tr>
<tr><td><code id="schc_+3A_df">df</code></td>
<td>
<p>A data frame with selected variables only. E.g. guerry[c(&quot;Crm_prs&quot;, &quot;Crm_prp&quot;, &quot;Litercy&quot;)]</p>
</td></tr>
<tr><td><code id="schc_+3A_method">method</code></td>
<td>
<p>&quot;single&quot;, &quot;complete&quot;, &quot;average&quot;,&quot;ward&quot;</p>
</td></tr>
<tr><td><code id="schc_+3A_bound_variable">bound_variable</code></td>
<td>
<p>(optional) A data frame with selected bound variabl</p>
</td></tr>
<tr><td><code id="schc_+3A_min_bound">min_bound</code></td>
<td>
<p>(optional) A minimum bound value that applies to all clusters</p>
</td></tr>
<tr><td><code id="schc_+3A_scale_method">scale_method</code></td>
<td>
<p>One of the scaling methods 'raw', 'standardize', 'demean', 'mad', 'range_standardize', 'range_adjust' to apply on input data. Default is 'standardize' (Z-score normalization).</p>
</td></tr>
<tr><td><code id="schc_+3A_distance_method">distance_method</code></td>
<td>
<p>(optional) The distance method used to compute the distance betwen observation i and j. Defaults to &quot;euclidean&quot;. Options are &quot;euclidean&quot; and &quot;manhattan&quot;</p>
</td></tr>
<tr><td><code id="schc_+3A_rdist">rdist</code></td>
<td>
<p>(optional) The distance matrix (lower triangular matrix, column wise storage)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A names list with names &quot;Clusters&quot;, &quot;Total sum of squares&quot;, &quot;Within-cluster sum of squares&quot;, &quot;Total within-cluster sum of squares&quot;, and &quot;The ratio of between to total sum of squares&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
data &lt;- guerry[c('Crm_prs','Crm_prp','Litercy','Donatns','Infants','Suicids')]
guerry_clusters &lt;- schc(4, queen_w, data, "complete")
guerry_clusters
</code></pre>

<hr>
<h2 id='set_neighbors'>Set neighbors of an observation</h2><span id='topic+set_neighbors'></span>

<h3>Description</h3>

<p>Set neighbors for idx-th observation, idx starts from 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_neighbors(gda_w, idx, nbrs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_neighbors_+3A_gda_w">gda_w</code></td>
<td>
<p>A Weight object</p>
</td></tr>
<tr><td><code id="set_neighbors_+3A_idx">idx</code></td>
<td>
<p>A value indicates idx-th observation, idx start from 1</p>
</td></tr>
<tr><td><code id="set_neighbors_+3A_nbrs">nbrs</code></td>
<td>
<p>A list indicates the neighbors of idx-th observation
(id start from 1)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
new_w &lt;- create_weights(10)
set_neighbors(new_w, 1, c(2,3))
update_weights(new_w)

## End(Not run)
</code></pre>

<hr>
<h2 id='set_neighbors_with_weights'>Set neighbors and weights values of an observation</h2><span id='topic+set_neighbors_with_weights'></span>

<h3>Description</h3>

<p>Set neighbors and the associated weights values for idx-th
observation, idx starts from 1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_neighbors_with_weights(gda_w, idx, nbrs, wvals)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_neighbors_with_weights_+3A_gda_w">gda_w</code></td>
<td>
<p>A Weight object</p>
</td></tr>
<tr><td><code id="set_neighbors_with_weights_+3A_idx">idx</code></td>
<td>
<p>A value indicates idx-th observation, idx start from 1</p>
</td></tr>
<tr><td><code id="set_neighbors_with_weights_+3A_nbrs">nbrs</code></td>
<td>
<p>A list indicates the neighbors of idx-th observation
(id start from 1)</p>
</td></tr>
<tr><td><code id="set_neighbors_with_weights_+3A_wvals">wvals</code></td>
<td>
<p>A list indicates the associated weights values of the neighbors</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
new_w &lt;- create_weights(10)
set_neighbors(new_w, 1, c(2,3))
update_weights(new_w)

## End(Not run)
</code></pre>

<hr>
<h2 id='sf_to_geoda'>Create an instance of geoda-class from a 'sf' object</h2><span id='topic+sf_to_geoda'></span>

<h3>Description</h3>

<p>Create an instance of geoda-class from a 'sf' object returned
from 'st_read()' function. NOTE: The table content is NOT used to create an
instance of geoda-class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sf_to_geoda(sf_obj, with_table = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sf_to_geoda_+3A_sf_obj">sf_obj</code></td>
<td>
<p>An instance of 'sf' object</p>
</td></tr>
<tr><td><code id="sf_to_geoda_+3A_with_table">with_table</code></td>
<td>
<p>A boolean flag indicates if table is copied from sf object
to create geoda object. Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of geoda-class
</p>

<hr>
<h2 id='skater'>Spatial C(K)luster Analysis by Tree Edge Removal</h2><span id='topic+skater'></span>

<h3>Description</h3>

<p>SKATER forms clusters by spatially partitioning data that has
similar values for features of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skater(
  k,
  w,
  df,
  bound_variable = data.frame(),
  min_bound = 0,
  scale_method = "standardize",
  distance_method = "euclidean",
  random_seed = 123456789,
  cpu_threads = 6,
  rdist = numeric()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="skater_+3A_k">k</code></td>
<td>
<p>The number of clusters</p>
</td></tr>
<tr><td><code id="skater_+3A_w">w</code></td>
<td>
<p>An instance of Weight class</p>
</td></tr>
<tr><td><code id="skater_+3A_df">df</code></td>
<td>
<p>A data frame with selected variables only.
E.g. guerry[c(&quot;Crm_prs&quot;, &quot;Crm_prp&quot;, &quot;Litercy&quot;)]</p>
</td></tr>
<tr><td><code id="skater_+3A_bound_variable">bound_variable</code></td>
<td>
<p>(optional) A data frame with selected bound variable</p>
</td></tr>
<tr><td><code id="skater_+3A_min_bound">min_bound</code></td>
<td>
<p>(optional) A minimum bound value that applies to all
clusters</p>
</td></tr>
<tr><td><code id="skater_+3A_scale_method">scale_method</code></td>
<td>
<p>One of the scaling methods 'raw', 'standardize',
'demean', 'mad', 'range_standardize', 'range_adjust' to apply on input data.
Default is 'standardize' (Z-score normalization).</p>
</td></tr>
<tr><td><code id="skater_+3A_distance_method">distance_method</code></td>
<td>
<p>(optional) The distance method used to compute the
distance betwen observation i and j. Defaults to &quot;euclidean&quot;. Options are
&quot;euclidean&quot; and &quot;manhattan&quot;</p>
</td></tr>
<tr><td><code id="skater_+3A_random_seed">random_seed</code></td>
<td>
<p>(int,optional) The seed for random number generator.
Defaults to 123456789.</p>
</td></tr>
<tr><td><code id="skater_+3A_cpu_threads">cpu_threads</code></td>
<td>
<p>(optional) The number of cpu threads used for parallel
computation</p>
</td></tr>
<tr><td><code id="skater_+3A_rdist">rdist</code></td>
<td>
<p>(optional) The distance matrix (lower triangular matrix,
column wise storage)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A names list with names &quot;Clusters&quot;, &quot;Total sum of squares&quot;,
&quot;Within-cluster sum of squares&quot;, &quot;Total within-cluster sum of squares&quot;,
and &quot;The ratio of between to total sum of squares&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
data &lt;- guerry[c('Crm_prs','Crm_prp','Litercy','Donatns','Infants','Suicids')]
guerry_clusters &lt;- skater(4, queen_w, data)
guerry_clusters
</code></pre>

<hr>
<h2 id='sp_to_geoda'>Create an instance of geoda-class from a 'sp' object</h2><span id='topic+sp_to_geoda'></span>

<h3>Description</h3>

<p>Create an instance of geoda-class from a 'sp' object. NOTE: The
table content is NOT used to create an instance of geoda-class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp_to_geoda(sp_obj, with_table = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp_to_geoda_+3A_sp_obj">sp_obj</code></td>
<td>
<p>An instance of 'sp' object</p>
</td></tr>
<tr><td><code id="sp_to_geoda_+3A_with_table">with_table</code></td>
<td>
<p>A boolean flag indicates if table is copied from sf object
to create geoda object. Default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An instance of geoda-class
</p>

<hr>
<h2 id='spatial_lag'>Spatial Lag</h2><span id='topic+spatial_lag'></span>

<h3>Description</h3>

<p>Compute the spatial lag for idx-th observation using selected
variable and current weights matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_lag(gda_w, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_lag_+3A_gda_w">gda_w</code></td>
<td>
<p>A Weight object</p>
</td></tr>
<tr><td><code id="spatial_lag_+3A_df">df</code></td>
<td>
<p>A data frame with selected variable only. E.g. guerry[&quot;Crm_prs&quot;]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with one column &quot;Spatial Lag&quot;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
crm_lag &lt;- spatial_lag(queen_w, guerry["Crm_prs"])
crm_lag

## End(Not run)
</code></pre>

<hr>
<h2 id='spatial_validation'>Spatial Validation</h2><span id='topic+spatial_validation'></span>

<h3>Description</h3>

<p>Spatial validation provides a collection of validation measures including
1. fragmentations (entropy, simpson), 2. join count ratio, 3. compactness (isoperimeter quotient)
and 4. diameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_validation(sf_obj, clusters, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_validation_+3A_sf_obj">sf_obj</code></td>
<td>
<p>An sf (simple feature) object</p>
</td></tr>
<tr><td><code id="spatial_validation_+3A_clusters">clusters</code></td>
<td>
<p>A cluster classification variable (categorical values from a dataframe or values returned from cluster functions)</p>
</td></tr>
<tr><td><code id="spatial_validation_+3A_w">w</code></td>
<td>
<p>An instance of Weight class</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with names &quot;Is Spatially Constrained&quot;, &quot;Fragmentation&quot;, &quot;Join Count Ratio&quot;,
&quot;Compactness&quot;, and &quot;Diameter&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
data &lt;- guerry[c('Crm_prs','Crm_prp','Litercy','Donatns','Infants','Suicids')]
clusters &lt;- skater(5, queen_w, data)
results &lt;- spatial_validation(guerry, clusters, queen_w)
results

## End(Not run)
</code></pre>

<hr>
<h2 id='stddev_breaks'>Standard Deviation Breaks</h2><span id='topic+stddev_breaks'></span>

<h3>Description</h3>

<p>Standard deviation breaks first transforms data to standard
deviation units (mean=0, stddev=1), and then divide the range of values into
6 groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stddev_breaks(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stddev_breaks_+3A_df">df</code></td>
<td>
<p>A data frame with selected variable. E.g. guerry[&quot;Crm_prs&quot;]</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numeric values of computed breaks
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
stddev_breaks(guerry['Crm_prs'])
</code></pre>

<hr>
<h2 id='summary.Weight'>Summary of Spatial Weights</h2><span id='topic+summary.Weight'></span>

<h3>Description</h3>

<p>Override the summary() function for spatial weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Weight'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Weight_+3A_object">object</code></td>
<td>
<p>A Weight object</p>
</td></tr>
<tr><td><code id="summary.Weight_+3A_...">...</code></td>
<td>
<p>summary optional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A summary description of an instance of Weight-class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sf)
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
summary(queen_w)

## End(Not run)
</code></pre>

<hr>
<h2 id='update_weights'>Update meta data of a spatial weights</h2><span id='topic+update_weights'></span>

<h3>Description</h3>

<p>Update meta data of a spatial weights. This function can be used
after calling 'set_neighbor()' function .
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_weights(gda_w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_weights_+3A_gda_w">gda_w</code></td>
<td>
<p>A Weight object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
new_w &lt;- create_weights(10)
set_neighbors(new_w, 1, c(2,3))
update_weights(new_w)

## End(Not run)
</code></pre>

<hr>
<h2 id='Weight-class'>Weight class (Internally Used)</h2><span id='topic+Weight-class'></span><span id='topic+Weight'></span>

<h3>Description</h3>

<p>A wrapper class for p_GeoDaWeight class
</p>


<h3>Fields</h3>


<dl>
<dt><code>gda_w</code></dt><dd><p>An object of p_GeoDaWeight-class</p>
</dd>
<dt><code>is_symmetric</code></dt><dd><p>If weights matrix is symmetric</p>
</dd>
<dt><code>sparsity</code></dt><dd><p>Sparsity of weights matrix</p>
</dd>
<dt><code>min_neighbors</code></dt><dd><p>Minimum number of neighbors</p>
</dd>
<dt><code>max_neighbors</code></dt><dd><p>Maximum number of neighbors</p>
</dd>
<dt><code>num_obs</code></dt><dd><p>Number of observations</p>
</dd>
<dt><code>mean_neighbors</code></dt><dd><p>Mean number of neighbors</p>
</dd>
<dt><code>median_neighbors</code></dt><dd><p>Median number of neighbors</p>
</dd>
<dt><code>has_isolates</code></dt><dd><p>If the weights matrix has any isolates</p>
</dd>
</dl>


<h3>Methods</h3>


<dl>
<dt><code>GetNeighborWeights(idx)</code></dt><dd><p>Get weights values of neighbors for idx-th observation,
idx starts from 0</p>
</dd>
<dt><code>GetNeighbors(idx)</code></dt><dd><p>Get neighbors for idx-th observation, idx starts from 0</p>
</dd>
<dt><code>GetPointer()</code></dt><dd><p>Get the C++ object pointer (internally used)</p>
</dd>
<dt><code>GetSparsity()</code></dt><dd><p>Get sparsity computed from weights matrix</p>
</dd>
<dt><code>HasIsolates()</code></dt><dd><p>Check if weights matrix has isolates, or if any observation has no
neighbors</p>
</dd>
<dt><code>IsSymmetric()</code></dt><dd><p>Check if weights matrix is symmetric</p>
</dd>
<dt><code>SaveToFile(out_path, layer_name, id_name, id_values)</code></dt><dd><p>Save current spatial weights to a file.<br /> <br />
out_path: The path of an output weights file <br />
layer_name : The name of the layer of input dataset <br />
id_name : The id name (or field name), which is an associated column
contains unique values, that makes sure that the weights are connected
to the correct observations in the data table.<br />
id_values : The tuple of values of selected id_name (column/field)</p>
</dd>
<dt><code>SetNeighbors(idx, nbrs)</code></dt><dd><p>Set neighbors for one observation</p>
</dd>
<dt><code>SetNeighborsAndWeights(idx, nbrs, nbr_w)</code></dt><dd><p>Set neighbors with weights values for one observation</p>
</dd>
<dt><code>SpatialLag(values)</code></dt><dd><p>Compute spatial lag values for values of selected variable</p>
</dd>
<dt><code>Update(updateStats = TRUE)</code></dt><dd><p>Update the weights meta data</p>
</dd>
<dt><code>initialize(o_gda_w)</code></dt><dd><p>Constructor with a GeoDaWeight object (internally used)</p>
</dd>
</dl>

<hr>
<h2 id='weights_sparsity'>Sparsity of Spatial Weights</h2><span id='topic+weights_sparsity'></span>

<h3>Description</h3>

<p>Get sparsity (
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weights_sparsity(gda_w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weights_sparsity_+3A_gda_w">gda_w</code></td>
<td>
<p>A Weight object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value of spatial weights sparsity
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
guerry_path &lt;- system.file("extdata", "Guerry.shp", package = "rgeoda")
guerry &lt;- st_read(guerry_path)
queen_w &lt;- queen_weights(guerry)
weights_sparsity(queen_w)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
