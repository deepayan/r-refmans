<!DOCTYPE html><html><head><title>Help for package rmcfs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rmcfs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#artificial.data'><p>Creates artificial dataset</p></a></li>
<li><a href='#build.idgraph'><p>Constructs interdependencies graph</p></a></li>
<li><a href='#export.plots'><p>Exports MCFS-ID result plots</p></a></li>
<li><a href='#export.result'><p>Saves MCFS-ID result into set csv files</p></a></li>
<li><a href='#fix.data'><p>Fixes input data values, column names and attributes types</p></a></li>
<li><a href='#import.result'><p>Reads csv result files produced by the MCFS-ID Java module</p></a></li>
<li><a href='#mcfs'><p>MCFS-ID (Monte Carlo Feature Selection and Interdependency Discovery)</p></a></li>
<li><a href='#plot.idgraph'><p>Plots interdependencies graph</p></a></li>
<li><a href='#plot.mcfs'><p>Plots various MCFS result components</p></a></li>
<li><a href='#print.mcfs'><p>Prints mcfs result</p></a></li>
<li><a href='#prune.data'><p>Filters input data</p></a></li>
<li><a href='#read.adh'><p>Reads data from ADH</p></a></li>
<li><a href='#read.adx'><p>Reads data from ADX</p></a></li>
<li><a href='#showme'><p>Basic data information</p></a></li>
<li><a href='#write.adh'><p>Writes data to ADH</p></a></li>
<li><a href='#write.adx'><p>Writes data to ADX</p></a></li>
<li><a href='#write.arff'><p>Writes data to ARFF</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>The MCFS-ID Algorithm for Feature Selection and Interdependency
Discovery</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-09-17</td>
</tr>
<tr>
<td>Depends:</td>
<td>rJava (&ge; 0.5-0), R (&ge; 2.70)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Imports:</td>
<td>yaml, ggplot2, gridExtra, reshape2, dplyr, stringi, igraph,
data.table (&ge; 1.0.1)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Java (&gt;= 7)</td>
</tr>
<tr>
<td>Description:</td>
<td>MCFS-ID (Monte Carlo Feature Selection and Interdependency Discovery) is a Monte Carlo method-based tool for feature selection. It also allows for the discovery of interdependencies between the relevant features. MCFS-ID is particularly suitable for the analysis of high-dimensional, 'small n large p' transactional and biological data. M. Draminski, J. Koronacki (2018) &lt;<a href="https://doi.org/10.18637%2Fjss.v085.i12">doi:10.18637/jss.v085.i12</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://home.ipipan.waw.pl/m.draminski/mcfs.html">https://home.ipipan.waw.pl/m.draminski/mcfs.html</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>no</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-09-17 15:32:16 UTC; mdraminski</td>
</tr>
<tr>
<td>Author:</td>
<td>Michal Draminski [aut, cre],
  Jacek Koronacki [aut],
  Julian Zubek [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michal Draminski &lt;michal.draminski@ipipan.waw.pl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-09-18 13:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='artificial.data'>Creates artificial dataset</h2><span id='topic+artificial.data'></span>

<h3>Description</h3>

<p>Creates <code>data.frame</code> with artificial data. The last six columns are nominal and highly correlated to feature 'class'. This data set consists of objects from 3 classes, <em>A</em>, <em>B</em> and <em>C</em>, that contain 40, 20, 10 objects, respectively (70 objects altogether). For each object, 6 binary features (<em>A1</em>, <em>A2</em>, <em>B1</em>, <em>B2</em>, <em>C1</em> and <em>C2</em>) are created and they are 'ideally' or 'almost ideally' correlated with <em>class</em> feature. If an object's <em>'class'</em> equals <em>'A'</em>, then its features <em>A1</em> and <em>A2</em> are set to class value <em>'A'</em>; otherwise <em>A1 = A2 = 0</em>. If an object's <em>'class'</em> is <em>'B'</em> or <em>'C'</em>, the processing is analogous, but some random corruption is introduced. For 2 observations from class <em>'B'</em> and both attributes <em>B1/B2</em>, their values <em>'B'</em> are replaced by '0'. For 4 observations from class <em>'C'</em> and both attributes <em>C1/C2</em>, their values <em>'C'</em> are replaced by '0'. The number of corrupted values for each class is defined by <code>corruption</code> parameter. The data also contains additional <code>rnd_features = 500</code> random numerical features with uniformly [0,1] distributed values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>artificial.data(rnd_features = 500, size = c(40, 20, 10), 
                        corruption = c(0, 2, 4), seed = NA)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="artificial.data_+3A_rnd_features">rnd_features</code></td>
<td>
<p>number of numerical random features.</p>
</td></tr>
<tr><td><code id="artificial.data_+3A_size">size</code></td>
<td>
<p>size of classes <em>A</em>, <em>B</em>, and <em>C</em>.</p>
</td></tr>
<tr><td><code id="artificial.data_+3A_corruption">corruption</code></td>
<td>
<p>defines the number of corrupted values for a pairs of columns <em>A1/A2</em>, <em>B1/B2</em>, <em>C1/C2</em>,</p>
</td></tr>
<tr><td><code id="artificial.data_+3A_seed">seed</code></td>
<td>
<p>seed for random number generator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with six important features.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  d &lt;- artificial.data(rnd_features = 500)
  showme(d)
</code></pre>

<hr>
<h2 id='build.idgraph'>Constructs interdependencies graph</h2><span id='topic+build.idgraph'></span>

<h3>Description</h3>

<p>Constructs the ID-Graph (igraph/idgraph object) from <code>mcfs_result</code> object returned by <code><a href="#topic+mcfs">mcfs</a></code> function.
The number of top features included and the number of ID-Graph edges can be customized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>build.idgraph(mcfs_result, 
                      size = NA, 
                      size_ID = NA, 
                      self_ID = FALSE,
                      outer_ID = FALSE,
                      orphan_nodes = FALSE, 
                      size_ID_mult = 3, 
                      size_ID_max = 100)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="build.idgraph_+3A_mcfs_result">mcfs_result</code></td>
<td>
<p>results returned by <code><a href="#topic+mcfs">mcfs</a></code> function.</p>
</td></tr>
<tr><td><code id="build.idgraph_+3A_size">size</code></td>
<td>
<p>number of top features to select. If <code>size = NA</code>, then <code>size</code> is defined by <code>mcfs_result$cutoff_value</code> parameter.</p>
</td></tr>
<tr><td><code id="build.idgraph_+3A_size_id">size_ID</code></td>
<td>
<p>number of interdependencies (edges in ID-Graph) to be included. If <code>size_ID = NA</code>, then parameter <code>size_ID</code> is defined by multiplication <code>size_ID_mult</code>*<code>size</code>.</p>
</td></tr>
<tr><td><code id="build.idgraph_+3A_self_id">self_ID</code></td>
<td>
<p>if <code>self_ID = TRUE</code>, then include self-loops from ID-Graph.</p>
</td></tr>
<tr><td><code id="build.idgraph_+3A_outer_id">outer_ID</code></td>
<td>
<p>if <code>outer_ID = TRUE</code>, then include include all interactions between a feature from the top set features (defined by <code>size</code> parameter) with any other feature.</p>
</td></tr>
<tr><td><code id="build.idgraph_+3A_orphan_nodes">orphan_nodes</code></td>
<td>
<p>if <code>plot_all_nodes = TRUE</code>, then include all nodes, even if they are not connected to any other node (isolated nodes).</p>
</td></tr>
<tr><td><code id="build.idgraph_+3A_size_id_mult">size_ID_mult</code></td>
<td>
<p>If <code>size_ID_mult = 3</code> there will be 3 times more edges than features (nodes) presented on the ID-Graph. It works only if <code>size = NA</code> and <code>size_ID = NA</code></p>
</td></tr>
<tr><td><code id="build.idgraph_+3A_size_id_max">size_ID_max</code></td>
<td>
<p>maximum number of interactions to be included from ID-Graph (the upper limit).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><em>igraph/idgraph</em> S3 object that can be: plotted in R, exported to graphML (XML format) or saved as csv or rds files.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: ###dontrunbegin

  # create input data
  adata &lt;- artificial.data(rnd_features = 10)
  showme(adata)
  
  # Parametrize and run MCFS-ID procedure
  result &lt;- mcfs(class~., adata, cutoffPermutations = 0, featureFreq = 50,
                  buildID = TRUE, finalCV = FALSE, finalRuleset = FALSE,
                  threadsNumber = 2)

  # build interdependencies graph for top 6 features 
  # and top 12 interdependencies and plot all nodes
  gid &lt;- build.idgraph(result, size = 6, size_ID = 12, orphan_nodes = TRUE)
  plot(gid, label_dist = 1)

  # Export graph to graphML (XML structure)
  path &lt;- tempdir()
  igraph::write.graph(gid, file = file.path(path, "artificial.graphml"), 
            format = "graphml", prefixAttr = FALSE)

  
## End(Not run)###dontrunend
</code></pre>

<hr>
<h2 id='export.plots'>Exports MCFS-ID result plots</h2><span id='topic+export.plots'></span>

<h3>Description</h3>

<p>Saves all MCFS-ID result plots in the specified directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export.plots(mcfs_result, data = NULL, idgraph = NULL, 
                    path, label = "mcfs", color = "darkred",
                    size = NA, image_width = 8, image_height = 6, 
                    plot_format = c("pdf","svg","png"), cex = 1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="export.plots_+3A_mcfs_result">mcfs_result</code></td>
<td>
<p>result from <code><a href="#topic+mcfs">mcfs</a></code> function.</p>
</td></tr>
<tr><td><code id="export.plots_+3A_data">data</code></td>
<td>
<p>input data frame used to produce <code>mcfs_result</code>.</p>
</td></tr>
<tr><td><code id="export.plots_+3A_idgraph">idgraph</code></td>
<td>
<p><em>idgraph/igraph</em> S3 object representing feature interdependencies. This object is produced by <code><a href="#topic+build.idgraph">build.idgraph</a></code> function.</p>
</td></tr>
<tr><td><code id="export.plots_+3A_path">path</code></td>
<td>
<p>path to the where plot files should be saved.</p>
</td></tr>
<tr><td><code id="export.plots_+3A_label">label</code></td>
<td>
<p>a common prefix label of all plot files.</p>
</td></tr>
<tr><td><code id="export.plots_+3A_color">color</code></td>
<td>
<p>it defines main color of all plots.</p>
</td></tr>
<tr><td><code id="export.plots_+3A_size">size</code></td>
<td>
<p>number of features to plot.</p>
</td></tr>
<tr><td><code id="export.plots_+3A_image_width">image_width</code></td>
<td>
<p>width of plots (in inches).</p>
</td></tr>
<tr><td><code id="export.plots_+3A_image_height">image_height</code></td>
<td>
<p>height of plots (in inches).</p>
</td></tr>
<tr><td><code id="export.plots_+3A_plot_format">plot_format</code></td>
<td>
<p>image format of plot files - one of the following: &quot;pdf&quot;,&quot;svg&quot;,&quot;png&quot;.</p>
</td></tr>
<tr><td><code id="export.plots_+3A_cex">cex</code></td>
<td>
<p>size of fonts.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: ###dontrunbegin
  
  # create input data
  adata &lt;- artificial.data(rnd_features = 10)
  showme(adata)
  
  # Parametrize and run MCFS-ID procedure
  result &lt;- mcfs(class~., adata, cutoffPermutations = 0, featureFreq = 50,
                  finalCV = FALSE, finalRuleset = FALSE, threadsNumber = 2)
  
  # build interdependencies graph for top 6 features 
  # and top 12 interdependencies and plot all nodes
  gid &lt;- build.idgraph(result, size = 6, size_ID = 12, orphan_nodes = TRUE)

  #export plot files
  export.plots(result, adata, idgraph = gid, path = tempdir(), label = "mcfs", color = "darkgreen")

  
## End(Not run)###dontrunend
</code></pre>

<hr>
<h2 id='export.result'>Saves MCFS-ID result into set csv files</h2><span id='topic+export.result'></span>

<h3>Description</h3>

<p>Saves csv files with result obtained by the MCFS-ID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export.result(mcfs_result, path = "./", label = "rmcfs", zip = TRUE)</code></pre>


<h3>Arguments</h3>

  
<table>
<tr><td><code id="export.result_+3A_mcfs_result">mcfs_result</code></td>
<td>
<p>result of the MCFS-ID experiment returned by <code><a href="#topic+mcfs">mcfs</a></code> function.</p>
</td></tr>
<tr><td><code id="export.result_+3A_path">path</code></td>
<td>
<p>path to the MCFS-ID results files. This parameter can also point to the zip result file.</p>
</td></tr>
<tr><td><code id="export.result_+3A_label">label</code></td>
<td>
<p>label of the experiment and common name for output files.</p>
</td></tr>
<tr><td><code id="export.result_+3A_zip">zip</code></td>
<td>
<p>if <code>= TRUE</code>, saves all results data as one zip file.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: ###dontrunbegin
  
  # create input data
  adata &lt;- artificial.data(rnd_features = 10)
  showme(adata)
  
  # Parametrize and run MCFS-ID procedure
  result &lt;- mcfs(class~., adata, cutoffPermutations = 0, featureFreq = 10,
                  finalCV = FALSE, finalRuleset = FALSE, threadsNumber = 2)

  # Export and import R result to/from files
  path &lt;- file.path(tempdir(), "artificial.zip")
  export.result(result, path = path)
  result &lt;- import.result(path = path)
  
  
## End(Not run)###dontrunend
</code></pre>

<hr>
<h2 id='fix.data'>Fixes input data values, column names and attributes types</h2><span id='topic+fix.data'></span>

<h3>Description</h3>

<p>Fixes any input data to prepare them to export to ARFF/ADX formats. If after exporting data to ARFF/ADX formats there are some problems in running Java MCFS or WEKA, try to use this function before. This function fixes data values (e.g. space &quot; &quot; is replaced by &quot;_&quot;) and data types (e.g. all Date columns converted to character in R).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fix.data(x, 
          type = c("all", "names", "values", "types"), 
          source_chars = c(" ", "'", ",", "/", "|", "#", 
                           "-", "(", ")", "[", "]", "{", "}"),
          destination_char = "_", 
          numeric_class = c("difftime"), 
          nominal_class = c("factor", "logical", "Date", "POSIXct", "POSIXt"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fix.data_+3A_x">x</code></td>
<td>
<p>input data frame to be fixed.</p>
</td></tr>
<tr><td><code id="fix.data_+3A_type">type</code></td>
<td>


<ul>
<li><p><code>all</code> - fixes: column names, data values, data types.
</p>
</li>
<li><p><code>names</code> - fixes only column names. All characters determined by <code>source_chars</code> parameter are replaced by <code>destination_char</code> (e.g. space &quot; &quot; is replaced by &quot;_&quot;).
</p>
</li>
<li><p><code>values</code> - fixes only data values. All characters determined by <code>source_chars</code> parameter are replaced by <code>destination_char</code> (e.g. space &quot; &quot; is replaced by &quot;_&quot;).
</p>
</li>
<li><p><code>types</code> - fixes only data types (e.g. all possible nominal columns as (Date or logical) converted to character).
</p>
</li></ul>
</td></tr>
<tr><td><code id="fix.data_+3A_source_chars">source_chars</code></td>
<td>
<p>characters that will be replaced in column names and data values.</p>
</td></tr>
<tr><td><code id="fix.data_+3A_destination_char">destination_char</code></td>
<td>
<p>character that will be inserted in column names and data values.</p>
</td></tr>
<tr><td><code id="fix.data_+3A_numeric_class">numeric_class</code></td>
<td>
<p>vector of class labels to be casted <code>as.numeric</code>.</p>
</td></tr>
<tr><td><code id="fix.data_+3A_nominal_class">nominal_class</code></td>
<td>
<p>vector of class labels to be casted <code>as.character</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with fixed values and types (depends on <code>type</code> parameter).</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: ###dontrunbegin

  # create artificial data
  adata &lt;- artificial.data(rnd_features = 1000)
  
  # Fix data types and data values - remove "," " " "/" from values and fix data types
  # This function may help if mcfs has any problems with input data
  adata.fixed &lt;- fix.data(adata)
  
  
## End(Not run)###dontrunend
</code></pre>

<hr>
<h2 id='import.result'>Reads csv result files produced by the MCFS-ID Java module</h2><span id='topic+import.result'></span>

<h3>Description</h3>

<p>Reads csv result files produced by the MCFS-ID Java module.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import.result(path = "./", label = NA)</code></pre>


<h3>Arguments</h3>

  
<table>
<tr><td><code id="import.result_+3A_path">path</code></td>
<td>
<p>path to the MCFS-ID results files. This parameter can also point to the zip result file.</p>
</td></tr>
<tr><td><code id="import.result_+3A_label">label</code></td>
<td>
<p>experiment label for results files (name of the data).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the result of the MCFS-ID experiment returned by <code><a href="#topic+mcfs">mcfs</a></code> function.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: ###dontrunbegin

  # create input data
  adata &lt;- artificial.data(rnd_features = 10)
  showme(adata)
  
  # Parametrize and run MCFS-ID procedure
  result &lt;- mcfs(class~., adata, cutoffPermutations = 0, featureFreq = 10,
                  finalCV = FALSE, finalRuleset = FALSE, threadsNumber = 2)

  # Export and import R result to/from files
  path &lt;- file.path(tempdir(), "artificial.zip")
  export.result(result, path = path)
  result &lt;- import.result(path = path)

  
  
## End(Not run)###dontrunend
</code></pre>

<hr>
<h2 id='mcfs'>MCFS-ID (Monte Carlo Feature Selection and Interdependency Discovery)</h2><span id='topic+mcfs'></span>

<h3>Description</h3>

<p>Performs Monte Carlo Feature Selection (MCFS-ID) on a given data set. The data set
should define a classification problem with discrete/nominal class labels. This
function returns features sorted by RI as well as cutoff value, ID-Graph edges that denote interdependencies (ID), evaluation of top features and other statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcfs(formula, data,
    attrWeights = NULL,
    projections = 'auto',
    projectionSize = 'auto',
    featureFreq = 100,
    splits = 5,
    splitSetSize = 500,
    balance = 'auto',
    cutoffMethod = c("permutations", "criticalAngle", "kmeans", "mean", "contrast"),
    cutoffPermutations = 20,
    mode = 1,
    buildID = TRUE,
    finalRuleset = TRUE,
    finalCV = TRUE,
    finalCVSetSize = 1000,
    seed = NA,
    threadsNumber = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcfs_+3A_formula">formula</code></td>
<td>
<p>specifies decision attribute and relation between class and other attributes (e.g. <code>class~.</code>). The target attribute can be nominal (then MCFS-ID uses decision tree) or numerical (then MCFS-ID uses regression tree).</p>
</td></tr>
<tr><td><code id="mcfs_+3A_data">data</code></td>
<td>
<p>defines input <em>data.frame</em> containing all features with decision attribute included. This data.frame must contain proper types of columns. Columns <code>character</code>, <code>factor</code>, <code>Date</code>, <code>POSIXct</code>, <code>POSIXt</code> are treated as nominal/categorical and remaining columns as numerical/continuous. Decision attribute defined by <code>formula</code> can be nominal or numerical.</p>
</td></tr>
<tr><td><code id="mcfs_+3A_attrweights">attrWeights</code></td>
<td>
<p>defines vector of <code>length = ncol(data)</code> of attributes weights - weight 10 denotes 10 times larger chance for the attribute to be selected to the random subset than if weight equals to 1.</p>
</td></tr>
<tr><td><code id="mcfs_+3A_projections">projections</code></td>
<td>
<p>defines the number of subsets (projections) with randomly selected features. This parameter is usually set to a few thousands and is denoted in the paper as <em>s</em>. By default it is set to 'auto' and this value is based on size of input data set and <em>featureFreq</em> parameter.</p>
</td></tr>
<tr><td><code id="mcfs_+3A_projectionsize">projectionSize</code></td>
<td>
<p>defines the number of features in one subset. It can be defined by an absolute value (e.g. 100 denotes 100 randomly selected features) or by a fraction of input attributes (e.g. 0.05 denotes 5% of input features). This parameter is denoted in the paper as <em>m</em>. If is set to 'auto' then <em>projectionSize</em> equals to 
<code class="reqn">\sqrt{d}</code>, where <em>d</em> is the number of input features. Minimum number of features in one subset is 1.</p>
</td></tr>
<tr><td><code id="mcfs_+3A_featurefreq">featureFreq</code></td>
<td>
<p>determines how many times each input feature should be randomly selected when <code>projections = 'auto'</code>.</p>
</td></tr>
<tr><td><code id="mcfs_+3A_splits">splits</code></td>
<td>
<p>defines the number of splits of each subset. This parameter is denoted in the paper as <em>t</em>. The size of the training set in the input subset is always set on 66%.</p>
</td></tr>
<tr><td><code id="mcfs_+3A_splitsetsize">splitSetSize</code></td>
<td>
<p>determines whether to limit input dataset size. It helps to speedup computation for data sets with a large number of objects. If the parameter is larger than 1, it determines the number of objects that are drawn at random for each of the <code class="reqn">s \cdot t</code> decision trees. If <code>splitSetSize = 0</code> then the MCFS uses all objects in each iteration.</p>
</td></tr>
<tr><td><code id="mcfs_+3A_balance">balance</code></td>
<td>
<p>determines the way to balance classes. It should be set to 2 or higher if input dataset contains heavily unbalanced classes. Each subset <em>s</em> will contain all the objects from the least frequent class and randomly selected set of objects from each of the remaining classes. This option helps to select features that are important for discovering a relatively rare class. The parameter defines the maximal imbalance ratio. If the ratio is set to 2, then subset <em>s</em> will contain the number of objects from each class (but the least frequent one) proportional to the square root of the class size <code class="reqn">size(c)^{1/2}</code>. If <code>balance = 0</code> then balancing is turned off. If <code>balance = 1</code> it is on but does not change the size of classes. Default value is 'auto'.</p>
</td></tr>
<tr><td><code id="mcfs_+3A_cutoffmethod">cutoffMethod</code></td>
<td>
<p>determines the final cutoff method. Default value is 'permutations'.
The methods of finding cutoff value between important and unimportant attributes are the following:
</p>

<ul>
<li><p><code>permutations</code> - the method consists in permuting the decision attribute at least 20 times and running the MCFS-ID algorithm for each permutation. The set of the maximal RIs from all these experiments is assumed approximately normally distributed and a critical value based on the the one-sided (upper-tailed) Student's t-test (at 95% significance level) is provided. A feature is declared informative if its RI in the original ranking (without any permutation) exceeds the obtained critical value. A more detailed description of this method is included in the paper.
</p>
</li>
<li><p><code>criticalAngle</code> - critical angle method is based on the plot of the features' RIs in decreasing order of size, with the corresponding features equally spaced along the abscissa. The plot can be seen as piecewise linear function, where each linear segment joins two neighboring RIs. Roughly speaking, the cutoff (placed on the abscissa) corresponds to this point on the plot where the slope of consecutive segments changes significantly.
</p>
</li>
<li><p><code>kmeans</code> - the method is based on clustering the RI values into two clusters by the k-means algorithm. It sets the cutoff where the two clusters are separated. This method is quite valuable when data contains a subset of very informative features.
</p>
</li>
<li><p><code>mean</code> - cutoff value is set on mean values obtained from all the implemented methods.
</p>
</li>
<li><p><code>contrast</code> - This method adds 10% contrast (pure numerical random) atributes to the data then MCFS-ID is executed. Position of top 5% of them determines cutoff value. Usually it gives the largest cutoff beacause it select all attributes that are more informative than pure noise. 
</p>
</li></ul>
</td></tr>
<tr><td><code id="mcfs_+3A_cutoffpermutations">cutoffPermutations</code></td>
<td>
<p>determines the number of permutation runs. It needs at least 20 permutations (<code>cutoffPermutations = 20</code>) for a statistically significant result. Minimum value of this parameter is 3, however if it is 0 then permutations method is turned off.</p>
</td></tr>
<tr><td><code id="mcfs_+3A_mode">mode</code></td>
<td>
<p>determines number of stages in MCFS filtering. If <code>mode = 2</code> then MCFS is running new method that is based on two stage filtering. This method is much faster for BIG DATA - 1st stage filtering is performed based on contrast attributes (same as <code>cutoffMethod = 'contrast'</code>) and 2nd stage is performed based on permutations experiments. If <code>mode = 1</code> then it always runs one stage filtering the same as in rmcfs 1.2.x.</p>
</td></tr>
<tr><td><code id="mcfs_+3A_buildid">buildID</code></td>
<td>
<p>if <code>= TRUE</code>, Interdependencies Discovery is on and all ID-Graph edges are collected.</p>
</td></tr>
<tr><td><code id="mcfs_+3A_finalruleset">finalRuleset</code></td>
<td>
<p>if <code>= TRUE</code>, classification rules (by <em>ripper</em> algorithm) are created on the basis of the final set of features.</p>
</td></tr>
<tr><td><code id="mcfs_+3A_finalcv">finalCV</code></td>
<td>
<p>if <code>= TRUE</code>, it runs 10 folds cross validation (cv) experiments on the final set of features. The following set of classifiers is used: C4.5, NB, SVM, kNN, logistic regression and Ripper.</p>
</td></tr>
<tr><td><code id="mcfs_+3A_finalcvsetsize">finalCVSetSize</code></td>
<td>
<p>limits the number of objects used in the final cv experiment. For each out of 3 cv repetitions, the objects are selected randomly from the uniform distribution.</p>
</td></tr>
<tr><td><code id="mcfs_+3A_seed">seed</code></td>
<td>
<p>seed for random number generator in Java. By default the seed is random. Replication of the result is possible only if <code>threadsNumber = 1</code>.</p>
</td></tr>
<tr><td><code id="mcfs_+3A_threadsnumber">threadsNumber</code></td>
<td>
<p>number of threads to use in computation. More threads needs more CPU cores as well as memory usage is a bit higher. It is recommended to set this value equal to or less than CPU available cores.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>data</code></td>
<td>
<p>input data.frame limited to the top important features set.</p>
</td></tr>
<tr><td><code>target</code></td>
<td>
<p>decision attribute name.</p>
</td></tr>
<tr><td><code>RI</code></td>
<td>
<p><em>data.frame</em> that contains all features with relevance scores sorted from the most relevant to the least relevant. This is the ranking of features.</p>
</td></tr>
<tr><td><code>ID</code></td>
<td>
<p><em>data.frame</em> that contains features interdependencies as graph edges. It can be converted into a graph object by <code><a href="#topic+build.idgraph">build.idgraph</a></code> function.</p>
</td></tr>
<tr><td><code>distances</code></td>
<td>
<p><em>data.frame</em> that contains convergence statistics of subsequent projections.</p>
</td></tr>
<tr><td><code>cmatrix</code></td>
<td>
<p>confusion matrix obtained from all <code class="reqn">s \cdot t</code> decision trees.</p>
</td></tr>
<tr><td><code>cutoff</code></td>
<td>
<p><em>data.frame</em> that contains cutoff values obtained by the  following methods: mean, kmeans, criticalAngle, permutations (max RI).</p>
</td></tr>
<tr><td><code>cutoff_value</code></td>
<td>
<p>the number of features chosen as informative by the method defined by parameter <code>cutoffMethod</code>.</p>
</td></tr>
<tr><td><code>cv_accuracy</code></td>
<td>
<p><em>data.frame</em> that contains classification results obtained by cross validation performed on <code>cutoff_value</code> features. This <em>data.frame</em> exists if <code>finalCV = T</code>.</p>
</td></tr> 
<tr><td><code>permutations</code></td>
<td>
<p>this <em>data.frame</em> contains the following results of permutation experiments: 
</p>

<ul>
<li><p><code>perm_x</code> all RI values obtained from all permutation experiments;
</p>
</li>
<li><p><code>RI</code> RI obtained for reference MCFS experiment (i.e, the experiment on the original data); p-values from Anderson-Darling normality test applied separately for each feature to the <code>cutoffPermutations</code> RI set;
</p>
</li>
<li><p><code>t_test_p</code> <code class="reqn">p</code>-values from Student-t test applied separately for each feature to the <code>cutoffPermutations</code> RI vs. reference RI. This <em>data.frame</em> exists if parameter <code>cutoffPermutations &gt; 0</code>.</p>
</li></ul>
</td></tr>
<tr><td><code>jrip</code></td>
<td>
<p>classification rules produced by <em>ripper</em> algorithm and related cross validation result obtained for top features.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>all settings used by MCFS-ID.</p>
</td></tr>
<tr><td><code>exec_time</code></td>
<td>
<p>execution time of MCFS-ID.</p>
</td></tr>
</table>


<h3>References</h3>

<p>M. Draminski, J. Koronacki (2018),&quot;rmcfs: An R Package for Monte Carlo Feature Selection and Interdependency Discovery&quot;, <em>Journal of Statistical Software, vol 85(12)</em>, 1-28, doi:10.18637/jss.v085.i12.
URL: <a href="https://www.jstatsoft.org/v85/i12/">https://www.jstatsoft.org/v85/i12/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: ###dontrunbegin

  ####################################
  ######### Artificial data ##########
  ####################################
  
  # create input data and review it
  adata &lt;- artificial.data(rnd_features = 10)
  showme(adata)
  
  # Parametrize and run MCFS-ID procedure
  result &lt;- mcfs(class~., adata, cutoffPermutations = 3, featureFreq = 50,
                  buildID = TRUE, finalCV = FALSE, finalRuleset = FALSE, 
                 threadsNumber = 2)

  # Print basic information about mcfs result
  print(result)
  
  # Review cutoff values for all methods
  print(result$cutoff)
  
  # Review cutoff value used in plots
  print(result$cutoff_value)
  
  # Plot &amp; print out distances between subsequent projections. 
  # These are convergence MCFS-ID statistics.
  plot(result, type = "distances")
  print(result$distances)
  
  # Plot &amp; print out 50 most important features and show max RI values from 
  # permutation experiment.
  plot(result, type = "ri", size = 50)
  print(head(result$RI, 50))
  
  # Plot &amp; print out 50 strongest feature interdependencies.
  plot(result, type = "id", size = 50)
  print(head(result$ID, 50))
  
  # Plot features ordered by RI. Parameter 'size' is the number of 
  # top features in the chart. By default it is set on cutoff_value + 10
  plot(result, type = "features", cex = 1)

  # Here we set 'size' at fixed value 10.
  plot(result, type = "features", size = 10)
  
  # Plot cv classification result obtained on top features.
  # In the middle of x axis red label denotes cutoff_value.
  # plot(result, type = "cv", cv_measure = "wacc", cex = 0.8)
  
  # Plot &amp; print out confusion matrix. This matrix is the result of 
  # all classifications performed by all decision trees on all s*t datasets.
  plot(result, type = "cmatrix")
  
  # build interdependencies graph (all default parameters).
  gid &lt;- build.idgraph(result)
  plot(gid, label_dist = 1)
  
  # build interdependencies graph for top 6 features 
  # and top 12 interdependencies and plot all nodes
  gid &lt;- build.idgraph(result, size = 6, size_ID = 12, orphan_nodes = TRUE)
  plot(gid, label_dist = 1)

  # Export graph to graphML (XML structure)
  path &lt;- tempdir()
  igraph::write.graph(gid, file = file.path(path, "artificial.graphml"), 
              format = "graphml", prefixAttr = FALSE)
  
  # Export and import results to/from csv files
  export.result(result, path = path, label = "artificial")
  result &lt;- import.result(path = path, label = "artificial")

  ####################################
  ########## Alizadeh data ###########
  ####################################
  
  # Load Alizadeh dataset.
  # A 4026 x 62 gene expression data matrix of log-ratio values. The last column contains 
  # the annotations of the 62 samples with respect to the cancer types C, D, F.
  # The data are from the lymphoma/leukemia study of A. Alizadeh et al., Nature 403:503-511 (2000), 
  # http://llmpp.nih.gov/lymphoma/index.shtml
  
  alizadeh &lt;- read.csv(file="http://home.ipipan.waw.pl/m.draminski/files/data/alizadeh.csv", 
                        stringsAsFactors = FALSE)
  showme(alizadeh)
  
  # Fix data types and data values - replace characters such as "," " " "/" etc. 
  # from values and column names and fix data types
  # This function may help if mcfs has any problems with input data
  alizadeh &lt;- fix.data(alizadeh)
  
  # Run MCFS-ID procedure on default parameters. 
  # For larger real data (thousands of features) default 'auto' settings are the best.
  # This example may take 10-20 minutes but this one is a real dataset with 4026 features.
  # Set up more threads according to your CPU cores number.
  result &lt;- mcfs(class~., alizadeh, featureFreq = 100, cutoffPermutations = 10, threadsNumber = 8)
  
  # Print basic information about mcfs result.
  print(result)
  
  # Plot &amp; print out distances between subsequent projections. 
  plot(result, type="distances")
  
  # Show RI values for top 500 features and max RI values from permutation experiment.
  plot(result, type = "ri", size = 500)
  
  # Plot heatmap on top features, only numeric features are presented
  plot(result, type = "heatmap", size = 20, heatmap_norm = 'norm', heatmap_fun = 'median')
  
  # Plot cv classification result obtained on top features.
  # In the middle of x axis red label denotes cutoff_value.
  plot(result, type = "cv", cv_measure = "wacc", cex = 0.8)
  
  # build interdependencies graph.
  gid &lt;- build.idgraph(result, size = 20)
  plot.idgraph(gid, label_dist = 0.3)
  
  
## End(Not run)###dontrunend
</code></pre>

<hr>
<h2 id='plot.idgraph'>Plots interdependencies graph</h2><span id='topic+plot.idgraph'></span>

<h3>Description</h3>

<p>Invokes <em>plot.igraph</em> with predefined parameters to visualize interdependencies
graph (ID-Graph). Standard <code>plot</code> function with custom parameters may be used instead of this one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'idgraph'
plot(x, 
          label_dist = 0.5, 
          color = 'darkred',
          cex = 1, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.idgraph_+3A_x">x</code></td>
<td>
<p><em>idgraph/igraph</em> S3 object representing feature interdependencies. This object is produced by <code><a href="#topic+build.idgraph">build.idgraph</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.idgraph_+3A_label_dist">label_dist</code></td>
<td>
<p>space between the node's label and the corresponding node in the plot.</p>
</td></tr>
<tr><td><code id="plot.idgraph_+3A_color">color</code></td>
<td>
<p>it defines color of the graph nodes.</p>
</td></tr>
<tr><td><code id="plot.idgraph_+3A_cex">cex</code></td>
<td>
<p>size of fonts.</p>
</td></tr>
<tr><td><code id="plot.idgraph_+3A_...">...</code></td>
<td>
<p>additional plotting parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: ###dontrunbegin
  
  # create input data
  adata &lt;- artificial.data(rnd_features = 10)
  showme(adata)
  
  # Parametrize and run MCFS-ID procedure
  result &lt;- mcfs(class~., adata, cutoffPermutations = 0, featureFreq = 50,
                  finalCV = FALSE, finalRuleset = FALSE, threadsNumber = 2)
  
  # build interdependencies graph for top 6 features 
  # and top 12 interdependencies and plot all nodes
  gid &lt;- build.idgraph(result, size = 6, size_ID = 12, orphan_nodes = TRUE)
  plot(gid, label_dist = 1)
  
  
## End(Not run)###dontrunend
</code></pre>

<hr>
<h2 id='plot.mcfs'>Plots various MCFS result components</h2><span id='topic+plot.mcfs'></span>

<h3>Description</h3>

<p>Plots various aspects of the MCFS-ID result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'mcfs'
plot(x, type = c("features", "ri", "id", "distances", "cv", "cmatrix", "heatmap"), 
        size = NA, 
        ri_permutations = c("max", "all", "sorted", "none"),
        diff_bars = TRUE,
        features_margin = 10,
        cv_measure = c("wacc", "acc", "pearson", "MAE", "RMSE", "SMAPE"),
        heatmap_norm = c('none', 'norm', 'scale'),
        heatmap_fun = c('median', 'mean'),
        color = c('darkred'),
        gg = TRUE,
        cex = 1, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mcfs_+3A_x">x</code></td>
<td>
<p>'mcfs' S3 object - result of the MCFS-ID experiment returned by <code><a href="#topic+mcfs">mcfs</a></code> function.</p>
</td></tr>
<tr><td><code id="plot.mcfs_+3A_type">type</code></td>
<td>


<ul>
<li><p><code>features</code> plots top features set along with their RI. It is a horizontal barplot that shows important features in red color and unimportant in grey.
</p>
</li>
<li><p><code>ri</code> plots top features set with their RIs as well as max RI obtained from permutation experiments. Red color denotes important features.
</p>
</li>
<li><p><code>id</code> plots top ID values obtained from the MCFS-ID.
</p>
</li>
<li><p><code>distances</code> plots distances (convergence diagnostics of the algorithm) between subsequent feature rankings obtained during the MCFS-ID experiment.
</p>
</li>
<li><p><code>cv</code> plots cross validation results based on top features.
</p>
</li>
<li><p><code>cmatrix</code> plots the confusion matrix obtained on all <code class="reqn">s \cdot t</code> trees.
</p>
</li>
<li><p><code>heatmap</code> plots heatmap results based on top features. Only numeric features can be presented on the heatmap.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.mcfs_+3A_size">size</code></td>
<td>
<p>number of features to plot.</p>
</td></tr>
<tr><td><code id="plot.mcfs_+3A_ri_permutations">ri_permutations</code></td>
<td>
<p>if <code>type = "ri"</code> and <code>ri_permutations = "max"</code>, then it additionally shows horizontal lines that correspond to max RI values obtained from each single permutation experiment.</p>
</td></tr>
<tr><td><code id="plot.mcfs_+3A_diff_bars">diff_bars</code></td>
<td>
<p>if <code>type = "ri"</code> or <code>type = "id"</code> and <code>diff_bars = T</code>, then it shows difference values for RI or ID values.</p>
</td></tr>
<tr><td><code id="plot.mcfs_+3A_features_margin">features_margin</code></td>
<td>
<p>if <code>type = "features"</code>, then it determines the size of the left margin of the plot.</p>
</td></tr>
<tr><td><code id="plot.mcfs_+3A_cv_measure">cv_measure</code></td>
<td>
<p>if <code>type = "cv"</code>, then it determines the type of accuracy shown in the plot: weighted or unweighted accuracy (&quot;wacc&quot; or &quot;acc&quot;). If target attribute is numeric it is possible to review one of the following prediction quality measures: (&quot;pearson&quot;, &quot;MAE&quot;, &quot;RMSE&quot;, &quot;SMAPE&quot;)</p>
</td></tr>
<tr><td><code id="plot.mcfs_+3A_heatmap_norm">heatmap_norm</code></td>
<td>
<p>if <code>type = "heatmap"</code>, then it defines type of input data normalization <code>'none'</code> - without any normalization, <code>'norm'</code> - normalization within range [-1,1], <code>'scale'</code> - standardization/centering by mean and stdev.</p>
</td></tr>
<tr><td><code id="plot.mcfs_+3A_heatmap_fun">heatmap_fun</code></td>
<td>
<p>if <code>type = "heatmap"</code>, then it determines calculation <code>'mean'</code> or <code>'median'</code> within the class to be shown as heatmap color intensity.</p>
</td></tr>
<tr><td><code id="plot.mcfs_+3A_color">color</code></td>
<td>
<p>it defines main color of the following type of plots: 'ri', 'id', 'heatmap', 'features' and 'cmatrix'.</p>
</td></tr>
<tr><td><code id="plot.mcfs_+3A_gg">gg</code></td>
<td>
<p>if <code>gg = TRUE</code> use ggplot2.</p>
</td></tr>
<tr><td><code id="plot.mcfs_+3A_cex">cex</code></td>
<td>
<p>size of fonts.</p>
</td></tr>
<tr><td><code id="plot.mcfs_+3A_...">...</code></td>
<td>
<p>additional plotting parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: ###dontrunbegin

  # Create input data.
  adata &lt;- artificial.data(rnd_features = 10)
  showme(adata)
  
  # Parametrize and run MCFS-ID procedure.
  result &lt;- mcfs(class~., adata, cutoffPermutations = 0, featureFreq = 10,
                  finalCV = FALSE, finalRuleset = TRUE, threadsNumber = 2)

  # Plot &amp; print out distances between subsequent projections. 
  # These are convergence MCFS-ID statistics.
  plot(result, type = "distances")
  print(result$distances)
  
  # Plot &amp; print out 50 most important features and show max RI values from 
  # permutation experiment.
  plot(result, type = "ri", size = 50)
  print(head(result$RI, 50))
  
  # Plot &amp; print out 50 strongest feature interdependencies.
  plot(result, type = "id", size = 50)
  print(head(result$ID, 50))
  
  # Plot features ordered by RI. Parameter 'size' is the number of 
  # top features in the chart. By default it is set on cutoff_value + 10
  plot(result, type = "features", cex = 1)

  # Here we set 'size' at fixed value 10.
  plot(result, type = "features", size = 10)
  
  # Plot cv classification result obtained on top features.
  # In the middle of x axis red label denotes cutoff_value.
  # plot(result, type = "cv", measure = "wacc", cex = 0.8)
  
  # Plot &amp; print out confusion matrix. This matrix is the result of 
  # all classifications performed by all decision trees on all s*t datasets.
  plot(result, type = "cmatrix")
  
  
## End(Not run)###dontrunend
</code></pre>

<hr>
<h2 id='print.mcfs'>Prints mcfs result</h2><span id='topic+print.mcfs'></span>

<h3>Description</h3>

<p>Prints basic information about the MCFS-ID result: top features, cutoff values, confusion matrix obtained for <code class="reqn">s \cdot t</code> trees and classification rules obtained by <em>Ripper</em> (<em>jrip</em>) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'mcfs'
print(x, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mcfs_+3A_x">x</code></td>
<td>
<p>'mcfs' object - result of the MCFS-ID experiment returned by <code><a href="#topic+mcfs">mcfs</a></code> function.</p>
</td></tr>
<tr><td><code id="print.mcfs_+3A_...">...</code></td>
<td>
<p>additional printing parameters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: ###dontrunbegin

  # create input data
  adata &lt;- artificial.data(rnd_features = 10)
  showme(adata)
  
  # Parametrize and run MCFS-ID procedure
  result &lt;- mcfs(class~., adata, cutoffPermutations = 0, featureFreq = 10,
                  finalCV = FALSE, finalRuleset = TRUE, threadsNumber = 2)

  # Print basic information about mcfs result.
  print(result)
  
  
## End(Not run)###dontrunend
</code></pre>

<hr>
<h2 id='prune.data'>Filters input data</h2><span id='topic+prune.data'></span>

<h3>Description</h3>

<p>Selects columns from input data based on the highest RIs of attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune.data(x, mcfs_result, size = NA)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune.data_+3A_x">x</code></td>
<td>
<p>input data.frame.</p>
</td></tr>
<tr><td><code id="prune.data_+3A_mcfs_result">mcfs_result</code></td>
<td>
<p>result from <code><a href="#topic+mcfs">mcfs</a></code> function.</p>
</td></tr>
<tr><td><code id="prune.data_+3A_size">size</code></td>
<td>
<p>number of top features to select from input data. If <code>size = NA</code>, then it is defined by 
<code>mcfs_result$cutoff_value</code> parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame with selected columns.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: ###dontrunbegin

  # create input data
  adata &lt;- artificial.data(rnd_features = 10)
  showme(adata)
  
  # Parametrize and run MCFS-ID procedure
  result &lt;- mcfs(class~., adata, cutoffPermutations = 0, featureFreq = 10,
                  finalCV = FALSE, finalRuleset = FALSE, threadsNumber = 2)

  head(prune.data(adata, result, size = result$cutoff_value))

  
## End(Not run)###dontrunend  
</code></pre>

<hr>
<h2 id='read.adh'>Reads data from ADH</h2><span id='topic+read.adh'></span>

<h3>Description</h3>

<p>Imports data from ADH format. This format is based on two files: 'adh' that contains ADX header and 'csv' that contains the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.adh(file = "")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.adh_+3A_file">file</code></td>
<td>
<p>exported filename</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: ###dontrunbegin

  # create artificial data
  adata &lt;- artificial.data(rnd_features = 1000)

  write.adh(adata, file = file.path(tempdir(), "adata.adh"), target = "class")
  adata &lt;- read.adh(file = file.path(tempdir(), "adata.adh"))
  
  
## End(Not run)###dontrunend
</code></pre>

<hr>
<h2 id='read.adx'>Reads data from ADX</h2><span id='topic+read.adx'></span>

<h3>Description</h3>

<p>Imports data from ADX format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.adx(file = "")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.adx_+3A_file">file</code></td>
<td>
<p>exported filename</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: ###dontrunbegin

  # create artificial data
  adata &lt;- artificial.data(rnd_features = 1000)
  
  write.adx(adata, file = file.path(tempdir(), "adata.adx"), target = "class")
  adata &lt;- read.adx(file = file.path(tempdir(), "adata.adx"))
  
  
## End(Not run)###dontrunend
</code></pre>

<hr>
<h2 id='showme'>Basic data information</h2><span id='topic+showme'></span>

<h3>Description</h3>

<p>Prints basic information about the data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showme(x, size = 10, show = c("tiles", "head", "tail", "none"))</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showme_+3A_x">x</code></td>
<td>
<p>input data frame.</p>
</td></tr>
<tr><td><code id="showme_+3A_size">size</code></td>
<td>
<p>number of rows/columns to be printed.</p>
</td></tr>
<tr><td><code id="showme_+3A_show">show</code></td>
<td>
<p>parameters that controls print content.
</p>

<ul>
<li><p><code>tiles</code> - shows top left and bottom right cells (size of both subsets is controlled by <code>size</code> parameter)
</p>
</li>
<li><p><code>head</code> - shows top <code>size</code> rows
</p>
</li>
<li><p><code>tail</code> - shows bottom <code>size</code> rows
</p>
</li>
<li><p><code>none</code> - does not show the content
</p>
</li></ul>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
  # create artificial data
  adata &lt;- artificial.data(rnd_features = 1000)
  showme(adata)
</code></pre>

<hr>
<h2 id='write.adh'>Writes data to ADH</h2><span id='topic+write.adh'></span>

<h3>Description</h3>

<p>Exports data into ADH format. This format is based on two files: 'adh' that contains ADX header and 'csv' that contains the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.adh(x, file = "", target = NA, chunk_size = 100000, zip = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.adh_+3A_x">x</code></td>
<td>
<p>data frame with data</p>
</td></tr>
<tr><td><code id="write.adh_+3A_file">file</code></td>
<td>
<p>exported filename</p>
</td></tr>
<tr><td><code id="write.adh_+3A_target">target</code></td>
<td>
<p>sets target attribute in ADH format. Default value is NA what refers to the last column.</p>
</td></tr>
<tr><td><code id="write.adh_+3A_chunk_size">chunk_size</code></td>
<td>
<p>defines size of chunk (number of cells) that are processed and exported. The bigger the value, the function is faster for small data and slower for big data.</p>
</td></tr>
<tr><td><code id="write.adh_+3A_zip">zip</code></td>
<td>
<p>whether to create zip archive.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: ###dontrunbegin

  # create artificial data
  adata &lt;- artificial.data(rnd_features = 1000)
  
  #Fix input data to be consistent with ARFF and ADX formats. 
  #It is not necessary but for some data can help to export in proper format.
  adata &lt;- fix.data(adata)
  write.adh(adata, file = file.path(tempdir(), "adata.adh"), target = "class")
  
  
## End(Not run)###dontrunend
</code></pre>

<hr>
<h2 id='write.adx'>Writes data to ADX</h2><span id='topic+write.adx'></span>

<h3>Description</h3>

<p>Exports data into ADX format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.adx(x, file = "", target = NA, chunk_size = 100000, zip = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.adx_+3A_x">x</code></td>
<td>
<p>data frame with data</p>
</td></tr>
<tr><td><code id="write.adx_+3A_file">file</code></td>
<td>
<p>exported filename</p>
</td></tr>
<tr><td><code id="write.adx_+3A_target">target</code></td>
<td>
<p>sets target attribute in ADX format. Default value is NA what refers to the last column.</p>
</td></tr>
<tr><td><code id="write.adx_+3A_chunk_size">chunk_size</code></td>
<td>
<p>defines size of chunk (number of cells) that are processed and exported. The bigger the value, the function is faster for small data and slower for big data.</p>
</td></tr>
<tr><td><code id="write.adx_+3A_zip">zip</code></td>
<td>
<p>whether to create zip archive.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: ###dontrunbegin

  # create artificial data
  adata &lt;- artificial.data(rnd_features = 1000)
  
  #Fix input data to be consistent with ARFF and ADX formats. 
  #It is not necessary but for some data can help to export in proper format.
  adata &lt;- fix.data(adata)
  write.adx(adata, file = file.path(tempdir(), "adata.adx"), target = "class")
  
  
## End(Not run)###dontrunend
</code></pre>

<hr>
<h2 id='write.arff'>Writes data to ARFF</h2><span id='topic+write.arff'></span>

<h3>Description</h3>

<p>Exports data into ARFF format. This format is used by Weka 
Data Mining software <a href="http://www.cs.waikato.ac.nz/ml/weka/">http://www.cs.waikato.ac.nz/ml/weka/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.arff(x, file = "", target = NA, chunk_size=100000, zip = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.arff_+3A_x">x</code></td>
<td>
<p>data frame with data</p>
</td></tr>
<tr><td><code id="write.arff_+3A_file">file</code></td>
<td>
<p>exported filename</p>
</td></tr>
<tr><td><code id="write.arff_+3A_target">target</code></td>
<td>
<p>sets target attribute in ARFF format. Default value is NA what refers to the last column.</p>
</td></tr>
<tr><td><code id="write.arff_+3A_chunk_size">chunk_size</code></td>
<td>
<p>it defines size of chunk (number of cells) that are processed and exported. The bigger the value, the function is faster for small data and slower for big data.</p>
</td></tr>
<tr><td><code id="write.arff_+3A_zip">zip</code></td>
<td>
<p>whether to create zip archive.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>  ## Not run: ###dontrunbegin

  # create artificial data
  adata &lt;- artificial.data(rnd_features = 1000)
  
  #Fix input data to be consistent with ARFF and ADX formats. 
  #It is not necessary but for some data can help to export in proper format.
  adata &lt;- fix.data(adata)
  write.arff(adata, file = file.path(tempdir(), "adata.arff"), target = "class")
  
  
## End(Not run)###dontrunend
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
