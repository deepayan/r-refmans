<!DOCTYPE html><html lang="en"><head><title>Help for package heatmaply</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {heatmaply}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ggheatmap'><p>ggplot heatmap equivalent to heatmaply</p></a></li>
<li><a href='#ggplot_side_color_plot'><p>Side color plots for heatmaps</p></a></li>
<li><a href='#heatmaply'><p>Cluster heatmap based on plotly</p></a></li>
<li><a href='#heatmapr'><p>Creates a heatmapr object</p></a></li>
<li><a href='#is.heatmapr'><p>Is the object of class heatmapr</p></a></li>
<li><a href='#is.na10'><p>Indicates which elements are missing (either 1 and 0)</p></a></li>
<li><a href='#is.plotly'><p>Checks if an object is of class plotly or not.</p></a></li>
<li><a href='#normalize'><p>Normalization transformation (0-1)</p></a></li>
<li><a href='#percentize'><p>Empirical Percentile Transformation</p></a></li>
<li><a href='#RColorBrewer_colors'><p>RColorBrewer color Ramp Palette</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Interactive Cluster Heat Maps Using 'plotly' and 'ggplot2'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-06</td>
</tr>
<tr>
<td>Description:</td>
<td>Create interactive cluster 'heatmaps' that can be saved as a stand-
    alone HTML file, embedded in 'R Markdown' documents or in a 'Shiny' app, and
    available in the 'RStudio' viewer pane. Hover the mouse pointer over a cell to
    show details or drag a rectangle to zoom. A 'heatmap' is a popular graphical
    method for visualizing high-dimensional data, in which a table of numbers
    are encoded as a grid of colored cells. The rows and columns of the matrix
    are ordered to highlight patterns and are often accompanied by 'dendrograms'.
    'Heatmaps' are used in many fields for visualizing observations, correlations,
    missing values patterns, and more. Interactive 'heatmaps' allow the inspection
    of specific value by hovering the mouse over a cell, as well as zooming into
    a region of the 'heatmap' by dragging a rectangle around the relevant area.
    This work is based on the 'ggplot2' and 'plotly.js' engine. It produces
    similar 'heatmaps' to 'heatmap.2' with the advantage of speed
    ('plotly.js' is able to handle larger size matrix), the ability to zoom from
    the 'dendrogram' panes, and the placing of factor variables in the sides of the
    'heatmap'.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), plotly (&ge; 4.7.1), viridis</td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2 (&ge; 2.2.0), dendextend (&ge; 1.12.0), magrittr (&ge;
1.0.1), reshape2, scales, seriation, utils, stats, grDevices,
methods, colorspace, RColorBrewer, htmlwidgets, webshot,
assertthat, egg</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, covr, gplots, tidyselect, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://talgalili.github.io/heatmaply/">https://talgalili.github.io/heatmaply/</a>,
<a href="https://cran.r-project.org/package=heatmaply">https://cran.r-project.org/package=heatmaply</a>,
<a href="https://github.com/talgalili/heatmaply/">https://github.com/talgalili/heatmaply/</a>,
<a href="https://www.r-statistics.com/tag/heatmaply/">https://www.r-statistics.com/tag/heatmaply/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/talgalili/heatmaply/issues">https://github.com/talgalili/heatmaply/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-06 15:41:58 UTC; talgalili</td>
</tr>
<tr>
<td>Author:</td>
<td>Tal Galili [aut, cre, cph] (https://www.r-statistics.com),
  Alan O'Callaghan [aut] (https://github.com/Alanocallaghan),
  Jonathan Sidi [ctb] (https://github.com/yonicd),
  Jaehyun Joo [ctb] (https://github.com/jaehyunjoo),
  Yoav Benjamini [ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tal Galili &lt;tal.galili@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-06 20:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='ggheatmap'>ggplot heatmap equivalent to heatmaply</h2><span id='topic+ggheatmap'></span>

<h3>Description</h3>

<p>This function produces a ggplot analogue of heatmaply figures
using <a href="egg.html#topic+ggarrange">ggarrange</a>. This function may not always support the same
set of features as , and exporting the heatmaply object with, for example,
<a href="plotly.html#topic+orca">orca</a> or <code>heatmaply(mtcars, file = "foo.png")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggheatmap(
  ...,
  widths = NULL,
  heights = NULL,
  row_dend_left = FALSE,
  hide_colorbar = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggheatmap_+3A_...">...</code></td>
<td>
<p>Passed to <a href="#topic+heatmaply">heatmaply</a></p>
</td></tr>
<tr><td><code id="ggheatmap_+3A_widths">widths</code>, <code id="ggheatmap_+3A_heights">heights</code></td>
<td>
<p>Relative widths and heights of plots.</p>
</td></tr>
<tr><td><code id="ggheatmap_+3A_row_dend_left">row_dend_left</code></td>
<td>
<p>Logical argument controlling whether the row
dendrogram is placed on the left of the plot.</p>
</td></tr>
<tr><td><code id="ggheatmap_+3A_hide_colorbar">hide_colorbar</code></td>
<td>
<p>Logical argument controlling whether the color bar (i.e.:
the legend) is hidden.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ggheatmap(mtcars)
</code></pre>

<hr>
<h2 id='ggplot_side_color_plot'>Side color plots for heatmaps</h2><span id='topic+ggplot_side_color_plot'></span>

<h3>Description</h3>

<p>Important for creating annotation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot_side_color_plot(
  df,
  palette = NULL,
  scale_title = paste(type, "side colors"),
  type = c("column", "row"),
  text_angle = if (type == "column") 0 else 90,
  is_colors = FALSE,
  fontsize = 10,
  label_name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggplot_side_color_plot_+3A_df">df</code></td>
<td>
<p>A &quot;molten&quot; data.frame as produced by (eg) reshape2::melt</p>
</td></tr>
<tr><td><code id="ggplot_side_color_plot_+3A_palette">palette</code></td>
<td>
<p>A function which can return colors to be used in the sidebar
plot</p>
</td></tr>
<tr><td><code id="ggplot_side_color_plot_+3A_scale_title">scale_title</code></td>
<td>
<p>Title of the color scale. Not currently used.</p>
</td></tr>
<tr><td><code id="ggplot_side_color_plot_+3A_type">type</code></td>
<td>
<p>Horizontal or vertical plot? Valid values are &quot;column&quot; and &quot;row&quot;</p>
</td></tr>
<tr><td><code id="ggplot_side_color_plot_+3A_text_angle">text_angle</code></td>
<td>
<p>the angle of the text of the rows/columns.</p>
</td></tr>
<tr><td><code id="ggplot_side_color_plot_+3A_is_colors">is_colors</code></td>
<td>
<p>Use if the values in df are valid colours and should not be mapped
to a color scheme, and instead should be plotted directly.</p>
</td></tr>
<tr><td><code id="ggplot_side_color_plot_+3A_fontsize">fontsize</code></td>
<td>
<p>Font size (currently unused)</p>
</td></tr>
<tr><td><code id="ggplot_side_color_plot_+3A_label_name">label_name</code></td>
<td>
<p>Name for the mouseover label, usually &quot;row&quot; or &quot;column&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot geom_tile object
</p>

<hr>
<h2 id='heatmaply'>Cluster heatmap based on plotly</h2><span id='topic+heatmaply'></span><span id='topic+heatmaply_na'></span><span id='topic+heatmaply_cor'></span><span id='topic+heatmaply.default'></span><span id='topic+heatmaply.heatmapr'></span>

<h3>Description</h3>

<p>An object of class heatmapr includes all the needed information
for producing a heatmap. The goal is to separate the pre-processing of the
heatmap elements from the graphical rendering of the object, which could be done
</p>
<p>(Please submit an issue on github if you have a feature that you wish to have added)
</p>
<p>heatmaply_na is a wrapper for 'heatmaply' which comes with defaults that are better
for exploring missing value (NA) patterns. Specifically, the grid_gap is set to 1, and the
colors include two shades of grey. It also calculates the <a href="#topic+is.na10">is.na10</a> automatically.
</p>
<p>heatmaply_cor is a wrapper for 'heatmaply' which comes with defaults that are better
for correlation matrixes. Specifically, the limits are set from -1 to 1, and the color palette is <a href="#topic+RdBu">RdBu</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmaply(x, ...)

heatmaply_na(x, grid_gap = 1, colors = c("grey80", "grey20"), ...)

heatmaply_cor(x, limits = c(-1, 1), colors = cool_warm, ...)

## Default S3 method:
heatmaply(
  x,
  colors = viridis(n = 256, alpha = 1, begin = 0, end = 1, option = "viridis"),
  limits = NULL,
  na.value = "grey50",
  row_text_angle = 0,
  column_text_angle = 45,
  subplot_margin = 0,
  cellnote = NULL,
  draw_cellnote = !is.null(cellnote),
  cellnote_color = "auto",
  cellnote_textposition = "middle right",
  cellnote_size = 12,
  Rowv = NULL,
  Colv = NULL,
  distfun = stats::dist,
  hclustfun = stats::hclust,
  dist_method = NULL,
  hclust_method = NULL,
  distfun_row = distfun,
  hclustfun_row = hclustfun,
  distfun_col = distfun,
  hclustfun_col = hclustfun,
  dendrogram = c("both", "row", "column", "none"),
  show_dendrogram = c(TRUE, TRUE),
  reorderfun = function(d, w) reorder(d, w),
  k_row = 1,
  k_col = 1,
  symm = FALSE,
  revC = symm || (is.dendrogram(Colv) &amp; is.dendrogram(Rowv) &amp; identical(Rowv, rev(Colv))),
  scale = c("none", "row", "column"),
  na.rm = TRUE,
  row_dend_left = FALSE,
  margins = c(NA, NA, NA, NA),
  ...,
  scale_fill_gradient_fun = NULL,
  grid_color = NA,
  grid_gap = 0,
  srtRow = NULL,
  srtCol = NULL,
  xlab = "",
  ylab = "",
  main = "",
  titleX = TRUE,
  titleY = TRUE,
  hide_colorbar = FALSE,
  key.title = NULL,
  return_ppxpy = FALSE,
  row_side_colors = NULL,
  row_side_palette = NULL,
  col_side_colors = NULL,
  col_side_palette = NULL,
  ColSideColors = NULL,
  RowSideColors = NULL,
  seriate = c("OLO", "mean", "none", "GW"),
  heatmap_layers = NULL,
  side_color_layers = NULL,
  dendrogram_layers = NULL,
  branches_lwd = 0.6,
  file = NULL,
  width = NULL,
  height = NULL,
  long_data = NULL,
  plot_method = c("ggplot", "plotly"),
  label_names = c("row", "column", "value"),
  fontsize_row = 10,
  fontsize_col = 10,
  cexRow = NULL,
  cexCol = NULL,
  subplot_widths = NULL,
  subplot_heights = NULL,
  colorbar_len = 0.3,
  colorbar_thickness = 30,
  colorbar_xanchor = if (row_dend_left) "right" else "left",
  colorbar_yanchor = "bottom",
  colorbar_xpos = if (row_dend_left) -0.1 else 1.1,
  colorbar_ypos = 0,
  showticklabels = c(TRUE, TRUE),
  dynamicTicks = FALSE,
  grid_size = 0.1,
  node_type = "heatmap",
  point_size_mat = NULL,
  point_size_name = "Point size",
  label_format_fun = function(...) format(..., digits = 4),
  labRow = NULL,
  labCol = NULL,
  custom_hovertext = NULL,
  col = NULL,
  dend_hoverinfo = TRUE,
  side_color_colorbar_len = 0.3,
  plotly_source = "A"
)

## S3 method for class 'heatmapr'
heatmaply(
  x,
  colors = viridis(n = 256, alpha = 1, begin = 0, end = 1, option = "viridis"),
  limits = NULL,
  na.value = "grey50",
  row_text_angle = 0,
  column_text_angle = 45,
  subplot_margin = 0,
  row_dend_left = FALSE,
  margins = c(NA, NA, NA, NA),
  ...,
  scale_fill_gradient_fun = scale_fill_gradientn(colors = if (is.function(colors))
    colors(256) else colors, na.value = na.value, limits = limits),
  grid_color = NA,
  grid_gap = 0,
  srtRow = NULL,
  srtCol = NULL,
  xlab = "",
  ylab = "",
  main = "",
  titleX = TRUE,
  titleY = TRUE,
  hide_colorbar = FALSE,
  key.title = NULL,
  return_ppxpy = FALSE,
  draw_cellnote = FALSE,
  cellnote_color = "auto",
  cellnote_textposition = "middle right",
  cellnote_size = 12,
  row_side_colors = x[["row_side_colors"]],
  row_side_palette = NULL,
  col_side_colors = x[["col_side_colors"]],
  col_side_palette = NULL,
  plot_method = c("ggplot", "plotly"),
  ColSideColors = NULL,
  RowSideColors = NULL,
  heatmap_layers = NULL,
  side_color_layers = NULL,
  dendrogram_layers = NULL,
  branches_lwd = 0.6,
  label_names = c("row", "column", "value"),
  fontsize_row = 10,
  fontsize_col = 10,
  subplot_widths = NULL,
  subplot_heights = NULL,
  colorbar_xanchor = if (row_dend_left) "right" else "left",
  colorbar_yanchor = "bottom",
  colorbar_xpos = if (row_dend_left) -0.1 else 1.1,
  colorbar_ypos = 0,
  colorbar_len = 0.3,
  colorbar_thickness = 30,
  showticklabels = c(TRUE, TRUE),
  dynamicTicks = FALSE,
  node_type = c("scatter", "heatmap"),
  grid_size = 0.1,
  point_size_mat = x[["matrix"]][["point_size_mat"]],
  point_size_name = "Point size",
  label_format_fun = function(...) format(..., digits = 4),
  custom_hovertext = x[["matrix"]][["custom_hovertext"]],
  dend_hoverinfo = TRUE,
  side_color_colorbar_len = 0.3,
  plotly_source = "A",
  height = NULL,
  width = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heatmaply_+3A_x">x</code></td>
<td>
<p>can either be a heatmapr object, or a numeric matrix
Defaults to <code>TRUE</code> unless <code>x</code> contains any <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_...">...</code></td>
<td>
<p>other parameters passed to <a href="#topic+heatmapr">heatmapr</a> (currently, various
parameters may be ignored.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_grid_gap">grid_gap</code></td>
<td>
<p>this is a fast alternative to grid_color. The default is 0, but if a larger value
is used (for example, 1), then the resulting heatmap will have a white grid which can
help identify different cells. This is implemented using <a href="plotly.html#topic+style">style</a> (with xgap and ygap).</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_colors">colors</code>, <code id="heatmaply_+3A_col">col</code></td>
<td>
<p>a vector of colors to use for heatmap color.
The default uses
<code><a href="viridis.html#topic+viridis">viridis</a>(n=256, alpha = 1, begin = 0, end = 1, option = "viridis")</code>
It is passed to <a href="ggplot2.html#topic+scale_fill_gradientn">scale_fill_gradientn</a>.
If colors is a color function (with the first argument being 'n' = the number of colors),
it will be used to create 256 colors from that function.
(col is there to stay compatible with <a href="gplots.html#topic+heatmap.2">heatmap.2</a>)</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_limits">limits</code></td>
<td>
<p>a two dimensional numeric vector specifying the data range for the scale.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_na.value">na.value</code></td>
<td>
<p>color to use for missing values (default is &quot;grey50&quot;).</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_row_text_angle">row_text_angle</code></td>
<td>
<p>numeric (Default is 0), the angle of the text of the
rows. (this is called srtRow in <a href="gplots.html#topic+heatmap.2">heatmap.2</a>)</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_column_text_angle">column_text_angle</code></td>
<td>
<p>numeric (Default is 45), the angle of the text of
the columns. (this is called srtCol in <a href="gplots.html#topic+heatmap.2">heatmap.2</a>)</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_subplot_margin">subplot_margin</code></td>
<td>
<p>Currently not well implemented. It is passed to
<a href="plotly.html#topic+subplot">subplot</a>. Default is 0. Either a single value or
four values (all between 0 and 1). If four values are provided,
the first is used as the left margin, the second is used as the right margin,
the third is used as the top margin, and the fourth is used as the bottom margin.
If a single value is provided, it will be used as all four margins.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_cellnote">cellnote</code></td>
<td>
<p>Values to be shown as annotations atop the heatmap cells.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_draw_cellnote">draw_cellnote</code></td>
<td>
<p>Should the cellnote annotations be drawn? Defaults is FALSE,
if cellnote is not supplied, TRUE if cellnote is supplied. If TRUE and
cellnote is not supplied, x will be used for cellnote.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_cellnote_color">cellnote_color</code></td>
<td>
<p>The color of the cellnote text to be used.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_cellnote_textposition">cellnote_textposition</code></td>
<td>
<p>The text positioning/centering of the cellnote.
Default is &quot;middle right&quot;. Options are
&quot;top left&quot;, &quot;top center&quot;, &quot;top right&quot;, &quot;middle left&quot;, &quot;middle center&quot;,
&quot;middle right&quot;, &quot;bottom left&quot;, &quot;bottom center&quot;, &quot;bottom right&quot;</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_cellnote_size">cellnote_size</code></td>
<td>
<p>The font size (HTML/CSS) of the cellnote. Default is 12.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_rowv">Rowv</code></td>
<td>
<p>determines if and how the row dendrogram should be reordered.
By default, it is TRUE, which implies dendrogram is computed and reordered
based on row means. If NULL or FALSE, then no dendrogram is computed and
no reordering is done. If a <a href="stats.html#topic+dendrogram">dendrogram</a> (or <a href="stats.html#topic+hclust">hclust</a>),
then it is used &quot;as-is&quot;, ie without any reordering. If a vector of integers,
then dendrogram is computed and reordered based on the order of the vector.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_colv">Colv</code></td>
<td>
<p>determines if and how the column dendrogram should be reordered.
Has the options as the Rowv argument above and additionally when x is a
square matrix, Colv = &quot;Rowv&quot; means that columns should be treated
identically to the rows.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_distfun">distfun</code></td>
<td>
<p>function used to compute the distance (dissimilarity)
between both rows and columns. Defaults to dist.
The options &quot;pearson&quot;, &quot;spearman&quot; and &quot;kendall&quot; can be used to
use correlation-based clustering, which uses <code>as.dist(1 - cor(t(x)))</code>
as the distance metric (using the specified correlation method).</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_hclustfun">hclustfun</code></td>
<td>
<p>function used to compute the hierarchical clustering
when Rowv or Colv are not dendrograms. Defaults to hclust.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_dist_method">dist_method</code></td>
<td>
<p>default is NULL (which results in &quot;euclidean&quot; to be used).
Can accept alternative character strings indicating the
method to be passed to distfun. By default distfun. is <a href="stats.html#topic+dist">dist</a> hence
this can be one of &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot;
or &quot;minkowski&quot;.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_hclust_method">hclust_method</code></td>
<td>
<p>default is NULL (which results in &quot;complete&quot; to be used).
Can accept alternative character strings indicating the
method to be passed to hclustfun By default hclustfun is <a href="stats.html#topic+hclust">hclust</a> hence
this can be one of &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot;
(= UPGMA), &quot;mcquitty&quot; (= WPGMA), &quot;median&quot; (= WPGMC) or &quot;centroid&quot; (= UPGMC).
Specifying hclust_method=NA causes heatmaply to use
<code><a href="dendextend.html#topic+find_dend">find_dend</a></code> to find the &quot;optimal&quot; dendrogram for
the data.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_distfun_row">distfun_row</code></td>
<td>
<p>distfun for row dendrogram only.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_hclustfun_row">hclustfun_row</code></td>
<td>
<p>hclustfun for col dendrogram only.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_distfun_col">distfun_col</code></td>
<td>
<p>distfun for row dendrogram only.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_hclustfun_col">hclustfun_col</code></td>
<td>
<p>hclustfun for col dendrogram only.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_dendrogram">dendrogram</code></td>
<td>
<p>character string indicating whether to compute 'none',
'row', 'column' or 'both' dendrograms. Defaults to 'both'.
However, if Rowv (or Colv) is FALSE or NULL and dendrogram is 'both',
then a warning is issued and Rowv (or Colv) arguments are honoured.
It also accepts TRUE/FALSE as synonyms for &quot;both&quot;/&quot;none&quot;.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_show_dendrogram">show_dendrogram</code></td>
<td>
<p>Logical vector of length two, controlling whether
the row and/or column dendrograms are displayed. If a logical scalar is
provided, it is repeated to become a logical vector of length two.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_reorderfun">reorderfun</code></td>
<td>
<p>function(d, w) of dendrogram and weights for reordering the
row and column dendrograms. The default uses statsreorder.dendrogram</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_k_row">k_row</code></td>
<td>
<p>an integer scalar with the desired number of groups by which to
color the dendrogram's branches in the rows (uses <a href="dendextend.html#topic+color_branches">color_branches</a>)
If NA then <a href="dendextend.html#topic+find_k">find_k</a> is used to deduce the optimal number of clusters.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_k_col">k_col</code></td>
<td>
<p>an integer scalar with the desired number of groups by which to
color the dendrogram's branches in the columns (uses <a href="dendextend.html#topic+color_branches">color_branches</a>)
If NA then <a href="dendextend.html#topic+find_k">find_k</a> is used to deduce the optimal number of clusters.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_symm">symm</code></td>
<td>
<p>logical indicating if x should be treated symmetrically; can only
be true when x is a square matrix.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_revc">revC</code></td>
<td>
<p>logical indicating if the column order should be reversed for plotting.
Default (when missing) - is FALSE, unless symm is TRUE.
This is useful for cor matrix.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_scale">scale</code></td>
<td>
<p>character indicating if the values should be centered and scaled
in either the row direction or the column direction, or none. The default is
&quot;none&quot;.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_na.rm">na.rm</code></td>
<td>
<p>logical (default is TRUE) indicating whether NA's should be
removed when scaling (i.e.: when using rowMeans/colMeans). Generally it
should always be kept as TRUE, and is included here mainly to stay backward
compatible with gplots::heatmap.2. This argument does not effect the presence
of NA values in the matrix itself. For removing rows/columns with NAs you
should pre-process your matrix using na.omit (or some form of imputation).</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_row_dend_left">row_dend_left</code></td>
<td>
<p>logical (default is FALSE). Should the row dendrogram be
plotted on the left side of the heatmap. If false then it will be plotted on
the right side.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_margins">margins</code></td>
<td>
<p>numeric vector of length 4 (default is c(50,50,NA,0))
containing the margins (see <a href="plotly.html#topic+layout">layout</a>) for column, row and main
title names, respectively. The top margin is NA by default. If main==&quot;&quot;
then the top margin will be set to 0, otherwise it will get 30.
For a multiline title a larger default for the 3rd element should be set.
The right margin is NA by default, meaning it will be zero if row_dend_left
is FALSE, or 100 if row_dend_left is TRUE.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_scale_fill_gradient_fun">scale_fill_gradient_fun</code></td>
<td>
<p>A function that creates a smooth gradient for the heatmap.
The default uses <a href="ggplot2.html#topic+scale_fill_gradientn">scale_fill_gradientn</a> with the values of colors, limits, and
na.value that are supplied by the user. The user can input a customized function, such as
scale_color_gradient() in order to get other results (although the virids default
is quite recommended)</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_grid_color">grid_color</code></td>
<td>
<p>control the color of the heatmap grid. Default is NA.
Value passed to <a href="ggplot2.html#topic+geom_tile">geom_tile</a>. Do not use this parameter on
larger matrix sizes, as it can dramatically prolong the build time of the heatmap.
(another parameter, grid_color, will be added in the future - once it is implemented in plotly)
In the meantime it is MUCH better to use the grid_gap argument.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_srtrow">srtRow</code></td>
<td>
<p>if supplied, this overrides row_text_angle (this is to stay compatible with <a href="gplots.html#topic+heatmap.2">heatmap.2</a>)</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_srtcol">srtCol</code></td>
<td>
<p>if supplied, this overrides column_text_angle (this is to stay compatible with <a href="gplots.html#topic+heatmap.2">heatmap.2</a>)</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_xlab">xlab</code></td>
<td>
<p>A character title for the x axis.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_ylab">ylab</code></td>
<td>
<p>A character title for the y axis.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_main">main</code></td>
<td>
<p>A character title for the heatmap.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_titlex">titleX</code></td>
<td>
<p>logical (TRUE). should x-axis titles be retained? (passed to <a href="plotly.html#topic+subplot">subplot</a>).</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_titley">titleY</code></td>
<td>
<p>logical (TRUE). should y-axis titles be retained? (passed to <a href="plotly.html#topic+subplot">subplot</a>).</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_hide_colorbar">hide_colorbar</code></td>
<td>
<p>logical (FALSE). If TRUE, then the color bar (i.e.: the legend) is hidden.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_key.title">key.title</code></td>
<td>
<p>(character) main title of the color key. If set to NULL (default) no title will be plotted.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_return_ppxpy">return_ppxpy</code></td>
<td>
<p>logical (FALSE). If TRUE, then no plotting is done and the p, px and py objects are
returned (before turning into plotly objects). This is a temporary option which might be removed in the
future just to make it easy to create a ggplot heatmaps.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_row_side_colors">row_side_colors</code>, <code id="heatmaply_+3A_col_side_colors">col_side_colors</code></td>
<td>
<p>data.frame of factors to produce
row/column side colors in the style of heatmap.2/heatmap.3.
When a data.frame is provided, the column names are used as the label names for each of the newly added row_side_colors.
When a vector is provided it is coerced into a data.frame and the name of the side color will be just row_side_colors.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_row_side_palette">row_side_palette</code>, <code id="heatmaply_+3A_col_side_palette">col_side_palette</code></td>
<td>
<p>Color palette functions to be
used for row_side_colors and col_side_colors respectively.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_colsidecolors">ColSideColors</code>, <code id="heatmaply_+3A_rowsidecolors">RowSideColors</code></td>
<td>
<p>passed to row_side_colors,col_side_colors in order
to keep compatibility with <a href="gplots.html#topic+heatmap.2">heatmap.2</a></p>
</td></tr>
<tr><td><code id="heatmaply_+3A_seriate">seriate</code></td>
<td>
<p>character indicating the method of matrix sorting (default: &quot;OLO&quot;).
Implemented options include:
&quot;OLO&quot; (Optimal leaf ordering, optimizes the Hamiltonian path length that is
restricted by the dendrogram structure - works in O(n^4) )
&quot;mean&quot; (sorts the matrix based on the reorderfun using marginal means of
the matrix. This is the default used by <a href="gplots.html#topic+heatmap.2">heatmap.2</a>),
&quot;none&quot; (the default order produced by the dendrogram),
&quot;GW&quot; (Gruvaeus and Wainer heuristic to optimize the Hamiltonian path length
that is restricted by the dendrogram structure)</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_heatmap_layers">heatmap_layers</code></td>
<td>
<p>ggplot object(s) (eg, list(theme_bw())) to be added to
the heatmap before conversion to a plotly object.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_side_color_layers">side_color_layers</code></td>
<td>
<p>ggplot2 objects to be added to side color plots,
similar to heatmap_layers.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_dendrogram_layers">dendrogram_layers</code></td>
<td>
<p>ggplot2 objects to be added to dendrograms,
similar to heatmap_layers and side_color_layers.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_branches_lwd">branches_lwd</code></td>
<td>
<p>numeric (default is 0.6). The width of the dendrograms' branches.
If NULL then it is ignored. If the &quot;lwd&quot; is already defined in Rowv/Colv then this
parameter is ignored (it is checked using <a href="dendextend.html#topic+has_edgePar">has_edgePar</a>(&quot;lwd&quot;)).</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_file">file</code></td>
<td>
<p>name of the file(s) into which to save the heatmaply output.
Should be a character vector of strings ending with &quot;.html&quot; for a dynamic output,
or &quot;.png&quot;, &quot;.jpeg&quot;, &quot;.pdf&quot; for a static output.
</p>
<p>For example: heatmaply(x, file = &quot;heatmaply_plot.html&quot;) or
dir.create(&quot;folder&quot;);
heatmaply(x, file = &quot;folder/heatmaply_plot.html&quot;)
</p>
<p>This is based on <a href="htmlwidgets.html#topic+saveWidget">saveWidget</a>, and <a href="webshot.html#topic+webshot">webshot</a> for the static files.
For more refined control over the static file output, you should save the heatmaply object using <a href="plotly.html#topic+export">export</a> and pass the
arguments you want based on the ones in <a href="webshot.html#topic+webshot">webshot</a>.
</p>
<p>Another example: heatmaply(x, file = c(&quot;heatmaply_plot.html&quot;, &quot;heatmaply_plot.png&quot;))</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_width">width</code>, <code id="heatmaply_+3A_height">height</code></td>
<td>
<p>The width and height of the output htmlwidget, or the
output file if exporting to png/pdf/etc. Presumed to be in pixels, but
if a plotly internal function decides it's in other units you may end up
with a huge file! Default is 800x500 when exporting to a file, and 100
as a htmlwidget.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_long_data">long_data</code></td>
<td>
<p>Data in long format. Replaces x, so both should not be used.
Colnames must be c(&quot;name&quot;, &quot;variable&quot;, &quot;value&quot;). If you do not have a names
column you can simply use a sequence of numbers from 1 to the number of &quot;rows&quot;
in the data.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_plot_method">plot_method</code></td>
<td>
<p>Use &quot;ggplot&quot; or &quot;plotly&quot; to choose which library produces heatmap
and dendrogram plots</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_label_names">label_names</code></td>
<td>
<p>Names for labels of x, y and value/fill mouseover.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_fontsize_row">fontsize_row</code>, <code id="heatmaply_+3A_fontsize_col">fontsize_col</code>, <code id="heatmaply_+3A_cexrow">cexRow</code>, <code id="heatmaply_+3A_cexcol">cexCol</code></td>
<td>
<p>Font size for row and column labels.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_subplot_widths">subplot_widths</code>, <code id="heatmaply_+3A_subplot_heights">subplot_heights</code></td>
<td>
<p>The relative widths and heights of each
subplot. The length of these vectors will vary depending on the number of
plots involved.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_colorbar_len">colorbar_len</code></td>
<td>
<p>The length of the colorbar/color key relative to the total
plot height. Only used if plot_method = &quot;plotly&quot;</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_colorbar_thickness">colorbar_thickness</code></td>
<td>
<p>The thickness (width) of the colorbar/color key
in pixels. Only used if plot_method = &quot;plotly&quot;.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_colorbar_xanchor">colorbar_xanchor</code>, <code id="heatmaply_+3A_colorbar_yanchor">colorbar_yanchor</code></td>
<td>
<p>The x and y anchoring points of the
colorbar/color legend. Can be &quot;left&quot;, &quot;middle&quot; or &quot;right&quot; for colorbar_xanchor,
and &quot;top&quot;, &quot;middle&quot; or &quot;bottom&quot; for colorbar_yanchor.
See <code><a href="plotly.html#topic+colorbar">colorbar</a></code> for more details.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_colorbar_xpos">colorbar_xpos</code>, <code id="heatmaply_+3A_colorbar_ypos">colorbar_ypos</code></td>
<td>
<p>The x and y co-ordinates (in proportion of the plot window)
of the colorbar/color legend. See <code><a href="plotly.html#topic+colorbar">colorbar</a></code> for more details.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_showticklabels">showticklabels</code></td>
<td>
<p>A logical vector of length two (default is TRUE).
If FALSE, then the ticks are removed from the sides of the plot. The first location refers to
the x axis and the second to the y axis. If only one value is supplied (TRUE/FALSE) then it is
replicated to get to length 2. When using this parameter, it might be worth also adjusting
margins.
This option should be used when working with medium to large matrix size as it
makes the heatmap much faster (and the hover still works).</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_dynamicticks">dynamicTicks</code></td>
<td>
<p>(default: FALSE). passed to <a href="plotly.html#topic+ggplotly">ggplotly</a>:
should plotly.js dynamically generate axis tick labels?
Dynamic ticks are useful for updating ticks in response to zoom/pan interactions; however,
they can not always reproduce labels as they would appear in the static ggplot2 image.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_grid_size">grid_size</code></td>
<td>
<p>When node_type is &quot;scatter&quot;, this controls point size. When
node_type is &quot;heatmap&quot;, this controls the size of the grid between heatmap cells.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_node_type">node_type</code></td>
<td>
<p>For plot_method = &quot;ggplot&quot;, should the heatmap be rendered as
a x-y scatter plot (node_type = &quot;scatter&quot;) or a heatmap (node_type = &quot;heatmap&quot;).
Default is node_type = &quot;heatmap&quot;.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_point_size_mat">point_size_mat</code></td>
<td>
<p>Matrix to map to point size</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_point_size_name">point_size_name</code></td>
<td>
<p>Name of point size mapping (for hovertext/legend)</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_label_format_fun">label_format_fun</code></td>
<td>
<p>Function to format hovertext (eg,
<code>function(...) round(..., digits=3)</code> or
<code>function(...) format(..., digits=3)</code></p>
</td></tr>
<tr><td><code id="heatmaply_+3A_labrow">labRow</code>, <code id="heatmaply_+3A_labcol">labCol</code></td>
<td>
<p>character vectors with row and column labels to use;
these default to rownames(x) or colnames(x), respectively.
if set to NA, they change the value in showticklabels to be FALSE. This is mainly to keep
backward compatibility with gplots::heatmap.2.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_custom_hovertext">custom_hovertext</code></td>
<td>
<p>Custom hovertext matrix (the same dimensions as the input).
If plot_method is &quot;plotly&quot; then just this text is displayed; if plot_method
if &quot;ggplot&quot; then it is appended to the existing text.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_dend_hoverinfo">dend_hoverinfo</code></td>
<td>
<p>Boolean value which controls whether mouseover text
is shown for the row and column dendrograms.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_side_color_colorbar_len">side_color_colorbar_len</code></td>
<td>
<p>As with colorbar_len, this controls the
length of the colorbar/color key relative to the total plot height.
This argument controls the colorbar_len of the side colour plots.
Only used if plot_method = &quot;plotly&quot;.</p>
</td></tr>
<tr><td><code id="heatmaply_+3A_plotly_source">plotly_source</code></td>
<td>
<p>See <code>source</code> argument in <code><a href="plotly.html#topic+plot_ly">plot_ly</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# mtcars
# x &lt;- heatmapr(mtcars)
library(heatmaply)
heatmaply(iris[, -5], k_row = 3, k_col = 2)
heatmaply(cor(iris[, -5]))
heatmaply(cor(iris[, -5]), limits = c(-1, 1))
heatmaply(mtcars, k_row = 3, k_col = 2)
# heatmaply(mtcars, k_row = 3, k_col = 2, grid_color = "white")
heatmaply(mtcars, k_row = 3, k_col = 2, grid_gap = 1)

# make sure there is enough room for the labels:
heatmaply(mtcars, margins = c(40, 130))
# this is the same as using:
heatmaply(mtcars) %&gt;% layout(margin = list(l = 130, b = 40))

# control text angle
heatmaply(mtcars, column_text_angle = 90, margins = c(40, 130))
# the same as using srtCol:
# heatmaply(mtcars, srtCol = 90) %&gt;% layout(margin = list(l = 130, b = 40))



x &lt;- mtcars
# different colors
heatmaply(x, colors = heat.colors(200))
# using special scale_fill_gradient_fun colors
heatmaply(x, scale_fill_gradient_fun = scale_color_gradient())


# We can join two heatmaps together:
library(heatmaply)
hm1 &lt;- heatmaply(mtcars, margins = c(40, 130))
hm2 &lt;- heatmaply(mtcars, scale = "col", margins = c(40, 130))
subplot(hm1, hm2, margin = .2)

# If we want to share the Y axis, then it is risky to keep any of the dendrograms:
library(heatmaply)
hm1 &lt;- heatmaply(mtcars, Colv = FALSE, Rowv = FALSE, margins = c(40, 130))
hm2 &lt;- heatmaply(mtcars,
  scale = "col", Colv = FALSE, Rowv = FALSE,
  margins = c(40, 130)
)
subplot(hm1, hm2, margin = .02, shareY = TRUE)


# We can save heatmaply as an HTML file by using:
heatmaply(iris[, -5], file = "heatmaply_iris.html")
# or a png/pdf/jpeg file using:
heatmaply(iris[, -5], file = "heatmaply_iris.png")
# or just doing it in one go:
heatmaply(iris[, -5], file = c("heatmaply_iris.html", "heatmaply_iris.png"))



# If we don't want the HTML to be selfcontained, we can use the following:
library(heatmaply)
library(htmlwidgets)
heatmaply(iris[, -5]) %&gt;%
  saveWidget(file = "heatmaply_iris.html", selfcontained = FALSE)


# Example for using RowSideColors

x &lt;- as.matrix(datasets::mtcars)
rc &lt;- colorspace::rainbow_hcl(nrow(x))

library(gplots)
library(viridis)
heatmap.2(x,
  trace = "none", col = viridis(100),
  RowSideColors = rc
)

heatmaply(x,
  seriate = "mean",
  RowSideColors = rc
)


heatmaply(x[, -c(8, 9)],
  seriate = "mean",
  col_side_colors = c(rep(0, 5), rep(1, 4)),
  row_side_colors = x[, 8:9]
)
heatmaply(x[, -c(8, 9)],
  seriate = "mean",
  col_side_colors = data.frame(a = c(rep(0, 5), rep(1, 4))),
  row_side_colors = x[, 8:9]
)


## Example of using Rowv And Colv for custumized dendrograms.


x &lt;- as.matrix(datasets::mtcars)

# now let's spice up the dendrograms a bit:
library(dendextend)

row_dend &lt;- x %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram() %&gt;%
  set("branches_k_color", k = 3) %&gt;%
  set("branches_lwd", 4) %&gt;%
  ladderize()
#    rotate_DendSer(ser_weight = dist(x))
col_dend &lt;- x %&gt;%
  t() %&gt;%
  dist() %&gt;%
  hclust() %&gt;%
  as.dendrogram() %&gt;%
  set("branches_k_color", k = 2) %&gt;%
  set("branches_lwd", 4) %&gt;%
  ladderize()
#    rotate_DendSer(ser_weight = dist(t(x)))

heatmaply(x, Rowv = row_dend, Colv = col_dend)


heatmaply(is.na10(airquality))
heatmaply(is.na10(airquality), grid_gap = 1)

# grid_gap can handle quite large data matrix
heatmaply(matrix(1:10000, 100, 100), k_row = 3, k_col = 3, grid_gap = 1)

# Examples of playing with font size:
heatmaply(mtcars, fontsize_col = 20, fontsize_row = 5, margin = c(100, 90))



# Example for using subplot_width/subplot_height

heatmaply(percentize(mtcars),
  subplot_widths = c(0.6, 0.4),
  subplot_heights = c(0.05, 0.95)
)



# Example of removing labels and thus making the plot faster
heatmaply(iris, showticklabels = c(T, F), margins = c(80, 10))

# this is what allows for a much larger matrix to be printed:
set.seed(2017 - 05 - 18)
large_x &lt;- matrix(rnorm(19), 1000, 100)
heatmaply(large_x, dendrogram = F, showticklabels = F, margins = c(1, 1))

## End(Not run)
## Not run: 
heatmaply_na(airquality)

## End(Not run)
## Not run: 
heatmaply_cor(cor(mtcars))

## End(Not run)
</code></pre>

<hr>
<h2 id='heatmapr'>Creates a heatmapr object</h2><span id='topic+heatmapr'></span>

<h3>Description</h3>

<p>An object of class heatmapr includes all the needed information
for producing a heatmap. The goal is to separate the pre-processing of the
heatmap elements from the graphical rendering of the object, which could be done
using plotly (but potentially also with other graphical devices).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmapr(
  x,
  Rowv = NULL,
  Colv = NULL,
  distfun = dist,
  hclustfun = hclust,
  dist_method = NULL,
  hclust_method = NULL,
  distfun_row = distfun,
  hclustfun_row = hclustfun,
  distfun_col = distfun,
  hclustfun_col = hclustfun,
  dendrogram = c("both", "row", "column", "none"),
  show_dendrogram = c(TRUE, TRUE),
  reorderfun = function(d, w) reorder(d, w),
  k_row = 1,
  k_col = 1,
  symm = FALSE,
  revC = symm || (is.dendrogram(Colv) &amp; is.dendrogram(Rowv) &amp; identical(Rowv, rev(Colv))),
  scale = c("none", "row", "column"),
  na.rm = TRUE,
  labRow = rownames(x),
  labCol = colnames(x),
  cexRow = NULL,
  cexCol = NULL,
  digits = 3L,
  cellnote = NULL,
  theme = NULL,
  colors = "RdYlBu",
  width = NULL,
  height = NULL,
  xaxis_height = 80,
  yaxis_width = 120,
  xaxis_font_size = NULL,
  yaxis_font_size = NULL,
  brush_color = "#0000FF",
  show_grid = TRUE,
  anim_duration = 500,
  row_side_colors = NULL,
  col_side_colors = NULL,
  seriate = c("OLO", "mean", "none", "GW"),
  point_size_mat = NULL,
  custom_hovertext = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="heatmapr_+3A_x">x</code></td>
<td>
<p>A numeric matrix
Defaults to <code>TRUE</code> unless <code>x</code> contains any <code>NA</code>s.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_rowv">Rowv</code></td>
<td>
<p>determines if and how the row dendrogram should be reordered.    By default, it is TRUE, which implies dendrogram is computed and reordered based on row means. If NULL or FALSE, then no dendrogram is computed and no reordering is done. If a <a href="stats.html#topic+dendrogram">dendrogram</a> (or <a href="stats.html#topic+hclust">hclust</a>), then it is used &quot;as-is&quot;, ie without any reordering. If a vector of integers, then dendrogram is computed and reordered based on the order of the vector.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_colv">Colv</code></td>
<td>
<p>determines if and how the column dendrogram should be reordered.    Has the options as the Rowv argument above and additionally when x is a square matrix, Colv = &quot;Rowv&quot; means that columns should be treated identically to the rows.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_distfun">distfun</code></td>
<td>
<p>function used to compute the distance (dissimilarity) between both rows and columns. Defaults to dist.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_hclustfun">hclustfun</code></td>
<td>
<p>function used to compute the hierarchical clustering when Rowv or Colv are not dendrograms. Defaults to hclust.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_dist_method">dist_method</code></td>
<td>
<p>default is NULL (which results in &quot;euclidean&quot; to be used). Can accept alternative character strings indicating the
method to be passed to distfun. By default distfun. is <a href="stats.html#topic+dist">dist</a> hence
this can be one of &quot;euclidean&quot;, &quot;maximum&quot;, &quot;manhattan&quot;, &quot;canberra&quot;, &quot;binary&quot; or &quot;minkowski&quot;.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_hclust_method">hclust_method</code></td>
<td>
<p>default is NULL (which results in &quot;complete&quot; to be used). Can accept alternative character strings indicating the
method to be passed to hclustfun By default hclustfun is <a href="stats.html#topic+hclust">hclust</a> hence
this can be one of &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot; (= UPGMA), &quot;mcquitty&quot; (= WPGMA), &quot;median&quot; (= WPGMC) or &quot;centroid&quot; (= UPGMC).</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_distfun_row">distfun_row</code></td>
<td>
<p>distfun for row dendrogram only.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_hclustfun_row">hclustfun_row</code></td>
<td>
<p>hclustfun for col dendrogram only.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_distfun_col">distfun_col</code></td>
<td>
<p>distfun for row dendrogram only.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_hclustfun_col">hclustfun_col</code></td>
<td>
<p>hclustfun for col dendrogram only.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_dendrogram">dendrogram</code></td>
<td>
<p>character string indicating whether to compute 'none',
'row', 'column' or 'both' dendrograms. Defaults to 'both'. However, if Rowv
(or Colv) is FALSE or NULL and dendrogram is 'both', then a warning is issued
and Rowv (or Colv) arguments are honoured.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_show_dendrogram">show_dendrogram</code></td>
<td>
<p>Logical vector of length controlling whether the row
and column dendrograms are displayed. If a logical scalar is
provided, it is repeated to become a logical vector of length two.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_reorderfun">reorderfun</code></td>
<td>
<p>function(d, w) of dendrogram and weights for reordering the row and column dendrograms. The default uses statsreorder.dendrogram</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_k_row">k_row</code></td>
<td>
<p>an integer scalar with the desired number of groups by which to color the dendrogram's branches in the rows (uses <a href="dendextend.html#topic+color_branches">color_branches</a>)
If NA then <a href="dendextend.html#topic+find_k">find_k</a> is used to deduce the optimal number of clusters.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_k_col">k_col</code></td>
<td>
<p>an integer scalar with the desired number of groups by which to color the dendrogram's branches in the columns (uses <a href="dendextend.html#topic+color_branches">color_branches</a>)
If NA then <a href="dendextend.html#topic+find_k">find_k</a> is used to deduce the optimal number of clusters.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_symm">symm</code></td>
<td>
<p>logical indicating if x should be treated symmetrically; can only be true when x is a square matrix.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_revc">revC</code></td>
<td>
<p>logical indicating if the column order should be reversed for plotting.
Default (when NULL) - is FALSE, unless symm is TRUE.
This is useful for cor matrix.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_scale">scale</code></td>
<td>
<p>character indicating if the values should be centered and scaled in either the row direction or the column direction, or none. The default is &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_na.rm">na.rm</code></td>
<td>
<p>logical indicating whether NA's should be removed.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_labrow">labRow</code></td>
<td>
<p>character vectors with row labels to use (from top to bottom); default to rownames(x).</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_labcol">labCol</code></td>
<td>
<p>character vectors with column labels to use (from left to right); default to colnames(x).</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_cexrow">cexRow</code></td>
<td>
<p>positive numbers. If not NULL, it will override <code>xaxis_font_size</code>
and will give it a value cexRow*14</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_cexcol">cexCol</code></td>
<td>
<p>positive numbers. If not NULL, it will override <code>yaxis_font_size</code>
and will give it a value cexCol*14</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of decimal places to be used by <a href="base.html#topic+round">round</a> for 'label'.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_cellnote">cellnote</code></td>
<td>
<p>(optional) matrix of the same dimensions as <code>x</code>
that has the human-readable version of each value,
for displaying on top of the heatmap cells.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_theme">theme</code></td>
<td>
<p>A custom CSS theme to use. Currently the only valid values are
<code>""</code> and <code>"dark"</code>. <code>"dark"</code> is primarily intended for
standalone visualizations, not R Markdown or Shiny.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_colors">colors</code></td>
<td>
<p>Either a colorbrewer2.org palette name (e.g. <code>"YlOrRd"</code> or
<code>"Blues"</code>), or a vector of colors to interpolate in hexadecimal
<code>"#RRGGBB"</code> format, or a color interpolation function like
<code><a href="grDevices.html#topic+colorRamp">colorRamp</a></code>.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_width">width</code></td>
<td>
<p>Width in pixels (optional, defaults to automatic sizing).</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_height">height</code></td>
<td>
<p>Height in pixels (optional, defaults to automatic sizing).</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_xaxis_height">xaxis_height</code></td>
<td>
<p>Size of axes, in pixels.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_yaxis_width">yaxis_width</code></td>
<td>
<p>Size of axes, in pixels.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_xaxis_font_size">xaxis_font_size</code></td>
<td>
<p>Font size of axis labels, as a CSS size (e.g. &quot;14px&quot; or &quot;12pt&quot;).</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_yaxis_font_size">yaxis_font_size</code></td>
<td>
<p>Font size of axis labels, as a CSS size (e.g. &quot;14px&quot; or &quot;12pt&quot;).</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_brush_color">brush_color</code></td>
<td>
<p>The base color to be used for the brush. The brush will be
filled with a low-opacity version of this color. <code>"#RRGGBB"</code> format
expected.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_show_grid">show_grid</code></td>
<td>
<p><code>TRUE</code> to show gridlines, <code>FALSE</code> to hide them, or
a numeric value to specify the gridline thickness in pixels (can be a
non-integer).</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_anim_duration">anim_duration</code></td>
<td>
<p>Number of milliseconds to animate zooming in and out.
For large <code>x</code> it may help performance to set this value to <code>0</code>.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_row_side_colors">row_side_colors</code>, <code id="heatmapr_+3A_col_side_colors">col_side_colors</code></td>
<td>
<p>data.frame of factors to produce
row/column side colors in the style of heatmap.2/heatmap.3.
col_side_colors should be &quot;wide&quot;, ie be the same dimensions
as the column side colors it will produce.</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_seriate">seriate</code></td>
<td>
<p>character indicating the method of matrix sorting (default: &quot;OLO&quot;).
Implemented options include:
&quot;OLO&quot; (Optimal leaf ordering, optimizes the Hamiltonian path length that is restricted by the dendrogram structure - works in O(n^4) )
&quot;mean&quot; (sorts the matrix based on the reorderfun using marginal means of the matrix. This is the default used by <a href="gplots.html#topic+heatmap.2">heatmap.2</a>),
&quot;none&quot; (the default order produced by the dendrogram),
&quot;GW&quot; (Gruvaeus and Wainer heuristic to optimize the Hamiltonian path length that is restricted by the dendrogram structure)</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_point_size_mat">point_size_mat</code></td>
<td>
<p>A matrix of values which can be mapped to point size</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_custom_hovertext">custom_hovertext</code></td>
<td>
<p>Custom hovertext matrix (the same dimensions as the input).</p>
</td></tr>
<tr><td><code id="heatmapr_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Source</h3>

<p>The interface was designed based on <a href="stats.html#topic+heatmap">heatmap</a>, <a href="gplots.html#topic+heatmap.2">heatmap.2</a>, and (the also d3heatmap).
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+heatmap">heatmap</a>, <a href="gplots.html#topic+heatmap.2">heatmap.2</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(heatmaply)
hm &lt;- heatmapr(mtcars, scale = "column", colors = "Blues")
heatmaply(hm)

## End(Not run)

</code></pre>

<hr>
<h2 id='is.heatmapr'>Is the object of class heatmapr</h2><span id='topic+is.heatmapr'></span>

<h3>Description</h3>

<p>Is the object of class heatmapr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.heatmapr(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.heatmapr_+3A_x">x</code></td>
<td>
<p>an object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical - is the object of class heatmapr.
</p>

<hr>
<h2 id='is.na10'>Indicates which elements are missing (either 1 and 0)</h2><span id='topic+is.na10'></span>

<h3>Description</h3>

<p>is.na10 is a helper function for creating heatmaps to diagnose missing value patterns.
It is similar to <a href="base.html#topic+is.na">is.na</a> but instead of returning a logical TRUE/FALSE vector (or matrix) it
returns a numeric 1/0 output. This enables the <a href="#topic+heatmaply">heatmaply</a> function to be used on the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.na10(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.na10_+3A_x">x</code></td>
<td>
<p>a vector, matrix or data.frame.</p>
</td></tr>
<tr><td><code id="is.na10_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a numeric (instead of a logical) variable/matrix of 1 (missing) or 0 (not missing) values (hence the name is.na10)
while still preserving the attributes resulted from running <a href="base.html#topic+is.na">is.na</a>.
</p>
<p>These are useful for funnelling into a heatmap (see the examples).
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+is.na">is.na</a>, the grid_gap parameter in <a href="#topic+heatmaply">heatmaply</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- mtcars
x &lt;- data.frame(x)
x$am &lt;- factor(x$am)
x$vs &lt;- factor(x$vs)
set.seed(2017 - 01 - 19)
x[sample(nrow(x))[1:6], sample(ncol(x))[1:6]] &lt;- NA


# nice grey colors from here: https://github.com/njtierney/visdat/blob/master/R/vis_miss_ly.R
x %&gt;%
  is.na10() %&gt;%
  heatmaply(colors = c("grey80", "grey20"), dendrogram = "none")
x %&gt;%
  is.na10() %&gt;%
  heatmaply(colors = c("grey80", "grey20"), k_col = 2, k_row = 2)

heatmaply(is.na10(airquality),
  grid_gap = 1,
  colors = c("grey80", "grey20"), k_col = 2, k_row = 2
)

## End(Not run)
</code></pre>

<hr>
<h2 id='is.plotly'>Checks if an object is of class plotly or not.</h2><span id='topic+is.plotly'></span>

<h3>Description</h3>

<p>Helpful for the plot_method in linkheatmaply.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.plotly(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.plotly_+3A_x">x</code></td>
<td>
<p>an object to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the object inherits &quot;plotly&quot; as a class.
</p>

<hr>
<h2 id='normalize'>Normalization transformation (0-1)</h2><span id='topic+normalize'></span><span id='topic+normalize.default'></span><span id='topic+normalize.data.frame'></span><span id='topic+normalize.matrix'></span>

<h3>Description</h3>

<p>An Empirical Normalization Transformation brings data to the 0 to 1 scale
by substracting the minimum and dividing by the maximum of all observations.
This is similar to <a href="#topic+percentize">percentize</a> in that it allows to compare variables
of different scales, but it also keeps the shape of the distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normalize_+3A_x">x</code></td>
<td>
<p>a vector or a data.frame.</p>
</td></tr>
<tr><td><code id="normalize_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector (or data.frame) after normalizing the numeric variables.
</p>


<h3>See Also</h3>

<p><a href="#topic+percentize">percentize</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- mtcars
x &lt;- data.frame(x)
x$am &lt;- factor(x$am)
x$vs &lt;- factor(x$vs)
heatmaply(percentize(x))
heatmaply(normalize(x))


x &lt;- data.frame(a = 1:10, b = 11:20)
x[4:6, 1:2] &lt;- NA
normalize(x)
normalize(x[, 1])

## End(Not run)
</code></pre>

<hr>
<h2 id='percentize'>Empirical Percentile Transformation</h2><span id='topic+percentize'></span><span id='topic+percentize.default'></span><span id='topic+percentize.data.frame'></span><span id='topic+percentize.matrix'></span>

<h3>Description</h3>

<p>An Empirical Percentile Transformation (percentize) is similar to taking the rank
of a variable. The difference is that it is simpler to compare and interpret
the transformed variables.
</p>
<p>This is helpful for comparing several variables in a heatmap (e.g.: <a href="#topic+heatmaply">heatmaply</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>percentize(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="percentize_+3A_x">x</code></td>
<td>
<p>a vector or a data.frame.</p>
</td></tr>
<tr><td><code id="percentize_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector (or data.frame) after <a href="stats.html#topic+ecdf">ecdf</a> was used on that vector.
If x is a <a href="base.html#topic+data.frame">data.frame</a> then only the numeric variables are transformed.
</p>


<h3>See Also</h3>

<p><a href="#topic+normalize">normalize</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- mtcars
x &lt;- data.frame(x)
x$am &lt;- factor(x$am)
x$vs &lt;- factor(x$vs)
heatmaply(percentize(x))


x &lt;- data.frame(a = 1:10, b = 11:20)
x[4:6, 1:2] &lt;- NA
percentize(x)
percentize(x[, 1])

## End(Not run)
</code></pre>

<hr>
<h2 id='RColorBrewer_colors'>RColorBrewer color Ramp Palette</h2><span id='topic+RColorBrewer_colors'></span><span id='topic+BrBG'></span><span id='topic+PiYG'></span><span id='topic+PRGn'></span><span id='topic+PuOr'></span><span id='topic+RdBu'></span><span id='topic+RdGy'></span><span id='topic+RdYlBu'></span><span id='topic+RdYlGn'></span><span id='topic+Spectral'></span><span id='topic+Blues'></span><span id='topic+BuGn'></span><span id='topic+BuPu'></span><span id='topic+GnBu'></span><span id='topic+Greens'></span><span id='topic+Greys'></span><span id='topic+Oranges'></span><span id='topic+OrRd'></span><span id='topic+PuBu'></span><span id='topic+PuBuGn'></span><span id='topic+PuRd'></span><span id='topic+Purples'></span><span id='topic+RdPu'></span><span id='topic+Reds'></span><span id='topic+YlGn'></span><span id='topic+YlGnBu'></span><span id='topic+YlOrBr'></span><span id='topic+YlOrRd'></span><span id='topic+cool_warm'></span>

<h3>Description</h3>

<p>Functions for getting the colors of RColorBrewer (i.e.: brewer.pal) without the limitation of only 9/11
color values, based on <a href="grDevices.html#topic+colorRampPalette">colorRampPalette</a>.
</p>
<p>For sequential palettes this is not essential since we have viridis. But for diverging palettes
this is quit essential.
</p>
<p>The sequential palettes names are
Blues BuGn BuPu GnBu Greens Greys Oranges OrRd PuBu PuBuGn PuRd Purples RdPu Reds YlGn YlGnBu YlOrBr YlOrRd
</p>
<p>The diverging palettes are
BrBG PiYG PRGn PuOr RdBu RdGy RdYlBu RdYlGn Spectral
And also cool_warm. The cool_warm palette is based on Kenneth Moreland's proposal (see ref).
It goes from blue (cool) to ref (warm), based on well thought-out design elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BrBG(n)

PiYG(n)

PRGn(n)

PuOr(n)

RdBu(n)

RdGy(n)

RdYlBu(n)

RdYlGn(n)

Spectral(n)

Blues(n)

BuGn(n)

BuPu(n)

GnBu(n)

Greens(n)

Greys(n)

Oranges(n)

OrRd(n)

PuBu(n)

PuBuGn(n)

PuRd(n)

Purples(n)

RdPu(n)

Reds(n)

YlGn(n)

YlGnBu(n)

YlOrBr(n)

YlOrRd(n)

cool_warm(n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RColorBrewer_colors_+3A_n">n</code></td>
<td>
<p>the number of colors (&gt;= 1) to be in the palette.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of color names.
</p>


<h3>References</h3>

<p>* Moreland, Kenneth. &quot;Diverging color maps for scientific visualization.&quot; Advances in Visual Computing (2009): 92-103.
url: http://www.kennethmoreland.com/color-maps/
The code was provided here: http://stackoverflow.com/a/44073011/256662
Thanks to the user YAK, who relied on the code from the Rgnuplot package
(which is duplicated here, in order to save the need to import the entire package)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(RColorBrewer)
display.brewer.all(n = 11, type = "div")
title(main = "Divergent color palette")
display.brewer.all(n = 9, type = c("seq"))
title(main = "Sequential color palette")



img &lt;- function(obj, nam) {
  image(1:length(obj), 1, as.matrix(1:length(obj)),
    col = obj,
    main = nam, ylab = "", xaxt = "n", yaxt = "n", bty = "n"
  )
}

par(mfrow = c(10, 1))
img(rev(cool_warm(500)), "cool_warm, (Moreland 2009)")
img(RdBu(500), "RdBu")
img(BrBG(500), "BrBG")
img(PiYG(500), "PiYG")
img(PRGn(500), "PRGn")
img(PuOr(500), "PuOr")
img(RdGy(500), "RdGy")
img(RdYlBu(500), "RdYlBu")
img(RdYlGn(500), "RdYlGn")
img(Spectral(500), "Spectral")


library(heatmaply)
heatmaply(cor(mtcars), colors = PiYG, limits = c(-1, 1))
heatmaply(cor(mtcars), colors = RdBu, limits = c(-1, 1))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
