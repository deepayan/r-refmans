<!DOCTYPE html><html><head><title>Help for package collinear</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {collinear}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#auc_score'><p>Area Under the Receiver Operating Characteristic</p></a></li>
<li><a href='#case_weights'><p>Case Weights for Unbalanced Binary Response</p></a></li>
<li><a href='#collinear'><p>Automated multicollinearity management</p></a></li>
<li><a href='#collinear-package'><p>collinear</p></a></li>
<li><a href='#cor_df'><p>Correlation data frame of numeric and character variables</p></a></li>
<li><a href='#cor_matrix'><p>Correlation matrix of numeric and character variables</p></a></li>
<li><a href='#cor_select'><p>Automated multicollinearity reduction via pairwise correlation</p></a></li>
<li><a href='#cramer_v'><p>Bias Corrected Cramer's V</p></a></li>
<li><a href='#drop_geometry_column'><p>Removes geometry column in sf data frames</p></a></li>
<li><a href='#f_gam_auc_balanced'><p>AUC of Logistic GAM Model</p></a></li>
<li><a href='#f_gam_auc_unbalanced'><p>AUC of Logistic GAM Model with Weighted Cases</p></a></li>
<li><a href='#f_gam_deviance'><p>Explained Deviance from univariate GAM model</p></a></li>
<li><a href='#f_logistic_auc_balanced'><p>AUC of Binomial GLM with Logit Link</p></a></li>
<li><a href='#f_logistic_auc_unbalanced'><p>AUC of Binomial GLM with Logit Link and Case Weights</p></a></li>
<li><a href='#f_rf_auc_balanced'><p>AUC of Random Forest model of a balanced binary response</p></a></li>
<li><a href='#f_rf_auc_unbalanced'><p>AUC of Random Forest model of an unbalanced binary response</p></a></li>
<li><a href='#f_rf_rsquared'><p>R-squared of Random Forest model</p></a></li>
<li><a href='#f_rsquared'><p>R-squared between a response and a predictor</p></a></li>
<li><a href='#identify_non_numeric_predictors'><p>Identify non-numeric predictors</p></a></li>
<li><a href='#identify_numeric_predictors'><p>Identify numeric predictors</p></a></li>
<li><a href='#identify_zero_variance_predictors'><p>Identify zero and near-zero-variance predictors</p></a></li>
<li><a href='#preference_order'><p>Compute the preference order for predictors based on a user-defined function.</p></a></li>
<li><a href='#target_encoding_lab'><p>Target encoding of non-numeric variables</p></a></li>
<li><a href='#target_encoding_mean'><p>Target-encoding methods</p></a></li>
<li><a href='#toy'><p>One response and four predictors with varying levels of multicollinearity</p></a></li>
<li><a href='#validate_df'><p>Validate input data frame</p></a></li>
<li><a href='#validate_predictors'><p>Validate the 'predictors' argument for analysis</p></a></li>
<li><a href='#validate_response'><p>Validate the 'response' argument for target encoding of non-numeric variables</p></a></li>
<li><a href='#vi'><p>30.000 records of responses and predictors all over the world</p></a></li>
<li><a href='#vi_predictors'><p>Predictor names in data frame 'vi'</p></a></li>
<li><a href='#vif_df'><p>Variance Inflation Factor</p></a></li>
<li><a href='#vif_select'><p>Automated multicollinearity reduction via Variance Inflation Factor</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Seamless Multicollinearity Management</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>System for seamless management of multicollinearity in data frames
    with numeric and/or categorical variables for statistical analysis and 
    machine learning modeling. The package combines bivariate correlation 
    (Pearson, Spearman, and Cramer's V) with variance inflation factor analysis, 
    target encoding to transform categorical variables into numeric (Micci-Barreca, D. 2001 
    &lt;<a href="https://doi.org/10.1145%2F507533.507538">doi:10.1145/507533.507538</a>&gt;), and a flexible 
    feature prioritization method, to deliver a comprehensive 
    multicollinearity management tool covering a wide range of use cases.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ranger, mgcv, future, future.apply, testthat (&ge; 3.0.0),
spelling</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://blasbenito.github.io/collinear/">https://blasbenito.github.io/collinear/</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-07 19:44:28 UTC; blas</td>
</tr>
<tr>
<td>Author:</td>
<td>Blas M. Benito <a href="https://orcid.org/0000-0001-5105-7232"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Blas M. Benito &lt;blasbenito@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-08 08:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='auc_score'>Area Under the Receiver Operating Characteristic</h2><span id='topic+auc_score'></span>

<h3>Description</h3>

<p>Computes the AUC score of binary model predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auc_score(observed = NULL, predicted = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auc_score_+3A_observed">observed</code></td>
<td>
<p>(required, integer) Numeric vector with observations. Valid values are 1 and 0. Must have the same length as <code>predicted</code>. Default: NULL</p>
</td></tr>
<tr><td><code id="auc_score_+3A_predicted">predicted</code></td>
<td>
<p>(required, numeric) Numeric vector in the range 0-1 with binary model predictions. Must have the same length as <code>observed</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>AUC value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 out &lt;- auc_score(
   observed = c(0, 0, 1, 1),
   predicted = c(0.1, 0.6, 0.4, 0.8)
   )

</code></pre>

<hr>
<h2 id='case_weights'>Case Weights for Unbalanced Binary Response</h2><span id='topic+case_weights'></span>

<h3>Description</h3>

<p>Case Weights for Unbalanced Binary Response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>case_weights(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="case_weights_+3A_x">x</code></td>
<td>
<p>(required, integer vector) Binary response with 1s and 0s. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with a length equal to <code>x</code> with case weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

 case_weights(
   x = c(0, 0, 0, 1, 1)
 )

 }
</code></pre>

<hr>
<h2 id='collinear'>Automated multicollinearity management</h2><span id='topic+collinear'></span>

<h3>Description</h3>

<p>Automates multicollinearity management in data frames with numeric and categorical predictors by combining four methods:
</p>

<ul>
<li><p> Pairwise correlation filtering: Pearson, Spearman, and Cramer's V statistics to identify pairs of highly correlated predictors.
</p>
</li>
<li><p> Variance Inflation Factor (VIF) filtering: identifies predictors that are linear combinations of other predictors.
</p>
</li>
<li><p> Target encoding: to transform categorical predictors to numeric using a numeric variable as reference.
</p>
</li>
<li><p> Flexible prioritization method: to help the user select a meaningful set of non-correlated predictors.
</p>
</li></ul>

<p>The pairwise correlation filtering is implemented in <code><a href="#topic+cor_select">cor_select()</a></code>. This function applies a recursive forward selection algorithm to keep predictors with a Pearson correlation with all other selected predictors lower than the value of the argument <code>max_cor</code>.  When two predictors are correlated above this threshold, the one with the lowest preference order is removed. At this stage, if <code>preference_order</code> is NULL, predictors are ranked from lower to higher sum of absolute pairwise correlation with the other predictors.
</p>
<p>The VIF-based filtering is implemented in <code><a href="#topic+vif_select">vif_select()</a></code>, which removes variables and recomputes VIF scores iteratively, until all variables in the resulting selection have a VIF below the value of the argument <code>max_vif</code>. The VIF for a given variable <code>y</code> is computed as <code>1/(1-R2)</code>, where <code>R2</code> is the R-squared of a multiple regression model fitted using <code>y</code> as response against the other predictors. The equation can be interpreted as &quot;the rate of perfect model's R-squared to the unexplained variance of this model&quot;. The possible range of VIF values is (1, Inf], but the recommended thresholds for maximum VIF (argument <code>max_vif</code>) may vary, being 2.5, 5, and 10 the values most commonly mentioned in the relevant bibliography. At this stage, if <code>preference_order</code> is NULL, predictors are ranked from lower to higher Variance Inflation Factor.
</p>
<p>When a 'response' argument is provided, categorical predictors are converted to numeric via target encoding with the function <code><a href="#topic+target_encoding_lab">target_encoding_lab()</a></code>, and all predictors are then handled as numeric during the multicollinearity filtering. When the 'response' argument is not provided, categorical variables are ignored. However, in such case, the function <code><a href="#topic+cor_select">cor_select()</a></code> can handle categorical variables, albeit with a lower computation speed.
</p>
<p>The argument <code>preference_order</code> allows prioritizing variables that might be interesting or even required for a given analysis. If <code>preference_order</code> is not provided, then the predictors are ranked from lower to higher sum of their absolute correlations with the other predictors in <code><a href="#topic+cor_select">cor_select()</a></code>, and by their VIF in <code><a href="#topic+vif_select">vif_select()</a></code>, and removed one by one until the maximum R-squared of the correlation matrix is lower than <code>max_cor</code> and the maximum VIF is below <code>max_vif</code>.
</p>
<p>Please note that near-zero variance columns are identified by <code><a href="#topic+identify_zero_variance_predictors">identify_zero_variance_predictors()</a></code>, and ignored by <code><a href="#topic+collinear">collinear()</a></code>, <code><a href="#topic+cor_select">cor_select()</a></code>, and <code><a href="#topic+vif_select">vif_select()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collinear(
  df = NULL,
  response = NULL,
  predictors = NULL,
  preference_order = NULL,
  cor_method = "pearson",
  max_cor = 0.75,
  max_vif = 5,
  encoding_method = "mean"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collinear_+3A_df">df</code></td>
<td>
<p>(required; data frame) A data frame with numeric and/or character predictors predictors, and optionally, a response variable. Default: NULL.</p>
</td></tr>
<tr><td><code id="collinear_+3A_response">response</code></td>
<td>
<p>(recommended, character string) Name of a numeric response variable. Character response variables are ignored. Please, see 'Details' to better understand how providing this argument or not leads to different results when there are character variables in 'predictors'. Default: NULL.</p>
</td></tr>
<tr><td><code id="collinear_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) character vector with predictor names in 'df'. If omitted, all columns of 'df' are used as predictors. Default: NULL</p>
</td></tr>
<tr><td><code id="collinear_+3A_preference_order">preference_order</code></td>
<td>
<p>(optional; character vector) vector with column names in 'predictors' in the desired preference order, or result of the function <code><a href="#topic+preference_order">preference_order()</a></code>. Allows defining a priority order for selecting predictors, which can be particularly useful when some predictors are more critical for the analysis than others. Predictors not included in this argument are ranked by their Variance Inflation Factor. Default: NULL.</p>
</td></tr>
<tr><td><code id="collinear_+3A_cor_method">cor_method</code></td>
<td>
<p>(optional; character string) Method used to compute pairwise correlations. Accepted methods are &quot;pearson&quot; (with a recommended minimum of 30 rows in 'df') or &quot;spearman&quot; (with a recommended minimum of 10 rows in 'df'). Default: &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code id="collinear_+3A_max_cor">max_cor</code></td>
<td>
<p>(optional; numeric) Maximum correlation allowed between any pair of predictors. Higher values return larger number of predictors with higher multicollinearity. Default: <code>0.75</code></p>
</td></tr>
<tr><td><code id="collinear_+3A_max_vif">max_vif</code></td>
<td>
<p>(optional, numeric) Numeric with recommended values between 2.5 and 10 defining the maximum VIF allowed for any given predictor in the output dataset. Higher VIF thresholds should result in a higher number of selected variables. Default: 5.</p>
</td></tr>
<tr><td><code id="collinear_+3A_encoding_method">encoding_method</code></td>
<td>
<p>(optional; character string). Name of the target encoding method to convert character and factor predictors to numeric. One of &quot;mean&quot;, &quot;rank&quot;, &quot;loo&quot;, &quot;rnorm&quot; (see <code><a href="#topic+target_encoding_lab">target_encoding_lab()</a></code> for further details). Default: &quot;mean&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with the names of uncorrelated predictors.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito
</p>


<h3>References</h3>


<ul>
<li><p> David A. Belsley, D.A., Kuh, E., Welsch, R.E. (1980). Regression Diagnostics: Identifying Influential Data and Sources of Collinearity. John Wiley &amp; Sons. <a href="https://doi.org/10.1002/0471725153">doi:10.1002/0471725153</a>.
</p>
</li>
<li><p> Micci-Barreca, D. (2001) A Preprocessing Scheme for High-Cardinality Categorical Attributes in Classification and Prediction Problems. SIGKDD Explor. Newsl. 3, 1, 27-32 <a href="https://doi.org/10.1145/507533.507538">doi:10.1145/507533.507538</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi,
  vi_predictors
)

#subset to limit example run time
vi &lt;- vi[1:1000, ]

#without response
#without preference_order
#permissive max_cor and max_vif
#only numeric variables in output
selected.predictors &lt;- collinear(
  df = vi,
  predictors = vi_predictors,
  max_cor = 0.8,
  max_vif = 10
  )

selected.predictors

#without response
#without preference_order
#restrictive max_cor and max_vif
#only numeric variables in output
selected.predictors &lt;- collinear(
  df = vi,
  predictors = vi_predictors,
  max_cor = 0.5,
  max_vif = 2.5
)

selected.predictors

#with response
#without preference_order
#restrictive max_cor and max_vif
#numerics and categorical variables in output
selected.predictors &lt;- collinear(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  max_cor = 0.5,
  max_vif = 2.5
)

selected.predictors

#with response
#with user-defined preference_order
#restrictive max_cor and max_vif
#numerics and categorical variables in output
selected.predictors &lt;- collinear(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  preference_order = c(
    "soil_temperature_mean",
    "swi_mean",
    "rainfall_mean",
    "evapotranspiration_mean"
  ),
  max_cor = 0.5,
  max_vif = 2.5
)

selected.predictors


#with response
#with automated preference_order
#restrictive max_cor and max_vif
#numerics and categorical variables in output
preference.order &lt;- preference_order(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  f = f_rsquared, #cor(response, predictor)
  workers = 1
)

selected.predictors &lt;- collinear(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  preference_order = preference.order,
  max_cor = 0.5,
  max_vif = 2.5
)

selected.predictors

</code></pre>

<hr>
<h2 id='collinear-package'>collinear</h2><span id='topic+collinear-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>Package for multicollinearity management in data frames with numeric and categorical variables.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Blas M. Benito <a href="mailto:blasbenito@gmail.com">blasbenito@gmail.com</a> (<a href="https://orcid.org/0000-0001-5105-7232">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://blasbenito.github.io/collinear/">https://blasbenito.github.io/collinear/</a>
</p>
</li></ul>


<hr>
<h2 id='cor_df'>Correlation data frame of numeric and character variables</h2><span id='topic+cor_df'></span>

<h3>Description</h3>

<p>Returns a correlation data frame between all pairs of predictors in a training dataset. Non-numeric predictors are transformed into numeric via target encoding, using the 'response' variable as reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_df(
  df = NULL,
  response = NULL,
  predictors = NULL,
  cor_method = "pearson",
  encoding_method = "mean"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_df_+3A_df">df</code></td>
<td>
<p>(required; data frame) A data frame with numeric and/or character predictors, and optionally, a response variable. Default: NULL.</p>
</td></tr>
<tr><td><code id="cor_df_+3A_response">response</code></td>
<td>
<p>(recommended, character string) Name of a numeric response variable. Character response variables are ignored. Please, see 'Details' to better understand how providing this argument or not leads to different results when there are character variables in 'predictors'. Default: NULL.</p>
</td></tr>
<tr><td><code id="cor_df_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) character vector with predictor names in 'df'. If omitted, all columns of 'df' are used as predictors. Default:'NULL'</p>
</td></tr>
<tr><td><code id="cor_df_+3A_cor_method">cor_method</code></td>
<td>
<p>(optional; character string) Method used to compute pairwise correlations. Accepted methods are &quot;pearson&quot; (with a recommended minimum of 30 rows in 'df') or &quot;spearman&quot; (with a recommended minimum of 10 rows in 'df'). Default: &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code id="cor_df_+3A_encoding_method">encoding_method</code></td>
<td>
<p>(optional; character string). Name of the target encoding method to convert character and factor predictors to numeric. One of &quot;mean&quot;, &quot;rank&quot;, &quot;loo&quot;, &quot;rnorm&quot; (see <code><a href="#topic+target_encoding_lab">target_encoding_lab()</a></code> for further details). Default: &quot;mean&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function attempts to handle correlations between pairs of variables that can be of different types:
</p>

<ul>
<li><p> numeric vs. numeric: computed with stats::cor() with the methods &quot;pearson&quot; or &quot;spearman&quot;.
</p>
</li>
<li><p> numeric vs. character, two alternatives leading to different results:
</p>

<ul>
<li><p> 'response' is provided: the character variable is target-encoded as numeric using the values of the response as reference, and then its correlation with the numeric variable is computed with stats::cor(). This option generates a response-specific result suitable for training statistical and machine-learning models
</p>
</li>
<li><p> 'response' is NULL (or the name of a non-numeric column): the character variable is target-encoded as numeric using the values of the numeric predictor (instead of the response) as reference, and then their correlation is computed with stats::cor(). This option leads to a response-agnostic result suitable for clustering problems.
</p>
</li></ul>

</li>
<li><p> character vs. character, two alternatives leading to different results:
</p>

<ul>
<li><p> 'response' is provided: the character variables are target-encoded as numeric using the values of the response as reference, and then their correlation is computed with stats::cor().
</p>
</li>
<li><p> response' is NULL (or the name of a non-numeric column): the association between the character variables is computed using Cramer's V. This option might be problematic, because R-squared values and Cramer's V, even when having the same range between 0 and 1, are not fully comparable.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>data frame with pairs of predictors and their correlation.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi,
  vi_predictors
)

#reduce size of vi to speed-up example execution
vi &lt;- vi[1:1000, ]
vi_predictors &lt;- vi_predictors[1:10]

#without response
#categorical vs categorical compared with cramer_v()
#categorical vs numerical compared wit stats::cor() via target-encoding
#numerical vs numerical compared with stats::cor()
df &lt;- cor_df(
  df = vi,
  predictors = vi_predictors
)

head(df)

#with response
#different solution than previous one
#because target encoding is done against the response
#rather than against the other numeric in the pair
df &lt;- cor_df(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors
)

head(df)

</code></pre>

<hr>
<h2 id='cor_matrix'>Correlation matrix of numeric and character variables</h2><span id='topic+cor_matrix'></span>

<h3>Description</h3>

<p>Returns a correlation matrix between all pairs of predictors in a training dataset. Non-numeric predictors are transformed into numeric via target encoding, using the 'response' variable as reference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_matrix(
  df = NULL,
  response = NULL,
  predictors = NULL,
  cor_method = "pearson",
  encoding_method = "mean"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_matrix_+3A_df">df</code></td>
<td>
<p>(required; data frame) A data frame with numeric and/or character predictors, and optionally, a response variable. Default: NULL.</p>
</td></tr>
<tr><td><code id="cor_matrix_+3A_response">response</code></td>
<td>
<p>(recommended, character string) Name of a numeric response variable. Character response variables are ignored. Please, see 'Details' to better understand how providing this argument or not leads to different results when there are character variables in 'predictors'. Default: NULL.</p>
</td></tr>
<tr><td><code id="cor_matrix_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) character vector with predictor names in 'df'. If omitted, all columns of 'df' are used as predictors. Default:'NULL'</p>
</td></tr>
<tr><td><code id="cor_matrix_+3A_cor_method">cor_method</code></td>
<td>
<p>(optional; character string) Method used to compute pairwise correlations. Accepted methods are &quot;pearson&quot; (with a recommended minimum of 30 rows in 'df') or &quot;spearman&quot; (with a recommended minimum of 10 rows in 'df'). Default: &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code id="cor_matrix_+3A_encoding_method">encoding_method</code></td>
<td>
<p>(optional; character string). Name of the target encoding method to convert character and factor predictors to numeric. One of &quot;mean&quot;, &quot;rank&quot;, &quot;loo&quot;, &quot;rnorm&quot; (see <code><a href="#topic+target_encoding_lab">target_encoding_lab()</a></code> for further details). Default: &quot;mean&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function attempts to handle correlations between pairs of variables that can be of different types:
</p>

<ul>
<li><p> numeric vs. numeric: computed with stats::cor() with the methods &quot;pearson&quot; or &quot;spearman&quot;.
</p>
</li>
<li><p> numeric vs. character, two alternatives leading to different results:
</p>

<ul>
<li><p> 'response' is provided: the character variable is target-encoded as numeric using the values of the response as reference, and then its correlation with the numeric variable is computed with stats::cor(). This option generates a response-specific result suitable for training statistical and machine-learning models
</p>
</li>
<li><p> 'response' is NULL (or the name of a non-numeric column): the character variable is target-encoded as numeric using the values of the numeric predictor (instead of the response) as reference, and then their correlation is computed with stats::cor(). This option leads to a response-agnostic result suitable for clustering problems.
</p>
</li></ul>

</li>
<li><p> character vs. character, two alternatives leading to different results:
</p>

<ul>
<li><p> 'response' is provided: the character variables are target-encoded as numeric using the values of the response as reference, and then their correlation is computed with stats::cor().
</p>
</li>
<li><p> response' is NULL (or the name of a non-numeric column): the association between the character variables is computed using Cramer's V. This option might be problematic, because R-squared values and Cramer's V, even when having the same range between 0 and 1, are not fully comparable.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>correlation matrix
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi,
  vi_predictors
)

#subset to limit example run time
vi &lt;- vi[1:1000, ]
vi_predictors &lt;- vi_predictors[1:5]

#convert correlation data frame to matrix
df &lt;- cor_df(
  df = vi,
  predictors = vi_predictors
)

m &lt;- cor_matrix(
  df = df
)

#show first three columns and rows
m[1:5, 1:5]

#generate correlation matrix directly
m &lt;- cor_matrix(
  df = vi,
  predictors = vi_predictors
)

m[1:5, 1:5]

#with response (much faster)
#different solution than previous one
#because target encoding is done against the response
#rather than against the other numeric in the pair
m &lt;- cor_matrix(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors
)

m[1:5, 1:5]

</code></pre>

<hr>
<h2 id='cor_select'>Automated multicollinearity reduction via pairwise correlation</h2><span id='topic+cor_select'></span>

<h3>Description</h3>

<p>Applies a recursive forward selection algorithm algorithm to select predictors with a bivariate correlation with any other predictor lower than a threshold defined by the argument <code>max_cor</code>.
</p>
<p>If the argument <code>response</code> is provided, all non-numeric variables in <code>predictors</code> are transformed into numeric using target encoding (see <code><a href="#topic+target_encoding_lab">target_encoding_lab()</a></code>). Otherwise, non-numeric variables are ignored.
</p>
<p>The argument <code>preference_order</code> allows defining a preference selection order to preserve (when possible) variables that might be interesting or even required for a given analysis. If NULL, predictors are ordered from lower to higher sum of their absolute pairwise correlation with the other predictors.
</p>
<p>For example, if <code>predictors</code> is <code>c("a", "b", "c")</code> and <code>preference_order</code> is <code>c("a", "b")</code>, there are two possibilities:
</p>

<ul>
<li><p> If the correlation between <code>"a"</code> and <code>"b"</code> is below <code>max_cor</code>, both variables are selected.
</p>
</li>
<li><p> If their correlation is equal or above <code>max_cor</code>, then <code>"a"</code> is selected, no matter its correlation with <code>"c"</code>,
</p>
</li></ul>

<p>If <code>preference_order</code> is not provided, then the predictors are ranked by their variance inflation factor as computed by <code>vif_df()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_select(
  df = NULL,
  response = NULL,
  predictors = NULL,
  preference_order = NULL,
  cor_method = "pearson",
  max_cor = 0.75,
  encoding_method = "mean"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_select_+3A_df">df</code></td>
<td>
<p>(required; data frame) A data frame with numeric and/or character predictors predictors, and optionally, a response variable. Default: NULL.</p>
</td></tr>
<tr><td><code id="cor_select_+3A_response">response</code></td>
<td>
<p>(recommended, character string) Name of a numeric response variable. Character response variables are ignored. Please, see 'Details' to better understand how providing this argument or not leads to different results when there are character variables in 'predictors'. Default: NULL.</p>
</td></tr>
<tr><td><code id="cor_select_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Character vector with predictor names in 'df'. If omitted, all columns of 'df' are used as predictors. Default:'NULL'</p>
</td></tr>
<tr><td><code id="cor_select_+3A_preference_order">preference_order</code></td>
<td>
<p>(optional; character vector) vector with column names in 'predictors' in the desired preference order, or result of the function <code><a href="#topic+preference_order">preference_order()</a></code>. Allows defining a priority order for selecting predictors, which can be particularly useful when some predictors are more critical for the analysis than others. Default: NULL (predictors ordered from lower to higher sum of absolute correlation with the other predictors).</p>
</td></tr>
<tr><td><code id="cor_select_+3A_cor_method">cor_method</code></td>
<td>
<p>(optional; character string) Method used to compute pairwise correlations. Accepted methods are &quot;pearson&quot; (with a recommended minimum of 30 rows in 'df') or &quot;spearman&quot; (with a recommended minimum of 10 rows in 'df'). Default: &quot;pearson&quot;.</p>
</td></tr>
<tr><td><code id="cor_select_+3A_max_cor">max_cor</code></td>
<td>
<p>(optional; numeric) Maximum correlation allowed between any pair of predictors. Higher values return larger number of predictors with higher multicollinearity. Default: 0.75</p>
</td></tr>
<tr><td><code id="cor_select_+3A_encoding_method">encoding_method</code></td>
<td>
<p>(optional; character string). Name of the target encoding method to convert character and factor predictors to numeric. One of &quot;mean&quot;, &quot;rank&quot;, &quot;loo&quot;, &quot;rnorm&quot; (see <code><a href="#topic+target_encoding_lab">target_encoding_lab()</a></code> for further details). Default: &quot;mean&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with the names of the selected predictors.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi,
  vi_predictors
)

#subset to limit example run time
vi &lt;- vi[1:1000, ]
vi_predictors &lt;- vi_predictors[1:10]

#without response
#without preference_order
#permissive max_cor
selected.predictors &lt;- cor_select(
  df = vi,
  predictors = vi_predictors,
  max_cor = 0.8
)

selected.predictors

#without response
#without preference_order
#restrictive max_cor
selected.predictors &lt;- cor_select(
  df = vi,
  predictors = vi_predictors,
  max_cor = 0.5
)

selected.predictors

#with response
#without preference_order
#restrictive max_cor
#slightly different solution than previous one
#because here target encoding is done against the response
#while before was done pairwise against each numeric predictor
selected.predictors &lt;- cor_select(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  max_cor = 0.5
)

selected.predictors

#with response
#with user-defined preference_order
#restrictive max_cor
#numerics and categorical variables in output
selected.predictors &lt;- cor_select(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  preference_order = c(
    "soil_type", #categorical variable
    "soil_temperature_mean",
    "swi_mean",
    "rainfall_mean",
    "evapotranspiration_mean"
  ),
  max_cor = 0.5
)

selected.predictors


#with response
#with automated preference_order
#restrictive max_cor and max_vif
#numerics and categorical variables in output
preference.order &lt;- preference_order(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  f = f_rsquared #cor(response, predictor)
)

head(preference.order)

selected.predictors &lt;- cor_select(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  preference_order = preference.order,
  max_cor = 0.5
)

selected.predictors

</code></pre>

<hr>
<h2 id='cramer_v'>Bias Corrected Cramer's V</h2><span id='topic+cramer_v'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+cramer_v">cramer_v()</a></code> function calculates bias-corrected Cramer's V, a measure of association between two categorical variables.
</p>
<p>Cramer's V is an extension of the chi-squared test to measure the strength of association between two categorical variables. Provides values between 0 and 1, where 0 indicates no association, and 1 indicates a perfect association. In essence, Cramer's V assesses the co-occurrence of the categories of two variables to quantify how strongly these variables are related.
</p>
<p>Even when its range is between 0 and 1, Cramer's V values are not directly comparable to R-squared values, and as such, a multicollinearity analysis containing both types of values must be assessed with care. It is probably preferable to convert non-numeric variables to numeric using target encoding rather before a multicollinearity analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cramer_v(x = NULL, y = NULL, check_input = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cramer_v_+3A_x">x</code></td>
<td>
<p>(required; character vector) character vector representing a categorical variable.  Default: NULL</p>
</td></tr>
<tr><td><code id="cramer_v_+3A_y">y</code></td>
<td>
<p>(required; character vector) character vector representing a categorical variable. Must have the same length as 'x'. Default: NULL</p>
</td></tr>
<tr><td><code id="cramer_v_+3A_check_input">check_input</code></td>
<td>
<p>(required; logical) If FALSE, disables data checking for a slightly faster execution. Default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric, value of Cramer's V
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito
</p>


<h3>References</h3>


<ul>
<li><p> Cramér, H. (1946). Mathematical Methods of Statistics. Princeton: Princeton University Press, page 282 (Chapter 21. The two-dimensional case). ISBN 0-691-08004-6
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
#loading example data
data(vi)

#subset to limit example run time
vi &lt;- vi[1:1000, ]

#computing Cramer's V for two categorical predictors
v &lt;- cramer_v(
  x = vi$soil_type,
  y = vi$koppen_zone
  )

v

</code></pre>

<hr>
<h2 id='drop_geometry_column'>Removes geometry column in sf data frames</h2><span id='topic+drop_geometry_column'></span>

<h3>Description</h3>

<p>Replicates the functionality of  <code style="white-space: pre;">&#8288;\link[sf]{st_drop_geometry}&#8288;</code> without depending on the <code>sf</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_geometry_column(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_geometry_column_+3A_df">df</code></td>
<td>
<p>(required; data frame or matrix) Input data frame. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input data frame without a geometry column
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito
</p>

<hr>
<h2 id='f_gam_auc_balanced'>AUC of Logistic GAM Model</h2><span id='topic+f_gam_auc_balanced'></span>

<h3>Description</h3>

<p>Fits a binomial logistic Generalized Additive Model (GAM) <code>y ~ s(x, k = 3)</code> between a binary response and a numeric predictor and returns the Area Under the Curve of the observations versus the predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_gam_auc_balanced(x, y, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_gam_auc_balanced_+3A_x">x</code></td>
<td>
<p>(required, character string) name of the predictor variable.</p>
</td></tr>
<tr><td><code id="f_gam_auc_balanced_+3A_y">y</code></td>
<td>
<p>(required, character string) name of the binary response variable.</p>
</td></tr>
<tr><td><code id="f_gam_auc_balanced_+3A_df">df</code></td>
<td>
<p>(required, data frame) data frame with the columns 'x' and 'y'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Area Under the Curve
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vi)

#subset to limit example run time
vi &lt;- vi[1:1000, ]

#this example requires "mgcv" installed
if(requireNamespace(package = "mgcv", quietly = TRUE)){

  f_gam_auc_balanced(
    x = "growing_season_length", #predictor
    y = "vi_binary",               #response
    df = vi
  )

}

</code></pre>

<hr>
<h2 id='f_gam_auc_unbalanced'>AUC of Logistic GAM Model with Weighted Cases</h2><span id='topic+f_gam_auc_unbalanced'></span>

<h3>Description</h3>

<p>Fits a quasibinomial logistic Generalized Additive Model (GAM) <code>y ~ s(x, k = 3)</code> with weighted cases between a binary response and a numeric predictor and returns the Area Under the Curve of the observations versus the predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_gam_auc_unbalanced(x, y, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_gam_auc_unbalanced_+3A_x">x</code></td>
<td>
<p>(required, character string) name of the predictor variable.</p>
</td></tr>
<tr><td><code id="f_gam_auc_unbalanced_+3A_y">y</code></td>
<td>
<p>(required, character string) name of the binary response variable</p>
</td></tr>
<tr><td><code id="f_gam_auc_unbalanced_+3A_df">df</code></td>
<td>
<p>(required, data frame) data frame with the columns 'x' and 'y'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Area Under the Curve
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vi)

#subset to limit example run time
vi &lt;- vi[1:1000, ]

#this example requires "mgcv" installed
if(requireNamespace(package = "mgcv", quietly = TRUE)){

  f_gam_auc_unbalanced(
    x = "growing_season_length", #predictor
    y = "vi_binary",               #response
    df = vi
  )

}

</code></pre>

<hr>
<h2 id='f_gam_deviance'>Explained Deviance from univariate GAM model</h2><span id='topic+f_gam_deviance'></span>

<h3>Description</h3>

<p>Computes the explained deviance of a response against a predictor via Generalized Additive Model (GAM). This option is slower than <code><a href="#topic+f_rsquared">f_rsquared()</a></code>, but suitable if you will be fitting GAMs with the resulting preference order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_gam_deviance(x, y, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_gam_deviance_+3A_x">x</code></td>
<td>
<p>(required, character string) name of the predictor variable.</p>
</td></tr>
<tr><td><code id="f_gam_deviance_+3A_y">y</code></td>
<td>
<p>(required, character string) name of the response variable</p>
</td></tr>
<tr><td><code id="f_gam_deviance_+3A_df">df</code></td>
<td>
<p>(required, data frame) data frame with the columns 'x' and 'y'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Explained deviance
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vi)

#subset to limit example run time
vi &lt;- vi[1:1000, ]

#this example requires "mgcv" installed in the system
if(requireNamespace(package = "mgcv", quietly = TRUE)){

  f_gam_deviance(
    x = "growing_season_length", #predictor
    y = "vi_mean",               #response
    df = vi
  )

}

</code></pre>

<hr>
<h2 id='f_logistic_auc_balanced'>AUC of Binomial GLM with Logit Link</h2><span id='topic+f_logistic_auc_balanced'></span>

<h3>Description</h3>

<p>Fits a logistic GLM model <code>y ~ x</code> when <code>y</code> is a binary response with values 0 and 1 and <code>x</code> is numeric. This function is suitable when the response variable is balanced. If the response is unbalanced, then <code><a href="#topic+f_logistic_auc_unbalanced">f_logistic_auc_unbalanced()</a></code> should provide better results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_logistic_auc_balanced(x, y, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_logistic_auc_balanced_+3A_x">x</code></td>
<td>
<p>(required, character string) name of the predictor variable.</p>
</td></tr>
<tr><td><code id="f_logistic_auc_balanced_+3A_y">y</code></td>
<td>
<p>(required, character string) name of the binary response variable</p>
</td></tr>
<tr><td><code id="f_logistic_auc_balanced_+3A_df">df</code></td>
<td>
<p>(required, data frame) data frame with the columns 'x' and 'y'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Area Under the Curve
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vi)

#subset to limit example run time
vi &lt;- vi[1:1000, ]

f_logistic_auc_balanced(
  x = "growing_season_length", #predictor
  y = "vi_binary",             #binary response
  df = vi
)

</code></pre>

<hr>
<h2 id='f_logistic_auc_unbalanced'>AUC of Binomial GLM with Logit Link and Case Weights</h2><span id='topic+f_logistic_auc_unbalanced'></span>

<h3>Description</h3>

<p>Fits a quasibinomial GLM model <code>y ~ x</code> with case weights when <code>y</code> is an unbalanced binary response with values 0 and 1 and <code>x</code> is numeric. It uses the function <code><a href="#topic+case_weights">case_weights()</a></code> to weight 0s and 1s according to their frequency within <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_logistic_auc_unbalanced(x, y, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_logistic_auc_unbalanced_+3A_x">x</code></td>
<td>
<p>(required, character string) name of the predictor variable.</p>
</td></tr>
<tr><td><code id="f_logistic_auc_unbalanced_+3A_y">y</code></td>
<td>
<p>(required, character string) name of the binary response variable.</p>
</td></tr>
<tr><td><code id="f_logistic_auc_unbalanced_+3A_df">df</code></td>
<td>
<p>(required, data frame) data frame with the columns 'x' and 'y'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Area Under the Curve
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vi)

#subset to limit example run time
vi &lt;- vi[1:1000, ]

f_logistic_auc_unbalanced(
  x = "growing_season_length", #predictor
  y = "vi_binary",             #binary response
  df = vi
)

</code></pre>

<hr>
<h2 id='f_rf_auc_balanced'>AUC of Random Forest model of a balanced binary response</h2><span id='topic+f_rf_auc_balanced'></span>

<h3>Description</h3>

<p>Computes a univariate random forest model  cases via <code style="white-space: pre;">&#8288;\link[ranger]{ranger}&#8288;</code> and returns the Area Under the Curve on the out-of-bag data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_rf_auc_balanced(x, y, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_rf_auc_balanced_+3A_x">x</code></td>
<td>
<p>(required, character string) name of the predictor variable.</p>
</td></tr>
<tr><td><code id="f_rf_auc_balanced_+3A_y">y</code></td>
<td>
<p>(required, character string) name of the binary response variable</p>
</td></tr>
<tr><td><code id="f_rf_auc_balanced_+3A_df">df</code></td>
<td>
<p>(required, data frame) data frame with the columns 'x' and 'y'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Area Under the Curve
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vi)

#subset to limit example run time
vi &lt;- vi[1:1000, ]

#this example requires "ranger" installed in the system
if(requireNamespace(package = "ranger", quietly = TRUE)){

  f_rf_auc_balanced(
    x = "growing_season_length", #predictor
    y = "vi_binary",               #response
    df = vi
  )

}

</code></pre>

<hr>
<h2 id='f_rf_auc_unbalanced'>AUC of Random Forest model of an unbalanced binary response</h2><span id='topic+f_rf_auc_unbalanced'></span>

<h3>Description</h3>

<p>Computes a univariate random forest model with weighted cases via <code style="white-space: pre;">&#8288;\link[ranger]{ranger}&#8288;</code> and returns the Area Under the Curve on the out-of-bag data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_rf_auc_unbalanced(x, y, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_rf_auc_unbalanced_+3A_x">x</code></td>
<td>
<p>(required, character string) name of the predictor variable.</p>
</td></tr>
<tr><td><code id="f_rf_auc_unbalanced_+3A_y">y</code></td>
<td>
<p>(required, character string) name of the binary response variable</p>
</td></tr>
<tr><td><code id="f_rf_auc_unbalanced_+3A_df">df</code></td>
<td>
<p>(required, data frame) data frame with the columns 'x' and 'y'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Area Under the Curve
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vi)

#subset to limit example run time
vi &lt;- vi[1:1000, ]

#this example requires "ranger" installed in the system
if(requireNamespace(package = "ranger", quietly = TRUE)){

  f_rf_auc_unbalanced(
    x = "growing_season_length", #predictor
    y = "vi_binary",               #response
    df = vi
  )

}

</code></pre>

<hr>
<h2 id='f_rf_rsquared'>R-squared of Random Forest model</h2><span id='topic+f_rf_rsquared'></span><span id='topic+f_rf_deviance'></span>

<h3>Description</h3>

<p>Computes a univariate random forest model with <code style="white-space: pre;">&#8288;\link[ranger]{ranger}&#8288;</code> and returns the R-squared on the out-of-bag data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_rf_rsquared(x, y, df)

f_rf_deviance(x, y, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_rf_rsquared_+3A_x">x</code></td>
<td>
<p>(required, character string) name of the predictor variable.</p>
</td></tr>
<tr><td><code id="f_rf_rsquared_+3A_y">y</code></td>
<td>
<p>(required, character string) name of the response variable</p>
</td></tr>
<tr><td><code id="f_rf_rsquared_+3A_df">df</code></td>
<td>
<p>(required, data frame) data frame with the columns 'x' and 'y'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>f_rf_rsquared()</code> and <code>f_rf_deviance()</code> are synonyms
</p>


<h3>Value</h3>

<p>R-squared
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vi)

#subset to limit example run time
vi &lt;- vi[1:1000, ]

#this example requires "ranger" installed in the system
if(requireNamespace(package = "ranger", quietly = TRUE)){

  f_rf_rsquared(
    x = "growing_season_length", #predictor
    y = "vi_mean",               #response
    df = vi
  )

}

</code></pre>

<hr>
<h2 id='f_rsquared'>R-squared between a response and a predictor</h2><span id='topic+f_rsquared'></span>

<h3>Description</h3>

<p>Computes the R-squared between a response and a predictor.
Fastest option to compute preference order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_rsquared(x, y, df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_rsquared_+3A_x">x</code></td>
<td>
<p>(required, character string) name of the predictor variable.</p>
</td></tr>
<tr><td><code id="f_rsquared_+3A_y">y</code></td>
<td>
<p>(required, character string) name of the response variable</p>
</td></tr>
<tr><td><code id="f_rsquared_+3A_df">df</code></td>
<td>
<p>(required, data frame) data frame with the columns 'x' and 'y'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>R-squared
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vi)

#subset to limit example run time
vi &lt;- vi[1:1000, ]

f_rsquared(
  x = "growing_season_length", #predictor
  y = "vi_mean",               #response
  df = vi
)

</code></pre>

<hr>
<h2 id='identify_non_numeric_predictors'>Identify non-numeric predictors</h2><span id='topic+identify_non_numeric_predictors'></span>

<h3>Description</h3>

<p>Given 'df' and 'predictors' arguments, this function subsets and returns the non-numeric (character, factor, and logical) predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_non_numeric_predictors(df = NULL, predictors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_non_numeric_predictors_+3A_df">df</code></td>
<td>
<p>(required; data frame) A data frame with numeric and/or character predictors predictors, and optionally, a response variable. Default: NULL.</p>
</td></tr>
<tr><td><code id="identify_non_numeric_predictors_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) A vector with predictor names in 'df'. If omitted, all columns of 'df' are used as predictors. Default:'NULL'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector with names of numeric predictors.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi,
  vi_predictors
)

non.numeric.predictors &lt;- identify_non_numeric_predictors(
  df = vi,
  predictors = vi_predictors
)

non.numeric.predictors

</code></pre>

<hr>
<h2 id='identify_numeric_predictors'>Identify numeric predictors</h2><span id='topic+identify_numeric_predictors'></span>

<h3>Description</h3>

<p>Given 'df' and 'predictors' arguments, this function subsets and returns the numeric predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_numeric_predictors(df = NULL, predictors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_numeric_predictors_+3A_df">df</code></td>
<td>
<p>(required; data frame) A data frame with numeric and/or character predictors predictors, and optionally, a response variable. Default: NULL.</p>
</td></tr>
<tr><td><code id="identify_numeric_predictors_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) A vector with predictor names in 'df'. If omitted, all columns of 'df' are used as predictors. Default:'NULL'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector with names of numeric predictors.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {

data(
  vi,
  vi_predictors
)

numeric.predictors &lt;- identify_numeric_predictors(
  df = vi,
  predictors = vi_predictors
)

numeric.predictors

}
</code></pre>

<hr>
<h2 id='identify_zero_variance_predictors'>Identify zero and near-zero-variance predictors</h2><span id='topic+identify_zero_variance_predictors'></span>

<h3>Description</h3>

<p>Predictors a variance of zero or near zero are highly problematic for multicollinearity analysis and modelling in general. This function identifies these predictors with a level of sensitivity defined by the 'decimals' argument. Smaller number of decimals increase the number of variables detected as near zero variance. Recommended values will depend on the range of the numeric variables in 'df'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_zero_variance_predictors(df = NULL, predictors = NULL, decimals = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_zero_variance_predictors_+3A_df">df</code></td>
<td>
<p>(required; data frame) A data frame with numeric and/or character predictors predictors, and optionally, a response variable. Default: NULL.</p>
</td></tr>
<tr><td><code id="identify_zero_variance_predictors_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) A vector with predictor names in 'df'. If omitted, all columns of 'df' are used as predictors. Default:'NULL'</p>
</td></tr>
<tr><td><code id="identify_zero_variance_predictors_+3A_decimals">decimals</code></td>
<td>
<p>(required, integer) number of decimal places for the zero variance test. Default: 4</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector with names of zero and near-zero variance columns.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi,
  vi_predictors
)

#create zero variance predictors
vi$zv_1 &lt;- 1
vi$zv_2 &lt;- runif(n = nrow(vi), min = 0, max = 0.0001)


#add to vi predictors
vi_predictors &lt;- c(
  vi_predictors,
  "zv_1",
  "zv_2"
)

#identify zero variance predictors
zero.variance.predictors &lt;- identify_zero_variance_predictors(
  df = vi,
  predictors = vi_predictors
)

zero.variance.predictors

</code></pre>

<hr>
<h2 id='preference_order'>Compute the preference order for predictors based on a user-defined function.</h2><span id='topic+preference_order'></span>

<h3>Description</h3>

<p>This function calculates the preference order of predictors based on a user-provided function that takes a predictor, a response, and a data frame as arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preference_order(
  df = NULL,
  response = NULL,
  predictors = NULL,
  f = f_rsquared,
  encoding_method = "mean",
  workers = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preference_order_+3A_df">df</code></td>
<td>
<p>(required; data frame) A data frame with numeric and/or character predictors predictors, and optionally, a response variable. Default: NULL.</p>
</td></tr>
<tr><td><code id="preference_order_+3A_response">response</code></td>
<td>
<p>(required, character string) Name of a numeric response variable. Character response variables are ignored. Please, see 'Details' to better understand how providing this argument or not leads to different results when there are character variables in 'predictors'. Default: NULL.</p>
</td></tr>
<tr><td><code id="preference_order_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) character vector with predictor names in 'df'. If omitted, all columns of 'df' are used as predictors. Default:'NULL'</p>
</td></tr>
<tr><td><code id="preference_order_+3A_f">f</code></td>
<td>
<p>(optional: function) A function that returns a value representing the relationship between a given predictor and the response. Higher values are ranked higher. The available options are:
</p>

<ul>
<li> <p><code><a href="#topic+f_rsquared">f_rsquared()</a></code> (default option): returns the R-squared of the correlation between a numeric response and a numeric predictor.
</p>
</li>
<li><p> f_gam_deviance: fits a univariate GAM model between a numeric response and a numeric predictor to return the explained deviance. Requires the package <code>mgcv</code>.
</p>
</li>
<li> <p><code><a href="#topic+f_rf_rsquared">f_rf_rsquared()</a></code> also named <code><a href="#topic+f_rf_deviance">f_rf_deviance()</a></code>: fits a univariate random forest model with <code>ranger::ranger()</code> between a numeric response and a numeric predictor to return the R-squared of the observations against the out-of-bag predictions. Requires the package <code>ranger</code>.
</p>
</li>
<li> <p><code><a href="#topic+f_logistic_auc_balanced">f_logistic_auc_balanced()</a></code>: fits a logistic univariate GLM of a balanced binary response (0s and 1s) against a numeric predictor to return the Area Under the Curve of the observations against the predictors.
</p>
</li>
<li> <p><code><a href="#topic+f_logistic_auc_unbalanced">f_logistic_auc_unbalanced()</a></code>: fits a quasibinomial univariate GLM with weighted cases of an unbalanced binary response (0s and 1s) against a numeric predictor to return the Area Under the Curve of the observations against the predictors.
</p>
</li>
<li> <p><code><a href="#topic+f_gam_auc_balanced">f_gam_auc_balanced()</a></code>: fits a logistic univariate GAM of a balanced binary response (0s and 1s) against a numeric predictor to return the Area Under the Curve of the observations against the predictors.
</p>
</li>
<li> <p><code><a href="#topic+f_gam_auc_unbalanced">f_gam_auc_unbalanced()</a></code>: fits a quasibinomial univariate GAM with weighted cases of an unbalanced binary response (0s and 1s) against a numeric predictor to return the Area Under the Curve of the observations against the predictors.
</p>
</li>
<li> <p><code><a href="#topic+f_rf_auc_balanced">f_rf_auc_balanced()</a></code>: fits a random forest model of a balanced binary response (0s and 1s) against a numeric predictor to return the Area Under the Curve of the observations against the predictors.
</p>
</li>
<li> <p><code><a href="#topic+f_rf_auc_unbalanced">f_rf_auc_unbalanced()</a></code>: fits a random forest model with weighted cases of an unbalanced binary response (0s and 1s) against a numeric predictor to return the Area Under the Curve of the observations against the predictors.
</p>
</li></ul>
</td></tr>
<tr><td><code id="preference_order_+3A_encoding_method">encoding_method</code></td>
<td>
<p>(optional; character string). Name of the target encoding method to convert character and factor predictors to numeric. One of &quot;mean&quot;, &quot;rank&quot;, &quot;loo&quot;, &quot;rnorm&quot; (see <code><a href="#topic+target_encoding_lab">target_encoding_lab()</a></code> for further details). Default: &quot;mean&quot;</p>
</td></tr>
<tr><td><code id="preference_order_+3A_workers">workers</code></td>
<td>
<p>(integer) number of workers for parallel execution. Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the columns &quot;predictor&quot; and &quot;value&quot;. The former contains the predictors names in order, ready for the argument <code>preference_order</code> in <code><a href="#topic+cor_select">cor_select()</a></code>, <code><a href="#topic+vif_select">vif_select()</a></code> and <code><a href="#topic+collinear">collinear()</a></code>. The latter contains the result of the function <code>f</code> for each combination of predictor and response.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi,
  vi_predictors
)

#subset to limit example run time
vi &lt;- vi[1:1000, ]

#computing preference order
#with response
#numeric and categorical predictors in the output
#as the R-squared between each predictor and the response
preference.order &lt;- preference_order(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  f = f_rsquared,
  workers = 1
  )

preference.order

#using it in variable selection with collinear()
selected.predictors &lt;- cor_select(
  df = vi,
  response = "vi_mean", #don't forget the response!
  predictors = vi_predictors,
  preference_order = preference.order,
  max_cor = 0.75
  )

selected.predictors

#check their correlations
selected.predictors.cor &lt;- cor_df(
  df = vi,
  response = "vi_mean",
  predictors = selected.predictors
)

#all correlations below max_cor
selected.predictors.cor

#USING A CUSTOM FUNCTION
#custom function to compute RMSE between a predictor and a response
#x is a predictor name
#y is a response name
#df is a data frame with multiple predictors and one response
#must return a single number, with higher number indicating higher preference
#notice we use "one minus RMSE" to give higher rank to variables with lower RMSE
f_rmse &lt;- function(x, y, df){

  xy &lt;- df[, c(x, y)] |&gt;
    na.omit() |&gt;
    scale()

  1 - sqrt(mean((xy[, 1] - xy[, 2])^2))

}

preference.order &lt;- preference_order(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  f = f_rmse,
  workers = 1
)

preference.order

</code></pre>

<hr>
<h2 id='target_encoding_lab'>Target encoding of non-numeric variables</h2><span id='topic+target_encoding_lab'></span>

<h3>Description</h3>

<p>Target encoding involves replacing the values of categorical variables with numeric ones from a &quot;target variable&quot;, usually a model's response. Target encoding can be useful for improving the performance of machine learning models.
</p>
<p>This function identifies categorical variables in the input data frame, and transforms them using a set of target-encoding methods selected by the user, and returns the input data frame with the newly encoded variables.
</p>
<p>The target encoding methods implemented in this function are:
</p>

<ul>
<li><p> &quot;rank&quot;: Returns the rank of the group as a integer, starting with 1 as the rank of the group with the lower mean of the response variable. The variables returned by this method are named with the suffix &quot;__encoded_rank&quot;. This method is implemented in the function <code><a href="#topic+target_encoding_rank">target_encoding_rank()</a></code>.
</p>
</li>
<li><p> &quot;mean&quot;: Replaces each value of the categorical variable with the mean of the response across the category the given value belongs to. This option accepts the argument &quot;white_noise&quot; to limit potential overfitting. The variables returned by this method are named with the suffix &quot;__encoded_mean&quot;. This method is implemented in the function <code><a href="#topic+target_encoding_mean">target_encoding_mean()</a></code>.
</p>
</li>
<li><p> &quot;rnorm&quot;: Computes the mean and standard deviation of the response for each group of the categorical variable, and uses <code><a href="stats.html#topic+rnorm">rnorm()</a></code> to generate random values from a normal distribution with these parameters. The argument <code>rnorm_sd_multiplier</code> is used as a multiplier of the standard deviation to control the range of values produced by <code><a href="stats.html#topic+rnorm">rnorm()</a></code> for each group of the categorical predictor. The variables returned by this method are named with the suffix &quot;__encoded_rnorm&quot;.  This method is implemented in the function <code><a href="#topic+target_encoding_rnorm">target_encoding_rnorm()</a></code>.
</p>
</li>
<li><p> &quot;loo&quot;: This is the leave-one-out method, that replaces each categorical value with the mean of the response variable across the other cases within the same group. This method supports the <code>white_noise</code> argument to increase limit potential overfitting. The variables returned by this method are named with the suffix &quot;__encoded_loo&quot;. This method is implemented in the function <code><a href="#topic+target_encoding_loo">target_encoding_loo()</a></code>.
</p>
</li></ul>

<p>The methods &quot;mean&quot; and &quot;rank&quot; support the <code>white_noise</code> argument, which is a fraction of the range of the <code>response</code> variable, and the maximum possible value of white noise to be added. For example, if <code>response</code> is within 0 and 1, a <code>white_noise</code> of 0.25 will add to every value of the encoded variable a random number selected from a normal distribution between -0.25 and 0.25. This argument helps control potential overfitting induced by the encoded variable.
</p>
<p>The method &quot;rnorm&quot; has the argument <code>rnorm_sd_multiplier</code>, which multiplies the standard deviation argument of the <code style="white-space: pre;">&#8288;\link[stats]{rnorm}&#8288;</code> function to control the spread of the encoded values between groups. Values smaller than 1 reduce the spread in the results, while values larger than 1 have the opposite effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target_encoding_lab(
  df = NULL,
  response = NULL,
  predictors = NULL,
  encoding_methods = c("mean", "rank", "loo", "rnorm"),
  smoothing = 0,
  rnorm_sd_multiplier = 0,
  seed = 1,
  white_noise = 0,
  replace = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target_encoding_lab_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A training data frame. Default: NULL</p>
</td></tr>
<tr><td><code id="target_encoding_lab_+3A_response">response</code></td>
<td>
<p>(required; character string) Name of the response. Must be a column name of <code>df</code>. Default: NULL</p>
</td></tr>
<tr><td><code id="target_encoding_lab_+3A_predictors">predictors</code></td>
<td>
<p>(required; character vector) Names of all the predictors in <code>df</code>. Only character and factor predictors are processed, but all are returned in the &quot;df&quot; slot of the function's output.  Default: NULL</p>
</td></tr>
<tr><td><code id="target_encoding_lab_+3A_encoding_methods">encoding_methods</code></td>
<td>
<p>(optional; character string or vector). Name of the target encoding methods. Default: c(&quot;mean&quot;, &quot;mean_smoothing, &quot;rank&quot;, &quot;loo&quot;, &quot;rnorm&quot;)</p>
</td></tr>
<tr><td><code id="target_encoding_lab_+3A_smoothing">smoothing</code></td>
<td>
<p>(optional; numeric) Argument of <code><a href="#topic+target_encoding_mean">target_encoding_mean()</a></code> (method &quot;mean_smoothing&quot;). Minimum group size that keeps the mean of the group. Groups smaller than this have their means pulled towards the global mean of the response. Default: 0</p>
</td></tr>
<tr><td><code id="target_encoding_lab_+3A_rnorm_sd_multiplier">rnorm_sd_multiplier</code></td>
<td>
<p>(optional; numeric) Numeric with multiplier of the standard deviation of each group in the categorical variable, in the range 0-1. Controls the variability in the encoded variables to mitigate potential overfitting. Default: <code>1</code></p>
</td></tr>
<tr><td><code id="target_encoding_lab_+3A_seed">seed</code></td>
<td>
<p>(optional; integer) Random seed to facilitate reproducibility when <code>white_noise</code> is not 0. Default: 1</p>
</td></tr>
<tr><td><code id="target_encoding_lab_+3A_white_noise">white_noise</code></td>
<td>
<p>(optional; numeric) Numeric with white noise values in the range 0-1, representing a fraction of the range of the response to be added as noise to the encoded variable. Controls the variability in the encoded variables to mitigate potential overfitting. Default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="target_encoding_lab_+3A_replace">replace</code></td>
<td>
<p>(optional; logical) If <code>TRUE</code>, the function replaces each categorical variable with its encoded version, and returns the input data frame with the encoded variables instead of the original ones. Default: FALSE</p>
</td></tr>
<tr><td><code id="target_encoding_lab_+3A_verbose">verbose</code></td>
<td>
<p>(optional; logical) If TRUE, messages generated during the execution of the function are printed to the console Default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input data frame with newly encoded columns if <code>replace</code> is <code>FALSE</code>, or the input data frame with encoded columns if <code>TRUE</code>
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito
</p>


<h3>References</h3>


<ul>
<li><p> Micci-Barreca, D. (2001) A Preprocessing Scheme for High-Cardinality Categorical Attributes in Classification and Prediction Problems. SIGKDD Explor. Newsl. 3, 1, 27-32 <a href="https://doi.org/10.1145/507533.507538">doi:10.1145/507533.507538</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi,
  vi_predictors
  )

#subset to limit example run time
vi &lt;- vi[1:1000, ]

#applying all methods for a continuous response
df &lt;- target_encoding_lab(
  df = vi,
  response = "vi_mean",
  predictors = "koppen_zone",
  encoding_methods = c(
    "mean",
    "rank",
    "rnorm",
    "loo"
  ),
  rnorm_sd_multiplier = c(0, 0.1, 0.2),
  white_noise = c(0, 0.1, 0.2)
)

#identify encoded predictors
predictors.encoded &lt;- grep(
  pattern = "*__encoded*",
  x = colnames(df),
  value = TRUE
)

#correlation between encoded predictors and the response
stats::cor(
  x = df[["vi_mean"]],
  y = df[, predictors.encoded],
  use = "pairwise.complete.obs"
)


</code></pre>

<hr>
<h2 id='target_encoding_mean'>Target-encoding methods</h2><span id='topic+target_encoding_mean'></span><span id='topic+target_encoding_rnorm'></span><span id='topic+target_encoding_rank'></span><span id='topic+target_encoding_loo'></span><span id='topic+add_white_noise'></span>

<h3>Description</h3>

<p>Methods to apply target-encoding to individual categorical variables. The functions implemented are:
</p>

<ul>
<li> <p><code><a href="#topic+target_encoding_mean">target_encoding_mean()</a></code>: Each group is identified by the mean of the response over the group cases. The argument <code>smoothing</code> controls pushes the mean of small groups towards the global mean to avoid overfitting. White noise can be added via the <code>white_noise</code> argument. Columns encoded with this function are identified by the suffix &quot;__encoded_mean&quot;. If <code>white_noise</code> is used, then the amount of white noise is also added to the suffix.
</p>
</li>
<li> <p><code><a href="#topic+target_encoding_rank">target_encoding_rank()</a></code>: Each group is identified by the rank of the mean of the response variable over the group cases. The group with the lower mean receives the rank 1. White noise can be added via the <code>white_noise</code> argument. Columns encoded with this function are identified by the suffix &quot;__encoded_rank&quot;. If <code>white_noise</code> is used, then the amount of noise is also added to the suffix.
</p>
</li>
<li> <p><code><a href="#topic+target_encoding_rnorm">target_encoding_rnorm()</a></code>: Each case in a group receives a value coming from a normal distribution with the mean and the standard deviation of the response over the cases of the group. The argument <code>rnorm_sd_multiplier</code> multiplies the standard deviation to reduce the spread of the obtained values. Columns encoded with this function are identified by the suffix &quot;__encoded_rnorm_rnorm_sd_multiplier_X&quot;, where X is the amount of <code>rnorm_sd_multiplier</code> used.
</p>
</li>
<li> <p><code><a href="#topic+target_encoding_loo">target_encoding_loo()</a></code>: The suffix &quot;loo&quot; stands for &quot;leave-one-out&quot;. Each case in a group is encoded as the average of the response over the other cases of the group. Columns encoded with this function are identified by the suffix &quot;__encoded_loo&quot;.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>target_encoding_mean(
  df,
  response,
  predictor,
  smoothing = 0,
  white_noise = 0,
  seed = 1,
  replace = FALSE,
  verbose = TRUE
)

target_encoding_rnorm(
  df,
  response,
  predictor,
  rnorm_sd_multiplier = 1,
  seed = 1,
  replace = FALSE,
  verbose = TRUE
)

target_encoding_rank(
  df,
  response,
  predictor,
  white_noise = 0,
  seed = 1,
  replace = FALSE,
  verbose = TRUE
)

target_encoding_loo(
  df,
  response,
  predictor,
  white_noise = 0,
  seed = 1,
  replace = FALSE,
  verbose = TRUE
)

add_white_noise(df, response, predictor, white_noise = 0.1, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target_encoding_mean_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A training data frame. Default: NULL</p>
</td></tr>
<tr><td><code id="target_encoding_mean_+3A_response">response</code></td>
<td>
<p>(required; character string) Name of the response. Must be a column name of <code>df</code>. Default: NULL</p>
</td></tr>
<tr><td><code id="target_encoding_mean_+3A_predictor">predictor</code></td>
<td>
<p>(required; character) Name of the categorical variable to encode. Default: NULL</p>
</td></tr>
<tr><td><code id="target_encoding_mean_+3A_smoothing">smoothing</code></td>
<td>
<p>(optional; numeric) Argument of <code><a href="#topic+target_encoding_mean">target_encoding_mean()</a></code>. Minimum group size that keeps the mean of the group. Groups smaller than this have their means pulled towards the global mean of the response. Default: 0.</p>
</td></tr>
<tr><td><code id="target_encoding_mean_+3A_white_noise">white_noise</code></td>
<td>
<p>(optional; numeric) Numeric with white noise values in the range 0-1, representing a fraction of the range of the response to be added as noise to the encoded variable. Controls the variability in the encoded variables to mitigate potential overfitting. Default: 0.</p>
</td></tr>
<tr><td><code id="target_encoding_mean_+3A_seed">seed</code></td>
<td>
<p>(optional; integer) Random seed to facilitate reproducibility. Default: 1</p>
</td></tr>
<tr><td><code id="target_encoding_mean_+3A_replace">replace</code></td>
<td>
<p>(optional; logical) Advanced option that changes the behavior of the function. Use only if you really know exactly what you need. If <code>TRUE</code>, it replaces each categorical variable with its encoded version, and returns the input data frame with the replaced variables.</p>
</td></tr>
<tr><td><code id="target_encoding_mean_+3A_verbose">verbose</code></td>
<td>
<p>(optional; logical) If TRUE, messages and plots generated during the execution of the function are displayed. Default: TRUE</p>
</td></tr>
<tr><td><code id="target_encoding_mean_+3A_rnorm_sd_multiplier">rnorm_sd_multiplier</code></td>
<td>
<p>(optional; numeric) Numeric with multiplier of the standard deviation of each group in the categorical variable, in the range 0-1. Controls the variability in the encoded variables to mitigate potential overfitting. Default: 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input data frame with a target-encoded variable.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito
</p>


<h3>References</h3>


<ul>
<li><p> Micci-Barreca, D. (2001) A Preprocessing Scheme for High-Cardinality Categorical Attributes in Classification and Prediction Problems. SIGKDD Explor. Newsl. 3, 1, 27-32 <a href="https://doi.org/10.1145/507533.507538">doi:10.1145/507533.507538</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(vi)

#subset to limit example run time
vi &lt;- vi[1:1000, ]

#mean encoding
#-------------

#without noise
df &lt;- target_encoding_mean(
  df = vi,
  response = "vi_mean",
  predictor = "soil_type",
  replace = TRUE
)

plot(
  x = df$soil_type,
  y = df$vi_mean,
  xlab = "encoded variable",
  ylab = "response"
)

#with noise
df &lt;- target_encoding_mean(
  df = vi,
  response = "vi_mean",
  predictor = "soil_type",
  white_noise = 0.1,
  replace = TRUE
)

plot(
  x = df$soil_type,
  y = df$vi_mean,
  xlab = "encoded variable",
  ylab = "response"
)


#group rank
#----------

df &lt;- target_encoding_rank(
  df = vi,
  response = "vi_mean",
  predictor = "soil_type",
  replace = TRUE
)

plot(
  x = df$soil_type,
  y = df$vi_mean,
  xlab = "encoded variable",
  ylab = "response"
)


#leave-one-out
#-------------

#without noise
df &lt;- target_encoding_loo(
  df = vi,
  response = "vi_mean",
  predictor = "soil_type",
  replace = TRUE
)

plot(
  x = df$soil_type,
  y = df$vi_mean,
  xlab = "encoded variable",
  ylab = "response"
)

#with noise
df &lt;- target_encoding_loo(
  df = vi,
  response = "vi_mean",
  predictor = "soil_type",
  white_noise = 0.1,
  replace = TRUE
)

plot(
  x = df$soil_type,
  y = df$vi_mean,
  xlab = "encoded variable",
  ylab = "response"
)


#rnorm
#-----

#without sd multiplier
df &lt;- target_encoding_rnorm(
  df = vi,
  response = "vi_mean",
  predictor = "soil_type",
  replace = TRUE
)

plot(
  x = df$soil_type,
  y = df$vi_mean,
  xlab = "encoded variable",
  ylab = "response"
)

#with sd multiplier
df &lt;- target_encoding_rnorm(
  df = vi,
  response = "vi_mean",
  predictor = "soil_type",
  rnorm_sd_multiplier = 0.1,
  replace = TRUE
)

plot(
  x = df$soil_type,
  y = df$vi_mean,
  xlab = "encoded variable",
  ylab = "response"
)


</code></pre>

<hr>
<h2 id='toy'>One response and four predictors with varying levels of multicollinearity</h2><span id='topic+toy'></span>

<h3>Description</h3>

<p>Data frame with known relationship between responses and predictors useful
to illustrate multicollinearity concepts. Created from <a href="#topic+vi">vi</a> using the code
shown in the example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(toy)
</code></pre>


<h3>Format</h3>

<p>Data frame with 2000 rows and 5 columns.
</p>


<h3>Details</h3>

<p>Columns:
</p>

<ul>
<li> <p><code>y</code>: response variable generated from <code>a * 0.75 + b * 0.25 + noise</code>.
</p>
</li>
<li> <p><code>a</code>: most important predictor of <code>y</code>, uncorrelated with <code>b</code>.
</p>
</li>
<li> <p><code>b</code>: second most important predictor of <code>y</code>, uncorrelated with <code>a</code>.
</p>
</li>
<li> <p><code>c</code>: generated from <code>a + noise</code>.
</p>
</li>
<li> <p><code>d</code>: generated from <code>(a + b)/2 + noise</code>.
</p>
</li></ul>

<p>These are variance inflation factors of the predictors in <code>toy</code>.
variable vif
b       4.062
d       6.804
c       13.263
a       16.161
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(collinear)
library(dplyr)
data(vi)
set.seed(1)
toy &lt;- vi |&gt;
  dplyr::slice_sample(n = 2000) |&gt;
  dplyr::transmute(
    a = soil_clay,
    b = humidity_range
  ) |&gt;
  scale() |&gt;
  as.data.frame() |&gt;
  dplyr::mutate(
    y = a * 0.75 + b * 0.25 + runif(n = dplyr::n(), min = -0.5, max = 0.5),
    c = a + runif(n = dplyr::n(), min = -0.5, max = 0.5),
    d = (a + b) / 2 + runif(n = dplyr::n(), min = -0.5, max = 0.5)
  ) |&gt;
  dplyr::transmute(y, a, b, c, d)

</code></pre>

<hr>
<h2 id='validate_df'>Validate input data frame</h2><span id='topic+validate_df'></span>

<h3>Description</h3>

<p>Internal function to validate and prepare the input data frame for a multicollinearity analysis.
</p>
<p>Validates a data frame to ensure it complies with the requirements of the package functions. The function performs the following actions:
</p>

<ul>
<li><p> Stops if 'df' is NULL.
</p>
</li>
<li><p> Stops if 'df' cannot be coerced to data frame.
</p>
</li>
<li><p> Stops if 'df' has zero rows.
</p>
</li>
<li><p> Removes geometry column if the input data frame is an &quot;sf&quot; object.
</p>
</li>
<li><p> Removes non-numeric columns with as many unique values as rows df has.
</p>
</li>
<li><p> Raise warning if number of rows of 'df' is lower than 'min_rows'.
</p>
</li>
<li><p> Converts logical columns to numeric.
</p>
</li>
<li><p> Converts factor and ordered columns to character.
</p>
</li>
<li><p> Tags the data frame with the attribute <code>validated = TRUE</code> to let the package functions skip the data validation.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>validate_df(df = NULL, min_rows = 30)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_df_+3A_df">df</code></td>
<td>
<p>(required; data frame or matrix) Input data frame. Default: NULL</p>
</td></tr>
<tr><td><code id="validate_df_+3A_min_rows">min_rows</code></td>
<td>
<p>(required; integer) Minimum number of rows required for a pairwise correlation or a variance inflation factor analysis. Default: 30</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input data frame modified to comply with the requirements of the functions in this package
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vi)

#validating example data frame
vi &lt;- validate_df(
  df = vi
)

#tagged as validated
attributes(vi)$validated

</code></pre>

<hr>
<h2 id='validate_predictors'>Validate the 'predictors' argument for analysis</h2><span id='topic+validate_predictors'></span>

<h3>Description</h3>

<p>Requires the argument 'df' to be validated with <code><a href="#topic+validate_df">validate_df()</a></code>.
</p>
<p>Validates the 'predictors' argument to ensure it complies with the requirements of the package functions. It performs the following actions:
</p>

<ul>
<li><p> Stops if 'df' is NULL.
</p>
</li>
<li><p> Stops if 'df' is not validated.
</p>
</li>
<li><p> If 'predictors' is NULL, uses column names of 'df' as 'predictors' in the 'df' data frame.
</p>
</li>
<li><p> Raise a warning if there are names in 'predictors' not in the column names of 'df', and returns only the ones in 'df'.
</p>
</li>
<li><p> Stop if the number of numeric columns in 'predictors' is smaller than 'min_numerics'.
</p>
</li>
<li><p> Raise a warning if there are zero-variance columns in 'predictors' and returns a new 'predictors' argument without them.
</p>
</li>
<li><p> Tags the vector with the attribute <code>validated = TRUE</code> to let the package functions skip the data validation.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>validate_predictors(
  df = NULL,
  response = NULL,
  predictors = NULL,
  min_numerics = 0,
  decimals = 4
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_predictors_+3A_df">df</code></td>
<td>
<p>(required; data frame) A validated data frame with numeric and/or character predictors, and optionally, a response variable. Default: NULL.</p>
</td></tr>
<tr><td><code id="validate_predictors_+3A_response">response</code></td>
<td>
<p>(optional, character string) Name of a numeric response variable. Used to remove the response from the predictors when predictors is NULL. Character response variables are ignored. Default: NULL.</p>
</td></tr>
<tr><td><code id="validate_predictors_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) character vector with predictor names in 'df'. If omitted, all columns of 'df' are used as predictors. Default:NULL</p>
</td></tr>
<tr><td><code id="validate_predictors_+3A_min_numerics">min_numerics</code></td>
<td>
<p>(required, integer) Minimum number of numeric predictors required. Default: 1</p>
</td></tr>
<tr><td><code id="validate_predictors_+3A_decimals">decimals</code></td>
<td>
<p>(required, integer) Number of decimal places for the zero variance test. Smaller numbers will increase the number of variables detected as near-zero variance. Recommended values will depend on the range of the numeric variables in 'df'. Default: 4</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of validated predictor names
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi,
  vi_predictors
  )

#validating example data frame
vi &lt;- validate_df(
  df = vi
)

#validating example predictors
vi_predictors &lt;- validate_predictors(
  df = vi,
  predictors = vi_predictors
)

#tagged as validated
attributes(vi_predictors)$validated

</code></pre>

<hr>
<h2 id='validate_response'>Validate the 'response' argument for target encoding of non-numeric variables</h2><span id='topic+validate_response'></span>

<h3>Description</h3>

<p>Requires the argument 'df' to be validated with <code><a href="#topic+validate_df">validate_df()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_response(df = NULL, response = NULL, decimals = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_response_+3A_df">df</code></td>
<td>
<p>(required; data frame) A validated data frame with numeric and/or character predictors predictors, and optionally, a response variable. Default: NULL.</p>
</td></tr>
<tr><td><code id="validate_response_+3A_response">response</code></td>
<td>
<p>(optional, character string) Name of a numeric response variable. Character response variables are ignored. Default: NULL.</p>
</td></tr>
<tr><td><code id="validate_response_+3A_decimals">decimals</code></td>
<td>
<p>(required, integer) number of decimal places for the zero variance test. Default: 4</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string with name of the response
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi
)

#validating example data frame
vi &lt;- validate_df(
  df = vi
)

#validating example predictors
response &lt;- validate_response(
  df = vi,
  response = "vi_mean"
)

#tagged as validated
attributes(response)$validated

</code></pre>

<hr>
<h2 id='vi'>30.000 records of responses and predictors all over the world</h2><span id='topic+vi'></span>

<h3>Description</h3>

<p>30.000 records of responses and predictors all over the world
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vi)
</code></pre>


<h3>Format</h3>

<p>Data frame with 30.000 rows and 68 columns.
</p>


<h3>See Also</h3>

<p><a href="#topic+vi_predictors">vi_predictors</a>
</p>

<hr>
<h2 id='vi_predictors'>Predictor names in data frame 'vi'</h2><span id='topic+vi_predictors'></span>

<h3>Description</h3>

<p>Predictor names in data frame 'vi'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vi_predictors)
</code></pre>


<h3>Format</h3>

<p>Character vector with predictor names.
</p>


<h3>See Also</h3>

<p><a href="#topic+vi">vi</a>
</p>

<hr>
<h2 id='vif_df'>Variance Inflation Factor</h2><span id='topic+vif_df'></span>

<h3>Description</h3>

<p>Computes the Variance Inflation Factor of all variables in a training data frame.
</p>
<p>Warning: predictors with perfect correlation might cause errors, please use <code><a href="#topic+cor_select">cor_select()</a></code> to remove perfect correlations first.
</p>
<p>The Variance Inflation Factor for a given variable <code>y</code> is computed as <code>1/(1-R2)</code>, where <code>R2</code> is the multiple R-squared of a multiple regression model fitted using <code>y</code> as response and all the remaining variables of the input data set as predictors. The equation can be interpreted as &quot;the rate of perfect model's R-squared to the unexplained variance of this model&quot;.
</p>
<p>The possible range of VIF values is (1, Inf]. A VIF lower than 10 suggest that removing <code>y</code> from the data set would reduce overall multicollinearity.
</p>
<p>This function computes the Variance Inflation Factor (VIF) in two steps:
</p>

<ul>
<li><p> Applies <code style="white-space: pre;">&#8288;\link[base]{solve}&#8288;</code> to obtain the precision matrix, which is the inverse of the covariance matrix.
</p>
</li>
<li><p> Uses <code style="white-space: pre;">&#8288;\link[base]{diag}&#8288;</code> to extract the diagonal of the precision matrix, which contains the variance of the prediction of each predictor from all other predictors.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>vif_df(df = NULL, response = NULL, predictors = NULL, encoding_method = "mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vif_df_+3A_df">df</code></td>
<td>
<p>(required; data frame) A data frame with numeric and/or character predictors predictors, and optionally, a response variable. Default: NULL.</p>
</td></tr>
<tr><td><code id="vif_df_+3A_response">response</code></td>
<td>
<p>(recommended, character string) Name of a numeric response variable. Character response variables are ignored. Please, see 'Details' to better understand how providing this argument or not leads to different results when there are character variables in 'predictors'. Default: NULL.</p>
</td></tr>
<tr><td><code id="vif_df_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) character vector with predictor names in 'df'. If omitted, all columns of 'df' are used as predictors. Default:'NULL'</p>
</td></tr>
<tr><td><code id="vif_df_+3A_encoding_method">encoding_method</code></td>
<td>
<p>(optional; character string). Name of the target encoding method to convert character and factor predictors to numeric. One of &quot;mean&quot;, &quot;rank&quot;, &quot;loo&quot;, &quot;rnorm&quot; (see <code><a href="#topic+target_encoding_lab">target_encoding_lab()</a></code> for further details). Default: &quot;mean&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with predictor names and VIF values
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito
</p>

<ul>
<li><p> David A. Belsley, D.A., Kuh, E., Welsch, R.E. (1980). Regression Diagnostics: Identifying Influential Data and Sources of Collinearity. John Wiley &amp; Sons. <a href="https://doi.org/10.1002/0471725153">doi:10.1002/0471725153</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi,
  vi_predictors
)

#subset to limit example run time
vi &lt;- vi[1:1000, ]

#reduce correlation in predictors with cor_select()
vi_predictors &lt;- cor_select(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  max_cor = 0.75
)

#without response
#only numeric predictors are returned
df &lt;- vif_df(
  df = vi,
  predictors = vi_predictors
)

df

#with response
#categorical and numeric predictors are returned
df &lt;- vif_df(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors
)

df

</code></pre>

<hr>
<h2 id='vif_select'>Automated multicollinearity reduction via Variance Inflation Factor</h2><span id='topic+vif_select'></span>

<h3>Description</h3>

<p>Automates multicollinearity management by selecting variables based on their Variance Inflation Factor (VIF).
</p>
<p>Warning: predictors with perfect correlation might cause errors, please use <code><a href="#topic+cor_select">cor_select()</a></code> to remove perfect correlations first.
</p>
<p>The <code><a href="#topic+vif_select">vif_select()</a></code> function is designed to automate the reduction of multicollinearity in a set of predictors by using Variance Inflation Factors.
</p>
<p>If the 'response' argument is provided, categorical predictors are converted to numeric via target encoding (see <code><a href="#topic+target_encoding_lab">target_encoding_lab()</a></code>). If the 'response' argument is not provided, categorical variables are ignored.
</p>
<p>The Variance Inflation Factor for a given variable <code>y</code> is computed as <code>1/(1-R2)</code>, where <code>R2</code> is the multiple R-squared of a multiple regression model fitted using <code>y</code> as response and all other predictors in the input data frame as predictors. The VIF equation can be interpreted as the &quot;rate of perfect model's R-squared to the unexplained variance of this model&quot;.
</p>
<p>The possible range of VIF values is (1, Inf]. A VIF lower than 10 suggest that removing <code>y</code> from the data set would reduce overall multicollinearity. The recommended thresholds for maximum VIF may vary depending on the source consulted, being the most common values, 2.5, 5, and 10.
</p>
<p>The function <code><a href="#topic+vif_select">vif_select()</a></code> applies a recursive algorithm to remove variables with a VIF higher than a given threshold (defined by the argument <code>max_vif</code>).
</p>
<p>If the argument <code>response</code> is provided, all non-numeric variables in <code>predictors</code> are transformed into numeric using target encoding (see <code><a href="#topic+target_encoding_lab">target_encoding_lab()</a></code>). Otherwise, non-numeric variables are ignored.
</p>
<p>The argument <code>preference_order</code> allows defining a preference selection order to preserve (when possible) variables that might be interesting or even required for a given analysis.
</p>
<p>For example, if <code>predictors</code> is <code>c("a", "b", "c")</code> and <code>preference_order</code> is <code>c("a", "b")</code>, there are two possibilities:
</p>

<ul>
<li><p> If the VIF of <code>"a"</code> is higher than the VIF of <code>"b"</code>, and both VIF values are above <code>max_vif</code>, then <code>"a"</code> is selected and <code>"b"</code> is removed.
</p>
</li>
<li><p> If their correlation is equal or above <code>max_cor</code>, then <code>"a"</code> is selected, no matter its correlation with <code>"c"</code>,
</p>
</li></ul>

<p>If <code>preference_order</code> is not provided, then the predictors are ranked by their variance inflation factor as computed by <code><a href="#topic+vif_df">vif_df()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vif_select(
  df = NULL,
  response = NULL,
  predictors = NULL,
  preference_order = NULL,
  max_vif = 5,
  encoding_method = "mean"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vif_select_+3A_df">df</code></td>
<td>
<p>(required; data frame) A data frame with numeric and/or character predictors predictors, and optionally, a response variable. Default: NULL.</p>
</td></tr>
<tr><td><code id="vif_select_+3A_response">response</code></td>
<td>
<p>(recommended, character string) Name of a numeric response variable. Character response variables are ignored. Please, see 'Details' to better understand how providing this argument or not leads to different results when there are character variables in 'predictors'. Default: NULL.</p>
</td></tr>
<tr><td><code id="vif_select_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) character vector with predictor names in 'df'. If omitted, all columns of 'df' are used as predictors. Default:'NULL'</p>
</td></tr>
<tr><td><code id="vif_select_+3A_preference_order">preference_order</code></td>
<td>
<p>(optional; character vector) vector with column names in 'predictors' in the desired preference order, or result of the function <code><a href="#topic+preference_order">preference_order()</a></code>. Allows defining a priority order for selecting predictors, which can be particularly useful when some predictors are more critical for the analysis than others. Predictors not included in this argument are ranked by their Variance Inflation Factor. Default: NULL.</p>
</td></tr>
<tr><td><code id="vif_select_+3A_max_vif">max_vif</code></td>
<td>
<p>(optional, numeric) Numeric with recommended values between 2.5 and 10 defining the maximum VIF allowed for any given predictor in the output dataset. Higher VIF thresholds should result in a higher number of selected variables. Default: 5.</p>
</td></tr>
<tr><td><code id="vif_select_+3A_encoding_method">encoding_method</code></td>
<td>
<p>(optional; character string). Name of the target encoding method to convert character and factor predictors to numeric. One of &quot;mean&quot;, &quot;rank&quot;, &quot;loo&quot;, &quot;rnorm&quot; (see <code><a href="#topic+target_encoding_lab">target_encoding_lab()</a></code> for further details). Default: &quot;mean&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector with the names of the selected predictors.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito
</p>

<ul>
<li><p> David A. Belsley, D.A., Kuh, E., Welsch, R.E. (1980). Regression Diagnostics: Identifying Influential Data and Sources of Collinearity. John Wiley &amp; Sons. <a href="https://doi.org/10.1002/0471725153">doi:10.1002/0471725153</a>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi,
  vi_predictors
)

#subset to limit example run time
vi &lt;- vi[1:1000, ]
vi_predictors &lt;- vi_predictors[1:10]

#reduce correlation in predictors with cor_select()
vi_predictors &lt;- cor_select(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  max_cor = 0.75
)

#without response
#without preference_order
#permissive max_vif
#only numeric predictors are processed
selected.predictors &lt;- vif_select(
  df = vi,
  predictors = vi_predictors,
  max_vif = 10
)

selected.predictors

#without response
#without preference_order
#restrictive max_vif
#only numeric predictors are processed
selected.predictors &lt;- vif_select(
  df = vi,
  predictors = vi_predictors,
  max_vif = 2.5
)

selected.predictors

#with response
#without preference_order
#restrictive max_cor
#slightly different solution than previous one
#because categorical variables are target-enccoded
selected.predictors &lt;- vif_select(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  max_vif = 2.5
)

selected.predictors

#with response
#with user-defined preference_order
#restrictive max_cor
#numerics and categorical variables in output
selected.predictors &lt;- vif_select(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  preference_order = c(
    "soil_type", #categorical variable
    "soil_temperature_mean",
    "swi_mean",
    "rainfall_mean",
    "evapotranspiration_mean"
  ),
  max_vif = 2.5
)

selected.predictors


#with response
#with automated preference_order
#restrictive max_cor and max_vif
#numerics and categorical variables in output
preference.order &lt;- preference_order(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  f = f_rsquared #cor(response, predictor)
)

head(preference.order)

selected.predictors &lt;- vif_select(
  df = vi,
  response = "vi_mean",
  predictors = vi_predictors,
  preference_order = preference.order,
  max_vif = 2.5
)

selected.predictors

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
