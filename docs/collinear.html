<!DOCTYPE html><html lang="en-US"><head><title>Help for package collinear</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {collinear}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#collinear-package'><p>collinear</p></a></li>
<li><a href='#add_white_noise'><p>Add White Noise to Encoded Predictor</p></a></li>
<li><a href='#case_weights'><p>Case Weights for Unbalanced Binomial or Categorical Responses</p></a></li>
<li><a href='#collinear'><p>Automated multicollinearity management</p></a></li>
<li><a href='#cor_clusters'><p>Hierarchical Clustering from a Pairwise Correlation Matrix</p></a></li>
<li><a href='#cor_cramer_v'><p>Bias Corrected Cramer's V</p></a></li>
<li><a href='#cor_df'><p>Pairwise Correlation Data Frame</p></a></li>
<li><a href='#cor_matrix'><p>Pairwise Correlation Matrix</p></a></li>
<li><a href='#cor_select'><p>Automated Multicollinearity Filtering with Pairwise Correlations</p></a></li>
<li><a href='#drop_geometry_column'><p>Removes geometry column in sf data frames</p></a></li>
<li><a href='#encoded_predictor_name'><p>Name of Target-Encoded Predictor</p></a></li>
<li><a href='#f_auc'><p>Association Between a Binomial Response and a Continuous Predictor</p></a></li>
<li><a href='#f_auto'><p>Select Function to Compute Preference Order</p></a></li>
<li><a href='#f_auto_rules'><p>Rules to Select Default f Argument to Compute Preference Order</p></a></li>
<li><a href='#f_functions'><p>Data Frame of Preference Functions</p></a></li>
<li><a href='#f_r2'><p>Association Between a Continuous Response and a Continuous Predictor</p></a></li>
<li><a href='#f_r2_counts'><p>Association Between a Count Response and a Continuous Predictor</p></a></li>
<li><a href='#f_v'><p>Association Between a Categorical Response and a Categorical Predictor</p></a></li>
<li><a href='#f_v_rf_categorical'><p>Association Between a Categorical Response and a Categorical or Numeric Predictor</p></a></li>
<li><a href='#identify_predictors'><p>Identify Numeric and Categorical Predictors</p></a></li>
<li><a href='#identify_predictors_categorical'><p>Identify Valid Categorical Predictors</p></a></li>
<li><a href='#identify_predictors_numeric'><p>Identify Valid Numeric Predictors</p></a></li>
<li><a href='#identify_predictors_type'><p>Identify Predictor Types</p></a></li>
<li><a href='#identify_predictors_zero_variance'><p>Identify Zero and Near-Zero Variance Predictors</p></a></li>
<li><a href='#identify_response_type'><p>Identify Response Type</p></a></li>
<li><a href='#model_formula'><p>Generate Model Formulas</p></a></li>
<li><a href='#performance_score_auc'><p>Area Under the Curve of Binomial Observations vs Probabilistic Model Predictions</p></a></li>
<li><a href='#performance_score_r2'><p>Pearson's R-squared of Observations vs Predictions</p></a></li>
<li><a href='#performance_score_v'><p>Cramer's V of Observations vs Predictions</p></a></li>
<li><a href='#preference_order'><p>Quantitative Variable Prioritization for Multicollinearity Filtering</p></a></li>
<li><a href='#preference_order_collinear'><p>Preference Order Argument in collinear()</p></a></li>
<li><a href='#target_encoding_lab'><p>Target Encoding Lab: Transform Categorical Variables to Numeric</p></a></li>
<li><a href='#target_encoding_mean'><p>Target Encoding Methods</p></a></li>
<li><a href='#toy'><p>One response and four predictors with varying levels of multicollinearity</p></a></li>
<li><a href='#validate_data_cor'><p>Validate Data for Correlation Analysis</p></a></li>
<li><a href='#validate_data_vif'><p>Validate Data for VIF Analysis</p></a></li>
<li><a href='#validate_df'><p>Validate Argument df</p></a></li>
<li><a href='#validate_encoding_arguments'><p>Validates Arguments of <code>target_encoding_lab()</code></p></a></li>
<li><a href='#validate_predictors'><p>Validate Argument predictors</p></a></li>
<li><a href='#validate_preference_order'><p>Validate Argument preference_order</p></a></li>
<li><a href='#validate_response'><p>Validate Argument response</p></a></li>
<li><a href='#vi'><p>Example Data With Different Response and Predictor Types</p></a></li>
<li><a href='#vi_predictors'><p>All Predictor Names in Example Data Frame vi</p></a></li>
<li><a href='#vi_predictors_categorical'><p>All Categorical and Factor Predictor Names in Example Data Frame vi</p></a></li>
<li><a href='#vi_predictors_numeric'><p>All Numeric Predictor Names in Example Data Frame vi</p></a></li>
<li><a href='#vif_df'><p>Variance Inflation Factor</p></a></li>
<li><a href='#vif_select'><p>Automated Multicollinearity Filtering with Variance Inflation Factors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Automated Multicollinearity Management</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://blasbenito.github.io/collinear/">https://blasbenito.github.io/collinear/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/blasbenito/collinear/issues">https://github.com/blasbenito/collinear/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Effortless multicollinearity management in data frames with both numeric and categorical variables for statistical and machine learning applications. The package simplifies multicollinearity analysis by combining four robust methods: 1) target encoding for categorical variables (Micci-Barreca, D. 2001 &lt;<a href="https://doi.org/10.1145%2F507533.507538">doi:10.1145/507533.507538</a>&gt;); 2) automated feature prioritization to prevent key variable loss during filtering; 3) pairwise correlation for all variable combinations (numeric-numeric, numeric-categorical, categorical-categorical); and 4) fast computation of variance inflation factors.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>progressr, future.apply, mgcv, rpart, ranger</td>
</tr>
<tr>
<td>Suggests:</td>
<td>future, testthat (&ge; 3.0.0), spelling</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-08 13:37:40 UTC; blas</td>
</tr>
<tr>
<td>Author:</td>
<td>Blas M. Benito <a href="https://orcid.org/0000-0001-5105-7232"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Blas M. Benito &lt;blasbenito@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-08 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='collinear-package'>collinear</h2><span id='topic+collinear-package'></span>

<h3>Description</h3>

<p>Package for multicollinearity management in data frames with numeric and categorical variables.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Blas M. Benito <a href="mailto:blasbenito@gmail.com">blasbenito@gmail.com</a> (<a href="https://orcid.org/0000-0001-5105-7232">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://blasbenito.github.io/collinear/">https://blasbenito.github.io/collinear/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/blasbenito/collinear/issues">https://github.com/blasbenito/collinear/issues</a>
</p>
</li></ul>


<hr>
<h2 id='add_white_noise'>Add White Noise to Encoded Predictor</h2><span id='topic+add_white_noise'></span>

<h3>Description</h3>

<p>Internal function to add white noise to a encoded predictor to reduce the risk of overfitting when used in a model along with the response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_white_noise(
  df = NULL,
  response = NULL,
  predictor = NULL,
  white_noise = 0,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_white_noise_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="add_white_noise_+3A_response">response</code></td>
<td>
<p>(optional, character string) Name of a numeric response variable in <code>df</code>. Default: NULL.</p>
</td></tr>
<tr><td><code id="add_white_noise_+3A_predictor">predictor</code></td>
<td>
<p>(required, string) Name of a target-encoded predictor. Default: NULL</p>
</td></tr>
<tr><td><code id="add_white_noise_+3A_white_noise">white_noise</code></td>
<td>
<p>(optional; numeric vector) Argument of the methods &quot;mean&quot;, &quot;rank&quot;, and &quot;loo&quot;. Maximum white noise to add, expressed as a fraction of the range of the response variable. Range from 0 to 1. Default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="add_white_noise_+3A_seed">seed</code></td>
<td>
<p>(optional; integer vector) Random seed to facilitate reproducibility when <code>white_noise</code> is not 0. If NULL, the function selects one at random, and the selected seed does not appear in the encoded variable names. Default: 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other target_encoding_tools: 
<code><a href="#topic+encoded_predictor_name">encoded_predictor_name</a>()</code>
</p>

<hr>
<h2 id='case_weights'>Case Weights for Unbalanced Binomial or Categorical Responses</h2><span id='topic+case_weights'></span>

<h3>Description</h3>

<p>Case Weights for Unbalanced Binomial or Categorical Responses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>case_weights(x = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="case_weights_+3A_x">x</code></td>
<td>
<p>(required, integer, character, or factor vector) binomial, categorical, or factor response variable. Default: <code>NULL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector: case weights
</p>


<h3>See Also</h3>

<p>Other modelling_tools: 
<code><a href="#topic+model_formula">model_formula</a>()</code>,
<code><a href="#topic+performance_score_auc">performance_score_auc</a>()</code>,
<code><a href="#topic+performance_score_r2">performance_score_r2</a>()</code>,
<code><a href="#topic+performance_score_v">performance_score_v</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> case_weights(
   x = c(0, 0, 0, 1, 1)
   )

 case_weights(
   x = c("a", "a", "b", "b", "c")
   )
</code></pre>

<hr>
<h2 id='collinear'>Automated multicollinearity management</h2><span id='topic+collinear'></span>

<h3>Description</h3>

<p>Automates multicollinearity management in data frames with numeric and non-numeric predictors by combining four methods:
</p>

<ul>
<li> <p><strong>Target Encoding</strong>: When a numeric <code>response</code> is provided and <code>encoding_method</code> is not NULL, it transforms categorical predictors (classes &quot;character&quot; and &quot;factor&quot;) to numeric using the response values as reference. See <code><a href="#topic+target_encoding_lab">target_encoding_lab()</a></code> for further details.
</p>
</li>
<li> <p><strong>Preference Order</strong>: When a response of any type is provided via <code>response</code>, the association between the response and each predictor is computed with an appropriate function (see <code><a href="#topic+preference_order">preference_order()</a></code> and <code><a href="#topic+f_auto">f_auto()</a></code>), and all predictors are ranked from higher to lower association. This rank is used to preserve important predictors during the multicollinearity filtering.
</p>
</li>
<li> <p><strong>Pairwise Correlation Filtering</strong>: Automated multicollinearity filtering via pairwise correlation. Correlations between numeric and categoricals  predictors are computed by target-encoding the categorical against the predictor, and correlations between categoricals are computed via Cramer's V. See <code><a href="#topic+cor_select">cor_select()</a></code>, <code><a href="#topic+cor_df">cor_df()</a></code>, and <code><a href="#topic+cor_cramer_v">cor_cramer_v()</a></code> for further details.
</p>
</li>
<li> <p><strong>VIF filtering</strong>: Automated algorithm to identify and remove numeric predictors that are linear combinations of other predictors. See <code><a href="#topic+vif_select">vif_select()</a></code> and <code><a href="#topic+vif_df">vif_df()</a></code>.
</p>
</li></ul>

<p>Accepts a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code> and a progress bar via <code><a href="progressr.html#topic+handlers">progressr::handlers()</a></code> (see examples).
</p>
<p>Accepts a character vector of response variables as input for the argument <code>response</code>. When more than one response is provided, the output is a named list of character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collinear(
  df = NULL,
  response = NULL,
  predictors = NULL,
  encoding_method = "loo",
  preference_order = "auto",
  f = "auto",
  max_cor = 0.75,
  max_vif = 5,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="collinear_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="collinear_+3A_response">response</code></td>
<td>
<p>(optional; character string or vector) Name/s of response variable/s in <code>df</code>. Used in target encoding when it names a numeric variable and there are categorical predictors, and to compute preference order. Default: NULL.</p>
</td></tr>
<tr><td><code id="collinear_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
<tr><td><code id="collinear_+3A_encoding_method">encoding_method</code></td>
<td>
<p>(optional; character string). Name of the target encoding method. One of: &quot;loo&quot;, &quot;mean&quot;, or &quot;rank&quot;. If NULL, target encoding is disabled. Default: &quot;loo&quot;</p>
</td></tr>
<tr><td><code id="collinear_+3A_preference_order">preference_order</code></td>
<td>
<p>(optional; string, character vector, output of <code><a href="#topic+preference_order">preference_order()</a></code>). Defines a priority order, from first to last, to preserve predictors during the selection process. Accepted inputs are:
</p>

<ul>
<li> <p><strong>&quot;auto&quot;</strong> (default): if <code>response</code> is not NULL, calls <code><a href="#topic+preference_order">preference_order()</a></code> for internal computation.
</p>
</li>
<li> <p><strong>character vector</strong>: predictor names in a custom preference order.
</p>
</li>
<li> <p><strong>data frame</strong>: output of <code><a href="#topic+preference_order">preference_order()</a></code> from <code>response</code> of length one.
</p>
</li>
<li> <p><strong>named list</strong>: output of <code><a href="#topic+preference_order">preference_order()</a></code> from <code>response</code> of length two or more.
</p>
</li>
<li> <p><strong>NULL</strong>: disabled.
</p>
</li></ul>
<p>. Default: &quot;auto&quot;</p>
</td></tr>
<tr><td><code id="collinear_+3A_f">f</code></td>
<td>
<p>(optional: function) Function to compute preference order. If &quot;auto&quot; (default) or NULL, the output of <code><a href="#topic+f_auto">f_auto()</a></code> for the given data is used:
</p>

<ul>
<li> <p><code><a href="#topic+f_auc_rf">f_auc_rf()</a></code>: if <code>response</code> is binomial.
</p>
</li>
<li> <p><code><a href="#topic+f_r2_pearson">f_r2_pearson()</a></code>: if <code>response</code> and <code>predictors</code> are numeric.
</p>
</li>
<li> <p><code><a href="#topic+f_v">f_v()</a></code>: if <code>response</code> and <code>predictors</code> are categorical.
</p>
</li>
<li> <p><code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical()</a></code>: if <code>response</code> is categorical and <code>predictors</code> are numeric or mixed .
</p>
</li>
<li> <p><code><a href="#topic+f_r2_rf">f_r2_rf()</a></code>: in all other cases.
</p>
</li></ul>

<p>Default: NULL</p>
</td></tr>
<tr><td><code id="collinear_+3A_max_cor">max_cor</code></td>
<td>
<p>(optional; numeric) Maximum correlation allowed between any pair of variables in <code>predictors</code>. Recommended values are between 0.5 and 0.9. Higher values return larger number of predictors with a higher multicollinearity. If NULL, the pairwise correlation analysis is disabled. Default: <code>0.75</code></p>
</td></tr>
<tr><td><code id="collinear_+3A_max_vif">max_vif</code></td>
<td>
<p>(optional, numeric) Maximum Variance Inflation Factor allowed during variable selection. Recommended values are between 2.5 and 10. Higher values return larger number of predictors with a higher multicollinearity. If NULL, the variance inflation analysis is disabled. Default: 5.</p>
</td></tr>
<tr><td><code id="collinear_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> character vector if <code>response</code> is NULL or is a string.
</p>
</li>
<li><p> named list if <code>response</code> is a character vector.
</p>
</li></ul>



<h3>Target Encoding</h3>

<p>When the argument <code>response</code> names a <strong>numeric response variable</strong>, categorical predictors in <code>predictors</code> (or in the columns of <code>df</code> if <code>predictors</code> is NULL) are converted to numeric via <strong>target encoding</strong> with the function <code><a href="#topic+target_encoding_lab">target_encoding_lab()</a></code>. When <code>response</code> is NULL or names a categorical variable, target-encoding is skipped. This feature facilitates multicollinearity filtering in data frames with mixed column types.
</p>


<h3>Preference Order</h3>

<p>This feature is designed to help protect important predictors during the multicollinearity filtering. It involves the arguments <code>preference_order</code> and <code>f</code>.
</p>
<p>The argument <code>preference_order</code> accepts:
</p>

<ul>
<li><p>: A character vector of predictor names in a custom order of preference, from first to last. This vector does not need to contain all predictor names, but only the ones relevant to the user.
</p>
</li>
<li><p> A data frame returned by <code><a href="#topic+preference_order">preference_order()</a></code>, which ranks predictors based on their association with a response variable.
</p>
</li>
<li><p> If NULL, and <code>response</code> is provided, then <code><a href="#topic+preference_order">preference_order()</a></code> is used internally to rank the predictors using the function <code>f</code>. If <code>f</code> is NULL as well, then <code><a href="#topic+f_auto">f_auto()</a></code> selects a proper function based on the data properties.
</p>
</li></ul>



<h3>Variance Inflation Factors</h3>

<p>The Variance Inflation Factor for a given variable <code class="reqn">a</code> is computed as <code class="reqn">1/(1-R2)</code>, where <code class="reqn">R2</code> is the multiple R-squared of a multiple regression model fitted using <code class="reqn">a</code> as response and all other predictors in the input data frame as predictors, as in  <code class="reqn">a = b + c + ...</code>.
</p>
<p>The square root of the VIF of <code class="reqn">a</code> is the factor by which the confidence interval of the estimate for <code class="reqn">a</code> in the linear model <code class="reqn">y = a + b + c + ...</code>' is widened by multicollinearity in the model predictors.
</p>
<p>The range of VIF values is (1, Inf]. The recommended thresholds for maximum VIF may vary depending on the source consulted, being the most common values, 2.5, 5, and 10.
</p>


<h3>VIF-based Filtering</h3>

<p>The function <code><a href="#topic+vif_select">vif_select()</a></code> computes Variance Inflation Factors and removes variables iteratively, until all variables in the resulting selection have a VIF below <code>max_vif</code>.
</p>
<p>If the argument <code>preference_order</code> is not provided, all variables are ranked from lower to higher VIF, as returned by <code><a href="#topic+vif_df">vif_df()</a></code>, and the variable with the higher VIF above <code>max_vif</code> is removed on each iteration.
</p>
<p>If <code>preference_order</code> is defined, whenever two or more variables are above <code>max_vif</code>, the one higher in <code>preference_order</code> is preserved, and the next one with a higher VIF is removed. For example, for the predictors and preference order <code class="reqn">a</code> and <code class="reqn">b</code>, if any of their VIFs is higher than <code>max_vif</code>, then <code class="reqn">b</code> will be removed no matter whether its VIF is lower or higher than <code class="reqn">a</code>'s VIF. If their VIF scores are lower than <code>max_vif</code>, then both are preserved.
</p>


<h3>Pairwise Correlation Filtering</h3>

<p>The function <code><a href="#topic+cor_select">cor_select()</a></code> applies a recursive forward selection algorithm to keep predictors with a maximum Pearson correlation with all other selected predictors lower than <code>max_cor</code>.
</p>
<p>If the argument <code>preference_order</code> is NULL, the predictors are ranked from lower to higher sum of absolute pairwise correlation with all other predictors.
</p>
<p>If <code>preference_order</code> is defined, whenever two or more variables are above <code>max_cor</code>, the one higher in <code>preference_order</code> is preserved. For example, for the predictors and preference order <code class="reqn">a</code> and <code class="reqn">b</code>, if their correlation is higher than <code>max_cor</code>, then <code class="reqn">b</code> will be removed and <code class="reqn">a</code> preserved. If their correlation is lower than <code>max_cor</code>, then both are preserved.
</p>


<h3>References</h3>


<ul>
<li><p> David A. Belsley, D.A., Kuh, E., Welsch, R.E. (1980). Regression Diagnostics: Identifying Influential Data and Sources of Collinearity. John Wiley &amp; Sons. DOI: 10.1002/0471725153.
</p>
</li>
<li><p> Micci-Barreca, D. (2001) A Preprocessing Scheme for High-Cardinality Categorical Attributes in Classification and Prediction Problems. SIGKDD Explor. Newsl. 3, 1, 27-32. DOI: 10.1145/507533.507538
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>#parallelization setup
future::plan(
  future::multisession,
  workers = 2 #set to parallelly::availableCores() - 1
)

#progress bar
#progressr::handlers(global = TRUE)

#subset to limit example run time
df &lt;- vi[1:500, ]

#predictors has mixed types
#small subset to speed example up
predictors &lt;- c(
  "swi_mean",
  "soil_type",
  "soil_temperature_mean",
  "growing_season_length",
  "rainfall_mean"
  )


#with numeric responses
#--------------------------------
#  target encoding
#  automated preference order
#  all predictors filtered by correlation and VIF
x &lt;- collinear(
  df = df,
  response = c(
    "vi_numeric",
    "vi_binomial"
    ),
  predictors = predictors
)

x


#with custom preference order
#--------------------------------
x &lt;- collinear(
  df = df,
  response = "vi_numeric",
  predictors = predictors,
  preference_order = c(
    "swi_mean",
    "soil_type"
  )
)


#pre-computed preference order
#--------------------------------
preference_df &lt;- preference_order(
  df = df,
  response = "vi_numeric",
  predictors = predictors
)

x &lt;- collinear(
  df = df,
  response = "vi_numeric",
  predictors = predictors,
  preference_order = preference_df
)

#resetting to sequential processing
future::plan(future::sequential)

</code></pre>

<hr>
<h2 id='cor_clusters'>Hierarchical Clustering from a Pairwise Correlation Matrix</h2><span id='topic+cor_clusters'></span>

<h3>Description</h3>

<p>Hierarchical clustering of predictors from their pairwise correlation matrix. Computes the correlation matrix with <code><a href="#topic+cor_df">cor_df()</a></code> and <code><a href="#topic+cor_matrix">cor_matrix()</a></code>, transforms it to a dist object, computes a clustering solution with <code><a href="stats.html#topic+hclust">stats::hclust()</a></code>, and applies <code><a href="stats.html#topic+cutree">stats::cutree()</a></code> to separate groups based on the value of the argument <code>max_cor</code>.
</p>
<p>Returns a data frame with predictor names and their clusters, and optionally, prints a dendrogram of the clustering solution.
</p>
<p>Accepts a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code> and a progress bar via <code><a href="progressr.html#topic+handlers">progressr::handlers()</a></code> (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_clusters(
  df = NULL,
  predictors = NULL,
  max_cor = 0.75,
  method = "complete",
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_clusters_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="cor_clusters_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
<tr><td><code id="cor_clusters_+3A_max_cor">max_cor</code></td>
<td>
<p>(optional; numeric) Maximum correlation allowed between any pair of variables in <code>predictors</code>. Recommended values are between 0.5 and 0.9. Higher values return larger number of predictors with a higher multicollinearity. If NULL, the pairwise correlation analysis is disabled. Default: <code>0.75</code></p>
</td></tr>
<tr><td><code id="cor_clusters_+3A_method">method</code></td>
<td>
<p>(optional, character string) Argument of <code><a href="stats.html#topic+hclust">stats::hclust()</a></code> defining the agglomerative method. One of: &quot;ward.D&quot;, &quot;ward.D2&quot;, &quot;single&quot;, &quot;complete&quot;, &quot;average&quot; (= UPGMA), &quot;mcquitty&quot; (= WPGMA), &quot;median&quot; (= WPGMC) or &quot;centroid&quot; (= UPGMC). Unambiguous abbreviations are accepted as well. Default: &quot;complete&quot;.</p>
</td></tr>
<tr><td><code id="cor_clusters_+3A_plot">plot</code></td>
<td>
<p>(optional, logical) If TRUE, the clustering is plotted. Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame: predictor names and their clusters
</p>


<h3>See Also</h3>

<p>Other pairwise_correlation: 
<code><a href="#topic+cor_cramer_v">cor_cramer_v</a>()</code>,
<code><a href="#topic+cor_df">cor_df</a>()</code>,
<code><a href="#topic+cor_matrix">cor_matrix</a>()</code>,
<code><a href="#topic+cor_select">cor_select</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#parallelization setup
future::plan(
  future::multisession,
  workers = 2 #set to parallelly::availableCores() - 1
)

#progress bar
# progressr::handlers(global = TRUE)

df_clusters &lt;- cor_clusters(
  df = vi[1:1000, ],
  predictors = vi_predictors[1:15]
)

#disable parallelization
future::plan(future::sequential)

</code></pre>

<hr>
<h2 id='cor_cramer_v'>Bias Corrected Cramer's V</h2><span id='topic+cor_cramer_v'></span>

<h3>Description</h3>

<p>Computes bias-corrected Cramer's V (extension of the chi-squared test), a measure of association between two categorical variables. Results are in the range 0-1, where 0 indicates no association, and 1 indicates a perfect association.
</p>
<p>In essence, Cramer's V assesses the co-occurrence of the categories of two variables to quantify how strongly these variables are related.
</p>
<p>Even when its range is between 0 and 1, Cramer's V values are not directly comparable to R-squared values, and as such, a multicollinearity analysis containing both types of values must be assessed with care. It is probably preferable to convert non-numeric variables to numeric using target encoding rather before a multicollinearity analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_cramer_v(x = NULL, y = NULL, check_input = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_cramer_v_+3A_x">x</code></td>
<td>
<p>(required; character vector) character vector representing a categorical variable.  Default: NULL</p>
</td></tr>
<tr><td><code id="cor_cramer_v_+3A_y">y</code></td>
<td>
<p>(required; character vector) character vector representing a categorical variable. Must have the same length as 'x'. Default: NULL</p>
</td></tr>
<tr><td><code id="cor_cramer_v_+3A_check_input">check_input</code></td>
<td>
<p>(required; logical) If FALSE, disables data checking for a slightly faster execution. Default: TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric: Cramer's V
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito, PhD
</p>


<h3>References</h3>


<ul>
<li><p> Cram√©r, H. (1946). Mathematical Methods of Statistics. Princeton: Princeton University Press, page 282 (Chapter 21. The two-dimensional case). ISBN 0-691-08004-6
</p>
</li></ul>



<h3>See Also</h3>

<p>Other pairwise_correlation: 
<code><a href="#topic+cor_clusters">cor_clusters</a>()</code>,
<code><a href="#topic+cor_df">cor_df</a>()</code>,
<code><a href="#topic+cor_matrix">cor_matrix</a>()</code>,
<code><a href="#topic+cor_select">cor_select</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#loading example data
data(vi)

#subset to limit example run time
vi &lt;- vi[1:1000, ]

#computing Cramer's V for two categorical predictors
v &lt;- cor_cramer_v(
  x = vi$soil_type,
  y = vi$koppen_zone
  )

v

</code></pre>

<hr>
<h2 id='cor_df'>Pairwise Correlation Data Frame</h2><span id='topic+cor_df'></span><span id='topic+cor_numeric_vs_numeric'></span><span id='topic+cor_numeric_vs_categorical'></span><span id='topic+cor_categorical_vs_categorical'></span>

<h3>Description</h3>

<p>Computes a pairwise correlation data frame. Implements methods to compare different types of predictors:
</p>

<ul>
<li> <p><strong>numeric vs. numeric</strong>: as computed with <code><a href="stats.html#topic+cor">stats::cor()</a></code> using the methods &quot;pearson&quot; or &quot;spearman&quot;, via <code><a href="#topic+cor_numeric_vs_numeric">cor_numeric_vs_numeric()</a></code>.
</p>
</li>
<li> <p><strong>numeric vs. categorical</strong>: the function <code><a href="#topic+cor_numeric_vs_categorical">cor_numeric_vs_categorical()</a></code> target-encodes the categorical variable using the numeric variable as reference with <code><a href="#topic+target_encoding_lab">target_encoding_lab()</a></code> and the method &quot;loo&quot; (leave-one-out), and then their correlation is computed with <code><a href="stats.html#topic+cor">stats::cor()</a></code>.
</p>
</li>
<li> <p><strong>categorical vs. categorical</strong>: the function <code><a href="#topic+cor_categorical_vs_categorical">cor_categorical_vs_categorical()</a></code> computes Cramer's V (see <code><a href="#topic+cor_cramer_v">cor_cramer_v()</a></code>) as indicator of the association between character or factor variables. However, take in mind that Cramer's V is not directly comparable with R-squared, even when having the same range from zero to one. It is always recommended to target-encode categorical variables with <code><a href="#topic+target_encoding_lab">target_encoding_lab()</a></code> before the pairwise correlation analysis.
</p>
</li></ul>

<p>Accepts a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code> and a progress bar via <code><a href="progressr.html#topic+handlers">progressr::handlers()</a></code> (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_df(df = NULL, predictors = NULL, quiet = FALSE)

cor_numeric_vs_numeric(df = NULL, predictors = NULL, quiet = FALSE)

cor_numeric_vs_categorical(df = NULL, predictors = NULL, quiet = FALSE)

cor_categorical_vs_categorical(df = NULL, predictors = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_df_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="cor_df_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
<tr><td><code id="cor_df_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame; pairwise correlation
</p>


<h3>See Also</h3>

<p>Other pairwise_correlation: 
<code><a href="#topic+cor_clusters">cor_clusters</a>()</code>,
<code><a href="#topic+cor_cramer_v">cor_cramer_v</a>()</code>,
<code><a href="#topic+cor_matrix">cor_matrix</a>()</code>,
<code><a href="#topic+cor_select">cor_select</a>()</code>
</p>
<p>Other pairwise_correlation: 
<code><a href="#topic+cor_clusters">cor_clusters</a>()</code>,
<code><a href="#topic+cor_cramer_v">cor_cramer_v</a>()</code>,
<code><a href="#topic+cor_matrix">cor_matrix</a>()</code>,
<code><a href="#topic+cor_select">cor_select</a>()</code>
</p>
<p>Other pairwise_correlation: 
<code><a href="#topic+cor_clusters">cor_clusters</a>()</code>,
<code><a href="#topic+cor_cramer_v">cor_cramer_v</a>()</code>,
<code><a href="#topic+cor_matrix">cor_matrix</a>()</code>,
<code><a href="#topic+cor_select">cor_select</a>()</code>
</p>
<p>Other pairwise_correlation: 
<code><a href="#topic+cor_clusters">cor_clusters</a>()</code>,
<code><a href="#topic+cor_cramer_v">cor_cramer_v</a>()</code>,
<code><a href="#topic+cor_matrix">cor_matrix</a>()</code>,
<code><a href="#topic+cor_select">cor_select</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(
  vi,
  vi_predictors
)

#reduce size of vi to speed-up example execution
vi &lt;- vi[1:1000, ]

#mixed predictors
vi_predictors &lt;- vi_predictors[1:10]

#parallelization setup
future::plan(
  future::multisession,
  workers = 2 #set to parallelly::availableCores() - 1
)

#progress bar
# progressr::handlers(global = TRUE)

#correlation data frame
df &lt;- cor_df(
  df = vi,
  predictors = vi_predictors
)

df

#disable parallelization
future::plan(future::sequential)

</code></pre>

<hr>
<h2 id='cor_matrix'>Pairwise Correlation Matrix</h2><span id='topic+cor_matrix'></span>

<h3>Description</h3>

<p>If argument 'df' results from <code><a href="#topic+cor_df">cor_df()</a></code>, transforms it to a correlation matrix. If argument 'df' is a dataframe with predictors, and the argument 'predictors' is provided then <code><a href="#topic+cor_df">cor_df()</a></code> is used to compute pairwise correlations, and the result is transformed to matrix.
</p>
<p>Accepts a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code> and a progress bar via <code><a href="progressr.html#topic+handlers">progressr::handlers()</a></code> (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_matrix(df = NULL, predictors = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_matrix_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="cor_matrix_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>correlation matrix
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito, PhD
</p>


<h3>See Also</h3>

<p>Other pairwise_correlation: 
<code><a href="#topic+cor_clusters">cor_clusters</a>()</code>,
<code><a href="#topic+cor_cramer_v">cor_cramer_v</a>()</code>,
<code><a href="#topic+cor_df">cor_df</a>()</code>,
<code><a href="#topic+cor_select">cor_select</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(
  vi,
  vi_predictors
)

#reduce size of vi to speed-up example execution
vi &lt;- vi[1:1000, ]

#mixed predictors
vi_predictors &lt;- vi_predictors[1:10]

#parallelization setup
future::plan(
  future::multisession,
  workers = 2 #set to parallelly::availableCores() - 1
)

#progress bar
# progressr::handlers(global = TRUE)

#correlation data frame
df &lt;- cor_df(
  df = vi,
  predictors = vi_predictors
)

df

#correlation matrix
m &lt;- cor_matrix(
  df = df
)

m

#generating it from the original data
m &lt;- cor_matrix(
  df = vi,
  predictors = vi_predictors
)

m

#disable parallelization
future::plan(future::sequential)
</code></pre>

<hr>
<h2 id='cor_select'>Automated Multicollinearity Filtering with Pairwise Correlations</h2><span id='topic+cor_select'></span>

<h3>Description</h3>

<p>Implements a recursive forward selection algorithm to keep predictors with a maximum pairwise correlation with all other selected predictors lower than a given threshold. Uses <code><a href="#topic+cor_df">cor_df()</a></code> underneath, and as such, can handle different combinations of predictor types.
</p>
<p>Please check the section <strong>Pairwise Correlation Filtering</strong> at the end of this help file for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor_select(
  df = NULL,
  predictors = NULL,
  preference_order = NULL,
  max_cor = 0.75,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cor_select_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="cor_select_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
<tr><td><code id="cor_select_+3A_preference_order">preference_order</code></td>
<td>
<p>(optional; string, character vector, output of <code><a href="#topic+preference_order">preference_order()</a></code>). Defines a priority order, from first to last, to preserve predictors during the selection process. Accepted inputs are:
</p>

<ul>
<li> <p><strong>&quot;auto&quot;</strong> (default): if <code>response</code> is not NULL, calls <code><a href="#topic+preference_order">preference_order()</a></code> for internal computation.
</p>
</li>
<li> <p><strong>character vector</strong>: predictor names in a custom preference order.
</p>
</li>
<li> <p><strong>data frame</strong>: output of <code><a href="#topic+preference_order">preference_order()</a></code> from <code>response</code> of length one.
</p>
</li>
<li> <p><strong>named list</strong>: output of <code><a href="#topic+preference_order">preference_order()</a></code> from <code>response</code> of length two or more.
</p>
</li>
<li> <p><strong>NULL</strong>: disabled.
</p>
</li></ul>
<p>. Default: &quot;auto&quot;</p>
</td></tr>
<tr><td><code id="cor_select_+3A_max_cor">max_cor</code></td>
<td>
<p>(optional; numeric) Maximum correlation allowed between any pair of variables in <code>predictors</code>. Recommended values are between 0.5 and 0.9. Higher values return larger number of predictors with a higher multicollinearity. If NULL, the pairwise correlation analysis is disabled. Default: <code>0.75</code></p>
</td></tr>
<tr><td><code id="cor_select_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> character vector if <code>response</code> is NULL or is a string.
</p>
</li>
<li><p> named list if <code>response</code> is a character vector.
</p>
</li></ul>



<h3>Pairwise Correlation Filtering</h3>

<p>The function <code><a href="#topic+cor_select">cor_select()</a></code> applies a recursive forward selection algorithm to keep predictors with a maximum Pearson correlation with all other selected predictors lower than <code>max_cor</code>.
</p>
<p>If the argument <code>preference_order</code> is NULL, the predictors are ranked from lower to higher sum of absolute pairwise correlation with all other predictors.
</p>
<p>If <code>preference_order</code> is defined, whenever two or more variables are above <code>max_cor</code>, the one higher in <code>preference_order</code> is preserved. For example, for the predictors and preference order <code class="reqn">a</code> and <code class="reqn">b</code>, if their correlation is higher than <code>max_cor</code>, then <code class="reqn">b</code> will be removed and <code class="reqn">a</code> preserved. If their correlation is lower than <code>max_cor</code>, then both are preserved.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito, PhD
</p>


<h3>See Also</h3>

<p>Other pairwise_correlation: 
<code><a href="#topic+cor_clusters">cor_clusters</a>()</code>,
<code><a href="#topic+cor_cramer_v">cor_cramer_v</a>()</code>,
<code><a href="#topic+cor_df">cor_df</a>()</code>,
<code><a href="#topic+cor_matrix">cor_matrix</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#subset to limit example run time
df &lt;- vi[1:1000, ]

#only numeric predictors only to speed-up examples
#categorical predictors are supported, but result in a slower analysis
predictors &lt;- vi_predictors_numeric[1:8]

#predictors has mixed types
sapply(
  X = df[, predictors, drop = FALSE],
  FUN = class
)

#parallelization setup
future::plan(
  future::multisession,
  workers = 2 #set to parallelly::availableCores() - 1
)

#progress bar
# progressr::handlers(global = TRUE)

#without preference order
x &lt;- cor_select(
  df = df,
  predictors = predictors,
  max_cor = 0.75
)


#with custom preference order
x &lt;- cor_select(
  df = df,
  predictors = predictors,
  preference_order = c(
    "swi_mean",
    "soil_type"
  ),
  max_cor = 0.75
)


#with automated preference order
df_preference &lt;- preference_order(
  df = df,
  response = "vi_numeric",
  predictors = predictors
)

x &lt;- cor_select(
  df = df,
  predictors = predictors,
  preference_order = df_preference,
  max_cor = 0.75
)

#resetting to sequential processing
future::plan(future::sequential)
</code></pre>

<hr>
<h2 id='drop_geometry_column'>Removes geometry column in sf data frames</h2><span id='topic+drop_geometry_column'></span>

<h3>Description</h3>

<p>Replicates the functionality of  <code>sf::st_drop_geometry()</code> without depending on the <code>sf</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_geometry_column(df = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drop_geometry_column_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="drop_geometry_column_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito, PhD
</p>

<hr>
<h2 id='encoded_predictor_name'>Name of Target-Encoded Predictor</h2><span id='topic+encoded_predictor_name'></span>

<h3>Description</h3>

<p>Name of Target-Encoded Predictor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>encoded_predictor_name(
  predictor = NULL,
  encoding_method = "mean",
  smoothing = 0,
  white_noise = 0,
  seed = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="encoded_predictor_name_+3A_predictor">predictor</code></td>
<td>
<p>(required; string) Name of the categorical predictor to encode. Default: NULL</p>
</td></tr>
<tr><td><code id="encoded_predictor_name_+3A_encoding_method">encoding_method</code></td>
<td>
<p>(required, string) Name of the encoding method. One of: &quot;mean&quot;, &quot;rank&quot;, or &quot;loo&quot;. Default: &quot;mean&quot;</p>
</td></tr>
<tr><td><code id="encoded_predictor_name_+3A_smoothing">smoothing</code></td>
<td>
<p>(optional; integer) Groups smaller than this number have their means pulled towards the mean of the response across all cases. Ignored by <code>target_encoding_rank()</code> and <code>target_encoding_loo()</code>. Default: 0</p>
</td></tr>
<tr><td><code id="encoded_predictor_name_+3A_white_noise">white_noise</code></td>
<td>
<p>(optional; numeric vector) Argument of the methods &quot;mean&quot;, &quot;rank&quot;, and &quot;loo&quot;. Maximum white noise to add, expressed as a fraction of the range of the response variable. Range from 0 to 1. Default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="encoded_predictor_name_+3A_seed">seed</code></td>
<td>
<p>(optional; integer vector) Random seed to facilitate reproducibility when <code>white_noise</code> is not 0. If NULL, the function selects one at random, and the selected seed does not appear in the encoded variable names. Default: 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string: predictor name
</p>


<h3>See Also</h3>

<p>Other target_encoding_tools: 
<code><a href="#topic+add_white_noise">add_white_noise</a>()</code>
</p>

<hr>
<h2 id='f_auc'>Association Between a Binomial Response and a Continuous Predictor</h2><span id='topic+f_auc'></span><span id='topic+f_auc_glm_binomial'></span><span id='topic+f_auc_glm_binomial_poly2'></span><span id='topic+f_auc_gam_binomial'></span><span id='topic+f_auc_rpart'></span><span id='topic+f_auc_rf'></span>

<h3>Description</h3>

<p>These functions take a data frame with a binomial response &quot;y&quot; with unique values 1 and 0, and a continuous predictor &quot;x&quot;, fit a univariate model, to return the Area Under the ROC Curve (AUC) of observations versus predictions:
</p>

<ul>
<li> <p><code>f_auc_glm_binomial()</code>: AUC of a binomial response against the predictions of a GLM model with formula <code>y ~ x</code>, family <code>stats::quasibinomial(link = "logit")</code>, and weighted cases (see <code><a href="#topic+case_weights">case_weights()</a></code>) to control for unbalanced data.
</p>
</li>
<li> <p><code>f_auc_glm_binomial_poly2()</code>: AUC of a binomial response against the predictions of a GLM model with formula <code>y ~ stats::poly(x, degree = 2, raw = TRUE)</code>, family <code>stats::quasibinomial(link = "logit")</code>, and weighted cases (see <code><a href="#topic+case_weights">case_weights()</a></code>) to control for unbalanced data.
</p>
</li>
<li> <p><code>f_auc_gam_binomial()</code>: AUC  of a GAM model with formula  <code>y ~ s(x)</code>, family <code>stats::quasibinomial(link = "logit")</code>, and weighted cases.
</p>
</li>
<li> <p><code>f_auc_rpart()</code>: AUC of a Recursive Partition Tree with weighted cases.
</p>
</li>
<li> <p><code>f_auc_rf()</code>: AUC of a Random Forest model with weighted cases.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>f_auc_glm_binomial(df)

f_auc_glm_binomial_poly2(df)

f_auc_gam_binomial(df)

f_auc_rpart(df)

f_auc_rf(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_auc_+3A_df">df</code></td>
<td>
<p>(required, data frame) with columns:
</p>

<ul>
<li><p> &quot;x&quot;: (numeric) continuous predictor.
</p>
</li>
<li><p> &quot;y&quot; (integer) binomial response with unique values 0 and 1.
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other preference_order_functions: 
<code><a href="#topic+f_r2">f_r2</a></code>,
<code><a href="#topic+f_r2_counts">f_r2_counts</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>
<p>Other preference_order_functions: 
<code><a href="#topic+f_r2">f_r2</a></code>,
<code><a href="#topic+f_r2_counts">f_r2_counts</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>
<p>Other preference_order_functions: 
<code><a href="#topic+f_r2">f_r2</a></code>,
<code><a href="#topic+f_r2_counts">f_r2_counts</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>
<p>Other preference_order_functions: 
<code><a href="#topic+f_r2">f_r2</a></code>,
<code><a href="#topic+f_r2_counts">f_r2_counts</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>
<p>Other preference_order_functions: 
<code><a href="#topic+f_r2">f_r2</a></code>,
<code><a href="#topic+f_r2_counts">f_r2_counts</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>
<p>Other preference_order_functions: 
<code><a href="#topic+f_r2">f_r2</a></code>,
<code><a href="#topic+f_r2_counts">f_r2_counts</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load example data
data(vi)

#reduce size to speed-up example
vi &lt;- vi[1:1000, ]

#integer counts response and continuous predictor
#to data frame without NAs
df &lt;- data.frame(
  y = vi[["vi_binomial"]],
  x = vi[["swi_max"]]
) |&gt;
  na.omit()

#AUC of GLM with binomial response and weighted cases
f_auc_glm_binomial(df = df)

#AUC of GLM as above plus second degree polynomials
f_auc_glm_binomial_poly2(df = df)

#AUC of binomial GAM with weighted cases
f_auc_gam_binomial(df = df)

#AUC of recursive partition tree with weighted cases
f_auc_rpart(df = df)

#AUC of random forest with weighted cases
f_auc_rf(df = df)
</code></pre>

<hr>
<h2 id='f_auto'>Select Function to Compute Preference Order</h2><span id='topic+f_auto'></span>

<h3>Description</h3>

<p>Internal function to select a proper f_...() function to compute preference order depending on the types of the response variable and the predictors. The selection criteria is available as a data frame generated by <code><a href="#topic+f_auto_rules">f_auto_rules()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_auto(df = NULL, response = NULL, predictors = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_auto_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="f_auto_+3A_response">response</code></td>
<td>
<p>(optional; character string or vector) Name/s of response variable/s in <code>df</code>. Used in target encoding when it names a numeric variable and there are categorical predictors, and to compute preference order. Default: NULL.</p>
</td></tr>
<tr><td><code id="f_auto_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
<tr><td><code id="f_auto_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>function name
</p>


<h3>See Also</h3>

<p>Other preference_order_tools: 
<code><a href="#topic+f_auto_rules">f_auto_rules</a>()</code>,
<code><a href="#topic+f_functions">f_functions</a>()</code>,
<code><a href="#topic+preference_order_collinear">preference_order_collinear</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- f_auto(
  df = vi[1:1000, ],
  response = "vi_numeric",
  predictors = vi_predictors_numeric
  )
</code></pre>

<hr>
<h2 id='f_auto_rules'>Rules to Select Default f Argument to Compute Preference Order</h2><span id='topic+f_auto_rules'></span>

<h3>Description</h3>

<p>Data frame with rules used by <code><a href="#topic+f_auto">f_auto()</a></code> to select the function <code>f</code> to compute preference order in <code><a href="#topic+preference_order">preference_order()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_auto_rules()
</code></pre>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other preference_order_tools: 
<code><a href="#topic+f_auto">f_auto</a>()</code>,
<code><a href="#topic+f_functions">f_functions</a>()</code>,
<code><a href="#topic+preference_order_collinear">preference_order_collinear</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f_auto_rules()
</code></pre>

<hr>
<h2 id='f_functions'>Data Frame of Preference Functions</h2><span id='topic+f_functions'></span>

<h3>Description</h3>

<p>Data Frame of Preference Functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_functions()
</code></pre>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other preference_order_tools: 
<code><a href="#topic+f_auto">f_auto</a>()</code>,
<code><a href="#topic+f_auto_rules">f_auto_rules</a>()</code>,
<code><a href="#topic+preference_order_collinear">preference_order_collinear</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f_functions()
</code></pre>

<hr>
<h2 id='f_r2'>Association Between a Continuous Response and a Continuous Predictor</h2><span id='topic+f_r2'></span><span id='topic+f_r2_pearson'></span><span id='topic+f_r2_spearman'></span><span id='topic+f_r2_glm_gaussian'></span><span id='topic+f_r2_glm_gaussian_poly2'></span><span id='topic+f_r2_gam_gaussian'></span><span id='topic+f_r2_rpart'></span><span id='topic+f_r2_rf'></span>

<h3>Description</h3>

<p>These functions take a data frame with two numeric continuous columns &quot;x&quot; (predictor) and &quot;y&quot; (response), fit a univariate model, and return the R-squared of the observations versus the model predictions:
</p>

<ul>
<li> <p><code>f_r2_pearson()</code>: Pearson's R-squared.
</p>
</li>
<li> <p><code>f_r2_spearman()</code>: Spearman's R-squared.
</p>
</li>
<li> <p><code>f_r2_glm_gaussian()</code>: Pearson's R-squared of a GLM model fitted with <code><a href="stats.html#topic+glm">stats::glm()</a></code>, with formula <code>y ~ s(x)</code> and family <code>stats::gaussian(link = "identity")</code>.
</p>
</li>
<li> <p><code>f_r2_glm_gaussian_poly2()</code>: Pearson's R-squared of a GLM model fitted with <code><a href="stats.html#topic+glm">stats::glm()</a></code>, with formula <code>y ~ stats::poly(x, degree = 2, raw = TRUE)</code> and family <code>stats::gaussian(link = "identity")</code>.
</p>
</li>
<li> <p><code>f_r2_gam_gaussian()</code>: Pearson's R-squared of a GAM model fitted with <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>, with formula <code>y ~ s(x)</code> and family <code>stats::gaussian(link = "identity")</code>.
</p>
</li>
<li> <p><code>f_r2_rpart()</code>: Pearson's R-squared of a Recursive Partition Tree fitted with <code><a href="rpart.html#topic+rpart">rpart::rpart()</a></code> with formula <code>y ~ x</code>.
</p>
</li>
<li> <p><code>f_r2_rf()</code>: Pearson's R-squared of a 100 trees Random Forest model fitted with <code><a href="ranger.html#topic+ranger">ranger::ranger()</a></code> and formula <code>y ~ x</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>f_r2_pearson(df)

f_r2_spearman(df)

f_r2_glm_gaussian(df)

f_r2_glm_gaussian_poly2(df)

f_r2_gam_gaussian(df)

f_r2_rpart(df)

f_r2_rf(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_r2_+3A_df">df</code></td>
<td>
<p>(required, data frame) with columns:
</p>

<ul>
<li><p> &quot;x&quot;: (numeric) continuous predictor.
</p>
</li>
<li><p> &quot;y&quot; (numeric) continuous response.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric: R-squared
</p>


<h3>See Also</h3>

<p>Other preference_order_functions: 
<code><a href="#topic+f_auc">f_auc</a></code>,
<code><a href="#topic+f_r2_counts">f_r2_counts</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>
<p>Other preference_order_functions: 
<code><a href="#topic+f_auc">f_auc</a></code>,
<code><a href="#topic+f_r2_counts">f_r2_counts</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>
<p>Other preference_order_functions: 
<code><a href="#topic+f_auc">f_auc</a></code>,
<code><a href="#topic+f_r2_counts">f_r2_counts</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>
<p>Other preference_order_functions: 
<code><a href="#topic+f_auc">f_auc</a></code>,
<code><a href="#topic+f_r2_counts">f_r2_counts</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>
<p>Other preference_order_functions: 
<code><a href="#topic+f_auc">f_auc</a></code>,
<code><a href="#topic+f_r2_counts">f_r2_counts</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>
<p>Other preference_order_functions: 
<code><a href="#topic+f_auc">f_auc</a></code>,
<code><a href="#topic+f_r2_counts">f_r2_counts</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>
<p>Other preference_order_functions: 
<code><a href="#topic+f_auc">f_auc</a></code>,
<code><a href="#topic+f_r2_counts">f_r2_counts</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>
<p>Other preference_order_functions: 
<code><a href="#topic+f_auc">f_auc</a></code>,
<code><a href="#topic+f_r2_counts">f_r2_counts</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vi)

#reduce size to speed-up example
vi &lt;- vi[1:1000, ]

#numeric response and predictor
#to data frame without NAs
df &lt;- data.frame(
  y = vi[["vi_numeric"]],
  x = vi[["swi_max"]]
) |&gt;
  na.omit()

# Continuous response

#Pearson R-squared
f_r2_pearson(df = df)

#Spearman R-squared
f_r2_spearman(df = df)

#R-squared of a gaussian gam
f_r2_glm_gaussian(df = df)

#gaussian glm with second-degree polynomials
f_r2_glm_gaussian_poly2(df = df)

#R-squared of a gaussian gam
f_r2_gam_gaussian(df = df)

#recursive partition tree
f_r2_rpart(df = df)

#random forest model
f_r2_rf(df = df)

#load example data
data(vi)

#reduce size to speed-up example
vi &lt;- vi[1:1000, ]

#continuous response and predictor
#to data frame without NAs
df &lt;- data.frame(
  y = vi[["vi_numeric"]],
  x = vi[["swi_max"]]
) |&gt;
  na.omit()

# Continuous response

#Pearson R-squared
f_r2_pearson(df = df)

#Spearman R-squared
f_r2_spearman(df = df)

#R-squared of a gaussian gam
f_r2_glm_gaussian(df = df)

#gaussian glm with second-degree polynomials
f_r2_glm_gaussian_poly2(df = df)

#R-squared of a gaussian gam
f_r2_gam_gaussian(df = df)

#recursive partition tree
f_r2_rpart(df = df)

#random forest model
f_r2_rf(df = df)

</code></pre>

<hr>
<h2 id='f_r2_counts'>Association Between a Count Response and a Continuous Predictor</h2><span id='topic+f_r2_counts'></span><span id='topic+f_r2_glm_poisson'></span><span id='topic+f_r2_glm_poisson_poly2'></span><span id='topic+f_r2_gam_poisson'></span>

<h3>Description</h3>

<p>These functions take a data frame with a integer counts response &quot;y&quot;, and a continuous predictor &quot;x&quot;, fit a univariate model, and return the R-squared of observations versus predictions:
</p>

<ul>
<li> <p><code>f_r2_glm_poisson()</code> Pearson's R-squared between a count response and the predictions of a GLM model with formula <code>y ~ x</code> and family <code>stats::poisson(link = "log")</code>.
</p>
</li>
<li> <p><code>f_r2_glm_poisson_poly2()</code> Pearson's R-squared between a count response and the predictions of a GLM model with formula <code>y ~ stats::poly(x, degree = 2, raw = TRUE)</code> and family <code>stats::poisson(link = "log")</code>.
</p>
</li>
<li> <p><code>f_r2_gam_poisson()</code> Pearson's R-squared between a count response and the predictions of a <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code> model with formula <code>y ~ s(x)</code> and family <code>stats::poisson(link = "log")</code>.
</p>
</li>
<li> <p><code>f_r2_rpart()</code>: Pearson's R-squared of a Recursive Partition Tree fitted with <code><a href="rpart.html#topic+rpart">rpart::rpart()</a></code> with formula <code>y ~ x</code>.
</p>
</li>
<li> <p><code>f_r2_rf()</code>: Pearson's R-squared of a 100 trees Random Forest model fitted with <code><a href="ranger.html#topic+ranger">ranger::ranger()</a></code> and formula <code>y ~ x</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>f_r2_glm_poisson(df)

f_r2_glm_poisson_poly2(df)

f_r2_gam_poisson(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_r2_counts_+3A_df">df</code></td>
<td>
<p>(required, data frame) with columns:
</p>

<ul>
<li><p> &quot;x&quot;: (numeric) continuous predictor.
</p>
</li>
<li><p> &quot;y&quot; (integer) counts response.
</p>
</li></ul>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other preference_order_functions: 
<code><a href="#topic+f_auc">f_auc</a></code>,
<code><a href="#topic+f_r2">f_r2</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>
<p>Other preference_order_functions: 
<code><a href="#topic+f_auc">f_auc</a></code>,
<code><a href="#topic+f_r2">f_r2</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>
<p>Other preference_order_functions: 
<code><a href="#topic+f_auc">f_auc</a></code>,
<code><a href="#topic+f_r2">f_r2</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>
<p>Other preference_order_functions: 
<code><a href="#topic+f_auc">f_auc</a></code>,
<code><a href="#topic+f_r2">f_r2</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#load example data
data(vi)

#reduce size to speed-up example
vi &lt;- vi[1:1000, ]

#integer counts response and continuous predictor
#to data frame without NAs
df &lt;- data.frame(
  y = vi[["vi_counts"]],
  x = vi[["swi_max"]]
) |&gt;
  na.omit()

#GLM model with Poisson family
f_r2_glm_poisson(df = df)

#GLM model with second degree polynomials and Poisson family
f_r2_glm_poisson_poly2(df = df)

#GAM model with Poisson family
f_r2_gam_poisson(df = df)
</code></pre>

<hr>
<h2 id='f_v'>Association Between a Categorical Response and a Categorical Predictor</h2><span id='topic+f_v'></span>

<h3>Description</h3>

<p>Computes Cramer's V, a measure of association between categorical or factor variables. Please see <code><a href="#topic+cor_cramer_v">cor_cramer_v()</a></code> for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_v(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_v_+3A_df">df</code></td>
<td>
<p>(required, data frame) with columns:
</p>

<ul>
<li><p> &quot;x&quot;: (character or factor) categorical predictor.
</p>
</li>
<li><p> &quot;y&quot;: (character or factor) categorical response.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric: Cramer's V
</p>


<h3>See Also</h3>

<p>Other preference_order_functions: 
<code><a href="#topic+f_auc">f_auc</a></code>,
<code><a href="#topic+f_r2">f_r2</a></code>,
<code><a href="#topic+f_r2_counts">f_r2_counts</a></code>,
<code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load example data
data(vi)

#reduce size to speed-up example
vi &lt;- vi[1:1000, ]

#categorical response and predictor
#to data frame without NAs
df &lt;- data.frame(
  y = vi[["vi_factor"]],
  x = vi[["soil_type"]]
) |&gt;
  na.omit()

#Cramer's V
f_v(df = df)
</code></pre>

<hr>
<h2 id='f_v_rf_categorical'>Association Between a Categorical Response and a Categorical or Numeric Predictor</h2><span id='topic+f_v_rf_categorical'></span>

<h3>Description</h3>

<p>Computes the Cramer's V between a categorical response (of class &quot;character&quot; or &quot;factor&quot;) and the prediction of a Random Forest model with a categorical or numeric predictor and weighted cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f_v_rf_categorical(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_v_rf_categorical_+3A_df">df</code></td>
<td>
<p>(required, data frame) with columns:
</p>

<ul>
<li><p> &quot;x&quot;: (character, factor, or numeric) categorical or numeric predictor.
</p>
</li>
<li><p> &quot;y&quot; (character or factor) categorical response.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric: Cramer's V
</p>


<h3>See Also</h3>

<p>Other preference_order_functions: 
<code><a href="#topic+f_auc">f_auc</a></code>,
<code><a href="#topic+f_r2">f_r2</a></code>,
<code><a href="#topic+f_r2_counts">f_r2_counts</a></code>,
<code><a href="#topic+f_v">f_v</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#load example data
data(vi)

#reduce size to speed-up example
vi &lt;- vi[1:1000, ]

#categorical response and predictor
#to data frame without NAs
df &lt;- data.frame(
  y = vi[["vi_factor"]],
  x = vi[["soil_type"]]
) |&gt;
  na.omit()

#Cramer's V of a Random Forest model
f_v_rf_categorical(df = df)

#categorical response and numeric predictor
df &lt;- data.frame(
  y = vi[["vi_factor"]],
  x = vi[["swi_mean"]]
) |&gt;
  na.omit()

f_v_rf_categorical(df = df)
</code></pre>

<hr>
<h2 id='identify_predictors'>Identify Numeric and Categorical Predictors</h2><span id='topic+identify_predictors'></span>

<h3>Description</h3>

<p>Returns a list with the names of the valid numeric predictors and the names of the valid categorical predictors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_predictors(df = NULL, predictors = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identify_predictors_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="identify_predictors_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list: names of numeric and categorical predictors
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito, PhD
</p>


<h3>See Also</h3>

<p>Other data_types: 
<code><a href="#topic+identify_predictors_categorical">identify_predictors_categorical</a>()</code>,
<code><a href="#topic+identify_predictors_numeric">identify_predictors_numeric</a>()</code>,
<code><a href="#topic+identify_predictors_type">identify_predictors_type</a>()</code>,
<code><a href="#topic+identify_predictors_zero_variance">identify_predictors_zero_variance</a>()</code>,
<code><a href="#topic+identify_response_type">identify_response_type</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {

data(
  vi,
  vi_predictors
)

predictors_names &lt;- identify_predictors(
  df = vi,
  predictors = vi_predictors
)

predictors_names

}
</code></pre>

<hr>
<h2 id='identify_predictors_categorical'>Identify Valid Categorical Predictors</h2><span id='topic+identify_predictors_categorical'></span>

<h3>Description</h3>

<p>Returns the names of character or factor predictors, if any. Removes categorical predictors with constant values, or with as many unique values as rows are in the input data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_predictors_categorical(df = NULL, predictors = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identify_predictors_categorical_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="identify_predictors_categorical_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector: categorical predictors names
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito, PhD
</p>


<h3>See Also</h3>

<p>Other data_types: 
<code><a href="#topic+identify_predictors">identify_predictors</a>()</code>,
<code><a href="#topic+identify_predictors_numeric">identify_predictors_numeric</a>()</code>,
<code><a href="#topic+identify_predictors_type">identify_predictors_type</a>()</code>,
<code><a href="#topic+identify_predictors_zero_variance">identify_predictors_zero_variance</a>()</code>,
<code><a href="#topic+identify_response_type">identify_response_type</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi,
  vi_predictors
)

non.numeric.predictors &lt;- identify_predictors_categorical(
  df = vi,
  predictors = vi_predictors
)

non.numeric.predictors

</code></pre>

<hr>
<h2 id='identify_predictors_numeric'>Identify Valid Numeric Predictors</h2><span id='topic+identify_predictors_numeric'></span>

<h3>Description</h3>

<p>Returns the names of valid numeric predictors. Ignores predictors with constant values or with near-zero variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_predictors_numeric(df = NULL, predictors = NULL, decimals = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identify_predictors_numeric_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="identify_predictors_numeric_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
<tr><td><code id="identify_predictors_numeric_+3A_decimals">decimals</code></td>
<td>
<p>(required, integer) Number of decimal places for the zero variance test. Smaller numbers will increase the number of variables detected as near-zero variance. Recommended values will depend on the range of the numeric variables in 'df'. Default: 4</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector: names of numeric predictors
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito, PhD
</p>


<h3>See Also</h3>

<p>Other data_types: 
<code><a href="#topic+identify_predictors">identify_predictors</a>()</code>,
<code><a href="#topic+identify_predictors_categorical">identify_predictors_categorical</a>()</code>,
<code><a href="#topic+identify_predictors_type">identify_predictors_type</a>()</code>,
<code><a href="#topic+identify_predictors_zero_variance">identify_predictors_zero_variance</a>()</code>,
<code><a href="#topic+identify_response_type">identify_response_type</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (interactive()) {

data(
  vi,
  vi_predictors
)

numeric.predictors &lt;- identify_predictors_numeric(
  df = vi,
  predictors = vi_predictors
)

numeric.predictors

}
</code></pre>

<hr>
<h2 id='identify_predictors_type'>Identify Predictor Types</h2><span id='topic+identify_predictors_type'></span>

<h3>Description</h3>

<p>Internal function to identify predictor types. The supported types are:
</p>

<ul>
<li><p> &quot;numeric&quot;: all predictors belong to the classes &quot;numeric&quot; and/or &quot;integer&quot;.
</p>
</li>
<li><p> &quot;categorical&quot;: all predictors belong to the classes &quot;character&quot; and/or &quot;factor&quot;.
</p>
</li>
<li><p> &quot;mixed&quot;: predictors are of types &quot;numeric&quot; and &quot;categorical&quot;.
</p>
</li>
<li><p> &quot;unknown&quot;: predictors of unknown type.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>identify_predictors_type(df = NULL, predictors = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identify_predictors_type_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="identify_predictors_type_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string: predictors type
</p>


<h3>See Also</h3>

<p>Other data_types: 
<code><a href="#topic+identify_predictors">identify_predictors</a>()</code>,
<code><a href="#topic+identify_predictors_categorical">identify_predictors_categorical</a>()</code>,
<code><a href="#topic+identify_predictors_numeric">identify_predictors_numeric</a>()</code>,
<code><a href="#topic+identify_predictors_zero_variance">identify_predictors_zero_variance</a>()</code>,
<code><a href="#topic+identify_response_type">identify_response_type</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
identify_predictors_type(
  df = vi,
  predictors = vi_predictors
)

identify_predictors_type(
  df = vi,
  predictors = vi_predictors_numeric
)

identify_predictors_type(
  df = vi,
  predictors = vi_predictors_categorical
)

</code></pre>

<hr>
<h2 id='identify_predictors_zero_variance'>Identify Zero and Near-Zero Variance Predictors</h2><span id='topic+identify_predictors_zero_variance'></span>

<h3>Description</h3>

<p>Variables with a variance of zero or near-zero are highly problematic for multicollinearity analysis and modelling in general. This function identifies these variables with a level of sensitivity defined by the 'decimals' argument. Smaller number of decimals increase the number of variables detected as near zero variance. Recommended values will depend on the range of the numeric variables in 'df'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_predictors_zero_variance(df = NULL, predictors = NULL, decimals = 4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identify_predictors_zero_variance_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="identify_predictors_zero_variance_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
<tr><td><code id="identify_predictors_zero_variance_+3A_decimals">decimals</code></td>
<td>
<p>(required, integer) Number of decimal places for the zero variance test. Smaller numbers will increase the number of variables detected as near-zero variance. Recommended values will depend on the range of the numeric variables in 'df'. Default: 4</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector: names of zero and near-zero variance columns.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito, PhD
</p>


<h3>See Also</h3>

<p>Other data_types: 
<code><a href="#topic+identify_predictors">identify_predictors</a>()</code>,
<code><a href="#topic+identify_predictors_categorical">identify_predictors_categorical</a>()</code>,
<code><a href="#topic+identify_predictors_numeric">identify_predictors_numeric</a>()</code>,
<code><a href="#topic+identify_predictors_type">identify_predictors_type</a>()</code>,
<code><a href="#topic+identify_response_type">identify_response_type</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi,
  vi_predictors
)

#create zero variance predictors
vi$zv_1 &lt;- 1
vi$zv_2 &lt;- runif(n = nrow(vi), min = 0, max = 0.0001)


#add to vi predictors
vi_predictors &lt;- c(
  vi_predictors,
  "zv_1",
  "zv_2"
)

#identify zero variance predictors
zero.variance.predictors &lt;- identify_predictors_zero_variance(
  df = vi,
  predictors = vi_predictors
)

zero.variance.predictors

</code></pre>

<hr>
<h2 id='identify_response_type'>Identify Response Type</h2><span id='topic+identify_response_type'></span>

<h3>Description</h3>

<p>Internal function to identify the type of response variable. Supported types are:
</p>

<ul>
<li><p> &quot;continuous-binary&quot;: decimal numbers and two unique values; results in a warning, as this type is difficult to model.
</p>
</li>
<li><p> &quot;continuous-low&quot;: decimal numbers and 3 to 5 unique values; results in a message, as this type is difficult to model.
</p>
</li>
<li><p> &quot;continuous-high&quot;: decimal numbers and more than 5 unique values.
</p>
</li>
<li><p> &quot;integer-binomial&quot;: integer with 0s and 1s, suitable for binomial models.
</p>
</li>
<li><p> &quot;integer-binary&quot;: integer with 2 unique values other than 0 and 1; returns a warning, as this type is difficult to model.
</p>
</li>
<li><p> &quot;integer-low&quot;: integer with 3 to 5 unique values or meets specified thresholds.
</p>
</li>
<li><p> &quot;integer-high&quot;: integer with more than 5 unique values suitable for count modelling.
</p>
</li>
<li><p> &quot;categorical&quot;: character or factor with 2 or more levels.
</p>
</li>
<li><p> &quot;unknown&quot;: when the response type cannot be determined.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>identify_response_type(df = NULL, response = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identify_response_type_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="identify_response_type_+3A_response">response</code></td>
<td>
<p>(optional; character string or vector) Name/s of response variable/s in <code>df</code>. Used in target encoding when it names a numeric variable and there are categorical predictors, and to compute preference order. Default: NULL.</p>
</td></tr>
<tr><td><code id="identify_response_type_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string: response type
</p>


<h3>See Also</h3>

<p>Other data_types: 
<code><a href="#topic+identify_predictors">identify_predictors</a>()</code>,
<code><a href="#topic+identify_predictors_categorical">identify_predictors_categorical</a>()</code>,
<code><a href="#topic+identify_predictors_numeric">identify_predictors_numeric</a>()</code>,
<code><a href="#topic+identify_predictors_type">identify_predictors_type</a>()</code>,
<code><a href="#topic+identify_predictors_zero_variance">identify_predictors_zero_variance</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>identify_response_type(
  df = vi,
  response = "vi_numeric"
)

identify_response_type(
  df = vi,
  response = "vi_counts"
)

identify_response_type(
  df = vi,
  response = "vi_binomial"
)

identify_response_type(
  df = vi,
  response = "vi_categorical"
)

identify_response_type(
  df = vi,
  response = "vi_factor"
)

</code></pre>

<hr>
<h2 id='model_formula'>Generate Model Formulas</h2><span id='topic+model_formula'></span>

<h3>Description</h3>

<p>Generate Model Formulas
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_formula(
  df = NULL,
  response = NULL,
  predictors = NULL,
  term_f = NULL,
  term_args = NULL,
  random_effects = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model_formula_+3A_df">df</code></td>
<td>
<p>(optional; data frame, tibble, or sf). A data frame with responses and predictors. Required if <code>predictors = NULL</code>. Default: NULL.</p>
</td></tr>
<tr><td><code id="model_formula_+3A_response">response</code></td>
<td>
<p>(optional; character string or vector) Name/s of response variable/s in <code>df</code>. Used in target encoding when it names a numeric variable and there are categorical predictors, and to compute preference order. Default: NULL.</p>
</td></tr>
<tr><td><code id="model_formula_+3A_predictors">predictors</code></td>
<td>
<p>(optional, character vector, output of <code><a href="#topic+collinear">collinear()</a></code>): predictors to include in the formula. Required if <code>df = NULL</code>.</p>
</td></tr>
<tr><td><code id="model_formula_+3A_term_f">term_f</code></td>
<td>
<p>(optional; string). Name of function to apply to each term in the formula, such as &quot;s&quot; for <code><a href="mgcv.html#topic+s">mgcv::s()</a></code> or any other smoothing function, &quot;poly&quot; for <code><a href="stats.html#topic+poly">stats::poly()</a></code>. Default: NULL</p>
</td></tr>
<tr><td><code id="model_formula_+3A_term_args">term_args</code></td>
<td>
<p>(optional; string). Arguments of the function applied to each term. For example, for &quot;poly&quot; it can be &quot;degree = 2, raw = TRUE&quot;. Default: NULL</p>
</td></tr>
<tr><td><code id="model_formula_+3A_random_effects">random_effects</code></td>
<td>
<p>(optional, string or character vector). Names of variables to be used as random effects. Each element is added to the final formula as <code> +(1 | random_effect_name)</code>. Default: NULL</p>
</td></tr>
<tr><td><code id="model_formula_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list if <code>predictors</code> is a list or length of <code>response</code> is higher than one, and character vector otherwise.
</p>


<h3>See Also</h3>

<p>Other modelling_tools: 
<code><a href="#topic+case_weights">case_weights</a>()</code>,
<code><a href="#topic+performance_score_auc">performance_score_auc</a>()</code>,
<code><a href="#topic+performance_score_r2">performance_score_r2</a>()</code>,
<code><a href="#topic+performance_score_v">performance_score_v</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#using df, response, and predictors
#----------------------------------
df &lt;- vi[1:1000, ]

#additive formulas
formulas_additive &lt;- model_formula(
  df = df,
  response = c(
    "vi_numeric",
    "vi_categorical"
    ),
  predictors = vi_predictors_numeric[1:10]
)

formulas_additive

#using a formula in a model
#m &lt;- stats::lm(
#  formula = formulas_additive[[1]],
#  data = df
#  )

# using output of collinear()
#----------------------------------
selection &lt;- collinear(
  df = df,
  response = c(
    "vi_numeric",
    "vi_binomial"
  ),
  predictors = vi_predictors_numeric[1:10],
  quiet = TRUE
)

#polynomial formulas
formulas_poly &lt;- model_formula(
  predictors = selection,
  term_f = "poly",
  term_args = "degree = 3, raw = TRUE"
)

formulas_poly

#gam formulas
formulas_gam &lt;- model_formula(
  predictors = selection,
  term_f = "s"
)

formulas_gam

#adding a random effect
formulas_random_effect &lt;- model_formula(
  predictors = selection,
  random_effects = "country_name"
)

formulas_random_effect
</code></pre>

<hr>
<h2 id='performance_score_auc'>Area Under the Curve of Binomial Observations vs Probabilistic Model Predictions</h2><span id='topic+performance_score_auc'></span>

<h3>Description</h3>

<p>Internal function to compute the AUC of binomial models within <code><a href="#topic+preference_order">preference_order()</a></code>. As it is build for speed, this function does not check the inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performance_score_auc(o = NULL, p = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="performance_score_auc_+3A_o">o</code></td>
<td>
<p>(required, binomial vector) Binomial response with values 0 and 1. Default: NULL</p>
</td></tr>
<tr><td><code id="performance_score_auc_+3A_p">p</code></td>
<td>
<p>(required, numeric vector) Predictions of binomial model. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric: Area Under the ROC Curve
</p>


<h3>See Also</h3>

<p>Other modelling_tools: 
<code><a href="#topic+case_weights">case_weights</a>()</code>,
<code><a href="#topic+model_formula">model_formula</a>()</code>,
<code><a href="#topic+performance_score_r2">performance_score_r2</a>()</code>,
<code><a href="#topic+performance_score_v">performance_score_v</a>()</code>
</p>

<hr>
<h2 id='performance_score_r2'>Pearson's R-squared of Observations vs Predictions</h2><span id='topic+performance_score_r2'></span>

<h3>Description</h3>

<p>Internal function to compute the R-squared of observations versus model predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performance_score_r2(o = NULL, p = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="performance_score_r2_+3A_o">o</code></td>
<td>
<p>(required, numeric vector) Response values. Default: NULL</p>
</td></tr>
<tr><td><code id="performance_score_r2_+3A_p">p</code></td>
<td>
<p>(required, numeric vector) Model predictions. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric: Pearson R-squared
</p>


<h3>See Also</h3>

<p>Other modelling_tools: 
<code><a href="#topic+case_weights">case_weights</a>()</code>,
<code><a href="#topic+model_formula">model_formula</a>()</code>,
<code><a href="#topic+performance_score_auc">performance_score_auc</a>()</code>,
<code><a href="#topic+performance_score_v">performance_score_v</a>()</code>
</p>

<hr>
<h2 id='performance_score_v'>Cramer's V of Observations vs Predictions</h2><span id='topic+performance_score_v'></span>

<h3>Description</h3>

<p>Internal function to compute the Cramer's V of categorical observations versus categorical model predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performance_score_v(o = NULL, p = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="performance_score_v_+3A_o">o</code></td>
<td>
<p>(required, numeric vector) Response values. Default: NULL</p>
</td></tr>
<tr><td><code id="performance_score_v_+3A_p">p</code></td>
<td>
<p>(required, numeric vector) Model predictions. Default: NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric: Cramer's V
</p>


<h3>See Also</h3>

<p>Other modelling_tools: 
<code><a href="#topic+case_weights">case_weights</a>()</code>,
<code><a href="#topic+model_formula">model_formula</a>()</code>,
<code><a href="#topic+performance_score_auc">performance_score_auc</a>()</code>,
<code><a href="#topic+performance_score_r2">performance_score_r2</a>()</code>
</p>

<hr>
<h2 id='preference_order'>Quantitative Variable Prioritization for Multicollinearity Filtering</h2><span id='topic+preference_order'></span>

<h3>Description</h3>

<p>Ranks a set of predictors by the strength of their association with a response. Aims to minimize the loss of important predictors during multicollinearity filtering.
</p>
<p>The strength of association between the response and each predictor is computed by the function <code>f</code>. The <code>f</code> functions available are:
</p>

<ul>
<li> <p><strong>Numeric response vs numeric predictor</strong>:
</p>

<ul>
<li> <p><code><a href="#topic+f_r2_pearson">f_r2_pearson()</a></code>: Pearson's R-squared.
</p>
</li>
<li> <p><code><a href="#topic+f_r2_spearman">f_r2_spearman()</a></code>: Spearman's R-squared.
</p>
</li>
<li> <p><code><a href="#topic+f_r2_glm_gaussian">f_r2_glm_gaussian()</a></code>: Pearson's R-squared of response versus the predictions of a Gaussian GLM.
</p>
</li>
<li> <p><code><a href="#topic+f_r2_glm_gaussian_poly2">f_r2_glm_gaussian_poly2()</a></code>: Gaussian GLM with second degree polynomial.
</p>
</li>
<li> <p><code><a href="#topic+f_r2_gam_gaussian">f_r2_gam_gaussian()</a></code>: GAM model fitted with <code><a href="mgcv.html#topic+gam">mgcv::gam()</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+f_r2_rpart">f_r2_rpart()</a></code>: Recursive Partition Tree fitted with <code><a href="rpart.html#topic+rpart">rpart::rpart()</a></code>.
</p>
</li>
<li> <p><code><a href="#topic+f_r2_rf">f_r2_rf()</a></code>: Random Forest model fitted with <code><a href="ranger.html#topic+ranger">ranger::ranger()</a></code>.
</p>
</li></ul>

</li>
<li> <p><strong>Integer counts response vs. numeric predictor</strong>:
</p>

<ul>
<li> <p><code><a href="#topic+f_r2_glm_poisson">f_r2_glm_poisson()</a></code>: Pearson's R-squared of a Poisson GLM.
</p>
</li>
<li> <p><code><a href="#topic+f_r2_glm_poisson_poly2">f_r2_glm_poisson_poly2()</a></code>: Poisson GLM with second degree polynomial.
</p>
</li>
<li> <p><code><a href="#topic+f_r2_gam_poisson">f_r2_gam_poisson()</a></code>: Poisson GAM.
</p>
</li></ul>

</li>
<li> <p><strong>Binomial response (1 and 0) vs. numeric predictor</strong>:
</p>

<ul>
<li> <p><code><a href="#topic+f_auc_glm_binomial">f_auc_glm_binomial()</a></code>: AUC of quasibinomial GLM with weighted cases.
</p>
</li>
<li> <p><code><a href="#topic+f_auc_glm_binomial_poly2">f_auc_glm_binomial_poly2()</a></code>: As above with second degree polynomial.
</p>
</li>
<li> <p><code><a href="#topic+f_auc_gam_binomial">f_auc_gam_binomial()</a></code>: Quasibinomial GAM with weighted cases.
</p>
</li>
<li> <p><code><a href="#topic+f_auc_rpart">f_auc_rpart()</a></code>: Recursive Partition Tree with weighted cases.
</p>
</li>
<li> <p><code><a href="#topic+f_auc_rf">f_auc_rf()</a></code>: Random Forest model with weighted cases.
</p>
</li></ul>

</li>
<li> <p><strong>Categorical response (character of factor) vs. categorical predictor</strong>:
</p>

<ul>
<li> <p><code><a href="#topic+f_v">f_v()</a></code>: Cramer's V between two categorical variables.
</p>
</li></ul>

</li>
<li> <p><strong>Categorical response vs. categorical or numerical predictor</strong>:
</p>

<ul>
<li> <p><code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical()</a></code>: Cramer's V of a Random Forest model.
</p>
</li></ul>

</li></ul>

<p>The name of the used function is stored in the attribute &quot;f_name&quot; of the output data frame. It can be retrieved via <code>attributes(df)$f_name</code>
</p>
<p>Additionally, any custom function accepting a data frame with the columns &quot;x&quot; (predictor) and &quot;y&quot; (response) and returning a numeric indicator of association where higher numbers indicate higher association will work.
</p>
<p>This function returns a data frame with the column &quot;predictor&quot;, with predictor names ordered by the column &quot;preference&quot;, with the result of <code>f</code>. This data frame, or the column &quot;predictor&quot; alone, can be used as inputs for the argument <code>preference_order</code> in <code><a href="#topic+collinear">collinear()</a></code>, <code><a href="#topic+cor_select">cor_select()</a></code>, and <code><a href="#topic+vif_select">vif_select()</a></code>.
</p>
<p>Accepts a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code> and a progress bar via <code><a href="progressr.html#topic+handlers">progressr::handlers()</a></code> (see examples).
</p>
<p>Accepts a character vector of response variables as input for the argument <code>response</code>. When more than one response is provided, the output is a named list of preference data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preference_order(
  df = NULL,
  response = NULL,
  predictors = NULL,
  f = "auto",
  warn_limit = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preference_order_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="preference_order_+3A_response">response</code></td>
<td>
<p>(optional; character string or vector) Name/s of response variable/s in <code>df</code>. Used in target encoding when it names a numeric variable and there are categorical predictors, and to compute preference order. Default: NULL.</p>
</td></tr>
<tr><td><code id="preference_order_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
<tr><td><code id="preference_order_+3A_f">f</code></td>
<td>
<p>(optional: function) Function to compute preference order. If &quot;auto&quot; (default) or NULL, the output of <code><a href="#topic+f_auto">f_auto()</a></code> for the given data is used:
</p>

<ul>
<li> <p><code><a href="#topic+f_auc_rf">f_auc_rf()</a></code>: if <code>response</code> is binomial.
</p>
</li>
<li> <p><code><a href="#topic+f_r2_pearson">f_r2_pearson()</a></code>: if <code>response</code> and <code>predictors</code> are numeric.
</p>
</li>
<li> <p><code><a href="#topic+f_v">f_v()</a></code>: if <code>response</code> and <code>predictors</code> are categorical.
</p>
</li>
<li> <p><code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical()</a></code>: if <code>response</code> is categorical and <code>predictors</code> are numeric or mixed .
</p>
</li>
<li> <p><code><a href="#topic+f_r2_rf">f_r2_rf()</a></code>: in all other cases.
</p>
</li></ul>

<p>Default: NULL</p>
</td></tr>
<tr><td><code id="preference_order_+3A_warn_limit">warn_limit</code></td>
<td>
<p>(optional, numeric) Preference value (R-squared, AUC, or Cramer's V) over which a warning flagging suspicious predictors is issued. Disabled if NULL. Default: NULL</p>
</td></tr>
<tr><td><code id="preference_order_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame: columns are &quot;response&quot;, &quot;predictor&quot;, &quot;f&quot; (function name), and &quot;preference&quot;.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito, PhD
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#subsets to limit example run time
df &lt;- vi[1:1000, ]
predictors &lt;- vi_predictors[1:10]
predictors_numeric &lt;- vi_predictors_numeric[1:10]

#parallelization setup
future::plan(
  future::multisession,
  workers = 2 #set to parallelly::availableCores() - 1
)

#progress bar
# progressr::handlers(global = TRUE)

#numeric response and predictors
#------------------------------------------------
#selects f automatically depending on data features
#applies f_r2_pearson() to compute correlation between response and predictors
df_preference &lt;- preference_order(
  df = df,
  response = "vi_numeric",
  predictors = predictors_numeric,
  f = NULL
  )

#returns data frame ordered by preference
df_preference


#several responses
#------------------------------------------------
responses &lt;- c(
  "vi_categorical",
  "vi_counts"
)

preference_list &lt;- preference_order(
  df = df,
  response = responses,
  predictors = predictors
)

#returns a named list
names(preference_list)
preference_list[[1]]
preference_list[[2]]

#can be used in collinear()
# x &lt;- collinear(
#   df = df,
#   response = responses,
#   predictors = predictors,
#   preference_order = preference_list
# )

#f function selected by user
#for binomial response and numeric predictors
# preference_order(
#   df = vi,
#   response = "vi_binomial",
#   predictors = predictors_numeric,
#   f = f_auc_glm_binomial
# )


#disable parallelization
future::plan(future::sequential)
</code></pre>

<hr>
<h2 id='preference_order_collinear'>Preference Order Argument in collinear()</h2><span id='topic+preference_order_collinear'></span>

<h3>Description</h3>

<p>Internal function to manage the argument <code>preference_order</code> in <code><a href="#topic+collinear">collinear()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preference_order_collinear(
  df = NULL,
  response = NULL,
  predictors = NULL,
  preference_order = NULL,
  f = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preference_order_collinear_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="preference_order_collinear_+3A_response">response</code></td>
<td>
<p>(optional; character string or vector) Name/s of response variable/s in <code>df</code>. Used in target encoding when it names a numeric variable and there are categorical predictors, and to compute preference order. Default: NULL.</p>
</td></tr>
<tr><td><code id="preference_order_collinear_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
<tr><td><code id="preference_order_collinear_+3A_preference_order">preference_order</code></td>
<td>
<p>(optional; string, character vector, output of <code><a href="#topic+preference_order">preference_order()</a></code>). Defines a priority order, from first to last, to preserve predictors during the selection process. Accepted inputs are:
</p>

<ul>
<li> <p><strong>&quot;auto&quot;</strong> (default): if <code>response</code> is not NULL, calls <code><a href="#topic+preference_order">preference_order()</a></code> for internal computation.
</p>
</li>
<li> <p><strong>character vector</strong>: predictor names in a custom preference order.
</p>
</li>
<li> <p><strong>data frame</strong>: output of <code><a href="#topic+preference_order">preference_order()</a></code> from <code>response</code> of length one.
</p>
</li>
<li> <p><strong>named list</strong>: output of <code><a href="#topic+preference_order">preference_order()</a></code> from <code>response</code> of length two or more.
</p>
</li>
<li> <p><strong>NULL</strong>: disabled.
</p>
</li></ul>
<p>. Default: &quot;auto&quot;</p>
</td></tr>
<tr><td><code id="preference_order_collinear_+3A_f">f</code></td>
<td>
<p>(optional: function) Function to compute preference order. If &quot;auto&quot; (default) or NULL, the output of <code><a href="#topic+f_auto">f_auto()</a></code> for the given data is used:
</p>

<ul>
<li> <p><code><a href="#topic+f_auc_rf">f_auc_rf()</a></code>: if <code>response</code> is binomial.
</p>
</li>
<li> <p><code><a href="#topic+f_r2_pearson">f_r2_pearson()</a></code>: if <code>response</code> and <code>predictors</code> are numeric.
</p>
</li>
<li> <p><code><a href="#topic+f_v">f_v()</a></code>: if <code>response</code> and <code>predictors</code> are categorical.
</p>
</li>
<li> <p><code><a href="#topic+f_v_rf_categorical">f_v_rf_categorical()</a></code>: if <code>response</code> is categorical and <code>predictors</code> are numeric or mixed .
</p>
</li>
<li> <p><code><a href="#topic+f_r2_rf">f_r2_rf()</a></code>: in all other cases.
</p>
</li></ul>

<p>Default: NULL</p>
</td></tr>
<tr><td><code id="preference_order_collinear_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector or NULL
</p>


<h3>See Also</h3>

<p>Other preference_order_tools: 
<code><a href="#topic+f_auto">f_auto</a>()</code>,
<code><a href="#topic+f_auto_rules">f_auto_rules</a>()</code>,
<code><a href="#topic+f_functions">f_functions</a>()</code>
</p>

<hr>
<h2 id='target_encoding_lab'>Target Encoding Lab: Transform Categorical Variables to Numeric</h2><span id='topic+target_encoding_lab'></span>

<h3>Description</h3>

<p>Target encoding involves replacing the values of categorical variables with numeric ones derived from a &quot;target variable&quot;, usually a model's response.
</p>
<p>In essence, target encoding works as follows:
</p>

<ul>
<li><p> 1. group all cases belonging to a unique value of the categorical variable.
</p>
</li>
<li><p> 2. compute a statistic of the target variable across the group cases.
</p>
</li>
<li><p> 3. assign the value of the statistic to the group.
</p>
</li></ul>

<p>The methods to compute the group statistic implemented here are:
</p>

<ul>
<li><p> &quot;mean&quot; (implemented in <code>target_encoding_mean()</code>): Encodes categorical values with the group means of the response. Variables encoded with this method are identified with the suffix &quot;__encoded_mean&quot;. It has a method to control overfitting implemented via the argument <code>smoothing</code>. The integer value of this argument indicates a threshold in number of rows. Groups above this threshold are encoded with the group mean, while groups below it are encoded with a weighted mean of the group's mean and the global mean. This method is named &quot;mean smoothing&quot; in the relevant literature.
</p>
</li>
<li><p> &quot;rank&quot; (implemented in <code>target_encoding_rank()</code>): Returns the rank of the group as a integer, being 1 he group with the lower mean of the response variable. Variables encoded with this method are identified with the suffix &quot;__encoded_rank&quot;.
</p>
</li>
<li><p> &quot;loo&quot; (implemented in <code>target_encoding_loo()</code>): Known as the &quot;leave-one-out method&quot; in the literature, it encodes each categorical value with the mean of the response variable across all other group cases. This method controls overfitting better than &quot;mean&quot;. Variables encoded with this method are identified with the suffix &quot;__encoded_loo&quot;.
</p>
</li></ul>

<p>Accepts a parallelization setup via <code><a href="future.html#topic+plan">future::plan()</a></code> and a progress bar via <code><a href="progressr.html#topic+handlers">progressr::handlers()</a></code> (see examples).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target_encoding_lab(
  df = NULL,
  response = NULL,
  predictors = NULL,
  methods = c("loo", "mean", "rank"),
  smoothing = 0,
  white_noise = 0,
  seed = 0,
  overwrite = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="target_encoding_lab_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="target_encoding_lab_+3A_response">response</code></td>
<td>
<p>(optional, character string) Name of a numeric response variable in <code>df</code>. Default: NULL.</p>
</td></tr>
<tr><td><code id="target_encoding_lab_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
<tr><td><code id="target_encoding_lab_+3A_methods">methods</code></td>
<td>
<p>(optional; character vector or NULL). Name of the target encoding methods. If NULL, target encoding is ignored, and <code>df</code> is returned with no modification. Default: c(&quot;loo&quot;, &quot;mean&quot;, &quot;rank&quot;)</p>
</td></tr>
<tr><td><code id="target_encoding_lab_+3A_smoothing">smoothing</code></td>
<td>
<p>(optional; integer vector) Argument of the method &quot;mean&quot;. Groups smaller than this number have their means pulled towards the mean of the response across all cases. Default: 0</p>
</td></tr>
<tr><td><code id="target_encoding_lab_+3A_white_noise">white_noise</code></td>
<td>
<p>(optional; numeric vector) Argument of the methods &quot;mean&quot;, &quot;rank&quot;, and &quot;loo&quot;. Maximum white noise to add, expressed as a fraction of the range of the response variable. Range from 0 to 1. Default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="target_encoding_lab_+3A_seed">seed</code></td>
<td>
<p>(optional; integer vector) Random seed to facilitate reproducibility when <code>white_noise</code> is not 0. If NULL, the function selects one at random, and the selected seed does not appear in the encoded variable names. Default: 0</p>
</td></tr>
<tr><td><code id="target_encoding_lab_+3A_overwrite">overwrite</code></td>
<td>
<p>(optional; logical) If <code>TRUE</code>, the original predictors in <code>df</code> are overwritten with their encoded versions, but only one encoding method, smoothing, white noise, and seed are allowed. Otherwise, encoded predictors with their descriptive names are added to <code>df</code>. Default: FALSE</p>
</td></tr>
<tr><td><code id="target_encoding_lab_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito, PhD
</p>


<h3>References</h3>


<ul>
<li><p> Micci-Barreca, D. (2001) A Preprocessing Scheme for High-Cardinality Categorical Attributes in Classification and Prediction Problems. SIGKDD Explor. Newsl. 3, 1, 27-32. doi: 10.1145/507533.507538
</p>
</li></ul>



<h3>See Also</h3>

<p>Other target_encoding: 
<code><a href="#topic+target_encoding_mean">target_encoding_mean</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi,
  vi_predictors
  )

#subset to limit example run time
vi &lt;- vi[1:1000, ]

#applying all methods for a continuous response
df &lt;- target_encoding_lab(
  df = vi,
  response = "vi_numeric",
  predictors = "koppen_zone",
  methods = c(
    "mean",
    "loo",
    "rank"
  ),
  white_noise = c(0, 0.1, 0.2)
)

#identify encoded predictors
predictors.encoded &lt;- grep(
  pattern = "*__encoded*",
  x = colnames(df),
  value = TRUE
)


</code></pre>

<hr>
<h2 id='target_encoding_mean'>Target Encoding Methods</h2><span id='topic+target_encoding_mean'></span><span id='topic+target_encoding_rank'></span><span id='topic+target_encoding_loo'></span>

<h3>Description</h3>

<p>Target Encoding Methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target_encoding_mean(
  df = NULL,
  response = NULL,
  predictor = NULL,
  encoded_name = NULL,
  smoothing = 0
)

target_encoding_rank(
  df = NULL,
  response = NULL,
  predictor = NULL,
  encoded_name = NULL,
  smoothing = 0
)

target_encoding_loo(
  df = NULL,
  response = NULL,
  predictor = NULL,
  encoded_name = NULL,
  smoothing = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="target_encoding_mean_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="target_encoding_mean_+3A_response">response</code></td>
<td>
<p>(optional, character string) Name of a numeric response variable in <code>df</code>. Default: NULL.</p>
</td></tr>
<tr><td><code id="target_encoding_mean_+3A_predictor">predictor</code></td>
<td>
<p>(required; string) Name of the categorical predictor to encode. Default: NULL</p>
</td></tr>
<tr><td><code id="target_encoding_mean_+3A_encoded_name">encoded_name</code></td>
<td>
<p>(required, string) Name of the encoded predictor. Default: NULL</p>
</td></tr>
<tr><td><code id="target_encoding_mean_+3A_smoothing">smoothing</code></td>
<td>
<p>(optional; integer) Groups smaller than this number have their means pulled towards the mean of the response across all cases. Ignored by <code>target_encoding_rank()</code> and <code>target_encoding_loo()</code>. Default: 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other target_encoding: 
<code><a href="#topic+target_encoding_lab">target_encoding_lab</a>()</code>
</p>
<p>Other target_encoding: 
<code><a href="#topic+target_encoding_lab">target_encoding_lab</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vi)

#subset to limit example run time
vi &lt;- vi[1:1000, ]

#mean encoding
#-------------

#without noise
df &lt;- target_encoding_mean(
  df = vi,
  response = "vi_numeric",
  predictor = "soil_type",
  encoded_name = "soil_type_encoded"
)

plot(
  x = df$soil_type_encoded,
  y = df$vi_numeric,
  xlab = "encoded variable",
  ylab = "response"
)

#group rank
#----------

df &lt;- target_encoding_rank(
  df = vi,
  response = "vi_numeric",
  predictor = "soil_type",
  encoded_name = "soil_type_encoded"
)

plot(
  x = df$soil_type_encoded,
  y = df$vi_numeric,
  xlab = "encoded variable",
  ylab = "response"
)


#leave-one-out
#-------------

#without noise
df &lt;- target_encoding_loo(
  df = vi,
  response = "vi_numeric",
  predictor = "soil_type",
  encoded_name = "soil_type_encoded"
)

plot(
  x = df$soil_type_encoded,
  y = df$vi_numeric,
  xlab = "encoded variable",
  ylab = "response"
)
</code></pre>

<hr>
<h2 id='toy'>One response and four predictors with varying levels of multicollinearity</h2><span id='topic+toy'></span>

<h3>Description</h3>

<p>Data frame with known relationship between responses and predictors useful
to illustrate multicollinearity concepts. Created from <a href="#topic+vi">vi</a> using the code
shown in the example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(toy)
</code></pre>


<h3>Format</h3>

<p>Data frame with 2000 rows and 5 columns.
</p>


<h3>Details</h3>

<p>Columns:
</p>

<ul>
<li> <p><code>y</code>: response variable generated from <code>a * 0.75 + b * 0.25 + noise</code>.
</p>
</li>
<li> <p><code>a</code>: most important predictor of <code>y</code>, uncorrelated with <code>b</code>.
</p>
</li>
<li> <p><code>b</code>: second most important predictor of <code>y</code>, uncorrelated with <code>a</code>.
</p>
</li>
<li> <p><code>c</code>: generated from <code>a + noise</code>.
</p>
</li>
<li> <p><code>d</code>: generated from <code>(a + b)/2 + noise</code>.
</p>
</li></ul>

<p>These are variance inflation factors of the predictors in <code>toy</code>.
variable vif
b       4.062
d       6.804
c       13.263
a       16.161
</p>


<h3>See Also</h3>

<p>Other example_data: 
<code><a href="#topic+vi">vi</a></code>,
<code><a href="#topic+vi_predictors">vi_predictors</a></code>,
<code><a href="#topic+vi_predictors_categorical">vi_predictors_categorical</a></code>,
<code><a href="#topic+vi_predictors_numeric">vi_predictors_numeric</a></code>
</p>

<hr>
<h2 id='validate_data_cor'>Validate Data for Correlation Analysis</h2><span id='topic+validate_data_cor'></span>

<h3>Description</h3>

<p>Internal function to assess whether the input arguments <code>df</code> and <code>predictors</code> result in data dimensions suitable for pairwise correlation analysis.
</p>
<p>If the number of rows in <code>df</code> is smaller than 10, an error is issued.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_data_cor(
  df = NULL,
  predictors = NULL,
  function_name = "collinear::validate_data_cor()",
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_data_cor_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="validate_data_cor_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
<tr><td><code id="validate_data_cor_+3A_function_name">function_name</code></td>
<td>
<p>(optional, character string) Name of the function performing the check. Default: &quot;collinear::validate_data_cor()&quot;</p>
</td></tr>
<tr><td><code id="validate_data_cor_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector: predictors names
</p>


<h3>See Also</h3>

<p>Other data_validation: 
<code><a href="#topic+validate_data_vif">validate_data_vif</a>()</code>,
<code><a href="#topic+validate_df">validate_df</a>()</code>,
<code><a href="#topic+validate_encoding_arguments">validate_encoding_arguments</a>()</code>,
<code><a href="#topic+validate_predictors">validate_predictors</a>()</code>,
<code><a href="#topic+validate_preference_order">validate_preference_order</a>()</code>,
<code><a href="#topic+validate_response">validate_response</a>()</code>
</p>

<hr>
<h2 id='validate_data_vif'>Validate Data for VIF Analysis</h2><span id='topic+validate_data_vif'></span>

<h3>Description</h3>

<p>Internal function to assess whether the input arguments <code>df</code> and <code>predictors</code> result in data dimensions suitable for a VIF analysis.
</p>
<p>If the number of rows in <code>df</code> is smaller than 10 times the length of <code>predictors</code>, the function either issues a message and restricts <code>predictors</code> to a manageable number, or returns an error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_data_vif(
  df = NULL,
  predictors = NULL,
  function_name = "collinear::validate_data_vif()",
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_data_vif_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="validate_data_vif_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
<tr><td><code id="validate_data_vif_+3A_function_name">function_name</code></td>
<td>
<p>(optional, character string) Name of the function performing the check. Default: &quot;collinear::validate_data_vif()&quot;</p>
</td></tr>
<tr><td><code id="validate_data_vif_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector: predictors names
</p>


<h3>See Also</h3>

<p>Other data_validation: 
<code><a href="#topic+validate_data_cor">validate_data_cor</a>()</code>,
<code><a href="#topic+validate_df">validate_df</a>()</code>,
<code><a href="#topic+validate_encoding_arguments">validate_encoding_arguments</a>()</code>,
<code><a href="#topic+validate_predictors">validate_predictors</a>()</code>,
<code><a href="#topic+validate_preference_order">validate_preference_order</a>()</code>,
<code><a href="#topic+validate_response">validate_response</a>()</code>
</p>

<hr>
<h2 id='validate_df'>Validate Argument df</h2><span id='topic+validate_df'></span>

<h3>Description</h3>

<p>Internal function to validate the argument <code>df</code> and ensure it complies with the requirements of the package functions. It performs the following actions:
</p>

<ul>
<li><p> Stops if 'df' is NULL.
</p>
</li>
<li><p> Stops if 'df' cannot be coerced to data frame.
</p>
</li>
<li><p> Stops if 'df' has zero rows.
</p>
</li>
<li><p> Removes geometry column if the input data frame is an &quot;sf&quot; object.
</p>
</li>
<li><p> Removes non-numeric columns with as many unique values as rows df has.
</p>
</li>
<li><p> Converts logical columns to numeric.
</p>
</li>
<li><p> Converts factor and ordered columns to character.
</p>
</li>
<li><p> Tags the data frame with the attribute <code>validated = TRUE</code> to let the package functions skip the data validation.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>validate_df(df = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_df_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="validate_df_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>See Also</h3>

<p>Other data_validation: 
<code><a href="#topic+validate_data_cor">validate_data_cor</a>()</code>,
<code><a href="#topic+validate_data_vif">validate_data_vif</a>()</code>,
<code><a href="#topic+validate_encoding_arguments">validate_encoding_arguments</a>()</code>,
<code><a href="#topic+validate_predictors">validate_predictors</a>()</code>,
<code><a href="#topic+validate_preference_order">validate_preference_order</a>()</code>,
<code><a href="#topic+validate_response">validate_response</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(vi)

#validating example data frame
vi &lt;- validate_df(
  df = vi
)

#tagged as validated
attributes(vi)$validated
</code></pre>

<hr>
<h2 id='validate_encoding_arguments'>Validates Arguments of <code>target_encoding_lab()</code></h2><span id='topic+validate_encoding_arguments'></span>

<h3>Description</h3>

<p>Internal function to validate configuration arguments for <code><a href="#topic+target_encoding_lab">target_encoding_lab()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_encoding_arguments(
  df = NULL,
  response = NULL,
  predictors = NULL,
  methods = c("mean", "loo", "rank"),
  smoothing = 0,
  white_noise = 0,
  seed = 0,
  overwrite = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_encoding_arguments_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="validate_encoding_arguments_+3A_response">response</code></td>
<td>
<p>(optional, character string) Name of a numeric response variable in <code>df</code>. Default: NULL.</p>
</td></tr>
<tr><td><code id="validate_encoding_arguments_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
<tr><td><code id="validate_encoding_arguments_+3A_methods">methods</code></td>
<td>
<p>(optional; character vector or NULL). Name of the target encoding methods. If NULL, target encoding is ignored, and <code>df</code> is returned with no modification. Default: c(&quot;loo&quot;, &quot;mean&quot;, &quot;rank&quot;)</p>
</td></tr>
<tr><td><code id="validate_encoding_arguments_+3A_smoothing">smoothing</code></td>
<td>
<p>(optional; integer vector) Argument of the method &quot;mean&quot;. Groups smaller than this number have their means pulled towards the mean of the response across all cases. Default: 0</p>
</td></tr>
<tr><td><code id="validate_encoding_arguments_+3A_white_noise">white_noise</code></td>
<td>
<p>(optional; numeric vector) Argument of the methods &quot;mean&quot;, &quot;rank&quot;, and &quot;loo&quot;. Maximum white noise to add, expressed as a fraction of the range of the response variable. Range from 0 to 1. Default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="validate_encoding_arguments_+3A_seed">seed</code></td>
<td>
<p>(optional; integer vector) Random seed to facilitate reproducibility when <code>white_noise</code> is not 0. If NULL, the function selects one at random, and the selected seed does not appear in the encoded variable names. Default: 0</p>
</td></tr>
<tr><td><code id="validate_encoding_arguments_+3A_overwrite">overwrite</code></td>
<td>
<p>(optional; logical) If <code>TRUE</code>, the original predictors in <code>df</code> are overwritten with their encoded versions, but only one encoding method, smoothing, white noise, and seed are allowed. Otherwise, encoded predictors with their descriptive names are added to <code>df</code>. Default: FALSE</p>
</td></tr>
<tr><td><code id="validate_encoding_arguments_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>See Also</h3>

<p>Other data_validation: 
<code><a href="#topic+validate_data_cor">validate_data_cor</a>()</code>,
<code><a href="#topic+validate_data_vif">validate_data_vif</a>()</code>,
<code><a href="#topic+validate_df">validate_df</a>()</code>,
<code><a href="#topic+validate_predictors">validate_predictors</a>()</code>,
<code><a href="#topic+validate_preference_order">validate_preference_order</a>()</code>,
<code><a href="#topic+validate_response">validate_response</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>validate_encoding_arguments(
  df = vi,
  response = "vi_numeric",
  predictors = vi_predictors
  )
</code></pre>

<hr>
<h2 id='validate_predictors'>Validate Argument predictors</h2><span id='topic+validate_predictors'></span>

<h3>Description</h3>

<p>Internal function to validate the <code>predictors</code> argument. Requires the argument 'df' to be validated with <code><a href="#topic+validate_df">validate_df()</a></code>.
</p>
<p>Validates the 'predictors' argument to ensure it complies with the requirements of the package functions. It performs the following actions:
</p>

<ul>
<li><p> Stops if 'df' is NULL.
</p>
</li>
<li><p> Stops if 'df' is not validated.
</p>
</li>
<li><p> If 'predictors' is NULL, uses column names of 'df' as 'predictors' in the 'df' data frame.
</p>
</li>
<li><p> Print a message if there are names in 'predictors' not in the column names of 'df', and returns only the ones in 'df'.
</p>
</li>
<li><p> Stop if the number of numeric columns in 'predictors' is smaller than 'min_numerics'.
</p>
</li>
<li><p> Print a message if there are zero-variance columns in 'predictors' and returns a new 'predictors' argument without them.
</p>
</li>
<li><p> Tags the vector with the attribute <code>validated = TRUE</code> to let the package functions skip the data validation.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>validate_predictors(
  df = NULL,
  response = NULL,
  predictors = NULL,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_predictors_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="validate_predictors_+3A_response">response</code></td>
<td>
<p>(optional; character string or vector) Name/s of response variable/s in <code>df</code>. Used in target encoding when it names a numeric variable and there are categorical predictors, and to compute preference order. Default: NULL.</p>
</td></tr>
<tr><td><code id="validate_predictors_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
<tr><td><code id="validate_predictors_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector: predictor names
</p>


<h3>See Also</h3>

<p>Other data_validation: 
<code><a href="#topic+validate_data_cor">validate_data_cor</a>()</code>,
<code><a href="#topic+validate_data_vif">validate_data_vif</a>()</code>,
<code><a href="#topic+validate_df">validate_df</a>()</code>,
<code><a href="#topic+validate_encoding_arguments">validate_encoding_arguments</a>()</code>,
<code><a href="#topic+validate_preference_order">validate_preference_order</a>()</code>,
<code><a href="#topic+validate_response">validate_response</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi,
  vi_predictors
  )

#validating example data frame
vi &lt;- validate_df(
  df = vi
)

#validating example predictors
vi_predictors &lt;- validate_predictors(
  df = vi,
  predictors = vi_predictors
)

#tagged as validated
attributes(vi_predictors)$validated

</code></pre>

<hr>
<h2 id='validate_preference_order'>Validate Argument preference_order</h2><span id='topic+validate_preference_order'></span>

<h3>Description</h3>

<p>Internal function to validate the argument <code>preference_order</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_preference_order(
  predictors = NULL,
  preference_order = NULL,
  preference_order_auto = NULL,
  function_name = "collinear::validate_preference_order()",
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_preference_order_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
<tr><td><code id="validate_preference_order_+3A_preference_order">preference_order</code></td>
<td>
<p>(optional; string, character vector, output of <code><a href="#topic+preference_order">preference_order()</a></code>). Defines a priority order, from first to last, to preserve predictors during the selection process. Accepted inputs are:
</p>

<ul>
<li> <p><strong>&quot;auto&quot;</strong> (default): if <code>response</code> is not NULL, calls <code><a href="#topic+preference_order">preference_order()</a></code> for internal computation.
</p>
</li>
<li> <p><strong>character vector</strong>: predictor names in a custom preference order.
</p>
</li>
<li> <p><strong>data frame</strong>: output of <code><a href="#topic+preference_order">preference_order()</a></code> from <code>response</code> of length one.
</p>
</li>
<li> <p><strong>named list</strong>: output of <code><a href="#topic+preference_order">preference_order()</a></code> from <code>response</code> of length two or more.
</p>
</li>
<li> <p><strong>NULL</strong>: disabled.
</p>
</li></ul>
<p>. Default: &quot;auto&quot;</p>
</td></tr>
<tr><td><code id="validate_preference_order_+3A_preference_order_auto">preference_order_auto</code></td>
<td>
<p>(required, character vector) names of the predictors in the automated preference order returned by <code><a href="#topic+vif_select">vif_select()</a></code> or <code><a href="#topic+cor_select">cor_select()</a></code></p>
</td></tr>
<tr><td><code id="validate_preference_order_+3A_function_name">function_name</code></td>
<td>
<p>(optional, character string) Name of the function performing the check. Default: &quot;collinear::validate_preference_order()&quot;</p>
</td></tr>
<tr><td><code id="validate_preference_order_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector: ranked variable names
</p>


<h3>See Also</h3>

<p>Other data_validation: 
<code><a href="#topic+validate_data_cor">validate_data_cor</a>()</code>,
<code><a href="#topic+validate_data_vif">validate_data_vif</a>()</code>,
<code><a href="#topic+validate_df">validate_df</a>()</code>,
<code><a href="#topic+validate_encoding_arguments">validate_encoding_arguments</a>()</code>,
<code><a href="#topic+validate_predictors">validate_predictors</a>()</code>,
<code><a href="#topic+validate_response">validate_response</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(
  vi,
  vi_predictors
  )

#validating example data frame
vi &lt;- validate_df(
  df = vi
)

#validating example predictors
vi_predictors &lt;- validate_predictors(
  df = vi,
  predictors = vi_predictors
)

#tagged as validated
attributes(vi_predictors)$validated

#validate preference order
my_order &lt;- c(
  "swi_max",
  "swi_min",
  "swi_deviance" #wrong one
)

my_order &lt;- validate_preference_order(
  predictors = vi_predictors,
  preference_order = my_order,
  preference_order_auto = vi_predictors
)

#has my_order first
#excludes wrong names
#all other variables ordered according to preference_order_auto
my_order
</code></pre>

<hr>
<h2 id='validate_response'>Validate Argument response</h2><span id='topic+validate_response'></span>

<h3>Description</h3>

<p>Internal function to validate the argument <code>response</code>. Requires the argument 'df' to be validated with <code><a href="#topic+validate_df">validate_df()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_response(df = NULL, response = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="validate_response_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="validate_response_+3A_response">response</code></td>
<td>
<p>(optional; character string or vector) Name/s of response variable/s in <code>df</code>. Used in target encoding when it names a numeric variable and there are categorical predictors, and to compute preference order. Default: NULL.</p>
</td></tr>
<tr><td><code id="validate_response_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string: response name
</p>


<h3>See Also</h3>

<p>Other data_validation: 
<code><a href="#topic+validate_data_cor">validate_data_cor</a>()</code>,
<code><a href="#topic+validate_data_vif">validate_data_vif</a>()</code>,
<code><a href="#topic+validate_df">validate_df</a>()</code>,
<code><a href="#topic+validate_encoding_arguments">validate_encoding_arguments</a>()</code>,
<code><a href="#topic+validate_predictors">validate_predictors</a>()</code>,
<code><a href="#topic+validate_preference_order">validate_preference_order</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi
)

#validating example data frame
vi &lt;- validate_df(
  df = vi
)

#validating example predictors
response &lt;- validate_response(
  df = vi,
  response = "vi_numeric"
)

#tagged as validated
attributes(response)$validated

</code></pre>

<hr>
<h2 id='vi'>Example Data With Different Response and Predictor Types</h2><span id='topic+vi'></span>

<h3>Description</h3>

<p>The response variable is a Vegetation Index encoded in different ways to help highlight the package capabilities:
</p>

<ul>
<li> <p><code>vi_numeric</code>: continuous vegetation index values in the range 0-1.
</p>
</li>
<li> <p><code>vi_counts</code>: simulated integer counts created by multiplying <code>vi_numeric</code> by 1000 and coercing the result to integer.
</p>
</li>
<li> <p><code>vi_binomial</code>: simulated binomial variable created by transforming <code>vi_numeric</code> to zeros and ones.
</p>
</li>
<li> <p><code>vi_categorical</code>: character variable with the categories &quot;very_low&quot;, &quot;low&quot;, &quot;medium&quot;, &quot;high&quot;, and &quot;very_high&quot;, with thresholds located at the quantiles of <code>vi_numeric</code>.
</p>
</li>
<li> <p><code>vi_factor</code>: <code>vi_categorical</code> converted to factor.
</p>
</li></ul>

<p>The names of all predictors (continuous, integer, character, and factors) are in <a href="#topic+vi_predictors">vi_predictors</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vi)
</code></pre>


<h3>Format</h3>

<p>Data frame with 30.000 rows and 68 columns.
</p>


<h3>See Also</h3>

<p><a href="#topic+vi_predictors">vi_predictors</a>
</p>
<p>Other example_data: 
<code><a href="#topic+toy">toy</a></code>,
<code><a href="#topic+vi_predictors">vi_predictors</a></code>,
<code><a href="#topic+vi_predictors_categorical">vi_predictors_categorical</a></code>,
<code><a href="#topic+vi_predictors_numeric">vi_predictors_numeric</a></code>
</p>

<hr>
<h2 id='vi_predictors'>All Predictor Names in Example Data Frame vi</h2><span id='topic+vi_predictors'></span>

<h3>Description</h3>

<p>All Predictor Names in Example Data Frame vi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vi_predictors)
</code></pre>


<h3>Format</h3>

<p>Character vector with predictor names.
</p>


<h3>See Also</h3>

<p><a href="#topic+vi">vi</a>
</p>
<p>Other example_data: 
<code><a href="#topic+toy">toy</a></code>,
<code><a href="#topic+vi">vi</a></code>,
<code><a href="#topic+vi_predictors_categorical">vi_predictors_categorical</a></code>,
<code><a href="#topic+vi_predictors_numeric">vi_predictors_numeric</a></code>
</p>

<hr>
<h2 id='vi_predictors_categorical'>All Categorical and Factor Predictor Names in Example Data Frame vi</h2><span id='topic+vi_predictors_categorical'></span>

<h3>Description</h3>

<p>All Categorical and Factor Predictor Names in Example Data Frame vi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vi_predictors_categorical)
</code></pre>


<h3>Format</h3>

<p>Character vector with predictor names.
</p>


<h3>See Also</h3>

<p><a href="#topic+vi">vi</a>
</p>
<p>Other example_data: 
<code><a href="#topic+toy">toy</a></code>,
<code><a href="#topic+vi">vi</a></code>,
<code><a href="#topic+vi_predictors">vi_predictors</a></code>,
<code><a href="#topic+vi_predictors_numeric">vi_predictors_numeric</a></code>
</p>

<hr>
<h2 id='vi_predictors_numeric'>All Numeric Predictor Names in Example Data Frame vi</h2><span id='topic+vi_predictors_numeric'></span>

<h3>Description</h3>

<p>All Numeric Predictor Names in Example Data Frame vi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(vi_predictors_numeric)
</code></pre>


<h3>Format</h3>

<p>Character vector with predictor names.
</p>


<h3>See Also</h3>

<p><a href="#topic+vi">vi</a>
</p>
<p>Other example_data: 
<code><a href="#topic+toy">toy</a></code>,
<code><a href="#topic+vi">vi</a></code>,
<code><a href="#topic+vi_predictors">vi_predictors</a></code>,
<code><a href="#topic+vi_predictors_categorical">vi_predictors_categorical</a></code>
</p>

<hr>
<h2 id='vif_df'>Variance Inflation Factor</h2><span id='topic+vif_df'></span>

<h3>Description</h3>

<p>Computes the Variance Inflation Factor of numeric variables in a data frame.
</p>
<p>This function computes the VIF (see section <strong>Variance Inflation Factors</strong> below) in two steps:
</p>

<ul>
<li><p> Applies <code><a href="base.html#topic+solve">base::solve()</a></code> to obtain the precision matrix, which is the inverse of the covariance matrix between all variables in <code>predictors</code>.
</p>
</li>
<li><p> Uses <code><a href="base.html#topic+diag">base::diag()</a></code> to extract the diagonal of the precision matrix, which contains the variance of the prediction of each predictor from all other predictors, and represents the VIF.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>vif_df(df = NULL, predictors = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vif_df_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="vif_df_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
<tr><td><code id="vif_df_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame; predictors names their VIFs
</p>


<h3>Variance Inflation Factors</h3>

<p>The Variance Inflation Factor for a given variable <code class="reqn">a</code> is computed as <code class="reqn">1/(1-R2)</code>, where <code class="reqn">R2</code> is the multiple R-squared of a multiple regression model fitted using <code class="reqn">a</code> as response and all other predictors in the input data frame as predictors, as in  <code class="reqn">a = b + c + ...</code>.
</p>
<p>The square root of the VIF of <code class="reqn">a</code> is the factor by which the confidence interval of the estimate for <code class="reqn">a</code> in the linear model <code class="reqn">y = a + b + c + ...</code>' is widened by multicollinearity in the model predictors.
</p>
<p>The range of VIF values is (1, Inf]. The recommended thresholds for maximum VIF may vary depending on the source consulted, being the most common values, 2.5, 5, and 10.
</p>


<h3>References</h3>


<ul>
<li><p> David A. Belsley, D.A., Kuh, E., Welsch, R.E. (1980). Regression Diagnostics: Identifying Influential Data and Sources of Collinearity. John Wiley &amp; Sons. DOI: 10.1002/0471725153.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other vif: 
<code><a href="#topic+vif_select">vif_select</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(
  vi,
  vi_predictors_numeric
)

#subset to limit run time
df &lt;- vi[1:1000, ]

#apply pairwise correlation first
selection &lt;- cor_select(
  df = df,
  predictors = vi_predictors_numeric,
  quiet = TRUE
)

#VIF data frame
df &lt;- vif_df(
  df = df,
  predictors = selection
)

df

</code></pre>

<hr>
<h2 id='vif_select'>Automated Multicollinearity Filtering with Variance Inflation Factors</h2><span id='topic+vif_select'></span>

<h3>Description</h3>

<p>This function automatizes multicollinearity filtering in data frames with numeric predictors by combining two methods:
</p>

<ul>
<li> <p><strong>Preference Order</strong>: method to rank and preserve relevant variables during  multicollinearity filtering. See argument <code>preference_order</code> and function <code><a href="#topic+preference_order">preference_order()</a></code>.
</p>
</li>
<li> <p><strong>VIF-based filtering</strong>: recursive algorithm to identify and remove predictors with a VIF above a given threshold.
</p>
</li></ul>

<p>When the argument <code>preference_order</code> is not provided, the predictors are ranked lower to higher VIF. The predictor selection resulting from this option, albeit diverse and uncorrelated, might not be the one with the highest overall predictive power when used in a model.
</p>
<p>Please check the sections <strong>Preference Order</strong>, <strong>Variance Inflation Factors</strong>, and <strong>VIF-based Filtering</strong> at the end of this help file for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vif_select(
  df = NULL,
  predictors = NULL,
  preference_order = NULL,
  max_vif = 5,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vif_select_+3A_df">df</code></td>
<td>
<p>(required; data frame, tibble, or sf) A data frame with responses and predictors. Default: NULL.</p>
</td></tr>
<tr><td><code id="vif_select_+3A_predictors">predictors</code></td>
<td>
<p>(optional; character vector) Names of the predictors to select from <code>df</code>. If omitted, all numeric columns in <code>df</code> are used instead. If argument <code>response</code> is not provided, non-numeric variables are ignored. Default: NULL</p>
</td></tr>
<tr><td><code id="vif_select_+3A_preference_order">preference_order</code></td>
<td>
<p>(optional; string, character vector, output of <code><a href="#topic+preference_order">preference_order()</a></code>). Defines a priority order, from first to last, to preserve predictors during the selection process. Accepted inputs are:
</p>

<ul>
<li> <p><strong>&quot;auto&quot;</strong> (default): if <code>response</code> is not NULL, calls <code><a href="#topic+preference_order">preference_order()</a></code> for internal computation.
</p>
</li>
<li> <p><strong>character vector</strong>: predictor names in a custom preference order.
</p>
</li>
<li> <p><strong>data frame</strong>: output of <code><a href="#topic+preference_order">preference_order()</a></code> from <code>response</code> of length one.
</p>
</li>
<li> <p><strong>named list</strong>: output of <code><a href="#topic+preference_order">preference_order()</a></code> from <code>response</code> of length two or more.
</p>
</li>
<li> <p><strong>NULL</strong>: disabled.
</p>
</li></ul>
<p>. Default: &quot;auto&quot;</p>
</td></tr>
<tr><td><code id="vif_select_+3A_max_vif">max_vif</code></td>
<td>
<p>(optional, numeric) Maximum Variance Inflation Factor allowed during variable selection. Recommended values are between 2.5 and 10. Higher values return larger number of predictors with a higher multicollinearity. If NULL, the variance inflation analysis is disabled. Default: 5.</p>
</td></tr>
<tr><td><code id="vif_select_+3A_quiet">quiet</code></td>
<td>
<p>(optional; logical) If FALSE, messages generated during the execution of the function are printed to the console Default: FALSE</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> character vector if <code>response</code> is NULL or is a string.
</p>
</li>
<li><p> named list if <code>response</code> is a character vector.
</p>
</li></ul>



<h3>Preference Order</h3>

<p>This feature is designed to help protect important predictors during the multicollinearity filtering. It involves the arguments <code>preference_order</code> and <code>f</code>.
</p>
<p>The argument <code>preference_order</code> accepts:
</p>

<ul>
<li><p>: A character vector of predictor names in a custom order of preference, from first to last. This vector does not need to contain all predictor names, but only the ones relevant to the user.
</p>
</li>
<li><p> A data frame returned by <code><a href="#topic+preference_order">preference_order()</a></code>, which ranks predictors based on their association with a response variable.
</p>
</li>
<li><p> If NULL, and <code>response</code> is provided, then <code><a href="#topic+preference_order">preference_order()</a></code> is used internally to rank the predictors using the function <code>f</code>. If <code>f</code> is NULL as well, then <code><a href="#topic+f_auto">f_auto()</a></code> selects a proper function based on the data properties.
</p>
</li></ul>



<h3>Variance Inflation Factors</h3>

<p>The Variance Inflation Factor for a given variable <code class="reqn">a</code> is computed as <code class="reqn">1/(1-R2)</code>, where <code class="reqn">R2</code> is the multiple R-squared of a multiple regression model fitted using <code class="reqn">a</code> as response and all other predictors in the input data frame as predictors, as in  <code class="reqn">a = b + c + ...</code>.
</p>
<p>The square root of the VIF of <code class="reqn">a</code> is the factor by which the confidence interval of the estimate for <code class="reqn">a</code> in the linear model <code class="reqn">y = a + b + c + ...</code>' is widened by multicollinearity in the model predictors.
</p>
<p>The range of VIF values is (1, Inf]. The recommended thresholds for maximum VIF may vary depending on the source consulted, being the most common values, 2.5, 5, and 10.
</p>


<h3>VIF-based Filtering</h3>

<p>The function <code><a href="#topic+vif_select">vif_select()</a></code> computes Variance Inflation Factors and removes variables iteratively, until all variables in the resulting selection have a VIF below <code>max_vif</code>.
</p>
<p>If the argument <code>preference_order</code> is not provided, all variables are ranked from lower to higher VIF, as returned by <code><a href="#topic+vif_df">vif_df()</a></code>, and the variable with the higher VIF above <code>max_vif</code> is removed on each iteration.
</p>
<p>If <code>preference_order</code> is defined, whenever two or more variables are above <code>max_vif</code>, the one higher in <code>preference_order</code> is preserved, and the next one with a higher VIF is removed. For example, for the predictors and preference order <code class="reqn">a</code> and <code class="reqn">b</code>, if any of their VIFs is higher than <code>max_vif</code>, then <code class="reqn">b</code> will be removed no matter whether its VIF is lower or higher than <code class="reqn">a</code>'s VIF. If their VIF scores are lower than <code>max_vif</code>, then both are preserved.
</p>


<h3>Author(s)</h3>

<p>Blas M. Benito, PhD
</p>


<h3>References</h3>


<ul>
<li><p> David A. Belsley, D.A., Kuh, E., Welsch, R.E. (1980). Regression Diagnostics: Identifying Influential Data and Sources of Collinearity. John Wiley &amp; Sons. DOI: 10.1002/0471725153.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other vif: 
<code><a href="#topic+vif_df">vif_df</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#subset to limit example run time
df &lt;- vi[1:1000, ]
predictors &lt;- vi_predictors[1:10]
predictors_numeric &lt;- vi_predictors_numeric[1:10]

#predictors has mixed types
sapply(
  X = df[, predictors, drop = FALSE],
  FUN = class
)

#categorical predictors are ignored
x &lt;- vif_select(
  df = df,
  predictors = predictors,
  max_vif = 2.5
)

x

#all these have a VIF lower than max_vif (2.5)
vif_df(
  df = df,
  predictors = x
)


#higher max_vif results in larger selection
x &lt;- vif_select(
  df = df,
  predictors = predictors_numeric,
  max_vif = 10
)

x


#smaller max_vif results in smaller selection
x &lt;- vif_select(
  df = df,
  predictors = predictors_numeric,
  max_vif = 2.5
)

x


#custom preference order
x &lt;- vif_select(
  df = df,
  predictors = predictors_numeric,
  preference_order = c(
    "swi_mean",
    "soil_temperature_mean",
    "topo_elevation"
  ),
  max_vif = 2.5
)

x

#using automated preference order
df_preference &lt;- preference_order(
  df = df,
  response = "vi_numeric",
  predictors = predictors_numeric
)

x &lt;- vif_select(
  df = df,
  predictors = predictors_numeric,
  preference_order = df_preference,
  max_vif = 2.5
)

x


#categorical predictors are ignored
#the function returns NA
x &lt;- vif_select(
  df = df,
  predictors = vi_predictors_categorical
)

x


#if predictors has length 1
#selection is skipped
#and data frame with one row is returned
x &lt;- vif_select(
  df = df,
  predictors = predictors_numeric[1]
)

x
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
