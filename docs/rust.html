<!DOCTYPE html><html><head><title>Help for package rust</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rust}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#create_log_j_xptr'><p>Create external pointer to a C++ function for <code>log_j</code></p></a></li>
<li><a href='#create_phi_to_theta_xptr'><p>Create external pointer to a C++ function for <code>phi_to_theta</code></p></a></li>
<li><a href='#create_xptr'><p>Create external pointer to a C++ function for <code>logf</code></p></a></li>
<li><a href='#find_lambda'><p>Selecting the Box-Cox parameter for general d</p></a></li>
<li><a href='#find_lambda_one_d'><p>Selecting the Box-Cox parameter in the 1D case</p></a></li>
<li><a href='#find_lambda_one_d_rcpp'><p>Selecting the Box-Cox parameter in the 1D case using Rcpp</p></a></li>
<li><a href='#find_lambda_rcpp'><p>Selecting the Box-Cox parameter for general d using Rcpp</p></a></li>
<li><a href='#gpd_init'><p>Initial estimates for Generalized Pareto parameters</p></a></li>
<li><a href='#gpd_logpost'><p>Generalized Pareto posterior log-density</p></a></li>
<li><a href='#gpd_sum_stats'><p>Generalized Pareto summary statistics</p></a></li>
<li><a href='#plot.ru'><p>Plot diagnostics for an ru object</p></a></li>
<li><a href='#print.ru'><p>Print method for an <code>"ru"</code> object</p></a></li>
<li><a href='#rgpd'><p>Generalized Pareto simulation</p></a></li>
<li><a href='#ru'><p>Generalized ratio-of-uniforms sampling</p></a></li>
<li><a href='#ru_rcpp'><p>Generalized ratio-of-uniforms sampling using C++ via Rcpp</p></a></li>
<li><a href='#rust-internal'><p>Internal rust functions</p></a></li>
<li><a href='#rust-package'><p>rust: Ratio-of-Uniforms Simulation with Transformation</p></a></li>
<li><a href='#summary.ru'><p>Summarizing ratio-of-uniforms samples</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Ratio-of-Uniforms Simulation with Transformation</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-02</td>
</tr>
<tr>
<td>Description:</td>
<td>Uses the generalized ratio-of-uniforms (RU) method to simulate
    from univariate and (low-dimensional) multivariate continuous distributions.
    The user specifies the log-density, up to an additive constant. The RU
    algorithm is applied after relocation of mode of the density to zero, and
    the user can choose a tuning parameter r. For details see Wakefield, Gelfand
    and Smith (1991) &lt;<a href="https://doi.org/10.1007%2FBF01889987">doi:10.1007/BF01889987</a>&gt;, Efficient generation of random
    variates via the ratio-of-uniforms method, Statistics and Computing (1991)
    1, 129-133.  A Box-Cox variable transformation can be used to make the input
    density suitable for the RU method and to improve efficiency.  In the
    multivariate case rotation of axes can also be used to improve efficiency.
    From version 1.2.0 the 'Rcpp' package 
    <a href="https://cran.r-project.org/package=Rcpp">https://cran.r-project.org/package=Rcpp</a> can be used to improve efficiency.</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, Rcpp (&ge; 0.12.10), stats</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bang, knitr, microbenchmark, revdbayes, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://paulnorthrop.github.io/rust/">https://paulnorthrop.github.io/rust/</a>,
<a href="https://github.com/paulnorthrop/rust">https://github.com/paulnorthrop/rust</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/paulnorthrop/rust/issues">https://github.com/paulnorthrop/rust/issues</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 0.12.10), RcppArmadillo</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-02 17:14:01 UTC; Paul</td>
</tr>
<tr>
<td>Author:</td>
<td>Paul J. Northrop [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul J. Northrop &lt;p.northrop@ucl.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-02 17:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='create_log_j_xptr'>Create external pointer to a C++ function for <code>log_j</code></h2><span id='topic+create_log_j_xptr'></span>

<h3>Description</h3>

<p>Create external pointer to a C++ function for <code>log_j</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_log_j_xptr(fstr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_log_j_xptr_+3A_fstr">fstr</code></td>
<td>
<p>A string indicating the C++ function required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="https://cran.r-project.org/package=rust">
Rusting faster: Simulation using Rcpp</a> vignette.
</p>


<h3>Examples</h3>

<p>See the examples in <code><a href="#topic+ru_rcpp">ru_rcpp</a></code>.
</p>

<hr>
<h2 id='create_phi_to_theta_xptr'>Create external pointer to a C++ function for <code>phi_to_theta</code></h2><span id='topic+create_phi_to_theta_xptr'></span>

<h3>Description</h3>

<p>Create external pointer to a C++ function for <code>phi_to_theta</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_phi_to_theta_xptr(fstr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_phi_to_theta_xptr_+3A_fstr">fstr</code></td>
<td>
<p>A string indicating the C++ function required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="https://cran.r-project.org/package=rust">
Rusting faster: Simulation using Rcpp</a> vignette.
</p>


<h3>Examples</h3>

<p>See the examples in <code><a href="#topic+ru_rcpp">ru_rcpp</a></code>.
</p>

<hr>
<h2 id='create_xptr'>Create external pointer to a C++ function for <code>logf</code></h2><span id='topic+create_xptr'></span>

<h3>Description</h3>

<p>Create external pointer to a C++ function for <code>logf</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_xptr(fstr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_xptr_+3A_fstr">fstr</code></td>
<td>
<p>A string indicating the C++ function required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the <a href="https://cran.r-project.org/package=rust">
Rusting faster: Simulation using Rcpp</a> vignette.
</p>


<h3>Examples</h3>

<p>See the examples in <code><a href="#topic+ru_rcpp">ru_rcpp</a></code>.
</p>

<hr>
<h2 id='find_lambda'>Selecting the Box-Cox parameter for general d</h2><span id='topic+find_lambda'></span>

<h3>Description</h3>

<p>Finds a value of the Box-Cox transformation parameter lambda for which
the (positive) random variable with log-density <code class="reqn">\log f</code> has a
density  closer to that of a Gaussian random variable.
In the following we use <code>theta</code> (<code class="reqn">\theta</code>) to denote the argument
of <code class="reqn">\log f</code> on the original scale and <code>phi</code> (<code class="reqn">\phi</code>) on
the Box-Cox transformed scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_lambda(
  logf,
  ...,
  d = 1,
  n_grid = NULL,
  ep_bc = 1e-04,
  min_phi = rep(ep_bc, d),
  max_phi = rep(10, d),
  which_lam = 1:d,
  lambda_range = c(-3, 3),
  init_lambda = NULL,
  phi_to_theta = NULL,
  log_j = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_lambda_+3A_logf">logf</code></td>
<td>
<p>A function returning the log of the target density <code class="reqn">f</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>logf</code> and related
functions.</p>
</td></tr>
<tr><td><code id="find_lambda_+3A_d">d</code></td>
<td>
<p>A numeric scalar. Dimension of <code class="reqn">f</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_+3A_n_grid">n_grid</code></td>
<td>
<p>A numeric scalar.  Number of ordinates for each variable in
<code>phi</code>.  If this is not supplied a default value of
<code>ceiling(2501 ^ (1 / d))</code> is used.</p>
</td></tr>
<tr><td><code id="find_lambda_+3A_ep_bc">ep_bc</code></td>
<td>
<p>A (positive) numeric scalar. Smallest possible value of
<code>phi</code> to consider.  Used to avoid negative values of <code>phi</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_+3A_min_phi">min_phi</code>, <code id="find_lambda_+3A_max_phi">max_phi</code></td>
<td>
<p>Numeric vectors.  Smallest and largest values
of <code>phi</code> at which to evaluate <code>logf</code>, i.e. the range of values
of phi over which to evaluate <code>logf</code>. Any components in
<code>min_phi</code> that are not positive are set to <code>ep_bc</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_+3A_which_lam">which_lam</code></td>
<td>
<p>A numeric vector.  Contains the indices of the components
of <code>phi</code> that ARE to be Box-Cox transformed.</p>
</td></tr>
<tr><td><code id="find_lambda_+3A_lambda_range">lambda_range</code></td>
<td>
<p>A numeric vector of length 2.  Range of lambda over
which to optimise.</p>
</td></tr>
<tr><td><code id="find_lambda_+3A_init_lambda">init_lambda</code></td>
<td>
<p>A numeric vector of length 1 or <code>d</code>.  Initial value
of lambda used in the search for the best lambda.  If <code>init_lambda</code>
is a scalar then <code>rep(init_lambda, d)</code> is used.</p>
</td></tr>
<tr><td><code id="find_lambda_+3A_phi_to_theta">phi_to_theta</code></td>
<td>
<p>A function returning (inverse) of the transformation
from <code>theta</code> to <code>phi</code> used to ensure positivity of <code>phi</code>
prior to Box-Cox transformation.  The argument is <code>phi</code> and the
returned value is <code>theta</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_+3A_log_j">log_j</code></td>
<td>
<p>A function returning the log of the Jacobian of the
transformation from <code>theta</code> to <code>phi</code>, i.e. based on derivatives
of <code>phi</code> with respect to <code>theta</code>. Takes <code>theta</code> as its
argument.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general idea is to evaluate the density <code class="reqn">f</code> on a
<code>d</code>-dimensional grid, with <code>n_grid</code> ordinates for each of the
<code>d</code> variables.
We treat each combination of the variables in the grid as a data point
and perform an estimation of the Box-Cox transformation parameter
lambda, in which each data point is weighted by the density
at that point.  The vectors <code>min_phi</code> and <code>max_phi</code> define the
limits of the grid and <code>which_lam</code> can be used to specify that only
certain components of <code>phi</code> are to be transformed.
</p>


<h3>Value</h3>

<p>A list containing the following components
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>A numeric vector.  The value of lambda.</p>
</td></tr>
<tr><td><code>gm</code></td>
<td>
<p>A numeric vector.  Box-cox scaling parameter, estimated by the
geometric mean of the values of <code>phi</code> used in the optimisation to
find the value of lambda, weighted by the values of <code class="reqn">f</code> evaluated at
<code>phi</code>.</p>
</td></tr>
<tr><td><code>init_psi</code></td>
<td>
<p>A numeric vector.  An initial estimate of the mode of the
Box-Cox transformed density</p>
</td></tr>
<tr><td><code>sd_psi</code></td>
<td>
<p>A numeric vector.  Estimates of the marginal standard
deviations of the Box-Cox transformed variables.</p>
</td></tr>
<tr><td><code>phi_to_theta</code></td>
<td>
<p>as detailed above (only if <code>phi_to_theta</code> is
supplied)</p>
</td></tr>
<tr><td><code>log_j</code></td>
<td>
<p>as detailed above (only if <code>log_j</code> is supplied)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Box, G. and Cox, D. R. (1964) An Analysis of Transformations.
Journal of the Royal Statistical Society. Series B (Methodological), 26(2),
211-252.
</p>
<p>Andrews, D. F. and Gnanadesikan, R. and Warner, J. L. (1971)
Transformations of Multivariate Data, Biometrics, 27(4).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ru">ru</a></code> and <code><a href="#topic+ru_rcpp">ru_rcpp</a></code> to perform
ratio-of-uniforms sampling.
</p>
<p><code><a href="#topic+find_lambda_one_d">find_lambda_one_d</a></code> and
<code><a href="#topic+find_lambda_one_d_rcpp">find_lambda_one_d_rcpp</a></code> to produce (somewhat) automatically
a list for the argument lambda of <code>ru</code>/<code>ru_rcpp</code> for the
<code>d</code> = 1 case.
</p>
<p><code><a href="#topic+find_lambda_rcpp">find_lambda_rcpp</a></code> for a version of
<code><a href="#topic+find_lambda">find_lambda</a></code> that uses the Rcpp package to improve
efficiency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Log-normal density ===================
# Note: the default value max_phi = 10 is OK here but this will not always
# be the case
lambda &lt;- find_lambda(logf = dlnorm, log = TRUE)
lambda
x &lt;- ru(logf = dlnorm, log = TRUE, d = 1, n = 1000, trans = "BC",
        lambda = lambda)

# Gamma density ===================
alpha &lt;- 1
#  Choose a sensible value of max_phi
max_phi &lt;- qgamma(0.999, shape = alpha)
# [Of course, typically the quantile function won't be available.  However,
# In practice the value of lambda chosen is quite insensitive to the choice
# of max_phi, provided that max_phi is not far too large or far too small.]

lambda &lt;- find_lambda(logf = dgamma, shape = alpha, log = TRUE,
                      max_phi = max_phi)
lambda
x &lt;- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,
        trans = "BC", lambda = lambda)


# Generalized Pareto posterior distribution ===================

# Sample data from a GP(sigma, xi) distribution
gpd_data &lt;- rgpd(m = 100, xi = -0.5, sigma = 1)
# Calculate summary statistics for use in the log-likelihood
ss &lt;- gpd_sum_stats(gpd_data)
# Calculate an initial estimate
init &lt;- c(mean(gpd_data), 0)

n &lt;- 1000
# Sample on original scale, with no rotation ----------------
x1 &lt;- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, init = init,
  lower = c(0, -Inf), rotate = FALSE)
plot(x1, xlab = "sigma", ylab = "xi")
# Parameter constraint line xi &gt; -sigma/max(data)
# [This may not appear if the sample is far from the constraint.]
abline(a = 0, b = -1 / ss$xm)
summary(x1)

# Sample on original scale, with rotation ----------------
x2 &lt;- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, init = init,
  lower = c(0, -Inf))
plot(x2, xlab = "sigma", ylab = "xi")
abline(a = 0, b = -1 / ss$xm)
summary(x2)

# Sample on Box-Cox transformed scale ----------------

# Find initial estimates for phi = (phi1, phi2),
# where phi1 = sigma
#   and phi2 = xi + sigma / max(x),
# and ranges of phi1 and phi2 over over which to evaluate
# the posterior to find a suitable value of lambda.
temp &lt;- do.call(gpd_init, ss)
min_phi &lt;- pmax(0, temp$init_phi - 2 * temp$se_phi)
max_phi &lt;- pmax(0, temp$init_phi + 2 * temp$se_phi)

# Set phi_to_theta() that ensures positivity of phi
# We use phi1 = sigma and phi2 = xi + sigma / max(data)
phi_to_theta &lt;- function(phi) c(phi[1], phi[2] - phi[1] / ss$xm)
log_j &lt;- function(x) 0

lambda &lt;- find_lambda(logf = gpd_logpost, ss = ss, d = 2, min_phi = min_phi,
  max_phi = max_phi, phi_to_theta = phi_to_theta, log_j = log_j)
lambda

# Sample on Box-Cox transformed, without rotation
x3 &lt;- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, trans = "BC",
  lambda = lambda, rotate = FALSE)
plot(x3, xlab = "sigma", ylab = "xi")
abline(a = 0, b = -1 / ss$xm)
summary(x3)

# Sample on Box-Cox transformed, with rotation
x4 &lt;- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, trans = "BC",
  lambda = lambda)
plot(x4, xlab = "sigma", ylab = "xi")
abline(a = 0, b = -1 / ss$xm)
summary(x4)

def_par &lt;- graphics::par(no.readonly = TRUE)
par(mfrow = c(2,2), mar = c(4, 4, 1.5, 1))
plot(x1, xlab = "sigma", ylab = "xi", ru_scale = TRUE,
  main = "mode relocation")
plot(x2, xlab = "sigma", ylab = "xi", ru_scale = TRUE,
  main = "mode relocation and rotation")
plot(x3, xlab = "sigma", ylab = "xi", ru_scale = TRUE,
  main = "Box-Cox and mode relocation")
plot(x4, xlab = "sigma", ylab = "xi", ru_scale = TRUE,
  main = "Box-Cox, mode relocation and rotation")
graphics::par(def_par)

</code></pre>

<hr>
<h2 id='find_lambda_one_d'>Selecting the Box-Cox parameter in the 1D case</h2><span id='topic+find_lambda_one_d'></span>

<h3>Description</h3>

<p>Finds a value of the Box-Cox transformation parameter lambda (<code class="reqn">\lambda</code>)
for which the (positive univariate) random variable with log-density
<code class="reqn">\log f</code> has a density closer to that of a Gaussian random
variable. Works by estimating a set of quantiles of the distribution implied
by <code class="reqn">\log f</code> and treating those quantiles as data in a standard
Box-Cox analysis.  In the following we use <code>theta</code> (<code class="reqn">\theta</code>) to
denote the argument of <code class="reqn">\log f</code> on the original scale and
<code>phi</code> (<code class="reqn">\phi</code>) on the Box-Cox transformed scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_lambda_one_d(
  logf,
  ...,
  ep_bc = 1e-04,
  min_phi = ep_bc,
  max_phi = 10,
  num = 1001,
  xdiv = 100,
  probs = seq(0.01, 0.99, by = 0.01),
  lambda_range = c(-3, 3),
  phi_to_theta = NULL,
  log_j = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_lambda_one_d_+3A_logf">logf</code></td>
<td>
<p>A function returning the log of the target density <code class="reqn">f</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>logf</code> and related
functions.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_+3A_ep_bc">ep_bc</code></td>
<td>
<p>A (positive) numeric scalar. Smallest possible value of
<code>phi</code> to consider.  Used to avoid negative values of <code>phi</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_+3A_min_phi">min_phi</code>, <code id="find_lambda_one_d_+3A_max_phi">max_phi</code></td>
<td>
<p>Numeric scalars.  Smallest and largest values
of <code>phi</code> at which to evaluate <code>logf</code>, i.e., the range of values
of <code>phi</code> over which to evaluate <code>logf</code>. Any components in
<code>min_phi</code> that are not positive are set to <code>ep_bc</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_+3A_num">num</code></td>
<td>
<p>A numeric scalar. Number of values at which to evaluate
<code>logf</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_+3A_xdiv">xdiv</code></td>
<td>
<p>A numeric scalar.  Only values of <code>phi</code> at which the
density <code class="reqn">f</code> is greater than the (maximum of <code class="reqn">f</code>) / <code>xdiv</code> are
used.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_+3A_probs">probs</code></td>
<td>
<p>A numeric scalar. Probabilities at which to estimate the
quantiles of that will be used as data to find lambda.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_+3A_lambda_range">lambda_range</code></td>
<td>
<p>A numeric vector of length 2.  Range of lambda
over which to optimise.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_+3A_phi_to_theta">phi_to_theta</code></td>
<td>
<p>A function returning (inverse) of the transformation
from <code>theta</code> to <code>phi</code> used to ensure positivity of <code>phi</code>
prior to Box-Cox transformation.  The argument is <code>phi</code> and the
returned value is <code>theta</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_+3A_log_j">log_j</code></td>
<td>
<p>A function returning the log of the Jacobian of the
transformation from <code>theta</code> to <code>phi</code>, i.e. based on derivatives
of <code class="reqn">phi</code> with respect to <code class="reqn">theta</code>. Takes <code>theta</code> as its
argument. If this is not supplied then a constant Jacobian is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general idea is to estimate quantiles of <code class="reqn">f</code> corresponding
to a set of equally-spaced probabilities in <code>probs</code> and to use these
estimated quantiles as data in a standard estimation of the Box-Cox
transformation parameter lambda.
</p>
<p>The density <code>f</code> is first evaluated at <code>num</code> points equally
spaced over the interval (<code>min_phi</code>, <code>max_phi</code>).  The continuous
density <code class="reqn">f</code> is approximated by attaching trapezium-rule estimates of
probabilities to the midpoints of the intervals between the points.  After
standardizing to account for the fact that <code class="reqn">f</code> may not be normalized,
(<code>min_phi</code>, <code>max_phi</code>) is reset so that values with small
estimated probability (determined by <code>xdiv</code>) are excluded and the
procedure is repeated on this new range.  Then the required quantiles are
estimated by inferring them from a weighted empirical distribution
function based on treating the midpoints as data and the estimated
probabilities at the midpoints as weights.
</p>


<h3>Value</h3>

<p>A list containing the following components
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>A numeric scalar.  The value of lambda.</p>
</td></tr>
<tr><td><code>gm</code></td>
<td>
<p>A numeric scalar.  Box-cox scaling parameter, estimated by the
geometric mean of the quantiles used in the optimisation to find the
value of lambda.</p>
</td></tr>
<tr><td><code>init_psi</code></td>
<td>
<p>A numeric scalar.  An initial estimate of the mode of the
Box-Cox transformed density</p>
</td></tr>
<tr><td><code>sd_psi</code></td>
<td>
<p>A numeric scalar.  Estimates of the marginal standard
deviations of the Box-Cox transformed variables.</p>
</td></tr>
<tr><td><code>phi_to_theta</code></td>
<td>
<p>as detailed above (only if <code>phi_to_theta</code> is
supplied)</p>
</td></tr>
<tr><td><code>log_j</code></td>
<td>
<p>as detailed above (only if <code>log_j</code> is supplied)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Box, G. and Cox, D. R. (1964) An Analysis of Transformations.
Journal of the Royal Statistical Society. Series B (Methodological), 26(2),
211-252.
</p>
<p>Andrews, D. F. and Gnanadesikan, R. and Warner, J. L. (1971)
Transformations of Multivariate Data, Biometrics, 27(4).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ru">ru</a></code> and <code><a href="#topic+ru_rcpp">ru_rcpp</a></code> to perform
ratio-of-uniforms sampling.
</p>
<p><code><a href="#topic+find_lambda">find_lambda</a></code> and <code><a href="#topic+find_lambda_rcpp">find_lambda_rcpp</a></code>
to produce (somewhat) automatically
a list for the argument lambda of <code>ru</code>/<code>ru_rcpp</code>
for any value of <code>d</code>.
</p>
<p><code><a href="#topic+find_lambda_one_d_rcpp">find_lambda_one_d_rcpp</a></code> for a version of
<code><a href="#topic+find_lambda_one_d">find_lambda_one_d</a></code> that uses the Rcpp package to improve
efficiency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Log-normal density ===================

# Note: the default value of max_phi = 10 is OK here but this will not
# always be the case.

lambda &lt;- find_lambda_one_d(logf = dlnorm, log = TRUE)
lambda
x &lt;- ru(logf = dlnorm, log = TRUE, d = 1, n = 1000, trans = "BC",
        lambda = lambda)

# Gamma density ===================

alpha &lt;- 1
# Choose a sensible value of max_phi
max_phi &lt;- qgamma(0.999, shape = alpha)
# [I appreciate that typically the quantile function won't be available.
# In practice the value of lambda chosen is quite insensitive to the choice
# of max_phi, provided that max_phi is not far too large or far too small.]

lambda &lt;- find_lambda_one_d(logf = dgamma, shape = alpha, log = TRUE,
                            max_phi = max_phi)
lambda
x &lt;- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,
        trans = "BC", lambda = lambda)

alpha &lt;- 0.1
# NB. for alpha &lt; 1 the gamma(alpha, beta) density is not bounded
# So the ratio-of-uniforms emthod can't be used but it may work after a
# Box-Cox transformation.
# find_lambda_one_d() works much better than find_lambda() here.

max_phi &lt;- qgamma(0.999, shape = alpha)
lambda &lt;- find_lambda_one_d(logf = dgamma, shape = alpha, log = TRUE,
                            max_phi = max_phi)
lambda
x &lt;- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,
        trans = "BC", lambda = lambda)


plot(x)
plot(x, ru_scale = TRUE)

</code></pre>

<hr>
<h2 id='find_lambda_one_d_rcpp'>Selecting the Box-Cox parameter in the 1D case using Rcpp</h2><span id='topic+find_lambda_one_d_rcpp'></span>

<h3>Description</h3>

<p>Finds a value of the Box-Cox transformation parameter lambda for which
the (positive univariate) random variable with log-density
<code class="reqn">\log f</code> has a density closer to that of a Gaussian random
variable. Works by estimating a set of quantiles of the distribution implied
by <code class="reqn">\log f</code> and treating those quantiles as data in a standard
Box-Cox analysis.  In the following we use <code>theta</code> (<code class="reqn">\theta</code>) to
denote the argument of <code class="reqn">\log f</code> on the original scale and
<code>phi</code> (<code class="reqn">\phi</code>) on the Box-Cox transformed scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_lambda_one_d_rcpp(
  logf,
  ...,
  ep_bc = 1e-04,
  min_phi = ep_bc,
  max_phi = 10,
  num = 1001L,
  xdiv = 100,
  probs = seq(0.01, 0.99, by = 0.01),
  lambda_range = c(-3, 3),
  phi_to_theta = NULL,
  log_j = NULL,
  user_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_lambda_one_d_rcpp_+3A_logf">logf</code></td>
<td>
<p>A pointer to a compiled C++ function returning the log
of the target density <code class="reqn">f</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_rcpp_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>logf</code> and related
functions.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_rcpp_+3A_ep_bc">ep_bc</code></td>
<td>
<p>A (positive) numeric scalar. Smallest possible value of
<code>phi</code> to consider.  Used to avoid negative values of <code>phi</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_rcpp_+3A_min_phi">min_phi</code>, <code id="find_lambda_one_d_rcpp_+3A_max_phi">max_phi</code></td>
<td>
<p>Numeric scalars.  Smallest and largest values
of <code>phi</code> at which to evaluate <code>logf</code>, i.e., the range of values
of <code>phi</code> over which to evaluate <code>logf</code>. Any components in
<code>min_phi</code> that are not positive are set to <code>ep_bc</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_rcpp_+3A_num">num</code></td>
<td>
<p>A numeric scalar. Number of values at which to evaluate
<code>logf</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_rcpp_+3A_xdiv">xdiv</code></td>
<td>
<p>A numeric scalar.  Only values of <code>phi</code> at which the
density <code class="reqn">f</code> is greater than the (maximum of <code class="reqn">f</code>) / <code>xdiv</code> are
used.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_rcpp_+3A_probs">probs</code></td>
<td>
<p>A numeric scalar. Probabilities at which to estimate the
quantiles of that will be used as data to find lambda.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_rcpp_+3A_lambda_range">lambda_range</code></td>
<td>
<p>A numeric vector of length 2.  Range of lambda over
which to optimise.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_rcpp_+3A_phi_to_theta">phi_to_theta</code></td>
<td>
<p>A pointer to a compiled C++ function returning
(the inverse) of the transformation from <code>theta</code> to <code>phi</code> used
to ensure positivity of <code>phi</code> prior to Box-Cox transformation.  The
argument is <code>phi</code> and the returned value is <code>theta</code>.  If
<code>phi_to_theta</code> is undefined at the input value then the function
should return <code>NA</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_rcpp_+3A_log_j">log_j</code></td>
<td>
<p>A pointer to a compiled C++ function returning the log of
the Jacobian of the transformation from <code>theta</code> to <code>phi</code>, i.e.,
based on derivatives of <code class="reqn">phi</code> with respect to <code class="reqn">theta</code>. Takes
<code>theta</code> as its argument.
If this is not supplied then a constant Jacobian is used.</p>
</td></tr>
<tr><td><code id="find_lambda_one_d_rcpp_+3A_user_args">user_args</code></td>
<td>
<p>A list of numeric components providing arguments to
the user-supplied functions <code>phi_to_theta</code> and <code>log_j</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general idea is to estimate quantiles of <code class="reqn">f</code> corresponding
to a set of equally-spaced probabilities in <code>probs</code> and to use these
estimated quantiles as data in a standard estimation of the Box-Cox
transformation parameter <code>lambda</code>.
</p>
<p>The density <code class="reqn">f</code> is first evaluated at <code>num</code> points equally spaced
over the interval (<code>min_phi</code>, <code>max_phi</code>).  The continuous
density <code class="reqn">f</code> is approximated by attaching trapezium-rule estimates of
probabilities to the midpoints of the intervals between the points.  After
standardizing to account for the fact that <code class="reqn">f</code> may not be normalized,
(<code>min_phi</code>, <code>max_phi</code>) is reset so that values with small
estimated probability (determined by <code>xdiv</code>) are excluded and the
procedure is repeated on this new range.  Then the required quantiles are
estimated by inferring them from a weighted empirical distribution
function based on treating the midpoints as data and the estimated
probabilities at the midpoints as weights.
</p>


<h3>Value</h3>

<p>A list containing the following components
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>A numeric scalar.  The value of <code>lambda</code>.</p>
</td></tr>
<tr><td><code>gm</code></td>
<td>
<p>A numeric scalar.  Box-cox scaling parameter, estimated by the
geometric mean of the quantiles used in the optimisation to find the
value of lambda.</p>
</td></tr>
<tr><td><code>init_psi</code></td>
<td>
<p>A numeric scalar.  An initial estimate of the mode of the
Box-Cox transformed density</p>
</td></tr>
<tr><td><code>sd_psi</code></td>
<td>
<p>A numeric scalar.  Estimates of the marginal standard
deviations of the Box-Cox transformed variables.</p>
</td></tr>
<tr><td><code>phi_to_theta</code></td>
<td>
<p>as detailed above (only if <code>phi_to_theta</code> is
supplied)</p>
</td></tr>
<tr><td><code>log_j</code></td>
<td>
<p>as detailed above (only if <code>log_j</code> is supplied)</p>
</td></tr>
<tr><td><code>user_args</code></td>
<td>
<p>as detailed above (only if <code>user_args</code> is supplied)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Box, G. and Cox, D. R. (1964) An Analysis of Transformations.
Journal of the Royal Statistical Society. Series B (Methodological), 26(2),
211-252.
</p>
<p>Andrews, D. F. and Gnanadesikan, R. and Warner, J. L. (1971)
Transformations of Multivariate Data, Biometrics, 27(4).
</p>
<p>Eddelbuettel, D. and Francois, R. (2011). Rcpp: Seamless
R and C++ Integration. <em>Journal of Statistical Software</em>,
<strong>40</strong>(8), 1-18. <a href="https://doi.org/10.18637/jss.v040.i08">doi:10.18637/jss.v040.i08</a>
</p>
<p>Eddelbuettel, D. (2013). <em>Seamless R and C++ Integration
with Rcpp</em>, Springer, New York. ISBN 978-1-4614-6867-7.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ru_rcpp">ru_rcpp</a></code> to perform ratio-of-uniforms sampling.
</p>
<p><code><a href="#topic+find_lambda_rcpp">find_lambda_rcpp</a></code> to produce (somewhat) automatically
a list for the argument <code>lambda</code> of <code>ru</code> for any value of
<code>d</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Log-normal density ===================

# Note: the default value of max_phi = 10 is OK here but this will not
# always be the case.

ptr_lnorm &lt;- create_xptr("logdlnorm")
mu &lt;- 0
sigma &lt;- 1
lambda &lt;- find_lambda_one_d_rcpp(logf = ptr_lnorm, mu = mu, sigma = sigma)
lambda
x &lt;- ru_rcpp(logf = ptr_lnorm, mu = mu, sigma = sigma, log = TRUE, d = 1,
             n = 1000, trans = "BC", lambda = lambda)

# Gamma density ===================

alpha &lt;- 1
# Choose a sensible value of max_phi
max_phi &lt;- qgamma(0.999, shape = alpha)
# [I appreciate that typically the quantile function won't be available.
# In practice the value of lambda chosen is quite insensitive to the choice
# of max_phi, provided that max_phi is not far too large or far too small.]

ptr_gam &lt;- create_xptr("logdgamma")
lambda &lt;- find_lambda_one_d_rcpp(logf = ptr_gam, alpha = alpha,
                                 max_phi = max_phi)
lambda
x &lt;- ru_rcpp(logf = ptr_gam, alpha = alpha, d = 1, n = 1000, trans = "BC",
             lambda = lambda)

alpha &lt;- 0.1
# NB. for alpha &lt; 1 the gamma(alpha, beta) density is not bounded
# So the ratio-of-uniforms emthod can't be used but it may work after a
# Box-Cox transformation.
# find_lambda_one_d() works much better than find_lambda() here.

max_phi &lt;- qgamma(0.999, shape = alpha)
lambda &lt;- find_lambda_one_d_rcpp(logf = ptr_gam, alpha = alpha,
                                 max_phi = max_phi)
lambda
x &lt;- ru_rcpp(logf = ptr_gam, alpha = alpha, d = 1, n = 1000, trans = "BC",
             lambda = lambda)

plot(x)
plot(x, ru_scale = TRUE)

</code></pre>

<hr>
<h2 id='find_lambda_rcpp'>Selecting the Box-Cox parameter for general d using Rcpp</h2><span id='topic+find_lambda_rcpp'></span>

<h3>Description</h3>

<p>Finds a value of the Box-Cox transformation parameter lambda for which
the (positive) random variable with log-density <code class="reqn">\log f</code> has a
density closer to that of a Gaussian random variable.
In the following we use <code>theta</code> (<code class="reqn">\theta</code>) to denote the argument
of <code>logf</code> on the original scale and <code>phi</code> (<code class="reqn">\phi</code>) on the
Box-Cox transformed scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_lambda_rcpp(
  logf,
  ...,
  d = 1,
  n_grid = NULL,
  ep_bc = 1e-04,
  min_phi = rep(ep_bc, d),
  max_phi = rep(10, d),
  which_lam = 1:d,
  lambda_range = c(-3, 3),
  init_lambda = NULL,
  phi_to_theta = NULL,
  log_j = NULL,
  user_args = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_lambda_rcpp_+3A_logf">logf</code></td>
<td>
<p>A pointer to a compiled C++ function returning the log
of the target density <code class="reqn">f</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_rcpp_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>logf</code> and related
functions.</p>
</td></tr>
<tr><td><code id="find_lambda_rcpp_+3A_d">d</code></td>
<td>
<p>A numeric scalar. Dimension of <code class="reqn">f</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_rcpp_+3A_n_grid">n_grid</code></td>
<td>
<p>A numeric scalar.  Number of ordinates for each variable in
<code>phi</code>.  If this is not supplied a default value of
<code>ceiling(2501 ^ (1 / d))</code> is used.</p>
</td></tr>
<tr><td><code id="find_lambda_rcpp_+3A_ep_bc">ep_bc</code></td>
<td>
<p>A (positive) numeric scalar. Smallest possible value of
<code>phi</code> to consider.  Used to avoid negative values of <code>phi</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_rcpp_+3A_min_phi">min_phi</code>, <code id="find_lambda_rcpp_+3A_max_phi">max_phi</code></td>
<td>
<p>Numeric vectors.  Smallest and largest values
of <code>phi</code> at which to evaluate <code>logf</code>, i.e., the range of values
of <code>phi</code> over which to evaluate <code>logf</code>. Any components in
<code>min_phi</code> that are not positive are set to <code>ep_bc</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_rcpp_+3A_which_lam">which_lam</code></td>
<td>
<p>A numeric vector.  Contains the indices of the components
of <code>phi</code> that ARE to be Box-Cox transformed.</p>
</td></tr>
<tr><td><code id="find_lambda_rcpp_+3A_lambda_range">lambda_range</code></td>
<td>
<p>A numeric vector of length 2.  Range of lambda over
which to optimise.</p>
</td></tr>
<tr><td><code id="find_lambda_rcpp_+3A_init_lambda">init_lambda</code></td>
<td>
<p>A numeric vector of length 1 or <code>d</code>.  Initial value
of lambda used in the search for the best lambda.  If <code>init_lambda</code>
is a scalar then <code>rep(init_lambda, d)</code> is used.</p>
</td></tr>
<tr><td><code id="find_lambda_rcpp_+3A_phi_to_theta">phi_to_theta</code></td>
<td>
<p>A pointer to a compiled C++ function returning
(the inverse) of the transformation from <code>theta</code> to <code>phi</code> used
to ensure positivity of <code>phi</code> prior to Box-Cox transformation.  The
argument is <code>phi</code> and the returned value is <code>theta</code>.  If
<code>phi_to_theta</code> is undefined at the input value then the function
should return <code>NA</code>.</p>
</td></tr>
<tr><td><code id="find_lambda_rcpp_+3A_log_j">log_j</code></td>
<td>
<p>A pointer to a compiled C++ function returning the log of
the Jacobian of the transformation from <code>theta</code> to <code>phi</code>, i.e.,
based on derivatives of <code class="reqn">phi</code> with respect to <code class="reqn">theta</code>. Takes
<code>theta</code> as its argument.</p>
</td></tr>
<tr><td><code id="find_lambda_rcpp_+3A_user_args">user_args</code></td>
<td>
<p>A list of numeric components providing arguments to
the user-supplied functions <code>phi_to_theta</code> and <code>log_j</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The general idea is to evaluate the density <code class="reqn">f</code> on a
<code>d</code>-dimensional grid, with <code>n_grid</code> ordinates for each of the
<code>d</code> variables.
We treat each combination of the variables in the grid as a data point
and perform an estimation of the Box-Cox transformation parameter
<code>lambda</code>, in which each data point is weighted by the density
at that point.  The vectors <code>min_phi</code> and <code>max_phi</code> define the
limits of the grid and <code>which_lam</code> can be used to specify that only
certain components of <code>phi</code> are to be transformed.
</p>


<h3>Value</h3>

<p>A list containing the following components
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>A numeric vector.  The value of <code>lambda</code>.</p>
</td></tr>
<tr><td><code>gm</code></td>
<td>
<p>A numeric vector.  Box-cox scaling parameter, estimated by the
geometric mean of the values of phi used in the optimisation to find
the value of lambda, weighted by the values of f evaluated at phi.</p>
</td></tr>
<tr><td><code>init_psi</code></td>
<td>
<p>A numeric vector.  An initial estimate of the mode of the
Box-Cox transformed density</p>
</td></tr>
<tr><td><code>sd_psi</code></td>
<td>
<p>A numeric vector.  Estimates of the marginal standard
deviations of the Box-Cox transformed variables.</p>
</td></tr>
<tr><td><code>phi_to_theta</code></td>
<td>
<p>as detailed above (only if <code>phi_to_theta</code> is
supplied)</p>
</td></tr>
<tr><td><code>log_j</code></td>
<td>
<p>as detailed above (only if <code>log_j</code> is supplied)</p>
</td></tr>
<tr><td><code>user_args</code></td>
<td>
<p>as detailed above (only if <code>user_args</code> is supplied)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Box, G. and Cox, D. R. (1964) An Analysis of Transformations.
Journal of the Royal Statistical Society. Series B (Methodological), 26(2),
211-252.
</p>
<p>Andrews, D. F. and Gnanadesikan, R. and Warner, J. L. (1971)
Transformations of Multivariate Data, Biometrics, 27(4).
</p>
<p>Eddelbuettel, D. and Francois, R. (2011). Rcpp: Seamless
R and C++ Integration. <em>Journal of Statistical Software</em>,
<strong>40</strong>(8), 1-18. <a href="https://doi.org/10.18637/jss.v040.i08">doi:10.18637/jss.v040.i08</a>
</p>
<p>Eddelbuettel, D. (2013). <em>Seamless R and C++ Integration
with Rcpp</em>, Springer, New York. ISBN 978-1-4614-6867-7.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ru_rcpp">ru_rcpp</a></code> to perform ratio-of-uniforms sampling.
</p>
<p><code><a href="#topic+find_lambda_one_d_rcpp">find_lambda_one_d_rcpp</a></code> to produce (somewhat)
automatically a list for the argument <code>lambda</code> of <code>ru</code> for the
<code>d</code> = 1 case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Log-normal density ===================
# Note: the default value max_phi = 10 is OK here but this will not always
# be the case
ptr_lnorm &lt;- create_xptr("logdlnorm")
mu &lt;- 0
sigma &lt;- 1
lambda &lt;- find_lambda_rcpp(logf = ptr_lnorm, mu = mu, sigma = sigma)
lambda
x &lt;- ru_rcpp(logf = ptr_lnorm, mu = mu, sigma = sigma, d = 1, n = 1000,
             trans = "BC", lambda = lambda)

# Gamma density ===================
alpha &lt;- 1
#  Choose a sensible value of max_phi
max_phi &lt;- qgamma(0.999, shape = alpha)
# [Of course, typically the quantile function won't be available.  However,
# In practice the value of lambda chosen is quite insensitive to the choice
# of max_phi, provided that max_phi is not far too large or far too small.]

ptr_gam &lt;- create_xptr("logdgamma")
lambda &lt;- find_lambda_rcpp(logf = ptr_gam, alpha = alpha, max_phi = max_phi)
lambda
x &lt;- ru_rcpp(logf = ptr_gam, alpha = alpha, d = 1, n = 1000, trans = "BC",
             lambda = lambda)


# Generalized Pareto posterior distribution ===================

n &lt;- 1000
# Sample data from a GP(sigma, xi) distribution
gpd_data &lt;- rgpd(m = 100, xi = -0.5, sigma = 1)
# Calculate summary statistics for use in the log-likelihood
ss &lt;- gpd_sum_stats(gpd_data)
# Calculate an initial estimate
init &lt;- c(mean(gpd_data), 0)

n &lt;- 1000
# Sample on original scale, with no rotation ----------------
ptr_gp &lt;- create_xptr("loggp")
for_ru_rcpp &lt;- c(list(logf = ptr_gp, init = init, d = 2, n = n,
                     lower = c(0, -Inf)), ss, rotate = FALSE)
x1 &lt;- do.call(ru_rcpp, for_ru_rcpp)
plot(x1, xlab = "sigma", ylab = "xi")
# Parameter constraint line xi &gt; -sigma/max(data)
# [This may not appear if the sample is far from the constraint.]
abline(a = 0, b = -1 / ss$xm)
summary(x1)

# Sample on original scale, with rotation ----------------
for_ru_rcpp &lt;- c(list(logf = ptr_gp, init = init, d = 2, n = n,
                      lower = c(0, -Inf)), ss)
x2 &lt;- do.call(ru_rcpp, for_ru_rcpp)
plot(x2, xlab = "sigma", ylab = "xi")
abline(a = 0, b = -1 / ss$xm)
summary(x2)

# Sample on Box-Cox transformed scale ----------------

# Find initial estimates for phi = (phi1, phi2),
# where phi1 = sigma
#   and phi2 = xi + sigma / max(x),
# and ranges of phi1 and phi2 over over which to evaluate
# the posterior to find a suitable value of lambda.
temp &lt;- do.call(gpd_init, ss)
min_phi &lt;- pmax(0, temp$init_phi - 2 * temp$se_phi)
max_phi &lt;- pmax(0, temp$init_phi + 2 * temp$se_phi)

# Set phi_to_theta() that ensures positivity of phi
# We use phi1 = sigma and phi2 = xi + sigma / max(data)

# Create an external pointer to this C++ function
ptr_phi_to_theta_gp &lt;- create_phi_to_theta_xptr("gp")
# Note: log_j is set to zero by default inside find_lambda_rcpp()
lambda &lt;- find_lambda_rcpp(logf = ptr_gp, ss = ss, d = 2, min_phi = min_phi,
                           max_phi = max_phi, user_args = list(xm = ss$xm),
                           phi_to_theta = ptr_phi_to_theta_gp)
lambda

# Sample on Box-Cox transformed, without rotation
x3 &lt;- ru_rcpp(logf = ptr_gp, ss = ss, d = 2, n = n, trans = "BC",
              lambda = lambda, rotate = FALSE)
plot(x3, xlab = "sigma", ylab = "xi")
abline(a = 0, b = -1 / ss$xm)
summary(x3)

# Sample on Box-Cox transformed, with rotation
x4 &lt;- ru_rcpp(logf = ptr_gp, ss = ss, d = 2, n = n, trans = "BC",
              lambda = lambda)
plot(x4, xlab = "sigma", ylab = "xi")
abline(a = 0, b = -1 / ss$xm)
summary(x4)

def_par &lt;- graphics::par(no.readonly = TRUE)
par(mfrow = c(2,2), mar = c(4, 4, 1.5, 1))
plot(x1, xlab = "sigma", ylab = "xi", ru_scale = TRUE,
  main = "mode relocation")
plot(x2, xlab = "sigma", ylab = "xi", ru_scale = TRUE,
  main = "mode relocation and rotation")
plot(x3, xlab = "sigma", ylab = "xi", ru_scale = TRUE,
  main = "Box-Cox and mode relocation")
plot(x4, xlab = "sigma", ylab = "xi", ru_scale = TRUE,
  main = "Box-Cox, mode relocation and rotation")
graphics::par(def_par)

</code></pre>

<hr>
<h2 id='gpd_init'>Initial estimates for Generalized Pareto parameters</h2><span id='topic+gpd_init'></span>

<h3>Description</h3>

<p>Calculates initial estimates and estimated standard errors (SEs) for the
generalized Pareto parameters <code class="reqn">\sigma</code> and <code class="reqn">\xi</code> based on an
assumed random sample from this distribution.  Also, calculates
initial estimates and estimated standard errors for
<code class="reqn">\phi</code><sub>1</sub> = <code class="reqn">\sigma</code>
and
<code class="reqn">\phi</code><sub>2</sub> = <code class="reqn">\xi + \sigma x</code>
<sub>(m)</sub>, where
<code class="reqn">x</code><sub>(m)</sub> is the sample
maximum threshold exceedance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpd_init(gpd_data, m, xm, sum_gp = NULL, xi_eq_zero = FALSE, init_ests = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpd_init_+3A_gpd_data">gpd_data</code></td>
<td>
<p>A numeric vector containing positive sample values.</p>
</td></tr>
<tr><td><code id="gpd_init_+3A_m">m</code></td>
<td>
<p>A numeric scalar.  The sample size, i.e., the length of
<code>gpd_data</code>.</p>
</td></tr>
<tr><td><code id="gpd_init_+3A_xm">xm</code></td>
<td>
<p>A numeric scalar. The sample maximum.</p>
</td></tr>
<tr><td><code id="gpd_init_+3A_sum_gp">sum_gp</code></td>
<td>
<p>A numeric scalar. The sum of the sample values.</p>
</td></tr>
<tr><td><code id="gpd_init_+3A_xi_eq_zero">xi_eq_zero</code></td>
<td>
<p>A logical scalar.  If TRUE assume that the shape
parameter <code class="reqn">\xi = 0</code>.</p>
</td></tr>
<tr><td><code id="gpd_init_+3A_init_ests">init_ests</code></td>
<td>
<p>A numeric vector.  Initial estimate of
<code class="reqn">\theta = (\sigma, \xi)</code>.  If supplied <code>gpd_init()</code>
returns the corresponding initial estimate of
<code class="reqn">\phi</code> = (<code class="reqn">\phi</code><sub>1</sub>,
<code class="reqn">\phi</code><sub>2</sub>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main aim is to calculate an admissible estimate of
<code class="reqn">\theta</code>, i.e., one at which the log-likelihood is finite (necessary
for the posterior log-density to be finite) at the estimate, and
associated estimated SEs. These are converted into estimates and SEs for
<code class="reqn">\phi</code>.  The latter can be used to set values of <code>min_phi</code> and
<code>max_phi</code> for input to <code>find_lambda</code>.
</p>
<p>In the default setting (<code>xi_eq_zero = FALSE</code> and
<code>init_ests = NULL</code>) the methods tried are Maximum Likelihood
Estimation (MLE) (Grimshaw, 1993), Probability-Weighted Moments (PWM)
(Hosking and Wallis, 1987) and Linear Combinations of Ratios of Spacings
(LRS) (Reiss and Thomas, 2007, page 134) in that order.
</p>
<p>For <code class="reqn">\xi &lt; -1</code> the likelihood is unbounded, MLE may fail when
<code class="reqn">\xi</code> is not greater than <code class="reqn">-0.5</code> and the observed Fisher
information for <code class="reqn">(sigma, xi)</code> has finite variance only if
<code class="reqn">\xi &gt; -0.25</code>.  We use the ML estimate provided that
the estimate of <code class="reqn">\xi</code> returned from <code>gpd_mle</code> is greater than
<code class="reqn">-1</code>. We only use the SE if the MLE of <code class="reqn">\xi</code> is greater than
<code class="reqn">-0.25</code>.
</p>
<p>If either the MLE or the SE are not OK then we try PWM.  We use the PWM
estimate only if is admissible, and the MLE was not OK.  We use the PWM SE,
but this will be <code>c(NA, NA)</code> is the PWM estimate of <code class="reqn">\xi</code> is
<code class="reqn">&gt; 1/2</code>.  If the estimate is still not OK then we try LRS.  As a last
resort, which will tend to occur only when <code class="reqn">\xi</code> is strongly negative,
we set <code class="reqn">\xi = -1</code> and estimate sigma conditional on this.
</p>


<h3>Value</h3>

<p>If <code>init_ests</code> is not supplied by the user, a list is returned
with components
</p>
<table>
<tr><td><code>init</code></td>
<td>
<p>A numeric vector. Initial estimates of <code class="reqn">\sigma</code>
and <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>A numeric vector. Estimated standard errors of
<code class="reqn">\sigma</code> and <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code>init_phi</code></td>
<td>
<p>A numeric vector. Initial estimates of
<code class="reqn">\phi</code><sub>1</sub> = <code class="reqn">\sigma</code>
and
<code class="reqn">\phi</code><sub>2</sub> = <code class="reqn">\xi + \sigma x</code>
<sub>(m)</sub>
where <code class="reqn">x</code><sub>(m)</sub>
is the maximum of <code>gpd_data</code>.</p>
</td></tr>
<tr><td><code>se_phi</code></td>
<td>
<p>A numeric vector. Estimated standard errors of
<code class="reqn">\phi</code><sub>1</sub>
and
<code class="reqn">\phi</code><sub>1</sub>.</p>
</td></tr>
</table>
<p>If <code>init_ests</code> is supplied then only the numeric vector
<code>init_phi</code> is returned.
</p>


<h3>References</h3>

<p>Grimshaw, S. D. (1993) Computing Maximum Likelihood Estimates
for the Generalized Pareto Distribution.  Technometrics, 35(2), 185-191.
and Computing (1991) 1, 129-133. <a href="https://doi.org/10.1007/BF01889987">doi:10.1007/BF01889987</a>.
</p>
<p>Hosking, J. R. M. and Wallis, J. R. (1987) Parameter and Quantile
Estimation for the Generalized Pareto Distribution. Technometrics, 29(3),
339-349. <a href="https://doi.org/10.2307/1269343">doi:10.2307/1269343</a>.
</p>
<p>Reiss, R.-D., Thomas, M. (2007) Statistical Analysis of Extreme Values
with Applications to Insurance, Finance, Hydrology and Other Fields.Birkhauser.
<a href="https://doi.org/10.1007/978-3-7643-7399-3">doi:10.1007/978-3-7643-7399-3</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpd_sum_stats">gpd_sum_stats</a></code> to calculate summary statistics for
use in <code>gpd_loglik</code>.
</p>
<p><code><a href="#topic+rgpd">rgpd</a></code> for simulation from a generalized Pareto
</p>
<p><code><a href="#topic+find_lambda">find_lambda</a></code> to produce (somewhat) automatically
a list for the argument <code>lambda</code> of <code>ru</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Sample data from a GP(sigma, xi) distribution
gpd_data &lt;- rgpd(m = 100, xi = 0, sigma = 1)
# Calculate summary statistics for use in the log-likelihood
ss &lt;- gpd_sum_stats(gpd_data)
# Calculate initial estimates
do.call(gpd_init, ss)

</code></pre>

<hr>
<h2 id='gpd_logpost'>Generalized Pareto posterior log-density</h2><span id='topic+gpd_logpost'></span>

<h3>Description</h3>

<p>Calculates the generalized Pareto posterior log-density based on a particular
prior for the generalized Pareto parameters, a Maximal Data Information
(MDI) prior truncated to <code class="reqn">\xi \geq -1</code> in order to produce a
posterior density that is proper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpd_logpost(pars, ss)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpd_logpost_+3A_pars">pars</code></td>
<td>
<p>A numeric vector containing the values of the generalized Pareto
parameters <code class="reqn">\sigma</code> and <code class="reqn">\xi</code>.</p>
</td></tr>
<tr><td><code id="gpd_logpost_+3A_ss">ss</code></td>
<td>
<p>A numeric list. Summary statistics to be passed to the generalized
Pareto log-likelihood.  Calculated using <code>gpd_sum_stats</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric scalar. The value of the log-likelihood.
</p>


<h3>References</h3>

<p>Northrop, P. J. and Attalides, N. (2016) Posterior propriety in
Bayesian extreme value analyses using reference priors. Statistica Sinica,
26(2), 721-743, <a href="https://doi.org/10.5705/ss.2014.034">doi:10.5705/ss.2014.034</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gpd_sum_stats">gpd_sum_stats</a></code> to calculate summary statistics for
use in <code>gpd_loglik</code>.
</p>
<p><code><a href="#topic+rgpd">rgpd</a></code> for simulation from a generalized Pareto
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Sample data from a GP(sigma, xi) distribution
gpd_data &lt;- rgpd(m = 100, xi = 0, sigma = 1)
# Calculate summary statistics for use in the log-likelihood
ss &lt;- gpd_sum_stats(gpd_data)
# Calculate the generalized Pareto log-posterior
gpd_logpost(pars = c(1, 0), ss = ss)

</code></pre>

<hr>
<h2 id='gpd_sum_stats'>Generalized Pareto summary statistics</h2><span id='topic+gpd_sum_stats'></span>

<h3>Description</h3>

<p>Calculates summary statistics involved in the Generalized Pareto
log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpd_sum_stats(gpd_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpd_sum_stats_+3A_gpd_data">gpd_data</code></td>
<td>
<p>A numeric vector containing positive values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>gpd_data</code></td>
<td>
<p>A numeric vector. The input vector with any missings
removed.</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>A numeric scalar. The sample size, i.e., the number of
non-missing values.</p>
</td></tr>
<tr><td><code>xm</code></td>
<td>
<p>A numeric scalar. The sample maximum</p>
</td></tr>
<tr><td><code>sum_gp</code></td>
<td>
<p>A numeric scalar. The sum of the non-missing sample
values.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rgpd">rgpd</a></code> for simulation from a generalized Pareto
distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Sample data from a GP(sigma, xi) distribution
gpd_data &lt;- rgpd(m = 100, xi = 0, sigma = 1)
# Calculate summary statistics for use in the log-likelihood
ss &lt;- gpd_sum_stats(gpd_data)

</code></pre>

<hr>
<h2 id='plot.ru'>Plot diagnostics for an ru object</h2><span id='topic+plot.ru'></span>

<h3>Description</h3>

<p><code>plot</code> method for class <code>"ru"</code>.  For <code>d = 1</code> a histogram of
the simulated values is plotted with a the density function superimposed.
The density is normalized crudely using the trapezium rule.  For
<code>d = 2</code> a scatter plot of the simulated values is produced with
density contours superimposed.  For <code>d &gt; 2</code> pairwise plots of the
simulated values are produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ru'
plot(
  x,
  y,
  ...,
  n = ifelse(x$d == 1, 1001, 101),
  prob = c(0.1, 0.25, 0.5, 0.75, 0.95, 0.99),
  ru_scale = FALSE,
  rows = NULL,
  xlabs = NULL,
  ylabs = NULL,
  var_names = NULL,
  points_par = list(col = 8)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ru_+3A_x">x</code></td>
<td>
<p>an object of class <code>"ru"</code>, a result of a call to <code>ru</code>.</p>
</td></tr>
<tr><td><code id="plot.ru_+3A_y">y</code></td>
<td>
<p>Not used.</p>
</td></tr>
<tr><td><code id="plot.ru_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to <code>hist</code>, <code>lines</code>,
<code>contour</code> or <code>points</code>.</p>
</td></tr>
<tr><td><code id="plot.ru_+3A_n">n</code></td>
<td>
<p>A numeric scalar.  Only relevant if <code>x$d = 1</code> or
<code>x$d = 2</code>. The meaning depends on the value of x$d.
</p>

<ul>
<li><p> For d = 1 : n + 1 is the number of abscissae in the trapezium
method used to normalize the density.
</p>
</li>
<li><p> For d = 2 : an n by n regular grid is used to contour the density.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot.ru_+3A_prob">prob</code></td>
<td>
<p>Numeric vector. Only relevant for <code>d = 2</code>.  The contour
lines are drawn such that the respective probabilities that the variable
lies within the contour are approximately equal to the values in
<code>prob</code>.</p>
</td></tr>
<tr><td><code id="plot.ru_+3A_ru_scale">ru_scale</code></td>
<td>
<p>A logical scalar.  Should we plot data and density on the
scale used in the ratio-of-uniforms algorithm (<code>TRUE</code>) or on the
original scale (<code>FALSE</code>)?</p>
</td></tr>
<tr><td><code id="plot.ru_+3A_rows">rows</code></td>
<td>
<p>A numeric scalar.  When <code>d &gt; 2</code> this sets the number of
rows of plots.  If the user doesn't provide this then it is set
internally.</p>
</td></tr>
<tr><td><code id="plot.ru_+3A_xlabs">xlabs</code>, <code id="plot.ru_+3A_ylabs">ylabs</code></td>
<td>
<p>Numeric vectors.  When <code>d &gt; 2</code> these set the labels
on the x and y axes respectively.  If the user doesn't provide these then
the column names of the simulated data matrix to be plotted are used.</p>
</td></tr>
<tr><td><code id="plot.ru_+3A_var_names">var_names</code></td>
<td>
<p>A character (or numeric) vector of length <code>x$d</code>. This
argument can be used to replace variable names set using <code>var_names</code>
in the call to <code><a href="#topic+ru">ru</a></code> or <code><a href="#topic+ru_rcpp">ru_rcpp</a></code>.</p>
</td></tr>
<tr><td><code id="plot.ru_+3A_points_par">points_par</code></td>
<td>
<p>A list of arguments to pass to
<code><a href="graphics.html#topic+points">points</a></code> to control the appearance of points
depicting the simulated values. Only relevant when <code>d = 2</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, only the plot is produced.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.ru">summary.ru</a></code> for summaries of the simulated values
and properties of the ratio-of-uniforms algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Log-normal density ----------------
x &lt;- ru(logf = dlnorm, log = TRUE, d = 1, n = 1000, lower = 0, init = 1)

plot(x)

# Improve appearance using arguments to plot() and hist()

plot(x, breaks = seq(0, ceiling(max(x$sim_vals)), by = 0.25),
  xlim = c(0, 10))

# Two-dimensional normal with positive association ----------------
rho &lt;- 0.9
covmat &lt;- matrix(c(1, rho, rho, 1), 2, 2)
log_dmvnorm &lt;- function(x, mean = rep(0, d), sigma = diag(d)) {
  x &lt;- matrix(x, ncol = length(x))
  d &lt;- ncol(x)
  - 0.5 * (x - mean) %*% solve(sigma) %*% t(x - mean)
}
x &lt;- ru(logf = log_dmvnorm, sigma = covmat, d = 2, n = 1000, init = c(0, 0))

plot(x)

</code></pre>

<hr>
<h2 id='print.ru'>Print method for an <code>"ru"</code> object</h2><span id='topic+print.ru'></span>

<h3>Description</h3>

<p><code>print</code> method for class <code>"ru"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ru'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.ru_+3A_x">x</code></td>
<td>
<p>an object of class <code>"ru"</code>, a result of a call to
<code><a href="#topic+ru">ru</a></code> or <code><a href="#topic+ru_rcpp">ru_rcpp</a></code>.</p>
</td></tr>
<tr><td><code id="print.ru_+3A_...">...</code></td>
<td>
<p>Additional arguments.  None are used in this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simply prints the call to <code>ru</code> or <code>ru_rcpp</code>.
</p>


<h3>Value</h3>

<p>The argument <code>x</code>, invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.ru">summary.ru</a></code> for summaries of the simulated values
and properties of the ratio-of-uniforms algorithm.
</p>
<p><code><a href="#topic+plot.ru">plot.ru</a></code> for a diagnostic plot.
</p>

<hr>
<h2 id='rgpd'>Generalized Pareto simulation</h2><span id='topic+rgpd'></span>

<h3>Description</h3>

<p>Simulates a sample of size <code>m</code> from a generalized Pareto distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rgpd(m = 1, sigma = 1, xi = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgpd_+3A_m">m</code></td>
<td>
<p>A numeric scalar.  The size of sample required.</p>
</td></tr>
<tr><td><code id="rgpd_+3A_sigma">sigma</code></td>
<td>
<p>A numeric scalar.  The generalized Pareto scale parameter
<code class="reqn">\sigma</code>.</p>
</td></tr>
<tr><td><code id="rgpd_+3A_xi">xi</code></td>
<td>
<p>A numeric scalar.  The generalized Pareto shape parameter
<code class="reqn">\xi</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector.  A generalized Pareto sample of size <code>m</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Sample data from a GP(sigma, xi) distribution
gpd_data &lt;- rgpd(m = 100, xi = 0, sigma = 1)

</code></pre>

<hr>
<h2 id='ru'>Generalized ratio-of-uniforms sampling</h2><span id='topic+ru'></span>

<h3>Description</h3>

<p>Uses the generalized ratio-of-uniforms method to simulate from a
distribution with log-density <code class="reqn">\log f</code> (up to an additive
constant). The density <code class="reqn">f</code> must be bounded, perhaps after a
transformation of variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ru(
  logf,
  ...,
  n = 1,
  d = 1,
  init = NULL,
  mode = NULL,
  trans = c("none", "BC", "user"),
  phi_to_theta = NULL,
  log_j = NULL,
  user_args = list(),
  lambda = rep(1L, d),
  lambda_tol = 1e-06,
  gm = NULL,
  rotate = ifelse(d == 1, FALSE, TRUE),
  lower = rep(-Inf, d),
  upper = rep(Inf, d),
  r = 1/2,
  ep = 0L,
  a_algor = if (d == 1) "nlminb" else "optim",
  b_algor = c("nlminb", "optim"),
  a_method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"),
  b_method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"),
  a_control = list(),
  b_control = list(),
  var_names = NULL,
  shoof = 0.2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ru_+3A_logf">logf</code></td>
<td>
<p>A function returning the log of the target density <code class="reqn">f</code>
evaluated at its first argument.
This function should return <code>-Inf</code> when the density is zero.
It is better to use <code>logf = </code> explicitly, for example,
<code>ru(logf = dnorm, log = TRUE, init = 0.1)</code>,
to avoid argument matching problems.  In contrast,
<code>ru(dnorm, log = TRUE, init = 0.1)</code>
will throw an error because partial matching results in
<code>logf</code> being matched to <code>log = TRUE</code>.</p>
</td></tr>
<tr><td><code id="ru_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>logf</code> and related
functions.</p>
</td></tr>
<tr><td><code id="ru_+3A_n">n</code></td>
<td>
<p>A non-negative integer scalar.  The number of simulated values
required. If <code>n = 0</code> then no simulation is performed but the
component <code>box</code> in the returned object gives the ratio-of-uniforms
bounding box that would have been used.</p>
</td></tr>
<tr><td><code id="ru_+3A_d">d</code></td>
<td>
<p>A positive integer scalar. The dimension of <code class="reqn">f</code>.</p>
</td></tr>
<tr><td><code id="ru_+3A_init">init</code></td>
<td>
<p>A numeric vector. Initial estimates of the mode of <code>logf</code>.
If <code>trans = "BC"</code> or <code>trans = "user"</code> this is <em>after</em>
Box-Cox transformation or user-defined transformation, but <em>before</em>
any rotation of axes.
If <code>init</code> is not supplied then <code>rep(1, d)</code> is used.</p>
</td></tr>
<tr><td><code id="ru_+3A_mode">mode</code></td>
<td>
<p>A numeric vector of length <code>d</code>.  The mode of <code>logf</code>.
If <code>trans = "BC"</code> or <code>trans = "user"</code> this is <em>after</em>
Box-Cox transformation or user-defined transformation, but <em>before</em>
any rotation of axes.  Only supply <code>mode</code> if the mode is known: it
will not be checked.  If <code>mode</code> is supplied then <code>init</code> is
ignored.</p>
</td></tr>
<tr><td><code id="ru_+3A_trans">trans</code></td>
<td>
<p>A character scalar. <code>trans = "none"</code> for no
transformation, <code>trans = "BC"</code> for Box-Cox transformation,
<code>trans = "user"</code> for a user-defined transformation.
If <code>trans = "user"</code> then the transformation should be specified
using <code>phi_to_theta</code> and <code>log_j</code> and <code>user_args</code> may be
used to pass arguments to <code>phi_to_theta</code> and <code>log_j</code>.
See <strong>Details</strong> and the <strong>Examples</strong>.</p>
</td></tr>
<tr><td><code id="ru_+3A_phi_to_theta">phi_to_theta</code></td>
<td>
<p>A function returning (the inverse) of the transformation
from <code>theta</code> (<code class="reqn">\theta</code>) to <code>phi</code> (<code class="reqn">\phi</code>) that may be
used to ensure positivity of <code class="reqn">\phi</code> prior to Box-Cox transformation.
The argument is <code>phi</code> and the returned value is <code>theta</code>.
If <code>phi_to_theta</code> is undefined at the input value then the
function should return <code>NA</code>. See <strong>Details</strong>.
If <code>lambda$phi_to_theta</code> (see argument <code>lambda</code> below) is
supplied then this is used instead of any function supplied via
<code>phi_to_theta</code>.</p>
</td></tr>
<tr><td><code id="ru_+3A_log_j">log_j</code></td>
<td>
<p>A function returning the log of the Jacobian of the
transformation from <code>theta</code> (<code class="reqn">\theta</code>) to <code>phi</code> (<code class="reqn">\phi</code>),
i.e., based on derivatives of <code class="reqn">\phi</code> with respect to <code class="reqn">\theta</code>.
Takes <code>theta</code> as its argument.
If <code>lambda$log_j</code> (see argument <code>lambda</code> below) is
supplied then this is used instead of any function supplied via
<code>log_j</code>.</p>
</td></tr>
<tr><td><code id="ru_+3A_user_args">user_args</code></td>
<td>
<p>A list of numeric components. If <code>trans = "user"</code>
then <code>user_args</code> is a list providing arguments to the user-supplied
functions <code>phi_to_theta</code> and <code>log_j</code>.</p>
</td></tr>
<tr><td><code id="ru_+3A_lambda">lambda</code></td>
<td>
<p>Either
</p>

<ul>
<li><p> A numeric vector.  Box-Cox transformation parameters, or
</p>
</li>
<li><p> A list with components
</p>

<dl>
<dt>lambda</dt><dd><p>A numeric vector.  Box-Cox parameters (required).</p>
</dd>
<dt>gm</dt><dd><p>A numeric vector.  Box-cox scaling parameters (optional).
If supplied this overrides any <code>gm</code> supplied by the individual
<code>gm</code> argument described below.</p>
</dd>
<dt>init_psi</dt><dd><p>A numeric vector.  Initial estimate of mode <em>after</em>
Box-Cox transformation (optional).</p>
</dd>
<dt>sd_psi</dt><dd><p>A numeric vector.  Estimates of the marginal standard
deviations of the Box-Cox transformed variables (optional).</p>
</dd>
<dt>phi_to_theta</dt><dd><p>As above (optional).</p>
</dd>
<dt>log_j</dt><dd><p>As above (optional).</p>
</dd>
</dl>

<p>This list may be created using <a href="#topic+find_lambda_one_d">find_lambda_one_d</a> (for <code>d</code> = 1)
or <a href="#topic+find_lambda">find_lambda</a> (for any <code>d</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="ru_+3A_lambda_tol">lambda_tol</code></td>
<td>
<p>A numeric scalar.  Any values in lambda that are less
than <code>lambda_tol</code> in magnitude are set to zero.</p>
</td></tr>
<tr><td><code id="ru_+3A_gm">gm</code></td>
<td>
<p>A numeric vector. Box-cox scaling parameters (optional). If
<code>lambda$gm</code> is supplied in input list <code>lambda</code> then
<code>lambda$gm</code> is used, not <code>gm</code>.</p>
</td></tr>
<tr><td><code id="ru_+3A_rotate">rotate</code></td>
<td>
<p>A logical scalar. If TRUE (<code>d</code> &gt; 1 only) use Choleski
rotation.  If d = 1 and <code>rotate = TRUE</code> then rotate will be set to
FALSE with a warning. See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="ru_+3A_lower">lower</code>, <code id="ru_+3A_upper">upper</code></td>
<td>
<p>Numeric vectors.  Lower/upper bounds on the arguments of
the function <em>after</em> any transformation from theta to phi implied by
the inverse of <code>phi_to_theta</code>. If <code>rotate = FALSE</code> these
are used in all of the optimisations used to construct the bounding box.
If <code>rotate = TRUE</code> then they are use only in the first optimisation
to maximise the target density.'
If <code>trans = "BC"</code> components of <code>lower</code> that are negative are
set to zero without warning and the bounds implied after the Box-Cox
transformation are calculated inside <code>ru</code>.</p>
</td></tr>
<tr><td><code id="ru_+3A_r">r</code></td>
<td>
<p>A numeric scalar.  Parameter of generalized ratio-of-uniforms.</p>
</td></tr>
<tr><td><code id="ru_+3A_ep">ep</code></td>
<td>
<p>A numeric scalar.  Controls initial estimates for optimisations
to find the <code class="reqn">b</code>-bounding box parameters.  The default (<code>ep</code>=0)
corresponds to starting at the mode of <code>logf</code> small positive values
of <code>ep</code> move the constrained variable slightly away from the mode in
the correct direction.  If <code>ep</code> is negative its absolute value is
used, with no warning given.</p>
</td></tr>
<tr><td><code id="ru_+3A_a_algor">a_algor</code>, <code id="ru_+3A_b_algor">b_algor</code></td>
<td>
<p>Character scalars.  Either <code>"nlminb"</code> or
<code>"optim"</code>.
Respective optimisation algorithms used to find <code class="reqn">a(r)</code> and
(<code class="reqn">b</code><sub>i</sub><sup>-</sup>(r),
<code class="reqn">b</code><sub>i</sub><sup>+</sup>(r)).</p>
</td></tr>
<tr><td><code id="ru_+3A_a_method">a_method</code>, <code id="ru_+3A_b_method">b_method</code></td>
<td>
<p>Character scalars.  Respective methods used by
<code>optim</code> to find <code class="reqn">a(r)</code> and
(<code class="reqn">b</code><sub>i</sub><sup>-</sup>(r),
<code class="reqn">b</code><sub>i</sub><sup>+</sup>(r)).
Only used if <code>optim</code> is the chosen algorithm.  If <code>d</code> = 1 then
<code>a_method</code> and <code>b_method</code> are set to <code>"Brent"</code> without
warning.</p>
</td></tr>
<tr><td><code id="ru_+3A_a_control">a_control</code>, <code id="ru_+3A_b_control">b_control</code></td>
<td>
<p>Lists of control arguments to <code>optim</code> or
<code>nlminb</code> to find <code class="reqn">a(r)</code> and
(<code class="reqn">b</code><sub>i</sub><sup>-</sup>(r),
<code class="reqn">b</code><sub>i</sub><sup>+</sup>(r))
respectively.</p>
</td></tr>
<tr><td><code id="ru_+3A_var_names">var_names</code></td>
<td>
<p>A character (or numeric) vector of length <code>d</code>.  Names
to give to the column(s) of the simulated values.</p>
</td></tr>
<tr><td><code id="ru_+3A_shoof">shoof</code></td>
<td>
<p>A numeric scalar in [0, 1].  Sometimes a spurious
non-zero convergence indicator is returned from
<code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="stats.html#topic+nlminb">nlminb</a></code>).
In this event we try to check that a minimum has indeed been found using
different algorithm.  <code>shoof</code> controls the starting value provided
to this algorithm.
If <code>shoof = 0</code> then we start from the current solution.
If <code>shoof = 1</code> then we start from the initial estimate provided
to the previous minimisation.  Otherwise, <code>shoof</code> interpolates
between these two extremes, with a value close to zero giving a starting
value that is close to the current solution.
The exception to this is when the initial and current solutions are equal.
Then we start from the current solution multiplied by <code>1 - shoof</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For information about the generalised ratio-of-uniforms method and
transformations see the
<a href="https://paulnorthrop.github.io/rust/articles/rust-a-vignette.html">
Introducing rust</a> vignette.  This can also be accessed using
<code>vignette("rust-a-vignette", package = "rust")</code>.
</p>
<p>If <code>trans = "none"</code> and <code>rotate = FALSE</code> then <code>ru</code>
implements the (multivariate) generalized ratio of uniforms method
described in Wakefield, Gelfand and Smith (1991) using a target
density whose mode is relocated to the origin (&lsquo;mode relocation&rsquo;) in the
hope of increasing efficiency.
</p>
<p>If <code>trans = "BC"</code> then marginal Box-Cox transformations of each of
the <code>d</code> variables is performed, with parameters supplied in
<code>lambda</code>.  The function <code>phi_to_theta</code> may be used, if
necessary, to ensure positivity of the variables prior to Box-Cox
transformation.
</p>
<p>If <code>trans = "user"</code> then the function <code>phi_to_theta</code> enables
the user to specify their own transformation.
</p>
<p>In all cases the mode of the target function is relocated to the origin
<em>after</em> any user-supplied transformation and/or Box-Cox
transformation.
</p>
<p>If <code>d</code> is greater than one and <code>rotate = TRUE</code> then a rotation
of the variable axes is performed <em>after</em> mode relocation.  The
rotation is based on the Choleski decomposition (see <a href="Matrix.html#topic+chol">chol</a>) of the
estimated Hessian (computed using <code><a href="stats.html#topic+optim">optimHess</a></code>
of the negated
log-density after any user-supplied transformation or Box-Cox
transformation.  If any of the eigenvalues of the estimated Hessian are
non-positive (which may indicate that the estimated mode of <code>logf</code>
is close to a variable boundary) then <code>rotate</code> is set to <code>FALSE</code>
with a warning.  A warning is also given if this happens when
<code>d</code> = 1.
</p>
<p>The default value of the tuning parameter <code>r</code> is 1/2, which is
likely to be close to optimal in many cases, particularly if
<code>trans = "BC"</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"ru"</code> is a list containing the following
components:
</p>
<table>
<tr><td><code>sim_vals</code></td>
<td>
<p>An <code>n</code> by <code>d</code> matrix of simulated values.</p>
</td></tr>
<tr><td><code>box</code></td>
<td>
<p>A (2 * <code>d</code> + 1) by <code>d</code> + 2 matrix of
ratio-of-uniforms bounding box information, with row names indicating
the box parameter.  The columns contain
</p>

<dl>
<dt>column 1</dt><dd><p>values of box parameters.</p>
</dd>
<dt>columns 2 to (2+<code>d</code>-1)</dt><dd><p>values of variables at which
these box parameters are obtained.</p>
</dd>
<dt>column 2+<code>d</code></dt><dd><p>convergence indicators.</p>
</dd>
</dl>

<p>Scaling of f within <code>ru</code> and relocation of the
mode to the origin means that the first row of <code>box</code> will always
be <code>c(1, rep(0, d))</code>.
</p>
</td></tr>
<tr><td><code>pa</code></td>
<td>
<p>A numeric scalar.  An estimate of the probability of
acceptance.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The value of <code>r</code>.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>The value of <code>d</code>.</p>
</td></tr>
<tr><td><code>logf</code></td>
<td>
<p>A function. <code>logf</code> supplied by the user, but
with f scaled by the maximum of the target density used in the
ratio-of-uniforms method (i.e. <code>logf_rho</code>), to avoid numerical
problems in contouring f in <code><a href="#topic+plot.ru">plot.ru</a></code> when
<code>d = 2</code>.</p>
</td></tr>
<tr><td><code>logf_rho</code></td>
<td>
<p>A function. The target function actually used in the
ratio-of-uniforms algorithm.</p>
</td></tr>
<tr><td><code>sim_vals_rho</code></td>
<td>
<p>An <code>n</code> by <code>d</code> matrix of values simulated
from the function used in the ratio-of-uniforms algorithm.</p>
</td></tr>
<tr><td><code>logf_args</code></td>
<td>
<p>A list of further arguments to <code>logf</code>.</p>
</td></tr>
<tr><td><code>f_mode</code></td>
<td>
<p>The estimated mode of the target density f, after any
Box-Cox transformation and/or user supplied transformation, but before
mode relocation.</p>
</td></tr>
<tr><td><code>trans_fn</code></td>
<td>
<p>An R function that performs the inverse transformation
from the transformed variable <code class="reqn">\rho</code>, on which the generalised
ratio-of-uniforms method is performed, back to the original variable
<code class="reqn">\theta</code>. <strong>Note</strong>: <code>trans_fn</code> is <strong>not</strong>
vectorised with respect to <code class="reqn">\rho</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wakefield, J. C., Gelfand, A. E. and Smith, A. F. M. (1991)
Efficient generation of random variates via the ratio-of-uniforms method.
<em>Statistics and Computing</em> (1991), <strong>1</strong>, 129-133.
<a href="https://doi.org/10.1007/BF01889987">doi:10.1007/BF01889987</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ru_rcpp">ru_rcpp</a></code> for a version of <code><a href="#topic+ru">ru</a></code> that uses
the Rcpp package to improve efficiency.
</p>
<p><code><a href="#topic+summary.ru">summary.ru</a></code> for summaries of the simulated values
and properties of the ratio-of-uniforms algorithm.
</p>
<p><code><a href="#topic+plot.ru">plot.ru</a></code> for a diagnostic plot.
</p>
<p><code><a href="#topic+find_lambda_one_d">find_lambda_one_d</a></code> to produce (somewhat) automatically
a list for the argument <code>lambda</code> of <code>ru</code> for the
<code>d</code> = 1 case.
</p>
<p><code><a href="#topic+find_lambda">find_lambda</a></code> to produce (somewhat) automatically
a list for the argument <code>lambda</code> of <code>ru</code> for any value of
<code>d</code>.
</p>
<p><code><a href="stats.html#topic+optim">optim</a></code> for choices of the arguments
<code>a_method</code>, <code>b_method</code>, <code>a_control</code> and <code>b_control</code>.
</p>
<p><code><a href="stats.html#topic+nlminb">nlminb</a></code> for choices of the arguments
<code>a_control</code> and <code>b_control</code>.
</p>
<p><code><a href="stats.html#topic+optim">optimHess</a></code> for Hessian estimation.
</p>
<p><code><a href="base.html#topic+chol">chol</a></code> for the Choleski decomposition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Normal density ===================

# One-dimensional standard normal ----------------
x &lt;- ru(logf = function(x) -x ^ 2 / 2, d = 1, n = 1000, init = 0.1)

# Two-dimensional standard normal ----------------
x &lt;- ru(logf = function(x) -(x[1]^2 + x[2]^2) / 2, d = 2, n = 1000,
        init = c(0, 0))

# Two-dimensional normal with positive association ----------------
rho &lt;- 0.9
covmat &lt;- matrix(c(1, rho, rho, 1), 2, 2)
log_dmvnorm &lt;- function(x, mean = rep(0, d), sigma = diag(d)) {
  x &lt;- matrix(x, ncol = length(x))
  d &lt;- ncol(x)
  - 0.5 * (x - mean) %*% solve(sigma) %*% t(x - mean)
}

# No rotation.
x &lt;- ru(logf = log_dmvnorm, sigma = covmat, d = 2, n = 1000, init = c(0, 0),
        rotate = FALSE)

# With rotation.
x &lt;- ru(logf = log_dmvnorm, sigma = covmat, d = 2, n = 1000, init = c(0, 0))

# three-dimensional normal with positive association ----------------
covmat &lt;- matrix(rho, 3, 3) + diag(1 - rho, 3)

# No rotation.  Slow !
x &lt;- ru(logf = log_dmvnorm, sigma = covmat, d = 3, n = 1000,
        init = c(0, 0, 0), rotate = FALSE)

# With rotation.
x &lt;- ru(logf = log_dmvnorm, sigma = covmat, d = 3, n = 1000,
        init = c(0, 0, 0))

# Log-normal density ===================

# Sampling on original scale ----------------
x &lt;- ru(logf = dlnorm, log = TRUE, d = 1, n = 1000, lower = 0, init = 1)

# Box-Cox transform with lambda = 0 ----------------
lambda &lt;- 0
x &lt;- ru(logf = dlnorm, log = TRUE, d = 1, n = 1000, lower = 0, init = 0.1,
        trans = "BC", lambda = lambda)

# Equivalently, we could use trans = "user" and supply the (inverse) Box-Cox
# transformation and the log-Jacobian by hand
x &lt;- ru(logf = dlnorm, log = TRUE, d = 1, n = 1000, init = 0.1,
        trans = "user", phi_to_theta = function(x) exp(x),
        log_j = function(x) -log(x))

# Gamma(alpha, 1) density ===================

# Note: the gamma density in unbounded when its shape parameter is &lt; 1.
# Therefore, we can only use trans="none" if the shape parameter is &gt;= 1.

# Sampling on original scale ----------------

alpha &lt;- 10
x &lt;- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,
        lower = 0, init = alpha)

alpha &lt;- 1
x &lt;- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,
        lower = 0, init = alpha)

# Box-Cox transform with lambda = 1/3 works well for shape &gt;= 1. -----------

alpha &lt;- 1
x &lt;- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,
        trans = "BC", lambda = 1/3, init = alpha)
summary(x)

# Equivalently, we could use trans = "user" and supply the (inverse) Box-Cox
# transformation and the log-Jacobian by hand

# Note: when phi_to_theta is undefined at x this function returns NA
phi_to_theta  &lt;- function(x, lambda) {
  ifelse(x * lambda + 1 &gt; 0, (x * lambda + 1) ^ (1 / lambda), NA)
}
log_j &lt;- function(x, lambda) (lambda - 1) * log(x)
lambda &lt;- 1/3
x &lt;- ru(logf = dgamma, shape = alpha, log = TRUE, d = 1, n = 1000,
        trans = "user", phi_to_theta = phi_to_theta, log_j = log_j,
        user_args = list(lambda = lambda), init = alpha)
summary(x)


# Generalized Pareto posterior distribution ===================

# Sample data from a GP(sigma, xi) distribution
gpd_data &lt;- rgpd(m = 100, xi = -0.5, sigma = 1)
# Calculate summary statistics for use in the log-likelihood
ss &lt;- gpd_sum_stats(gpd_data)
# Calculate an initial estimate
init &lt;- c(mean(gpd_data), 0)

# Mode relocation only ----------------
n &lt;- 1000
x1 &lt;- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, init = init,
         lower = c(0, -Inf), rotate = FALSE)
plot(x1, xlab = "sigma", ylab = "xi")
# Parameter constraint line xi &gt; -sigma/max(data)
# [This may not appear if the sample is far from the constraint.]
abline(a = 0, b = -1 / ss$xm)
summary(x1)

# Rotation of axes plus mode relocation ----------------
x2 &lt;- ru(logf = gpd_logpost, ss = ss, d = 2, n = n, init = init,
         lower = c(0, -Inf))
plot(x2, xlab = "sigma", ylab = "xi")
abline(a = 0, b = -1 / ss$xm)
summary(x2)

# Cauchy ========================

# The bounding box cannot be constructed if r &lt; 1.  For r = 1 the
# bounding box parameters b1-(r) and b1+(r) are attained in the limits
# as x decreases/increases to infinity respectively.  This is fine in
# theory but using r &gt; 1 avoids this problem and the largest probability
# of acceptance is obtained for r approximately equal to 1.26.

res &lt;- ru(logf = dcauchy, log = TRUE, init = 0, r = 1.26, n = 1000)

# Half-Cauchy ===================

log_halfcauchy &lt;- function(x) {
  return(ifelse(x &lt; 0, -Inf, dcauchy(x, log = TRUE)))
}

# Like the Cauchy case the bounding box cannot be constructed if r &lt; 1.
# We could use r &gt; 1 but the mode is on the edge of the support of the
# density so as an alternative we use a log transformation.

x &lt;- ru(logf = log_halfcauchy, init = 0, trans = "BC", lambda = 0, n = 1000)
x$pa
plot(x, ru_scale = TRUE)

# Example 4 from Wakefield et al. (1991) ===================

# Bivariate normal x bivariate student-t
log_norm_t &lt;- function(x, mean = rep(0, d), sigma1 = diag(d), sigma2 = diag(d)) {
  x &lt;- matrix(x, ncol = length(x))
  log_h1 &lt;- -0.5 * (x - mean) %*% solve(sigma1) %*% t(x - mean)
  log_h2 &lt;- -2 * log(1 + 0.5 * x %*% solve(sigma2) %*% t(x))
  return(log_h1 + log_h2)
}

rho &lt;- 0.9
covmat &lt;- matrix(c(1, rho, rho, 1), 2, 2)
y &lt;- c(0, 0)

# Case in the top right corner of Table 3
x &lt;- ru(logf = log_norm_t, mean = y, sigma1 = covmat, sigma2 = covmat,
  d = 2, n = 10000, init = y, rotate = FALSE)
x$pa

# Rotation increases the probability of acceptance
x &lt;- ru(logf = log_norm_t, mean = y, sigma1 = covmat, sigma2 = covmat,
  d = 2, n = 10000, init = y, rotate = TRUE)
x$pa

# Normal x log-normal: different Box-Cox parameters ==================
norm_lognorm &lt;- function(x, ...) {
  dnorm(x[1], ...) + dlnorm(x[2], ...)
}
x &lt;- ru(logf = norm_lognorm, log = TRUE, n = 1000, d = 2, init = c(-1, 0),
        trans = "BC", lambda = c(1, 0))
plot(x)
plot(x, ru_scale = TRUE)

</code></pre>

<hr>
<h2 id='ru_rcpp'>Generalized ratio-of-uniforms sampling using C++ via Rcpp</h2><span id='topic+ru_rcpp'></span>

<h3>Description</h3>

<p>Uses the generalized ratio-of-uniforms method to simulate from a
distribution with log-density <code class="reqn">\log f</code> (up to an additive
constant). The density <code class="reqn">f</code> must be bounded, perhaps after a
transformation of variable.
The file <code>user_fns.cpp</code> that is sourced before running the examples
below is available at the rust Github page at
<a href="https://raw.githubusercontent.com/paulnorthrop/rust/master/src/user_fns.cpp">https://raw.githubusercontent.com/paulnorthrop/rust/master/src/user_fns.cpp</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ru_rcpp(
  logf,
  ...,
  n = 1,
  d = 1,
  init = NULL,
  mode = NULL,
  trans = c("none", "BC", "user"),
  phi_to_theta = NULL,
  log_j = NULL,
  user_args = list(),
  lambda = rep(1L, d),
  lambda_tol = 1e-06,
  gm = NULL,
  rotate = ifelse(d == 1, FALSE, TRUE),
  lower = rep(-Inf, d),
  upper = rep(Inf, d),
  r = 1/2,
  ep = 0L,
  a_algor = if (d == 1) "nlminb" else "optim",
  b_algor = c("nlminb", "optim"),
  a_method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"),
  b_method = c("Nelder-Mead", "BFGS", "CG", "L-BFGS-B", "SANN", "Brent"),
  a_control = list(),
  b_control = list(),
  var_names = NULL,
  shoof = 0.2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ru_rcpp_+3A_logf">logf</code></td>
<td>
<p>An external pointer to a compiled C++ function returning the
log of the target density <code class="reqn">f</code> evaluated at its first argument.
This function should return <code>-Inf</code> when the density is zero.
It is better to use <code>logf = </code> explicitly, for example,
<code>ru(logf = dnorm, log = TRUE, init = 0.1)</code>,
to avoid argument matching problems.  In contrast,
<code>ru(dnorm, log = TRUE, init = 0.1)</code>
will throw an error because partial matching results in
<code>logf</code> being matched to <code>log = TRUE</code>.
</p>
<p>See the
<a href="https://gallery.rcpp.org/articles/passing-cpp-function-pointers/">
Passing user-supplied C++ functions</a> in the
<a href="https://gallery.rcpp.org/">Rcpp Gallery</a> and the
<strong>Providing a C++ function to <code>ru_rcpp</code></strong> section in the
<a href="https://paulnorthrop.github.io/rust/articles/rust-c-using-rcpp-vignette.html">
Rusting faster: Simulation using Rcpp</a> vignette.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>logf</code> and related
functions.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_n">n</code></td>
<td>
<p>A non-negative integer scalar.  The number of simulated values
required. If <code>n = 0</code> then no simulation is performed but the
component <code>box</code> in the returned object gives the ratio-of-uniforms
bounding box that would have been used.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_d">d</code></td>
<td>
<p>A positive integer scalar. The dimension of <code class="reqn">f</code>.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_init">init</code></td>
<td>
<p>A numeric vector. Initial estimates of the mode of <code>logf</code>.
If <code>trans = "BC"</code> or <code>trans = "user"</code> this is <em>after</em>
Box-Cox transformation or user-defined transformation, but <em>before</em>
any rotation of axes.
If <code>init</code> is not supplied then <code>rep(1, d)</code> is used.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_mode">mode</code></td>
<td>
<p>A numeric vector of length <code>d</code>.  The mode of <code>logf</code>.
If <code>trans = "BC"</code> or <code>trans = "user"</code> this is <em>after</em>
Box-Cox transformation or user-defined transformation, but <em>before</em>
any rotation of axes.  Only supply <code>mode</code> if the mode is known: it
will not be checked.  If <code>mode</code> is supplied then <code>init</code> is
ignored.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_trans">trans</code></td>
<td>
<p>A character scalar. <code>trans = "none"</code> for no
transformation, <code>trans = "BC"</code> for Box-Cox transformation,
<code>trans = "user"</code> for a user-defined transformation.
If <code>trans = "user"</code> then the transformation should be specified
using <code>phi_to_theta</code> and <code>log_j</code> and <code>user_args</code> may be
used to pass arguments to <code>phi_to_theta</code> and <code>log_j</code>.
See <strong>Details</strong> and the <strong>Examples</strong>.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_phi_to_theta">phi_to_theta</code></td>
<td>
<p>An external pointer to a compiled C++ function returning
(the inverse) of the transformation from <code>theta</code> (<code class="reqn">\theta</code>) to
<code>phi</code> (<code class="reqn">\phi</code>) that may be used to ensure positivity of
<code class="reqn">\phi</code> prior to Box-Cox transformation.  The argument is <code>phi</code>
and the returned value is <code>theta</code>.  If <code>phi_to_theta</code> is
undefined at the input value then the function should return <code>NA</code>.
See <strong>Details</strong>.
If <code>lambda$phi_to_theta</code> (see argument <code>lambda</code> below) is
supplied then this is used instead of any function supplied via
<code>phi_to_theta</code>.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_log_j">log_j</code></td>
<td>
<p>An external pointer to a compiled C++ function returning the
log of the Jacobian of the transformation from <code>theta</code> (<code class="reqn">\theta</code>)
to <code>phi</code> (<code class="reqn">\phi</code>), i.e., based on derivatives of <code class="reqn">\phi</code> with
respect to <code class="reqn">\theta</code>. Takes <code>theta</code> as its argument.
If <code>lambda$log_j</code> (see argument <code>lambda</code> below) is
supplied then this is used instead of any function supplied via
<code>log_j</code>.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_user_args">user_args</code></td>
<td>
<p>A list of numeric components. If <code>trans = ``user''</code>
then <code>user_args</code> is a list providing arguments to the user-supplied
functions <code>phi_to_theta</code> and <code>log_j</code>.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_lambda">lambda</code></td>
<td>
<p>Either
</p>

<ul>
<li><p> A numeric vector.  Box-Cox transformation parameters, or
</p>
</li>
<li><p> A list with components
</p>

<dl>
<dt>lambda</dt><dd><p>A numeric vector.  Box-Cox parameters (required).</p>
</dd>
<dt>gm</dt><dd><p>A numeric vector.  Box-cox scaling parameters (optional).
If supplied this overrides any <code>gm</code> supplied by the individual
<code>gm</code> argument described below.</p>
</dd>
<dt>init_psi</dt><dd><p>A numeric vector.  Initial estimate of mode <em>after</em>
Box-Cox transformation (optional).</p>
</dd>
<dt>sd_psi</dt><dd><p>A numeric vector.  Estimates of the marginal standard
deviations of the Box-Cox transformed variables (optional).</p>
</dd>
<dt>phi_to_theta</dt><dd><p>as above (optional).</p>
</dd>
<dt>log_j</dt><dd><p>As above (optional).</p>
</dd>
<dt>user_args</dt><dd><p>As above (optional).</p>
</dd>
</dl>

<p>This list may be created using <code><a href="#topic+find_lambda_one_d_rcpp">find_lambda_one_d_rcpp</a></code>
(for <code>d</code> = 1) or <code><a href="#topic+find_lambda_rcpp">find_lambda_rcpp</a></code> (for any <code>d</code>).
</p>
</li></ul>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_lambda_tol">lambda_tol</code></td>
<td>
<p>A numeric scalar.  Any values in lambda that are less
than <code>lambda_tol</code> in magnitude are set to zero.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_gm">gm</code></td>
<td>
<p>A numeric vector. Box-cox scaling parameters (optional). If
<code>lambda$gm</code> is supplied in input list <code>lambda</code> then
<code>lambda$gm</code> is used, not <code>gm</code>.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_rotate">rotate</code></td>
<td>
<p>A logical scalar. If TRUE (<code>d</code> &gt; 1 only) use Choleski
rotation.  If d = 1 and <code>rotate = TRUE</code> then rotate will be set to
FALSE with a warning.  See <strong>Details</strong>.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_lower">lower</code>, <code id="ru_rcpp_+3A_upper">upper</code></td>
<td>
<p>Numeric vectors.  Lower/upper bounds on the arguments of
the function <em>after</em> any transformation from theta to phi implied by
the inverse of <code>phi_to_theta</code>. If <code>rotate = FALSE</code> these
are used in all of the optimisations used to construct the bounding box.
If <code>rotate = TRUE</code> then they are use only in the first optimisation
to maximise the target density.'
If <code>trans = "BC"</code> components of <code>lower</code> that are negative are
set to zero without warning and the bounds implied after the Box-Cox
transformation are calculated inside <code>ru</code>.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_r">r</code></td>
<td>
<p>A numeric scalar.  Parameter of generalized ratio-of-uniforms.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_ep">ep</code></td>
<td>
<p>A numeric scalar.  Controls initial estimates for optimisations
to find the <code class="reqn">b</code>-bounding box parameters.  The default (<code>ep</code>=0)
corresponds to starting at the mode of <code>logf</code> small positive values
of <code>ep</code> move the constrained variable slightly away from the mode in
the correct direction.  If <code>ep</code> is negative its absolute value is
used, with no warning given.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_a_algor">a_algor</code>, <code id="ru_rcpp_+3A_b_algor">b_algor</code></td>
<td>
<p>Character scalars.  Either <code>"nlminb"</code> or
<code>"optim".</code>
Respective optimisation algorithms used to find <code class="reqn">a(r)</code> and
(<code class="reqn">b</code><sub>i</sub><sup>-</sup>(r),
<code class="reqn">b</code><sub>i</sub><sup>+</sup>(r)).</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_a_method">a_method</code>, <code id="ru_rcpp_+3A_b_method">b_method</code></td>
<td>
<p>Character scalars.  Respective methods used by
<code>optim</code> to find <code class="reqn">a(r)</code> and
(<code class="reqn">b</code><sub>i</sub><sup>-</sup>(r),
<code class="reqn">b</code><sub>i</sub><sup>+</sup>(r)).
Only used if <code>optim</code> is the chosen algorithm.  If <code>d</code> = 1 then
<code>a_method</code> and <code>b_method</code> are set to <code>"Brent"</code> without
warning.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_a_control">a_control</code>, <code id="ru_rcpp_+3A_b_control">b_control</code></td>
<td>
<p>Lists of control arguments to <code>optim</code> or
<code>nlminb</code> to find <code class="reqn">a(r)</code> and
(<code class="reqn">b</code><sub>i</sub><sup>-</sup>(r),
<code class="reqn">b</code><sub>i</sub><sup>+</sup>(r))
respectively.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_var_names">var_names</code></td>
<td>
<p>A character (or numeric) vector of length <code>d</code>.  Names
to give to the column(s) of the simulated values.</p>
</td></tr>
<tr><td><code id="ru_rcpp_+3A_shoof">shoof</code></td>
<td>
<p>A numeric scalar in [0, 1].  Sometimes a spurious
non-zero convergence indicator is returned from
<code><a href="stats.html#topic+optim">optim</a></code> or <code><a href="stats.html#topic+nlminb">nlminb</a></code>).
In this event we try to check that a minimum has indeed been found using
different algorithm.  <code>shoof</code> controls the starting value provided
to this algorithm.
If <code>shoof = 0</code> then we start from the current solution.
If <code>shoof = 1</code> then we start from the initial estimate provided
to the previous minimisation.  Otherwise, <code>shoof</code> interpolates
between these two extremes, with a value close to zero giving a starting
value that is close to the current solution.
The exception to this is when the initial and current solutions are equal.
Then we start from the current solution multiplied by <code>1 - shoof</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For information about the generalised ratio-of-uniforms method and
transformations see the
<a href="https://paulnorthrop.github.io/rust/articles/rust-a-vignette.html">
Introducing rust</a> vignette. See also
<a href="https://paulnorthrop.github.io/rust/articles/rust-c-using-rcpp-vignette.html">
Rusting faster: Simulation using Rcpp</a>
These vignettes can also be accessed using
<code>vignette("rust-a-vignette", package = "rust")</code> and
<code>vignette("rust-c-using-rcpp-vignette", package = "rust")</code>.
</p>
<p>If <code>trans = "none"</code> and <code>rotate = FALSE</code> then <code>ru</code>
implements the (multivariate) generalized ratio of uniforms method
described in Wakefield, Gelfand and Smith (1991) using a target
density whose mode is relocated to the origin (&lsquo;mode relocation&rsquo;) in the
hope of increasing efficiency.
</p>
<p>If <code>trans = "BC"</code> then marginal Box-Cox transformations of each of
the <code>d</code> variables is performed, with parameters supplied in
<code>lambda</code>.  The function <code>phi_to_theta</code> may be used, if
necessary, to ensure positivity of the variables prior to Box-Cox
transformation.
</p>
<p>If <code>trans = "user"</code> then the function <code>phi_to_theta</code> enables
the user to specify their own transformation.
</p>
<p>In all cases the mode of the target function is relocated to the origin
<em>after</em> any user-supplied transformation and/or Box-Cox
transformation.
</p>
<p>If <code>d</code> is greater than one and <code>rotate = TRUE</code> then a rotation
of the variable axes is performed <em>after</em> mode relocation.  The
rotation is based on the Choleski decomposition (see <a href="Matrix.html#topic+chol">chol</a>) of the
estimated Hessian (computed using <code><a href="stats.html#topic+optim">optimHess</a></code>
of the negated
log-density after any user-supplied transformation or Box-Cox
transformation.  If any of the eigenvalues of the estimated Hessian are
non-positive (which may indicate that the estimated mode of <code>logf</code>
is close to a variable boundary) then <code>rotate</code> is set to <code>FALSE</code>
with a warning.  A warning is also given if this happens when
<code>d</code> = 1.
</p>
<p>The default value of the tuning parameter <code>r</code> is 1/2, which is
likely to be close to optimal in many cases, particularly if
<code>trans = "BC"</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"ru"</code> is a list containing the following
components:
</p>
<table>
<tr><td><code>sim_vals</code></td>
<td>
<p>An <code>n</code> by <code>d</code> matrix of simulated values.</p>
</td></tr>
<tr><td><code>box</code></td>
<td>
<p>A (2 * <code>d</code> + 1) by <code>d</code> + 2 matrix of
ratio-of-uniforms bounding box information, with row names indicating
the box parameter.  The columns contain
</p>

<dl>
<dt>column 1</dt><dd><p>values of box parameters.</p>
</dd>
<dt>columns 2 to (2+<code>d</code>-1)</dt><dd><p>values of variables at which
these box parameters are obtained.</p>
</dd>
<dt>column 2+<code>d</code></dt><dd><p>convergence indicators.</p>
</dd>
</dl>

<p>Scaling of f within <code>ru</code> and relocation of the
mode to the origin means that the first row of <code>box</code> will always
be <code>c(1, rep(0, d))</code>.
</p>
</td></tr>
<tr><td><code>pa</code></td>
<td>
<p>A numeric scalar.  An estimate of the probability of
acceptance.</p>
</td></tr>
<tr><td><code>r</code></td>
<td>
<p>The value of <code>r</code>.</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>The value of <code>d</code>.</p>
</td></tr>
<tr><td><code>logf</code></td>
<td>
<p>A function. <code>logf</code> supplied by the user, but
with f scaled by the maximum of the target density used in the
ratio-of-uniforms method (i.e. <code>logf_rho</code>), to avoid numerical
problems in contouring f in <code><a href="#topic+plot.ru">plot.ru</a></code> when
<code>d = 2</code>.</p>
</td></tr>
<tr><td><code>logf_rho</code></td>
<td>
<p>A function. The target function actually used in the
ratio-of-uniforms algorithm.</p>
</td></tr>
<tr><td><code>sim_vals_rho</code></td>
<td>
<p>An <code>n</code> by <code>d</code> matrix of values simulated
from the function used in the ratio-of-uniforms algorithm.</p>
</td></tr>
<tr><td><code>logf_args</code></td>
<td>
<p>A list of further arguments to <code>logf</code>.</p>
</td></tr>
<tr><td><code>logf_rho_args</code></td>
<td>
<p>A list of further arguments to <code>logf_rho</code>.
Note: this component is returned by <code>ru_rcpp</code> but not
by <code>ru</code>.</p>
</td></tr>
<tr><td><code>f_mode</code></td>
<td>
<p>The estimated mode of the target density f, after any
Box-Cox transformation and/or user supplied transformation, but before
mode relocation.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Wakefield, J. C., Gelfand, A. E. and Smith, A. F. M. (1991)
Efficient generation of random variates via the ratio-of-uniforms method.
<em>Statistics and Computing</em> (1991), <strong>1</strong>, 129-133.
<a href="https://doi.org/10.1007/BF01889987">doi:10.1007/BF01889987</a>.
</p>
<p>Eddelbuettel, D. and Francois, R. (2011). Rcpp: Seamless
R and C++ Integration. <em>Journal of Statistical Software</em>,
<strong>40</strong>(8), 1-18. <a href="https://doi.org/10.18637/jss.v040.i08">doi:10.18637/jss.v040.i08</a>
</p>
<p>Eddelbuettel, D. (2013). <em>Seamless R and C++ Integration
with Rcpp</em>, Springer, New York. ISBN 978-1-4614-6867-7.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ru">ru</a></code> for a version of <code><a href="#topic+ru_rcpp">ru_rcpp</a></code> that
accepts R functions as arguments.
</p>
<p><code><a href="#topic+summary.ru">summary.ru</a></code> for summaries of the simulated values
and properties of the ratio-of-uniforms algorithm.
</p>
<p><code><a href="#topic+plot.ru">plot.ru</a></code> for a diagnostic plot.
</p>
<p><code><a href="#topic+find_lambda_one_d_rcpp">find_lambda_one_d_rcpp</a></code> to produce (somewhat)
automatically a list for the argument <code>lambda</code> of <code>ru</code> for the
<code>d</code> = 1 case.
</p>
<p><code><a href="#topic+find_lambda_rcpp">find_lambda_rcpp</a></code> to produce (somewhat) automatically
a list for the argument <code>lambda</code> of <code>ru</code> for any value of
<code>d</code>.
</p>
<p><code><a href="stats.html#topic+optim">optim</a></code> for choices of the arguments
<code>a_method</code>, <code>b_method</code>, <code>a_control</code> and <code>b_control</code>.
</p>
<p><code><a href="stats.html#topic+nlminb">nlminb</a></code> for choices of the arguments
<code>a_control</code> and <code>b_control</code>.
</p>
<p><code><a href="stats.html#topic+optim">optimHess</a></code> for Hessian estimation.
</p>
<p><code><a href="base.html#topic+chol">chol</a></code> for the Choleski decomposition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 1000

# Normal density ===================

# One-dimensional standard normal ----------------
ptr_N01 &lt;- create_xptr("logdN01")
x &lt;- ru_rcpp(logf = ptr_N01, d = 1, n = n, init = 0.1)

# Two-dimensional standard normal ----------------
ptr_bvn &lt;- create_xptr("logdnorm2")
rho &lt;- 0
x &lt;- ru_rcpp(logf = ptr_bvn, rho = rho, d = 2, n = n,
  init = c(0, 0))

# Two-dimensional normal with positive association ===================
rho &lt;- 0.9
# No rotation.
x &lt;- ru_rcpp(logf = ptr_bvn, rho = rho, d = 2, n = n, init = c(0, 0),
             rotate = FALSE)

# With rotation.
x &lt;- ru_rcpp(logf = ptr_bvn, rho = rho, d = 2, n = n, init = c(0, 0))

# Using general multivariate normal function.
ptr_mvn &lt;- create_xptr("logdmvnorm")
covmat &lt;- matrix(rho, 2, 2) + diag(1 - rho, 2)
x &lt;- ru_rcpp(logf = ptr_mvn, sigma = covmat, d = 2, n = n, init = c(0, 0))

# Three-dimensional normal with positive association ----------------
covmat &lt;- matrix(rho, 3, 3) + diag(1 - rho, 3)

# No rotation.
x &lt;- ru_rcpp(logf = ptr_mvn, sigma = covmat, d = 3, n = n,
             init = c(0, 0, 0), rotate = FALSE)

# With rotation.
x &lt;- ru_rcpp(logf = ptr_mvn, sigma = covmat, d = 3, n = n,
             init = c(0, 0, 0))

# Log-normal density ===================

ptr_lnorm &lt;- create_xptr("logdlnorm")
mu &lt;- 0
sigma &lt;- 1
# Sampling on original scale ----------------
x &lt;- ru_rcpp(logf = ptr_lnorm, mu = mu, sigma = sigma, d = 1, n = n,
             lower = 0, init = exp(mu))

# Box-Cox transform with lambda = 0 ----------------
lambda &lt;- 0
x &lt;- ru_rcpp(logf = ptr_lnorm, mu = mu, sigma = sigma, d = 1, n = n,
             lower = 0, init = exp(mu), trans = "BC", lambda = lambda)

# Equivalently, we could use trans = "user" and supply the (inverse) Box-Cox
# transformation and the log-Jacobian by hand
ptr_phi_to_theta_lnorm &lt;- create_phi_to_theta_xptr("exponential")
ptr_log_j_lnorm &lt;- create_log_j_xptr("neglog")
x &lt;- ru_rcpp(logf = ptr_lnorm, mu = mu, sigma = sigma, d = 1, n = n,
  init = 0.1, trans = "user", phi_to_theta = ptr_phi_to_theta_lnorm,
  log_j = ptr_log_j_lnorm)

# Gamma (alpha, 1) density ===================

# Note: the gamma density in unbounded when its shape parameter is &lt; 1.
# Therefore, we can only use trans="none" if the shape parameter is &gt;= 1.

# Sampling on original scale ----------------

ptr_gam &lt;- create_xptr("logdgamma")
alpha &lt;- 10
x &lt;- ru_rcpp(logf = ptr_gam, alpha = alpha, d = 1, n = n,
  lower = 0, init = alpha)

alpha &lt;- 1
x &lt;- ru_rcpp(logf = ptr_gam, alpha = alpha, d = 1, n = n,
  lower = 0, init = alpha)

# Box-Cox transform with lambda = 1/3 works well for shape &gt;= 1. -----------

alpha &lt;- 1
x &lt;- ru_rcpp(logf = ptr_gam, alpha = alpha, d = 1, n = n,
  trans = "BC", lambda = 1/3, init = alpha)
summary(x)

# Equivalently, we could use trans = "user" and supply the (inverse) Box-Cox
# transformation and the log-Jacobian by hand

lambda &lt;- 1/3
ptr_phi_to_theta_bc &lt;- create_phi_to_theta_xptr("bc")
ptr_log_j_bc &lt;- create_log_j_xptr("bc")
x &lt;- ru_rcpp(logf = ptr_gam, alpha = alpha, d = 1, n = n,
  trans = "user", phi_to_theta = ptr_phi_to_theta_bc, log_j = ptr_log_j_bc,
  user_args = list(lambda = lambda), init = alpha)
summary(x)


# Generalized Pareto posterior distribution ===================

# Sample data from a GP(sigma, xi) distribution
gpd_data &lt;- rgpd(m = 100, xi = -0.5, sigma = 1)
# Calculate summary statistics for use in the log-likelihood
ss &lt;- gpd_sum_stats(gpd_data)
# Calculate an initial estimate
init &lt;- c(mean(gpd_data), 0)

n &lt;- 1000
# Mode relocation only ----------------
ptr_gp &lt;- create_xptr("loggp")
for_ru_rcpp &lt;- c(list(logf = ptr_gp, init = init, d = 2, n = n,
                 lower = c(0, -Inf)), ss, rotate = FALSE)
x1 &lt;- do.call(ru_rcpp, for_ru_rcpp)
plot(x1, xlab = "sigma", ylab = "xi")
# Parameter constraint line xi &gt; -sigma/max(data)
# [This may not appear if the sample is far from the constraint.]
abline(a = 0, b = -1 / ss$xm)
summary(x1)

# Rotation of axes plus mode relocation ----------------
for_ru_rcpp &lt;- c(list(logf = ptr_gp, init = init, d = 2, n = n,
                 lower = c(0, -Inf)), ss)
x2 &lt;- do.call(ru_rcpp, for_ru_rcpp)
plot(x2, xlab = "sigma", ylab = "xi")
abline(a = 0, b = -1 / ss$xm)
summary(x2)

# Cauchy ========================

ptr_c &lt;- create_xptr("logcauchy")

# The bounding box cannot be constructed if r &lt; 1.  For r = 1 the
# bounding box parameters b1-(r) and b1+(r) are attained in the limits
# as x decreases/increases to infinity respectively.  This is fine in
# theory but using r &gt; 1 avoids this problem and the largest probability
# of acceptance is obtained for r approximately equal to 1.26.

res &lt;- ru_rcpp(logf = ptr_c, log = TRUE, init = 0, r = 1.26, n = 1000)

# Half-Cauchy ===================

ptr_hc &lt;- create_xptr("loghalfcauchy")

# Like the Cauchy case the bounding box cannot be constructed if r &lt; 1.
# We could use r &gt; 1 but the mode is on the edge of the support of the
# density so as an alternative we use a log transformation.

x &lt;- ru_rcpp(logf = ptr_hc, init = 0, trans = "BC", lambda = 0, n = 1000)
x$pa
plot(x, ru_scale = TRUE)

# Example 4 from Wakefield et al. (1991) ===================
# Bivariate normal x bivariate student-t

ptr_normt &lt;- create_xptr("lognormt")
rho &lt;- 0.9
covmat &lt;- matrix(c(1, rho, rho, 1), 2, 2)
y &lt;- c(0, 0)

# Case in the top right corner of Table 3
x &lt;- ru_rcpp(logf = ptr_normt, mean = y, sigma1 = covmat, sigma2 = covmat,
  d = 2, n = 10000, init = y, rotate = FALSE)
x$pa

# Rotation increases the probability of acceptance
x &lt;- ru_rcpp(logf = ptr_normt, mean = y, sigma1 = covmat, sigma2 = covmat,
  d = 2, n = 10000, init = y, rotate = TRUE)
x$pa


</code></pre>

<hr>
<h2 id='rust-internal'>Internal rust functions</h2><span id='topic+rust-internal'></span><span id='topic+box_cox'></span><span id='topic+box_cox_vec'></span><span id='topic+optim_box_cox'></span><span id='topic+n_grid_fn'></span><span id='topic+init_psi_calc'></span><span id='topic+log_gpd_mdi_prior'></span><span id='topic+gpd_loglik'></span><span id='topic+gpd_mle'></span><span id='topic+fallback_gp_mle'></span><span id='topic+gpd_obs_info'></span><span id='topic+find_a'></span><span id='topic+find_bs'></span><span id='topic+cpp_find_a'></span><span id='topic+cpp_find_bs'></span><span id='topic+fac3'></span>

<h3>Description</h3>

<p>Internal rust functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box_cox(x, lambda = 1, gm = 1, lambda_tol = 1e-06)

box_cox_vec(x, lambda = 1, gm = 1, lambda_tol = 1e-06)

optim_box_cox(
  x,
  w,
  lambda_range = c(-3, 3),
  start = NULL,
  which_lam = 1:ncol(x)
)

n_grid_fn(d)

init_psi_calc(phi_to_psi, phi, lambda, gm, w, which_lam)

log_gpd_mdi_prior(pars)

gpd_loglik(pars, gpd_data, m, xm, sum_gp)

gpd_mle(gpd_data)

fallback_gp_mle(init, ...)

gpd_obs_info(gpd_pars, y, eps = 1e-05, m = 3)

find_a(
  neg_logf_rho,
  init_psi,
  d,
  r,
  lower,
  upper,
  algor,
  method,
  control,
  shoof,
  ...
)

find_bs(
  f_rho,
  d,
  r,
  lower,
  upper,
  f_mode,
  ep,
  vals,
  conv,
  algor,
  method,
  control,
  shoof,
  ...
)

cpp_find_a(
  init_psi,
  lower,
  upper,
  algor,
  method,
  control,
  a_obj_fun,
  ru_args,
  shoof
)

cpp_find_bs(
  lower,
  upper,
  ep,
  vals,
  conv,
  algor,
  method,
  control,
  lower_box_fun,
  upper_box_fun,
  ru_args,
  shoof
)

fac3(d)
</code></pre>


<h3>Details</h3>

<p>These functions are not intended to be called by the user.
</p>

<hr>
<h2 id='rust-package'>rust: Ratio-of-Uniforms Simulation with Transformation</h2><span id='topic+rust'></span><span id='topic+rust-package'></span>

<h3>Description</h3>

<p>Uses the multivariate generalized ratio-of-uniforms method to simulate from a
distribution with log-density <code>logf</code> (up to an additive constant).
<code>logf</code> must be bounded, perhaps after a transformation of variable.
</p>


<h3>Details</h3>

<p>The main functions in the rust package are <code><a href="#topic+ru">ru</a></code> and
<code><a href="#topic+ru_rcpp">ru_rcpp</a></code>, which implement the generalized ratio-of-uniforms
algorithm.  The latter uses the Rcpp package to improve efficiency.
Also provided are two functions,
<code><a href="#topic+find_lambda">find_lambda</a></code> and <code><a href="#topic+find_lambda_one_d">find_lambda_one_d</a></code>, that may be
used to set a suitable value for the parameter <code>lambda</code> if Box-Cox
transformation is used prior to simulation.
If <code><a href="#topic+ru_rcpp">ru_rcpp</a></code> is used the equivalent functions are
<code>find_lambda_rcpp</code> and <code>find_lambda_one_d_rcpp</code>
Basic <code>plot</code> and <code>summary</code> methods are also provided.
</p>
<p>See the following package vignettes for information:
</p>

<ul>
<li>
<p><a href="https://paulnorthrop.github.io/rust/articles/rust-a-vignette.html">
Introducing rust</a> or <code>vignette("rust-a-vignette", package = "rust")</code>.
</p>
</li>
<li>
<p><a href="https://paulnorthrop.github.io/rust/articles/rust-b-when-to-use-vignette.html">
When can rust be used?</a> or
<code>vignette("rust-b-when-to-use-vignette", package = "rust")</code>.
</p>
</li>
<li>
<p><a href="https://paulnorthrop.github.io/rust/articles/rust-c-using-rcpp-vignette.html">
Rusting faster: Simulation using Rcpp</a> or
<code>vignette("rust-c-using-rcpp-vignette", package = "rust")</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Paul J. Northrop <a href="mailto:p.northrop@ucl.ac.uk">p.northrop@ucl.ac.uk</a> [copyright holder]
</p>


<h3>References</h3>

<p>Wakefield, J. C., Gelfand, A. E. and Smith, A. F. M. Efficient
generation of random variates via the ratio-of-uniforms method. Statistics
and Computing (1991) 1, 129-133.
<a href="https://doi.org/10.1007/BF01889987">doi:10.1007/BF01889987</a>.
</p>
<p>Box, G. and Cox, D. R. (1964) An Analysis of Transformations.
Journal of the Royal Statistical Society. Series B (Methodological), 26(2),
211-252.
</p>
<p>Eddelbuettel, D. and Francois, R. (2011). Rcpp: Seamless R and
C++ Integration. Journal of Statistical Software, 40(8), 1-18.
<a href="https://doi.org/10.18637/jss.v040.i08">doi:10.18637/jss.v040.i08</a>.
</p>
<p>Eddelbuettel, D. (2013) Seamless R and C++ Integration with
Rcpp. Springer, New York. ISBN 978-1-4614-6867-7.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ru">ru</a></code> and <code><a href="#topic+ru_rcpp">ru_rcpp</a></code> to perform
ratio-of-uniforms sampling.
</p>
<p><code><a href="#topic+summary.ru">summary.ru</a></code> for summaries of the simulated values
and properties of the ratio-of-uniforms algorithm.
</p>
<p><code><a href="#topic+plot.ru">plot.ru</a></code> for a diagnostic plot.
</p>
<p><code><a href="#topic+find_lambda_one_d">find_lambda_one_d</a></code> and
<code><a href="#topic+find_lambda_one_d_rcpp">find_lambda_one_d_rcpp</a></code> to produce (somewhat) automatically
a list for the argument <code>lambda</code> of <code>ru</code> for the
<code>d</code> = 1 case.
</p>
<p><code><a href="#topic+find_lambda">find_lambda</a></code> and <code><a href="#topic+find_lambda_rcpp">find_lambda_rcpp</a></code>
to produce (somewhat) automatically
a list for the argument <code>lambda</code> of <code>ru</code> for any value of
<code>d</code>.
</p>

<hr>
<h2 id='summary.ru'>Summarizing ratio-of-uniforms samples</h2><span id='topic+summary.ru'></span><span id='topic+print.summary.ru'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"ru"</code>.
</p>
<p><code>print</code> method for an object <code>object</code> of class
<code>"summary.ru"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ru'
summary(object, ...)

## S3 method for class 'summary.ru'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ru_+3A_object">object</code></td>
<td>
<p>an object of class <code>"ru"</code>, a result of a call to
<code>ru</code>.</p>
</td></tr>
<tr><td><code id="summary.ru_+3A_...">...</code></td>
<td>
<p>For <code>summary.lm</code>: additional arguments passed to
<code><a href="base.html#topic+summary">summary</a></code>.
For <code>print.lm</code>: additional optional arguments passed to
<code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
<tr><td><code id="summary.ru_+3A_x">x</code></td>
<td>
<p>an object of class <code>"summary.ru"</code>, a result of a call to
<code><a href="#topic+summary.ru">summary.ru</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>summary.lm</code>: a list of the following components from
<code>object</code>:
</p>

<ul>
<li><p> information about the ratio-of-uniforms bounding box, i.e.,
<code>object$box</code>
</p>
</li>
<li><p> an estimate of the probability of acceptance, i.e.,
<code>object$pa</code>
</p>
</li>
<li><p> a summary of the simulated values, via
<code>summary(object$sim_vals)</code>
</p>
</li></ul>

<p>For <code>print.summary.ru</code>: the argument <code>x</code>, invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ru">ru</a></code> for descriptions of <code>object$sim_vals</code> and
<code>object$box</code>.
</p>
<p><code><a href="#topic+plot.ru">plot.ru</a></code> for a diagnostic plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># one-dimensional standard normal ----------------
x &lt;- ru(logf = function(x) -x ^ 2 / 2, d = 1, n = 1000, init = 0)
summary(x)

# two-dimensional normal with positive association ----------------
rho &lt;- 0.9
covmat &lt;- matrix(c(1, rho, rho, 1), 2, 2)
log_dmvnorm &lt;- function(x, mean = rep(0, d), sigma = diag(d)) {
  x &lt;- matrix(x, ncol = length(x))
  d &lt;- ncol(x)
  - 0.5 * (x - mean) %*% solve(sigma) %*% t(x - mean)
}
x &lt;- ru(logf = log_dmvnorm, sigma = covmat, d = 2, n = 1000, init = c(0, 0))
summary(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
