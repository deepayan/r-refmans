<!DOCTYPE html><html><head><title>Help for package Rquake</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Rquake}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ASW.vel'><p>1D Velocity Ecuador</p></a></li>
<li><a href='#BLACKJACK'><p>Jackknife earthquake location</p></a></li>
<li><a href='#checkLOCATEinput'><p>Check Location data</p></a></li>
<li><a href='#clusterWPX'><p>Cluster Analysis of Picks</p></a></li>
<li><a href='#CONTPF'><p>Button to Contour Pickfile Arrivals</p></a></li>
<li><a href='#contPFarrivals'><p>Contour Pickfile Arrivals</p></a></li>
<li><a href='#coso_sta_LLZ'><p>Coso Station File</p></a></li>
<li><a href='#cosopix'><p>Selection of pickfiles from Coso Geothermal Field</p></a></li>
<li><a href='#defaultVEL'><p>Default Velocity Function</p></a></li>
<li><a href='#DistWeight'><p>Distance wheighting</p></a></li>
<li><a href='#doAmap'><p>Plot a map of station locations</p></a></li>
<li><a href='#eqlipse'><p>Error Elipse for Hypocenter Location</p></a></li>
<li><a href='#eqwrapup'><p>Earthquake Wrap Uo</p></a></li>
<li><a href='#EQXYresid'><p>Calculate Residuals</p></a></li>
<li><a href='#euler_passive'><p>Euler Rotation Angles</p></a></li>
<li><a href='#getEulers'><p>Get Eulers Angles</p></a></li>
<li><a href='#getGAP'><p>Get Seismic Gap</p></a></li>
<li><a href='#GETpsTT'><p>Get Pand S travel times and derivatives</p></a></li>
<li><a href='#getregionals'><p>Extract regional events</p></a></li>
<li><a href='#getresidTT'><p>Travel time residuals</p></a></li>
<li><a href='#Gfirstguess'><p>First guess from a pick file</p></a></li>
<li><a href='#gMAP'><p>Generic Map Button</p></a></li>
<li><a href='#GPIX'><p>PICK Buttons for swig</p></a></li>
<li><a href='#HiJACK'><p>Jackknife a list of events</p></a></li>
<li><a href='#imageINFLUENCE'><p>Image Influence of stations</p></a></li>
<li><a href='#INITpickfile'><p>Initialize a pickfile</p></a></li>
<li><a href='#Klocate'><p>Earthquake Hypocenter Location</p></a></li>
<li><a href='#lastPIX'><p>Last Pix</p></a></li>
<li><a href='#latlonz2wpx'><p>Add Lat-Lon-Z to WPX list</p></a></li>
<li><a href='#LDATlist'><p>List location data</p></a></li>
<li><a href='#LeftjustTime'><p>Adjust times relative to</p>
least minute.</a></li>
<li><a href='#legitWPX'><p>Legitimate Pix</p></a></li>
<li><a href='#MeanStaDist'><p>Mean Station Distance</p></a></li>
<li><a href='#NLSlocate'><p>Nonlinear Least Squares Location</p></a></li>
<li><a href='#OnePerSta'><p>One Phase Pick Per Station</p></a></li>
<li><a href='#PCfiledatetime'><p>Create a character string from a date</p></a></li>
<li><a href='#PCsaveWPX'><p>Save WPX list</p></a></li>
<li><a href='#PFoutput'><p>Write a pickfile to disk</p></a></li>
<li><a href='#Pick3'><p>PICK Buttons for swig</p></a></li>
<li><a href='#plotEQ'><p>Plot Earthquake location</p></a></li>
<li><a href='#plotJACKLLZ'><p>BoxPlot Jackknife of station locations</p></a></li>
<li><a href='#PostREQquake'><p>Post Processing on EQrquake</p></a></li>
<li><a href='#PostVquake'><p>Plotting error ellipsoids of many events</p></a></li>
<li><a href='#Qrangedatetime'><p>Range of Date Time</p></a></li>
<li><a href='#ReSet'><p>Button to reset the choices of station and component</p></a></li>
<li><a href='#ripper'><p>Rip off Event location information</p></a></li>
<li><a href='#Rowz2Keep'><p>Rows to Keep for inversion</p></a></li>
<li><a href='#RQ'><p>Rquake Button</p></a></li>
<li><a href='#Rquake-package'>
<p>Seismic Analysis of Earthquake Hypocenter determination</p></a></li>
<li><a href='#SavePF'><p>Save Pick File Button</p></a></li>
<li><a href='#SELstaDB'><p>Pick stations and components</p>
interactively</a></li>
<li><a href='#UPdateEQLOC'><p>Update an Earthquake location</p></a></li>
<li><a href='#Vlocate'><p>Hypocenter Determination</p></a></li>
<li><a href='#XYerror.bars'><p>Error Bars in X and Y</p></a></li>
<li><a href='#XYlocate'><p>Locate Earthquake with UTM projection</p></a></li>
<li><a href='#XYSETUP'><p>Set up matrix for hypocenter inversion</p></a></li>
<li><a href='#Y2Pphase'>
<p>Convert Y-phase to P-phase</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Seismic Hypocenter Determination</td>
</tr>
<tr>
<td>Version:</td>
<td>2.5-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-22</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>RPMG, RSEIS, GEOmap, MBA, minpack.lm</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan M. Lees [aut, cre],
  Baptiste Auguie [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Non-linear inversion for hypocenter estimation and analysis of seismic data collected continuously, or in trigger mode. The functions organize other functions from 'RSEIS' and 'GEOmap' to help researchers pick, locate, and store hypocenters for detailed seismic investigation. Error ellipsoids and station influence are estimated via jackknife analysis. References include  Iversen, E. S., and J. M. Lees (1996)&lt;<a href="https://doi.org/10.1785%2FBSSA0860061853">doi:10.1785/BSSA0860061853</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-05 15:19:18 UTC; lees</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-05 17:00:24 UTC</td>
</tr>
</table>
<hr>
<h2 id='ASW.vel'>1D Velocity Ecuador</h2><span id='topic+ASW.vel'></span><span id='topic+LITHOS.vel'></span><span id='topic+StHelens4.vel'></span><span id='topic+fuj1.vel'></span><span id='topic+jap1.vel'></span><span id='topic+montserat.vel'></span><span id='topic+wu_coso.vel'></span>

<h3>Description</h3>

<p>1D Velocity Ecuador
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ASW.vel)
</code></pre>


<h3>Format</h3>

<p>a list of velocities for hypocenter relocation
</p>


<h3>Source</h3>

<p>Mario Ruiz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ASW.vel)
data(wu_coso.vel)
data(fuj1.vel)
data(LITHOS.vel)

RSEIS::Comp1Dvels(c("ASW.vel","wu_coso.vel",  "fuj1.vel" , "LITHOS.vel"  ))


</code></pre>

<hr>
<h2 id='BLACKJACK'>Jackknife earthquake location
</h2><span id='topic+BLACKJACK'></span>

<h3>Description</h3>

<p>Perform jackknife on earthquake location
by eliminating stations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BLACKJACK(Ldat, vel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BLACKJACK_+3A_ldat">Ldat</code></td>
<td>
<p>event list
</p>
</td></tr>
<tr><td><code id="BLACKJACK_+3A_vel">vel</code></td>
<td>
<p>Velocity model
</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Stations are eliminated, not rows.
</p>


<h3>Value</h3>

<p>event list with pseudo values
</p>


<h3>Note</h3>

<p>events are located with P and S-wave arrivals,
but code here should eliminate just stations.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Iversen, E. S., and J. M. Lees (1996), A statistical technique for validating velocity models, Bull. Seismol. Soc. Am. 86(6), 1853-1862.
</p>


<h3>See Also</h3>

<p>Vlocate, plotJACKLLZ
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

###### lps=list of files names to be read

data(GH, package='RSEIS')

g1 = GH$pickfile
data(VELMOD1D, package='RSEIS')

vel= VELMOD1D

 w1 = which(!is.na(g1$STAS$lat))
         sec = g1$STAS$sec[w1]

         N = length(sec)
         Ldat =    list(
           name = g1$STAS$name[w1],
           sec = g1$STAS$sec[w1],
           phase = g1$STAS$phase[w1],
           lat=g1$STAS$lat[w1],
           lon = g1$STAS$lon[w1],
           z = g1$STAS$z[w1],
           err= g1$STAS$err[w1],
           yr = rep(g1$LOC$yr , times=N),
           jd = rep(g1$LOC$jd, times=N),
           mo = rep(g1$LOC$mo, times=N),
           dom = rep(g1$LOC$dom, times=N),
           hr =rep( g1$LOC$hr, times=N),
           mi = rep(g1$LOC$mi, times=N) )

B = BLACKJACK(Ldat, vel)

##  the code HiJACK
###  runs BLACKJACK on many pickfiles stored in files
###  COSOjack = HiJACK(lps, sta)
###   plotJACKLLZ(COSOjack, sta, proj)

</code></pre>

<hr>
<h2 id='checkLOCATEinput'>Check Location data
</h2><span id='topic+checkLOCATEinput'></span>

<h3>Description</h3>

<p>Check to see if location data has the minimally correct list components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkLOCATEinput(Ldat, EQ, vel = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkLOCATEinput_+3A_ldat">Ldat</code></td>
<td>
<p>list, must inlude: x,y,err, sec, cor (see details)
</p>
</td></tr>
<tr><td><code id="checkLOCATEinput_+3A_eq">EQ</code></td>
<td>
<p>list, must inlude: x,y,z, t
</p>
</td></tr>
<tr><td><code id="checkLOCATEinput_+3A_vel">vel</code></td>
<td>
<p>list, 1D velocity structure
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input pick list must have at x,y,z, sec, cor, err elements
for each station.
</p>


<h3>Value</h3>

<p>logical: FALSE mean problem with data
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>XYlocate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(RSEIS)
library(GEOmap)
data(GH, package='RSEIS')

g1 = GH$pickfile
data(VELMOD1D, package='RSEIS')
vel= VELMOD1D



 w1 = which(!is.na(g1$STAS$lat))
         sec = g1$STAS$sec[w1]

         N = length(sec)
         Ldat =    list(
           name = g1$STAS$name[w1],
           sec = g1$STAS$sec[w1],
           phase = g1$STAS$phase[w1],
           lat=g1$STAS$lat[w1],
           lon = g1$STAS$lon[w1],
           z = g1$STAS$z[w1],
           err= g1$STAS$err[w1],
           yr = rep(g1$LOC$yr , times=N),
           jd = rep(g1$LOC$jd, times=N),
           mo = rep(g1$LOC$mo, times=N),
           dom = rep(g1$LOC$dom, times=N),
           hr =rep( g1$LOC$hr, times=N),
           mi = rep(g1$LOC$mi, times=N) )

 MLAT = median(Ldat$lat)
    MLON = median(Ldat$lon)
    
    proj = GEOmap::setPROJ(type=2, LAT0=MLAT, LON0=MLON)

####   get station X-Y values in km
    XY = GEOmap::GLOB.XY(Ldat$lat, Ldat$lon, proj)
###   add to Ldat list
    Ldat$x = XY$x
    Ldat$y = XY$y
       wstart = which.min(Ldat$sec)



EQ = list(x=XY$x[wstart], y=XY$y[wstart], z=6, t=Ldat$sec[wstart] )

checkLOCATEinput(Ldat, EQ)

</code></pre>

<hr>
<h2 id='clusterWPX'>Cluster Analysis of Picks
</h2><span id='topic+clusterWPX'></span>

<h3>Description</h3>

<p>Given a pick file in WPX format, break the
picks apart clustered accoring to 
single link cluster analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clusterWPX(twpx, tol = 200, PLOT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clusterWPX_+3A_twpx">twpx</code></td>
<td>
<p>WPX list
</p>
</td></tr>
<tr><td><code id="clusterWPX_+3A_tol">tol</code></td>
<td>
<p>tolerance in seconds - all
pick distances less than tol will be set to zero 
to force these to be associated.
</p>
</td></tr>
<tr><td><code id="clusterWPX_+3A_plot">PLOT</code></td>
<td>
<p>logical, if TRUE, add verbose plotting 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there is not significant separation of picks,
only one cluster is returned.  
To avoid spurious clusters, increase the tolerance.
</p>


<h3>Value</h3>

<p>list of WPX lists
</p>


<h3>Note</h3>

<p>Cluster depends on what one considers a cluster.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>RSEIS::addWPX,	RSEIS::catWPX,	RSEIS::checkWPX,RSEIS::cleanWPX, PCsaveWPX, RSEIS::setWPX, RSEIS::repairWPX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
s1 = RSEIS::setWPX(name="HI", yr=2011, jd=231, hr=4, mi=3, sec = runif(5)) 

s2 = RSEIS::setWPX(name="HI", yr=2011, jd=231, hr=5, mi=2, sec = runif(5)) 


s3 = RSEIS::catWPX(s1,s2)

twpx = data.frame(s3)
L3 = clusterWPX(twpx)

</code></pre>

<hr>
<h2 id='CONTPF'>Button to Contour Pickfile Arrivals
</h2><span id='topic+CONTPF'></span>

<h3>Description</h3>

<p>Button to Contour Pickfile Arrivals, used internally in swig.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CONTPF(nh, g, idev = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CONTPF_+3A_nh">nh</code></td>
<td>
<p>RSEIS list
</p>
</td></tr>
<tr><td><code id="CONTPF_+3A_g">g</code></td>
<td>
<p>swig parameters
</p>
</td></tr>
<tr><td><code id="CONTPF_+3A_idev">idev</code></td>
<td>
<p>device for plotting
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Driver for contPFarrivals
</p>


<h3>Value</h3>

<p>Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>contPFarrivals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(interactive()){
######  interactive: addition of button in swig
data(GH, package='RSEIS')

buts = "CONTPF"
RSEIS::swig(GH, PADDLAB=buts, SHOWONLY=FALSE )
}


</code></pre>

<hr>
<h2 id='contPFarrivals'>Contour Pickfile Arrivals
</h2><span id='topic+contPFarrivals'></span>

<h3>Description</h3>

<p>Contour plot of arrival times recorded in
a pickfile list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contPFarrivals(PF, stas, proj=NULL, cont=TRUE, POINTS=TRUE, image=FALSE ,
             col=RSEIS::tomo.colors(50), gcol="black",   phase="P", add=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contPFarrivals_+3A_pf">PF</code></td>
<td>
<p>Pickfile list in RSEIS format
</p>
</td></tr>
<tr><td><code id="contPFarrivals_+3A_stas">stas</code></td>
<td>
<p>station list
</p>
</td></tr>
<tr><td><code id="contPFarrivals_+3A_proj">proj</code></td>
<td>
<p>projection from GEOmap
</p>
</td></tr>
<tr><td><code id="contPFarrivals_+3A_cont">cont</code></td>
<td>
<p>logical, add contour to plot</p>
</td></tr>
<tr><td><code id="contPFarrivals_+3A_points">POINTS</code></td>
<td>
<p>logical, add mark up (stations)  to plot</p>
</td></tr>
<tr><td><code id="contPFarrivals_+3A_image">image</code></td>
<td>
<p>logical, add image to plot
</p>
</td></tr>
<tr><td><code id="contPFarrivals_+3A_col">col</code></td>
<td>
<p>color palette for image</p>
</td></tr>
<tr><td><code id="contPFarrivals_+3A_gcol">gcol</code></td>
<td>
<p>color for contour lines</p>
</td></tr>
<tr><td><code id="contPFarrivals_+3A_phase">phase</code></td>
<td>
<p>character,  phase to contour
</p>
</td></tr>
<tr><td><code id="contPFarrivals_+3A_add">add</code></td>
<td>
<p>logical, TRUE=add to existing plot
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Contours the arrival time.
The earliest arrival is subtracted from each
time pick.  Uses only the phase indicated and there can be only
one phase per station - default is earliest at each station. 
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>doAmap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(RSEIS)

data(GH, package='RSEIS')

sta = GH$stafile
g1 = GH$pickfile


proj = GEOmap::setPROJ(type=2, LAT0 =median(sta$lat) , LON0 = median(sta$lon))


grcol =  grey(seq(from=0.3, to=0.95, length=50))
  contPFarrivals(g1, sta, proj=proj,cont=TRUE, POINTS=TRUE,
                           image=TRUE , col=grcol,     phase="P",
add=FALSE )


</code></pre>

<hr>
<h2 id='coso_sta_LLZ'>Coso Station File</h2><span id='topic+coso_sta_LLZ'></span>

<h3>Description</h3>

<p>Coso Station Location file, 1989-1999
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(coso_sta_LLZ)
</code></pre>


<h3>Format</h3>

<p>Name, Lat, Lon, Z
</p>


<h3>Source</h3>

<p>Personal Files
</p>


<h3>References</h3>

<p>Wu, H. and J. M. Lees (1996). Attenuation Structure of Coso Geothermal
Area, California, from P Wave Pulse Widths, Bull. Seismol. Soc. Am.,
86, 1574-1590.
</p>
<p>Lees, J. M. (1998), Multiplet analysis at Coso Geothermal,Bull. Seismol. Soc. Am. 88(5) 1127-1143.
</p>

<hr>
<h2 id='cosopix'>Selection of pickfiles from Coso Geothermal Field
</h2><span id='topic+cosopix'></span>

<h3>Description</h3>

<p>Set of selected seismic arrival files with hypocenter locations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("cosopix")</code></pre>


<h3>Format</h3>

<p>List consisting of:
</p>

<ul>
<li><p> PF: original text version of file, as read from disk
</p>
</li>
<li><p> AC: Acard: hypocenter information
</p>
</li>
<li><p> LOC: location
</p>
</li>
<li><p> MC: Fault Mechanizm card
</p>
</li>
<li><p> STAS: Station information
</p>
</li>
<li><p> LIP: Error Ellipse
</p>
</li>
<li><p> E: E-card
</p>
</li>
<li><p> F: F-card
</p>
</li>
<li><p> filename: original file location
</p>
</li>
<li><p> UWFILEID: UW file identification
</p>
</li>
<li><p> comments: Comments on event location
</p>
</li>
<li><p> OSTAS: Station names
</p>
</li>
<li><p> H: High resolution location numbers
</p>
</li>
<li><p> N: Stations Not used in location
</p>
</li></ul>



<h3>Details</h3>

<p>Each element of this list is an individual earthquake record.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cosopix)
A = sapply(cosopix, '[[', 'LOC')
###  gather stations

ST.name = vector(mode='character')
ST.lat = vector(mode='numeric')
ST.lon = vector(mode='numeric')
ST.z = vector(mode='numeric')

for(i in 1:length(cosopix))
{
g = cosopix[[i]]
g = data.frame(g$STAS )
w = which(!is.na(g$lat) )
ST.name = c(ST.name, g$name[w])
ST.lat = c(ST.lat, g$lat[w])
ST.lon = c(ST.lon, g$lon[w])
ST.z = c(ST.z, g$z[w])
}

notdup = !duplicated(ST.name)

name = ST.name[notdup ]
lat = ST.lat[notdup ]
lon =ST.lon[notdup ]
z = ST.z[notdup ]

plot(range(c(A[9, ], lon)) , range(c(A[8, ], lat)) , type='n',
xlab='Lon', ylab='Lat')
points(lon, lat, pch=6)

text(lon, lat, labels=name, pos=3)

points(A[9, ], A[8, ])



</code></pre>

<hr>
<h2 id='defaultVEL'>Default Velocity Function
</h2><span id='topic+defaultVEL'></span>

<h3>Description</h3>

<p>Default Velocity Function is returned
in the event no velocity function is available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>defaultVEL(kind = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="defaultVEL_+3A_kind">kind</code></td>
<td>
<p>integer, 1=fuj1, 2=LITHOS
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A set of default velocity functions are available.
</p>


<h3>Value</h3>

<p>velocity list, P and S waves
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>fuj1.vel
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
v = defaultVEL(1)

</code></pre>

<hr>
<h2 id='DistWeight'>Distance wheighting
</h2><span id='topic+DistWeight'></span><span id='topic+DistWeightLL'></span><span id='topic+DistWeightXY'></span>

<h3>Description</h3>

<p>Distance weighting for non-linear
earthquake location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DistWeight(dist, err, distwt)
DistWeightLL(lat, lon, elat, elon, err, distwt)
DistWeightXY(x, y, ex, ey, err, distwt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DistWeight_+3A_dist">dist</code></td>
<td>
<p>distance in km
</p>
</td></tr>
<tr><td><code id="DistWeight_+3A_err">err</code></td>
<td>
<p>sigma error in seconds
</p>
</td></tr>
<tr><td><code id="DistWeight_+3A_distwt">distwt</code></td>
<td>
<p>distance weighting parameter
</p>
</td></tr>
<tr><td><code id="DistWeight_+3A_lat">lat</code></td>
<td>
<p>Latitude</p>
</td></tr>
<tr><td><code id="DistWeight_+3A_lon">lon</code></td>
<td>
<p>Longitude </p>
</td></tr>
<tr><td><code id="DistWeight_+3A_elat">elat</code></td>
<td>
<p>Event Latitude </p>
</td></tr>
<tr><td><code id="DistWeight_+3A_elon">elon</code></td>
<td>
<p>Event Longitude</p>
</td></tr>
<tr><td><code id="DistWeight_+3A_x">x</code></td>
<td>
<p>station X(km) </p>
</td></tr>
<tr><td><code id="DistWeight_+3A_y">y</code></td>
<td>
<p>station Y(km) </p>
</td></tr>
<tr><td><code id="DistWeight_+3A_ex">ex</code></td>
<td>
<p>event X (km) </p>
</td></tr>
<tr><td><code id="DistWeight_+3A_ey">ey</code></td>
<td>
<p>event Y (km) </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based  on Lquake scheme from University of Washington.
If you need to reduce the effect of distance weighting,
increase distwt.
</p>
<p>Since the hypocenter moves between each iteration,
the distance weighting is updated.
</p>


<h3>Value</h3>

<p>vector of weights
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

DistWeight(1:10, .4, 20)


</code></pre>

<hr>
<h2 id='doAmap'>Plot a map of station locations
</h2><span id='topic+doAmap'></span>

<h3>Description</h3>

<p>Plot a map of station locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doAmap(stas, doproj = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="doAmap_+3A_stas">stas</code></td>
<td>
<p>station list
</p>
</td></tr>
<tr><td><code id="doAmap_+3A_doproj">doproj</code></td>
<td>
<p>logical, if TRUE, project (UTM)
the data so plot is in units of km with the median
lat-lon as the center.
If FALSE, use the lat-lon coordinates.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The range of the plot is
expanded by 10 percent prior to plotting.
</p>


<h3>Value</h3>

<p>list, GEOmap projection
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>gMAP,expandbound,GLOB.XY
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(coso_sta_LLZ)
###  or read in from file:
##   fsta = "staLLZ.txt"
##  stas = scan(file=fsta,what=list(name="", lat=0, lon=0, z=0))
##  stas$z = stas$z/1000

stas = coso_sta_LLZ

STA = doAmap(stas, doproj = TRUE)



</code></pre>

<hr>
<h2 id='eqlipse'>Error Elipse for Hypocenter Location
</h2><span id='topic+eqlipse'></span>

<h3>Description</h3>

<p>Error Elipse for Hypocenter Location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eqlipse(x, y, cov, wcols = c(1, 2), dof = 2, pct=0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eqlipse_+3A_x">x</code></td>
<td>
<p>X-location for drawing
</p>
</td></tr>
<tr><td><code id="eqlipse_+3A_y">y</code></td>
<td>
<p>Y-location for drawing
</p>
</td></tr>
<tr><td><code id="eqlipse_+3A_cov">cov</code></td>
<td>
<p>matrix, 3 by 3 Covariance matrix 
</p>
</td></tr>
<tr><td><code id="eqlipse_+3A_wcols">wcols</code></td>
<td>
<p>vector, which columns to extract from cov,
see details.
</p>
</td></tr>
<tr><td><code id="eqlipse_+3A_dof">dof</code></td>
<td>
<p>Degrees of Freedom for 95 percent confidence
</p>
</td></tr>
<tr><td><code id="eqlipse_+3A_pct">pct</code></td>
<td>
<p> Percent used for 2-sided confidence bounds, default=0.05 </p>
</td></tr>
<tr><td><code id="eqlipse_+3A_...">...</code></td>
<td>
<p>graphical parameters, par</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>The 3 by 3 matrix is supplied and
a 2 by 2 matrix is subtracted depending on
which components are being drawn.
For X-Y projections, use  wcols=c(1,2).
For vertical cross sections, rotate the
cov matrix and then extract the columns.
</p>


<h3>Value</h3>

<p>Side effects, graphical
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>eqwrapup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(RSEIS)
data(GH, package='RSEIS')
data(VELMOD1D, package='RSEIS' )


vel = VELMOD1D


gpf = GH$pickfile

w1 = which(gpf$STAS$phase=="P" | gpf$STAS$phase=="S" )

N = length(w1)

 Ldat =    list(
      name = gpf$STAS$name[w1],
      sec = gpf$STAS$sec[w1],
      phase = gpf$STAS$phase[w1],
      lat=gpf$STAS$lat[w1],
      lon = gpf$STAS$lon[w1],
      z = gpf$STAS$z[w1],
      err= gpf$STAS$err[w1],
      yr = rep(gpf$LOC$yr , times=N),
      jd = rep(gpf$LOC$jd, times=N),
      mo = rep(gpf$LOC$mo, times=N),
      dom = rep(gpf$LOC$dom, times=N),
      hr =rep( gpf$LOC$hr, times=N),
      mi = rep(gpf$LOC$mi, times=N) )

EQ = GH$pickfile$LOC

EQ$t = EQ$sec

kuality = eqwrapup(Ldat, EQ, vel, distwt = 20, verbose = TRUE )


 MLAT = median(Ldat$lat)
  MLON = median(Ldat$lon)
  proj = GEOmap::setPROJ(type=2, LAT0=MLAT, LON0=MLON)

  XYSTAS = GEOmap::GLOB.XY(Ldat$lat,  Ldat$lon , proj)


 eqxy = GEOmap::GLOB.XY(EQ$lat, EQ$lon, proj)


plot(range(c(XYSTAS$x, eqxy$x)), range(c(XYSTAS$y, eqxy$y)),
          type='n', asp=1, xlab="km", ylab="km" )
points(XYSTAS$x, XYSTAS$y, pch=6)
points(eqxy$x, eqxy$y, pch=8, col='red')

####  covariance matrix
KOV = kuality$cov[2:4, 2:4]

####  add uncertainty
eqlipse(eqxy$x, eqxy$y , KOV,   wcols = c(1,2) , dof=kuality$ndf,
border="blue"  )



</code></pre>

<hr>
<h2 id='eqwrapup'>Earthquake Wrap Uo
</h2><span id='topic+eqwrapup'></span>

<h3>Description</h3>

<p>Calculate error and summary 
information on earthquake location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eqwrapup(Ldat, EQ, vel, distwt=20, lambdareg = 0.0, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eqwrapup_+3A_ldat">Ldat</code></td>
<td>
<p>List of station arrival times, lat-lon, and uncertainty
</p>
</td></tr>
<tr><td><code id="eqwrapup_+3A_eq">EQ</code></td>
<td>
<p>List of earthquake location: Lat-Lon-z-t
</p>
</td></tr>
<tr><td><code id="eqwrapup_+3A_vel">vel</code></td>
<td>
<p>velocity model
</p>
</td></tr>
<tr><td><code id="eqwrapup_+3A_distwt">distwt</code></td>
<td>
<p>distance weight, default=20
</p>
</td></tr>
<tr><td><code id="eqwrapup_+3A_lambdareg">lambdareg</code></td>
<td>
<p>numeric, regularization parameter (default=0)
</p>
</td></tr>
<tr><td><code id="eqwrapup_+3A_verbose">verbose</code></td>
<td>
<p>logical, TRUE=print information to screen
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Earthquakes are located with a generalized inverse (SVD).
covariance matrix is extracted and 95% confidence bounds are 
calculated.  Quality factors Q1 and Q1 estimate the 
quality iof the location based on the gap, minimum distance and rms.
</p>


<h3>Value</h3>

<p>List
</p>
<table>
<tr><td><code>rms</code></td>
<td>
<p>Root Mean Square Residual</p>
</td></tr>
<tr><td><code>meanres</code></td>
<td>
<p>Mean Residual</p>
</td></tr>
<tr><td><code>sdres</code></td>
<td>
<p>Standard Dev of residuals</p>
</td></tr>
<tr><td><code>sdmean</code></td>
<td>
<p>Standard error of mean residual</p>
</td></tr>
<tr><td><code>sswres</code></td>
<td>
<p>Sum squared weighted residuals</p>
</td></tr>
<tr><td><code>ndf</code></td>
<td>
<p>Number of Degrees of Freedom</p>
</td></tr>
<tr><td><code>sterrx</code></td>
<td>
<p>km, error in X (East-West)</p>
</td></tr>
<tr><td><code>sterry</code></td>
<td>
<p>km, error in Y (North-South)</p>
</td></tr>
<tr><td><code>sterrz</code></td>
<td>
<p>km, error in Z, (depth)</p>
</td></tr>
<tr><td><code>sterrt</code></td>
<td>
<p>s, Delta-time</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>covariance matrix (used for error ellipsoids)</p>
</td></tr>
<tr><td><code>lam</code></td>
<td>
<p>lambda</p>
</td></tr>
<tr><td><code>gap</code></td>
<td>
<p>Spatial gap (max subtended angle)</p>
</td></tr>
<tr><td><code>herr</code></td>
<td>
<p>Horizontal error</p>
</td></tr>
<tr><td><code>distmin</code></td>
<td>
<p>Minimum distance to epicenter</p>
</td></tr>
<tr><td><code>Q1</code></td>
<td>
<p>Quality Factor based on Gap and RMS</p>
</td></tr>
<tr><td><code>Q2</code></td>
<td>
<p>Quality factor based on RMS, depth and min-Distance</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The Damping parameter (lambda) is set to zero.
In the UW lquake program, lambda is set to 0.02.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>Klocate, Glocate, getGAP
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(RSEIS, package='RSEIS')
data(GH, package='RSEIS')
data(wu_coso.vel, package='Rquake' )
vel = wu_coso.vel


gpf = GH$pickfile

w1 = which(gpf$STAS$phase=="P" | gpf$STAS$phase=="S" )

N = length(w1)

 Ldat =    list(
      name = gpf$STAS$name[w1],
      sec = gpf$STAS$sec[w1],
      phase = gpf$STAS$phase[w1],
      lat=gpf$STAS$lat[w1],
      lon = gpf$STAS$lon[w1],
      z = gpf$STAS$z[w1],
      err= gpf$STAS$err[w1],
      yr = rep(gpf$LOC$yr , times=N),
      jd = rep(gpf$LOC$jd, times=N),
      mo = rep(gpf$LOC$mo, times=N),
      dom = rep(gpf$LOC$dom, times=N),
      hr =rep( gpf$LOC$hr, times=N),
      mi = rep(gpf$LOC$mi, times=N) )

EQ = GH$pickfile$LOC

EQ$t = EQ$sec

kuality = eqwrapup(Ldat, EQ, vel, distwt = 20, verbose = TRUE )

names(kuality)

</code></pre>

<hr>
<h2 id='EQXYresid'>Calculate Residuals
</h2><span id='topic+EQXYresid'></span>

<h3>Description</h3>

<p>Given an earthquake hypocenter
and a list of station information, retrieve
the station residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EQXYresid(XY, vel = list(), h1 = c(0, 0, 0, 0), PLOT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EQXYresid_+3A_xy">XY</code></td>
<td>
<p>matrix of station location and arrival times.
</p>
</td></tr>
<tr><td><code id="EQXYresid_+3A_vel">vel</code></td>
<td>
<p>list, RSEIS velocity model 
</p>
</td></tr>
<tr><td><code id="EQXYresid_+3A_h1">h1</code></td>
<td>
<p>hypocenter location, c(x,y,z,t)
</p>
</td></tr>
<tr><td><code id="EQXYresid_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE=plot the residuals
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The XY mtrix is in cartesian coordinates, i.e. 
it has been projected into units of km.  Only 1D velocity
models are used at this time.
Only residuals of P and S wave arrivals are estimated.
</p>


<h3>Value</h3>

<p>vector, right hand side of the least squares problem.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>travel.time1D,UPdateEQLOC
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
####  get sample data
data(GH, package='RSEIS')

pstas  = GH$pickfile

######  get velocity file
v = GH$velfile

####  project to flatten
proj = GEOmap::setPROJ(type = 2, LAT0 = mean(pstas$STAS$lat), LON0 = mean(pstas$STAS$lon) )

 XY = GEOmap::GLOB.XY(pstas$STAS$lat, pstas$STAS$lon, proj)
#######  elevation corrections
    elcor = rep(0, length(pstas$STAS$lat))
    DZ = pstas$STAS$z - mean(pstas$STAS$z)
    elcor[pstas$STAS$phase=="P"] = DZ[pstas$STAS$phase=="P"]/v$vp[1]
    elcor[pstas$STAS$phase=="S"] = DZ[pstas$STAS$phase=="S"]/v$vs[1]

######   set up requisite vectors
    XY$cor = elcor
    XY$phase = pstas$STAS$phase
    XY$sec = pstas$STAS$sec

    sol = c(GH$pickfile$LOC$lat, GH$pickfile$LOC$lon, GH$pickfile$LOC$z, GH$pickfile$LOC$sec)
    
    eqXY = GEOmap::GLOB.XY(sol[1], sol[2], proj)

#######  get residuals
    res =  EQXYresid(XY, vel=v , h1=c(eqXY$x, eqXY$y, sol[3], sol[4] ) ,
    PLOT=FALSE)

</code></pre>

<hr>
<h2 id='euler_passive'>Euler Rotation Angles
</h2><span id='topic+euler_passive'></span>

<h3>Description</h3>

<p>Given three angles return rotation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>euler_passive(phi, theta, psi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="euler_passive_+3A_phi">phi</code></td>
<td>
<p>angle with x-axis
</p>
</td></tr>
<tr><td><code id="euler_passive_+3A_theta">theta</code></td>
<td>
<p>angle with y-axis
</p>
</td></tr>
<tr><td><code id="euler_passive_+3A_psi">psi</code></td>
<td>
<p>angle with z-axis
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Code borrowed from cpp code in package cda. used in rgl.ellipsoid.
</p>


<h3>Value</h3>

<p>3 by 3 rotation matrix.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;,
Baptiste Auguie&lt;baptiste.auguie@gmail.com&gt;
</p>


<h3>See Also</h3>

<p>rgl.ellipsoid
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(rgl.useNULL = TRUE)
phi=30*pi/180 ; theta= 20*pi/180; psi = 6*pi/180
rr = euler_passive(phi,theta,psi)



</code></pre>

<hr>
<h2 id='getEulers'>Get Eulers Angles
</h2><span id='topic+getEulers'></span>

<h3>Description</h3>

<p>Given a covariance matrix
calculated with Vlocate, extract euler's angles
for plotting in rgl
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getEulers(R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getEulers_+3A_r">R</code></td>
<td>
<p>covarince matrix
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract the euler angles for plotting an ellipsoid.
psi about X-axis, theta about Y axis, phi about Z-axis.
</p>


<h3>Value</h3>

<p>vector, phi theta psi
</p>


<h3>Note</h3>

<p>Used in conjunction with ROTcovQUAKE
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>ROTcovQUAKE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>options(rgl.useNULL = TRUE)
R = matrix( runif(9), ncol=3)

getEulers(R)




</code></pre>

<hr>
<h2 id='getGAP'>Get Seismic Gap
</h2><span id='topic+getGAP'></span>

<h3>Description</h3>

<p>Given an earthquake and
a set of stations, return the maximum angle
subtended between adjacent stations relative to the epicenter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGAP(EQ, Ldat, PLOT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGAP_+3A_eq">EQ</code></td>
<td>
<p>List, Earthequake location, elements (lat, lon) must be present
</p>
</td></tr>
<tr><td><code id="getGAP_+3A_ldat">Ldat</code></td>
<td>
<p>List, station information, (lat, lon) must be present
</p>
</td></tr>
<tr><td><code id="getGAP_+3A_plot">PLOT</code></td>
<td>
<p>logical, plot the stations and show the gap</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Theangles are calculated in cartesian coordinates
with the epicenter at the origin using a UTM projection.
</p>


<h3>Value</h3>

<p>numeric, gap in degrees
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>eqwrapup
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(0)

N = 10
snames = paste(sep="", "A", as.character(1:N))
stas = list(name=snames, lat=runif(N, 35.9823, 36.1414), lon=runif(N, -118.0031, -117.6213))

NEQ = 3
WEQ = list(lat=runif(NEQ, 35.9823, 36.1414), lon=runif(NEQ, -118.0031, -117.6213))

 MLAT = median(stas$lat)
  MLON = median(stas$lon)
  proj = GEOmap::setPROJ(type=2, LAT0=MLAT, LON0=MLON)

  XYSTAS = GEOmap::GLOB.XY(stas$lat,  stas$lon , proj)
  eqxy = GEOmap::GLOB.XY(WEQ$lat, WEQ$lon, proj)


plot(range(c(XYSTAS$x, eqxy$x)), range(c(XYSTAS$y, eqxy$y)), type='n', asp=1, xlab="km", ylab="km" )
points(XYSTAS$x, XYSTAS$y, pch=6)

for(i in 1:NEQ)
{
EQ = list(lat=WEQ$lat[i], lon=WEQ$lon[i])


g = getGAP(EQ, stas, PLOT=FALSE)

points(eqxy$x[i], eqxy$y[i], pch=8, col='red')
text(eqxy$x[i], eqxy$y[i], labels=paste("gap=", format(g)), pos=3)

}


</code></pre>

<hr>
<h2 id='GETpsTT'>Get Pand S travel times and derivatives
</h2><span id='topic+GETpsTT'></span>

<h3>Description</h3>

<p>Get Pand S travel times and derivatives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GETpsTT(phase, eqz = 6, staz = 0, delx = 1, dely = 1, deltadis = 6, vel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GETpsTT_+3A_phase">phase</code></td>
<td>
<p>character vector, phase
</p>
</td></tr>
<tr><td><code id="GETpsTT_+3A_eqz">eqz</code></td>
<td>
<p>event depth
</p>
</td></tr>
<tr><td><code id="GETpsTT_+3A_staz">staz</code></td>
<td>
<p>station elevation
</p>
</td></tr>
<tr><td><code id="GETpsTT_+3A_delx">delx</code></td>
<td>
<p>km, delta X
</p>
</td></tr>
<tr><td><code id="GETpsTT_+3A_dely">dely</code></td>
<td>
<p>km, delta Y
</p>
</td></tr>
<tr><td><code id="GETpsTT_+3A_deltadis">deltadis</code></td>
<td>
<p>km, distance
</p>
</td></tr>
<tr><td><code id="GETpsTT_+3A_vel">vel</code></td>
<td>
<p>velocity models (P and S)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a vector of travel times, and a matrix
and derivatives used for inversion.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>TT</code></td>
<td>
<p>travel time vector</p>
</td></tr>
<tr><td><code>Derivs</code></td>
<td>
<p>matrix of derivatives, dtdx, dtdy, dtdz </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>many.time1D
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(RSEIS)
library(GEOmap)


data(GH, package='RSEIS')

data(VELMOD1D, package='RSEIS')
vel = VELMOD1D


p1 = GH$pickfile$STAS


loc = GH$pickfile$LOC


proj  = GEOmap::setPROJ(type = 2, LAT0 =loc$lat, LON0 =  loc$lon)


XYsta = GEOmap::GLOB.XY(p1$lat, p1$lon, proj)
XYq =   GEOmap::GLOB.XY(loc$lat, loc$lon, proj)

delx = XYq$x-XYsta$x
dely = XYq$y-XYsta$y
dists = sqrt(delx^2+dely^2)

G1 = GETpsTT(p1$phase, eqz=loc$z, staz=0, delx=delx, dely=dely,  deltadis=dists , vel)

</code></pre>

<hr>
<h2 id='getregionals'>Extract regional events 
</h2><span id='topic+getregionals'></span>

<h3>Description</h3>

<p>Extract regional events from a hypocenter list (catalog)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getregionals(KAT, Mlat, Mlon, rad = 1000, t1 = 1, t2 = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getregionals_+3A_kat">KAT</code></td>
<td>
<p>catalog list: must include lat, lon and jsec.
</p>
</td></tr>
<tr><td><code id="getregionals_+3A_mlat">Mlat</code></td>
<td>
<p>central latitude
</p>
</td></tr>
<tr><td><code id="getregionals_+3A_mlon">Mlon</code></td>
<td>
<p>central longitude 
</p>
</td></tr>
<tr><td><code id="getregionals_+3A_rad">rad</code></td>
<td>
<p>radius (km)
</p>
</td></tr>
<tr><td><code id="getregionals_+3A_t1">t1</code></td>
<td>
<p>start time (julian days)
</p>
</td></tr>
<tr><td><code id="getregionals_+3A_t2">t2</code></td>
<td>
<p>end  time (julian days)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an earthquake catalog from PDEs, for example,
extract the events that are close to a network in
a given time frame.  The limited data set may be used
to help predict arrival times for known hypocenter 
locations.
</p>
<p>The time jsec is in julian days,
i.e. jsec=jd+hr/24+mi/(24*60)+sec/(24*3600) so that they can be compared
to t1 and t2.
</p>


<h3>Value</h3>

<p>Catalog 
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>RSEIS::Mine.seis, RSEIS::swig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(1)
Mlat = 36.00833
Mlon = -117.8048
N = 100
degz = 5
KAT = list(lat=runif(N, Mlat-degz,Mlat+degz) ,
    lon=runif(N,Mlon-degz,Mlon+degz)  )

######  ranfdom times in January
KAT$jsec = runif(N, 1, 30) + runif(N, 0, 24)/(24) + runif(N, 0, 59)/(24*60)

######   extract regional events
localeqs = getregionals(KAT, Mlat, Mlon, rad=200 ,  t1=NULL, t2=NULL)

plot(KAT$lon, KAT$lat, pch=8, col=grey(0.75) )
points(KAT$lon[localeqs], KAT$lat[localeqs], pch=1, col='red', cex=1.5 )



</code></pre>

<hr>
<h2 id='getresidTT'>Travel time residuals
</h2><span id='topic+getresidTT'></span>

<h3>Description</h3>

<p>Given an earthquake location
and a set of arrival times,
return a vector of residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getresidTT(Ldat, EQ, stas, vel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getresidTT_+3A_ldat">Ldat</code></td>
<td>
<p>List of arrival times
</p>
</td></tr>
<tr><td><code id="getresidTT_+3A_eq">EQ</code></td>
<td>
<p>List of event location, (lat, lon, z, and time)
</p>
</td></tr>
<tr><td><code id="getresidTT_+3A_stas">stas</code></td>
<td>
<p>station location list
</p>
</td></tr>
<tr><td><code id="getresidTT_+3A_vel">vel</code></td>
<td>
<p>list, velocity structure
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1D travel time calculation.
</p>


<h3>Value</h3>

<p>vector of residuals
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>travel.time1D
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#########  LF is a vector of arrival time files
#####  KAM is a set of locations


data(GH, package='RSEIS')

g1 = GH$pickfile
data(VELMOD1D, package='RSEIS')

vel= VELMOD1D
WW = RSEIS::uwpfile2ypx(GH$pickfile)

twpx  = latlonz2wpx(WW, GH$pickfile$STAS )

   
    zip = LeftjustTime(twpx)


 w1 = which(!is.na(g1$STAS$lat))
         sec = g1$STAS$sec[w1]

         N = length(sec)
         Ldat =    list(
           name = g1$STAS$name[w1],
           sec = g1$STAS$sec[w1],
           phase = g1$STAS$phase[w1],
           lat=g1$STAS$lat[w1],
           lon = g1$STAS$lon[w1],
           z = g1$STAS$z[w1],
           err= g1$STAS$err[w1],
           yr = rep(g1$LOC$yr , times=N),
           jd = rep(g1$LOC$jd, times=N),
           mo = rep(g1$LOC$mo, times=N),
           dom = rep(g1$LOC$dom, times=N),
           hr =rep( g1$LOC$hr, times=N),
           mi = rep(g1$LOC$mi, times=N) )



 resids = getresidTT(Ldat, g1$LOC, g1$STAS , vel)




</code></pre>

<hr>
<h2 id='Gfirstguess'>First guess from a pick file	
</h2><span id='topic+Gfirstguess'></span>

<h3>Description</h3>

<p>Extract the lat lon from the pick file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gfirstguess(Ldat, type = "first")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gfirstguess_+3A_ldat">Ldat</code></td>
<td>
<p>Matrix of data information
</p>
</td></tr>
<tr><td><code id="Gfirstguess_+3A_type">type</code></td>
<td>
<p>one of &quot;first&quot;, &quot;mean&quot;, or &quot;median&quot;
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either the earliest arrival or the average station is
returned.  Used internally in the earthquake location program
to provide a first guess.
</p>


<h3>Value</h3>

<p>vector, lat, lon, z and tee
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>Klocate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(GH, package='RSEIS')
WW = RSEIS::uwpfile2ypx(GH$pickfile)

twpx  = latlonz2wpx(WW, GH$pickfile$STAS )

g1 = Gfirstguess(twpx, type = "first")

</code></pre>

<hr>
<h2 id='gMAP'>Generic Map Button
</h2><span id='topic+gMAP'></span>

<h3>Description</h3>

<p>Generic Map Button
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gMAP(nh, g, idev = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gMAP_+3A_nh">nh</code></td>
<td>
<p>RSEIS structure 
</p>
</td></tr>
<tr><td><code id="gMAP_+3A_g">g</code></td>
<td>
<p>parameters used in swig
</p>
</td></tr>
<tr><td><code id="gMAP_+3A_idev">idev</code></td>
<td>
<p>device for plotting (not used)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a button used internally in swig
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>swig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
####  this is interactive
###  adds button to swig menu
data(GH, package='RSEIS')

buts = "gMAP"
RSEIS::swig(GH, PADDLAB = buts )

}


</code></pre>

<hr>
<h2 id='GPIX'>PICK Buttons for swig
</h2><span id='topic+GPIX'></span>

<h3>Description</h3>

<p>defining functions for swig
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GPIX(nh, g)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GPIX_+3A_nh">nh</code></td>
<td>
<p>waveform list for RSEIS
</p>
</td></tr>
<tr><td><code id="GPIX_+3A_g">g</code></td>
<td>
<p>plotting parameter list for interactive program
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Buttons can be defined on the fly.
</p>

<dl>
<dt>GPIX</dt><dd><p>Multiple picks on a panel</p>
</dd>
</dl>



<h3>Value</h3>

<p>The return value depends on the nature of the function
as it is returned to the main code swig.
Choices for returning to swig are: break, replot, revert, replace,
donothing, exit.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>swig, XTR
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(interactive()){
######  interactive addition of buttons in swig

STDLAB=c("DONE", "QUIT", "SELBUT" , "GPIX" )
data(GH, package='RSEIS')
JJ = RSEIS::swig(GH, sel=1:10, STDLAB=STDLAB)

}


</code></pre>

<hr>
<h2 id='HiJACK'>Jackknife a list of events
</h2><span id='topic+HiJACK'></span>

<h3>Description</h3>

<p>Jackknife a list of events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HiJACK(lps, sta, vel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HiJACK_+3A_lps">lps</code></td>
<td>
<p>list of earthquake event pickfiles, each element is an
individual pickfile list, with STAS: relative timing of phase arrivals
</p>
</td></tr>
<tr><td><code id="HiJACK_+3A_sta">sta</code></td>
<td>
<p>staiton list
</p>
</td></tr>
<tr><td><code id="HiJACK_+3A_vel">vel</code></td>
<td>
<p>velocity list
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Driver for BLACKJACK
</p>


<h3>Value</h3>

<p>jackknife pseudovalues for each event
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Iversen, E. S., and J. M. Lees (1996), A statistical technique for
validating velocity models,
Bull. Seismol. Soc. Am. 86(6), 1853-1862.
</p>


<h3>See Also</h3>

<p>BLACKJACK
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####  uses external files, runs Vlocate on each one
#### lps = list of file names to be read

data(cosopix)
data(wu_coso.vel)
data(coso_sta_LLZ)

COSOjack = HiJACK(cosopix, coso_sta_LLZ, wu_coso.vel)

proj = GEOmap::setPROJ(2, mean(coso_sta_LLZ$lat),
mean(coso_sta_LLZ$lon))


####  show stats
plotJACKLLZ(COSOjack, coso_sta_LLZ, proj, PLOT=1 )


####  show maps
plotJACKLLZ(COSOjack, coso_sta_LLZ, proj, PLOT=2 )



</code></pre>

<hr>
<h2 id='imageINFLUENCE'>Image Influence of stations
</h2><span id='topic+imageINFLUENCE'></span>

<h3>Description</h3>

<p>Plot contours/image of Influence scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imageINFLUENCE(B, sta, proj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imageINFLUENCE_+3A_b">B</code></td>
<td>
<p>Pseudovalue list
</p>
</td></tr>
<tr><td><code id="imageINFLUENCE_+3A_sta">sta</code></td>
<td>
<p>station location list
</p>
</td></tr>
<tr><td><code id="imageINFLUENCE_+3A_proj">proj</code></td>
<td>
<p>projection list
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following jackknife - plot results.
this function is called by
plotJACKLLZ.
</p>


<h3>Value</h3>

<p>side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Iversen, E. S., and J. M. Lees (1996), A statistical technique for validating velocity models, Bull. Seismol. Soc. Am. 86(6), 1853-1862.
</p>


<h3>See Also</h3>

<p>plotJACKLLZ
</p>

<hr>
<h2 id='INITpickfile'>Initialize a pickfile
</h2><span id='topic+INITpickfile'></span>

<h3>Description</h3>

<p>Initialize a pickfile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>INITpickfile(stas = NULL, src = NULL, WPX = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="INITpickfile_+3A_stas">stas</code></td>
<td>
<p>station list
</p>
</td></tr>
<tr><td><code id="INITpickfile_+3A_src">src</code></td>
<td>
<p>hypocenter location
</p>
</td></tr>
<tr><td><code id="INITpickfile_+3A_wpx">WPX</code></td>
<td>
<p>GPIX or PPIX picks from swig
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Initialize a pickfile with a 
set of picks extracted from swig.
</p>


<h3>Value</h3>

<p>list, pickfile
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>EmptyPickfile
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(GH, package='RSEIS')
WW = RSEIS::uwpfile2ypx(GH$pickfile)

PF =  INITpickfile(stas=GH$stafile, src=NULL, WPX=WW )


</code></pre>

<hr>
<h2 id='Klocate'>Earthquake Hypocenter Location
</h2><span id='topic+Klocate'></span>

<h3>Description</h3>

<p>Earthquake Hypocenter Location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Klocate(Ldat, sol = c(0, 0, 0, 0), vel=defaultVEL(6),
distwt = 20, errtol = c(0.01, 0.01, 0.01), maxit = 20,
Lambda = 1, guessdepth = 6, APLOT = FALSE,
stas = list(name = "", lat = NA, lon = NA, z = NA))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Klocate_+3A_ldat">Ldat</code></td>
<td>
<p>swig pick list
</p>
</td></tr>
<tr><td><code id="Klocate_+3A_sol">sol</code></td>
<td>
<p>vector, initial solution
</p>
</td></tr>
<tr><td><code id="Klocate_+3A_vel">vel</code></td>
<td>
<p>velocity list
</p>
</td></tr>
<tr><td><code id="Klocate_+3A_distwt">distwt</code></td>
<td>
<p>distance weight parameter
</p>
</td></tr>
<tr><td><code id="Klocate_+3A_errtol">errtol</code></td>
<td>
<p>error tolerance
</p>
</td></tr>
<tr><td><code id="Klocate_+3A_maxit">maxit</code></td>
<td>
<p>Maximum number of iterations
</p>
</td></tr>
<tr><td><code id="Klocate_+3A_lambda">Lambda</code></td>
<td>
<p>damping parameter
</p>
</td></tr>
<tr><td><code id="Klocate_+3A_guessdepth">guessdepth</code></td>
<td>
<p>initial depth for guess
</p>
</td></tr>
<tr><td><code id="Klocate_+3A_aplot">APLOT</code></td>
<td>
<p>logical, plot intermediate solutions
</p>
</td></tr>
<tr><td><code id="Klocate_+3A_stas">stas</code></td>
<td>
<p>station list
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Inversion is done with 
SVD.  
</p>


<h3>Value</h3>

<p>Event location in Lat-Lon-Z-T.
</p>


<h3>Note</h3>

<p>Damped least squares.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>swig, defaultVEL
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
######  could read from a list of files on disk
###  LF = list.files(path=pdir, pattern="p$", full.names=TRUE )

   data(GH, package='RSEIS')

g1 = GH$pickfile




    ##  points(g1$H$lon, g1$H$lat, pch=8, col='red')

    w1 = which(!is.na(g1$STAS$lat))
    sec = g1$STAS$sec[w1]

    N = length(sec)
    Ldat =    list(
      name = g1$STAS$name[w1],
      sec = g1$STAS$sec[w1],
      phase = g1$STAS$phase[w1],
      lat=g1$STAS$lat[w1],
      lon = g1$STAS$lon[w1],
      z = g1$STAS$z[w1],
      err= g1$STAS$err[w1],
      yr = rep(g1$LOC$yr , times=N),
      jd = rep(g1$LOC$jd, times=N),
      mo = rep(g1$LOC$mo, times=N),
      dom = rep(g1$LOC$dom, times=N),
      hr =rep( g1$LOC$hr, times=N),
      mi = rep(g1$LOC$mi, times=N) )

 ######  let the code determine the initial guess
    NEW = Klocate(Ldat  )

  


</code></pre>

<hr>
<h2 id='lastPIX'>Last Pix
</h2><span id='topic+lastPIX'></span><span id='topic+editPIX'></span>

<h3>Description</h3>

<p>'RSEIS' Button: Restore Last WPX file from
memory. Function is used internally in swig.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lastPIX(nh, g)
editPIX(nh, g)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lastPIX_+3A_nh">nh</code></td>
<td>
<p>GH list from RSEIS
</p>
</td></tr>
<tr><td><code id="lastPIX_+3A_g">g</code></td>
<td>
<p>parameters from swig
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New WPX list attached to g
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>

<hr>
<h2 id='latlonz2wpx'>Add Lat-Lon-Z to WPX list
</h2><span id='topic+latlonz2wpx'></span>

<h3>Description</h3>

<p>Given an existing list of seismic picks, add
Latitude, Longitude and Elevation
associated with the indicated station.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latlonz2wpx(twpx, stas)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latlonz2wpx_+3A_twpx">twpx</code></td>
<td>
<p>List of picks from swig
</p>
</td></tr>
<tr><td><code id="latlonz2wpx_+3A_stas">stas</code></td>
<td>
<p>station list
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The names of the stations 
are matched to the station names int he station file.
</p>


<h3>Value</h3>

<p>Pick file with LLZ added as list members.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>Klocate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(GH, package='RSEIS')
WW = RSEIS::uwpfile2ypx(GH$pickfile)

twpx  = latlonz2wpx(WW, GH$pickfile$STAS )


</code></pre>

<hr>
<h2 id='LDATlist'>List location data
</h2><span id='topic+LDATlist'></span>

<h3>Description</h3>

<p>List location data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDATlist(g1, w1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDATlist_+3A_g1">g1</code></td>
<td>
<p>loc list
</p>
</td></tr>
<tr><td><code id="LDATlist_+3A_w1">w1</code></td>
<td>
<p>index
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>

<hr>
<h2 id='LeftjustTime'>Adjust times relative to 
least minute.
</h2><span id='topic+LeftjustTime'></span>

<h3>Description</h3>

<p>Adjust times relative to 
least minute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LeftjustTime(g1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LeftjustTime_+3A_g1">g1</code></td>
<td>
<p>list with times, yr, jd, hr, mi, sec
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Reutrns the list with the 
times adjusted to the least minimum (left adjusted)
</p>


<h3>Value</h3>

<p>list is returned.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p> recdate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(0)

d1  = list(yr=rep(2005, 4), jd=rep(5, 4), hr=rep(6, 4), mi=c(1,1,2,3), sec=runif(4, 0, 60))
LeftjustTime(d1)

</code></pre>

<hr>
<h2 id='legitWPX'>Legitimate Pix
</h2><span id='topic+legitWPX'></span>

<h3>Description</h3>

<p>Check WPX list for legitimate picks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>legitWPX(twpx, quiet=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="legitWPX_+3A_twpx">twpx</code></td>
<td>
<p>pick information list (WPX)
</p>
</td></tr>
<tr><td><code id="legitWPX_+3A_quiet">quiet</code></td>
<td>
<p>logical, default=TRUE, FALSE generates an error message
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used internall to test if
a WPX list has legitimate picks.
Initially a list is generated with
NA and 0 values in the place holders.
If no legitimate picks are added, the list still exists, but the
picks are bogus, so this routine will return 0.
</p>


<h3>Value</h3>

<p>integer: 0=not legitimate, 1=legitimate
</p>


<h3>Note</h3>

<p>Currently only the name is tested for all(NA), but
this might be changed int he future
for a more sophisticated test.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>PCsaveWPX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###  test fails

library(RSEIS)
jk = RSEIS::cleanWPX()
legitWPX(jk)

####  test passes:
data(GH, package='RSEIS')
gwpx = RSEIS::uwpfile2ypx(GH$pickfile)

legitWPX(gwpx)


</code></pre>

<hr>
<h2 id='MeanStaDist'>Mean Station Distance
</h2><span id='topic+MeanStaDist'></span>

<h3>Description</h3>

<p> calculate the mean km distance of a set of Lat-lon pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MeanStaDist(Ldat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MeanStaDist_+3A_ldat">Ldat</code></td>
<td>
<p>station list with elements of Lat-Lon
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a list with elements named lat and lon,
find the mean station distance.
</p>


<h3>Value</h3>

<p>scalar
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>setPROJ, GLOB.XY,  dist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(GH, package='RSEIS')
MeanStaDist(GH$pickfile$STAS)

</code></pre>

<hr>
<h2 id='NLSlocate'>Nonlinear Least Squares Location
</h2><span id='topic+NLSlocate'></span>

<h3>Description</h3>

<p>Nonlinear Least Squares Location using Gieger's method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NLSlocate(GH, vel = list(), init = c(0, 0, 0, 0), PLOT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NLSlocate_+3A_gh">GH</code></td>
<td>
<p>List, RSEIS
</p>
</td></tr>
<tr><td><code id="NLSlocate_+3A_vel">vel</code></td>
<td>
<p>velocity model
</p>
</td></tr>
<tr><td><code id="NLSlocate_+3A_init">init</code></td>
<td>
<p>initial guess for event location
</p>
</td></tr>
<tr><td><code id="NLSlocate_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE=plot
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an adaptation of non-linear least squares 
inversion for earthquake location.
A residual function is supplied, 
and iterations are performed until the location
is determined.
</p>


<h3>Value</h3>

<p>vector, new location
</p>


<h3>Note</h3>

<p>At this stage there are no weighting
mechanisms or code to eliminate 
data that has residuals that are too large.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Lee, W.H.K., and S.W. Stewart, 
Principles and Applications of Microearthquake Networks, Academic Press, New York, 1981.
</p>


<h3>See Also</h3>

<p>swig
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(GH, package='RSEIS')
###  location is:
eqsol = NLSlocate(GH, vel=GH$velfile,  PLOT=TRUE )


</code></pre>

<hr>
<h2 id='OnePerSta'>One Phase Pick Per Station
</h2><span id='topic+OnePerSta'></span>

<h3>Description</h3>

<p>Require only one pick per station of a specified phase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OnePerSta(twpx, phase = "Y")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OnePerSta_+3A_twpx">twpx</code></td>
<td>
<p>WPX list
</p>
</td></tr>
<tr><td><code id="OnePerSta_+3A_phase">phase</code></td>
<td>
<p>character, specific phase
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is used to reduce the number of
picks for specific station and phase.  
The purpose is avoid multiple P-wave phases 
for each station in the earthquake location 
routines.
</p>


<h3>Value</h3>

<p>WPX list
</p>


<h3>Note</h3>

<p>For S-waves there may be multiple
S-wave arrivals, as in the 
case for shear wave splitting.
In that case it is probably best to 
name the phases differently, as in 
S1, S2, for example.  
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>cleanWPX, repairWPX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
s1 = RSEIS::setWPX(name="HI", phase="P", yr=2011, jd=231, hr=4, mi=3, sec = runif(5)) 
s2 = RSEIS::setWPX(name="BYE", phase="P", yr=2011, jd=231, hr=4, mi=3, sec = runif(5)) 

s3 = RSEIS::catWPX(s1, s2)

s4 = OnePerSta(s3, phase = "P")



</code></pre>

<hr>
<h2 id='PCfiledatetime'>Create a character string from a date</h2><span id='topic+PCfiledatetime'></span>

<h3>Description</h3>

<p>Create a character string from a date for
naming unique output files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCfiledatetime(orgtim, tims)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCfiledatetime_+3A_orgtim">orgtim</code></td>
<td>
<p>time vector of length 5: c(yr, jd, hr, mi, sec)  </p>
</td></tr>
<tr><td><code id="PCfiledatetime_+3A_tims">tims</code></td>
<td>
<p>seconds to add to orgtim</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>filename</code></td>
<td>
<p>character string</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(RSEIS)
data(GH, package='RSEIS')

g1 = getGHtime(GH)
g2 = unlist(g1)

PCfiledatetime(g2, 1)



</code></pre>

<hr>
<h2 id='PCsaveWPX'>Save WPX list 
</h2><span id='topic+PCsaveWPX'></span><span id='topic+SaveCSV'></span>

<h3>Description</h3>

<p>Save a WPX list to a file on the local file system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCsaveWPX(twpx, destdir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCsaveWPX_+3A_twpx">twpx</code></td>
<td>
<p>WPX list
</p>
</td></tr>
<tr><td><code id="PCsaveWPX_+3A_destdir">destdir</code></td>
<td>
<p>character, destination directory, default=NULL
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a file with the list as in native
binary format.  This file can
be loaded with the standard load function in R.
The name of the file is 
created by using the minimum time extracted from the WPX list.
The suffix on the file name is RDATA.
When reading in, the object created is named &quot;twpx&quot;
for further processing.
</p>
<p>destdir must be set, otherwise the destination directory will be
temporary.  Typically this is set to a local directory where the user
has write access.
</p>


<h3>Value</h3>

<p>Side effects on file system.  The name of the output file is returned.
</p>


<h3>Note</h3>

<p>User must have write access to the destination directory.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>RSEIS::addWPX,	RSEIS::catWPX,	RSEIS::checkWPX,	RSEIS::cleanWPX,	RSEIS::clusterWPX,	RSEIS::repairWPX,	RSEIS::setWPX
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#####  save files as RDS to users disk

s1 = RSEIS::setWPX(name="HI", yr=2011, jd=231, hr=4, mi=3, sec = runif(5))

hh = PCsaveWPX(s1, destdir= tempdir() )

###   read in the data
twpx = readRDS(hh)

data.frame(twpx)

</code></pre>

<hr>
<h2 id='PFoutput'>Write a pickfile to disk
</h2><span id='topic+PFoutput'></span>

<h3>Description</h3>

<p>Write a pickfile to disk, after updating the earthquake location,
in a variety of formats. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PFoutput(PF, stas = NULL, sol = NULL, format = 0, destdir=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PFoutput_+3A_pf">PF</code></td>
<td>
<p>Pickfile list from RSEIS
</p>
</td></tr>
<tr><td><code id="PFoutput_+3A_stas">stas</code></td>
<td>
<p>station list
</p>
</td></tr>
<tr><td><code id="PFoutput_+3A_sol">sol</code></td>
<td>
<p>solution vector, (lat, lon, z, t0)
</p>
</td></tr>
<tr><td><code id="PFoutput_+3A_format">format</code></td>
<td>
<p>integer, 0=all formats, 1=native R, 2=UW, 3=csv)
</p>
</td></tr>
<tr><td><code id="PFoutput_+3A_destdir">destdir</code></td>
<td>
<p>character, full path to destination directory,
default=NULL )
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Writes files to disk in local directory.
</p>


<h3>Value</h3>

<p>Side effects: writes files to user's disk
</p>


<h3>Note</h3>

<p>The destdir (destination directory) must be provided
for the file to be save properly.
</p>
<p>Creates a file name and writes to disk in a variety of formats.
</p>
<p>A destdir that is NULL will result in writing to a temporary file.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>SavePF, RSEIS
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(GH, package='RSEIS')
g1 = GH$pickfile

####  saves pick files to disk 
PFoutput(g1, stas = NULL, sol = NULL, format = 1, destdir=tempdir() )

PFoutput(g1, stas = NULL, sol = NULL, format = 2, destdir=tempdir() )

PFoutput(g1, stas = NULL, sol = NULL, format = 3, destdir=tempdir() )

PFoutput(g1, stas = NULL, sol = NULL, format = 0, destdir=tempdir() )




</code></pre>

<hr>
<h2 id='Pick3'>PICK Buttons for swig
</h2><span id='topic+Pick3'></span>

<h3>Description</h3>

<p>Picking functions for swig
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Pick3(nh, g)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Pick3_+3A_nh">nh</code></td>
<td>
<p>waveform list for RSEIS
</p>
</td></tr>
<tr><td><code id="Pick3_+3A_g">g</code></td>
<td>
<p>plotting parameter list for interactive program
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Buttons can be defined on the fly.
</p>

<dl>
<dt>Pick3</dt><dd><p>Multiple picks on a panel</p>
</dd>
</dl>



<h3>Value</h3>

<p>The return value depends on the nature of the function
as it is returned to the main code swig.
Choices for returning to swig are: break, replot, revert, replace,
donothing, exit.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>swig, PickWin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(interactive()){ 
######  interactive addition of button in swig
library(RSEIS)
MYFUNC&lt;-function(nh, g)
  {
    print("pressed MYFUNC")
    d = data.frame(list(stations=nh$STNS, components=nh$COMPS))
print(d)        
    g$action = "replot"
    invisible(list(global.vars=g))	
  }

STDLAB=c("DONE", "QUIT", "SELBUT" , "MYFUNC" )
data(GH, package='RSEIS')
JJ = RSEIS::swig(GH, sel=1:10, STDLAB=STDLAB)

}


</code></pre>

<hr>
<h2 id='plotEQ'>Plot Earthquake location
</h2><span id='topic+plotEQ'></span>

<h3>Description</h3>

<p>Plot Earthquake location
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotEQ(Ldat, AQ, add = FALSE, prep = FALSE,
TIT = "UTM Projected Stations", proj = NULL,
 xlim = NULL, ylim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotEQ_+3A_ldat">Ldat</code></td>
<td>
<p>Data list
</p>
</td></tr>
<tr><td><code id="plotEQ_+3A_aq">AQ</code></td>
<td>
<p>Earthquake solution (location)
</p>
</td></tr>
<tr><td><code id="plotEQ_+3A_add">add</code></td>
<td>
<p>logical, TRUE=add to plot
</p>
</td></tr>
<tr><td><code id="plotEQ_+3A_prep">prep</code></td>
<td>
<p>preparation
</p>
</td></tr>
<tr><td><code id="plotEQ_+3A_tit">TIT</code></td>
<td>
<p>title
</p>
</td></tr>
<tr><td><code id="plotEQ_+3A_proj">proj</code></td>
<td>
<p>projection list
</p>
</td></tr>
<tr><td><code id="plotEQ_+3A_xlim">xlim</code></td>
<td>
<p>2-vector, x limits (km)
</p>
</td></tr>
<tr><td><code id="plotEQ_+3A_ylim">ylim</code></td>
<td>
<p>2-vector, y limits (km)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>used internally in RElocateEQ
</p>


<h3>Value</h3>

<p>graphical side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>RElocateEQ
</p>

<hr>
<h2 id='plotJACKLLZ'>BoxPlot Jackknife of station locations
</h2><span id='topic+plotJACKLLZ'></span>

<h3>Description</h3>

<p>BoxPlot Jackknife of station locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotJACKLLZ(hjack, sta, proj = NULL,  PLOT=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotJACKLLZ_+3A_hjack">hjack</code></td>
<td>
<p>Output of hijack
</p>
</td></tr>
<tr><td><code id="plotJACKLLZ_+3A_sta">sta</code></td>
<td>
<p>station location list
</p>
</td></tr>
<tr><td><code id="plotJACKLLZ_+3A_proj">proj</code></td>
<td>
<p>projection list
</p>
</td></tr>
<tr><td><code id="plotJACKLLZ_+3A_plot">PLOT</code></td>
<td>
<p>plotting flag, 1,2. 
if plot =1 plot only boxplot, if plot=2 plot only map. Default=0
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>takes the output of the HiJack function and extracts the pseudovalues
and influence information for boxplots.
</p>


<h3>Value</h3>

<p>Graphical side effects and
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>influence of lon
</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>influence of lat
</p>
</td></tr>
<tr><td><code>Z</code></td>
<td>
<p>influence of depth
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Iversen, E. S., and J. M. Lees (1996), A statistical technique for
validating velocity models,
Bull. Seismol. Soc. Am. 86(6), 1853-1862.
</p>


<h3>See Also</h3>

<p>HiJACK, BLACKJACK,imageINFLUENCE, Vlocate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cosopix)
data(wu_coso.vel)
data(coso_sta_LLZ)

COSOjack = HiJACK(cosopix, coso_sta_LLZ, wu_coso.vel)

proj = GEOmap::setPROJ(2, mean(coso_sta_LLZ$lat),
mean(coso_sta_LLZ$lon))

####  show stats
plotJACKLLZ(COSOjack, coso_sta_LLZ, proj, PLOT=1 )


####  show maps
plotJACKLLZ(COSOjack, coso_sta_LLZ, proj, PLOT=2 )



</code></pre>

<hr>
<h2 id='PostREQquake'>Post Processing on EQrquake
</h2><span id='topic+PostREQquake'></span>

<h3>Description</h3>

<p>Post Processing on EQrquake
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PostREQquake(XQ, proj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PostREQquake_+3A_xq">XQ</code></td>
<td>
<p>List of Earthquakes
</p>
</td></tr>
<tr><td><code id="PostREQquake_+3A_proj">proj</code></td>
<td>
<p>projection list
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following event locations, plot.
</p>


<h3>Value</h3>

<p>graphical side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>

<hr>
<h2 id='PostVquake'>Plotting error ellipsoids of many events
</h2><span id='topic+PostVquake'></span>

<h3>Description</h3>

<p>Plotting error ellipsoids of many events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PostVquake(MANYeq, GX, GY, XY, proj, add=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PostVquake_+3A_manyeq">MANYeq</code></td>
<td>
<p>List of earthquakes following Vlocate
</p>
</td></tr>
<tr><td><code id="PostVquake_+3A_gx">GX</code></td>
<td>
<p>X-bounds for plot
</p>
</td></tr>
<tr><td><code id="PostVquake_+3A_gy">GY</code></td>
<td>
<p>Y-bounds for plot
</p>
</td></tr>
<tr><td><code id="PostVquake_+3A_xy">XY</code></td>
<td>
<p>station locations in km
</p>
</td></tr>
<tr><td><code id="PostVquake_+3A_proj">proj</code></td>
<td>
<p>projection list
</p>
</td></tr>
<tr><td><code id="PostVquake_+3A_add">add</code></td>
<td>
<p>logical; if TRUE, add to existing plot (DEFAULT=FALSE)
</p>
</td></tr>
<tr><td><code id="PostVquake_+3A_...">...</code></td>
<td>
<p> graphical parameters for plotting (see par)   </p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Plots the event and the error ellipsoids
</p>


<h3>Value</h3>

<p>Graphical side effects
</p>


<h3>Note</h3>

<p>This is used to plot many event locations
and their error ellipsoids
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>eqlipse
</p>

<hr>
<h2 id='Qrangedatetime'>Range of Date Time</h2><span id='topic+Qrangedatetime'></span>

<h3>Description</h3>

<p>Return the range of dates and times for any list with a date/time list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qrangedatetime(D)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qrangedatetime_+3A_d">D</code></td>
<td>
<p>info list from RSEIS seismic data list</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>min</code></td>
<td>
<p>date time list</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>date time list</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(RSEIS)
data(GH, package='RSEIS')

v = Qrangedatetime(GH$info)



</code></pre>

<hr>
<h2 id='ReSet'>Button to reset the choices of station and component 
</h2><span id='topic+ReSet'></span>

<h3>Description</h3>

<p>Button to reset the choices of station and component in swig and Mine.seis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReSet(nh, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReSet_+3A_nh">nh</code></td>
<td>
<p>RSEIS list
</p>
</td></tr>
<tr><td><code id="ReSet_+3A_g">g</code></td>
<td>
<p>swig parameters
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Driver for SELstaDB
</p>


<h3>Value</h3>

<p>Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>SELstaDB, Mine.seis
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(interactive()){
data(GH, package='RSEIS')

buts = "ReSet"
RSEIS::swig(GH, PADDLAB=buts)

}

</code></pre>

<hr>
<h2 id='ripper'>Rip off Event location information
</h2><span id='topic+ripper'></span>

<h3>Description</h3>

<p>Extract Event location information following Vlocate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ripper(AQ)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ripper_+3A_aq">AQ</code></td>
<td>
<p>event location list
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extract lat-lon from event locations to track
intermediate solutions and convergence
</p>


<h3>Value</h3>

<p>2 by N matrix, lat-lon
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>plotEQ
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(RSEIS)
data(GH, package='RSEIS')

g1 = GH$pickfile

data(VELMOD1D, package='RSEIS')
vel= VELMOD1D

 w1 = which(!is.na(g1$STAS$lat))
         sec = g1$STAS$sec[w1]

         N = length(sec)
         Ldat =    list(
           name = g1$STAS$name[w1],
           sec = g1$STAS$sec[w1],
           phase = g1$STAS$phase[w1],
           lat=g1$STAS$lat[w1],
           lon = g1$STAS$lon[w1],
           z = g1$STAS$z[w1],
           err= g1$STAS$err[w1],
           yr = rep(g1$LOC$yr , times=N),
           jd = rep(g1$LOC$jd, times=N),
           mo = rep(g1$LOC$mo, times=N),
           dom = rep(g1$LOC$dom, times=N),
           hr =rep( g1$LOC$hr, times=N),
           mi = rep(g1$LOC$mi, times=N) )


wstart = which.min(Ldat$sec)
        EQ = list(lat=Ldat$lat[wstart], lon=Ldat$lon[wstart], z=6, t=Ldat$sec[wstart] )
      

  AQ = Vlocate(Ldat,EQ,vel, 
      distwt = 10,
      lambdareg =100 ,
      REG = TRUE,
      WTS = TRUE,
      STOPPING = TRUE,
      tolx =   0.01,
      toly = 0.01 ,
      tolz = 0.05, maxITER = c(7,5,7,4) , RESMAX = c(0.1, 0.1),  PLOT=FALSE)


qtip = ripper(AQ)



</code></pre>

<hr>
<h2 id='Rowz2Keep'>Rows to Keep for inversion
</h2><span id='topic+Rowz2Keep'></span>

<h3>Description</h3>

<p>Selects which rows in the
hypocenter determination to keep during non-linear itaerations
based on robust rsidual elimination.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rowz2Keep(Ldat, EQ, G1, RESMAX)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Rowz2Keep_+3A_ldat">Ldat</code></td>
<td>
<p>List of station arrivals 
</p>
</td></tr>
<tr><td><code id="Rowz2Keep_+3A_eq">EQ</code></td>
<td>
<p>Earthquake location
</p>
</td></tr>
<tr><td><code id="Rowz2Keep_+3A_g1">G1</code></td>
<td>
<p>derivative and travel time estimates
</p>
</td></tr>
<tr><td><code id="Rowz2Keep_+3A_resmax">RESMAX</code></td>
<td>
<p>2-vector for P and S-wave residual maxima
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a utility used internally.
</p>
<p>Residuals greater than the respective maxima
provided are eliminated in the svd inversion.
If fewer than 4 remain, the smallest 4 rows are returned.
</p>


<h3>Value</h3>

<p>Index of good rows
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>XYlocate
</p>

<hr>
<h2 id='RQ'>Rquake Button
</h2><span id='topic+RQ'></span>

<h3>Description</h3>

<p>Driver for NLSlocate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RQ(nh, g, idev = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RQ_+3A_nh">nh</code></td>
<td>
<p>RSEIS list 
</p>
</td></tr>
<tr><td><code id="RQ_+3A_g">g</code></td>
<td>
<p>parameters from swig
</p>
</td></tr>
<tr><td><code id="RQ_+3A_idev">idev</code></td>
<td>
<p>device for plotting
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Button to be called from 
within swig after picking.
</p>


<h3>Value</h3>

<p>new hypocenter
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>NLSlocate, EQXYresid, XYSETUP, swig,chak
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
##### interactive  
data(GH, package='RSEIS')

 buts = c("GPIX","PPIX", "PickWin",
         "fspread", "gMAP", "RQ" , "CONTPF")

RSEIS::swig(GH, PADDLAB=buts)
}

</code></pre>

<hr>
<h2 id='Rquake-package'>
Seismic Analysis of Earthquake Hypocenter determination
</h2><span id='topic+Rquake-package'></span><span id='topic+Rquake'></span>

<h3>Description</h3>

<p>Non-linear earthquake locations are estimated
by sequential convergence to
hypocenter solutions, along with error ellipsoids and
3D-plotting, using a
coordination of functions  from 'RSEIS', 'GEOmap', 'RFOC'
and others for a complete seismic analysis
from field campaign data or data extracted from online websites.
Interactive codes for seismic phase picking can be combined with
event location to go from raw seismic time series to earthquake analysis
and spatial statistics.
</p>


<h3>Details</h3>

<p>Rquake is a package for analaysis of seismic data 
collected continuously, or in trigger mode.
The functions organize other functions from
'RSEIS' and 'GEOmap' to help researchers 
pick, locate, and store hypocenters
for detailed seismic investigation.
</p>


<h3>Note</h3>

 
<dl>
<dt>Functions</dt><dd>
<p>CONTPF
EQXYresid
INITpickfile
NLSlocate
PFoutput
RQ
SavePF
UPdateEQLOC
XYSETUP
Y2Pphase
chak
contPFarrivals
doAmap
gMAP
getregionals
prepPDE
viewCHAC
</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;
Maintainer:Jonathan M. Lees&lt;jonathan.lees.edu&gt;
</p>


<h3>References</h3>

<p>Lee, W.H.K., and S.W. Stewart, Principles and Applications of Microearthquake Networks, Academic Press, New York, 1981.
</p>


<h3>See Also</h3>

<p><code><a href="RSEIS.html#topic+RSEIS-package">RSEIS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(RSEIS)
data(GH, package='RSEIS')

g1 = GH$pickfile

data(VELMOD1D, package='RSEIS')
vel= VELMOD1D

 w1 = which(!is.na(g1$STAS$lat))
         sec = g1$STAS$sec[w1]

         N = length(sec)
         Ldat =    list(
           name = g1$STAS$name[w1],
           sec = g1$STAS$sec[w1],
           phase = g1$STAS$phase[w1],
           lat=g1$STAS$lat[w1],
           lon = g1$STAS$lon[w1],
           z = g1$STAS$z[w1],
           err= g1$STAS$err[w1],
           yr = rep(g1$LOC$yr , times=N),
           jd = rep(g1$LOC$jd, times=N),
           mo = rep(g1$LOC$mo, times=N),
           dom = rep(g1$LOC$dom, times=N),
           hr =rep( g1$LOC$hr, times=N),
           mi = rep(g1$LOC$mi, times=N) )


wstart = which.min(Ldat$sec)
        EQ = list(lat=Ldat$lat[wstart], lon=Ldat$lon[wstart], z=6, t=Ldat$sec[wstart] )
      

  AQ = Vlocate(Ldat,EQ,vel, 
      distwt = 10,
      lambdareg =100 ,
      REG = TRUE,
      WTS = TRUE,
      STOPPING = TRUE,
      tolx =   0.01,
      toly = 0.01 ,
      tolz = 0.05, maxITER = c(7,5,7,4) , RESMAX = c(0.1, 0.1),  PLOT=FALSE)



</code></pre>

<hr>
<h2 id='SavePF'>Save Pick File Button
</h2><span id='topic+SavePF'></span>

<h3>Description</h3>

<p>Save a pick file from within swig
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SavePF(nh, g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SavePF_+3A_nh">nh</code></td>
<td>
<p>RSEIS data list
</p>
</td></tr>
<tr><td><code id="SavePF_+3A_g">g</code></td>
<td>
<p>list of parameters internal to swig
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses PFoutput to save a pickfile to disk.
</p>


<h3>Value</h3>

<p>Side Effects
</p>


<h3>Note</h3>

<p>Pickfile is saved as a native R file with wpx extension
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>PFoutput
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(interactive()){
data(GH, package='RSEIS')
buts = "SavePF"
RSEIS::swig(GH, PADDLAB=buts)

}

</code></pre>

<hr>
<h2 id='SELstaDB'>Pick stations and components
interactively
</h2><span id='topic+SELstaDB'></span>

<h3>Description</h3>

<p>Pick stations and components
interactively.  This is a routine
used in swig.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SELstaDB(IDB, sel=1, newdev=TRUE, STAY=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SELstaDB_+3A_idb">IDB</code></td>
<td>
<p>list with component vectors, usta and ucomp
</p>
</td></tr>
<tr><td><code id="SELstaDB_+3A_sel">sel</code></td>
<td>
<p>vector of index to selected traces
</p>
</td></tr>
<tr><td><code id="SELstaDB_+3A_newdev">newdev</code></td>
<td>
<p>logical, whether
to create a new device.
</p>
</td></tr>
<tr><td><code id="SELstaDB_+3A_stay">STAY</code></td>
<td>
<p>logical, whether
to keep device active.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of index to list of stations and components
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>infoDB, makeDB</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){

### make a database from the files on disk
### DBnov = makeDB(fpath, fpat, kind=2, Iendian=1, BIGLONG=FALSE)
### IDB = infoDB(DBnov)
###   or, as an example:
data(GH, package='RSEIS')

DBnov = list(usta = unique(GH$STNS), unique(GH$COMPS))
 

k = SELstaDB(IDB)

}
</code></pre>

<hr>
<h2 id='UPdateEQLOC'>Update an Earthquake location
</h2><span id='topic+UPdateEQLOC'></span>

<h3>Description</h3>

<p>Update an Earthquake location following
a relocation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UPdateEQLOC(PF, sol, vel, stas = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UPdateEQLOC_+3A_pf">PF</code></td>
<td>
<p>Pickfile List
</p>
</td></tr>
<tr><td><code id="UPdateEQLOC_+3A_sol">sol</code></td>
<td>
<p>solution vector (lat, lon, z, t0)
</p>
</td></tr>
<tr><td><code id="UPdateEQLOC_+3A_vel">vel</code></td>
<td>
<p> 1D velocity model
</p>
</td></tr>
<tr><td><code id="UPdateEQLOC_+3A_stas">stas</code></td>
<td>
<p>station list (name, lat, lon, z)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After re-picking or changing the model or the
station corrections, update the event location in
the pickfile.
</p>


<h3>Value</h3>

<p>Pickfile List
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>EQXYresid, NLSlocate,PFoutput
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(GH, package='RSEIS')

g1 = GH$pickfile
data(VELMOD1D, package='RSEIS')

vel= VELMOD1D

 w1 = which(!is.na(g1$STAS$lat))
         sec = g1$STAS$sec[w1]

         N = length(sec)
         Ldat =    list(
           name = g1$STAS$name[w1],
           sec = g1$STAS$sec[w1],
           phase = g1$STAS$phase[w1],
           lat=g1$STAS$lat[w1],
           lon = g1$STAS$lon[w1],
           z = g1$STAS$z[w1],
           err= g1$STAS$err[w1],
           yr = rep(g1$LOC$yr , times=N),
           jd = rep(g1$LOC$jd, times=N),
           mo = rep(g1$LOC$mo, times=N),
           dom = rep(g1$LOC$dom, times=N),
           hr =rep( g1$LOC$hr, times=N),
           mi = rep(g1$LOC$mi, times=N) )

  wstart = which.min(Ldat$sec)
  EQ = list(lat=Ldat$lat[wstart], lon=Ldat$lon[wstart], z=6, t=Ldat$sec[wstart] )
      

 AQ = Vlocate(Ldat,EQ,vel, 
      distwt = 10,
      lambdareg =100 ,
      REG = TRUE,
      WTS = TRUE,
      STOPPING = TRUE,
      tolx =   0.01,
      toly = 0.01 ,
      tolz = 0.05, maxITER = c(7,5,7,4) , RESMAX = c(0.1, 0.1),  PLOT=FALSE)

sol = c(AQ$EQ$lat, AQ$EQ$lon, AQ$EQ$z, AQ$EQ$t)

upf = UPdateEQLOC(g1, sol  , vel, stas=g1$STAS)

</code></pre>

<hr>
<h2 id='Vlocate'>Hypocenter Determination
</h2><span id='topic+Vlocate'></span>

<h3>Description</h3>

<p>Hypocenter Determination
with error checking and adjustments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Vlocate(Ldat,EQ,vel, 
                  distwt = 10,
                  lambdareg =100,
                  REG = TRUE,
                  WTS = TRUE,
                  STOPPING = TRUE,
                  tolx = 0.1,
                  toly = 0.1,
                  tolz = 0.5,
                  RESMAX = c(.4,.5),
                  maxITER = c(7, 5, 7, 4),
                  PLOT=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Vlocate_+3A_ldat">Ldat</code></td>
<td>
<p>list, must inlude: lat, lon ,err, sec, cor (see details)
</p>
</td></tr>
<tr><td><code id="Vlocate_+3A_eq">EQ</code></td>
<td>
<p>list, must inlude: lat,lon,z, t
</p>
</td></tr>
<tr><td><code id="Vlocate_+3A_vel">vel</code></td>
<td>
<p>list, 1D velocity structure
</p>
</td></tr>
<tr><td><code id="Vlocate_+3A_distwt">distwt</code></td>
<td>
<p>distance weighting factor
</p>
</td></tr>
<tr><td><code id="Vlocate_+3A_lambdareg">lambdareg</code></td>
<td>
<p>regularization parameter for damping
</p>
</td></tr>
<tr><td><code id="Vlocate_+3A_reg">REG</code></td>
<td>
<p> logical, TRUE=use regularization
</p>
</td></tr>
<tr><td><code id="Vlocate_+3A_wts">WTS</code></td>
<td>
<p>logical, TRUE==use weighting
</p>
</td></tr>
<tr><td><code id="Vlocate_+3A_stopping">STOPPING</code></td>
<td>
<p>logical, TRUE=use stopping criteria
</p>
</td></tr>
<tr><td><code id="Vlocate_+3A_tolx">tolx</code></td>
<td>
<p>numeric, tolerance in km in x direction
</p>
</td></tr>
<tr><td><code id="Vlocate_+3A_toly">toly</code></td>
<td>
<p>numeric, tolerance in km in y  direction
</p>
</td></tr>
<tr><td><code id="Vlocate_+3A_tolz">tolz</code></td>
<td>
<p>numeric, tolerance in km in z  direction
</p>
</td></tr>
<tr><td><code id="Vlocate_+3A_resmax">RESMAX</code></td>
<td>
<p>vector, residual max for P and S, default=c(4,5)
</p>
</td></tr>
<tr><td><code id="Vlocate_+3A_maxiter">maxITER</code></td>
<td>
<p>vector, Maximum number of iterations
for each section of the location routine, default=c(7,5,7,4)
</p>
</td></tr>
<tr><td><code id="Vlocate_+3A_plot">PLOT</code></td>
<td>
<p>logical, plot results during iterations
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper for XYlocate, only here the lat-lon
of the stations is passed and the code does the
projection internally.
</p>
<p>There are 3 main loops, each controled by differing input params: first event is located only in XY
keeping the depth fixed (7 iterations).  Then an initial free solution
is estimated using
robust elimination of residual based on RESMAX (5 iterations).
Finally a set of 7 iterations is applied providing the final
estimate, along with error bars, elliposids, etc.
</p>
<p>In the event no good solution is derived, the regularization parameter
is doubled and a loop with 4 iterations is applied, and the result
returned.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>EQ</code></td>
<td>
<p>Hypocenter lcoation</p>
</td></tr>
<tr><td><code>ERR</code></td>
<td>
<p>Error Analysis</p>
</td></tr>
<tr><td><code>its</code></td>
<td>
<p>number of iteration</p>
</td></tr>
<tr><td><code>Ksolutions</code></td>
<td>
<p>list of matrices, each with intermediate x,y,z,t locations</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The schedule may be adjusted by
duplicating this function and changing the
maxit parameters.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Lee and Stewart
</p>


<h3>See Also</h3>

<p>XYlocate, Klocate, DoRLocate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(RSEIS)
data(GH, package='RSEIS')

g1 = GH$pickfile

data(VELMOD1D, package='RSEIS')
vel= VELMOD1D

 w1 = which(!is.na(g1$STAS$lat))
         sec = g1$STAS$sec[w1]

         N = length(sec)
         Ldat =    list(
           name = g1$STAS$name[w1],
           sec = g1$STAS$sec[w1],
           phase = g1$STAS$phase[w1],
           lat=g1$STAS$lat[w1],
           lon = g1$STAS$lon[w1],
           z = g1$STAS$z[w1],
           err= g1$STAS$err[w1],
           yr = rep(g1$LOC$yr , times=N),
           jd = rep(g1$LOC$jd, times=N),
           mo = rep(g1$LOC$mo, times=N),
           dom = rep(g1$LOC$dom, times=N),
           hr =rep( g1$LOC$hr, times=N),
           mi = rep(g1$LOC$mi, times=N) )


wstart = which.min(Ldat$sec)
        EQ = list(lat=Ldat$lat[wstart], lon=Ldat$lon[wstart], z=6, t=Ldat$sec[wstart] )
      

  AQ = Vlocate(Ldat,EQ,vel, 
      distwt = 10,
      lambdareg =100 ,
      REG = TRUE,
      WTS = TRUE,
      STOPPING = TRUE,
      tolx =   0.01,
      toly = 0.01 ,
      tolz = 0.05, maxITER = c(7,5,7,4) , RESMAX = c(0.1, 0.1),  PLOT=FALSE)



</code></pre>

<hr>
<h2 id='XYerror.bars'>Error Bars in X and Y
</h2><span id='topic+XYerror.bars'></span>

<h3>Description</h3>

<p>Error Bars in X and Y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>XYerror.bars(x, y, xlo = 0, xhi = 0, ylo = 0,
yhi = 0, pch = 1, col = 1, barw = 0.1, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="XYerror.bars_+3A_x">x</code></td>
<td>
<p>X-values
</p>
</td></tr>
<tr><td><code id="XYerror.bars_+3A_y">y</code></td>
<td>
<p>Y-values
</p>
</td></tr>
<tr><td><code id="XYerror.bars_+3A_xlo">xlo</code></td>
<td>
<p>X Lower limit of error bars
</p>
</td></tr>
<tr><td><code id="XYerror.bars_+3A_xhi">xhi</code></td>
<td>
<p>X Upper limit of error bars
</p>
</td></tr>
<tr><td><code id="XYerror.bars_+3A_ylo">ylo</code></td>
<td>
<p>Y Lower limit of error bars
</p>
</td></tr>
<tr><td><code id="XYerror.bars_+3A_yhi">yhi</code></td>
<td>
<p>Y  Upper limit of error bars
</p>
</td></tr>
<tr><td><code id="XYerror.bars_+3A_pch">pch</code></td>
<td>
<p>plotting character
</p>
</td></tr>
<tr><td><code id="XYerror.bars_+3A_col">col</code></td>
<td>
<p>color
</p>
</td></tr>
<tr><td><code id="XYerror.bars_+3A_barw">barw</code></td>
<td>
<p>width of the bar (inches)
</p>
</td></tr>
<tr><td><code id="XYerror.bars_+3A_add">add</code></td>
<td>
<p>logical, add=FALSE starts a new plot
</p>
</td></tr>
<tr><td><code id="XYerror.bars_+3A_...">...</code></td>
<td>
<p>other plotting parameters
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>graphical side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(0)
zup = rnorm(10)

x = 1:10
y = 2*x+5+zup

ydown = rnorm(10)
ydown = ydown-min(ydown)+.2

yup = rnorm(10)
yup = yup-min(yup)+.2



zup = rnorm(10)
xup = zup-min(zup)+.5
xdown = rnorm(10)
xdown = xdown-min(xdown)+.2


####  example with different  error on either side:
XYerror.bars(x, y, y-ydown, y+yup, x-xdown, x+xup,
 pch = 1, col = 'brown' , barw = 0.1, add
= FALSE)



</code></pre>

<hr>
<h2 id='XYlocate'>Locate Earthquake with UTM projection
</h2><span id='topic+XYlocate'></span>

<h3>Description</h3>

<p>Non-linear hypocenter location with UTM
geographical projection.  Used for locating earthquakes in
local or regional settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>XYlocate(Ldat, EQ, vel, maxITER = 10, distwt = 10,
lambdareg = 100, FIXZ
= FALSE, REG = TRUE, WTS = TRUE, STOPPING = TRUE,
RESMAX = c(.4,.5), tolx = 0.005, toly = 0.005,
 tolz = 0.01, PLOT = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="XYlocate_+3A_ldat">Ldat</code></td>
<td>
<p>list, must inlude: x,y,err, sec, cor (see details)
</p>
</td></tr>
<tr><td><code id="XYlocate_+3A_eq">EQ</code></td>
<td>
<p>list, must inlude: x,y,z, t
</p>
</td></tr>
<tr><td><code id="XYlocate_+3A_vel">vel</code></td>
<td>
<p>list, 1D velocity structure
</p>
</td></tr>
<tr><td><code id="XYlocate_+3A_maxiter">maxITER</code></td>
<td>
<p>Maximum number of iterations
</p>
</td></tr>
<tr><td><code id="XYlocate_+3A_distwt">distwt</code></td>
<td>
<p>distance weighting factor
</p>
</td></tr>
<tr><td><code id="XYlocate_+3A_lambdareg">lambdareg</code></td>
<td>
<p>regularization parameter for damping
</p>
</td></tr>
<tr><td><code id="XYlocate_+3A_fixz">FIXZ</code></td>
<td>
<p>logical, TRUE = fix depth, i.e. only calculate x,y,t
</p>
</td></tr>
<tr><td><code id="XYlocate_+3A_reg">REG</code></td>
<td>
<p> logical, TRUE=use regularization
</p>
</td></tr>
<tr><td><code id="XYlocate_+3A_wts">WTS</code></td>
<td>
<p>logical, TRUE==use weighting
</p>
</td></tr>
<tr><td><code id="XYlocate_+3A_stopping">STOPPING</code></td>
<td>
<p>logical, TRUE=use stopping criteria
</p>
</td></tr>
<tr><td><code id="XYlocate_+3A_resmax">RESMAX</code></td>
<td>
<p>vector, residual max for P and S, default=c(4,5)
</p>
</td></tr>
<tr><td><code id="XYlocate_+3A_tolx">tolx</code></td>
<td>
<p>numeric, tolerance in km in x direction
</p>
</td></tr>
<tr><td><code id="XYlocate_+3A_toly">toly</code></td>
<td>
<p>numeric, tolerance in km in y  direction
</p>
</td></tr>
<tr><td><code id="XYlocate_+3A_tolz">tolz</code></td>
<td>
<p>numeric, tolerance in km in z  direction
</p>
</td></tr>
<tr><td><code id="XYlocate_+3A_plot">PLOT</code></td>
<td>
<p>logical, plot results during iterations
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input pick list must have at x,y,z, sec, cor, err elements
for each station.  If no station correction is available it is set to
zero.  If no uncertainty (err) is available, it is set to 0.05 sec.
Each station must have a finite x-y coordinate and arrival time in
seconds. Events are located relative to the minute.
</p>
<p>Routine uses the svd in a sequence of linear inversions
to estimate the nonlinear location.
</p>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>EQ</code></td>
<td>
<p>list, Earthquake hypocenter and time</p>
</td></tr>
<tr><td><code>its</code></td>
<td>
<p>number of iterations</p>
</td></tr>
<tr><td><code>rms</code></td>
<td>
<p>rms residual</p>
</td></tr>
<tr><td><code>wrms</code></td>
<td>
<p>wheighted rms residual</p>
</td></tr>
<tr><td><code>used</code></td>
<td>
<p>vector, index of used equations</p>
</td></tr>
<tr><td><code>guesses</code></td>
<td>
<p>list of x,y,z,t intermediate locations when converging </p>
</td></tr>
</table>


<h3>Note</h3>

<p>This routine should be called by a wrapper (Vlocate) that applies the
algorithm several times and changes parameters based on
the quality.
</p>
<p>If RESMAX is used and the robust approach yields
fewer than 4 equations, the best (smallest) four residuals will be
used to determiine the event location.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>Vlocate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(RSEIS)
data(GH, package='RSEIS')

g1 = GH$pickfile
data(VELMOD1D, package='RSEIS')

vel= VELMOD1D

 w1 = which(!is.na(g1$STAS$lat))
         sec = g1$STAS$sec[w1]

         N = length(sec)
         Ldat =    list(
           name = g1$STAS$name[w1],
           sec = g1$STAS$sec[w1],
           phase = g1$STAS$phase[w1],
           lat=g1$STAS$lat[w1],
           lon = g1$STAS$lon[w1],
           z = g1$STAS$z[w1],
           err= g1$STAS$err[w1],
           yr = rep(g1$LOC$yr , times=N),
           jd = rep(g1$LOC$jd, times=N),
           mo = rep(g1$LOC$mo, times=N),
           dom = rep(g1$LOC$dom, times=N),
           hr =rep( g1$LOC$hr, times=N),
           mi = rep(g1$LOC$mi, times=N) )

 MLAT = median(Ldat$lat)
    MLON = median(Ldat$lon)
    
    proj = GEOmap::setPROJ(type=2, LAT0=MLAT, LON0=MLON)

####   get station X-Y values in km
    XY = GEOmap::GLOB.XY(Ldat$lat, Ldat$lon, proj)
###   add to Ldat list
    Ldat$x = XY$x
    Ldat$y = XY$y
       wstart = which.min(Ldat$sec)



EQ = list(x=XY$x[wstart], y=XY$y[wstart], z=6, t=Ldat$sec[wstart] )

      
 maxITER = 7
###print(EQ)
    AQ = XYlocate(Ldat,EQ,vel, 
      maxITER = maxITER,
      distwt = 1,
      lambdareg =10 ,
      FIXZ = FALSE,
      REG = TRUE,
      WTS = TRUE,
      STOPPING = TRUE,
      RESMAX = c(0.1,0.1),
      tolx =   0.001,
      toly = 0.001 ,
      tolz = 0.5, PLOT=FALSE)

########  update the new location

AXY = GEOmap::XY.GLOB(AQ$EQ$x, AQ$EQ$y, proj)
AQ$EQ$lat = AXY$lat
AQ$EQ$lon = AXY$lon
if(AQ$EQ$lon&gt;180) { AQ$EQ$lon = AQ$EQ$lon-360 }


plot(c(Ldat$x, AQ$EQ$x) , c(Ldat$y,AQ$EQ$y), type='n' , xlab="km",
ylab="km" )

points(Ldat$x, Ldat$y, pch=6)

points(AQ$EQ$x, AQ$EQ$y, pch=8, col='red')

points(EQ$x, EQ$y, pch=4, col='blue')


legend("topright", pch=c(8,4, 6), col=c("red", "blue", "black"),
 legend=c("Final location", "Initial guess", "Station"))


print(AQ)

#####  try a different case with an extremely wrong start
EQ$x = 10
EQ$y = 2

</code></pre>

<hr>
<h2 id='XYSETUP'>Set up matrix for hypocenter inversion
</h2><span id='topic+XYSETUP'></span>

<h3>Description</h3>

<p>Set up matrix for hypocenter inversion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>XYSETUP(STAS, init, vel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="XYSETUP_+3A_stas">STAS</code></td>
<td>
<p>station information from pickfile
</p>
</td></tr>
<tr><td><code id="XYSETUP_+3A_init">init</code></td>
<td>
<p>initial event location
</p>
</td></tr>
<tr><td><code id="XYSETUP_+3A_vel">vel</code></td>
<td>
<p>list, velocity
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This sets up the matrix used for nonlinear inversion.
The code does not include
information on the weighting.
Station corrections are included.
</p>
<p>The STAS are an internal component of the pickfile.
</p>


<h3>Value</h3>

<p>matrix
</p>


<h3>Note</h3>

<p>Need scheme for weighting according to errors
in picks and distance weighting.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>setPROJ, GLOB.XY,NLSlocate
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##  start with the location of the closest station
data(GH, package='RSEIS')

g1 = GH$pickfile
data(VELMOD1D, package='RSEIS')

vel= VELMOD1D

STAS = GH$pickfile$STAS
w1 = STAS$phase == 'P'
initz = 6
t0a = GH$pickfile$LOC$sec


XY = XYSETUP(STAS, c(STAS$lat[w1],STAS$lon[w1], initz,  STAS$sec[w1]-t0a  ) , vel  )



</code></pre>

<hr>
<h2 id='Y2Pphase'>
Convert Y-phase to P-phase
</h2><span id='topic+Y2Pphase'></span>

<h3>Description</h3>

<p>Removes extraneous other-phase from a pick file.
If Ypix were made initially as a rough pick, this
removes them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Y2Pphase(twpx, phase)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Y2Pphase_+3A_twpx">twpx</code></td>
<td>
<p> WPX list
</p>
</td></tr>
<tr><td><code id="Y2Pphase_+3A_phase">phase</code></td>
<td>
<p> character, phase to exchange to P
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Initially many events may be picked using GPIX
button.  These should  be removed after the 
P-phases have been determined with PickWin.
</p>


<h3>Value</h3>

<p>WPX returned without other-phases
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>PPIX, GPIX, YPIX, PickWin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(GH, package='RSEIS')
WW = RSEIS::uwpfile2ypx(GH$pickfile)

twpx  = latlonz2wpx(WW, GH$pickfile$STAS )

twpx$phase[twpx$phase=='P']  = 'Y'
####  now twpx is like a Ypix from swig
###  switch to P
newwpx = Y2Pphase(twpx, "Y" )


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
