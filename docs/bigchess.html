<!DOCTYPE html><html lang="en"><head><title>Help for package bigchess</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bigchess}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#analyze_game'><p>Analyze game</p></a></li>
<li><a href='#analyze_position'><p>Analyze position</p></a></li>
<li><a href='#browse_eco_opening'><p>Browse ECO opening</p></a></li>
<li><a href='#browse_opening'><p>Browse opening</p></a></li>
<li><a href='#eco'><p>ECO</p></a></li>
<li><a href='#extract_moves'><p>Extract first N moves</p></a></li>
<li><a href='#FirstTwoMoves'><p>Example dataset</p></a></li>
<li><a href='#lan2san'><p>Movetext conversion from LAN to SAN</p></a></li>
<li><a href='#n_moves'><p>Compute number of moves</p></a></li>
<li><a href='#player_profile'><p>Compute player profile</p></a></li>
<li><a href='#plot_tree_eco'><p>Plot tree for a given tree ECO table</p></a></li>
<li><a href='#plot_tree_move'><p>Plot tree for a given tree move table</p></a></li>
<li><a href='#read.pgn'><p>Reads PGN files into data frame</p></a></li>
<li><a href='#read.pgn.db'><p>Reads PGN files into database table</p></a></li>
<li><a href='#read.pgn.ff'><p>Reads PGN files into ff data frame</p></a></li>
<li><a href='#san2lan'><p>Movetext conversion from SAN to LAN</p></a></li>
<li><a href='#stat_moves'><p>Extract statistics of moves</p></a></li>
<li><a href='#tree_eco'><p>Compute ECO tree</p></a></li>
<li><a href='#tree_move'><p>Compute tree for a given move</p></a></li>
<li><a href='#uci_cmd'><p>Sending command to chess engine</p></a></li>
<li><a href='#uci_debug'><p>Sending command debug for chess engine</p></a></li>
<li><a href='#uci_engine'><p>Create an engine handler in R</p></a></li>
<li><a href='#uci_go'><p>Sending command go for chess engine</p></a></li>
<li><a href='#uci_isready'><p>Checking if chess engine is ready</p></a></li>
<li><a href='#uci_parse'><p>Parse GUI commands from chess engine</p></a></li>
<li><a href='#uci_ponderhit'><p>Sending command ponderhit for chess engine</p></a></li>
<li><a href='#uci_position'><p>Sending command position for chess engine</p></a></li>
<li><a href='#uci_quit'><p>Sending quit command to chess engine</p></a></li>
<li><a href='#uci_read'><p>Read current stdout from chess engine</p></a></li>
<li><a href='#uci_register'><p>Sending command register for chess engine</p></a></li>
<li><a href='#uci_setoption'><p>Sending command setoption for chess engine</p></a></li>
<li><a href='#uci_stop'><p>Sending command stop for chess engine</p></a></li>
<li><a href='#uci_uci'><p>Sending command uci for chess engine</p></a></li>
<li><a href='#uci_ucinewgame'><p>Sending command ucinewgame for chess engine</p></a></li>
<li><a href='#write.pgn'><p>Write PGN data.frames into file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Read, Write, Manipulate, Explore Chess PGN Files and R API to
UCI Chess Engines</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Wojciech Rosa</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wojciech Rosa &lt;w.rosa@pollub.pl&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions for reading *.PGN files with more than one game, including large files without copying it into RAM (using 'ff' package or 'RSQLite' package). Handle chess data and chess aggregated data, count figure moves statistics, create player profile, plot winning chances, browse openings. Set of functions of R API to communicate with UCI-protocol based chess engines.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>processx</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ff,ffbase,RSQLite,rjson,magrittr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.0</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-08-05 12:13:14 UTC; wojci</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-08-05 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='analyze_game'>Analyze game</h2><span id='topic+analyze_game'></span>

<h3>Description</h3>

<p>Analyze game using UCI engine and R API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_game(engine, san = NULL, lan = NULL, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyze_game_+3A_engine">engine</code></td>
<td>
<p>engine path or engine object from uci_engine()</p>
</td></tr>
<tr><td><code id="analyze_game_+3A_san">san</code></td>
<td>
<p>movetext in short algebraic notation, default NULL</p>
</td></tr>
<tr><td><code id="analyze_game_+3A_lan">lan</code></td>
<td>
<p>movetext in long algebraic notation, default NULL</p>
</td></tr>
<tr><td><code id="analyze_game_+3A_quiet">quiet</code></td>
<td>
<p>boolean, hide system messages? Default FALSE</p>
</td></tr>
<tr><td><code id="analyze_game_+3A_...">...</code></td>
<td>
<p>further arguments passed directly to uci_go(), i.e. depth = 10</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containg analyze_position() result (score and bestlines) for each move in the game. Note that if black moves, then score is multiplied by -1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Linux (make sure you have executable permission):
engine_path &lt;- "./stockfish_10_x64"
# Windows
# engine_path &lt;- "./stockfish_10_x64.exe"
g &lt;- "1. e4 e5 2. Nf3 Nc6 3. d4 exd4 4. Bc4 Nf6 5. O-O Be7"
G &lt;- analyze_game(engine_path,san = g ,depth = 20)
G[[1]] # handles info about first move in the game
G[[1]]$comment # "book"
G[[10]]$curmove_san # "Be7"
G[[10]]$score # 62

</code></pre>

<hr>
<h2 id='analyze_position'>Analyze position</h2><span id='topic+analyze_position'></span>

<h3>Description</h3>

<p>Analyze position using UCI engine and R API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_position(engine, san = NULL, lan = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyze_position_+3A_engine">engine</code></td>
<td>
<p>engine path or engine object from uci_engine()</p>
</td></tr>
<tr><td><code id="analyze_position_+3A_san">san</code></td>
<td>
<p>movetext in short algebraic notation, default NULL</p>
</td></tr>
<tr><td><code id="analyze_position_+3A_lan">lan</code></td>
<td>
<p>movetext in long algebraic notation, default NULL</p>
</td></tr>
<tr><td><code id="analyze_position_+3A_...">...</code></td>
<td>
<p>further arguments passed directly to uci_go()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containg bestomove, score and bestlines
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Linux (make sure you have executable permission):
engine_path &lt;- "./stockfish_10_x64"
# Windows
# engine_path &lt;- "./stockfish_10_x64.exe"
require(magrittr)
ap &lt;- analyze_position(engine_path,san = "1. e4",depth = 20)
ap$bestmove_lan
# "e7e5"
ap$score
# -7
ap$bestmove_san
# "e5"
ap$curpos_lan
# "e2e4"
ap$curpos_san
# "1. e4"
ap$bestline_san
# "e5 2. Nf3 Nc6 3. d4 exd4 4. Bc4 Nf6 5. O-O Be7
# 6. Re1 d6 7. Nxd4 Ne5 8. Bb3 O-O 9. Nc3 c5
# 10. Nf5 Bxf5 11. exf5 c4 12. Ba4 a6 13. Qe2"
ap$bestline_lan
# "e7e5 g1f3 b8c6 d2d4 e5d4 f1c4 g8f6 e1g1 f8e7
# f1e1 d7d6 f3d4 c6e5 c4b3 e8g8 b1c3 c7c5 d4f5
# c8f5 e4f5 c5c4 b3a4 a7a6 d1e2"

</code></pre>

<hr>
<h2 id='browse_eco_opening'>Browse ECO opening</h2><span id='topic+browse_eco_opening'></span>

<h3>Description</h3>

<p>Browse ECO opening winning and drawing percentages by table and barplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>browse_eco_opening(df, topn = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="browse_eco_opening_+3A_df">df</code></td>
<td>
<p>data frame with imported chess games from read.pgn() function.</p>
</td></tr>
<tr><td><code id="browse_eco_opening_+3A_topn">topn</code></td>
<td>
<p>integer, default is 0, passed to tree_eco function (indicating how many top openings should be included).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame from tree_eco function and plot from plot_tree_eco function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "Kasparov.gz", package = "bigchess")
con &lt;- gzfile(f,encoding = "latin1")
df &lt;- read.pgn(con,quiet = TRUE,ignore.other.games = TRUE,stat.moves = FALSE, add.tags = "ECO")
# Analyze 20 best ECO Kasparov openings:
bo &lt;- browse_eco_opening(subset(df,grepl("Kasparov",White)),20)
</code></pre>

<hr>
<h2 id='browse_opening'>Browse opening</h2><span id='topic+browse_opening'></span>

<h3>Description</h3>

<p>Browse opening winning and drawing percentages by table and barplot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>browse_opening(df, movetext = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="browse_opening_+3A_df">df</code></td>
<td>
<p>data frame with imported chess games from read.pgn() function.</p>
</td></tr>
<tr><td><code id="browse_opening_+3A_movetext">movetext</code></td>
<td>
<p>movetext string, default is &quot;&quot; means browse first move for White. The standard English values are required: pawn = &quot;P&quot; (often not used), knight = &quot;N&quot;, bishop = &quot;B&quot;, rook = &quot;R&quot;, queen = &quot;Q&quot;, and king = &quot;K&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame from tree_move function and plot from plot_tree_move function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "Kasparov.gz", package = "bigchess")
con &lt;- gzfile(f,encoding = "latin1")
df &lt;- read.pgn(con,quiet = TRUE,ignore.other.games = TRUE,stat.moves = FALSE)
# Analyze best Kasparov openings:
bo &lt;- browse_opening(subset(df,grepl("Kasparov",White)))
# Analyze 'best' answer to Kasparov Ruy Lopez:
bo &lt;- browse_opening(subset(df,grepl("Kasparov",White)),"1.e4 e5 2.Nf3 Nc6 3.Bb5")
# Analyze best answer to "1.e4 e5 2.Nf3" in aggregated data
browse_opening(FirstTwoMoves,"1.e4 e5 2.Nf3")
</code></pre>

<hr>
<h2 id='eco'>ECO</h2><span id='topic+eco'></span>

<h3>Description</h3>

<p>A dataset containing 2014 ECO (Encyclopedia of Chess Openings) openings
</p>

<ul>
<li><p> ECO
</p>
</li>
<li><p> Opening
</p>
</li>
<li><p> Variation
</p>
</li>
<li><p> Movetext: Standard algebraic notation
</p>
</li>
<li><p> NMoves
</p>
</li>
<li><p> LAN: Movetext converted into long algebraic notation
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(eco)
</code></pre>


<h3>Format</h3>

<p>A data frame with ECO openings</p>

<hr>
<h2 id='extract_moves'>Extract first N moves</h2><span id='topic+extract_moves'></span>

<h3>Description</h3>

<p>Extract first N moves from pgn movetext into data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_moves(movetext, N = 10, last.move = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="extract_moves_+3A_movetext">movetext</code></td>
<td>
<p>movetext string (or string vector). The standard English values are required: pawn = &quot;P&quot; (often not used), knight = &quot;N&quot;, bishop = &quot;B&quot;, rook = &quot;R&quot;, queen = &quot;Q&quot;, and king = &quot;K&quot;.</p>
</td></tr>
<tr><td><code id="extract_moves_+3A_n">N</code></td>
<td>
<p>integer (default 10) determines how many first N moves will be extracted. Default is 10, should be greater than 0.</p>
</td></tr>
<tr><td><code id="extract_moves_+3A_last.move">last.move</code></td>
<td>
<p>boolean (default TRUE) indicating whether to calculate the last move</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame containing first N moves for white and for black, named as W1, B1, W2 and so on, up to WN and BN (where N is input argument). If N is greater than total moves number then NA's generated. Column complete.movetext flag is indicating if movetext string begin with &quot;1.'move'&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>extract_moves("1. e4 e5 2. Nf3 Nf5 3. d5 ",N = 3)
# e4 e5 Nf3 Nf5 d5 NA TRUE
extract_moves("1. e4 e5 2. Nf3 Nf5 3. d5 ",N = 3, last.move = TRUE)
# e4 e5 Nf3 Nf5 d5 NA d5 TRUE
</code></pre>

<hr>
<h2 id='FirstTwoMoves'>Example dataset</h2><span id='topic+FirstTwoMoves'></span>

<h3>Description</h3>

<p>A dataset containing 10,894 results after first two moves in 2,395,869 high-quality chess games played over the board by players with ELO &gt; 2000.
Source data OTB-HQ.7z downloaded from:
https://sourceforge.net/projects/codekiddy-chess/
and converted to PGN in SCID software.
</p>

<ul>
<li><p> Result:
</p>
</li>
<li><p> W1: White first move
</p>
</li>
<li><p> B1: Black first move
</p>
</li>
<li><p> W2: White second move
</p>
</li>
<li><p> B2: Black second move
</p>
</li>
<li><p> Freq: Number of games played in database
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(FirstTwoMoves)
</code></pre>


<h3>Format</h3>

<p>A data frame with popular positions in classic chess</p>

<hr>
<h2 id='lan2san'>Movetext conversion from LAN to SAN</h2><span id='topic+lan2san'></span>

<h3>Description</h3>

<p>Convert LAN movetext (long algebraic notation used by chess engines) to SAN movetext (standard algebraic notation required by FIDE)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lan2san(movetext.lan)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lan2san_+3A_movetext.lan">movetext.lan</code></td>
<td>
<p>movetext string in long algebraic notation (LAN), but without comments, variants etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>movetext in standard algebraic notation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lan2san("e2e4 c7c5")
</code></pre>

<hr>
<h2 id='n_moves'>Compute number of moves</h2><span id='topic+n_moves'></span>

<h3>Description</h3>

<p>Compute total number of moves given movetext string (or string vector)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n_moves(movetext)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="n_moves_+3A_movetext">movetext</code></td>
<td>
<p>movetext string (or string vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n integer (or integer vector)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_moves(c("1. e4 e5 2. Nf3 Nf5 3. d5 ","1. d4 d5"))
# 3 1
</code></pre>

<hr>
<h2 id='player_profile'>Compute player profile</h2><span id='topic+player_profile'></span>

<h3>Description</h3>

<p>Computes players profile from data frame obtained from read.pgn() function into data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>player_profile(df, player)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="player_profile_+3A_df">df</code></td>
<td>
<p>data frame from read.pgn or read.pgn.ff files with stats computed.</p>
</td></tr>
<tr><td><code id="player_profile_+3A_player">player</code></td>
<td>
<p>string used in grepl(player,White) and grepl(player,Black)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with player (column prefix P_) and opponent (column prefix O_) figure move counts. Column Player_Col indicating pieces colour for player (factor White or Black).
Example column P_Q_moves means number of player Queen moves count.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "Kasparov.gz", package = "bigchess")
con &lt;- gzfile(f,encoding = "latin1")
df &lt;- read.pgn(con,quiet = TRUE,ignore.other.games = TRUE)
nrow(df) # 2109
df_pp &lt;- player_profile(df,"Kasparov, Gary")
nrow(df_pp) # 1563
df_pp &lt;- player_profile(df,"Kasparov,G")
nrow(df_pp) # 543
df_pp &lt;- player_profile(df,"Kasparov, G\\.")
nrow(df_pp) # 2
df_pp &lt;- player_profile(df,"Kasparov")
nrow(df_pp) # 2109 - correct
boxplot(P_Q_moves/NMoves~Player_Col,df_pp,
main = "Average Queen Moves\n Kasparov as Black (909 games) vs Kasparov as White (1200 games)",
col = c("black","white"),border = c("black","black"),notch = TRUE)
# Magnus Carlsen data example
f &lt;- system.file("extdata", "Carlsen.gz", package = "bigchess")
con &lt;- gzfile(f,encoding = "latin1")
df &lt;- read.pgn(con,quiet = TRUE,ignore.other.games = TRUE)
nrow(df) # 2410
df_pp &lt;- player_profile(df,"Carlsen")
nrow(df_pp) # 2411 - ??
# One game was played by Carlsen,H
df_pp &lt;- player_profile(df,"Carlsen,M")
nrow(df_pp) # 2410 - correct
</code></pre>

<hr>
<h2 id='plot_tree_eco'>Plot tree for a given tree ECO table</h2><span id='topic+plot_tree_eco'></span>

<h3>Description</h3>

<p>Plot tree (barplot percentages) for a given tree ECO data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_tree_eco(tr, main = "", add.lines = T, add.labels = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_tree_eco_+3A_tr">tr</code></td>
<td>
<p>data frame containg tree ECO</p>
</td></tr>
<tr><td><code id="plot_tree_eco_+3A_main">main</code></td>
<td>
<p>string for main title, default is &quot;&quot;</p>
</td></tr>
<tr><td><code id="plot_tree_eco_+3A_add.lines">add.lines</code></td>
<td>
<p>boolean (default TRUE) add weighted mean lines?</p>
</td></tr>
<tr><td><code id="plot_tree_eco_+3A_add.labels">add.labels</code></td>
<td>
<p>boolean (default TRUE) add labels?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Barplot with white scores, draws percent and black scores.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "Kasparov.gz", package = "bigchess")
con &lt;- gzfile(f,encoding = "latin1")
df &lt;- read.pgn(con,quiet = TRUE,stat.moves = FALSE, add.tags = "ECO")
tr &lt;- tree_eco(subset(df,W1=="e4"),20)
plot_tree_eco(tr,"1. e4 ... ?")
</code></pre>

<hr>
<h2 id='plot_tree_move'>Plot tree for a given tree move table</h2><span id='topic+plot_tree_move'></span>

<h3>Description</h3>

<p>Plot tree (barplot percentages) for a given tree move data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_tree_move(tr, main = "", add.lines = T, add.labels = T)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_tree_move_+3A_tr">tr</code></td>
<td>
<p>data frame containg tree move</p>
</td></tr>
<tr><td><code id="plot_tree_move_+3A_main">main</code></td>
<td>
<p>string for main title, default is &quot;&quot;</p>
</td></tr>
<tr><td><code id="plot_tree_move_+3A_add.lines">add.lines</code></td>
<td>
<p>boolean (default TRUE) add weighted mean lines?</p>
</td></tr>
<tr><td><code id="plot_tree_move_+3A_add.labels">add.labels</code></td>
<td>
<p>boolean (default TRUE) add labels?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Barplot with white scores, draws percent and black scores.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "Kasparov.gz", package = "bigchess")
con &lt;- gzfile(f,encoding = "latin1")
df &lt;- read.pgn(con,quiet = TRUE,stat.moves = FALSE)
tr &lt;- tree_move(subset(df,W1=="e4"),"B1")
plot_tree_move(tr,"1. e4 ... ?")
# Plot tree move openings in aggregated data
tr &lt;- tree_move(FirstTwoMoves,"W1")
plot_tree_move(tr,paste0("1. ... ?\n",sum(FirstTwoMoves$Freq)," total games"))
</code></pre>

<hr>
<h2 id='read.pgn'>Reads PGN files into data frame</h2><span id='topic+read.pgn'></span>

<h3>Description</h3>

<p>Reads PGN files into data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.pgn(
  con,
  add.tags = NULL,
  n.moves = T,
  extract.moves = 10,
  last.move = T,
  stat.moves = T,
  big.mode = F,
  quiet = F,
  ignore.other.games = F,
  source.movetext = F
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.pgn_+3A_con">con</code></td>
<td>
<p>connection argument passed directly to readLines() function. String - the name of the file which the data are to be read from or connection object or URL.</p>
</td></tr>
<tr><td><code id="read.pgn_+3A_add.tags">add.tags</code></td>
<td>
<p>string vector containing additional tags to be parsed.
According to Seven Tag Roster rule:
http://www.saremba.de/chessgml/standards/pgn/pgn-complete.htm#c8.1.1
The STR tag pairs appear before any other tag pairs: &quot;Event&quot;, &quot;Site&quot;, &quot;Date&quot;, &quot;Round&quot;, &quot;White&quot;, &quot;Black&quot; and &quot;Result&quot;.
Using this argument you can specify supplemental tag names, such as: Player related information, Event related information, Opening information (locale specific), Opening information (third party vendors), Time and date related information, Time control, Alternative starting positions, Game conclusion and Miscellaneous.
Most popular: &quot;WhiteElo&quot;, &quot;BlackElo&quot;,&quot;ECO&quot;,&quot;SetUp&quot; or &quot;FEN&quot;. Case sensitive.</p>
</td></tr>
<tr><td><code id="read.pgn_+3A_n.moves">n.moves</code></td>
<td>
<p>boolean (default TRUE), compute number of moves?</p>
</td></tr>
<tr><td><code id="read.pgn_+3A_extract.moves">extract.moves</code></td>
<td>
<p>integer (default 10) passed to extract_moves function. Additionaly value -1 will extract all moves from movetext (not recommended for big files). Value 0 means that moves will not be extracted.</p>
</td></tr>
<tr><td><code id="read.pgn_+3A_last.move">last.move</code></td>
<td>
<p>boolean (default TRUE) passed to extract_moves, ignored when extract.moves = 0</p>
</td></tr>
<tr><td><code id="read.pgn_+3A_stat.moves">stat.moves</code></td>
<td>
<p>boolean (default TRUE), compute moves count statistics? Could take a long time for big file.</p>
</td></tr>
<tr><td><code id="read.pgn_+3A_big.mode">big.mode</code></td>
<td>
<p>boolean (default FALSE) used in read.pgn.ff function</p>
</td></tr>
<tr><td><code id="read.pgn_+3A_quiet">quiet</code></td>
<td>
<p>boolean (default FALSE), indicating if messages should appear.</p>
</td></tr>
<tr><td><code id="read.pgn_+3A_ignore.other.games">ignore.other.games</code></td>
<td>
<p>boolean (default FALSE) if TRUE result is subset of original dataset without games with result marked as &quot;*&quot;, i.e. ongoing games</p>
</td></tr>
<tr><td><code id="read.pgn_+3A_source.movetext">source.movetext</code></td>
<td>
<p>boolean (default FALSE, experimental!) if TRUE column with original movetext will be added</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame containg STR, additional tags (conditionally), Movetext, NMoves (conditionally), extracted moves (conditionally) with complete.movetext flag, figure moves count statistics (conditionally).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "2016_Candidates.pgn", package = "bigchess")
df &lt;- read.pgn(f)
# ...successfully imported 56 games...

# Example downloaded from https://www.pgnmentor.com/files.html#players and gzipped:
f &lt;- system.file("extdata", "Carlsen.gz", package = "bigchess")
con &lt;- gzfile(f,encoding = "latin1")
df &lt;- read.pgn(con,quiet = TRUE)
# Fastest mode:
con &lt;- gzfile(f,encoding = "latin1")
df &lt;- read.pgn(con,quiet = TRUE,n.moves = FALSE,extract.moves = FALSE,
stat.moves = FALSE, ignore.other.games = FALSE)
# Parse additional tags and extract all moves:
con &lt;- gzfile(f,encoding = "latin1")
df &lt;- read.pgn(con,add.tags = c("WhiteElo", "BlackElo", "ECO"),extract.moves = -1)
# Example of direct downloading data from chess.com using API:
df &lt;- read.pgn("https://api.chess.com/pub/player/fabianocaruana/games/2013/03/pgn")
# Warning of incomplete line could appear

# Example of scraping all of games given user:
user &lt;- "fabianocaruana"
library("rjson")
json_file &lt;- paste0("https://api.chess.com/pub/player/",user,"/games/archives")
json_data &lt;- fromJSON(paste(readLines(json_file), collapse=""))
result &lt;- data.frame()
for(i in json_data$archives)
result &lt;- rbind(result,read.pgn(paste0(i,"/pgn")))
</code></pre>

<hr>
<h2 id='read.pgn.db'>Reads PGN files into database table</h2><span id='topic+read.pgn.db'></span>

<h3>Description</h3>

<p>Reads PGN files into database table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.pgn.db(con, batch.size = 10^6, conn, table.name = "pgn", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.pgn.db_+3A_con">con</code></td>
<td>
<p>connection argument passed directly to readLines() function. String - the name of the file which the data are to be read from or connection object or URL.</p>
</td></tr>
<tr><td><code id="read.pgn.db_+3A_batch.size">batch.size</code></td>
<td>
<p>number of lines to read in one batch, default is 10^6.</p>
</td></tr>
<tr><td><code id="read.pgn.db_+3A_conn">conn</code></td>
<td>
<p>connection argument created by dbConnect</p>
</td></tr>
<tr><td><code id="read.pgn.db_+3A_table.name">table.name</code></td>
<td>
<p>string (default &quot;pgn&quot;), table name, used in dbWriteTable(conn, table.name, read.pgn(batch))</p>
</td></tr>
<tr><td><code id="read.pgn.db_+3A_...">...</code></td>
<td>
<p>further arguments passed directly to read.pgn() function (besides ignore.other.games and big.mode)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- system.file("extdata", "Carlsen.gz", package = "bigchess")
con &lt;- gzfile(f,"rbt",encoding = "latin1")
require(RSQLite)
conn &lt;- dbConnect(SQLite())
read.pgn.db(con,stat.moves = FALSE,conn = conn)
dbGetQuery(conn, "SELECT COUNT(*) FROM pgn") #2410
dbDisconnect(conn)
# Works with all types of connections (also gz or zip files).
# con argument is passed directly to readLines(con,batch.size)
# so (if total number of lines to read is greater then batch.size)
# depending on platform use it correctly:
# Windows ('rb' opening mode for loop over readLines):
con &lt;- gzfile(system.file("extdata", "Carlsen.gz", package = "bigchess"),"rb",encoding = "latin1")
# con &lt;- file("path_to_big_chess_file.pgn","rb",encoding = "latin1")
read.pgn.db(con,conn = conn)


# Linux/Mac OS X ('r' opening mode for loop over readLines):
con &lt;- gzfile(system.file("extdata", "Carlsen.gz", package = "bigchess"),"r",encoding = "latin1")
# con &lt;- file("path_to_big_chess_file.pgn","r",encoding = "latin1")
read.pgn.db(con,conn = conn)


# Windows (example of zipped file handling)
unzf &lt;- unzip("zipped_pgn_file.zip")
read.pgn.db(con,conn = conn)

</code></pre>

<hr>
<h2 id='read.pgn.ff'>Reads PGN files into ff data frame</h2><span id='topic+read.pgn.ff'></span>

<h3>Description</h3>

<p>Reads PGN files into ff data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.pgn.ff(con, batch.size = 10^6, ignore.other.games = F, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read.pgn.ff_+3A_con">con</code></td>
<td>
<p>connection argument passed directly to readLines() function. String - the name of the file which the data are to be read from or connection object or URL.</p>
</td></tr>
<tr><td><code id="read.pgn.ff_+3A_batch.size">batch.size</code></td>
<td>
<p>number of lines to read in one batch, default is 10^6.</p>
</td></tr>
<tr><td><code id="read.pgn.ff_+3A_ignore.other.games">ignore.other.games</code></td>
<td>
<p>boolean (default FALSE) if TRUE result is subset of original dataset without games with result marked as &quot;*&quot;, i.e. ongoing games. The only one argument which is not passed directly to read.pgn function.</p>
</td></tr>
<tr><td><code id="read.pgn.ff_+3A_...">...</code></td>
<td>
<p>further arguments passed directly to read.pgn() function (besides ignore.other.games and big.mode)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ff data frame like from read.pgn() function. Since character values are not supported in ffdf object, &quot;Movetext&quot; column is ommited.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(ff)
require(ffbase)
f &lt;- system.file("extdata", "Carlsen.gz", package = "bigchess")
con &lt;- gzfile(f,"rbt",encoding = "latin1")
# options("fftempdir"="/path/"...) # if necessarily
fdf &lt;- read.pgn.ff(con,stat.moves = FALSE)
delete(fdf)
# Works with all types of connections (also gz or zip files).
# con argument is passed directly to readLines(con,batch.size)
# so (if total number of lines to read is greater then batch.size)
# depending on platform use it correctly:
# Windows ('rb' opening mode for loop over readLines):
con &lt;- gzfile(system.file("extdata", "Carlsen.gz", package = "bigchess"),"rb",encoding = "latin1")
# con &lt;- file("path_to_big_chess_file.pgn","rb",encoding = "latin1")
fdf &lt;- read.pgn.ff(con)
delete(fdf)

# Linux/Mac OS X ('r' opening mode for loop over readLines):
con &lt;- gzfile(system.file("extdata", "Carlsen.gz", package = "bigchess"),"r",encoding = "latin1")
# con &lt;- file("path_to_big_chess_file.pgn","r",encoding = "latin1")
fdf &lt;- read.pgn.ff(con)
delete(fdf)

# Windows (example of zipped file handling)
unzf &lt;- unzip("zipped_pgn_file.zip")
fdf &lt;- read.pgn.ff(file(unzf,"rb"))
delete(fdf)

</code></pre>

<hr>
<h2 id='san2lan'>Movetext conversion from SAN to LAN</h2><span id='topic+san2lan'></span>

<h3>Description</h3>

<p>Convert SAN movetext (FIDE) to LAN movetext (used by chess engines)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>san2lan(movetext.san)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="san2lan_+3A_movetext.san">movetext.san</code></td>
<td>
<p>movetext string in standard algebraic notation (SAN) required by FIDE, but without comments, variants etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>movetext in long algebraic notation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>san2lan("1. e4 e5 2. Nf3 Nf5 3. d5 ")
</code></pre>

<hr>
<h2 id='stat_moves'>Extract statistics of moves</h2><span id='topic+stat_moves'></span>

<h3>Description</h3>

<p>Extract statistics of moves (counts figure moves) from movetext vector into data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_moves(movetext, sides = "both")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_moves_+3A_movetext">movetext</code></td>
<td>
<p>movetext string (or string vector). The standard English values are required: pawn = &quot;P&quot; (often not used), knight = &quot;N&quot;, bishop = &quot;B&quot;, rook = &quot;R&quot;, queen = &quot;Q&quot;, and king = &quot;K&quot;.</p>
</td></tr>
<tr><td><code id="stat_moves_+3A_sides">sides</code></td>
<td>
<p>&quot;both&quot; (default),&quot;white&quot; or &quot;black&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame containing moves count statistics for white and for black and total.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>stat_moves("1. e4 e5 2. Nf3 Nf5 3. d5 ")
</code></pre>

<hr>
<h2 id='tree_eco'>Compute ECO tree</h2><span id='topic+tree_eco'></span>

<h3>Description</h3>

<p>Compute ECO tree (frequencies and winning percent)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_eco(df, topn = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tree_eco_+3A_df">df</code></td>
<td>
<p>data frame containg ECO and Result columns</p>
</td></tr>
<tr><td><code id="tree_eco_+3A_topn">topn</code></td>
<td>
<p>integer, default 0, indicating how many top openings should be included, 0 means show all openings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame containg White_score (White winning percent), Draws_percent, Black_score and N (number of games). Sorted by power of ECO (White_score * N which describes popularity and score of move) descending.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "Kasparov.gz", package = "bigchess")
con &lt;- gzfile(f,encoding = "latin1")
df &lt;- read.pgn(con,quiet = TRUE,stat.moves = FALSE, add.tags = "ECO")
</code></pre>

<hr>
<h2 id='tree_move'>Compute tree for a given move</h2><span id='topic+tree_move'></span>

<h3>Description</h3>

<p>Compute tree for a given move (frequencies and winning percent)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree_move(df, move)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tree_move_+3A_df">df</code></td>
<td>
<p>data frame containg move and Result column from pgn function or data frame containing aggregated data from such df (containg columns: Result, W1, B1, W2, ..., WN, BN, Freq)</p>
</td></tr>
<tr><td><code id="tree_move_+3A_move">move</code></td>
<td>
<p>character indicating which move should be browsed, example &quot;W1&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame containg White_score (White winning percent), Draws_percent, Black_score and N (number of games). Sorted by power of move (White_score times N which describes popularity and score of move) descending.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "Kasparov.gz", package = "bigchess")
con &lt;- gzfile(f,encoding = "latin1")
df &lt;- read.pgn(con,quiet = TRUE,stat.moves = FALSE)
# Analyze best answers to 1. e4 in Kasparov games (both white and black)
tree_move(subset(df,W1=="e4"),move = "B1")
# Analyze openings in aggregated data
tree_move(FirstTwoMoves,"W1")
</code></pre>

<hr>
<h2 id='uci_cmd'>Sending command to chess engine</h2><span id='topic+uci_cmd'></span>

<h3>Description</h3>

<p>Sending command to chess engine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uci_cmd(engine, command = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uci_cmd_+3A_engine">engine</code></td>
<td>
<p>engine object</p>
</td></tr>
<tr><td><code id="uci_cmd_+3A_command">command</code></td>
<td>
<p>string command</p>
</td></tr>
</table>


<h3>Value</h3>

<p>engine object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Linux (make sure you have executable permission):
engine_path &lt;- "./stockfish_10_x64"
# Windows
# engine_path &lt;- "./stockfish_10_x64.exe"
e &lt;- uci_engine(engine_path)
e &lt;- uci_command(e,"go depth 10")
uci_quit(e)
# Using pipe '%&gt;%' from magrittr:
require(magrittr)
uci_engine(engine_path) %&gt;% uci_command("go depth 10") %&gt;% uci_quit()
</code></pre>

<hr>
<h2 id='uci_debug'>Sending command debug for chess engine</h2><span id='topic+uci_debug'></span>

<h3>Description</h3>

<p>Sending command debug for chess engine. Info about debug command from http://wbec-ridderkerk.nl/html/UCIProtocol.html
switch the debug mode of the engine on and off. In debug mode the engine should sent additional infos to the GUI, e.g. with the &quot;info string&quot; command, to help debugging, e.g. the commands that the engine has received etc. This mode should be switched off by default and this command can be sent any time, also when the engine is thinking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uci_debug(engine, on = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uci_debug_+3A_engine">engine</code></td>
<td>
<p>engine object</p>
</td></tr>
<tr><td><code id="uci_debug_+3A_on">on</code></td>
<td>
<p>boolean default TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>engine object
</p>

<hr>
<h2 id='uci_engine'>Create an engine handler in R</h2><span id='topic+uci_engine'></span>

<h3>Description</h3>

<p>Create an engine handler in R and send command isready
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uci_engine(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uci_engine_+3A_path">path</code></td>
<td>
<p>path to engine file. Make sure you have executable permission on this file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>engine object (list of two: pipe to engine and temp as a result from stdout engine)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Linux (make sure you have executable permission):
engine_path &lt;- "./stockfish_10_x64"
# Windows
# engine_path &lt;- "./stockfish_10_x64.exe"
e &lt;- uci_engine(engine_path)
uci_quit(e)

# Using pipe '%&gt;%' from magrittr:
require(magrittr)
uci_engine(engine_path) %&gt;% uci_quit()
</code></pre>

<hr>
<h2 id='uci_go'>Sending command go for chess engine</h2><span id='topic+uci_go'></span>

<h3>Description</h3>

<p>Sending command go for chess engine. Info about go command from http://wbec-ridderkerk.nl/html/UCIProtocol.html
start calculating on the current position set up with the &quot;position&quot; command. There are a number of commands that can follow this command, all will be sent in the same string. If one command is not send its value should be interpreted as it would not influence the search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uci_go(
  engine,
  depth = NULL,
  infinite = FALSE,
  stoptime = 1,
  wtime = NULL,
  btime = NULL,
  winc = NULL,
  binc = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uci_go_+3A_engine">engine</code></td>
<td>
<p>engine object</p>
</td></tr>
<tr><td><code id="uci_go_+3A_depth">depth</code></td>
<td>
<p>integer depth (search x plies only)</p>
</td></tr>
<tr><td><code id="uci_go_+3A_infinite">infinite</code></td>
<td>
<p>boolean default FALSE. If TRUE, stoptime (next argument) should be defined</p>
</td></tr>
<tr><td><code id="uci_go_+3A_stoptime">stoptime</code></td>
<td>
<p>integer default 1. Used in Sys.sleep after go infinite in egine. After this, uci_stop() is executed</p>
</td></tr>
<tr><td><code id="uci_go_+3A_wtime">wtime</code></td>
<td>
<p>integer default NULL (white has x msec left on the clock)</p>
</td></tr>
<tr><td><code id="uci_go_+3A_btime">btime</code></td>
<td>
<p>integer default NULL (black has x msec left on the clock)</p>
</td></tr>
<tr><td><code id="uci_go_+3A_winc">winc</code></td>
<td>
<p>integer default NULL (white increment per move in mseconds if x &gt; 0)</p>
</td></tr>
<tr><td><code id="uci_go_+3A_binc">binc</code></td>
<td>
<p>integer default NULL (black increment per move in mseconds if x &gt; 0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>engine object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Linux (make sure you have executable permission):
engine_path &lt;- "./stockfish_10_x64"
# Windows
# engine_path &lt;- "./stockfish_10_x64.exe"
e &lt;- uci_engine(engine_path)
e &lt;- uci_go(e,depth = 10)
uci_quit(e)
# Using pipe '%&gt;%' from magrittr:
require(magrittr)
uci_engine(engine_path) %&gt;% uci_go(depth = 10) %&gt;% uci_quit()
# Find best answer for black after 1. e4 in 100 seconds:
uci_engine(engine_path) %&gt;% uci_position(moves = "e2e4") %&gt;%
  uci_go(depth = 20) %&gt;% uci_quit() %&gt;% uci_parse()
# Find best answer for black after 1. e4 in 100 seconds:
uci_engine(engine_path) %&gt;% uci_position(moves = "e2e4") %&gt;%
  uci_go(infinite = TRUE,stoptime = 100) %&gt;% uci_quit() %&gt;% uci_parse()
</code></pre>

<hr>
<h2 id='uci_isready'>Checking if chess engine is ready</h2><span id='topic+uci_isready'></span>

<h3>Description</h3>

<p>Checking if chess engine is ready - sending command isready and parsing GUI until readyok is obtained. Info about isready command from http://wbec-ridderkerk.nl/html/UCIProtocol.html
This is used to synchronize the engine with the GUI. When the GUI has sent a command or multiple commands that can take some time to complete, this command can be used to wait for the engine to be ready again or to ping the engine to find out if it is still alive. E.g. this should be sent after setting the path to the tablebases as this can take some time. This command is also required once before the engine is asked to do any search to wait for the engine to finish initializing. This command must always be answered with &quot;readyok&quot; and can be sent also when the engine is calculating in which case the engine should also immediately answer with &quot;readyok&quot; without stopping the search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uci_isready(engine)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uci_isready_+3A_engine">engine</code></td>
<td>
<p>engine object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>engine object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Linux (make sure you have executable permission):
engine_path &lt;- "./stockfish_10_x64"
# Windows
# engine_path &lt;- "./stockfish_10_x64.exe"
e &lt;- uci_engine(engine_path)
e &lt;- uci_isready(e)
uci_quit(e)
# Using pipe '%&gt;%' from magrittr:
require(magrittr)
uci_engine(engine_path) %&gt;% uci_isready() %&gt;% uci_quit()
</code></pre>

<hr>
<h2 id='uci_parse'>Parse GUI commands from chess engine</h2><span id='topic+uci_parse'></span>

<h3>Description</h3>

<p>Parse GUI commands from chess engine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uci_parse(ucilog, filter = "bestmove")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uci_parse_+3A_ucilog">ucilog</code></td>
<td>
<p>strings from uci_quit() or uci_read()$temp</p>
</td></tr>
<tr><td><code id="uci_parse_+3A_filter">filter</code></td>
<td>
<p>string, one of 'bestmove' (default), 'score' or 'bestline'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>strings with parsed information from engine
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Linux (make sure you have executable permission):
engine_path &lt;- "./stockfish_10_x64"
# Windows
# engine_path &lt;- "./stockfish_10_x64.exe"
require(processx)
e &lt;- uci_engine(engine_path)
e &lt;- uci_go(depth = 10)
rslt &lt;- uci_quit(e)
uci_parse(rslt)
# Using pipe '%&gt;%' from magrittr:
require(magrittr)
uci_engine(engine_path) %&gt;% uci_go(depth = 10) %&gt;% uci_quit() %&gt;% uci_parse()
</code></pre>

<hr>
<h2 id='uci_ponderhit'>Sending command ponderhit for chess engine</h2><span id='topic+uci_ponderhit'></span>

<h3>Description</h3>

<p>Sending command ponderhit for chess engine. Info about ponderhit command from http://wbec-ridderkerk.nl/html/UCIProtocol.html
the user has played the expected move. This will be sent if the engine was told to ponder on the same move the user has played. The engine should continue searching but switch from pondering to normal search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uci_ponderhit(engine)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uci_ponderhit_+3A_engine">engine</code></td>
<td>
<p>engine object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>engine object
</p>

<hr>
<h2 id='uci_position'>Sending command position for chess engine</h2><span id='topic+uci_position'></span>

<h3>Description</h3>

<p>Sending command position for chess engine. Info about position command from http://wbec-ridderkerk.nl/html/UCIProtocol.html
set up the position described in fenstring on the internal board and play the moves on the internal chess board. if the game was played  from the start position the string &quot;startpos&quot; will be sent Note: no &quot;new&quot; command is needed. However, if this position is from a different game than the last position sent to the engine, the GUI should have sent a &quot;ucinewgame&quot; inbetween.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uci_position(engine, moves = NULL, startpos = TRUE, fen = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uci_position_+3A_engine">engine</code></td>
<td>
<p>engine object</p>
</td></tr>
<tr><td><code id="uci_position_+3A_moves">moves</code></td>
<td>
<p>string in long algebraic notation</p>
</td></tr>
<tr><td><code id="uci_position_+3A_startpos">startpos</code></td>
<td>
<p>boolean default TRUE</p>
</td></tr>
<tr><td><code id="uci_position_+3A_fen">fen</code></td>
<td>
<p>string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>engine object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Linux (make sure you have executable permission):
engine_path &lt;- "./stockfish_10_x64"
# Windows
# engine_path &lt;- "./stockfish_10_x64.exe"
e &lt;- uci_engine(engine_path)
e &lt;- uci_position(e,moves = "e2e4")
e &lt;- uci_go(e,depth = 10)
uci_quit(e)
# Using pipe '%&gt;%' from magrittr:
require(magrittr)
uci_engine(engine_path) %&gt;% uci_position(moves = "e2e4") %&gt;%
  uci_go(depth = 10) %&gt;% uci_quit() %&gt;% uci_parse()
</code></pre>

<hr>
<h2 id='uci_quit'>Sending quit command to chess engine</h2><span id='topic+uci_quit'></span>

<h3>Description</h3>

<p>Sending quit command to chess engine and cleaning temps from R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uci_quit(engine)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uci_quit_+3A_engine">engine</code></td>
<td>
<p>engine object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>strings from uci chess engine GUI
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Linux (make sure you have executable permission):
engine_path &lt;- "./stockfish_10_x64"
# Windows
# engine_path &lt;- "./stockfish_10_x64.exe"
e &lt;- uci_engine(engine_path)
uci_quit(e)
# Using pipe '%&gt;%' from magrittr:
require(magrittr)
uci_engine(engine_path) %&gt;% uci_quit()
</code></pre>

<hr>
<h2 id='uci_read'>Read current stdout from chess engine</h2><span id='topic+uci_read'></span>

<h3>Description</h3>

<p>Read current stdout from chess engine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uci_read(engine)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uci_read_+3A_engine">engine</code></td>
<td>
<p>engine object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>engine object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Linux (make sure you have executable permission):
engine_path &lt;- "./stockfish_10_x64"
# Windows
# engine_path &lt;- "./stockfish_10_x64.exe"
e &lt;- uci_engine(engine_path)
e &lt;- uci_read(e)
e$temp
uci_quit(e)
</code></pre>

<hr>
<h2 id='uci_register'>Sending command register for chess engine</h2><span id='topic+uci_register'></span>

<h3>Description</h3>

<p>Sending command register for chess engine. Info about register command from http://wbec-ridderkerk.nl/html/UCIProtocol.html
this is the command to try to register an engine or to tell the engine that registration will be done later. This command should always be sent if the engine	has send &quot;registration error&quot; at program startup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uci_register(engine, later = TRUE, name = NULL, code = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uci_register_+3A_engine">engine</code></td>
<td>
<p>engine object</p>
</td></tr>
<tr><td><code id="uci_register_+3A_later">later</code></td>
<td>
<p>boolean default TRUE</p>
</td></tr>
<tr><td><code id="uci_register_+3A_name">name</code></td>
<td>
<p>string</p>
</td></tr>
<tr><td><code id="uci_register_+3A_code">code</code></td>
<td>
<p>string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>engine object
</p>

<hr>
<h2 id='uci_setoption'>Sending command setoption for chess engine</h2><span id='topic+uci_setoption'></span>

<h3>Description</h3>

<p>Sending command setoption for chess engine. Info about setoption command from http://wbec-ridderkerk.nl/html/UCIProtocol.html
this is sent to the engine when the user wants to change the internal parameters of the engine. For the &quot;button&quot; type no value is needed. One string will be sent for each parameter and this will only be sent when the engine is waiting. The name of the option in  should not be case sensitive and can inludes spaces like also the value. The substrings &quot;value&quot; and &quot;name&quot; should be avoided in  and  to allow unambiguous parsing, for example do not use  = &quot;draw value&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uci_setoption(engine, name = NULL, value = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uci_setoption_+3A_engine">engine</code></td>
<td>
<p>engine object</p>
</td></tr>
<tr><td><code id="uci_setoption_+3A_name">name</code></td>
<td>
<p>string option name</p>
</td></tr>
<tr><td><code id="uci_setoption_+3A_value">value</code></td>
<td>
<p>string option value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>engine object
</p>

<hr>
<h2 id='uci_stop'>Sending command stop for chess engine</h2><span id='topic+uci_stop'></span>

<h3>Description</h3>

<p>Sending command stop for chess engine. Info about stop command from http://wbec-ridderkerk.nl/html/UCIProtocol.html
stop calculating as soon as possible, don't forget the &quot;bestmove&quot; and possibly the &quot;ponder&quot; token when finishing the search
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uci_stop(engine)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uci_stop_+3A_engine">engine</code></td>
<td>
<p>engine object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>engine object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Linux (make sure you have executable permission):
engine_path &lt;- "./stockfish_10_x64"
# Windows
# engine_path &lt;- "./stockfish_10_x64.exe"
e &lt;- uci_engine(engine_path)
e &lt;- uci_go(depth = 100)
Sys.sleep(1)
e &lt;- uci_stop(e)
uci_quit(e)
</code></pre>

<hr>
<h2 id='uci_uci'>Sending command uci for chess engine</h2><span id='topic+uci_uci'></span>

<h3>Description</h3>

<p>Sending command uci for chess engine. Info about uci command from http://wbec-ridderkerk.nl/html/UCIProtocol.html
tell engine to use the uci (universal chess interface), this will be send once as a first command after program boot to tell the engine to switch to uci mode. After receiving the uci command the engine must identify itself with the &quot;id&quot; command and sent the &quot;option&quot; commands to tell the GUI which engine settings the engine supports if any. After that the engine should sent &quot;uciok&quot; to acknowledge the uci mode. If no uciok is sent within a certain time period, the engine task will be killed by the GUI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uci_uci(engine)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uci_uci_+3A_engine">engine</code></td>
<td>
<p>engine object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>engine object
</p>

<hr>
<h2 id='uci_ucinewgame'>Sending command ucinewgame for chess engine</h2><span id='topic+uci_ucinewgame'></span>

<h3>Description</h3>

<p>Sending command ucinewgame for chess engine. Info about ucinewgame command from http://wbec-ridderkerk.nl/html/UCIProtocol.html
this is sent to the engine when the next search (started with &quot;position&quot; and &quot;go&quot;) will be from a different game. This can be a new game the engine should play or a new game it should analyse but also the next position from a testsuite with positions only. If the GUI hasn't sent a &quot;ucinewgame&quot; before the first &quot;position&quot; command, the engine shouldn't expect any further ucinewgame commands as the GUI is probably not supporting the ucinewgame command. So the engine should not rely on this command even though all new GUIs should support it. As the engine's reaction to &quot;ucinewgame&quot; can take some time the GUI should always send &quot;isready&quot; after &quot;ucinewgame&quot; to wait for the engine to finish its operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uci_ucinewgame(engine)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uci_ucinewgame_+3A_engine">engine</code></td>
<td>
<p>engine object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>engine object
</p>

<hr>
<h2 id='write.pgn'>Write PGN data.frames into file</h2><span id='topic+write.pgn'></span>

<h3>Description</h3>

<p>Write PGN data.frames into file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.pgn(df, file, add.tags = NULL, append = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="write.pgn_+3A_df">df</code></td>
<td>
<p>data.frame from read.pgn()</p>
</td></tr>
<tr><td><code id="write.pgn_+3A_file">file</code></td>
<td>
<p>string path to destination file</p>
</td></tr>
<tr><td><code id="write.pgn_+3A_add.tags">add.tags</code></td>
<td>
<p>string vector containing additional tags to be parsed.
According to Seven Tag Roster rule:
http://www.saremba.de/chessgml/standards/pgn/pgn-complete.htm#c8.1.1
The STR tag pairs appear before any other tag pairs: &quot;Event&quot;, &quot;Site&quot;, &quot;Date&quot;, &quot;Round&quot;, &quot;White&quot;, &quot;Black&quot; and &quot;Result&quot;.
Using this argument you can specify supplemental tag names, such as: Player related information, Event related information, Opening information (locale specific), Opening information (third party vendors), Time and date related information, Time control, Alternative starting positions, Game conclusion and Miscellaneous.
Most popular: &quot;WhiteElo&quot;, &quot;BlackElo&quot;,&quot;ECO&quot;,&quot;SetUp&quot; or &quot;FEN&quot;. Case sensitive.</p>
</td></tr>
<tr><td><code id="write.pgn_+3A_append">append</code></td>
<td>
<p>boolean (default FALSE), should games be appended to current file?</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- system.file("extdata", "2016_Candidates.pgn", package = "bigchess")
df &lt;- read.pgn(f)
write.pgn(df, file = "my_file.pgn")
df2 &lt;- read.pgn("my_file.pgn")
all.equal(df,df2) # TRUE
unlink("my_file.pgn") # clean up
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
