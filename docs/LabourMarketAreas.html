<!DOCTYPE html><html lang="en"><head><title>Help for package LabourMarketAreas</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LabourMarketAreas}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#LabourMarketAreas-package'>
<p>LabourMarketAreas</p></a></li>
<li><a href='#AddStatistics'><p>AddStatistics</p></a></li>
<li><a href='#AssignLmaName'>
<p>AssignLmaName</p></a></li>
<li><a href='#AssignSingleComToSingleLma'>
<p>AssignSingleComToSingleLma</p></a></li>
<li><a href='#BindPiecesLma'>
<p>BindPiecesLma</p></a></li>
<li><a href='#Brindisi'>
<p>Brindisi</p></a></li>
<li><a href='#CompareLMAsStat'>
<p>CompareLMAsStat</p></a></li>
<li><a href='#copyClusterData'>
<p>copyClusterData</p></a></li>
<li><a href='#CreateClusterData'>
<p>CreateClusterData</p></a></li>
<li><a href='#CreateLMAshape'>
<p>CreateLMAshape</p></a></li>
<li><a href='#DeleteLmaName'>
<p>DeleteLmaName</p></a></li>
<li><a href='#determineCohesion'>
<p>determineCohesion</p></a></li>
<li><a href='#determineRegroupList'>
<p>determineRegroupList</p></a></li>
<li><a href='#dissolveCluster'>
<p>dissolveCluster</p></a></li>
<li><a href='#dissolveClusterSel'>
<p>dissolveClusterSel</p></a></li>
<li><a href='#EqualLmaPartition'>
<p>EqualLmaPartition</p></a></li>
<li><a href='#findClusters'>
<p>findClusters</p></a></li>
<li><a href='#FindContig'>
<p>FindContig</p></a></li>
<li><a href='#FindIsolated'>
<p>FindIsolated</p></a></li>
<li><a href='#FineTuning'>
<p>FineTuning</p></a></li>
<li><a href='#getLeastSelfContained'>
<p>getLeastSelfContained</p></a></li>
<li><a href='#iso'>
<p>iso</p></a></li>
<li><a href='#LmaSpatialComparison'>
<p>LmaSpatialComparison</p></a></li>
<li><a href='#LMAwrite'>
<p>LMAwrite</p></a></li>
<li><a href='#mergeCluster'>
<p>mergeCluster</p></a></li>
<li><a href='#names.Brindisi'>
<p>names.Brindisi</p></a></li>
<li><a href='#names.Sardinia'>
<p>names.Sardinia</p></a></li>
<li><a href='#PlotLmaCommunity'>
<p>PlotLmaCommunity</p></a></li>
<li><a href='#Qmodularity'>
<p>Qmodularity</p></a></li>
<li><a href='#regroupDissolved'>
<p>regroupDissolved</p></a></li>
<li><a href='#regroupDissolved.ncom'>
<p>regroupDissolved.ncom</p></a></li>
<li><a href='#Sardinia'>
<p>Sardinia</p></a></li>
<li><a href='#SardiniaGrid'>
<p>SardiniaGrid</p></a></li>
<li><a href='#shpBrindisi'>
<p>shpBrindisi</p></a></li>
<li><a href='#shpSardinia'><p>shpSardinia</p>
</p></a></li>
<li><a href='#StatClusterData'>
<p>StatClusterData</p></a></li>
<li><a href='#StatReserveList'>
<p>StatReserveList</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Identification, Tuning, Visualisation and Analysis of Labour
Market Areas</td>
</tr>
<tr>
<td>Version:</td>
<td>3.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-09</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniela Ichim, Luisa Franconi, Michele D'Alo', Guido van den Heuvel</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luisa Franconi &lt;franconi@istat.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Produces Labour Market Areas from commuting flows available at elementary territorial units. It provides tools for automatic tuning based on spatial contiguity. It also allows for statistical analyses and visualisation of the new functional geography.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0), sp, sf</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, spdep, methods, tmap</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-09 19:28:46 UTC; brunero</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-10 10:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='LabourMarketAreas-package'>
LabourMarketAreas
</h2><span id='topic+LabourMarketAreas-package'></span><span id='topic+LabourMarketAreas'></span>

<h3>Description</h3>

<p>Makes Travel-To-Work-Areas from commuting flow data by means of the version of the TTWA algorithm by Coombes and Bond (2008) according to the implementation carried out at Istat (Franconi, D'Alo' and Ichim, 2016) within a Europan framework of Labour Market Area development (Franconi, Ichim and D'Alo'  2017). The whole process of Labour Market Areas development has been taken care of (regionalisation algorithm, creation of shape file, assignment of names, fine tuning of the output of the algorithm, quality assessment and sensitivity analysis.).
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> LabourMarketAreas</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 3.4</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-10-09</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Labour market areas (LMAs) are sub-regional geographical areas where the bulk of the labour force lives and works, and where establishments can find the main part of the labour force necessary to occupy the offered jobs. They are functional regions that stem from the aggregation of elementary
geographical units (municipalities, census output areas, etc.) on the basis of
their level of spatial interaction measured by commuting to work 
flows through quantitative methods. The guiding idea is to maximise the flow inside  the area (internal cohesion) and minimise it outside (external separation) according to a predefined rule.
</p>
<p>The package is based on original script by Guido van den Heuvel at Statistics Netherlands and further developed at the Italian National Statistical Institute (Istat) to implement the algorithm described in Coombes and Bond (2008) - a variation of the seminal paper by Coombes et al. (1986). See Franconi, D'Alo'and Ichim (2016) for the full description of this implementation and Franconi, Ichim and D'Alo' (2017) for an overview of project. 
</p>
<p>The algorithm is a rule based algorithm that stops when all areas satisfy the rule.
</p>
<p>Every area is characterised by the number of commuters living in it, by the number of commuters that go there to work (called number of jobs/workers) and by those commuters that live and work in the same area. The ratios between these quantities define the concept of self-containment. We are interested in the minimum self-containment i.e. the minimum between the Supply side self-containment and the Demand side self-containment (see Coombes and Bond, 2008). According to Coombes and Bond (2008) an area is a Labour Market Area (LMA) if it satisfies the validity condition (see Coombes and Bond, 2008). Such validity depends on the number of commuters living in the area, the minimum self-containment and four parameters chosen by the user (see function findcluster).
</p>
<p>The package produces LMAs for the country/region for which commuting flows are available at basic territorial level (municipality, province, census output areas, etc.). We call this basic territorial level community. If the names of the communities are provided, the package allows to assign names to each LMA (see function AssignLmaName). The package allows also to plot a cartographic map of the produced LMAs given the shape files of the communities (see function PlotLmaCommunity). 
Finally the package identifies enclaves (communities that are not contiguous with the rest of the LMA they belong to) and perform a re-assignment of such community based on contiguity and cohesion (see the function FineTuning). 
</p>
<p>The main output of the function findClusters is the set of LMAs produced by the algorithm, the so called a partition. There are three dimensions that characterise the partition: the dimension of the starting configuration i.e. number of communities in the country/region of interest, the dimension of the final configuration, i.e. the number of LMAs identified by the algorithm using the chosen parameters, and the flows between LMAs. 
These three dimensions need to be represented in the solution of the algorithm; this is done through a list of three data.table the lma (or clusterData) data structure. Such lma data structure is the cornerstone of the whole package as it is the input or the output of many functions inside the package. 
</p>
<p>The work was partially funded by Eurostat Grant &quot;EU-TTWA method: improvements, documentation and 
sharing knowledge activities&quot; awarded to Istat the Italian National Statistical Institute 
(http://www.istat.it/en/archive/182743). This is part of a system of grants in the EU with the aim of supporting the ongoing development of a methodology for the creation of LMA and test the application of methods nationally in the participating National Statistical Institutes. The goal is to arrive at a harmonised EU-wide definition for labour market areas. More info at: 
</p>
<p>https://ec.europa.eu/eurostat/cros/content/labour-market-areas_en
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo', Guido van den Heuvel
</p>
<p>Maintainer: Luisa Franconi &lt;franconi at istat.it&gt;
</p>


<h3>References</h3>

<p>[1] Coombes, M. e Bond, S. (2008). Travel-to-Work Areas: the 2007 review. London: Office for National Statistics, 2008. 
</p>
<p>https://ons.maps.arcgis.com/home/item.html?id=5efb4f1c1a114fef8f74f6f0347c10e8
</p>
<p>[2] Coombes, M., Casado-Diaz, J.M., Martinez-Bernabeu, L. e Carausu, F. (2012). Study on comparable labour market areas: final research report. 17 October 2012. Eurostat- Framework contract no:6001. 2008.001 - 2009.065, Specific contract no:50405.2010.004 - 2011.325.
</p>
<p>[3] Coombes, M.G., Green, A.E. e Openshow, S. (1986). An efficient algorithm to generate official statistics report areas: the case of the 1984 Travel-to-Work Areas in Britain. The Journal of Operational Research Society, Vol. 37, No. 10, pp. 943-953.
</p>
<p>[4] Franconi, L., D'Alo', M. and Ichim, D. (2016). Istat Implementation of the  algorithm to develop Labour Market Areas. Available at 
</p>
<p>http://www.istat.it/en/files/2016/03/Description-of-the-LabourMarketAreas-algorithm.pdf.
</p>
<p>[5] Franconi, L., Ichim, D. and D'Alo', M. (2017). Labour Market Areas for territorial policies:
tools for a European approach. Statistical Journal of the IAOS,
Vol. 33, No. 3, pp. 585-591. 
</p>
<p>https://content.iospress.com/articles/statistical-journal-of-the-iaos/sji160343
</p>
<p>[6] Istat (2015). La nuova Geografia dei Sistemi Locali. (in italian). Available at 
</p>
<p>http://www.istat.it/it/files/2015/10/La-nuova-geografia-dei-sistemi-locali.pdf
</p>

<hr>
<h2 id='AddStatistics'>AddStatistics
</h2><span id='topic+AddStatistics'></span>

<h3>Description</h3>

<p>Function to evaluate statistics at LMA level based on data at community level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddStatistics(statData, comID.file, lma, comID.lma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AddStatistics_+3A_statdata">statData</code></td>
<td>

<p>data.frame or data.table containing the ID of the communities and the numerical variables to be summed at LMA level.
</p>
</td></tr>
<tr><td><code id="AddStatistics_+3A_comid.file">comID.file</code></td>
<td>

<p>character: name of the variable containing the community ID in the statData object.
</p>
</td></tr>
<tr><td><code id="AddStatistics_+3A_lma">lma</code></td>
<td>

<p>list of three data.tables: clusterList, LWClus and marginals. See function findClusters.
</p>
</td></tr>
<tr><td><code id="AddStatistics_+3A_comid.lma">comID.lma</code></td>
<td>

<p>character: name of the variable containing the community ID in the lma object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used in general to compute several statistics at LMA level provided data at community level is provided. This function sums the values at community level to obtain the corresponding value at LMA level.
</p>


<h3>Value</h3>

<p>data.table containing the LMA ID and the summed numerical variables from statData. 
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compute population totals at LMA level from population values at community level.
## Not run: 
out&lt;- findClusters(LWCom=Brindisi, minSZ=1000,minSC=0.6667,tarSZ=10000,tarSC=0.75, 
verbose=TRUE)
AddStatistics(shpBrindisi[,c("PRO_COM","POP2001")], "PRO_COM",out$lma,"community" )

## End(Not run)
</code></pre>

<hr>
<h2 id='AssignLmaName'>
AssignLmaName
</h2><span id='topic+AssignLmaName'></span>

<h3>Description</h3>

<p>Given the names of the original communities (elementary area or municipality) as input, this function assigns the name to each labour market area given its code. The assigned LMA name corresponds to the name of the community having the highest number of jobs (incoming commuters) among all the communities in the corresponding LMA. If more than one community shares the maximum number of jobs, the first one is taken. In order to differ the community name by the LMA with the same name, the community is expressed as  first letter in uppercase and the remaining letters in lowercase, whereas the LMA name is all in uppercase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AssignLmaName(LWCom,lma,ComNames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AssignLmaName_+3A_lwcom">LWCom</code></td>
<td>

<p>data frame/data.table of commuting data (see for example Sardinia).
</p>
</td></tr>
<tr><td><code id="AssignLmaName_+3A_lma">lma</code></td>
<td>

<p>list of three data tables. It is the output of the function findClusters. It contains the three data.tables clusterList, LWClus, marginals.
</p>
</td></tr>
<tr><td><code id="AssignLmaName_+3A_comnames">ComNames</code></td>
<td>

<p>data frame/data.table containing two variables: code, integer representing the id of the community and com.name, character containing the community name.  The code must be positive.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>lma</code></td>
<td>

<p>list of three data.tables. It contains the three data.table clusterList, LWClus, marginals with the new added columns related to the names of the communities and their corresponding labour market areas. The added columns are character type. In clusterList the new variables are com.name, lma.name, in LWCom the variables are  lma.name.live, lma.name.work  and in marginals the new added variable is lma.name.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo'
</p>


<h3>See Also</h3>

<p>findClusters
</p>

<hr>
<h2 id='AssignSingleComToSingleLma'>
AssignSingleComToSingleLma
</h2><span id='topic+AssignSingleComToSingleLma'></span>

<h3>Description</h3>

<p>This function assigns a community to a given labour market area. It simulates a manual assignment. It might be used inside the fine tuning process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AssignSingleComToSingleLma(lma,comID,lmaID,dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AssignSingleComToSingleLma_+3A_lma">lma</code></td>
<td>

<p>The partition to be modified. A list of three components named:  clusterList, LWClus and marginals, respectively. See the output of the findClusters function.
</p>
</td></tr>
<tr><td><code id="AssignSingleComToSingleLma_+3A_comid">comID</code></td>
<td>

<p>The identifier of the community to be assigned.
</p>
</td></tr>
<tr><td><code id="AssignSingleComToSingleLma_+3A_lmaid">lmaID</code></td>
<td>

<p>The identifier of the  labour market area where comID has to be assigned.
</p>
</td></tr>
<tr><td><code id="AssignSingleComToSingleLma_+3A_dat">dat</code></td>
<td>

<p>The initial commuting matrix between communities. A data.table containing the variables community_live, community_work and amount.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new labour market partition. A list of three components named:
</p>
<table role = "presentation">
<tr><td><code>clusterList</code></td>
<td>
<p>A data.table with three variables: community, cluster, residents</p>
</td></tr>
<tr><td><code>LWClus</code></td>
<td>
<p>A data.table with three variables: cluster_live, cluster_work, amount</p>
</td></tr>
<tr><td><code>marginals</code></td>
<td>
<p>A data.table with three variables: cluster, amount_live, amount_work</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function can be called before the call to the function AssignLmaName.
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi
</p>


<h3>See Also</h3>

<p>findClusters
</p>

<hr>
<h2 id='BindPiecesLma'>
BindPiecesLma
</h2><span id='topic+BindPiecesLma'></span>

<h3>Description</h3>

<p>This function (row) binds two local labour market areas structures. It deletes the communities that are registered twice (or more) in both structures. It deletes the communities that are not registered in the input flows data frame/data.frame. LMA Ids that are registered in both structures are deleted as well.
</p>
<p>In case there are common LMA ids, those of input2 are summed to the maximum LMA id of input1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BindPiecesLma(input1,input2,LWCom)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BindPiecesLma_+3A_input1">input1</code></td>
<td>

<p>list of three data.table: clusterList, LWClus and marginals. See function findClusters.
</p>
</td></tr>
<tr><td><code id="BindPiecesLma_+3A_input2">input2</code></td>
<td>

<p>list of three data.table: clusterList, LWClus and marginals. See function findClusters.
</p>
</td></tr>
<tr><td><code id="BindPiecesLma_+3A_lwcom">LWCom</code></td>
<td>

<p>data frame/data.table containing the commuting flows information. Three variables: community_live, community_work and amount. See function findClusters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of five components.
</p>
<table role = "presentation">
<tr><td><code>com.twice.1</code></td>
<td>
<p> numeric vector; communities ids that are registered twice (or more) in the first input data structure</p>
</td></tr>
<tr><td><code>com.twice.2</code></td>
<td>
<p> numeric vector; communities ids that are registered twice (or more) in the second input data structure</p>
</td></tr>
<tr><td><code>coms.not.in.flows</code></td>
<td>
<p> numeric vector; communities ids that are registered in either input data structures, but not in the commuting flows data.table</p>
</td></tr>
<tr><td><code>LMAtwice</code></td>
<td>
<p> numeric vector; LMA ids that are registered in both input data structures. These LMAs are not included in the new structure.</p>
</td></tr>
<tr><td><code>lma</code></td>
<td>
<p> a list of three data.tables: clusterList, LWClus and marginals. Information on commuters, residents and workers is computed using the input commuting flows data frame/data.table.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi
</p>


<h3>See Also</h3>

<p>findClusters
</p>

<hr>
<h2 id='Brindisi'>
Brindisi
</h2><span id='topic+Brindisi'></span>

<h3>Description</h3>

<p>data frame/data.table containing the commuting flows between municipalities in Brindisi province from Italian Population Census (the complete data set http://www.istat.it/it/archivio/157423).  Each row corresponds to an observation i.e. a flow and each column corresponds to a variable.  The variables are: community_live, community work and amount, in this order.  The meaning of the variables is the following: community_live, integer, id number of the community (elementary territorial unit) where the commuter/commuters live, community_work, integer, containing the id number of the community (elementary territorial unit) where the commuter/commuters work and amount, numeric containing the number of commuter/commuters commuting between community_live and community_work (direction is important). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Brindisi)
</code></pre>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo'
</p>

<hr>
<h2 id='CompareLMAsStat'>
CompareLMAsStat
</h2><span id='topic+CompareLMAsStat'></span>

<h3>Description</h3>

<p>This function computes several statistics to be used for comparing partitions, e.g. for parameter selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CompareLMAsStat(list.lma,dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CompareLMAsStat_+3A_list.lma">list.lma</code></td>
<td>

<p>list of LMAs to be compared. Each component of the list is a list of at least two components: lma and param (see the output of the function findCluster). The lma component is a list of three data.tables: clusterList, LWClus and marginals (the names should have not been assigned; otherwise use function DeleteLmaName). The param is a numeric vector containing the parameters of the corresponding LMAs, i.e. minSZ, minSC, tarSZ, tarSC.
</p>
</td></tr>
<tr><td><code id="CompareLMAsStat_+3A_dat">dat</code></td>
<td>
<p>data frame/data.table with the original commuting flows between communities. It contains three columns: community_live, community_work and amount.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the quality statistics computed by the StatClusterData function.
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo'
</p>


<h3>See Also</h3>

<p>findClusters, StatClusterData
</p>

<hr>
<h2 id='copyClusterData'>
copyClusterData
</h2><span id='topic+copyClusterData'></span>

<h3>Description</h3>

<p>This function copies (in data.table parlance) the three components of lma, i.e. clusterList, LWClus and marginals. See function findClusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copyClusterData(lma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="copyClusterData_+3A_lma">lma</code></td>
<td>

<p>list of three data.tables: clusterList, LWClus and marginals. See function findClusters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of three. It contains the three data tables clusterList, LWClus, marginals. They are copies of the input data.tables.
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi
</p>


<h3>See Also</h3>

<p>findClusters
</p>

<hr>
<h2 id='CreateClusterData'>
CreateClusterData
</h2><span id='topic+CreateClusterData'></span>

<h3>Description</h3>

<p>This function creates a labour market areas structure, i.e. a list of three data.tables: clusterList, LWClus and marginals given a set of commuting data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateClusterData(LWCom,residents=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateClusterData_+3A_lwcom">LWCom</code></td>
<td>

<p>input data frame/data.table of commuting data (see for example Sardinia).
</p>
</td></tr>
<tr><td><code id="CreateClusterData_+3A_residents">residents</code></td>
<td>

<p>A data.table with two columns: Code and residents. Code is the community Id while residents represents the amount of occupied persons living in the community. If NULL, the residents data.table is computed using the commuting flows dataset. The missing values are not allowed: communities with no residents present zero values.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If needed, the fictitious community (see Franconi, D'Alo' and Ichim, 2016 for definition and details) should be a-priori included in both residents and commuting flows datasets.
</p>


<h3>Value</h3>

<p>A list of three components:
</p>
<table role = "presentation">
<tr><td><code>clusterList:</code></td>
<td>
<p>data.table with three variables: community, cluster and residents. Each community is assigned to a cluster. The clusters ID is a numerical sequential vector, generated independently on the community IDs values.</p>
</td></tr>
<tr><td><code>LWClus:</code></td>
<td>
<p>a data.table representing the commuting flows between clusters. The three variables are cluster_live, cluster_work and amount</p>
</td></tr>
<tr><td><code>marginals:</code></td>
<td>
<p>a data.table representing the cluster characteristics. The three variables are cluster, amount_live (residents) and amount_work (workers).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo'
</p>


<h3>References</h3>

<p>[1] Franconi, L., D'Alo', M. and Ichim, D. (2016). Istat Implementation of the  algorithm to develop Labour Market Areas. Available at 
</p>
<p><a href="http://www.istat.it/en/files/2016/03/Description-of-the-LabourMarketAreas-algorithm.pdf">http://www.istat.it/en/files/2016/03/Description-of-the-LabourMarketAreas-algorithm.pdf</a>.
</p>


<h3>See Also</h3>

<p>findClusters
</p>

<hr>
<h2 id='CreateLMAshape'>
CreateLMAshape
</h2><span id='topic+CreateLMAshape'></span>

<h3>Description</h3>

<p>Starting from the communities shape files, the function creates the shape files of labour market areas. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CreateLMAshape(lma,comIDs,lmaIDs,shp_com,dsn,shp_com_name,id_shp_com,outd,outf,bf,po)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CreateLMAshape_+3A_lma">lma</code></td>
<td>

<p>List (three data.tables) containing all defining information of the LMAs. See the output of the function findClusters. The names of the clusters have been assigned, see AssignLmaName function.
</p>
</td></tr>
<tr><td><code id="CreateLMAshape_+3A_comids">comIDs</code></td>
<td>

<p>Name of the variable containing the community identifier in the lma input.
</p>
</td></tr>
<tr><td><code id="CreateLMAshape_+3A_lmaids">lmaIDs</code></td>
<td>

<p>Name of the variable containing the labour market areas identifier in the lma input.
</p>
</td></tr>
<tr><td><code id="CreateLMAshape_+3A_shp_com">shp_com</code></td>
<td>

<p>Object of class sf containing the shape file of the communities. Defaults to NULL. In case both shp_com and shp_com_name are provided, only the first one is considered.
</p>
</td></tr>
<tr><td><code id="CreateLMAshape_+3A_dsn">dsn</code></td>
<td>

<p>character; data source name specifying the directory (path) in which the shp_com_name file is stored. 
</p>
</td></tr>
<tr><td><code id="CreateLMAshape_+3A_shp_com_name">shp_com_name</code></td>
<td>

<p>character; the file name of the communities shape file. Defaults to NULL. In case both shp_com and shp_com_name are provided, only the first one is considered.
</p>
</td></tr>
<tr><td><code id="CreateLMAshape_+3A_id_shp_com">id_shp_com</code></td>
<td>

<p>character; name of the variable containing the communities identifier in the shp_com object or in the shp_com_name file. 
</p>
</td></tr>
<tr><td><code id="CreateLMAshape_+3A_outd">outd</code></td>
<td>

<p>character. The path where to save the shape files. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="CreateLMAshape_+3A_outf">outf</code></td>
<td>

<p>character. The file name where to save the shape files. Defaults to NULL. If it is provided, the outdir should be provided, too.
</p>
</td></tr>
<tr><td><code id="CreateLMAshape_+3A_bf">bf</code></td>
<td>

<p>character. The bmpfile file name (including the path) of the bitmap file where to save the cartographic map of the communities and labour market areas together.  Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="CreateLMAshape_+3A_po">po</code></td>
<td>

<p>Graphical parameters (plot_opt) to be used when bmpfile is not NULL. The parameters are: background colour of the map, line width of the lma borders, line type of the lma borders, lma names color, line width for the lma names, line type for the lma names, cex factor for the lma names, font for the lma names. Defaults to c(&quot;green&quot;, 1, 2, &quot;red&quot;, 1, 2, 0.8, 2).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three components:
</p>
<table role = "presentation">
<tr><td><code>shp_lma</code></td>
<td>
<p>object of class sf containing the shape file of lma</p>
</td></tr>
<tr><td><code>comID.in.LMA.not.in.SHP</code></td>
<td>
<p>vector of communities registered in lma but not in the input shape object/file.</p>
</td></tr>
<tr><td><code>comID.in.SHP.not.in.LMA</code></td>
<td>
<p>vector of communities registered in the input shape object/file but not in the lma.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function has to be applied on a labour market partition whose names are assigned. 
Note that some communities present in the shape files may not be available in the lma structure. These missing communities can be found in the zero.list and ComNotAssigned. They could also be structurally missing i.e. could not be present in the initial commuting data.
Note also that if the option of providing an output file is activated then the usage of an existing file name in the selected outdir will generate an error.
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi
</p>


<h3>See Also</h3>

<p>findClusters, AssignLmaName
</p>

<hr>
<h2 id='DeleteLmaName'>
DeleteLmaName
</h2><span id='topic+DeleteLmaName'></span>

<h3>Description</h3>

<p>This function deletes the variables corresponding to names of communities and clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeleteLmaName(lma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DeleteLmaName_+3A_lma">lma</code></td>
<td>

<p>list of three data.tables: clusterList, LWClus and marginals. See function findClusters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of three. It contains the three data.tables clusterList, LWClus, marginals. From clusterList the deleted variables are com.name, lma.name, from LWCom the deleted variables are lma.name.live, lma.name.work  and from marginals the deleted variable is lma.name.
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo'
</p>


<h3>See Also</h3>

<p>findClusters
</p>

<hr>
<h2 id='determineCohesion'>
determineCohesion
</h2><span id='topic+determineCohesion'></span>

<h3>Description</h3>

<p>Computes the cohesion matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determineCohesion(LWClus, marginals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="determineCohesion_+3A_lwclus">LWClus</code></td>
<td>

<p>data table containing the flows between the clusters.
</p>
</td></tr>
<tr><td><code id="determineCohesion_+3A_marginals">marginals</code></td>
<td>

<p>data table containing the main characteristics of the current set of clusters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The cohesion matrix between clusters.
</p>


<h3>Note</h3>

<p>This function is called and used internally by the main function findClusters
through the function determineRegroupList. 
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo', Guido van den Heuvel
</p>


<h3>References</h3>

<p>[1] Coombes, M.G., Green, A.E. and Openshow, S. (1986). An efficient algorithm to generate official statistics report areas: the case of the 1984 Travel-to-Work Areas in Britain. The Journal of Operational Research Society, Vol. 37, No. 10, pp. 943-953.
</p>
<p>[2] Franconi, L., D'Alo' M. and Ichim, D. (2016). Istat implementation of the  algorithm to develop Labour Market Areas.
</p>


<h3>See Also</h3>

<p>determineRegroupList
</p>

<hr>
<h2 id='determineRegroupList'>
determineRegroupList
</h2><span id='topic+determineRegroupList'></span>

<h3>Description</h3>

<p>This function determines, for each cluster in LWClus, the cluster with which that cluster is most closely associated. First the cohesion between all pairs of clusters is calculated; then the cohesion is sorted for each cluster and only the last (i.e., highest) one is selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determineRegroupList(LWClus, marginals)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="determineRegroupList_+3A_lwclus">LWClus</code></td>
<td>

<p>data table containing the flows between the clusters.
</p>
</td></tr>
<tr><td><code id="determineRegroupList_+3A_marginals">marginals</code></td>
<td>

<p>data table containing the main characteristics of the cluster.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function determines, for each pair of cluster in LWClus,  the cohesion; then it is sorted and only the last (i.e., highest) one is selected. The highest value it associated with the dominant cluster for the dissolved cluster.
</p>


<h3>Value</h3>

<p>Integer: the candidate cluster identifier.
</p>


<h3>Note</h3>

<p>This function is called and used internally by the main function findClusters. 
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo', Guido van den Heuvel
</p>


<h3>References</h3>

<p>[1] Franconi, L., D'Alo' M. and Ichim, D. (2016). Istat implementation of the  algorithm to develop Labour Market Areas.
</p>


<h3>See Also</h3>

<p>findClusters
</p>

<hr>
<h2 id='dissolveCluster'>
dissolveCluster
</h2><span id='topic+dissolveCluster'></span>

<h3>Description</h3>

<p>This function dissolves a selected cluster into its constituent communities. Such communities are given temporary cluster IDs. 
Then clusterList is updated with the temporary IDs and the number of commuters (LWClus) and the cluster structure (marginals) are recomputed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissolveCluster(clusterData, cluster, LWCom)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dissolveCluster_+3A_clusterdata">clusterData</code></td>
<td>

<p>list of 3 data.tables defining all the elements of the current set of clusters.
</p>
</td></tr>
<tr><td><code id="dissolveCluster_+3A_cluster">cluster</code></td>
<td>

<p>integer: id of the selected cluster to be dissolved into its constituent communities.
</p>
</td></tr>
<tr><td><code id="dissolveCluster_+3A_lwcom">LWCom</code></td>
<td>

<p>data frame/data.table containing the commuting data. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>clusterData</code></td>
<td>

<p>list of 3 data tables defining all the elements of the current set of clusters. The ID includes negative values corresponding to the dissolved cluster.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is called and used internally by the main function findClusters. 
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo, Guido van den Heuvel
</p>


<h3>References</h3>

<p>[1] Franconi, L., D'Alo' M. and Ichim, D. (2016). Istat implementation of the  algorithm to develop Labour Market Areas.
</p>


<h3>See Also</h3>

<p>findClusters
</p>

<hr>
<h2 id='dissolveClusterSel'>
dissolveClusterSel
</h2><span id='topic+dissolveClusterSel'></span>

<h3>Description</h3>

<p>This function dissolves a selected cluster into its constituent communities. Such communities are given temporary cluster IDs. 
Then clusterList is updated with the temporary IDs and the number of commuters (LWClus) and the cluster structure (marginals) are recomputed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dissolveClusterSel(clusterData, cluster, lwcom)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dissolveClusterSel_+3A_clusterdata">clusterData</code></td>
<td>

<p>list of 3 data.tables defining all the elements of the current set of clusters.
</p>
</td></tr>
<tr><td><code id="dissolveClusterSel_+3A_cluster">cluster</code></td>
<td>

<p>integer: id of the selected cluster to be dissolved into its constituent communities.
</p>
</td></tr>
<tr><td><code id="dissolveClusterSel_+3A_lwcom">lwcom</code></td>
<td>

<p>data frame/data.table containing the selected commuting data. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>clusterData</code></td>
<td>

<p>list of 3 data tables defining all the elements of the current set of clusters. The ID includes negative values corresponding to the dissolved cluster.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is called and used internally by the main function findClusters. 
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo, Guido van den Heuvel
</p>


<h3>References</h3>

<p>[1] Franconi, L., D'Alo' M. and Ichim, D. (2016). Istat implementation of the  algorithm to develop Labour Market Areas.
</p>


<h3>See Also</h3>

<p>findClusters
</p>

<hr>
<h2 id='EqualLmaPartition'>
EqualLmaPartition
</h2><span id='topic+EqualLmaPartition'></span>

<h3>Description</h3>

<p>This function tests whether two partitions are equal. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EqualLmaPartition(lma1, lma2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="EqualLmaPartition_+3A_lma1">lma1</code></td>
<td>

<p>List (three components) containing all defining information of the partition. The clusterList component should contain variables community and LMA. See findClusters function.
</p>
</td></tr>
<tr><td><code id="EqualLmaPartition_+3A_lma2">lma2</code></td>
<td>

<p>List (three components) containing all defining information of the partition to be compared with the previous one.The clusterList component should contain variables community and LMA.See findClusters function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical value.
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi</p>


<h3>See Also</h3>

<p>findClusters
</p>

<hr>
<h2 id='findClusters'>
findClusters
</h2><span id='topic+findClusters'></span>

<h3>Description</h3>

<p>This function builds labour market areas (LMAs) starting from commuting data between communities i.e. elementary territorial units (municipalities, census output areas, provinces, etc.). The function implements the algorithm described in Coombes and Bond (2008) according to the implementation detailed in Franconi, D'Alo' and Ichim (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findClusters(LWCom, minSZ, minSC, tarSZ, tarSC, 
verbose = F, sink.output = NULL,trace=NULL,
PartialClusterData=NULL, idcom_type=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findClusters_+3A_lwcom">LWCom</code></td>
<td>

<p>data frame/data.table containing the commuting data. Each row corresponds to an observation i.e. a flow and each column corresponds to a variable. The variables are named: &quot;community_live&quot;, integer contains the id number of the elementary zone of residence, &quot;community_work&quot;, integer, contains the id number of the working community (elementary zone of work), &quot;amount&quot;, integer/numeric contains the number of commuters commuting between the &quot;community_live&quot; and the &quot;community_work&quot; (direction is important). Missing values (NAs) are not allowed. The community id must be positive. Only positive flows are present in the data frame. See Sardinia.   
</p>
</td></tr>
<tr><td><code id="findClusters_+3A_minsz">minSZ</code></td>
<td>

<p>integer specifying the parameter containing the acceptable minimum size of an area in terms of occupied persons. Must be positive.
</p>
</td></tr>
<tr><td><code id="findClusters_+3A_minsc">minSC</code></td>
<td>

<p>numeric in the interval (0,1) specifying the parameter representing the acceptable minimum self-containment of an area. Usually values range from 0.6 to 0.7.
</p>
</td></tr>
<tr><td><code id="findClusters_+3A_tarsz">tarSZ</code></td>
<td>

<p>integer specifying the parameter containing the target size of an area in terms of occupied persons. It must be greater than minSZ. 
</p>
</td></tr>
<tr><td><code id="findClusters_+3A_tarsc">tarSC</code></td>
<td>

<p>numeric in the interval (0,1) specifying the parameter representing the target self containment of an area. It must be greater than minSZ. Usually values range 0.75 to 0.9. 
</p>
</td></tr>
<tr><td><code id="findClusters_+3A_verbose">verbose</code></td>
<td>

<p>logical. If TRUE the iteration number and the minimum validity are printed on the screen together with warning messages. Default is FALSE.
</p>
</td></tr>
<tr><td><code id="findClusters_+3A_sink.output">sink.output</code></td>
<td>

<p>character string containing the name of the .txt file that will contain optional information for each iteration of the algorithm. Default is NULL i.e. the sink function is not activated. 
</p>
</td></tr>
<tr><td><code id="findClusters_+3A_trace">trace</code></td>
<td>
<p>integer. If not NULL (default value) and if the number of (internal) iterations is multiple of it, an intermediate output is saved in the file intermclusterData.Rdata in the current working directory. The intermediate output is a list of two elements: a clusterData object and the vector of parameters.</p>
</td></tr>
<tr><td><code id="findClusters_+3A_partialclusterdata">PartialClusterData</code></td>
<td>
<p>labour market areas structure (clusterData) representing the starting point of the iterative algorithm.
</p>
<p>The labour market areas structure is a list of three components: clusterList (whose variables are: community, cluster and residents), LWClus (variables: cluster_live, cluster_work and amount) and marginals (variables: cluster, 
amount_live and amount_work). Defaults to NULL. 
</p>
<p>If it is not NULL, the information related to the process used to derive this structure is not registered in the output of the function). </p>
</td></tr>
<tr><td><code id="findClusters_+3A_idcom_type">idcom_type</code></td>
<td>
<p>character. If not NULL (default value) the identification code of the community is a character and not an integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of the function is a list of lists with components:
</p>
<table role = "presentation">
<tr><td><code>lma</code></td>
<td>

<p>List of three data.tables: it contains all the information on the partitioning of the initial communities stemming from the input data frame LWCom into a set of labour market areas. Each data frame contains a dimension of the partition: the initial list of communities (municipalities or elementary areas), the relationships between the labour market areas and their structural characteristics. 
</p>
<p>The three data.tables are:
</p>
<p><b>clusterList</b>: data.table containing the allocation of each community to the corresponing Labour Market Areas (LMA). It  includes three variables: <em>community</em>, integer containing the id of the community, <em>cluster</em>, integer containing the id of the labour market areas, and <em>residents</em>, integer/numeric containing the number of commuters who are residents in the corresponding community. 
</p>
<p><b>LWClus</b>: data.table containing the flows between the LMA. It includes three variables:  <em>cluster_live</em>, integer representing the id number of the labour market area of residence, <em>cluster_work</em>, integer representing the id number of the labour market area of work and <em>amount</em>, numeric representing the number of employee commuting from cluster_live to cluster_work (the direction is important).
</p>
<p><b>marginals</b>: data.table containing the main characteristics of the labour market areas. The variables representing such characteristics are: 
<em>cluster</em>, integer containing the id number of the labour market area, <em>amount_live</em> numeric, number of employees who are residents in the LMA (i.e. who live in the LMA), <em>amount_work</em> numeric, number of employees working in LMA regardless of where they live (this variable is also known as workers or jobs). 
</p>
</td></tr>
<tr><td><code>lma.before0</code></td>
<td>
<p>List with the same structure as lma (above) containing the result of the algorithm before the assignment of the communities belonging to the reserve list to the dominating labour market areas (if it exists). The reserve list is the LMA with id=0. The communities belonging to it can be investigated through the data.table clusterList. </p>
</td></tr> 
<tr><td><code>reserve.list</code></td>
<td>
<p>List of lists. Communities that do not improve the value of the validity when assigned to the dominating cluster or that do not have a dominating cluster are put into the reserve list. Each list contains a character string with information on:
</p>
<p>the type reason for being assigned to the reserve list; possible values are: &quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;. Please refer to Franconi, D'Alo' and Ichim (2016) for details on the description of such cases.
</p>
<p>the iteration in which the community was assigned to the reserve list;
</p>
<p>the id of the dissolved cluster i.e. the cluster to which the community belonged before being assigned to the reserve list;
</p>
<p>the value of the validity of such cluster (in character format); 
</p>
<p>the id of the community assigned to the reserve list;
</p>
<p>the community belonging to the cluster being dissolved with the second lowest 
external relationships value see Franconi, D'Alo' and Ichim (2016) (if available otherwise NULL). </p>
</td></tr> 
<tr><td><code>comNotAssigned</code></td>
<td>
<p>List. Component: integer containing the id of the community in the reserve list that the algorithm was not able to assign to any existing cluster. NULL otherwise. </p>
</td></tr> 
<tr><td><code>zero.list</code></td>
<td>
<p>List of four objects: they contain information on communities (elementary areas or municipalities) that could not be processed by the algorithm for various reasons; either the number of commuters resident in it is 0 or the number of workers/jobs is 0 or the community has no interaction with any other community. In such cases the algorithm eliminates these communities from the initial list and let the user the choice to allocate them at a later stage (see function AssignSingleComToSingleLma).
</p>
<p>Communities: integer containing the ids of the communities that could not be processed by the algorithm. 
</p>
<p>LWCom: data.table containing the flows involving the above communities. The data.table is in a sense a subset of the initial data.table containing the commuting data. Its variables are community_live, integer containing the id of the community where the commuters live, community_work, integer containing the id of the community where the commuters work, amount, numeric, containing the number of commuters commuting from community_live to community_work. 
</p>
<p>Residents, data frame containing the variables Code, integer representing the id of the community and residents, integer representing the number of employees who are resident in the community. 
</p>
<p>Workers, data frame containing the variables Code, integer representing the id of the community and workers, integer/numeric representing the number of commuters working in the community (jobs).
</p>
</td></tr> 
<tr><td><code>communitiesMovements</code></td>
<td>
<p>data.table with two columns: <em>community</em>  and <em>moves</em>. 
</p>
<p><em>community</em>: integer. It  represents the community ID;
</p>
<p><em>moves</em>: integer. It represents the number of times a community has changed cluster. The movement toward the reserve list is not computed.</p>
</td></tr>
<tr><td><code>param</code></td>
<td>
<p>vector containing the parameters used to apply the algorithm, i.e. minSZ, minSC, tarSZ, tarSC.</p>
</td></tr>
<tr><td><code>idcom_rel</code></td>
<td>
<p>data.table containing the list of original id community (character) and their corresponding numerical labels created and used inside the algorithm.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that everytime that the idcom_type is not NULL in all the output of the function the community identifier will be character and not integer. In anycase in the sink file and in the PartialClusterData component the community identifier will still be integer and not character.
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo', Guido van den Heuvel
</p>


<h3>References</h3>

<p>[1] Franconi, L., D'Alo' M. and Ichim, D. (2016). Istat implementation of the  algorithm to develop Labour Market Areas.
</p>


<h3>See Also</h3>

<p>LMAwrite
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
out&lt;- findClusters(LWCom=Brindisi, minSZ=1000,minSC=0.6667,tarSZ=10000,tarSC=0.75, 
verbose=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='FindContig'>
FindContig
</h2><span id='topic+FindContig'></span>

<h3>Description</h3>

<p>Given a territorial object (either an LMA, formed by a single community, or a polygon) the function determines its contiguous labour market areas.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindContig(type = "poly", lma, contig.matrix, isolated)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindContig_+3A_type">type</code></td>
<td>

<p>Character indicating which type of objects should be treated. It may be &quot;poly&quot; (polygons) or &quot;lma&quot; (local labour market areas). Defaults to &quot;poly&quot;.
</p>
</td></tr>
<tr><td><code id="FindContig_+3A_lma">lma</code></td>
<td>

<p>A list of three components clusterList, LWClus, marginals. See the function FindClusters.
</p>
</td></tr>
<tr><td><code id="FindContig_+3A_contig.matrix">contig.matrix</code></td>
<td>

<p>matrix: the (spatial) contiguity matrix to be used (see the function FindIsolated).
</p>
</td></tr>
<tr><td><code id="FindContig_+3A_isolated">isolated</code></td>
<td>

<p>Information on the isolated objects. If type is &quot;poly&quot;, isolated is the association matrix between communities and polygons. See the poly.com.linkage component in the output of FindIsolated function. If type is &quot;lma&quot;, isolated is the vector of labour market areas identifiers. See the lma.unique component in the output of the FindIsolated function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If type=&quot;poly&quot;, the output is a list of two components:
</p>
<table role = "presentation">
<tr><td><code>list.contig.poly</code></td>
<td>
<p>list containing the IDs of the contiguous labour market areas of each community (polygon). The list names are the communities identifiers.</p>
</td></tr>
<tr><td><code>com_no.LMA.neigh</code></td>
<td>
<p>character. The names of the communities having only polygons as neighbours.</p>
</td></tr>
</table>
<p>If type=&quot;lma&quot;, the output is a list containing the IDs of the contiguous labour market areas of each given lma. The list names are the communities identifiers. This option should be used for the labour market areas with a unique community.
</p>


<h3>Note</h3>

<p>This function should be used to identify the neighbours of the labour market areas having an unique community (type=&quot;lma&quot;) or to identify the labour market areas which are contiguous to a polygon associated to a unique community (the case of a community having an enclave outside its own territory).
</p>
<p>If type=&quot;poly&quot;, there is no special ordering of the contiguous LMAs.
</p>
<p>If type=&quot;lma&quot;, the contiguous LMAs are ordered in decreasing order of commuters who are resident in the LMA.
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi
</p>


<h3>See Also</h3>

<p>findClusters, FindIsolated</p>

<hr>
<h2 id='FindIsolated'>
FindIsolated
</h2><span id='topic+FindIsolated'></span>

<h3>Description</h3>

<p>A labour market area is defined as isolated when there are no (spatial) neighbours or there is a unique community inside it. A polygon is defined as isolated  when there are no (spatial) neighbours (e.g. a small island which is part of a community in the main land is isolated). 
This function identifies the isolated labour market areas and their isolated  polygons.  The contiguity between two objects (labour market areas or polygons) is based on spatial relationships, not on their commuting flows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindIsolated(lma,lma_shp=NULL,lma_shp_path,
lma_shp_name,com_shp=NULL,com_shp_path,
com_shp_name, id_com)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FindIsolated_+3A_lma">lma</code></td>
<td>

<p>List (three components) containing all defining information on the labour market areas. See findClusters function. The names of the lma have already been assigned (see AssignLmaName).
</p>
</td></tr>
<tr><td><code id="FindIsolated_+3A_lma_shp">lma_shp</code></td>
<td>

<p>object of class sf corresponding to  the labour market areas. See function CreateLmaShape. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="FindIsolated_+3A_lma_shp_path">lma_shp_path</code></td>
<td>

<p>character. The path where the shape files of the labour market areas are saved. See function CreateLmaShape. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="FindIsolated_+3A_lma_shp_name">lma_shp_name</code></td>
<td>

<p>character. The file name where the shape files of the labour market areas are saved. See function CreateLmaShape. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="FindIsolated_+3A_com_shp">com_shp</code></td>
<td>

<p>object of class sf corresponding to the communities. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="FindIsolated_+3A_com_shp_path">com_shp_path</code></td>
<td>

<p>character. The path where the shape files of the communities are saved. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="FindIsolated_+3A_com_shp_name">com_shp_name</code></td>
<td>

<p>character. The file name where the shape files of the communities are saved. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="FindIsolated_+3A_id_com">id_com</code></td>
<td>

<p>character. The field name of the variable containing the community ID in the communities object of class sf.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two components.
</p>
<table role = "presentation">
<tr><td><code>isolated.lma</code></td>
<td>
<p> A list of three components: contig.matrix.lma, lma.unique and lma.nolink.
</p>
</td></tr>
</table>
<p>contig.matrix.lma: matrix. The contiguity matrix of the given labour market areas.
</p>
<p>lma.unique: data.table. It has two columns: lma.unique.ID and lma.unique.name. lma.unique.ID: integer, the identifier of the unique labour market areas.
lma.unique.name: character, name of the unique labour market area. The unique areas are the areas with a unique community.
</p>
<p>lma.nolink data.table with two columns: lma.nolink.ID and lma.nolink.name. lma.nolink.ID integer, the identifier of the labour market area with no links. lma.nolink.name: character, the name of the labour market area with no links.
</p>
<table role = "presentation">
<tr><td><code>isolated.poly</code></td>
<td>
<p>A list of three components: contig.matrix.poly, poly.com.linkage and poly.nolink.
</p>
</td></tr>
</table>
<p>contig.matrix.poly: matrix. It is the contiguity matrix of the polygons.
</p>
<p>poly.com.linkage data.table with two columns, community and Polygon. It represents the association between communities and polygons.
</p>
<p>poly.nolink: data.table with two colums: poly.nolink.ID and poly.nolink.name. poly.nolink.ID integer: the identifiers of the  no-linked polygons.
poly.nolink.name character: the name of the labour market area with no-linked polygons.
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi
</p>


<h3>See Also</h3>

<p>findClusters, CreateLmaShape
</p>

<hr>
<h2 id='FineTuning'>
FineTuning
</h2><span id='topic+FineTuning'></span>

<h3>Description</h3>

<p>This function assigns enclaves (i.e.communities - or part of them - that are not contiguous to the rest of the LMA they belong to) to labour market areas, based on contiguity principle and the cohesion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FineTuning(dat, out.ini, list.contiguity)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="FineTuning_+3A_dat">dat</code></td>
<td>

<p>The commuting flows between communities. See function findCluster.
</p>
</td></tr>
<tr><td><code id="FineTuning_+3A_out.ini">out.ini</code></td>
<td>

<p>A list of three components: clusterList, LWClus and marginals. See function findClusters. The names should not have been assigned. Use function DeleteLmaName.
</p>
</td></tr>
<tr><td><code id="FineTuning_+3A_list.contiguity">list.contiguity</code></td>
<td>

<p>list. Each component of the list is a vector indicating the neighbouring labour market areas. The names of the list are the communities IDs. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm (function findCluster) assigns communities to clusters based on a rule. There is no check that communities in clusters are contiguous. For this reason a fine tuning of the initial result is needed (the function FineTuning).
There is no ordering of the neighbours.
</p>


<h3>Value</h3>

<p>A list of two components: 
</p>
<table role = "presentation">
<tr><td><code>tunned.lma</code></td>
<td>
<p> list of three components clusterList, LWClus and marginals containing the result of the fine tuning procedure. See function findClusters</p>
</td></tr>
<tr><td><code>not.tunned.commID</code></td>
<td>
<p> a vector of communities IDs that were not assigned based on a contiguity principle; e.g. those communities having no flows with their neighbours.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi
</p>

<hr>
<h2 id='getLeastSelfContained'>
getLeastSelfContained
</h2><span id='topic+getLeastSelfContained'></span>

<h3>Description</h3>

<p>This function determines the validity for all clusters as well as the minimum value i.e. the value for which the &quot;X-equation&quot; is minimal (see [1] and [2]).
This minimum corresponds to the selected cluster to be dissolved. 
If more than one cluster share the same minimum value the first will be chosen.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getLeastSelfContained(LWClus, marginals, minSZ, minSC, tarSZ, tarSC)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getLeastSelfContained_+3A_lwclus">LWClus</code></td>
<td>

<p>data table containing the flows between the clusters.
</p>
</td></tr>
<tr><td><code id="getLeastSelfContained_+3A_marginals">marginals</code></td>
<td>

<p>data table containing the structural characteristics of the clusters.
</p>
</td></tr>
<tr><td><code id="getLeastSelfContained_+3A_minsz">minSZ</code></td>
<td>

<p>numeric, parameter indicating the minimum size of the cluster in order to be an acceptable LMA.
</p>
</td></tr>
<tr><td><code id="getLeastSelfContained_+3A_minsc">minSC</code></td>
<td>

<p>numeric, parameter indicating the minimum self containment of the cluster in order to be an acceptable LMA.
</p>
</td></tr>
<tr><td><code id="getLeastSelfContained_+3A_tarsz">tarSZ</code></td>
<td>

<p>numeric, parameter indicating the target size of the clusters.  
</p>
</td></tr>
<tr><td><code id="getLeastSelfContained_+3A_tarsc">tarSC</code></td>
<td>

<p>numeric, parameter indicating the target self containment of the clusters.  
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> A list of two components:
</p>
<table role = "presentation">
<tr><td><code>minivalout</code></td>
<td>
<p>data.table containing the identifier of cluster attaining the minimum validity and its corresponding value.</p>
</td></tr>
<tr><td><code>LWSelf</code></td>
<td>
<p>data.table containing the validity computations for each cluster.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is called and used internally by the main function findClusters. 
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo', Guido van den Heuvel
</p>


<h3>References</h3>

<p>[1] Coombes, M. e Bond, S. (2008). Travel-to-Work Areas: the 2007 review. London: Office for National Statistics, 2008. 
</p>
<p>[2] Franconi, L., D'Alo' M. and Ichim, D. (2016). Istat implementation of the  algorithm to develop Labour Market Areas.
</p>


<h3>See Also</h3>

<p>findClusters
</p>

<hr>
<h2 id='iso'>
iso
</h2><span id='topic+iso'></span>

<h3>Description</h3>

<p>a list used to build vignette
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iso
</code></pre>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi
</p>

<hr>
<h2 id='LmaSpatialComparison'>
LmaSpatialComparison
</h2><span id='topic+LmaSpatialComparison'></span>

<h3>Description</h3>

<p>This function takes as input the shapefiles of two distinct sets of LMAs (on the same territory) and produces statistics to compare them.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LmaSpatialComparison(shape,shape_ref,lma.id="LMA")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LmaSpatialComparison_+3A_shape">shape</code></td>
<td>

<p>Shapefile of the output of an LMA delineation process (sf object).
</p>
</td></tr>
<tr><td><code id="LmaSpatialComparison_+3A_shape_ref">shape_ref</code></td>
<td>

<p>Shapefile of the output of an LMA delineation process (sf object).
</p>
</td></tr>
<tr><td><code id="LmaSpatialComparison_+3A_lma.id">lma.id</code></td>
<td>

<p>Column name of the column registering the LMA (the same in both shape files).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output is a data.table with statistics on the comparison of the two shapefiles.
</p>
<p>Each row represents an association between an LMA in the
shape partition (first argument) and an unique LMA in the shape_ref
partition (second argument).
</p>
<p>The output columns are as follows:
</p>
<table role = "presentation">
<tr><td><code>shape_lma</code></td>
<td>
<p>ID of the LMA unit in the shape partition (first argument)</p>
</td></tr>
<tr><td><code>shape_ref_lma</code></td>
<td>
<p>ID of the LMA unita in the shape_ref partition (second argument)</p>
</td></tr>
<tr><td><code>area_intersection</code></td>
<td>
<p>area of the intersection of the two LMA units</p>
</td></tr>
<tr><td><code>shape_area</code></td>
<td>
<p>area of the LMA unit in the shape partition (first argument)</p>
</td></tr>
<tr><td><code>shape_ref_area</code></td>
<td>
<p>area of the associated LMA unit is the shape_ref partition (second argument)</p>
</td></tr>       
<tr><td><code>shape_EMP_live</code></td>
<td>
<p>number of employees living in the LMA unit is the shape partition</p>
</td></tr>
<tr><td><code>shape_EMP_work</code></td>
<td>
<p>number of employees working in the LMA unit in the shape partition</p>
</td></tr> <tr><td><code>shape_ref_EMP_live</code></td>
<td>
<p>number of employees living in the LMA unit is the shape_ref partition</p>
</td></tr>
<tr><td><code>shape_ref_EMP_work</code></td>
<td>
<p>number of employees working in the LMA unit in the shape_ref partition</p>
</td></tr>     
<tr><td><code>perc_intersection_shape</code></td>
<td>
<p>percentage of the intersection area over the area of the LMA unit in the shape partition</p>
</td></tr>
<tr><td><code>perc_intersection_shape_ref</code></td>
<td>
<p>percentage of the intersection area over the area of the LMA unit in the shape_ref partition</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi 
</p>


<h3>See Also</h3>

<p>findClusters, CreateLmaShape
</p>

<hr>
<h2 id='LMAwrite'>
LMAwrite
</h2><span id='topic+LMAwrite'></span>

<h3>Description</h3>

<p>This function saves the lists composing the output of the lma package into separate data frames as .RData. The files are saved in the path_wd directory. The main output - the first and second list containing, respectively, the characteristics of the created labour market areas and the characteristics of the areas before the assignment of the reserve list - are also saved in a .csv file. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LMAwrite(out, path_wd = NULL, suff = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LMAwrite_+3A_out">out</code></td>
<td>

<p>list of lists containing the output of the lma package.
</p>
</td></tr>
<tr><td><code id="LMAwrite_+3A_path_wd">path_wd</code></td>
<td>

<p>character containing the path of the directory where the output ought to be saved. Default is NULL, working directory.
</p>
</td></tr>
<tr><td><code id="LMAwrite_+3A_suff">suff</code></td>
<td>

<p>character containing the suffix to be added to the name of the saved output files. Default is NULL.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function has to be applied on a labour market partition whose names are not assigned otherwise it
will generate an error.
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo', Guido van den Heuvel
</p>

<hr>
<h2 id='mergeCluster'>
mergeCluster
</h2><span id='topic+mergeCluster'></span>

<h3>Description</h3>

<p>This function updates clusterData by merging cluster1 and cluster2. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeCluster(clusterData, cluster1, cluster2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mergeCluster_+3A_clusterdata">clusterData</code></td>
<td>

<p>List (three components) containing all defining information on the current clusters found by the algorithm.
</p>
</td></tr>
<tr><td><code id="mergeCluster_+3A_cluster1">cluster1</code></td>
<td>

<p>Cluster ID to be merged. An unique positive integer.
</p>
</td></tr>
<tr><td><code id="mergeCluster_+3A_cluster2">cluster2</code></td>
<td>

<p>cluster ID to be merged. An unique positive integer.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A cluster data object, i.e. a list of three components: 
</p>
<table role = "presentation">
<tr><td><code>ClusterList</code></td>
<td>
<p>data.table of three columns: community, cluster, residents</p>
</td></tr>
<tr><td><code>LWClus</code></td>
<td>
<p>data.table of three columns; cluster_live, cluster_work and amount</p>
</td></tr>
<tr><td><code>marginals</code></td>
<td>
<p>data.table of three columns: cluster, amount_live, amount_work</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is called and used internally by the main function findClusters. 
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo', Guido van den Heuvel
</p>


<h3>See Also</h3>

<p>findClusters
</p>

<hr>
<h2 id='names.Brindisi'>
names.Brindisi
</h2><span id='topic+names.Brindisi'></span>

<h3>Description</h3>

<p>data frame/data.table; it contains Code, integer representing the id of the community (elementary area or municipality) and com.name, character, containing the community name. The Code must be positive. In order to differ the community name by the lma with the same name, the community is expressed as  first letter in uppercase and the remaining letters in lowercase, whereas the lma name is all in uppercase.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(names.Brindisi)
</code></pre>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo'
</p>

<hr>
<h2 id='names.Sardinia'>
names.Sardinia
</h2><span id='topic+names.Sardinia'></span>

<h3>Description</h3>

<p>data frame/data.table; it contains Code, integer representing the id of the community (elementary area or municipality) and com.name, character, containing the community name. The Code must be positive. In order to differ the community name by the lma with the same name, the community is expressed as  first letter in uppercase and the remaining letters in lowercase, whereas the lma name is all in uppercase.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(names.Sardinia)
</code></pre>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo'
</p>

<hr>
<h2 id='PlotLmaCommunity'>
PlotLmaCommunity
</h2><span id='topic+PlotLmaCommunity'></span>

<h3>Description</h3>

<p>This function visualizes/plots the LMAs containing given communities.
</p>
<p>It may be used to compare two partitions or to see the assignment of a set of communities during the iterations of the algorithm (object intermClusterData when trace is not NULL in the findClusters function). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotLmaCommunity(list.lma, lmaIDs, communityID, shp_com, id_shp,
bmpfile, col.vec)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotLmaCommunity_+3A_list.lma">list.lma</code></td>
<td>

<p>List of two labour market areas structures (lma). The two components of the list are lists with components clusterList, LWClus and marginals representing the two different partitions to be compared. The names of the communities and LMAs have already been assigned before running this function; See functions findClusters and AssignLmaName.
</p>
<p>If the list has length greater than 2, only the first two partitions will be compared.
</p>
</td></tr>
<tr><td><code id="PlotLmaCommunity_+3A_lmaids">lmaIDs</code></td>
<td>

<p>The name of the variable identifying the LMA in list.lma.
</p>
</td></tr>
<tr><td><code id="PlotLmaCommunity_+3A_communityid">communityID</code></td>
<td>

<p>Positive integer vector, the IDs of the communities under study.
</p>
</td></tr>
<tr><td><code id="PlotLmaCommunity_+3A_shp_com">shp_com</code></td>
<td>

<p>object of class sf containing the shape files of the communities.
</p>
</td></tr>
<tr><td><code id="PlotLmaCommunity_+3A_id_shp">id_shp</code></td>
<td>

<p>The name of the variable identifying the communities in shp_com object of class sf.
</p>
</td></tr>
<tr><td><code id="PlotLmaCommunity_+3A_bmpfile">bmpfile</code></td>
<td>

<p>character: the name of the bmp file where to save the images complete with its path.
</p>
</td></tr>
<tr><td><code id="PlotLmaCommunity_+3A_col.vec">col.vec</code></td>
<td>

<p>character vector of three color names. The first one corresponds to the communities under investigation; the second color corresponds to the communities which are present in the first partition, but not in the second one; the third color corresponds to the communities which are present in the second partition, but not in the first one. Defaults to c(&quot;red&quot;,&quot;orange&quot;,&quot;yellow&quot;).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical  indicating whether the communities belong to the same clusters. The identity is checked using the cluster ID.
</p>
<p>The graphic is saved in the specified path/file.
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi
</p>


<h3>See Also</h3>

<p>findClusters, AssignLmaName
</p>

<hr>
<h2 id='Qmodularity'>
Qmodularity
</h2><span id='topic+Qmodularity'></span>

<h3>Description</h3>

<p>This function computes the Q-modularity index for a given partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qmodularity(lma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qmodularity_+3A_lma">lma</code></td>
<td>

<p>list of three data.frames: clusterList, LWClus and marginals. See function findClusters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value, the Q-modularity index for the given partition.
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo'
</p>


<h3>References</h3>

<p>[1] Y. Liu, Q. Liu, and Z. Qin, &quot;Community Detecting and Feature
Analysis in Real Directed Weighted Social Networks&quot;,  Journal of Networks, vol. 8, no. 6, pp. 1432-1439, Jun. 2013.
</p>


<h3>See Also</h3>

<p>findClusters
</p>

<hr>
<h2 id='regroupDissolved'>
regroupDissolved
</h2><span id='topic+regroupDissolved'></span>

<h3>Description</h3>

<p>This function is used within the core function when the selected cluster to be dissolved has only one municipality. The call, inside this function, to the two functions determineRegroupList and determineCohesion allows to identify the new cluster to which the municipality is temporarily assigned. The output of the function is different whether the new cluster is a proper one or it is the reserve list (i.e. it does not exist a cluster to whom it can be assigned). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regroupDissolved(clusterData)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regroupDissolved_+3A_clusterdata">clusterData</code></td>
<td>

<p>List (three components) containing all defining information on the current clusters found by the algorithm.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is called and used internally by the main function findClusters. 
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo', Guido van den Heuvel
</p>


<h3>See Also</h3>

<p>findClusters
</p>

<hr>
<h2 id='regroupDissolved.ncom'>
regroupDissolved.ncom
</h2><span id='topic+regroupDissolved.ncom'></span>

<h3>Description</h3>

<p>This function is used within the core function findcluster when the selected cluster to be dissolved has more than one municipality. The function identifies the new cluster to which the selected municipality is temporarily assigned. The output of the function is different whether the new cluster is a proper one or it is the reserve list (i.e. it does not exist a cluster to whom it can be assigned).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regroupDissolved.ncom(clusterData, index.com.2diss)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="regroupDissolved.ncom_+3A_clusterdata">clusterData</code></td>
<td>

<p>List (three components) containing all defining information on the current clusters found by the algorithm. 
</p>
</td></tr>
<tr><td><code id="regroupDissolved.ncom_+3A_index.com.2diss">index.com.2diss</code></td>
<td>

<p>integer containing the identifier of the community inside the dissolved cluster that will be assigned to a different cluster.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is called and used internally by the main function findClusters. 
</p>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo', Guido van den Heuvel
</p>


<h3>See Also</h3>

<p>findClusters
</p>

<hr>
<h2 id='Sardinia'>
Sardinia
</h2><span id='topic+Sardinia'></span>

<h3>Description</h3>

<p>data frame/data.table containing the commuting flows between municipalities in Sardinia Island (Italy) from 2001 Italian Population Census (the complete data set http://www.istat.it/it/archivio/157423).  Each row corresponds to an observation i.e. a flow and each column corresponds to a variable.  The variables are: community_live, community work and amount, in this order.  The meaning of the variables is the following: community_live, integer, id number of the community (elementary territorial unit) where the commuter/commuters live, community_work, integer, containing the id number of the community (elementary territorial unit) where the commuter/commuters work and amount, numeric containing the number of commuter/commuters commuting between community_live and community_work (direction is important). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Sardinia)
#Encoding(names.Sardinia$com.name)="latin1" # to deal with a specific accent.
</code></pre>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo'
</p>

<hr>
<h2 id='SardiniaGrid'>
SardiniaGrid
</h2><span id='topic+SardiniaGrid'></span>

<h3>Description</h3>

<p>data frame/data.table containing the commuting flows between grid cells in the Sardinia region; 
from Italian Population Census 2011.  
Each row corresponds to an observation i.e. a flow and each column corresponds to a variable.  
The variables are: community_live, community work and amount, in this order.  
The meaning of the variables is the following: community_live, Character, containing the id of the grid cell where the commuters live, community_work, character, containing the id grid cell where the commuter/commuters work and amount, numeric, containing the number of commuter/commuters commuting between community_live and community_work (direction is important). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SardiniaGrid)
</code></pre>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi 
</p>


<h3>Source</h3>

<p>The data is elaborated from the shape files of the Geostat 2011 population grid: https://ec.europa.eu/eurostat/web/gisco/geodata/reference-data/population-distribution-demography/geostat 
</p>

<hr>
<h2 id='shpBrindisi'>
shpBrindisi
</h2><span id='topic+shpBrindisi'></span>

<h3>Description</h3>

<p>object of class sf that holds polygons with attributes for each community in Brindisi provincie as from Italian Population Census 2001.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("shpBrindisi")</code></pre>


<h3>Source</h3>

<p>The data is taken from the shape files (in generalised form) of the whole of Italian municipalities at the 2001 Populalation Census published by Istat: http://www.istat.it/it/archivio/124086 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(data.table)
## Not run: 
data(shpBrindisi)
plot(shpBrindisi)
## maybe str(shpBrindisi) ;  ...

## End(Not run)</code></pre>

<hr>
<h2 id='shpSardinia'>shpSardinia
</h2><span id='topic+shpSardinia'></span>

<h3>Description</h3>

<p>object of class sf containing that holds polygons with attributes for each community in Sardinia island as from Italian Population Census 2001.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("shpSardinia")</code></pre>


<h3>Source</h3>

<p>The data is taken from the shape files (in generalised form) of the whole of Italian municipalities at the 2001 Populalation Census published by Istat: http://www.istat.it/it/archivio/124086 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(shpSardinia)
plot(shpSardinia)

## End(Not run)
## maybe str(shpSardinia) ; ...
</code></pre>

<hr>
<h2 id='StatClusterData'>
StatClusterData
</h2><span id='topic+StatClusterData'></span>

<h3>Description</h3>

<p>This function computes several statistics on a given set of labour market areas (a given partition). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StatClusterData(lma,param,threshold,dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StatClusterData_+3A_lma">lma</code></td>
<td>

<p>A list of data.table containing information on the labour market areas. Three components: clusterList, LWClus and marginals. clusterList is a data.table containing the variables community, cluster and EMP_live; everything else will be ignored. LWClus is a data.table containing the variables cluster_live, cluster_work and amount; everything else will be ignored. marginals is a data.table containing the variables cluster, amount_live and amount_work; everything else will be ignored. 
</p>
<p>In each data.table object, the order of the variables is mandatory.
</p>
<p>The lma names should have not been assigned; otherwise use function DeleteLmaName.
</p>
</td></tr>
<tr><td><code id="StatClusterData_+3A_param">param</code></td>
<td>
<p>numeric vector: the set of parameters corresponding to the lma object, i.e. minSZ,minSC,tarSZ,tarSC, respectively. See function findClusters.</p>
</td></tr>
<tr><td><code id="StatClusterData_+3A_threshold">threshold</code></td>
<td>

<p>numeric. It is used to identify particular small labour market areas or flows. 
</p>
</td></tr>
<tr><td><code id="StatClusterData_+3A_dat">dat</code></td>
<td>

<p>data frame/data.table containing the commuting flows between communities (see for example Sardinia).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>marginals</code></td>
<td>
<p>data.table containing the following variables for each LMA.
</p>
<p><b>LMA: </b> positive integer; labour market areas ID 
</p>
<p><b>EMP_live: </b>numeric; number of commuters who live in the area 
</p>
<p><b>EMP_work: </b>numeric; number of commuters working in the area
</p>
<p><b>validity: </b>numeric; validity value computed with the current parameters
</p>
<p><b>EMP_live_work: </b>numeric; number of commuters living and working in the area
</p>
<p><b>lma_commuter_percent: </b>numeric; the quantity: (EMP_live-EMP_live_work)+(EMP_work-EMP_live_work)/(2*EMP_live_work) 
</p>
<p><b>Home_Work_Ratio: </b>numeric; the quantity 
(( EMP_live-EMP_live_work)-( EMP_work-EMP_live_work))/EMP_live_work

</p>
<p><b>SC_demand_side: </b>numeric; demand side self-containment
</p>
<p><b>SC_supply_side: </b>numeric; supply side self-containment
</p>
<p><b>N_com: </b>integer; number of communities forming the LMA
</p>
<p><b>InternalCohesionLink: </b>numeric; consistency of internal relationships. It is given by the ratio between number of links between communities inside LMA, excluding itself, and the maximum number of possible links, i.e. (N_com * (N_com-1)). See [1].

</p>
<p><b>InternalCohesionFlows: </b>numeric; intensity of internal relationships. It is the percentage of internal flows (excluding flows having as origin and destination the same node) of the LMA between different communities w.r.t the total internal flows. See [3].

</p>
<p><b>NbCentralComm: </b>integer; number of communities having a centrality index greater than 1 (for communities with more than 100 workers, the centrality index is the ratio between net incoming flows and net outgoing flows).

</p>
<p><b>N_links_in: </b>integer; number of LMAs whose residents work in the current LMA (including itself)  
</p>
<p><b>N_links_out: </b>integer; number of LMAs where the residents of the current LMA work (including itself)
</p>
</td></tr>
<tr><td><code>StatFlows</code></td>
<td>
<p>list containing several statistics on flows and links between the labour market areas of the given partition.
</p>
<p><b>N_links: </b>numeric; number of links between LMAs
</p>
<p><b>PercNbLinksLessThreshold: </b>numeric; percentage of links corresponding to flows below threshold
</p>
<p><b>summFlows: </b>numeric vector; summary statistics on flows
</p>
<p><b>summFlowsNoItself: </b>numeric vector; summary statistics on flows, excluding the self-flows
</p>
<p><b>summLinks_in: </b>numeric vector; summary statistics on the number of incoming flows
</p>
<p><b>summLinks_out: </b>summary statistics on the number of outgoing flows
</p>
<p><b>clusterMaxNlinks_in: </b>positive integer; the LMA ID of the cluster reaching the maximum number of incoming flows
</p>
<p><b>clusterMaxNlinks_out: </b>positive integer; the LMA ID of the cluster reaching the maximum number of outgoing flows
</p>
<p><b>clusterMinNlinks_in: </b>positive integer; the LMA ID of the cluster reaching the minimum number of incoming flows
</p>
<p><b>clusterMinNlinks_out: </b>positive integer; the LMA ID of the cluster reaching the minimum number of outgoing flows
</p>
</td></tr>
<tr><td><code>StatQuality</code></td>
<td>
<p>list containing several statistics on the given partition: 
</p>
<p><b>NbClusters: </b>integer; number of clusters
</p>
<p><b>NbClusterUniqueCom: </b>integer; number of clusters with an unique community
</p>
<p><b>NbClustersValidLess1: </b>integer; number of clusters with validity smaller than 1
</p>
<p><b>NbClustersNoCentralCom: </b>integer; number of clusters with no communities having a centrality measure greater than 1 
</p>
<p><b>Mean.SC_demand_side: </b>numeric; mean of the demand side self-containment of the clusters in the partition  
</p>
<p><b>Std.SC_demand_side: </b>numeric; standard deviation of the demand side self-containment 
</p>
<p><b>Mean.SC_supply_side: </b>numeric; mean of the supply side self-containment of the clusters in the partition 
</p>
<p><b>Std.SC_supply_side: </b>numeric; standard deviation of the supply side self-containment   
</p>
<p><b>Q1.InternalCohesionFlows: </b>numeric; first quartile of the InternalCohesionFlows 
</p>
<p><b>Q2.InternalCohesionFlows: </b>numeric; median of the InternalCohesionFlows
</p>
<p><b>Q3.InternalCohesionFlows: </b>numeric; third quartile of the InternalCohesionFlows 
</p>
<p><b>Q1.InternalCohesionLink: </b>numeric; first quartile of the InternalCohesionLink 
</p>
<p><b>Q2.InternalCohesionLink: </b>numeric; median of the InternalCohesionLink
</p>
<p><b>Q3.InternalCohesionLink: </b>numeric; third quartile of the InternalCohesionLink 
</p>
<p><b>Q1.EMP_live: </b>numeric; first quartile of the residents 
</p>
<p><b>Q2.EMP_live: </b>numeric; median of the residents
</p>
<p><b>Q3.EMP_live: </b>numeric; third quartile of the residents 
</p>
<p><b>Mean.EMP_live: </b>numeric; mean value of the residents 
</p>
<p><b>Std.EMP_live: </b>numeric; standard deviation of the residents 
</p>
<p><b>Min.EMP_live: </b>numeric; minimum value of the residents 
</p>
<p><b>Max.EMP_live: </b>numeric; maximum value of the residents 
</p>
<p><b>Q1.EMP_work: </b>numeric; first quartile of the workers/jobs 
</p>
<p><b>Q2.EMP_work: </b>numeric; median of the workers/jobs
</p>
<p><b>Q3.EMP_work: </b>numeric; third quartile of the workers/jobs 
</p>
<p><b>Mean.EMP_work: </b>numeric; mean value of the workers 
</p>
<p><b>Std.EMP_work: </b>numeric; standard deviation of the workers 
</p>
<p><b>Min.EMP_work: </b>numeric; minimum value of the workers 
</p>
<p><b>Max.EMP_work: </b>numeric; maximum value of the workers 
</p>
<p><b>Q1.EMP_live_work: </b>numeric; first quartile of the commuters living and working in the same area
</p>
<p><b>Q2.EMP_live_work: </b>numeric; median of the commuters living and working in the same area
</p>
<p><b>Q3.EMP_live_work: </b>numeric; third quartile of the the commuters living and working in the same area 
</p>
<p><b>Min.EMP_live_work: </b>numeric; minimum value of the commuters living and working in the same area 
</p>
<p><b>Max.EMP_live_work: </b>numeric; maximum value of the commuters living and working in the same area 
</p>
<p><b>Mean.lma_commuter_percent: </b>numeric; mean value of the quantity: (EMP_live-EMP_live_work)+(EMP_work-EMP_live_work)/(2*EMP_live_work) 
</p>
<p><b>Std.lma_commuter_percent: </b>numeric; standard deviation of the quantity (EMP_live-EMP_live_work)+(EMP_work-EMP_live_work)/(2*EMP_live_work) 
</p>
<p><b>Mean.Home_Work_Ratio: </b>numeric; mean value of the quantity 
(( EMP_live-EMP_live_work)-( EMP_work-EMP_live_work))/EMP_live_work

<b>Std.Home_Work_Ratio: </b>numeric; standard deviation of the quantity 
(( EMP_live-EMP_live_work)-( EMP_work-EMP_live_work))/EMP_live_work

</p>
<p><b>Q_modularity: </b>numeric; Q_modularity index 
</p>
</td></tr>
<tr><td><code>param:</code></td>
<td>
<p>numeric vector; it contains the parameters of the given solution, i.e. the output of the function findClusters. The parameters are minSZ,minSC,tarSZ,tarSC.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi, Michele D'Alo'
</p>


<h3>References</h3>

<p>[1] Erba, A., D'Angio', A. e Marzulli, S. (1990). Partizioni funzionali del territorio: il modello Isers, Franco Angeli, Milano.
</p>
<p>[2] Franconi, L., D'Alo' M. and Ichim, D. (2016). Istat implementation of the algorithm to develop Labour Market Areas.
</p>
<p>[3] Lipizzi, F. (2014). Strumenti e indicatori per la misura della consistenza e omogeneita' delle aree funzionali. XXXV Conferenza annuale AISRe, &quot;Uscire dalla crisi. Citta', Comunita' e Specializzazione Intelligenti&quot;, Padova,  11-13 September 2014.
</p>


<h3>See Also</h3>

<p>findClusters
</p>

<hr>
<h2 id='StatReserveList'>
StatReserveList
</h2><span id='topic+StatReserveList'></span>

<h3>Description</h3>

<p>This function computes several statistics on the reserve.list (see function findCluster). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>StatReserveList(reserve.list, dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="StatReserveList_+3A_reserve.list">reserve.list</code></td>
<td>

<p>list containing the information on the reserve list. It is the output of the findClusters function. Each component of the list should contain (at least): the type of assignment to the reserve list, the iteration number, the cluster dissolved to be assigned to the reserve list and its validity, the community assigned to the reserve list. See function findClusters.
</p>
</td></tr>
<tr><td><code id="StatReserveList_+3A_dat">dat</code></td>
<td>

<p>data.frame/data.table containing the commuting data. Each row corresponds to an observation, i.e. a flow, and each column corresponds to a variable. The variables are named: community_live: (integer) contains the id number of the elementary zone of residence, community_work:  (integer) contains the id number of the working community (elementary zone of work), amount: (numeric) contains the number of employees commuting between the &quot;community_live&quot; and &quot;community_work&quot; (direction is important). Missing values (NAs) are not allowed. The community id must be strictly positive. Negative flows are not allowed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>NumComm</code></td>
<td>
<p>integer; number of communities in the reserve list</p>
</td></tr>
<tr><td><code>NumClus</code></td>
<td>
<p>integer; as each community in the reserve list initially belonged to a cluster, this statistics reports the number of different clusters in the reserve list. The clusters ID are the ones initially generated by the algorithm.</p>
</td></tr>
<tr><td><code>NumUniqueClus</code></td>
<td>
<p>integer; number of clusters (for communities in the reserve list) with a unique community.</p>
</td></tr>
<tr><td><code>summaryCommByClus</code></td>
<td>
<p>numeric vector; summary statistics on the number of communities, by cluster. Only the communities included in the reserve list are considered.</p>
</td></tr>
<tr><td><code>summaryValidities</code></td>
<td>
<p>numeric vector; summary statistics on validity values of the clusters when they were considered for the reserve.list.</p>
</td></tr>
<tr><td><code>TypesTable</code></td>
<td>
<p>frequency table of the types of assignment of the communities to the reserve list.</p>
</td></tr>
<tr><td><code>Residents</code></td>
<td>
<p>data.table of two columns: communities in the reserve list and their residents.</p>
</td></tr>
<tr><td><code>summaryResidByComm</code></td>
<td>
<p>numeric vector; summary statistics on the number of residents by community in the reserve list.</p>
</td></tr>
<tr><td><code>Workers</code></td>
<td>
<p>data.table of two columns: communities in the reserve list and their jobs.</p>
</td></tr>
<tr><td><code>summaryWorkersByCom</code></td>
<td>
<p>numeric vector; summary statistics on the number of workers by community in the reserve list.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Daniela Ichim, Luisa Franconi
</p>


<h3>References</h3>

<p>[1] Franconi, L., D'Alo' M. and Ichim, D. (2016). Istat implementation of the algorithm to develop Labour Market Areas.
</p>


<h3>See Also</h3>

<p>findClusters
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
