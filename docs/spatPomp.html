<!DOCTYPE html><html><head><title>Help for package spatPomp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spatPomp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abf'><p>Adapted Bagged Filter (ABF)</p></a></li>
<li><a href='#abfir'><p>Adapted Bagged Filter with Intermediate Resampling (ABF-IR)</p></a></li>
<li><a href='#arma_benchmark'><p>Calculated log-ARMA log-likelihood benchmark for spatPomp models</p></a></li>
<li><a href='#as.data.frame'><p>Coerce to data frame</p></a></li>
<li><a href='#bm'><p>Brownian motion spatPomp simulator</p></a></li>
<li><a href='#bm_kalman_logLik'><p>Exact log-likelihood for Brownian motion spatPomp generator</p></a></li>
<li><a href='#bm2'><p>Brownian motion spatPomp generator with shared or unit-specific parameters</p></a></li>
<li><a href='#bm2_kalman_logLik'><p>Exact log-likelihood for Brownian motion spatPomp generator</p>
with shared or unit-specific parameters</a></li>
<li><a href='#bpfilter'><p>Block particle filter (BPF)</p></a></li>
<li><a href='#city_data_UK'><p>City data in the United Kingdom</p></a></li>
<li><a href='#conc'><p>Concatenate</p></a></li>
<li><a href='#concat'><p>Concatenate</p></a></li>
<li><a href='#dunit_measure'><p>dunit_measure</p>
<code>dunit_measure</code> evaluates the unit measurement density of a unit's observation given the entire state</a></li>
<li><a href='#enkf'><p>Generalized Ensemble Kalman filter (EnKF)</p></a></li>
<li><a href='#eunit_measure'><p>eunit_measure</p></a></li>
<li><a href='#expand_params'><p>Book-keeping functions for working with expanded parameters</p></a></li>
<li><a href='#gbm'><p>Geometric Brownian motion spatPomp simulator</p></a></li>
<li><a href='#girf'><p>Guided intermediate resampling filter (GIRF)</p></a></li>
<li><a href='#he10'><p>Measles in UK: spatPomp generator with shared or unit-specific parameters</p></a></li>
<li><a href='#he10coordinates'><p>City data in the United Kingdom</p></a></li>
<li><a href='#he10demography'><p>Demographic data for 20 towns in the United Kingdom</p></a></li>
<li><a href='#he10measles'><p>Measles in the United Kingdom</p></a></li>
<li><a href='#he10mle'><p>Measles in the United Kingdom: MLE from He et al (2010)</p></a></li>
<li><a href='#ibpf'><p>Iterated block particle filter (IBPF)</p></a></li>
<li><a href='#ienkf'><p>Iterated ensemble Kalman filter (IEnKF)</p></a></li>
<li><a href='#igirf'><p>Iterated guided intermediate resampling filter (IGIRF)</p></a></li>
<li><a href='#iubf'><p>Iterated Unadapted Bagged Filter (IUBF)</p></a></li>
<li><a href='#listie'><p>listie</p></a></li>
<li><a href='#logLik'><p>Log likelihood</p></a></li>
<li><a href='#lorenz'><p>Lorenz '96 spatPomp simulator</p></a></li>
<li><a href='#measles'><p>Measles in UK spatPomp generator</p></a></li>
<li><a href='#measles2'><p>Measles in UK: spatPomp generator with shared or unit-specific parameters</p></a></li>
<li><a href='#measlesUK'><p>Measles in the United Kingdom</p></a></li>
<li><a href='#munit_measure'><p>munit_measure</p></a></li>
<li><a href='#plot'><p>Plotting <code>spatPomp</code> data</p></a></li>
<li><a href='#print'><p>Print methods</p></a></li>
<li><a href='#pStop'><p>pStop</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#runit_measure'><p>runit_measure</p></a></li>
<li><a href='#simulate'><p>Simulation of a spatiotemporal partially-observed Markov process</p></a></li>
<li><a href='#spatPomp'><p>Constructor of the spatPomp object</p></a></li>
<li><a href='#spatPomp_Csnippet'><p>C snippets</p></a></li>
<li><a href='#spatPomp-class'><p>An S4 class to represent a spatiotemporal POMP model and data.</p></a></li>
<li><a href='#spatPomp-package'><p>Inference for SpatPOMPs (Spatiotemporal Partially Observed Markov Processes)</p></a></li>
<li><a href='#undefined'><p>Undefined</p></a></li>
<li><a href='#unit_names'><p>Unit names of a spatiotemporal model</p></a></li>
<li><a href='#vec_dmeasure'><p>Vector of measurement densities</p></a></li>
<li><a href='#vec_rmeasure'><p>Vector of simulated measurements</p></a></li>
<li><a href='#vunit_measure'><p>vunit_measure</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Inference for Spatiotemporal Partially Observed Markov Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.34.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-17</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kidusasfaw/spatPomp">https://github.com/kidusasfaw/spatPomp</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Inference on panel data using spatiotemporal partially-observed Markov process (SpatPOMP) models. The 'spatPomp' package extends 'pomp' to include algorithms taking advantage of the spatial structure in order to assist with handling high dimensional processes. See Asfaw et al. (2023) &lt;<a href="https://arxiv.org/abs/2101.01157">arXiv:2101.01157</a>&gt; for further description of the package.</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>For Windows users, Rtools (see
https://cran.r-project.org/bin/windows/Rtools/).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kidusasfaw/spatPomp/issues/">https://github.com/kidusasfaw/spatPomp/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>pomp (&ge; 5.4), R(&ge; 4.1), methods</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>pomp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doParallel (&ge; 1.0.11), parallel, doRNG</td>
</tr>
<tr>
<td>Imports:</td>
<td>foreach, dplyr, tidyr, stringr, abind, rlang, magrittr,
ggplot2</td>
</tr>
<tr>
<td>Collate:</td>
<td>'spatPomp_class.R' 'abf.R' 'abfir.R' 'arma_benchmark.R'
'get_covariate_names.R' 'as_data_frame.R' 'bm.R' 'bm2.R'
'bm2_kalman_logLik.R' 'bm_kalman_logLik.R' 'bpfilter.R'
'city_data_UK.R' 'iter_filter.R' 'safecall.R' 'pstop.R'
'undefined.R' 'spatPomp.R' 'ibpf.R' 'listie.R' 'conc.R'
'concat.R' 'dunit_measure.R' 'enkf.R' 'eunit_measure.R' 'gbm.R'
'girf.R' 'he10.R' 'he10coordinates.R' 'he10demography.R'
'he10measles.R' 'he10mle.R' 'ienkf.R' 'igirf.R' 'iubf.R'
'loglik.R' 'lorenz.R' 'measles.R' 'measles2.R' 'measlesUK.R'
'munit_measure.R' 'package.R' 'param_formats.R' 'pipe.R'
'plot.R' 'print.R' 'runit_measure.R' 'simulate.R'
'spatPomp_Csnippet.R' 'spatPomp_workhorses.R' 'unit_names.R'
'vec_dmeasure.R' 'vec_rmeasure.R' 'vunit_measure.R'</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-18 15:31:16 UTC; ionides</td>
</tr>
<tr>
<td>Author:</td>
<td>Kidus Asfaw [aut],
  Edward Ionides [cre, aut],
  Aaron A. King [aut],
  Allister Ho [ctb],
  Joonha Park [ctb],
  Jesse Wheeler [ctb],
  Jifan Li [ctb],
  Ning Ning [ctb],
  Haogao Gu [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Edward Ionides &lt;ionides@umich.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-18 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='abf'>Adapted Bagged Filter (ABF)</h2><span id='topic+abf'></span><span id='topic+abf-spatPomp'></span><span id='topic+abf+2CspatPomp-method'></span><span id='topic+abf-abfd_spatPomp'></span><span id='topic+abf+2Cabfd_spatPomp-method'></span>

<h3>Description</h3>

<p>An algorithm for estimating the likelihood of a spatiotemporal partially-observed Markov process model.
Running <code>abf</code> causes the algorithm to run bootstrap replicate jobs which each yield an imperfect adapted simulation. Simulating from the &quot;adapted filter&quot;
distribution runs into a curse of dimensionality (COD) problem, which is mitigated by keeping particles in each replicate close to each other through resampling down
to one particle per replicate at each observation time point.
The adapted simulations are then weighted in a way that mitigates COD by making a weak coupling assumption to get an approximate filter distribution.
As a by-product, we also get an estimate of the likelihood of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spatPomp'
abf(
  object,
  Nrep,
  Np,
  nbhd,
  tol = 1e-300,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'abfd_spatPomp'
abf(
  object,
  Nrep,
  Np,
  nbhd,
  tol = 1e-300,
  ...,
  verbose = getOption("verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abf_+3A_object">object</code></td>
<td>
<p>A <code>spatPomp</code> object.</p>
</td></tr>
<tr><td><code id="abf_+3A_nrep">Nrep</code></td>
<td>
<p>The number of bootstrap replicates for the adapted simulations.</p>
</td></tr>
<tr><td><code id="abf_+3A_np">Np</code></td>
<td>
<p>The number of particles used within each replicate for the adapted simulations.</p>
</td></tr>
<tr><td><code id="abf_+3A_nbhd">nbhd</code></td>
<td>
<p>A neighborhood function with three arguments: <code>object</code>, <code>time</code> and <code>unit</code>.
The function should return a <code>list</code> of two-element vectors that represent space-time neighbors of <code class="reqn">(u,n)</code>,
which is represented by <code>c(unit,time)</code>. See example below for more details.</p>
</td></tr>
<tr><td><code id="abf_+3A_tol">tol</code></td>
<td>
<p>If the resampling weight for a particle is zero due to floating-point precision issues, it is set to the value of <code>tol</code> since resampling has to be done.</p>
</td></tr>
<tr><td><code id="abf_+3A_...">...</code></td>
<td>
<p>If a <code>params</code> argument is specified, <code>abf</code> will estimate the likelihood at that parameter set instead of at <code>coef(object)</code>.</p>
</td></tr>
<tr><td><code id="abf_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, messages updating the user on progress will be printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Upon successful completion, <code>abf()</code> returns an object of class
&lsquo;abfd_spatPomp&rsquo; containing the algorithmic parameters used to run <code>abf()</code>
and the estimated likelihood.
</p>


<h3>Methods</h3>

<p>The following methods are available for such an object:
</p>

<dl>
<dt><code><a href="#topic+logLik">logLik</a></code></dt><dd><p> yields an estimate of the log-likelihood of the data under the model. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kidus Asfaw
</p>


<h3>References</h3>

<p>Ionides, E. L., Asfaw, K., Park, J., and King, A. A. (2021). Bagged filters for partially observed interacting systems. <em>Journal of the American Statistical Association</em>, <a href="https://doi.org/10.1080/01621459.2021.1974867">doi:10.1080/01621459.2021.1974867</a>
</p>


<h3>See Also</h3>

<p>likelihood maximization algorithms: <code>ienkf()</code>, <code>igirf</code>, <code>iubf</code>, <code>ibpf</code>
</p>
<p>Other likelihood evaluation algorithms: 
<code><a href="#topic+abfir">abfir</a>()</code>,
<code><a href="#topic+bpfilter">bpfilter</a>()</code>,
<code><a href="#topic+enkf">enkf</a>()</code>,
<code><a href="#topic+girf">girf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
# Create a simulation of a Brownian motion
b &lt;- bm(U=2, N=5)

# Create a neighborhood function mapping a point in space-time
# to a list of neighboring points in space-time
bm_nbhd &lt;- function(object, time, unit) {
  nbhd_list = list()
  if(time &gt; 1 &amp;&amp; unit &gt; 1){
    nbhd_list = c(nbhd_list, list(c(unit-1, time-1)))
  }
  return(nbhd_list)
}

# Run ABF specified number of Monte Carlo replicates and particles per replicate
abfd_bm &lt;- abf(b, Nrep=2, Np=10, nbhd=bm_nbhd)

# Get the likelihood estimate from ABF
logLik(abfd_bm)

## End(Not run)
</code></pre>

<hr>
<h2 id='abfir'>Adapted Bagged Filter with Intermediate Resampling (ABF-IR)</h2><span id='topic+abfir'></span><span id='topic+abfir-spatPomp'></span><span id='topic+abfir+2CspatPomp-method'></span><span id='topic+abfir-abfird_spatPomp'></span><span id='topic+abfir+2Cabfird_spatPomp-method'></span>

<h3>Description</h3>

<p>An algorithm for estimating the filter distribution and likelihood of a spatiotemporal partially-observed Markov process model.
Running <code>abfir</code> causes the algorithm to run Monte Carlo replicated jobs which
each carry out an adapted simulation using intermediate resampling.
Adapted simulation is an easier task than filtering, since particles in each replicate
remain close to each other. Intermediate resampling further assists against
the curse of dimensionality (COD) problem for importance sampling.
The adapted simulations are then weighted in a way that mitigates COD by
making a weak coupling assumption to get an approximate filter distribution.
As a by-product, we also get an approximation to the likelihood of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spatPomp'
abfir(
  object,
  Np,
  Nrep,
  nbhd,
  Ninter,
  tol = (1e-300),
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'abfird_spatPomp'
abfir(object, Np, Nrep, nbhd, Ninter, tol, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abfir_+3A_object">object</code></td>
<td>
<p>A <code>spatPomp</code> object.</p>
</td></tr>
<tr><td><code id="abfir_+3A_np">Np</code></td>
<td>
<p>The number of particles used within each replicate for the adapted simulations.</p>
</td></tr>
<tr><td><code id="abfir_+3A_nrep">Nrep</code></td>
<td>
<p>The number of bootstrap replicates for the adapted simulations.</p>
</td></tr>
<tr><td><code id="abfir_+3A_nbhd">nbhd</code></td>
<td>
<p>A neighborhood function with three arguments: <code>object</code>, <code>time</code> and <code>unit</code>.
The function should return a <code>list</code> of two-element vectors that represent space-time neighbors of <code class="reqn">(u,n)</code>,
which is represented by <code>c(unit,time)</code>. See example below for more details.</p>
</td></tr>
<tr><td><code id="abfir_+3A_ninter">Ninter</code></td>
<td>
<p>the number of intermediate resampling time points. By default, this is set equal to the number of units.</p>
</td></tr>
<tr><td><code id="abfir_+3A_tol">tol</code></td>
<td>
<p>If the resampling weight for a particle is zero due to floating-point precision issues, it is set to the value of <code>tol</code> since resampling has to be done.</p>
</td></tr>
<tr><td><code id="abfir_+3A_...">...</code></td>
<td>
<p>If a <code>params</code> argument is specified, <code>abf</code> will estimate the likelihood at that parameter set instead of at <code>coef(object)</code>.</p>
</td></tr>
<tr><td><code id="abfir_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, messages updating the user on progress will be printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Upon successful completion, <code>abfir()</code> returns an object of class
&lsquo;abfird_spatPomp&rsquo; containing the algorithmic parameters used to run <code>abfir()</code>
and the estimated likelihood.
</p>


<h3>Methods</h3>

<p>The following methods are available for such an object:
</p>

<dl>
<dt><code><a href="#topic+logLik">logLik</a></code></dt><dd><p> yields a biased estimate of the log-likelihood of
the data under the model. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kidus Asfaw
</p>


<h3>References</h3>

<p>Ionides, E. L., Asfaw, K., Park, J., and King, A. A. (2021). Bagged filters for partially observed interacting systems. <em>Journal of the American Statistical Association</em>, <a href="https://doi.org/10.1080/01621459.2021.1974867">doi:10.1080/01621459.2021.1974867</a>
</p>


<h3>See Also</h3>

<p>likelihood maximization algorithms: <code>ienkf()</code>, <code>igirf()</code>, <code>iubf()</code>, <code>ibpf()</code>
</p>
<p>Other likelihood evaluation algorithms: 
<code><a href="#topic+abf">abf</a>()</code>,
<code><a href="#topic+bpfilter">bpfilter</a>()</code>,
<code><a href="#topic+enkf">enkf</a>()</code>,
<code><a href="#topic+girf">girf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
# Create a simulation of a Brownian motion
b &lt;- bm(U=2, N=5)

# Create a neighborhood function mapping a point in space-time
# to a list of ``neighboring points" in space-time
bm_nbhd &lt;- function(object, time, unit) {
  nbhd_list = list()
  if(time &gt; 1 &amp;&amp; unit &gt; 1){
    nbhd_list = c(nbhd_list, list(c(unit-1, time-1)))
  }
  return(nbhd_list)
}
# Run ABFIR with specified number of Monte Carlo replicates and particles
# per replicate
abfird_bm &lt;- abfir(b,
                  Nrep = 2,
                  Np=10,
                  nbhd = bm_nbhd,
                  Ninter = length(unit_names(b)))
# Get the likelihood estimate from ABFIR
logLik(abfird_bm)

## End(Not run)
</code></pre>

<hr>
<h2 id='arma_benchmark'>Calculated log-ARMA log-likelihood benchmark for spatPomp models</h2><span id='topic+arma_benchmark'></span>

<h3>Description</h3>

<p>Fits independent log-ARMA models for each unit, and calculates the conditional
log-likelihood for each observation, as well as log-likelihood for
each unit and total log-likelihood. A simple tool, but one with
practical applicability, as demonstrated by King et al (2008) and
Wheeler et al (2023). This function is designed for non-negative 
data, and adds 1 to each observation to avoid log(0).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arma_benchmark(spo, order = c(2, 0, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arma_benchmark_+3A_spo">spo</code></td>
<td>
<p>A spatPomp object</p>
</td></tr>
<tr><td><code id="arma_benchmark_+3A_order">order</code></td>
<td>
<p>A triple (p,d,q) for the ARIMA model fitted to the data. It is
intended that d=0</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Edward L. Ionides
</p>


<h3>References</h3>

<p>King, A. A., Ionides, E. L., Pascual, M. and Bouma, M. J. (2008). Inapparent infections and cholera dynamics. Nature 454 877-880.
</p>
<p>Wheeler, J., Rosengart, A. L., Jiang, Z., Tan, K., Treutle, N. and Ionides, E. L. (2023). Informing policy via dynamic models: Cholera in Haiti. arxiv:2301.08979.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+expand_params">expand_params</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
m &lt;- he10(U = 5)
arma_benchmark(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='as.data.frame'>Coerce to data frame</h2><span id='topic+as.data.frame'></span><span id='topic+coerce+2CspatPomp+2Cdata.frame-method'></span><span id='topic+as.data.frame.spatPomp'></span>

<h3>Description</h3>

<p><span class="pkg">spatPomp</span> objects can be recast as data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spatPomp'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame_+3A_x">x</code></td>
<td>
<p>a <code>spatPomp</code> object.</p>
</td></tr>
<tr><td><code id="as.data.frame_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>object</code> is a simple &lsquo;spatPomp&rsquo; object,
<code>as(object,"data.frame")</code> or <code>as.data.frame(object)</code> results in a
data frame with the times, units, observables, states (if known), and
interpolated covariates (if any).
</p>


<h3>Value</h3>

<p>A &lsquo;data.frame&rsquo; with columns for time, spatial unit and observations.
</p>

<hr>
<h2 id='bm'>Brownian motion spatPomp simulator</h2><span id='topic+bm'></span>

<h3>Description</h3>

<p>Generate a class &lsquo;spatPomp&rsquo; object representing a <code>U</code>-dimensional
Brownian motion with spatial correlation decaying geometrically with
distance around a circle. The model is defined in continuous time
though in this case an Euler approximation is exact at the evaluation
times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm(U = 5, N = 100, delta_t = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_+3A_u">U</code></td>
<td>
<p>A length-one numeric signifying dimension of the process.</p>
</td></tr>
<tr><td><code id="bm_+3A_n">N</code></td>
<td>
<p>A length-one numeric signifying the number of observation time steps to evolve the process.</p>
</td></tr>
<tr><td><code id="bm_+3A_delta_t">delta_t</code></td>
<td>
<p>Process simulations are performed every <code>delta_t</code> time units
whereas observations occur every one time unit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lsquo;spatPomp&rsquo; representing a simulation from a <code>U</code>-dimensional
Brownian motion
</p>


<h3>Author(s)</h3>

<p>Edward L. Ionides
</p>


<h3>See Also</h3>

<p>Other spatPomp model generators: 
<code><a href="#topic+bm2">bm2</a>()</code>,
<code><a href="#topic+gbm">gbm</a>()</code>,
<code><a href="#topic+he10">he10</a>()</code>,
<code><a href="#topic+lorenz">lorenz</a>()</code>,
<code><a href="#topic+measles">measles</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
b &lt;- bm(U=4, N=20)
# See all the model specifications of the object
spy(b)
# Examples of methodologies applied to this model
# are provided in the tests directory

## End(Not run)
</code></pre>

<hr>
<h2 id='bm_kalman_logLik'>Exact log-likelihood for Brownian motion spatPomp generator</h2><span id='topic+bm_kalman_logLik'></span>

<h3>Description</h3>

<p>Computes the exact likelihood for a model constructed using <code>bm</code>,
using the Kalman filter. This model is useful for testing methods
in a situation where an exact answer is available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm_kalman_logLik(bm_object, params = coef(bm_object))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm_kalman_logLik_+3A_bm_object">bm_object</code></td>
<td>
<p>A spatPomp model built using <code>bm</code>.</p>
</td></tr>
<tr><td><code id="bm_kalman_logLik_+3A_params">params</code></td>
<td>
<p>A parameter vector at which to evaluate the log-likelihood.
whereas observations occur every one time unit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value for the log-likelihood.
</p>


<h3>Author(s)</h3>

<p>Edward L. Ionides
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Further examples are provided in the tests directory
## Not run: 
b &lt;- bm()
bm_kalman_logLik(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='bm2'>Brownian motion spatPomp generator with shared or unit-specific parameters</h2><span id='topic+bm2'></span>

<h3>Description</h3>

<p>An extension of <code>bm</code> allowing for shared or unit-specific parameters.
Generate a class &lsquo;spatPomp&rsquo; object representing a <code>U</code>-dimensional
Brownian motion with spatial correlation decaying geometrically with
distance around a circle. The model is defined in continuous time
though in this case an Euler approximation is exact at the evaluation
times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm2(
  U = 5,
  N = 100,
  delta_t = 0.1,
  unit_specific_names = "rho",
  shared_names = NULL,
  unit_params = c(rho = 0.4, sigma = 1, tau = 1, X_0 = 0)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm2_+3A_u">U</code></td>
<td>
<p>A length-one numeric signifying dimension of the process.</p>
</td></tr>
<tr><td><code id="bm2_+3A_n">N</code></td>
<td>
<p>A length-one numeric signifying the number of observation time steps to evolve the process.</p>
</td></tr>
<tr><td><code id="bm2_+3A_delta_t">delta_t</code></td>
<td>
<p>Process simulations are performed every <code>delta_t</code> time units
whereas observations occur every one time unit</p>
</td></tr>
<tr><td><code id="bm2_+3A_unit_specific_names">unit_specific_names</code></td>
<td>
<p>determines which parameters take a different value
for each unit. Cannot be specified if shared_names is specified.
each unit. Other parameters are considered shared between all units.</p>
</td></tr>
<tr><td><code id="bm2_+3A_shared_names">shared_names</code></td>
<td>
<p>identifies parameters that have common shared value for all units, which by default is all parameters.</p>
</td></tr>
<tr><td><code id="bm2_+3A_unit_params">unit_params</code></td>
<td>
<p>parameter values used to build the object, copied across 
each unit for unit-specific parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lsquo;spatPomp&rsquo; representing a simulation from a
<code>U</code>-dimensional Brownian motion
</p>


<h3>Author(s)</h3>

<p>Edward L. Ionides
</p>


<h3>See Also</h3>

<p>Other spatPomp model generators: 
<code><a href="#topic+bm">bm</a>()</code>,
<code><a href="#topic+gbm">gbm</a>()</code>,
<code><a href="#topic+he10">he10</a>()</code>,
<code><a href="#topic+lorenz">lorenz</a>()</code>,
<code><a href="#topic+measles">measles</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
b &lt;- bm2(U=4, N=20,shared_names="rho",unit_specific_names=c("sigma","tau"))
# See all the model specifications of the object
spy(b)
# Examples of methodologies applied to this model
# are provided in the tests directory

## End(Not run)
</code></pre>

<hr>
<h2 id='bm2_kalman_logLik'>Exact log-likelihood for Brownian motion spatPomp generator
with shared or unit-specific parameters</h2><span id='topic+bm2_kalman_logLik'></span>

<h3>Description</h3>

<p>Computes the exact likelihood for a model constructed using <code>bm2</code>,
using the Kalman filter. This model is useful for testing methods
for models with unit-specific parameters, or method such as ibpf
which require a unit-specific extension of shared parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bm2_kalman_logLik(bm2_object, params = coef(bm2_object))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bm2_kalman_logLik_+3A_bm2_object">bm2_object</code></td>
<td>
<p>A spatPomp model built using <code>bm2</code>.</p>
</td></tr>
<tr><td><code id="bm2_kalman_logLik_+3A_params">params</code></td>
<td>
<p>A parameter vector at which to evaluate the log-likelihood.
whereas observations occur every one time unit</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value for the log-likelihood.
</p>


<h3>Author(s)</h3>

<p>Edward L. Ionides
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Further examples are provided in the tests directory
## Not run: 
b &lt;- bm2()
bm2_kalman_logLik(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='bpfilter'>Block particle filter (BPF)</h2><span id='topic+bpfilter'></span><span id='topic+bpfilter-missing'></span><span id='topic+bpfilter+2Cmissing-method'></span><span id='topic+bpfilter-ANY'></span><span id='topic+bpfilter+2CANY-method'></span><span id='topic+bpfilter-spatPomp'></span><span id='topic+bpfilter+2CspatPomp-method'></span><span id='topic+bpfilter-bpfilterd_spatPomp'></span><span id='topic+bpfilter+2Cbpfilterd_spatPomp-method'></span>

<h3>Description</h3>

<p>An implementation of the block particle filter algorithm of Rebeschini and van Handel (2015), which is used to estimate the filter distribution
of a spatiotemporal partially-observed Markov process.
<code>bpfilter</code> requires a partition of the spatial units which can be provided by either the <code>block_size</code> or the <code>block_list</code> argument.
The elements of the partition are called blocks. We perform resampling for each block independently based on sample weights within the block.
Each resampled block only contains latent states for the spatial components within the block which allows for a &ldquo;cross-pollination&quot; of
particles where the highest weighted segments of each particle are more likely to be resampled and get combined with resampled components of
other particles. The method mitigates the curse of dimensionality by resampling locally.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing'
bpfilter(object, ...)

## S4 method for signature 'ANY'
bpfilter(object, ...)

## S4 method for signature 'spatPomp'
bpfilter(
  object,
  Np,
  block_size,
  block_list,
  save_states,
  filter_traj,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'bpfilterd_spatPomp'
bpfilter(
  object,
  Np,
  block_size,
  block_list,
  save_states,
  filter_traj,
  ...,
  verbose = getOption("verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bpfilter_+3A_object">object</code></td>
<td>
<p>A <code>spatPomp</code> object.</p>
</td></tr>
<tr><td><code id="bpfilter_+3A_...">...</code></td>
<td>
<p>If a <code>params</code> argument is specified, <code>bpfilter</code> will estimate the likelihood at that parameter set instead of at <code>coef(object)</code>.</p>
</td></tr>
<tr><td><code id="bpfilter_+3A_np">Np</code></td>
<td>
<p>The number of particles used within each replicate for the adapted simulations.</p>
</td></tr>
<tr><td><code id="bpfilter_+3A_block_size">block_size</code></td>
<td>
<p>The number of spatial units per block. If this is provided, the method subdivides units approximately evenly
into blocks with size <code>block_size</code>.</p>
</td></tr>
<tr><td><code id="bpfilter_+3A_block_list">block_list</code></td>
<td>
<p>List that specifies an exact partition of the spatial units. Each partition element, or block, is
an integer vector of neighboring units.</p>
</td></tr>
<tr><td><code id="bpfilter_+3A_save_states">save_states</code></td>
<td>
<p>logical. If True, the state-vector for each particle and
block is saved.</p>
</td></tr>
<tr><td><code id="bpfilter_+3A_filter_traj">filter_traj</code></td>
<td>
<p>logical; if <code>TRUE</code>, a filtered trajectory is returned for the state variables and parameters.</p>
</td></tr>
<tr><td><code id="bpfilter_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, messages updating the user on progress will be printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Upon successful completion, <code>bpfilter()</code> returns an object of class
&lsquo;bpfilterd_spatPomp&rsquo; containing the algorithmic parameters used to run <code>bpfilter()</code>
and the estimated likelihood.
</p>


<h3>Details</h3>

<p>Only one of <code>block_size</code> or <code>block_list</code> should be specified.
If both or neither is provided, an error is triggered.
</p>


<h3>Methods</h3>

<p>The following methods are available for such an object:
</p>

<dl>
<dt><code><a href="#topic+logLik">logLik</a></code></dt><dd><p> yields an estimate of the log-likelihood of the data under the model. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kidus Asfaw
</p>


<h3>References</h3>

<p>Rebeschini, P., &amp; Van Handel, R. (2015). Can local particle filters beat the curse of dimensionality?. <em>The Annals of Applied Probability</em>, <b>25(5)</b>, 2809-2866.
</p>
<p>Asfaw, K., Park, J., Ho, A., King, A. A., and Ionides, E. L. (2020) Partially observed Markov processes with spatial structure via the R package spatPomp. <em>ArXiv</em>: 2101.01157. <a href="https://doi.org/10.48550/arXiv.2101.01157">doi:10.48550/arXiv.2101.01157</a>
</p>


<h3>See Also</h3>

<p>likelihood maximization algorithms: <code>ienkf()</code>, <code>igirf()</code>, <code>iubf()</code>, <code>ibpf()</code>
</p>
<p>Other likelihood evaluation algorithms: 
<code><a href="#topic+abf">abf</a>()</code>,
<code><a href="#topic+abfir">abfir</a>()</code>,
<code><a href="#topic+enkf">enkf</a>()</code>,
<code><a href="#topic+girf">girf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
# Create a simulation of a Brownian motion
b &lt;- bm(U=4, N=2)

# Run BPF with the specified number of units per block
bpfilterd_b1 &lt;- bpfilter(b, Np = 10, block_size = 2)

# Run BPF with the specified partition
bpfilterd_b2 &lt;- bpfilter(b,
                         Np = 10,
                         block_list = list(c(1,2),c(3,4)) )

# Get a likelihood estimate
logLik(bpfilterd_b2)

## End(Not run)

</code></pre>

<hr>
<h2 id='city_data_UK'>City data in the United Kingdom</h2><span id='topic+city_data_UK'></span>

<h3>Description</h3>

<p>Population and birth information about cities in England and Wales during the measles pre-vaccine era.
</p>


<h3>Details</h3>

<p>Data includes births and population at bi-weekly observations from 40 cities and towns.
</p>


<h3>Value</h3>

<p>a &lsquo;data.frame&rsquo; of the 40 largest cities and towns in the UK and Wales, their latitude, longitude and
mean population during the measles pre-vaccine period.
</p>


<h3>References</h3>

<p>Dalziel, Benjamin D. et al. (2016) Persistent chaos of measles epidemics in the prevaccination United States caused by a small change in seasonal transmission patterns. <em>PLoS Computational Biology</em>, <b>12(2)</b>, e1004655. <a href="https://doi.org/10.5061/dryad.r4q34">doi:10.5061/dryad.r4q34</a>
</p>


<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+measlesUK">measlesUK</a></code>
</p>

<hr>
<h2 id='conc'>Concatenate</h2><span id='topic+conc'></span><span id='topic+conc+2CSpatPomp-method'></span><span id='topic+conc+2CBpfilter-method'></span><span id='topic+conc+2CIbpf-method'></span>

<h3>Description</h3>

<p>Internal methods to concatenate objects into useful listie.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'SpatPomp'
conc(...)

## S4 method for signature 'Bpfilter'
conc(...)

## S4 method for signature 'Ibpf'
conc(...)
</code></pre>


<h3>Details</h3>

<p>Not exported.
</p>

<hr>
<h2 id='concat'>Concatenate</h2><span id='topic+concat'></span><span id='topic+c'></span><span id='topic+c.SpatPomp'></span>

<h3>Description</h3>

<p>Concatenate two or more &lsquo;pomp&rsquo; objects into a list-like &lsquo;listie&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SpatPomp'
c(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="concat_+3A_...">...</code></td>
<td>
<p>elements to be recursively combined into a &lsquo;listie&rsquo;</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>concat</code> applied to one or more &lsquo;pomp&rsquo; objects or lists of &lsquo;pomp&rsquo; objects converts the list into a &lsquo;listie&rsquo;.
In particular, <code>concat(A,B,C)</code> is equivalent to <code>do.call(c,unlist(list(A,B,C)))</code>.
</p>

<hr>
<h2 id='dunit_measure'>dunit_measure
<code>dunit_measure</code> evaluates the unit measurement density of a unit's observation given the entire state</h2><span id='topic+dunit_measure'></span><span id='topic+dunit_measure-spatPomp'></span><span id='topic+dunit_measure+2CspatPomp-method'></span>

<h3>Description</h3>

<p>dunit_measure
<code>dunit_measure</code> evaluates the unit measurement density of a unit's observation given the entire state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spatPomp'
dunit_measure(object, y, x, unit, time, params, log = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dunit_measure_+3A_object">object</code></td>
<td>
<p>An object of class <code>spatPomp</code></p>
</td></tr>
<tr><td><code id="dunit_measure_+3A_y">y</code></td>
<td>
<p>A U by 1 matrix of observations for all units</p>
</td></tr>
<tr><td><code id="dunit_measure_+3A_x">x</code></td>
<td>
<p>A state vector for all units</p>
</td></tr>
<tr><td><code id="dunit_measure_+3A_unit">unit</code></td>
<td>
<p>The unit for which to evaluate the unit measurement density</p>
</td></tr>
<tr><td><code id="dunit_measure_+3A_time">time</code></td>
<td>
<p>The time for which to evaluate the unit measurement density</p>
</td></tr>
<tr><td><code id="dunit_measure_+3A_params">params</code></td>
<td>
<p>parameters at which to evaluate the unit measurement density</p>
</td></tr>
<tr><td><code id="dunit_measure_+3A_log">log</code></td>
<td>
<p>logical; should the density be returned on log scale?</p>
</td></tr>
<tr><td><code id="dunit_measure_+3A_...">...</code></td>
<td>
<p>additional arguments will be ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A class &lsquo;matrix&rsquo; with the unit measurement density for spatial unit <code>unit</code>
corresponding to the corresponding measurement in <code>y</code> and states in <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
b &lt;- bm(U=3)
s &lt;- states(b)[,1,drop=FALSE]
rownames(s) -&gt; rn
dim(s) &lt;- c(3,1,1)
dimnames(s) &lt;- list(variable=rn, rep=NULL)
p &lt;- coef(b); names(p) -&gt; rnp
dim(p) &lt;- c(length(p),1); dimnames(p) &lt;- list(param=rnp)
o &lt;- obs(b)[,1,drop=FALSE]
dunit_measure(b, y=o, x=s, unit=1, time=1, params=p)

## End(Not run)

</code></pre>

<hr>
<h2 id='enkf'>Generalized Ensemble Kalman filter (EnKF)</h2><span id='topic+enkf'></span><span id='topic+enkf+2CANY-method'></span><span id='topic+enkf+2Cmissing-method'></span><span id='topic+enkf-spatPomp'></span><span id='topic+enkf+2CspatPomp-method'></span>

<h3>Description</h3>

<p>A function to perform filtering using the ensemble Kalman filter of Evensen, G. (1994).
This function is generalized to allow for an measurement covariance matrix that varies over time.
This is useful if the measurement model varies with the state.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spatPomp'
enkf(data, Np, ..., verbose = getOption("verbose", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enkf_+3A_data">data</code></td>
<td>
<p>A <code>spatPomp</code> object.</p>
</td></tr>
<tr><td><code id="enkf_+3A_np">Np</code></td>
<td>
<p>The number of Monte Carlo particles used to approximate the filter distribution.</p>
</td></tr>
<tr><td><code id="enkf_+3A_...">...</code></td>
<td>
<p>If a <code>params</code> argument is specified, <code>abf</code> will estimate the likelihood at that parameter set instead of at <code>coef(object)</code>.</p>
</td></tr>
<tr><td><code id="enkf_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, messages updating the user on progress will be printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lsquo;enkfd_spatPomp&rsquo; that contains the estimate of the log likelihood
(via the <code>loglik</code> attribute), algorithmic parameters used to run <code>enkf()</code>. Also included
are estimated filter means, prediction means and forecasts that are generated during an <code>enkf()</code> run.
</p>


<h3>References</h3>

<p>G. Evensen. Sequential data assimilation with a nonlinear quasi-geostrophic model using Monte Carlo methods to forecast error statistics. <em>Journal of Geophysical Research: Oceans</em> <b>99</b>, 10143&ndash;10162, 1994.
</p>
<p>G. Evensen. <em>Data assimilation: the ensemble Kalman filter</em>. Springer-Verlag, 2009.
</p>
<p>J.L. Anderson. An Ensemble Adjustment Kalman Filter for Data Assimilation. <em>Monthly Weather Review</em> <b>129</b>, 2884&ndash;2903, 2001.
</p>


<h3>See Also</h3>

<p><code>ienkf()</code>, <code>igirf</code>, <code>iubf</code>, <code>ibpf</code>
</p>
<p>Other likelihood evaluation algorithms: 
<code><a href="#topic+abf">abf</a>()</code>,
<code><a href="#topic+abfir">abfir</a>()</code>,
<code><a href="#topic+bpfilter">bpfilter</a>()</code>,
<code><a href="#topic+girf">girf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
# Create a simulation of a Brownian motion
b &lt;- bm(U=2, N=5)

# Run EnKF
enkfd_bm &lt;- enkf(b, Np = 20)

# Get a likelihood estimate
logLik(enkfd_bm)

## End(Not run)
</code></pre>

<hr>
<h2 id='eunit_measure'>eunit_measure</h2><span id='topic+eunit_measure'></span><span id='topic+eunit_measure-spatPomp'></span><span id='topic+eunit_measure+2CspatPomp-method'></span>

<h3>Description</h3>

<p><code>eunit_measure</code> evaluates the expectation of a unit's observation given the entire state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spatPomp'
eunit_measure(object, x, unit, time, params, Np = 1, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eunit_measure_+3A_object">object</code></td>
<td>
<p>An object of class <code>spatPomp</code></p>
</td></tr>
<tr><td><code id="eunit_measure_+3A_x">x</code></td>
<td>
<p>A state vector for all units</p>
</td></tr>
<tr><td><code id="eunit_measure_+3A_unit">unit</code></td>
<td>
<p>The unit for which to evaluate the expectation</p>
</td></tr>
<tr><td><code id="eunit_measure_+3A_time">time</code></td>
<td>
<p>The time for which to evaluate the expectation</p>
</td></tr>
<tr><td><code id="eunit_measure_+3A_params">params</code></td>
<td>
<p>parameters at which to evaluate the unit expectation</p>
</td></tr>
<tr><td><code id="eunit_measure_+3A_np">Np</code></td>
<td>
<p>numeric; defaults to 1 and the user need not change this</p>
</td></tr>
<tr><td><code id="eunit_measure_+3A_log">log</code></td>
<td>
<p>logical; should the density be returned on log scale?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A class &lsquo;matrix&rsquo; with the unit expected observation for spatial unit <code>unit</code>
corresponding to the corresponding states in <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
b &lt;- bm(U=3)
s &lt;- states(b)[,1,drop=FALSE]
rownames(s) -&gt; rn
dim(s) &lt;- c(3,1,1)
dimnames(s) &lt;- list(variable=rn, rep=NULL)
p &lt;- coef(b); names(p) -&gt; rnp
dim(p) &lt;- c(length(p),1); dimnames(p) &lt;- list(param=rnp)
o &lt;- obs(b)[,1,drop=FALSE]
eunit_measure(b, x=s, unit=2, time=1, params=p)

## End(Not run)

</code></pre>

<hr>
<h2 id='expand_params'>Book-keeping functions for working with expanded parameters</h2><span id='topic+expand_params'></span><span id='topic+contract_params+2C'></span><span id='topic+mean_by_unit+2C'></span><span id='topic+expand_params+2C'></span><span id='topic+param_formats'></span><span id='topic+contract_params'></span><span id='topic+mean_by_unit'></span>

<h3>Description</h3>

<p>Iterated block particle filters require shared parameters to be
expanded into having a value at each unit. expand_params, contract_params
and mean_by_unit provide tools for moving between representations.
For a unit-specific expansion of a shared parameter, all the values for
different units should be the same, and mean_by_unit ensures this
by taking an average.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_params(params, expandedParNames, U)

contract_params(params, expandedParNames, U, average = FALSE)

mean_by_unit(params, expandedParNames, U)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_params_+3A_params">params</code></td>
<td>
<p>Input parameter vector</p>
</td></tr>
<tr><td><code id="expand_params_+3A_expandedparnames">expandedParNames</code></td>
<td>
<p>character vector of parameters that are, or
should be, expanded. These names should have no numerical suffix 1:U.</p>
</td></tr>
<tr><td><code id="expand_params_+3A_u">U</code></td>
<td>
<p>Number of units</p>
</td></tr>
<tr><td><code id="expand_params_+3A_average">average</code></td>
<td>
<p>Logical value for whether contract_params should
average unequal values</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions assume that expanded parameters have names ending
in &quot;1&quot; through &quot;U&quot;, where U is the number of units. Contracted parameters, 
meaning any parameter that is not expanded, should have a name ending
in &quot;1&quot;. This numerical suffix convention is useful for writing model-building 
code that allows parameters to be either expanded or contracted.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+arma_benchmark">arma_benchmark</a>()</code>
</p>

<hr>
<h2 id='gbm'>Geometric Brownian motion spatPomp simulator</h2><span id='topic+gbm'></span>

<h3>Description</h3>

<p>Generate a spatPomp object representing a <code>U</code>-dimensional
geometric Brownian motion with spatial correlation decaying geometrically with
distance around a circle. The model is defined in continuous time, but
an Euler approximation is used for this numerical implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gbm(U = 5, N = 100, delta_t = 0.1, IVP_values = 1, delta_obs = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gbm_+3A_u">U</code></td>
<td>
<p>A length-one numeric signifying dimension of the process.</p>
</td></tr>
<tr><td><code id="gbm_+3A_n">N</code></td>
<td>
<p>A length-one numeric signifying the number of time steps to evolve the process.</p>
</td></tr>
<tr><td><code id="gbm_+3A_delta_t">delta_t</code></td>
<td>
<p>process simulations are performed every <code>delta_t</code> time units</p>
</td></tr>
<tr><td><code id="gbm_+3A_ivp_values">IVP_values</code></td>
<td>
<p>initial value parameters for the latent states</p>
</td></tr>
<tr><td><code id="gbm_+3A_delta_obs">delta_obs</code></td>
<td>
<p>observations occur every <code>delta_obs</code> time units</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lsquo;spatPomp&rsquo; representing a simulation from a <code>U</code>-dimensional
geometric Brownian motion
</p>


<h3>Author(s)</h3>

<p>Kidus Asfaw
</p>


<h3>References</h3>

<p>Asfaw, K. T. (2021). Simulation-based Inference for Partially Observed Markov Process Models with Spatial Coupling. University of Michigan Doctoral dissertation. <a href="https://doi.org/10.7302/2751">doi:10.7302/2751</a>
</p>


<h3>See Also</h3>

<p>Other spatPomp model generators: 
<code><a href="#topic+bm">bm</a>()</code>,
<code><a href="#topic+bm2">bm2</a>()</code>,
<code><a href="#topic+he10">he10</a>()</code>,
<code><a href="#topic+lorenz">lorenz</a>()</code>,
<code><a href="#topic+measles">measles</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
g &lt;- gbm(U=4, N=20)
# See all the model specifications of the object
spy(g)

## End(Not run)

</code></pre>

<hr>
<h2 id='girf'>Guided intermediate resampling filter (GIRF)</h2><span id='topic+girf'></span><span id='topic+girf-missing'></span><span id='topic+girf+2Cmissing-method'></span><span id='topic+girf-ANY'></span><span id='topic+girf+2CANY-method'></span><span id='topic+girf-spatPomp'></span><span id='topic+girf+2CspatPomp-method'></span><span id='topic+girf-girfd_spatPomp'></span><span id='topic+girf+2Cgirfd_spatPomp-method'></span>

<h3>Description</h3>

<p>An implementation of the algorithm of Park and Ionides (2020),
following the pseudocode in Asfaw et al. (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing'
girf(object, ...)

## S4 method for signature 'ANY'
girf(object, ...)

## S4 method for signature 'spatPomp'
girf(
  object,
  Np,
  Ninter,
  lookahead = 1,
  Nguide,
  kind = c("bootstrap", "moment"),
  tol,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'girfd_spatPomp'
girf(
  object,
  Np,
  Ninter,
  lookahead,
  Nguide,
  kind = c("bootstrap", "moment"),
  tol,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="girf_+3A_object">object</code></td>
<td>
<p>A <code>spatPomp</code> object.</p>
</td></tr>
<tr><td><code id="girf_+3A_...">...</code></td>
<td>
<p>If a <code>params</code> argument is specified, <code>abf</code> will estimate the likelihood at that parameter set instead of at <code>coef(object)</code>.</p>
</td></tr>
<tr><td><code id="girf_+3A_np">Np</code></td>
<td>
<p>The number of particles used within each replicate for the adapted simulations.</p>
</td></tr>
<tr><td><code id="girf_+3A_ninter">Ninter</code></td>
<td>
<p>the number of intermediate resampling time points. By default, this is set equal to the number of units.</p>
</td></tr>
<tr><td><code id="girf_+3A_lookahead">lookahead</code></td>
<td>
<p>The number of future observations included in the guide function.</p>
</td></tr>
<tr><td><code id="girf_+3A_nguide">Nguide</code></td>
<td>
<p>The number of simulations used to estimate state process uncertainty for each particle.</p>
</td></tr>
<tr><td><code id="girf_+3A_kind">kind</code></td>
<td>
<p>One of two types of guide function construction. Defaults to <code>'bootstrap'</code>. See Park and Ionides (2020) for more details.</p>
</td></tr>
<tr><td><code id="girf_+3A_tol">tol</code></td>
<td>
<p>If all of the guide function evaluations become too small (beyond floating-point precision limits), we set them to this value.</p>
</td></tr>
<tr><td><code id="girf_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, messages updating the user on progress will be printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Upon successful completion, <code>girf()</code> returns an object of class
&lsquo;girfd_spatPomp&rsquo; which contains the algorithmic parameters that were used to
run <code>girf()</code> and the resulting log likelihood estimate.
</p>


<h3>Methods</h3>

<p>The following methods are available for such an object:
</p>

<dl>
<dt><code><a href="#topic+logLik">logLik</a></code></dt><dd><p> yields an unbiased estimate of the log-likelihood of the data under the model. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kidus Asfaw
</p>


<h3>References</h3>

<p>Park, J. and Ionides, E. L. (2020) Inference on high-dimensional implicit dynamic models using a guided intermediate resampling filter. <em>Statistics and Computing</em>, <a href="https://doi.org/10.1007/s11222-020-09957-3">doi:10.1007/s11222-020-09957-3</a>
</p>
<p>Asfaw, K., Park, J., Ho, A., King, A. A., and Ionides, E. L. (2020) Partially observed Markov processes with spatial structure via the R package spatPomp. <em>ArXiv</em>: 2101.01157. <a href="https://doi.org/10.48550/arXiv.2101.01157">doi:10.48550/arXiv.2101.01157</a>
</p>


<h3>See Also</h3>

<p>likelihood maximization algorithms: <code>ienkf()</code>, <code>igirf()</code>, <code>iubf()</code>, <code>ibpf()</code>
</p>
<p>Other likelihood evaluation algorithms: 
<code><a href="#topic+abf">abf</a>()</code>,
<code><a href="#topic+abfir">abfir</a>()</code>,
<code><a href="#topic+bpfilter">bpfilter</a>()</code>,
<code><a href="#topic+enkf">enkf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
#
# Create a simulation of a Brownian motion
b &lt;- bm(U=2, N=5)

# Run GIRF
girfd_bm &lt;- girf(b,
                 Np = 10,
                 Ninter = length(unit_names(b)),
                 lookahead = 1,
                 Nguide = 10
)
# Get the likelihood estimate from GIRF
logLik(girfd_bm)

# Compare with the likelihood estimate from particle filter
pfd_bm &lt;- pfilter(b, Np = 10)
logLik(pfd_bm)

## End(Not run)
</code></pre>

<hr>
<h2 id='he10'>Measles in UK: spatPomp generator with shared or unit-specific parameters</h2><span id='topic+he10'></span>

<h3>Description</h3>

<p>Generate a spatPomp object for measles adding spatial coupling to
The model and data from He et al. (2010) with gravity transport as
in Park and Ionides (2020). Other transport models may be added in future.
The data in the object matches He et al. (2010). The model matches
that analysis in the specific case where there is no coupling and all
parameters are unit-specific.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>he10(
  U = 6,
  dt = 2/365,
  Tmax = 1964,
  expandedParNames = c("alpha", "iota", "R0", "cohort", "amplitude", "gamma", "sigma",
    "sigmaSE", "rho", "psi", "g", "S_0", "E_0", "I_0"),
  basic_params = c(alpha = 1, iota = 0, R0 = 30, cohort = 0, amplitude = 0.5, gamma = 52,
    sigma = 52, mu = 0.02, sigmaSE = 0.15, rho = 0.5, psi = 0.15, g = 400, S_0 = 0.032,
    E_0 = 5e-05, I_0 = 4e-05),
  towns_selected = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="he10_+3A_u">U</code></td>
<td>
<p>A length-one numeric signifying the number of cities to be
represented in the spatPomp object. Default U=20 gives all the towns
studied by He et al., the 10 largest and 10 selected smaller towns.</p>
</td></tr>
<tr><td><code id="he10_+3A_dt">dt</code></td>
<td>
<p>a numeric (in unit of years) that is used as the Euler time-increment for simulating measles data.</p>
</td></tr>
<tr><td><code id="he10_+3A_tmax">Tmax</code></td>
<td>
<p>Upper time for the window used to construct the object. The lower time is fixed at 1950.0. The default value matches He et al (2010).</p>
</td></tr>
<tr><td><code id="he10_+3A_expandedparnames">expandedParNames</code></td>
<td>
<p>specifies the names of parameters which take unit-specific values. Remaining parameters take a single, shared value for all units.</p>
</td></tr>
<tr><td><code id="he10_+3A_basic_params">basic_params</code></td>
<td>
<p>A candidate parameter vector in the basic format, i.e., no unit-specific parameters or unit-related name extensions.</p>
</td></tr>
<tr><td><code id="he10_+3A_towns_selected">towns_selected</code></td>
<td>
<p>A numeric vector of towns to be modeled. Defaults 
to 1:U, with cities ranked by decreasing population and 1 being London.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code for this spatPomp has duplication with measles(), but in future
the two models may diverge. The measles() spatPomp is a simplified
situation useful for testing some methods. However, measles() does not
permit unit-specific parameters, which he10() allows. Also, 
the structure of this spatPomp is compatible with the spatiotemporal 
iterated filtering algorithm ibpf(). This requires shared parameters to
be represented with a value for each unit, which should be the same for each
unit in a valid model instance but may vary between units while optimizing.
</p>


<h3>Value</h3>

<p>An object of class &lsquo;spatPomp&rsquo; representing a <code>U</code>-dimensional spatially coupled measles POMP model.
</p>


<h3>Relationship to published analysis</h3>

<p>The model generator <code>he10()</code> differs from <code>measles()</code> in some details necessitated to reproduce the results of He et al (2010).
The <code>measles()</code> model follows the decision of Park and Ionides (2020) and Ionides et al (2021) to apply the mixing exponent <code class="reqn">\alpha_u</code> to <code class="reqn">(I_u/P_u)</code> rather than just to <code class="reqn">I_u</code>.
<code>he10()</code> does this for the infections arising from individuals traveling to another town (which don't arise for the panel model of He et al (2010)).
However, for infections arising within a city, in order to reproduce the results of He et al (2010), <code>he10()</code> uses <code class="reqn">(I_u^{\alpha_u}/P_u)</code>.
This is not fully documented in the text of Ionides et al (2022).
Models fitted to data have <code class="reqn">alpha_u</code> close to <code class="reqn">1</code>, so this issue may be negligible in practice.
</p>
<p>Another discrepancy between the <code>he10()</code> code and the mathematical model written by Ionides et al (2022) arises in whether individuals traveling from <code class="reqn">u</code> to <code class="reqn">v</code> use mixing exponent <code class="reqn">\alpha_u</code> or <code class="reqn">\alpha_v</code>.
Ionides et al (2022) wrote <code class="reqn">u</code> but the code used implemented <code class="reqn">v</code>.
The implementation in <code>he10()</code> matches the implementation of Ionides et al (2022) and so uses <code class="reqn">v</code>.
</p>
<p>It might seem surprising that immigrant infections affect only the first term in the expression for <code class="reqn">\mu_{SE}</code> in Ionides et al (2022), and in the corresponding <code>he10()</code> code.
This immigration term is needed in the first term to make the model of He et al (2010) a proper sub-model, when coupling is removed by setting the gravitational constant parameter equal to zero.
When this constant is allowed to be positive, the role of immigrant infections transmitting to traveling individuals is anticipated to be a negligible, second-order effect which has been omitted from the model.
</p>


<h3>Note</h3>

<p>This function goes through a typical workflow of constructing
a typical spatPomp object (1-4 below). This allows the user to have a
file that replicates the exercise of model building as well as function
that creates a typical nonlinear model in epidemiology in case they want
to test a new inference methodology. We purposely do not modularize this
function because it is not an operational piece of the package and is
instead useful as an example.<br />
1. Getting a measurements data.frame with columns for times,
spatial units and measurements.<br />
2. Getting a covariates data.frame with columns for times,
spatial units and covariate data.<br />
3. Constructing model components (latent state initializer,
latent state transition simulator and measurement model). Depending
on the methods used, the user may have to supply a vectorfield to
be integrated that represents the deterministic skeleton of the latent
process.<br />
4. Bringing all the data and model components together to form a
spatPomp object via a call to spatPomp().
</p>


<h3>Author(s)</h3>

<p>Edward L. Ionides
</p>


<h3>References</h3>

<p>Asfaw, K., Park, J., Ho, A., King, A. A., and Ionides, E. L. (2020) Partially observed Markov processes with spatial structure via the R package spatPomp. <em>ArXiv</em>: 2101.01157. <a href="https://doi.org/10.48550/arXiv.2101.01157">doi:10.48550/arXiv.2101.01157</a>
</p>
<p>He, D., Ionides, E. L., and King, A. A. (2010). Plug-and-play inference for disease dynamics: measles in large and small populations as a case study. <em>Journal of the Royal Society Interface</em>, <b>7</b>(43), 271-283. <a href="https://doi.org/10.1098/rsif.2009.0151">doi:10.1098/rsif.2009.0151</a>
</p>
<p>Ionides, E. L., Asfaw, K., Park, J., and King, A. A. (2021). Bagged filters for partially observed interacting systems. <em>Journal of the American Statistical Association</em>, <a href="https://doi.org/10.1080/01621459.2021.1974867">doi:10.1080/01621459.2021.1974867</a>
</p>
<p>Ionides, E. L., Ning, N., and Wheeler, J. (2022). An iterated block particle filter for inference on coupled dynamic systems with shared and unit-specific parameters. <em>Statistica Sinica</em>, to appear. <a href="https://doi.org/10.48550/arXiv.2206.03837">doi:10.48550/arXiv.2206.03837</a>
</p>
<p>Park, J. and Ionides, E. L. (2020) Inference on high-dimensional implicit dynamic models using a guided intermediate resampling filter. <em>Statistics and Computing</em>, <a href="https://doi.org/10.1007/s11222-020-09957-3">doi:10.1007/s11222-020-09957-3</a>
</p>


<h3>See Also</h3>

<p><code>he10coordinates</code>, <code>he10measles</code>, <code>he10mle</code>, <code>he10demography</code>
</p>
<p>Other spatPomp model generators: 
<code><a href="#topic+bm">bm</a>()</code>,
<code><a href="#topic+bm2">bm2</a>()</code>,
<code><a href="#topic+gbm">gbm</a>()</code>,
<code><a href="#topic+lorenz">lorenz</a>()</code>,
<code><a href="#topic+measles">measles</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
m &lt;- he10(U = 5)
# See all the model specifications of the object
spy(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='he10coordinates'>City data in the United Kingdom</h2><span id='topic+he10coordinates'></span>

<h3>Description</h3>

<p>Longitude and lattitude for the 20 towns in England and Wales studied by
He et al (2010).
</p>


<h3>Value</h3>

<p>a &lsquo;data.frame&rsquo; of longitude and lattitude for each town.
</p>


<h3>References</h3>

<p>He, D., Ionides, E. L., and King, A. A. (2010). Plug-and-play inference for disease dynamics: measles in large and small populations as a case study. <em>Journal of the Royal Society Interface</em>, <b>7</b>(43), 271-283. <a href="https://doi.org/10.1098/rsif.2009.0151">doi:10.1098/rsif.2009.0151</a>
</p>


<h3>See Also</h3>

<p>Other datasets he10: 
<code><a href="#topic+he10demography">he10demography</a></code>,
<code><a href="#topic+he10measles">he10measles</a></code>,
<code><a href="#topic+he10mle">he10mle</a></code>
</p>

<hr>
<h2 id='he10demography'>Demographic data for 20 towns in the United Kingdom</h2><span id='topic+he10demography'></span>

<h3>Description</h3>

<p>Population and birth information for some towns in England and Wales
during the measles pre-vaccine era.
</p>


<h3>Details</h3>

<p>Data are annual statistics for the 20 towns analyzed by He et al (2010).
</p>


<h3>Value</h3>

<p>a &lsquo;data.frame&rsquo; of with variables town, year, pop and births.
</p>


<h3>References</h3>

<p>He, D., Ionides, E. L., and King, A. A. (2010). Plug-and-play inference for disease dynamics: measles in large and small populations as a case study. <em>Journal of the Royal Society Interface</em>, <b>7</b>(43), 271-283. <a href="https://doi.org/10.1098/rsif.2009.0151">doi:10.1098/rsif.2009.0151</a>
</p>


<h3>See Also</h3>

<p>Other datasets he10: 
<code><a href="#topic+he10coordinates">he10coordinates</a></code>,
<code><a href="#topic+he10measles">he10measles</a></code>,
<code><a href="#topic+he10mle">he10mle</a></code>
</p>

<hr>
<h2 id='he10measles'>Measles in the United Kingdom</h2><span id='topic+he10measles'></span>

<h3>Description</h3>

<p>Measles case data from various cities and towns in England and Wales during the pre-vaccine era.
</p>


<h3>Details</h3>

<p>Data are weekly case counts for the 20 towns analyzed by He et al (2010).
</p>


<h3>Value</h3>

<p>a &lsquo;data.frame&rsquo; of reported measles cases for 20 towns,
analyzed by He et al (2010).
</p>


<h3>References</h3>

<p>He, D., Ionides, E. L., and King, A. A. (2010). Plug-and-play inference for disease dynamics: measles in large and small populations as a case study. <em>Journal of the Royal Society Interface</em>, <b>7</b>(43), 271-283. <a href="https://doi.org/10.1098/rsif.2009.0151">doi:10.1098/rsif.2009.0151</a>
</p>


<h3>See Also</h3>

<p>Other datasets he10: 
<code><a href="#topic+he10coordinates">he10coordinates</a></code>,
<code><a href="#topic+he10demography">he10demography</a></code>,
<code><a href="#topic+he10mle">he10mle</a></code>
</p>

<hr>
<h2 id='he10mle'>Measles in the United Kingdom: MLE from He et al (2010)</h2><span id='topic+he10mle'></span>

<h3>Description</h3>

<p>Maximum likelihood estimate for fitting a susceptible-exposed-infected-
recovered model to the measles case report data analyzed by He et al (2010).
The values are similar, but not identical, to those reported by He et al.
</p>


<h3>Value</h3>

<p>a &lsquo;data.frame&rsquo; containing the estimated parameters.
</p>


<h3>References</h3>

<p>He, D., Ionides, E. L., and King, A. A. (2010). Plug-and-play inference for disease dynamics: measles in large and small populations as a case study. <em>Journal of the Royal Society Interface</em>, <b>7</b>(43), 271-283. <a href="https://doi.org/10.1098/rsif.2009.0151">doi:10.1098/rsif.2009.0151</a>
</p>


<h3>See Also</h3>

<p>Other datasets he10: 
<code><a href="#topic+he10coordinates">he10coordinates</a></code>,
<code><a href="#topic+he10demography">he10demography</a></code>,
<code><a href="#topic+he10measles">he10measles</a></code>
</p>

<hr>
<h2 id='ibpf'>Iterated block particle filter (IBPF)</h2><span id='topic+ibpf'></span><span id='topic+ibpf-missing'></span><span id='topic+ibpf+2Cmissing-method'></span><span id='topic+ibpf-ANY'></span><span id='topic+ibpf+2CANY-method'></span><span id='topic+ibpf-spatPomp'></span><span id='topic+ibpf+2CspatPomp-method'></span><span id='topic+ibpf-ibpfd_spatPomp'></span><span id='topic+ibpf+2Cibpfd_spatPomp-method'></span><span id='topic+ibpf-bpfd_spatPomp'></span><span id='topic+ibpf+2Cbpfilterd_spatPomp-method'></span>

<h3>Description</h3>

<p>An iterated block particle filter, for both shared and unit-specific
parameters. We require that the spatPomp has
been constructed to have a unit-specific parameter &quot;thetau&quot;
for unit u corresponding to an estimated parameter &quot;theta&quot;, whether
theta is shared or unit-specific. This permits IBPF
to implement a spatiotemporal random walk to estimate theta.
We require that rw.sd is positive for, and only for, all parameters
of the form &quot;thetau&quot; if &quot;theta&quot; is listed in sharedParNames or
unitParNames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing'
ibpf(data, ...)

## S4 method for signature 'ANY'
ibpf(data, ...)

## S4 method for signature 'spatPomp'
ibpf(
  data,
  Nbpf,
  Np,
  rw.sd,
  sharedParNames,
  unitParNames,
  cooling.type = "geometric",
  cooling.fraction.50,
  block_size,
  block_list,
  spat_regression,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'ibpfd_spatPomp'
ibpf(
  data,
  Nbpf,
  Np,
  rw.sd,
  sharedParNames,
  unitParNames,
  cooling.type = "geometric",
  cooling.fraction.50,
  block_size,
  block_list,
  spat_regression,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'bpfilterd_spatPomp'
ibpf(
  data,
  Nbpf,
  Np,
  rw.sd,
  sharedParNames,
  unitParNames,
  cooling.type = "geometric",
  cooling.fraction.50,
  block_size,
  block_list,
  spat_regression,
  ...,
  verbose = getOption("verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ibpf_+3A_data">data</code></td>
<td>
<p>either a data frame holding the time series data,
or an object of class &lsquo;pomp&rsquo;,
i.e., the output of another <span class="pkg">pomp</span> calculation.
Internally, <code>data</code> will be coerced to an array with storage-mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="ibpf_+3A_...">...</code></td>
<td>
<p>If a <code>params</code> argument is specified, <code>bpfilter</code> will estimate the likelihood at that parameter set instead of at <code>coef(object)</code>.</p>
</td></tr>
<tr><td><code id="ibpf_+3A_nbpf">Nbpf</code></td>
<td>
<p>the number of iterations of perturbed BPF.</p>
</td></tr>
<tr><td><code id="ibpf_+3A_np">Np</code></td>
<td>
<p>The number of particles used within each replicate for the adapted simulations.</p>
</td></tr>
<tr><td><code id="ibpf_+3A_rw.sd">rw.sd</code></td>
<td>
<p>specification of the magnitude of the random-walk perturbations that will be applied to some or all model parameters.
Parameters that are to be estimated should have positive perturbations specified here.
The specification is given using the <code><a href="pomp.html#topic+rw.sd">rw.sd</a></code> function, which creates a list of unevaluated expressions.
The latter are evaluated in a context where the model time variable is defined (as <code>time</code>).
The expression <code>ivp(s)</code> can be used in this context as shorthand for </p>
<pre>ifelse(time==time[1],s,0).</pre>
<p>Likewise, <code>ivp(s,lag)</code> is equivalent to </p>
<pre>ifelse(time==time[lag],s,0).</pre>
<p>See below for some examples.
</p>
<p>The perturbations that are applied are normally distributed with the specified s.d.
If parameter transformations have been supplied, then the perturbations are applied on the transformed (estimation) scale.</p>
</td></tr>
<tr><td><code id="ibpf_+3A_sharedparnames">sharedParNames</code></td>
<td>
<p>estimated parameters that are equal for each unit.</p>
</td></tr>
<tr><td><code id="ibpf_+3A_unitparnames">unitParNames</code></td>
<td>
<p>estimated parameters that are different for
each unit.</p>
</td></tr>
<tr><td><code id="ibpf_+3A_cooling.type">cooling.type</code>, <code id="ibpf_+3A_cooling.fraction.50">cooling.fraction.50</code></td>
<td>
<p>specifications for the cooling schedule,
i.e., the manner and rate with which the intensity of the parameter perturbations is reduced with successive filtering iterations.
<code>cooling.type</code> specifies the nature of the cooling schedule.
See below (under &ldquo;Specifying the perturbations&rdquo;) for more detail.</p>
</td></tr>
<tr><td><code id="ibpf_+3A_block_size">block_size</code></td>
<td>
<p>The number of spatial units per block. If this is provided, the method subdivides units approximately evenly
into blocks with size <code>block_size</code>.</p>
</td></tr>
<tr><td><code id="ibpf_+3A_block_list">block_list</code></td>
<td>
<p>List that specifies an exact partition of the spatial units. Each partition element, or block, is
an integer vector of neighboring units.</p>
</td></tr>
<tr><td><code id="ibpf_+3A_spat_regression">spat_regression</code></td>
<td>
<p>fraction of each extended parameter regressed toward the unit mean. Not required when all parameters are unit-specific.</p>
</td></tr>
<tr><td><code id="ibpf_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, messages updating the user on progress will be printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Upon successful completion, <code>ibpf</code> returns an object of class
&lsquo;ibpfd_spatPomp&rsquo;.
</p>


<h3>Methods</h3>

<p>The following methods are available for such an object:
</p>

<dl>
<dt><code><a href="stats.html#topic+coef">coef</a></code></dt><dd><p> gives the Monte Carlo estimate of the maximum likelihood. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Edward L. Ionides
</p>


<h3>References</h3>

<p>Ionides, E. L., Ning, N., and Wheeler, J. (2022). An iterated block particle filter for inference on coupled dynamic systems with shared and unit-specific parameters. <em>Statistica Sinica</em>, to appear. <a href="https://doi.org/10.48550/arXiv.2206.03837">doi:10.48550/arXiv.2206.03837</a>
</p>


<h3>See Also</h3>

<p>likelihood evaluation algorithms: <code>girf()</code>, <code>enkf()</code>, <code>bpfilter()</code>, <code>abf()</code>, <code>abfir()</code>
</p>
<p>Other likelihood maximization algorithms: 
<code><a href="#topic+ienkf">ienkf</a>()</code>,
<code><a href="#topic+igirf">igirf</a>()</code>,
<code><a href="#topic+iubf">iubf</a>()</code>
</p>

<hr>
<h2 id='ienkf'>Iterated ensemble Kalman filter (IEnKF)</h2><span id='topic+ienkf'></span><span id='topic+ienkf-spatPomp'></span><span id='topic+ienkf+2CspatPomp-method'></span>

<h3>Description</h3>

<p>An implementation of a parameter estimation algorithm that uses
the ensemble Kalman filter (Evensen, G. (1994)) to perform the filtering step in the
parameter-perturbed iterated filtering scheme of Ionides et al. (2015)
following the pseudocode in Asfaw, et al. (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spatPomp'
ienkf(
  data,
  Nenkf = 1,
  rw.sd,
  cooling.type = c("geometric", "hyperbolic"),
  cooling.fraction.50,
  Np,
  ...,
  verbose = getOption("verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ienkf_+3A_data">data</code></td>
<td>
<p>an object of class <code>spatPomp</code></p>
</td></tr>
<tr><td><code id="ienkf_+3A_nenkf">Nenkf</code></td>
<td>
<p>number of iterations of perturbed EnKF.</p>
</td></tr>
<tr><td><code id="ienkf_+3A_rw.sd">rw.sd</code></td>
<td>
<p>specification of the magnitude of the random-walk perturbations that will be applied to some or all model parameters.
Parameters that are to be estimated should have positive perturbations specified here.
The specification is given using the <code><a href="pomp.html#topic+rw.sd">rw.sd</a></code> function, which creates a list of unevaluated expressions.
The latter are evaluated in a context where the model time variable is defined (as <code>time</code>).
The expression <code>ivp(s)</code> can be used in this context as shorthand for </p>
<pre>ifelse(time==time[1],s,0).</pre>
<p>Likewise, <code>ivp(s,lag)</code> is equivalent to </p>
<pre>ifelse(time==time[lag],s,0).</pre>
<p>See below for some examples.
</p>
<p>The perturbations that are applied are normally distributed with the specified s.d.
If parameter transformations have been supplied, then the perturbations are applied on the transformed (estimation) scale.</p>
</td></tr>
<tr><td><code id="ienkf_+3A_cooling.type">cooling.type</code>, <code id="ienkf_+3A_cooling.fraction.50">cooling.fraction.50</code></td>
<td>
<p>specifications for the cooling schedule,
i.e., the manner and rate with which the intensity of the parameter perturbations is reduced with successive filtering iterations.
<code>cooling.type</code> specifies the nature of the cooling schedule.
See below (under &ldquo;Specifying the perturbations&rdquo;) for more detail.</p>
</td></tr>
<tr><td><code id="ienkf_+3A_np">Np</code></td>
<td>
<p>The number of particles used within each replicate for the adapted simulations.</p>
</td></tr>
<tr><td><code id="ienkf_+3A_...">...</code></td>
<td>
<p>If a <code>params</code> argument is specified, <code>abf</code> will estimate the likelihood at that parameter set instead of at <code>coef(object)</code>.</p>
</td></tr>
<tr><td><code id="ienkf_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, messages updating the user on progress will be printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Upon successful completion, <code>ienkf</code> returns an object of class
&lsquo;ienkfd_spatPomp&rsquo;. This object contains the convergence record of the iterative algorithm with
respect to the likelihood and the parameters of the model (which can be accessed using the <code>traces</code>
attribute) as well as a final parameter estimate, which can be accessed using the <code>coef()</code>.
</p>


<h3>Methods</h3>

<p>The following methods are available for such an object:
</p>

<dl>
<dt><code><a href="stats.html#topic+coef">coef</a></code></dt><dd><p> gives the Monte Carlo estimate of the maximum likelihood. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kidus Asfaw
</p>


<h3>References</h3>

<p>Asfaw, K., Park, J., Ho, A., King, A. A., and Ionides, E. L. (2020) Partially observed Markov processes with spatial structure via the R package spatPomp. <em>ArXiv</em>: 2101.01157. <a href="https://doi.org/10.48550/arXiv.2101.01157">doi:10.48550/arXiv.2101.01157</a>
</p>
<p>Evensen, G. (1994) Sequential data assimilation with a
nonlinear quasi-geostrophic model using Monte Carlo methods to forecast
error statistics Journal of Geophysical Research: Oceans 99:10143&ndash;10162
</p>
<p>Evensen, G. (2009) Data assimilation: the ensemble Kalman filter
Springer-Verlag.
</p>
<p>Anderson, J. L. (2001) An Ensemble Adjustment Kalman Filter for Data
Assimilation Monthly Weather Review 129:2884&ndash;2903
</p>


<h3>See Also</h3>

<p>likelihood evaluation algorithms: <code>girf()</code>, <code>enkf()</code>, <code>bpfilter()</code>, <code>abf()</code>, <code>abfir()</code>
</p>
<p>Other likelihood maximization algorithms: 
<code><a href="#topic+ibpf">ibpf</a>()</code>,
<code><a href="#topic+igirf">igirf</a>()</code>,
<code><a href="#topic+iubf">iubf</a>()</code>
</p>

<hr>
<h2 id='igirf'>Iterated guided intermediate resampling filter (IGIRF)</h2><span id='topic+igirf'></span><span id='topic+igirf-missing'></span><span id='topic+igirf+2Cmissing-method'></span><span id='topic+igirf-ANY'></span><span id='topic+igirf+2CANY-method'></span><span id='topic+igirf-spatPomp'></span><span id='topic+igirf+2CspatPomp-method'></span><span id='topic+igirf-igirfd_spatPomp'></span><span id='topic+igirf+2Cigirfd_spatPomp-method'></span>

<h3>Description</h3>

<p>An implementation of a parameter estimation algorithm combining
the intermediate resampling scheme of the guided intermediate resampling filter of Park and Ionides (2020)
and the parameter perturbation scheme of Ionides et al. (2015) following the pseudocode in Asfaw, et al. (2020).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'missing'
igirf(data, ...)

## S4 method for signature 'ANY'
igirf(data, ...)

## S4 method for signature 'spatPomp'
igirf(
  data,
  Ngirf,
  Np,
  rw.sd,
  cooling.type,
  cooling.fraction.50,
  Ninter,
  lookahead = 1,
  Nguide,
  kind = c("bootstrap", "moment"),
  tol = 1e-300,
  ...,
  verbose = getOption("verbose", FALSE)
)

## S4 method for signature 'igirfd_spatPomp'
igirf(
  data,
  Ngirf,
  Np,
  rw.sd,
  cooling.type,
  cooling.fraction.50,
  Ninter,
  lookahead,
  Nguide,
  kind = c("bootstrap", "moment"),
  tol,
  ...,
  verbose = getOption("verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="igirf_+3A_data">data</code></td>
<td>
<p>an object of class <code>spatPomp</code> or <code>igirfd_spatPomp</code></p>
</td></tr>
<tr><td><code id="igirf_+3A_...">...</code></td>
<td>
<p>If a <code>params</code> argument is specified, <code>abf</code> will estimate the likelihood at that parameter set instead of at <code>coef(object)</code>.</p>
</td></tr>
<tr><td><code id="igirf_+3A_ngirf">Ngirf</code></td>
<td>
<p>the number of iterations of parameter-perturbed GIRF.</p>
</td></tr>
<tr><td><code id="igirf_+3A_np">Np</code></td>
<td>
<p>The number of particles used within each replicate for the adapted simulations.</p>
</td></tr>
<tr><td><code id="igirf_+3A_rw.sd">rw.sd</code></td>
<td>
<p>specification of the magnitude of the random-walk perturbations that will be applied to some or all model parameters.
Parameters that are to be estimated should have positive perturbations specified here.
The specification is given using the <code><a href="pomp.html#topic+rw.sd">rw.sd</a></code> function, which creates a list of unevaluated expressions.
The latter are evaluated in a context where the model time variable is defined (as <code>time</code>).
The expression <code>ivp(s)</code> can be used in this context as shorthand for </p>
<pre>ifelse(time==time[1],s,0).</pre>
<p>Likewise, <code>ivp(s,lag)</code> is equivalent to </p>
<pre>ifelse(time==time[lag],s,0).</pre>
<p>See below for some examples.
</p>
<p>The perturbations that are applied are normally distributed with the specified s.d.
If parameter transformations have been supplied, then the perturbations are applied on the transformed (estimation) scale.</p>
</td></tr>
<tr><td><code id="igirf_+3A_cooling.type">cooling.type</code>, <code id="igirf_+3A_cooling.fraction.50">cooling.fraction.50</code></td>
<td>
<p>specifications for the cooling schedule,
i.e., the manner and rate with which the intensity of the parameter perturbations is reduced with successive filtering iterations.
<code>cooling.type</code> specifies the nature of the cooling schedule.
See below (under &ldquo;Specifying the perturbations&rdquo;) for more detail.</p>
</td></tr>
<tr><td><code id="igirf_+3A_ninter">Ninter</code></td>
<td>
<p>the number of intermediate resampling time points. By default, this is set equal to the number of units.</p>
</td></tr>
<tr><td><code id="igirf_+3A_lookahead">lookahead</code></td>
<td>
<p>The number of future observations included in the guide function.</p>
</td></tr>
<tr><td><code id="igirf_+3A_nguide">Nguide</code></td>
<td>
<p>The number of simulations used to estimate state process uncertainty for each particle.</p>
</td></tr>
<tr><td><code id="igirf_+3A_kind">kind</code></td>
<td>
<p>One of two types of guide function construction. Defaults to <code>'bootstrap'</code>. See Park and Ionides (2020) for more details.</p>
</td></tr>
<tr><td><code id="igirf_+3A_tol">tol</code></td>
<td>
<p>If all of the guide function evaluations become too small (beyond floating-point precision limits), we set them to this value.</p>
</td></tr>
<tr><td><code id="igirf_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, messages updating the user on progress will be printed to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Upon successful completion, <code>igirf()</code> returns an object of class
&lsquo;igirfd_spatPomp&rsquo;. This object contains the convergence record of the iterative algorithm with
respect to the likelihood and the parameters of the model (which can be accessed using the <code>traces</code>
attribute) as well as a final parameter estimate, which can be accessed using the <code>coef()</code>. The
algorithmic parameters used to run <code>igirf()</code> are also included.
</p>


<h3>Methods</h3>

<p>The following methods are available for such an object:
</p>

<dl>
<dt><code><a href="stats.html#topic+coef">coef</a></code></dt><dd><p> gives the Monte Carlo maximum likelihood parameter estimate. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kidus Asfaw
</p>


<h3>References</h3>

<p>Park, J. and Ionides, E. L. (2020) Inference on high-dimensional implicit dynamic models using a guided intermediate resampling filter. <em>Statistics and Computing</em>, <a href="https://doi.org/10.1007/s11222-020-09957-3">doi:10.1007/s11222-020-09957-3</a>
</p>
<p>Asfaw, K., Park, J., Ho, A., King, A. A., and Ionides, E. L. (2020) Partially observed Markov processes with spatial structure via the R package spatPomp. <em>ArXiv</em>: 2101.01157. <a href="https://doi.org/10.48550/arXiv.2101.01157">doi:10.48550/arXiv.2101.01157</a>
</p>


<h3>See Also</h3>

<p>likelihood evaluation algorithms: <code>girf()</code>, <code>enkf()</code>, <code>bpfilter()</code>, <code>abf()</code>, <code>abfir()</code>
</p>
<p>Other likelihood maximization algorithms: 
<code><a href="#topic+ibpf">ibpf</a>()</code>,
<code><a href="#topic+ienkf">ienkf</a>()</code>,
<code><a href="#topic+iubf">iubf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
igirf(bm(U=2,N=4),Ngirf=2,
  rw.sd = rw_sd(rho=0.02,X1_0=ivp(0.02)),
  cooling.type="geometric",cooling.fraction.50=0.5,
  Np=10,Ninter=2,lookahead=1,Nguide=5)

## End(Not run)
</code></pre>

<hr>
<h2 id='iubf'>Iterated Unadapted Bagged Filter (IUBF)</h2><span id='topic+iubf'></span><span id='topic+iubf-spatPomp'></span><span id='topic+iubf+2CspatPomp-method'></span>

<h3>Description</h3>

<p>An algorithm for estimating the parameters of a spatiotemporal partially-observed Markov process.
Running <code>iubf</code> causes the algorithm to perform a specified number of iterations of unadapted simulations with parameter perturbation and parameter resamplings.
At each iteration, unadapted simulations are performed on a perturbed version of the model, in which the parameters to be estimated are subjected to random perturbations at each observation.
After cycling through the data, each replicate's weight is calculated and is used to rank the bootstrap replictates. The highest ranking replicates are recycled into the next iteration.
This extra variability introduced through parameter perturbation effectively smooths the likelihood surface and combats particle depletion by introducing diversity into particle population.
As the iterations progress, the magnitude of the perturbations is diminished according to a user-specified cooling schedule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spatPomp'
iubf(
  object,
  Nubf = 1,
  Nrep_per_param,
  Nparam,
  nbhd,
  prop,
  rw.sd,
  cooling.type = c("geometric", "hyperbolic"),
  cooling.fraction.50,
  tol = (1e-18)^17,
  verbose = getOption("verbose"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iubf_+3A_object">object</code></td>
<td>
<p>A <code>spatPomp</code> object.</p>
</td></tr>
<tr><td><code id="iubf_+3A_nubf">Nubf</code></td>
<td>
<p>The number of iterations to perform</p>
</td></tr>
<tr><td><code id="iubf_+3A_nrep_per_param">Nrep_per_param</code></td>
<td>
<p>The number of replicates used to estimate the likelihood at a parameter</p>
</td></tr>
<tr><td><code id="iubf_+3A_nparam">Nparam</code></td>
<td>
<p>The number of parameters that will undergo the iterated perturbation</p>
</td></tr>
<tr><td><code id="iubf_+3A_nbhd">nbhd</code></td>
<td>
<p>A neighborhood function with three arguments: <code>object</code>, <code>time</code> and <code>unit</code>.
The function should return a <code>list</code> of two-element vectors that represent space-time neighbors of <code class="reqn">(u,n)</code>,
which is represented by <code>c(unit,time)</code>. See example below for more details.</p>
</td></tr>
<tr><td><code id="iubf_+3A_prop">prop</code></td>
<td>
<p>A numeric between 0 and 1. The top <code>prop</code>*100% of the parameters are resampled at each observation</p>
</td></tr>
<tr><td><code id="iubf_+3A_rw.sd">rw.sd</code></td>
<td>
<p>specification of the magnitude of the random-walk perturbations that will be applied to some or all model parameters.
Parameters that are to be estimated should have positive perturbations specified here.
The specification is given using the <code><a href="pomp.html#topic+rw.sd">rw.sd</a></code> function, which creates a list of unevaluated expressions.
The latter are evaluated in a context where the model time variable is defined (as <code>time</code>).
The expression <code>ivp(s)</code> can be used in this context as shorthand for </p>
<pre>ifelse(time==time[1],s,0).</pre>
<p>Likewise, <code>ivp(s,lag)</code> is equivalent to </p>
<pre>ifelse(time==time[lag],s,0).</pre>
<p>See below for some examples.
</p>
<p>The perturbations that are applied are normally distributed with the specified s.d.
If parameter transformations have been supplied, then the perturbations are applied on the transformed (estimation) scale.</p>
</td></tr>
<tr><td><code id="iubf_+3A_cooling.type">cooling.type</code>, <code id="iubf_+3A_cooling.fraction.50">cooling.fraction.50</code></td>
<td>
<p>specifications for the cooling schedule,
i.e., the manner and rate with which the intensity of the parameter perturbations is reduced with successive filtering iterations.
<code>cooling.type</code> specifies the nature of the cooling schedule.
See below (under &ldquo;Specifying the perturbations&rdquo;) for more detail.</p>
</td></tr>
<tr><td><code id="iubf_+3A_tol">tol</code></td>
<td>
<p>If the resampling weight for a particle is zero due to floating-point precision issues, it is set to the value of <code>tol</code> since resampling has to be done.</p>
</td></tr>
<tr><td><code id="iubf_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
<tr><td><code id="iubf_+3A_...">...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="pomp.html#topic+pomp">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="pomp.html#topic+pomp">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="pomp.html#topic+userdata">userdata</a> for information on how to use this facility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Upon successful completion, <code>iubf()</code> returns an object of class
&lsquo;iubfd_spatPomp&rsquo;. This object contains the convergence record of the iterative algorithm with
respect to the likelihood and the parameters of the model (which can be accessed using the <code>traces</code>
attribute) as well as a final parameter estimate, which can be accessed using the <code>coef()</code>. The
algorithmic parameters used to run <code>iubf()</code> are also included.
</p>


<h3>Methods</h3>

<p>The following methods are available for such an object:
</p>

<dl>
<dt><code><a href="stats.html#topic+coef">coef</a></code></dt><dd><p> extracts the point estimate </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Kidus Asfaw
</p>


<h3>References</h3>

<p>Asfaw, K., Park, J., Ho, A., King, A. A., and Ionides, E. L. (2020) Partially observed Markov processes with spatial structure via the R package spatPomp. <em>ArXiv</em>: 2101.01157. <a href="https://doi.org/10.48550/arXiv.2101.01157">doi:10.48550/arXiv.2101.01157</a>
</p>
<p>Ionides, E. L., Asfaw, K., Park, J., and King, A. A. (2021). Bagged filters for partially observed interacting systems. <em>Journal of the American Statistical Association</em>, <a href="https://doi.org/10.1080/01621459.2021.1974867">doi:10.1080/01621459.2021.1974867</a>
</p>


<h3>See Also</h3>

<p>likelihood evaluation algorithms: <code>girf()</code>, <code>enkf()</code>, <code>bpfilter()</code>, <code>abf()</code>, <code>abfir()</code>
</p>
<p>Other likelihood maximization algorithms: 
<code><a href="#topic+ibpf">ibpf</a>()</code>,
<code><a href="#topic+ienkf">ienkf</a>()</code>,
<code><a href="#topic+igirf">igirf</a>()</code>
</p>

<hr>
<h2 id='listie'>listie</h2><span id='topic+listie'></span>

<h3>Description</h3>

<p>List-like objects.
</p>

<hr>
<h2 id='logLik'>Log likelihood</h2><span id='topic+logLik'></span><span id='topic+logLik-girfd_spatPomp'></span><span id='topic+logLik+2Cgirfd_spatPomp-method'></span><span id='topic+logLik-bpfilterd_spatPomp'></span><span id='topic+logLik+2Cbpfilterd_spatPomp-method'></span><span id='topic+logLik-abfd_spatPomp'></span><span id='topic+logLik+2Cabfd_spatPomp-method'></span><span id='topic+logLik-iubfd_spatPomp'></span><span id='topic+logLik+2Ciubfd_spatPomp-method'></span><span id='topic+logLik-abfird_spatPomp'></span><span id='topic+logLik+2Cabfird_spatPomp-method'></span><span id='topic+logLik-igirfd_spatPomp'></span><span id='topic+logLik+2Cigirfd_spatPomp-method'></span>

<h3>Description</h3>

<p>Extract the estimated log likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'girfd_spatPomp'
logLik(object)

## S4 method for signature 'bpfilterd_spatPomp'
logLik(object)

## S4 method for signature 'abfd_spatPomp'
logLik(object)

## S4 method for signature 'iubfd_spatPomp'
logLik(object)

## S4 method for signature 'abfird_spatPomp'
logLik(object)

## S4 method for signature 'igirfd_spatPomp'
logLik(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik_+3A_object">object</code></td>
<td>
<p>fitted model object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric which is the estimated log likelihood
</p>

<hr>
<h2 id='lorenz'>Lorenz '96 spatPomp simulator</h2><span id='topic+lorenz'></span><span id='topic+lorenz96'></span>

<h3>Description</h3>

<p>Generate a spatPomp object representing a <code>U</code>-dimensional stochastic Lorenz '96 process with
<code>N</code> measurements made at times <code class="reqn">t_n = n * delta_obs</code>, simulated using an Euler method
with time increment <code>delta_t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lorenz(
  U = 5,
  N = 100,
  delta_t = 0.01,
  delta_obs = 0.5,
  regular_params = c(F = 8, sigma = 1, tau = 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lorenz_+3A_u">U</code></td>
<td>
<p>A length-one numeric signifying the number of spatial units for the process.</p>
</td></tr>
<tr><td><code id="lorenz_+3A_n">N</code></td>
<td>
<p>A length-one numeric signifying the number of observations.</p>
</td></tr>
<tr><td><code id="lorenz_+3A_delta_t">delta_t</code></td>
<td>
<p>A length-one numeric giving the Euler time step for the numerical solution.</p>
</td></tr>
<tr><td><code id="lorenz_+3A_delta_obs">delta_obs</code></td>
<td>
<p>A length-one numeric giving the time between observations.</p>
</td></tr>
<tr><td><code id="lorenz_+3A_regular_params">regular_params</code></td>
<td>
<p>A named numeric vector containing the values of the <code>F</code>,
<code>sigma</code> and <code>tau</code> parameters.
<code>F=8</code> is a common value that causes chaotic behavior.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lsquo;spatPomp&rsquo; representing a simulation from a <code>U</code>-dimensional
Lorenz 96 model
</p>


<h3>Author(s)</h3>

<p>Edward L. Ionides
</p>


<h3>References</h3>

<p>Lorenz, E. N. (1996) Predictability: A problem partly solved. <em>Proceedings of the seminar on predictability</em>
</p>
<p>Ionides, E. L., Asfaw, K., Park, J., and King, A. A. (2021). Bagged filters for partially observed interacting systems. <em>Journal of the American Statistical Association</em>, <a href="https://doi.org/10.1080/01621459.2021.1974867">doi:10.1080/01621459.2021.1974867</a>
</p>


<h3>See Also</h3>

<p>Other spatPomp model generators: 
<code><a href="#topic+bm">bm</a>()</code>,
<code><a href="#topic+bm2">bm2</a>()</code>,
<code><a href="#topic+gbm">gbm</a>()</code>,
<code><a href="#topic+he10">he10</a>()</code>,
<code><a href="#topic+measles">measles</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
l &lt;- lorenz(U=5, N=100, delta_t=0.01, delta_obs=1)
# See all the model specifications of the object
spy(l)

## End(Not run)
</code></pre>

<hr>
<h2 id='measles'>Measles in UK spatPomp generator</h2><span id='topic+measles'></span>

<h3>Description</h3>

<p>Generate a spatPomp object for measles in the top-<code>U</code> most populous cities in England and Wales.
The model is adapted from He et al. (2010) with gravity transport following Park and Ionides (2020).
The data are from Dalziel et al (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measles(
  U = 6,
  dt = 2/365,
  fixed_ivps = TRUE,
  S_0 = 0.032,
  E_0 = 5e-05,
  I_0 = 4e-05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measles_+3A_u">U</code></td>
<td>
<p>A length-one numeric signifying the number of cities to be represented in the spatPomp object.</p>
</td></tr>
<tr><td><code id="measles_+3A_dt">dt</code></td>
<td>
<p>a numeric (in unit of years) that is used as the Euler time-increment for simulating measles data.</p>
</td></tr>
<tr><td><code id="measles_+3A_fixed_ivps">fixed_ivps</code></td>
<td>
<p>a logical. If <code>TRUE</code> initial value parameters will be
declared in the <code>globals</code> slot, shared for each unit, and
will not be part of the parameter vector.</p>
</td></tr>
<tr><td><code id="measles_+3A_s_0">S_0</code></td>
<td>
<p>a numeric. If <code>fixed_ivps=TRUE</code> this is the initial proportion of all of the spatial units that are susceptible.</p>
</td></tr>
<tr><td><code id="measles_+3A_e_0">E_0</code></td>
<td>
<p>a numeric. If <code>fixed_ivps=TRUE</code> this is the initial proportion of all of the spatial units that are exposed.</p>
</td></tr>
<tr><td><code id="measles_+3A_i_0">I_0</code></td>
<td>
<p>a numeric. If <code>fixed_ivps=TRUE</code> this is the initial proportion of all of the spatial units that are infected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lsquo;spatPomp&rsquo; representing a <code>U</code>-dimensional spatially coupled measles POMP model.
</p>


<h3>Relationship to published analysis</h3>

<p>This model was used to generate the results of Ionides et al (2021).
However, their equation (6) is not exactly correct for the Binomial Gamma infinitesimal model used in the code, as shown by Proposition 5 of Breto and Ionides, 2011.
If Poisson Gamma infinitesimal increments were used (Proposition 4 of Breto and Ionides, 2011) then (6) would be correct, but the resulting unbounded increments could break the non-negativity requirement for compartment membership.
The same issue arises with the description in Park and Ionides (2020), though that analysis was based on a different model implementation since the spatPomp package was not yet available.
</p>
<p>A difference between (6) of Ionides et al (2021) and (2.1) of He et al (2010) is that in (6) the mixing exponent <code class="reqn">\alpha</code> is applied to <code class="reqn">(I_u/P_u)</code> rather than just to <code class="reqn">I_u</code>.
In the context of He et al (2010) this changes the parameterization but has negligible effect on the model itself since <code class="reqn">P_u(t)</code> is approximately constant and so changing its power can be compensated by a corresponding change in the transmission rate, <code class="reqn">\beta</code>.
In practice, models fitted to data have <code class="reqn">alpha</code> close to <code class="reqn">1</code>, so this issue may be moot and  this modeling mechanism may not be an effective empirical way to carry out the goal of making allowance for heterogeneous mixing.
</p>
<p>The code here includes a cohort effect, <code class="reqn">c</code>, following He et al (2010), that was not included by Ionides et al (2021).
This effect leads to a non-differentiability of expected increments which is problematic for the spatPomp implementation of GIRF.
For the results of Ionides et al (2021), this was set to <code class="reqn">c=0</code>.
</p>
<p>The analysis of He et al (2010), and the model generated by <code>he10()</code>, use weekly aggregated cases.
Weekly reports were not available beyond the 20 cites studied by He et al (2010) so <code>measles()</code> relies on the biweekly reports used by Ionides et al (2021) and Ionides &amp; Park (2020).
</p>
<p>It turns out to be an important detail of the model by He et al (2010) that a delay is included between birth and entry into the susceptible compartment. 
He et al (2010) found a 4 year delay fits the data.
This value is fixed to be the variable <code>birth_delay</code> in the code for <code>measles()</code>.
The code for Ionides et al (2021) uses a 3 year delay, and the delay is not explained in the abbreviated model description.
In <code>measles()</code> we have reverted to the 4 year delay identified by He et al (2010).
</p>


<h3>Note</h3>

<p>This function goes through a typical workflow of constructing
a typical spatPomp object (1-4 below). This allows the user to have a
file that replicates the exercise of model building as well as function
that creates a typical nonlinear model in epidemiology in case they want
to test a new inference methodology. We purposely do not modularize this
function because it is not an operational piece of the package and is
instead useful as an example.<br />
1. Getting a measurements data.frame with columns for times,
spatial units and measurements.<br />
2. Getting a covariates data.frame with columns for times,
spatial units and covariate data.<br />
3. Constructing model components (latent state initializer,
latent state transition simulator and measurement model). Depending
on the methods used, the user may have to supply a vectorfield to
be integrated that represents the deterministic skeleton of the latent
process.<br />
4. Bringing all the data and model components together to form a
spatPomp object via a call to spatPomp().
</p>


<h3>Author(s)</h3>

<p>Edward L. Ionides
</p>


<h3>References</h3>

<p>Ionides, E. L., Asfaw, K., Park, J., and King, A. A. (2021). Bagged filters for partially observed interacting systems. <em>Journal of the American Statistical Association</em>, <a href="https://doi.org/10.1080/01621459.2021.1974867">doi:10.1080/01621459.2021.1974867</a>
</p>
<p>Dalziel, Benjamin D. et al. (2016) Persistent chaos of measles epidemics in the prevaccination United States caused by a small change in seasonal transmission patterns. <em>PLoS Computational Biology</em>, <b>12(2)</b>, e1004655. <a href="https://doi.org/10.5061/dryad.r4q34">doi:10.5061/dryad.r4q34</a>
</p>
<p>Park, J. and Ionides, E. L. (2020) Inference on high-dimensional implicit dynamic models using a guided intermediate resampling filter. <em>Statistics and Computing</em>, <a href="https://doi.org/10.1007/s11222-020-09957-3">doi:10.1007/s11222-020-09957-3</a>
</p>
<p>Breto, C. and Ionides, E.L. (2011) Compound Markov counting processes and their applications to modeling infinitesimally over-dispersed systems. Stochastic Processes and their Applications <b>121</b>, 2571-2591. <a href="https://doi.org/10.1016/j.spa.2011.07.005">doi:10.1016/j.spa.2011.07.005</a>
</p>


<h3>See Also</h3>

<p><code>measles_UK</code>, <code>city_data_UK</code>
</p>
<p>Other spatPomp model generators: 
<code><a href="#topic+bm">bm</a>()</code>,
<code><a href="#topic+bm2">bm2</a>()</code>,
<code><a href="#topic+gbm">gbm</a>()</code>,
<code><a href="#topic+he10">he10</a>()</code>,
<code><a href="#topic+lorenz">lorenz</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
m &lt;- measles(U = 5)
# See all the model specifications of the object
spy(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='measles2'>Measles in UK: spatPomp generator with shared or unit-specific parameters</h2><span id='topic+measles2'></span>

<h3>Description</h3>

<p>Generate a spatPomp object for measles in the top-<code>U</code> most populous cities in England and Wales.
The model is adapted from He et al. (2010) with gravity transport following Park and Ionides (2019).
The structure of this spatPomp is designed to accommodate shared and unit-specific parameters.
If carrying out spatiotemporal iterated filtering for shared parameters via ibpf, it is necessary to
have a unit-specific expansion and so these parameters should be included in expandedParNames.
This model and data correspond to the biweekly analysis of Park and Ionides (2020) and
Ionides et al (2021). There are small differences with the weekly model and data of
He et al (2010) and Ionides, Ning and Wheeler (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>measles2(
  U = 6,
  dt = 2/365,
  N = 391,
  expandedParNames = c("R0", "c", "A", "muIR", "muEI", "sigmaSE", "rho", "psi", "g",
    "S_0", "E_0", "I_0"),
  contractedParNames = NULL,
  simulated = FALSE,
  basic_params = c(alpha = 0.98, iota = 0.1, R0 = 30, c = 0.3, A = 0.5, muIR = 52, muEI =
    52, muD = 0.02, sigmaSE = 0.15, rho = 0.5, psi = 0.15, g = 400, S_0 = 0.032, E_0 =
    5e-05, I_0 = 4e-05)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="measles2_+3A_u">U</code></td>
<td>
<p>An integer from 1 to 40 specifying the number of cities to be represented in the spatPomp object.</p>
</td></tr>
<tr><td><code id="measles2_+3A_dt">dt</code></td>
<td>
<p>a numeric (in unit of years) that is used as the Euler time-increment for simulating measles data</p>
</td></tr>
<tr><td><code id="measles2_+3A_n">N</code></td>
<td>
<p>An integer from 1 to 391 specifying the number of time points.</p>
</td></tr>
<tr><td><code id="measles2_+3A_expandedparnames">expandedParNames</code></td>
<td>
<p>specifies parameters that are defined for each unit. This also allows unit perturbations for a parameter with a value shared across units.</p>
</td></tr>
<tr><td><code id="measles2_+3A_contractedparnames">contractedParNames</code></td>
<td>
<p>specifies parameters having a shared value across units. Remaining parameters that are neither expanded nor contracted are considered fixed, and will not have a transformation defined for them.</p>
</td></tr>
<tr><td><code id="measles2_+3A_simulated">simulated</code></td>
<td>
<p>determines whether to return a simulation from the model or the
UK measles data</p>
</td></tr>
<tr><td><code id="measles2_+3A_basic_params">basic_params</code></td>
<td>
<p>A named vector used to specify shared parameters or unit-specific parameters
having common values for each unit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lsquo;spatPomp&rsquo; representing a <code>U</code>-dimensional spatially coupled measles POMP model.
</p>


<h3>References</h3>

<p>He, D., Ionides, E. L., and King, A. A. (2010). Plug-and-play inference for disease dynamics: measles in large and small populations as a case study. <em>Journal of the Royal Society Interface</em>, <b>7</b>(43), 271-283. <a href="https://doi.org/10.1098/rsif.2009.0151">doi:10.1098/rsif.2009.0151</a>
</p>
<p>Park, J. and Ionides, E. L. (2020) Inference on high-dimensional implicit dynamic models using a guided intermediate resampling filter. <em>Statistics and Computing</em>, <a href="https://doi.org/10.1007/s11222-020-09957-3">doi:10.1007/s11222-020-09957-3</a>
</p>
<p>Ionides, E. L., Asfaw, K., Park, J., and King, A. A. (2021). Bagged filters for partially observed interacting systems. <em>Journal of the American Statistical Association</em>, <a href="https://doi.org/10.1080/01621459.2021.1974867">doi:10.1080/01621459.2021.1974867</a>
</p>
<p>Ionides, E. L., Ning, N., and Wheeler, J. (2022). An iterated block particle filter for inference on coupled dynamic systems with shared and unit-specific parameters. <em>Statistica Sinica</em>, to appear. <a href="https://doi.org/10.48550/arXiv.2206.03837">doi:10.48550/arXiv.2206.03837</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
m &lt;- measles2(U = 5)
# See all the model specifications of the object
spy(m)

## End(Not run)
</code></pre>

<hr>
<h2 id='measlesUK'>Measles in the United Kingdom</h2><span id='topic+measlesUK'></span>

<h3>Description</h3>

<p>Measles case data from various cities and towns in England and Wales during the pre-vaccine era.
</p>


<h3>Details</h3>

<p>Data includes bi-weekly case counts as well as births and population from 40 cities and towns.
</p>


<h3>Value</h3>

<p>a &lsquo;data.frame&rsquo; of the 40 largest cities and towns in the UK and Wales, their latitude, longitude and
bi-weekly measles case counts, population and birthrates.
</p>


<h3>References</h3>

<p>Dalziel, Benjamin D. et al. (2016) Persistent chaos of measles epidemics in the prevaccination United States caused by a small change in seasonal transmission patterns. <em>PLoS Computational Biology</em>, <b>12(2)</b>, e1004655. <a href="https://doi.org/10.5061/dryad.r4q34">doi:10.5061/dryad.r4q34</a>
</p>


<h3>See Also</h3>

<p>Other datasets: 
<code><a href="#topic+city_data_UK">city_data_UK</a></code>
</p>

<hr>
<h2 id='munit_measure'>munit_measure</h2><span id='topic+munit_measure'></span><span id='topic+munit_measure-spatPomp'></span><span id='topic+munit_measure+2CspatPomp-method'></span>

<h3>Description</h3>

<p><code>munit_measure</code> returns a moment-matched parameter set given an empirically calculated measurement variance and latent states.
This is used in <code>girf()</code> and <code>igirf()</code> when they are run with <code>kind='moment'</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spatPomp'
munit_measure(object, x, vc, unit, time, params, Np = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="munit_measure_+3A_object">object</code></td>
<td>
<p>An object of class <code>spatPomp</code></p>
</td></tr>
<tr><td><code id="munit_measure_+3A_x">x</code></td>
<td>
<p>A state vector for all units</p>
</td></tr>
<tr><td><code id="munit_measure_+3A_vc">vc</code></td>
<td>
<p>The empirically calculated variance used to perform moment-matching</p>
</td></tr>
<tr><td><code id="munit_measure_+3A_unit">unit</code></td>
<td>
<p>The unit for which to obtain a moment-matched parameter set</p>
</td></tr>
<tr><td><code id="munit_measure_+3A_time">time</code></td>
<td>
<p>The time for which to obtain a moment-matched parameter set</p>
</td></tr>
<tr><td><code id="munit_measure_+3A_params">params</code></td>
<td>
<p>parameters to use to obtain a moment-matched parameter set</p>
</td></tr>
<tr><td><code id="munit_measure_+3A_np">Np</code></td>
<td>
<p>Number of particle replicates for which to get parameter sets</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array with dimensions <code>dim(array.params)[1]</code> by <code>dim(x)[2]</code> by <code>length(unit)</code> by<code>length(time)</code>
representing the moment-matched parameter set(s) corresponding to the variance of the measurements, <code>vc</code>, and the states, <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Kidus Asfaw
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
b &lt;- bm(U=3)
s &lt;- states(b)[,1,drop=FALSE]
rownames(s) -&gt; rn
dim(s) &lt;- c(3,1,1)
dimnames(s) &lt;- list(variable=rn, rep=NULL)
p &lt;- coef(b); names(p) -&gt; rnp
dim(p) &lt;- c(length(p),1); dimnames(p) &lt;- list(param=rnp)
o &lt;- obs(b)[,1,drop=FALSE]
array.params &lt;- array(p,
                      dim = c(length(p),
                              length(unit_names(b)), 1, 1),
                      dimnames = list(params = rownames(p)))
vc &lt;- c(4, 9, 16); dim(vc) &lt;- c(length(vc), 1, 1)
munit_measure(b, x=s, vc=vc, Np=1, unit = 1, time=1, params=array.params)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot'>Plotting <code>spatPomp</code> data</h2><span id='topic+plot'></span><span id='topic+plot-igirfd_spatPomp'></span><span id='topic+plot+2Cigirfd_spatPomp-method'></span><span id='topic+plot-spatPomp'></span><span id='topic+plot+2CspatPomp-method'></span>

<h3>Description</h3>

<p>Visualize <code>spatPomp</code> data
</p>
<p>Diagnostic plot for <code>igirf()</code>
</p>
<p>Visualize <code>spatPomp</code> data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'igirfd_spatPomp'
plot(x, params = names(coef(x)), ncol = 3)

## S4 method for signature 'spatPomp'
plot(x, type = c("l", "h"), log = F, plot_unit_names = T, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>a <code>spatPomp</code> object</p>
</td></tr>
<tr><td><code id="plot_+3A_params">params</code></td>
<td>
<p>the names of the parameters for which the user would like to see a trace plot</p>
</td></tr>
<tr><td><code id="plot_+3A_ncol">ncol</code></td>
<td>
<p>the number of columns in the grid plot</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>for visualizing an object of class <code>spatPomp</code>, the user
can obtain a grid of line plots by default (<code>'l'</code>) or a heat map by
supplying argument <code>'h'</code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_log">log</code></td>
<td>
<p>should the data be log-transformed before plotting?
This helps in contexts where there are spikes that could take away
attention from the dynamics illustrated by the rest of the data.</p>
</td></tr>
<tr><td><code id="plot_+3A_plot_unit_names">plot_unit_names</code></td>
<td>
<p>allows suppression of unit names when making
a heat map for a large number of units</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>for visualizing an object of class <code>spatPomp</code>, the user
can add arguments like <code>nrow</code> to specify the number of rows in the
grid.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>ggplot</code> facet plot of class &lsquo;gg&rsquo; and &lsquo;ggplot&rsquo; visualizing
the convergence record of running <code>igirf()</code> with respect to the likelihood and the parameters of the model.
</p>
<p>a <code>ggplot</code> plot of class &lsquo;gg&rsquo; and &lsquo;ggplot&rsquo; visualizing
the time series data over multiple spatial units via a tile-plot.
</p>

<hr>
<h2 id='print'>Print methods</h2><span id='topic+print'></span><span id='topic+print-spatPomp'></span><span id='topic+print+2CspatPomp-method'></span>

<h3>Description</h3>

<p>Prints its argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spatPomp'
print(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>a <code>spatPomp</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lsquo;spatPomp&rsquo; is returned *invisibly*. The user is notified on the console only the class of the object.
</p>


<h3>Note</h3>

<p>Use <code>spy()</code> to see model components of <code>x</code> instead.
</p>

<hr>
<h2 id='pStop'>pStop</h2><span id='topic+pStop'></span><span id='topic+pStop_'></span><span id='topic+pWarn'></span><span id='topic+pWarn_'></span>

<h3>Description</h3>

<p>Custom error function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pStop(fn, ...)

pStop_(...)

pWarn(fn, ...)

pWarn_(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pStop_+3A_fn">fn</code></td>
<td>
<p>name of function (will be enclosed in single quotes)</p>
</td></tr>
<tr><td><code id="pStop_+3A_...">...</code></td>
<td>
<p>message</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value as this is simply a custom error function.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>

<hr>
<h2 id='runit_measure'>runit_measure</h2><span id='topic+runit_measure'></span><span id='topic+runit_measure-spatPomp'></span><span id='topic+runit_measure+2CspatPomp-method'></span>

<h3>Description</h3>

<p><code>runit_measure</code> simulates a unit's observation given the entire state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spatPomp'
runit_measure(object, x, unit, time, params, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runit_measure_+3A_object">object</code></td>
<td>
<p>An object of class <code>spatPomp</code></p>
</td></tr>
<tr><td><code id="runit_measure_+3A_x">x</code></td>
<td>
<p>A state vector for all units</p>
</td></tr>
<tr><td><code id="runit_measure_+3A_unit">unit</code></td>
<td>
<p>The unit for which to simulate an observation</p>
</td></tr>
<tr><td><code id="runit_measure_+3A_time">time</code></td>
<td>
<p>The time for which to simulate an observation</p>
</td></tr>
<tr><td><code id="runit_measure_+3A_params">params</code></td>
<td>
<p>parameters to use to simulate an observation</p>
</td></tr>
<tr><td><code id="runit_measure_+3A_log">log</code></td>
<td>
<p>logical; should the density be returned on log scale?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the simulated observation corresponding to state
<code>x</code> and unit <code>unit</code> with parameter set <code>params</code>.
</p>


<h3>Author(s)</h3>

<p>Kidus Asfaw
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
b &lt;- bm(U=3)
s &lt;- states(b)[,1,drop=FALSE]
rownames(s) -&gt; rn
dim(s) &lt;- c(3,1,1)
dimnames(s) &lt;- list(variable=rn, rep=NULL)
p &lt;- coef(b); names(p) -&gt; rnp
dim(p) &lt;- c(length(p),1); dimnames(p) &lt;- list(param=rnp)
o &lt;- obs(b)[,1,drop=FALSE]
runit_measure(b, x=s, unit=2, time=1, params=p)

## End(Not run)
</code></pre>

<hr>
<h2 id='simulate'>Simulation of a spatiotemporal partially-observed Markov process</h2><span id='topic+simulate'></span><span id='topic+simulate-spatPomp'></span><span id='topic+simulate+2CspatPomp-method'></span>

<h3>Description</h3>

<p><code>simulate</code> generates simulations of the latent and measurement
processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spatPomp'
simulate(
  object,
  nsim = 1,
  seed = NULL,
  format = c("spatPomps", "data.frame"),
  include.data = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_+3A_object">object</code></td>
<td>
<p>optional;
if present, it should be a data frame or a &lsquo;pomp&rsquo; object.</p>
</td></tr>
<tr><td><code id="simulate_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations.</p>
</td></tr>
<tr><td><code id="simulate_+3A_seed">seed</code></td>
<td>
<p>optional;
if set, the pseudorandom number generator (RNG) will be initialized with <code>seed</code>.  the random seed to use.
The RNG will be restored to its original state afterward.</p>
</td></tr>
<tr><td><code id="simulate_+3A_format">format</code></td>
<td>
<p>the format of the simulated results. If the argument is
set to <code>'spatPomps'</code>, the default behavior, then the output is a
<code>list</code> of <code>spatPomp</code> objects. Options are <code>'spatPomps'</code>
and <code>'data.frame'</code>.</p>
</td></tr>
<tr><td><code id="simulate_+3A_include.data">include.data</code></td>
<td>
<p>if <code>TRUE</code>, the original data and covariates (if any) are included (with <code>.id = "data"</code>).
This option is ignored unless <code>format = "data.frame"</code>.</p>
</td></tr>
<tr><td><code id="simulate_+3A_...">...</code></td>
<td>
<p>additional arguments supply new or modify existing model characteristics or components.
See <code><a href="pomp.html#topic+pomp">pomp</a></code> for a full list of recognized arguments.
</p>
<p>When named arguments not recognized by <code><a href="pomp.html#topic+pomp">pomp</a></code> are provided, these are made available to all basic components via the so-called <dfn>userdata</dfn> facility.
This allows the user to pass information to the basic components outside of the usual routes of covariates (<code>covar</code>) and model parameters (<code>params</code>).
See <a href="pomp.html#topic+userdata">userdata</a> for information on how to use this facility.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if <code>format='spatPomps'</code> and <code>nsim=1</code> an object of class &lsquo;spatPomp&rsquo; representing a simulation from the model in <code>object</code> is returned.
If <code>format='spatPomps'</code> and <code>nsim&gt;1</code> a list of class &lsquo;spatPomp&rsquo; objects is returned.
If <code>format='data.frame'</code> then a class &lsquo;data.frame&rsquo; object is returned.
</p>


<h3>Author(s)</h3>

<p>Kidus Asfaw
</p>


<h3>References</h3>

<p>Asfaw, K., Park, J., Ho, A., King, A. A., and Ionides, E. L. (2020) Partially observed Markov processes with spatial structure via the R package spatPomp. <em>ArXiv</em>: 2101.01157. <a href="https://doi.org/10.48550/arXiv.2101.01157">doi:10.48550/arXiv.2101.01157</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
# Get a spatPomp object
b &lt;- bm(U=2, N=5)
# Get 2 simulations from same model as data.frame
sims &lt;- simulate(b, nsim=2, format='data.frame')

## End(Not run)
</code></pre>

<hr>
<h2 id='spatPomp'>Constructor of the spatPomp object</h2><span id='topic+spatPomp'></span>

<h3>Description</h3>

<p>This function constructs a class &lsquo;spatPomp&rsquo; object, encoding a spatiotemporal partially observed Markov process (<abbr><span class="acronym">SpatPOMP</span></abbr>) model together with a uni- or multi-variate time series on a collection of units.
Users will typically develop a POMP model for a single unit before embarking on a coupled SpatPOMP analysis.
Consequently, we assume some familiarity with <span class="pkg">pomp</span> and its description by King, Nguyen and Ionides (2016).
The <code>spatPomp</code> class inherits from <code>pomp</code> with the additional unit structure being a defining feature of the resulting models and inference algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatPomp(
  data,
  units,
  times,
  covar,
  t0,
  ...,
  eunit_measure,
  munit_measure,
  vunit_measure,
  dunit_measure,
  runit_measure,
  rprocess,
  rmeasure,
  dprocess,
  dmeasure,
  skeleton,
  rinit,
  rprior,
  dprior,
  unit_statenames,
  unit_accumvars,
  shared_covarnames,
  globals,
  paramnames,
  params,
  cdir,
  cfile,
  shlib.args,
  PACKAGE,
  partrans,
  compile = TRUE,
  verbose = getOption("verbose", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatPomp_+3A_data">data</code></td>
<td>
<p>either a dataframe holding the spatiotemporal data,
or an object of class &lsquo;spatPomp&rsquo;, i.e., the output of another <span class="pkg">spatPomp</span> calculation.
If dataframe, the user must provide the name of the times column using the <code>times</code> argument and
the spatial unit column name using the <code>units</code> argument. The dataframe provided should be sorted in
increasing order of time and unit name respectively, i.e. observation 1 in unit A should come before observation
1 in unit B, which should come before observation 2 in unit A.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_units">units</code></td>
<td>
<p>when <code>data</code> is a <code>data.frame</code> this is the name of the column containing the spatial units.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_times">times</code></td>
<td>
<p>the sequence of observation times.
<code>times</code> must indicate the column of observation times by name or index.
The time vector must be numeric and non-decreasing.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_covar">covar</code></td>
<td>
<p>An optional dataframe for supplying covariate information. If provided, there must be two
columns that provide the observation time and the observation spatial unit with the same names and arrangement as the <code>data</code>.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_t0">t0</code></td>
<td>
<p>The zero-time, i.e., the time of the initial state.
This must be no later than the time of the first observation, i.e., <code>t0 &lt;= times[1]</code>.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_...">...</code></td>
<td>
<p>If there are arguments that the user would like to pass to <span class="pkg">pomp</span>'s basic constructor function's ... argument,
this argument passes them along. Not recommended for this version of <span class="pkg">spatPomp</span>.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_eunit_measure">eunit_measure</code></td>
<td>
<p>Evaluator of the expected measurement given the latent states and model parameters. The <code>unit</code> variable is pre-defined, which allows the user to specify differing specifications for each unit using <code>if</code> conditions.
Only C snippets are accepted. The C snippet should assign the scalar approximation to the expected measurement to the pre-defined variable <code>ey</code> given the latent state and the parameters.
For more information, see the examples section below.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_munit_measure">munit_measure</code></td>
<td>
<p>Evaluator of a moment-matched parameter set (like the standard deviation parameter of a normal distribution or the size parameter of a negative binomial distribution) given an empirical variance estimate, the latent states and all model parameters.
Only Csnippets are accepted. The Csnippet should assign the scalar approximation to the measurement variance parameter to the pre-defined variable corresponding to that parameter, which has been predefined with a <code>M_</code> prefix. For instance, if the moment-matched parameter is <code>psi</code>, then the user should assign <code>M_psi</code> to the moment-matched value.
For more information, see the examples section below.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_vunit_measure">vunit_measure</code></td>
<td>
<p>Evaluator of the theoretical measurement variance given the latent states and model parameters. The <code>unit</code> variable is pre-defined, which allows the user to specify differing specifications for each unit using <code>if</code> conditions.
Only C snippets are accepted. The C snippet should assign the scalar approximation to the measurement variance to the pre-defined variable <code>vc</code> given the latent state and the parameters.
For more information, see the examples section below.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_dunit_measure">dunit_measure</code></td>
<td>
<p>Evaluator of the unit measurement model density given the measurement, the latent states and model parameters. The <code>unit</code> variable is pre-defined, which allows the user to specify differing specifications for each unit using <code>if</code> conditions.
Only Csnippets are accepted. The Csnippet should assign the scalar measurement density to the pre-defined variable <code>lik</code>. The user is encouraged to provide a logged density in an <code>if</code> condition that checks whether the predefined <code>give_log</code> variable is true.
For more information, see the examples section below.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_runit_measure">runit_measure</code></td>
<td>
<p>Simulator of the unit measurement model given the latent states and the model parameters.
The <code>unit</code> variable is pre-defined, which allows the user to specify differing specifications for each unit using <code>if</code> conditions.
Only Csnippets are accepted. The Csnippet should assign the scalar measurement density to the pre-defined which corresponds to the name of the observation for each unit (e.g. <code>cases</code> for the measles spatPomp example).
For more information, see the examples section below.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_rprocess">rprocess</code></td>
<td>
<p>simulator of the latent state process, specified using one of the <a href="pomp.html#topic+rprocess_spec">rprocess plugins</a>.
Setting <code>rprocess=NULL</code> removes the latent-state simulator.
For more information, see <a href="pomp.html#topic+rprocess_spec">rprocess specification for the documentation on these plugins</a>.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_rmeasure">rmeasure</code></td>
<td>
<p>simulator of the measurement model, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rmeasure=NULL</code> removes the measurement model simulator.
For more information, see <a href="pomp.html#topic+rmeasure_spec">rmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_dprocess">dprocess</code></td>
<td>
<p>evaluator of the probability density of transitions of the unobserved state process.
Setting <code>dprocess=NULL</code> removes the latent-state density evaluator.
For more information, see <a href="pomp.html#topic+dprocess_spec">dprocess specification</a>.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_dmeasure">dmeasure</code></td>
<td>
<p>evaluator of the measurement model density, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>dmeasure=NULL</code> removes the measurement density evaluator.
For more information, see <a href="pomp.html#topic+dmeasure_spec">dmeasure specification</a>.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_skeleton">skeleton</code></td>
<td>
<p>optional; the deterministic skeleton of the unobserved state process.
Depending on whether the model operates in continuous or discrete time, this is either a vectorfield or a map.
Accordingly, this is supplied using either the <code><a href="pomp.html#topic+skeleton_spec">vectorfield</a></code> or <code><a href="pomp.html#topic+skeleton_spec">map</a></code> fnctions.
For more information, see <a href="pomp.html#topic+skeleton_spec">skeleton specification</a>.
Setting <code>skeleton=NULL</code> removes the deterministic skeleton.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_rinit">rinit</code></td>
<td>
<p>simulator of the initial-state distribution.
This can be furnished either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
Setting <code>rinit=NULL</code> sets the initial-state simulator to its default.
For more information, see <a href="pomp.html#topic+rinit_spec">rinit specification</a>.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_rprior">rprior</code></td>
<td>
<p>optional; prior distribution sampler, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
For more information, see <a href="pomp.html#topic+prior_spec">prior specification</a>.
Setting <code>rprior=NULL</code> removes the prior distribution sampler.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_dprior">dprior</code></td>
<td>
<p>optional; prior distribution density evaluator, specified either as a C snippet, an <span class="rlang"><b>R</b></span> function, or the name of a pre-compiled native routine available in a dynamically loaded library.
For more information, see <a href="pomp.html#topic+prior_spec">prior specification</a>.
Setting <code>dprior=NULL</code> resets the prior distribution to its default, which is a flat improper prior.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_unit_statenames">unit_statenames</code></td>
<td>
<p>The names of the components of the latent state. E.g. if the user is constructing an joint SIR model
over many spatial units, <code>c('S','I','R')</code> would be passed.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_unit_accumvars">unit_accumvars</code></td>
<td>
<p>a subset of the <code>unit_statenames</code> argument that are accumulator variables. See <a href="pomp.html#topic+accumvars">accumvars</a>
for more on the concept of <span class="pkg">pomp</span> accumulator variables.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_shared_covarnames">shared_covarnames</code></td>
<td>
<p>If <code>covar</code> is supplied, covariates that are shared must still be specified for each unit, i.e.,
rows with equal values for the same time over all units must be supplied. However, if such covariates exists, supply the names
using this argument.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_globals">globals</code></td>
<td>
<p>optional character or C snippet;
arbitrary C code that will be hard-coded into the shared-object library created when C snippets are provided.
If no C snippets are used, <code>globals</code> has no effect.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_paramnames">paramnames</code></td>
<td>
<p>optional character vector;
names of model parameters.
It is typically only necessary to supply <code>paramnames</code> when C snippets are in use.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_params">params</code></td>
<td>
<p>optional; named numeric vector of parameters.
This will be coerced internally to storage mode <code>double</code>.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_cdir">cdir</code></td>
<td>
<p>optional character variable.
<code>cdir</code> specifies the name of the directory within which C snippet code will be compiled.
By default, this is in a temporary directory specific to the <span class="rlang"><b>R</b></span> session.
One can also set this directory using the <code>pomp_cdir</code> global option.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_cfile">cfile</code></td>
<td>
<p>optional character variable.
<code>cfile</code> gives the name of the file (in directory <code>cdir</code>) into which C snippet codes will be written.
By default, a random filename is used.
If the chosen filename would result in over-writing an existing file, an error is generated.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_shlib.args">shlib.args</code></td>
<td>
<p>optional character variables.
Command-line arguments to the <code>R CMD SHLIB</code> call that compiles the C snippets.
One can, for example, specify libraries against which the C snippets are to be linked.
In doing so, take care to make sure the appropriate header files are available to the C snippets, e.g., using the <code>globals</code> argument.
See <code><a href="pomp.html#topic+Csnippet">Csnippet</a></code> for more information.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_package">PACKAGE</code></td>
<td>
<p>optional character;
the name (without extension) of the external, dynamically loaded library in which any native routines are to be found.
This is only useful if one or more of the model components has been specified using a precompiled dynamically loaded library;
it is not used for any component specified using C snippets.
<code>PACKAGE</code> can name at most one library.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_partrans">partrans</code></td>
<td>
<p>optional parameter transformations, constructed using <code><a href="pomp.html#topic+parameter_trans">parameter_trans</a></code>.
</p>
<p>Many algorithms for parameter estimation search an unconstrained space of parameters.
When working with such an algorithm and a model for which the parameters are constrained, it can be useful to transform parameters.
One should supply the <code>partrans</code> argument via a call to <code><a href="pomp.html#topic+parameter_trans">parameter_trans</a></code>.
For more information, see <a href="pomp.html#topic+parameter_trans">parameter_trans</a>.
Setting <code>partrans=NULL</code> removes the parameter transformations, i.e., sets them to the identity transformation.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_compile">compile</code></td>
<td>
<p>logical;
if <code>FALSE</code>, compilation of the C snippets will be postponed until they are needed.</p>
</td></tr>
<tr><td><code id="spatPomp_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, diagnostic messages will be printed to the console.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One implements a <abbr><span class="acronym">SpatPOMP</span></abbr> model by specifying some or all of its <em>basic components</em>, including:
</p>

<dl>
<dt>rinit,</dt><dd><p>the simulator from the distribution of the latent state process at the zero-time;</p>
</dd>
<dt>rprocess,</dt><dd><p>the transition simulator of the latent state process;</p>
</dd>
<dt>dunit_measure,</dt><dd><p>the evaluator of the conditional density at a unit's measurement given the unit's latent state;</p>
</dd>
<dt>eunit_measure,</dt><dd><p>the evaluator of the expectation of a unit's measurement given the unit's latent state;</p>
</dd>
<dt>munit_measure,</dt><dd><p>the evaluator of the moment-matched parameter set given a unit's latent state and some empirical measurement variance;</p>
</dd>
<dt>vunit_measure,</dt><dd><p>the evaluator of the variance of a unit's measurement given the unit's latent state;</p>
</dd>
<dt>runit_measure,</dt><dd><p>the simulator of a unit's measurement conditional on the unit's latent state;</p>
</dd>
<dt>dprocess,</dt><dd><p>the evaluator of the density for transitions of the latent state process;</p>
</dd>
<dt>rmeasure,</dt><dd><p>the simulator of the measurements conditional on the latent state;</p>
</dd>
<dt>dmeasure,</dt><dd><p>the evaluator of the conditional density of the measurements given the latent state;</p>
</dd>
<dt>rprior,</dt><dd><p>the simulator from a prior distribution on the parameters;</p>
</dd>
<dt>dprior,</dt><dd><p>the evaluator of the prior density;</p>
</dd>
<dt>skeleton,</dt><dd><p>which computes the deterministic skeleton of the unobserved state process;</p>
</dd>
<dt>partrans,</dt><dd><p>which performs parameter transformations.</p>
</dd>
</dl>

<p>The basic structure and its rationale are described in Asfaw et al. (2020).
</p>
<p>Each basic component is supplied via an argument of the same name to <code>spatPomp()</code>.
The five unit-level model components must be provided via C snippets. The remaining components, whose behaviors are inherited from
<span class="pkg">pomp</span> may be furnished using C snippets, <span class="rlang"><b>R</b></span> functions, or pre-compiled native routine available in user-provided dynamically loaded libraries.
</p>


<h3>Value</h3>

<p>An object of class &lsquo;spatPomp&rsquo; representing observations and model components from the spatiotemporal POMP model.
</p>


<h3>Author(s)</h3>

<p>Kidus Asfaw, Edward L. Ionides, Aaron A. King
</p>


<h3>References</h3>

<p>Asfaw, K., Park, J., Ho, A., King, A. A., and Ionides, E. L. (2020) Partially observed Markov processes with spatial structure via the R package spatPomp. <em>ArXiv</em>: 2101.01157. <a href="https://doi.org/10.48550/arXiv.2101.01157">doi:10.48550/arXiv.2101.01157</a>
</p>
<p>King, A. A., Nguyen, D. and Ionides, E. L. (2016) Statistical Inference for Partially Observed Markov Processes via the R Package pomp. <em>Journal of Statistical Software</em>, <b>69(12)</b>, 1&ndash;43. <a href="https://doi.org/10.18637/jss.v069.i12">doi:10.18637/jss.v069.i12</a>
</p>

<hr>
<h2 id='spatPomp_Csnippet'>C snippets</h2><span id='topic+spatPomp_Csnippet'></span><span id='topic+spatPomp_Csnippet-character'></span><span id='topic+spatPomp_Csnippet+2Ccharacter-method'></span>

<h3>Description</h3>

<p><code>spatPomp_Csnippet()</code> is used to provide snippets of C
code that specify model components. It functions similarly to <code>Csnippet()</code> from
the <span class="pkg">pomp</span> package; in fact, the output of <code>spatPomp_Csnippet</code> is an object
of class <code>Csnippet</code>.  It additionally provides some arguments that allow the user
to stay focused on model development in the spatiotemporal context  where
model size grows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
spatPomp_Csnippet(
  code,
  method = "",
  unit_statenames,
  unit_obsnames,
  unit_covarnames,
  unit_ivpnames,
  unit_paramnames,
  unit_vfnames
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatPomp_Csnippet_+3A_code">code</code></td>
<td>
<p>encodes a component of a spatiotemporal POMP model using C code</p>
</td></tr>
<tr><td><code id="spatPomp_Csnippet_+3A_method">method</code></td>
<td>
<p>a character string matching the name of the <code>'spatPomp'</code>
argument which the code is designed to specify. This argument is ignored unless
needed to correctly specify the Csnippet.</p>
</td></tr>
<tr><td><code id="spatPomp_Csnippet_+3A_unit_statenames">unit_statenames</code></td>
<td>
<p>a subset of the <code>unit_statenames</code> slot of
the <code>spatPomp</code> object for which we are writing a model. This argument
allows the user to get variables that can be indexed conveniently to update
states and measurements in a loop. See examples for more details.</p>
</td></tr>
<tr><td><code id="spatPomp_Csnippet_+3A_unit_obsnames">unit_obsnames</code></td>
<td>
<p>a subset of the <code>unit_obsnames</code> slot of
the <code>spatPomp</code> object for which we are writing a model. This argument
allows the user to get variables that can be indexed conveniently to update
states and measurements in a loop. See examples for more details.</p>
</td></tr>
<tr><td><code id="spatPomp_Csnippet_+3A_unit_covarnames">unit_covarnames</code></td>
<td>
<p>if the model has covariate information for each unit,
the names of the covariates for each unit can be supplied to this argument.
This allows the user to get variables that can be indexed conveniently to
use incorporate the covariate information in a loop. See examples for more
details.</p>
</td></tr>
<tr><td><code id="spatPomp_Csnippet_+3A_unit_ivpnames">unit_ivpnames</code></td>
<td>
<p>This argument is particularly useful when specifying the
<code>rinit</code> model component. The <code>paramnames</code> argument to the
<code>spatPomp()</code> constructor often has names for initial value
parameters for the latent states (e.g. <code>S1_0</code>, <code>S2_0</code> for the
the quantity of susceptibles at unit 1 and unit 2 at the initial time in an
SIR model). By supplying <code>unit_ivpnames</code>, we can get variables
that can be easily indexed to reference the initial value parameters (in
the previous example, <code>unit_ivpnames=c('S')</code> we can get a variable
named <code>S_0</code> that we can index as <code>S_0[0]</code> and <code>S_0[1]</code> to
refer to <code>S1_0</code> and <code>S2_0</code>). See examples for more details.</p>
</td></tr>
<tr><td><code id="spatPomp_Csnippet_+3A_unit_paramnames">unit_paramnames</code></td>
<td>
<p>This argument is particularly useful when there
are non-initial value parameters that are unit-specific.</p>
</td></tr>
<tr><td><code id="spatPomp_Csnippet_+3A_unit_vfnames">unit_vfnames</code></td>
<td>
<p>This argument is particularly useful when specifying the
<code>skeleton</code> model component. For all components of the latent state,
the user can assume a variable defining the time-derivative is pre-defined (e.g.
<code>DS1</code> and <code>DS2</code> for the time-derivative of the quantity of the
susceptibles at unit 1 and unit 2 in an SIR model). By supplying
<code>unit_vfnames</code>, we can get variables that can be easily indexed to
reference these variables (in the previous example,
setting <code>unit_vfnames=c('S')</code> gets us a variable
named <code>DS</code> that we can index as <code>DS[0]</code> and <code>DS[1]</code> to
refer to <code>DS1</code> and <code>DS2</code>). See examples for more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &lsquo;Csnippet&rsquo; which represents a model specification in C code.
</p>


<h3>Author(s)</h3>

<p>Kidus Asfaw
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set initial states for Brownian motion
bm_rinit &lt;- spatPomp_Csnippet(
  method = "rinit",
  unit_statenames = c("X"),
  unit_ivpnames = c("X"),
  code = "
    for (int u = 0; u &lt; U; u++) {
      X[u]=X_0[u];
    }
  "
)
# Skeleton for Brownian motion
bm_skel &lt;- spatPomp_Csnippet(
  method = "skeleton",
  unit_statenames = c("X"),
  unit_vfnames = c("X"),
  code = "
      for (int u = 0 ; u &lt; U ; u++) {
        DX[u] = 0;
      }
  "
)
</code></pre>

<hr>
<h2 id='spatPomp-class'>An S4 class to represent a spatiotemporal POMP model and data.</h2><span id='topic+spatPomp-class'></span>

<h3>Description</h3>

<p>An S4 class to represent a spatiotemporal POMP model and data.
</p>


<h3>Slots</h3>


<dl>
<dt><code>unit_names</code></dt><dd><p>A vector containing the spatial units of a spatiotemporal POMP.</p>
</dd>
<dt><code>unit_statenames</code></dt><dd><p>A vector containing the state names such that appending the unit indices to the
unit statenames will result in the each unit's corresponding states.</p>
</dd>
<dt><code>unit_obsnames</code></dt><dd><p>A vector of observation types for a spatial unit.</p>
</dd>
<dt><code>eunit_measure</code></dt><dd><p>A pomp_fun representing the expected measurement for each spatial unit given its states.</p>
</dd>
<dt><code>dunit_measure</code></dt><dd><p>A pomp_fun representing the unit measurement density for each spatial unit.</p>
</dd>
<dt><code>runit_measure</code></dt><dd><p>A pomp_fun representing the unit observation simulator.</p>
</dd>
</dl>

<hr>
<h2 id='spatPomp-package'>Inference for SpatPOMPs (Spatiotemporal Partially Observed Markov Processes)</h2><span id='topic+spatPomp-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">spatPomp</span> package provides facilities for inference
on panel data using spatiotemporal partially-observed Markov process
(<abbr><span class="acronym">SpatPOMP</span></abbr>) models. To do so, it relies on and extends a number
of facilities that the <span class="pkg">pomp</span> package provides for inference on time
series data using partially-observed Markov process (<abbr><span class="acronym">POMP</span></abbr>) models.
</p>
<p>The <span class="pkg">spatPomp</span> package concerns models consisting of a collection
of interacting units. The methods in <span class="pkg">spatPomp</span> may be applicable
whether or not these units correspond to spatial locations.
</p>


<h3>Data analysis using <span class="pkg">spatPomp</span></h3>

<p>The first step in using <span class="pkg">spatPomp</span> is to encode one's model(s) and data
in objects of class <code>spatPomp</code>.
This can be done via a call to the <a href="#topic+spatPomp">spatPomp</a> constructor
function.
</p>


<h3>Extending the <span class="pkg">pomp</span> platform for developing inference tools</h3>

<p><span class="pkg">spatPomp</span> extends to panel data the general interface to the
components of <abbr><span class="acronym">POMP</span></abbr> models provided by <span class="pkg">pomp</span>. In doing so, it
contributes to the goal of the <span class="pkg">pomp</span> project of facilitating the
development of new algorithms in an environment where they can be tested
and compared on a growing body of models and datasets.
</p>


<h3>Documentation</h3>

<p><span class="pkg">spatPomp</span> is described by Asfaw et al. (2020)
</p>


<h3>License</h3>

<p><span class="pkg">spatPomp</span> is provided under the <abbr><span class="acronym">MIT</span></abbr> License.
</p>


<h3>Author(s)</h3>

<p>Kidus Asfaw, Joonha Park, Allister Ho, Edward Ionides, Aaron A. King
</p>


<h3>References</h3>

<p>Asfaw, K., Park, J., Ho, A., King, A. A., and Ionides, E. L. (2020) Partially observed Markov processes with spatial structure via the R package spatPomp. <em>ArXiv</em>: 2101.01157. <a href="https://doi.org/10.48550/arXiv.2101.01157">doi:10.48550/arXiv.2101.01157</a>
</p>


<h3>See Also</h3>

<p><a href="pomp.html#topic+pomp-package">pomp package</a>
</p>

<hr>
<h2 id='undefined'>Undefined</h2><span id='topic+undefined'></span><span id='topic+undefined+2CNULL-method'></span><span id='topic+undefined+2CANY-method'></span><span id='topic+undefined+2Cmissing-method'></span><span id='topic+undefined+2Cpomp_fun-method'></span><span id='topic+undefined+2CpartransPlugin-method'></span><span id='topic+undefined+2CrprocPlugin-method'></span><span id='topic+undefined+2Ccovartable-method'></span><span id='topic+undefined+2CskelPlugin-method'></span>

<h3>Description</h3>

<p>Check for undefined methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>undefined(object, ...)

## S4 method for signature 'NULL'
undefined(object, ...)

## S4 method for signature 'ANY'
undefined(object, ...)

## S4 method for signature 'missing'
undefined(object, ...)

## S4 method for signature 'pomp_fun'
undefined(object, ...)

## S4 method for signature 'partransPlugin'
undefined(object, ...)

## S4 method for signature 'rprocPlugin'
undefined(object, ...)

## S4 method for signature 'covartable'
undefined(object)

## S4 method for signature 'skelPlugin'
undefined(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="undefined_+3A_object">object</code></td>
<td>
<p>object to test.</p>
</td></tr>
<tr><td><code id="undefined_+3A_...">...</code></td>
<td>
<p>currently ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if the <span class="pkg">pomp</span> workhorse method is undefined,
<code>FALSE</code> if it is defined,
and <code>NA</code> if the question is inapplicable.
</p>

<hr>
<h2 id='unit_names'>Unit names of a spatiotemporal model</h2><span id='topic+unit_names'></span><span id='topic+unit_names-spatPomp'></span><span id='topic+unit_names+2CspatPomp-method'></span>

<h3>Description</h3>

<p><code>unit_names</code> outputs the contents of the <code>unit_names</code> slot
of a <code>spatPomp</code> object. The order in which the units
appear in the output vector determines the order in which latent
states and observations for the spatial units are stored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spatPomp'
unit_names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unit_names_+3A_x">x</code></td>
<td>
<p>a <code>spatPomp</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the unit names used to create the &lsquo;spatPomp&rsquo; object.
</p>

<hr>
<h2 id='vec_dmeasure'>Vector of measurement densities</h2><span id='topic+vec_dmeasure'></span><span id='topic+vec_dmeasure-spatPomp'></span><span id='topic+vec_dmeasure+2CspatPomp-method'></span>

<h3>Description</h3>

<p>Evaluate the unit measurement model density function for each unit.
This method is used primarily as part of likelihood evaluation and parameter inference algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spatPomp'
vec_dmeasure(object, y, x, units, times, params, log = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_dmeasure_+3A_object">object</code></td>
<td>
<p>a <code>spatPomp</code> object</p>
</td></tr>
<tr><td><code id="vec_dmeasure_+3A_y">y</code></td>
<td>
<p>numeric; measurements whose densities given the latent states are evaluated</p>
</td></tr>
<tr><td><code id="vec_dmeasure_+3A_x">x</code></td>
<td>
<p>numeric; state at which conditional measurement densities are evaluated</p>
</td></tr>
<tr><td><code id="vec_dmeasure_+3A_units">units</code></td>
<td>
<p>numeric; units at which measurement densities are evaluated</p>
</td></tr>
<tr><td><code id="vec_dmeasure_+3A_times">times</code></td>
<td>
<p>numeric; time at which measurement densities are evaluated</p>
</td></tr>
<tr><td><code id="vec_dmeasure_+3A_params">params</code></td>
<td>
<p>numeric; parameter set at which measurement densities is evaluated</p>
</td></tr>
<tr><td><code id="vec_dmeasure_+3A_log">log</code></td>
<td>
<p>logical; should the outputted measurement densities be on log scale?</p>
</td></tr>
<tr><td><code id="vec_dmeasure_+3A_...">...</code></td>
<td>
<p>additional parameters will be ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of dimension <code>length(unit_names(object))</code> by <code>dim(x)[2]</code> by <code>dim(x)[3]</code>
representing each unit's measurement density assessed for each replicate in <code>x</code> for each observation time.
</p>


<h3>Author(s)</h3>

<p>Kidus Asfaw
</p>

<hr>
<h2 id='vec_rmeasure'>Vector of simulated measurements</h2><span id='topic+vec_rmeasure'></span><span id='topic+vec_rmeasure-spatPomp'></span><span id='topic+vec_rmeasure+2CspatPomp-method'></span>

<h3>Description</h3>

<p>Simulate from the unit measurement model density function for each unit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spatPomp'
vec_rmeasure(object, x, times, params, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_rmeasure_+3A_object">object</code></td>
<td>
<p>a <code>spatPomp</code> object</p>
</td></tr>
<tr><td><code id="vec_rmeasure_+3A_x">x</code></td>
<td>
<p>numeric; state at which measurements are simulated</p>
</td></tr>
<tr><td><code id="vec_rmeasure_+3A_times">times</code></td>
<td>
<p>numeric; time at which measurements are simulated</p>
</td></tr>
<tr><td><code id="vec_rmeasure_+3A_params">params</code></td>
<td>
<p>numeric; parameter set at which measurements are simulated</p>
</td></tr>
<tr><td><code id="vec_rmeasure_+3A_...">...</code></td>
<td>
<p>additional parameters will be ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An array of dimension <code>length(unit_names(object))</code> by <code>dim(x)[2]</code> by <code>dim(x)[3]</code>
representing each unit's simulated measurement assessed for each replicate in <code>x</code> for each observation time.
</p>


<h3>Author(s)</h3>

<p>Kidus Asfaw
</p>

<hr>
<h2 id='vunit_measure'>vunit_measure</h2><span id='topic+vunit_measure'></span><span id='topic+vunit_measure-spatPomp'></span><span id='topic+vunit_measure+2CspatPomp-method'></span>

<h3>Description</h3>

<p><code>vunit_measure</code> evaluates the variance of a unit's observation given the entire state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'spatPomp'
vunit_measure(object, x, unit, time, params, Np = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vunit_measure_+3A_object">object</code></td>
<td>
<p>An object of class <code>spatPomp</code></p>
</td></tr>
<tr><td><code id="vunit_measure_+3A_x">x</code></td>
<td>
<p>A state vector for all units</p>
</td></tr>
<tr><td><code id="vunit_measure_+3A_unit">unit</code></td>
<td>
<p>The unit for which to evaluate the variance</p>
</td></tr>
<tr><td><code id="vunit_measure_+3A_time">time</code></td>
<td>
<p>The time for which to evaluate the variance</p>
</td></tr>
<tr><td><code id="vunit_measure_+3A_params">params</code></td>
<td>
<p>parameters at which to evaluate the unit variance</p>
</td></tr>
<tr><td><code id="vunit_measure_+3A_np">Np</code></td>
<td>
<p>numeric; defaults to 1 and the user need not change this</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the unit measurement variance implied by the state, <code>x</code>,
and the parameter set <code>params</code> for unit <code>unit</code>.
</p>


<h3>Author(s)</h3>

<p>Kidus Asfaw
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Complete examples are provided in the package tests
## Not run: 
b &lt;- bm(U=3)
s &lt;- states(b)[,1,drop=FALSE]
rownames(s) -&gt; rn
dim(s) &lt;- c(3,1,1)
dimnames(s) &lt;- list(variable=rn, rep=NULL)
p &lt;- coef(b); names(p) -&gt; rnp
dim(p) &lt;- c(length(p),1); dimnames(p) &lt;- list(param=rnp)
o &lt;- obs(b)[,1,drop=FALSE]
vunit_measure(b, x=s, unit=2, time=1, params=p)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
