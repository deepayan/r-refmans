<!DOCTYPE html><html><head><title>Help for package orloca.es</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {orloca.es}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#andalusia'><p>Ciudades de Andalucia</p></a></li>
<li><a href='#as-methods'><p>as-methods</p></a></li>
<li><a href='#as.data.frame.loca.p'><p>as.data.frame.loca.p Método S3 para convertir de loca.p a data.frame</p></a></li>
<li><a href='#as.loca.p'><p>as.loca.p Método para compatibilidad con clases S3, principalmente para el test de documentación</p></a></li>
<li><a href='#as.loca.p.data.frame'><p>as.loca.p.data.frame Método S3 para convertir de data.frame a loca.p</p></a></li>
<li><a href='#as.loca.p.matrix'><p>as-methods</p></a></li>
<li><a href='#as.matrix.loca.p'><p>as.matrix.loca.p Método para convertir de loca.p a matriz</p></a></li>
<li><a href='#contour.loca.p'><p>Gráfica de la función objetivo min-sum</p></a></li>
<li><a href='#distsum'><p>distsum y distsumgra del paquete orloca</p></a></li>
<li><a href='#distsumgra'><p>Calculo del gradiente de la funcion distsum</p></a></li>
<li><a href='#distsuml2min'><p>distsuml2min en el paquete orloca</p></a></li>
<li><a href='#distsumlp'><p>distsumlp y distsumlpgra del paquete orloca</p></a></li>
<li><a href='#distsumlpmin'><p>distsumlpmin en el paquete orloca</p></a></li>
<li><a href='#distsummin'><p>distsummin en el paquete orloca</p></a></li>
<li><a href='#loca.p-class'><p>Clase de objetos loca.p para Localizacion en Investigacion Operativa</p></a></li>
<li><a href='#orloca.es-package'><p>Spanish version of orloca package - Versión española del paquete orloca</p></a></li>
<li><a href='#persp.distsum'><p>Grafica de la funcion objetivo min-sum</p></a></li>
<li><a href='#plot'><p>Grafico de un objeto de la clase loca.p</p></a></li>
<li><a href='#rloca.p'><p>Generador de instancias aleatorias de objetos de la clase loca.p</p></a></li>
<li><a href='#zsum'><p>zsum</p></a></li>
<li><a href='#zsumgra'><p>zsumgra</p></a></li>
<li><a href='#zsuml2'><p>zsuml2 y zsuml2gra del paquete orloca</p></a></li>
<li><a href='#zsummin'><p>zsummin</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Depends:</td>
<td>orloca (&ge; 4.9)</td>
</tr>
<tr>
<td>Language:</td>
<td>es</td>
</tr>
<tr>
<td>Title:</td>
<td>Spanish version of orloca package. Modelos de localizacion en
investigacion operativa</td>
</tr>
<tr>
<td>Version:</td>
<td>4.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-03-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Manuel Munoz-Marquez &lt;manuel.munoz@uca.es&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Manuel Munoz-Marquez &lt;manuel.munoz@uca.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Help and demo in Spanish of the orloca package. (Ayuda y demo en espanol del paquete orloca.) Objetos y metodos para manejar y resolver el problema de localizacion de suma minima, tambien conocido como problema de Fermat-Weber. El problema de localizacion de suma minima busca un punto tal que la suma ponderada de las distancias a los puntos de demanda se minimice. Vease "The Fermat-Weber location problem revisited" por Brimberg, Mathematical Programming, 1, pag. 71-76, 1995. &lt;<a href="https://doi.org/10.1007%2FBF01592245">doi:10.1007/BF01592245</a>&gt;.
	     Se usan algoritmos generales de optimizacion global para resolver el problema, junto con el metodo adhoc Weiszfeld, vease "Sur le point pour lequel la Somme des distance de n points donnes est minimum", por Weiszfeld, Tohoku Mathematical Journal, First Series, 43, pag. 355-386, 1937 o "On the point for which the sum of the distances to n given points is minimum", por E. Weiszfeld y F. Plastria, Annals of Operations Research, 167, pg. 7-41, 2009. &lt;<a href="https://doi.org/10.1007%2Fs10479-008-0352-z">doi:10.1007/s10479-008-0352-z</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://knuth.uca.es/orloca">http://knuth.uca.es/orloca</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>orloca</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>55</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2020-03-06 08:24:32</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-06 16:30:02 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-06 13:10:08 UTC; rforge</td>
</tr>
</table>
<hr>
<h2 id='andalusia'>Ciudades de Andalucia</h2><span id='topic+andalucia'></span><span id='topic+andalusia'></span>

<h3>Description</h3>

<p>El conjunto de datos 'andalusia' tiene 12 filas y 4 columnas, que son la
posición geográfica de las capitales de provincia andaluzas.
</p>


<h3>Format</h3>

<p><code>name</code>: El nombre de una ciudad o de una etiqueta relativa de posición
</p>
<p><code>x</code>: La coordenada x de los puntos
</p>
<p><code>y</code>: La coordenada y de los puntos
</p>
<p><code>city</code>: Si yes entonces el punto es una ciudad, en otro caso es un límite.</p>


<h3>Uso</h3>

<p>data('andalusia')
</p>


<h3>Fuente</h3>

<p>Los datos se han tomado de wikipedia.
</p>


<h3>See Also</h3>

<p>Véase también <code><a href="#topic+orloca.es-package">orloca.es-package</a></code>.
</p>

<hr>
<h2 id='as-methods'>as-methods</h2><span id='topic+as-methods'></span><span id='topic+as.data.frame'></span><span id='topic+as.matrix'></span><span id='topic+as.loca.p+2Cdata.frame-method'></span><span id='topic+as.loca.p+2Cmatrix-method'></span>

<h3>Description</h3>

<p>Conversiones entre la clase loca.p y algunas otras</p>


<h3>Argumentos</h3>


<dl>
<dt>x:</dt><dd><p>es el objeto a convertir a la nueva clase.</p>
</dd>
<dt>row.names:</dt><dd><p>Sin uso.</p>
</dd>
<dt>optional:</dt><dd><p>Sin uso.</p>
</dd>
<dt>...:</dt><dd><p>Otros argumentos, sin uso.</p>
</dd>
</dl>



<h3>Valor</h3>

<p>Si el argumento tiene un valor válido devuelve un nuevo objeto de la nueva clase.
</p>


<h3>Detalles</h3>

<p>Métodos para convertir desde y a la clase <code>loca.p</code>.
</p>
<p>No se permiten valores NA en ningún argumento.
</p>
<p>La <code>matrix</code> a convertir en <code>loca.p</code> debe tener al menos dos columnas. 
La primera será  considerada como la coordenada x, y la segunda como la coordenada y, y la tercera (si se ha suministrado) serán los valores de w.
</p>
<p>El <code>data.frame</code> a convertir a <code>loca.p</code> debe tener al menos una columna <code>x</code> para la coordenada x, y una columna <code>y</code> para la coordenada y.
Opcionalmente, puede tener una columna <code>w</code> para los valores de w.
</p>


<h3>Ejemplos</h3>

<p># Un nuevo objeto loca.p
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
</p>
<p># Conversion a matrix
m &lt;- as.matrix(loca)
</p>
<p># Muestra la matrix
m
</p>
<p># Conversion desde matrix
as.loca.p(m)
</p>


<h3>Véase también</h3>

<p>Véase también <code><a href="#topic+loca.p">loca.p</a></code>
</p>

<hr>
<h2 id='as.data.frame.loca.p'>as.data.frame.loca.p Método S3 para convertir de loca.p a data.frame</h2><span id='topic+as.data.frame.loca.p'></span>

<h3>Description</h3>

<p>Conversiones entre la clase loca.p y algunas otras</p>


<h3>Argumentos</h3>


<dl>
<dt>x:</dt><dd><p>es el objeto a convertir a la nueva clase.</p>
</dd>
<dt>row.names:</dt><dd><p>Sin uso.</p>
</dd>
<dt>optional:</dt><dd><p>Sin uso.</p>
</dd>
<dt>...:</dt><dd><p>Otros argumentos, sin uso.</p>
</dd>
</dl>



<h3>Valor</h3>

<p>Si el argumento tiene un valor válido devuelve un nuevo objeto de la nueva clase.
</p>


<h3>Detalles</h3>

<p>Métodos para convertir desde y a la clase <code>loca.p</code>.
</p>
<p>No se permiten valores NA en ningún argumento.
</p>
<p>La <code>matrix</code> a convertir en <code>loca.p</code> debe tener al menos dos columnas. 
La primera será  considerada como la coordenada x, y la segunda como la coordenada y, y la tercera (si se ha suministrado) serán los valores de w.
</p>
<p>El <code>data.frame</code> a convertir a <code>loca.p</code> debe tener al menos una columna <code>x</code> para la coordenada x, y una columna <code>y</code> para la coordenada y.
Opcionalmente, puede tener una columna <code>w</code> para los valores de w.
</p>


<h3>Ejemplos</h3>

<p># Un nuevo objeto loca.p
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
</p>
<p># Conversion a matrix
m &lt;- as.matrix(loca)
</p>
<p># Muestra la matrix
m
</p>
<p># Conversion desde matrix
as.loca.p(m)
</p>


<h3>Véase también</h3>

<p>Véase también <code><a href="#topic+loca.p">loca.p</a></code>
</p>

<hr>
<h2 id='as.loca.p'>as.loca.p Método para compatibilidad con clases S3, principalmente para el test de documentación</h2><span id='topic+as.loca.p'></span>

<h3>Description</h3>

<p>Conversiones entre la clase loca.p y algunas otras</p>


<h3>Argumentos</h3>


<dl>
<dt>x:</dt><dd><p>es el objeto a convertir a la nueva clase.</p>
</dd>
<dt>row.names:</dt><dd><p>Sin uso.</p>
</dd>
<dt>optional:</dt><dd><p>Sin uso.</p>
</dd>
<dt>...:</dt><dd><p>Otros argumentos, sin uso.</p>
</dd>
</dl>



<h3>Valor</h3>

<p>Si el argumento tiene un valor válido devuelve un nuevo objeto de la nueva clase.
</p>


<h3>Detalles</h3>

<p>Métodos para convertir desde y a la clase <code>loca.p</code>.
</p>
<p>No se permiten valores NA en ningún argumento.
</p>
<p>La <code>matrix</code> a convertir en <code>loca.p</code> debe tener al menos dos columnas. 
La primera será  considerada como la coordenada x, y la segunda como la coordenada y, y la tercera (si se ha suministrado) serán los valores de w.
</p>
<p>El <code>data.frame</code> a convertir a <code>loca.p</code> debe tener al menos una columna <code>x</code> para la coordenada x, y una columna <code>y</code> para la coordenada y.
Opcionalmente, puede tener una columna <code>w</code> para los valores de w.
</p>


<h3>Ejemplos</h3>

<p># Un nuevo objeto loca.p
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
</p>
<p># Conversion a matrix
m &lt;- as.matrix(loca)
</p>
<p># Muestra la matrix
m
</p>
<p># Conversion desde matrix
as.loca.p(m)
</p>


<h3>Véase también</h3>

<p>Véase también <code><a href="#topic+loca.p">loca.p</a></code>
</p>

<hr>
<h2 id='as.loca.p.data.frame'>as.loca.p.data.frame Método S3 para convertir de data.frame a loca.p</h2><span id='topic+as.loca.p.data.frame'></span>

<h3>Description</h3>

<p>Conversiones entre la clase loca.p y algunas otras</p>


<h3>Argumentos</h3>


<dl>
<dt>x:</dt><dd><p>es el objeto a convertir a la nueva clase.</p>
</dd>
<dt>row.names:</dt><dd><p>Sin uso.</p>
</dd>
<dt>optional:</dt><dd><p>Sin uso.</p>
</dd>
<dt>...:</dt><dd><p>Otros argumentos, sin uso.</p>
</dd>
</dl>



<h3>Valor</h3>

<p>Si el argumento tiene un valor válido devuelve un nuevo objeto de la nueva clase.
</p>


<h3>Detalles</h3>

<p>Métodos para convertir desde y a la clase <code>loca.p</code>.
</p>
<p>No se permiten valores NA en ningún argumento.
</p>
<p>La <code>matrix</code> a convertir en <code>loca.p</code> debe tener al menos dos columnas. 
La primera será  considerada como la coordenada x, y la segunda como la coordenada y, y la tercera (si se ha suministrado) serán los valores de w.
</p>
<p>El <code>data.frame</code> a convertir a <code>loca.p</code> debe tener al menos una columna <code>x</code> para la coordenada x, y una columna <code>y</code> para la coordenada y.
Opcionalmente, puede tener una columna <code>w</code> para los valores de w.
</p>


<h3>Ejemplos</h3>

<p># Un nuevo objeto loca.p
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
</p>
<p># Conversion a matrix
m &lt;- as.matrix(loca)
</p>
<p># Muestra la matrix
m
</p>
<p># Conversion desde matrix
as.loca.p(m)
</p>


<h3>Véase también</h3>

<p>Véase también <code><a href="#topic+loca.p">loca.p</a></code>
</p>

<hr>
<h2 id='as.loca.p.matrix'>as-methods</h2><span id='topic+as.loca.p.matrix'></span>

<h3>Description</h3>

<p>Conversiones entre la clase loca.p y algunas otras</p>


<h3>Argumentos</h3>


<dl>
<dt>x:</dt><dd><p>es el objeto a convertir a la nueva clase.</p>
</dd>
<dt>row.names:</dt><dd><p>Sin uso.</p>
</dd>
<dt>optional:</dt><dd><p>Sin uso.</p>
</dd>
<dt>...:</dt><dd><p>Otros argumentos, sin uso.</p>
</dd>
</dl>



<h3>Valor</h3>

<p>Si el argumento tiene un valor válido devuelve un nuevo objeto de la nueva clase.
</p>


<h3>Detalles</h3>

<p>Métodos para convertir desde y a la clase <code>loca.p</code>.
</p>
<p>No se permiten valores NA en ningún argumento.
</p>
<p>La <code>matrix</code> a convertir en <code>loca.p</code> debe tener al menos dos columnas. 
La primera será  considerada como la coordenada x, y la segunda como la coordenada y, y la tercera (si se ha suministrado) serán los valores de w.
</p>
<p>El <code>data.frame</code> a convertir a <code>loca.p</code> debe tener al menos una columna <code>x</code> para la coordenada x, y una columna <code>y</code> para la coordenada y.
Opcionalmente, puede tener una columna <code>w</code> para los valores de w.
</p>


<h3>Ejemplos</h3>

<p># Un nuevo objeto loca.p
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
</p>
<p># Conversion a matrix
m &lt;- as.matrix(loca)
</p>
<p># Muestra la matrix
m
</p>
<p># Conversion desde matrix
as.loca.p(m)
</p>


<h3>Véase también</h3>

<p>Véase también <code><a href="#topic+loca.p">loca.p</a></code>
</p>

<hr>
<h2 id='as.matrix.loca.p'>as.matrix.loca.p Método para convertir de loca.p a matriz</h2><span id='topic+as.matrix.loca.p'></span>

<h3>Description</h3>

<p>Conversiones entre la clase loca.p y algunas otras</p>


<h3>Argumentos</h3>


<dl>
<dt>x:</dt><dd><p>es el objeto a convertir a la nueva clase.</p>
</dd>
<dt>row.names:</dt><dd><p>Sin uso.</p>
</dd>
<dt>optional:</dt><dd><p>Sin uso.</p>
</dd>
<dt>...:</dt><dd><p>Otros argumentos, sin uso.</p>
</dd>
</dl>



<h3>Valor</h3>

<p>Si el argumento tiene un valor válido devuelve un nuevo objeto de la nueva clase.
</p>


<h3>Detalles</h3>

<p>Métodos para convertir desde y a la clase <code>loca.p</code>.
</p>
<p>No se permiten valores NA en ningún argumento.
</p>
<p>La <code>matrix</code> a convertir en <code>loca.p</code> debe tener al menos dos columnas. 
La primera será  considerada como la coordenada x, y la segunda como la coordenada y, y la tercera (si se ha suministrado) serán los valores de w.
</p>
<p>El <code>data.frame</code> a convertir a <code>loca.p</code> debe tener al menos una columna <code>x</code> para la coordenada x, y una columna <code>y</code> para la coordenada y.
Opcionalmente, puede tener una columna <code>w</code> para los valores de w.
</p>


<h3>Ejemplos</h3>

<p># Un nuevo objeto loca.p
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
</p>
<p># Conversion a matrix
m &lt;- as.matrix(loca)
</p>
<p># Muestra la matrix
m
</p>
<p># Conversion desde matrix
as.loca.p(m)
</p>


<h3>Véase también</h3>

<p>Véase también <code><a href="#topic+loca.p">loca.p</a></code>
</p>

<hr>
<h2 id='contour.loca.p'>Gráfica de la función objetivo min-sum</h2><span id='topic+contour+2Cloca.p-method'></span><span id='topic+contour.loca.p'></span>

<h3>Description</h3>

<p><code>contour</code> proporcionan la representación gráfica de la función del problema min-sum (<code>zsum</code>).
</p>


<h3>Uso</h3>

<p>## Método S3 para la clase 'loca.p'
</p>
<p>contour(x, lp = numeric(0), xmin = min(min(x@x), xleft),
xmax = max(max(x@x), xright), ymin = min(min(x@y), ybottom),
ymax = max(max(x@y), ytop), n = 100, img = NULL, xleft = min(x@x),
ybottom = min(x@y), xright = max(x@x), ytop = max(x@y), ...)
</p>


<h3>Argumentos</h3>


<dl>
<dt>x:</dt><dd><p>El objeto <code>loca.p</code> para calcular el objetivo.</p>
</dd>
<dt>lp:</dt><dd><p>Si se proporciona, entonces se usa la norma <code class="reqn">l_p</code> en vez de la euclídea.</p>
</dd>
<dt>xmin:</dt><dd><p>El valor mínimo del eje x.</p>
</dd>
<dt>xmax:</dt><dd><p>El valor máximo del eje x.</p>
</dd>
<dt>ymin:</dt><dd><p>El valor mínimo del eje y.</p>
</dd>
<dt>ymax:</dt><dd><p>El valor máximo del eje y.</p>
</dd>
<dt>n:</dt><dd><p>El número de divisiones para la rejilla.</p>
</dd>
<dt>img:</dt><dd><p>Una imagen en formato raster para el fondo.</p>
</dd>
<dt>xleft:</dt><dd><p>Posición del borde izquierdo de la imagen.</p>
</dd>
<dt>ybottom:</dt><dd><p>Posición del borde inferior de la imagen.</p>
</dd>
<dt>xright:</dt><dd><p>Posición del borde derecho de la imagen.</p>
</dd>
<dt>ytop:</dt><dd><p>Posición del borde superior de la imagen.</p>
</dd>
<dt>...:</dt><dd><p>Otras opciones.</p>
</dd>
</dl>



<h3>Detalles</h3>

<p>Si <code class="reqn">p &lt; 1</code> entonces <code class="reqn">l_p</code> no es norma, por
tanto, sólo <code class="reqn">p \ge 1</code> es válido.</p>


<h3>Valor</h3>

<p>La función <code>contour.loca.p</code> representa un
gráfico de curvas de nivel de la función
min-sum (<code>zsum</code>).
</p>


<h3>Véase también</h3>

<p>Véase también <code><a href="#topic+orloca.es-package">orloca.es-package</a></code>, <code><a href="#topic+plot.loca.p">plot.loca.p</a></code> y <code><a href="#topic+loca.p">loca.p</a></code>.</p>


<h3>Ejemplos</h3>

<p># Un objeto loca.p sin pesos
</p>
<p>loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
</p>
<p># El grafico de curvas de nivel de la fucion min-sum para el objeto
</p>
<p>contour(loca)
</p>

<hr>
<h2 id='distsum'>distsum y distsumgra del paquete orloca</h2><span id='topic+distsum'></span><span id='topic+distsum+2Cloca.p-method'></span>

<h3>Description</h3>

<p>La función objetivo para el problema de
localización min-sum.
</p>


<h3>Uso</h3>

<p>distsum(o, x=0, y=0, lp=numeric(0))
</p>


<h3>Argumentos</h3>


<dl>
<dt>o:</dt><dd><p>Un objeto de la clase <code>loca.p</code></p>
</dd>
<dt>x:</dt><dd><p>La coordenada x del punto a ser evaluado</p>
</dd>
<dt>y:</dt><dd><p>La coordenada y del punto a ser evaluado</p>
</dd>
<dt>lp:</dt><dd><p>Si se proporciona, entonces se usa la norma <code class="reqn">l_p</code> en vez
de la euclídea</p>
</dd>
</dl>



<h3>Valor</h3>

<p><code>distsum</code> devuelve la función objetivo para el
problema de localización min-sum, <code class="reqn">\sum_{a_i
      \in o} w_i d(a_i, (x,y))</code>, donde <code class="reqn">d(a_i, (x,y))</code> es la
distancia euclídea o la distancia <code class="reqn">l_p</code> entre <code class="reqn">a_i</code> y <code class="reqn">(x,y)</code>. 
</p>


<h3>Detalles</h3>

<p>La función zsum está marcada como obsoleta
y será borrada de nuevas versiones del paquete.
</p>


<h3>Véase también</h3>

<p>Véase también <code><a href="#topic+orloca.es-package">orloca.es-package</a></code> y <code><a href="#topic+distsummin">distsummin</a></code>.
</p>


<h3>Ejemplos</h3>

<p># Un nuevo objeto loca.p sin pesos
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
</p>
<p># Evaluacion de distsum en (0, 0)
distsum(loca)
</p>
<p># Evaluacion de distsum at (1, 3)
distsum(loca, 1, 3)
</p>
<p># Calculo de la fucion objetivo en el punto (3, 4) usando la norma lp con p = 2.5
distsum(loca, 3, 4, lp=2.5)
</p>
<p># La funcion gradiente en (1,3)
distsumgra(loca, 1, 3)
</p>

<hr>
<h2 id='distsumgra'>Calculo del gradiente de la funcion distsum</h2><span id='topic+distsumgra'></span><span id='topic+distsumgra+2Cloca.p-method'></span>

<h3>Description</h3>

<p><code>distsumgra</code> calcula el
gradiente de la fución distsum</p>


<h3>Uso</h3>

<p>distsumgra(o, x = 0, y = 0, lp = numeric(0), partial = F)
</p>


<h3>Argumentos</h3>


<dl>
<dt>o</dt><dd><p>Un objeto de clase <code>loca.p</code>.</p>
</dd>
<dt>x</dt><dd><p>La coordenada x del punto a evaluar.</p>
</dd>
<dt>y</dt><dd><p>La coordenada y del punto a evaluar.</p>
</dd>
<dt>lp</dt><dd><p>Si se proporciona, la norma <code class="reqn">l_p</code> será usada en vez de
la norma euclídea.</p>
</dd>
<dt>partial</dt><dd><p>Si (x,y) es un punto de demanda <code>partial=T</code>
significa que se ignore dicho punto para el cálculo del
gradiente. Esta opción es principalmente para uso interno.</p>
</dd>
</dl>



<h3>Valor</h3>

<p><code>distsumgra</code> devuelve el vector gradiente de la función
min-sum del problema de localización, <code class="reqn">\sum_{a_i \in o} w_i
  d(a_i, (x,y))</code>, donde <code class="reqn">d(a_i, (x,y))</code> da la distancia
euclídea o la distancia <code class="reqn">l_p</code> entre <code class="reqn">a_i</code> y el punto <code class="reqn">(x,y)</code>.
</p>


<h3>Detalles</h3>

<p>La función zsumgra está marcada como obsoleta
y será borrada de nuevas versiones del paquete.
</p>


<h3>Ejemplos</h3>

<p># Un nuevo objeto loca.p no ponderado
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
</p>
<p># Evaluacion de distsum en (0, 0)
distsum(loca)
</p>
<p># Evaluacion de distsum en (1, 3)
distsum(loca, 1, 3)
</p>
<p># Calculo de la funcion objetivo en el punto (3, 4) usando la norma lp con p = 2.5
distsum(loca, 3, 4, lp=2.5)
</p>
<p># El gradiente de la funcion en el punto (1,3)
distsumgra(loca, 1, 3)
</p>


<h3>See Also</h3>

<p>Véase <code><a href="orloca.html#topic+orloca-package">orloca-package</a></code> y <code><a href="#topic+distsum">distsum</a></code>.
</p>

<hr>
<h2 id='distsuml2min'>distsuml2min en el paquete orloca</h2><span id='topic+distsuml2min'></span><span id='topic+distsuml2min+2Cloca.p-method'></span>

<h3>Description</h3>

<p>La función <code>distsummin</code> para la norma
euclídea (<code class="reqn">l_2</code>). Principalmente para uso interno.</p>


<h3>Uso</h3>

<p>distsuml2min(o, x=0, y=0, max.iter=100, eps=0.001, verbose=FALSE,
algorithm=&quot;Weiszfeld&quot;, ...)
</p>


<h3>Argumentos</h3>


<dl>
<dt>o</dt><dd><p>Un objeto de la clase <code>loca.p</code>.</p>
</dd>
<dt>x</dt><dd><p>La coordenada x del punto inicial.</p>
</dd>
<dt>y</dt><dd><p>La coordenada y del punto inicial.</p>
</dd>
<dt>max.iter</dt><dd><p>Número máximo de iteraciones permitido.</p>
</dd>
<dt>eps</dt><dd><p>La norma del gradiente en la regla de parada.</p>
</dd>
<dt>verbose</dt><dd><p>Si es TRUE la función proporciona salida
detallada.</p>
</dd>
<dt>algorithm</dt><dd><p>El algoritmo a utilizar. Los valores válidos son: &quot;gradient&quot; para un algoritmo de gradiente, &quot;search&quot; para un algoritmo de búsqueda local (esta
opción está obsoleta), &quot;Weiszfeld&quot; para el algoritmo de Weiszfeld o cualquiera de los métodos válidos para la
función optim, a saber, &quot;Nelder-Mead&quot;, &quot;BFGS&quot;, &quot;CG&quot;, &quot;L-BFGS-B&quot;, &quot;SANN&quot;. 
&quot;Weiszfeld&quot; es el valor por defecto.</p>
</dd>
<dt>...</dt><dd><p>Otras opciones para los algoritmos de
optimización.</p>
</dd>
</dl>



<h3>Valor</h3>

<p><code>distsummin</code> devuelve un vector con las coordenadas del punto solución.
</p>


<h3>Detalles</h3>

<p>Los algoritmos de Weiszfeld y gradiente incluyen un test de
optimalidad para los puntos de demanda. El algoritmo de Weiszfeld
también implementa un test de convergencia lenta y un
procedimiento acelerador.
</p>
<p>Si <code class="reqn">p &lt; 1</code> entonces <code class="reqn">l_p</code> no es una norma, por ello, solo se
admiten valores <code class="reqn">p \ge 1</code>.
</p>
<p><code class="reqn">l_2</code> es la norma euclídea, cuando <code class="reqn">p=2</code>
<code>distsumlpmin</code> es igual a <code>distsuml2min</code>. Pero los
cálculos involucrados en la primera forma son mucho
mayores.
</p>
<p>max.iter en el algoritmo SANN es el número de
evaluaciones de la función objetivo, por lo que este
método requiere de valores grandes de max.iter para
alcanzar el óptimo.
</p>
<p>La función zsuml2min está marcada como obsoleta
y será borrada de nuevas versiones del paquete.
</p>


<h3>Véase también</h3>

<p>Vea también <code><a href="#topic+orloca.es-package">orloca.es-package</a></code>, <code><a href="#topic+loca.p">loca.p</a></code> y <code><a href="#topic+distsum">distsum</a></code>.
</p>

<hr>
<h2 id='distsumlp'>distsumlp y distsumlpgra del paquete orloca</h2><span id='topic+distsumlp'></span><span id='topic+distsumlp+2Cloca.p-method'></span><span id='topic+distsumlpgra'></span><span id='topic+distsumlpgra+2Cloca.p-method'></span>

<h3>Description</h3>

<p>Las funciones distsum y distsumgra con norma
<code class="reqn">l_p</code>. Principalmente para uso interno.</p>


<h3>Uso</h3>

<p>distsumlp(o, x=0, y=0, p=2)
distsumlpgra(o, x=0, y=0, p=2, partial=F)
</p>


<h3>Argumentos</h3>


<dl>
<dt>o</dt><dd><p>Un objeto de clase <code>loca.p</code>.</p>
</dd>
<dt>x</dt><dd><p>La coordenada x del punto a ser evaluado.</p>
</dd>
<dt>y</dt><dd><p>La coordenada y del punto a ser evaluado.</p>
</dd>
<dt>p</dt><dd><p>La norma <code class="reqn">l_p</code> a usar.</p>
</dd>
<dt>partial</dt><dd><p>Si (x,y) es un punto de demanda, <code>partial=T</code>
significa que se ignore dicho punto para el cálculo del
gradiente. Principalmente para uso interno.</p>
</dd>
</dl>



<h3>Valor</h3>

<p><code>distsumlp</code> devuelve el valor de la función objetivo
del problema de localización min-sum con norma
<code class="reqn">l_p</code>, <code class="reqn">\sum_{a_i \in o} w_i d(a_i, (x,y))</code>, donde <code class="reqn">d(a_i,
    (x,y))</code> es la distancia entre <code class="reqn">a_i</code> y el punto <code class="reqn">(x,y)</code>
usando la norma <code class="reqn">l_p</code>. 
</p>
<p><code>distsumlpgra</code> devuelve el vector gradiente de la función <code>distsumlp</code>.
</p>


<h3>Details</h3>

<p>Si <code class="reqn">p&lt;1</code> entonces <code class="reqn">l_p</code> no es una norma, por tanto, sólo valores
<code class="reqn">p&gt;=1</code> son válidos.
</p>
<p>Dado que <code class="reqn">l_2</code> es la norma euclídea, cuando <code class="reqn">p=2</code>
<code>distsumlp</code> es igual a <code>distsum</code>, y <code>distsumlpgra</code> es igual a
<code>distsumgra</code>. Pero los cálculos necesarios son
mayores para la primera forma.
</p>
<p>La función zsumlp está marcada como obsoleta
y será borrada de nuevas versiones del paquete.
</p>


<h3>Véase también</h3>

<p>Véase también <code><a href="#topic+distsum">distsum</a></code>, <code><a href="#topic+orloca.es-package">orloca.es-package</a></code> y <code><a href="#topic+distsumlpmin">distsumlpmin</a></code>.
</p>

<hr>
<h2 id='distsumlpmin'>distsumlpmin en el paquete orloca</h2><span id='topic+distsumlpmin'></span><span id='topic+distsumlpmin+2Cloca.p-method'></span>

<h3>Description</h3>

<p>La función <code>distsummin</code> con norma
<code class="reqn">l_p</code>. Principalmente para uso interno.</p>


<h3>Uso</h3>

<p>distsumlpmin(o, x=0, y=0, p=2, max.iter=100, eps=1.e-3, 
verbose=FALSE, algorithm=&quot;Weiszfeld&quot;, ...)
</p>


<h3>Argumentos</h3>


<dl>
<dt>o</dt><dd><p>Un objeto de la clase <code>loca.p</code>.</p>
</dd>
<dt>x</dt><dd><p>La coordenada x del punto inicial.</p>
</dd>
<dt>y</dt><dd><p>La coordenada y del punto inicial.</p>
</dd>
<dt>p</dt><dd><p>Valor de p para la norma <code class="reqn">l_p</code>.</p>
</dd>
<dt>max.iter</dt><dd><p>Número máximo de iteraciones permitido.</p>
</dd>
<dt>eps</dt><dd><p>El módulo del gradiente para la regla de
parada.</p>
</dd>
<dt>verbose</dt><dd><p>Si es TRUE la función proporciona salida
detallada.</p>
</dd>
<dt>algorithm</dt><dd><p>El algoritmo a utilizar. Para esta
versión del paquete, los valores
válidos son: &quot;gradient&quot; para un algoritmo de
gradiente, &quot;search&quot; para un algoritmo de
búsqueda local (esta opción
está obsoleta), &quot;Weiszfeld&quot; para el algoritmo de
Weiszfeld o cualquiera de los métodos
válidos para la función optim, a
saber, &quot;Nelder-Mead&quot;, &quot;BFGS&quot;, &quot;CG&quot;, &quot;L-BFGS-B&quot;, &quot;SANN&quot;. &quot;Weiszfeld&quot;
es el valor por defecto.</p>
</dd>
<dt>...</dt><dd><p>Otras opciones para los algoritmos de
optimización.</p>
</dd>
</dl>



<h3>Detalles</h3>

<p>Si <code class="reqn">p&lt;1</code> entonces <code class="reqn">l_p</code> no es una norma, por tanto,
sólo valores <code class="reqn">p&gt;=1</code> son válidos.
</p>
<p>Dado que <code class="reqn">l_2</code> es la norma euclídea, para <code class="reqn">p=2</code>
<code>distsumlpmin</code> es equivalente a <code>distsummin</code>. Pero los
cálculos involucrados son mayores en la primera forma.
</p>
<p>La función zsumlpmin está marcada como obsoleta
y será borrada de nuevas versiones del paquete.
</p>


<h3>Valor</h3>

<p><code>distsummin</code> devuelve un vector con las coordenadas del punto solución.
</p>


<h3>Ejemplos</h3>

<p># Un nuevo objeto loca.p
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
</p>
<p># Calcular el minimo
sol&lt;-distsummin(loca)
</p>
<p># Mostrar el resultado
sol
</p>
<p># Evaluar la funcion en el punto solucion
distsum(loca, sol[1], sol[2])
</p>


<h3>Véase también</h3>

<p><code>Véase</code>Vease también <code><a href="#topic+distsummin">distsummin</a></code>, <code><a href="#topic+orloca.es-package">orloca.es-package</a></code>, <code><a href="#topic+loca.p">loca.p</a></code> y <code><a href="#topic+distsum">distsum</a></code>.
</p>

<hr>
<h2 id='distsummin'>distsummin en el paquete orloca</h2><span id='topic+distsummin'></span><span id='topic+distsummin+2Cloca.p-method'></span>

<h3>Description</h3>

<p>Resuelve el problema de localización min-sum para un objeto dado de la clase <code>loca.p</code>.
</p>


<h3>Uso</h3>

<p>distsummin(o, x=0, y=0, lp=numeric(0), max.iter=100, eps=1.e-3, 
verbose=FALSE, algorithm=&quot;Weiszfeld&quot;, ...)
</p>


<h3>Argumentos</h3>


<dl>
<dt>o</dt><dd><p>Un objeto de la clase <code>loca.p</code>.</p>
</dd>
<dt>x</dt><dd><p>La coordenada x del punto inicial.</p>
</dd>
<dt>y</dt><dd><p>La coordenada y del punto inicial.</p>
</dd>
<dt>lp</dt><dd><p>Si se proporciona, la norma <code class="reqn">l_p</code> se usa en vez de la norma euclídea.</p>
</dd>
<dt>max.iter</dt><dd><p>Número máximo de iteraciones permitido.</p>
</dd>
<dt>eps</dt><dd><p>La norma del gradiente en la regla de parada.</p>
</dd>
<dt>verbose</dt><dd><p>Si es TRUE la función proporciona salida
detallada.</p>
</dd>
<dt>algorithm</dt><dd><p>El algoritmo a utilizar. En esta
versión del paquete los valores
válidos son: &quot;gradient&quot; o &quot;g&quot; para el
método basado en gradiente, &quot;search&quot; o &quot;s&quot;
para el método de búsqueda local,
&quot;ucminf&quot; o &quot;u&quot; para usar optimizar usando ucminf del paquete ucminf,
y &quot;weiszfeld&quot; o &quot;w&quot; para el método de Weiszfeld o
cualquier otro método válido para la
función optim, ahora &quot;Nelder-Mead&quot;, &quot;BFGS&quot;, &quot;CG&quot;,
&quot;L-BFGS-B&quot;, &quot;SANN&quot;. &quot;weiszfeld&quot; es el valor por defecto.</p>
</dd>
<dt>...</dt><dd><p>Otras opciones para los algoritmos de optimización.</p>
</dd>
</dl>



<h3>Detalles</h3>

<p>Los algoritmos de Weiszfeld y gradiente incluyen un test de
optimalidad para los puntos de demanda. El algoritmo de Weiszfeld
también implementa un test de convergencia lenta y un
procedimiento acelerador.
</p>
<p>Si <code class="reqn">p &lt; 1</code> entonces <code class="reqn">l_p</code> no es una norma, por tanto,
sólo <code class="reqn">p \ge 1</code> es válido.
</p>
<p><code class="reqn">l_2</code> es la norma euclídea, cuando <code class="reqn">p=2</code>
<code>distsumlpmin</code> es igual a <code>distsuml2min</code>. Pero los
cálculos involucrados en la primera forma son mucho
mayores.
</p>
<p>max.iter en el algoritmo SANN es el número de
evaluaciones de la función objetivo, por lo que este
método requiere de valores grandes de max.iter para
alcanzar el óptimo.
</p>
<p>La función zsummin está marcada como obsoleta
y será borrada de nuevas versiones del paquete.
</p>


<h3>Valor</h3>

<p><code>distsummin</code> devuelve un vector con las coordenadas del punto solución.
</p>


<h3>Véase también</h3>

<p><code>Véase</code>Vease también <code><a href="#topic+orloca.es-package">orloca.es-package</a></code>, <code><a href="#topic+loca.p">loca.p</a></code> y <code><a href="#topic+distsum">distsum</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Un objeto loca.p sin pesos
loca &lt;- new("loca.p", x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))

# Calcula el minimo
sol &lt;- distsummin(loca)

# Muestra el resultado
sol

# Evaluacion de la funcion objetivo en el punto solucion
distsum(loca, sol[1], sol[2])
</code></pre>

<hr>
<h2 id='loca.p-class'>Clase de objetos loca.p para Localizacion en Investigacion Operativa</h2><span id='topic+loca.p'></span><span id='topic+print'></span><span id='topic+summary'></span><span id='topic+initialize'></span>

<h3>Description</h3>

<p>Un objeto de la clase <code>loca.p</code> representa un problema de
localización ponderado con un conjunto finito de
puntos de demanda en el plano. 
El <code><a href="#topic+orloca.es-package">orloca.es-package</a></code> está principalmente
dedicado a abordar problemas de localización plana.
</p>


<h3>Argumentos</h3>


<dl>
<dt>x:</dt><dd><p>es un vector con las coordenadas x de los puntos de demanda</p>
</dd>
<dt>y:</dt><dd><p>es un vector con las coordenadas y de los puntos de demanda</p>
</dd>
<dt>w:</dt><dd><p>es un vector de pesos de los puntos de demanda. Si <code>w</code> se omite
entonces todos los pesos se consideran iguales a 1</p>
</dd>
<dt>label:</dt><dd><p>Si se explicita, es la etiqueta del nuevo objeto</p>
</dd>
</dl>



<h3>Detalles</h3>

<p>El principal generador es <code>loca.p(x, y, w = numeric(0), label = "")</code> o alternativamente  <code>new("loca.p", x, y, w = numeric(0), label = "")</code>.
</p>
<p>Las longitudes de los vectores <code>x</code> e <code>y</code> deben ser iguales. La longitud de <code>w</code> debe ser igual a los anteriores o 0. Los valores NA no están permitidos en ninguno de los argumentos.
</p>


<h3>Valor</h3>

<p>Si los argumentos son valores válidos, devuelve un objeto de la clase
<code>loca.p</code>, en caso contrario devuelve un error.
<code>summary(x)</code> devuelve un resumen del objeto <code>x</code> de la clase <code>loca.p</code> y
<code>print(x)</code> imprime el objeto <code>x</code> de la clase <code>loca.p</code>
en formato tabla.
</p>


<h3>Véase también</h3>

<p>Véase también <code><a href="#topic+orloca.es-package">orloca.es-package</a></code>.</p>


<h3>Ejemplos</h3>

<p># Un objeto loca.p sin pesos
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
</p>
<p># o
loca &lt;- new(&quot;loca.p&quot;, x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
</p>
<p># Un ejemplo con pesos y nombre
locb &lt;- new(&quot;loca.p&quot;, x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1), w = c(1, 2, 1, 2), label = &quot;Caso Ponderado&quot;)
</p>

<hr>
<h2 id='orloca.es-package'>Spanish version of orloca package - Versión española del paquete orloca</h2><span id='topic+orloca.es-package'></span><span id='topic+orloca'></span><span id='topic+orloca.es'></span>

<h3>Description</h3>

<p>Ayuda y demo en español del paquete orloca. 
</p>
<p>Objetos y métodos para manejar y resolver el problema de
localización de suma ponderada mínima, también
conocido como problema de Fermat-Weber.</p>


<h3>Detalles</h3>

<p>El problema de localización de suma mínima busca un
punto tal que la suma ponderada de las distancias a los puntos de
demanda se minimice. Véase
&quot;The Fermat-Weber location problem revisited&quot; por Brimberg,
Mathematical Programming, 1, pag. 71-76, 1995. &lt;DOI:
10.1007/BF01592245&gt;. 
</p>
<p>Se usan algoritmos generales de optimización global para
resolver el problema, junto con el método adhoc Weiszfeld, véase
&quot;Sur le point pour lequel la Somme des distance de n points donnes est minimum&quot;, por Weiszfeld, Tohoku Mathematical Journal, First Series, 43, pag. 355-386, 1937 o &quot;On the point for which the sum of the distances to n given points is minimum&quot;, por E. Weiszfeld y F. Plastria, Annals of Operations Research, 167, pg. 7-41, 2009. &lt;DOI:10.1007/s10479-008-0352-z&gt;.
</p>
<pre>
Package:   orloca.es
Type:      Package
Version:   4.9
Date:      2020-03-06
License:   GPL (&gt;= 3)
</pre>
<p>El paquete proporciona una clase, <code>loca.p</code>, que representa un problema de localización con un conjunto finito de puntos de demanda sobre el plano. También es posible representar los puntos y la función objetivo. Dicha función objetivo representa la suma de los desplazamientos de los usuarios al servicio.
</p>
<p>El problema de localización no plano será  abordado en futuras versiones del paquete.
</p>
<p>Para una demostración, cargue el paquete con <code>library(orloca.es)</code> y use <code>demo(orloca)</code>.
</p>
<p>El paquete está  preparado para su
internacionalización.
Las traducciones de los ficheros .mo recibidas serán añadidas en próximas versiones del paquete.
</p>


<h3>Autor</h3>

<p>Manuel  Munoz-Marquez &lt;manuel.munoz@uca.es&gt;
</p>
<p>Mantenedor: Manuel Munoz-Marquez &lt;manuel.munoz@uca.es&gt;
</p>


<h3>Referencias</h3>

<p>[1] Brimberg, J. <em>The Fermat-Weber location problem revisited</em>, Mathematical Programming, 1, pg. 71-76, 1995. <a href="https://doi.org/10.1007/BF01592245">https://doi.org/10.1007/BF01592245</a>.
</p>
<p>[2] Love, R. F., Morris, J. G., Wesolowsky, G. O. <em>Facilities Location: Chapter 2: Introduction to Single-Facility Location</em>, 1988, North-Holland
</p>
<p>[3] <a href="http://knuth.uca.es/orloca">http://knuth.uca.es/orloca</a>
</p>


<h3>Véase también</h3>

<p>For the English version of the package see <a href="orloca.html#topic+orloca-package">orloca-package</a>.</p>


<h3>Ejemplos</h3>

<p># Un objeto loca.p no ponderado
o &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
</p>
<p># Calcula la funcion objetivo en el punto (3, 4)
zsum(o, 3, 4)
</p>
<p># Calcula ls suma de las distancias al punto (3, 4) usando la norma lp
zsum(o, 3, 4, lp=2.5)
</p>
<p># Resuelve el problema de localizacion
zsummin(o)
</p>
<p># Curvas de nivel
contour(o)
</p>
<p># Ejecuta una demo del paquete
demo(orloca)
</p>

<hr>
<h2 id='persp.distsum'>Grafica de la funcion objetivo min-sum</h2><span id='topic+persp.loca.p'></span><span id='topic+persp+2Cloca.p-method'></span>

<h3>Description</h3>

<p><code>persp</code> proporciona la representación gráfica de la función objetivo del problema min-sum (<code>distsum</code>).
</p>


<h3>Uso</h3>

<p>## Metodo S3 para la clase <code>loca.p</code>
</p>
<p>persp(x, lp=numeric(0), xmin=min(x@x), xmax=max(x@x),
ymin=min(x@y), ymax=max(x@y), n=10, ...)
</p>


<h3>Argumentos</h3>


<dl>
<dt>x:</dt><dd><p>El objeto <code>loca.p</code> para calcular el objetivo</p>
</dd>
<dt>lp:</dt><dd><p>Si se proporciona, entonces se usa la norma <code class="reqn">l_p</code> en vez de la euclídea</p>
</dd>
<dt>xmin:</dt><dd><p>El valor mínimo del eje x</p>
</dd>
<dt>xmax:</dt><dd><p>El valor máximo del eje x</p>
</dd>
<dt>ymin:</dt><dd><p>El valor mínimo del eje y</p>
</dd>
<dt>ymax:</dt><dd><p>El valor máximo del eje y</p>
</dd>
<dt>n:</dt><dd><p>El número de divisiones para la rejilla</p>
</dd>
<dt>...</dt><dd><p>Otras opciones</p>
</dd>
</dl>



<h3>Detalles</h3>

<p>Si <code class="reqn">p &lt; 1</code> entonces <code class="reqn">l_p</code> no es norma, por tanto, sólo <code class="reqn">p \ge 1</code> es válido.</p>


<h3>Valor</h3>

<p>Un gráfico 3D de la función min-sum.
</p>


<h3>Véase también</h3>

<p>Véase también <code><a href="#topic+orloca.es-package">orloca.es-package</a></code>, <code><a href="#topic+plot.loca.p">plot.loca.p</a></code> y <code><a href="#topic+loca.p">loca.p</a></code>.</p>


<h3>Ejemplos</h3>

<p># Un objeto loca.p sin pesos
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
</p>
<p># El grafico 3D del objeto loca.p
persp(loca)
</p>

<hr>
<h2 id='plot'>Grafico de un objeto de la clase loca.p</h2><span id='topic+plot'></span><span id='topic+plot.loca.p'></span>

<h3>Description</h3>

<p>Este método proporciona una representación gráfica de un objeto de la clase <code>loca.p</code>.
</p>


<h3>Uso</h3>

<p>## Metodo S3 para la clase 'loca.p'
</p>
<p>plot(x, xlab = &quot;&quot;, ylab = &quot;&quot;,
main = gettext(&quot;Plot of loca.p object&quot;, domain = &quot;R-orloca&quot;), img = NULL,
xlim = c(min(xleft, min(x@x)), max(xright, max(x@x))),
ylim = c(min(ybottom, min(x@y)), max(ytop, max(x@y))), xleft = min(x@x),
ybottom = min(x@y), xright = max(x@x), ytop = max(x@y), ...)
</p>


<h3>Argumentos</h3>


<dl>
<dt>x:</dt><dd><p>El objeto <code>loca.p</code> a representar.</p>
</dd>
<dt>xlab:</dt><dd><p>La etiqueta para el eje x.</p>
</dd>
<dt>ylab:</dt><dd><p>La etiqueta para el eje y.</p>
</dd>
<dt>main:</dt><dd><p>El título principal del gráfico.</p>
</dd>
<dt>img:</dt><dd><p>Una imagen en formato raster para el fondo.</p>
</dd>
<dt>xlim:</dt><dd><p>Límite sobre el eje x del gráfico.</p>
</dd>
<dt>ylim:</dt><dd><p>Límite sobre el eje y del gráfico.</p>
</dd>
<dt>xleft:</dt><dd><p>Posición del borde izquierdo de la imagen.</p>
</dd>
<dt>ybottom:</dt><dd><p>Posición del borde inferior de la imagen.</p>
</dd>
<dt>xright:</dt><dd><p>Posición del borde derecho de la imagen.</p>
</dd>
<dt>ytop:</dt><dd><p>Posición del borde superior de la imagen.</p>
</dd>
<dt>...:</dt><dd><p>Otras opciones gráficas.</p>
</dd>
</dl>



<h3>Detalles</h3>

<p>Gráfico de los puntos de demanda con límites de evaluación automáticos.
</p>


<h3>Valor</h3>

<p>La representación gráfica de los puntos de demanda.
</p>


<h3>Véase también</h3>

<p>Véase también <code><a href="#topic+orloca.es-package">orloca.es-package</a></code>,
<code><a href="#topic+loca.p">loca.p</a></code> y <code><a href="#topic+plot">plot</a></code>.</p>


<h3>Ejemplos</h3>

<p># Un objeto de la clase loca.p sin pesos
loca &lt;- loca.p(x = c(-1, 1, 1, -1), y = c(-1, -1, 1, 1))
</p>
<p># El grafico del objeto loca.p
plot(loca)
</p>

<hr>
<h2 id='rloca.p'>Generador de instancias aleatorias de objetos de la clase loca.p</h2><span id='topic+rloca.p'></span>

<h3>Description</h3>

<p>Devuelve una instancia aleatoria de un objeto de la clase
<code>loca.p</code> en una región dada.
</p>


<h3>Uso</h3>

<p>rloca.p(n, xmin = 0, xmax = 1, ymin = 0, ymax = 1, groups = 0,
xgmin = xmin, xgmax = xmax, ygmin = ymin, ygmax = ymax)
</p>


<h3>Argumentos</h3>


<dl>
<dt>n:</dt><dd><p>El número de puntos de demanda.</p>
</dd>
<dt>xmin:</dt><dd><p>Mínimo valor para la coordenada x de los puntos de demanda.</p>
</dd>
<dt>xmax:</dt><dd><p>Máximo valor para la coordenada x de los puntos de demanda.</p>
</dd>
<dt>ymin:</dt><dd><p>Mínimo valor para la coordenada y de los puntos de demanda.</p>
</dd>
<dt>ymax:</dt><dd><p>Máximo valor para la coordenada y de los puntos de demanda.</p>
</dd>
<dt>groups:</dt><dd><p>El número de grupos (de aproximadamente
igual tamaño) o una lista con los tamaños de los
grupos a generar. En el segundo caso <code>n</code> se ignora.</p>
</dd>
<dt>xgmin:</dt><dd><p>Mínimo valor para la coordenada x de los
puntos de demanda respecto del punto referencia del grupo.</p>
</dd>
<dt>xgmax:</dt><dd><p>Máximo valor para la coordenada x de los
puntos de demanda respecto del punto referencia del grupo.</p>
</dd>
<dt>ygmin:</dt><dd><p>Mínimo valor para la coordenada y de los
puntos de demanda respecto del punto referencia del grupo.</p>
</dd>
<dt>ygmax:</dt><dd><p>Máximo valor para la coordenada y de los
puntos de demanda respecto del punto referencia del grupo.</p>
</dd>
</dl>



<h3>Detalles</h3>

<p><code>n</code> debe ser al menos 1.
</p>
<p><code>xmin</code> debe ser menor o igual que <code>xmax</code>.
</p>
<p><code>ymin</code> debe ser menor o igual que <code>ymax</code>.
</p>
<p>Cuando se suministra valor no nulo para <code>groups</code> los puntos se generan en
dos fases, en la primera se genera un punto de referencia, en la
segunda se genera un desplazamiento sobre dicho punto de referencia
que se suma a éste.
</p>
<p>Obsérvese que <code>groups = 1</code> no es equivalente a
<code>groups = 0</code>, debido a que en el primer caso se genera
un punto de referencia en la primera etapa.
</p>


<h3>Valor</h3>

<p>Si los argumentos son valores válidos, devuelve un nuevo objeto de la clase
<code>loca_p</code>, en otro caso informa de un error.
</p>


<h3>Véase también</h3>

<p>Véase también <code><a href="orloca.html#topic+orloca-package">orloca-package</a></code> y <code><a href="#topic+loca.p">loca.p</a></code></p>


<h3>Ejemplos</h3>

<p># Un objeto aleatorio loca.p en el cuadrado unidad con 5 puntos de demanda
rloca.p(5)
</p>
<p># En otra region
rloca.p(10, xmin=-2, xmax=2, ymin=-2, ymax=2)
</p>
<p># Cinco grupos
rloca.p(48, groups=5)
</p>
<p># Tres grupos de distinto tamano
rloca.p(1, groups=c(10, 7, 2))
</p>

<hr>
<h2 id='zsum'>zsum</h2><span id='topic+zsum'></span>

<h3>Description</h3>

<p>La función zsum esta obsoleta y podría ser suprimida en sucesivas versiones del paquete. Use <a href="#topic+distsum">distsum</a> en su lugar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zsum(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zsum_+3A_...">...</code></td>
<td>
<p>Parámetros pasados a distsum</p>
</td></tr>
</table>

<hr>
<h2 id='zsumgra'>zsumgra</h2><span id='topic+zsumgra'></span>

<h3>Description</h3>

<p>La función zsumgra esta obsoleta y podría ser suprimida en sucesivas versiones del paquete. Use <a href="#topic+distsumgra">distsumgra</a> en su lugar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zsumgra(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zsumgra_+3A_...">...</code></td>
<td>
<p>Parámetros pasados a distsumgra</p>
</td></tr>
</table>

<hr>
<h2 id='zsuml2'>zsuml2 y zsuml2gra del paquete orloca</h2><span id='topic+zsuml2'></span><span id='topic+zsuml2+2Cloca.p-method'></span><span id='topic+zsuml2gra'></span><span id='topic+zsuml2gra+2Cloca.p-method'></span>

<h3>Description</h3>

<p>Las funciones <code>zsum</code> y <code>zsumgra</code> para la norma
euclídea (<code class="reqn">l_2</code>). Principalmente para uso interno.</p>


<h3>Uso</h3>

<p>zsuml2(o, x=0, y=0)
zsuml2gra(o, x=0, y=0, partial=F)
</p>


<h3>Argumentos</h3>


<dl>
<dt>o:</dt><dd><p>Un objeto de la clase <code>loca.p</code>.</p>
</dd>
<dt>x:</dt><dd><p>La coordenada x del punto a ser evaluado.</p>
</dd>
<dt>y:</dt><dd><p>La coordenada y del punto a ser evaluado.</p>
</dd>
<dt>partial:</dt><dd><p>Si (x,y) es un punto de demanda <code>partial=T</code>
significa que se ignore dicho punto para el cálculo
del gradiente. Principalmente para uso interno.</p>
</dd>
</dl>



<h3>Valor</h3>

<p><code>zsuml2</code> devuelve la función objetivo para el problema de localización min-sum, <code class="reqn">\sum_{a_i \in o} w_i d(a_i, (x,y))</code>, donde <code class="reqn">d(a_i, (x,y))</code> es la distancia euclídea entre <code class="reqn">a_i</code> y <code class="reqn">(x,y)</code>. 
</p>
<p><code>zsumgra</code> devuelve el vector gradiente de la función <code>zsum</code>.
</p>


<h3>Detalles</h3>

<p>La función zsuml2 está marcada como obsoleta
y será borrada de nuevas versiones del paquete.
</p>


<h3>Véase también</h3>

<p>Véase también <code><a href="#topic+orloca.es-package">orloca.es-package</a></code>, <code><a href="#topic+zsum">zsum</a></code>, <code><a href="#topic+zsumgra">zsumgra</a></code> y <code><a href="#topic+zsummin">zsummin</a></code>.
</p>

<hr>
<h2 id='zsummin'>zsummin</h2><span id='topic+zsummin'></span>

<h3>Description</h3>

<p>La función zsummin esta obsoleta y podría ser suprimida en sucesivas versiones del paquete. Use <a href="#topic+distsummin">distsummin</a> en su lugar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zsummin(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zsummin_+3A_...">...</code></td>
<td>
<p>Parámetros pasados a distsummin</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
