<!DOCTYPE html><html lang="en"><head><title>Help for package rtdists</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rtdists}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rtdists-package'><p>The rtdists Package</p></a></li>
<li><a href='#Diffusion'><p>The Ratcliff Diffusion Model</p></a></li>
<li><a href='#drd'><p>Deprecated functions</p></a></li>
<li><a href='#LBA'><p>The Linear Ballistic Accumulator (LBA)</p></a></li>
<li><a href='#LBA-race'><p>LBA race functions: Likelihood for first accumulator to win.</p></a></li>
<li><a href='#rr98'><p>Ratcliff and Rouder (1998, Exp. 1) Luminance Discrimination Data</p></a></li>
<li><a href='#single-LBA'><p>Single accumulator of linear ballistic accumulator (LBA)</p></a></li>
<li><a href='#speed_acc'><p>Speed-Accuracy Data from Wagenmakers, Ratcliff, Gomez, &amp; McKoon (2008, Experiment 1)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Response Time Distributions</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, glba, knitr, rmarkdown, dplyr, tidyr, purrr,
lattice, latticeExtra, binom, RWiener</td>
</tr>
<tr>
<td>Imports:</td>
<td>evd, msm, gsl, stats, Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides response time distributions (density/PDF,
       distribution function/CDF, quantile function, and random
       generation): (a) Ratcliff diffusion model (Ratcliff &amp;
       McKoon, 2008, &lt;<a href="https://doi.org/10.1162%2Fneco.2008.12-06-420">doi:10.1162/neco.2008.12-06-420</a>&gt;) based on C
       code by Andreas and Jochen Voss and (b) linear ballistic
       accumulator (LBA; Brown &amp; Heathcote, 2008,
       &lt;<a href="https://doi.org/10.1016%2Fj.cogpsych.2007.12.002">doi:10.1016/j.cogpsych.2007.12.002</a>&gt;) with different
       distributions underlying the drift rate.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rtdists/rtdists/">https://github.com/rtdists/rtdists/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rtdists/rtdists/issues">https://github.com/rtdists/rtdists/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Version:</td>
<td>0.11-5</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-01-03 19:06:08 UTC; singm</td>
</tr>
<tr>
<td>Author:</td>
<td>Henrik Singmann <a href="https://orcid.org/0000-0002-4842-3657"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Scott Brown [aut],
  Matthew Gretton [aut],
  Andrew Heathcote [aut],
  Andreas Voss [ctb],
  Jochen Voss [ctb],
  Andrew Terry [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Henrik Singmann &lt;singmann@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-01-07 14:02:42 UTC</td>
</tr>
</table>
<hr>
<h2 id='rtdists-package'>The rtdists Package</h2><span id='topic+rtdists-package'></span>

<h3>Description</h3>

<p>Response Time Distributions.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> rtdists</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.8-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2018-06-23</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 3.0.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=3)</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/rtdists/rtdists/</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Provides response time distributions (density/PDF, distribution function/CDF, quantile
function, and random generation): (a) Ratcliff diffusion model (Ratcliff &amp; McKoon, 2008,
&lt;doi:10.1162/neco.2008.12-06-420&gt;) based on C code by Andreas and Jochen Voss and (b) linear
ballistic accumulator (LBA; Brown &amp; Heathcote, 2008, &lt;doi:10.1016/j.cogpsych.2007.12.002&gt;)
with different distributions underlying the drift rate.
</p>


<h3>Author(s)</h3>

<p>Henrik Singmann, Scott Brown, Matthew Gretton, Andrew Heathcote, with contributions from Andreas Voss, Jochen Voss, Andrew Terry
</p>

<hr>
<h2 id='Diffusion'>The Ratcliff Diffusion Model</h2><span id='topic+Diffusion'></span><span id='topic+recalc_t0'></span><span id='topic+diffusion'></span><span id='topic+ddiffusion'></span><span id='topic+pdiffusion'></span><span id='topic+qdiffusion'></span><span id='topic+rdiffusion'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random generation for the Ratcliff diffusion model with following parameters: <code>a</code> (threshold separation), <code>z</code> (starting point), <code>v</code> (drift rate), <code>t0</code> (non-decision time/response time constant), <code>d</code> (differences in speed of response execution), <code>sv</code> (inter-trial-variability of drift), <code>st0</code> (inter-trial-variability of non-decisional components), <code>sz</code> (inter-trial-variability of relative starting point), and <code>s</code> (diffusion constant). <strong>Note that the parameterization or defaults of non-decision time variability <code>st0</code> and diffusion constant <code>s</code> differ from what is often found in the literature and that the parameterization of <code>z</code> and <code>sz</code> have changed compared to previous versions (now absolute and not relative).</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recalc_t0(t0, st0)

ddiffusion(rt, response = "upper", a, v, t0, z = 0.5 * a, d = 0,
  sz = 0, sv = 0, st0 = 0, s = 1, precision = 3,
  stop_on_error = FALSE)

pdiffusion(rt, response = "upper", a, v, t0, z = 0.5 * a, d = 0,
  sz = 0, sv = 0, st0 = 0, s = 1, precision = 3, maxt = 20,
  stop_on_error = FALSE, use_precise = TRUE)

qdiffusion(p, response = "upper", a, v, t0, z = 0.5 * a, d = 0,
  sz = 0, sv = 0, st0 = 0, s = 1, precision = 3, maxt = 20,
  interval = c(0, 10), scale_p = FALSE, scale_max = Inf,
  stop_on_error = FALSE, max_diff = 1e-04)

rdiffusion(n, a, v, t0, z = 0.5 * a, d = 0, sz = 0, sv = 0,
  st0 = 0, s = 1, precision = 3, stop_on_error = TRUE, maxt = 20,
  interval = c(0, 10), method = c("fastdm", "qdiffusion"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Diffusion_+3A_t0">t0</code></td>
<td>
<p>non-decision time or response time constant (in seconds). Lower bound for the duration of all non-decisional processes (encoding and response execution). Typical range: 0.1 &lt; <code>t0</code> &lt; 0.5</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_st0">st0</code></td>
<td>
<p>inter-trial-variability of non-decisional components. Range of a uniform distribution with mean <code>t0 + st0/2</code> describing the distribution of actual <code>t0</code> values across trials. Accounts for response times below <code>t0</code>. Reduces skew of predicted RT distributions. Values different from 0 can slow computation considerably. Typical range: 0 &lt; <code>st0</code> &lt; 0.2. Default is 0.</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_rt">rt</code></td>
<td>
<p>a vector of RTs. Or for convenience also a <code>data.frame</code> with columns <code>rt</code> and <code>response</code> (such as returned from <code>rdiffusion</code> or <code><a href="#topic+rLBA">rLBA</a></code>). See examples.</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_response">response</code></td>
<td>
<p>character vector. Which response boundary should be tested? Possible values are <code>c("upper", "lower")</code>, possibly abbreviated and <code>"upper"</code> being the default. Alternatively, a numeric vector with values 1=lower and 2=upper. For convenience, <code>response</code> is converted via <code>as.numeric</code> also allowing factors (see examples). Ignored if the first argument is a <code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_a">a</code></td>
<td>
<p>threshold separation. Amount of information that is considered for a decision. Large values indicate a conservative decisional style. Typical range: 0.5 &lt; <code>a</code> &lt; 2</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_v">v</code></td>
<td>
<p>drift rate. Average slope of the information accumulation process. The drift gives information about the speed and direction of the accumulation of information. Large (absolute) values of drift indicate a good performance. If received information supports the response linked to the upper threshold the sign will be positive and vice versa. Typical range: -5 &lt; <code>v</code> &lt; 5</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_z">z</code></td>
<td>
<p>starting point. Indicator of an a priori bias in decision making. When the relative starting point <code>z</code> deviates from <code>0.5*a</code>, the amount of information necessary for a decision differs between response alternatives. Default is <code>0.5*a</code> (i.e., no bias).</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_d">d</code></td>
<td>
<p>differences in speed of response execution (in seconds). Positive values indicate that response execution is faster for responses linked to the upper threshold than for responses linked to the lower threshold. Typical range: -0.1 &lt; <code>d</code> &lt; 0.1. Default is 0.</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_sz">sz</code></td>
<td>
<p>inter-trial-variability of starting point. Range of a uniform distribution with mean <code>z</code> describing the distribution of actual starting points from specific trials. Values different from 0 can predict fast errors (but can slow computation considerably). Typical range: 0 &lt; <code>sz</code> &lt; 0.5. Default is 0.</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_sv">sv</code></td>
<td>
<p>inter-trial-variability of drift rate. Standard deviation of a normal distribution with mean <code>v</code> describing the distribution of actual drift rates from specific trials. Values different from 0 can predict slow errors. Typical range: 0 &lt; <code>sv</code> &lt; 2. Default is 0.</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_s">s</code></td>
<td>
<p>diffusion constant; standard deviation of the random noise of the diffusion process (i.e., within-trial variability), scales <code>a</code>, <code>v</code>, and <code>sv</code>. Needs to be fixed to a constant in most applications. Default is 1. Note that the default used by Ratcliff and in other applications is often 0.1.</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_precision">precision</code></td>
<td>
<p><code>numerical</code> scalar value. Precision of calculation. Corresponds roughly to the number of decimals of the predicted CDFs that are calculated accurately. Default is 3.</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_stop_on_error">stop_on_error</code></td>
<td>
<p>Should the diffusion functions return 0 if the parameters values are outside the allowed range (= <code>FALSE</code>) or produce an error in this case (= <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_maxt">maxt</code></td>
<td>
<p>maximum <code>rt</code> allowed, used to stop integration problems. Larger values lead to considerably longer calculation times.</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_use_precise">use_precise</code></td>
<td>
<p>boolean. Should <code>pdiffusion</code> use the precise version for calculating the CDF? The default is <code>TRUE</code> which is highly recommended. Using <code>FALSE</code> (i.e., the imprecise version) is hardly any faster and produces clearly wrong results for most parameter settings.</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_p">p</code></td>
<td>
<p>vector of probabilities. Or for convenience also a <code>data.frame</code> with columns <code>p</code> and <code>response</code>. See examples.</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_interval">interval</code></td>
<td>
<p>a vector containing the end-points of the interval to be searched for the desired quantiles (i.e., RTs) in <code>qdiffusion</code>. Default is <code>c(0, 10)</code>.</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_scale_p">scale_p</code></td>
<td>
<p>logical. Should entered probabilities automatically be scaled by maximally predicted probability? Default is <code>FALSE</code>. Convenience argument for obtaining predicted quantiles. Can be slow as the maximally predicted probability is calculated individually for each <code>p</code>.</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_scale_max">scale_max</code></td>
<td>
<p>numerical scalar. Value at which maximally predicted RT should be calculated if <code>scale_p</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_max_diff">max_diff</code></td>
<td>
<p>numeric. Maximum acceptable difference between desired and observed probability of the quantile function (<code>qdiffusion</code>).</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_n">n</code></td>
<td>
<p>is a desired number of observations.</p>
</td></tr>
<tr><td><code id="Diffusion_+3A_method">method</code></td>
<td>
<p>character. Experimentally implementation of an alternative way of generating random variates via the quantile function (<code>qdiffusion</code>) and random uniform value. For simple calls, the default method <code>"fastdm"</code> is dramatically faster.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Ratcliff diffusion model (Ratcliff, 1978) is a mathematical model for two-choice discrimination tasks. It is based on the assumption that information is accumulated continuously until one of two decision thresholds is hit. For introductions see Ratcliff and McKoon (2008), Voss, Rothermund, and Voss (2004), Voss, Nagler, and Lerche (2013), or Wagenmakers (2009).
</p>
<p>All functions are fully vectorized across all parameters as well as the response to match the length or <code>rt</code> (i.e., the output is always of length equal to <code>rt</code>). This allows for trialwise parameters for each model parameter. 
</p>
<p>For convenience, all functions (with the exception of <code>rdiffusion</code>) allow that the first argument is a <code>data.frame</code> containing the information of the first and second argument in two columns (i.e., <code>rt</code>/<code>p</code> and <code>response</code>). Other columns (as well as passing <code>response</code> separately argument) will be ignored. This allows, for example, to pass the <code>data.frame</code> generated by <code>rdiffusion</code> directly to <code>pdiffusion</code>. See examples.
</p>


<h4>Quantile Function</h4>

<p>Due to the bivariate nature of the diffusion model, the diffusion processes reaching each response boundary only return the defective CDF that does not reach 1. Only the sum of the CDF for both boundaries reaches 1. Therefore, <code>qdiffusion</code> can only return quantiles/RTs for any accumulator up to the maximal probability of that accumulator's CDF. This can be obtained by evaluating the CDF at <code>Inf</code>. 
</p>
<p>As a convenience for the user, if <code>scale_p = TRUE</code> in the call to <code>qdiffusion</code> the desired probabilities are automatically scaled by the maximal probability for the corresponding response. Note that this can be slow as the maximal probability is calculated separately for each desired probability. See examples.
</p>
<p>Also note that quantiles (i.e., predicted RTs) are obtained by numerically minimizing the absolute difference between desired probability and the value returned from <code>pdiffusion</code> using <code><a href="stats.html#topic+optimize">optimize</a></code>. If the difference between the desired probability and probability corresponding to the returned quantile is above a certain threshold (currently 0.0001) no quantile is returned but <code>NA</code>. This can be either because the desired quantile is above the maximal probability for this accumulator or because the limits for the numerical integration are too small (default is <code>c(0, 10)</code>).
</p>



<h3>Value</h3>

<p><code>ddiffusion</code> gives the density, <code>pdiffusion</code> gives the distribution function, <code>qdiffusion</code> gives the quantile function (i.e., predicted RTs), and <code>rdiffusion</code> generates random response times and decisions (returning a <code>data.frame</code> with columns <code>rt</code> (numeric) and <code>response</code> (factor)).
</p>
<p>The length of the result is determined by <code>n</code> for <code>rdiffusion</code>, equal to the length of <code>rt</code> for <code>ddiffusion</code> and <code>pdiffusion</code>, and equal to the length of <code>p</code> for <code>qdiffusion</code>.
</p>
<p>The distribution parameters (as well as <code>response</code>) are recycled to the length of the result. In other words, the functions are completely vectorized for all parameters and even the response boundary.
</p>


<h3>Note</h3>

<p>The parameterization of the non-decisional components, <code>t0</code> and <code>st0</code>, differs from the parameterization used by, for example, Andreas Voss or Roger Ratcliff. In the present case <code>t0</code> is the lower bound of the uniform distribution of length <code>st0</code>, but <em>not</em> its midpoint. The parameterization employed here is in line with the parametrization for the <a href="#topic+LBA">LBA</a> code (where <code>t0</code> is also the lower bound).
</p>
<p>The default diffusion constant <code>s</code> is 1 and not 0.1 as in most applications of Roger Ratcliff and others.
</p>
<p>We have changed the parameterization of the start point <code>z</code> which is now the absolute start point in line with most published literature (it was the relative start point in previous versions of <span class="pkg">rtdists</span>).
</p>


<h3>Author(s)</h3>

<p>Underlying C code by Jochen Voss and Andreas Voss. Porting and R wrapping by Matthew Gretton, Andrew Heathcote, Scott Brown, and Henrik Singmann. <code>qdiffusion</code> by Henrik Singmann.
</p>


<h3>References</h3>

<p>Ratcliff, R. (1978). A theory of memory retrieval. <em>Psychological Review</em>, 85(2), 59-108.
</p>
<p>Ratcliff, R., &amp; McKoon, G. (2008). The diffusion decision model: Theory and data for two-choice decision tasks. <em>Neural Computation</em>, 20(4), 873-922.
</p>
<p>Voss, A., Rothermund, K., &amp; Voss, J. (2004). Interpreting the parameters of the diffusion model: An empirical validation. <em>Memory &amp; Cognition</em>. Vol 32(7), 32, 1206-1220.
</p>
<p>Voss, A., Nagler, M., &amp; Lerche, V. (2013). Diffusion Models in Experimental Psychology: A Practical Introduction. <em>Experimental Psychology</em>, 60(6), 385-402. doi:10.1027/1618-3169/a000218
</p>
<p>Wagenmakers, E.-J., van der Maas, H. L. J., &amp; Grasman, R. P. P. P. (2007). An EZ-diffusion model for response time and accuracy. <em>Psychonomic Bulletin &amp; Review</em>, 14(1), 3-22.
</p>
<p>Wagenmakers, E.-J. (2009). Methodological and empirical developments for the Ratcliff diffusion model of response times and accuracy. <em>European Journal of Cognitive Psychology</em>, 21(5), 641-671.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## identical calls (but different random values)
rt1 &lt;- rdiffusion(500, a=1, v=2, t0=0.5)
head(rt1)
rt2 &lt;- rdiffusion(500, a=1, v=2, t0=0.5, d=0, sz=0, sv=0, st0=0)
head(rt2)
  
# get density for random RTs (possible to specify arguments for pdiffusion in same way):
sum(log(ddiffusion(rt1$rt, rt1$response, a=1, v=2, t0=0.5)))  # response is factor
sum(log(ddiffusion(rt1$rt, as.numeric(rt1$response), a=1, v=2, t0=0.5))) # response is numeric
sum(log(ddiffusion(rt1$rt, as.character(rt1$response), a=1, v=2, t0=0.5))) # response is character
sum(log(ddiffusion(rt1, a=1, v=2, t0=0.5))) # response is data.frame


sum(log(ddiffusion(rt2$rt, rt2$response, a=1, v=2, t0=0.5)))

# can we recover the parameters?
ll_diffusion &lt;- function(pars, rt, response) 
{
  densities &lt;- ddiffusion(rt, response=response, 
               a=pars[1], v=pars[2], t0=pars[3], 
               sz=pars[4], 
               st0=pars[5], sv=pars[6])
  if (any(densities == 0)) return(1e6)
  return(-sum(log(densities)))
}

## Not run: )
start &lt;- c(runif(2, 0.5, 3), 0.1, runif(3, 0, 0.5))
names(start) &lt;- c("a", "v", "t0", "sz", "st0", "sv")
recov &lt;- nlminb(start, ll_diffusion, lower = 0, rt=rt1$rt, response=rt1$response)
round(recov$par, 3)
#     a     v    t0    sz   st0    sv 
# 1.019 1.879 0.496 0.000 0.000 0.389 
## results of course depend on random seed for rdiffusion and runif

## End(Not run)


## Not run: 
## replicate Table 1 from Wagenmakers et al. (2007) using rdiffusion:

n &lt;- 1e5 # number of samples
# take parameter valeus from Table 2 and set s to 0.1
george &lt;- rdiffusion(n, a = 0.12, v = 0.25, t0 = 0.3, s = 0.1)
rich   &lt;- rdiffusion(n, a = 0.12, v = 0.25, t0 = 0.25, s = 0.1)
amy    &lt;- rdiffusion(n, a = 0.08, v = 0.25, t0 = 0.3, s = 0.1)
mark   &lt;- rdiffusion(n, a = 0.08, v = 0.25, t0 = 0.25, s = 0.1)

george$id &lt;- "george"
rich$id &lt;- "rich"
amy$id &lt;- "amy"
mark$id &lt;- "mark"

wag &lt;- rbind(george, rich, amy, mark)
wag$id &lt;- factor(wag$id, levels = c("george", "rich", "amy", "mark"))

opt &lt;- options()
options(digits = 3)
aggregate(cbind(rt, as.numeric(response)-1) ~ id, wag, mean)
#       id    rt    V2
# 1 george 0.517 0.952
# 2   rich 0.467 0.953
# 3    amy 0.422 0.881
# 4   mark 0.372 0.882
options(digits = 1)
aggregate(rt ~ id, wag, var)
#       id    rt
# 1 george 0.024
# 2   rich 0.024
# 3    amy 0.009
# 4   mark 0.009
options(opt)

## End(Not run)


## plot density:
curve(ddiffusion(x, a=1, v=2, t0=0.5, response = "upper"), 
      xlim=c(0,3), main="Density of upper responses", ylab="density", xlab="response time")
curve(ddiffusion(x, a=1, v=2, t0=0.5, st0=0.2, response = "upper"), 
      add=TRUE, lty = 2)
legend("topright", legend=c("no", "yes"), title = "Starting Point Variability?", lty = 1:2)

# plot cdf:
curve(pdiffusion(x, a=1, v=2, t0=0.5, st0=0.2, response="u"), 
     xlim = c(0, 3),ylim = c(0,1), 
     ylab = "cumulative probability", xlab = "response time",
     main = "CDF of diffusion model with start point variability")
curve(pdiffusion(x, a=1, v=2, t0=0.5, st0=0.2, response="l"), 
     add=TRUE, lty = 2)
legend("topleft", legend=c("upper", "lower"), title="response boundary", lty=1:2)

## Not run: 
### qdiffusion can only return values up to maximal predicted probability:
(max_p &lt;- pdiffusion(Inf, a=1, v=2, t0=0.5, st0=0.2, sz = 0.1, sv = 0.5, response="u"))
# [1] 0.87
# (Note that with the current integration routine for pdiffusion use Inf and not smaller values.)

qdiffusion(0.87, a=1, v=2, t0=0.5, st0=0.2, sz = 0.1, sv = 0.5, response="u")
# [1] 1.945802

qdiffusion(0.88, a=1, v=2, t0=0.5, st0=0.2, sz = 0.1, sv = 0.5, response="u")
# NA with warning.

# to get predicted quantiles, scale required quantiles by maximally predicted response rate:
qs &lt;- c(.1, .3, .5, .7, .9)
qdiffusion(qs*max_p, a=1, v=2, t0=0.5, st0=0.2, sz = 0.1, sv = 0.5, response="u")

# or set scale_p to TRUE which scales automatically by maximum p
# (but can be slow as it calculates max_p for each probability separately) 
qdiffusion(qs, a=1, v=2, t0=0.5, st0=0.2, sz = 0.1, sv = 0.5, response="u", scale_p = TRUE)


# qdiffusion also accepts a data.frame as first argument:
t3 &lt;- data.frame(p = rep(c(0.05, 0.1, 0.87), 2), response = rep(c("upper", "lower"), each = 3))
#      p response
# 1 0.05    upper
# 2 0.10    upper
# 3 0.87    upper
# 4 0.05    lower
# 5 0.10    lower
# 6 0.87    lower
qdiffusion(t3, a=1, v=2, t0=0.5, st0=0.2, sz = 0.1, sv = 0.5, scale_p = TRUE)

## End(Not run)

## LBA and diffusion can be used interchangeably:
rt1 &lt;- rLBA(500, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))
rt2 &lt;- rdiffusion(500, a=1, v=2, t0=0.5)

# data can also be passed as data.frame (same is true for pLBA):
sum(log(dLBA(rt1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))))
sum(log(dLBA(rt2, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))))

sum(log(ddiffusion(rt1, a=1, v=2, t0=0.5)))
sum(log(ddiffusion(rt2, a=1, v=2, t0=0.5)))

</code></pre>

<hr>
<h2 id='drd'>Deprecated functions</h2><span id='topic+drd'></span><span id='topic+rtdists-deprecated'></span><span id='topic+prd'></span><span id='topic+rrd'></span>

<h3>Description</h3>

<p>These functions have been renamed and deprecated in <span class="pkg">rtdists</span>:
<code>drd()</code> (use <code><a href="#topic+ddiffusion">ddiffusion</a>()</code>), 
<code>prd()</code> (use <code><a href="#topic+pdiffusion">pdiffusion</a>()</code>),
<code>rrd()</code> (use <code><a href="#topic+rdiffusion">rdiffusion</a>()</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drd(...)

prd(...)

rrd(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="drd_+3A_...">...</code></td>
<td>
<p>arguments passed from the old functions to the new functions</p>
</td></tr>
</table>

<hr>
<h2 id='LBA'>The Linear Ballistic Accumulator (LBA)</h2><span id='topic+LBA'></span><span id='topic+dLBA'></span><span id='topic+pLBA'></span><span id='topic+qLBA'></span><span id='topic+rLBA'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random generation for
the LBA model with the following parameters: <code>A</code> (upper value of
starting point), <code>b</code> (response threshold), <code>t0</code> (non-decision
time), and driftrate (<code>v</code>). All functions are available with different
distributions underlying the drift rate: Normal (<code>norm</code>), Gamma
(<code>gamma</code>), Frechet (<code>frechet</code>), and log normal (<code>lnorm</code>). The
functions return their values conditional on the accumulator given in the
response argument winning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dLBA(rt, response, A, b, t0, ..., st0 = 0, distribution = c("norm",
  "gamma", "frechet", "lnorm"), args.dist = list(), silent = FALSE)

pLBA(rt, response, A, b, t0, ..., st0 = 0, distribution = c("norm",
  "gamma", "frechet", "lnorm"), args.dist = list(), silent = FALSE)

qLBA(p, response, A, b, t0, ..., st0 = 0, distribution = c("norm",
  "gamma", "frechet", "lnorm"), args.dist = list(), silent = FALSE,
  interval = c(0, 10), scale_p = FALSE, scale_max = Inf)

rLBA(n, A, b, t0, ..., st0 = 0, distribution = c("norm", "gamma",
  "frechet", "lnorm"), args.dist = list(), silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LBA_+3A_rt">rt</code></td>
<td>
<p>vector of RTs. Or for convenience also a <code>data.frame</code> with
columns <code>rt</code> and <code>response</code> (such as returned from <code>rLBA</code> or
<code><a href="#topic+rdiffusion">rdiffusion</a></code>). See examples.</p>
</td></tr>
<tr><td><code id="LBA_+3A_response">response</code></td>
<td>
<p>integer vector of winning accumulators/responses
corresponding to the vector of RTs/p (i.e., used for specifying the
response for a given RT/probability). Will be recycled if necessary. Cannot
contain values larger than the number of accumulators. First
response/accumulator must receive value 1, second 2, and so forth. For
conmvenience, <code>response</code> is converted via <code>as.numeric</code> thereby
allowing factors to be passed as well (such as returned from
<code><a href="#topic+rdiffusion">rdiffusion</a></code>). Ignored if <code>rt</code> or <code>p</code> is a
<code>data.frame</code>.</p>
</td></tr>
<tr><td><code id="LBA_+3A_a">A</code></td>
<td>
<p>start point interval or evidence in accumulator before beginning of
decision process. Start point varies from trial to trial in the interval
[0, <code>A</code>] (uniform distribution). Average amount of evidence before
evidence accumulation across trials is <code>A</code>/2.</p>
</td></tr>
<tr><td><code id="LBA_+3A_b">b</code></td>
<td>
<p>response threshold. (<code>b</code> - <code>A</code>/2) is a measure of
&quot;response caution&quot;.</p>
</td></tr>
<tr><td><code id="LBA_+3A_t0">t0</code></td>
<td>
<p>non-decision time or response time constant (in seconds). Lower
bound for the duration of all non-decisional processes (encoding and
response execution).</p>
</td></tr>
<tr><td><code id="LBA_+3A_...">...</code></td>
<td>
<p>two <em>named</em> drift rate parameters depending on
<code>distribution</code> (e.g., <code>mean_v</code> and <code>sd_v</code> for
<code>distribution=="norm"</code>). The parameters can either be given as a
numeric vector or a list. If a numeric vector is passed each element of the
vector corresponds to one accumulator. If a list is passed each list
element corresponds to one accumulator allowing again trialwise driftrates.
The shorter parameter will be recycled as necessary (and also the elements
of the list to match the length of <code>rt</code>). See details.</p>
</td></tr>
<tr><td><code id="LBA_+3A_st0">st0</code></td>
<td>
<p>variability of non-decision time, such that <code>t0</code> is uniformly
distributed between <code>t0</code> and <code>t0</code> + <code>st0</code>. Default is 0. Can
be trialwise, and will be recycled to length of <code>rt</code>.</p>
</td></tr>
<tr><td><code id="LBA_+3A_distribution">distribution</code></td>
<td>
<p>character specifying the distribution of the drift rate.
Possible values are <code>c("norm", "gamma", "frechet", "lnorm")</code>, default
is <code>"norm"</code>.</p>
</td></tr>
<tr><td><code id="LBA_+3A_args.dist">args.dist</code></td>
<td>
<p>list of optional further arguments to the distribution
functions (i.e., <code>posdrift</code> or <code>robust</code> for
<code>distribution=="norm"</code>, see <code><a href="#topic+single-LBA">single-LBA</a></code>).</p>
</td></tr>
<tr><td><code id="LBA_+3A_silent">silent</code></td>
<td>
<p>logical. Should the number of accumulators used be suppressed?
Default is <code>FALSE</code> which prints the number of accumulators.</p>
</td></tr>
<tr><td><code id="LBA_+3A_p">p</code></td>
<td>
<p>vector of probabilities. Or for convenience also a <code>data.frame</code>
with columns <code>p</code> and <code>response</code>. See examples.</p>
</td></tr>
<tr><td><code id="LBA_+3A_interval">interval</code></td>
<td>
<p>a vector containing the end-points of the interval to be
searched for the desired quantiles (i.e., RTs) in <code>qLBA</code>. Default is
<code>c(0, 10)</code>.</p>
</td></tr>
<tr><td><code id="LBA_+3A_scale_p">scale_p</code></td>
<td>
<p>logical. Should entered probabilities automatically be scaled
by maximally predicted probability? Default is <code>FALSE</code>. Convenience
argument for obtaining predicted quantiles. Can be slow as the maximally
predicted probability is calculated individually for each <code>p</code>.</p>
</td></tr>
<tr><td><code id="LBA_+3A_scale_max">scale_max</code></td>
<td>
<p>numerical scalar. Value at which maximally predicted RT
should be calculated if <code>scale_p</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="LBA_+3A_n">n</code></td>
<td>
<p>desired number of observations (scalar integer).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For convenience, all functions (with the exception of <code>rdiffusion</code>)
allow that the first argument is a <code>data.frame</code> containing the
information of the first and second argument in two columns (i.e.,
<code>rt</code>/<code>p</code> and <code>response</code>). Other columns will be ignored. This
allows, for example, to pass the <code>data.frame</code> generated by <code>rLBA</code>
directly to <code>pLBA</code>. See examples.
</p>


<h4>Parameters</h4>

<p> The following arguments are allowed as <code>...</code>
drift rate parameters: </p>
 <ul>
<li> <p><code>mean_v,sd_v</code> mean and standard
deviation of normal distribution for drift rate (<code>norm</code>). See
<code><a href="stats.html#topic+Normal">Normal</a></code> </p>
</li>
<li> <p><code>shape_v,rate_v,scale_v</code> shape, rate, and
scale of gamma (<code>gamma</code>) and scale and shape of Frechet (<code>frechet</code>)
distributions for drift rate. See <code><a href="stats.html#topic+GammaDist">GammaDist</a></code> or
<code><a href="evd.html#topic+frechet">frechet</a></code>. For Gamma, scale = 1/shape and shape = 1/scale. 
</p>
</li>
<li> <p><code>meanlog_v,sdlog_v</code> mean and standard deviation of lognormal
distribution on the log scale for drift rate (<code>lnorm</code>). See
<code><a href="stats.html#topic+Lognormal">Lognormal</a></code>. </p>
</li></ul>

<p>As described above, the accumulator parameters can either be given as a
numeric vector or a list. If a numeric vector is passed each element of the
vector corresponds to one accumulator. If a list is passed each list element
corresponds to one accumulator allowing trialwise driftrates. The shorter
parameter will be recycled as necessary (and also the elements of the list to
match the length of <code>rt</code>).
</p>
<p>The other LBA parameters (i.e., <code>A</code>, <code>b</code>, and <code>t0</code>, with the
exception of <code>st0</code>) can either be a single numeric vector (which will be
recycled to reach <code>length(rt)</code> or <code>length(n)</code> for trialwise
parameters) <em>or</em> a <code>list</code> of such vectors in which each list
element corresponds to the parameters for this accumulator (i.e., the list
needs to be of the same length as there are accumulators). Each list will
also be recycled to reach <code>length(rt)</code> for trialwise parameters per
accumulator.
</p>
<p>To make the difference between both paragraphs clear: Whereas for the
accumulators both a single vector or a list corresponds to different
accumulators, only the latter is true for the other parameters. For those
(i.e., <code>A</code>, <code>b</code>, and <code>t0</code>) a single vector always corresponds
to trialwise values and a list must be used for accumulator wise values.
</p>
<p><code>st0</code> can only vary trialwise (via a vector). And it should be noted
that <code>st0</code> not equal to zero will considerably slow done everything. </p>



<h4>Quantile Function</h4>

<p> Due to the bivariate nature of the LBA,
single accumulators only return defective CDFs that do not reach 1. Only the
sum of all accumulators reaches 1. Therefore, <code>qLBA</code> can only return
quantiles/RTs for any accumulator up to the maximal probability of that
accumulator's CDF. This can be obtained by evaluating the CDF at <code>Inf</code>.
</p>
<p>As a conveniece for the user, if <code>scale_p = TRUE</code> in the call to
<code>qLBA</code> the desired probabilities are automatically scaled by the maximal
probability for the corresponding response. Note that this can be slow as the
maximal probability is calculated separately for each desired probability.
See examples.
</p>
<p>Also note that quantiles (i.e., predicted RTs) are obtained by numerically
minimizing the absolute difference between desired probability and the value
returned from <code>pLBA</code> using <code><a href="stats.html#topic+optimize">optimize</a></code>. If the difference
between the desired probability and probability corresponding to the returned
quantile is above a certain threshold (currently 0.0001) no quantile is
returned but <code>NA</code>. This can be either because the desired quantile is
above the maximal probability for this accumulator or because the limits for
the numerical integration are too small (default is <code>c(0, 10)</code>). </p>



<h4>RNG</h4>

<p> For random number generation at least one of the
distribution parameters (i.e., <code>mean_v</code>, <code>sd_v</code>, <code>shape_v</code>,
<code>scale_v</code>, <code>rate_v</code>, <code>meanlog_v</code>, and <code>sdlog_v</code>) should
be of length &gt; 1 to receive RTs from multiple responses. Shorter vectors are
recycled as necessary.<br /> Note that for random number generation from a
normal distribution for the driftrate the number of returned samples may be
less than the number of requested samples if <code>posdrifts==FALSE</code>. </p>



<h3>Value</h3>

<p><code>dLBA</code> returns the density (PDF), <code>pLBA</code> returns the
distribution function (CDF), <code>qLBA</code> returns the quantile/RT,
<code>rLBA</code> return random response times and responses (in a
<code>data.frame</code>).
</p>
<p>The length of the result is determined by <code>n</code> for <code>rLBA</code>, equal
to the length of <code>rt</code> for <code>dLBA</code> and <code>pLBA</code>, and equal to
the length of <code>p</code> for <code>qLBA</code>.
</p>
<p>The distribution parameters (as well as <code>response</code>) are recycled to
the length of the result. In other words, the functions are completely
vectorized for all parameters and even the response.
</p>


<h3>Note</h3>

<p>These are the top-level functions intended for end-users. To obtain the
density and cumulative density the race functions are called for each
response time with the corresponding winning accumulator as first
accumulator (see <code><a href="#topic+LBA-race">LBA-race</a></code>).
</p>


<h3>References</h3>

<p>Brown, S. D., &amp; Heathcote, A. (2008). The simplest complete model of choice
response time: Linear ballistic accumulation. <em>Cognitive Psychology</em>,
57(3), 153-178. doi:10.1016/j.cogpsych.2007.12.002
</p>
<p>Donkin, C., Averell, L., Brown, S., &amp; Heathcote, A. (2009). Getting more from
accuracy and response time data: Methods for fitting the linear ballistic
accumulator. <em>Behavior Research Methods</em>, 41(4), 1095-1110.
doi:10.3758/BRM.41.4.1095
</p>
<p>Heathcote, A., &amp; Love, J. (2012). Linear deterministic accumulator models of
simple choice. <em>Frontiers in Psychology</em>, 3, 292.
doi:10.3389/fpsyg.2012.00292
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate random LBA data:
rt1 &lt;- rLBA(500, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))
head(rt1)
prop.table(table(rt1$response))

# original parameters have 'high' log-likelihood:
sum(log(dLBA(rt1$rt, rt1$response, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))))

# data can also be passed as data.frame (same is true for pLBA):
sum(log(dLBA(rt1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))))

objective_fun &lt;- function(par, rt, response, distribution = "norm") {
  # simple parameters
  spar &lt;- par[!grepl("[12]$", names(par))]  
  
  # distribution parameters:
  dist_par_names &lt;- unique(sub("[12]$", "", grep("[12]$" ,names(par), value = TRUE)))
  dist_par &lt;- vector("list", length = length(dist_par_names))
  names(dist_par) &lt;- dist_par_names
  for (i in dist_par_names) dist_par[[i]] &lt;- as.list(unname(par[grep(i, names(par))]))
  dist_par$sd_v &lt;- c(1, dist_par$sd_v) # fix first sd to 1

  # get summed log-likelihood:
  d &lt;- do.call(dLBA, args = c(rt=list(rt), response=list(response), spar, dist_par, 
                               distribution=distribution, silent=TRUE))
  if (any(d &lt; 0e-10)) return(1e6) 
  else return(-sum(log(d)))
}

# gives same value as manual calculation above:
objective_fun(c(A=0.5, b=1, t0=0.5, mean_v1=2.4, mean_v2=1.6, sd_v2=1.2), 
              rt=rt1$rt, response=rt1$response)

## Not run: 
# can we recover the parameters? 
# should be run several times with different random values of init_par
init_par &lt;- runif(6)
init_par[2] &lt;- sum(init_par[1:2]) # ensures b is larger than A
init_par[3] &lt;- runif(1, 0, min(rt1$rt)) #ensures t0 is mot too large
names(init_par) &lt;- c("A", "b", "t0", "mean_v1", "mean_v2",  "sd_v2")
nlminb(objective_fun, start = init_par, rt=rt1$rt, response=rt1$response, lower = 0)

## End(Not run)


# plot cdf (2 accumulators):
curve(pLBA(x, response = 1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2)), 
     xlim = c(0, 2), ylim = c(0,1), 
     ylab = "cumulative probability", xlab = "response time",
     main = "Defective CDFs of LBA")
curve(pLBA(x, response = 2, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2)), 
     add=TRUE, lty = 2)
legend("topleft", legend=c("1", "2"), title="Response", lty=1:2)


# plot cdf (3 accumulators):
curve(pLBA(x, response = 1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6, 1.0), sd_v=c(1,1.2, 2.0)), 
     xlim = c(0, 2), ylim = c(0,1), 
     ylab = "cumulative probability", xlab = "response time",
     main = "Defective CDFs of LBA")
curve(pLBA(x, response = 2, A=0.5, b=1, t0 = 0.5,  mean_v=c(2.4, 1.6, 1.0), sd_v=c(1,1.2, 2.0)), 
     add=TRUE, lty = 2)
curve(pLBA(x, response = 3, A=0.5, b=1, t0 = 0.5,  mean_v=c(2.4, 1.6, 1.0), sd_v=c(1,1.2, 2.0)), 
     add=TRUE, lty = 3)
legend("topleft", legend=c("1", "2", "3"), title="Response", lty=1:2)


## qLBA can only return values up to maximal predicted probability:
(max_p &lt;- pLBA(Inf, response = 1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2)))
# [1] 0.6604696

qLBA(0.66, response = 1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))
# 2.559532

qLBA(0.67, response = 1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))
# NA

# to get predicted quantiles, scale required quantiles by maximally predicted response rate:
qs &lt;- c(.1, .3, .5, .7, .9)
qLBA(qs*max_p, response = 1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))

# or set scale_p to TRUE which scales automatically by maximum p
# (but can be slow as it calculates max_p for each probability separately) 
qLBA(qs, response = 1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2), scale_p=TRUE)

# qLBA also accepts a data.frame as first argument:
t &lt;- data.frame(p = rep(c(0.05, 0.1, 0.66), 2), response = rep(1:2, each = 3))
#      p response
# 1 0.05        1
# 2 0.10        1
# 3 0.66        1
# 4 0.05        2
# 5 0.10        2
# 6 0.66        2
qLBA(t, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))


## LBA and diffusion can be used interchangeably:
rt1 &lt;- rLBA(500, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))
rt2 &lt;- rdiffusion(500, a=1, v=2, t0=0.5)

# data can also be passed as data.frame (same is true for pLBA):
sum(log(dLBA(rt1, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))))
sum(log(dLBA(rt2, A=0.5, b=1, t0 = 0.5, mean_v=c(2.4, 1.6), sd_v=c(1,1.2))))

sum(log(ddiffusion(rt1, a=1, v=2, t0=0.5)))
sum(log(ddiffusion(rt2, a=1, v=2, t0=0.5)))

### trial wise parameters work as expected (only since package version 0.9):
x1 &lt;- dLBA(rt=c(1,1), response=c(1,2), A=1,b=list(c(1,3),c(2,4)),
           t0=0.1, mean_v=c(3,3), sd_v=c(1,1),distribution="norm")
x2a &lt;- dLBA(rt=c(1), response=c(1), A=1,b=list(c(1),c(2)),
            t0=0.1,mean_v=c(3,3),sd_v=c(1,1),distribution="norm")
x2b &lt;- dLBA(rt=c(1), response=c(2), A=1,b=list(c(3),c(4)),
            t0=0.1,mean_v=c(3,3),sd_v=c(1,1),distribution="norm")
all(x1 == c(x2a, x2b)) ## should be TRUE
</code></pre>

<hr>
<h2 id='LBA-race'>LBA race functions: Likelihood for first accumulator to win.</h2><span id='topic+LBA-race'></span><span id='topic+n1PDF'></span><span id='topic+n1CDF'></span>

<h3>Description</h3>

<p>n1PDF and n1CDF take RTs, the distribution functions of the <a href="#topic+LBA">LBA</a>, and
corresponding parameter values and put them throughout the race equations and
return the likelihood for the first accumulator winning (hence n1) in a set
of accumulators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n1PDF(rt, A, b, t0, ..., st0 = 0, distribution = c("norm", "gamma",
  "frechet", "lnorm"), args.dist = list(), silent = FALSE)

n1CDF(rt, A, b, t0, ..., st0 = 0, distribution = c("norm", "gamma",
  "frechet", "lnorm"), args.dist = list(), silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LBA-race_+3A_rt">rt</code></td>
<td>
<p>a vector of RTs.</p>
</td></tr>
<tr><td><code id="LBA-race_+3A_a">A</code>, <code id="LBA-race_+3A_b">b</code>, <code id="LBA-race_+3A_t0">t0</code></td>
<td>
<p>LBA parameters, see <code><a href="#topic+LBA">LBA</a></code>. Can either be a single
numeric vector (which will be recycled to reach <code>length(rt)</code> for
trialwise parameters) <em>or</em> a <code>list</code> of such vectors in which each
list element corresponds to the parameters for this accumulator (i.e., the
list needs to be of the same length as there are accumulators). Each list
will also be recycled to reach <code>length(rt)</code> for trialwise parameters
per accumulator.</p>
</td></tr>
<tr><td><code id="LBA-race_+3A_...">...</code></td>
<td>
<p>two <em>named</em> drift rate parameters depending on
<code>distribution</code> (e.g., <code>mean_v</code> and <code>sd_v</code> for
<code>distribution=="norm"</code>). The parameters can either be given as a
numeric vector or a list. If a numeric vector is passed each element of the
vector corresponds to one accumulator. If a list is passed each list
element corresponds to one accumulator allowing again trialwise driftrates.
The shorter parameter will be recycled as necessary (and also the elements
of the list to match the length of <code>rt</code>). See examples.</p>
</td></tr>
<tr><td><code id="LBA-race_+3A_st0">st0</code></td>
<td>
<p>parameter specifying the variability of <code>t0</code> (which varies
uniformly from <code>t0</code> to <code>t0</code> + <code>st0</code>). Can be trialwise, and
will be recycled to length of <code>rt</code>.</p>
</td></tr>
<tr><td><code id="LBA-race_+3A_distribution">distribution</code></td>
<td>
<p>character specifying the distribution of the drift rate.
Possible values are <code>c("norm", "gamma", "frechet", "lnorm")</code>, default
is <code>"norm"</code>.</p>
</td></tr>
<tr><td><code id="LBA-race_+3A_args.dist">args.dist</code></td>
<td>
<p>list of optional further arguments to the distribution
functions (i.e., <code>posdrift</code> or <code>robust</code> for
<code>distribution=="norm"</code>).</p>
</td></tr>
<tr><td><code id="LBA-race_+3A_silent">silent</code></td>
<td>
<p>logical. Should the number of accumulators used be suppressed?
Default is <code>FALSE</code> which prints the number of accumulators.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a set of <code class="reqn">N</code> independent accumulators <code class="reqn">i = 1...N</code>, the
race likelihood for a given accumulator <code class="reqn">i</code> is given by 
</p>
<p style="text-align: center;"><code class="reqn">L(\mbox{unit }i \mbox{ wins}) = f_i(t) \times \prod_{j&lt;&gt;i} [ S_j(t)
  ]</code>
</p>
<p> where <code class="reqn">f(t)</code> is the
PDF (<code>dlba_...</code>) and <code class="reqn">S_j(t) = 1 - F_j(t)</code> is the survivor
function, that is the complement of the CDF <code class="reqn">F(t)</code> (<code>plba_...</code>) at
time <code class="reqn">t</code>.
</p>
<p>In other words, this is just the PDF/CDF for the winning accumulator at
time <code class="reqn">t</code> times the probability that no other accumulators have finished
at time <code class="reqn">t</code>.
</p>


<h3>See Also</h3>

<p>For more user-friendly functions that return the PDF or CDF for the
corresponding (and not first) accumulator winning see /code/linkLBA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## check random generated values against race functions:

## 1. Without st0:
r_lba &lt;- rLBA(1e4, A=0.5, b=1, t0 = 0.5, mean_v=c(1.2, 1), sd_v=0.2)
x &lt;- seq(0.5, 4, length.out = 100) # for plotting
# PDF
y &lt;- n1PDF(x, A=0.5, b=1, t0 = 0.5, mean_v=c(1.2, 1.0), sd_v=0.2) # PDF
hist(r_lba$rt[r_lba$response==1],probability = TRUE, breaks = "FD")
lines(x=x,y=y/mean(r_lba$response == 1))
# CDF
plot(ecdf(r_lba$rt[r_lba$response==1]))
y &lt;- n1CDF(x, A=0.5, b=1, t0 = 0.5, st0 = 0, mean_v=c(1.2, 1.0), sd_v=0.2)
lines(x=x,y=y/mean(r_lba$response == 1), col = "red", lwd = 4.5, lty = 2)
# KS test
## Not run: 
normalised_n1CDF = function(rt,...) n1CDF(rt,...)/n1CDF(rt=Inf,...) 
ks.test(r_lba$rt[r_lba$response==1], normalised_n1CDF, A=0.5, b=1, t0 = 0.5, 
        mean_v=c(1.2, 1.0), sd_v=0.2)

## End(Not run)

## Not run: 
## Other examples (don't run to save time):
  
## 2. With st0 = 0.2:
r_lba &lt;- rLBA(1e4, A=0.5, b=1, t0 = 0.5, st0 = 0.2, mean_v=c(1.2, 1), sd_v=0.2)
x &lt;- seq(0.5, 4, length.out = 100) # for plotting
# PDF
y &lt;- n1PDF(x, A=0.5, b=1, t0 = 0.5, st0 = 0.2, mean_v=c(1.2, 1.0), sd_v=0.2) # PDF
hist(r_lba$rt[r_lba$response==1],probability = TRUE, breaks = "FD")
lines(x=x,y=y/mean(r_lba$response == 1))
# CDF
plot(ecdf(r_lba$rt[r_lba$response==1]))
y &lt;- n1CDF(x, A=0.5, b=1, t0 = 0.5, st0 = 0.2, mean_v=c(1.2, 1.0), sd_v=0.2)
lines(x=x,y=y/mean(r_lba$response == 1), col = "red", lwd = 4.5, lty = 2)
# KS test
normalised_n1CDF = function(rt,...) n1CDF(rt,...)/n1CDF(rt=Inf,...) 
ks.test(r_lba$rt[r_lba$response==1], normalised_n1CDF, A=0.5, b=1, t0 = 0.5, 
        st0 = 0.2, mean_v=c(1.2, 1.0), sd_v=0.2)


xx &lt;- rLBA(10, A=0.5, b=1, t0 = 0.5, mean_v=1.2, sd_v=0.2)

# default uses normal distribution for drift rate:
n1PDF(xx$rt, A=0.5, b=1, t0 = 0.5, mean_v=c(1.2, 1.0), sd_v=0.2)

# other distributions:
n1PDF(xx$rt, A=0.5, b=1, t0 = 0.5, shape_v=c(1.2, 1), scale_v=c(0.2,0.3), distribution = "gamma")
n1PDF(xx$rt, A=0.5, b=1, t0 = 0.5, shape_v=c(1.2, 1), scale_v=c(0.2,0.3), distribution = "frechet")
n1PDF(xx$rt, A=0.5, b=1, t0 = 0.5, meanlog_v = c(0.5, 0.8), sdlog_v = 0.5, distribution = "lnorm")

# add st0:
n1PDF(xx$rt, A=0.5, b=1, t0 = 0.5, mean_v=c(1.2, 1.0), sd_v=0.2, st0 = 0.4)


# use different A parameters for each RT:
n1PDF(xx$rt, A=runif(10, 0.4, 0.6), 
      b=1, t0 = 0.5, mean_v=c(1.2, 1.0), sd_v=0.2)

# use different A parameters for each RT and each accumulator:
n1PDF(xx$rt, A=list(runif(10, 0.4, 0.6), runif(10, 0.2, 0.4)), 
      b=1, t0 = 0.5, mean_v=c(1.2, 1.0), sd_v=0.2)


### vectorize drift rates:

# vector versus list:
v1 &lt;- n1PDF(xx$rt, A=0.5, b=1, t0 = 0.5, mean_v=c(1.2, 1.0), sd_v=0.2)
v2 &lt;- n1PDF(xx$rt, A=0.5, b=1, t0 = 0.5, mean_v=list(1.2, 1.0), sd_v=0.2)
identical(v1, v2)  # TRUE

# drift rate per trial:
n1PDF(xx$rt, A=0.5, b=1, t0 = 0.5, mean_v=list(rnorm(10, 1.2), rnorm(10, 1)), sd_v=0.2)

# combine list with vector:
n1PDF(xx$rt, A=0.5, b=1, t0 = 0.5, mean_v=list(rnorm(10, 1.2), rnorm(10, 1)), sd_v=c(0.2, 0.1))

# t0 per trial and accumulator:
n1PDF(xx$rt, A=0.5, b=1, t0 = c(0.5), mean_v=c(1.2, 1.0), sd_v=0.2)
n1PDF(xx$rt, A=0.5, b=1, t0 = c(0.5, 0.6), mean_v=c(1.2, 1.0), sd_v=0.2) # per trial only
n1PDF(xx$rt, A=0.5, b=1, t0 = list(0.5, 0.6), mean_v=c(1.2, 1.0), sd_v=0.2) # per drift rate only
n1PDF(xx$rt, A=0.5, b=1, t0 = list(c(0.4, 0.5), c(0.5, 0.6)), mean_v=c(1.2, 1.0), sd_v=0.2)

## End(Not run)
</code></pre>

<hr>
<h2 id='rr98'>Ratcliff and Rouder (1998, Exp. 1) Luminance Discrimination Data</h2><span id='topic+rr98'></span>

<h3>Description</h3>

<p>Responses and response times from an experiment in which three participants were asked to decide whether the overall brightness of pixel arrays displayed on a computer monitor was &quot;high&quot; or &quot;low&quot;. In addition, instruction manipulated speed and accuracy between blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rr98
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 24,358 obs. and 12 variables:
</p>

<dl>
<dt>id</dt><dd><p>participant id, factor with three levels</p>
</dd>
<dt>session</dt><dd><p>session number, integer</p>
</dd>
<dt>block</dt><dd><p>block number, integer</p>
</dd>
<dt>trial</dt><dd><p>trial number within a block, integer</p>
</dd>
<dt>instruction</dt><dd><p>factor with two levels: <code>"accuracy"</code> for blocks with accuracy instructions; <code>"speed"</code> for blocks with speed instruction</p>
</dd>
<dt>source</dt><dd><p>factor with two levels: distribution strength was drawn from, <code>"dark"</code> and <code>"light"</code></p>
</dd>
<dt>strength</dt><dd><p>proportion of white to black pixels were varied by 33 equally spaced proportions from zero (all 1,024 pixels were black) to 1 (all 1,024 pixels were white). with 0 darkest and 32 lightest. Integer.</p>
</dd>
<dt>response</dt><dd><p>factor with two levels: <code>"dark"</code> and <code>"light"</code></p>
</dd>
<dt>response_num</dt><dd><p>numeric response variable such that <code>1="dark"</code> and <code>2="light"</code></p>
</dd>
<dt>correct</dt><dd><p>boolean indicating whether or not <code>source==response</code>. (Does not seem to be used in the original analysis.)</p>
</dd>
<dt>rt</dt><dd><p>response time in seconds</p>
</dd>
<dt>outlier</dt><dd><p>boolean indicating whether or not the response was considered an outlier by Ratcliff and Rouder (1998), i.e., RTs outside of (200ms, 2500ms)</p>
</dd>
</dl>


<h3>Details</h3>

<p>The Experiment is described in the following by Ratcliff and Rouder (1998, pp. 349):
</p>
<p>In Experiment 1, subjects were asked to decide whether the overall
brightness of pixel arrays displayed on a computer monitor was &quot;high&quot;
or &quot;low&quot;. The brightness of a display was controlled by the
proportion of the pixels that were white. For each trial, the proportion
of white pixels was chosen from one of two distributions, a high
distribution [i.e., light] or a low [i.e., dark] distribution, each with fixed mean and standard
deviation. Feedback was given after each trial to tell the subject whether his or her decision had correctly indicated the distribution
from which the stimulus had been chosen. Other than this feedback, a
subject had no information about the distributions. Because the distributions overlapped substantially, a subject could not be highly accurate. A display with 50
from the high distribution on one trial and the low distribution on
another.
</p>


<h4>Stimuli</h4>

 
<p>The stimulus display for Experiment 1 was a square that was 64
pixels on each side and subtended 3.8 degree of visual angle on a PC-VGA
monitor. [...] In each square, 3,072 randomly
chosen pixels were neutral gray, like the background, and the remaining 
1,024 pixels were either black or white; the proportion of white to
black pixels provided the brightness manipulation. There were 33
equally spaced proportions from zero (all 1,024 pixels were black) to
1 (all 1,024 pixels were white). The two distributions from which the
bright and dark stimuli were chosen were centered at .375 (low brightness) 
and .625 (high brightness), and they each had a standard deviation of .1875.
</p>



<h4>Procedure</h4>

<p>A subject's task was to decide, on each trial, from which distribution, 
high or low brightness in Experiment 1, the observed
stimulus (stimuli) had been sampled. Subjects made their decision by
pressing one of two response keys. On each trial, a 500-ms foreperiod, 
during which the display consisted solely of neutral gray, was followed 
by presentation of the stimulus; presentation was terminated by
the subject's response. In Experiment 1, speed-versus-accuracy
instructions were manipulated. For some blocks of trials, subjects
were instructed to respond as quickly as possible, and a &quot;too slow&quot;
message followed every response longer than 550 ms. For other
blocks of trials, subjects were instructed to be as accurate as possible,
and a &quot;bad error&quot; message followed incorrect responses to stimuli
from the extreme ends of the distributions. Experiment 1 had ten 35-min 
sessions, and Experiments 2 and 3 had four sessions. In Experiment 1, 
subjects switched from emphasis on speed to emphasis on
accuracy every 204 trials. Each session consisted of eight blocks of
102 trials per block, for a total of 8,160 trials per subject. Each 
session consisted of eight blocks of 102 trials, for a total of 3,264 trials
per subject in each experiment. For all trials in each experiment, subjects 
were instructed to maintain a high level of accuracy while
responding quickly, and an &quot;error&quot; message indicated incorrect
responses. Responses were followed by a 300-ms blank interval, and
the error message was displayed for 300 ms after the blank interval.
</p>



<h3>Note</h3>

<p>The data is already prepared following Ratcliff and Rouder (1998) by removing the following trials:
</p>

<ul>
<li><p>the first session for each participant
</p>
</li>
<li><p>the first 20 trials of each session
</p>
</li>
<li><p>the first trial of each block (each change in speed accuracy starts a new block)
</p>
</li></ul>

<p>To fully replicate the data used by Ratcliff and Rouder (1998) one only needs to remove the trials that are <code>TRUE</code> in column <code>outlier</code> (i.e., RTs outside of (200ms, 2500ms)). The full raw data is also available as part of this package, see:<br />
<code>system.file("extdata", "rr98-data", package = "rtdists")</code> and <code>system.file("extdata", "rr98-data.codes", package = "rtdists")</code>
</p>


<h3>Source</h3>

<p>Ratcliff, R., &amp; Rouder, J. N. (1998). Modeling Response Times for Two-Choice Decisions. <em>Psychological Science</em>, 9(5), 347-356. http://doi.org/10.1111/1467-9280.00067
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(rr98)
rr98 &lt;- rr98[!rr98$outlier,]  #remove outliers
head(rr98)
#   id session block trial instruction source strength response response_num correct    rt outlier
# 1 jf       2     1    21    accuracy   dark        8     dark            1    TRUE 0.801   FALSE
# 2 jf       2     1    22    accuracy   dark        7     dark            1    TRUE 0.680   FALSE
# 3 jf       2     1    23    accuracy  light       19    light            2    TRUE 0.694   FALSE
# 4 jf       2     1    24    accuracy   dark       21    light            2   FALSE 0.582   FALSE
# 5 jf       2     1    25    accuracy  light       19     dark            1   FALSE 0.925   FALSE
# 6 jf       2     1    26    accuracy   dark       10     dark            1    TRUE 0.605   FALSE

## See vignette for more examples.
</code></pre>

<hr>
<h2 id='single-LBA'>Single accumulator of linear ballistic accumulator (LBA)</h2><span id='topic+single-LBA'></span><span id='topic+dlba_norm'></span><span id='topic+plba_norm'></span><span id='topic+rlba_norm'></span><span id='topic+dlba_gamma'></span><span id='topic+plba_gamma'></span><span id='topic+rlba_gamma'></span><span id='topic+dlba_frechet'></span><span id='topic+plba_frechet'></span><span id='topic+rlba_frechet'></span><span id='topic+dlba_lnorm'></span><span id='topic+plba_lnorm'></span><span id='topic+rlba_lnorm'></span>

<h3>Description</h3>

<p>Density, distribution function, and random generation for a single accumulator of the LBA model with the following parameters: <code>A</code> (upper value of starting point), <code>b</code> (response threshold), <code>t0</code> (non-decision time), and driftrate (<code>v</code>). All functions are available with different distributions underlying the drift rate: Normal (<code>norm</code>), Gamma (<code>gamma</code>), Frechet (<code>frechet</code>), and log normal (<code>lnorm</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlba_norm(rt, A, b, t0, mean_v, sd_v, posdrift = TRUE, robust = FALSE)

plba_norm(rt, A, b, t0, mean_v, sd_v, posdrift = TRUE, robust = FALSE)

rlba_norm(n, A, b, t0, mean_v, sd_v, st0 = 0, posdrift = TRUE)

dlba_gamma(rt, A, b, t0, shape_v, rate_v, scale_v)

plba_gamma(rt, A, b, t0, shape_v, rate_v, scale_v)

rlba_gamma(n, A, b, t0, shape_v, rate_v, scale_v, st0 = 0)

dlba_frechet(rt, A, b, t0, shape_v, scale_v)

plba_frechet(rt, A, b, t0, shape_v, scale_v)

rlba_frechet(n, A, b, t0, shape_v, scale_v, st0 = 0)

dlba_lnorm(rt, A, b, t0, meanlog_v, sdlog_v, robust = FALSE)

plba_lnorm(rt, A, b, t0, meanlog_v, sdlog_v, robust = FALSE)

rlba_lnorm(n, A, b, t0, meanlog_v, sdlog_v, st0 = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="single-LBA_+3A_rt">rt</code></td>
<td>
<p>a vector of RTs.</p>
</td></tr>
<tr><td><code id="single-LBA_+3A_a">A</code></td>
<td>
<p>start point interval or evidence in accumulator before beginning of decision process. Start point varies from trial to trial in the interval [0, <code>A</code>] (uniform distribution). Average amount of evidence before evidence accumulation across trials is <code>A</code>/2.</p>
</td></tr>
<tr><td><code id="single-LBA_+3A_b">b</code></td>
<td>
<p>response threshold. (<code>b</code> - <code>A</code>/2) is a measure of &quot;response caution&quot;.</p>
</td></tr>
<tr><td><code id="single-LBA_+3A_t0">t0</code></td>
<td>
<p>non-decision time or response time constant (in seconds). Lower bound for the duration of all non-decisional processes (encoding and response execution).</p>
</td></tr>
<tr><td><code id="single-LBA_+3A_mean_v">mean_v</code>, <code id="single-LBA_+3A_sd_v">sd_v</code></td>
<td>
<p>mean and standard deviation of normal distribution for drift rate (<code>norm</code>). See <code><a href="stats.html#topic+Normal">Normal</a></code></p>
</td></tr>
<tr><td><code id="single-LBA_+3A_posdrift">posdrift</code></td>
<td>
<p>logical. Should driftrates be forced to be positive? Default is <code>TRUE</code>. (Uses truncated normal for random generation).</p>
</td></tr>
<tr><td><code id="single-LBA_+3A_robust">robust</code></td>
<td>
<p>logical. Should robust normal distributions be used for <code>norm</code> and <code>lnorm</code>? Can be helpful in rare cases but is approximately three times slower than the non-robust versions. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="single-LBA_+3A_n">n</code></td>
<td>
<p>desired number of observations (scalar integer).</p>
</td></tr>
<tr><td><code id="single-LBA_+3A_st0">st0</code></td>
<td>
<p>variability of non-decision time, such that <code>t0</code> is uniformly distributed between <code>t0</code> and <code>t0</code> + <code>st0</code>. Only available in random number generation functions <code>rlba_</code>.</p>
</td></tr>
<tr><td><code id="single-LBA_+3A_shape_v">shape_v</code>, <code id="single-LBA_+3A_rate_v">rate_v</code>, <code id="single-LBA_+3A_scale_v">scale_v</code></td>
<td>
<p>shape, rate, and scale of gamma (<code>gamma</code>) and scale and shape of Frechet (<code>frechet</code>) distributions for drift rate. See <code><a href="stats.html#topic+GammaDist">GammaDist</a></code> or <code><a href="evd.html#topic+frechet">frechet</a></code>. For Gamma, scale = 1/shape and shape = 1/scale.</p>
</td></tr>
<tr><td><code id="single-LBA_+3A_meanlog_v">meanlog_v</code>, <code id="single-LBA_+3A_sdlog_v">sdlog_v</code></td>
<td>
<p>mean and standard deviation of lognormal distribution on the log scale for drift rate (<code>lnorm</code>). See <code><a href="stats.html#topic+Lognormal">Lognormal</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are mainly for internal purposes. We do not recommend to use them. Use the high-level functions described in <code>/link{LBA}</code> instead.
</p>


<h3>Value</h3>

<p>All functions starting with a <code>d</code> return the density (PDF), all functions starting with <code>p</code> return the distribution function (CDF), and all functions starting with <code>r</code> return random response times and responses (in a <code>matrix</code>).
</p>


<h3>Note</h3>

<p>Density (i.e., <code>dlba_</code>), distribution (i.e., <code>plba_</code>), and random derivative (i.e., <code>rlba_</code>) functions are vectorized for all parameters (i.e., in case parameters are not of the same length as <code>rt</code>, parameters are recycled). Furthermore, the random derivative functions also accept a matrix of length <code>n</code> in which each column corresponds to a accumulator specific value (see <code><a href="#topic+rLBA">rLBA</a></code> for a more user-friendly way).
</p>


<h3>References</h3>

<p>Brown, S. D., &amp; Heathcote, A. (2008). The simplest complete model of choice response time: Linear ballistic accumulation. <em>Cognitive Psychology</em>, 57(3), 153-178. doi:10.1016/j.cogpsych.2007.12.002
</p>
<p>Donkin, C., Averell, L., Brown, S., &amp; Heathcote, A. (2009). Getting more from accuracy and response time data: Methods for fitting the linear ballistic accumulator. <em>Behavior Research Methods</em>, 41(4), 1095-1110. doi:10.3758/BRM.41.4.1095
</p>
<p>Heathcote, A., &amp; Love, J. (2012). Linear deterministic accumulator models of simple choice. <em>Frontiers in Psychology</em>, 3, 292. doi:10.3389/fpsyg.2012.00292
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## random number generation using different distributions for v:
rlba_norm(10, A=0.5, b=1, t0 = 0.5, mean_v=c(1.2, 1), sd_v=c(0.2,0.3))
rlba_gamma(10, A=0.5, b=1, t0 = 0.5, shape_v=c(1.2, 1), scale_v=c(0.2,0.3))
rlba_frechet(10, A=0.5, b=1, t0 = 0.5, shape_v=c(1.2, 1), scale_v=c(0.2,0.3))
rlba_lnorm(10, A=0.5, b=1, t0 = 0.5, meanlog_v=c(1.2, 1), sdlog_v=c(0.2, 0.3))

# use somewhat plausible values for plotting:
A &lt;- 0.2
b &lt;- 0.5
t0 &lt;- 0.3

# plot density:
curve(dlba_norm(x, A=A, b=b, t0=t0, mean_v = 1.0, sd_v = 0.5), ylim = c(0, 4),
      xlim=c(0,3), main="Density/PDF of LBA versions", ylab="density", xlab="response time")
curve(dlba_gamma(x, A=A, b=b, t0=t0, shape_v=1, scale_v=1), add=TRUE, lty = 2)
curve(dlba_frechet(x, A=A, b=b, t0=t0, shape_v=1,scale_v=1.0), add=TRUE, lty = 3)
curve(dlba_lnorm(x, A=A, b=b, t0=t0, meanlog_v = 0.5, sdlog_v = 0.5), add=TRUE, lty = 4)
legend("topright", legend=c("Normal", "Gamma", "Frechet", "Log-Normal"), 
      title = expression("Distribution of"~~italic(v)), lty = 1:4)


# plot cdf:
curve(plba_norm(x, A=A, b=b, t0=t0, mean_v=1.0, sd_v=1.0), 
      xlim = c(0, 3),ylim = c(0,1), 
      ylab = "cumulative probability", xlab = "response time",
      main = "Distribution/CDF of LBA versions")
curve(plba_gamma(x, A=A, b=b, t0=t0, shape_v=1,scale_v=1), add=TRUE, lty = 2)
curve(plba_frechet(x, A=A, b=b, t0=t0, shape=1, scale=1), add=TRUE, lty = 3)
curve(plba_lnorm(x, A=A, b=b, t0=t0, meanlog_v=0.5, sdlog_v = 0.5), add=TRUE, lty = 4)
legend("bottomright", legend=c("Normal", "Gamma", "Frechet", "Log-Normal"), 
       title = expression("Distribution of"~~italic(v)), lty = 1:4)
</code></pre>

<hr>
<h2 id='speed_acc'>Speed-Accuracy Data from Wagenmakers, Ratcliff, Gomez, &amp; McKoon (2008, Experiment 1)</h2><span id='topic+speed_acc'></span>

<h3>Description</h3>

<p>Responses and response times from an experiment in which instruction manipulated speed and accuracy between blocks. This data was also analyzed by Heathcote and Love (2012) who were the first to use the 17 participants also included here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>speed_acc
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 31,522 obs. and 9 variables:
</p>

<dl>
<dt>id</dt><dd><p>participant id</p>
</dd>
<dt>block</dt><dd><p>block number</p>
</dd>
<dt>condition</dt><dd><p><code>accuracy</code> for blocks with accuracy instructions; <code>speed</code> for blocks with speed instruction</p>
</dd>
<dt>stim</dt><dd><p>unique identifier of stimulus, stimuli are nested in frequency conditions</p>
</dd>
<dt>stim_cat</dt><dd><p>category of stimulus, either word or non-word</p>
</dd>
<dt>frequency</dt><dd><p>&quot;high frequency word&quot;, &quot;low frequency word&quot;, &quot;very low frequency word&quot;, or non-words derived from the first three categories</p>
</dd>
<dt>response</dt><dd><p><code>word</code>, <code>nonword</code>, or not interpretable response (<code>error</code>, i.e., pushed a button, but not the right one and also not the one next to the right button)</p>
</dd>
<dt>rt</dt><dd><p>response time in seconds</p>
</dd>
<dt>censor</dt><dd><p>boolean indicating whether or not a response should be eliminated prior to analysis; uninterpretable response, too fast response (&lt;180 ms), too slow response (&gt;3 sec)</p>
</dd>
</dl>


<h3>Details</h3>

<p>The data excludes the practice blocks but includes all trials. Variable <code>censor</code> can be used for excluding all trials also excluded from the papers using it namely uninterpretable response, too fast response (&lt;180 ms), too slow response (&gt;3 sec). Heathcote and Love (2012, p. 7) describe the data as follows:
</p>
<p>We fit the LBA and LNR models to data from Wagenmaker et al.'s (2008) experiment one, where participants made decisions about whether a string of letters constituted a word. These lexical decisions were made about four types of stimuli, non-words (nw) and high-frequency (hf), low-frequency (lf), and very low-frequency (vlf) words. Participants made decisions either under speed or accuracy emphasis instructions in different experimental blocks. Accuracy blocks were preceded by the message &quot;Try to respond accurately&quot; and &quot;ERROR&quot; was displayed after each wrong response. Speed blocks were preceded by the message &quot;Try to respond accurately&quot; and &quot;TOO SLOW&quot; was displayed after each response slower than 0.75 s.We report analyses of data from 17 participants (31,412 data points) in their Experiment 1, including the 15 participants analyzed in Wagenmakers et al. (2008) and two extras (we thank Eric-Jan Wagenmakers for supplying this data).
</p>


<h3>Source</h3>

<p>Wagenmakers, E.-J., Ratcliff, R., Gomez, P., &amp; McKoon, G. (2008). A diffusion model account of criterion shifts in the lexical decision task. <em>Journal of Memory and Language</em>, 58(1), 140-159.
</p>


<h3>References</h3>

<p>Heathcote, A., &amp; Love, J. (2012). Linear deterministic accumulator models of simple choice. <em>Frontiers in Psychology: Cognitive Science</em>, 3, 292. doi:10.3389/fpsyg.2012.00292
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(speed_acc)
str(speed_acc)

# remove excluded trials:
speed_acc &lt;- droplevels(speed_acc[!speed_acc$censor,])

# new factors for obtaining values as in Table 1, Wagenmakers et al. (2008, p. 152)
speed_acc$freq &lt;- with(speed_acc, 
                       factor(ifelse(stim_cat == "nonword", "nonword", 
                                     as.character(frequency)), 
                              levels = c("high", "low", "very_low", "nonword")))
# corr = correct (0 = correct, 1 = error)
speed_acc$corr &lt;- with(speed_acc, 1-as.numeric(stim_cat == response))

str(speed_acc)

## aggregated RTs:
aggregate(rt ~ condition + freq + corr, speed_acc, mean)
## Error Rate:
aggregate(corr ~ condition + freq + corr, speed_acc, mean)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
