<!DOCTYPE html><html><head><title>Help for package ssanv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ssanv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#example.of.Fisher.exact'><p>Object of class &lsquo;power.htest&rsquo;</p></a></li>
<li><a href='#find.calibrated.beta'><p> Find calibrated beta</p></a></li>
<li><a href='#ss.fromdata.neff'><p>Find sample sizes when normal standardized difference is estimated from data</p></a></li>
<li><a href='#ss.fromdata.nvar'><p>Find sample sizes when normal standard deviation is estimated from data</p></a></li>
<li><a href='#ss.fromdata.pois'><p>Find sample sizes when 2 Poisson means are estimated from data</p></a></li>
<li><a href='#ss.nonadh'><p>Find sample sizes accounting for nonadherence</p></a></li>
<li><a href='#ssanv-package'>
<p>Sample Size Adjusted for Nonadherence or Variability of Input Parameters</p></a></li>
<li><a href='#uniroot.integer'><p>Find the root of a function to the nearest integer</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Sample Size Adjusted for Nonadherence or Variability of Input
Parameters</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2015-06-22</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael P. Fay &lt;mfay@niaid.nih.gov&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael P. Fay &lt;mfay@niaid.nih.gov&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.1.1), stats</td>
</tr>
<tr>
<td>Description:</td>
<td>A set of functions to calculate sample size for two-sample difference in means tests. Does adjustments for either nonadherence or variability that comes from using data to estimate parameters.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-06-23 13:18:28 UTC; faym</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-06-23 17:26:38</td>
</tr>
</table>
<hr>
<h2 id='example.of.Fisher.exact'>Object of class &lsquo;power.htest&rsquo;</h2><span id='topic+example.of.Fisher.exact'></span>

<h3>Description</h3>

<p>Result from ss.nonadh(mu0=.1,mu1=.4,refinement=&quot;Fisher.exact&quot;). It took about 8 seconds to calculate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(example.of.Fisher.exact)</code></pre>


<h3>Details</h3>

<p>Compared with StatXact, gives same sample sizes.
</p>

<hr>
<h2 id='find.calibrated.beta'> Find calibrated beta</h2><span id='topic+find.calibrated.beta'></span>

<h3>Description</h3>

<p>Called by <code><a href="#topic+ss.fromdata.nvar">ss.fromdata.nvar</a></code>. Finds calibrated beta (1-power) for use when estimating 
standard deviation from data in sample size calculations for differences in two normal means.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.calibrated.beta(beta, df, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.calibrated.beta_+3A_beta">beta</code></td>
<td>
<p> 1-nominal.power</p>
</td></tr>
<tr><td><code id="find.calibrated.beta_+3A_df">df</code></td>
<td>
<p>degrees of freedom</p>
</td></tr>
<tr><td><code id="find.calibrated.beta_+3A_alpha">alpha</code></td>
<td>
<p>one-sided significance level of test </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+ss.fromdata.nvar">ss.fromdata.nvar</a></code>.
</p>


<h3>Value</h3>

<p>Calibrated beta value = 1 - calibrated power.
</p>


<h3>Author(s)</h3>

<p>Michael P. Fay</p>


<h3>References</h3>

<p> Fay, M.P., Halloran, M.E., and Follmann, D.A. (2007). 'Accounting for Variability in Sample Size Estimation with Applications to 
Nonadherence and Estimation of  Variance and Effect Size' Biometrics 63: 465-474. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ss.fromdata.nvar">ss.fromdata.nvar</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>## see Table 2 of Fay et al 2006.
1-find.calibrated.beta(.2,12,.025)

</code></pre>

<hr>
<h2 id='ss.fromdata.neff'>Find sample sizes when normal standardized difference is estimated from data</h2><span id='topic+ss.fromdata.neff'></span>

<h3>Description</h3>

<p>Calculate sample sizes for two-sample differences in normal means when standardized difference is estimated from existing data</p>


<h3>Usage</h3>

<pre><code class='language-R'>ss.fromdata.neff(thetahat, m0, m1, ss.ratio = 1, thetaB = 0, 
    sig.level = 0.05, real.power = 0.8, nominal.power = NULL, 
    alternative = c("two.sided", "one.sided"), 
    MINN0 = 2, MAXN0 = Inf, subdivisions = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ss.fromdata.neff_+3A_thetahat">thetahat</code></td>
<td>
<p>estimated standardized difference in means</p>
</td></tr>
<tr><td><code id="ss.fromdata.neff_+3A_m0">m0</code></td>
<td>
<p>sample size from control group of existing data</p>
</td></tr>
<tr><td><code id="ss.fromdata.neff_+3A_m1">m1</code></td>
<td>
<p>sample size from treatment group of existing data</p>
</td></tr>
<tr><td><code id="ss.fromdata.neff_+3A_ss.ratio">ss.ratio</code></td>
<td>
<p>n1/n0, where n0 (n1) is sample size of control (treatment) group for proposed study</p>
</td></tr>
<tr><td><code id="ss.fromdata.neff_+3A_thetab">thetaB</code></td>
<td>
<p>boundary value between null and alternative hypotheses for one-sided tests (see details)</p>
</td></tr>
<tr><td><code id="ss.fromdata.neff_+3A_sig.level">sig.level</code></td>
<td>
<p> significance level (Type I error)</p>
</td></tr>
<tr><td><code id="ss.fromdata.neff_+3A_real.power">real.power</code></td>
<td>
<p>minimum power that you want the sample size to achieve, only .8 or .9 allowed</p>
</td></tr>
<tr><td><code id="ss.fromdata.neff_+3A_nominal.power">nominal.power</code></td>
<td>
<p>see details</p>
</td></tr>
<tr><td><code id="ss.fromdata.neff_+3A_alternative">alternative</code></td>
<td>
<p>One- or two-sided test</p>
</td></tr>
<tr><td><code id="ss.fromdata.neff_+3A_minn0">MINN0</code></td>
<td>
<p>minimum sample size for control group </p>
</td></tr>
<tr><td><code id="ss.fromdata.neff_+3A_maxn0">MAXN0</code></td>
<td>
<p>maximum sample size for control group</p>
</td></tr>
<tr><td><code id="ss.fromdata.neff_+3A_subdivisions">subdivisions</code></td>
<td>
<p> number of subdivisions for numerical integration</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the sample sizes for a study designed to test the difference between the means of two groups, 
where it is assumed  that the responses from each group are distributed normally with the same variance. 
The standardized difference in means (<code>thetahat</code>) is estimated from existing data that is assumed to also follow the 
same normal distribution. The method is inherently conservative, so that with a nominal power of .76 the real power 
will be about .80, and a nominal power of .88 the real power will be about .90. Other values of nominal power are 
allowed, but only real powers of .80 or .90 are allowed. 
The one-sided tests are designed to test either 
<code class="reqn">H_0: \theta \leq \theta_B</code> vs. 
<code class="reqn">H_1: \theta &gt; \theta_B</code> or to test 
<code class="reqn">H_0: \theta \geq \theta_B</code> vs. 
<code class="reqn">H_1: \theta &lt; \theta_B</code>.
The choice of hypotheses is determined by the value of <code>thetahat</code>; 
if <code>thetahat</code> <code class="reqn">&gt;</code> <code>thetaB</code> 
then the former hypotheses are tested, otherwise the latter are.
See Fay, Halloran and Follmann (2007) for details. 
</p>


<h3>Value</h3>

<p>Object of class &quot;power.htest&quot;, a list of the arguments
(including the computed sample sizes) augmented with 'METHOD' and 'NOTE'
elements. The values 'n0' and 'n1' are the samples sizes for the two groups, rounded up to the nearest integer.
</p>


<h3>Note</h3>

 
<p>The function <code>ss.fromdata.neff</code> calls <code><a href="#topic+uniroot.integer">uniroot.integer</a></code>, a function written for this package that 
finds the nearest integer to the root. </p>


<h3>Author(s)</h3>

<p>Michael P. Fay</p>


<h3>References</h3>

<p> Fay, M.P., Halloran, M.E., and Follmann, D.A. (2007). 'Accounting for Variability in Sample Size Estimation with Applications to 
Nonadherence and Estimation of  Variance and Effect Size' Biometrics 63: 465-474. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ss.fromdata.nvar">ss.fromdata.nvar</a></code>, 
<code><a href="#topic+ss.fromdata.pois">ss.fromdata.pois</a></code>,  
<code><a href="#topic+ss.nonadh">ss.nonadh</a></code>,  
<code><a href="#topic+uniroot.integer">uniroot.integer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ss.fromdata.neff(.588,23,25)
</code></pre>

<hr>
<h2 id='ss.fromdata.nvar'>Find sample sizes when normal standard deviation is estimated from data</h2><span id='topic+ss.fromdata.nvar'></span>

<h3>Description</h3>

<p>Calculate sample sizes for two-sample differences in normal means when the standard deviation (or variance) 
is estimated from existing data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ss.fromdata.nvar(delta, sdhat = NULL, vhat = NULL, 
    df = Inf, ss.ratio = 1, var.ratio = 1, deltaB = 0, 
    sig.level = 0.05, power = 0.8, 
    alternative = c("two.sided", "one.sided"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ss.fromdata.nvar_+3A_delta">delta</code></td>
<td>
<p>clinically significant difference in means</p>
</td></tr>
<tr><td><code id="ss.fromdata.nvar_+3A_sdhat">sdhat</code></td>
<td>
<p>estimate of standard deviation from existing data (must supply either sdhat or vhat)</p>
</td></tr>
<tr><td><code id="ss.fromdata.nvar_+3A_vhat">vhat</code></td>
<td>
<p>estimate of variance from existing data (must supply either sdhat or vhat)</p>
</td></tr>
<tr><td><code id="ss.fromdata.nvar_+3A_df">df</code></td>
<td>
<p> degrees of freedom associated with standard deviation (or variance) estimate</p>
</td></tr>
<tr><td><code id="ss.fromdata.nvar_+3A_ss.ratio">ss.ratio</code></td>
<td>
<p>n1/n0, where n0 (n1) is sample size of control (treatment) group for proposed study</p>
</td></tr>
<tr><td><code id="ss.fromdata.nvar_+3A_var.ratio">var.ratio</code></td>
<td>
<p><code class="reqn">\sigma_1^2/\sigma_0^2</code>, where <code class="reqn">\sigma_0</code> (<code class="reqn">\sigma_1</code>) is standard deviation of 
control (treatment) group for proposed study</p>
</td></tr>
<tr><td><code id="ss.fromdata.nvar_+3A_deltab">deltaB</code></td>
<td>
<p> boundary value between null and alternative hypotheses for one-sided tests (see details)</p>
</td></tr>
<tr><td><code id="ss.fromdata.nvar_+3A_sig.level">sig.level</code></td>
<td>
<p>significance level (Type I error)</p>
</td></tr>
<tr><td><code id="ss.fromdata.nvar_+3A_power">power</code></td>
<td>
<p> minimum power that you want the sample size to achieve</p>
</td></tr>
<tr><td><code id="ss.fromdata.nvar_+3A_alternative">alternative</code></td>
<td>
<p> One- or two-sided test</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the sample sizes for a study designed to test the difference between the means of two groups, 
where it is assumed  that the responses from each group are distributed normally. 
The standard deviation (sdhat) or variance (vhat) is estimated from existing data 
that is assumed to also follow a normal distribution with variance the same as the control group of 
the proposed study. 
If sdhat (or vhat) is estimated from one group with a sample size of m, then df=m-1.
If sdhat (or vhat) is estimated from two groups with sample sizes of m0 and m1, then df=m0+m1-2.
</p>
<p>The one-sided tests are designed to test either 
<code class="reqn">H_0: \delta \leq \delta_B</code> vs. 
<code class="reqn">H_1: \delta &gt; \delta_B</code> or to test 
<code class="reqn">H_0: \delta \geq \delta_B</code> vs. 
<code class="reqn">H_1: \delta &lt; \delta_B</code>.
The choice of hypotheses is determined by the value of <code>delta</code>; 
if <code>delta</code> <code class="reqn">&gt;</code> <code>deltaB</code>  
then the former hypotheses are tested, otherwise the latter are.
</p>
<p>See Fay, Halloran and Follmann (2007) for details. 
</p>


<h3>Value</h3>

<p>Object of class &quot;power.htest&quot;, a list of the arguments
(including the computed sample sizes) augmented with 'METHOD' and 'NOTE'
elements. The values 'n0' and 'n1' are the samples sizes for the two groups, rounded up to the nearest integer.
</p>


<h3>Note</h3>

<p>The function <code>ss.fromdata.nvar</code> calls <code><a href="#topic+find.calibrated.beta">find.calibrated.beta</a></code>, a function written for this package 
that finds the calibrated beta value (see Fay, Halloran and Follmann, 2007). 
</p>


<h3>Author(s)</h3>

<p>Michael P. Fay</p>


<h3>References</h3>

<p> Fay, M.P., Halloran, M.E., and Follmann, D.A. (2007). 'Accounting for Variability in Sample Size Estimation with Applications to 
Nonadherence and Estimation of  Variance and Effect Size' Biometrics 63: 465-474. </p>


<h3>See Also</h3>

  <p><code><a href="#topic+ss.fromdata.neff">ss.fromdata.neff</a></code>, 
<code><a href="#topic+ss.fromdata.pois">ss.fromdata.pois</a></code>,  
<code><a href="#topic+ss.nonadh">ss.nonadh</a></code>,  
<code><a href="#topic+find.calibrated.beta">find.calibrated.beta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ss.fromdata.nvar(.4,sdhat=.682,df=46)
</code></pre>

<hr>
<h2 id='ss.fromdata.pois'>Find sample sizes when 2 Poisson means are estimated from data </h2><span id='topic+ss.fromdata.pois'></span>

<h3>Description</h3>

<p>Calculate sample sizes for two-sample differences in Poisson means when means are estimated from existing data</p>


<h3>Usage</h3>

<pre><code class='language-R'>ss.fromdata.pois(xbar0, xbar1, m0, m1, ss.ratio = 1, sig.level = 0.05, 
    real.power = 0.8, nominal.power = NULL, 
    alternative = c("two.sided", "one.sided"), MINN0 = 1, MAXN0 = 10^5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ss.fromdata.pois_+3A_xbar0">xbar0</code></td>
<td>
<p> mean from control group of existing data </p>
</td></tr>
<tr><td><code id="ss.fromdata.pois_+3A_xbar1">xbar1</code></td>
<td>
<p> mean from treatment group of existing data</p>
</td></tr>
<tr><td><code id="ss.fromdata.pois_+3A_m0">m0</code></td>
<td>
<p>sample size of control group of existing data</p>
</td></tr>
<tr><td><code id="ss.fromdata.pois_+3A_m1">m1</code></td>
<td>
<p>sample size of treatment group of existing data</p>
</td></tr>
<tr><td><code id="ss.fromdata.pois_+3A_ss.ratio">ss.ratio</code></td>
<td>
<p>n1/n0, where n0 (n1) is sample size of control (treatment) group for proposed study</p>
</td></tr>
<tr><td><code id="ss.fromdata.pois_+3A_sig.level">sig.level</code></td>
<td>
<p> significance level (Type I error)</p>
</td></tr>
<tr><td><code id="ss.fromdata.pois_+3A_real.power">real.power</code></td>
<td>
<p>minimum power that you want the sample size to achieve, only .8 or .9 allowed</p>
</td></tr>
<tr><td><code id="ss.fromdata.pois_+3A_nominal.power">nominal.power</code></td>
<td>
<p>see details</p>
</td></tr>
<tr><td><code id="ss.fromdata.pois_+3A_alternative">alternative</code></td>
<td>
<p>One- or two-sided test</p>
</td></tr>
<tr><td><code id="ss.fromdata.pois_+3A_minn0">MINN0</code></td>
<td>
<p>minimum sample size for control group </p>
</td></tr>
<tr><td><code id="ss.fromdata.pois_+3A_maxn0">MAXN0</code></td>
<td>
<p>maximum sample size for control group</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the sample sizes for a study designed to test the difference between the means of two groups, 
where it is assumed  that the responses from both groups are distributed Poisson. 
The means from each group (<code>xbar0</code> and <code>xbar1</code>) come from existing data that is assumed to also follow the 
same Poisson distributions. The method is inherently conservative, so that with a nominal power of .77 the real power 
will be about .80, and a nominal power of .89 the real power will be about .90. Other values of nominal power are 
allowed, but only real powers of .80 or .90 are allowed. 
If mu0 and mu1 are the means from the two groups, 
the one-sided tests are designed to test either 
<code class="reqn">H_0: \mu_0 \leq \mu_1</code> vs. 
<code class="reqn">H_1: \mu_0 &gt; \mu_1</code> or to test 
<code class="reqn">H_0: \mu_0 \geq \mu_1</code> vs. 
<code class="reqn">H_1: \mu_0 &lt; \mu_1</code>. 
We estimate <code class="reqn">\mu_0</code> and <code class="reqn">\mu_1</code> with 
<code class="reqn">\hat{\mu}_0 = xbar0 + \frac{1}{2m_0} </code>
and 
<code class="reqn">\hat{\mu}_1 = xbar1 + \frac{1}{2m_1} </code>.
The choice of hypotheses is determined by the value of <code class="reqn">\hat{\mu}_0</code> 
and <code class="reqn">\hat{\mu}_1</code>; 
if <code class="reqn">\hat{\mu}_0 &gt; \hat{\mu}_1</code> then the former hypotheses are tested, otherwise the latter are.
See Fay, Halloran and Follmann (2007) for details. 
</p>


<h3>Value</h3>

<p>Object of class &quot;power.htest&quot;, a list of the arguments
(including the computed sample sizes) augmented with 'METHOD' and 'NOTE'
elements. The values 'n0' and 'n1' are the samples sizes for the two groups, rounded up to the nearest integer.
</p>


<h3>Note</h3>

 
<p>The function <code>ss.fromdata.pois</code> calls <code><a href="#topic+uniroot.integer">uniroot.integer</a></code>, a function written for this package that 
finds the nearest integer to the root. </p>


<h3>Author(s)</h3>

<p>Michael P. Fay</p>


<h3>References</h3>

<p> Fay, M.P., Halloran, M.E., and Follmann, D.A. (2007). 'Accounting for Variability in Sample Size Estimation with Applications to 
Nonadherence and Estimation of  Variance and Effect Size' Biometrics 63: 465-474. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+ss.fromdata.nvar">ss.fromdata.nvar</a></code>, 
<code><a href="#topic+ss.fromdata.neff">ss.fromdata.neff</a></code>,  
<code><a href="#topic+ss.nonadh">ss.nonadh</a></code>,  
<code><a href="#topic+uniroot.integer">uniroot.integer</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ss.fromdata.pois(1.65,.88,23,25)
</code></pre>

<hr>
<h2 id='ss.nonadh'>Find sample sizes accounting for nonadherence</h2><span id='topic+ss.nonadh'></span>

<h3>Description</h3>

<p>Calculate sample sizes needed for a two-sample difference in means test accounting for nonadherence 
(i.e., noncompliance) in a proportion of subjects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ss.nonadh(mu0 = NULL, mu1 = NULL, delta = NULL, sigma0.sq = 1, 
    rho0 = 0, rho1 = 0, ss.ratio = 1, var.ratio = 1, deltaB = 0, 
    sig.level = 0.05, power = 0.8, alternative = c("two.sided", "one.sided"), 
    refinement = NULL,error.fisher=10^-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ss.nonadh_+3A_mu0">mu0</code></td>
<td>
<p> mean of control group</p>
</td></tr>
<tr><td><code id="ss.nonadh_+3A_mu1">mu1</code></td>
<td>
<p>mean of treatment group</p>
</td></tr>
<tr><td><code id="ss.nonadh_+3A_delta">delta</code></td>
<td>
<p>mu0 - mu1 </p>
</td></tr>
<tr><td><code id="ss.nonadh_+3A_sigma0.sq">sigma0.sq</code></td>
<td>
<p>variance of control group</p>
</td></tr>
<tr><td><code id="ss.nonadh_+3A_rho0">rho0</code></td>
<td>
<p>probability that a subject randomized to control will switch to treatment</p>
</td></tr>
<tr><td><code id="ss.nonadh_+3A_rho1">rho1</code></td>
<td>
<p>probability that a subject randomized to treatment will switch to control 
(or respond like control subjects)</p>
</td></tr>
<tr><td><code id="ss.nonadh_+3A_ss.ratio">ss.ratio</code></td>
<td>
<p>n1/n0, where n0 (n1) is sample size of control (treatment) group for proposed study</p>
</td></tr>
<tr><td><code id="ss.nonadh_+3A_var.ratio">var.ratio</code></td>
<td>
<p><code class="reqn">\sigma_1^2/\sigma_0^2</code>, where <code class="reqn">\sigma_0</code> (<code class="reqn">\sigma_1</code>) is standard deviation of 
control (treatment) group for proposed study</p>
</td></tr>
<tr><td><code id="ss.nonadh_+3A_deltab">deltaB</code></td>
<td>
<p> boundary value between null and alternative hypotheses for one-sided tests (see details)</p>
</td></tr>
<tr><td><code id="ss.nonadh_+3A_sig.level">sig.level</code></td>
<td>
<p>significance level (Type I error)</p>
</td></tr>
<tr><td><code id="ss.nonadh_+3A_power">power</code></td>
<td>
<p> minimum power that you want the sample size to achieve</p>
</td></tr>
<tr><td><code id="ss.nonadh_+3A_alternative">alternative</code></td>
<td>
<p>One- or two-sided test</p>
</td></tr>
<tr><td><code id="ss.nonadh_+3A_refinement">refinement</code></td>
<td>
<p>More precise sample size estimates for certain types of responses, 
possible values: NULL (use asymptotic method), &lsquo;Normal&rsquo; or 'N','Bernoulli' or 'B',
and 'Fisher.exact' or 'F'.</p>
</td></tr>
<tr><td><code id="ss.nonadh_+3A_error.fisher">error.fisher</code></td>
<td>
<p>bound on the abolute error of the power calculations for the Fisher.exact refinement</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>Calculates the sample sizes for a study designed to test the difference between the means of two groups, 
where a proportion of those randomized to the control regimin switch to the treatment regimin (rho0) 
and a proportion of those randomized to the treatment regimin switch to the control regimin (rho1).
</p>
<p>You must supply either <code>mu0</code> and <code>mu1</code> or <code>delta</code>=mu0-mu1. 
The one-sided tests are designed to test either 
<code class="reqn">H_0: \delta \leq \delta_B</code> vs. 
<code class="reqn">H_1: \delta &gt; \delta_B</code> or to test 
<code class="reqn">H_0: \delta \geq \delta_B</code> vs. 
<code class="reqn">H_1: \delta &lt; \delta_B</code>.
The choice of hypotheses is determined by the value of <code>delta</code>; 
if <code>delta</code> <code class="reqn">&gt;</code> <code>deltaB</code> 
then the former hypotheses are tested, otherwise the latter are.
</p>
<p>The responses may be continuous, discrete, or even binary. 
The value <code>refinement</code> defines different methods related to the response type.
When refinement=NULL, the method is based on asymptotic normal approximation. 
For refinement='Normal' the method is based on the t-distribution derived when the responses are normal. 
For refinement='Bernoulli' the <code>sigma0.sq</code> and <code>var.ratio</code> values are defined by 
<code>mu0</code> and <code>mu1</code>, and the sample sizes do not use any continuity correction. 
For refinement='Fisher.exact' only the two-sided alternative is allowed and the sample size related to 
exact powers for the 2X2 Fisher exact test are calculated.  
</p>
<p>See Fay, Halloran and Follmann (2007) for details. 
</p>


<h3>Value</h3>

<p>Object of class &quot;power.htest&quot;, a list of the arguments
(including the computed sample sizes) augmented with 'METHOD' and 'NOTE'
elements. The values 'n0' and 'n1' are the samples sizes for the two groups, rounded up to the nearest integer.
</p>


<h3>Note</h3>

 
<p>If you have a two-sided hypotheses with binary data, then refinement='Fisher.exact' is 
more accurate than refinement='Bernoulli',  but it  takes  considerably longer to run. 
If 'Fisher.exact' is chosen the method uses the <code><a href="#topic+uniroot.integer">uniroot.integer</a></code> function, and 
if you &lsquo;Esc&rsquo; during the calculation, intermediate 
exact powers will print. 
</p>


<h3>Author(s)</h3>

<p>Michael P. Fay</p>


<h3>References</h3>

<p> Fay, M.P., Halloran, M.E., and Follmann, D.A. (2007). 'Accounting for Variability in Sample Size Estimation with Applications to 
Nonadherence and Estimation of  Variance and Effect Size' Biometrics 63: 465-474. </p>


<h3>See Also</h3>

 <p><code><a href="#topic+uniroot.integer">uniroot.integer</a></code>,
<code><a href="#topic+ss.fromdata.neff">ss.fromdata.neff</a></code>, 
<code><a href="#topic+ss.fromdata.pois">ss.fromdata.pois</a></code>,  
<code><a href="#topic+ss.fromdata.nvar">ss.fromdata.nvar</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Suppose treatment will not work on about 30 percent of subjects 
### then rho0=.3 and clinically significant difference in means is .5 
ss.nonadh(delta=.5,rho0=.3)

## Binary data, quick calculation
ss.nonadh(mu0=.1,mu1=.4,refinement="B")
# Calculate Fisher.exact before packaging, took about 8 seconds
#example.of.Fisher.exact&lt;-ss.nonadh(mu0=.1,mu1=.4,refinement="Fisher.exact")
data(example.of.Fisher.exact)
example.of.Fisher.exact

</code></pre>

<hr>
<h2 id='ssanv-package'>
Sample Size Adjusted for Nonadherence or Variability of Input Parameters</h2><span id='topic+ssanv-package'></span><span id='topic+ssanv'></span>

<h3>Description</h3>

<p>Calculate sample size for two sample difference in means tests. The function, 
<code>ss.nonadh</code> accounts for known proportions of nonadherence. There are three 
functions that calculate sample size accounting for the variability that comes from 
estimating parameters from data.  
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ssanv</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-06-22</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL3 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This package does adjustments for sample size calculations for two-sample difference in means tests. 
The function <code>ss.nonadh</code> adjusts for nonadherence, where the responses may be continuous, discrete, or binary.
There are 3 functions which account for variability of estimating parameters from data: 
<code>ss.fromdata.nvar</code>&ndash; accouts for variability of standard deviation estimate when data are normal 
and the clincially significant difference is known,
<code>ss.fromdata.neff</code>&ndash; accounts for variability of estimated standardized difference in means when both groups 
come from normal distributions with the same variance,
<code>ss.fromdata.pois</code>&ndash; accounts for variability of means when both means are estimated from data assumed Poisson. 
</p>


<h3>Author(s)</h3>

<p>Michael Fay &lt;mfay@niaid.nih.gov&gt;
</p>
<p>Maintainer: Michael Fay &lt;mfay@niaid.nih.gov&gt;
</p>


<h3>References</h3>

<p> Fay, M.P., Halloran, M.E., and Follmann, D.A. (2007). 'Accounting for Variability in Sample Size Estimation with Applications to 
Nonadherence and Estimation of  Variance and Effect Size' Biometrics 63: 465-474. </p>


<h3>Examples</h3>

<pre><code class='language-R'>### Suppose treatment will not work on about 30 percent of subjects 
### then rho0=.3 and clinically significant difference in means is .5 
ss.nonadh(delta=.5,rho0=.3)

### Suppose you estimate standard deviation of .32 from a sample of size 12
### and the clinically significant difference is .2
ss.fromdata.nvar(delta=.2,sdhat=.32,df=11)
### The usual method is to assume that the standard deviation is known 
### this result is the same as df=Inf
ss.fromdata.nvar(delta=.2,sdhat=.32,df=Inf)
</code></pre>

<hr>
<h2 id='uniroot.integer'>Find the root of a function to the nearest integer</h2><span id='topic+uniroot.integer'></span>

<h3>Description</h3>

<p>Let f be a monotonic function that changes sign within the interval specified. If f(i)=0 for some i within the interval specified (including the ends of the interval), then the root is i. Otherwise  if <code>pos.side</code>=TRUE (or FALSE) then <code>uniroot.integer</code> finds the integer i such that 
f(i) is closest to the sign change and is positive (or negative). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniroot.integer(f, interval, lower = min(interval), upper = max(interval), 
    step.power = 6, step.up = TRUE, pos.side = FALSE, print.steps = FALSE, 
    maxiter = 1000, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uniroot.integer_+3A_f">f</code></td>
<td>
<p> function for which a root is needed </p>
</td></tr>
<tr><td><code id="uniroot.integer_+3A_interval">interval</code></td>
<td>
<p>an interval giving minimum and maximum allowable values for root</p>
</td></tr>
<tr><td><code id="uniroot.integer_+3A_lower">lower</code></td>
<td>
<p>minimum allowable root</p>
</td></tr>
<tr><td><code id="uniroot.integer_+3A_upper">upper</code></td>
<td>
<p>maximum allowable root</p>
</td></tr>
<tr><td><code id="uniroot.integer_+3A_step.power">step.power</code></td>
<td>
<p>initial step size is <code class="reqn">2^{step.power}</code></p>
</td></tr>
<tr><td><code id="uniroot.integer_+3A_step.up">step.up</code></td>
<td>
<p>if TRUE steps up from 'lower', if FALSE steps down from 'upper'</p>
</td></tr>
<tr><td><code id="uniroot.integer_+3A_pos.side">pos.side</code></td>
<td>
<p>if TRUE finds integer, i, closest to the root such that f(i) <code class="reqn">&gt;</code> zero</p>
</td></tr>
<tr><td><code id="uniroot.integer_+3A_print.steps">print.steps</code></td>
<td>
<p>if TRUE, prints iterations</p>
</td></tr>
<tr><td><code id="uniroot.integer_+3A_maxiter">maxiter</code></td>
<td>
<p> maximum number of iterations </p>
</td></tr>
<tr><td><code id="uniroot.integer_+3A_...">...</code></td>
<td>
<p>additional arguments to 'f'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm evaluates f(i) iteratively, increasing (or decreasing if step.up=FALSE) 
i by <code class="reqn">2^{step.power}</code> until either f(i)=0 or f(i) switches sign.
If f(i)=0, then stop. If f(i) switches sign, then the change in  'i' is halved each iteration until convergence. 
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>
<table>
<tr><td><code>root</code></td>
<td>
<p>the integer on the correct side of the root</p>
</td></tr>
<tr><td><code>f.root</code></td>
<td>
<p>value of f at root</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>number of times f was evaluated</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Unlike <code><a href="stats.html#topic+uniroot">uniroot</a></code>, the function is not automatically evaluated at both extremes. This makes 
<code>uniroot.integer</code> an efficient method to use when the calculation time of f(i) 
increases with the value of 'i'. For an example of the importance of this see 
<code><a href="#topic+ss.fromdata.pois">ss.fromdata.pois</a></code>. </p>


<h3>Author(s)</h3>

<p>Michael P. Fay</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+uniroot">uniroot</a></code>, used by <code><a href="#topic+ss.fromdata.neff">ss.fromdata.neff</a></code>, <code><a href="#topic+ss.fromdata.pois">ss.fromdata.pois</a></code>,
<code><a href="#topic+ss.nonadh">ss.nonadh</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>root.func&lt;-function(i) i - 500.1 
## initial step sizes = 2^2 =4
uniroot.integer(root.func,c(0,Inf),step.power=2)
## more efficient to use bigger initial step sizes = 2^10 =1024
uniroot.integer(root.func,c(0,Inf),step.power=10,print.steps=TRUE)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
