<!DOCTYPE html><html><head><title>Help for package mi</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mi}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#00mi-package'><p>Iterative Multiple Imputation from Conditional Distributions</p></a></li>
<li><a href='#01missing_variable'><p>Class &quot;missing_variable&quot; and Inherited Classes</p></a></li>
<li><a href='#02missing_data.frame'><p>Class &quot;missing_data.frame&quot;</p></a></li>
<li><a href='#03change'><p>Make Changes to Discretionary Characteristics of Missing Variables</p></a></li>
<li><a href='#04mi'><p>Multiple Imputation</p></a></li>
<li><a href='#05Rhats'><p>Convergence Diagnostics</p></a></li>
<li><a href='#06pool'><p>Estimate a Model Pooling Over the Imputed Datasets</p></a></li>
<li><a href='#07complete'><p>Extract the Completed Data</p></a></li>
<li><a href='#allcategorical_missing_data.frame'><p>Class &quot;allcategorical_missing_data.frame&quot;</p></a></li>
<li><a href='#bounded-continuous-class'><p>Class &quot;bounded-continuous&quot;</p></a></li>
<li><a href='#categorical'><p>Class &quot;categorical&quot; and Inherited Classes</p></a></li>
<li><a href='#censored-continuous-class'><p>The &quot;censored-continuous&quot; Class, the &quot;truncated-continuous&quot; Class and Inherited Classes</p></a></li>
<li><a href='#CHAIN'>
<p>Subset of variables from the CHAIN project</p></a></li>
<li><a href='#continuous'><p>Class &quot;continuous&quot;</p></a></li>
<li><a href='#count-class'><p>Class &quot;count&quot;</p></a></li>
<li><a href='#experiment_missing_data.frame'><p>Class &quot;experiment_missing_data.frame&quot;</p></a></li>
<li><a href='#fit_model'><p>Wrappers To Fit a Model</p></a></li>
<li><a href='#get_parameters'><p>An Extractor Function for Model Parameters</p></a></li>
<li><a href='#hist'><p>Histograms of Multiply Imputed Data</p></a></li>
<li><a href='#irrelevant'><p>Class &quot;irrelevant&quot; and Inherited Classes</p></a></li>
<li><a href='#mi-internal'><p>Internal Functions and Methods</p></a></li>
<li><a href='#mi2stata'><p>Exports completed data in Stata (.dta) or comma-separated (.csv) format</p></a></li>
<li><a href='#mipply'><p>Apply a Function to a Object of Class mi</p></a></li>
<li><a href='#multilevel_missing_data.frame'><p>Class &quot;multilevel_missing_data.frame&quot;</p></a></li>
<li><a href='#multinomial'><p>The multinomial family</p></a></li>
<li><a href='#nlsyV'>
<p>National Longitudinal Survey of Youth Extract</p></a></li>
<li><a href='#positive-continuous-class'><p>Class &quot;positive-continuous&quot; and Inherited Classes</p></a></li>
<li><a href='#rdata.frame'><p>Generate a random data.frame with tunable characteristics</p></a></li>
<li><a href='#semi-continuous-class'><p>Class &quot;semi-continuous&quot; and Inherited Classes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Missing Data Imputation and Model Checking</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-05</td>
</tr>
<tr>
<td>Description:</td>
<td>The mi package provides functions for data manipulation, imputing missing values in an approximate Bayesian framework, diagnostics of the models used to generate the imputations, confidence-building mechanisms to validate some of the assumptions of the imputation algorithm, and functions to analyze multiply imputed data sets with the appropriate degree of sampling uncertainty.</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), methods, Matrix, stats4</td>
</tr>
<tr>
<td>Imports:</td>
<td>arm (&ge; 1.4-11)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>betareg, lattice, knitr, MASS, nnet, parallel, sn, survival,
truncnorm, foreign</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.stat.columbia.edu/~gelman/">http://www.stat.columbia.edu/~gelman/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Gelman [ctb],
  Jennifer Hill [ctb],
  Yu-Sung Su [aut],
  Masanao Yajima [ctb],
  Maria Pittau [ctb],
  Ben Goodrich [cre, aut],
  Yajuan Si [ctb],
  Jon Kropko [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ben Goodrich &lt;benjamin.goodrich@columbia.edu&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-05 05:31:15 UTC; ben</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-06 20:10:04 UTC</td>
</tr>
</table>
<hr>
<h2 id='00mi-package'>Iterative Multiple Imputation from Conditional Distributions
</h2><span id='topic+mi-package'></span>

<h3>Description</h3>

<p>The mi package performs multiple imputation for data with missing values.  The algorithm iteratively draws imputed values from the conditional distribution for each variable given the observed and imputed values of the other variables in the data. The process approximates a Bayesian framework; multiple chains are run and convergence is assessed after a pre-specified number of iterations within each chain.  The package allows customization of the conditional model and the treatment of missing values for each variable.  In addition, the package provides graphics to visualize missing data patterns, to diagnose the models used to generate the imputations, and to assess convergence. Functions are included to run statistical models post-imputation with the appropriate degree of sampling uncertainty.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> mi</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> Sun Jun  5 01:30:56 2022 </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2) </td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>See the vignette for an example of typical usage.
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions 
written by Yu-Sung Su, Masanao Yajima,Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missing_data.frame">missing_data.frame</a></code>, <code><a href="#topic+change">change</a></code>, <code><a href="#topic+mi">mi</a></code>, <code><a href="#topic+Rhats">Rhats</a></code>, 
<code><a href="#topic+pool">pool</a></code>, <code><a href="#topic+complete">complete</a></code>
</p>

<hr>
<h2 id='01missing_variable'>Class &quot;missing_variable&quot; and Inherited Classes</h2><span id='topic+01missing_variable'></span><span id='topic+missing_variable'></span><span id='topic+missing_variable-class'></span><span id='topic+MatrixTypeThing-class'></span><span id='topic+WeAreFamily-class'></span>

<h3>Description</h3>

<p>The missing_variable class is essentially the data comprising a variable plus all
the metadata needed to understand how its missing values will be imputed. However, no variable is
merely of missing_variable class; rather every variable is of a class that inherits from the 
missing_variable class. Even if a variable has no missing values, it needs to be coerced to a class 
that inherits from the missing_variable class before it can be used to impute values of other 
missing_variables. Understanding the properties of different subclasses of the missing_variable class 
is essential for modeling and imputing them. The <code><a href="#topic+missing_data.frame-class">missing_data.frame-class</a></code> is essentially
a list of objects that inherit from the missing_variable class, plus metadata need to understand how
these missing_variables relate to each other.  Most users will never need to call <code>missing_variable</code> directly since it is called by <code><a href="#topic+missing_data.frame">missing_data.frame</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_variable(y, type, ...)
## Hidden arugments not included in the signature:
## favor_ordered = TRUE, favor_positive = FALSE, 
## variable_name = deparse(substitute(y))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="01missing_variable_+3A_y">y</code></td>
<td>
<p>Can be any vector, some of whose values may be <code><a href="base.html#topic+NA">NA</a></code>, which will
comprise the <b>raw_data</b> slot of a missing_variable (see the Slots section). It is 
recommended that this vector <em>not</em> have any transformations, such as a log-transformation. 
Any continuous variable can be transformed using the function in its <b>transformation</b> slot. 
The transformations and other discretionary aspects of a missing_variable are typically changed
by calling the <code><a href="#topic+change">change</a></code> function on a <code><a href="#topic+missing_data.frame">missing_data.frame</a></code> 
See the Slots section for more details.
</p>
</td></tr>
<tr><td><code id="01missing_variable_+3A_type">type</code></td>
<td>
<p>Missing or a character string among the classes that inherit from the missing_variable
class. If missing, the constructor will guess (sometimes incorrectly) based on the characteristics 
of the variable. The best way to improve the guessing of categorical variables is to 
use the <code><a href="base.html#topic+factor">factor</a></code> function &mdash; possibly with <code>ordered = TRUE</code> &mdash; to create
(possibly ordered) factors that will correctly be coerced to objects of 
<code><a href="#topic+unordered-categorical-class">unordered-categorical-class</a></code> and <code><a href="#topic+ordered-categorical-class">ordered-categorical-class</a></code> respectively. 
If you fail to do so, the hidden arguments that are not included in the signature affect the guesses. 
If <code>favor_ordered = TRUE</code>, which is the default, it will tend to guess that variables with few 
unique values are should be coerced to <code><a href="#topic+ordered-categorical-class">ordered-categorical-class</a></code> and 
<code><a href="#topic+unordered-categorical-class">unordered-categorical-class</a></code> otherwise. If <code>favor_positive = FALSE</code>, which is the 
default, it will tend to guess that variables with many unique values are merely continuous, whether 
or not all the observed values are positive. If <code>favor_positive = TRUE</code> nonnegative or positive
variables will get coerced to
<code><a href="#topic+nonnegative-continuous-class">nonnegative-continuous-class</a></code> or <code><a href="#topic+positive-continuous-class">positive-continuous-class</a></code>. See the Slots
section and the specific help pages for more details on the subclasses.
</p>
</td></tr>
<tr><td><code id="01missing_variable_+3A_...">...</code></td>
<td>
<p>Further hidden arguments that are not in the signature. The <code>favor_ordered</code> and
<code>favor_positive</code> arguments are documented immediately above. The <code>variable</code> name argument
can be used to control what gets put in the <b>variable_name</b> slot, see the Slots section below.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The missing_variable function returns an object that inherits from the missing_variable class.
</p>


<h3>Objects from the Classes</h3>

<p>The missing_variable class is virtual, so no objects 
may be created from it. However, the missing_variable generic function can be used to 
instantiate an object that inherits from the missing_variable class by specifying its 
<code>type</code> argument. A user would call the <code><a href="#topic+missing_data.frame">missing_data.frame</a></code>
function on a <code><a href="base.html#topic+data.frame">data.frame</a></code>, which in turn calls the missing_variable function
on each column of the <code><a href="base.html#topic+data.frame">data.frame</a></code> using various heuristics to guess the
<code>type</code> argument.
</p>


<h3>Slots</h3>

<p>In the following table, indentation indicates inheritance from the class with less indentation, and
italics indicates that the class is virtual so no variables can be created with that class. Inherited
classes inherit the transformations, families, link functions, and <code><a href="#topic+fit_model-methods">fit_model-methods</a></code>
from their parent class, although these are often superceeded by analogues that are tailored for the
inherited class. Also note, the default transformation for the continuous class is a standardization 
using <em>twice</em> the standard deviation of the observed values.
</p>
<p>The distinction between the transformation entailed by the <code><a href="stats.html#topic+family">family</a></code> and the transformation
entailed by the function in the <b>tranformation</b> slot may be confusing at this point. The former pertains
to how the linear predictor of a variable is mapped to the space of a variable when it is on the left-hand
side of a generalized linear model. The latter pertains &mdash; for continuous variables only &mdash; to how the
values in the <b>raw_data</b> slot are mapped into those in the <b>data</b> and thus affects how a continuous 
variable enters into the model whether it is on the left or right-hand side. The classes are discussed in 
much more detail below.
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>Class name [transformation]</b>   </td><td style="text-align: left;"> <b>Default family and link</b> </td><td style="text-align: left;"> <b>Default <code><a href="#topic+fit_model">fit_model</a></code></b> </td>
</tr>
<tr>
 <td style="text-align: left;">
    <em>missing_variable</em>            </td><td style="text-align: left;"> none                  </td><td style="text-align: left;"> throws error </td>
</tr>
<tr>
 <td style="text-align: left;">
     <em>categorical</em>                  </td><td style="text-align: left;"> none        </td><td style="text-align: left;"> throws error </td>
</tr>
<tr>
 <td style="text-align: left;">
      unordered-categorical         </td><td style="text-align: left;"> <code>binomial(link = 'logit')</code> </td><td style="text-align: left;"> <code><a href="nnet.html#topic+multinom">multinom</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
      ordered-categorical           </td><td style="text-align: left;"> <code>binomial(link = 'logit')</code> </td><td style="text-align: left;"> <code><a href="arm.html#topic+bayespolr">bayespolr</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
       binary              </td><td style="text-align: left;"> <code>binomial(link = 'logit')</code> </td><td style="text-align: left;"> <code><a href="arm.html#topic+bayesglm">bayesglm</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
       interval            </td><td style="text-align: left;"> <code>gaussian{link = 'identity'}</code> </td><td style="text-align: left;"> <code><a href="survival.html#topic+survreg">survreg</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
     continuous[standardize]                 </td><td style="text-align: left;"> <code>gaussian{link = 'identity'}</code> </td><td style="text-align: left;"> <code><a href="arm.html#topic+bayesglm">bayesglm</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
      semi-continuous[identity]     </td><td style="text-align: left;">                                     </td><td style="text-align: left;">                             </td>
</tr>
<tr>
 <td style="text-align: left;">
       nonnegative-continuous[logshift] </td><td style="text-align: left;">                     </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
        SC_proportion[squeeze] </td><td style="text-align: left;">  <code>binomial(link = 'logit')</code> </td><td style="text-align: left;"> <code><a href="betareg.html#topic+betareg">betareg</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
      positive-continuous[<code><a href="base.html#topic+log">log</a></code>]           </td><td style="text-align: left;">                    </td><td style="text-align: left;">                              </td>
</tr>
<tr>
 <td style="text-align: left;">
       proportion[identity] </td><td style="text-align: left;">              <code>binomial(link = 'logit')</code> </td><td style="text-align: left;"> <code><a href="betareg.html#topic+betareg">betareg</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
      bounded-continuous[identity]  </td><td style="text-align: left;"> </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
     count                           </td><td style="text-align: left;"> <code>quasipoisson{link = 'log'}</code>     </td><td style="text-align: left;">      <code><a href="arm.html#topic+bayesglm">bayesglm</a></code>    </td>
</tr>
<tr>
 <td style="text-align: left;">
     irrelevant                      </td><td style="text-align: left;">                                       </td><td style="text-align: left;">      throws error                   </td>
</tr>
<tr>
 <td style="text-align: left;">
      fixed                 </td><td style="text-align: left;">                               </td><td style="text-align: left;">      throws error                   </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>The missing_variable class is virtual and has the following slots (this information is primarily directed at developeRs):
</p>

<dl>
<dt><code>variable_name</code>:</dt><dd><p>Object of class <code><a href="base.html#topic+character">character</a></code> of length one naming the variable</p>
</dd>
<dt><code>raw_data</code>:</dt><dd><p>Object of class <code>"ANY"</code> representing the observations
on a variable, some of which may be <code><a href="base.html#topic+NA">NA</a></code>. No method should ever change 
this slot at all. Instead, methods should change the <b>data</b> slot.</p>
</dd>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"ANY"</code>, which is initially a copy of the
<b>raw_data</b> slot &mdash; transformed by the function in the <b>transformation</b> slot 
for continuous variables only &mdash; and whose <code><a href="base.html#topic+NA">NA</a></code> values are replaced during
the multiple imputation process. See <code><a href="#topic+mi">mi</a></code></p>
</dd>
<dt><code>n_total</code>:</dt><dd><p>Object of class <code>"integer"</code> which is the <code><a href="base.html#topic+length">length</a></code>
of the <b>data</b> slot</p>
</dd>
<dt><code>all_obs</code>:</dt><dd><p>Object of class <code>"logical"</code> of length one indicating whether
all values of the <b>data</b> slot are observed and thus not <code><a href="base.html#topic+NA">NA</a></code> </p>
</dd>
<dt><code>n_obs</code>:</dt><dd><p>Object of class <code>"integer"</code> of length one indicating the number
of values of the <b>data</b> slot that are observed and thus not <code><a href="base.html#topic+NA">NA</a></code> </p>
</dd>
<dt><code>which_obs</code>:</dt><dd><p>Object of class <code>"integer"</code>, which is a vector indicating 
the positions of the observed values in the <b>data</b> slot</p>
</dd>
<dt><code>all_miss</code>:</dt><dd><p>Object of class <code>"logical"</code> of length one indicating whether
all values of the <b>data</b> slot are <code><a href="base.html#topic+NA">NA</a></code> </p>
</dd>
<dt><code>n_miss</code>:</dt><dd><p>Object of class <code>"integer"</code> of length one indicating the number
of values of the <b>data</b> slot that are <code><a href="base.html#topic+NA">NA</a></code> </p>
</dd>
<dt><code>which_miss</code>:</dt><dd><p>Object of class <code>"integer"</code>, which is a vector indicating
the positions of the missing values in the <b>data</b> slot </p>
</dd>
<dt><code>n_extra</code>:</dt><dd><p>Object of class <code>"integer"</code> of length one indicating how many
(missing) observations have been added to the end of the <b>data</b> slot that are not
included in the <b>raw_data</b> slot. Although the extra values will be imputed, they
are not considered to be &ldquo;missing&rdquo; for the purposes of defining the previous
three slots</p>
</dd>
<dt><code>which_extra</code>:</dt><dd><p>Object of class <code>"integer"</code>, which is a vector indicating
the positions of the extra values at the end of the <b>data</b> slot </p>
</dd>
<dt><code>n_unpossible</code>:</dt><dd><p>Object of class <code>"integer"</code> of length one indicating the
number of values that are logically or structurally unobservable</p>
</dd>
<dt><code>which_unpossible</code>:</dt><dd><p>Object of class <code>"integer"</code> indicating the positions
of the unpossible values in the <b>data</b> slot </p>
</dd> 
<dt><code>n_drawn</code>:</dt><dd><p>Object of class <code>"integer"</code> of length one which is the sum of
the <b>n_miss</b> and <b>n_extra</b> slots</p>
</dd>
<dt><code>which_drawn</code>:</dt><dd><p>Object of class <code>"integer"</code> which is a vector concatinating
the <b>which_miss</b> and <b>which_extra</b> slots </p>
</dd>
<dt><code>imputation_method</code>:</dt><dd><p>Object of class <code>"character"</code> of length one indicating
how the <code><a href="base.html#topic+NA">NA</a></code> values are to be imputed. Possibilities include &ldquo;ppd&rdquo; for
imputation from the posterior predictive distribution, &ldquo;pmm&rdquo; for imputation via
predictive mean matching, &ldquo;mean&rdquo; for mean-imputation, &ldquo;median&rdquo; for 
median-imputation, &ldquo;expectation&rdquo; for conditional mean-imputation. With enough
programming effort, other kinds of imputation can be defined and specified here.</p>
</dd>
<dt><code>family</code>:</dt><dd><p>Object of class <code>"WeAreFamily"</code> that will typically be passed to 
<code><a href="stats.html#topic+glm">glm</a></code> and similar functions during the multiple imputation process</p>
</dd>
<dt><code>known_families</code>:</dt><dd><p>Object of class <code><a href="base.html#topic+character">character</a></code> indicating the families
that are known to be supported for a class; see <code><a href="stats.html#topic+family">family</a></code></p>
</dd>
<dt><code>known_links</code>:</dt><dd><p>Object of class <code><a href="base.html#topic+character">character</a></code> indicating what link functions
are known to be supported by the elements of the <b>known_families</b> slot; see 
<code><a href="stats.html#topic+family">family</a></code></p>
</dd>
<dt><code>imputations</code>:</dt><dd><p>Object of class <code>"MatrixTypeThing"</code> with rows equal to the number
of iterations (initially zero) of the multiple imputation algorithm and columns equal to the 
<b>n_drawn</b> slot. The rows are appropriately extended and then filled by the 
<code><a href="#topic+mi">mi</a></code> function</p>
</dd>
<dt><code>done</code>:</dt><dd><p>Object of class <code>"logical"</code> of length one indicating whether the
<code><a href="base.html#topic+NA">NA</a></code> values in the <b>data</b> slot have been replaced by imputed values</p>
</dd>
<dt><code>parameters</code>:</dt><dd><p>Object of class <code>"MatrixTypeThing"</code> with rows equal to the number
of iterations (initially zero) of the multiple imputation algorithm and columns equal to the number 
of estimated parameters when modeling the <b>data</b> slot. The rows are appropriately extended
and then filled by the <code><a href="#topic+mi">mi</a></code> function</p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"ANY"</code> which can be filled by an object that is output
by one of the <code><a href="#topic+fit_model-methods">fit_model-methods</a></code>, which is done by default by <code><a href="#topic+mi">mi</a></code>
when all the iterations have completed</p>
</dd>
<dt><code>fitted</code>:</dt><dd><p>Object of class <code>"ANY"</code> although typically a vector or matrix that 
contains the fitted values of the model in the slot immediately above. Note that the
<b>fitted</b> slot is filled by default by <code><a href="#topic+mi">mi</a></code>, although the <b>model</b> slot
is left empty by default to save RAM.</p>
</dd>
<dt><code>estimator</code>:</dt><dd><p>Object of class <code>"character"</code> of length one indicating which pre-existing 
<code><a href="#topic+fit_model">fit_model</a></code> to use for an unordered-categorical variable.  Options are <code>"mnl"</code>, in which 
<code><a href="nnet.html#topic+multinom">multinom</a></code> from the <span class="pkg">nnet</span> package is used to fit the values of the unordered 
categorical variable; and <code>"rnl"</code>, in which each category is separately modeled as the positive 
binary outcome against all other categories using a <code><a href="arm.html#topic+bayesglm">bayesglm</a></code> <code>fit_model</code> and 
the probabilities of each category are normalized to sum to 1 after each model is run. In general, 
<code>"rnl"</code> is slightly less accurate than <code>"mnl"</code>, but runs much more quickly especially when 
the unordered categorical variable has many unique categories.</p>
</dd>
</dl>

<p>The WeAreFamily class is a class union of <code><a href="base.html#topic+character">character</a></code> and <code><a href="stats.html#topic+family">family</a></code>, while the
MatrixTypeThing class is a class union of <code><a href="base.html#topic+matrix">matrix</a></code> only at the moment.
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missing_data.frame">missing_data.frame</a></code>, <code><a href="#topic+categorical-class">categorical-class</a></code>,  <code><a href="#topic+unordered-categorical-class">unordered-categorical-class</a></code>, 
<code><a href="#topic+ordered-categorical-class">ordered-categorical-class</a></code>, <code><a href="#topic+binary-class">binary-class</a></code>, <code><a href="#topic+interval-class">interval-class</a></code>, 
<code><a href="#topic+continuous-class">continuous-class</a></code>, <code><a href="#topic+semi-continuous-class">semi-continuous-class</a></code>, <code><a href="#topic+nonnegative-continuous-class">nonnegative-continuous-class</a></code>,
<code><a href="#topic+SC_proportion-class">SC_proportion-class</a></code>, <code><a href="#topic+censored-continuous-class">censored-continuous-class</a></code>, 
<code><a href="#topic+truncated-continuous-class">truncated-continuous-class</a></code>, <code><a href="#topic+bounded-continuous-class">bounded-continuous-class</a></code>, 
<code><a href="#topic+positive-continuous-class">positive-continuous-class</a></code>, <code><a href="#topic+proportion-class">proportion-class</a></code>, <code><a href="#topic+count-class">count-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># STEP 0: GET DATA
data(nlsyV, package = "mi")

# STEP 0.5 CREATE A missing_variable (you never need to actually do this)
income &lt;- missing_variable(nlsyV$income, type = "continuous")
show(income)

# STEP 1: CONVERT IT TO A missing_data.frame
mdf &lt;- missing_data.frame(nlsyV) # this calls missing_variable() internally
show(mdf)
</code></pre>

<hr>
<h2 id='02missing_data.frame'>Class &quot;missing_data.frame&quot;</h2><span id='topic+02missing_data.frame'></span><span id='topic+missing_data.frame-class'></span><span id='topic+missing_data.frame'></span>

<h3>Description</h3>

<p>This class is similar to a <code><a href="base.html#topic+data.frame">data.frame</a></code> but is customized for the situation in 
which variables with missing data are being modeled for multiple imputation. This class primarily 
consists of a list of <code><a href="#topic+missing_variable">missing_variable</a></code>s plus slots containing metadata indicating how the
<code><a href="#topic+missing_variable">missing_variable</a></code>s relate to each other. Most operations that work for a
<code><a href="base.html#topic+data.frame">data.frame</a></code> also work for a missing_data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>missing_data.frame(y, ...)
## Hidden arguments not included in the signature
## favor_ordered = TRUE, favor_positive = FALSE, 
## subclass = NA_character_,
## include_missingness = TRUE, skip_correlation_check = FALSE
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="02missing_data.frame_+3A_y">y</code></td>
<td>
<p>Usually a <code><a href="base.html#topic+data.frame">data.frame</a></code>, possibly a numeric matrix, 
possibly a list of <code><a href="#topic+missing_variable">missing_variable</a></code>s.</p>
</td></tr>
<tr><td><code id="02missing_data.frame_+3A_...">...</code></td>
<td>
<p>Hidden arguments. The <code>favor_ordered</code> and <code>favor_positive</code>
arguments are passed to the <code><a href="#topic+missing_variable">missing_variable</a></code> function and are 
documented under the <code>type</code> argument. Briefly, they affect the heuristics
that are used to guess what class a variable should be coerced to. The 
<code>subclass</code> argument defaults to <code><a href="base.html#topic+NA">NA</a></code> and can be used to specify
that the resulting object should inherit from the missing_data.frame class
rather than be an object of <code>missing_data.frame</code> class.
</p>
<p>Any further arguments are passed to the <code><a href="methods.html#topic+initialize-methods">initialize-methods</a></code> for
a missing_data.frame. They currently are <code>include_missingness</code>, which 
defaults to <code>TRUE</code> and indicates that the missingness pattern of the other
variables should be included when modeling a particular <code><a href="#topic+missing_variable">missing_variable</a></code>, 
and <code>skip_correlation_check</code>, which defaults to FALSE and indicates whether
to skip the default check for whether the observed values of each pair of <code><a href="#topic+missing_variable">missing_variable</a></code>s 
has a perfect absolute Spearman <code><a href="stats.html#topic+cor">cor</a></code>relation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In most cases, the first step of an analysis is for a useR to call the 
<code>missing_data.frame</code> function on a <code><a href="base.html#topic+data.frame">data.frame</a></code> whose variables
have some <code><a href="base.html#topic+NA">NA</a></code> values, which will call the <code><a href="#topic+missing_variable">missing_variable</a></code>
function on each column of the <code><a href="base.html#topic+data.frame">data.frame</a></code> and return the <code><a href="base.html#topic+list">list</a></code>
that fills the <b>variable</b> slot. The classes of the list elements will depend on the
nature of the column of the <code><a href="base.html#topic+data.frame">data.frame</a></code> and various fallible heuristics. The
success rate can be enhanced by making sure that columns of the original 
<code><a href="base.html#topic+data.frame">data.frame</a></code> that are intended to be categorical variables are 
(ordered if appropriate) <code><a href="base.html#topic+factor">factor</a></code>s with labels. Even in the best case
scenario, it will often be necessary to utlize the <code><a href="#topic+change">change</a></code> function to 
modify various discretionary aspects of the <code><a href="#topic+missing_variable">missing_variable</a></code>s in the 
<b>variables</b> slot of the missing_data.frame. The <code><a href="methods.html#topic+show">show</a></code> method for
a missing_data.frame should be utilized to get a quick overview of the 
<code><a href="#topic+missing_variable">missing_variable</a></code>s in a missing_data.frame and recognized what needs
to be <code><a href="#topic+change">change</a></code>d.
</p>


<h3>Value</h3>

<p>The <code>missing_data.frame</code> constructor function returns an object of class <code>missing_data.frame</code> 
or that inherits from the <code>missing_data.frame</code> class.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("missing_data.frame", ...)</code>.
However, useRs almost always will pass a <code><a href="base.html#topic+data.frame">data.frame</a></code> to the 
missing_data.frame constructor function to produce an object of missing_data.frame class.
</p>


<h3>Slots</h3>

<p>This section is primarily aimed at developeRs. A missing_data.frame inherits from
<code><a href="base.html#topic+data.frame">data.frame</a></code> but has the following additional slots:
</p>

<dl>
<dt><code>variables</code>:</dt><dd><p>Object of class <code>"list"</code> and each list element
is an object that inherits from the <code><a href="#topic+missing_variable-class">missing_variable-class</a></code> </p>
</dd>
<dt><code>no_missing</code>:</dt><dd><p>Object of class <code>"logical"</code>, which is a vector
whose length is the same as the length of the <b>variables</b> slot indicating 
whether the corresponding <code><a href="#topic+missing_variable">missing_variable</a></code> is fully observed </p>
</dd>
<dt><code>patterns</code>:</dt><dd><p>Object of class <code><a href="base.html#topic+factor">factor</a></code> whose length is equal
to the number of observation and whose elements indicate the missingness pattern
for that observation</p>
</dd>
<dt><code>DIM</code>:</dt><dd><p>Object of class <code>"integer"</code> of length two indicating
first the number of observations and second the length of the <b>variables</b>
slot </p>
</dd>
<dt><code>DIMNAMES</code>:</dt><dd><p>Object of class <code>"list"</code> of length two providing
the appropriate number rownames and column names </p>
</dd>
<dt><code>postprocess</code>:</dt><dd><p>Object of class <code>"function"</code> used to create
additional variables from existing variables, such as interactions between
two <code><a href="#topic+missing_variable">missing_variable</a></code>s once their missing values have been
imputed. Does not work at the moment</p>
</dd>
<dt><code>index</code>:</dt><dd><p>Object of class <code>"list"</code> whose length is equal to 
the number of <code><a href="#topic+missing_variable">missing_variable</a></code>s with some missing values. Each
list element is an integer vector indicating which columns of the <b>X</b>
slot must be dropped when modeling the corresponding <code><a href="#topic+missing_variable">missing_variable</a></code> </p>
</dd>
<dt><code>X</code>:</dt><dd><p>Object of <code><a href="#topic+MatrixTypeThing-class">MatrixTypeThing-class</a></code> with rows equal to the
number of observations and is loosely related to a <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>. Rather 
than repeatedly parsing a <code><a href="stats.html#topic+formula">formula</a></code> during the multiple imputation process,
this <b>X</b> matrix is created once and some of its columns are dropped when
modeling a <code><a href="#topic+missing_variable">missing_variable</a></code> utilizing the <b>index</b> slot.
The columns of the <b>X</b> matrix consists of numeric representations of the 
<code><a href="#topic+missing_variable">missing_variable</a></code>s plus (by default) the unique missingness patterns </p>
</dd>
<dt><code>weights</code>:</dt><dd><p>Object of class <code>"list"</code> whose length is equal to one
or the number of <code><a href="#topic+missing_variable">missing_variable</a></code>s with some missing values. Each 
list element is passed to the corresponding argument of <code>bayesglm</code> 
and similar functions. In particular, some observations can be given a weight
of zero, which should drop them when modeling some <code><a href="#topic+missing_variable">missing_variable</a></code>s</p>
</dd>
<dt><code>priors</code>:</dt><dd><p>Object of class <code>"list"</code> whose length is equal to the number
of <code><a href="#topic+missing_variable">missing_variable</a></code>s and whose elements give appropriate values for
the priors used by the model fitting function wraped by the <code><a href="#topic+fit_model-methods">fit_model-methods</a></code>; 
see, e.g., <code><a href="arm.html#topic+bayesglm">bayesglm</a></code></p>
</dd>
<dt><code>correlations</code>:</dt><dd><p>Object of class <code>"matrix"</code> with rows and
columns equal to the length of the <b>variables</b> slot. Its strict upper
triangle contains Spearman <code><a href="stats.html#topic+cor">cor</a></code>relations between pairs of
variables (ignoring missing values), and its strict lower triangle contains
Squared Multiple Correlations (SMCs) between a variable and all other
variables (ignoring missing values). If either a Spearman correlation or
a SMC is very close to unity, there may be difficulty or error messages
during the multiple imputation process.</p>
</dd>
<dt><code>done</code>:</dt><dd><p>Object of class <code>"logical"</code> of length one indicating
whether the missing values have been imputed</p>
</dd>
<dt><code>workpath</code>:</dt><dd><p>Object of class <code><a href="base.html#topic+character">character</a></code> of length one indicating
the path to a working directory that is used to store some objects</p>
</dd>
</dl>



<h3>Methods</h3>

<p>There are many methods that are defined for a missing_data.frame, although some
are primarily intended for developers. The most relevant ones for users are:
</p>

<dl>
<dt>change</dt><dd><p><code>signature(data = "missing_data.frame", y = "ANY", what = "character", to = "ANY")</code>
which is used to change discretionary aspects of the <code><a href="#topic+missing_variable">missing_variable</a></code>s
in the <b>variables</b> slot of a missing_data.frame</p>
</dd>
<dt>hist</dt><dd><p><code>signature(x = "missing_data.frame")</code> which shows histograms
of the observed variables that have missingness</p>
</dd>
<dt>image</dt><dd><p><code>signature(x = "missing_data.frame")</code> which plots 
an image of the <b>missingness</b> slot to visualize the pattern of missingness
when <code>grayscale = FALSE</code> or the pattern of missingness in light of the
observed values (<code>grayscale = TRUE</code>, the default)</p>
</dd>
<dt>mi</dt><dd><p><code>signature(y = "missing_data.frame", model = "missing")</code> which 
multiply imputes the missing values</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "missing_data.frame")</code> which gives an overview
of the salient characteristics of the <code><a href="#topic+missing_variable">missing_variable</a></code>s in the 
<b>variables</b> slot of a missing_data.frame </p>
</dd>
<dt>summary</dt><dd><p><code>signature(object = "missing_data.frame")</code> which produces the same
result as the <code><a href="base.html#topic+summary">summary</a></code> method for a <code><a href="base.html#topic+data.frame">data.frame</a></code></p>
</dd>
</dl>

<p>There are also S3 methods for the <code><a href="base.html#topic+dim">dim</a></code>, <code><a href="base.html#topic+dimnames">dimnames</a></code>, and <code><a href="base.html#topic+names">names</a></code>
generics, which allow functions like <code><a href="base.html#topic+nrow">nrow</a></code>, <code><a href="base.html#topic+ncol">ncol</a></code>, <code><a href="base.html#topic+rownames">rownames</a></code>,
<code><a href="base.html#topic+colnames">colnames</a></code>, etc. to work as expected on <code>missing_data.frame</code>s. Also, accessing
and changing elements for a <code>missing_data.frame</code> mostly works the same way as for a
<code><a href="base.html#topic+data.frame">data.frame</a></code>
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+change">change</a></code>, <code><a href="#topic+missing_variable">missing_variable</a></code>, <code><a href="#topic+mi">mi</a></code>,
<code><a href="#topic+experiment_missing_data.frame">experiment_missing_data.frame</a></code>, <code><a href="#topic+multilevel_missing_data.frame">multilevel_missing_data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># STEP 0: Get data
data(CHAIN, package = "mi")

# STEP 1: Convert to a missing_data.frame
mdf &lt;- missing_data.frame(CHAIN) # warnings about missingness patterns
show(mdf)

# STEP 2: change things
mdf &lt;- change(mdf, y = "log_virus", what = "transformation", to = "identity")

# STEP 3: look deeper
summary(mdf)
hist(mdf)
image(mdf)

# STEP 4: impute
## Not run: 
imputations &lt;- mi(mdf)

## End(Not run)

## An example with subsetting on a fully observed variable
data(nlsyV, package = "mi")
mdfs &lt;- missing_data.frame(nlsyV, favor_positive = TRUE, favor_ordered = FALSE, by = "first")
mdfs &lt;- change(mdfs, y = "momed", what = "type", to = "ord")
show(mdfs)

</code></pre>

<hr>
<h2 id='03change'>Make Changes to Discretionary Characteristics of Missing Variables</h2><span id='topic+03change'></span><span id='topic+change'></span><span id='topic+change-methods'></span><span id='topic+change_family'></span><span id='topic+change_imputation_method'></span><span id='topic+change_link'></span><span id='topic+change_model'></span><span id='topic+change_size'></span><span id='topic+change_transformation'></span><span id='topic+change_type'></span>

<h3>Description</h3>

<p>These methods change the family, imputation method, size, type, and
so forth of a <code><a href="#topic+missing_variable">missing_variable</a></code>. They are typically
called immediately before calling <code><a href="#topic+mi">mi</a></code> because they
affect how the conditional expectation of each <code><a href="#topic+missing_variable">missing_variable</a></code>
is modeled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>change(data, y, to, what, ...)
change_family(data, y, to, ...)
change_imputation_method(data, y, to, ...)
change_link(data, y, to, ...)
change_model(data, y, to, ...)
change_size(data, y, to, ...)
change_transformation(data, y, to, ...)
change_type(data, y, to, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="03change_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+missing_data.frame">missing_data.frame</a></code> (typically) but can be missing for all but
the <code>change</code> function
</p>
</td></tr>
<tr><td><code id="03change_+3A_y">y</code></td>
<td>
<p>A character vector (typically) naming one or more <code><a href="#topic+missing_variable">missing_variable</a></code>s
within the <code><a href="#topic+missing_data.frame">missing_data.frame</a></code> specified by the <b>data</b> argument. 
Alternatively, <b>y</b> can be the name of a class that inherits from 
<code><a href="#topic+missing_variable">missing_variable</a></code>, in which case all <code><a href="#topic+missing_variable">missing_variable</a></code>s of
that class within <code>data</code> will be changed. Can also be an vector of integers or a 
logical vector indicating which <code><a href="#topic+missing_variable">missing_variable</a></code>s to change.
</p>
</td></tr>
<tr><td><code id="03change_+3A_what">what</code></td>
<td>
<p>Typically a character string naming what is to be changed, such
as <code>"family"</code>, <code>"imputation_method"</code>, <code>"size"</code>, <code>"transformation"</code>, 
<code>"type"</code>, <code>"link"</code>, or <code>"model"</code>. Alternatively, it can be a scalar value, 
in which case all occurances of that value for the variable indicated by <code>y</code> will be changed to
the value indicated by <code>to</code>
</p>
</td></tr>
<tr><td><code id="03change_+3A_to">to</code></td>
<td>
<p>Typically a character string naming what <code>y</code> should be changed to, 
such as one of the admissible families, imputation methods, transformations, or types.
If missing, then possible choices for the <code>to</code> argument will be helpfully printed
on the screen. If <code>what</code> is a number, then <code>to</code> should be the number (or <code>NA</code>)
that the value designated by <code>what</code> will be recoded to. See the Details section for more information.
</p>
</td></tr>
<tr><td><code id="03change_+3A_...">...</code></td>
<td>
<p>Other arguments, not currently utilized</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to run <code><a href="#topic+mi">mi</a></code> correctly, data must first be specified to be ready for multiple imputation using the <code><a href="#topic+missing_data.frame">missing_data.frame</a></code> function.  For each variable, <code>missing_data.frame</code> will record information required by <code>mi</code>: the variable's type, distribution family, and link function; whether a variable should be standardized or tranformed by a log function or square root; what specific model to use for the conditional distribution of the variable in the <code>mi</code> algorithm and how to draw imputed values from this model; and whether additional rows (for the purposes of prediction) are required. <code>missing_data.frame</code> will attempt to guess the correct type, family, and link for each variable based on its class in a regular <code>data.frame</code>.  These guesses can be checked with <code>show</code> and adjusted if necessary with <code>change</code>.  Any further additions to the model in regards to variable transformations, custom conditional models, or extra non-observed predictive cases must be specified with <code>change</code> before <code>mi</code> is run.
</p>
<p>In general, most users will only use the <code>change</code> command.  <code>change</code> will then call <code>change_family</code>, <code>change_imputation_method</code>, <code>change_link</code>, <code>change_model</code>, <code>change_size</code>, <code>change_transformation</code>, or <code>change_type</code> depending on what characteristic is specified with the <code>what</code> option. The other change_* functions can be called directly but are primarily intended to be called indirectly by the change function.
</p>

<dl>
<dt><code>what = "type"</code></dt><dd><p>Change the subclass of variable(s) <code>y</code>.  <code>to</code> should be a character vector whose elements are subclasses of the <code><a href="#topic+missing_variable-class">missing_variable-class</a></code> and are documented further there. Among the most commonly used subclasses are <code>"unordered-categorical"</code>, <code>"ordered-categorical"</code>, <code>"binary"</code>, <code>"interval"</code>, <code>"continuous"</code>, <code>"count"</code>, and <code>"irrelevant"</code>.</p>
</dd>
<dt><code>what = "family"</code></dt><dd><p>Change the distribution family for variable(s) <code>y</code>. <code>to</code> must be of class <code><a href="stats.html#topic+family">family</a></code> or a list where each element is of class <code><a href="stats.html#topic+family">family</a></code>. If a variable is of <code><a href="#topic+binary-class">binary-class</a></code>, then the family must be <code><a href="stats.html#topic+binomial">binomial</a></code> (the default) or possibly <code><a href="stats.html#topic+quasibinomial">quasibinomial</a></code>. If a variable is of <code><a href="#topic+ordered-categorical-class">ordered-categorical-class</a></code> or <code><a href="#topic+unordered-categorical-class">unordered-categorical-class</a></code>, use the <code><a href="#topic+multinomial">multinomial</a></code> family. If a variable is of <code><a href="#topic+count-class">count-class</a></code>, then the family must be <code><a href="stats.html#topic+quasipoisson">quasipoisson</a></code> (the default) or <code><a href="stats.html#topic+poisson">poisson</a></code>. If a variable is continuous, there are more choices for its family, but <code><a href="stats.html#topic+gaussian">gaussian</a></code> is the default and the others are not supported yet.</p>
</dd>
<dt><code>what = "link"</code></dt><dd><p>Change the link function for variable(s) <code>y</code>. <code>to</code> can be any of the supported link functions for the existing <b>family</b>. See <code><a href="stats.html#topic+family">family</a></code> for details; however, not all of these link functions have appropriate <code><a href="#topic+fit_model">fit_model</a></code> and <code><a href="#topic+mi-methods">mi-methods</a></code> yet.</p>
</dd>
<dt><code>what = "model"</code></dt><dd><p>Change the conditional model for variable <code>y</code>. It usually is not necessary to change the model, since it is actually determined by the class, family, and link function of the variable.  This option can be used, however, to employ models that are not among those listed above.<code>to</code> should be a character vector of length one indicating what model should be used during the imputation process. Valid choices for binary variables include <code>"logit"</code>, <code>"probit"</code> <code>"cauchit"</code>, <code>"cloglog"</code>, or quasilikelihoods <code>"qlogit"</code>, <code>"qprobit"</code>, <code>"qcauchit"</code>, <code>"qcloglog"</code>.  For ordinal variables, valid choices include <code>"ologit"</code>, <code>"oprobit"</code>, <code>"ocauchit"</code>, and <code>"ocloglog"</code>.  For count variables, valid choices include <code>"qpoisson"</code> and <code>"poisson"</code>. Currently the only valid option for gaussian variables is <code>"linear"</code>. To change the model for unordered-categorical variables, see the estimator slot in <code><a href="#topic+missing_variable">missing_variable</a></code>.</p>
</dd>
<dt><code>what = "imputation_method"</code></dt><dd><p>Change the method for drawing imputed values from the conditional model specified for variable(s) <code>y</code>. <code>to</code> should be a character vector of length one or of the same length as <code>y</code> naming one of the following imputation methods: <code>"ppd"</code> (posterior predictive distribution), <code>"pmm"</code> (predictive mean matching), <code>"mean"</code> (mean imputation), <code>"median"</code> (median imputation), <code>"expectation"</code> (conditional expectation imputation).</p>
</dd>
<dt><code>what = "size"</code></dt><dd><p>Optionally add additional rows for the purposes of prediction.  <code>to</code> should be a single integer. If <code>to</code> is non-negative but less than the number of rows in the <code><a href="#topic+missing_data.frame">missing_data.frame</a></code> given by the <code>data</code> argument, then <code><a href="#topic+missing_data.frame">missing_data.frame</a></code> is augmented with <code>to</code> more rows, where all the additional observations are missing. If <code>to</code> is greater than the number of rows in the <code><a href="#topic+missing_data.frame">missing_data.frame</a></code>given by the <code>data</code> argument, then the <code><a href="#topic+missing_data.frame">missing_data.frame</a></code> is extended to have <code>to</code> rows, where the observations in the surplus rows are missing. If <code>to</code> is negative, then any additional rows in the <code><a href="#topic+missing_data.frame">missing_data.frame</a></code> given by the <code>data</code> argument are removed to restore it to its original size.</p>
</dd>
<dt><code>what = "transformation"</code></dt><dd><p>Specify a particular transformation to be applied to variable(s) <code>y</code>. <code>to</code> should be a character vector of length one or of
the same length as <code>y</code> indicating what transformation function to use. Valid choices are <code>"identity"</code> for no transformation, <code>"standardize"</code> for standardization (using twice the standard deviation of the observed values), <code>"log"</code> for natural logarithm transformation, <code>"logshift"</code> for a <code>log(y + a)</code> transformation where <code>a</code> is a small constant, or <code>"sqrt"</code> for square-root transformation. Changing the transformation will also change the inverse transformation in the appropriate way. Any other value of <code>to</code> will produce an informative error message indicating that the transformation and inverse transformation need to be changed manually.</p>
</dd>
<dt>what = a value</dt><dd><p>Finally, if both <code>what</code> and <code>to</code> are values then the former is recoded to the latter for all
occurances within the missing variable indicated by <code>y</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>If the <b>data</b> argument is not missing, then the method returns this argument with the 
specified changes. If <b>data</b> is missing, then the method returns an object that inherits 
from the <code><a href="#topic+missing_variable-class">missing_variable-class</a></code> with the specified changes.
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missing_variable">missing_variable</a></code>, <code><a href="#topic+missing_data.frame">missing_data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># STEP 0: GET DATA
data(nlsyV, package = "mi")

# STEP 1: CONVERT IT TO A missing_data.frame
mdf &lt;- missing_data.frame(nlsyV)
show(mdf)

# STEP 2: CHANGE WHATEVER IS WRONG WITH IT
mdf &lt;- change(mdf, y = "momrace", what = "type", to = "un")
mdf &lt;- change(mdf, y = "income", what = "imputation_method", to = "pmm")
mdf &lt;- change(mdf, y = "binary", what = "family", to = binomial(link = "probit"))
mdf &lt;- change(mdf, y = 5, what = "transformation", to = "identity")
show(mdf)
</code></pre>

<hr>
<h2 id='04mi'>Multiple Imputation
</h2><span id='topic+04mi'></span><span id='topic+mi'></span><span id='topic+mi-class'></span><span id='topic+mi-methods'></span>

<h3>Description</h3>

<p>The <code>mi</code> function cannot be run in isolation.  It is the most important step of a multi-step process to perform multiple imputation.  The data must be specified as a <code><a href="#topic+missing_data.frame">missing_data.frame</a></code> before <code>mi</code> is used to impute missing values for one or more <code><a href="#topic+missing_variable">missing_variable</a></code>s. An iterative algorithm is used where each <code><a href="#topic+missing_variable">missing_variable</a></code> is modeled (using <code><a href="#topic+fit_model">fit_model</a></code>) as a function of all the other <code><a href="#topic+missing_variable">missing_variable</a></code>s and their missingness patterns.  This documentation outlines the technical uses of the <code>mi</code> function.  For a more general discussion of how to use <code>mi</code> for multiple imputation, see <code><a href="#topic+mi-package">mi-package</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi(y, model, ...)
## Hidden arguments:
## n.iter = 30, n.chains = 4, max.minutes = Inf, seed = NA, verbose = TRUE,
## save_models = FALSE, parallel = .Platform$OS.type != "windows"
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="04mi_+3A_y">y</code></td>
<td>
<p>Typically an object that inherits from the <code><a href="#topic+missing_data.frame-class">missing_data.frame-class</a></code>,
although many methods are defined for subclasses of the <code><a href="#topic+missing_variable-class">missing_variable-class</a></code>.
Alternatively, <code>y = "parallel"</code> the appropriate parallel backend will be
registered but no imputation performed. See the Details section.
</p>
</td></tr>
<tr><td><code id="04mi_+3A_model">model</code></td>
<td>
<p>Missing when <code>y = "parallel"</code> or when <code>y</code> inherits from the 
<code><a href="#topic+missing_data.frame-class">missing_data.frame-class</a></code> but otherwise should be the result of a call to 
<code><a href="#topic+fit_model">fit_model</a></code>.
</p>
</td></tr>
<tr><td><code id="04mi_+3A_...">...</code></td>
<td>
<p>Further arguments, the most important of which are
</p>

<dl>
<dt><code>n.iter</code></dt><dd><p>number of iterations to perform, defaulting to 30</p>
</dd>
<dt><code>n.chains</code></dt><dd><p>number of chains to use, ideally equal to the number of virtual cores
available for use, and defaulting to 4</p>
</dd>
<dt><code>max.minutes</code></dt><dd><p>hard time limit that defaults to 20</p>
</dd>
<dt><code>seed</code></dt><dd><p>either <code>NA</code>, which is the default, or a psuedo-random number seed</p>
</dd>
<dt><code>verbose</code></dt><dd><p>logical scalar that is <code>TRUE</code> by default, indicating that
progress of the iterative algorithm should be printed to the screen, which does not
work under Windows when the chains are executed in parallel</p>
</dd>
<dt><code>save_models</code></dt><dd><p>logical scalar that defaults to <code>FALSE</code> but if <code>TRUE</code> indicates
that the models estimated on a frozen completed dataset should be saved. This option should be used if the user is interested in evaluating the quality of the models 			run after the last iteration of the <code>mi</code> algorithm, but saving these models consumes much more RAM</p>
</dd>
<dt><code>debug</code></dt><dd><p>logical scalar indicating whether to run in debug mode, which forces the processing to be sequential, and allows developers to capture errors within 			chains</p>
</dd>
<dt><code>parallel</code></dt><dd><p>if TRUE, then parallel processing is used, if available.  If FALSE, sequential processing is used. In addition, ths argument may be an object produced 		by <code><a href="parallel.html#topic+makeCluster">makeCluster</a></code></p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>It is important to distinguish the two <code>mi</code> methods that are most relevant to users from the many <code>mi</code> methods that are less relevant. The primary <code>mi</code> method is that where <code>y</code> inherits from the <code><a href="#topic+missing_data.frame-class">missing_data.frame-class</a></code> and <code>model</code> is omitted. This method &ldquo;does&rdquo; the imputation according to the additional arguments described under ... above and returns an object of class <code>"mi"</code>. Executing two or more independent chains is important for monitoring the convergence
of each chain, see <code><a href="#topic+Rhats">Rhats</a></code>.
</p>
<p>If the chains have not converged in the amount of iterations or time specified, the second important <code>mi</code> method is that where <code>y</code> is an object of class <code>"mi"</code> and <code>model</code> is omitted, which continues a previous run of the iterative imputation algorithm. All the arguments described under ... above remain applicable, except for <code>n.chains</code> and <code>save_RAM</code> because these are established by the previous run that is being continued.
</p>
<p>The numerous remaining methods are of less importance to users.  One <code>mi</code> method is called when <code>y = "parallel"</code> and <code>model</code> is omitted. This method merely sets up the parallel backend so that the chains can be executed in parallel on the local machine.  We use the <code><a href="parallel.html#topic+mclapply">mclapply</a></code> function in the <span class="pkg">parallel</span> package to implement parallel processing on non-Windows machines, and we use the <span class="pkg">snow</span> package to implement parallel processing on Windows machines; we refer users to the documentation for these packages for more detail about parallel processing. Parallel processing is used by default on machines with multiple processors, but sequential processing can be used instead by using the <code>parallel=FALSE</code> option. If the user is not using a mulitcore computer, sequential processing is used instead of parallel processing.
</p>
<p>The first two <code>mi</code> methods described above in turn call a <code>mi</code> method where <code>y</code> inherits from the <code><a href="#topic+missing_data.frame-class">missing_data.frame-class</a></code> and <code>model</code> is that which is returned by one of the <code><a href="#topic+fit_model-methods">fit_model-methods</a></code>. The methods impute values for the originally missing values of a <code><a href="#topic+missing_variable">missing_variable</a></code> given a fitted model, according to the <b>imputation_method</b> slot of the <code><a href="#topic+missing_variable">missing_variable</a></code> in question. Advanced users could define new subclasses of the <code><a href="#topic+missing_variable-class">missing_variable-class</a></code> in which case it may be necessary to write such a <code>mi</code> method for the new class. It will almost certainly be necessary to add to the 
<code><a href="#topic+fit_model-methods">fit_model-methods</a></code>. The existing <code>mi</code> and <code>fit-model-methods</code> should provide a template for doing so.
</p>


<h3>Value</h3>

<p>If <code>model</code> is missing and <code>n.chains</code> is positive, then the <code>mi</code> method will return an object of 
class <code>"mi"</code>, which has the following slots:
</p>

<dl>
<dt>call</dt><dd><p>the call to <code>mi</code></p>
</dd>
<dt>data</dt><dd><p>a list of <code><a href="#topic+missing_data.frame">missing_data.frame</a></code>s, one for each chain</p>
</dd>
<dt>total_iters</dt><dd><p>an integer vector that records how many iterations have been performed</p>
</dd>
</dl>

<p>There are a few methods for such an object, such as <code><a href="methods.html#topic+show">show</a></code>, <code><a href="base.html#topic+summary">summary</a></code>,
<code><a href="base.html#topic+dimnames">dimnames</a></code>, <code><a href="base.html#topic+nrow">nrow</a></code>, <code><a href="base.html#topic+ncol">ncol</a></code>, etc.
</p>
<p>If <code>mi</code> is called on a <code><a href="#topic+missing_data.frame">missing_data.frame</a></code> with <code>model</code> missing and a nonpositive
<code>n.chains</code>, then the <code><a href="#topic+missing_data.frame">missing_data.frame</a></code> will be returned after allocating storeage.
</p>
<p>If <code>model</code> is not missing, then the <code>mi</code> method will impute missing values for the <code>y</code>
argument and return it.
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missing_data.frame">missing_data.frame</a></code>, <code><a href="#topic+fit_model">fit_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># STEP 0: Get data
data(CHAIN, package = "mi")

# STEP 1: Convert to a missing_data.frame
mdf &lt;- missing_data.frame(CHAIN) # warnings about missingness patterns
show(mdf)

# STEP 2: change things
mdf &lt;- change(mdf, y = "log_virus", what = "transformation", to = "identity")

# STEP 3: look deeper
summary(mdf)

# STEP 4: impute
## Not run: 
imputations &lt;- mi(mdf)

## End(Not run)
</code></pre>

<hr>
<h2 id='05Rhats'>Convergence Diagnostics</h2><span id='topic+Rhats'></span><span id='topic+05Rhats'></span><span id='topic+mi2BUGS'></span>

<h3>Description</h3>

<p>These functions are used to gauge whether <code><a href="#topic+mi">mi</a></code> has converged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rhats(imputations, statistic = c("moments", "imputations", "parameters"))
mi2BUGS(imputations, statistic = c("moments", "imputations", "parameters"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="05Rhats_+3A_imputations">imputations</code></td>
<td>
<p>an object of <code><a href="#topic+mi-class">mi-class</a></code>
</p>
</td></tr>
<tr><td><code id="05Rhats_+3A_statistic">statistic</code></td>
<td>
<p>single character string among <code>"moments"</code>, <code>"imputations"</code>, 
and <code>"parameters"</code> indicating what statistic to monitor for convergence
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>statistic = "moments"</code> (the default), then the mean and standard deviation of
each variable will be monitored over the iterations. If <code>statistic = "imputations"</code>, then
the imputed values will be monitored, which may be quite large and quite slow and is not
possible if the <code>save_RAM = TRUE</code> flag was set in the call to the <code><a href="#topic+mi">mi</a></code> function.
If <code>statistic = "parameters"</code>, then the estimated coefficients and ancillary parameters 
extracted by the <code><a href="#topic+get_parameters-methods">get_parameters-methods</a></code> will be monitored.
</p>
<p><code>Rhats</code> produces a vector of R-hat convergence statistics that compare the variance between chains to the variance across chains. Values closer to 1.0 indicate little is to be gained by running the chains longer, and in general, values greater than 1.1 indicate that the chains should be run longer.  See Gelman, Carlin, Stern, and Rubin, &quot;Bayesian Data Analysis&quot;, Second Edition, 2009, p.304 for more information about the R-hat statistic.
</p>
<p><code>mi2BUGS</code> outputs the history of the indicated statistic
</p>


<h3>Value</h3>

<p><code>mi2BUGS</code> returns an array while <code>Rhats</code> a vector of R-hat convergence statistics.
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!exists("imputations", env = .GlobalEnv)) {
  imputations &lt;- mi:::imputations # cached from example("mi-package")
}
  dim(mi2BUGS(imputations))
  Rhats(imputations)
</code></pre>

<hr>
<h2 id='06pool'>Estimate a Model Pooling Over the Imputed Datasets</h2><span id='topic+06pool'></span><span id='topic+pool'></span><span id='topic+pooled-class'></span><span id='topic+pooled-methods'></span><span id='topic+display+2Cpooled-method'></span>

<h3>Description</h3>

<p>This function estimates a chosen model, taking into account the additional
uncertainty that arises due to a finite number of imputations of the missing
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pool(formula, data, m = NULL, FUN = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="06pool_+3A_formula">formula</code></td>
<td>
<p>a <code><a href="stats.html#topic+formula">formula</a></code> in the same syntax as used by <code><a href="stats.html#topic+glm">glm</a></code>
</p>
</td></tr>
<tr><td><code id="06pool_+3A_data">data</code></td>
<td>
<p>an object of <code><a href="#topic+mi-class">mi-class</a></code>
</p>
</td></tr>
<tr><td><code id="06pool_+3A_m">m</code></td>
<td>
<p>number of completed datasets to average over, which if <code>NULL</code> defaults to
the number of chains used in <code><a href="#topic+mi">mi</a></code>
</p>
</td></tr>
<tr><td><code id="06pool_+3A_fun">FUN</code></td>
<td>
<p>Function to estimate models or <code>NULL</code> which uses the same function as
used in the <code><a href="#topic+fit_model-methods">fit_model-methods</a></code> for the dependent variable
</p>
</td></tr>
<tr><td><code id="06pool_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>FUN</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>FUN</code> is estimated on each of the <code>m</code> completed datasets according to the given
<code>formula</code> and the results are combined using the Rubin Rules.
</p>


<h3>Value</h3>

<p>An object of class <code>"pooled"</code> whose definition is subject to change but it has a 
<code><a href="base.html#topic+summary">summary</a></code> and <code><a href="arm.html#topic+display">display</a></code> method.
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mi">mi</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!exists("imputations", env = .GlobalEnv)) {
  imputations &lt;- mi:::imputations # cached from example("mi-package")
}
analysis &lt;- pool(ppvtr.36 ~ first + b.marr + income + momage + momed + momrace, 
                 data = imputations)
display(analysis)
</code></pre>

<hr>
<h2 id='07complete'>Extract the Completed Data</h2><span id='topic+07complete'></span><span id='topic+complete'></span><span id='topic+complete-methods'></span>

<h3>Description</h3>

<p>This function extracts several multiply imputed <code><a href="base.html#topic+data.frame">data.frame</a></code>s 
from an object of <code><a href="#topic+mi-class">mi-class</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complete(y, m, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="07complete_+3A_y">y</code></td>
<td>
<p>An object of <code><a href="#topic+mi-class">mi-class</a></code> (typically) or 
<code><a href="#topic+missing_data.frame-class">missing_data.frame-class</a></code> or 
<code><a href="#topic+missing_variable-class">missing_variable-class</a></code>
</p>
</td></tr>
<tr><td><code id="07complete_+3A_m">m</code></td>
<td>
<p>If <b>y</b> is an object of <code><a href="#topic+mi-class">mi-class</a></code>, then
<code>m</code> must be a specified integer indicating how many multiply
imputed <code><a href="base.html#topic+data.frame">data.frame</a></code>s to return or, if missing, the 
number of <code><a href="base.html#topic+data.frame">data.frame</a></code>s will be equal to the length of the 
<b>data</b> slot in <code>y</code>. If <code>y</code> is not an object of <code><a href="#topic+mi-class">mi-class</a></code>, 
then <b>m</b> must be a specified integer indicating which iteration to use in 
the resulting <code><a href="base.html#topic+data.frame">data.frame</a></code>, where any non-positive integer is 
a short hand for the last iteration.
</p>
</td></tr>
<tr><td><code id="07complete_+3A_...">...</code></td>
<td>
<p>Other arguments, not currently utilized</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several functions within <span class="pkg">mi</span> use <code>complete</code>, although the only reason
in principle why a user should need to call <code>complete</code> is to create 
<code><a href="base.html#topic+data.frame">data.frame</a></code>s to export to another program. For analysis, it is 
better to use the <code><a href="#topic+pool">pool</a></code> function, although currently <code><a href="#topic+pool">pool</a></code>
might not offer all the necessary functionality.
</p>


<h3>Value</h3>

<p>If <b>y</b> is an object of <code><a href="#topic+mi-class">mi-class</a></code> and <code>m &gt; 1</code>, a <code><a href="base.html#topic+list">list</a></code> 
of <code>m</code> <code><a href="base.html#topic+data.frame">data.frame</a></code>s is returned. Otherwise, a single <code><a href="base.html#topic+data.frame">data.frame</a></code>
is returned.
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mi-class">mi-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!exists("imputations", env = .GlobalEnv)) {
  imputations &lt;- mi:::imputations # cached from example("mi-package")
}
data.frames &lt;- complete(imputations, 3)
lapply(data.frames, summary)
</code></pre>

<hr>
<h2 id='allcategorical_missing_data.frame'>Class &quot;allcategorical_missing_data.frame&quot;</h2><span id='topic+allcategorical_missing_data.frame'></span><span id='topic+allcategorical_missing_data.frame-class'></span>

<h3>Description</h3>

<p>This class inherits from the <code><a href="#topic+missing_data.frame-class">missing_data.frame-class</a></code> but is customized for the situation where all the variables are categorical.
</p>


<h3>Details</h3>

<p>The <code><a href="#topic+fit_model-methods">fit_model-methods</a></code> for the allcategorical_missing_data.frame class 
implement a Gibbs sampler. However, it does not utilize any ordinal information that 
may be available. Continuous variables should be made into factors using the
<code><a href="base.html#topic+cut">cut</a></code> command before calling <code><a href="#topic+missing_data.frame">missing_data.frame</a></code>.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("allcategorical_missing_data.frame", ...)</code>.
However, its users almost always will pass a <code><a href="base.html#topic+data.frame">data.frame</a></code> to the 
<code><a href="#topic+missing_data.frame">missing_data.frame</a></code> function and specify the <code>subclass</code> argument.
</p>


<h3>Slots</h3>

<p>The allcategorical_missing_data.frame class inherits from the <code><a href="#topic+missing_data.frame-class">missing_data.frame-class</a></code> and
has three additional slots
</p>

<dl>
<dt>Hstar</dt><dd><p>Positive integer indicating the maximum number of latent classes</p>
</dd>
<dt>parameters</dt><dd><p>A list that holds the current realization of the unknown parameters</p>
</dd>
<dt>latents</dt><dd><p>An object of <code><a href="#topic+unordered-categorical-class">unordered-categorical-class</a></code> that contains
the current realization of the latent classes</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Sophie Si for the algorithm and Ben Goodrich for the R implementation
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missing_data.frame">missing_data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdf &lt;- rdata.frame(n_full = 2, n_partial = 2, 
                   restrictions = "stratified", types = "ord")
mdf &lt;- missing_data.frame(rdf$obs, subclass = "allcategorical")
</code></pre>

<hr>
<h2 id='bounded-continuous-class'>Class &quot;bounded-continuous&quot;</h2><span id='topic+bounded-continuous-class'></span><span id='topic+bounded-continuous'></span>

<h3>Description</h3>

<p>The bounded-continuous class inherits from the <code><a href="#topic+continuous-class">continuous-class</a></code> and is intended for variables whose observations
fall within open intervals that have <em>known</em> boundaries. Although proportions satisfy this definition, the 
<code><a href="#topic+proportion-class">proportion-class</a></code> should be used in that case. At the moment, a bounded continuous variable is modeled as if it were
simply a continuous variable, but its <code><a href="#topic+mi-methods">mi-methods</a></code> impute the missing values from a truncated normal distribution using
the <code><a href="truncnorm.html#topic+rtruncnorm">rtruncnorm</a></code> function in the <span class="pkg">truncnorm</span> package. Note that the default transformation is the identity
so if another transformation is used, the bounds must be specified on the transformed data. Aside from these facts, the rest of the 
documentation here is primarily directed toward developers.
</p>


<h3>Objects from the Classes</h3>

<p>Objects can be created that are of bounded-continuous class via the 
the <code><a href="#topic+missing_variable">missing_variable</a></code> generic function by specifying <code>type = "bounded-continuous"</code> 
as well as <code>lower</code> and / or <code>upper</code>
</p>


<h3>Slots</h3>

<p>The bounded-continuous class inherits from the continuous class and is intended for variables that are supported on a known
interval. Its default transformation function is the identity transformation and its <code>imputation_method</code> must be 
<code>"ppd"</code>. It has two additional slots:
</p>

<dl>
<dt>upper</dt><dd><p>a numeric vector whose length is either one or the value of the <code>n_total</code> slot giving the upper bound for
<em>every</em> observation; <code>NA</code>s are not allowed</p>
</dd>
<dt>lower</dt><dd><p>a numeric vector whose length is either one or the value of the <code>n_total</code> slot giving the lower bound for
<em>every</em> observation; <code>NA</code>s are not allowed</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missing_variable">missing_variable</a></code>, <code><a href="#topic+continuous-class">continuous-class</a></code>, <code><a href="#topic+positive-continuous-class">positive-continuous-class</a></code>,
<code><a href="#topic+proportion-class">proportion-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># STEP 0: GET DATA
data(CHAIN, package = "mi")

# STEP 0.5 CREATE A missing_variable (you never need to actually do this)
lo_bound &lt;- 0
hi_bound &lt;- rep(Inf, nrow(CHAIN))
hi_bound[CHAIN$log_virus == 0] &lt;- 6
log_virus &lt;- missing_variable(ifelse(CHAIN$log_virus == 0, NA, CHAIN$log_virus), 
                              type = "bounded-continuous", lower = lo_bound, upper = hi_bound)

show(log_virus)
</code></pre>

<hr>
<h2 id='categorical'>Class &quot;categorical&quot; and Inherited Classes</h2><span id='topic+categorical'></span><span id='topic+categorical-class'></span><span id='topic+unordered-categorical-class'></span><span id='topic+ordered-categorical-class'></span><span id='topic+interval-class'></span><span id='topic+binary-class'></span><span id='topic+grouped-binary-class'></span>

<h3>Description</h3>

<p>The categorical class is a virtual class that inherits from the <code><a href="#topic+missing_variable-class">missing_variable-class</a></code>
and is the parent of the unordered-categorical and ordered-categorical classes. The ordered-categorical
class is the parent of both the binary and interval classes. Aside from these facts, the rest of the 
documentation here is primarily directed toward developers.
</p>


<h3>Objects from the Classes</h3>

<p>The categorical class is virtual, so no objects 
may be created from it. However, the <code><a href="#topic+missing_variable">missing_variable</a></code> generic function can be used to 
instantiate an object that inherits from the categorical class by specifying 
<code>type = "unordered-categorical"</code>, <code>type = "ordered-categorical"</code>, 
<code>type = "binary"</code>, <code>type = "grouped-binary"</code>, or <code>type = "interval"</code>.
</p>


<h3>Slots</h3>

<p>The unordered-categorical class inherits from the categorical class and has no additional slots
but must have more than two uniquely observed values in its <code>raw_data</code> slot. The default <code><a href="#topic+fit_model">fit_model</a></code>
method is a wrapper for the <code><a href="nnet.html#topic+multinom">multinom</a></code> function in the <span class="pkg">nnet</span> package. The ordered-categorical 
class inherits from the categorical class and has one additional slot:
</p>

<dl>
<dt>cutpoints</dt><dd><p>Object of class <code>"numeric"</code> which is a vector of thresholds (sometimes estimated) that 
govern how an assumed latent variable is divided into observed ordered categories</p>
</dd>
</dl>

<p>The <code><a href="#topic+fit_model">fit_model</a></code> method for an ordered-categorical variable is, by default, a wrapper for 
<code><a href="arm.html#topic+bayespolr">bayespolr</a></code>. The binary class inherits from the ordered-categorical class and has no additional slots. 
It must have exactly two uniquely observed values in its <code>raw_data</code> slot and its <code><a href="#topic+fit_model">fit_model</a></code> method is,
by default, a wrapper for <code><a href="arm.html#topic+bayespolr">bayespolr</a></code>. The grouped-binary class inherits from the binary class and
has one additional slot:
</p>

<dl>
<dt>strata</dt><dd><p>Object of class <code>"character"</code> which is a vector (possibly of length one) of variable names that
group the observations into strata. The named external variables should also be categorical.</p>
</dd>
</dl>

<p>The default <code><a href="#topic+fit_model">fit_model</a></code> method for a grouped-binary variable is a wrapper for the <code><a href="survival.html#topic+clogit">clogit</a></code>
function in the <span class="pkg">survival</span> package and the variables named in the <b>strata</b> slot are passed to the
<code><a href="survival.html#topic+strata">strata</a></code> function.
</p>
<p>The interval class inherits from the ordered-categorical class, has no additional slots, and is intended for variables 
whose observed values are only known up to orderable intervals. Its <code><a href="#topic+fit_model">fit_model</a></code> method is, by default, a 
wrapper for <code><a href="survival.html#topic+survreg">survreg</a></code> even though it may or may not be a &ldquo;survival&rdquo; model in any meaningful sense.
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missing_variable">missing_variable</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># STEP 0: GET DATA
data(nlsyV, package = "mi")

# STEP 0.5 CREATE A missing_variable (you never need to actually do this)
momrace &lt;- missing_variable(as.factor(nlsyV$momrace), type = "unordered-categorical")
show(momrace)
</code></pre>

<hr>
<h2 id='censored-continuous-class'>The &quot;censored-continuous&quot; Class, the &quot;truncated-continuous&quot; Class and Inherited Classes</h2><span id='topic+truncated-continuous-class'></span><span id='topic+truncated-continuous'></span><span id='topic+FF_truncated-continuous-class'></span><span id='topic+FN_truncated-continuous-class'></span><span id='topic+NF_truncated-continuous-class'></span><span id='topic+NN_truncated-continuous-class'></span><span id='topic+censored-continuous-class'></span><span id='topic+censored-continuous'></span><span id='topic+FF_censored-continuous-class'></span><span id='topic+FN_censored-continuous-class'></span><span id='topic+NF_censored-continuous-class'></span><span id='topic+NN_censored-continuous-class'></span>

<h3>Description</h3>

<p>The censored-continuous class and the truncated-continuous class are both virtual and both inherit from the <code><a href="#topic+continuous-class">continuous-class</a></code>
and each is the parent of four classes that differ depending on whether the lower and upper bounds are numeric vectors or functions. A
censored observation is one whose exact value is not observed. A truncated observation is one whose exact value is not observed and which
implies that values on some <em>other</em> variables are not observed for that unit of observation. An example of truncation might be that 
some taxation forms are not required when a person's income falls below a certain threshold. The methods for these classes are not
working yet. Aside from these facts, the rest of the documentation here is primarily directed toward developeRs.
</p>


<h3>Objects from the Classes</h3>

<p>Both the censored-continuous class and the truncated-continuous class are virtual, so no objects can be 
created with these classes. However, the <code><a href="#topic+missing_variable">missing_variable</a></code> generic function can be used to create an object that inherits
from one of their subclasses by specifying <code>type = "NNcensored-continuous"</code>, <code>type = "NFcensored-continuous"</code>, 
<code>type = "FNcensored-continuous"</code>, <code>type = "FFcensored-continuous"</code>, <code>type = "NNtruncated-continuous"</code>, <code>type = "NFtruncated-continuous"</code>, 
<code>type = "FNtruncated-continuous"</code>, <code>type = "FFtruncated-continuous"</code>. When doing so, the lower and upper slots need to be
specified appropriately.
</p>


<h3>Slots</h3>

<p>The censored-continuous class and the truncated-continuous class are both virtual, both inherit from
the continuous class, both use the identity transformation by default, and both have two additional slots:
</p>

<dl>
<dt>upper</dt><dd><p>The upper bound for each observation</p>
</dd>
<dt>lower</dt><dd><p>The lower bound for each observation</p>
</dd>
</dl>

<p>Both the censored-continuous class and the truncated-continuous class have four subclasses that differ depending 
on whether the upper and / or lower bounds are numeric vectors or functions that output numeric 
vectors (scalars are recycled and can be <code>Inf</code>). These subclasses are 
</p>

<dl>
<dt>NN_censored-continuous</dt><dd><p>where both the lower and upper bounds are numeric vectors</p>
</dd>
<dt>FN_censored-continuous</dt><dd><p>where the lower bound is a function and the upper bound is a numeric vector</p>
</dd>
<dt>NF_censored-continuous</dt><dd><p>where the lower bound is a numeric vector and the upper bound is a function</p>
</dd>
<dt>FF_censored-continuous</dt><dd><p>where both the lower and upper bounds are functions</p>
</dd>
<dt>NN_truncated-continuous</dt><dd><p>where both the lower and upper bounds are numeric vectors</p>
</dd>
<dt>FN_truncated-continuous</dt><dd><p>where the lower bound is a function and the upper bound is a numeric vector</p>
</dd>
<dt>NF_truncated-continuous</dt><dd><p>where the lower bound is a numeric vector and the upper bound is a function</p>
</dd>
<dt>FF_truncated-continuous</dt><dd><p>where both the lower and upper bounds are functions</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ben Goodrich, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missing_variable">missing_variable</a></code>, <code><a href="#topic+continuous-class">continuous-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># STEP 0: GET DATA
data(CHAIN, package = "mi")

# STEP 0.5 CREATE A missing_variable (you never need to actually do this)
#log_virus &lt;- missing_variable(CHAIN$log_virus, type = "NN_censored-continuous", 
#                              lower = 0, upper = Inf)
#show(log_virus)
</code></pre>

<hr>
<h2 id='CHAIN'>
Subset of variables from the CHAIN project
</h2><span id='topic+CHAIN'></span>

<h3>Description</h3>

<p>The CHAIN project was a longitudinal cohort study of people living with HIV in New York City, 
which was recruited in 1994 from a large number of medical care and social service agencies
serving HIV in New York City. This subset of data pertain to the sixth round of interviews.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CHAIN)</code></pre>


<h3>Format</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> with 532 observations on the following 8 variables.
</p>

<dl>
<dt><code>log_virus</code></dt><dd>
<p>log of self reported viral load level, where zero represents an undetectable level.
</p>
</dd>
<dt><code>age</code></dt><dd>
<p>age at time of the interview
</p>
</dd>
<dt><code>income</code></dt><dd>
<p>annual family income in 10 intervals
</p>
</dd>
<dt><code>healthy</code></dt><dd>
<p>a continuous scale of physical health with a theoretical range between 0 and 100 where
better health is associated with higher scale values
</p>
</dd>
<dt><code>mental</code></dt><dd>
<p>a binary measure of poor mental health ( 1=Yes, 0=No )
</p>
</dd>
<dt><code>damage</code></dt><dd>
<p>ordered interval for the CD4 count, which is an
indicator of how much damage HIV has caused to the immune system
</p>
</dd>
<dt><code>treatment</code></dt><dd>
<p>a three-level ordered variable:
0=Not currently taking HAART (Highly Active AntiretRoviral Therapy)
1=taking HAART but nonadherent,
2=taking HAART and adherent
</p>
</dd>
</dl>



<h3>Details</h3>

<p>A missing value in the log virus load level 
was assigned to individuals who either could not recall
their viral load level, did not have a viral load test in the six month
preceding the interview, or reported their viral loads as &quot;good&quot; or &quot;bad&quot;.
</p>


<h3>Source</h3>

<p>http://cchps.columbia.edu/research.cfm
</p>


<h3>References</h3>

<p>Messeri P, Lee G, Abramson DA, Aidala A, Chiasson MA, Jones JD. (2003).
&ldquo;Antiretroviral therapy and declining AIDS mortality in New York City&rdquo;.
<em>Medical Care</em> 41:512&ndash;521.
</p>

<hr>
<h2 id='continuous'>Class &quot;continuous&quot;</h2><span id='topic+continuous'></span><span id='topic+continuous-class'></span>

<h3>Description</h3>

<p>The continuous class inherits from the <code><a href="#topic+missing_variable-class">missing_variable-class</a></code> and is the parent of the following
classes: <code><a href="#topic+semi-continuous">semi-continuous</a></code>, <code><a href="#topic+censored-continuous">censored-continuous</a></code>, <code><a href="#topic+truncated-continuous">truncated-continuous</a></code>, 
and <code><a href="#topic+bounded-continuous">bounded-continuous</a></code>. The distinctions
among these subclasses are given on their respective help pages. Aside from these facts, the rest of the 
documentation here is primarily directed toward developers.
</p>


<h3>Objects from the Classes</h3>

<p>Objects can be created that are of class continuous via
the <code><a href="#topic+missing_variable">missing_variable</a></code> generic function by specifying <code>type = "continuous"</code>
</p>


<h3>Slots</h3>

<p>The continuous class inherits from the <code><a href="#topic+missing_variable">missing_variable</a></code> class and has the following additional slots:
</p>

<dl>
<dt>transformation</dt><dd><p>Object of class <code>"function"</code> which is passed the <code>raw_data</code> slot and
whose returned value is assigned to the <code>data</code> slot. By default, this function is the 
&ldquo;standardize&rdquo; transformation, using the mean and <em>twice</em> the standard deviation of the 
observed values</p>
</dd>
<dt>inverse_transformation</dt><dd><p>Object of class <code>"function"</code> which is the inverse of the function
in the <code>transformation</code> slot.</p>
</dd>
<dt>transformed</dt><dd><p>Object of class <code>"logical"</code> of length one indicating whether the 
<code>data</code> slot is in the &ldquo;transformed&rdquo; state or the &ldquo;untransformed&rdquo; state</p>
</dd>
<dt>known_transformations</dt><dd><p>Object of class <code>"character"</code> indicating which transformations
are possible for this variable</p>
</dd>
</dl>

<p>The <code><a href="#topic+fit_model">fit_model</a></code> method for a continuous variable is, by default, a wrapper for
<code><a href="arm.html#topic+bayesglm">bayesglm</a></code> and its <code>family</code> slot is, by default, <code><a href="stats.html#topic+gaussian">gaussian</a></code>
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missing_variable">missing_variable</a></code>, <code><a href="#topic+semi-continuous-class">semi-continuous-class</a></code>, <code><a href="#topic+censored-continuous-class">censored-continuous-class</a></code>,
<code><a href="#topic+truncated-continuous-class">truncated-continuous-class</a></code>, <code><a href="#topic+bounded-continuous-class">bounded-continuous-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># STEP 0: GET DATA
data(nlsyV, package = "mi")

# STEP 0.5 CREATE A missing_variable (you never need to actually do this)
income &lt;- missing_variable(nlsyV$income, type = "continuous")
show(income)
</code></pre>

<hr>
<h2 id='count-class'>Class &quot;count&quot;</h2><span id='topic+count-class'></span>

<h3>Description</h3>

<p>The count class inherits from the <code><a href="#topic+missing_variable-class">missing_variable-class</a></code> and is intended for count data. 
Aside from these facts, the rest of the documentation here is primarily directed toward developers.
</p>


<h3>Objects from the Classes</h3>

<p>Objects can be created that are of count class via the 
<code><a href="#topic+missing_variable">missing_variable</a></code> generic function by specifying <code>type = "count"</code> 
</p>


<h3>Slots</h3>

<p>The count class inherits from the missing_variable class and its <code>raw_data</code> slot must consist of nonnegative
integers. Its default family is <code><a href="stats.html#topic+quasipoisson">quasipoisson</a></code> and its default <code><a href="#topic+fit_model">fit_model</a></code> method is 
a wrapper for <code><a href="arm.html#topic+bayesglm">bayesglm</a></code>. The other possibility for the family is <code><a href="stats.html#topic+poisson">poisson</a></code> but is
not recommended due to its overly-restrictive nature.
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missing_variable">missing_variable</a></code>, <code><a href="#topic+continuous-class">continuous-class</a></code>, <code><a href="#topic+positive-continuous-class">positive-continuous-class</a></code>,
<code><a href="#topic+proportion-class">proportion-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># STEP 0: GET DATA
data(CHAIN, package = "mi")

# STEP 0.5 CREATE A missing_variable (you never need to actually do this)
age &lt;- missing_variable(as.integer(CHAIN$age), type = "count")
show(age)
</code></pre>

<hr>
<h2 id='experiment_missing_data.frame'>Class &quot;experiment_missing_data.frame&quot;</h2><span id='topic+experiment_missing_data.frame'></span><span id='topic+experiment_missing_data.frame-class'></span>

<h3>Description</h3>

<p>This class inherits from the <code><a href="#topic+missing_data.frame-class">missing_data.frame-class</a></code> but is customized for the situation
where the sample is a randomized experiment.
</p>


<h3>Details</h3>

<p>The <code><a href="#topic+fit_model-methods">fit_model-methods</a></code> for the experiment_missing_data.frame class take into account the
special nature of a randomized experiment. At the moment, the treatment variable must be binary and
fully observed.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("experiment_missing_data.frame", ...)</code>.
However, its users almost always will pass a <code><a href="base.html#topic+data.frame">data.frame</a></code> to the 
<code><a href="#topic+missing_data.frame">missing_data.frame</a></code> function and specify the <code>subclass</code> and <code>concept</code> arguments.
</p>


<h3>Slots</h3>

<p>The experiment_missing_data.frame class inherits from the <code><a href="#topic+missing_data.frame-class">missing_data.frame-class</a></code> and
has two additional slots
</p>

<dl>
<dt>concept</dt><dd><p>Object of class <code><a href="base.html#topic+factor">factor</a></code> whose length is equal to the number of variables
and whose levels are <code>"treatment"</code>, <code>"covariate"</code> and <code>"outcome"</code></p>
</dd>
<dt>case</dt><dd><p>Object of class <code><a href="base.html#topic+character">character</a></code> of length one, indicating whether the missingness
is in the outcomes only, in the covariates only, or in both the outcomes and covariates. This slot
is filled automatically by the <code><a href="methods.html#topic+initialize">initialize</a></code> method</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missing_data.frame">missing_data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdf &lt;- rdata.frame(n_full = 2, n_partial = 2, 
                   restrictions = "stratified", experiment = TRUE,
                   types = c("t", "ord", "con", "pos"),
                   treatment_cor = c(0, 0, NA, 0, NA))
Sigma &lt;- tcrossprod(rdf$L)
rownames(Sigma) &lt;- colnames(Sigma) &lt;- c("treatment", "X_2", "y_1", "Y_2",
                                        "missing_y_1", "missing_Y_2")
print(round(Sigma, 3))

concept &lt;- as.factor(c("treatment", "covariate", "covariate", "outcome"))
mdf &lt;- missing_data.frame(rdf$obs, subclass = "experiment", concept = concept)
</code></pre>

<hr>
<h2 id='fit_model'>Wrappers To Fit a Model</h2><span id='topic+fit_model'></span><span id='topic+fit_model-methods'></span>

<h3>Description</h3>

<p>The methods are called by the <code><a href="#topic+mi">mi</a></code> function to model a given
<code><a href="#topic+missing_variable">missing_variable</a></code> as a function of all the other 
<code><a href="#topic+missing_variable">missing_variable</a></code>s and also their missingness pattern.
By overwriting these methods, users can change the way a 
<code><a href="#topic+missing_variable">missing_variable</a></code> is modeled for the purposes of imputing
its missing values. See also the table in <code><a href="#topic+missing_variable">missing_variable</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_model(y, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_model_+3A_y">y</code></td>
<td>
<p>An object that inherits from <code><a href="#topic+missing_variable-class">missing_variable-class</a></code> or
missing
</p>
</td></tr>
<tr><td><code id="fit_model_+3A_data">data</code></td>
<td>
<p>A <code><a href="#topic+missing_data.frame">missing_data.frame</a></code>
</p>
</td></tr>
<tr><td><code id="fit_model_+3A_...">...</code></td>
<td>
<p>Additional arguments, not currently utilized
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In <code><a href="#topic+mi">mi</a></code>, each <code><a href="#topic+missing_variable">missing_variable</a></code> is modeled as a function of 
all the other <code><a href="#topic+missing_variable">missing_variable</a></code>s plus their missingness pattern. The
<code>fit_model</code> methods are typically short wrappers around a statistical model fitting
function and return the estimated model. The model is then passed to one of the 
<code><a href="#topic+mi-methods">mi-methods</a></code> to impute the missing values of that <code><a href="#topic+missing_variable">missing_variable</a></code>.
</p>
<p>Users can easily overwrite these methods to estimate a different model, such as wrapping
<code><a href="stats.html#topic+glm">glm</a></code> instead of <code><a href="arm.html#topic+bayesglm">bayesglm</a></code>. See the source code for examples,
but the basic outline is to first extract the <code>X</code> slot of the 
<code><a href="#topic+missing_data.frame">missing_data.frame</a></code>, then drop some of its columns using the <code>index</code> slot
of the <code><a href="#topic+missing_data.frame">missing_data.frame</a></code>, next pass the result along with the <code>data</code> slot
of <code>y</code> to a statistical fitting function, and finally returned the appropriately classed
result (along with the subset of <code>X</code> used in the model).
</p>
<p>Many of the optional arguments to a statistical fitting function can be specified using the
slots of <code>y</code> (e.g. its <code>family</code> slot) or the slots of <b>data</b> (e.g. its 
<code>weights</code> slot).
</p>
<p>The exception is the method where <code>y</code> is missing, which is used internally by 
<code><a href="#topic+mi">mi</a></code>, and should <em>not</em> be overwritten unless great care is taken to understand
its role.
</p>


<h3>Value</h3>

<p>If <code>y</code> is missing, then the modified <code><a href="#topic+missing_data.frame">missing_data.frame</a></code> passed to
<code>data</code> is returned. Otherwise, the estimated model is returned as a classed
list object.
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missing_variable">missing_variable</a></code>, <code><a href="#topic+mi">mi</a></code>, <code><a href="#topic+get_parameters">get_parameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>getMethod("fit_model", signature(y = "binary", data = "missing_data.frame"))
setMethod("fit_model", signature(y = "binary", data = "missing_data.frame"), def =
function(y, data, ...) {
  to_drop &lt;- data@index[[y@variable_name]]
  X &lt;- data@X[, -to_drop]
  start &lt;- NULL
  # using glm.fit() instead of bayesglm.fit()
  out &lt;- glm.fit(X, y@data, weights = data@weights[[y@variable_name]], start = start, 
                 family = y@family, Warning = FALSE, ...)
  out$x &lt;- X
  class(out) &lt;- c("glm", "lm") # not "bayesglm" class anymore
  return(out)
})
## Not run: 
if(!exists("imputations", env = .GlobalEnv)) {
  imputations &lt;- mi:::imputations # cached from example("mi-package")
}
imputations &lt;- mi(imputations) # will use new fit_model() method for binary variables

## End(Not run)
</code></pre>

<hr>
<h2 id='get_parameters'>An Extractor Function for Model Parameters</h2><span id='topic+get_parameters'></span><span id='topic+get_parameters-methods'></span>

<h3>Description</h3>

<p>This function is not intended to be called directly by users.
During the multiple imputation process, the <code><a href="#topic+mi">mi</a></code>
function estimates models and stores the estimated parameters in the
<code>parameters</code> slot of an object that inherits from the 
<code><a href="#topic+missing_variable-class">missing_variable-class</a></code>. The <code>get_parameter</code> 
function simply extracts these parameters for storeage, which are
usually the estimated coefficients but may also include ancillary
parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_parameters(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_parameters_+3A_object">object</code></td>
<td>
<p>Usually an estimated model, such as that produced by <code><a href="stats.html#topic+glm">glm</a></code>
</p>
</td></tr>
<tr><td><code id="get_parameters_+3A_...">...</code></td>
<td>
<p>Additional arguments, currently not used
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is method for the object produced by <code><a href="MASS.html#topic+polr">polr</a></code>, which
also returns the estimated cutpoints in a proportional odds model. However,
the default method simply calls <code><a href="stats.html#topic+coef">coef</a></code> and returns the result.
If users implement their own models, it may be necessary to write a short
<code>get_parameters</code> method.
</p>


<h3>Value</h3>

<p>A numeric vector of estimated parameters
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_model">fit_model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showMethods("get_parameters")
</code></pre>

<hr>
<h2 id='hist'>Histograms of Multiply Imputed Data
</h2><span id='topic+hist'></span><span id='topic+hist-methods'></span>

<h3>Description</h3>

<p>This function creates a histogram from an object of
<code><a href="#topic+missing_data.frame-class">missing_data.frame-class</a></code> or 
<code><a href="#topic+mi-class">mi-class</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hist(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist_+3A_x">x</code></td>
<td>
<p>an object of <code><a href="#topic+missing_data.frame-class">missing_data.frame-class</a></code> or 
<code><a href="#topic+mi-class">mi-class</a></code>
</p>
</td></tr>
<tr><td><code id="hist_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+plot.histogram">plot.histogram</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When called on an object of <code><a href="#topic+missing_data.frame-class">missing_data.frame-class</a></code>, the
histograms of the observed data are generated, one for each <code><a href="#topic+missing_variable">missing_variable</a></code>
but grouped on a single page. When called on an object of <code><a href="#topic+mi-class">mi-class</a></code>, 
the histograms of the observed, imputed, and completed data are generated, one for each
<code><a href="#topic+missing_variable">missing_variable</a></code>, grouped on a single page for each chain.
</p>


<h3>Value</h3>

<p>An invisible <code>NULL</code> is returned with a side-effect of creating a plot
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!exists("imputations", env = .GlobalEnv)) {
  imputations &lt;- mi:::imputations # cached from example("mi-package")
}
hist(imputations)
</code></pre>

<hr>
<h2 id='irrelevant'>Class &quot;irrelevant&quot; and Inherited Classes</h2><span id='topic+irrelevant'></span><span id='topic+irrelevant-class'></span><span id='topic+fixed-class'></span><span id='topic+group-class'></span>

<h3>Description</h3>

<p>The irrelevant class inherits from the <code><a href="#topic+missing_variable-class">missing_variable-class</a></code> and is used to 
designate variables that are excluded from the models used to impute the missing values of 
&ldquo;relevant&rdquo; variables. For example, if a survey has an &ldquo;id&rdquo; variable that 
simply distinguishes observations, the user should designate it as irrelevant, although it 
will automatically be classified so if its name is either &ldquo;id&rdquo; or starts with punctuation 
(including underscores). The fixed class inherits from the irrelevant class and is used 
for variables that are constant (within a sample). A variable that is instantiated from the
fixed class cannot have any missing values. The group class inherits from the fixed 
class and is used like a <code><a href="base.html#topic+factor">factor</a></code> to spit samples in multilevel modeling; see 
<code><a href="#topic+multilevel_missing_data.frame-class">multilevel_missing_data.frame-class</a></code>. None of these classes have an additional
slots. Aside from these facts, the rest of the documentation here is primarily directed toward developeRs.
</p>


<h3>Objects from the Classes</h3>

<p>The <code><a href="#topic+missing_variable">missing_variable</a></code> generic function can be used to 
instantiate an object that inherits from the irrelevant class by specifying 
<code>type = "irrelevant"</code>, <code>type = "fixed"</code>, or <code>type = "group"</code>.
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missing_variable-class">missing_variable-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># STEP 0: GET DATA
data(nlsyV, package = "mi")

# STEP 0.5 CREATE A missing_variable (you never need to actually do this)
first &lt;- missing_variable(as.factor(nlsyV$first), type = "group")
show(first)
</code></pre>

<hr>
<h2 id='mi-internal'>Internal Functions and Methods</h2><span id='topic+mi-internal'></span><span id='topic+change+2Cmissing_data.frame+2CANY+2CANY+2Ccharacter-method'></span><span id='topic+mi+2Cmissing_data.frame+2Cmissing-method'></span><span id='topic+plot+2Cmissing_data.frame+2Cmissing-method'></span><span id='topic+plot+2Cmi+2CANY-method'></span><span id='topic+show+2Cmissing_data.frame-method'></span><span id='topic+show+2Cmissing_variable-method'></span><span id='topic+summary+2Cmissing_data.frame-method'></span><span id='topic+summary+2Cmi-method'></span><span id='topic+show+2Cmi-method'></span><span id='topic+change_family+2Cmissing+2Cmissing_variable+2Cfamily-method'></span><span id='topic+change_family+2Cmissing+2Cproportion+2Cfamily-method'></span><span id='topic+change_family+2Cmissing+2Cunordered-categorical+2Cfamily-method'></span><span id='topic+change_imputation_method+2Cmissing+2Cmissing_variable+2Ccharacter-method'></span><span id='topic+change_imputation_method+2Cmissing+2Cmissing_variable+2Cmissing-method'></span><span id='topic+change_link+2Cmissing+2Cmissing_variable+2Ccharacter-method'></span><span id='topic+change_link+2Cmissing+2Cmissing_variable+2Cmissing-method'></span><span id='topic+change_link+2Cmissing_data.frame+2Ccharacter+2Ccharacter-method'></span><span id='topic+change_link+2Cmissing_data.frame+2Cnumeric+2Ccharacter-method'></span><span id='topic+change_link+2Cmissing_data.frame+2Clogical+2Ccharacter-method'></span><span id='topic+change_model+2Cmissing+2Cmissing_variable+2Ccharacter-method'></span><span id='topic+change_model+2Cmissing_data.frame+2Ccharacter+2Ccharacter-method'></span><span id='topic+change_model+2Cmissing_data.frame+2Cnumeric+2Ccharacter-method'></span><span id='topic+change_model+2Cmissing_data.frame+2Clogical+2Ccharacter-method'></span><span id='topic+change_size+2Cmissing+2Cmissing_variable+2Cinteger-method'></span><span id='topic+change_size+2Cmissing+2Ccategorical+2Cinteger-method'></span><span id='topic+change_size+2Cmissing+2Cfixed+2Cinteger-method'></span><span id='topic+change_size+2Cmissing_data.frame+2Cmissing+2Cinteger-method'></span><span id='topic+change_type+2Cmissing+2Cmissing_variable+2Ccharacter-method'></span><span id='topic+change_imputation_method+2Cmissing_data.frame+2Clogical+2Ccharacter-method'></span><span id='topic+change_imputation_method+2Cmissing_data.frame+2Cnumeric+2Ccharacter-method'></span><span id='topic+change_transformation+2Cmissing+2Cmissing_variable+2Cmissing-method'></span><span id='topic+change_transformation+2Cmissing_data.frame+2Ccharacter+2Cmissing-method'></span><span id='topic+change_transformation+2Cmissing_data.frame+2Ccharacter+2Cfunction-method'></span><span id='topic+change_transformation+2Cmissing_data.frame+2Cnumeric+2Cfunction-method'></span><span id='topic+change_transformation+2Cmissing_data.frame+2Clogical+2Cfunction-method'></span><span id='topic+change_type+2Cmissing+2Cmissing_variable+2Cmissing-method'></span><span id='topic+change_type+2Cmissing_data.frame+2Ccharacter+2Cmissing-method'></span><span id='topic+complete+2Cirrelevant+2Cinteger-method'></span><span id='topic+complete+2Ccategorical+2Cinteger-method'></span><span id='topic+complete+2Cbinary+2Cinteger-method'></span><span id='topic+complete+2Ccontinuous+2Cinteger-method'></span><span id='topic+complete+2Cnonnegative-continuous+2Cinteger-method'></span><span id='topic+complete+2CSC_proportion+2Cinteger-method'></span><span id='topic+complete+2Cmi+2Cinteger-method'></span><span id='topic+complete+2Cmissing_data.frame+2Cnumeric-method'></span><span id='topic+complete+2Cmissing_variable+2Cinteger-method'></span><span id='topic+complete+2Cmi+2Cmissing-method'></span><span id='topic+complete+2Cmi_list+2Cnumeric-method'></span><span id='topic+complete+2Cmi_list+2Cmissing-method'></span><span id='topic+fit_model+2Cmissing_variable+2Cmissing_data.frame-method'></span><span id='topic+fit_model+2Cmissing+2Cmissing_data.frame-method'></span><span id='topic+fit_model+2Ccontinuous+2Cmissing_data.frame-method'></span><span id='topic+fit_model+2Csemi-continuous+2Cmissing_data.frame-method'></span><span id='topic+fit_model+2Cnonnegative-continuous+2Cmissing_data.frame-method'></span><span id='topic+fit_model+2CSC_proportion+2Cmissing_data.frame-method'></span><span id='topic+fit_model+2Cproportion+2Cmissing_data.frame-method'></span><span id='topic+fit_model+2Ctruncated-continuous+2Cmissing_data.frame-method'></span><span id='topic+fit_model+2Ccensored-continuous+2Cmissing_data.frame-method'></span><span id='topic+fit_model+2Cmissing_variable+2Cexperiment_missing_data.frame-method'></span><span id='topic+fit_model+2Ccontinuous+2Cexperiment_missing_data.frame-method'></span><span id='topic+fit_model+2Cmissing+2Cmultilevel_missing_data.frame-method'></span><span id='topic+fit_model+2Cmissing+2Cmdf_list-method'></span><span id='topic+fit_model+2Cbinary+2Callcategorical_missing_data.frame-method'></span><span id='topic+fit_model+2Cmissing+2Callcategorical_missing_data.frame-method'></span><span id='topic+fit_model+2Cordered-categorical+2Callcategorical_missing_data.frame-method'></span><span id='topic+fit_model+2Cunordered-categorical+2Callcategorical_missing_data.frame-method'></span><span id='topic+get_parameters+2CANY-method'></span><span id='topic+get_parameters+2Cpolr-method'></span><span id='topic+get_parameters+2Cmultinom-method'></span><span id='topic+get_parameters+2Cmi-method'></span><span id='topic+get_parameters+2Cmi_list-method'></span><span id='topic+get_parameters+2Cmissing_data.frame-method'></span><span id='topic+get_parameters+2Cmissing_variable-method'></span><span id='topic+hist+2Cmi-method'></span><span id='topic+hist+2Cmissing_variable-method'></span><span id='topic+hist+2Csemi-continuous-method'></span><span id='topic+hist+2Cbinary-method'></span><span id='topic+hist+2Ccategorical-method'></span><span id='topic+initialize+2Cmissing_variable-method'></span><span id='topic+image+2Cmi-method'></span><span id='topic+image+2Cmi_list-method'></span><span id='topic+image+2Cmdf_list-method'></span><span id='topic+image+2Cmissing_data.frame-method'></span><span id='topic+image+2CdgTMatrix-method'></span><span id='topic+mi+2Ccharacter+2Cmissing-method'></span><span id='topic+mi+2Cmissing_variable+2CANY-method'></span><span id='topic+mi+2Cmissing_variable+2Cmissing-method'></span><span id='topic+mi+2Csemi-continuous+2Cmissing-method'></span><span id='topic+mi+2Cbounded-continuous+2Cmissing-method'></span><span id='topic+mi+2Cbinary+2Cglm-method'></span><span id='topic+mi+2Cgrouped-binary+2Cclogit-method'></span><span id='topic+mi+2Ccontinuous+2Cglm-method'></span><span id='topic+mi+2Cbounded-continuous+2Cglm-method'></span><span id='topic+mi+2CSC_proportion+2Cbetareg-method'></span><span id='topic+mi+2Cproportion+2Cbetareg-method'></span><span id='topic+mi+2Cnonnegative-continuous+2Cglm-method'></span><span id='topic+mi+2Ccensored-continuous+2Cglm-method'></span><span id='topic+mi+2Csemi-continuous+2Cglm-method'></span><span id='topic+mi+2Ccategorical+2Cmissing-method'></span><span id='topic+mi+2Ccount+2Cglm-method'></span><span id='topic+mi+2Cdata.frame+2Cmissing-method'></span><span id='topic+mi+2Cirrelevant+2CANY-method'></span><span id='topic+mi+2Cinterval+2Cglm-method'></span><span id='topic+mi+2Cmdf_list+2Cmissing-method'></span><span id='topic+mi+2Cmi_list+2Cmissing-method'></span><span id='topic+mi+2Clist+2Cmissing-method'></span><span id='topic+mi+2Cmissing_data.frame+2Cmi-method'></span><span id='topic+mi+2Cmatrix+2Cmissing-method'></span><span id='topic+mi+2Cmi+2Cmissing-method'></span><span id='topic+mi+2Cby+2Cmissing-method'></span><span id='topic+mi+2Cmissing_variable+2CANY-method'></span><span id='topic+mi+2Cmissing_variable+2Cmissing-method'></span><span id='topic+mi+2Cnonnegative-continuous+2Cmissing-method'></span><span id='topic+mi+2Cordered-categorical+2Cpolr-method'></span><span id='topic+mi+2Cproportion+2Cglm-method'></span><span id='topic+mi+2Cunordered-categorical+2Cmultinom-method'></span><span id='topic+mi+2Cunordered-categorical+2CRNL-method'></span><span id='topic+mi+2Ccategorical+2Cmatrix-method'></span><span id='topic+missing_data.frame+2Cdata.frame-method'></span><span id='topic+missing_data.frame+2Clist-method'></span><span id='topic+missing_data.frame+2Cmatrix-method'></span><span id='topic+missing_variable+2CANY+2Ccharacter-method'></span><span id='topic+missing_variable+2CANY+2Cmissing-method'></span><span id='topic+betareg-class'></span><span id='topic+clogit-class'></span><span id='topic+mdf_list-class'></span><span id='topic+mi_list-class'></span><span id='topic+family-class'></span><span id='topic+multinom-class'></span><span id='topic+RNL-class'></span><span id='topic+plot+2Cmissing_data.frame+2Cmissing_variable-method'></span><span id='topic+plot+2Cmi_list+2CANY-method'></span><span id='topic+plot+2Callcategorical_missing_data.frame+2Cbinary-method'></span><span id='topic+plot+2Callcategorical_missing_data.frame+2Ccategorical-method'></span><span id='topic+change_family+2Cmissing_data.frame+2Ccharacter+2Ccharacter-method'></span><span id='topic+change_family+2Cmissing+2Cmissing_variable+2Cmissing-method'></span><span id='topic+change_family+2Cmissing_data.frame+2Ccharacter+2Cfamily-method'></span><span id='topic+change_family+2Cmissing_data.frame+2Ccharacter+2Clist-method'></span><span id='topic+change_family+2Cmissing_data.frame+2Clogical+2Ccharacter-method'></span><span id='topic+change_family+2Cmissing_data.frame+2Clogical+2Cfamily-method'></span><span id='topic+change_family+2Cmissing_data.frame+2Cnumeric+2Ccharacter-method'></span><span id='topic+change_family+2Cmissing_data.frame+2Cnumeric+2Cfamily-method'></span><span id='topic+change_family+2Cmissing_data.frame+2Cnumeric+2Clist-method'></span><span id='topic+change_imputation_method+2Cmissing_data.frame+2Ccharacter+2Ccharacter-method'></span><span id='topic+change_size+2Cmissing_data.frame+2Cnumeric-method'></span><span id='topic+change_transformation+2Cmissing+2Cmissing_variable+2Cfunction-method'></span><span id='topic+change_transformation+2Cmissing_data.frame+2Ccharacter+2Ccharacter-method'></span><span id='topic+change_transformation+2Cmissing_data.frame+2Cnumeric+2Ccharacter-method'></span><span id='topic+change_transformation+2Cmissing_data.frame+2Clogical+2Ccharacter-method'></span><span id='topic+change_type+2Cmissing_data.frame+2Ccharacter+2Ccharacter-method'></span><span id='topic+change_type+2Cmissing_data.frame+2Clogical+2Ccharacter-method'></span><span id='topic+change_type+2Cmissing_data.frame+2Cnumeric+2Ccharacter-method'></span><span id='topic+change+2Cmissing_data.frame+2CANY+2Cnumeric+2Cnumeric-method'></span><span id='topic+change+2Cmissing_data.frame+2CANY+2Clogical+2Cnumeric-method'></span><span id='topic+change+2Cmissing_data.frame+2CANY+2Ccharacter+2Cnumeric-method'></span><span id='topic+change+2Cmissing_data.frame+2CANY+2Clogical+2Ccharacter-method'></span><span id='topic+change+2Cmdf_list+2CANY+2CANY+2CANY-method'></span><span id='topic+coerce+2Cdata.frame+2Cmissing_data.frame-method'></span><span id='topic+coerce+2Cmatrix+2Cmissing_data.frame-method'></span><span id='topic+coerce+2Cmissing_data.frame+2Cdata.frame-method'></span><span id='topic+coerce+2Cmissing_data.frame+2Cmatrix-method'></span><span id='topic+complete+2Cmissing_data.frame+2Cinteger-method'></span><span id='topic+complete+2Cmi+2Cnumeric-method'></span><span id='topic+fit_model+2Cbinary+2Cmissing_data.frame-method'></span><span id='topic+fit_model+2Cgrouped-binary+2Cmissing_data.frame-method'></span><span id='topic+fit_model+2Ccount+2Cmissing_data.frame-method'></span><span id='topic+fit_model+2Cirrelevant+2Cmissing_data.frame-method'></span><span id='topic+fit_model+2Cinterval+2Cmissing_data.frame-method'></span><span id='topic+fit_model+2Cmissing_variable+2Cmissing_data.frame-method'></span><span id='topic+fit_model+2Cordered-categorical+2Cmissing_data.frame-method'></span><span id='topic+fit_model+2Cunordered-categorical+2Cmissing_data.frame-method'></span><span id='topic+fit_model+2Ccharacter+2Cmi-method'></span><span id='topic+fit_model+2Cmissing+2Cmi-method'></span><span id='topic+fit_model+2Cmissing_data.frame+2Cmissing_data.frame-method'></span><span id='topic+hist+2Cmissing_data.frame-method'></span><span id='topic+hist+2Cmdf_list-method'></span><span id='topic+hist+2Cmi_list-method'></span><span id='topic+initialize+2Cmissing_data.frame-method'></span><span id='topic+plot+2Cmissing_data.frame+2Cbinary-method'></span><span id='topic+plot+2Cmissing_data.frame+2Ccategorical-method'></span><span id='topic+plot+2Cmissing_data.frame+2Csemi-continuous-method'></span><span id='topic+plot+2Cmissing_data.frame+2Cmissing_variable-method'></span><span id='topic+plot+2Cmi+2Cmissing-method'></span><span id='topic+traceplot+2Cmi'></span><span id='topic+traceplot+2Cmi_list'></span><span id='topic+.prune'></span><span id='topic+.possible_missing_variable'></span>

<h3>Description</h3>

<p>These functions are not intended to be called directly. In the case of
methods, they documented elsewhere, either with the associated generic
function or with the class of the object that the method is defined for.
</p>

<hr>
<h2 id='mi2stata'>Exports completed data in Stata (.dta) or comma-separated (.csv) format</h2><span id='topic+mi2stata'></span>

<h3>Description</h3>

<p>This function exports completed data from an object of <code><a href="#topic+mi-class">mi-class</a></code> in which <code>m</code> completed 
<code><a href="base.html#topic+data.frame">data.frame</a></code>s are appended to the end of the raw data. Two additional variables are added which indicate the row number and distinguish the <code><a href="base.html#topic+data.frame">data.frame</a></code>s.  The outputed file is either Stata 
(.dta) or comma-separated (.csv) format, and can be easily registered in Stata as multiply imputed data.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mi2stata(imputations, m, file, missing.ind=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mi2stata_+3A_imputations">imputations</code></td>
<td>
<p>Object of <code><a href="#topic+mi-class">mi-class</a></code></p>
</td></tr>
<tr><td><code id="mi2stata_+3A_m">m</code></td>
<td>
<p>The number of completed datasets to append onto the raw data</p>
</td></tr>
<tr><td><code id="mi2stata_+3A_file">file</code></td>
<td>
<p>The filename, either a full path or relative to the working directory, where the file will be saved.  
Filenames must end in either '.dta' or '.csv'.  Files with names ending in '.dta' will be saved  
as a Stata data file, and files with names ending in '.csv' will be saved as a comma-separated file.</p>
</td></tr>
<tr><td><code id="mi2stata_+3A_missing.ind">missing.ind</code></td>
<td>
<p>If <code>TRUE</code>, includes a binary variable for each variable with <code><a href="base.html#topic+NA">NA</a></code> values,
indicating the observations which were originally missing. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mi2stata_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="foreign.html#topic+write.dta">write.dta</a></code> for Stata files, or to <code><a href="utils.html#topic+write.table">write.table</a></code>
for .csv files.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calls <code><a href="#topic+complete">complete</a></code> to construct <code>m</code> completed <code><a href="base.html#topic+data.frame">data.frame</a></code>s, and uses 
<code><a href="base.html#topic+rbind">rbind</a></code> to append them to the bottom of the raw data that still contains all of the missing values. 
Two new variables are added: <code>_mi</code>, which contains the observation numbers; and <code>_mj</code>, which indexes the
<code><a href="base.html#topic+data.frame">data.frame</a></code>s.
</p>
<p>To save a Stata .dta file, end the filename with '.dta'. To save a comma-separated file, end the filename with 
.csv'. Stata files are loaded into Stata using Stata's <code>use</code> command, and comma-separated files can be loaded
by typing <code>insheet using</code> <em>filename</em><code>, comma names clear</code>. Once the file is loaded into Stata, the
data must be registered as multiply imputed before any subsequent analyses can be performed. In Stata version 11 or
later, type <code>mi import mice</code> to register the data.  The <code>_mi</code> and <code>_mj</code> variables will be replaced
by variables named <code>_mi_id</code> and <code>_mi_m</code> respectively. In Stata version 10 or earlier, install the
<code>MIM</code> package by typing <code>findit mim</code> and installing package <code>st0139_1</code>.  Then the prefix <code>mim:</code>
must be added to any command using the multiply imputed data.
</p>
<p>Any observations which are unpossible (legitimately skipped, and are not imputed, see 
<code><a href="#topic+missing_variable">missing_variable</a></code>) will remain missing in the complete data, but will not be indicated as missing by these variables.  If there are
any unpossible values, missing indicators are included automatically.
</p>


<h3>Value</h3>

<p><code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao 
Yajima, Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+complete">complete</a></code>, <code><a href="#topic+mi">mi</a></code>, <code><a href="foreign.html#topic+write.dta">write.dta</a></code>, <code><a href="utils.html#topic+write.table">write.table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fn &lt;- paste(tempfile(), "dta", sep = ".")
if(!exists("imputations", env = .GlobalEnv)) {
  imputations &lt;- mi:::imputations # cached from example("mi-package")
}
mi2stata(imputations, m=5, file=fn , missing.ind=TRUE)
</code></pre>

<hr>
<h2 id='mipply'>Apply a Function to a Object of Class mi</h2><span id='topic+mipply'></span>

<h3>Description</h3>

<p>This function is a wrapper around <code><a href="base.html#topic+sapply">sapply</a></code> that is invoked on the
<code>data</code> slot of an object of <code><a href="#topic+mi-class">mi-class</a></code> and / or on an object
of <code><a href="#topic+missing_data.frame-class">missing_data.frame-class</a></code> after being coerced to a
<code><a href="base.html#topic+data.frame">data.frame</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mipply(X, FUN, ..., simplify = TRUE, USE.NAMES = TRUE, 
       columnwise = TRUE, to.matrix = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mipply_+3A_x">X</code></td>
<td>
<p>Object of <code><a href="#topic+mi-class">mi-class</a></code>, <code><a href="#topic+missing_data.frame-class">missing_data.frame-class</a></code>, 
<code><a href="#topic+missing_variable-class">missing_variable-class</a></code>, <code><a href="#topic+mi_list-class">mi_list-class</a></code>, or <code><a href="#topic+mdf_list-class">mdf_list-class</a></code>
</p>
</td></tr>
<tr><td><code id="mipply_+3A_fun">FUN</code></td>
<td>
<p>Function to call</p>
</td></tr>
<tr><td><code id="mipply_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>FUN</code>, currently broken
</p>
</td></tr>
<tr><td><code id="mipply_+3A_simplify">simplify</code></td>
<td>
<p>If <code>TRUE</code>, coerces result to a vector or matrix if possible
</p>
</td></tr>
<tr><td><code id="mipply_+3A_use.names">USE.NAMES</code></td>
<td>
<p>ignored but included for compatibility with <code><a href="base.html#topic+sapply">sapply</a></code>
</p>
</td></tr>
<tr><td><code id="mipply_+3A_columnwise">columnwise</code></td>
<td>
<p>logical indicating whether to invoke <code>FUN</code> on the columns
of a <code><a href="#topic+missing_data.frame">missing_data.frame</a></code> after coercing it to a <code><a href="base.html#topic+data.frame">data.frame</a></code>
or a <code><a href="base.html#topic+matrix">matrix</a></code> or to invoke <code>FUN</code> on the &ldquo;whole&rdquo; 
<code><a href="base.html#topic+data.frame">data.frame</a></code> or <code><a href="base.html#topic+matrix">matrix</a></code>
</p>
</td></tr>
<tr><td><code id="mipply_+3A_to.matrix">to.matrix</code></td>
<td>
<p>Logical indicating whether to coerce each <code><a href="#topic+missing_data.frame">missing_data.frame</a></code>
to a numeric <code><a href="base.html#topic+matrix">matrix</a></code> or to a <code><a href="base.html#topic+data.frame">data.frame</a></code>. The default is
<code>FALSE</code>, in which case the <code><a href="base.html#topic+data.frame">data.frame</a></code> will include <code><a href="base.html#topic+factor">factor</a></code>s
if any of the <code><a href="#topic+missing_variable">missing_variable</a></code>s inherit from <code><a href="#topic+categorical-class">categorical-class</a></code>
</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The <code>columnwise</code> and <code>to.matrix</code> arguments are the only additions to the argument list 
in <code><a href="base.html#topic+sapply">sapply</a></code>, see the Examples section for an illustration of their use. Note that 
functions such as <code><a href="base.html#topic+mean">mean</a></code> only accept <code><a href="base.html#topic+numeric">numeric</a></code> inputs, which can produce
errors or warnings when <code>to.matrix = FALSE</code>.
</p>


<h3>Value</h3>

<p>A list, vector, or matrix depending on the arguments
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+sapply">sapply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(!exists("imputations", env = .GlobalEnv)) {
  imputations &lt;- mi:::imputations # cached from example("mi-package")
}
round(mipply(imputations, mean, to.matrix = TRUE), 3)
mipply(imputations, summary, columnwise = FALSE)
</code></pre>

<hr>
<h2 id='multilevel_missing_data.frame'>Class &quot;multilevel_missing_data.frame&quot;</h2><span id='topic+multilevel_missing_data.frame'></span><span id='topic+multilevel_missing_data.frame-class'></span>

<h3>Description</h3>

<p>This class inherits from the <code><a href="#topic+missing_data.frame-class">missing_data.frame-class</a></code> but is customized for the situation
where the sample has a multilevel structure.
</p>


<h3>Details</h3>

<p>The <code><a href="#topic+fit_model-methods">fit_model-methods</a></code> for the multilevel_missing_data.frame class will, by default, utilize 
multilevel modeling techniques that shrink the estimated parameters for each group toward their global
means.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("multilevel_missing_data.frame", ...)</code>.
However, its users almost always will pass a <code><a href="base.html#topic+data.frame">data.frame</a></code> to the 
<code><a href="#topic+missing_data.frame">missing_data.frame</a></code> function and specify the <code>subclass</code> and <code>groups</code> arguments.
</p>


<h3>Slots</h3>

<p>The multilevel_missing_data.frame class inherits from the <code><a href="#topic+missing_data.frame-class">missing_data.frame-class</a></code> and
has two additional slots
</p>

<dl>
<dt>groups</dt><dd><p>Object of class <code><a href="base.html#topic+character">character</a></code> indicating which variables define the 
multilevel structure</p>
</dd>
<dt>mdf_list</dt><dd><p>Object of class <code>mdf_list</code> whose elements contain a <code><a href="#topic+missing_data.frame">missing_data.frame</a></code>
for each group. This slot is filled automatically by the <code><a href="methods.html#topic+initialize">initialize</a></code> method.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missing_data.frame">missing_data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Write example
</code></pre>

<hr>
<h2 id='multinomial'>The multinomial family</h2><span id='topic+multinomial'></span>

<h3>Description</h3>

<p>This function is a returns a <code><a href="stats.html#topic+family">family</a></code> and is a generalization of <code><a href="stats.html#topic+binomial">binomial</a></code>.
users would only need to call it when calling <code><a href="#topic+change">change</a></code> with 
<code>what = "family", to = multinomial(link = 'logit')</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multinomial(link = "logit")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multinomial_+3A_link">link</code></td>
<td>
<p>character string among those supported by <code><a href="stats.html#topic+binomial">binomial</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mostly cosmetic. The <code>family</code> slot for an object of 
<code><a href="#topic+unordered-categorical-class">unordered-categorical-class</a></code> must be <code>multinomial(link = 'logit')</code>. For
an object of <code><a href="#topic+ordered-categorical-class">ordered-categorical-class</a></code> but not its subclasses, the <code>family</code>
slot must be <code>multinomial()</code> but the link function can differ from its default (<code>"logit"</code>)
</p>


<h3>Value</h3>

<p>A <code><a href="stats.html#topic+family">family</a></code> object
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+family">family</a></code>, <code><a href="stats.html#topic+binomial">binomial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>multinomial()
</code></pre>

<hr>
<h2 id='nlsyV'>
National Longitudinal Survey of Youth Extract
</h2><span id='topic+nlsyV'></span>

<h3>Description</h3>

<p>This dataset pertains to children and their families in the United States and 
is intended to illustrate missing data issues. Note that although the original
data are longitudinal, this extract is not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(nlsyV)</code></pre>


<h3>Format</h3>

<p>A data frame with 400 randomly subsampled observations on the following 7 variables.
</p>

<dl>
<dt><code>ppvtr.36</code></dt><dd><p>a numeric vector with data on the Peabody Picture Vocabulary Test (Revised) 
administered at 36 months</p>
</dd>
<dt><code>first</code></dt><dd><p>indicator for whether child was first-born</p>
</dd>
<dt><code>b.marr</code></dt><dd><p>indicator for whether mother was married when child was born</p>
</dd>
<dt><code>income</code></dt><dd><p>a numeric vector with data on family income in year after the child was born</p>
</dd>
<dt><code>momage</code></dt><dd><p>a numeric vector with data on the age of the mother when the child was born</p>
</dd>
<dt><code>momed</code></dt><dd><p>educational status of mother when child was born (1 = less than high school, 
2 = high school graduate, 3 = some college, 4 = college graduate)</p>
</dd>
<dt><code>momrace</code></dt><dd><p>race of mother (1 = black, 2 = Hispanic, 3 = white)</p>
</dd>
</dl>

<p>Note that <b>momed</b> would typically be an ordered <code><a href="base.html#topic+factor">factor</a></code> while <b>momrace</b>
would typically be an unorderd <code><a href="base.html#topic+factor">factor</a></code> but both are <code><a href="base.html#topic+numeric">numeric</a></code> in this
<code><a href="base.html#topic+data.frame">data.frame</a></code> in order to illustrate the mechanism to <code><a href="#topic+change">change</a></code> the
type of a <code><a href="#topic+missing_variable">missing_variable</a></code>
</p>


<h3>Source</h3>

<p>National Longitudinal Survey of Youth, 1997, <a href="https://www.bls.gov/nls/nlsy97.htm">https://www.bls.gov/nls/nlsy97.htm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nlsyV)
summary(nlsyV)
</code></pre>

<hr>
<h2 id='positive-continuous-class'>Class &quot;positive-continuous&quot; and Inherited Classes</h2><span id='topic+positive-continuous-class'></span><span id='topic+proportion-class'></span>

<h3>Description</h3>

<p>The positive-continuous class inherits from the <code><a href="#topic+continuous-class">continuous-class</a></code> and is the parent of the proportion class.
In both cases, no observations can be zero, and in the case of the proportion class, no observations can be one. The 
<code><a href="#topic+nonnegative-continuous-class">nonnegative-continuous-class</a></code> and the <code><a href="#topic+SC_proportion-class">SC_proportion-class</a></code> are appropriate for those situations.
Aside from these facts, the rest of the 
documentation here is primarily directed toward developeRs.
</p>


<h3>Objects from the Classes</h3>

<p>Objects can be created that are of positive-continuous or proportion class via the
<code><a href="#topic+missing_variable">missing_variable</a></code> generic function by specifying <code>type = "positive-continuous"</code> or
<code>type = "proportion"</code>
</p>


<h3>Slots</h3>

<p>The default transformation for the positive-continuous class is the <code><a href="base.html#topic+log">log</a></code> function. The proportion class inherits 
from the positive-continuous class and has the identity transformation and the <code><a href="stats.html#topic+binomial">binomial</a></code> family as defaults, in
which case the <code><a href="#topic+fit_model-methods">fit_model-methods</a></code> call the <code><a href="betareg.html#topic+betareg">betareg</a></code> function in the <span class="pkg">betareg</span> package. 
Alternatively, the transformation could be an inverse CDF like the <code><a href="stats.html#topic+qnorm">qnorm</a></code> function and the family could be <code><a href="stats.html#topic+gaussian">gaussian</a></code>,
in which case the <code><a href="#topic+fit_model-methods">fit_model-methods</a></code> call the <code><a href="arm.html#topic+bayesglm">bayesglm</a></code> function in the <span class="pkg">arm</span> package.
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missing_variable">missing_variable</a></code>, <code><a href="#topic+continuous-class">continuous-class</a></code>, <code><a href="#topic+positive-continuous-class">positive-continuous-class</a></code>,
<code><a href="#topic+proportion-class">proportion-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># STEP 0: GET DATA
data(CHAIN, package = "mi")

# STEP 0.5 CREATE A missing_variable (you never need to actually do this)
healthy &lt;- missing_variable(CHAIN$healthy / 100, type = "proportion")
show(healthy)
</code></pre>

<hr>
<h2 id='rdata.frame'>Generate a random data.frame with tunable characteristics</h2><span id='topic+rdata.frame'></span>

<h3>Description</h3>

<p>This function generates a random <code><a href="base.html#topic+data.frame">data.frame</a></code> with a
missingness mechanism that is used to impose a missingness pattern. The primary
purpose of this function is for use in simulations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdata.frame(N = 1000, 
            restrictions = c("none", "MARish", "triangular", "stratified", "MCAR"),
            last_CPC = NA_real_, strong = FALSE, pr_miss = .25, Sigma = NULL, 
            alpha = NULL, experiment = FALSE, 
            treatment_cor = c(rep(0, n_full - 1), rep(NA, 2 * n_partial)),
            n_full = 1, n_partial = 1, n_cat = NULL,
            eta = 1, df = Inf, types = "continuous", estimate_CPCs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdata.frame_+3A_n">N</code></td>
<td>
<p>integer indicating the number of observations</p>
</td></tr>
<tr><td><code id="rdata.frame_+3A_restrictions">restrictions</code></td>
<td>
<p>character string indicating what restrictions to impose on
the the missing data mechansim, see the Details section</p>
</td></tr>
<tr><td><code id="rdata.frame_+3A_last_cpc">last_CPC</code></td>
<td>
<p>a numeric scalar between <code class="reqn">-1</code> and <code class="reqn">1</code> exclusive or 
<code>NA_real_</code> (the default). If not <code>NA_real_</code>, then this value will
be used to construct the correlation matrix from which the data are drawn.
This option is useful if restrictions is <code>"triangular"</code> or <code>"stratified"</code>,
in which case the degree to which <code>last_CPC</code> is not zero causes a violation of 
the Missing-At-Random assumption that is confined to the last of the partially 
observed variables</p>
</td></tr>
<tr><td><code id="rdata.frame_+3A_strong">strong</code></td>
<td>
<p>Integer among 0, 1, and 2 indicating how strong to
make the instruments with multiple partially observed variables,
in which case the missingness indicators for each partially observed variable
can be used as instruments when predicting missingness on other partially
observed variables. Only applies when <code>restrictions = "triangular"</code></p>
</td></tr>
<tr><td><code id="rdata.frame_+3A_pr_miss">pr_miss</code></td>
<td>
<p>numeric scalar on the (0,1) interval or vector
of length <code>n_partial</code> indicating the proportion of observations
that are missing on partially observed variables</p>
</td></tr>
<tr><td><code id="rdata.frame_+3A_sigma">Sigma</code></td>
<td>
<p>Either <code><a href="base.html#topic+NULL">NULL</a></code> (the default) or a correlation matrix
of appropriate order for the variables (including the missingness
indicators). By default, such a matrix is generated at random.</p>
</td></tr>
<tr><td><code id="rdata.frame_+3A_alpha">alpha</code></td>
<td>
<p>Either <code><a href="base.html#topic+NULL">NULL</a></code>, <code><a href="base.html#topic+NA">NA</a></code>, or a numeric
vector of appropriate length that governs the skew of a multivariate
skewed normal distribution; see <code><a href="sn.html#topic+rmsn">rmsn</a></code>. The appropriate
length is <code>n_full - 1 + 2 * n_partial</code> iff none of the variable types
is nominal. If some of the variable types are nominal, then the appropriate
length is <code>n_full - 1 + 2 * n_partial + sum(n_cat) - length(n_cat)</code>.
If <code><a href="base.html#topic+NULL">NULL</a></code>, <code>alpha</code> is taken to be zero, in which case the
data-generating process has no skew. If <code><a href="base.html#topic+NA">NA</a></code>, <code>alpha</code>
is drawn from <code><a href="stats.html#topic+rt">rt</a></code> with <code>df</code> degrees of freedom</p>
</td></tr>
<tr><td><code id="rdata.frame_+3A_experiment">experiment</code></td>
<td>
<p>logical indicating whether to simulate a randomized
experiment</p>
</td></tr>
<tr><td><code id="rdata.frame_+3A_treatment_cor">treatment_cor</code></td>
<td>
<p>Numeric vector of appropriate length indicating the
correlations between the treatment variable and the other variables, which
is only relevant if <code>experiment = TRUE</code>. The appropriate length is
<code>n_full - 1 + 2 * n_partial</code> iff none of the variable types is nominal.
If some of the variable types are nominal, then the appropriate length is
<code>n_full - 1 + 2 * n_partial + sum(n_cat) - length(n_cat)</code>. If
treatment_cor is of length one and is zero, then it will be recylced to
the appropriate length. The treatment variable should be uncorrelated with
intended covariates and uncorrelated with missingness on intended
covariates. If any elements of treatment_cor are <code><a href="base.html#topic+NA">NA</a></code>, then
those elements will be replaced with random draws. Note that the order of
the random variables is: all fully observed variables,all partially observed
but not nominal variables, all partially observed nominal variables, all
missingness indicators for partially observed variables.</p>
</td></tr>
<tr><td><code id="rdata.frame_+3A_n_full">n_full</code></td>
<td>
<p>integer indicating the number of fully observed variables</p>
</td></tr>
<tr><td><code id="rdata.frame_+3A_n_partial">n_partial</code></td>
<td>
<p>integer indicating the number of partially observed
variables</p>
</td></tr>
<tr><td><code id="rdata.frame_+3A_n_cat">n_cat</code></td>
<td>
<p>Either <code><a href="base.html#topic+NULL">NULL</a></code> or an integer vector (possibly of
length one) indicating the number of categories in each partially observed
nominal or ordinal variable; see the Details section</p>
</td></tr>
<tr><td><code id="rdata.frame_+3A_eta">eta</code></td>
<td>
<p>Positive numeric scalar which serves as a hyperparameter in the
data-generating process. The default value of 1 implies that the correlation
matrix among the variables is jointly uniformally distributed, using
essentially the same logic as in the <span class="pkg">clusterGeneration</span> package</p>
</td></tr>
<tr><td><code id="rdata.frame_+3A_df">df</code></td>
<td>
<p>positive numeric scalar indicating the degress of freedom for the
(possibly skewed) multivariate t distribution, which defaults to
<code><a href="base.html#topic+Inf">Inf</a></code> implying a (possibly skewed) multivariate normal 
distribution</p>
</td></tr>
<tr><td><code id="rdata.frame_+3A_types">types</code></td>
<td>
<p>a character vector (possibly of length one, in which case it
is recycled) indicating the type for each fully observed and partially
observed variable, which currently can be among <code>"continuous"</code>,
<code>"count"</code>, <code>"binary"</code>, <code>"treatment"</code> (which is binary),
<code>"ordinal"</code>, <code>"nominal"</code>, <code>"proportion"</code>, <code>"positive"</code>.
See the Details section. Unique abbreviations are acceptable.</p>
</td></tr>
<tr><td><code id="rdata.frame_+3A_estimate_cpcs">estimate_CPCs</code></td>
<td>
<p>A logical indicating whether the canonical partial correlations
between the partially observed variables and the latent missingnesses should
be estimated. The default is <code>TRUE</code> but considerable wall time can be saved
by switching it to <code>FALSE</code> when there are many partially observed variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, the correlation matrix among the variables and missingness indicators
is intended to be close to uniform, although it is often not possible to achieve
exactly. If <code>restrictions = "none"</code>, the data will be Not Missing At Random
(NMAR). If <code>restrictions = "MARish"</code>, the departure from Missing At Random
(MAR) will be minimized via a call to <code><a href="stats.html#topic+optim">optim</a></code>, but generally will
not fully achieve MAR. If <code>restrictions = "triangular"</code>, the MAR assumption
will hold but the missingness of each partially observed variable will only 
depend on the fully observed variables and the other latent missingness indicators.
If <code>restrictions = "stratified"</code>, the MAR assumption will hold but the
missingness of each partially observed variable will only depend on the fully
observed variables. If <code>restrictions = "MCAR"</code>, the Missing Completely At
Random (MCAR) assumption holds, which is much more restrictive than MAR.
</p>
<p>There are some rules to follow, particularly when specifying <code>types</code>.
First, if <code>experiment = TRUE</code>, there must be exactly one treatment
variable (taken to be binary) and it must come first to ensure that the
elements of <code>treatment_cor</code> are handled properly. Second, if there are any
partially observed nominal variables, they must come last; this is to ensure
that they are conditionally uncorrelated with each other. Third, fully observed
nominal variables are not supported, but they can be made into ordinal variables
and then converted to nominal after the fact. Fourth, including both ordinal and
nominal partially observed variables is not supported yet, Finally, if any
variable is specified as a count, it will not be exactly consistent with the
data-generating process. Essentially, a count variable is constructed from a
continuous variable by evaluating <code><a href="stats.html#topic+pt">pt</a></code> on it and passing that to
<code><a href="stats.html#topic+qpois">qpois</a></code> with an intensity parameter of 5. The other non-continuous
variables are constructed via some transformation or discretization of a continuous
variable.
</p>
<p>If some partially observed variables are either ordinal or nominal (but not both), 
then the <code>n_cat</code> argument governs how many categories there are. If <code>n_cat</code>
is <code>NULL</code>, then the number of categories defaults to three. If
<code>n_cat</code> has length one, then that number of categories will be used for all
categorical variables but must be greater than two. Otherwise, the length of 
<code>n_cat</code> must match the number of partially observed categorical variables and
the number of categories for the <code class="reqn">i</code>th such variable will be the <code class="reqn">i</code>th element
of <code>n_cat</code>.
</p>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ol>
<li><p>true a <code><a href="base.html#topic+data.frame">data.frame</a></code> containing no <code><a href="base.html#topic+NA">NA</a></code> values
</p>
</li>
<li><p>obs a <code><a href="base.html#topic+data.frame">data.frame</a></code> derived from the previous with some
<code><a href="base.html#topic+NA">NA</a></code> values that represents a dataset that could be observed
</p>
</li>
<li><p>empirical_CPCs a numeric vector of empirical Canonical Partial
Correlations, which should differ only randomly from zero iff
<code>MAR = TRUE</code> and the data-generating process is multivariate normal
</p>
</li>
<li><p>L a Cholesky factor of the correlation matrix used to generate the
true data
</p>
</li></ol>

<p>In addition, if <code>alpha</code> is not <code><a href="base.html#topic+NULL">NULL</a></code>, then the following
elements are also included:
</p>

<ol>
<li><p>alpha the <code>alpha</code> vector utilized
</p>
</li>
<li><p>sn_skewness the skewness of the multivariate skewed normal distribution
in the population; note that this value is only an approximation of the
skewness when <code>df &lt; Inf</code>
</p>
</li>
<li><p>sn_kurtosis the kurtosis of the multivariate skewed normal distribution
in the population; note that this value is only an approximation of the
kurtosis when <code>df &lt; Inf</code>
</p>
</li></ol>



<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung
Su, Masanao Yajima, Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+data.frame">data.frame</a></code>, <code><a href="#topic+missing_data.frame">missing_data.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdf &lt;- rdata.frame(n_partial = 2, df = 5, alpha = rnorm(5))
print(rdf$empirical_CPCs) # not zero
rdf &lt;- rdata.frame(n_partial = 2, restrictions = "triangular", alpha = NA)
print(rdf$empirical_CPCs) # only randomly different from zero
print(rdf$L == 0) # some are exactly zero by construction
mdf &lt;- missing_data.frame(rdf$obs)
show(mdf)
hist(mdf)
image(mdf)
# a randomized experiment
rdf &lt;- rdata.frame(n_full = 2, n_partial = 2, 
                   restrictions = "triangular", experiment = TRUE,
                   types = c("t", "ord", "con", "pos"),
                   treatment_cor = c(0, 0, NA, 0, NA))
Sigma &lt;- tcrossprod(rdf$L)
rownames(Sigma) &lt;- colnames(Sigma) &lt;- c("treatment", "X_2", "y_1", "Y_2",
                                        "missing_y_1", "missing_Y_2")
print(round(Sigma, 3))
</code></pre>

<hr>
<h2 id='semi-continuous-class'>Class &quot;semi-continuous&quot; and Inherited Classes</h2><span id='topic+semi-continuous'></span><span id='topic+semi-continuous-class'></span><span id='topic+semi-continuous'></span><span id='topic+nonnegative-continuous-class'></span><span id='topic+nonnegative-continuous'></span><span id='topic+SC_proportion-class'></span><span id='topic+SC_proportion'></span>

<h3>Description</h3>

<p>The <code>semi-continuous</code> class inherits from the <code><a href="#topic+continuous-class">continuous-class</a></code> and is the parent of the <code>nonnegative-continuous</code>
class, which in turn is the parent of the <code>SC_proportion class</code> for semi-continuous variables. A semi-continuous variable has support on one or more point
masses and a continuous interval. The <code>semi-continuous</code> class differs from the <code><a href="#topic+censored-continuous-class">censored-continuous-class</a></code> and
the <code><a href="#topic+truncated-continuous-class">truncated-continuous-class</a></code> in that observations that fall on the point masses are bonafide data, rather than
indicators of censoring or truncation. If there are no observations that fall on a point mass, then either the 
<code><a href="#topic+continuous-class">continuous-class</a></code> or one of its other subclasses should be used. Aside from these facts, the rest of the 
documentation here is primarily directed toward developers.
</p>


<h3>Objects from the Classes</h3>

<p>Objects can be created that are of <code>semi-continuous</code>, <code>nonnegative-continuous</code>, or
<code>SC_proportion</code> class via the <code><a href="#topic+missing_variable">missing_variable</a></code> generic function by specifying <code>type = "semi-continuous"</code> 
<code>type = "nonnegative-continuous"</code>, <code>type = "SC_proportion"</code>.
</p>


<h3>Slots</h3>

<p>The semi-continuous class inherits from the continuous class and is intended for variables that, for
example have a point mass at certain points and are continuous in between. Thus, its default transformation
is the identity transformation, which is to say no transformation in practice.
It has one additional slot.
</p>

<dl>
<dt>indicator</dt><dd><p>Object of class <code>"ordered-categorical"</code> that indicates whether an observed 
value falls on a point mass or the continuous interval in between. By convention, zero signifies an
observation that falls within the continuous interval</p>
</dd>
</dl>

<p>At the moment, there are no methods for the semi-continuous class. However, the basic approach to modeling a semi-continuous
variable has two steps. First, the <b>indicator</b> is modeled using the methods that are defined for it and its missing values
are imputed. Second, the continuous part of the semi-continuous variable is modeled using the same techniques that are used
when modeling continuous variables. Note that in the second step, only a subset of the observations are modeled, although this
subset possibly includes values that were originally missing in which case they are imputed.
</p>
<p>The nonnegative-continuous class inherits from the semi-continuous class,  which has its point mass at zero and 
is continuous over the positive real line. By default, the transformation for the positive part of a 
nonnegative-continuuos variable is <code>log(y + a)</code>, where <code>a</code> is a small constant determined by the 
observed data. If a variable is strictly positive, the <code><a href="#topic+positive-continuous-class">positive-continuous-class</a></code> should be used instead. 
</p>
<p>The SC_proportion class inherits from the nonnegative-continuous class. It has no additional slots, and the only supported 
transformation function is the <code>(y * (n - 1) + .5) / n</code> function. Its default <code><a href="#topic+fit_model">fit_model</a></code> method is a 
wrapper for the <code><a href="betareg.html#topic+betareg">betareg</a></code> function in the <span class="pkg">betareg</span> package. Its <b>family</b> must be
<code><a href="stats.html#topic+binomial">binomial</a></code> so that its <code>link</code> function can be passed to <code><a href="betareg.html#topic+betareg">betareg</a></code>
If the observed values fall strictly on the open unit interval, the <code><a href="#topic+proportion-class">proportion-class</a></code> should be used instead.
</p>


<h3>Author(s)</h3>

<p>Ben Goodrich and Jonathan Kropko, for this version, based on earlier versions written by Yu-Sung Su, Masanao Yajima,
Maria Grazia Pittau, Jennifer Hill, and Andrew Gelman.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+missing_variable">missing_variable</a></code>, <code><a href="#topic+continuous-class">continuous-class</a></code>, <code><a href="#topic+positive-continuous-class">positive-continuous-class</a></code>,
<code><a href="#topic+proportion-class">proportion-class</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># STEP 0: GET DATA
data(nlsyV, package = "mi")

# STEP 0.5 CREATE A missing_variable (you never need to actually do this)
income &lt;- missing_variable(nlsyV$income, type = "nonnegative-continuous")
show(income)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
