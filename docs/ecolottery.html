<!DOCTYPE html><html><head><title>Help for package ecolottery</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ecolottery}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abund'>
<p>Compute absolute and relative abundances in the local community and the reference pool</p></a></li>
<li><a href='#coalesc'>
<p>Coalescent-based simulation of ecological communities undergoing both neutral and niche-base dynamics</p></a></li>
<li><a href='#coalesc_abc'>
<p>Estimation of neutral and non-neutral parameters of community assembly using</p>
Approximate Bayesian Computation (ABC)</a></li>
<li><a href='#ecolottery-package'>
<p>Coalescent-Based Simulation of Ecological Communities</p></a></li>
<li><a href='#forward'>
<p>Simulation of neutral and niche-based community dynamics forward in time</p></a></li>
<li><a href='#plot_comm'>
<p>Regional vs. Local trait distributions of abundances</p></a></li>
<li><a href='#tcor'>
<p>Generates Correlated Traits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Coalescent-Based Simulation of Ecological Communities</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/frmunoz/ecolottery">https://github.com/frmunoz/ecolottery</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/frmunoz/ecolottery/issues">https://github.com/frmunoz/ecolottery/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>abc, stats, graphics, ggplot2, grDevices, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ape, changepoint, knitr, picante, rmarkdown, testthat, untb,
vegan</td>
</tr>
<tr>
<td>Description:</td>
<td>Coalescent-Based Simulation of Ecological Communities as proposed
    by Munoz et al. (2017) &lt;<a href="https://doi.org/10.13140%2FRG.2.2.31737.26728">doi:10.13140/RG.2.2.31737.26728</a>&gt;. The package includes
    a tool for estimating parameters of community assembly by using Approximate 
    Bayesian Computation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-07-03 10:31:38 UTC; munoz</td>
</tr>
<tr>
<td>Author:</td>
<td>François Munoz [aut, cre],
  Matthias Grenié [aut],
  Pierre Denelle [aut],
  Adrien Taudière [ctb],
  Fabien Laroche [ctb],
  Caroline Tucker [ctb],
  Cyrille Violle [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>François Munoz &lt;francois.munoz@hotmail.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-07-03 11:01:29 UTC</td>
</tr>
</table>
<hr>
<h2 id='abund'>
Compute absolute and relative abundances in the local community and the reference pool
</h2><span id='topic+abund'></span>

<h3>Description</h3>

<p>Compute the abundances and relative abundances of species in simulated
communities and in the corresponding species pools. The input must be an output of
either <code><a href="#topic+coalesc">coalesc</a></code> or the <code><a href="#topic+forward">forward</a></code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abund(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abund_+3A_x">x</code></td>
<td>

<p>a list including the species pool composition (<code>x$pool</code>) and the local
community composition (<code>x$com</code>)
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>pool</code></td>
<td>

<p>species abundances and relative abundances in the reference pool
</p>
</td></tr>
<tr><td><code>com</code></td>
<td>

<p>species abundances and relative abundances in the local community
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>F. Munoz, P. Denelle and M. Grenie
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation of a neutral community including 500 individuals
J &lt;- 500; theta &lt;- 50; m &lt;- 0.05;
comm1a &lt;- coalesc(J, m, theta) 
abund1a &lt;- abund(comm1a) 
  
# Log-series distribution of regional abundances
fit &lt;- vegan::fisherfit(abund1a$pool$ab)
freq &lt;- as.numeric(names(fit$fisher))
plot(log(freq), fit$fisher,
     xlab = "Frequency (log)",
     ylab = "Species", type = "n")
rect(log(freq - 0.5), 0, log(freq + 0.5), fit$fisher, col="skyblue")

alpha &lt;- fit$estimate
k &lt;- fit$nuisance

curve(alpha * k^exp(x) / exp(x), log(0.5), max(log(freq)),
      col = "red", lwd = 2, add = TRUE)

# Relationship between local and regional abundances
par(mfrow=c(1, 2))
plot(abund1a$pool[rownames(abund1a$com), "relab"],
  abund1a$com$relab,
  main = "m = 0.05",
  xlab = "Regional abundance",
  ylab = "Local abundance",
  log = "xy")
abline(0,1)

# With higher immigration rate
m &lt;- 0.95
comm1b &lt;- coalesc(J, m, theta) 
abund1b &lt;- abund(comm1b) 
plot(abund1b$pool[rownames(abund1b$com),"relab"],
  abund1b$com$relab,
  main = "m = 0.95",
  xlab = "Regional abundance",
  ylab = "Local abundance",
  log = "xy")
abline(0,1)
</code></pre>

<hr>
<h2 id='coalesc'>
Coalescent-based simulation of ecological communities undergoing both neutral and niche-base dynamics
</h2><span id='topic+coalesc'></span>

<h3>Description</h3>

<p>Simulates the composition of a community based on immigration from a regional pool, habitat filtering depending on local environment and species traits, and local birth-death stochastic dynamics. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coalesc(J, m = 1, theta = NULL, filt = NULL, pool = NULL, traits = NULL, 
        Jpool = 50 * J, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coalesc_+3A_j">J</code></td>
<td>

<p>number of individuals in the local community.
</p>
</td></tr>
<tr><td><code id="coalesc_+3A_m">m</code></td>
<td>

<p>migration rate (if <code>m = 1</code> the community is a subsample of the regional pool).
</p>
</td></tr>
<tr><td><code id="coalesc_+3A_theta">theta</code></td>
<td>

<p>parameter of neutral dynamics in the regional pool (used only if <code>pool=NULL</code>), it is the &ldquo;fundamental biodiversity number&rdquo; (<code class="reqn">\theta</code>).
</p>
</td></tr>
<tr><td><code id="coalesc_+3A_filt">filt</code></td>
<td>

<p>a function representing the effect of local habitat filtering. For a given trait value <code>t</code>, <code>filt(t)</code> represents the probability that an individual with trait <code>t</code> enters the local community. If <code>filt = NULL</code>,  <code>coalesc()</code> provides a neutral community.
</p>
</td></tr>
<tr><td><code id="coalesc_+3A_pool">pool</code></td>
<td>

<p>the regional pool of species providing immigrants to the local community. It should include the label of individual on first column, and of its species on second column. If <code>pool = NULL</code>, the pool is simulated as a metacommunity at speciation-drift equilibrium, based on parameter <code>theta</code>. The provided <code>pool</code> can contain trait values for each individuals in a third column.
</p>
</td></tr>
<tr><td><code id="coalesc_+3A_traits">traits</code></td>
<td>

<p>a matrix or data.frame including one or several traits on columns. A unique trait value is assigned to each species in the regional pool. If <code>traits = NULL</code>, a random trait value is given to species of the regional pool, from a uniform distribution between 0 and 1.
</p>
</td></tr>
<tr><td><code id="coalesc_+3A_jpool">Jpool</code></td>
<td>

<p>if <code>pool = NULL</code>, it is the number of individuals to be simulated in the regional pool.
</p>
</td></tr>
<tr><td><code id="coalesc_+3A_verbose">verbose</code></td>
<td>

<p>if <code>verbose = TRUE</code>, functions returns a lot of outputs about parameters, species pool and environmental filter.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coalescent-based simulation of a community of size <code>J</code>. This generic function can simulate a neutral community (if <code>filt = NULL</code>) or a community undergoing both neutral and niche-based dynamics. In the latter case, <code>filt(t)</code> represents the relative ability of immigrants with trait values <code>t</code> in the regional pool to enter the community.
</p>


<h3>Value</h3>

<table>
<tr><td><code>com</code></td>
<td>

<p>a data.frame of simulated individuals, with the label of ancestor individual in the regional pool on first column (as in first column of pool), species label on second column (as in second column of pool), and species trait (as in third column of pool).
<strong>Not provided if <code>m = 1</code> and <code>filt = NULL</code>: in this case the function provides a sample of the regional pool.</strong></p>
</td></tr>
<tr><td><code>pool</code></td>
<td>

<p>a data.frame of the individuals of the regional source pool, with the label of ancestor individual in the regional pool on first column (as in first column of input <code>pool</code>), species label on second column (as in second column of input <code>pool</code>), and species trait (as in third column of input <code>pool</code>).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>F. Munoz
</p>


<h3>References</h3>

<p>Hurtt, G. C. and S. W. Pacala (1995). &quot;The consequences of recruitment limitation: reconciling chance, history and competitive differences between plants.&quot; Journal of Theoretical Biology 176(1): 1-12.
</p>
<p>Gravel, D., C. D. Canham, M. Beaudet and C. Messier (2006). &quot;Reconciling niche and neutrality: the continuum hypothesis.&quot; Ecology Letters 9(4): 399-409.
</p>
<p>Munoz, F., P. Couteron, B. R. Ramesh and R. S. Etienne (2007). &quot;Estimating parameters of neutral communities: from one Single Large to Several Small samples.&quot; Ecology 88(10): 2482-2488.
</p>
<p>Munoz, F., B. R. Ramesh and P. Couteron (2014). &quot;How do habitat filtering and niche conservatism affect community composition at different taxonomic resolutions?&quot; Ecology 95(8): 2179-2191. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation of a neutral community including 100 individuals
J &lt;- 500; theta &lt;- 50; m &lt;- 0.1
comm1 &lt;- coalesc(J, m, theta) 
# Regional and local trait distributions
plot_comm(comm1)
 
# Define a regional pool of species with equal abundances
pool &lt;- cbind(1:10000, rep(1:500, 20), rep(NA, 10000))
# Uniform distribution of trait values
t.sp &lt;- runif(500)
# No intraspecific variation
pool[,3] &lt;- t.sp[pool[,2]]
# Generate a neutral community drawn from the pool
comm2&lt;- coalesc(J, m, pool = pool) 
plot_comm(comm2)

# Directional habitat filtering toward t = 0
comm3 &lt;- coalesc(J, m, filt = function(x) 1 - x, pool = pool)
# Regional and local trait distributions
plot_comm(comm3)

# Function for environmental filtering
sigma &lt;- 0.1
filt_gaussian &lt;- function(t, x) exp(-(x - t)^2/(2*sigma^2))

# Stabilizing habitat filtering around t = 0.1
comm4a &lt;- coalesc(J, m, filt = function(x) filt_gaussian(0.1, x), pool = pool)
plot_comm(comm4a)
# Stabilizing habitat filtering around t = 0.5
comm4b &lt;- coalesc(J, m, theta, filt = function(x) filt_gaussian(0.5, x),
                  pool = pool)
plot_comm(comm4b)
# Stabilizing habitat filtering around t = 0.9
comm4c &lt;- coalesc(J, m, theta, filt = function(x) filt_gaussian(0.9, x),
                  pool = pool)
plot_comm(comm4c)

# Mean trait values in communities reflect the influence of habitat filtering
mean(comm4a$com[, 3])
mean(comm4b$com[, 3])
mean(comm4c$com[, 3])

# Disruptive habitat filtering around t = 0.5
comm5 &lt;- coalesc(J, m, filt = function(x) abs(0.5 - x), pool = pool)
plot_comm(comm5)

# Multi-modal habitat filtering 
t.sp &lt;- rnorm(500)
pool[, 3] &lt;- t.sp[pool[,2]]
comm6 &lt;- coalesc(J, m, filt = function(x) sin(3*x) + 1, pool = pool)
plot_comm(comm6)

</code></pre>

<hr>
<h2 id='coalesc_abc'>
Estimation of neutral and non-neutral parameters of community assembly using
Approximate Bayesian Computation (ABC)
</h2><span id='topic+coalesc_abc'></span><span id='topic+do.simul'></span>

<h3>Description</h3>

<p>Estimates parameters of neutral migration-drift dynamics (through migration
rate m and parameters of environmental filtering (through a filtering function
<code>filt.abc()</code>) from the composition of a local community and the related
regional pool. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  coalesc_abc(comm.obs, pool = NULL, multi = "single", traits = NULL,
              f.sumstats, filt.abc = NULL, params = NULL, 
              theta.max = NULL, nb.samp = 10^6, parallel = TRUE,
              tol = NULL, pkg = NULL, method="rejection")
  do.simul(J, pool = NULL, multi = "single", nb.com = NULL, 
              traits = NULL, f.sumstats = NULL, filt.abc = NULL,
              params, theta.max = NULL, nb.samp = 10^6, 
              parallel = TRUE, tol = NULL, pkg = NULL,
              method = "rejection")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coalesc_abc_+3A_comm.obs">comm.obs</code></td>
<td>

<p>the observed community composition. If <code>multi = FALSE</code> (default),
should be a matrix or data.frame of individuals on rows with their
individual id (first column), and species id (second column).
</p>
</td></tr>
<tr><td><code id="coalesc_abc_+3A_pool">pool</code></td>
<td>

<p>composition of the regional pool to which the local community is
hypothesized to be related through migration dynamics with possible
environmental filtering. Should be a matrix of individuals on rows with
their individual id (first column), species id (second column), and
(optionally) the trait values of the individuals.
</p>
</td></tr>
<tr><td><code id="coalesc_abc_+3A_multi">multi</code></td>
<td>

<p>structure of the community inputs:
</p>

<ul>
<li><p> if <code>multi = "single"</code>, <code>comm.obs</code> contains a single
community
</p>
</li>
<li><p> if <code>multi = "tab"</code>, the user provides a site-species matrix
(<strong>sites in rows and species in columns</strong>)
</p>
</li>
<li><p> if <code>multi = "seqcom"</code>, <code>comm.obs</code> contains a list of
communities
</p>
</li></ul>

</td></tr>
<tr><td><code id="coalesc_abc_+3A_traits">traits</code></td>
<td>

<p>the trait values of species in the regional pool. It is used if trait
information is not provided in <code>pool</code>. In this case, intraspecific
trait variation is assumed to be null.
</p>
</td></tr>
<tr><td><code id="coalesc_abc_+3A_f.sumstats">f.sumstats</code></td>
<td>

<p>a function allowing to calculate the summary statistics of local community
composition. Will be used to compare observed and simulated community
composition in the ABC estimation. It should take a community as input and
output a list of summary statistics.
</p>
</td></tr>
<tr><td><code id="coalesc_abc_+3A_filt.abc">filt.abc</code></td>
<td>

<p>the hypothesized environmental filtering function. It is a function of
individual trait values and additional parameters to be estimated.
</p>
</td></tr>
<tr><td><code id="coalesc_abc_+3A_params">params</code></td>
<td>

<p>a matrix of the bounds of the parameters used in <code>filt.abc</code>. The row
names of <code>params</code> provide the parameter names used in ABC calculation
and output. First column contains minimum values and second column contains
maximum values.
</p>
</td></tr>
<tr><td><code id="coalesc_abc_+3A_theta.max">theta.max</code></td>
<td>

<p>if <code>pool = NULL</code>, regional abundances will be simulated following a
log-series distribution. The function will estimate the <code>theta</code>
parameter of this distribution. <code>theta.max</code> then provides the upper
bound for this estimation.
</p>
</td></tr>
<tr><td><code id="coalesc_abc_+3A_nb.samp">nb.samp</code></td>
<td>

<p>the number of parameter values to be sampled in ABC calculation. Random
values of parameters of environmental filtering (see <code>filt.abc</code> and
<code>params</code>) and of migration (denoted as <code>m</code>) are drawn from a
uniform distribution between minimum and maximum values provided in
<code>params</code> (and between 0 and 1 for m).
</p>
</td></tr>
<tr><td><code id="coalesc_abc_+3A_parallel">parallel</code></td>
<td>

<p>boolean. If <code>parallel = TRUE</code>, the function will perform parallel
processing using the <code><a href="parallel.html#topic+parLapply">parLapply()</a></code> function of
package <code>parallel</code>.
</p>
</td></tr>
<tr><td><code id="coalesc_abc_+3A_tol">tol</code></td>
<td>

<p>the tolerance value used in ABC estimation (see help in
<code><a href="HH.html#topic+abc">abc()</a></code> function of package <code>abc</code> for further
information).
</p>
</td></tr>
<tr><td><code id="coalesc_abc_+3A_pkg">pkg</code></td>
<td>

<p>packages needed for calculation of <code>filt.abc</code> and/or <code>f.sumstats</code>.
</p>
</td></tr>
<tr><td><code id="coalesc_abc_+3A_method">method</code></td>
<td>

<p>the method to be used in ABC estimation (see help on
<code><a href="HH.html#topic+abc">abc()</a></code> function  of package <code>abc</code> for further
information).
</p>
</td></tr>
<tr><td><code id="coalesc_abc_+3A_j">J</code></td>
<td>

<p>local community size.
</p>
</td></tr>
<tr><td><code id="coalesc_abc_+3A_nb.com">nb.com</code></td>
<td>

<p>number of communities.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>coalesc_abc()</code> performs ABC estimation for one (if <code>multi = FALSE</code>,
default) or several communities (if <code>multi = TRUE</code>) related to the same
regional pool.
</p>
<p><code>do.simul()</code> provides the simulated communities used in ABC estimation,
and is not intended to be used directly.
</p>


<h3>Value</h3>

<table>
<tr><td><code>par</code></td>
<td>

<p>parameter values used in simulations.
</p>
</td></tr>
<tr><td><code>obs</code></td>
<td>

<p>observed summary statistics.
</p>
</td></tr>
<tr><td><code>obs.scaled</code></td>
<td>

<p>observed summary statistics standardized according to the mean and standard
deviation of simulated values.
</p>
</td></tr>
<tr><td><code>ss</code></td>
<td>

<p>standardized summary statistics of the communities simulated with parameter
values listed in <code>par</code>.
</p>
</td></tr>
<tr><td><code>abc</code></td>
<td>

<p>a single (if <code>multi = FALSE</code>, default) or a list of abc objects
including ABC estimation information for each community provided in input
(<code>comm.obs</code>).
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>F. Munoz
</p>


<h3>References</h3>

<p>Jabot, F., and J. Chave. 2009. Inferring the parameters of the neutral theory
of biodiversity using phylogenetic information and implications for tropical
forests. Ecology Letters 12:239-248.
</p>
<p>Csillery, K., M. G. B. Blum, O. E. Gaggiotti, and O. Francois. 2010.
Approximate Bayesian computation (ABC) in practice. Trends in Ecology &amp;
Evolution 25:410-418.
</p>
<p>Csillery, K., O. Francois, and M. G. Blum. 2012. abc: an R package for
Approximate Bayesian Computation (ABC). Methods in Ecology and Evolution
3:475-479.
</p>


<h3>See Also</h3>

<p><code><a href="HH.html#topic+abc">abc()</a></code> in <code>abc</code> package,
<code><a href="parallel.html#topic+parLapply">parLapply()</a></code> in <code>parallel</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Trait-dependent filtering function
filt_gaussian &lt;- function(t, params) exp(-(t-params[1])^2/(2*params[2]^2))

# Definition of parameters and their range
params &lt;- data.frame(rbind(c(0, 1), c(0.05, 1)))
row.names(params) &lt;- c("topt", "sigmaopt")
# Number of values to sample in prior distributions
nb.samp &lt;- 10^6 # Should be large

## Not run: 
# Basic summary statistics
f.sumstats &lt;- function(com) array(dimnames=list(c("cwm", "cwv", "cws",
                                                  "cwk", "S", "Es")),
                                  c(mean(com[,3]), var(com[,3]), 
                                    e1071::skewness(com[,3]),  
                                    e1071::kurtosis(com[,3]),
                                    vegan::specnumber(table(com[,2])),
                                    vegan::diversity(table(com[,2]))))

# An observed community is here simulated (known parameters)
comm &lt;- coalesc(J = 400, m = 0.5, theta = 50,
                filt = function(x) filt_gaussian(x, c(0.2, 0.1)))

# ABC estimation of the parameters based on observed community composition 
## Warning: this function may take a while
res &lt;- coalesc_abc(comm$com, comm$pool, f.sumstats = f.sumstats,
                   filt.abc = filt_gaussian, params = params, 
                   nb.samp = nb.samp, parallel = TRUE, 
                   pkg = c("e1071","vegan"), method = "neuralnet")
plot(res$abc, param = res$par)
hist(res$abc)

# Cross validation
## Warning: this function is slow
res$cv &lt;- abc::cv4abc(param = res$par, sumstat = res$ss, nval = 1000,
                      tols = c(0.01, 0.1, 1), method = "neuralnet")
plot(res$cv)

# Multiple community option
# When the input is a site-species matrix, use argument multi="tab"
# See vignette Barro_Colorado for more details

# When the input is a list of communities, use argument multi="seqcom"
comm.obs &lt;- list()

comm.obs[[1]] &lt;- cbind(rep(1,400), coalesc(J = 400, m = 0.5, filt = function(x)
                                           filt_gaussian(x, c(0.2, 0.1)),
                                           pool = comm$pool)$com))
comm.obs[[2]] &lt;- cbind(rep(2,400), coalesc(J = 400, m = 0.5, filt = function(x) 
                                           filt_gaussian(x, c(0.5, 0.1)),
                                           pool = comm$pool)$com))
comm.obs[[3]] &lt;- cbind(rep(3,400), coalesc(J = 400, m = 0.5, filt = function(x) 
                                           filt_gaussian(x, c(0.8, 0.1)),
                                           pool = comm$pool)$com))

comm.obs &lt;- lapply(comm.obs, as.matrix)

res &lt;- coalesc_abc(comm.obs, comm$pool, multi="seqcom", f.sumstats=f.sumstats,
                   filt.abc = filt_gaussian, params = params, nb.samp = nb.samp,
                   parallel = TRUE, pkg = c("e1071","vegan"), tol = 0.1,
                   method = "neuralnet")
                   
lapply(res$abc, summary)


## End(Not run)
</code></pre>

<hr>
<h2 id='ecolottery-package'>
Coalescent-Based Simulation of Ecological Communities
</h2><span id='topic+ecolottery-package'></span><span id='topic+ecolottery'></span>

<h3>Description</h3>

<p>Coalescent-Based Simulation of Ecological Communities as proposed
by Munoz et al. (2017) &lt;doi:10.13140/RG.2.2.31737.26728&gt;. The package includes
a tool for estimating parameters of community assembly by using Approximate 
Bayesian Computation.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> ecolottery</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> Coalescent-Based Simulation of Ecological Communities</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("François", "Munoz", role = c("aut", "cre"),
                     email = "francois.munoz@hotmail.fr"),
              person("Matthias", "Grenié", role = "aut"),
              person("Pierre", "Denelle", role = "aut"),
              person("Adrien", "Taudière", role = "ctb"),
              person("Fabien", "Laroche", role = "ctb"),
              person("Caroline", "Tucker", role = "ctb"),
              person("Cyrille", "Violle", role = "ctb"))</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/frmunoz/ecolottery</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/frmunoz/ecolottery/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> 
R (&gt;= 3.0.2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> 
abc,
stats,
graphics,
ggplot2,
grDevices,
parallel</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> 
ape,
changepoint,
knitr,
picante,
rmarkdown,
testthat,
untb,
vegan</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Coalescent-Based Simulation of Ecological Communities as proposed
    by Munoz et al. (2017) &lt;doi:10.13140/RG.2.2.31737.26728&gt;. The package includes
    a tool for estimating parameters of community assembly by using Approximate 
    Bayesian Computation.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 6.0.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> François Munoz [aut, cre],
  Matthias Grenié [aut],
  Pierre Denelle [aut],
  Adrien Taudière [ctb],
  Fabien Laroche [ctb],
  Caroline Tucker [ctb],
  Cyrille Violle [ctb]</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> NA</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Index of help topics:
</p>
<pre>
abund                   Compute absolute and relative abundances in the
                        local community and the reference pool
coalesc                 Coalescent-based simulation of ecological
                        communities undergoing both neutral and
                        niche-base dynamics
coalesc_abc             Estimation of neutral and non-neutral
                        parameters of community assembly using
                        Approximate Bayesian Computation (ABC)
ecolottery-package      Coalescent-Based Simulation of Ecological
                        Communities
forward                 Simulation of neutral and niche-based community
                        dynamics forward in time
plot_comm               Regional vs. Local trait distributions of
                        abundances
tcor                    Generates Correlated Traits
</pre>
<p>Two basic functions: <code>coalesc</code> for coalescent-based simulation, and <code>forward</code> for forward-in-time simulation
</p>


<h3>Author(s)</h3>

<p>NA
</p>
<p>Maintainer: NA
</p>


<h3>References</h3>

<p>Hurtt, G. C. and S. W. Pacala (1995). &quot;The consequences of recruitment limitation: reconciling chance, history and competitive differences between plants.&quot; Journal of Theoretical Biology 176(1): 1-12.
</p>
<p>Hubbell, S. P. (2001). &quot;The Unified Neutral Theory of Biodiversity&quot;. Princeton University Press. 
</p>
<p>Gravel, D., C. D. Canham, M. Beaudet and C. Messier (2006). &quot;Reconciling niche and neutrality: the continuum hypothesis.&quot; Ecology Letters 9(4): 399-409.
</p>
<p>Munoz, F., P. Couteron, B. R. Ramesh and R. S. Etienne (2007). &quot;Estimating parameters of neutral communities: from one Single Large to Several Small samples.&quot; Ecology 88(10): 2482-2488.
</p>
<p>Munoz, F., B. R. Ramesh and P. Couteron (2014). &quot;How do habitat filtering and niche conservatism affect community composition at different taxonomic resolutions?&quot; Ecology 95(8): 2179-2191. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Coalescent-based simulation of stabilizing habitat filtering around 
## t = 0.5
J &lt;- 100; theta &lt;- 50; m &lt;- 0.5;
comm &lt;- coalesc(J, m, theta, filt = function(x) 0.5 - abs(0.5 - x))
plot_comm(comm)

## Forward-in-time simulation of stabilizing habitat filtering around 
## t = 0.5, over 100 time steps

# A regional pool including 100 species each including 10 individuals
pool &lt;- sort(rep(as.character(1:100), 10))

# Initial community composed of 10 species each including 10 individuals, 
# with trait information for niche-based dynamics
initial &lt;- data.frame(sp = sort(rep(as.character(1:10), 10)),
                      trait = runif(100))
final &lt;- forward(initial = initial, prob = 0.5, gens = 100, pool = pool,
                 filt = function(x) 0.5 - abs(0.5 - x))
plot_comm(final)
</code></pre>

<hr>
<h2 id='forward'>
Simulation of neutral and niche-based community dynamics forward in time
</h2><span id='topic+forward'></span><span id='topic+get_number_of_gens'></span><span id='topic+pick'></span><span id='topic+pick.mutate'></span><span id='topic+pick.immigrate'></span>

<h3>Description</h3>

<p>Simulates niche-based (habitat filtering and/or limiting similarity) and neutral
community dynamics from a given initial composition, over a given number of
generations. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forward(initial, prob = 0, d = 1, gens = 150, keep = FALSE,
        pool = NULL, limit.sim = FALSE, coeff.lim.sim = 1,
        sigm = 0.1, filt = NULL, prob.death = NULL,
        method.dist = "euclidean", plot_gens = FALSE)
get_number_of_gens(given_size, pool, nbrep = 5, prob = 1, d = 1, 
                   gens = NULL, limit.sim = FALSE, 
                   coeff.lim.sim = 1, sigm = 0.1, filt = NULL, 
                   prob.death = NULL, method.dist = "euclidean",
                   plot_gens = FALSE)
pick(com, d = 1, prob = 0, pool = NULL, prob.death = prob.death,
     limit.sim = NULL, coeff.lim.sim = 1, sigm = 0.1, filt = NULL, 
     new.index = new.index, method.dist = "euclidean")
pick.mutate(com, d = 1, prob.of.mutate = 0, new.index = 0)
pick.immigrate(com, d = 1, prob.of.immigrate = 0, pool, 
               prob.death = NULL, limit.sim = NULL, coeff.lim.sim = 1,
               sigm = 0.1, filt = NULL, method.dist = "euclidean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forward_+3A_com">com</code>, <code id="forward_+3A_initial">initial</code></td>
<td>

<p>starting community. It is in principle a three (or more) column matrix or
data.frame including individual ID, species names and trait values. For strictly
neutral dynamics, it can be a vector of individual species names.
</p>
</td></tr>
<tr><td><code id="forward_+3A_prob">prob</code>, <code id="forward_+3A_prob.of.immigrate">prob.of.immigrate</code>, <code id="forward_+3A_prob.of.mutate">prob.of.mutate</code></td>
<td>

<p>probability of an individual establishing in the community not being a
descendant of an existing individual. If descendant from a new ancestor, can be
either through immigration (in <code>pick.immigrate()</code>) or through mutation
(in <code>pick.mutate()</code>).
</p>
</td></tr>
<tr><td><code id="forward_+3A_d">d</code></td>
<td>

<p>number of individuals that die in each time-step.
</p>
</td></tr>
<tr><td><code id="forward_+3A_gens">gens</code></td>
<td>

<p>number of generations to simulate.
</p>
</td></tr>
<tr><td><code id="forward_+3A_keep">keep</code></td>
<td>

<p>boolean value. If <code>FALSE</code> (default) the function output only the community
composition at the end of the simulation. If <code>TRUE</code> the function output a
list of community composition at successive time steps (see Value section).
</p>
</td></tr>
<tr><td><code id="forward_+3A_pool">pool</code></td>
<td>

<p>the regional pool of species providing immigrants to the local community. It is
in principle a three-column matrix or data frame including individual ID,
species names and trait values. If trait information is missing, a random trait
value is given to individuals, from a uniform distribution between 0 and 1.
If <code>NULL</code>, the pool is simulated as a metacommunity at speciation-drift
equilibrium, based on <code>prob</code> for speciation rate.
</p>
</td></tr>
<tr><td><code id="forward_+3A_given_size">given_size</code></td>
<td>

<p>size of the community you want to have an estimate of the number of generations
needed to reach stationarity in species richness.
</p>
</td></tr>
<tr><td><code id="forward_+3A_nbrep">nbrep</code></td>
<td>

<p>number of replicates from which you want to estimate the number of generations
needed to reach stationarity in species richness.
</p>
</td></tr>
<tr><td><code id="forward_+3A_limit.sim">limit.sim</code></td>
<td>

<p>if <code>TRUE,</code> limiting similarity will be simulated, based on species trait
distances (computed with the method given by <code>method.dist</code>) and a Gaussian
overlapping function. 
</p>
</td></tr>
<tr><td><code id="forward_+3A_coeff.lim.sim">coeff.lim.sim</code></td>
<td>

<p>adjust the intensity of limiting similarity. 
</p>
</td></tr>
<tr><td><code id="forward_+3A_sigm">sigm</code></td>
<td>

<p>adjust the variance of the overlap function used to calculate limiting
similarity.
</p>
</td></tr>
<tr><td><code id="forward_+3A_filt">filt</code></td>
<td>

<p>the function used to represent habitat filtering. For a given trait value
<code>t</code>, <code>filt(t)</code> represents the probability that an individual with
trait <code>t</code> enters the local community.
</p>
</td></tr>
<tr><td><code id="forward_+3A_prob.death">prob.death</code></td>
<td>

<p>provides a baseline probability of death that is homogeneous across species. It
is used in niche-based dynamics to represent the balance of baseline and
niche-dependent mortality.
</p>
</td></tr>
<tr><td><code id="forward_+3A_method.dist">method.dist</code></td>
<td>

<p>provide the method to compute trait distances between individuals (syntax of
function <code><a href="stats.html#topic+dist">dist</a></code>, can be in the list <code>c("euclidean",
"maximum", "manhattan", 
"canberra", "binary", "minkowski")</code>).
</p>
</td></tr>
<tr><td><code id="forward_+3A_new.index">new.index</code></td>
<td>

<p>prefix used to give a new species name when speciation occurs.
</p>
</td></tr>
<tr><td><code id="forward_+3A_plot_gens">plot_gens</code></td>
<td>

<p>plot the number of unique individuals and species over generations.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is a zero-sum game, so that the number of individuals of the community is
fixed to the number of individuals in initial community.
</p>
<p>When niche-based dynamics are simulated, the niche-based constraints influence
both immigration and mortality.
</p>
<p>Function <code>get_number_of_gen()</code> allows determining the number of generations
needed to reach stationary richness for given parameterization of
<code>forward()</code>. The target number of generation is based on assessing the
change point in species richness change over time for replicate simulated
communities with random initial composition. A conservative measure is proposed
as the maximum time to reach stationary richness over the replicate simulated
communities.
</p>
<p>Functions <code>pick.immigrate()</code> and <code>pick.mutate()</code> are used to simulate
immigration and speciation events within a time step. They are embedded in
forward and are not really intended for the end user. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>com</code></td>
<td>

<p>if <code>keep = FALSE</code>, a data.frame of simulated individuals, with the label
of ancestor individual in the regional pool on first column (as in the first
column of the pool), species label on second column (as in the second column of
the pool), and species trait (as in the third column of the pool).
</p>
</td></tr>
<tr><td><code>pool</code></td>
<td>

<p>a data.frame of the individuals of the regional source pool, with the label of
ancestor individual in the regional pool on first column (as in first column of
input <code>pool</code>), species label on second column (as in second column of input
<code>pool</code>), and species trait (as in third column of input <code>pool</code>).
</p>
</td></tr>
<tr><td><code>sp_t</code></td>
<td>

<p>a vector of species richness at each time step.
</p>
</td></tr>
<tr><td><code>com_t</code></td>
<td>

<p>if <code>keep = TRUE</code>, a list of community composition for each time step 
(a data.frame as in <code>com</code>).
</p>
</td></tr>
<tr><td><code>dist.t</code></td>
<td>

<p>if <code>limit.sim = TRUE</code>, the average value of the limiting similarity
function over time.
</p>
</td></tr>
<tr><td><code>new.index</code></td>
<td>

<p>for <code>pick.mutate()</code>, return the new index to be used for species name at a
next speciation event.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>F. Munoz, derived from the <code>untb</code> function of R. Hankin.
</p>


<h3>References</h3>

<p>For neutral dynamics, S. P. Hubbell 2001. &quot;The Unified Neutral Theory of
Biodiversity&quot;. Princeton University Press. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Initial community composed of 10 species each including 10 individuals
initial1 &lt;- rep(as.character(1:10), each = 10)

# Simulation of speciation and drift dynamics over 100 time steps
final1 &lt;- forward(initial = initial1, prob = 0.1, gens = 1000)
# The final community includes new species (by default names begins with "new")
final1$com$sp # includes new species generated by speciation events

# A regional pool including 100 species each including 10 individuals
pool &lt;- rep(as.character(1:100), each = 10)

# Simulation of migration and drift dynamics over 1000 time steps
final2 &lt;- forward(initial = initial1, prob = 0.1, gens = 1000, pool = pool)
# The final community includes species that have immigrated from the pool
final2$com$sp # includes new species that immigrated from the pool

# Initial community composed of 10 species each including 10 individuals, 
# with trait information for niche-based dynamics
initial2 &lt;- data.frame(sp = rep(as.character(1:10), each = 10), 
                      trait = runif(100))

# Simulation of stabilizing hab. filtering around t = 0.5, over 1000 time steps
sigm &lt;- 0.1
filt_gaussian &lt;- function(t,x) exp(-(x - t)^2/(2*sigm^2))
final3 &lt;- forward(initial = initial2, prob = 0.1, gens = 1000, pool = pool, 
                 filt = function(x) filt_gaussian(0.5,x))
plot_comm(final3) # trait distribution in final community

# With higher immigration
final4 &lt;- forward(initial = initial2, prob = 0.8, gens = 1000, pool = pool, 
                 filt = function(x) filt_gaussian(0.5,x))
plot_comm(final4) # should be closer to 0.5

# Simulation of limiting similarity, over 1000 time steps
final5 &lt;- forward(initial = initial2, prob = 0.1, gens = 1000, pool = pool, 
                 limit.sim = TRUE)
plot_comm(final5)

# Stronger limiting similarity
final6 &lt;- forward(initial = initial2, prob = 0.1, gens = 1000, pool = pool, 
                 limit.sim = TRUE, coeff.lim.sim = 20)
plot_comm(final6) # the distribution will be more even

# Variation of community richness with time
final7 &lt;- forward(initial = initial2, prob = 0.1, gens = 1000, pool = pool, 
                 limit.sim = TRUE, keep = TRUE, plot_gens = TRUE)

# Check stationarity
plot(unlist(lapply(final7$com_t, function(x) length(unique(x[, 2])))), 
     xlab = "Time step", ylab = "Community richness") 

# Index of limiting similarity over time
plot(final7$dist.t, xlab = "Time step", ylab = "Limiting similarity")

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_comm'>
Regional vs. Local trait distributions of abundances
</h2><span id='topic+plot_comm'></span>

<h3>Description</h3>

<p>Graphical function to used on the output of <code>coalesc()</code> or
<code>forward()</code> functions.It aims at plotting links between regional and
local trait/abundance distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_comm(x, type = "trait", seltrait = 1, main = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_comm_+3A_x">x</code></td>
<td>

<p>a list including the species pool composition (<code>x$pool</code>) and the local
community composition (<code>x$com</code>). For example, x may be the output of
<code>coalesc()</code> or <code>forward()</code> functions.
</p>
</td></tr>
<tr><td><code id="plot_comm_+3A_type">type</code></td>
<td>


<ul>
<li><p> if <code>type = "trait"</code>, the function displays density plots of trait
distributions.
</p>
</li>
<li><p> if <code>type = "abund"</code>, it displays the relationship between local
and regional abundances.
</p>
</li></ul>

</td></tr>
<tr><td><code id="plot_comm_+3A_seltrait">seltrait</code></td>
<td>

<p>index of the trait to be plotted following community data.frame (if multiple
traits used in simulation).
</p>
</td></tr>
<tr><td><code id="plot_comm_+3A_main">main</code></td>
<td>

<p>an overall title for the plot.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>type = "trait"</code>, the function provides density plots of the trait or
abundance distributions in the regional pool and in a local community.
If <code>type = "abund"</code>, the function displays the relationship between
regional and local species relative abundances.
By default <code>type = "trait"</code>.
To be used on the output of <code>coalesc()</code> or <code>forward()</code> functions.
</p>


<h3>Value</h3>

<p>Return two stacked <code><a href="ggplot2.html#topic+ggplot2-package">ggplot2</a></code> density plots if
<code>type = "trait"</code> and a biplot if <code>type = "abund"</code>.
</p>


<h3>Author(s)</h3>

<p>F. Munoz; P. Denelle
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulation of a neutral community including 100 individuals
J &lt;- 500; theta &lt;- 50; m &lt;- 0.1;
comm1 &lt;- coalesc(J, m, theta) 
plot_comm(comm1)
plot_comm(comm1, type = "abund")

# Stabilizing habitat filtering around t = 0.5
comm2 &lt;- coalesc(J, m, theta, filt = function(x) 0.5 - abs(0.5 - x))
plot_comm(comm2)
plot_comm(comm2, type = "abund")
</code></pre>

<hr>
<h2 id='tcor'>
Generates Correlated Traits
</h2><span id='topic+tcor'></span>

<h3>Description</h3>

<p>Create two random vectors of traits correlated between each other or a vector
of traits correlated to an existing one. The linear correlation is
defined by the parameter <code>rho</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcor(n, rho = 0.5, mar.fun = rnorm, x = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tcor_+3A_n">n</code></td>
<td>

<p>the integer number of values to be generated.
</p>
</td></tr>
<tr><td><code id="tcor_+3A_rho">rho</code></td>
<td>

<p>a numeric parameter defining the linear correlation between the two
traits (default is 0.5).
It must belong to the interval [-1, 1].
</p>
</td></tr>
<tr><td><code id="tcor_+3A_x">x</code></td>
<td>

<p>an vector of numeric values. Default is NULL. 
</p>
</td></tr>
<tr><td><code id="tcor_+3A_mar.fun">mar.fun</code></td>
<td>

<p>a function defining the random generation for the trait distribution. Default is
<code>rnorm</code>.
</p>
</td></tr>
<tr><td><code id="tcor_+3A_...">...</code></td>
<td>

<p>other arguments for the <code>mar.fun()</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rho</code> parameter is set to 0.5 by default. <code>x = NULL</code> by default.
Code adapted from: <a href="http://stats.stackexchange.com/questions/15011/generate-a-random-variable-with-a-defined-correlation-to-an-existing-variable">http://stats.stackexchange.com/questions/15011/generate-a-random-variable-with-a-defined-correlation-to-an-existing-variable</a>
</p>


<h3>Value</h3>

<p>Return a data.frame with two numeric columns, each column defining a trait.
</p>


<h3>Author(s)</h3>

<p>P. Denelle
F. Munoz
</p>


<h3>Examples</h3>

<pre><code class='language-R'># With no predefined trait
traits &lt;- tcor(n = 10000, rho = 0.8)
plot(traits[, 1], traits[, 2])
cor(traits[, 1], traits[, 2])

# With existing trait
existing_trait &lt;- rnorm(10000, 10, 1)
traits &lt;- tcor(n = 10000, rho = 0.8, x = existing_trait)
plot(traits[, 1], traits[, 2])
cor(traits[, 1], traits[, 2])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
