<!DOCTYPE html><html lang="en"><head><title>Help for package predint</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {predint}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ames_HCD'><p>Historical numbers of revertant colonies in the Ames test (OECD 471)</p></a></li>
<li><a href='#as.data.frame.predint'><p>Store prediction intervals or limits as a <code>data.frame</code></p></a></li>
<li><a href='#bb_dat1'><p>Beta-binomial data (example 1)</p></a></li>
<li><a href='#bb_dat2'><p>Beta-binomial data (example 2)</p></a></li>
<li><a href='#bb_pi'><p>Simple uncalibrated prediction intervals for beta-binomial data</p></a></li>
<li><a href='#beta_bin_pi'><p>Prediction intervals for beta-binomial data</p></a></li>
<li><a href='#bisection'><p>Bisection algorithm for bootstrap calibration of prediction intervals</p></a></li>
<li><a href='#boot_predint'><p>Bootstrap new data from uncalibrated prediction intervals</p></a></li>
<li><a href='#c2_dat1'><p>Cross-classified data (example 1)</p></a></li>
<li><a href='#c2_dat2'><p>Cross-classified data (example 2)</p></a></li>
<li><a href='#c2_dat3'><p>Cross-classified data (example 3)</p></a></li>
<li><a href='#c2_dat4'><p>Cross-classified data (example 4)</p></a></li>
<li><a href='#lmer_bs'><p>Sampling of bootstrap data from a given random effects model</p></a></li>
<li><a href='#lmer_pi'><p>Prediction intervals for future observations based on linear random effects models (DEPRECATED)</p></a></li>
<li><a href='#lmer_pi_futmat'><p>Prediction intervals for future observations based on linear random effects models</p></a></li>
<li><a href='#lmer_pi_futvec'><p>Prediction intervals for future observations based on linear random effects models</p></a></li>
<li><a href='#lmer_pi_unstruc'><p>Prediction intervals for future observations based on linear random effects models</p></a></li>
<li><a href='#mortality_HCD'><p>Historical mortality of male B6C3F1-mice</p></a></li>
<li><a href='#nb_pi'><p>Simple uncalibrated prediction intervals for negative-binomial data</p></a></li>
<li><a href='#neg_bin_pi'><p>Prediction intervals for negative-binomial data</p></a></li>
<li><a href='#normal_pi'><p>Simple uncalibrated prediction intervals for normal distributed data</p></a></li>
<li><a href='#pi_rho_est'><p>Estimation of the binomial proportion and the intra class correlation.</p></a></li>
<li><a href='#plot.predint'><p>Plots of <code>predint</code> objects</p></a></li>
<li><a href='#print.predint'><p>Print objects of class <code>predint</code></p></a></li>
<li><a href='#qb_dat1'><p>Quasi-binomial data (example 1)</p></a></li>
<li><a href='#qb_dat2'><p>Quasi-binomial data (example 2)</p></a></li>
<li><a href='#qb_pi'><p>Simple uncalibrated prediction intervals for quasi-binomial data</p></a></li>
<li><a href='#qp_dat1'><p>Quasi-Poisson data (example 1)</p></a></li>
<li><a href='#qp_dat2'><p>Quasi-Poisson data (example 2)</p></a></li>
<li><a href='#qp_pi'><p>Simple uncalibrated prediction intervals for quasi-Poisson data</p></a></li>
<li><a href='#quasi_bin_pi'><p>Prediction intervals for quasi-binomial data</p></a></li>
<li><a href='#quasi_pois_pi'><p>Prediction intervals for quasi-Poisson data</p></a></li>
<li><a href='#rbbinom'><p>Sampling of beta-binomial data</p></a></li>
<li><a href='#rnbinom'><p>Sampling of negative binomial data</p></a></li>
<li><a href='#rqbinom'><p>Sampling of overdispersed binomial data with constant overdispersion</p></a></li>
<li><a href='#rqpois'><p>Sampling of overdispersed Poisson data with constant overdispersion</p></a></li>
<li><a href='#summary.predint'><p>Summarizing objects of class <code>predint</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Prediction Intervals</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation of prediction intervals for overdispersed count data,
            for overdispersed binomial data and for linear random effects models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, methods</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), ggplot2, lme4, MASS</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/MaxMenssen/predint">https://github.com/MaxMenssen/predint</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MaxMenssen/predint/issues">https://github.com/MaxMenssen/predint/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-04 10:25:57 UTC; maxmenssen</td>
</tr>
<tr>
<td>Author:</td>
<td>Max Menssen [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Max Menssen &lt;menssen@cell.uni-hannover.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-04 15:10:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='ames_HCD'>Historical numbers of revertant colonies in the Ames test (OECD 471)</h2><span id='topic+ames_HCD'></span>

<h3>Description</h3>

<p>This data set contains artificial historical control data that was sampled in
order to mimic the number of revertant colonies based on two or three petri dishes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ames_HCD
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 2 rows and 10 columns:
</p>

<dl>
<dt>rev_col</dt><dd><p>no. of revertant colonies</p>
</dd>
<dt>no_dish</dt><dd><p>no. of petri dishes in the control group</p>
</dd>
</dl>


<hr>
<h2 id='as.data.frame.predint'>Store prediction intervals or limits as a <code>data.frame</code></h2><span id='topic+as.data.frame.predint'></span>

<h3>Description</h3>

<p>Get the prediction intervals or limits of an object of class <code>predint</code> and
save them as a <code>data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predint'
as.data.frame(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.predint_+3A_x">x</code></td>
<td>
<p>object of class <code>predint</code></p>
</td></tr>
<tr><td><code id="as.data.frame.predint_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to <code>base::as.data.frame()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns the prediction intervals or limits stored in an
object of class <code>"predint"</code> as a <code>data.frame</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### PI for quasi-Poisson data
pred_int &lt;- quasi_pois_pi(histdat=ames_HCD,
                          newoffset=3,
                          nboot=100,
                          traceplot = FALSE)

# Return the prediction intervals as a data.frame
as.data.frame(pred_int)

# Please note that nboot was set to 100 in order to decrease computing time
# of the example. For a valid analysis set nboot=10000.
</code></pre>

<hr>
<h2 id='bb_dat1'>Beta-binomial data (example 1)</h2><span id='topic+bb_dat1'></span>

<h3>Description</h3>

<p>This data set contains sampled beta-binomial data from 10 clusters
each of size 50. The data set was sampled with <code>rbbinom(n=10, size=50, prob=0.1, rho=0.06)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bb_dat1
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 10 rows and 2 columns:
</p>

<dl>
<dt>succ</dt><dd><p>number of successes</p>
</dd>
<dt>fail</dt><dd><p>number of failures</p>
</dd>
</dl>


<hr>
<h2 id='bb_dat2'>Beta-binomial data (example 2)</h2><span id='topic+bb_dat2'></span>

<h3>Description</h3>

<p>This data set contains sampled beta-binomial data from 3 clusters each of
different size. The data set was sampled with <code>rbbinom(n=3, size=c(40, 50, 60), prob=0.1, rho=0.06)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bb_dat2
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 3 rows and 2 columns:
</p>

<dl>
<dt>succ</dt><dd><p>number of successes</p>
</dd>
<dt>fail</dt><dd><p>number of failures</p>
</dd>
</dl>


<hr>
<h2 id='bb_pi'>Simple uncalibrated prediction intervals for beta-binomial data</h2><span id='topic+bb_pi'></span>

<h3>Description</h3>

<p><code>bb_pi()</code> is a helper function that is internally called by <code>beta_bin_pi()</code>. It
calculates simple uncalibrated prediction intervals for binary
data with overdispersion changing between the clusters (beta-binomial).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bb_pi(
  newsize,
  histsize,
  pi,
  rho,
  q = qnorm(1 - 0.05/2),
  alternative = "both",
  newdat = NULL,
  histdat = NULL,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bb_pi_+3A_newsize">newsize</code></td>
<td>
<p>number of experimental units in the historical clusters</p>
</td></tr>
<tr><td><code id="bb_pi_+3A_histsize">histsize</code></td>
<td>
<p>number of experimental units in the future clusters</p>
</td></tr>
<tr><td><code id="bb_pi_+3A_pi">pi</code></td>
<td>
<p>binomial proportion</p>
</td></tr>
<tr><td><code id="bb_pi_+3A_rho">rho</code></td>
<td>
<p>intra class correlation</p>
</td></tr>
<tr><td><code id="bb_pi_+3A_q">q</code></td>
<td>
<p>quantile used for interval calculation</p>
</td></tr>
<tr><td><code id="bb_pi_+3A_alternative">alternative</code></td>
<td>
<p>either &quot;both&quot;, &quot;upper&quot; or &quot;lower&quot;
<code>alternative</code> specifies, if a prediction interval or
an upper or a lower prediction limit should be computed</p>
</td></tr>
<tr><td><code id="bb_pi_+3A_newdat">newdat</code></td>
<td>
<p>additional argument to specify the current data set</p>
</td></tr>
<tr><td><code id="bb_pi_+3A_histdat">histdat</code></td>
<td>
<p>additional argument to specify the historical data set</p>
</td></tr>
<tr><td><code id="bb_pi_+3A_algorithm">algorithm</code></td>
<td>
<p>used to define the algorithm for calibration if called via
<code>beta_bin_pi()</code>. This argument is not of interest for the calculation
of simple uncalibrated intervals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a simple uncalibrated prediction interval
</p>
<p style="text-align: center;"><code class="reqn">[l,u]_m = n^*_m \hat{\pi} \pm q \sqrt{n^*_m \hat{\pi} (1- \hat{\pi}) [1 + (n^*_m -1) \hat{\rho}] +
[\frac{n^{*2}_m \hat{\pi} (1- \hat{\pi})}{\sum_h n_h} + \frac{\sum_h n_h -1}{\sum_h n_h} n^{*2}_m \hat{\pi} (1- \hat{\pi}) \hat{\rho}]}</code>
</p>

<p>with <code class="reqn">n^*_m</code> as the number of experimental units in the <code class="reqn">m=1, 2, ... , M</code> future clusters,
<code class="reqn">\hat{\pi}</code> as the estimate for the binomial proportion obtained from the
historical data, <code class="reqn">\hat{\rho}</code> as the estimate for the intra class correlation
and <code class="reqn">n_h</code> as the number of experimental units per historical cluster. <br />
</p>
<p>The direct application of this uncalibrated prediction interval to real life data
is not recommended. Please use <code>beta_bin_pi()</code> for real life applications.  <br />
</p>


<h3>Value</h3>

<p><code>bb_pi()</code> returns an object of class <code>c("predint", "betaBinomialPI")</code>
with prediction intervals or limits in the first entry (<code>$prediction</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pointwise uncalibrated PI
bb_pred &lt;- bb_pi(newsize=c(50), pi=0.3, rho=0.05, histsize=rep(50, 20), q=qnorm(1-0.05/2))
summary(bb_pred)

</code></pre>

<hr>
<h2 id='beta_bin_pi'>Prediction intervals for beta-binomial data</h2><span id='topic+beta_bin_pi'></span>

<h3>Description</h3>

<p><code>beta_bin_pi()</code> calculates bootstrap calibrated prediction intervals for
beta-binomial data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_bin_pi(
  histdat,
  newdat = NULL,
  newsize = NULL,
  alternative = "both",
  alpha = 0.05,
  nboot = 10000,
  delta_min = 0.01,
  delta_max = 10,
  tolerance = 0.001,
  traceplot = TRUE,
  n_bisec = 30,
  algorithm = "MS22mod"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="beta_bin_pi_+3A_histdat">histdat</code></td>
<td>
<p>a <code>data.frame</code> with two columns (number of successes and
number of failures) containing the historical data</p>
</td></tr>
<tr><td><code id="beta_bin_pi_+3A_newdat">newdat</code></td>
<td>
<p>a <code>data.frame</code> with two columns (number of successes and
number of failures) containing the future data</p>
</td></tr>
<tr><td><code id="beta_bin_pi_+3A_newsize">newsize</code></td>
<td>
<p>a vector containing the future cluster sizes</p>
</td></tr>
<tr><td><code id="beta_bin_pi_+3A_alternative">alternative</code></td>
<td>
<p>either &quot;both&quot;, &quot;upper&quot; or &quot;lower&quot;. <code>alternative</code>
specifies if a prediction interval or an upper or a lower prediction limit
should be computed</p>
</td></tr>
<tr><td><code id="beta_bin_pi_+3A_alpha">alpha</code></td>
<td>
<p>defines the level of confidence (1-<code>alpha</code>)</p>
</td></tr>
<tr><td><code id="beta_bin_pi_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstraps</p>
</td></tr>
<tr><td><code id="beta_bin_pi_+3A_delta_min">delta_min</code></td>
<td>
<p>lower start value for bisection</p>
</td></tr>
<tr><td><code id="beta_bin_pi_+3A_delta_max">delta_max</code></td>
<td>
<p>upper start value for bisection</p>
</td></tr>
<tr><td><code id="beta_bin_pi_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for the coverage probability in the bisection</p>
</td></tr>
<tr><td><code id="beta_bin_pi_+3A_traceplot">traceplot</code></td>
<td>
<p>if <code>TRUE</code>: Plot for visualization of the bisection process</p>
</td></tr>
<tr><td><code id="beta_bin_pi_+3A_n_bisec">n_bisec</code></td>
<td>
<p>maximal number of bisection steps</p>
</td></tr>
<tr><td><code id="beta_bin_pi_+3A_algorithm">algorithm</code></td>
<td>
<p>either &quot;MS22&quot; or &quot;MS22mod&quot; (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns bootstrap-calibrated prediction intervals as well as
lower or upper prediction limits.
</p>
<p>If <code>algorithm</code> is set to &quot;MS22&quot;, both limits of the prediction interval
are calibrated simultaneously using the algorithm described in Menssen and
Schaarschmidt (2022), section 3.2.4. The calibrated prediction interval is given
as
</p>
<p style="text-align: center;"><code class="reqn">[l,u]_m = n^*_m \hat{\pi} \pm q^{calib} \hat{se}(Y_m - y^*_m)</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\hat{se}(Y_m - y^*_m) = \sqrt{n^*_m \hat{\pi} (1- \hat{\pi}) [1 + (n^*_m -1) \hat{\rho}] +
[\frac{n^{*2}_m \hat{\pi} (1- \hat{\pi})}{\sum_h n_h} + \frac{\sum_h n_h -1}{\sum_h n_h} n^{*2}_m \hat{\pi} (1- \hat{\pi}) \hat{\rho}]}</code>
</p>

<p>with <code class="reqn">n^*_m</code> as the number of experimental units in the future clusters,
<code class="reqn">\hat{\pi}</code> as the estimate for the binomial proportion obtained from the
historical data, <code class="reqn">q^{calib}</code> as the bootstrap-calibrated coefficient,
<code class="reqn">\hat{\rho}</code> as the estimate for the intra class correlation (Lui et al. 2000)
and <code class="reqn">n_h</code> as the number of experimental units per historical cluster. <br />
</p>
<p>If <code>algorithm</code> is set to &quot;MS22mod&quot;, both limits of the prediction interval
are calibrated independently from each other. The resulting prediction interval
is given by
</p>
<p style="text-align: center;"><code class="reqn">[l,u]_m = \big[n^*_m \hat{\pi} - q^{calib}_l \hat{se}(Y_m - y^*_m), \quad n^*_m \hat{\pi} + q^{calib}_u \hat{se}(Y_m - y^*_m) \big]</code>
</p>

<p>Please note, that this modification does not affect the calibration procedure, if only
prediction limits are of interest.
</p>


<h3>Value</h3>

<p><code>beta_bin_pi</code> returns an object of class <code>c("predint", "betaBinomialPI")</code>
with prediction intervals or limits in the first entry (<code>$prediction</code>).
</p>


<h3>References</h3>

<p>Lui et al. (2000): Confidence intervals for the risk ratio
under cluster sampling based on the beta-binomial model. Statistics in Medicine. <br />
<a href="https://doi.org/10.1002/1097-0258%2820001115%2919%3A21%3C2933%3A%3AAID-SIM591%3E3.0.CO%3B2-Q">doi:10.1002/1097-0258(20001115)19:21&lt;2933::AID-SIM591&gt;3.0.CO;2-Q</a>
</p>
<p>Menssen and Schaarschmidt (2022): Prediction intervals for all of M future
observations based on linear random effects models. Statistica Neerlandica.
<a href="https://doi.org/10.1111/stan.12260">doi:10.1111/stan.12260</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Prediction interval
pred_int &lt;- beta_bin_pi(histdat=mortality_HCD, newsize=40, nboot=100)
summary(pred_int)

# Upper prediction bound
pred_u &lt;- beta_bin_pi(histdat=mortality_HCD, newsize=40, alternative="upper", nboot=100)
summary(pred_u)

# Please note that nboot was set to 100 in order to decrease computing time
# of the example. For a valid analysis set nboot=10000.


</code></pre>

<hr>
<h2 id='bisection'>Bisection algorithm for bootstrap calibration of prediction intervals</h2><span id='topic+bisection'></span>

<h3>Description</h3>

<p>This helper function returns a bootstrap calibrated coefficient for the calculation
of prediction intervals (and limits).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bisection(
  y_star_hat,
  pred_se,
  y_star,
  alternative,
  quant_min,
  quant_max,
  n_bisec,
  tol,
  alpha,
  traceplot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bisection_+3A_y_star_hat">y_star_hat</code></td>
<td>
<p>a list of length <code class="reqn">B</code> that contains the expected future observations.
Each entry in this list has to be a numeric vector of length <code class="reqn">M</code>.</p>
</td></tr>
<tr><td><code id="bisection_+3A_pred_se">pred_se</code></td>
<td>
<p>a list of length <code class="reqn">B</code> that contains the standard errors of the prediction.
Each entry in this list has to be a numeric vector of length <code class="reqn">M</code>.</p>
</td></tr>
<tr><td><code id="bisection_+3A_y_star">y_star</code></td>
<td>
<p>a list of length <code class="reqn">B</code> that contains the future observations.
Each entry in this list has to be a numeric vector of length <code class="reqn">M</code>.</p>
</td></tr>
<tr><td><code id="bisection_+3A_alternative">alternative</code></td>
<td>
<p>either &quot;both&quot;, &quot;upper&quot; or &quot;lower&quot;.
<code>alternative</code> specifies if a prediction interval or
an upper or a lower prediction limit should be computed</p>
</td></tr>
<tr><td><code id="bisection_+3A_quant_min">quant_min</code></td>
<td>
<p>lower start value for bisection</p>
</td></tr>
<tr><td><code id="bisection_+3A_quant_max">quant_max</code></td>
<td>
<p>upper start value for bisection</p>
</td></tr>
<tr><td><code id="bisection_+3A_n_bisec">n_bisec</code></td>
<td>
<p>maximal number of bisection steps</p>
</td></tr>
<tr><td><code id="bisection_+3A_tol">tol</code></td>
<td>
<p>tolerance for the coverage probability in the bisection</p>
</td></tr>
<tr><td><code id="bisection_+3A_alpha">alpha</code></td>
<td>
<p>defines the level of confidence (<code class="reqn">1-\alpha</code>)</p>
</td></tr>
<tr><td><code id="bisection_+3A_traceplot">traceplot</code></td>
<td>
<p>if <code>TRUE</code>: Plot for visualization of the bisection process</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an implementation of the bisection algorithm of Menssen
and Schaarschmidt 2022. It returns a calibrated coefficient <code class="reqn">q^{calib}</code> for the
calculation of pointwise and simultaneous prediction intervals
</p>
<p style="text-align: center;"><code class="reqn">[l,u] = \hat{y}^*_m  \pm q^{calib} \hat{se}(Y_m - y^*_m),</code>
</p>

<p>lower prediction limits
</p>
<p style="text-align: center;"><code class="reqn">l = \hat{y}^*_m - q^{calib} \hat{se}(Y_m - y^*_m)</code>
</p>

<p>or upper prediction limits
</p>
<p style="text-align: center;"><code class="reqn">u = \hat{y}^*_m  + q^{calib} \hat{se}(Y_m - y^*_m)</code>
</p>

<p>that cover all of <code class="reqn">m=1, ... , M</code> future observations. <br />
</p>
<p>In this notation, <code class="reqn">\hat{y}^*_m</code> are the expected future observations for each of
the <code class="reqn">m</code> future clusters, <code class="reqn">q^{calib}</code> is the
calibrated coefficient and <code class="reqn">\hat{se}(Y_m - y^*_m)</code>
are the standard errors of the prediction. <br />
</p>


<h3>Value</h3>

<p>This function returns <code class="reqn">q^{calib}</code> in the equation above.
</p>


<h3>References</h3>

<p>Menssen and Schaarschmidt (2022): Prediction intervals for all of M future
observations based on linear random effects models. Statistica Neerlandica. <br />
<a href="https://doi.org/10.1111/stan.12260">doi:10.1111/stan.12260</a>
</p>

<hr>
<h2 id='boot_predint'>Bootstrap new data from uncalibrated prediction intervals</h2><span id='topic+boot_predint'></span>

<h3>Description</h3>

<p><code>boot_predint()</code> is a helper function to bootstrap new data from the simple
uncalibrated prediction intervals implemented in predint.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boot_predint(pred_int, nboot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boot_predint_+3A_pred_int">pred_int</code></td>
<td>
<p>object of class <code>c("quasiPoissonPI", "betaBinomialPI",
"quasiBinomialPI", negativeBinomialPI)</code></p>
</td></tr>
<tr><td><code id="boot_predint_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstraps</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function only works for binomial and Poisson type data. For the sampling
of new data from random effects models see <code><a href="#topic+lmer_bs">lmer_bs</a></code>.
</p>


<h3>Value</h3>

<p><code>boot_predint</code> returns an object of class <code>c("predint", "bootstrap")</code>
which is a list with two entries: One for bootstrapped historical observations
and one for bootstrapped future observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simple quasi-Poisson PI
test_pi &lt;- qp_pi(histoffset=c(3,3,3,4,5), newoffset=3, lambda=10, phi=3, q=1.96)

# Draw 5 bootstrap samles
test_boot &lt;- boot_predint(pred_int = test_pi, nboot=50)
str(test_boot)
summary(test_boot)

# Please note that the low number of bootstrap samples was chosen in order to
# decrease computing time. For valid analysis draw at least 10000 bootstrap samples.

</code></pre>

<hr>
<h2 id='c2_dat1'>Cross-classified data (example 1)</h2><span id='topic+c2_dat1'></span>

<h3>Description</h3>

<p>c2_dat1 contains data that is sampled from a balanced cross-classified design.
This data set is used in order to demonstrate the functionality of the <code>lmer_pi_...()</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c2_dat1
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 27 rows and 3 columns:
</p>

<dl>
<dt>y_ijk</dt><dd><p>observations</p>
</dd>
<dt>a</dt><dd><p>treatment a</p>
</dd>
<dt>b</dt><dd><p>treatment b</p>
</dd>
</dl>


<hr>
<h2 id='c2_dat2'>Cross-classified data (example 2)</h2><span id='topic+c2_dat2'></span>

<h3>Description</h3>

<p>c2_dat2 contains data that was sampled from an unbalanced cross-classified design.
This data set is used in order to demonstrate the functionality of the <code>lmer_pi_...()</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c2_dat2
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 21 rows and 3 columns:
</p>

<dl>
<dt>y_ijk</dt><dd><p>observations</p>
</dd>
<dt>a</dt><dd><p>treatment a</p>
</dd>
<dt>b</dt><dd><p>treatment b</p>
</dd>
</dl>


<hr>
<h2 id='c2_dat3'>Cross-classified data (example 3)</h2><span id='topic+c2_dat3'></span>

<h3>Description</h3>

<p>c2_dat3 contains data that was sampled from a balanced cross-classified design.
This data set is used in order to demonstrate the functionality of the <code>lmer_pi_...()</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c2_dat3
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 8 rows and 3 columns:
</p>

<dl>
<dt>y_ijk</dt><dd><p>observations</p>
</dd>
<dt>a</dt><dd><p>treatment a</p>
</dd>
<dt>b</dt><dd><p>treatment b</p>
</dd>
</dl>


<hr>
<h2 id='c2_dat4'>Cross-classified data (example 4)</h2><span id='topic+c2_dat4'></span>

<h3>Description</h3>

<p>c2_dat4 contains data that was sampled from an unbalanced cross-classified design.
This data set is used in order to demonstrate the functionality of the <code>lmer_pi_...()</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c2_dat4
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 6 rows and 3 columns:
</p>

<dl>
<dt>y_ijk</dt><dd><p>observations</p>
</dd>
<dt>a</dt><dd><p>treatment a</p>
</dd>
<dt>b</dt><dd><p>treatment b</p>
</dd>
</dl>


<hr>
<h2 id='lmer_bs'>Sampling of bootstrap data from a given random effects model</h2><span id='topic+lmer_bs'></span>

<h3>Description</h3>

<p><code>lmer_bs()</code> draws bootstrap samples based on the estimates for the mean
and the variance components drawn from a random effects model fit with <code>lme4::lmer()</code>.
Contrary to <code>lme4::bootMer()</code>, the number of observations for each random factor
can vary between the original data set and the bootstrapped data. Random effects
in <code>model</code> have to be specified as <code>(1|random effect)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmer_bs(model, newdat = NULL, futmat_list = NULL, nboot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmer_bs_+3A_model">model</code></td>
<td>
<p>a random effects model of class lmerMod</p>
</td></tr>
<tr><td><code id="lmer_bs_+3A_newdat">newdat</code></td>
<td>
<p>a <code>data.frame</code> with the same column names as the historical data
on which <code>model</code> depends</p>
</td></tr>
<tr><td><code id="lmer_bs_+3A_futmat_list">futmat_list</code></td>
<td>
<p>a list that contains design matrices for each random factor</p>
</td></tr>
<tr><td><code id="lmer_bs_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstrap samples</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data sampling is based on a list of design matrices (one for each random factor)
that can be obtained if <code>newdat</code> and the model formula are provided to
<code>lme4::lFormula()</code>. Hence, each random factor that is part of the initial
model must have at least two replicates in <code>newdat</code>. <br />
If a random factor in the future data set does not have any replicate, a list
that contains design matrices (one for each random factor) can be provided via
<code>futmat_list</code>.
</p>


<h3>Value</h3>

<p>A list of length <code>nboot</code> containing the bootstrapped observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# loading lme4
library(lme4)

# Fitting a random effects model based on c2_dat1

fit &lt;- lmer(y_ijk~(1|a)+(1|b)+(1|a:b), c2_dat1)
summary(fit)

#----------------------------------------------------------------------------

### Using c2_dat2 as newdat

c2_dat2

lmer_bs(model=fit, newdat=c2_dat2, nboot=100)

#----------------------------------------------------------------------------

### Using futmat_list

# c2_dat4 has no replication for b. Hence the list of design matrices can not be
# generated by lme4::lFormula() and have to be provided by hand via futmat_list.

c2_dat4

# Build a list containing the design matrices

fml &lt;- vector(length=4, "list")

names(fml) &lt;- c("a:b", "b", "a", "Residual")

fml[["a:b"]] &lt;- matrix(nrow=6, ncol=2, data=c(1,1,0,0,0,0, 0,0,1,1,1,1))

fml[["b"]] &lt;- matrix(nrow=6, ncol=1, data=c(1,1,1,1,1,1))

fml[["a"]] &lt;- matrix(nrow=6, ncol=2, data=c(1,1,0,0,0,0, 0,0,1,1,1,1))

fml[["Residual"]] &lt;- diag(6)

fml

lmer_bs(model=fit, futmat_list=fml, nboot=100)

</code></pre>

<hr>
<h2 id='lmer_pi'>Prediction intervals for future observations based on linear random effects models (DEPRECATED)</h2><span id='topic+lmer_pi'></span>

<h3>Description</h3>

<p>This function is deprecated. Please use <code>lmer_pi_unstruc()</code>,
<code>lmer_pi_futvec()</code> or <code>lmer_pi_futmat()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmer_pi(
  model,
  newdat = NULL,
  m = NULL,
  alternative = "both",
  alpha = 0.05,
  nboot = 10000,
  lambda_min = 0.01,
  lambda_max = 10,
  traceplot = TRUE,
  n_bisec = 30
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmer_pi_+3A_model">model</code></td>
<td>
<p>a random effects model of class <code>"lmerMod"</code></p>
</td></tr>
<tr><td><code id="lmer_pi_+3A_newdat">newdat</code></td>
<td>
<p>a <code>data.frame</code> with the same column names as the historical data
on which the model depends</p>
</td></tr>
<tr><td><code id="lmer_pi_+3A_m">m</code></td>
<td>
<p>number of future observations</p>
</td></tr>
<tr><td><code id="lmer_pi_+3A_alternative">alternative</code></td>
<td>
<p>either &quot;both&quot;, &quot;upper&quot; or &quot;lower&quot;. <code>alternative</code> specifies
if a prediction interval or an upper or a lower prediction limit should be computed</p>
</td></tr>
<tr><td><code id="lmer_pi_+3A_alpha">alpha</code></td>
<td>
<p>defines the level of confidence (1-<code>alpha</code>)</p>
</td></tr>
<tr><td><code id="lmer_pi_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstraps</p>
</td></tr>
<tr><td><code id="lmer_pi_+3A_lambda_min">lambda_min</code></td>
<td>
<p>lower start value for bisection</p>
</td></tr>
<tr><td><code id="lmer_pi_+3A_lambda_max">lambda_max</code></td>
<td>
<p>upper start value for bisection</p>
</td></tr>
<tr><td><code id="lmer_pi_+3A_traceplot">traceplot</code></td>
<td>
<p>if <code>TRUE</code>: plot for visualization of the bisection process</p>
</td></tr>
<tr><td><code id="lmer_pi_+3A_n_bisec">n_bisec</code></td>
<td>
<p>maximal number of bisection steps</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a bootstrap calibrated prediction interval
</p>
<p style="text-align: center;"><code class="reqn">[l,u] = \hat{y} \pm q \sqrt{\hat{var}(\hat{y} - y)}</code>
</p>

<p>with <code class="reqn">\hat{y}</code> as the predicted future observation,
<code class="reqn">y</code> as the observed future observations, <code class="reqn">\sqrt{\hat{var}(\hat{y} - y)}</code>
as the prediction standard error and <code class="reqn">q</code> as the bootstrap calibrated coefficient that
approximates a quantile of the multivariate t-distribution. <br />
Please note that this function relies on linear random effects models that are
fitted with <code>lmer()</code> from the lme4 package. Random effects have to be specified as
<code>(1|random_effect)</code>.<br />
</p>


<h3>Value</h3>

<p>If <code>newdat</code> is specified: A <code>data.frame</code> that contains the future data,
the historical mean (hist_mean), the calibrated coefficient (quant_calib),
the prediction standard error (pred_se), the prediction interval (lower and upper)
and a statement if the prediction interval covers the future observation (cover).
</p>
<p>If <code>m</code> is specified: A <code>data.frame</code> that contains the number of future observations (m)
the historical mean (hist_mean), the calibrated coefficient (quant_calib),
the prediction standard error (pred_se) and the prediction interval (lower and upper).
</p>
<p>If <code>alternative</code> is set to &quot;lower&quot;: Lower prediction limits are computed instead
of a prediction interval.
</p>
<p>If <code>alternative</code> is set to &quot;upper&quot;: Upper prediction limits are computed instead
of a prediction interval.
</p>
<p>If <code>traceplot=TRUE</code>, a graphical overview about the bisection process is given.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This function is deprecated.
# Please use lmer_pi_unstruc() if you want exactly the same functionality.
# Please use lmer_pi_futmat() or lmer_pi_futvec() if you want to take care
# of the future experimental design

</code></pre>

<hr>
<h2 id='lmer_pi_futmat'>Prediction intervals for future observations based on linear random effects models</h2><span id='topic+lmer_pi_futmat'></span>

<h3>Description</h3>

<p><code>lmer_pi_futmat()</code> calculates a bootstrap calibrated prediction interval for one or more
future observation(s) based on linear random effects models. With this approach,
the experimental design of the future data is taken into account (see below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmer_pi_futmat(
  model,
  newdat = NULL,
  futmat_list = NULL,
  alternative = "both",
  alpha = 0.05,
  nboot = 10000,
  delta_min = 0.01,
  delta_max = 10,
  tolerance = 0.001,
  traceplot = TRUE,
  n_bisec = 30,
  algorithm = "MS22"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmer_pi_futmat_+3A_model">model</code></td>
<td>
<p>a random effects model of class  <code>"lmerMod"</code></p>
</td></tr>
<tr><td><code id="lmer_pi_futmat_+3A_newdat">newdat</code></td>
<td>
<p>either 1 or a <code>data.frame</code> with the same column names as the historical data
on which <code>model</code> depends</p>
</td></tr>
<tr><td><code id="lmer_pi_futmat_+3A_futmat_list">futmat_list</code></td>
<td>
<p>a list that contains design matrices for each random factor</p>
</td></tr>
<tr><td><code id="lmer_pi_futmat_+3A_alternative">alternative</code></td>
<td>
<p>either &quot;both&quot;, &quot;upper&quot; or &quot;lower&quot;. <code>alternative</code> specifies
if a prediction interval or an upper or a lower prediction limit should be computed</p>
</td></tr>
<tr><td><code id="lmer_pi_futmat_+3A_alpha">alpha</code></td>
<td>
<p>defines the level of confidence (1-<code>alpha</code>)</p>
</td></tr>
<tr><td><code id="lmer_pi_futmat_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstraps</p>
</td></tr>
<tr><td><code id="lmer_pi_futmat_+3A_delta_min">delta_min</code></td>
<td>
<p>lower start value for bisection</p>
</td></tr>
<tr><td><code id="lmer_pi_futmat_+3A_delta_max">delta_max</code></td>
<td>
<p>upper start value for bisection</p>
</td></tr>
<tr><td><code id="lmer_pi_futmat_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for the coverage probability in the bisection</p>
</td></tr>
<tr><td><code id="lmer_pi_futmat_+3A_traceplot">traceplot</code></td>
<td>
<p>if <code>TRUE</code>: Plot for visualization of the bisection process</p>
</td></tr>
<tr><td><code id="lmer_pi_futmat_+3A_n_bisec">n_bisec</code></td>
<td>
<p>maximal number of bisection steps</p>
</td></tr>
<tr><td><code id="lmer_pi_futmat_+3A_algorithm">algorithm</code></td>
<td>
<p>either &quot;MS22&quot; or &quot;MS22mod&quot; (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns bootstrap-calibrated prediction intervals as well as
lower or upper prediction limits.
</p>
<p>If <code>algorithm</code> is set to &quot;MS22&quot;, both limits of the prediction interval
are calibrated simultaneously using the algorithm described in Menssen and
Schaarschmidt (2022), section 3.2.4. The calibrated prediction interval is given
as
</p>
<p style="text-align: center;"><code class="reqn">[l,u] = \hat{\mu} \pm q^{calib} \sqrt{\widehat{var}(\hat{\mu}) + \sum_{c=1}^{C+1}
\hat{\sigma}^2_c}</code>
</p>

<p>with <code class="reqn">\hat{\mu}</code> as the expected future observation (historical mean) and
<code class="reqn">\hat{\sigma}^2_c</code> as the <code class="reqn">c=1, 2, ..., C</code> variance components and <code class="reqn">\hat{\sigma}^2_{C+1}</code>
as the residual variance obtained from the random
effects model fitted with <code>lme4::lmer()</code> and <code class="reqn">q^{calib}</code> as the as the bootstrap-calibrated
coefficient used for interval calculation. <br />
</p>
<p>If <code>algorithm</code> is set to &quot;MS22mod&quot;, both limits of the prediction interval
are calibrated independently from each other. The resulting prediction interval
is given by
</p>
<p style="text-align: center;"><code class="reqn">[l,u] = \Big[\hat{\mu} - q^{calib}_l \sqrt{\widehat{var}(\hat{\mu}) + \sum_{c=1}^{C+1} \hat{\sigma}^2_c}, \quad
\hat{\mu} + q^{calib}_u \sqrt{\widehat{var}(\hat{\mu}) + \sum_{c=1}^{C+1} \hat{\sigma}^2_c} \Big].</code>
</p>

<p>Please note, that this modification does not affect the calibration procedure, if only
prediction limits are of interest. <br />
</p>
<p>If <code>newdat</code> is defined, the bootstrapped future observations used for the calibration
process mimic the structure of the data set provided via <code>newdat</code>. The
data sampling is based on a list of design matrices (one for each random factor)
that can be obtained if <code>newdat</code> and the model formula are provided to
<code>lme4::lFormula()</code>. Hence, each random factor that is part of the initial
model must have at least two replicates in <code>newdat</code>. <br />
If a random factor in the future data set does not have any replicate, a list
that contains design matrices (one for each random factor) can be provided via <code>futmat_list</code>.
</p>
<p>This function is an implementation of the PI given in Menssen and Schaarschmidt 2022
section 3.2.4, except, that the bootstrap calibration values are drawn from
bootstrap samples that mimic the future data as described above.
</p>


<h3>Value</h3>

<p><code>lmer_pi_futmat()</code> returns an object of class <code>c("predint", "normalPI")</code>
with prediction intervals or limits in the first entry (<code>$prediction</code>).
</p>


<h3>References</h3>

<p>Menssen and Schaarschmidt (2022): Prediction intervals for all of M future
observations based on linear random effects models. Statistica Neerlandica,
<a href="https://doi.org/10.1111/stan.12260">doi:10.1111/stan.12260</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# loading lme4
library(lme4)

# Fitting a random effects model based on c2_dat1
fit &lt;- lmer(y_ijk~(1|a)+(1|b)+(1|a:b), c2_dat1)
summary(fit)

#----------------------------------------------------------------------------
### Using newdat

# Prediction interval using c2_dat2 as future data
pred_int &lt;- lmer_pi_futmat(model=fit, newdat=c2_dat2, alternative="both", nboot=100)
summary(pred_int)

# Upper prediction limit for m=1 future observations
pred_u &lt;- lmer_pi_futmat(model=fit, newdat=1, alternative="upper", nboot=100)
summary(pred_u)

#----------------------------------------------------------------------------

### Using futmat_list

# c2_dat4 has no replication for b. Hence the list of design matrices can not be
# generated by lme4::lFormula() and have to be provided by hand via futmat_list.

c2_dat4

# Build a list containing the design matrices

fml &lt;- vector(length=4, "list")

names(fml) &lt;- c("a:b", "b", "a", "Residual")

fml[["a:b"]] &lt;- matrix(nrow=6, ncol=2, data=c(1,1,0,0,0,0, 0,0,1,1,1,1))

fml[["b"]] &lt;- matrix(nrow=6, ncol=1, data=c(1,1,1,1,1,1))

fml[["a"]] &lt;- matrix(nrow=6, ncol=2, data=c(1,1,0,0,0,0, 0,0,1,1,1,1))

fml[["Residual"]] &lt;- diag(6)

fml

# Please note, that the design matrix for the interaction term a:b is also
# provided even there is no replication for b, since it is assumed that
# both, the historical and the future data descent from the same data generating
# process.

# Calculate the PI
pred_fml &lt;- lmer_pi_futmat(model=fit, futmat_list=fml, alternative="both", nboot=100)
summary(pred_fml)

#----------------------------------------------------------------------------

# Please note that nboot was set to 100 in order to decrease computing time
# of the example. For a valid analysis set nboot=10000.

</code></pre>

<hr>
<h2 id='lmer_pi_futvec'>Prediction intervals for future observations based on linear random effects models</h2><span id='topic+lmer_pi_futvec'></span>

<h3>Description</h3>

<p><code>lmer_pi_futvec()</code> calculates a bootstrap calibrated prediction interval for one or more
future observation(s) based on linear random effects models. With this approach,
the experimental design of the future data is taken into account (see below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmer_pi_futvec(
  model,
  futvec,
  newdat = NULL,
  alternative = "both",
  alpha = 0.05,
  nboot = 10000,
  delta_min = 0.01,
  delta_max = 10,
  tolerance = 0.001,
  traceplot = TRUE,
  n_bisec = 30,
  algorithm = "MS22"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmer_pi_futvec_+3A_model">model</code></td>
<td>
<p>a random effects model of class lmerMod</p>
</td></tr>
<tr><td><code id="lmer_pi_futvec_+3A_futvec">futvec</code></td>
<td>
<p>an integer vector that defines the structure of the future data based on the
row numbers of the historical data. If <code>length(futvec)</code> is one, a PI
for one future observation is computed</p>
</td></tr>
<tr><td><code id="lmer_pi_futvec_+3A_newdat">newdat</code></td>
<td>
<p>a <code>data.frame</code> with the same column names as the historical data
on which  <code>model</code> depends</p>
</td></tr>
<tr><td><code id="lmer_pi_futvec_+3A_alternative">alternative</code></td>
<td>
<p>either &quot;both&quot;, &quot;upper&quot; or &quot;lower&quot;. <code>alternative</code> specifies
if a prediction interval or an upper or a lower prediction limit should be computed</p>
</td></tr>
<tr><td><code id="lmer_pi_futvec_+3A_alpha">alpha</code></td>
<td>
<p>defines the level of confidence (1-<code>alpha</code>)</p>
</td></tr>
<tr><td><code id="lmer_pi_futvec_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstraps</p>
</td></tr>
<tr><td><code id="lmer_pi_futvec_+3A_delta_min">delta_min</code></td>
<td>
<p>lower start value for bisection</p>
</td></tr>
<tr><td><code id="lmer_pi_futvec_+3A_delta_max">delta_max</code></td>
<td>
<p>upper start value for bisection</p>
</td></tr>
<tr><td><code id="lmer_pi_futvec_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for the coverage probability in the bisection</p>
</td></tr>
<tr><td><code id="lmer_pi_futvec_+3A_traceplot">traceplot</code></td>
<td>
<p>if <code>TRUE</code>: Plot for visualization of the bisection process</p>
</td></tr>
<tr><td><code id="lmer_pi_futvec_+3A_n_bisec">n_bisec</code></td>
<td>
<p>maximal number of bisection steps</p>
</td></tr>
<tr><td><code id="lmer_pi_futvec_+3A_algorithm">algorithm</code></td>
<td>
<p>either &quot;MS22&quot; or &quot;MS22mod&quot; (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns bootstrap-calibrated prediction intervals as well as
lower or upper prediction limits.
</p>
<p>If <code>algorithm</code> is set to &quot;MS22&quot;, both limits of the prediction interval
are calibrated simultaneously using the algorithm described in Menssen and
Schaarschmidt (2022), section 3.2.4. The calibrated prediction interval is given
as
</p>
<p style="text-align: center;"><code class="reqn">[l,u] = \hat{\mu} \pm q^{calib} \sqrt{\widehat{var}(\hat{\mu}) + \sum_{c=1}^{C+1}
\hat{\sigma}^2_c}</code>
</p>

<p>with <code class="reqn">\hat{\mu}</code> as the expected future observation (historical mean) and
<code class="reqn">\hat{\sigma}^2_c</code> as the <code class="reqn">c=1, 2, ..., C</code> variance components and <code class="reqn">\hat{\sigma}^2_{C+1}</code>
as the residual variance obtained from the random
effects model fitted with <code>lme4::lmer()</code> and <code class="reqn">q^{calib}</code> as the as the bootstrap-calibrated
coefficient used for interval calculation. <br />
</p>
<p>If <code>algorithm</code> is set to &quot;MS22mod&quot;, both limits of the prediction interval
are calibrated independently from each other. The resulting prediction interval
is given by
</p>
<p style="text-align: center;"><code class="reqn">[l,u] = \Big[\hat{\mu} - q^{calib}_l \sqrt{\widehat{var}(\hat{\mu}) + \sum_{c=1}^{C+1} \hat{\sigma}^2_c}, \quad
\hat{\mu} + q^{calib}_u \sqrt{\widehat{var}(\hat{\mu}) + \sum_{c=1}^{C+1} \hat{\sigma}^2_c} \Big].</code>
</p>

<p>Please note, that this modification does not affect the calibration procedure, if only
prediction limits are of interest. <br />
</p>
<p>Be aware that the sampling structure of the historical data must contain the structure of the
future data. This means that the observations per random factor must be less or
equal in the future data compared to the historical data.
</p>
<p>This function is an implementation of the PI given in Menssen and Schaarschmidt 2022 section 3.2.4
except that the bootstrap calibration values are drawn from bootstrap samples that
mimic the future data.
</p>


<h3>Value</h3>

<p><code>lmer_pi_futvec()</code> returns an object of class <code>c("predint", "normalPI")</code>
with prediction intervals or limits in the first entry (<code>$prediction</code>).
</p>


<h3>References</h3>

<p>Menssen and Schaarschmidt (2022): Prediction intervals for all of M future
observations based on linear random effects models. Statistica Neerlandica,
<a href="https://doi.org/10.1111/stan.12260">doi:10.1111/stan.12260</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# loading lme4
library(lme4)

# Fitting a random effects model based on c2_dat1
fit &lt;- lmer(y_ijk~(1|a)+(1|b)+(1|a:b), c2_dat1)
summary(fit)

#----------------------------------------------------------------------------

### Prediction interval using c2_dat3 as future data
# without printing c2_dat3 in the output

# Row numbers of the historical data c2_dat1 that define the structure of
# the future data c2_dat3
futvec &lt;- c(1, 2, 4, 5, 10, 11, 13, 14)

# Calculating the PI
pred_int &lt;- lmer_pi_futvec(model=fit, futvec=futvec, nboot=100)
summary(pred_int)

#----------------------------------------------------------------------------

### Calculating the PI with c2_dat3 printed in the output
pred_int_new &lt;- lmer_pi_futvec(model=fit, futvec=futvec, newdat=c2_dat3, nboot=100)
summary(pred_int_new)

#----------------------------------------------------------------------------

### Upper prediction limit for m=1 future observation
pred_u &lt;- lmer_pi_futvec(model=fit, futvec=1, alternative="upper", nboot=100)
summary(pred_u)

#----------------------------------------------------------------------------

# Please note that nboot was set to 100 in order to decrease computing time
# of the example. For a valid analysis set nboot=10000.

</code></pre>

<hr>
<h2 id='lmer_pi_unstruc'>Prediction intervals for future observations based on linear random effects models</h2><span id='topic+lmer_pi_unstruc'></span>

<h3>Description</h3>

<p><code>lmer_pi_unstruc()</code> calculates a bootstrap calibrated prediction interval for one or more
future observation(s) based on linear random effects models as described in section
3.2.4. of Menssen and Schaarschmidt (2022).
Please note, that the bootstrap calibration used here does not consider the sampling
structure of the future data, since the calibration values are drawn randomly from
bootstrap data sets that have the same structure as the historical data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lmer_pi_unstruc(
  model,
  newdat = NULL,
  m = NULL,
  alternative = "both",
  alpha = 0.05,
  nboot = 10000,
  delta_min = 0.01,
  delta_max = 10,
  tolerance = 0.001,
  traceplot = TRUE,
  n_bisec = 30,
  algorithm = "MS22"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lmer_pi_unstruc_+3A_model">model</code></td>
<td>
<p>a random effects model of class lmerMod</p>
</td></tr>
<tr><td><code id="lmer_pi_unstruc_+3A_newdat">newdat</code></td>
<td>
<p>a <code>data.frame</code> with the same column names as the historical data
on which the model depends</p>
</td></tr>
<tr><td><code id="lmer_pi_unstruc_+3A_m">m</code></td>
<td>
<p>number of future observations</p>
</td></tr>
<tr><td><code id="lmer_pi_unstruc_+3A_alternative">alternative</code></td>
<td>
<p>either &quot;both&quot;, &quot;upper&quot; or &quot;lower&quot;. <code>alternative</code> specifies
if a prediction interval or an upper or a lower prediction limit should be computed</p>
</td></tr>
<tr><td><code id="lmer_pi_unstruc_+3A_alpha">alpha</code></td>
<td>
<p>defines the level of confidence (1-<code>alpha</code>)</p>
</td></tr>
<tr><td><code id="lmer_pi_unstruc_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstraps</p>
</td></tr>
<tr><td><code id="lmer_pi_unstruc_+3A_delta_min">delta_min</code></td>
<td>
<p>lower start value for bisection</p>
</td></tr>
<tr><td><code id="lmer_pi_unstruc_+3A_delta_max">delta_max</code></td>
<td>
<p>upper start value for bisection</p>
</td></tr>
<tr><td><code id="lmer_pi_unstruc_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for the coverage probability in the bisection</p>
</td></tr>
<tr><td><code id="lmer_pi_unstruc_+3A_traceplot">traceplot</code></td>
<td>
<p>if <code>TRUE</code>: Plot for visualization of the bisection process</p>
</td></tr>
<tr><td><code id="lmer_pi_unstruc_+3A_n_bisec">n_bisec</code></td>
<td>
<p>maximal number of bisection steps</p>
</td></tr>
<tr><td><code id="lmer_pi_unstruc_+3A_algorithm">algorithm</code></td>
<td>
<p>either &quot;MS22&quot; or &quot;MS22mod&quot; (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns bootstrap-calibrated prediction intervals as well as
lower or upper prediction limits.
</p>
<p>If <code>algorithm</code> is set to &quot;MS22&quot;, both limits of the prediction interval
are calibrated simultaneously using the algorithm described in Menssen and
Schaarschmidt (2022), section 3.2.4. The calibrated prediction interval is given
as
</p>
<p style="text-align: center;"><code class="reqn">[l,u] = \hat{\mu} \pm q^{calib} \sqrt{\widehat{var}(\hat{\mu}) + \sum_{c=1}^{C+1}
\hat{\sigma}^2_c}</code>
</p>

<p>with <code class="reqn">\hat{\mu}</code> as the expected future observation (historical mean) and
<code class="reqn">\hat{\sigma}^2_c</code> as the <code class="reqn">c=1, 2, ..., C</code> variance components and <code class="reqn">\hat{\sigma}^2_{C+1}</code>
as the residual variance obtained from the random
effects model fitted with <code>lme4::lmer()</code> and <code class="reqn">q^{calib}</code> as the as the bootstrap-calibrated
coefficient used for interval calculation. <br />
</p>
<p>If <code>algorithm</code> is set to &quot;MS22mod&quot;, both limits of the prediction interval
are calibrated independently from each other. The resulting prediction interval
is given by
</p>
<p style="text-align: center;"><code class="reqn">[l,u] = \Big[\hat{\mu} - q^{calib}_l \sqrt{\widehat{var}(\hat{\mu}) + \sum_{c=1}^{C+1} \hat{\sigma}^2_c}, \quad
\hat{\mu} + q^{calib}_u \sqrt{\widehat{var}(\hat{\mu}) + \sum_{c=1}^{C+1} \hat{\sigma}^2_c} \Big].</code>
</p>

<p>Please note, that this modification does not affect the calibration procedure, if only
prediction limits are of interest. <br />
</p>
<p>This function is an direct implementation of the PI given in Menssen and Schaarschmidt
2022 section 3.2.4.
</p>


<h3>Value</h3>

<p><code>lmer_pi_futvec()</code> returns an object of class <code>c("predint", "normalPI")</code>
with prediction intervals or limits in the first entry (<code>$prediction</code>).
</p>


<h3>References</h3>

<p>Menssen and Schaarschmidt (2022): Prediction intervals for all of M future
observations based on linear random effects models. Statistica Neerlandica,
<a href="https://doi.org/10.1111/stan.12260">doi:10.1111/stan.12260</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># loading lme4
library(lme4)

# Fitting a random effects model based on c2_dat1
fit &lt;- lmer(y_ijk~(1|a)+(1|b)+(1|a:b), c2_dat1)
summary(fit)

# Prediction interval using c2_dat2 as future data
pred_int &lt;- lmer_pi_unstruc(model=fit, newdat=c2_dat2, alternative="both", nboot=100)
summary(pred_int)

# Upper prediction limit for m=3 future observations
pred_u &lt;- lmer_pi_unstruc(model=fit, m=3, alternative="upper", nboot=100)
summary(pred_u)

# Please note that nboot was set to 100 in order to decrease computing time
# of the example. For a valid analysis set nboot=10000.

</code></pre>

<hr>
<h2 id='mortality_HCD'>Historical mortality of male B6C3F1-mice</h2><span id='topic+mortality_HCD'></span>

<h3>Description</h3>

<p>This data set contains historical control data about the mortality of male B6C3F1-mice
obtained in long term carcinogenicity studies at the National Toxicology Program
presented in NTP Historical Control Reports from 2013 to 2016.
It was used in Menssen and Schaarschmidt 2019 as a real life example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mortality_HCD
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 2 rows and 10 columns:
</p>

<dl>
<dt>dead</dt><dd><p>no. of dead mice</p>
</dd>
<dt>alive</dt><dd><p>no. of living mice</p>
</dd>
</dl>



<h3>References</h3>

<p>Menssen and Schaarschmidt (2019): Prediction intervals for overdispersed binomial
data with application to historical controls. Statistics in Medicine.
<a href="https://doi.org/10.1002/sim.8124">doi:10.1002/sim.8124</a> <br />
NTP Historical Control Reports: <a href="https://ntp.niehs.nih.gov/data/controls">https://ntp.niehs.nih.gov/data/controls</a>
</p>

<hr>
<h2 id='nb_pi'>Simple uncalibrated prediction intervals for negative-binomial data</h2><span id='topic+nb_pi'></span>

<h3>Description</h3>

<p><code>nb_pi()</code> is a helper function that is internally called by  <code>neg_bin_pi()</code>. It
calculates simple uncalibrated prediction intervals for negative-binomial data
with offsets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nb_pi(
  newoffset,
  histoffset,
  lambda,
  kappa,
  q = qnorm(1 - 0.05/2),
  alternative = "both",
  newdat = NULL,
  histdat = NULL,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nb_pi_+3A_newoffset">newoffset</code></td>
<td>
<p>number of experimental units in the future clusters</p>
</td></tr>
<tr><td><code id="nb_pi_+3A_histoffset">histoffset</code></td>
<td>
<p>number of experimental units in the historical clusters</p>
</td></tr>
<tr><td><code id="nb_pi_+3A_lambda">lambda</code></td>
<td>
<p>overall Poisson mean</p>
</td></tr>
<tr><td><code id="nb_pi_+3A_kappa">kappa</code></td>
<td>
<p>dispersion parameter</p>
</td></tr>
<tr><td><code id="nb_pi_+3A_q">q</code></td>
<td>
<p>quantile used for interval calculation</p>
</td></tr>
<tr><td><code id="nb_pi_+3A_alternative">alternative</code></td>
<td>
<p>either &quot;both&quot;, &quot;upper&quot; or &quot;lower&quot;.
<code>alternative</code> specifies, if a prediction interval or
an upper or a lower prediction limit should be computed</p>
</td></tr>
<tr><td><code id="nb_pi_+3A_newdat">newdat</code></td>
<td>
<p>additional argument to specify the current data set</p>
</td></tr>
<tr><td><code id="nb_pi_+3A_histdat">histdat</code></td>
<td>
<p>additional argument to specify the historical data set</p>
</td></tr>
<tr><td><code id="nb_pi_+3A_algorithm">algorithm</code></td>
<td>
<p>used to define the algorithm for calibration if called via
<code>quasi_pois_pi()</code>. This argument is not of interest for the calculation
of simple uncalibrated intervals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a simple uncalibrated prediction interval
</p>
<p style="text-align: center;"><code class="reqn">[l,u]_m = n^*_m \hat{\lambda} \pm q \sqrt{n^*_m
\frac{\hat{\lambda} + \hat{\kappa} \bar{n} \hat{\lambda}}{\bar{n} H} +
(n^*_m \hat{\lambda} + \hat{\kappa} n^{*2}_m \hat{\lambda}^2)
}</code>
</p>

<p>with <code class="reqn">n^*_m</code> as the number of experimental units in <code class="reqn">m=1, 2, ... , M</code> future clusters,
<code class="reqn">\hat{\lambda}</code> as the estimate for the Poisson mean obtained from the
historical data, <code class="reqn">\hat{\kappa}</code> as the estimate for the dispersion parameter,
<code class="reqn">n_h</code> as the number of experimental units per historical cluster and
<code class="reqn">\bar{n}=\sum_h^{n_h} n_h / H</code>. <br />
</p>
<p>The direct application of this uncalibrated prediction interval to real life data
is not recommended. Please use the <code>neg_bin_pi()</code> function for real life applications.
</p>


<h3>Value</h3>

<p><code>np_pi</code> returns an object of class <code>c("predint", "negativeBinomialPI")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Prediction interval
nb_pred &lt;- nb_pi(newoffset=3, lambda=3, kappa=0.04, histoffset=1:9, q=qnorm(1-0.05/2))
summary(nb_pred)

</code></pre>

<hr>
<h2 id='neg_bin_pi'>Prediction intervals for negative-binomial data</h2><span id='topic+neg_bin_pi'></span>

<h3>Description</h3>

<p><code>neg_bin_pi()</code> calculates bootstrap calibrated prediction intervals for
negative-binomial data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neg_bin_pi(
  histdat,
  newdat = NULL,
  newoffset = NULL,
  alternative = "both",
  alpha = 0.05,
  nboot = 10000,
  delta_min = 0.01,
  delta_max = 10,
  tolerance = 0.001,
  traceplot = TRUE,
  n_bisec = 30,
  algorithm = "MS22mod"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="neg_bin_pi_+3A_histdat">histdat</code></td>
<td>
<p>a <code>data.frame</code> with two columns. The first has to contain
the historical observations. The second has to contain the number of experimental
units per study (offsets).</p>
</td></tr>
<tr><td><code id="neg_bin_pi_+3A_newdat">newdat</code></td>
<td>
<p><code>data.frame</code> with two columns. The first has to contain
the future observations. The second has to contain the number of experimental
units per study (offsets).</p>
</td></tr>
<tr><td><code id="neg_bin_pi_+3A_newoffset">newoffset</code></td>
<td>
<p>vector with future number of experimental units per historical
study.</p>
</td></tr>
<tr><td><code id="neg_bin_pi_+3A_alternative">alternative</code></td>
<td>
<p>either &quot;both&quot;, &quot;upper&quot; or &quot;lower&quot;.
<code>alternative</code> specifies if a prediction interval or
an upper or a lower prediction limit should be computed</p>
</td></tr>
<tr><td><code id="neg_bin_pi_+3A_alpha">alpha</code></td>
<td>
<p>defines the level of confidence (<code class="reqn">1-\alpha</code>)</p>
</td></tr>
<tr><td><code id="neg_bin_pi_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstraps</p>
</td></tr>
<tr><td><code id="neg_bin_pi_+3A_delta_min">delta_min</code></td>
<td>
<p>lower start value for bisection</p>
</td></tr>
<tr><td><code id="neg_bin_pi_+3A_delta_max">delta_max</code></td>
<td>
<p>upper start value for bisection</p>
</td></tr>
<tr><td><code id="neg_bin_pi_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for the coverage probability in the bisection</p>
</td></tr>
<tr><td><code id="neg_bin_pi_+3A_traceplot">traceplot</code></td>
<td>
<p>if <code>TRUE</code>: Plot for visualization of the bisection process</p>
</td></tr>
<tr><td><code id="neg_bin_pi_+3A_n_bisec">n_bisec</code></td>
<td>
<p>maximal number of bisection steps</p>
</td></tr>
<tr><td><code id="neg_bin_pi_+3A_algorithm">algorithm</code></td>
<td>
<p>either &quot;MS22&quot; or &quot;MS22mod&quot; (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns bootstrap-calibrated prediction intervals as well as
lower or upper prediction limits.
</p>
<p>If <code>algorithm</code> is set to &quot;MS22&quot;, both limits of the prediction interval
are calibrated simultaneously using the algorithm described in Menssen and
Schaarschmidt (2022), section 3.2.4. The calibrated prediction interval is given
as
</p>
<p style="text-align: center;"><code class="reqn">[l,u]_m = n^*_m \hat{\lambda} \pm q \sqrt{n^*_m
\frac{\hat{\lambda} + \hat{\kappa} \bar{n} \hat{\lambda}}{\bar{n} H} +
(n^*_m \hat{\lambda} + \hat{\kappa} n^{*2}_m \hat{\lambda}^2)
}</code>
</p>

<p>with <code class="reqn">n^*_m</code> as the number of experimental units in the future clusters,
<code class="reqn">\hat{\lambda}</code> as the estimate for the Poisson mean obtained from the
historical data, <code class="reqn">\hat{\kappa}</code> as the estimate for the dispersion parameter,
<code class="reqn">n_h</code> as the number of experimental units per historical cluster and
<code class="reqn">\bar{n}=\sum_h^{n_h} n_h / H</code>.  <br />
</p>
<p>If <code>algorithm</code> is set to &quot;MS22mod&quot;, both limits of the prediction interval
are calibrated independently from each other. The resulting prediction interval
is given by
</p>
<p style="text-align: center;"><code class="reqn">[l,u] = \Big[n^*_m \hat{\lambda} - q^{calib}_l \sqrt{n^*_m
\frac{\hat{\lambda} + \hat{\kappa} \bar{n} \hat{\lambda}}{\bar{n} H} +
(n^*_m \hat{\lambda} + \hat{\kappa} n^{*2}_m \hat{\lambda}^2)}, \quad
 n^*_m \hat{\lambda} + q^{calib}_u \sqrt{n^*_m
\frac{\hat{\lambda} + \hat{\kappa} \bar{n} \hat{\lambda}}{\bar{n} H} +
(n^*_m \hat{\lambda} + \hat{\kappa} n^{*2}_m \hat{\lambda}^2)
} \Big]</code>
</p>

<p>Please note, that this modification does not affect the calibration procedure, if only
prediction limits are of interest.
</p>


<h3>Value</h3>

<p><code>neg_bin_pi()</code> returns an object of class <code>c("predint", "negativeBinomialPI")</code>
with prediction intervals or limits in the first entry (<code>$prediction</code>).
</p>


<h3>References</h3>

<p>Menssen and Schaarschmidt (2022): Prediction intervals for all of M future
observations based on linear random effects models. Statistica Neerlandica,
<a href="https://doi.org/10.1111/stan.12260">doi:10.1111/stan.12260</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># HCD from the Ames test
ames_HCD

# Prediction interval for one future number of revertant colonies
# obtained in three petridishes
pred_int &lt;- neg_bin_pi(histdat=ames_HCD, newoffset=3, nboot=100)
summary(pred_int)

# Please note that nboot was set to 100 in order to decrease computing time
# of the example. For a valid analysis set nboot=10000.

</code></pre>

<hr>
<h2 id='normal_pi'>Simple uncalibrated prediction intervals for normal distributed data</h2><span id='topic+normal_pi'></span>

<h3>Description</h3>

<p><code>normal_pi()</code> is a helper function that is internally called by the <code>lmer_pi_...()</code> functions.
It calculates simple uncalibrated prediction intervals for normal distributed
observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_pi(
  mu,
  pred_se,
  m = 1,
  q = qnorm(1 - 0.05/2),
  alternative = "both",
  futmat_list = NULL,
  futvec = NULL,
  newdat = NULL,
  histdat = NULL,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="normal_pi_+3A_mu">mu</code></td>
<td>
<p>overall mean</p>
</td></tr>
<tr><td><code id="normal_pi_+3A_pred_se">pred_se</code></td>
<td>
<p>standard error of the prediction</p>
</td></tr>
<tr><td><code id="normal_pi_+3A_m">m</code></td>
<td>
<p>number of future observations</p>
</td></tr>
<tr><td><code id="normal_pi_+3A_q">q</code></td>
<td>
<p>quantile used for interval calculation</p>
</td></tr>
<tr><td><code id="normal_pi_+3A_alternative">alternative</code></td>
<td>
<p>either &quot;both&quot;, &quot;upper&quot; or &quot;lower&quot;
<code>alternative</code> specifies, if a prediction interval or
an upper or a lower prediction limit should be computed</p>
</td></tr>
<tr><td><code id="normal_pi_+3A_futmat_list">futmat_list</code></td>
<td>
<p>used to add the list of future design matrices to the output
if called via <code>lmer_pi_futmat()</code></p>
</td></tr>
<tr><td><code id="normal_pi_+3A_futvec">futvec</code></td>
<td>
<p>used to add the vector of the historical row numbers that define
the future experimental design to the output if called via <code>lmer_pi_futmat()</code></p>
</td></tr>
<tr><td><code id="normal_pi_+3A_newdat">newdat</code></td>
<td>
<p>additional argument to specify the current data set</p>
</td></tr>
<tr><td><code id="normal_pi_+3A_histdat">histdat</code></td>
<td>
<p>additional argument to specify the historical data set</p>
</td></tr>
<tr><td><code id="normal_pi_+3A_algorithm">algorithm</code></td>
<td>
<p>used to define the algorithm for calibration if called via
<code>lmer_pi_...()</code>. This argument is not of interest for the calculation
of simple uncalibrated intervals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a simple uncalibrated prediction interval as
given in Menssen and Schaarschmidt 2022
</p>
<p style="text-align: center;"><code class="reqn">[l,u] = \hat{\mu} \pm q \sqrt{\widehat{var}(\hat{\mu}) + \sum_{c=1}^{C+1} \hat{\sigma}^2_c}</code>
</p>

<p>with <code class="reqn">\hat{\mu}</code> as the expected future observation (historical mean) and
<code class="reqn">\hat{\sigma}^2_c</code> as the <code class="reqn">c=1, 2, ..., C</code> variance components and <code class="reqn">\hat{\sigma}^2_{C+1}</code>
as the residual variance and <code class="reqn">q</code> as the quantile used for interval calculation. <br />
</p>
<p>The direct application of this uncalibrated prediction interval to real life data
is not recommended. Please use the <code>lmer_pi_...()</code> functions for real life applications.  <br />
</p>


<h3>Value</h3>

<p><code>normal_pi()</code> returns an object of class <code>c("predint", "normalPI")</code>
with prediction intervals or limits in the first entry (<code>$prediction</code>).
</p>


<h3>References</h3>

<p>Menssen and Schaarschmidt (2022): Prediction intervals for all of M future
observations based on linear random effects models. Statistica Neerlandica,
<a href="https://doi.org/10.1111/stan.12260">doi:10.1111/stan.12260</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# simple PI
norm_pred &lt;- normal_pi(mu=10, pred_se=3, m=1)
summary(norm_pred)

</code></pre>

<hr>
<h2 id='pi_rho_est'>Estimation of the binomial proportion and the intra class correlation.</h2><span id='topic+pi_rho_est'></span>

<h3>Description</h3>

<p><code>pi_rho_est()</code> estimates the overall binomial proportion <code class="reqn">\hat{\pi}</code> and the intra
class correlation <code class="reqn">\hat{\rho}</code> of data that is assumed to follow the beta-binomial
distribution. The estimation of <code class="reqn">\hat{\pi}</code> and <code class="reqn">\hat{\rho}</code> is done following
the approach of Lui et al. 2000.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pi_rho_est(dat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pi_rho_est_+3A_dat">dat</code></td>
<td>
<p>a <code>data.frame</code> with two columns (successes and failures)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing estimates for <code class="reqn">\pi</code> and <code class="reqn">\rho</code>
</p>


<h3>References</h3>

<p>Lui, K.-J., Mayer, J.A. and Eckhardt, L: Confidence intervals for the risk ratio
under cluster sampling based on the beta-binomial model. Statistics in Medicine.2000;19:2933-2942.
<a href="https://doi.org/10.1002/1097-0258%2820001115%2919%3A21%3C2933%3A%3AAID-SIM591%3E3.0.CO%3B2-Q">doi:10.1002/1097-0258(20001115)19:21&lt;2933::AID-SIM591&gt;3.0.CO;2-Q</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Estimates for bb_dat1
pi_rho_est(bb_dat1)

</code></pre>

<hr>
<h2 id='plot.predint'>Plots of <code>predint</code> objects</h2><span id='topic+plot.predint'></span>

<h3>Description</h3>

<p>This function provides methodology for plotting the prediction intervals or
limits that are calculated using the functionality of the <span class="pkg">predint</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predint'
plot(x, ..., size = 4, width = 0.05, alpha = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.predint_+3A_x">x</code></td>
<td>
<p>object of class <code>predint</code></p>
</td></tr>
<tr><td><code id="plot.predint_+3A_...">...</code></td>
<td>
<p>arguments handed over to <code>ggplot2::aes()</code></p>
</td></tr>
<tr><td><code id="plot.predint_+3A_size">size</code></td>
<td>
<p>size of the dots</p>
</td></tr>
<tr><td><code id="plot.predint_+3A_width">width</code></td>
<td>
<p>margin of jittering</p>
</td></tr>
<tr><td><code id="plot.predint_+3A_alpha">alpha</code></td>
<td>
<p>opacity of dot colors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Since <code>plot.predint()</code> is based on <code>ggplot2::ggplot</code>, it returns
an object of class <code>c("gg", "ggplot")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### PI for quasi-Poisson data
pred_int &lt;- quasi_pois_pi(histdat=ames_HCD,
                          newoffset=3,
                          nboot=100,
                          traceplot = FALSE)

### Plot the PI
plot(pred_int)

### Since plot.predint is based on ggplot, the grafic can be altered using
# the methodology provided via ggplot2
plot(pred_int)+
     theme_classic()

</code></pre>

<hr>
<h2 id='print.predint'>Print objects of class <code>predint</code></h2><span id='topic+print.predint'></span>

<h3>Description</h3>

<p>Print objects of class <code>predint</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predint'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.predint_+3A_x">x</code></td>
<td>
<p>an object of class <code>predint</code></p>
</td></tr>
<tr><td><code id="print.predint_+3A_...">...</code></td>
<td>
<p>additional arguments passed over to <code>base::cbind()</code> and <code>base::data.frame()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints output to the console
</p>

<hr>
<h2 id='qb_dat1'>Quasi-binomial data (example 1)</h2><span id='topic+qb_dat1'></span>

<h3>Description</h3>

<p>This data set contains sampled quasi-binomial data from 10 clusters
each of size 50. The data set was sampled with <code>rqbinom(n=10, size=50, prob=0.1, phi=3)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qb_dat1
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 3 rows and 2 columns:
</p>

<dl>
<dt>succ</dt><dd><p>numbers of success</p>
</dd>
<dt>fail</dt><dd><p>numbers of failures</p>
</dd>
</dl>


<hr>
<h2 id='qb_dat2'>Quasi-binomial data (example 2)</h2><span id='topic+qb_dat2'></span>

<h3>Description</h3>

<p>This data set contains sampled quasi binomial data from 3 clusters with
different size.The data set was sampled with <code>rqbinom(n=3, size=c(40, 50, 60), prob=0.1, phi=3)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qb_dat2
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 3 rows and 2 columns:
</p>

<dl>
<dt>succ</dt><dd><p>numbers of success</p>
</dd>
<dt>fail</dt><dd><p>numbers of failures</p>
</dd>
</dl>


<hr>
<h2 id='qb_pi'>Simple uncalibrated prediction intervals for quasi-binomial data</h2><span id='topic+qb_pi'></span>

<h3>Description</h3>

<p><code>qb_pi()</code> is a helper function that is internally called by  <code>quasi_bin_pi()</code>. It
calculates simple uncalibrated prediction intervals for binary
data with constant overdispersion (quasi-binomial assumption).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qb_pi(
  newsize,
  histsize,
  pi,
  phi,
  q = qnorm(1 - 0.05/2),
  alternative = "both",
  newdat = NULL,
  histdat = NULL,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qb_pi_+3A_newsize">newsize</code></td>
<td>
<p>number of experimental units in the historical clusters.</p>
</td></tr>
<tr><td><code id="qb_pi_+3A_histsize">histsize</code></td>
<td>
<p>number of experimental units in the future clusters.</p>
</td></tr>
<tr><td><code id="qb_pi_+3A_pi">pi</code></td>
<td>
<p>binomial proportion</p>
</td></tr>
<tr><td><code id="qb_pi_+3A_phi">phi</code></td>
<td>
<p>dispersion parameter</p>
</td></tr>
<tr><td><code id="qb_pi_+3A_q">q</code></td>
<td>
<p>quantile used for interval calculation</p>
</td></tr>
<tr><td><code id="qb_pi_+3A_alternative">alternative</code></td>
<td>
<p>either &quot;both&quot;, &quot;upper&quot; or &quot;lower&quot;
<code>alternative</code> specifies, if a prediction interval or
an upper or a lower prediction limit should be computed</p>
</td></tr>
<tr><td><code id="qb_pi_+3A_newdat">newdat</code></td>
<td>
<p>additional argument to specify the current data set</p>
</td></tr>
<tr><td><code id="qb_pi_+3A_histdat">histdat</code></td>
<td>
<p>additional argument to specify the historical data set</p>
</td></tr>
<tr><td><code id="qb_pi_+3A_algorithm">algorithm</code></td>
<td>
<p>used to define the algorithm for calibration if called via
<code>quasi_bin_pi</code>. This argument is not of interest for the calculation
of simple uncalibrated intervals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a simple uncalibrated prediction interval
</p>
<p style="text-align: center;"><code class="reqn">[l,u]_m = n^*_m \hat{\pi} \pm q \sqrt{\hat{\phi} n^*_m \hat{\pi} (1- \hat{\pi}) +
\frac{\hat{\phi} n^{*2}_m \hat{\pi} (1- \hat{\pi})}{\sum_h n_h}}</code>
</p>

<p>with <code class="reqn">n^*_m</code> as the number of experimental units in the <code class="reqn">m=1, 2, ... , M</code> future clusters,
<code class="reqn">\hat{\pi}</code> as the estimate for the binomial proportion obtained from the
historical data, <code class="reqn">\hat{\phi}</code> as the estimate for the dispersion parameter
and <code class="reqn">n_h</code> as the number of experimental units per historical cluster. <br />
</p>
<p>The direct application of this uncalibrated prediction interval to real life data
is not recommended. Please use the <code>beta_bin_pi()</code> functions for real life applications. <br />
</p>


<h3>Value</h3>

<p><code>qb_pi</code> returns an object of class <code>c("predint", "quasiBinomailPI")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qb_pred &lt;- qb_pi(newsize=50, pi=0.3, phi=3, histsize=c(50, 50, 30), q=qnorm(1-0.05/2))
summary(qb_pred)

</code></pre>

<hr>
<h2 id='qp_dat1'>Quasi-Poisson data (example 1)</h2><span id='topic+qp_dat1'></span>

<h3>Description</h3>

<p>This data set contains sampled quasi-Poisson data for 10 clusters.
The data set was sampled with <code>rqpois(n=10, lambda=50, phi=3)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qp_dat1
</code></pre>


<h3>Format</h3>

<p>A data.frame with two columns
</p>

<dl>
<dt>y</dt><dd><p>numbers of eventzs</p>
</dd>
<dt>offset</dt><dd><p>size of experimental units</p>
</dd>
</dl>


<hr>
<h2 id='qp_dat2'>Quasi-Poisson data (example 2)</h2><span id='topic+qp_dat2'></span>

<h3>Description</h3>

<p>This data set contains sampled quasi-Poisson data for 3 clusters.
The data set was sampled with <code>rqpois(n=3, lambda=50, phi=3)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qp_dat2
</code></pre>


<h3>Format</h3>

<p>A data.frame with two columns
</p>

<dl>
<dt>y</dt><dd><p>numbers of eventzs</p>
</dd>
<dt>offset</dt><dd><p>size of experimental units</p>
</dd>
</dl>


<hr>
<h2 id='qp_pi'>Simple uncalibrated prediction intervals for quasi-Poisson data</h2><span id='topic+qp_pi'></span>

<h3>Description</h3>

<p><code>qp_pi()</code> is a helper function that is internally called by  <code>quasi_pois_pi()</code>. It
calculates simple uncalibrated prediction intervals for Poisson
data with constant overdispersion (quasi-Poisson assumption).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qp_pi(
  newoffset,
  histoffset,
  lambda,
  phi,
  q = qnorm(1 - 0.05/2),
  alternative = "both",
  newdat = NULL,
  histdat = NULL,
  algorithm = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qp_pi_+3A_newoffset">newoffset</code></td>
<td>
<p>number of experimental units in the future clusters</p>
</td></tr>
<tr><td><code id="qp_pi_+3A_histoffset">histoffset</code></td>
<td>
<p>number of experimental units in the historical clusters</p>
</td></tr>
<tr><td><code id="qp_pi_+3A_lambda">lambda</code></td>
<td>
<p>overall Poisson mean</p>
</td></tr>
<tr><td><code id="qp_pi_+3A_phi">phi</code></td>
<td>
<p>dispersion parameter</p>
</td></tr>
<tr><td><code id="qp_pi_+3A_q">q</code></td>
<td>
<p>quantile used for interval calculation</p>
</td></tr>
<tr><td><code id="qp_pi_+3A_alternative">alternative</code></td>
<td>
<p>either &quot;both&quot;, &quot;upper&quot; or &quot;lower&quot;
<code>alternative</code> specifies, if a prediction interval or
an upper or a lower prediction limit should be computed</p>
</td></tr>
<tr><td><code id="qp_pi_+3A_newdat">newdat</code></td>
<td>
<p>additional argument to specify the current data set</p>
</td></tr>
<tr><td><code id="qp_pi_+3A_histdat">histdat</code></td>
<td>
<p>additional argument to specify the historical data set</p>
</td></tr>
<tr><td><code id="qp_pi_+3A_algorithm">algorithm</code></td>
<td>
<p>used to define the algorithm for calibration if called via
<code>quasi_pois_pi()</code>. This argument is not of interest for the calculation
of simple uncalibrated intervals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a simple uncalibrated prediction interval
</p>
<p style="text-align: center;"><code class="reqn">[l,u]_m = n^*_m \hat{\lambda} \pm q \sqrt{n^*_m \hat{\phi} \hat{\lambda} +
 \frac{n^{*2}_m \hat{\phi} \hat{\lambda}}{\sum_h n_h}}</code>
</p>

<p>with <code class="reqn">n^*_m</code> as the number of experimental units in the <code class="reqn">m=1, 2, ... , M</code> future clusters,
<code class="reqn">\hat{\lambda}</code> as the estimate for the Poisson mean obtained from the
historical data, <code class="reqn">\hat{\phi}</code> as the estimate for the dispersion parameter
and <code class="reqn">n_h</code> as the number of experimental units per historical cluster. <br />
</p>
<p>The direct application of this uncalibrated prediction interval to real life data
is not recommended. Please use the <code>quasi_pois_pi_pi()</code> functions for real life applications.
</p>


<h3>Value</h3>

<p><code>qp_pi</code> returns an object of class <code>c("predint", "quasiPoissonPI")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Prediction interval
qp_pred &lt;- qp_pi(newoffset=3, lambda=3, phi=3, histoffset=1:9, q=qnorm(1-0.05/2))
summary(qp_pred)

</code></pre>

<hr>
<h2 id='quasi_bin_pi'>Prediction intervals for quasi-binomial data</h2><span id='topic+quasi_bin_pi'></span>

<h3>Description</h3>

<p><code>quasi_bin_pi()</code> calculates bootstrap calibrated prediction intervals for binomial
data with constant overdispersion (quasi-binomial assumption).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quasi_bin_pi(
  histdat,
  newdat = NULL,
  newsize = NULL,
  alternative = "both",
  alpha = 0.05,
  nboot = 10000,
  delta_min = 0.01,
  delta_max = 10,
  tolerance = 0.001,
  traceplot = TRUE,
  n_bisec = 30,
  algorithm = "MS22mod"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quasi_bin_pi_+3A_histdat">histdat</code></td>
<td>
<p>a <code>data.frame</code> with two columns (success and failures) containing the historical data</p>
</td></tr>
<tr><td><code id="quasi_bin_pi_+3A_newdat">newdat</code></td>
<td>
<p>a <code>data.frame</code> with two columns (success and failures) containing the future data</p>
</td></tr>
<tr><td><code id="quasi_bin_pi_+3A_newsize">newsize</code></td>
<td>
<p>a vector containing the future cluster sizes</p>
</td></tr>
<tr><td><code id="quasi_bin_pi_+3A_alternative">alternative</code></td>
<td>
<p>either &quot;both&quot;, &quot;upper&quot; or &quot;lower&quot;. <code>alternative</code>
specifies if a prediction interval or an upper or a lower prediction limit
should be computed</p>
</td></tr>
<tr><td><code id="quasi_bin_pi_+3A_alpha">alpha</code></td>
<td>
<p>defines the level of confidence (1-alpha)</p>
</td></tr>
<tr><td><code id="quasi_bin_pi_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstraps</p>
</td></tr>
<tr><td><code id="quasi_bin_pi_+3A_delta_min">delta_min</code></td>
<td>
<p>lower start value for bisection</p>
</td></tr>
<tr><td><code id="quasi_bin_pi_+3A_delta_max">delta_max</code></td>
<td>
<p>upper start value for bisection</p>
</td></tr>
<tr><td><code id="quasi_bin_pi_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for the coverage probability in the bisection</p>
</td></tr>
<tr><td><code id="quasi_bin_pi_+3A_traceplot">traceplot</code></td>
<td>
<p>if <code>TRUE</code>: Plot for visualization of the bisection process</p>
</td></tr>
<tr><td><code id="quasi_bin_pi_+3A_n_bisec">n_bisec</code></td>
<td>
<p>maximal number of bisection steps</p>
</td></tr>
<tr><td><code id="quasi_bin_pi_+3A_algorithm">algorithm</code></td>
<td>
<p>either &quot;MS22&quot; or &quot;MS22mod&quot; (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns bootstrap-calibrated prediction intervals as well as
lower or upper prediction limits.
</p>
<p>If <code>algorithm</code> is set to &quot;MS22&quot;, both limits of the prediction interval
are calibrated simultaneously using the algorithm described in Menssen and
Schaarschmidt (2022), section 3.2.4. The calibrated prediction interval is given
as
</p>
<p style="text-align: center;"><code class="reqn">[l,u]_m = n^*_m \hat{\pi} \pm q^{calib} \hat{se}(Y_m - y^*_m)</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\hat{se}(Y_m - y^*_m) = \sqrt{\hat{\phi} n^*_m \hat{\pi} (1- \hat{\pi}) +
\frac{\hat{\phi} n^{*2}_m \hat{\pi} (1- \hat{\pi})}{\sum_h n_h}}</code>
</p>

<p>with <code class="reqn">n^*_m</code> as the number of experimental units in the future clusters,
<code class="reqn">\hat{\pi}</code> as the estimate for the binomial proportion obtained from the
historical data, <code class="reqn">q^{calib}</code> as the bootstrap-calibrated coefficient,
<code class="reqn">\hat{\phi}</code> as the estimate for the dispersion parameter
and <code class="reqn">n_h</code> as the number of experimental units per historical cluster. <br />
</p>
<p>If <code>algorithm</code> is set to &quot;MS22mod&quot;, both limits of the prediction interval
are calibrated independently from each other. The resulting prediction interval
is given by
</p>
<p style="text-align: center;"><code class="reqn">[l,u] = \Big[n^*_m \hat{\pi} - q^{calib}_l \hat{se}(Y_m - y^*_m), \quad
n^*_m \hat{\pi} + q^{calib}_u \hat{se}(Y_m - y^*_m) \Big]</code>
</p>

<p>Please note, that this modification does not affect the calibration procedure, if only
prediction limits are of interest.
</p>


<h3>Value</h3>

<p><code>quasi_bin_pi</code> returns an object of class <code>c("predint", "quasiBinomialPI")</code>
with prediction intervals or limits in the first entry (<code>$prediction</code>).
</p>


<h3>References</h3>

<p>Menssen and Schaarschmidt (2019): Prediction intervals for overdispersed binomial
data with application to historical controls. Statistics in Medicine.
<a href="https://doi.org/10.1002/sim.8124">doi:10.1002/sim.8124</a> <br />
Menssen and Schaarschmidt (2022): Prediction intervals for all of M future
observations based on linear random effects models. Statistica Neerlandica,
<a href="https://doi.org/10.1111/stan.12260">doi:10.1111/stan.12260</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Pointwise prediction interval
pred_int &lt;- quasi_bin_pi(histdat=mortality_HCD, newsize=40, nboot=100)
summary(pred_int)

# Pointwise upper prediction limit
pred_u &lt;- quasi_bin_pi(histdat=mortality_HCD, newsize=40, alternative="upper", nboot=100)
summary(pred_u)

# Please note that nboot was set to 100 in order to decrease computing time
# of the example. For a valid analysis set nboot=10000.

</code></pre>

<hr>
<h2 id='quasi_pois_pi'>Prediction intervals for quasi-Poisson data</h2><span id='topic+quasi_pois_pi'></span>

<h3>Description</h3>

<p><code>quasi_pois_pi()</code> calculates bootstrap calibrated prediction intervals for Poisson
data with constant overdispersion (quasi-Poisson).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quasi_pois_pi(
  histdat,
  newdat = NULL,
  newoffset = NULL,
  alternative = "both",
  alpha = 0.05,
  nboot = 10000,
  delta_min = 0.01,
  delta_max = 10,
  tolerance = 0.001,
  traceplot = TRUE,
  n_bisec = 30,
  algorithm = "MS22mod"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quasi_pois_pi_+3A_histdat">histdat</code></td>
<td>
<p>a <code>data.frame</code> with two columns. The first has to contain
the historical observations. The second has to contain the number of experimental
units per study (offsets).</p>
</td></tr>
<tr><td><code id="quasi_pois_pi_+3A_newdat">newdat</code></td>
<td>
<p>a <code>data.frame</code> with two columns. The first has to contain
the future observations. The second has to contain the number of experimental
units per study (offsets).</p>
</td></tr>
<tr><td><code id="quasi_pois_pi_+3A_newoffset">newoffset</code></td>
<td>
<p>vector with future number of experimental units per historical
study.</p>
</td></tr>
<tr><td><code id="quasi_pois_pi_+3A_alternative">alternative</code></td>
<td>
<p>either &quot;both&quot;, &quot;upper&quot; or &quot;lower&quot;.
<code>alternative</code> specifies if a prediction interval or
an upper or a lower prediction limit should be computed</p>
</td></tr>
<tr><td><code id="quasi_pois_pi_+3A_alpha">alpha</code></td>
<td>
<p>defines the level of confidence (<code class="reqn">1-\alpha</code>)</p>
</td></tr>
<tr><td><code id="quasi_pois_pi_+3A_nboot">nboot</code></td>
<td>
<p>number of bootstraps</p>
</td></tr>
<tr><td><code id="quasi_pois_pi_+3A_delta_min">delta_min</code></td>
<td>
<p>lower start value for bisection</p>
</td></tr>
<tr><td><code id="quasi_pois_pi_+3A_delta_max">delta_max</code></td>
<td>
<p>upper start value for bisection</p>
</td></tr>
<tr><td><code id="quasi_pois_pi_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for the coverage probability in the bisection</p>
</td></tr>
<tr><td><code id="quasi_pois_pi_+3A_traceplot">traceplot</code></td>
<td>
<p>if <code>TRUE</code>: Plot for visualization of the bisection process</p>
</td></tr>
<tr><td><code id="quasi_pois_pi_+3A_n_bisec">n_bisec</code></td>
<td>
<p>maximal number of bisection steps</p>
</td></tr>
<tr><td><code id="quasi_pois_pi_+3A_algorithm">algorithm</code></td>
<td>
<p>either &quot;MS22&quot; or &quot;MS22mod&quot; (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns bootstrap-calibrated prediction intervals as well as
lower or upper prediction limits.
</p>
<p>If <code>algorithm</code> is set to &quot;MS22&quot;, both limits of the prediction interval
are calibrated simultaneously using the algorithm described in Menssen and
Schaarschmidt (2022), section 3.2.4. The calibrated prediction interval is given
as
</p>
<p style="text-align: center;"><code class="reqn">[l,u]_m = n^*_m \hat{\lambda} \pm q^{calib} \sqrt{n^*_m \hat{\phi} \hat{\lambda} +
 \frac{n^{*2}_m \hat{\phi} \hat{\lambda}}{\sum_h n_h}}</code>
</p>

<p>with <code class="reqn">n^*_m</code> as the number of experimental units in the future clusters,
<code class="reqn">\hat{\lambda}</code> as the estimate for the Poisson mean obtained from the
historical data, <code class="reqn">q^{calib}</code> as the bootstrap-calibrated coefficient,
<code class="reqn">\hat{\phi}</code> as the estimate for the dispersion parameter
and <code class="reqn">n_h</code> as the number of experimental units per historical cluster. <br />
</p>
<p>If <code>algorithm</code> is set to &quot;MS22mod&quot;, both limits of the prediction interval
are calibrated independently from each other. The resulting prediction interval
is given by
</p>
<p style="text-align: center;"><code class="reqn">[l,u] = \Big[n^*_m \hat{\lambda} - q^{calib}_l \sqrt{n^*_m \hat{\phi} \hat{\lambda} +
 \frac{n^{*2}_m \hat{\phi} \hat{\lambda}}{\sum_h n_h}}, \quad
 n^*_m \hat{\lambda} + q^{calib}_u \sqrt{n^*_m \hat{\phi} \hat{\lambda} +
 \frac{n^{*2}_m \hat{\phi} \hat{\lambda}}{\sum_h n_h}} \Big]</code>
</p>

<p>Please note, that this modification does not affect the calibration procedure, if only
prediction limits are of interest.
</p>


<h3>Value</h3>

<p><code>quasi_pois_pi</code> returns an object of class <code>c("predint", "quasiPoissonPI")</code>
with prediction intervals or limits in the first entry (<code>$prediction</code>).
</p>


<h3>References</h3>

<p>Menssen and Schaarschmidt (2022): Prediction intervals for all of M future
observations based on linear random effects models. Statistica Neerlandica,
<a href="https://doi.org/10.1111/stan.12260">doi:10.1111/stan.12260</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' # Historical data
qp_dat1

# Future data
qp_dat2

# Pointwise prediction interval
pred_int &lt;- quasi_pois_pi(histdat=ames_HCD, newoffset=3, nboot=100)
summary(pred_int)

# Pointwise upper prediction
pred_u &lt;- quasi_pois_pi(histdat=ames_HCD, newoffset=3, alternative="upper", nboot=100)
summary(pred_u)

# Please note that nboot was set to 100 in order to decrease computing time
# of the example. For a valid analysis set nboot=10000.

</code></pre>

<hr>
<h2 id='rbbinom'>Sampling of beta-binomial data</h2><span id='topic+rbbinom'></span>

<h3>Description</h3>

<p><code>rbbinom()</code> samples beta-binomial data according to Menssen and Schaarschmidt (2019).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbbinom(n, size, prob, rho)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rbbinom_+3A_n">n</code></td>
<td>
<p>defines the number of clusters (<code class="reqn">i</code>)</p>
</td></tr>
<tr><td><code id="rbbinom_+3A_size">size</code></td>
<td>
<p>integer vector defining the number of trials per cluster (<code class="reqn">n_i</code>)</p>
</td></tr>
<tr><td><code id="rbbinom_+3A_prob">prob</code></td>
<td>
<p>probability of success on each trial (<code class="reqn">\pi</code>)</p>
</td></tr>
<tr><td><code id="rbbinom_+3A_rho">rho</code></td>
<td>
<p>intra class correlation (<code class="reqn">\rho</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For beta binomial data with <code class="reqn">i=1, ... I</code> clusters, the variance is
</p>
<p style="text-align: center;"><code class="reqn">var(y_i)= n_i \pi (1-\pi) [1+ (n_i - 1) \rho]</code>
</p>

<p>with <code class="reqn">\rho</code> as the intra class correlation coefficient
</p>
<p style="text-align: center;"><code class="reqn">\rho = 1 / (1+a+b).</code>
</p>

<p>For the sampling <code class="reqn">(a+b)</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">(a+b)=(1-\rho)/\rho</code>
</p>

<p>where <code class="reqn">a=\pi (a+b)</code> and <code class="reqn">b=(a+b)-a</code>. Then, the binomial proportions
for each cluster are sampled from the beta distribution
</p>
<p style="text-align: center;"><code class="reqn">\pi_i \sim Beta(a, b)</code>
</p>

<p>and the number of successes for each cluster are sampled to be
</p>
<p style="text-align: center;"><code class="reqn">y_i \sim Bin(n_i, \pi_i).</code>
</p>

<p>In this parametrization <code class="reqn">E(\pi_i)=\pi=a/(a+b)</code> and <code class="reqn">E(y_i)=n_i \pi</code>.
Please note, that <code class="reqn">1+ (n_i-1) \rho</code> is a constant if all cluster sizes are
the same and hence, in this special case, also the quasi-binomial assumption is
fulfilled.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with two columns (succ, fail)
</p>


<h3>References</h3>

<p>Menssen M, Schaarschmidt F.: Prediction intervals for overdispersed binomial data
with application to historical controls. Statistics in Medicine. 2019;38:2652-2663.
<a href="https://doi.org/10.1002/sim.8124">doi:10.1002/sim.8124</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sampling of example data
set.seed(234)
bb_dat1 &lt;- rbbinom(n=10, size=50, prob=0.1, rho=0.06)
bb_dat1


set.seed(234)
bb_dat2 &lt;- rbbinom(n=3, size=c(40, 50, 60), prob=0.1, rho=0.06)
bb_dat2


</code></pre>

<hr>
<h2 id='rnbinom'>Sampling of negative binomial data</h2><span id='topic+rnbinom'></span>

<h3>Description</h3>

<p><code>rnbinom()</code> samples negative-binomial data.
The following description of the sampling process is based on the parametrization
used by Gsteiger et al. 2013.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rnbinom(n, lambda, kappa, offset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rnbinom_+3A_n">n</code></td>
<td>
<p>defines the number of clusters (<code class="reqn">I</code>)</p>
</td></tr>
<tr><td><code id="rnbinom_+3A_lambda">lambda</code></td>
<td>
<p>defines the overall Poisson mean (<code class="reqn">\lambda</code>)</p>
</td></tr>
<tr><td><code id="rnbinom_+3A_kappa">kappa</code></td>
<td>
<p>dispersion parameter (<code class="reqn">\kappa</code>)</p>
</td></tr>
<tr><td><code id="rnbinom_+3A_offset">offset</code></td>
<td>
<p>defines the number of experimental units per cluster (<code class="reqn">n_i</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance of the negative-binomial distribution is
</p>
<p style="text-align: center;"><code class="reqn">var(Y_i) = n_i \lambda (1+ \kappa n_i \lambda).</code>
</p>

<p>Negative-biomial observations can be sampled based on predefined values of <code class="reqn">\kappa</code>,
<code class="reqn">\lambda</code> and <code class="reqn">n_i</code>: <br />
Define the parameters of the gamma distribution as <code class="reqn">a=\frac{1}{\kappa}</code> and
<code class="reqn">b_i=\frac{1}{\kappa n_i \lambda}</code>. Then, sample the Poisson means for each cluster
</p>
<p style="text-align: center;"><code class="reqn">\lambda_i \sim Gamma(a, b_i).</code>
</p>

<p>Finally, the observations <code class="reqn">y_i</code> are sampled from the Poisson distribution
</p>
<p style="text-align: center;"><code class="reqn">y_i \sim Pois(\lambda_i)</code>
</p>



<h3>Value</h3>

<p><code>rnbinom()</code> returns a <code>data.frame</code> with two columns:
<code>y</code> as the observations and <code>offset</code> as the number of offsets per
observation.
</p>


<h3>References</h3>

<p>Gsteiger, S., Neuenschwander, B., Mercier, F. and Schmidli, H. (2013):
Using historical control information for the design and analysis of clinical
trials with overdispersed count data. Statistics in  Medicine, 32: 3609-3622.
<a href="https://doi.org/10.1002/sim.5851">doi:10.1002/sim.5851</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Sampling of negative-binomial observations
# with different offsets
set.seed(123)
rnbinom(n=5, lambda=5, kappa=0.13, offset=c(3,3,2,3,2))

</code></pre>

<hr>
<h2 id='rqbinom'>Sampling of overdispersed binomial data with constant overdispersion</h2><span id='topic+rqbinom'></span>

<h3>Description</h3>

<p>rqbinom samples overdispersed binomial data with constant overdispersion from
the beta-binomial distribution such that the quasi-binomial assumption is fulfilled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rqbinom(n, size, prob, phi)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rqbinom_+3A_n">n</code></td>
<td>
<p>defines the number of clusters (<code class="reqn">i</code>)</p>
</td></tr>
<tr><td><code id="rqbinom_+3A_size">size</code></td>
<td>
<p>integer vector defining the number of trials per cluster (<code class="reqn">n_i</code>)</p>
</td></tr>
<tr><td><code id="rqbinom_+3A_prob">prob</code></td>
<td>
<p>probability of success on each trial (<code class="reqn">\pi</code>)</p>
</td></tr>
<tr><td><code id="rqbinom_+3A_phi">phi</code></td>
<td>
<p>dispersion parameter (<code class="reqn">\Phi</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that the dispersion parameter (<code class="reqn">\Phi</code>)
is constant for all <code class="reqn">i=1, ... I</code> clusters, such that the variance becomes
</p>
<p style="text-align: center;"><code class="reqn">var(y_i)=\Phi n_i \pi (1-\pi).</code>
</p>

<p>For the sampling <code class="reqn">(a+b)_i</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">(a+b)_i=(\Phi-n_i)/(1-\Phi)</code>
</p>

<p>where <code class="reqn">a_i=\pi (a+b)_i</code> and <code class="reqn">b_i=(a+b)_i-a_i</code>. Then, the binomial proportions
for each cluster are sampled from the beta distribution
</p>
<p style="text-align: center;"><code class="reqn">\pi_i \sim Beta(a_i, b_i)</code>
</p>

<p>and the numbers of success for each cluster are sampled to be
</p>
<p style="text-align: center;"><code class="reqn">y_i \sim Bin(n_i, \pi_i).</code>
</p>

<p>In this parametrization <code class="reqn">E(\pi_i)=\pi</code> and <code class="reqn">E(y_i)=n_i \pi</code>.
Please note, the quasi-binomial assumption is not in contradiction with
the beta-binomial distribution if all cluster sizes are the same.
</p>


<h3>Value</h3>

<p>a <code>data.frame</code> with two columns (succ, fail)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Sampling of example data
set.seed(456)
qb_dat1 &lt;- rqbinom(n=10, size=50, prob=0.1, phi=3)
qb_dat1

set.seed(456)
qb_dat2 &lt;- rqbinom(n=3, size=c(40, 50, 60), prob=0.1, phi=3)
qb_dat2


</code></pre>

<hr>
<h2 id='rqpois'>Sampling of overdispersed Poisson data with constant overdispersion</h2><span id='topic+rqpois'></span>

<h3>Description</h3>

<p><code>rqpois()</code> samples overdispersed Poisson data with constant overdispersion from
the negative-binomial distribution such that the quasi-Poisson assumption is fulfilled.
The following description of the sampling process is based on the parametrization
used by Gsteiger et al. 2013.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rqpois(n, lambda, phi, offset = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rqpois_+3A_n">n</code></td>
<td>
<p>defines the number of clusters (<code class="reqn">I</code>)</p>
</td></tr>
<tr><td><code id="rqpois_+3A_lambda">lambda</code></td>
<td>
<p>defines the overall Poisson mean (<code class="reqn">\lambda</code>)</p>
</td></tr>
<tr><td><code id="rqpois_+3A_phi">phi</code></td>
<td>
<p>dispersion parameter (<code class="reqn">\Phi</code>)</p>
</td></tr>
<tr><td><code id="rqpois_+3A_offset">offset</code></td>
<td>
<p>defines the number of experimental units per cluster (<code class="reqn">n_i</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is assumed that the dispersion parameter (<code class="reqn">\Phi</code>)
is constant for all <code class="reqn">i=1, ... I</code> clusters, such that the variance becomes
</p>
<p style="text-align: center;"><code class="reqn">var(y_i) = \Phi n_i \lambda</code>
</p>

<p>For the sampling <code class="reqn">\kappa_i</code> is defined as
</p>
<p style="text-align: center;"><code class="reqn">\kappa_i=(\Phi-1)/(n_i \lambda)</code>
</p>

<p>where <code class="reqn">a_i=1/\kappa_i</code> and <code class="reqn">b_i=1/(\kappa_i n_i \lambda)</code>. Then, the Poisson means
for each cluster are sampled from the gamma distribution
</p>
<p style="text-align: center;"><code class="reqn">\lambda_i \sim Gamma(a_i, b_i)</code>
</p>

<p>and the observations per cluster are sampled to be
</p>
<p style="text-align: center;"><code class="reqn">y_i \sim Pois(\lambda_i).</code>
</p>

<p>Please note, that the quasi-Poisson assumption is not in contradiction with the
negative-binomial distribution, if the data structure is defined by the number
of clusters only (which is the case here) and the offsets are all the same
<code class="reqn">n_h = n_{h´} = n</code>.
</p>


<h3>Value</h3>

<p>a data.frame containing the sampled observations and the offsets
</p>


<h3>References</h3>

<p>Gsteiger, S., Neuenschwander, B., Mercier, F. and Schmidli, H. (2013):
Using historical control information for the design and analysis of clinical
trials with overdispersed count data. Statistics in  Medicine, 32: 3609-3622.
<a href="https://doi.org/10.1002/sim.5851">doi:10.1002/sim.5851</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set.seed(123)
qp_dat1 &lt;- rqpois(n=10, lambda=50, phi=3)
qp_dat1

# set.seed(123)
qp_dat2 &lt;- rqpois(n=3, lambda=50, phi=3)
qp_dat2


</code></pre>

<hr>
<h2 id='summary.predint'>Summarizing objects of class <code>predint</code></h2><span id='topic+summary.predint'></span>

<h3>Description</h3>

<p>This function gives a summary about the prediction intervals (and limits)
computed with <span class="pkg">predint</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'predint'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.predint_+3A_object">object</code></td>
<td>
<p>object of class <code>predint</code></p>
</td></tr>
<tr><td><code id="summary.predint_+3A_...">...</code></td>
<td>
<p>further arguments passed over to <code>base::cbind()</code> and <code>base::data.frame()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the current data (if provided via <code>newdat</code>),
the prediction interval (or limit), the expected value for the future observation,
the bootstrap calibrated coefficient(s), the prediction standard error and
a statement about the coverage for each future observation, if new observations
were provided via <code>newdat</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fitting a random effects model based on c2_dat1
fit &lt;- lme4::lmer(y_ijk~(1|a)+(1|b)+(1|a:b), c2_dat1)


# Prediction interval using c2_dat2 as future data
pred_int &lt;- lmer_pi_futmat(model=fit, newdat=c2_dat2, alternative="both", nboot=100)
summary(pred_int)

#----------------------------------------------------------------------------

# Please note that nboot was set to 100 in order to decrease computing time
# of the example. For a valid analysis set nboot=10000.

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
