<!DOCTYPE html><html><head><title>Help for package tidyjson</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tidyjson}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+5B.tbl_json'><p>Extract subsets of a tbl_json object (not replace)</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Objects exported from other packages</p></a></li>
<li><a href='#allowed_json_types'><p>Fundamental JSON types from http://json.org/, where I collapse 'true' and</p>
'false' into 'logical'</a></li>
<li><a href='#append_values'><p>Appends all JSON values with a specified type as a new column</p></a></li>
<li><a href='#append_values_factory'><p>Creates the append_values_* functions</p></a></li>
<li><a href='#append_values_type'><p>get list of values from json</p></a></li>
<li><a href='#as_tibble'><p>Objects exported from other packages</p></a></li>
<li><a href='#as_tibble.tbl_json'><p>Convert a tbl_json back to a tbl_df</p></a></li>
<li><a href='#as.character.tbl_json'><p>Convert the JSON in an tbl_json object back to a JSON string</p></a></li>
<li><a href='#bind_rows'><p>Objects exported from other packages</p></a></li>
<li><a href='#commits'><p>Commit data for the dplyr repo from github API</p></a></li>
<li><a href='#companies'><p>Startup company information for 1,000 companies</p></a></li>
<li><a href='#determine_types'><p>Determines the types of a list of parsed JSON</p></a></li>
<li><a href='#enter_object'><p>Enter into a specific object and discard all other JSON data</p></a></li>
<li><a href='#filter'><p>Objects exported from other packages</p></a></li>
<li><a href='#gather_array'><p>Gather a JSON array into index-value pairs</p></a></li>
<li><a href='#gather_factory'><p>Factory to create gather functions</p></a></li>
<li><a href='#gather_object'><p>Gather a JSON object into name-value pairs</p></a></li>
<li><a href='#has_names'><p>Check for Names</p></a></li>
<li><a href='#is_data_list'><p>List Check</p></a></li>
<li><a href='#is_json'><p>Predicates to test for specific JSON types in <code>tbl_json</code> objects</p></a></li>
<li><a href='#is_json_factory'><p>Factory to create <code>is_json</code> functions</p></a></li>
<li><a href='#issues'><p>Issue data for the dplyr repo from github API</p></a></li>
<li><a href='#json_complexity'><p>Compute the complexity (recursively unlisted length) of JSON data</p></a></li>
<li><a href='#json_factory'><p>Factory that creates the j* functions below</p></a></li>
<li><a href='#json_functions'><p>Navigates nested objects to get at names of a specific type, to be used as</p>
arguments to <code>spread_values</code></a></li>
<li><a href='#json_get'><p>Get JSON from a tbl_json</p></a></li>
<li><a href='#json_get_column'><p>Make the JSON data a persistent column</p></a></li>
<li><a href='#json_lengths'><p>Compute the length of JSON data</p></a></li>
<li><a href='#json_schema'><p>Create a schema for a JSON document or collection</p></a></li>
<li><a href='#json_structure'><p>Recursively structures arbitrary JSON data into a single data frame</p></a></li>
<li><a href='#json_types'><p>Add a column that tells the 'type' of the JSON data</p></a></li>
<li><a href='#my_unlist'><p>Unlists while preserving NULLs and only unlisting lists with one value</p></a></li>
<li><a href='#path'><p>Create a JSON path with a minimum of typing</p></a></li>
<li><a href='#print.tbl_json'><p>Print a tbl_json object</p></a></li>
<li><a href='#rbind_tbl_json'><p>Bind two tbl_json objects together and preserve JSON attribute</p></a></li>
<li><a href='#read_json'><p>Reads JSON from an input uri (file, url, ...) and returns a</p>
<code>tbl_json</code> object</a></li>
<li><a href='#spread_all'><p>Spreads all scalar values of a JSON object into new columns</p></a></li>
<li><a href='#spread_values'><p>Spreads specific scalar values of a JSON object into new columns</p></a></li>
<li><a href='#tbl_json'><p>Combines structured JSON (as a data.frame) with remaining JSON</p></a></li>
<li><a href='#tidyjson'><p>tidyjson</p></a></li>
<li><a href='#worldbank'><p>Projects funded by the World Bank</p></a></li>
<li><a href='#wrap_dplyr_verb'><p>Wrapper for extending dplyr verbs to tbl_json objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tidy Complex 'JSON'</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Turn complex 'JSON' data into tidy data frames.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/colearendt/tidyjson">https://github.com/colearendt/tidyjson</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/colearendt/tidyjson/issues">https://github.com/colearendt/tidyjson/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, dplyr (&ge; 1.0.0), jsonlite, magrittr, purrr,
rlang, tibble, tidyr (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, forcats, ggplot2, igraph, knitr, listviewer, lubridate,
RColorBrewer, rmarkdown, rprojroot, testthat (&ge; 3.0.0), vctrs,
viridis, wordcloud</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-06 19:11:30 UTC; rstudio-user</td>
</tr>
<tr>
<td>Author:</td>
<td>Jeremy Stanley [aut],
  Cole Arendt [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cole Arendt &lt;cole@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-07 00:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.tbl_json'>Extract subsets of a tbl_json object (not replace)</h2><span id='topic++5B.tbl_json'></span>

<h3>Description</h3>

<p>Extends '[.data.frame' to work with tbl_json objects, so that row filtering
of the underlying data.frame also filters the associated JSON.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_json'
.x[i, j, drop = FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.tbl_json_+3A_.x">.x</code></td>
<td>
<p>a tbl_json object</p>
</td></tr>
<tr><td><code id="+2B5B.tbl_json_+3A_i">i</code></td>
<td>
<p>row elements to extract</p>
</td></tr>
<tr><td><code id="+2B5B.tbl_json_+3A_j">j</code></td>
<td>
<p>column elements to extract</p>
</td></tr>
<tr><td><code id="+2B5B.tbl_json_+3A_drop">drop</code></td>
<td>
<p>whether or not to simplify results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+tbl_json">tbl_json</a></code> object
</p>

<hr>
<h2 id='+25+26gt+3B+25'>Objects exported from other packages</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='allowed_json_types'>Fundamental JSON types from http://json.org/, where I collapse 'true' and
'false' into 'logical'</h2><span id='topic+allowed_json_types'></span>

<h3>Description</h3>

<p>Fundamental JSON types from http://json.org/, where I collapse 'true' and
'false' into 'logical'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allowed_json_types
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 6.
</p>

<hr>
<h2 id='append_values'>Appends all JSON values with a specified type as a new column</h2><span id='topic+append_values'></span><span id='topic+append_values_string'></span><span id='topic+append_values_number'></span><span id='topic+append_values_logical'></span>

<h3>Description</h3>

<p>The <code>append_values</code> functions let you take any scalar JSON values
of a given type (&quot;string&quot;, &quot;number&quot;, &quot;logical&quot;) and add them as a new
column named <code>column.name</code>. This is particularly useful after using
<code><a href="#topic+gather_object">gather_object</a></code> to gather an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_values_string(.x, column.name = type, force = TRUE, recursive = FALSE)

append_values_number(.x, column.name = type, force = TRUE, recursive = FALSE)

append_values_logical(.x, column.name = type, force = TRUE, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_values_+3A_.x">.x</code></td>
<td>
<p>a json string or <code><a href="#topic+tbl_json">tbl_json</a></code> object</p>
</td></tr>
<tr><td><code id="append_values_+3A_column.name">column.name</code></td>
<td>
<p>the name of the column to append values as</p>
</td></tr>
<tr><td><code id="append_values_+3A_force">force</code></td>
<td>
<p>should values be coerced to the appropriate type
when possible, otherwise, types are checked first (requires more
memory)</p>
</td></tr>
<tr><td><code id="append_values_+3A_recursive">recursive</code></td>
<td>
<p>logical indicating whether to recurisvely extract a single
value from a nested object. Only used when <code>force = TRUE</code>. If
<code>force = FALSE</code>, and <code>recursive = TRUE</code>, throws an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any values that can not be converted to the specified will be <code>NA</code> in
the resulting column. This includes other scalar types (e.g., numbers or
logicals if you are using <code>append_values_string</code>) and *also* any rows
where the JSON is NULL or an object or array.
</p>
<p>Note that the <code>append_values</code> functions do not alter the JSON
attribute of the <code>tbl_json</code> object in any way.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+tbl_json">tbl_json</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gather_object">gather_object</a></code> to gather an object first,
<code><a href="#topic+spread_all">spread_all</a></code> to spread values into new columns,
<code><a href="#topic+json_get_column">json_get_column</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Stack names
'{"first": "bob", "last": "jones"}' %&gt;%
  gather_object %&gt;%
  append_values_string

# This is most useful when data is stored in name-value pairs
# For example, tags in recipes:
recipes &lt;- c('{"name": "pie", "tags": {"apple": 10, "pie": 2, "flour": 5}}',
             '{"name": "cookie", "tags": {"chocolate": 2, "cookie": 1}}')
recipes %&gt;%
  spread_values(name = jstring(name)) %&gt;%
  enter_object(tags) %&gt;%
  gather_object("tag") %&gt;%
  append_values_number("count")
</code></pre>

<hr>
<h2 id='append_values_factory'>Creates the append_values_* functions</h2><span id='topic+append_values_factory'></span>

<h3>Description</h3>

<p>Creates the append_values_* functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_values_factory(type, as.value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_values_factory_+3A_type">type</code></td>
<td>
<p>the JSON type that will be appended</p>
</td></tr>
<tr><td><code id="append_values_factory_+3A_as.value">as.value</code></td>
<td>
<p>function to force coercion to numeric, string, or logical</p>
</td></tr>
</table>

<hr>
<h2 id='append_values_type'>get list of values from json</h2><span id='topic+append_values_type'></span>

<h3>Description</h3>

<p>get list of values from json
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_values_type(json, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_values_type_+3A_json">json</code></td>
<td>
<p>extracted using attributes</p>
</td></tr>
<tr><td><code id="append_values_type_+3A_type">type</code></td>
<td>
<p>input type (numeric, string, etc)</p>
</td></tr>
</table>

<hr>
<h2 id='as_tibble'>Objects exported from other packages</h2><span id='topic+as_tibble'></span><span id='topic+as_data_frame'></span><span id='topic+tbl_df'></span><span id='topic+reexports'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+reexports">as_data_frame</a></code></p>
</dd>
<dt>tibble</dt><dd><p><code><a href="tibble.html#topic+as_tibble">as_tibble</a></code></p>
</dd>
</dl>


<h3>Details</h3>

<p>Exported from dplyr package.  Converts an object
to a pure tibble (revert to tbl_df class and drops
tbl_json class/attributes).
</p>


<h3>See Also</h3>

<p>as_tibble.tbl_json
</p>

<hr>
<h2 id='as_tibble.tbl_json'>Convert a tbl_json back to a tbl_df</h2><span id='topic+as_tibble.tbl_json'></span><span id='topic+as_data_frame.tbl_json'></span>

<h3>Description</h3>

<p>Drops the JSON attribute and the tbl_json class, so that
we are back to a pure tbl_df.  Useful for some internals.  Also useful
when you are done processing the JSON portion of your data and are
ready to move on to other tools.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_json'
as_tibble(x, ...)

as_data_frame.tbl_json(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_tibble.tbl_json_+3A_x">x</code></td>
<td>
<p>a tbl_json object</p>
</td></tr>
<tr><td><code id="as_tibble.tbl_json_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that as.tbl calls tbl_df under the covers, which in turn
calls as_tibble.  As a result, this should take care of all cases.
</p>


<h3>Value</h3>

<p>a tbl_df object (with no tbl_json component)
</p>

<hr>
<h2 id='as.character.tbl_json'>Convert the JSON in an tbl_json object back to a JSON string</h2><span id='topic+as.character.tbl_json'></span>

<h3>Description</h3>

<p>Convert the JSON in an tbl_json object back to a JSON string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_json'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.character.tbl_json_+3A_x">x</code></td>
<td>
<p>a tbl_json object</p>
</td></tr>
<tr><td><code id="as.character.tbl_json_+3A_...">...</code></td>
<td>
<p>not used (<code><a href="purrr.html#topic+map_chr">map_chr</a></code> used instead)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector of formatted JSON
</p>

<hr>
<h2 id='bind_rows'>Objects exported from other packages</h2><span id='topic+bind_rows'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+bind_rows">bind_rows</a></code></p>
</dd>
</dl>

<hr>
<h2 id='commits'>Commit data for the dplyr repo from github API</h2><span id='topic+commits'></span>

<h3>Description</h3>

<p>Commit data for the dplyr repo from github API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>commits
</code></pre>


<h3>Format</h3>

<p>JSON
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

# Commits is a long character string
commits %&gt;% nchar

# Let's make it a tbl_json object
commits %&gt;% as.tbl_json

# It begins as an array, so let's gather that
commits %&gt;% gather_array

# Now let's spread all the top level values
commits %&gt;% gather_array %&gt;% spread_all %&gt;% glimpse

# Are there any top level objects or arrays?
commits %&gt;% gather_array %&gt;% gather_object %&gt;% json_types %&gt;%
  count(name, type)

# Let's look at the parents array
commits %&gt;% gather_array("commit") %&gt;%
  enter_object(parents) %&gt;% gather_array("parent") %&gt;%
  spread_all %&gt;% glimpse
</code></pre>

<hr>
<h2 id='companies'>Startup company information for 1,000 companies</h2><span id='topic+companies'></span>

<h3>Description</h3>

<p>From: http://jsonstudio.com/resources/
</p>


<h3>Usage</h3>

<pre><code class='language-R'>companies
</code></pre>


<h3>Format</h3>

<p>JSON
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

# Companies is a long character vector
companies %&gt;% str

# Work with a small sample
co_samp &lt;- companies[1:5]

# Gather top level values and glimpse
co_samp %&gt;% spread_all %&gt;% glimpse

# Get the key employees data for the first 100 companies
key_employees &lt;- companies[1:100] %&gt;%
  spread_all %&gt;%
  select(name) %&gt;%
  enter_object(relationships) %&gt;%
  gather_array() %&gt;%
  spread_all

key_employees %&gt;% glimpse

# Show the top 10 titles
key_employees %&gt;%
  filter(!is_past) %&gt;%
  count(title) %&gt;%
  arrange(desc(n)) %&gt;%
  top_n(10)
</code></pre>

<hr>
<h2 id='determine_types'>Determines the types of a list of parsed JSON</h2><span id='topic+determine_types'></span>

<h3>Description</h3>

<p>Determines the types of a list of parsed JSON
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determine_types(json_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="determine_types_+3A_json_list">json_list</code></td>
<td>
<p>a list of parsed JSON</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a factor with levels json_types
</p>

<hr>
<h2 id='enter_object'>Enter into a specific object and discard all other JSON data</h2><span id='topic+enter_object'></span>

<h3>Description</h3>

<p>When manipulating a JSON object, <code>enter_object</code> lets you navigate to
a specific value of the object by referencing it's name. JSON can contain
nested objects, and you can pass in more than one character string into
<code>enter_object</code> to navigate through multiple objects simultaneously.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enter_object(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enter_object_+3A_.x">.x</code></td>
<td>
<p>a json string or tbl_json object</p>
</td></tr>
<tr><td><code id="enter_object_+3A_...">...</code></td>
<td>
<p>a quoted or unquoted sequence of strings designating the object
name or sequences of names you wish to enter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>After using <code>enter_object</code>, all further tidyjson calls happen inside the
referenced object (all other JSON data outside the object is discarded).
If the object doesn't exist for a given row / index, then that row will be
discarded.
</p>
<p>In pipelines, <code>enter_object</code> is often preceded by <code>gather_object</code>
and followed by <code>gather_array</code> if the value is an array, or
<code>spread_all</code> if the value is an object.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+tbl_json">tbl_json</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gather_object">gather_object</a></code> to find sub-objects that could be
entered into, <code><a href="#topic+gather_array">gather_array</a></code> to gather an array in an object
and <code><a href="#topic+spread_all">spread_all</a></code> or <code><a href="#topic+spread_values">spread_values</a></code> to spread values in an object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Let's start with a simple example of parents and children
json &lt;- c('{"parent": "bob",  "children": ["sally", "george"]}',
          '{"parent": "fred", "children": ["billy"]}',
          '{"parent": "anne"}')

# We can see the names and types in each
json %&gt;% gather_object %&gt;% json_types

# Let's capture the parent first and then enter in the children object
json %&gt;% spread_all %&gt;% enter_object(children)

# Also works with quotes
json %&gt;% spread_all %&gt;% enter_object("children")

# Notice that "anne" was discarded, as she has no children

# We can now use gather array to stack the array
json %&gt;% spread_all %&gt;% enter_object(children) %&gt;%
  gather_array("child.num")

# And append_values_string to add the children names
json %&gt;% spread_all %&gt;% enter_object(children) %&gt;%
  gather_array("child.num") %&gt;%
  append_values_string("child")

# The path can be comma delimited to go deep into a nested object
json &lt;- '{"name": "bob", "attributes": {"age": 32, "gender": "male"}}'
json %&gt;% enter_object(attributes, age)

# A more realistc example with companies data
library(dplyr)
companies %&gt;%
  enter_object(acquisitions) %&gt;%
  gather_array %&gt;%
  spread_all %&gt;%
  glimpse
</code></pre>

<hr>
<h2 id='filter'>Objects exported from other packages</h2><span id='topic+filter'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>dplyr</dt><dd><p><code><a href="dplyr.html#topic+filter">filter</a></code></p>
</dd>
</dl>


<h3>Details</h3>

<p>This needs to be re-exported, since 'dplyr' implements a generic that 
is not a generic in the 'stats' package, and 'tidyjson' provides a method for that generic
</p>


<h3>See Also</h3>

<p>http://r.789695.n4.nabble.com/R-CMD-check-warning-with-S3-method-td4692255.html
</p>

<hr>
<h2 id='gather_array'>Gather a JSON array into index-value pairs</h2><span id='topic+gather_array'></span>

<h3>Description</h3>

<p><code>gather_array</code> collapses a JSON array into index-value pairs, creating
a new column <code>'array.index'</code> to store the index of the array, and
storing values in the <code>'JSON'</code> attribute for further tidyjson
manipulation. All other columns are duplicated as necessary. This allows you
to access the values of the array just like <code><a href="#topic+gather_object">gather_object</a></code> lets
you access the values of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gather_array(.x, column.name = default.column.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gather_array_+3A_.x">.x</code></td>
<td>
<p>a json string or tbl_json object whose JSON attribute should always
be an array</p>
</td></tr>
<tr><td><code id="gather_array_+3A_column.name">column.name</code></td>
<td>
<p>the name to give to the array index column created</p>
</td></tr>
</table>


<h3>Details</h3>

<p>JSON arrays can be simple vectors (fixed or varying length number, string
or logical vectors with or without null values). But they also often contain
lists of other objects (like a list of purchases for a user). Thus, the
best analogy in R for a JSON array is an unnamed list.
</p>
<p><code>gather_array</code> is often preceded by <code><a href="#topic+enter_object">enter_object</a></code> when the
array is nested under a JSON object, and is often followed by
<code><a href="#topic+gather_object">gather_object</a></code> or <code><a href="#topic+enter_object">enter_object</a></code> if the array values
are objects, or by <code><a href="#topic+append_values">append_values</a></code> to append all scalar values
as a new column or <code><a href="#topic+json_types">json_types</a></code> to determine the types of the
array elements (JSON does not guarantee they are the same type).
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+tbl_json">tbl_json</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gather_object">gather_object</a></code> to gather a JSON object,
<code><a href="#topic+enter_object">enter_object</a></code> to enter into an object,
<code><a href="tidyr.html#topic+gather">gather</a></code> to gather name-value pairs in a data
frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A simple character array example
json &lt;- '["a", "b", "c"]'

# Check that this is an array
json %&gt;% json_types

# Gather array and check types
json %&gt;% gather_array %&gt;% json_types

# Extract string values
json %&gt;% gather_array %&gt;% append_values_string

# A more complex mixed type example
json &lt;- '["a", 1, true, null, {"name": "value"}]'

# Then we can use the column.name argument to change the name column
json %&gt;% gather_array %&gt;% json_types

# A nested array
json &lt;- '[["a", "b", "c"], ["a", "d"], ["b", "c"]]'

# Extract both levels
json %&gt;% gather_array("index.1") %&gt;% gather_array("index.2") %&gt;%
  append_values_string

# Some JSON begins as an array
commits %&gt;% gather_array

# We can use spread_all to capture all values
# (recursive = FALSE to limit to the top level object)
library(dplyr)
commits %&gt;% gather_array %&gt;% spread_all(recursive = FALSE) %&gt;% glimpse
</code></pre>

<hr>
<h2 id='gather_factory'>Factory to create gather functions</h2><span id='topic+gather_factory'></span>

<h3>Description</h3>

<p>Factory to create gather functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gather_factory(
  default.column.name,
  default.column.empty,
  expand.fun,
  required.type
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gather_factory_+3A_default.column.name">default.column.name</code></td>
<td>
<p>the desired name of the default added column</p>
</td></tr>
<tr><td><code id="gather_factory_+3A_default.column.empty">default.column.empty</code></td>
<td>
<p>the value to use when the default column should
be empty because the JSON has length 0</p>
</td></tr>
<tr><td><code id="gather_factory_+3A_expand.fun">expand.fun</code></td>
<td>
<p>a function applied to the JSON that will expand the rows
in the tbl_df</p>
</td></tr>
<tr><td><code id="gather_factory_+3A_required.type">required.type</code></td>
<td>
<p>the json_types type that must be present in every
element of the JSON for this to succeed</p>
</td></tr>
</table>

<hr>
<h2 id='gather_object'>Gather a JSON object into name-value pairs</h2><span id='topic+gather_object'></span><span id='topic+gather_keys'></span>

<h3>Description</h3>

<p><code>gather_object</code> collapses a JSON object into name-value pairs, creating
a new column <code>'name'</code> to store the pair names, and storing the
values in the <code>'JSON'</code> attribute for further tidyjson manipulation.
All other columns are duplicated as necessary. This allows you to access the
names of the object pairs just like <code><a href="#topic+gather_array">gather_array</a></code> lets you
access the values of an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gather_object(.x, column.name = default.column.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gather_object_+3A_.x">.x</code></td>
<td>
<p>a JSON string or <code><a href="#topic+tbl_json">tbl_json</a></code> object whose JSON attribute
should always be an object</p>
</td></tr>
<tr><td><code id="gather_object_+3A_column.name">column.name</code></td>
<td>
<p>the name to give to the column of pair names created</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>gather_object</code> is often followed by <code><a href="#topic+enter_object">enter_object</a></code> to enter
into a value that is an object, by <code><a href="#topic+append_values">append_values</a></code> to append all
scalar values as a new column or <code><a href="#topic+json_types">json_types</a></code> to determine the
types of the values.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+tbl_json">tbl_json</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gather_array">gather_array</a></code> to gather a JSON array,
<code><a href="#topic+enter_object">enter_object</a></code> to enter into an object,
<code><a href="tidyr.html#topic+gather">gather</a></code> to gather name-value pairs in a data
frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Let's start with a very simple example
json &lt;- '{"name": "bob", "age": 32, "gender": "male"}'

# Check that this is an object
json %&gt;% json_types

# Gather object and check types
json %&gt;% gather_object %&gt;% json_types

# Sometimes data is stored in object pair names
json &lt;- '{"2014": 32, "2015": 56, "2016": 14}'

# Then we can use the column.name argument to change the column name
json %&gt;% gather_object("year")

# We can also use append_values_number to capture the values, since they are
# all of the same type
json %&gt;% gather_object("year") %&gt;% append_values_number("count")

# This can even work with a more complex, nested example
json &lt;- '{"2015": {"1": 10, "3": 1, "11": 5}, "2016": {"2": 3, "5": 15}}'
json %&gt;% gather_object("year") %&gt;% gather_object("month") %&gt;%
  append_values_number("count")

# Most JSON starts out as an object (or an array of objects), and
# gather_object can be used to inspect the top level (or 2nd level) objects
library(dplyr)
worldbank %&gt;% gather_object %&gt;% json_types %&gt;% count(name, type)
</code></pre>

<hr>
<h2 id='has_names'>Check for Names</h2><span id='topic+has_names'></span>

<h3>Description</h3>

<p>Checks the input object for the existence of names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_names_+3A_x">x</code></td>
<td>
<p>Input object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean.  Indicates whether x has names
</p>

<hr>
<h2 id='is_data_list'>List Check</h2><span id='topic+is_data_list'></span>

<h3>Description</h3>

<p>Checks whether a list is being provided
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_data_list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_data_list_+3A_x">x</code></td>
<td>
<p>Input object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean.  Indicates whether x is a list
</p>

<hr>
<h2 id='is_json'>Predicates to test for specific JSON types in <code><a href="#topic+tbl_json">tbl_json</a></code> objects</h2><span id='topic+is_json'></span><span id='topic+is_json_string'></span><span id='topic+is_json_number'></span><span id='topic+is_json_logical'></span><span id='topic+is_json_null'></span><span id='topic+is_json_array'></span><span id='topic+is_json_object'></span><span id='topic+is_json_scalar'></span>

<h3>Description</h3>

<p>These functions are often useful with <code><a href="dplyr.html#topic+filter">filter</a></code> to
filter complex JSON by type before applying <code><a href="#topic+gather_object">gather_object</a></code> or
<code><a href="#topic+gather_array">gather_array</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_json_string(.x)

is_json_number(.x)

is_json_logical(.x)

is_json_null(.x)

is_json_array(.x)

is_json_object(.x)

is_json_scalar(.x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_json_+3A_.x">.x</code></td>
<td>
<p>a json string or <code><a href="#topic+tbl_json">tbl_json</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+json_types">json_types</a></code> for creating a new column to identify the
type of every JSON document
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Test a simple example
json &lt;- '[1, "string", true, [1, 2], {"name": "value"}, null]' %&gt;% gather_array
json %&gt;% is_json_number
json %&gt;% is_json_array
json %&gt;% is_json_scalar

# Use with filter
library(dplyr)
json %&gt;% filter(is_json_object(.))

# Combine with filter in advance of using gather_array
companies[1:5] %&gt;% gather_object %&gt;% filter(is_json_array(.))
companies[1:5] %&gt;% gather_object %&gt;% filter(is_json_array(.)) %&gt;%
  gather_array

# Combine with filter in advance of using gather_object
companies[1:5] %&gt;% gather_object %&gt;% filter(is_json_object(.))
companies[1:5] %&gt;% gather_object %&gt;% filter(is_json_object(.)) %&gt;%
  gather_object("name2")
</code></pre>

<hr>
<h2 id='is_json_factory'>Factory to create <code>is_json</code> functions</h2><span id='topic+is_json_factory'></span>

<h3>Description</h3>

<p>Factory to create <code>is_json</code> functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_json_factory(desired.types)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_json_factory_+3A_desired.types">desired.types</code></td>
<td>
<p>character vector of types we want to check for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function
</p>

<hr>
<h2 id='issues'>Issue data for the dplyr repo from github API</h2><span id='topic+issues'></span>

<h3>Description</h3>

<p>Issue data for the dplyr repo from github API
</p>


<h3>Usage</h3>

<pre><code class='language-R'>issues
</code></pre>


<h3>Format</h3>

<p>JSON
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

# issues is a long character string
nchar(issues)

# Let's make it a tbl_json object
issues %&gt;% as.tbl_json

# It begins as an array, so let's gather that
issues %&gt;% gather_array

# Now let's spread all the top level values
issues %&gt;% gather_array %&gt;% spread_all %&gt;% glimpse

# Are there any top level objects or arrays?
issues %&gt;% gather_array %&gt;% gather_object %&gt;% json_types %&gt;%
  count(name, type) %&gt;%
  filter(type %in% c("array", "object"))

# Count issues labels by name
labels &lt;- issues %&gt;%
  gather_array %&gt;%                    # stack issues as "issue.num"
  spread_values(id = jnumber(id)) %&gt;% # capture just issue id
  enter_object(labels) %&gt;%            # filter just those with labels
  gather_array("label.index") %&gt;%     # stack labels
  spread_all
labels %&gt;% glimpse

# Count number of distinct issues each label appears in
labels %&gt;%
  group_by(name) %&gt;%
  summarize(num.issues = n_distinct(id))
</code></pre>

<hr>
<h2 id='json_complexity'>Compute the complexity (recursively unlisted length) of JSON data</h2><span id='topic+json_complexity'></span>

<h3>Description</h3>

<p>When investigating complex JSON data it can be helpful to identify the
complexity of deeply nested documents. The <code>json_complexity</code> function
adds a column (default name <code>"complexity"</code>) that contains the
'complexity' of the JSON associated with each row. Essentially, every on-null
scalar value is found in the object by recursively stripping away all objects
or arrays, and the complexity is the count of these scalar values. Note that
'null' has complexity 0, as do empty objects and arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_complexity(.x, column.name = "complexity")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json_complexity_+3A_.x">.x</code></td>
<td>
<p>a json string or tbl_json object</p>
</td></tr>
<tr><td><code id="json_complexity_+3A_column.name">column.name</code></td>
<td>
<p>the name to specify for the length column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+tbl_json">tbl_json</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+json_lengths">json_lengths</a></code> to compute the length of each value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A simple example
json &lt;- c('[1, 2, [3, 4]]', '{"k1": 1, "k2": [2, [3, 4]]}', '1', 'null')

# Complexity is larger than length for nested objects
json %&gt;% json_lengths %&gt;% json_complexity

# Worldbank has complexity ranging from 8 to 17
library(magrittr)
worldbank %&gt;% json_complexity %$% table(complexity)

# Commits are much more regular
commits %&gt;% gather_array %&gt;% json_complexity %$% table(complexity)
</code></pre>

<hr>
<h2 id='json_factory'>Factory that creates the j* functions below</h2><span id='topic+json_factory'></span>

<h3>Description</h3>

<p>Factory that creates the j* functions below
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_factory(map.function)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json_factory_+3A_map.function">map.function</code></td>
<td>
<p>function to map to collapse</p>
</td></tr>
</table>

<hr>
<h2 id='json_functions'>Navigates nested objects to get at names of a specific type, to be used as
arguments to <code><a href="#topic+spread_values">spread_values</a></code></h2><span id='topic+json_functions'></span><span id='topic+jstring'></span><span id='topic+jlogical'></span><span id='topic+jinteger'></span><span id='topic+jdouble'></span><span id='topic+jnumber'></span>

<h3>Description</h3>

<p>Note that these functions fail if they encounter the incorrect type. Note
that <code>jnumber()</code> is an alias for <code>jdouble()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jstring(..., recursive = FALSE)

jlogical(..., recursive = FALSE)

jinteger(..., recursive = FALSE)

jdouble(..., recursive = FALSE)

jnumber(..., recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json_functions_+3A_...">...</code></td>
<td>
<p>a quoted or unquoted sequence of strings designating the object
name sequence you wish to follow to find a value</p>
</td></tr>
<tr><td><code id="json_functions_+3A_recursive">recursive</code></td>
<td>
<p>logical indicating whether second level and beyond objects
should be extracted.  Only works when there exists a single value in
the nested json object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that can operate on parsed JSON data
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spread_values">spread_values</a></code> for using these functions to spread
the values of a JSON object into new columns
</p>

<hr>
<h2 id='json_get'>Get JSON from a tbl_json</h2><span id='topic+json_get'></span>

<h3>Description</h3>

<p>Extract the raw JSON from a tbl_json object. This is equivalent to reading
the &quot;..JSON&quot; hidden column. But is a helper in case of future behavior changes.
This replaces previous behavior, where the raw JSON was stored in an attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_get(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json_get_+3A_.data">.data</code></td>
<td>
<p>A tbl_json object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A nested list representing the JSON data
</p>

<hr>
<h2 id='json_get_column'>Make the JSON data a persistent column</h2><span id='topic+json_get_column'></span>

<h3>Description</h3>

<p>Extract the raw JSON from a tbl_json object. Store it in a column. WARNING:
column name collisions will be overwritten
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_get_column(.data, column_name = "json")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json_get_column_+3A_.data">.data</code></td>
<td>
<p>A tbl_json object</p>
</td></tr>
<tr><td><code id="json_get_column_+3A_column_name">column_name</code></td>
<td>
<p>Optional. The name of the output column (either as a
string or unquoted name). Default &quot;json&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tbl_json object with an added column containing the JSON data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tj &lt;- as_tbl_json('{"a": "b"}')
json_get_column(tj, my_json)

</code></pre>

<hr>
<h2 id='json_lengths'>Compute the length of JSON data</h2><span id='topic+json_lengths'></span>

<h3>Description</h3>

<p>When investigating JSON data it can be helpful to identify the lengths of the
JSON objects or arrays, especialy when they are 'ragged' across documents.
The <code>json_lengths</code> function adds a column (default name <code>"length"</code>)
that contains the 'length' of the JSON associated with each row. For objects,
this will be equal to the number of name-value pairs. For arrays, this will
be equal to the length of the array. All scalar values will be of length 1,
and null will have length 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_lengths(.x, column.name = "length")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json_lengths_+3A_.x">.x</code></td>
<td>
<p>a json string or <code><a href="#topic+tbl_json">tbl_json</a></code> object</p>
</td></tr>
<tr><td><code id="json_lengths_+3A_column.name">column.name</code></td>
<td>
<p>the name to specify for the length column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+tbl_json">tbl_json</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+json_complexity">json_complexity</a></code> to compute the recursive length of
each value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A simple example
json &lt;- c('[1, 2, 3]', '{"k1": 1, "k2": 2}', '1', 'null')

# Complexity is larger than length for nested objects
json %&gt;% json_lengths

# Worldbank objcts are either length 7 or 8
library(magrittr)
worldbank %&gt;% json_lengths %$% table(length)

# All commits are length 8
commits %&gt;% gather_array %&gt;% json_lengths %$% table(length)
</code></pre>

<hr>
<h2 id='json_schema'>Create a schema for a JSON document or collection</h2><span id='topic+json_schema'></span>

<h3>Description</h3>

<p>Returns a JSON document that captures the 'schema' of the collection of
document(s) passed in, as a JSON string. The schema collapses complex
JSON into a simple form using the following rules:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_schema(.x, type = c("string", "value"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json_schema_+3A_.x">.x</code></td>
<td>
<p>a json string or <code><a href="#topic+tbl_json">tbl_json</a></code> object</p>
</td></tr>
<tr><td><code id="json_schema_+3A_type">type</code></td>
<td>
<p>whether to capture scalar nodes using the string that defines
their type (e.g., &quot;logical&quot;) or as a representative value
(e.g., &quot;true&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> string  -&gt; &quot;string&quot;,        e.g., &quot;a sentence&quot; -&gt; &quot;string&quot;
</p>
</li>
<li><p> number  -&gt; &quot;number&quot;,        e.g., 32000.1 -&gt; &quot;number&quot;
</p>
</li>
<li><p> true    -&gt; &quot;logical&quot;,       e.g., true -&gt; &quot;logical&quot;
</p>
</li>
<li><p> false   -&gt; &quot;logical&quot;,       e.g., false -&gt; &quot;logical&quot;
</p>
</li>
<li><p> null    -&gt; &quot;null&quot;,          e.g., null -&gt; &quot;null&quot;
</p>
</li>
<li><p> array   -&gt; [&lt;type&gt;]         e.g., [1, 2] -&gt; [&quot;number&quot;]
</p>
</li>
<li><p> object  -&gt; &quot;name&quot;: &lt;type&gt; e.g., &quot;age&quot;: 32 -&gt; &quot;age&quot;: &quot;number&quot;
</p>
</li></ul>

<p>For more complex JSON objects, ties are broken by taking the most
complex example (using <code><a href="#topic+json_complexity">json_complexity</a></code>), and then by type
(using <code><a href="#topic+json_types">json_types</a></code>).
</p>
<p>This means that if a name has varying schema across documents, the
most complex schema will be chosen as being representative. Similarly,
if the elements of an array vary in schema, the most complex element is
chosen, and if arrays vary in schema across documents, the most
complex is chosen.
</p>
<p>Note that <code>json_schema</code> can be slow for large JSON document collections,
you may want to sample your JSON collection first.
</p>


<h3>Value</h3>

<p>a character string JSON document that represents the schema of
the collection
</p>


<h3>See Also</h3>

<p><code><a href="#topic+json_structure">json_structure</a></code> to recursively structure all
documents into a single data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A simple string
'"string"' %&gt;% json_schema %&gt;% writeLines

# A simple object
'{"name": "value"}' %&gt;% json_schema %&gt;% writeLines

# A more complex JSON array
json &lt;- '[{"a": 1}, [1, 2], "a", 1, true, null]'

# Using type = 'string' (default)
json %&gt;% json_schema %&gt;% writeLines

# Using type = 'value' to show a representative value
json %&gt;% json_schema(type = "value") %&gt;% writeLines

# Schema of the first 5 github issues
## Not run: 
  library(dplyr)
  issues %&gt;% gather_array %&gt;% slice(1:10) %&gt;%
    json_schema(type = "value") %&gt;% writeLines

## End(Not run)
</code></pre>

<hr>
<h2 id='json_structure'>Recursively structures arbitrary JSON data into a single data frame</h2><span id='topic+json_structure'></span>

<h3>Description</h3>

<p>Returns a <code><a href="#topic+tbl_json">tbl_json</a></code> object where each row corresponds to a leaf
in the JSON structure. The first row corresponds to the JSON document as
a whole. If the document is a scalar value (JSON string, number, logical
or null), then there will only be 1 row. If instead it is an object or
an array, then subsequent rows will recursively correspond to the elements
(and their children) of the object or array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_structure(.x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json_structure_+3A_.x">.x</code></td>
<td>
<p>a json string or tbl_json object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The columns in the <code><a href="#topic+tbl_json">tbl_json</a></code> returend are defined as
</p>

<ul>
<li> <p><code>document.id</code> 1L if <code>.x</code> is a single JSON string, otherwise
the index of <code>.x</code>.
</p>
</li>
<li> <p><code>parent.id</code> the string identifier of the parent node for this
child.
</p>
</li>
<li> <p><code>level</code> what level of the hierarchy this child resides at,
starting at <code>0L</code> for the root and incrementing for each level
of nested array or object.
</p>
</li>
<li> <p><code>index</code> what index of the parent object / array this child
resides at (from <code>gather_array</code> for arrays).
</p>
</li>
<li> <p><code>child.id</code> a unique ID for this leaf in this document,
represented as &lt;parent&gt;.&lt;index&gt; where &lt;parent&gt; is the ID for the
parent and &lt;index&gt; is this index.
</p>
</li>
<li> <p><code>seq</code> the sequence of names / indices that led to this child
(parents that are arrays are excluded) as a list, where character
strings denote objects and integers denote array positions
</p>
</li>
<li> <p><code>name</code> if this is the value of an object, what was the name that
it is listed under (from <code><a href="#topic+gather_object">gather_object</a></code>).
</p>
</li>
<li> <p><code>type</code> the type of this object (from <code><a href="#topic+json_types">json_types</a></code>).
</p>
</li>
<li> <p><code>length</code> the length of this object (from
<code><a href="#topic+json_lengths">json_lengths</a></code>).
</p>
</li></ul>



<h3>Value</h3>

<p>a <code><a href="#topic+tbl_json">tbl_json</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+json_schema">json_schema</a></code> to create a schema for a JSON document or
collection
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A simple string
'"string"' %&gt;% json_structure

# A simple object
'{"name": "value"}' %&gt;% json_structure

# A complex array
'[{"a": 1}, [1, 2], "a", 1, true, null]' %&gt;% json_structure

# A sample of structure rows from a company
library(dplyr)
companies[1] %&gt;% json_structure %&gt;% sample_n(5)
</code></pre>

<hr>
<h2 id='json_types'>Add a column that tells the 'type' of the JSON data</h2><span id='topic+json_types'></span>

<h3>Description</h3>

<p>The function <code>json_types</code> inspects the JSON associated with
each row of the <code><a href="#topic+tbl_json">tbl_json</a></code> object, and adds a new column
(<code>"type"</code> by default) that identifies the type according to the
JSON standard at <a href="http://json.org/">http://json.org/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>json_types(.x, column.name = "type")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="json_types_+3A_.x">.x</code></td>
<td>
<p>a json string or tbl_json object</p>
</td></tr>
<tr><td><code id="json_types_+3A_column.name">column.name</code></td>
<td>
<p>the name to specify for the type column</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is particularly useful for inspecting your JSON data types, and can
often follows after <code><a href="#topic+gather_array">gather_array</a></code>, <code><a href="#topic+gather_object">gather_object</a></code>
or <code><a href="#topic+enter_object">enter_object</a></code> to inspect the types of the elements of
JSON objects or arrays.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+tbl_json">tbl_json</a></code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A simple example
c('{"a": 1}', '[1, 2]', '"a"', '1', 'true', 'null') %&gt;% json_types

# Type distribution in the first 10 companies
library(dplyr)
companies[1:10] %&gt;% gather_object %&gt;% json_types %&gt;% count(type)
</code></pre>

<hr>
<h2 id='my_unlist'>Unlists while preserving NULLs and only unlisting lists with one value</h2><span id='topic+my_unlist'></span>

<h3>Description</h3>

<p>Unlists while preserving NULLs and only unlisting lists with one value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my_unlist(l, recursive = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="my_unlist_+3A_l">l</code></td>
<td>
<p>a list that we want to unlist</p>
</td></tr>
<tr><td><code id="my_unlist_+3A_recursive">recursive</code></td>
<td>
<p>logical indicating whether to unlist nested lists</p>
</td></tr>
</table>

<hr>
<h2 id='path'>Create a JSON path with a minimum of typing</h2><span id='topic+path'></span>

<h3>Description</h3>

<p>Create a JSON path with a minimum of typing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>path(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="path_+3A_...">...</code></td>
<td>
<p>a sequence of quoted or unquoted character strings specifying
JSON object names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>path</code> object
</p>

<hr>
<h2 id='print.tbl_json'>Print a tbl_json object</h2><span id='topic+print.tbl_json'></span>

<h3>Description</h3>

<p>Print a tbl_json object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tbl_json'
print(x, ..., json.n = 20, json.width = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.tbl_json_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+tbl_json">tbl_json</a></code> object</p>
</td></tr>
<tr><td><code id="print.tbl_json_+3A_...">...</code></td>
<td>
<p>other arguments into <code><a href="tibble.html#topic+print.tbl_df">print.tbl_df</a></code></p>
</td></tr>
<tr><td><code id="print.tbl_json_+3A_json.n">json.n</code></td>
<td>
<p>number of json records to add (...) otherwise</p>
</td></tr>
<tr><td><code id="print.tbl_json_+3A_json.width">json.width</code></td>
<td>
<p>number of json characters to print</p>
</td></tr>
</table>

<hr>
<h2 id='rbind_tbl_json'>Bind two tbl_json objects together and preserve JSON attribute</h2><span id='topic+rbind_tbl_json'></span>

<h3>Description</h3>

<p>Bind two tbl_json objects together and preserve JSON attribute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbind_tbl_json(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbind_tbl_json_+3A_x">x</code></td>
<td>
<p>a tbl_json object</p>
</td></tr>
<tr><td><code id="rbind_tbl_json_+3A_y">y</code></td>
<td>
<p>a tbl_json_object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x and y row-binded together with appropriate JSON attribute
</p>

<hr>
<h2 id='read_json'>Reads JSON from an input uri (file, url, ...) and returns a
<code><a href="#topic+tbl_json">tbl_json</a></code> object</h2><span id='topic+read_json'></span>

<h3>Description</h3>

<p>Reads JSON from an input uri (file, url, ...) and returns a
<code><a href="#topic+tbl_json">tbl_json</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_json(path, format = c("json", "jsonl", "infer"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_json_+3A_path">path</code></td>
<td>
<p>to some json data</p>
</td></tr>
<tr><td><code id="read_json_+3A_format">format</code></td>
<td>
<p>If <code>"json"</code>, process the data like one large JSON record.
If <code>"jsonl"</code>, process the data one JSON record per line (json lines
format).
If <code>"infer"</code>, the format is the suffix of the given filepath.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="#topic+tbl_json">tbl_json</a></code> object
</p>

<hr>
<h2 id='spread_all'>Spreads all scalar values of a JSON object into new columns</h2><span id='topic+spread_all'></span>

<h3>Description</h3>

<p>Like the <code><a href="tidyr.html#topic+spread">spread</a></code> function in <code>tidyr</code> but for JSON,
this function spreads out any JSON objects that are scalars into new columns.
If objects are nested, then the recursive flag will expand scalar values of
nested objects out with a compound column name based on the sequences of
nested object names concatenated with the <code>sep</code> character.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spread_all(.x, recursive = TRUE, sep = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spread_all_+3A_.x">.x</code></td>
<td>
<p>a json string or <code><a href="#topic+tbl_json">tbl_json</a></code> object</p>
</td></tr>
<tr><td><code id="spread_all_+3A_recursive">recursive</code></td>
<td>
<p>whether or not to recursively spread nested objects</p>
</td></tr>
<tr><td><code id="spread_all_+3A_sep">sep</code></td>
<td>
<p>character used to separate nested object names when resursive
is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that arrays are ignored by this function, use <code><a href="#topic+gather_array">gather_array</a></code>
to gather the array first, and then use <code>spread_all</code> if the array
contains objects or use one of the <code><a href="#topic+append_values">append_values</a></code> functions to
capture the array values if they are scalars.
</p>
<p>Note that scalar JSON values (e.g., a JSON string like '1') are also
ignored, as they have no names to create column names with.
</p>
<p>The order of columns is determined by the order they are encountered in the
JSON document, with nested objects placed at the end.
</p>
<p>If an objects have name-value pairs with names that are duplicates, then
<code>".n"</code> is appended for n incrementing from 2 on to ensure that columns
are unique. This also happens if <code>.x</code> already has a column with the
name of a name-value pair.
</p>
<p>This function does not change the value of the JSON attribute of the
<code><a href="#topic+tbl_json">tbl_json</a></code> object in any way.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+tbl_json">tbl_json</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spread_values">spread_values</a></code> to specific which specific values
to spread along with their types,
<code><a href="tidyr.html#topic+spread">spread</a></code> for spreading data frames
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A simple example
json &lt;- c('{"a": "x", "b": 1, "c": true}',
          '{"a": "y", "c": false}',
          '{"a": null, "d": "z"}')
json %&gt;% spread_all

# A more complex example
worldbank %&gt;% spread_all

## Not run: 
  # Resolving duplicate column names
  json &lt;- '{"a": "x", "a": "y"}'
  json %&gt;% spread_all

## End(Not run)
</code></pre>

<hr>
<h2 id='spread_values'>Spreads specific scalar values of a JSON object into new columns</h2><span id='topic+spread_values'></span>

<h3>Description</h3>

<p>The <code>spread_values</code> function lets you extract extract specific values
from (potentiall nested) JSON objects. <code>spread_values</code> takes
<code><a href="#topic+jstring">jstring</a></code>, <code><a href="#topic+jnumber">jnumber</a></code> or <code><a href="#topic+jlogical">jlogical</a></code> named
function calls as arguments in order to specify the type of the data that
should be captured at each desired name-value pair location. These values can
be of varying types at varying depths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spread_values(.x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spread_values_+3A_.x">.x</code></td>
<td>
<p>a json string or <code><a href="#topic+tbl_json">tbl_json</a></code> object</p>
</td></tr>
<tr><td><code id="spread_values_+3A_...">...</code></td>
<td>
<p><code>column = value</code> pairs where <code>column</code> will be the
column name created and <code>value</code> must be a call to
<code><a href="#topic+jstring">jstring</a></code>, <code><a href="#topic+jnumber">jnumber</a></code> or
<code><a href="#topic+jlogical">jlogical</a></code> specifying the path to get the value (and
the type implicit in the function name)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code><a href="#topic+jstring">jstring</a></code>, <code><a href="#topic+jnumber">jnumber</a></code> and
<code><a href="#topic+jlogical">jlogical</a></code> will fail if they encounter the incorrect type in any
document.
</p>
<p>The advantage of <code>spread_values</code> over <code><a href="#topic+spread_all">spread_all</a></code> is that
you are guaranteed to get a consistent data frame structure (columns and
types) out of any <code>spread_values</code> call. <code><a href="#topic+spread_all">spread_all</a></code>
requires less typing, but because it infers the columns and their types from
the JSON, it is less suitable when programming.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+tbl_json">tbl_json</a></code> object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spread_all">spread_all</a></code> for spreading all values,
<code><a href="tidyr.html#topic+spread">spread</a></code> for spreading data frames,
<code><a href="#topic+jstring">jstring</a></code>, <code><a href="#topic+jnumber">jnumber</a></code>,
<code><a href="#topic+jlogical">jlogical</a></code> for accessing specific names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A simple example
json &lt;- '{"name": {"first": "Bob", "last": "Jones"}, "age": 32}'

# Using spread_values
json %&gt;%
  spread_values(
    first.name = jstring(name, first),
    last.name  = jstring(name, last),
    age        = jnumber(age)
  )

# Another document, this time with a middle name (and no age)
json2 &lt;- '{"name": {"first": "Ann", "middle": "A", "last": "Smith"}}'

# spread_values still gives the same column structure
c(json, json2) %&gt;%
  spread_values(
    first.name = jstring(name, first),
    last.name  = jstring(name, last),
    age        = jnumber(age)
  )

# whereas spread_all adds a new column
json %&gt;% spread_all
c(json, json2) %&gt;% spread_all
</code></pre>

<hr>
<h2 id='tbl_json'>Combines structured JSON (as a data.frame) with remaining JSON</h2><span id='topic+tbl_json'></span><span id='topic+as.tbl_json'></span><span id='topic+as_tbl_json'></span><span id='topic+as.tbl_json.tbl_json'></span><span id='topic+as.tbl_json.character'></span><span id='topic+as.tbl_json.list'></span><span id='topic+as.tbl_json.data.frame'></span><span id='topic+is.tbl_json'></span>

<h3>Description</h3>

<p>Constructs a <code>tbl_json</code> object, for further downstream manipulation
by other tidyjson functions. Methods exist to convert JSON stored in
character strings without any other associated data, as a separate
character string and associated data frame, or as a single data frame
with a specified character string JSON column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tbl_json(df, json.list, drop.null.json = FALSE, ..., .column_order = NULL)

as.tbl_json(.x, ...)

as_tbl_json(.x, ...)

## S3 method for class 'tbl_json'
as.tbl_json(.x, ...)

## S3 method for class 'character'
as.tbl_json(.x, ...)

## S3 method for class 'list'
as.tbl_json(.x, ...)

## S3 method for class 'data.frame'
as.tbl_json(.x, json.column, ...)

is.tbl_json(.x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tbl_json_+3A_df">df</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="tbl_json_+3A_json.list">json.list</code></td>
<td>
<p>list of json lists parsed with
<code><a href="jsonlite.html#topic+fromJSON">fromJSON</a></code></p>
</td></tr>
<tr><td><code id="tbl_json_+3A_drop.null.json">drop.null.json</code></td>
<td>
<p>drop <code>NULL</code> json entries from <code>df</code> and
<code>json.list</code></p>
</td></tr>
<tr><td><code id="tbl_json_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
<tr><td><code id="tbl_json_+3A_.column_order">.column_order</code></td>
<td>
<p>Experimental argument to preserve column order for the hidden column</p>
</td></tr>
<tr><td><code id="tbl_json_+3A_.x">.x</code></td>
<td>
<p>an object to convert into a <code>tbl_json</code> object</p>
</td></tr>
<tr><td><code id="tbl_json_+3A_json.column">json.column</code></td>
<td>
<p>the name of the json column of data in <code>.x</code>, if
<code>.x</code> is a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most tidyjson functions accept a <code>tbl_json</code> object as the first
argument, and return a <code>tbl_json</code> object unless otherwise specified.
tidyjson functions will attempt to convert an object that isn't a
<code>tbl_json</code> object first, and so explicit construction of <code>tidyjson</code>
objects is rarely needed.
</p>
<p><code>tbl_json</code> objects consist of a data frame along with it's associated
JSON, where each row of the data frame corresponds to a single JSON
document. The JSON is stored in a <code>"JSON"</code> attribute.
</p>
<p>Note that <code>json.list</code> must have the same length as <code>nrow(df)</code>, and
if <code>json.list</code> has any <code>NULL</code> elements, the corresponding rows will
be removed from <code>df</code>. Also note that <code>"..JSON"</code> is a reserved
column name used internally for filtering tbl_json objects, and so is not
allowed in the names of <code>df</code>.
</p>


<h3>Value</h3>

<p>a <code><a href="#topic+tbl_json">tbl_json</a></code> object
</p>


<h3>See Also</h3>

<p><code>read_json</code> for reading json from files
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Construct a tbl_json object using a charater string of JSON
json &lt;- '{"animal": "cat", "count": 2}'
json %&gt;% as.tbl_json

# access the "JSON" argument
json %&gt;% as.tbl_json %&gt;% attr("JSON")

# Construct a tbl_json object using multiple documents
json &lt;- c('{"animal": "cat", "count": 2}', '{"animal": "parrot", "count": 1}')
json %&gt;% as.tbl_json

# Construct a tbl_json object from a data.frame with a JSON colum
library(tibble)
farms &lt;- tribble(
  ~farm, ~animals,
  1L,    '[{"animal": "pig", "count": 50}, {"animal": "cow", "count": 10}]',
  2L,    '[{"animal": "chicken", "count": 20}]'
)
farms %&gt;% as.tbl_json(json.column = "animals")
# tidy the farms
farms %&gt;% as.tbl_json(json.column = "animals") %&gt;%
  gather_array %&gt;% spread_all
</code></pre>

<hr>
<h2 id='tidyjson'>tidyjson</h2><span id='topic+tidyjson'></span>

<h3>Description</h3>

<p>The tidyjson package provides tools to turn complex JSON data into 
tidy tibbles and data frames.
</p>

<hr>
<h2 id='worldbank'>Projects funded by the World Bank</h2><span id='topic+worldbank'></span>

<h3>Description</h3>

<p>From: http://jsonstudio.com/resources/
</p>


<h3>Usage</h3>

<pre><code class='language-R'>worldbank
</code></pre>


<h3>Format</h3>

<p>JSON
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(dplyr)

# worldbank is a 500 length character vector of JSON
length(worldbank)

# Let's look at top level values
worldbank %&gt;% spread_all %&gt;% glimpse

# Are there any arrays?
worldbank %&gt;% gather_object %&gt;% json_types %&gt;% count(name, type)

# Get the top 10 sectors by funded project in Africa
wb_sectors &lt;- worldbank %&gt;%   # 500 Projects funded by the world bank
  spread_all %&gt;%
  select(project_name, regionname) %&gt;%
  enter_object(majorsector_percent) %&gt;% # Enter the 'sector' object
  gather_array("sector.index") %&gt;%      # Gather the array
  spread_values(sector = jstring(Name)) # Spread the sector name

# Examine the structured data
wb_sectors %&gt;% glimpse

# Get the top 10 sectors by funded project in Africa
wb_sectors %&gt;%
  filter(regionname == "Africa") %&gt;% # Filter to just Africa
  count(sector) %&gt;%              # Count by sector
  arrange(desc(n)) %&gt;%           # Arrange descending
  top_n(10)                      # Take the top 10

## End(Not run)
</code></pre>

<hr>
<h2 id='wrap_dplyr_verb'>Wrapper for extending dplyr verbs to tbl_json objects</h2><span id='topic+wrap_dplyr_verb'></span>

<h3>Description</h3>

<p>Wrapper for extending dplyr verbs to tbl_json objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrap_dplyr_verb(dplyr.verb, generic)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wrap_dplyr_verb_+3A_dplyr.verb">dplyr.verb</code></td>
<td>
<p>a dplyr::verb such as filter, arrange</p>
</td></tr>
<tr><td><code id="wrap_dplyr_verb_+3A_generic">generic</code></td>
<td>
<p>character. The name of the generic</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
