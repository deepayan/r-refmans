<!DOCTYPE html><html><head><title>Help for package DGEobj.utils</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DGEobj.utils}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#DGEobj.utils-package'><p>DGEobj.utils Package Overview</p></a></li>
<li><a href='#convertCounts'><p>Convert count matrix to CPM, FPKM, FPK, or TPM</p></a></li>
<li><a href='#extractCol'><p>Extract a named column from a series of df or matrices</p></a></li>
<li><a href='#lowIntFilter'><p>Apply low intensity filters to a DGEobj</p></a></li>
<li><a href='#rsqCalc'><p>Calculate R-squared for each gene fit</p></a></li>
<li><a href='#runContrasts'><p>Build contrast matrix and calculate contrast fits</p></a></li>
<li><a href='#runEdgeRNorm'><p>Run edgeR normalization on DGEobj</p></a></li>
<li><a href='#runIHW'><p>Apply Independent Hypothesis Weighting (IHW) to a list of topTable dataframes</p></a></li>
<li><a href='#runPower'><p>Run a power analysis on counts and design matrix</p></a></li>
<li><a href='#runQvalue'><p>Calculate and add q-value and lFDR to dataframe</p></a></li>
<li><a href='#runSVA'><p>Test for surrogate variables</p></a></li>
<li><a href='#runVoom'><p>Run functions in a typical voom/lmFit workflow</p></a></li>
<li><a href='#summarizeSigCounts'><p>Summarize a contrast list</p></a></li>
<li><a href='#topTable.merge'><p>Merge specified topTable df cols</p></a></li>
<li><a href='#tpm.direct'><p>Convert countsMatrix and geneLength to TPM units</p></a></li>
<li><a href='#tpm.on.subset'><p>Calculate TPM for a subsetted DGEobj</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Differential Gene Expression (DGE) Analysis Utility Toolkit</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Provides a function toolkit to facilitate reproducible RNA-Seq Differential Gene Expression (DGE)
    analysis (Law (2015) &lt;<a href="https://doi.org/10.12688%2Ff1000research.9005.3">doi:10.12688/f1000research.9005.3</a>&gt;).  The tools include both analysis 
    work-flow and utility functions: mapping/unit conversion, count normalization, accounting for 
    unknown covariates, and more.  This is a complement/cohort to the 'DGEobj' package that 
    provides a flexible container to manage and annotate Differential Gene Expression analysis results.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, DGEobj (&ge; 1.0.3), dplyr, methods, stats, stringr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>biomaRt, canvasXpress, conflicted, edgeR, glue, ggplot2, IHW,
limma, knitr, qvalue, RNASeqPower, rmarkdown, statmod, sva,
testthat, zFPKM</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-19 23:29:26 UTC; conniebrett</td>
</tr>
<tr>
<td>Author:</td>
<td>John Thompson [aut],
  Connie Brett [aut, cre],
  Isaac Neuhaus [aut],
  Ryan Thompson [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Connie Brett &lt;connie@aggregate-genius.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-19 23:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='DGEobj.utils-package'>DGEobj.utils Package Overview</h2><span id='topic+DGEobj.utils-package'></span>

<h3>Description</h3>

<p>This package implements a set of utility functions to enable a limma/voom workflow capturing
the results in DGEobj data structure. Aside from implementing a well developed and popular
workflow in DGEobj format, the run* functions in the package illustrate how to wrap the
individual processing steps in a workflow in functions that capture important metadata,
processing parameters, and intermediate data items in the DGEobj data structure. This function-
based approach to utilizing the DGEobj data structure insures consistency among a collection of
projects processed by these methods and thus facilitates downstream automated meta-analysis.
</p>


<h3>More Information</h3>

<p><code>browseVignettes(package = 'DGEobj.utils')</code>
</p>

<hr>
<h2 id='convertCounts'>Convert count matrix to CPM, FPKM, FPK, or TPM</h2><span id='topic+convertCounts'></span>

<h3>Description</h3>

<p>Takes a count matrix as input and converts to other desired units.  Supported
units include CPM, FPKM, FPK, and TPM.  Output units can be logged and/or
normalized.  Calculations are performed using edgeR functions except for the
conversion to TPM which is converted from FPKM using the formula provided by
<a href="https://haroldpimentel.wordpress.com/2014/05/08/what-the-fpkm-a-review-rna-seq-expression-units/">Harold Pimental</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertCounts(
  countsMatrix,
  unit,
  geneLength,
  log = FALSE,
  normalize = "none",
  prior.count = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertCounts_+3A_countsmatrix">countsMatrix</code></td>
<td>
<p>A numeric matrix or dataframe of N genes x M Samples.  All columns must be numeric.</p>
</td></tr>
<tr><td><code id="convertCounts_+3A_unit">unit</code></td>
<td>
<p>Required. One of CPM, FPKM, FPK or TPM.</p>
</td></tr>
<tr><td><code id="convertCounts_+3A_genelength">geneLength</code></td>
<td>
<p>A vector or matrix of gene lengths. Required for length-normalized units (TPM, FPKM or FPK).
If geneLength is a matrix, the rowMeans are calculated and used.</p>
</td></tr>
<tr><td><code id="convertCounts_+3A_log">log</code></td>
<td>
<p>Default = FALSE.  Set TRUE to return Log2 values.
Employs edgeR functions which use an prior.count of 0.25 scaled by the library size.</p>
</td></tr>
<tr><td><code id="convertCounts_+3A_normalize">normalize</code></td>
<td>
<p>Default = &quot;none&quot;. Invokes edgeR's calcNormFactors() for normalization.
Other options are: &quot;TMM&quot;, &quot;RLE&quot;, &quot;upperquartile&quot; (uses 75th percentile), &quot;TMMwzp&quot; and are case-insensitive.</p>
</td></tr>
<tr><td><code id="convertCounts_+3A_prior.count">prior.count</code></td>
<td>
<p>Average count to be added to each observation to avoid taking log of zero.
Used only if log = TRUE. (Default dependent on method; 0 for TPM, 0.25 for CPM and FPKM)
The prior.count is passed to edgeR cpm and rpkm functions and applies to logTPM, logCPM, and logFPKM calculations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>geneLength is a vector where length(geneLength) == nrow(countsMatrix). If a
RSEM effectiveLength matrix is passed as input, rowMeans(effectiveLength) is
used (because edgeR functions only accept a vector for effectiveLength).
</p>
<p>Note that log2 values for CPM, TPM, and FPKM employ edgeR's prior.count handling to avoid divide by zero.
</p>


<h3>Value</h3>

<p>A matrix in the new unit space
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # NOTE: Requires the edgeR package

  # Simulate some data
  counts &lt;- trunc(matrix(runif(6000, min=0, max=2000), ncol=6))
  geneLength &lt;- rowMeans(counts)

  # TMM normalized Log2FPKM
  Log2FPKM &lt;- convertCounts(counts,
                            unit       = "fpkm",
                            geneLength = geneLength,
                            log        = TRUE,
                            normalize  = "tmm")

  # Non-normalized CPM (not logged)
  RawCPM &lt;- convertCounts(counts,
                          unit      = "CPM",
                          log       = FALSE,
                          normalize = "none")

## End(Not run)

</code></pre>

<hr>
<h2 id='extractCol'>Extract a named column from a series of df or matrices</h2><span id='topic+extractCol'></span>

<h3>Description</h3>

<p>Take a named list of dataframes where each dataframe has the same
column names (e.g. a list of topTable dataframes), then extract
the named column from each dataframe and return a matrix.  The name of
each dataframe is used as the column name in the resulting table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractCol(contrastList, colName, robust = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractCol_+3A_contrastlist">contrastList</code></td>
<td>
<p>A list of data.frames which all have the same colnames and same row counts.
The dataframes in the list should have geneIDs as rownames.</p>
</td></tr>
<tr><td><code id="extractCol_+3A_colname">colName</code></td>
<td>
<p>The name of the data column to extract into a matrix.</p>
</td></tr>
<tr><td><code id="extractCol_+3A_robust">robust</code></td>
<td>
<p>Default = TRUE; TRUE forces use of a joins to merge columns
which is more reliable and allows for combination of contrasts from different
projects, but may not return items in the same row order as the source
table. Setting to FALSE invokes a cbind() approach that requires all
data.frames to have the same row count and row order but preserves the
original row order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The common use case for this is to provide a list of topTable
data frames and extract one column from each file to create
a matrix of LogRatios or P-values (genes x contrasts)..
</p>
<p>This should work as long as the requested column name is present in every
dataframe.  The default robust = TRUE should be used unless it has been
verified that each dataframe in the input list has the same row count and row
order.
</p>


<h3>Value</h3>

<p>A dataframe containing the extracted columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   dgeObj &lt;- readRDS(system.file("exampleObj.RDS", package = "DGEobj"))
   TopTableList &lt;- DGEobj::getType(dgeObj, type = "topTable")
   MyPvalues    &lt;- extractCol(TopTableList, colName = "P.Value")
   head(MyPvalues)

</code></pre>

<hr>
<h2 id='lowIntFilter'>Apply low intensity filters to a DGEobj</h2><span id='topic+lowIntFilter'></span>

<h3>Description</h3>

<p>Takes a DGEobj as input and applies a combination of low intensity filters as
specified by the user. Raw count, zFPKM, TPM, and/or FPK filters are
supported.  A gene must pass all active filters.  Not setting a threshold
argument inactivates that threshold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lowIntFilter(
  dgeObj,
  countThreshold,
  zfpkmThreshold,
  fpkThreshold,
  tpmThreshold,
  sampleFraction = 0.5,
  geneLength,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lowIntFilter_+3A_dgeobj">dgeObj</code></td>
<td>
<p>A DGEobj with RNA-Seq (counts) data (Required)</p>
</td></tr>
<tr><td><code id="lowIntFilter_+3A_countthreshold">countThreshold</code></td>
<td>
<p>Genes below this threshold are removed (10 is recommended).</p>
</td></tr>
<tr><td><code id="lowIntFilter_+3A_zfpkmthreshold">zfpkmThreshold</code></td>
<td>
<p>Genes below this threshold are removed. (-3.0 is recommended)</p>
</td></tr>
<tr><td><code id="lowIntFilter_+3A_fpkthreshold">fpkThreshold</code></td>
<td>
<p>Genes below this threshold are removed. (5 is recommended)</p>
</td></tr>
<tr><td><code id="lowIntFilter_+3A_tpmthreshold">tpmThreshold</code></td>
<td>
<p>Genes below this threshold are removed.</p>
</td></tr>
<tr><td><code id="lowIntFilter_+3A_samplefraction">sampleFraction</code></td>
<td>
<p>The proportion of samples that must meet the thresholds
(Default = 0.5). Range &gt; 0 and &lt;= 1.</p>
</td></tr>
<tr><td><code id="lowIntFilter_+3A_genelength">geneLength</code></td>
<td>
<p>Vector of geneLengths for rows of dgeObj. Required for FPK and
zFPKM filters, unless dgeObj is a DGEobj.  If a DGEobj is supplied, geneLength is
retrieved from the DGEobj, unless supplied by the geneLength argument.</p>
</td></tr>
<tr><td><code id="lowIntFilter_+3A_verbose">verbose</code></td>
<td>
<p>Prints messages about the filtering process.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same class as input object with low intensity rows removed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  myDGEobj &lt;- readRDS(system.file("exampleObj.RDS", package = "DGEobj"))
  dim(myDGEobj)

  # Simple count threshold in at least 3/4ths the samples
  myDGEobj &lt;- lowIntFilter(myDGEobj,
                           countThreshold = 10,
                           sampleFraction = 0.5)
  dim(myDGEobj)

  # Count and FPK thresholds
  myDGEobj &lt;- lowIntFilter(myDGEobj,
                           countThreshold = 10,
                           fpkThreshold = 5,
                           sampleFraction = 0.5)
  dim(myDGEobj)

## End(Not run)

</code></pre>

<hr>
<h2 id='rsqCalc'>Calculate R-squared for each gene fit</h2><span id='topic+rsqCalc'></span>

<h3>Description</h3>

<p>Takes a Log2CPM numeric matrix and MArrayLM fit object from limma's lmFit()
and calculates R-squared for each gene fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsqCalc(normMatrix, fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsqCalc_+3A_normmatrix">normMatrix</code></td>
<td>
<p>A normalized log2cpm matrix</p>
</td></tr>
<tr><td><code id="rsqCalc_+3A_fit">fit</code></td>
<td>
<p>A MArrayLM object from limma's lmFit()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of R-squared values for each gene fit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   # NOTE: Requires the edgeR package

   dgeObj    &lt;- readRDS(system.file("exampleObj.RDS", package = "DGEobj"))
   log2cpm   &lt;- convertCounts(dgeObj$counts, unit = "cpm", log=TRUE, normalize = "tmm")
   fitObject &lt;- dgeObj$ReplicateGroupDesign_fit
   rsq       &lt;- rsqCalc (log2cpm, fitObject)

## End(Not run)

</code></pre>

<hr>
<h2 id='runContrasts'>Build contrast matrix and calculate contrast fits</h2><span id='topic+runContrasts'></span>

<h3>Description</h3>

<p>Takes a DGEobj and a named list of contrasts to build. The DGEobj must
contain a limma Fit object and associated designMatrix. Returns the DGEobj with
contrast fit(s), contrast matrix, and topTable/topTreat dataframes added.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runContrasts(
  dgeObj,
  designMatrixName,
  contrastList,
  contrastSetName = NULL,
  runTopTable = TRUE,
  runTopTreat = FALSE,
  foldChangeThreshold = 1.5,
  runEBayes = TRUE,
  robust = TRUE,
  proportion = 0.01,
  qValue = FALSE,
  IHW = FALSE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runContrasts_+3A_dgeobj">dgeObj</code></td>
<td>
<p>A DGEobj object containing a Fit object and design matrix. (Required)</p>
</td></tr>
<tr><td><code id="runContrasts_+3A_designmatrixname">designMatrixName</code></td>
<td>
<p>The name of the design matrix within dgeObj to use for
contrast analysis. (Required)</p>
</td></tr>
<tr><td><code id="runContrasts_+3A_contrastlist">contrastList</code></td>
<td>
<p>A named list of contrasts. (Required)</p>
</td></tr>
<tr><td><code id="runContrasts_+3A_contrastsetname">contrastSetName</code></td>
<td>
<p>Name for the set of contrasts specified in
contrastList.  Defaults to &quot;&lt;fitName&gt;_cf&quot;. Only needed to create 2 or more
contrast sets from the same initial fit.</p>
</td></tr>
<tr><td><code id="runContrasts_+3A_runtoptable">runTopTable</code></td>
<td>
<p>Runs topTable on the specified contrasts. (Default = TRUE)</p>
</td></tr>
<tr><td><code id="runContrasts_+3A_runtoptreat">runTopTreat</code></td>
<td>
<p>Runs topTreat on the specified contrasts. (Default = FALSE)</p>
</td></tr>
<tr><td><code id="runContrasts_+3A_foldchangethreshold">foldChangeThreshold</code></td>
<td>
<p>Only applies to topTreat (Default = 1.5)</p>
</td></tr>
<tr><td><code id="runContrasts_+3A_runebayes">runEBayes</code></td>
<td>
<p>Runs eBayes after contrast.fit (Default = TRUE)</p>
</td></tr>
<tr><td><code id="runContrasts_+3A_robust">robust</code></td>
<td>
<p>eBayes robust option. 'statmod' package must be installed to perform required
calculations if robust = TRUE (Default = TRUE)</p>
</td></tr>
<tr><td><code id="runContrasts_+3A_proportion">proportion</code></td>
<td>
<p>Proportion of genes expected to be differentially expressed.
(used by eBayes) (Default = 0.01)</p>
</td></tr>
<tr><td><code id="runContrasts_+3A_qvalue">qValue</code></td>
<td>
<p>Set TRUE to include Q-values in topTable output. (Default = FALSE)</p>
</td></tr>
<tr><td><code id="runContrasts_+3A_ihw">IHW</code></td>
<td>
<p>Set TRUE to add FDR values from the IHW package. (Default = FALSE)</p>
</td></tr>
<tr><td><code id="runContrasts_+3A_verbose">verbose</code></td>
<td>
<p>Set TRUE to print some information during processing. (Default = FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The contrastList is a named list.  The values are composed of column names
from the designMatrix of the DGEobj.  Each contrast is named to give it a
short, recognizable name to be used for display purposes.
</p>
<p>Example contrastList <br />
</p>
<p>contrastList = list( <br />
T1 = &quot;treatment1 - control&quot;, <br />
T2 = &quot;treatment2 - control&quot; <br />
) <br />
</p>
<p>where treatment1, treatment2, and control are column names in the designMatrix.
</p>
<p>The returned DGEobj list contains the new items:
</p>

<ul>
<li><p>&quot;contrastMatrix&quot; a matrix
</p>
</li>
<li><p>&quot;Fit.Contrasts&quot; a Fit object
</p>
</li>
<li><p>&quot;topTableList&quot; a List of dataframes
</p>
</li>
<li><p>&quot;topTreatList&quot; a List of dataframes: if enabled
</p>
</li></ul>



<h3>Value</h3>

<p>The DGEobj with contrast matrix, fit and topTable/topTreat dataframes added.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # NOTE: Requires the limma and statmod packages

   myDGEobj &lt;- readRDS(system.file("exampleObj.RDS", package = "DGEobj"))

   # Name the design matrix to be used (see inventory(myDGEobj))
   designMatrixName &lt;- "ReplicateGroupDesign"

   # Define the named contrasts from design matrix column names
   contrastList  &lt;- list(BDL_v_Sham = "ReplicateGroupBDL - ReplicateGroupSham",
                         EXT1024_v_BDL = "ReplicateGroupBDL_EXT.1024  - ReplicateGroupBDL",
                         Nint_v_BDL = "ReplicateGroupBDL_Nint - ReplicateGroupBDL",
                         Sora_v_BDL = "ReplicateGroupBDL_Sora - ReplicateGroupBDL")


   myDGEobj &lt;- runContrasts(myDGEobj,
                            designMatrixName=designMatrixName,
                            contrastList=contrastList,
                            contrastSetName = "SecondContrastSet",
                            qValue = TRUE,
                            IHW = FALSE,
                            runTopTable = TRUE,
                            runTopTreat = TRUE,
                            foldChangeThreshold = 1.25)
   DGEobj::inventory(myDGEobj)

## End(Not run)

</code></pre>

<hr>
<h2 id='runEdgeRNorm'>Run edgeR normalization on DGEobj</h2><span id='topic+runEdgeRNorm'></span>

<h3>Description</h3>

<p>Takes a DGEobj and adds a normalized DGEList object representing the result of
edgeR normalization (calcNormFactors).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runEdgeRNorm(
  dgeObj,
  normMethod = "TMM",
  itemName = "DGEList",
  includePlot = FALSE,
  plotLabels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runEdgeRNorm_+3A_dgeobj">dgeObj</code></td>
<td>
<p>A DGEobj containing counts, design data, and gene annotation.</p>
</td></tr>
<tr><td><code id="runEdgeRNorm_+3A_normmethod">normMethod</code></td>
<td>
<p>One of &quot;TMM&quot;, &quot;RLE&quot;, &quot;upperquartile&quot;, or &quot;none&quot;. (Default = &quot;TMM&quot;)</p>
</td></tr>
<tr><td><code id="runEdgeRNorm_+3A_itemname">itemName</code></td>
<td>
<p>optional string represents the name of the new DGEList. It must be unique and not exist
in the passed DGEobj (Default = &quot;DGEList&quot;)</p>
</td></tr>
<tr><td><code id="runEdgeRNorm_+3A_includeplot">includePlot</code></td>
<td>
<p>Enable returning a &quot;canvasXpress&quot; or &quot;ggplot&quot; bar plot of the norm.factors
produced (Default = FALSE). Possible values to pass:
</p>

<ul>
<li> <p><strong>FALSE or NULL</strong>: Disable plot
</p>
</li>
<li> <p><strong>TRUE or &quot;canvasXpress&quot;</strong>: returns &quot;canvasXpress&quot; bar plot of the norm.factors produced.
</p>
</li>
<li> <p><strong>&quot;ggplot&quot;</strong>: returns &quot;ggplot&quot; bar plot of the norm.factors produced.
</p>
</li></ul>
</td></tr>
<tr><td><code id="runEdgeRNorm_+3A_plotlabels">plotLabels</code></td>
<td>
<p>Sample text labels for the plot. Length must equal the number of
samples. (Default = NULL; sample number will be displayed)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A DGEobj with a normalized DGEList added or a list containing the normalized DGEobj and a plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   # NOTE: Requires the edgeR package

   myDGEobj &lt;- readRDS(system.file("exampleObj.RDS", package = "DGEobj"))
   myDGEobj &lt;- DGEobj::resetDGEobj(myDGEobj)

   # Default TMM normalization
   myDGEobj &lt;- runEdgeRNorm(myDGEobj)

   # With some options and plot output
   require(canvasXpress)
   myDGEobj &lt;- DGEobj::resetDGEobj(myDGEobj)
   obj_plus_plot &lt;- runEdgeRNorm(myDGEobj,
                                 normMethod = "upperquartile",
                                 includePlot = TRUE)
   myDGEobj &lt;- obj_plus_plot[[1]]
   obj_plus_plot[[2]]

## End(Not run)

</code></pre>

<hr>
<h2 id='runIHW'>Apply Independent Hypothesis Weighting (IHW) to a list of topTable dataframes</h2><span id='topic+runIHW'></span>

<h3>Description</h3>

<p>This is a wrapper around the independent hypothesis weighting package that
takes a list of topTable data frames and applies Independent Hypothesis
Weighting (IHW) to each topTable data frame in the list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runIHW(contrastList, alpha = 0.1, FDRthreshold = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runIHW_+3A_contrastlist">contrastList</code></td>
<td>
<p>A named list of topTable dataframes.</p>
</td></tr>
<tr><td><code id="runIHW_+3A_alpha">alpha</code></td>
<td>
<p>Alpha should be the desired FDR level to interrogate (range 0-1; Default = 0.1)</p>
</td></tr>
<tr><td><code id="runIHW_+3A_fdrthreshold">FDRthreshold</code></td>
<td>
<p>Threshold value for the p-values of a dataframe (Default = 0.1)</p>
</td></tr>
<tr><td><code id="runIHW_+3A_...">...</code></td>
<td>
<p>other arguments are passed directly to the ihw function (see ?ihw)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IHW is a method developed by N. Ignatiadis (http://dx.doi.org/10.1101/034330)
to weight FDR values based on a covariate (AveExpr in this case).
</p>
<p>The IHW FDR values are added as additional columns to the topTable data frames.
</p>
<p>Function runIHW is normally called by runContrasts with argument IHW=T.  It
can also be used independently on a list of topTable dataframes.  A list of
topTable dataframes is conveniently retrieved with the DGEobj::getType
function with the type argument set to &quot;topTable&quot;.
</p>
<p>This function expects the following columns are present in each data frame:
P.value, adj.P.Val, AveExpr.
</p>
<p>Note that it is impractical to run IHW on a list of genes less than ~5000.
Operationally, IHW breaks the data into bins of 1500 genes for the analysis.
If bins = 1, IHW converges on the BH FDR value. Instead, run IHW on the
complete set of detected genes from topTable (not topTreat) results.
</p>


<h3>Value</h3>

<p>A list of lists.  The first element is the original contrastList with
additional IHW columns added to each dataframe. The topTable dataframes
will contain additional columns added by the IHW analysis and prefixed with
&quot;ihw.&quot; The second list element is the IHW result dataframe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   # NOTE: Requires the IHW package

   dgeObj &lt;- readRDS(system.file("exampleObj.RDS", package = "DGEobj"))
   contrastList &lt;- DGEobj::getType(dgeObj, type = "topTable")
   contrastList &lt;- lapply(contrastList, dplyr::select,
                          -ihw.adj_pvalue,
                          -ihw.weight,
                          -ihw.weighted_pvalue)
   colnames(contrastList[[1]])
   contrastList &lt;- runIHW(contrastList)

   # note new columns added
   colnames(contrastList[["contrasts"]][[1]])

## End(Not run)

</code></pre>

<hr>
<h2 id='runPower'>Run a power analysis on counts and design matrix</h2><span id='topic+runPower'></span>

<h3>Description</h3>

<p>Take a counts matrix and design matrix and return a power analysis using
the RNASeqPower package. The counts matrix should be pre-filtered to remove
non-expressed genes using an appropriate filtering criteria. The design matrix
should describe the major sources of variation so the procedure can dial
out those known effects for the power calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runPower(
  countsMatrix,
  designMatrix,
  depth = c(10, 100, 1000),
  N = c(3, 6, 10, 20),
  FDR = c(0.05, 0.1),
  effectSize = c(1.2, 1.5, 2),
  includePlots = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runPower_+3A_countsmatrix">countsMatrix</code></td>
<td>
<p>A counts matrix or dataframe of numeric data. (Required)</p>
</td></tr>
<tr><td><code id="runPower_+3A_designmatrix">designMatrix</code></td>
<td>
<p>A design matrix or dataframe of numeric data. (Required)</p>
</td></tr>
<tr><td><code id="runPower_+3A_depth">depth</code></td>
<td>
<p>A set of depth to use in the calculations.  The default depths of
c(10, 100, 1000) respectively represent a detection limit, below average
expression, and median expression levels, expressed in read count units.</p>
</td></tr>
<tr><td><code id="runPower_+3A_n">N</code></td>
<td>
<p>A set of N value to report power for. (Default = c(3, 6, 10, 20))</p>
</td></tr>
<tr><td><code id="runPower_+3A_fdr">FDR</code></td>
<td>
<p>FDR thresholds to filter for for FDR vs. Power graph. (Default = c(0.05, 0.1))</p>
</td></tr>
<tr><td><code id="runPower_+3A_effectsize">effectSize</code></td>
<td>
<p>A set of fold change values to test. (Default = c(1.2, 1.5, 2))</p>
</td></tr>
<tr><td><code id="runPower_+3A_includeplots">includePlots</code></td>
<td>
<p>controls adding tow plots to the returned dataframe (Default = FALSE).
The two plots are; a ROC curve (FDR vs. Power) and a plot of N vs. Power.
Possible values to pass:
</p>

<ul>
<li> <p><strong>FALSE or NULL</strong>: Disable plots
</p>
</li>
<li> <p><strong>TRUE or &quot;canvasXpress&quot;</strong>: returns &quot;canvasXpress&quot; plots.
</p>
</li>
<li> <p><strong>&quot;ggplot&quot;</strong>: returns &quot;ggplot&quot; plots.</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Note, both 'RNASeqPower' and 'statmod' packages are required to run this function as follow:
</p>

<ul>
<li> <p>'RNASeqPower' package is required to run power analysis on the given counts matrix and design matrix.
</p>
</li>
<li> <p>'statmod' package is required to run estimate dispersion calculations
</p>
</li></ul>

<p>If includePlots = FALSE (the default) or NULL, the function will return a tall skinny dataframe
of power calculations for various requested combinations of N and significance
thresholds.
</p>
<p>If includePlots = TRUE, &quot;canvasXpress&quot; or &quot;ggplot&quot;, a list is returned with an additional two
&quot;canvasXpress&quot; or ggplots (plots) to the dataframe.
</p>


<h3>Value</h3>

<p>a dataframe of power calculations or a list of the dataframe and defined plots as defined by the &quot;includePlots&quot; argument.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    # NOTE: Requires the RNASeqPower, statmod, and edgeR packages

    dgeObj &lt;- readRDS(system.file("exampleObj.RDS", package = "DGEobj"))
    counts &lt;- dgeObj$counts
    dm     &lt;- DGEobj::getType(dgeObj, type = "designMatrix")[[1]]

    resultList &lt;- runPower(countsMatrix = counts,
                           designMatrix = dm,
                           includePlots = TRUE)

    head(resultList[[1]]) # dataframe
    resultList[[2]]       # ROC Curves Plot
    resultList[[3]]       # N vs Power Plot

## End(Not run)

</code></pre>

<hr>
<h2 id='runQvalue'>Calculate and add q-value and lFDR to dataframe</h2><span id='topic+runQvalue'></span>

<h3>Description</h3>

<p>Takes an list of contrasts (e.g. topTable output or other dataframes that contain
a p-value column).  Adds a q-value and local FDR (lFDR) column to each dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runQvalue(contrastList, pvalField = "P.Value", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runQvalue_+3A_contrastlist">contrastList</code></td>
<td>
<p>A list of dataframes with a p-value column (all tables
must use the same colname for the p-value column.)</p>
</td></tr>
<tr><td><code id="runQvalue_+3A_pvalfield">pvalField</code></td>
<td>
<p>Define the colname of the p-value field in
each dataframe. Not needed if using topTable output. (Optional. Default = &quot;P.Value&quot;)</p>
</td></tr>
<tr><td><code id="runQvalue_+3A_...">...</code></td>
<td>
<p>Optional arguments passed to the qvalue function (See ?qvalue)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The qvalue package from John Storey at Princeton takes a list of p-values and
calculates a q-value and a Local FDR (lFDR). The q-value is essentially a less
conservative FDR estimate compared to the default Benjamini-Hochberg FDR
produced by topTable analysis (i.e. will give more differential genes at
the same nominal cutoff). The q-value function also produces a Local FDR
(lFDR) column which answers a slightly different and possibly more relevant
question. The BH FDR (adj.P.Val in topTable data.frames) and q-value gives
the false discovery rate is for a list of genes at a given threshold.
The local FDR attempts to answer the question: what is the probability that
this particular gene is a false discovery?
See <a href="https://doi.org/10.1007/978-3-642-04898-2_248">doi:10.1007/978-3-642-04898-2_248</a> for a brief introduction
to FDRs and q-values.
</p>


<h3>Value</h3>

<p>The input contrastList now containing q-value and lFDR columns
in each dataframe.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   # NOTE: Requires the qvalue package

   dgeObj &lt;- readRDS(system.file("exampleObj.RDS", package = "DGEobj"))
   contrastList &lt;- DGEobj::getType(dgeObj, type = "topTable")
   contrastList &lt;- lapply(contrastList, dplyr::select,
                          -Qvalue,
                          -qvalue.lfdr)
   colnames(contrastList[[1]])

   contrastList &lt;- runQvalue(contrastList)

   # note new columns added
   colnames(contrastList[[1]])

## End(Not run)

</code></pre>

<hr>
<h2 id='runSVA'>Test for surrogate variables</h2><span id='topic+runSVA'></span>

<h3>Description</h3>

<p>Takes a DGEobj from runVoom and tests for surrogate variables. Adds a new
design matrix to the DGEobj with the surrogate variable columns appended using cbind.
runVoom should then be run again with the new design matrix to complete the
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runSVA(dgeObj, designMatrixName, n.sv, method = "leek")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runSVA_+3A_dgeobj">dgeObj</code></td>
<td>
<p>A DGEobj with normalized counts and a designMatrix.</p>
</td></tr>
<tr><td><code id="runSVA_+3A_designmatrixname">designMatrixName</code></td>
<td>
<p>The itemName of the design matrix in DGEobj.</p>
</td></tr>
<tr><td><code id="runSVA_+3A_n.sv">n.sv</code></td>
<td>
<p>Optional; Use to override the default n.sv returned by num.sv
for the number of SV to analyze.</p>
</td></tr>
<tr><td><code id="runSVA_+3A_method">method</code></td>
<td>
<p>Method passed to num.sv. Supports &quot;leek&quot; or &quot;be&quot;. (Default =
&quot;leek&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dgeObj containing an updated design table, the svobj and a new design
matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   # NOTE: Requires the sva package

    dgeObj &lt;- readRDS(system.file("exampleObj.RDS", package = "DGEobj"))

    ###  Create a model based on surgery status, intentionally omitting the compound treatments
    dgeObj$design$SurgeryStatus &lt;- "BDL"
    dgeObj$design$SurgeryStatus[dgeObj$design$ReplicateGroup == "Sham"] &lt;- "Sham"
    formula &lt;- '~ 0 + SurgeryStatus'
    designMatrix &lt;- model.matrix (as.formula(formula), dgeObj$design)

    # Make sure the column names in the design matrix are legal
    colnames(designMatrix) &lt;- make.names(colnames(designMatrix))

    #capture the formula as an attribute of the design matrix
    attr(designMatrix, "formula") &lt;- formula

    #add the designMatrix to the DGEobj
    dgeObj &lt;- DGEobj::addItem(dgeObj,
                              item      = designMatrix,
                              itemName  = "SurgeryStatusDesign",
                              itemType  = "designMatrix",
                              parent    = "design",
                              overwrite = TRUE)

    dgeObj &lt;- runSVA(dgeObj, designMatrixName = "SurgeryStatusDesign")

## End(Not run)

</code></pre>

<hr>
<h2 id='runVoom'>Run functions in a typical voom/lmFit workflow</h2><span id='topic+runVoom'></span>

<h3>Description</h3>

<p>In the default workflow, this function runs voomWithQualityWeights followed by
lmFit and optionally eBayes. If the contrasts of interest are already represented
in the model, enable eBayes. To use contrasts.fit downstream, run eBayes
after that step instead. eBayes should always be run last.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runVoom(
  dgeObj,
  designMatrixName,
  dupCorBlock,
  runDupCorTwice = TRUE,
  qualityWeights = TRUE,
  var.design,
  mvPlot = TRUE,
  runEBayes = TRUE,
  robust = TRUE,
  proportion = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runVoom_+3A_dgeobj">dgeObj</code></td>
<td>
<p>A DGEobj containing a DGEList (e.g. from runEdgeRNorm) or counts (Required)</p>
</td></tr>
<tr><td><code id="runVoom_+3A_designmatrixname">designMatrixName</code></td>
<td>
<p>Name of a design matrix within dgeObj. (Required)</p>
</td></tr>
<tr><td><code id="runVoom_+3A_dupcorblock">dupCorBlock</code></td>
<td>
<p>Supply a block argument to trigger duplicateCorrelation. (Optional)
Should be a vector the same length as ncol with values to indicate common
group membership for duplicateCorrelation.
Also, 'statmod' package must be installed to run duplicate correlation calculations.</p>
</td></tr>
<tr><td><code id="runVoom_+3A_rundupcortwice">runDupCorTwice</code></td>
<td>
<p>Default = TRUE. Gordon Smyth recommends running duplicateCorrelation
twice. Set this to false to run duplicateCorrelation just once.</p>
</td></tr>
<tr><td><code id="runVoom_+3A_qualityweights">qualityWeights</code></td>
<td>
<p>Runs limma's voomWithQualityWeights() if set to TRUE (Default = TRUE).
This should normally be set to TRUE.</p>
</td></tr>
<tr><td><code id="runVoom_+3A_var.design">var.design</code></td>
<td>
<p>Provide a design matrix (from model.matrix) to identify
replicate groups (e.g. &quot;~ ReplicateGroup&quot;) for quality weight determination.
Causes quality weights to be determined on a group basis.  If omitted
limma's voomWithQualityWeights() treats each sample individually.</p>
</td></tr>
<tr><td><code id="runVoom_+3A_mvplot">mvPlot</code></td>
<td>
<p>Enables the voom mean-variance plot. (Default = TRUE)</p>
</td></tr>
<tr><td><code id="runVoom_+3A_runebayes">runEBayes</code></td>
<td>
<p>Runs eBayes after lmFit. (Default = TRUE)
Note, 'statmod' package must be installed to run eBayes calculations.</p>
</td></tr>
<tr><td><code id="runVoom_+3A_robust">robust</code></td>
<td>
<p>Used by eBayes. (Default = TRUE)
Note, 'statmod' package must be installed to run eBayes calculations.</p>
</td></tr>
<tr><td><code id="runVoom_+3A_proportion">proportion</code></td>
<td>
<p>Proportion of genes expected to be differentially expressed
(used by eBayes) (Default = 0.01) Modify the prior accordingly if the 1st pass analysis shows
a significantly higher or lower proportion of genes regulated than the default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Input is minimally a DGEobj containing a DGEList (which is typically TMM-normalized)
and a formula (character representation).  If a DGEList is missing on the object the
counts are used as-is.  Other arguments can invoke the duplicateCorrelation method and
modify use of quality weights.
</p>
<p>Returns a DGEobj class object containing the VoomElist (voom
output), and Fit object (lmFit output).
</p>
<p>Quality weights should be enabled unless there is a good reason to turn them
off. If all samples are equal quality, the weights will all approach 1.0 with no
consequence on the results. More typically, some samples are better than others
and using quality weights improves the overall result.
</p>
<p>Use var.design if the quality weights are correlated with some factor in the experiment.
This will cause the quality weights to be calculated as a group instead of individually.
</p>
<p>Use duplicate correlation (dupCorBlock) when there are subjects that have been sampled more
than once (e.g. before and after some treatment).  This calculates a within-
subject correlation and includes this in the model.
</p>


<h3>Value</h3>

<p>A DGEobj now containing designMatrix, Elist, and fit object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # NOTE: Requires the limma package

   dgeObj &lt;- readRDS(system.file("exampleObj.RDS", package = "DGEobj"))
   for (name in names(dgeObj)[11:length(dgeObj)]) {
       dgeObj &lt;- DGEobj::rmItem(dgeObj, name)
   }

   dgeObj &lt;- runVoom(dgeObj,
                     designMatrixName = "ReplicateGroupDesign",
                     mvPlot = TRUE)

   # Note the Elist and fit objects have been added
   DGEobj::inventory(dgeObj)

## End(Not run)

</code></pre>

<hr>
<h2 id='summarizeSigCounts'>Summarize a contrast list</h2><span id='topic+summarizeSigCounts'></span>

<h3>Description</h3>

<p>Takes a contrast list produced by runContrasts. Defaults are provided to specify columns to
summarize and thresholds for each column, though they can be adjusted. A fold change
threshold can optionally be specified. The function queries the topTable results and
returns a dataframe with the summary results, but only includes gene counts that meet
the specified conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizeSigCounts(
  contrastList,
  columns = c("P.Value", "adj.P.Val", "Qvalue", "qvalue.lfdr", "ihw.adj_pvalue"),
  sigThresholds = c(0.01, 0.05, 0.05, 0.05, 0.05),
  fcThreshold = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarizeSigCounts_+3A_contrastlist">contrastList</code></td>
<td>
<p>A list of topTable dataframes.</p>
</td></tr>
<tr><td><code id="summarizeSigCounts_+3A_columns">columns</code></td>
<td>
<p>Vector of column names to summarize from topTable dataframes.
Default = c(&quot;P.Value&quot;, &quot;adj.P.Val&quot;, &quot;Qvalue&quot;, &quot;qvalue.lfdr&quot;, &quot;ihw.adj_pvalue&quot;)</p>
</td></tr>
<tr><td><code id="summarizeSigCounts_+3A_sigthresholds">sigThresholds</code></td>
<td>
<p>Thresholds to use for each column specified in columns
Must be same length at columns argument.
Default = c(0.01, 0.05, 0.05, 0.05, 0.05)</p>
</td></tr>
<tr><td><code id="summarizeSigCounts_+3A_fcthreshold">fcThreshold</code></td>
<td>
<p>Fold-change threshold (absolute value, not logged.)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Any specified column names that don't exist will be ignored. Normally the
defaults cover all the p-value and FDR related columns. However, a fcThreshold
can be added and the p-value/FDR thresholds can be modified using the fcThreshold
and sigThresholds arguments, respectively.
</p>


<h3>Value</h3>

<p>data.frame with one summary row per contrast.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   dgeObj &lt;- readRDS(system.file("exampleObj.RDS", package = "DGEobj"))
   contrastList &lt;- DGEobj::getType(dgeObj, type = "topTable")

   #all defaults
   sigSummary &lt;- summarizeSigCounts(contrastList)

   #add the fold-chage threshold
   sigSummary &lt;- summarizeSigCounts(contrastList, fcThreshold = 2)

   #change the significance thresholds
   sigSummary &lt;- summarizeSigCounts(contrastList,
                                    sigThresholds = c(0.01, 0.1, 0.1, 0.1, 0.1))

</code></pre>

<hr>
<h2 id='topTable.merge'>Merge specified topTable df cols</h2><span id='topic+topTable.merge'></span>

<h3>Description</h3>

<p>Take a named list of topTable dataframes and cbinds the requested columns
from each file.  To avoid column name conflicts the names are used as suffixes
to the colnames. Although written for topTable data, this should work on any
named list of dataframes where each member of the list has the same columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topTable.merge(
  contrastList,
  colNames = c("logFC", "AveExpr", "P.Value", "adj.P.Val"),
  digits = c(2, 2, 4, 3)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topTable.merge_+3A_contrastlist">contrastList</code></td>
<td>
<p>A named list of topTable data.frames which all have the same colnames and same row counts.
The dataframes in the list should have rownames (geneIDs).</p>
</td></tr>
<tr><td><code id="topTable.merge_+3A_colnames">colNames</code></td>
<td>
<p>The list of column names of the data column to extract to a
matrix (Default = c(&quot;logFC&quot;, &quot;AveExpr&quot;, &quot;P.Value&quot;, &quot;adj.P.Val&quot;))</p>
</td></tr>
<tr><td><code id="topTable.merge_+3A_digits">digits</code></td>
<td>
<p>Number of decimal places for specified columns. Should be same
length as colNames. (Default = c(2, 2, 4, 3)). If one value supplied, it is used
for all columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing the extracted columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dgeObj &lt;- readRDS(system.file("exampleObj.RDS", package = "DGEobj"))
contrastList &lt;- DGEobj::getType(dgeObj, type = "topTable")

mergedData &lt;- topTable.merge(contrastList)
colnames(mergedData)

</code></pre>

<hr>
<h2 id='tpm.direct'>Convert countsMatrix and geneLength to TPM units</h2><span id='topic+tpm.direct'></span>

<h3>Description</h3>

<p>Takes a countsMatrix and geneLength as input and converts to TPM units using the equation from
<a href="https://haroldpimentel.wordpress.com/2014/05/08/what-the-fpkm-a-review-rna-seq-expression-units/">Harold Pimental</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpm.direct(countsMatrix, geneLength, collapse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tpm.direct_+3A_countsmatrix">countsMatrix</code></td>
<td>
<p>A numeric matrix of N genes x M samples. All columns must be numeric.</p>
</td></tr>
<tr><td><code id="tpm.direct_+3A_genelength">geneLength</code></td>
<td>
<p>Numeric matrix of gene lengths. Often the ExonLength item of a DGEobj.</p>
</td></tr>
<tr><td><code id="tpm.direct_+3A_collapse">collapse</code></td>
<td>
<p>Default = FALSE. TRUE or FALSE determines whether to use rowMeans on the geneLength matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The result should be the same as using convertCounts with normalize = 'tpm' and log = FALSE.
</p>
<p>geneLength can be a vector (length == nrow(countsMatrix)) or a matrix (same dim as countsMatrix).
The geneLength is used as is, or optionally collapsed to a vector by rowMeans.
</p>


<h3>Value</h3>

<p>A matrix of TPM values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   dgeObj &lt;- readRDS(system.file("exampleObj.RDS", package = "DGEobj"))

   counts &lt;- DGEobj::getItem(dgeObj, "counts")
   exonLength &lt;- dgeObj$geneData$ExonLength
   tpm &lt;- tpm.direct(counts, geneLength = exonLength)

</code></pre>

<hr>
<h2 id='tpm.on.subset'>Calculate TPM for a subsetted DGEobj</h2><span id='topic+tpm.on.subset'></span>

<h3>Description</h3>

<p>Calculates TPM for a heavily subsetted DGEobj. The function will calculate TPM
using the original data but returns a DGEobj with the subset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tpm.on.subset(dgeObj, applyFilter = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tpm.on.subset_+3A_dgeobj">dgeObj</code></td>
<td>
<p>A DGEobj data structure</p>
</td></tr>
<tr><td><code id="tpm.on.subset_+3A_applyfilter">applyFilter</code></td>
<td>
<p>Default = TRUE. If TRUE, reduces to the filtered gene list. FALSE returns
all genes in the raw data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TPM should be calculated on a full dataset with only low signal genes removed.
tpm.on.subset therefore allows calculation of TPM after heavy filtering of a DGEobj.
</p>
<p>Internally, convertCounts uses edgeR's fpkm() to calculate FPKM and converts to TPM
using the formula provided by [Harold Pimental](https://haroldpimentel.wordpress.com/2014/05/08/what-the-fpkm-a-review-rna-seq-expression-units/).
</p>


<h3>Value</h3>

<p>A matrix of TPM values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   # NOTE: Requires the edgeR package

   dgeObj &lt;- readRDS(system.file("exampleObj.RDS", package = "DGEobj"))
   tpm    &lt;- tpm.on.subset(dgeObj)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
