<!DOCTYPE html><html><head><title>Help for package hicp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hicp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chaining'><p>Chain-linking, rebasing and frequency conversion</p></a></li>
<li><a href='#coicop.bundles'><p>COICOP bundle codes</p></a></li>
<li><a href='#coicop.relatives'><p>Derive or flag COICOP relatives</p></a></li>
<li><a href='#coicop.tree'><p>Derive and fix COICOP tree</p></a></li>
<li><a href='#countries'><p>Country metadata</p></a></li>
<li><a href='#hicp.data'><p>Download HICP data</p></a></li>
<li><a href='#index.aggregation'><p>Index number functions and aggregation</p></a></li>
<li><a href='#linking'><p>Linking-in new index series</p></a></li>
<li><a href='#rates'><p>Change rates and contributions</p></a></li>
<li><a href='#spec.aggs'><p>Special aggregates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Harmonised Index of Consumer Prices</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.2</td>
</tr>
<tr>
<td>Description:</td>
<td>The Harmonised Index of Consumer Prices (HICP) is the key economic figure to measure inflation in the euro area.
              The methodology underlying the HICP is documented in the HICP Methodological Manual (<a href="https://ec.europa.eu/eurostat/web/products-manuals-and-guidelines/w/ks-gq-24-003">https://ec.europa.eu/eurostat/web/products-manuals-and-guidelines/w/ks-gq-24-003</a>).
              Based on the manual, this package provides functions to access and work with HICP data from Eurostat's public database (<a href="https://ec.europa.eu/eurostat/data/database">https://ec.europa.eu/eurostat/data/database</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://joinup.ec.europa.eu/software/page/eupl">EUPL</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>restatapi (&ge; 0.21.0), data.table (&ge; 1.14.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/eurostat/hicp">https://github.com/eurostat/hicp</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/eurostat/hicp/issues">https://github.com/eurostat/hicp/issues</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-28 14:12:08 UTC; Sebastian</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Weinand [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Weinand &lt;sebastian.weinand@ec.europa.eu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-28 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='chaining'>Chain-linking, rebasing and frequency conversion</h2><span id='topic+unchain'></span><span id='topic+chain'></span><span id='topic+rebase'></span><span id='topic+convert'></span>

<h3>Description</h3>

<p>Function <code>unchain()</code> decouples a chained index series with monthly frequency. These unchained index series can be aggregated into higher-level indices using <code><a href="#topic+aggregate">aggregate</a>()</code>. To obtain a longterm index series, the higher-level indices must be chained using function <code>chain()</code>. Finally, <code>rebase()</code> sets the index reference period. Monthly indices can be converted into annual or quarterly indices using function <code>convert()</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>unchain(x, t, by=12)

chain(x, t, by=12)

rebase(x, t, t.ref, verbose=FALSE)

convert(x, t, freq="annual")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chaining_+3A_x">x</code></td>
<td>
<p>numeric vector of index values</p>
</td></tr>
<tr><td><code id="chaining_+3A_t">t</code></td>
<td>
<p>date vector</p>
</td></tr>
<tr><td><code id="chaining_+3A_by">by</code></td>
<td>
<p>for annual overlap <code>NULL</code>; for one-month overlap a single integer between 1 and 12 specifying the price reference month</p>
</td></tr>
<tr><td><code id="chaining_+3A_t.ref">t.ref</code></td>
<td>
<p>character specifying the index reference period. Could be a whole year (<code>YYYY</code>) or a single year-month (<code>YYYY-MM</code>).</p>
</td></tr>
<tr><td><code id="chaining_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if messages regarding the index reference period should be printed to the console or not.</p>
</td></tr>
<tr><td><code id="chaining_+3A_freq">freq</code></td>
<td>
<p>frequency of converted index. Either <code>annual</code> or <code>quarterly</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Functions <code>unchain()</code>, <code>chain()</code> and <code>rebase()</code> return numeric values of the same length as <code>x</code>.
</p>
<p>Function <code>convert()</code> returns a named vector of the length of quarter or years available in <code>t</code>, where the names correspond to the years or quarters.
</p>


<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>References</h3>

<p>Eurostat (2024), <em>Harmonised Index of Consumer Prices (HICP): Methodological Manual</em>, Luxembourg: Publications Office of the European Union, online available at: <a href="https://ec.europa.eu/eurostat/web/products-manuals-and-guidelines/w/ks-gq-24-003">https://ec.europa.eu/eurostat/web/products-manuals-and-guidelines/w/ks-gq-24-003</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aggregate">aggregate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### EXAMPLE 1

t &lt;- seq.Date(from=as.Date("2021-12-01"), to=as.Date("2024-12-01"), by="1 month")
p &lt;- rnorm(n=length(t), mean=100, sd=5)

100*p/p[1]
chain(unchain(p, t, by=12), t, by=12)

convert(x=p, t=t, freq="q") # quarterly index

t &lt;- seq.Date(from=as.Date("2021-01-01"), to=as.Date("2024-12-01"), by="1 month")
p &lt;- rnorm(n=length(t), mean=100, sd=5)

100*p/mean(p[1:12])
(res &lt;- chain(unchain(p, t, by=NULL), t, by=NULL))
# note that for backwards compability, each month in the first
# year receives an index value of 100. this allows the same
# computation again:
chain(unchain(res, t, by=NULL), t, by=NULL)

### EXAMPLE 2

# set cores for testing on CRAN:
library(restatapi)
options(restatapi_cores=1)
library(data.table)

# get hicp index values for euro area with base 2015:
dt &lt;- hicp.dataimport(id="prc_hicp_midx", filter=list(unit="I15", geo="EA"))
dt[, "time":=as.Date(paste0(time, "-01"))]
setkeyv(x=dt, cols=c("unit","coicop","time"))

# check chain-linked indices against published data:
dt[, "dec_ratio" := unchain(x=values, t=time), by="coicop"]
dt[, "chained_index" := chain(x=dec_ratio, t=time), by="coicop"]
dt[, "index_own" := rebase(x=chained_index, t=time, t.ref="2015"), by="coicop"]
dt[abs(values-index_own)&gt;0.01,] # should be empty

# check converted indices against published data:
dta &lt;- dt[, as.data.table(convert(x=values, t=time), keep.rownames=TRUE), by="coicop"]
setnames(x=dta, c("coicop","time","index"))
aind &lt;- hicp.dataimport(id="prc_hicp_aind", filter=list(unit="INX_A_AVG", geo="EA"))
aind[, c("geo","unit") := NULL]
dtcomp &lt;- merge(x=aind, y=dta, by=c("coicop","time"), all=TRUE)
dtcomp[abs(values-index)&gt;0.01,] # should be empty
</code></pre>

<hr>
<h2 id='coicop.bundles'>COICOP bundle codes</h2><span id='topic+unbundle'></span><span id='topic+is.bundle'></span><span id='topic+coicop.bundles'></span>

<h3>Description</h3>

<p>HICP data follow the COICOP classification system. However, sometimes COICOP ids are merged into bundles, deviating from the usual structure of ids (e.g. 08X, 0531_2). Function <code>is.bundle()</code> flags if a coicop id is a bundle or not, while <code>unbundle()</code> splits the bundles into their original ids. Both functions make use of the bundle dictionary <code>coicop.bundles</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.bundle(id)

unbundle(id)

# list of coicop bundles:
coicop.bundles
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coicop.bundles_+3A_id">id</code></td>
<td>
<p>character vector of coicop ids.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>is.bundle()</code>, a logical vector of the same length as <code>id</code>. For <code>unbundle()</code> a vector of ids with length greater or equal to the length of <code>id</code>.</p>


<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>Examples</h3>

<pre><code class='language-R'>ids &lt;- c("011",NA,"08X","112","0531_2")
is.bundle(ids)
unbundle(ids)
</code></pre>

<hr>
<h2 id='coicop.relatives'>Derive or flag COICOP relatives</h2><span id='topic+is.coicop'></span><span id='topic+level'></span><span id='topic+child'></span><span id='topic+parent'></span>

<h3>Description</h3>

<p>Function <code>is.coicop()</code> checks if the input is a valid coicop code while <code>level()</code> returns the coicop level (e.g. division or subclass). Function <code>parent()</code> derives the parent of a coicop code if available in the data supplied, while <code>child()</code> does the same for children. Coicop codes must (roughly) follow the pattern <code>[0-9]{1,5}</code>, or be bundle codes defined in <code><a href="#topic+coicop.bundles">coicop.bundles</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.coicop(id, unbundle=TRUE)

level(id, unbundle=TRUE, label=FALSE)

child(id, flag=TRUE, unbundle=TRUE, direct=FALSE)

parent(id, flag=TRUE, unbundle=TRUE, direct=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coicop.relatives_+3A_id">id</code></td>
<td>
<p>character vector of coicop ids.</p>
</td></tr>
<tr><td><code id="coicop.relatives_+3A_label">label</code></td>
<td>
<p>logical indicating if digits or labels should be used for the COICOP level.</p>
</td></tr>
<tr><td><code id="coicop.relatives_+3A_flag">flag</code></td>
<td>
<p>for <code>flag=TRUE</code>, the function flags by a logical if parent or child codes are available in the data. Otherwise, it returns the parent or child codes.</p>
</td></tr>
<tr><td><code id="coicop.relatives_+3A_unbundle">unbundle</code></td>
<td>
<p>logical indicating if coicop bundles (e.g. 08X, 0531_2) should be taken into account or not.</p>
</td></tr>
<tr><td><code id="coicop.relatives_+3A_direct">direct</code></td>
<td>
<p>logical indicating if only direct relatives should be flagged as TRUE (e.g. <code>03-&gt;031</code>) or also indirect relatives (e.g. <code>03-&gt;0311</code>) if direct relatives in between are missing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>unbundle=TRUE</code>, coicop bundle codes are resolved into their component ids and processed in that way. By contrast, if <code>unbundle=FALSE</code>, coicop bundle codes are internally set to <code>NA</code>. Consequently, they can't be a parent or a child of some other coicop code.
</p>


<h3>Value</h3>

<p>Function <code>is.coicop()</code> returns a logical vector and function <code>level()</code> a numeric vector. If argument <code>flag=TRUE</code>, functions <code>parent()</code> and <code>child()</code> both return a logical vector. If <code>flag=FALSE</code>, <code>parent()</code> gives a character vector, while <code>child()</code> returns a list. In any case, all function outputs have the same length as <code>id</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>See Also</h3>

<p><code><a href="#topic+unbundle">unbundle</a></code>, <code><a href="#topic+tree">tree</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### EXAMPLE 1

# validity of coicop id:
is.coicop(id=c("00","CP00","13","08X"), unbundle=TRUE)
is.coicop(id=c("00","CP00","13","08X"), unbundle=FALSE)

# coicop level:
level(id=c("00","05","053","0531_2"))
level(id=c("00","05","053","0531_2"), label=TRUE)

# check for children in data:
child(id=c("0111"), flag=FALSE) # false, no child found
child(id=c("0111", "01"), flag=FALSE, direct=TRUE) # still false
child(id=c("0111", "01"), flag=FALSE, direct=FALSE) # now TRUE

# check for parent in data, including coicop bundles:
ids &lt;- c("053","0531_2","05311","05321")
parent(id=ids, flag=FALSE, unbundle=FALSE, direct=TRUE)
parent(id=ids, flag=FALSE, unbundle=TRUE, direct=TRUE)

### EXAMPLE 2

# set cores for testing on CRAN:
library(restatapi)
options(restatapi_cores=1)
library(data.table)

# load hicp item weights:
coicops &lt;- hicp.dataimport(id="prc_hicp_inw", filter=list(geo="EA"))
coicops &lt;- coicops[grepl("^CP", coicop),]
coicops[, "coicop":=gsub("^CP", "", coicop)]

# get frequency of coicop levels:
coicops[, .N, by=list(time, "lvl"=level(coicop))]

# get coicop parent from the data:
coicops[, "parent":=parent(id=coicop, flag=FALSE), by="time"]

# flag if coicop has child available in the data:
coicops[, "has_child":=child(id=coicop, flag=TRUE), by="time"]
coicops[has_child==FALSE, sum(values, na.rm=TRUE), by="time"]
# coicop bundles and their component ids are both taken into
# account. this double counting explains some differences
</code></pre>

<hr>
<h2 id='coicop.tree'>Derive and fix COICOP tree</h2><span id='topic+tree'></span>

<h3>Description</h3>

<p>Function <code>tree()</code> derives the COICOP tree at the lowest possible level. In HICP data, this can be done separately for each reporting month and country. Consequently, the COICOP tree can differ across space and time. If needed, specifying argument <code>by</code> in <code>tree()</code> allows to merge the COICOP trees at the lowest possible level, e.g. to obtain a unique composition of COICOP codes over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tree(id, by=NULL, w=NULL, w.tol=1/100, max.lvl=NULL, unbundle=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coicop.tree_+3A_id">id</code></td>
<td>
<p>character vector of coicop ids</p>
</td></tr>
<tr><td><code id="coicop.tree_+3A_by">by</code></td>
<td>
<p>vector specifying the variable to be used for merging the tree, e.g. vector of dates for merging over time or a vector of countries for merging across space. Can be <code>NULL</code> if no merging is required.</p>
</td></tr>
<tr><td><code id="coicop.tree_+3A_w">w</code></td>
<td>
<p>numeric weight of <code>id</code>. If supplied, it is checked that the weight of children add up to the corresponding weight of the parent (allowing for tolerance <code>w.tol</code>). If <code>w=NULL</code> (the default), no checking of weight aggregation is performed.</p>
</td></tr>
<tr><td><code id="coicop.tree_+3A_w.tol">w.tol</code></td>
<td>
<p>numeric tolerance for checking of weights. Only relevant in case <code>w</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="coicop.tree_+3A_max.lvl">max.lvl</code></td>
<td>
<p>integer specifying the maximum depth or deepest coicop level allowed. If <code>NULL</code>, the deepest level found in <code>id</code> is used.</p>
</td></tr>
<tr><td><code id="coicop.tree_+3A_unbundle">unbundle</code></td>
<td>
<p>logical indicating if coicop bundles (e.g. 08X, 0531_2) should be taken into account or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector of the same length as <code>id</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>See Also</h3>

<p><code><a href="#topic+unbundle">unbundle</a></code>, <code><a href="#topic+child">child</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### EXAMPLE 1

# flag lowest possible level to be used as COICOP tree:
tree(id=c("01","011","012"), w=NULL) # true
tree(id=c("01","011","012"), w=c(0.2,0.08,0.12)) # true, weights add up
tree(id=c("01","011","012"), w=c(0.2,0.08,0.10)) # false, weights do not add up

# set maximum (or deepest) coicop level to 3:
tree(id=c("01","011","012","0111","0112","01121"),
     w=c(0.2,0.08,0.12,0.02,0.06,0.06),
     max.lvl=3)

# maximum level=3, but weights do not add up:
tree(id=c("01","011","012","0111","0112","01121"),
     w=c(0.2,0.08,0.07,0.02,0.06,0.06),
     max.lvl=3)

# coicop bundles:
tree(id=c("08","081","082_083"), w=c(0.25,0.05,0.2))
tree(id=c("08","081","082_083"), w=c(0.25,0.05,0.2), unbundle=FALSE)

# merge (or fix) coicop tree over time:
tree(id=c("08","081","082","08"), by=c(1,1,1,2))

### EXAMPLE 2

# set cores for testing on CRAN:
library(restatapi)
options(restatapi_cores=1)
library(data.table)

# load hicp item weights:
coicops &lt;- hicp.dataimport(
              id="prc_hicp_inw",
              filter=list(geo=c("EA","DE","FR")),
              date.range=c("2005", NA))
coicops &lt;- coicops[grepl("^CP", coicop),]
coicops[, "coicop":=gsub("^CP", "", coicop)]

# derive seperate trees for each time period and country:
coicops[, "tree1" := tree(id=coicop, w=values, w.tol=0.1), by=c("geo","time")]
coicops[tree1==TRUE,
        list("n"=uniqueN(coicop),           # varying coicops over time and space
             "w"=sum(values, na.rm=TRUE)),  # weight sums should equal 1000
        by=c("geo","time")]

# derive merged trees over time, but not across countries:
coicops[, "tree2" := tree(id=coicop, by=time, w=values, w.tol=0.1), by="geo"]
coicops[tree2==TRUE,
        list("n"=uniqueN(coicop),           # same selection over time in a country
             "w"=sum(values, na.rm=TRUE)),  # weight sums should equal 1000
        by=c("geo","time")]

# derive merged trees over countries and time:
coicops[, "tree3" := tree(id=coicop, by=paste(geo,time), w=values, w.tol=0.1)]
coicops[tree3==TRUE,
        list("n"=uniqueN(coicop),           # same selection over time and across countries
             "w"=sum(values, na.rm=TRUE)),  # weight sums should equal 1000
        by=c("geo","time")]
</code></pre>

<hr>
<h2 id='countries'>Country metadata</h2><span id='topic+countries'></span>

<h3>Description</h3>

<p>This dataset contains metadata for the euro area, EU, EFTA, and candidate countries that submit(ted) HICP data on a regular basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># country metadata:
countries
</code></pre>


<h3>Format</h3>

<p>A data.table with metadata on the individual euro area (EA), EU, EFTA, and candidate countries producing the HICP.
</p>

<ul>
<li> <p><code>code</code>: the country code
</p>
</li>
<li> <p><code>name_[en|fr|de]</code>: the country name in English, French, and German
</p>
</li>
<li> <p><code>protocol_order</code>: the official protocol order of countries
</p>
</li>
<li> <p><code>is_eu, is_ea, is_efta, is_candidate</code>: a logical indicating if a country belongs to the EU, the euro area, or if it's an EFTA or candidate country, respectively
</p>
</li>
<li> <p><code>eu_since, eu_until</code>: date of joining and leaving the European Union
</p>
</li>
<li> <p><code>ea_since</code>: the date of introduction of the euro as the official currency
</p>
</li>
<li> <p><code>index_decimals</code>: the number of index decimals used for dissemination
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>Examples</h3>

<pre><code class='language-R'># subset to euro area countries:
countries[is_ea==TRUE, ]
</code></pre>

<hr>
<h2 id='hicp.data'>Download HICP data</h2><span id='topic+hicp.datasets'></span><span id='topic+hicp.datafilters'></span><span id='topic+hicp.dataimport'></span>

<h3>Description</h3>

<p>These functions are simple wrappers of functions in the <code>restatapi</code> package. Function <code>hicp.datasets()</code> lists all available HICP datasets in Eurostat's public database, while <code>hicp.datafilters()</code> gives the allowed values that can be used for filtering a dataset. <code>hicp.dataimport()</code> downloads a specific dataset with filtering on key parameters and time, if supplied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hicp.datasets()

hicp.datafilters(id)

hicp.dataimport(id, filters=list(), date.range=NULL, flags=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hicp.data_+3A_id">id</code></td>
<td>
<p>A dataset identifier, which can be obtained from <code>hicp.datasets()</code>.</p>
</td></tr>
<tr><td><code id="hicp.data_+3A_filters">filters</code></td>
<td>
<p>A named list of filters to be applied to the data request. Allowed values for filtering can be retrieved from <code>hicp.datafilters()</code>. For HICP data, typical filter variables are the index reference period (<code>unit: I96, I05, I15</code>), the country (<code>geo: EA, DE, FR,...</code>), or the COICOP code (<code>coicop: CP00, CP01, SERV, ...</code>).</p>
</td></tr>
<tr><td><code id="hicp.data_+3A_date.range">date.range</code></td>
<td>
<p>A vector of start and end date used for filtering on time dimension. These must follow the pattern <code>YYYY(-MM)?</code>. An open interval can be defined by setting one date to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="hicp.data_+3A_flags">flags</code></td>
<td>
<p>A logical indicating if data flags should be returned or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table.
</p>


<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>Source</h3>

<p>See Eurostat's public database at <a href="https://ec.europa.eu/eurostat/web/main/data/database">https://ec.europa.eu/eurostat/web/main/data/database</a>.
</p>


<h3>See Also</h3>

<p>restatapi: <code><a href="restatapi.html#topic+get_eurostat_toc">get_eurostat_toc</a></code>, <code><a href="restatapi.html#topic+get_eurostat_dsd">get_eurostat_dsd</a></code>, <code><a href="restatapi.html#topic+get_eurostat_data">get_eurostat_data</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># set cores for testing on CRAN:
library(restatapi)
options(restatapi_cores=1)

# view available datasets:
hicp.datasets()

# get allowed filters for item weights:
hicp.datafilters(id="prc_hicp_inw")

# download item weights for euro area from 2015 on:
hicp.dataimport(id="prc_hicp_inw", filters=list("geo"="EA"), date.range=c("2015", NA))
</code></pre>

<hr>
<h2 id='index.aggregation'>Index number functions and aggregation</h2><span id='topic+laspey'></span><span id='topic+paasche'></span><span id='topic+fisher'></span><span id='topic+walsh'></span><span id='topic+toernq'></span><span id='topic+aggregate'></span>

<h3>Description</h3>

<p>Currently, the following index number methods are implemented:
</p>

<ul>
<li> <p><code>laspey()</code> for the Laspeyres index;
</p>
</li>
<li> <p><code>paasche()</code> for the Paasche index;
</p>
</li>
<li> <p><code>toernq()</code> for the Toernqvist index;
</p>
</li>
<li> <p><code>fisher()</code> for the Fisher index;
</p>
</li>
<li> <p><code>walsh()</code> for the Walsh index.
</p>
</li></ul>

<p>Function <code>aggregate()</code> uses these functions (or other functions provided by the user) for step-wise aggregation of lower-level subindices into the overall index following the COICOP hierarchy.</p>


<h3>Usage</h3>

<pre><code class='language-R'># bilateral price indices:
laspey(x, w0, wt=NULL)
paasche(x, w0=NULL, wt)
fisher(x, w0, wt)
toernq(x, w0, wt)
walsh(x, w0, wt)

# step-wise index aggregation:
aggregate(x, w0, wt, grp, index=laspey, add=list(), keep.lowest=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="index.aggregation_+3A_x">x</code></td>
<td>
<p>numeric vector of price relatives obtained by <code>unchain()</code>ing some HICP index series.</p>
</td></tr>
<tr><td><code id="index.aggregation_+3A_w0">w0</code>, <code id="index.aggregation_+3A_wt">wt</code></td>
<td>
<p>numeric vector of weights in the base period <code>w0</code> (e.g., for the Laspeyres index) or current period <code>wt</code> (e.g., for the Paasche index), respectively.</p>
</td></tr>
<tr><td><code id="index.aggregation_+3A_grp">grp</code></td>
<td>
<p>grouping variable to be used. These should be valid COICOP codes or other hierarchical codes.</p>
</td></tr>
<tr><td><code id="index.aggregation_+3A_index">index</code></td>
<td>
<p>a function or named list of functions specifying the index formula used for aggregation. Each function must have arguments <code>x</code>, <code>w0</code> and <code>wt</code>, even if the attributes are not used (this can be indicated by setting this argument to <code>NULL</code>). Each function must return a scalar. Default is <code>index=laspey</code>.</p>
</td></tr>
<tr><td><code id="index.aggregation_+3A_add">add</code></td>
<td>
<p>a named list of user-defined aggregates to be calculated. Each list element is a vector of ids that can be found in <code>grp</code>. Only if all ids are present in <code>grp</code>, aggregation is done; otherwise <code>NA</code>.</p>
</td></tr>
<tr><td><code id="index.aggregation_+3A_keep.lowest">keep.lowest</code></td>
<td>
<p>logical indicating if the lowest-level indices that form the base of all aggregation steps should be kept in the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Functions <code>laspey()</code>, <code>paasche()</code>, <code>fisher()</code>, <code>toernq()</code>, and <code>walsh()</code> return a single (aggregated) value.
</p>
<p>Function <code>aggregate()</code> returns a <code>data.table</code> of aggregated values at each <code>grp</code>-level with the following variables:
</p>

<table>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> grp </td><td style="text-align: left;"> <em>character</em> </td><td style="text-align: left;"> the grouping variable </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> is_aggregated  </td><td style="text-align: left;"> <em>logical</em> </td><td style="text-align: left;"> is the value an aggregate (<code>TRUE</code>) or not; column available if <code>keep.lowest=TRUE</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> w0, wt  </td><td style="text-align: left;"> <em>numeric</em> </td><td style="text-align: left;"> sum of weights <code>w0</code> and <code>wt</code> </td>
</tr>
<tr>
 <td style="text-align: right;">
</td><td style="text-align: left;"> index  </td><td style="text-align: left;"> <em>numeric</em> </td><td style="text-align: left;"> aggregates for each <code>index</code> function
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>References</h3>

<p>Eurostat (2024), <em>Harmonised Index of Consumer Prices (HICP): Methodological Manual</em>, Luxembourg: Publications Office of the European Union, online available at: <a href="https://ec.europa.eu/eurostat/web/products-manuals-and-guidelines/w/ks-gq-24-003">https://ec.europa.eu/eurostat/web/products-manuals-and-guidelines/w/ks-gq-24-003</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+unchain">unchain</a></code>, <code><a href="#topic+chain">chain</a></code>, <code><a href="#topic+rebase">rebase</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(data.table)

### EXAMPLE 1

# data for two times periods:
dt &lt;- data.table(
  "time"=rep(1:2, each=5),
  "coicop"=rep(c("01111","01112","0112","0113","021"), times=2),
  "price"=c(105,103,102,99,120, 105,104,110,98,125),
  "weight"=rep(c(0.05,0.15,0.3,0.2,0.3), times=2),
  "weight_lag"=rep(c(0.03,0.12,0.33,0.2,0.32), times=2))

# aggregate directly to overall index:
dt[, laspey(x=price, w0=weight), by="time"]

# gives identical results at top level as with stepwise
# aggregation through all coicop levels:
dt[, aggregate(x=price, w0=weight, grp=coicop, index=laspey), by="time"]

# this is no longer the case for the superlative indices as shown
# here for the walsh index:
dt[, walsh(x=price, w0=weight, wt=weight_lag), by="time"]
dt[, aggregate(x=price, w0=weight, wt=weight_lag, grp=coicop, index=walsh), by="time"]

# see also for example Auer and Wengenroth (2017, p. 2)

# apply user-defined function:
dt[, aggregate(x=price, w0=weight, grp=coicop,
               index=list("carli"=function(x,w0=NULL,wt=NULL) mean(x))),
     by="time"]

# add additional, user-defined aggregates (e.g. special aggregates):
dt[, aggregate(x=price, w0=weight, grp=coicop,
               add=list("FOOD"=c("01111","021"), "MISS"=c("021","09"))),
     by="time"]

### EXAMPLE 2: Index aggregation using published HICP data

# set cores for testing on CRAN:
library(restatapi)
options(restatapi_cores=1)

# import monthly price indices:
prc &lt;- hicp.dataimport(id="prc_hicp_midx", filter=list(unit="I15", geo="EA"))
prc[, "time":=as.Date(paste0(time, "-01"))]
prc[, "year":=as.integer(format(time, "%Y"))]
setnames(x=prc, old="values", new="index")

# unchaining indices:
prc[, "dec_ratio" := unchain(x=index, t=time), by="coicop"]

# import item weights:
inw &lt;- hicp.dataimport(id="prc_hicp_inw", filter=list(geo="EA"))
inw[, "time":=as.integer(time)]
setnames(x=inw, old=c("time","values"), new=c("year","weight"))

# derive coicop tree:
inw[grepl("^CP",coicop),
    "tree":=tree(id=gsub("^CP","",coicop), w=weight, w.tol=0.1),
    by=c("geo","year")]

# except for rounding, we receive total weight of 1000 in each period:
inw[tree==TRUE, sum(weight), by="year"]

# merge price indices and item weights:
hicp.data &lt;- merge(x=prc, y=inw, by=c("geo","coicop","year"), all.x=TRUE)
hicp.data &lt;- hicp.data[year &lt;= year(Sys.Date())-1 &amp; grepl("^CP\\d+", coicop),]
hicp.data[, "coicop" := gsub(pattern="^CP", replacement="", x=coicop)]

# compute all-items HICP:
hicp.own &lt;- hicp.data[tree==TRUE,
                      list("laspey"=laspey(x=dec_ratio, w0=weight)),
                      by="time"]
setorderv(x=hicp.own, cols="time")
hicp.own[, "chain_laspey" := chain(x=laspey, t=time, by=12)]
hicp.own[, "chain_laspey_15" := rebase(x=chain_laspey, t=time, t.ref="2015")]

# add published all-items HICP for comparison:
hicp.own &lt;- merge(
            x=hicp.own,
            y=hicp.data[coicop=="00", list(time, index)],
            by="time",
            all.x=TRUE)
plot(index-chain_laspey_15~time, data=hicp.own, type="l")
head(hicp.own[abs(index-chain_laspey_15)&gt;0.1,])

# compute all-items HICP stepwise through all higher-levels:
hicp.own.all &lt;- hicp.data[, aggregate(x=dec_ratio, w0=weight, grp=coicop, index=laspey),
                            by="time"]
setorderv(x=hicp.own.all, cols="time")
hicp.own.all[, "chain_laspey" := chain(x=laspey, t=time, by=12), by="grp"]
hicp.own.all[, "chain_laspey_15" := rebase(x=chain_laspey, t=time, t.ref="2015"), by="grp"]

# add published indices for compariosn:
hicp.own.all &lt;- merge(
                x=hicp.own.all,
                y=hicp.data[, list(time,"grp"=coicop,index,weight)],
                by=c("time","grp"),
                all.x=TRUE)
hicp.own.all[, "diff" := index-chain_laspey_15]
head(hicp.own.all[abs(diff)&gt;0.1,])
head(hicp.own.all[abs(w0-weight)&gt;0.1,])

# compare all-items HICP from direct and step-wise aggregation:
agg.comp &lt;- merge(
        x=hicp.own.all[grp=="00", list(time, "index_stpwse"=chain_laspey_15)],
        y=hicp.own[, list(time, "index_direct"=chain_laspey_15)],
        by="time")

# no differences -&gt; consistent in aggregation:
head(agg.comp[abs(index_stpwse-index_direct)&gt;1e-4,])
</code></pre>

<hr>
<h2 id='linking'>Linking-in new index series</h2><span id='topic+link'></span><span id='topic+lsf'></span>

<h3>Description</h3>

<p>Function <code>link()</code> links a new index series to an existing one by an overlap period supplied. In the resulting linked index series, the new index series starts after the existing one. Function <code>lsf()</code> computes the level-shift factors for linking via the overlap periods in <code>t.overlap</code>. The level-shift factors can be applied to an index series that has already been linked by the standard HICP one-month overlap method using December of year <code>t-1</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>link(x, x.new, t, t.overlap=NULL)

lsf(x, x.new, t, t.overlap=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linking_+3A_x">x</code>, <code id="linking_+3A_x.new">x.new</code></td>
<td>
<p>numeric vector of index values. <code>NA</code>-values in the vectors indicate when the index series discontinues (for <code>x</code>) or starts (for <code>x.new</code>).</p>
</td></tr>
<tr><td><code id="linking_+3A_t">t</code></td>
<td>
<p>date vector</p>
</td></tr>
<tr><td><code id="linking_+3A_t.overlap">t.overlap</code></td>
<td>
<p>character specifying the overlap period to be used. Could be a whole year (<code>YYYY</code>) or a single year-month (<code>YYYY-MM</code>). Multiple periods can be provided. If <code>NULL</code>, all available overlap periods are considered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>link()</code> returns a numeric vector or a matrix of the same length as <code>t</code>, while <code>lsf()</code> provides a named numeric vector of the same length as <code>t.overlap</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>See Also</h3>

<p><code><a href="#topic+chain">chain</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># input data:
set.seed(1)
t &lt;- seq.Date(from=as.Date("2015-01-01"), to=as.Date("2024-05-01"), by="1 month")
x.new &lt;- rnorm(n=length(t), mean=100, sd=5)
x.new &lt;- rebase(x=x.new, t=t, t.ref="2019-12")
x.old &lt;- x.new + rnorm(n=length(x.new), sd=5)
x.old &lt;- rebase(x=x.old, t=t, t.ref="2015")
x.old[t&gt;as.Date("2021-12-01")] &lt;- NA # current index discontinues in 2021
x.new[t&lt;as.Date("2020-01-01")] &lt;- NA # new index starts in 2019-12

# linking in new index in different periods:
plot(x=t, y=link(x=x.old, x.new=x.new, t=t, t.overlap="2021-12"),
     col="red", type="l", xlab=NA, ylab="Index", ylim=c(80,120))
lines(x=t, y=link(x=x.old, x.new=x.new, t=t, t.overlap="2020"), col="blue")
lines(x=t, y=link(x=x.old, x.new=x.new, t=t, t.overlap="2021"), col="green")
lines(x=t, y=x.old, col="black")
abline(v=as.Date("2021-12-01"), lty="dashed")
legend(x="topleft",
       legend=c("One-month overlap using December 2021",
                "Annual overlap using 2021",
                "Annual overlap using 2020"),
       fill=c("red","green","blue"), bty = "n")

# compute level-shift factors:
lsf(x=x.old, x.new=x.new, t=t, t.overlap=c("2020","2021"))

# level-shift factors can be applied to already chain-linked index series
# to obtain linked series using another overlap period:
x.new.chained &lt;- link(x=x.old, x.new=x.new, t=t, t.overlap="2021-12")

# level-shift adjustment:
x.new.adj &lt;- ifelse(test=t&gt;as.Date("2021-12-01"),
                yes=x.new.chained*lsf(x=x.old, x.new=x.new, t=t, t.overlap="2020"),
                no=x.new.chained)

# compare:
all.equal(x.new.adj, link(x=x.old, x.new=x.new, t=t, t.overlap="2020"))
</code></pre>

<hr>
<h2 id='rates'>Change rates and contributions</h2><span id='topic+rates'></span><span id='topic+contrib'></span>

<h3>Description</h3>

<p>Function <code>rates()</code> computes monthly, annual and annual average rates of change for an index series. Function <code>contrib()</code> computes the contributions of a subcomponent to the annual change rate of the overall index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rates(x, t=NULL, type="monthly")

contrib(x, w, t, x.all, w.all, method="ribe")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rates_+3A_x">x</code>, <code id="rates_+3A_x.all">x.all</code></td>
<td>
<p>numeric vector of index values.</p>
</td></tr>
<tr><td><code id="rates_+3A_w">w</code>, <code id="rates_+3A_w.all">w.all</code></td>
<td>
<p>numeric vector of weights of the subcomponent (<code>w</code>) and the overall index (<code>w.all</code>).</p>
</td></tr>
<tr><td><code id="rates_+3A_t">t</code></td>
<td>
<p>date vector.</p>
</td></tr>
<tr><td><code id="rates_+3A_type">type</code></td>
<td>
<p>character specifying the type of change rate. Allowed values are <code>monthly</code> for monthly change rates, <code>annual</code> for annual change rates, and <code>annual-average</code> for annual average change rates.</p>
</td></tr>
<tr><td><code id="rates_+3A_method">method</code></td>
<td>
<p>character specifying the method used for the calculations. Allowed values are <code>ribe</code> and <code>kirchner</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>rates()</code>, a numeric vector of the same length as <code>x</code> if <code>type='monthly'</code> or <code>type='annual'</code>. If <code>type='annual-average'</code>, same length as years available.
</p>
<p>For <code>contrib()</code>, a numeric vector of the same length as <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>References</h3>

<p>Eurostat (2024), <em>Harmonised Index of Consumer Prices (HICP): Methodological Manual</em>, Luxembourg: Publications Office of the European Union, online available at: <a href="https://ec.europa.eu/eurostat/web/products-manuals-and-guidelines/w/ks-gq-24-003">https://ec.europa.eu/eurostat/web/products-manuals-and-guidelines/w/ks-gq-24-003</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### EXAMPLE 1

P &lt;- rnorm(n=25,mean=100,sd=5)
t &lt;- seq.Date(from=as.Date("2021-01-01"), by="1 month", length.out=length(P))

rates(x=P, type="monthly")
rates(x=P, type="annual")
rates(x=P, type="annual-average")
rates(x=P, t=t, type="annual-average")

### EXAMPLE 2: Contributions using published HICP data

# set cores for testing on CRAN:
library(restatapi)
options(restatapi_cores=1)
library(data.table)

# import monthly price indices:
prc &lt;- hicp.dataimport(id="prc_hicp_midx", filter=list(unit="I15", geo="EA"))
prc[, "time":=as.Date(paste0(time, "-01"))]
prc[, "year":=as.integer(format(time, "%Y"))]
setnames(x=prc, old="values", new="index")

# import item weights:
inw &lt;- hicp.dataimport(id="prc_hicp_inw", filter=list(geo="EA"))
inw[, "time":=as.integer(time)]
setnames(x=inw, old=c("time","values"), new=c("year","weight"))

# merge price indices and item weights:
hicp.data &lt;- merge(x=prc, y=inw, by=c("geo","coicop","year"), all.x=TRUE)

# add all-items hicp:
hicp.data &lt;- merge(x=hicp.data,
                   y=hicp.data[coicop=="CP00", list(geo,time,index,weight)],
                   by=c("geo","time"), all.x=TRUE, suffixes=c("","_all"))

# ribe decomposition:
hicp.data[, "ribe" := contrib(x=index, w=weight, t=time, 
                              x.all=index_all, w.all=weight_all), by="coicop"]

# annual change rates over time:
plot(rates(x=index, t=time, type="annual")~time,
     data=hicp.data[coicop=="CP00",],
     type="l", ylim=c(-2,12))

# add contribution of energy:
lines(ribe~time, data=hicp.data[coicop=="NRG"], col="red")

# compare to published contributions:
hicp.ctrb &lt;- hicp.dataimport(id="prc_hicp_ctrb")
hicp.ctrb[, "time":=as.Date(paste0(time, "-01"))]
dt.comp &lt;- merge(x=hicp.ctrb,
                 y=hicp.data[, list(coicop, time, ribe)],
                 by=c("coicop","time"),
                 all=TRUE)
head(dt.comp[!is.na(values) &amp; abs(values-ribe)&gt;0.1, ]) # should be empty
</code></pre>

<hr>
<h2 id='spec.aggs'>Special aggregates</h2><span id='topic+spec.aggs'></span>

<h3>Description</h3>

<p>This dataset contains the special aggregates and their composition of COICOP codes valid since 2017.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># special aggregates:
spec.aggs
</code></pre>


<h3>Format</h3>

<p>A data.table with the following variables.
</p>

<ul>
<li> <p><code>code</code>: the special aggregate code
</p>
</li>
<li> <p><code>name_[en|fr|de]</code>: the special aggregate description in English, French, and German
</p>
</li>
<li> <p><code>composition</code>: a list of the COICOP product codes forming the special aggregate
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Sebastian Weinand</p>


<h3>Examples</h3>

<pre><code class='language-R'># subset to services:
spec.aggs[code=="SERV", composition[[1]]]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
