<!DOCTYPE html><html><head><title>Help for package utility</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {utility}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#evaluate'><p>Evaluate Node and Associated Hierarchy</p></a></li>
<li><a href='#evaluate.utility.aggregation'><p>Evaluate Node and Associated Hierarchy</p></a></li>
<li><a href='#evaluate.utility.conversion.intpol'><p>Evaluate Node and Associated Hierarchy</p></a></li>
<li><a href='#evaluate.utility.conversion.parfun'><p>Evaluate Node and Associated Hierarchy</p></a></li>
<li><a href='#evaluate.utility.endnode.classcounts'><p>Evaluate Node and Associated Hierarchy</p></a></li>
<li><a href='#evaluate.utility.endnode.cond'><p>Evaluate Node and Associated Hierarchy</p></a></li>
<li><a href='#evaluate.utility.endnode.discrete'><p>Evaluate Node</p></a></li>
<li><a href='#evaluate.utility.endnode.firstavail'><p>Evaluate Node and Associated Hierarchy</p></a></li>
<li><a href='#evaluate.utility.endnode.intpol1d'><p>Evaluate Node</p></a></li>
<li><a href='#evaluate.utility.endnode.intpol2d'><p>Evaluate Node</p></a></li>
<li><a href='#evaluate.utility.endnode.parfun1d'><p>Evaluate Node</p></a></li>
<li><a href='#plot.utility.aggregation'><p>Plot Node Definition or Underlying Objectives Hierarchy</p></a></li>
<li><a href='#plot.utility.conversion.intpol'><p>Plot Node Definition or Underlying Objectives Hierarchy</p></a></li>
<li><a href='#plot.utility.conversion.parfun'><p>Plot Node Definition or Underlying Objectives Hierarchy</p></a></li>
<li><a href='#plot.utility.endnode.classcounts'><p>Plot Node Definition</p></a></li>
<li><a href='#plot.utility.endnode.cond'><p>Plot Node Definition</p></a></li>
<li><a href='#plot.utility.endnode.discrete'><p>Plot Node Definition</p></a></li>
<li><a href='#plot.utility.endnode.firstavail'><p>Plot Node Definition</p></a></li>
<li><a href='#plot.utility.endnode.intpol1d'><p>Plot Node Definition</p></a></li>
<li><a href='#plot.utility.endnode.intpol2d'><p>Plot Node Definition</p></a></li>
<li><a href='#plot.utility.endnode.parfun1d'><p>Plot Node Definition</p></a></li>
<li><a href='#print.utility.aggregation'><p>Print Definitions of Node and Associated Hierarchy</p></a></li>
<li><a href='#print.utility.conversion.intpol'><p>Print Definitions of Node and Associated Hierarchy</p></a></li>
<li><a href='#print.utility.conversion.parfun'><p>Print Definitions of Node and Associated Hierarchy</p></a></li>
<li><a href='#print.utility.endnode.classcounts'><p>Print Node Definition</p></a></li>
<li><a href='#print.utility.endnode.cond'><p>Print Node Definition</p></a></li>
<li><a href='#print.utility.endnode.discrete'><p>Print Node Definition</p></a></li>
<li><a href='#print.utility.endnode.firstavail'><p>Print Node Definition</p></a></li>
<li><a href='#print.utility.endnode.intpol1d'><p>Print Node Definition</p></a></li>
<li><a href='#print.utility.endnode.intpol2d'><p>Print Node Definition</p></a></li>
<li><a href='#print.utility.endnode.parfun1d'><p>Print Node Definition</p></a></li>
<li><a href='#summary.utility.aggregation'><p>Print Summary of Definitions of Node and Associated Hierarchy</p></a></li>
<li><a href='#summary.utility.conversion.intpol'><p>Print Summary of Definitions of Node and Associated Hierarchy</p></a></li>
<li><a href='#summary.utility.conversion.parfun'><p>Print Summary of Definitions of Node and Associated Hierarchy</p></a></li>
<li><a href='#summary.utility.endnode.classcounts'><p>Print Summary of Node Definition</p></a></li>
<li><a href='#summary.utility.endnode.cond'><p>Print Summary of Node Definition</p></a></li>
<li><a href='#summary.utility.endnode.discrete'><p>Print Summary of Node Definition</p></a></li>
<li><a href='#summary.utility.endnode.firstavail'><p>Print Summary of Node Definition</p></a></li>
<li><a href='#summary.utility.endnode.intpol1d'><p>Print Summary of Node Definition</p></a></li>
<li><a href='#summary.utility.endnode.intpol2d'><p>Print Summary of Node Definition</p></a></li>
<li><a href='#summary.utility.endnode.parfun1d'><p>Print Summary of Node Definition</p></a></li>
<li><a href='#updatepar'><p>Update Parameters in Node Definitions</p></a></li>
<li><a href='#updatepar.utility.aggregation'><p>Update Parameters in Node Definitions</p></a></li>
<li><a href='#updatepar.utility.conversion.intpol'><p>Update Parameters in Node Definitions</p></a></li>
<li><a href='#updatepar.utility.conversion.parfun'><p>Update Parameters in Node Definitions</p></a></li>
<li><a href='#updatepar.utility.endnode.classcounts'><p>Update Parameters in Node Definitions</p></a></li>
<li><a href='#updatepar.utility.endnode.cond'><p>Update Parameters in Node Definitions</p></a></li>
<li><a href='#updatepar.utility.endnode.discrete'><p>Update Parameters in Node Definition</p></a></li>
<li><a href='#updatepar.utility.endnode.firstavail'><p>Update Parameters in Node Definitions</p></a></li>
<li><a href='#updatepar.utility.endnode.intpol1d'><p>Update Parameters in Node Definition</p></a></li>
<li><a href='#updatepar.utility.endnode.intpol2d'><p>Update Parameters in Node Definition</p></a></li>
<li><a href='#updatepar.utility.endnode.parfun1d'><p>Update Parameters in Node Definition</p></a></li>
<li><a href='#utility-package'><p>Construct, Evaluate and Plot Value and Utility Functions</p></a></li>
<li><a href='#utility.aggregate.add'><p>Additive aggregation of values or utilities</p></a></li>
<li><a href='#utility.aggregate.addmin'><p>Mixture of additive and minimum aggregation</p></a></li>
<li><a href='#utility.aggregate.addpower'><p>Additive power aggregation of values or utilities</p></a></li>
<li><a href='#utility.aggregate.addsplitpower'><p>Splitted weighted power aggregation of values or utilities</p></a></li>
<li><a href='#utility.aggregate.bonusmalus'><p>Bonus-malus aggregation of values or utilities</p></a></li>
<li><a href='#utility.aggregate.cobbdouglas'><p>Cobb-Douglas aggregation of values or utilities</p></a></li>
<li><a href='#utility.aggregate.geo'><p>Geometric aggregation of values or utilities</p></a></li>
<li><a href='#utility.aggregate.geooff'><p>Geometric aggregation of values or utilities with offset</p></a></li>
<li><a href='#utility.aggregate.harmo'><p>Harmonic aggregation of values or utilities</p></a></li>
<li><a href='#utility.aggregate.harmooff'><p>Harmonic aggregation of values or utilities with offset</p></a></li>
<li><a href='#utility.aggregate.max'><p>Maximum aggregation of values or utilities</p></a></li>
<li><a href='#utility.aggregate.min'><p>Minimum aggregation of values or utilities</p></a></li>
<li><a href='#utility.aggregate.mix'><p>Mixed aggregation of values and utilities</p></a></li>
<li><a href='#utility.aggregate.mult'><p>Multiplicative aggregation of values or utilities</p></a></li>
<li><a href='#utility.aggregate.revaddpower'><p>Reverse additive power aggregation of values or utilities</p></a></li>
<li><a href='#utility.aggregate.revaddsplitpower'><p>Reverse splitted additive power aggregation of values or utilities</p></a></li>
<li><a href='#utility.aggregate.revgeo'><p>Reverse geometric aggregation of values or utilities</p></a></li>
<li><a href='#utility.aggregate.revgeooff'><p>Reverse geometric aggregation of values or utilities with offset</p></a></li>
<li><a href='#utility.aggregate.revharmo'><p>Reverse harmonic aggregation of values or utilities</p></a></li>
<li><a href='#utility.aggregate.revharmooff'><p>Reverse harmonic aggregation of values or utilities with offset</p></a></li>
<li><a href='#utility.aggregation.create'><p>Construct an aggregation node</p></a></li>
<li><a href='#utility.calc.colors'><p>Color Scheme for Value Functions</p></a></li>
<li><a href='#utility.conversion.intpol.create'><p>Construct an interpolation conversion node</p></a></li>
<li><a href='#utility.conversion.parfun.create'><p>Construct a parametric function conversion node</p></a></li>
<li><a href='#utility.endnode.classcounts.create'><p>Construct an end node that evaluates counts in different quality classes.</p></a></li>
<li><a href='#utility.endnode.cond.create'><p>Construct a conditional end node</p></a></li>
<li><a href='#utility.endnode.discrete.create'><p>Construct a discrete value or utility end node</p></a></li>
<li><a href='#utility.endnode.firstavail.create'><p>Construct an end node to get the results of the first available sub-node</p></a></li>
<li><a href='#utility.endnode.intpol1d.create'><p>Construct a single-attribute interpolation end node</p></a></li>
<li><a href='#utility.endnode.intpol2d.create'><p>Construct a two-attribute interpolation end node</p></a></li>
<li><a href='#utility.endnode.parfun1d.create'><p>Construct a single-attribute parametric function end node</p></a></li>
<li><a href='#utility.fun.exp'><p>Exponential function for value or utility functions</p></a></li>
<li><a href='#utility.get.attrib.names'><p>Get Names of Attributes Used by a Value Functions</p></a></li>
<li><a href='#utility.get.colors'><p>Get Color Corresponding to Specified Value Levels</p></a></li>
<li><a href='#utility.structure'><p>Extract Structure of Objectives Hierarchy</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Construct, Evaluate and Plot Value and Utility Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-27</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt; 
  with contributions by Nele Schuwirth &lt;nele.schuwirth@eawag.ch&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Construct and plot objective hierarchies and associated value and utility functions. 
  Evaluate the values and utilities and visualize the results as colored objective hierarchies or tables. 
  Visualize uncertainty by plotting median and quantile intervals within the nodes of objective hierarchies.
  Get numerical results of the evaluations in standard R data types for further processing.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-27 21:13:40 UTC; peter</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-27 22:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='evaluate'>Evaluate Node and Associated Hierarchy</h2><span id='topic+evaluate'></span>

<h3>Description</h3>

<p>Generic function to calculate values or utilities at all nodes of a hierarchy 
for given levels of the attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_+3A_x">x</code></td>
<td>

<p>node to be evaluated.
</p>
</td></tr>
<tr><td><code id="evaluate_+3A_...">...</code></td>
<td>

<p>attribute levels have to be provided as an additional argument <code>attrib</code>;
parameter values can optionally be provided as an additional argument <code>par</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with results of values or utilities 
at all nodes of the hierarchy 
for all provided sets of attribute levels.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, <br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code> <br /><br />
to create the nodes to be evaluated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='evaluate.utility.aggregation'>Evaluate Node and Associated Hierarchy</h2><span id='topic+evaluate.utility.aggregation'></span>

<h3>Description</h3>

<p>Calculate values or utilities at all nodes of a hierarchy 
for given levels of the attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.aggregation'
evaluate(x, attrib, par = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate.utility.aggregation_+3A_x">x</code></td>
<td>

<p>node to be evaluated.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.aggregation_+3A_attrib">attrib</code></td>
<td>

<p>numeric vector with labelled components providing the levels 
of a single set of attributes or data frame for which each row
provides such a set of attributes.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.aggregation_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before evaluation.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.aggregation_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with results of values or utilities 
at all nodes of the hierarchy 
for all provided sets of attribute levels.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> to create the node, <br />
<code><a href="#topic+print.utility.aggregation">print.utility.aggregation</a></code> or 
<code><a href="#topic+summary.utility.aggregation">summary.utility.aggregation</a></code> to print its definition, and <br />
<code><a href="#topic+plot.utility.aggregation">plot.utility.aggregation</a></code> to plot the node <br /><br />
and <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code> <br /><br />
to create other nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='evaluate.utility.conversion.intpol'>Evaluate Node and Associated Hierarchy</h2><span id='topic+evaluate.utility.conversion.intpol'></span>

<h3>Description</h3>

<p>Calculate values or utilities at all nodes of a hierarchy 
for given levels of the attributes.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.conversion.intpol'
evaluate(x, attrib, par = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate.utility.conversion.intpol_+3A_x">x</code></td>
<td>

<p>node to be evaluated.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.conversion.intpol_+3A_attrib">attrib</code></td>
<td>

<p>numeric vector with labelled components providing the levels 
of a single set of attributes or data frame for which each row
provides such a set of attributes.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.conversion.intpol_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before evaluation.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.conversion.intpol_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with results of values or utilities 
at all nodes of the hierarchy 
for all provided sets of attribute levels.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code> to create the node, <br />
<code><a href="#topic+print.utility.conversion.intpol">print.utility.conversion.intpol</a></code> or 
<code><a href="#topic+summary.utility.conversion.intpol">summary.utility.conversion.intpol</a></code> to print its definition, and <br />
<code><a href="#topic+plot.utility.conversion.intpol">plot.utility.conversion.intpol</a></code> to plot the node <br /><br />
and <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>. <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>. <br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code> <br /><br />
to create other nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='evaluate.utility.conversion.parfun'>Evaluate Node and Associated Hierarchy</h2><span id='topic+evaluate.utility.conversion.parfun'></span>

<h3>Description</h3>

<p>Calculate values or utilities at all nodes of a hierarchy 
for given levels of the attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.conversion.parfun'
evaluate(x, attrib, par = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate.utility.conversion.parfun_+3A_x">x</code></td>
<td>

<p>node to be evaluated.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.conversion.parfun_+3A_attrib">attrib</code></td>
<td>

<p>numeric vector with labelled components providing the levels 
of a single set of attributes or data frame for which each row
provides such a set of attributes.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.conversion.parfun_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before evaluation.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.conversion.parfun_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with results of values or utilities 
at all nodes of the hierarchy 
for all provided sets of attribute levels.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> to create the node, <br />
<code><a href="#topic+print.utility.aggregation">print.utility.aggregation</a></code> or 
<code><a href="#topic+summary.utility.aggregation">summary.utility.aggregation</a></code> to print its definition, and <br />
<code><a href="#topic+plot.utility.aggregation">plot.utility.aggregation</a></code> to plot the node <br /><br />
and <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>, <br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code> <br /><br />
to create other nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='evaluate.utility.endnode.classcounts'>Evaluate Node and Associated Hierarchy</h2><span id='topic+evaluate.utility.endnode.classcounts'></span>

<h3>Description</h3>

<p>Calculate values or utilities at the node 
for given levels of the attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.classcounts'
evaluate(x, attrib, par = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate.utility.endnode.classcounts_+3A_x">x</code></td>
<td>

<p>node to be evaluated.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.classcounts_+3A_attrib">attrib</code></td>
<td>

<p>numeric vector with labelled components providing the levels 
of a single set of attributes or data frame for which each row
provides such a set of attributes.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.classcounts_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before evaluation.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.classcounts_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of results of values or utilities 
at the node for all provided sets of attribute levels.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+utility.endnode.classcounts.create">utility.endnode.classcounts.create</a></code> to create the node, <br />
<code><a href="#topic+print.utility.endnode.classcounts">print.utility.endnode.classcounts</a></code> or 
<code><a href="#topic+summary.utility.endnode.classcounts">summary.utility.endnode.classcounts</a></code> to print its definition, and <br />
<code><a href="#topic+plot.utility.endnode.classcounts">plot.utility.endnode.classcounts</a></code> to plot the node <br /><br />
and <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>, <br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code> <br /><br />
to create other nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='evaluate.utility.endnode.cond'>Evaluate Node and Associated Hierarchy</h2><span id='topic+evaluate.utility.endnode.cond'></span>

<h3>Description</h3>

<p>Calculate values or utilities at the node 
for given levels of the attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.cond'
evaluate(x, attrib, par = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate.utility.endnode.cond_+3A_x">x</code></td>
<td>

<p>node to be evaluated.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.cond_+3A_attrib">attrib</code></td>
<td>

<p>numeric vector with labelled components providing the levels 
of a single set of attributes or data frame for which each row
provides such a set of attributes.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.cond_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before evaluation.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.cond_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of results of values or utilities 
at the node for all provided sets of attribute levels.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code> to create the node, <br />
<code><a href="#topic+print.utility.endnode.cond">print.utility.endnode.cond</a></code> or 
<code><a href="#topic+summary.utility.endnode.cond">summary.utility.endnode.cond</a></code> to print its definition, and <br />
<code><a href="#topic+plot.utility.endnode.cond">plot.utility.endnode.cond</a></code> to plot the node <br /><br />
and <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>, <br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code> <br /><br />
to create other nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='evaluate.utility.endnode.discrete'>Evaluate Node</h2><span id='topic+evaluate.utility.endnode.discrete'></span>

<h3>Description</h3>

<p>Calculate values or utilities at the node 
for given levels of the attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.discrete'
evaluate(x, attrib, par = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate.utility.endnode.discrete_+3A_x">x</code></td>
<td>

<p>node to be evaluated.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.discrete_+3A_attrib">attrib</code></td>
<td>

<p>numeric vector with labelled components providing the levels 
of a single set of attributes or data frame for which each row
provides such a set of attributes.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.discrete_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before evaluation.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.discrete_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of results of values or utilities 
at the node for all provided sets of attribute levels.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> to create the node, <br />
<code><a href="#topic+print.utility.aggregation">print.utility.aggregation</a></code> or 
<code><a href="#topic+summary.utility.aggregation">summary.utility.aggregation</a></code> to print its definition, and <br />
<code><a href="#topic+plot.utility.aggregation">plot.utility.aggregation</a></code> to plot the node <br /><br />
and <br /><br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>, <br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code> <br /><br />
to create other nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='evaluate.utility.endnode.firstavail'>Evaluate Node and Associated Hierarchy</h2><span id='topic+evaluate.utility.endnode.firstavail'></span>

<h3>Description</h3>

<p>Calculate values or utilities at the node 
for given levels of the attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.firstavail'
evaluate(x, attrib, par = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate.utility.endnode.firstavail_+3A_x">x</code></td>
<td>

<p>node to be evaluated.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.firstavail_+3A_attrib">attrib</code></td>
<td>

<p>numeric vector with labelled components providing the levels 
of a single set of attributes or data frame for which each row
provides such a set of attributes.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.firstavail_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before evaluation.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.firstavail_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of results of values or utilities 
at the node for all provided sets of attribute levels.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code> to create the node, <br />
<code><a href="#topic+print.utility.endnode.firstavail">print.utility.endnode.firstavail</a></code> or 
<code><a href="#topic+summary.utility.endnode.firstavail">summary.utility.endnode.firstavail</a></code> to print its definition, and <br />
<code><a href="#topic+plot.utility.endnode.firstavail">plot.utility.endnode.firstavail</a></code> to plot the node <br /><br />
and <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, <br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code> <br /><br />
to create other nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='evaluate.utility.endnode.intpol1d'>Evaluate Node</h2><span id='topic+evaluate.utility.endnode.intpol1d'></span>

<h3>Description</h3>

<p>Calculate values or utilities at the node 
for given levels of the attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.intpol1d'
evaluate(x, attrib, par = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate.utility.endnode.intpol1d_+3A_x">x</code></td>
<td>

<p>node to be evaluated.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.intpol1d_+3A_attrib">attrib</code></td>
<td>

<p>numeric vector with labelled components providing the levels 
of a single set of attributes or data frame for which each row
provides such a set of attributes.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.intpol1d_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before evaluation.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.intpol1d_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of results of values or utilities 
at the node for all provided sets of attribute levels.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> to create the node, <br />
<code><a href="#topic+print.utility.aggregation">print.utility.aggregation</a></code> or <br />
<code><a href="#topic+summary.utility.aggregation">summary.utility.aggregation</a></code> to print its definition, and <br />
<code><a href="#topic+plot.utility.aggregation">plot.utility.aggregation</a></code> to plot the node <br /><br />
and <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>, <br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code> <br /><br />
to create other nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='evaluate.utility.endnode.intpol2d'>Evaluate Node</h2><span id='topic+evaluate.utility.endnode.intpol2d'></span>

<h3>Description</h3>

<p>Calculate values or utilities at the node 
for given levels of the attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.intpol2d'
evaluate(x, attrib, par = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate.utility.endnode.intpol2d_+3A_x">x</code></td>
<td>

<p>node to be evaluated.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.intpol2d_+3A_attrib">attrib</code></td>
<td>

<p>numeric vector with labelled components providing the levels 
of a single set of attributes or data frame for which each row
provides such a set of attributes.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.intpol2d_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before evaluation.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.intpol2d_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of results of values or utilities 
at the node for all provided sets of attribute levels.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> to create the node, <br />
<code><a href="#topic+print.utility.aggregation">print.utility.aggregation</a></code> or 
<code><a href="#topic+summary.utility.aggregation">summary.utility.aggregation</a></code> to print its definition, and <br />
<code><a href="#topic+plot.utility.aggregation">plot.utility.aggregation</a></code> to plot the node <br /><br />
and <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>, <br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code> <br /><br />
to create other nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='evaluate.utility.endnode.parfun1d'>Evaluate Node</h2><span id='topic+evaluate.utility.endnode.parfun1d'></span>

<h3>Description</h3>

<p>Calculate values or utilities at the node 
for given levels of the attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.parfun1d'
evaluate(x, attrib, par = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate.utility.endnode.parfun1d_+3A_x">x</code></td>
<td>

<p>node to be evaluated.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.parfun1d_+3A_attrib">attrib</code></td>
<td>

<p>numeric vector with labelled components providing the levels 
of a single set of attributes or data frame for which each row
provides such a set of attributes.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.parfun1d_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before evaluation.
</p>
</td></tr>
<tr><td><code id="evaluate.utility.endnode.parfun1d_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of results of values or utilities 
at the node for all provided sets of attribute levels.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> to create the node, <br />
<code><a href="#topic+print.utility.aggregation">print.utility.aggregation</a></code> or 
<code><a href="#topic+summary.utility.aggregation">summary.utility.aggregation</a></code> to print its definition, and <br />
<code><a href="#topic+plot.utility.aggregation">plot.utility.aggregation</a></code> to plot the node <br /><br />
and <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>, <br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code> <br /><br />
to create other nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='plot.utility.aggregation'>Plot Node Definition or Underlying Objectives Hierarchy</h2><span id='topic+plot.utility.aggregation'></span>

<h3>Description</h3>

<p>Plot node definition or underlying objective hierarchy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.aggregation'
plot(x, 
     u           = NA, 
     uref        = NA, 
     par         = NA, 
     type        = c("hierarchy", "table", "node", "nodes"), 
     nodes       = NA, 
     col         = utility.calc.colors(), 
     gridlines   = c(0.2, 0.4, 0.6, 0.8), 
     main        = "", 
     cex.main    = 1, 
     cex.nodes   = 1, 
     cex.attrib  = 1, 
     f.reaches   = 0.2,
     f.nodes     = 0.2,
     with.attrib = TRUE,
     levels      = NA,
     plot.val    = TRUE,
     col.val     = "black",
     lwd.val     = 1,
     print.val   = TRUE,
     two.lines   = FALSE,
     ticks       = c(0,0.2,0.4,0.6,0.8,1),
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.utility.aggregation_+3A_x">x</code></td>
<td>

<p>node to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_u">u</code></td>
<td>

<p>(optional) vector or data frame with elements or columns labelled
according to the nodes of the hierarchy containing values or utilities.
Typically, this will be the complete output or an output row of
the function <br /> <code><a href="#topic+evaluate.utility.aggregation">evaluate.utility.aggregation</a></code>. <br />
This input is only considered if the argument <code>type</code> is specified
to be either <code>"hierarchy"</code> or <code>"table"</code>.
It is then used to color-code the boxes of the hierarchy representing value nodes or the table.
If <code>u</code> is a data frame with more than one row and the argument <code>type</code> 
is equal to <code>"hierarchy"</code>, then
the median and quantile boxes are plotted for value nodes or the expected utility for utility nodes unless the argument <code>main</code>
contains as many elements as the number of rows of <code>u</code>.
In the latter case, separate hierarchies with color-coded boxes for value nodes are produced for all rows of <code>u</code>.
For <code>type</code> equals <code>"table"</code>, this argument can be a list of data frames
to make it possible to plot uncertainty ranges from the samples provided
in the list.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_uref">uref</code></td>
<td>

<p>(optional) vector or data frame with elements or columns labelled
according to the nodes of the hierarchy containing values or utilities.
Typically, this will be the complete output or an output row of
the function <br /> <code><a href="#topic+evaluate.utility.aggregation">evaluate.utility.aggregation</a></code>. <br /> 
This input is only considered if the argument <code>type</code> is specified
to be <code>"hierarchy"</code>.
It is then used to color-code the upper part of the boxes of the hierarchy
to allow for a comparison with the results provided by the argument <code>u</code> which are shown in the lower part of the boxes.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before plotting the node.
Note that this affects only the node definitions plotted if the argument <code>type</code>
is specified to be <code>"node"</code> or <code>"nodes"</code>.
To color-code hierarchies or tables for different parameter values,
the parameters have to be passed to <br /> <code><a href="#topic+evaluate.utility.aggregation">evaluate.utility.aggregation</a></code> <br /> before passing the results of this function to this plotting routine.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_type">type</code></td>
<td>

<p>(optional) specifies the type of plot to be produced. <br /> Options: 
<code>"hierarchy"</code>, <code>"table"</code>, <code>"node"</code> or <code>"nodes"</code>. <br />
<code>"hierarchy"</code>: produces a plot of the objectives hierarchy including
color-coded results for values or utilities if these values are provided
by the arguments <code>u</code> and/or <code>uref</code>. <br />
<code>"table"</code>: produces a table with color-coded results for values or
utilities if these values are provided by the argument <code>u</code>. <br />
<code>"node"</code>: produces a plot of the definition of the current node. <br />
<code>"nodes"</code>: produces plots of node definitions for all nodes defined
by the attribute <code>nodes</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_nodes">nodes</code></td>
<td>

<p>(optional) character vector specifying the nodes for which the definitions
will be plotted or which will be considered in a table. 
The default value of NA indicates that all nodes will be plotted.
This argument only affects the output if the argument <code>type</code> was indicated to be either <code>"table"</code> or <code>"nodes"</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_col">col</code></td>
<td>

<p>(optional) character vector of colors to be used to color the interval
between zero and unity in equidistant sections (use repetitions of the
same color if you want to have a non-equidistant color-coding).
This attribute is only used for value nodes and if values are provided
by the arguments <code>u</code> and/or <code>uref</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_gridlines">gridlines</code></td>
<td>

<p>(optional) numeric vector of levels at which gridlines are plotted
in node definitions.
This attribute is only used if the argument <code>type</code> is specified to be either <code>"node"</code> or <code>"nodes"</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_main">main</code></td>
<td>

<p>(optional) title(s) of the plot.
If the argument <code>type</code> is equal to <code>"hierarchy"</code> and the a vector of titles with the same length as the number of rows of the argument <code>u</code> is provided, a color-coded hierarchy is plotted for each row of <code>u</code>.
Otherwise, the medians and colored boxes indicating 90% credibility or occurrence ranges are plotted at all nodes.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_cex.main">cex.main</code></td>
<td>

<p>(optional) scaling factor for title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_cex.nodes">cex.nodes</code></td>
<td>

<p>(optional) scaling factor for node labels used in the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_cex.attrib">cex.attrib</code></td>
<td>

<p>(optional) scaling factor for attribute labels used in the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_f.reaches">f.reaches</code></td>
<td>

<p>(optional) fraction of the width of the plot reserved for the row labels of the table if the argument <code>type</code> is equal to <code>"table"</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_f.nodes">f.nodes</code></td>
<td>

<p>(optional) fraction of the height of the plot reserved for the column labels of the table if the argument <code>type</code> is equal to <code>"table"</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_with.attrib">with.attrib</code></td>
<td>

<p>(optional) indicates if attributes should be listed if the argument <code>type</code> is equal to <code>"hierarchy"</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_levels">levels</code></td>
<td>

<p>(optional) how many levels of the hierarchy should be plotted (NA means to plot all levels).
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_plot.val">plot.val</code></td>
<td>

<p>(optional) plot value (for hierarchy without uncertainty) or median (for hierarchy with uncertainty) as a vertical line within the box.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_col.val">col.val</code></td>
<td>

<p>(optional) color of the vertical line indicating the value or median within the box (default black).
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_lwd.val">lwd.val</code></td>
<td>

<p>(optional) line width of the vertical line indicating the value or median within the box (default 1).
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_print.val">print.val</code></td>
<td>

<p>(optional) print value as a number when plotting a table of boxes.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_two.lines">two.lines</code></td>
<td>

<p>(optional) choose whether two lines should be used for the labels in the hierarchy plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_ticks">ticks</code></td>
<td>

<p>(optional) positions of tick marks for hierarchy and table plots (NA or numeric(0) avoids tick marks).
</p>
</td></tr>
<tr><td><code id="plot.utility.aggregation_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the R plotting routine.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that the plotting routines <br />
<code><a href="#topic+plot.utility.conversion.intpol">plot.utility.conversion.intpol</a></code> <br />
<code><a href="#topic+plot.utility.conversion.parfun">plot.utility.conversion.parfun</a></code> <br />
are exactly the same so that all hierarchies can be plotted with exactly
the same commands irrespective of the type of the top-level node.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> for how to construct such a node and <code><a href="#topic+evaluate.utility.aggregation">evaluate.utility.aggregation</a></code> for how to evaluate the node. <br /><br />
See <code><a href="#topic+utility.calc.colors">utility.calc.colors</a></code> for an example of how to construct color schemes and <code><a href="#topic+utility.get.colors">utility.get.colors</a></code> for how to get colors for specifed value levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='plot.utility.conversion.intpol'>Plot Node Definition or Underlying Objectives Hierarchy</h2><span id='topic+plot.utility.conversion.intpol'></span>

<h3>Description</h3>

<p>Plot node definition or underlying objective hierarchy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.conversion.intpol'
plot(x, 
     u           = NA, 
     uref        = NA, 
     par         = NA, 
     type        = c("hierarchy", "table", "node", "nodes"), 
     nodes       = NA, 
     col         = utility.calc.colors(), 
     gridlines   = c(0.2, 0.4, 0.6, 0.8), 
     main        = "", 
     cex.main    = 1, 
     cex.nodes   = 1, 
     cex.attrib  = 1, 
     f.reaches   = 0.2,
     f.nodes     = 0.2,
     with.attrib = TRUE,
     levels      = NA,
     plot.val    = TRUE,
     print.val   = TRUE,
     two.lines   = FALSE,
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.utility.conversion.intpol_+3A_x">x</code></td>
<td>

<p>node to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_u">u</code></td>
<td>

<p>(optional) vector or data frame with elements or columns labelled
according to the nodes of the hierarchy containing values or utilities.
Typically, this will be the complete output or an output row of
the function <br /> <code><a href="#topic+evaluate.utility.aggregation">evaluate.utility.aggregation</a></code>. <br />
This input is only considered if the argument <code>type</code> is specified
to be either <code>"hierarchy"</code> or <code>"table"</code>.
It is then used to color-code the boxes of the hierarchy representing value nodes or the table.
If <code>u</code> is a data frame with more than one row and the argument <code>type</code> 
is equal to <code>"hierarchy"</code>, then
the median and quantile boxes are plotted for value nodes or the expected utility for utility nodes unless the argument <code>main</code>
contains as many elements as the number of rows of <code>u</code>.
In the latter case, separate hierarchies with color-coded boxes for value nodes are produced for all rows of <code>u</code>.
For <code>type</code> equals <code>"table"</code>, this argument can be a list of data frames
to make it possible to plot uncertainty ranges from the samples provided
in the list.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_uref">uref</code></td>
<td>

<p>(optional) vector or data frame with elements or columns labelled
according to the nodes of the hierarchy containing values or utilities.
Typically, this will be the complete output or an output row of
the function <br /> <code><a href="#topic+evaluate.utility.aggregation">evaluate.utility.aggregation</a></code>. <br /> 
This input is only considered if the argument <code>type</code> is specified
to be <code>"hierarchy"</code>.
It is then used to color-code the upper part of the boxes of the hierarchy
to allow for a comparison with the results provided by the argument <code>u</code> which are shown in the lower part of the boxes.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before plotting the node.
Note that this affects only the node definitions plotted if the argument <code>type</code>
is specified to be <code>"node"</code> or <code>"nodes"</code>.
To color-code hierarchies or tables for different parameter values,
the parameters have to be passed to <br /> <code><a href="#topic+evaluate.utility.aggregation">evaluate.utility.aggregation</a></code> <br /> before passing the results of this function to this plotting routine.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_type">type</code></td>
<td>

<p>(optional) specifies the type of plot to be produced. <br /> Options: 
<code>"hierarchy"</code>, <code>"table"</code>, <code>"node"</code> or <code>"nodes"</code>. <br />
<code>"hierarchy"</code>: produces a plot of the objectives hierarchy including
color-coded results for values or utilities if these values are provided
by the arguments <code>u</code> and/or <code>uref</code>. <br />
<code>"table"</code>: produces a table with color-coded results for values or
utilities if these values are provided by the argument <code>u</code>. <br />
<code>"node"</code>: produces a plot of the definition of the current node. <br />
<code>"nodes"</code>: produces plots of node definitions for all nodes defined
by the attribute <code>nodes</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_nodes">nodes</code></td>
<td>

<p>(optional) character vector specifying the nodes for which the definitions
will be plotted or which will be considered in a table. 
The default value of NA indicates that all nodes will be plotted.
This argument only affects the output if the argument <code>type</code> was indicated to be either <code>"table"</code> or <code>"nodes"</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_col">col</code></td>
<td>

<p>(optional) character vector of colors to be used to color the interval
between zero and unity in equidistant sections (use repetitions of the
same color if you want to have a non-equidistant color-coding).
This attribute is only used for value nodes and if values are provided
by the arguments <code>u</code> and/or <code>uref</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_gridlines">gridlines</code></td>
<td>

<p>(optional) numeric vector of levels at which gridlines are plotted
in node definitions.
This attribute is only used if the argument <code>type</code> is specified to be either <code>"node"</code> or <code>"nodes"</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_main">main</code></td>
<td>

<p>(optional) title(s) of the plot.
If the argument <code>type</code> is equal to <code>"hierarchy"</code> and the a vector of titles with the same length as the number of rows of the argument <code>u</code> is provided, a color-coded hierarchy is plotted for each row of <code>u</code>.
Otherwise, the medians and colored boxes indicating 90% credibility or occurrence ranges are plotted at all nodes.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_cex.main">cex.main</code></td>
<td>

<p>(optional) scaling factor for title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_cex.nodes">cex.nodes</code></td>
<td>

<p>(optional) scaling factor for node labels used in the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_cex.attrib">cex.attrib</code></td>
<td>

<p>(optional) scaling factor for attribute labels used in the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_f.reaches">f.reaches</code></td>
<td>

<p>(optional) fraction of the width of the plot reserved for the row labels of the table if the argument <code>type</code> is equal to <code>"table"</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_f.nodes">f.nodes</code></td>
<td>

<p>(optional) fraction of the height of the plot reserved for the column labels of the table if the argument <code>type</code> is equal to <code>"table"</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_with.attrib">with.attrib</code></td>
<td>

<p>(optional) indicates if attributes should be listed if the argument <code>type</code> is equal to <code>"hierarchy"</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_levels">levels</code></td>
<td>

<p>(optional) how many levels of the hierarchy should be plotted (NA means to plot all levels).
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_plot.val">plot.val</code></td>
<td>

<p>(optional) plot value as a vertical line within the box.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_print.val">print.val</code></td>
<td>

<p>(optional) print value as a number when plotting a table of boxes.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_two.lines">two.lines</code></td>
<td>

<p>(optional) choose whether two lines should be used for the labels in the hierarchy plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.intpol_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the R plotting routine.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that the plotting routines <br />
<code><a href="#topic+plot.utility.conversion.parfun">plot.utility.conversion.parfun</a></code> <br />
<code><a href="#topic+plot.utility.aggregation">plot.utility.aggregation</a></code> <br />
are exactly the same so that all hierarchies can be plotted with exactly
the same commands irrespective of the type of the top-level node.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code> for how to construct such a node and <code><a href="#topic+evaluate.utility.conversion.intpol">evaluate.utility.conversion.intpol</a></code> for how to evaluate the node. <br /><br />
See <code><a href="#topic+utility.calc.colors">utility.calc.colors</a></code> for an example of how to construct color schemes and <code><a href="#topic+utility.get.colors">utility.get.colors</a></code> for how to get colors for specifed value levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='plot.utility.conversion.parfun'>Plot Node Definition or Underlying Objectives Hierarchy</h2><span id='topic+plot.utility.conversion.parfun'></span>

<h3>Description</h3>

<p>Plot node definition or underlying objectives hierarchy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.conversion.parfun'
plot(x, 
     u           = NA, 
     uref        = NA, 
     par         = NA, 
     type        = c("hierarchy", "table", "node", "nodes"), 
     nodes       = NA, 
     col         = utility.calc.colors(), 
     gridlines   = c(0.2, 0.4, 0.6, 0.8), 
     main        = "", 
     cex.main    = 1, 
     cex.nodes   = 1, 
     cex.attrib  = 1, 
     f.reaches   = 0.2,
     f.nodes     = 0.2,
     with.attrib = TRUE,
     levels      = NA,
     plot.val    = TRUE,
     print.val   = TRUE,
     two.lines   = FALSE,
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.utility.conversion.parfun_+3A_x">x</code></td>
<td>

<p>node to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_u">u</code></td>
<td>

<p>(optional) vector or data frame with elements or columns labelled
according to the nodes of the hierarchy containing values or utilities.
Typically, this will be the complete output or an output row of
the function <br /> <code><a href="#topic+evaluate.utility.aggregation">evaluate.utility.aggregation</a></code>. <br />
This input is only considered if the argument <code>type</code> is specified
to be either <code>"hierarchy"</code> or <code>"table"</code>.
It is then used to color-code the boxes of the hierarchy representing value nodes or the table.
If <code>u</code> is a data frame with more than one row and the argument <code>type</code> 
is equal to <code>"hierarchy"</code>, then
the median and quantile boxes are plotted for value nodes or the expected utility for utility nodes unless the argument <code>main</code>
contains as many elements as the number of rows of <code>u</code>.
In the latter case, separate hierarchies with color-coded boxes for value nodes are produced for all rows of <code>u</code>.
For <code>type</code> equals <code>"table"</code>, this argument can be a list of data frames
to make it possible to plot uncertainty ranges from the samples provided
in the list.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_uref">uref</code></td>
<td>

<p>(optional) vector or data frame with elements or columns labelled
according to the nodes of the hierarchy containing values or utilities.
Typically, this will be the complete output or an output row of
the function <br /> <code><a href="#topic+evaluate.utility.aggregation">evaluate.utility.aggregation</a></code>. <br /> 
This input is only considered if the argument <code>type</code> is specified
to be <code>"hierarchy"</code>.
It is then used to color-code the upper part of the boxes of the hierarchy
to allow for a comparison with the results provided by the argument <code>u</code> which are shown in the lower part of the boxes.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before plotting the node.
Note that this affects only the node definitions plotted if the argument <code>type</code>
is specified to be <code>"node"</code> or <code>"nodes"</code>.
To color-code hierarchies or tables for different parameter values,
the parameters have to be passed to <br /> <code><a href="#topic+evaluate.utility.aggregation">evaluate.utility.aggregation</a></code> <br /> before passing the results of this function to this plotting routine.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_type">type</code></td>
<td>

<p>(optional) specifies the type of plot to be produced. <br /> Options: 
<code>"hierarchy"</code>, <code>"table"</code>, <code>"node"</code> or <code>"nodes"</code>. <br />
<code>"hierarchy"</code>: produces a plot of the objectives hierarchy including
color-coded results for values or utilities if these values are provided
by the arguments <code>u</code> and/or <code>uref</code>. <br />
<code>"table"</code>: produces a table with color-coded results for values or
utilities if these values are provided by the argument <code>u</code>. <br />
<code>"node"</code>: produces a plot of the definition of the current node. <br />
<code>"nodes"</code>: produces plots of node definitions for all nodes defined
by the attribute <code>nodes</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_nodes">nodes</code></td>
<td>

<p>(optional) character vector specifying the nodes for which the definitions
will be plotted or which will be considered in a table. 
The default value of NA indicates that all nodes will be plotted.
This argument only affects the output if the argument <code>type</code> was indicated to be either <code>"table"</code> or <code>"nodes"</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_col">col</code></td>
<td>

<p>(optional) character vector of colors to be used to color the interval
between zero and unity in equidistant sections (use repetitions of the
same color if you want to have a non-equidistant color-coding).
This attribute is only used for value nodes and if values are provided
by the arguments <code>u</code> and/or <code>uref</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_gridlines">gridlines</code></td>
<td>

<p>(optional) numeric vector of levels at which gridlines are plotted
in node definitions.
This attribute is only used if the argument <code>type</code> is specified to be either <code>"node"</code> or <code>"nodes"</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_main">main</code></td>
<td>

<p>(optional) title(s) of the plot.
If the argument <code>type</code> is equal to <code>"hierarchy"</code> and the a vector of titles with the same length as the number of rows of the argument <code>u</code> is provided, a color-coded hierarchy is plotted for each row of <code>u</code>.
Otherwise, the medians and colored boxes indicating 90% credibility or occurrence ranges are plotted at all nodes.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_cex.main">cex.main</code></td>
<td>

<p>(optional) scaling factor for title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_cex.nodes">cex.nodes</code></td>
<td>

<p>(optional) scaling factor for node labels used in the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_cex.attrib">cex.attrib</code></td>
<td>

<p>(optional) scaling factor for attribute labels used in the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_f.reaches">f.reaches</code></td>
<td>

<p>(optional) fraction of the width of the plot reserved for the row labels of the table if the argument <code>type</code> is equal to <code>"table"</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_f.nodes">f.nodes</code></td>
<td>

<p>(optional) fraction of the height of the plot reserved for the column labels of the table if the argument <code>type</code> is equal to <code>"table"</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_with.attrib">with.attrib</code></td>
<td>

<p>(optional) indicates if attributes should be listed if the argument <code>type</code> is equal to <code>"hierarchy"</code>.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_levels">levels</code></td>
<td>

<p>(optional) how many levels of the hierarchy should be plotted (NA means to plot all levels).
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_plot.val">plot.val</code></td>
<td>

<p>(optional) plot value as a vertical line within the box.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_print.val">print.val</code></td>
<td>

<p>(optional) print value as a number when plotting a table of boxes.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_two.lines">two.lines</code></td>
<td>

<p>(optional) choose whether two lines should be used for the labels in the hierarchy plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.conversion.parfun_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the R plotting routine.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that the plotting routines <br />
<code><a href="#topic+plot.utility.conversion.intpol">plot.utility.conversion.intpol</a></code> <br />
<code><a href="#topic+plot.utility.aggregation">plot.utility.aggregation</a></code> <br />
are exactly the same so that all hierarchies can be plotted with exactly
the same commands irrespective of the type of the top-level node.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code> for how to construct such a node and <code><a href="#topic+evaluate.utility.conversion.parfun">evaluate.utility.conversion.parfun</a></code> for how to evaluate the node. <br /><br />
See <code><a href="#topic+utility.calc.colors">utility.calc.colors</a></code> for an example of how to construct color schemes and <code><a href="#topic+utility.get.colors">utility.get.colors</a></code> for how to get colors for specifed value levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='plot.utility.endnode.classcounts'>Plot Node Definition</h2><span id='topic+plot.utility.endnode.classcounts'></span>

<h3>Description</h3>

<p>Plot node definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.classcounts'
plot(x, 
     par       = NA, 
     col       = utility.calc.colors(), 
     gridlines = c(0.2, 0.4, 0.6, 0.8), 
     main      = "", 
     cex.main  = 1, 
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.utility.endnode.classcounts_+3A_x">x</code></td>
<td>

<p>node to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.classcounts_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before plotting the node.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.classcounts_+3A_col">col</code></td>
<td>

<p>(optional) character vector of colors to be used to color the interval
between zero and unity in equidistant sections (use repetitions of the
same color if you want to have a non-equidistant color-coding).
This attribute is only used for value nodes.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.classcounts_+3A_gridlines">gridlines</code></td>
<td>

<p>(optional) numeric vector of levels at which gridlines are plotted
in the node definition.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.classcounts_+3A_main">main</code></td>
<td>

<p>(optional) title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.classcounts_+3A_cex.main">cex.main</code></td>
<td>

<p>(optional) scaling factor for title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.classcounts_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the R plotting routine.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that the plotting routines for the other end nodes <br />
<code><a href="#topic+plot.utility.endnode.discrete">plot.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+plot.utility.endnode.intpol1d">plot.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.parfun1d">plot.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.intpol2d">plot.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.cond">plot.utility.endnode.cond</a></code> <br />
<code><a href="#topic+plot.utility.endnode.firstavail">plot.utility.endnode.firstavail</a></code> <br />
are as far as possible the same so that all end nodes can be plotted with the same commands irrespective of the type of the end node.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.classcounts.create">utility.endnode.classcounts.create</a></code> for how to construct such a node and <code><a href="#topic+evaluate.utility.endnode.classcounts">evaluate.utility.endnode.classcounts</a></code> for how to evaluate the node. <br /><br />
See <code><a href="#topic+utility.calc.colors">utility.calc.colors</a></code> for an example of how to construct color schemes and <code><a href="#topic+utility.get.colors">utility.get.colors</a></code> for how to get colors for specifed value levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='plot.utility.endnode.cond'>Plot Node Definition</h2><span id='topic+plot.utility.endnode.cond'></span>

<h3>Description</h3>

<p>Plot node definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.cond'
plot(x, 
     par       = NA, 
     col       = utility.calc.colors(), 
     gridlines = c(0.2, 0.4, 0.6, 0.8), 
     main      = "", 
     cex.main  = 1, 
     nodes     = x$name, 
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.utility.endnode.cond_+3A_x">x</code></td>
<td>

<p>node to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.cond_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before plotting the node.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.cond_+3A_col">col</code></td>
<td>

<p>(optional) character vector of colors to be used to color the interval
between zero and unity in equidistant sections (use repetitions of the
same color if you want to have a non-equidistant color-coding).
This attribute is only used for value nodes.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.cond_+3A_gridlines">gridlines</code></td>
<td>

<p>(optional) numeric vector of levels at which gridlines are plotted
in the node definition.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.cond_+3A_main">main</code></td>
<td>

<p>(optional) title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.cond_+3A_cex.main">cex.main</code></td>
<td>

<p>(optional) scaling factor for title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.cond_+3A_nodes">nodes</code></td>
<td>

<p>(optional) character vector specifying the names of the nodes to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.cond_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the R plotting routine.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that the plotting routines for the other end nodes <br />
<code><a href="#topic+plot.utility.endnode.discrete">plot.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+plot.utility.endnode.intpol1d">plot.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.parfun1d">plot.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.intpol2d">plot.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.firstavail">plot.utility.endnode.firstavail</a></code> <br />
are as far as possible the same so that all end nodes can be plotted with the same commands irrespective of the type of the end node.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code> for how to construct such a node and <code><a href="#topic+evaluate.utility.endnode.cond">evaluate.utility.endnode.cond</a></code> for how to evaluate the node. <br /><br />
See <code><a href="#topic+utility.calc.colors">utility.calc.colors</a></code> for an example of how to construct color schemes and <code><a href="#topic+utility.get.colors">utility.get.colors</a></code> for how to get colors for specifed value levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='plot.utility.endnode.discrete'>Plot Node Definition</h2><span id='topic+plot.utility.endnode.discrete'></span>

<h3>Description</h3>

<p>Plot node definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.discrete'
plot(x, 
     par       = NA, 
     col       = utility.calc.colors(), 
     gridlines = c(0.2, 0.4, 0.6, 0.8), 
     main      = "", 
     cex.main  = 1, 
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.utility.endnode.discrete_+3A_x">x</code></td>
<td>

<p>node to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.discrete_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before plotting the node.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.discrete_+3A_col">col</code></td>
<td>

<p>(optional) character vector of colors to be used to color the interval
between zero and unity in equidistant sections (use repetitions of the
same color if you want to have a non-equidistant color-coding).
This attribute is only used for value nodes.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.discrete_+3A_gridlines">gridlines</code></td>
<td>

<p>(optional) numeric vector of levels at which gridlines are plotted
in the node definition.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.discrete_+3A_main">main</code></td>
<td>

<p>(optional) title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.discrete_+3A_cex.main">cex.main</code></td>
<td>

<p>(optional) scaling factor for title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.discrete_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the R plotting routine.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that the plotting routines for the other end nodes <br />
<code><a href="#topic+plot.utility.endnode.intpol1d">plot.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.parfun1d">plot.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.intpol2d">plot.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.cond">plot.utility.endnode.cond</a></code> <br />
<code><a href="#topic+plot.utility.endnode.firstavail">plot.utility.endnode.firstavail</a></code> <br />
are as far as possible the same so that all end nodes can be plotted with the same commands irrespective of the type of the end node.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code> for how to construct such a node and <code><a href="#topic+evaluate.utility.endnode.discrete">evaluate.utility.endnode.discrete</a></code> for how to evaluate the node. <br /><br />
See <code><a href="#topic+utility.calc.colors">utility.calc.colors</a></code> for an example of how to construct color schemes and <code><a href="#topic+utility.get.colors">utility.get.colors</a></code> for how to get colors for specifed value levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='plot.utility.endnode.firstavail'>Plot Node Definition</h2><span id='topic+plot.utility.endnode.firstavail'></span>

<h3>Description</h3>

<p>Plot node definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.firstavail'
plot(x, 
     par       = NA, 
     col       = utility.calc.colors(), 
     gridlines = c(0.2, 0.4, 0.6, 0.8), 
     main      = "", 
     cex.main  = 1, 
     nodes     = x$name, 
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.utility.endnode.firstavail_+3A_x">x</code></td>
<td>

<p>node to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.firstavail_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before plotting the node.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.firstavail_+3A_col">col</code></td>
<td>

<p>(optional) character vector of colors to be used to color the interval
between zero and unity in equidistant sections (use repetitions of the
same color if you want to have a non-equidistant color-coding).
This attribute is only used for value nodes.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.firstavail_+3A_gridlines">gridlines</code></td>
<td>

<p>(optional) numeric vector of levels at which gridlines are plotted
in the node definition.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.firstavail_+3A_main">main</code></td>
<td>

<p>(optional) title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.firstavail_+3A_cex.main">cex.main</code></td>
<td>

<p>(optional) scaling factor for title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.firstavail_+3A_nodes">nodes</code></td>
<td>

<p>(optional) character vector specifying the names of the nodes to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.firstavail_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the R plotting routine.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that the plotting routines for the other end nodes <br />
<code><a href="#topic+plot.utility.endnode.discrete">plot.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+plot.utility.endnode.intpol1d">plot.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.parfun1d">plot.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.intpol2d">plot.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.cond">plot.utility.endnode.cond</a></code> <br />
are as far as possible the same so that all end nodes can be plotted with the same commands irrespective of the type of the end node.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code> for how to construct such a node and <code><a href="#topic+evaluate.utility.endnode.firstavail">evaluate.utility.endnode.firstavail</a></code> for how to evaluate the node. <br /><br />
See <code><a href="#topic+utility.calc.colors">utility.calc.colors</a></code> for an example of how to construct color schemes and <code><a href="#topic+utility.get.colors">utility.get.colors</a></code> for how to get colors for specifed value levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='plot.utility.endnode.intpol1d'>Plot Node Definition</h2><span id='topic+plot.utility.endnode.intpol1d'></span>

<h3>Description</h3>

<p>Plot node definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.intpol1d'
plot(x, 
     par       = NA, 
     col       = utility.calc.colors(), 
     gridlines = c(0.2, 0.4, 0.6, 0.8), 
     main      = "", 
     cex.main  = 1,
     xlim      = numeric(0),
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.utility.endnode.intpol1d_+3A_x">x</code></td>
<td>

<p>node to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.intpol1d_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before plotting the node.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.intpol1d_+3A_col">col</code></td>
<td>

<p>(optional) character vector of colors to be used to color the interval
between zero and unity in equidistant sections (use repetitions of the
same color if you want to have a non-equidistant color-coding).
This attribute is only used for value nodes.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.intpol1d_+3A_gridlines">gridlines</code></td>
<td>

<p>(optional) numeric vector of levels at which gridlines are plotted
in the node definition.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.intpol1d_+3A_main">main</code></td>
<td>

<p>(optional) title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.intpol1d_+3A_cex.main">cex.main</code></td>
<td>

<p>(optional) scaling factor for title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.intpol1d_+3A_xlim">xlim</code></td>
<td>

<p>(optional) limits for x-axis of the plot (default is range).
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.intpol1d_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the R plotting routine.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that the plotting routines for the other end nodes <br />
<code><a href="#topic+plot.utility.endnode.discrete">plot.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+plot.utility.endnode.parfun1d">plot.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.intpol2d">plot.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.cond">plot.utility.endnode.cond</a></code> <br />
<code><a href="#topic+plot.utility.endnode.firstavail">plot.utility.endnode.firstavail</a></code> <br />
are as far as possible the same so that all end nodes can be plotted with the same commands irrespective of the type of the end node.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code> for how to construct such a node and <code><a href="#topic+evaluate.utility.endnode.intpol1d">evaluate.utility.endnode.intpol1d</a></code> for how to evaluate the node. <br /><br />
See <code><a href="#topic+utility.calc.colors">utility.calc.colors</a></code> for an example of how to construct color schemes and <code><a href="#topic+utility.get.colors">utility.get.colors</a></code> for how to get colors for specifed value levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='plot.utility.endnode.intpol2d'>Plot Node Definition</h2><span id='topic+plot.utility.endnode.intpol2d'></span>

<h3>Description</h3>

<p>Plot node definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.intpol2d'
plot(x, 
     par       = NA, 
     col       = utility.calc.colors(), 
     gridlines = c(0.2, 0.4, 0.6, 0.8), 
     main      = "", 
     cex.main  = 1,
     xlim      = numeric(0),
     ylim      = numeric(0),
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.utility.endnode.intpol2d_+3A_x">x</code></td>
<td>

<p>node to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.intpol2d_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before plotting the node.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.intpol2d_+3A_col">col</code></td>
<td>

<p>(optional) character vector of colors to be used to color the interval
between zero and unity in equidistant sections (use repetitions of the
same color if you want to have a non-equidistant color-coding).
This attribute is only used for value nodes.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.intpol2d_+3A_gridlines">gridlines</code></td>
<td>

<p>(optional) numeric vector of levels at which gridlines are plotted
in the node definition.
Not used for this type of node.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.intpol2d_+3A_main">main</code></td>
<td>

<p>(optional) title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.intpol2d_+3A_cex.main">cex.main</code></td>
<td>

<p>(optional) scaling factor for title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.intpol2d_+3A_xlim">xlim</code></td>
<td>

<p>(optional) limits of the x-axis of the plot (defaults to range).
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.intpol2d_+3A_ylim">ylim</code></td>
<td>

<p>(optional) limits of the y-axis of the plot (defaults to range).
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.intpol2d_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the R plotting routine.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that the plotting routines for the other end nodes <br />
<code><a href="#topic+plot.utility.endnode.discrete">plot.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+plot.utility.endnode.parfun1d">plot.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.intpol2d">plot.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.cond">plot.utility.endnode.cond</a></code> <br />
<code><a href="#topic+plot.utility.endnode.firstavail">plot.utility.endnode.firstavail</a></code> <br />
are as far as possible the same so that all end nodes can be plotted with the same commands irrespective of the type of the end node.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code> for how to construct such a node and <code><a href="#topic+evaluate.utility.endnode.intpol1d">evaluate.utility.endnode.intpol1d</a></code> for how to evaluate the node. <br /><br />
See <code><a href="#topic+utility.calc.colors">utility.calc.colors</a></code> for an example of how to construct color schemes and <code><a href="#topic+utility.get.colors">utility.get.colors</a></code> for how to get colors for specifed value levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='plot.utility.endnode.parfun1d'>Plot Node Definition</h2><span id='topic+plot.utility.endnode.parfun1d'></span>

<h3>Description</h3>

<p>Plot node definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.parfun1d'
plot(x, 
     par       = NA, 
     col       = utility.calc.colors(), 
     gridlines = c(0.2, 0.4, 0.6, 0.8), 
     main      = "", 
     cex.main  = 1,
     xlim      = numeric(0),
     ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.utility.endnode.parfun1d_+3A_x">x</code></td>
<td>

<p>node to be plotted.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.parfun1d_+3A_par">par</code></td>
<td>

<p>(optional) labelled numeric parameter vector providing parameters to
modify the value or utility function before plotting the node.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.parfun1d_+3A_col">col</code></td>
<td>

<p>(optional) character vector of colors to be used to color the interval
between zero and unity in equidistant sections (use repetitions of the
same color if you want to have a non-equidistant color-coding).
This attribute is only used for value nodes.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.parfun1d_+3A_gridlines">gridlines</code></td>
<td>

<p>(optional) numeric vector of levels at which gridlines are plotted
in the node definition.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.parfun1d_+3A_main">main</code></td>
<td>

<p>(optional) title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.parfun1d_+3A_cex.main">cex.main</code></td>
<td>

<p>(optional) scaling factor for title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.parfun1d_+3A_xlim">xlim</code></td>
<td>

<p>(optional) limits for x-axis of the plot (default is range).
</p>
</td></tr>
<tr><td><code id="plot.utility.endnode.parfun1d_+3A_...">...</code></td>
<td>

<p>additional arguments passed to the R plotting routine.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note that the plotting routines for the other end nodes <br />
<code><a href="#topic+plot.utility.endnode.discrete">plot.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+plot.utility.endnode.intpol1d">plot.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.intpol2d">plot.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.cond">plot.utility.endnode.cond</a></code> <br />
<code><a href="#topic+plot.utility.endnode.firstavail">plot.utility.endnode.firstavail</a></code> <br />
are as far as possible the same so that all end nodes can be plotted with the same commands irrespective of the type of the end node.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code> for how to construct such a node and <code><a href="#topic+evaluate.utility.endnode.parfun1d">evaluate.utility.endnode.parfun1d</a></code> for how to evaluate the node. <br /><br />
See <code><a href="#topic+utility.calc.colors">utility.calc.colors</a></code> for an example of how to construct color schemes and <code><a href="#topic+utility.get.colors">utility.get.colors</a></code> for how to get colors for specifed value levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='print.utility.aggregation'>Print Definitions of Node and Associated Hierarchy</h2><span id='topic+print.utility.aggregation'></span>

<h3>Description</h3>

<p>Print definition of node and associated hierarchy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.aggregation'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.utility.aggregation_+3A_x">x</code></td>
<td>

<p>node to be printed.
</p>
</td></tr>
<tr><td><code id="print.utility.aggregation_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='print.utility.conversion.intpol'>Print Definitions of Node and Associated Hierarchy</h2><span id='topic+print.utility.conversion.intpol'></span>

<h3>Description</h3>

<p>Print definition of node and associated hierarchy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.conversion.intpol'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.utility.conversion.intpol_+3A_x">x</code></td>
<td>

<p>node to be printed.
</p>
</td></tr>
<tr><td><code id="print.utility.conversion.intpol_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='print.utility.conversion.parfun'>Print Definitions of Node and Associated Hierarchy</h2><span id='topic+print.utility.conversion.parfun'></span>

<h3>Description</h3>

<p>Print definition of node and associated hierarchy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.conversion.parfun'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.utility.conversion.parfun_+3A_x">x</code></td>
<td>

<p>node to be printed.
</p>
</td></tr>
<tr><td><code id="print.utility.conversion.parfun_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='print.utility.endnode.classcounts'>Print Node Definition</h2><span id='topic+print.utility.endnode.classcounts'></span>

<h3>Description</h3>

<p>Print node defintion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.classcounts'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.utility.endnode.classcounts_+3A_x">x</code></td>
<td>

<p>node to be printed.
</p>
</td></tr>
<tr><td><code id="print.utility.endnode.classcounts_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.classcounts.create">utility.endnode.classcounts.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='print.utility.endnode.cond'>Print Node Definition</h2><span id='topic+print.utility.endnode.cond'></span>

<h3>Description</h3>

<p>Print node defintion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.cond'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.utility.endnode.cond_+3A_x">x</code></td>
<td>

<p>node to be printed.
</p>
</td></tr>
<tr><td><code id="print.utility.endnode.cond_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='print.utility.endnode.discrete'>Print Node Definition</h2><span id='topic+print.utility.endnode.discrete'></span>

<h3>Description</h3>

<p>Print node defintion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.discrete'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.utility.endnode.discrete_+3A_x">x</code></td>
<td>

<p>node to be printed.
</p>
</td></tr>
<tr><td><code id="print.utility.endnode.discrete_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='print.utility.endnode.firstavail'>Print Node Definition</h2><span id='topic+print.utility.endnode.firstavail'></span>

<h3>Description</h3>

<p>Print node defintion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.firstavail'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.utility.endnode.firstavail_+3A_x">x</code></td>
<td>

<p>node to be printed.
</p>
</td></tr>
<tr><td><code id="print.utility.endnode.firstavail_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='print.utility.endnode.intpol1d'>Print Node Definition</h2><span id='topic+print.utility.endnode.intpol1d'></span>

<h3>Description</h3>

<p>Print node defintion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.intpol1d'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.utility.endnode.intpol1d_+3A_x">x</code></td>
<td>

<p>node to be printed.
</p>
</td></tr>
<tr><td><code id="print.utility.endnode.intpol1d_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='print.utility.endnode.intpol2d'>Print Node Definition</h2><span id='topic+print.utility.endnode.intpol2d'></span>

<h3>Description</h3>

<p>Print node defintion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.intpol2d'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.utility.endnode.intpol2d_+3A_x">x</code></td>
<td>

<p>node to be printed.
</p>
</td></tr>
<tr><td><code id="print.utility.endnode.intpol2d_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='print.utility.endnode.parfun1d'>Print Node Definition</h2><span id='topic+print.utility.endnode.parfun1d'></span>

<h3>Description</h3>

<p>Print node defintion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.parfun1d'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.utility.endnode.parfun1d_+3A_x">x</code></td>
<td>

<p>node to be printed.
</p>
</td></tr>
<tr><td><code id="print.utility.endnode.parfun1d_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='summary.utility.aggregation'>Print Summary of Definitions of Node and Associated Hierarchy</h2><span id='topic+summary.utility.aggregation'></span>

<h3>Description</h3>

<p>Print summary of definition of node and associated hierarchy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.aggregation'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.utility.aggregation_+3A_object">object</code></td>
<td>

<p>node of which a summary is to be printed.
</p>
</td></tr>
<tr><td><code id="summary.utility.aggregation_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='summary.utility.conversion.intpol'>Print Summary of Definitions of Node and Associated Hierarchy</h2><span id='topic+summary.utility.conversion.intpol'></span>

<h3>Description</h3>

<p>Print summary of definition of node and associated hierarchy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.conversion.intpol'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.utility.conversion.intpol_+3A_object">object</code></td>
<td>

<p>node of which a summary is to be printed.
</p>
</td></tr>
<tr><td><code id="summary.utility.conversion.intpol_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='summary.utility.conversion.parfun'>Print Summary of Definitions of Node and Associated Hierarchy</h2><span id='topic+summary.utility.conversion.parfun'></span>

<h3>Description</h3>

<p>Print summary of definition of node and associated hierarchy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.conversion.parfun'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.utility.conversion.parfun_+3A_object">object</code></td>
<td>

<p>node of which a summary is to be printed.
</p>
</td></tr>
<tr><td><code id="summary.utility.conversion.parfun_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='summary.utility.endnode.classcounts'>Print Summary of Node Definition</h2><span id='topic+summary.utility.endnode.classcounts'></span>

<h3>Description</h3>

<p>Print summary of node definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.classcounts'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.utility.endnode.classcounts_+3A_object">object</code></td>
<td>

<p>node of which a summary is to be printed.
</p>
</td></tr>
<tr><td><code id="summary.utility.endnode.classcounts_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.classcounts.create">utility.endnode.classcounts.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='summary.utility.endnode.cond'>Print Summary of Node Definition</h2><span id='topic+summary.utility.endnode.cond'></span>

<h3>Description</h3>

<p>Print summary of node definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.cond'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.utility.endnode.cond_+3A_object">object</code></td>
<td>

<p>node of which a summary is to be printed.
</p>
</td></tr>
<tr><td><code id="summary.utility.endnode.cond_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='summary.utility.endnode.discrete'>Print Summary of Node Definition</h2><span id='topic+summary.utility.endnode.discrete'></span>

<h3>Description</h3>

<p>Print summary of node definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.discrete'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.utility.endnode.discrete_+3A_object">object</code></td>
<td>

<p>node of which a summary is to be printed.
</p>
</td></tr>
<tr><td><code id="summary.utility.endnode.discrete_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='summary.utility.endnode.firstavail'>Print Summary of Node Definition</h2><span id='topic+summary.utility.endnode.firstavail'></span>

<h3>Description</h3>

<p>Print summary of node definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.firstavail'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.utility.endnode.firstavail_+3A_object">object</code></td>
<td>

<p>node of which a summary is to be printed.
</p>
</td></tr>
<tr><td><code id="summary.utility.endnode.firstavail_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='summary.utility.endnode.intpol1d'>Print Summary of Node Definition</h2><span id='topic+summary.utility.endnode.intpol1d'></span>

<h3>Description</h3>

<p>Print summary of node definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.intpol1d'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.utility.endnode.intpol1d_+3A_object">object</code></td>
<td>

<p>node of which a summary is to be printed.
</p>
</td></tr>
<tr><td><code id="summary.utility.endnode.intpol1d_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='summary.utility.endnode.intpol2d'>Print Summary of Node Definition</h2><span id='topic+summary.utility.endnode.intpol2d'></span>

<h3>Description</h3>

<p>Print summary of node definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.intpol2d'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.utility.endnode.intpol2d_+3A_object">object</code></td>
<td>

<p>node of which a summary is to be printed.
</p>
</td></tr>
<tr><td><code id="summary.utility.endnode.intpol2d_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='summary.utility.endnode.parfun1d'>Print Summary of Node Definition</h2><span id='topic+summary.utility.endnode.parfun1d'></span>

<h3>Description</h3>

<p>Print summary of node definition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.parfun1d'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.utility.endnode.parfun1d_+3A_object">object</code></td>
<td>

<p>node of which a summary is to be printed.
</p>
</td></tr>
<tr><td><code id="summary.utility.endnode.parfun1d_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In the current version of the package, the methods <code>print</code> and <code>summary</code>
provide the same output.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code> for how to construct such a node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see
help(utility)
# for examples.
</code></pre>

<hr>
<h2 id='updatepar'>Update Parameters in Node Definitions</h2><span id='topic+updatepar'></span>

<h3>Description</h3>

<p>Generic function to update parameters in all node defintions of the hierarchy defined by the given node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>updatepar(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updatepar_+3A_x">x</code></td>
<td>

<p>node to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar_+3A_...">...</code></td>
<td>

<p>parameter values can be provided by an additional argument <code>par</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The node or node hierarchy with updated parameters is returned.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, <br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code> <br /><br />
for how to construct the nodes and <br /><br />
<code><a href="#topic+updatepar.utility.endnode.discrete">updatepar.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol1d">updatepar.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.parfun1d">updatepar.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol2d">updatepar.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.cond">updatepar.utility.endnode.cond</a></code> <br />
<code><a href="#topic+updatepar.utility.aggregation">updatepar.utility.aggregation</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.intpol">updatepar.utility.conversion.intpol</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.parfun">updatepar.utility.conversion.parfun</a></code> <br />
for the updates of the specific nodes.
</p>

<hr>
<h2 id='updatepar.utility.aggregation'>Update Parameters in Node Definitions</h2><span id='topic+updatepar.utility.aggregation'></span>

<h3>Description</h3>

<p>Update parameters in all node defintions of the hierarchy defined by the node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.aggregation'
updatepar(x, par=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updatepar.utility.aggregation_+3A_x">x</code></td>
<td>

<p>node to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.aggregation_+3A_par">par</code></td>
<td>

<p>parameter vector with labelled parameters to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.aggregation_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The node hierarchy with updated parameters is returned.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> for how to construct such a node and <br /><br />
<code><a href="#topic+updatepar.utility.endnode.discrete">updatepar.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol1d">updatepar.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.parfun1d">updatepar.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol2d">updatepar.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.cond">updatepar.utility.endnode.cond</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.intpol">updatepar.utility.conversion.intpol</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.parfun">updatepar.utility.conversion.parfun</a></code> <br />
for analogous updates of other nodes
</p>

<hr>
<h2 id='updatepar.utility.conversion.intpol'>Update Parameters in Node Definitions</h2><span id='topic+updatepar.utility.conversion.intpol'></span>

<h3>Description</h3>

<p>Update parameters in all node defintions of the hierarchy defined by the node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.conversion.intpol'
updatepar(x, par=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updatepar.utility.conversion.intpol_+3A_x">x</code></td>
<td>

<p>node to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.conversion.intpol_+3A_par">par</code></td>
<td>

<p>parameter vector labelled with parameter values to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.conversion.intpol_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The node hierarchy with updated parameters is returned.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code> for how to construct such a node and <br /><br />
<code><a href="#topic+updatepar.utility.endnode.discrete">updatepar.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol1d">updatepar.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.parfun1d">updatepar.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol2d">updatepar.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.cond">updatepar.utility.endnode.cond</a></code> <br />
<code><a href="#topic+updatepar.utility.aggregation">updatepar.utility.aggregation</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.parfun">updatepar.utility.conversion.parfun</a></code> <br />
for analogous updates of other nodes
</p>

<hr>
<h2 id='updatepar.utility.conversion.parfun'>Update Parameters in Node Definitions</h2><span id='topic+updatepar.utility.conversion.parfun'></span>

<h3>Description</h3>

<p>Update parameters in all node defintions of the hierarchy defined by the node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.conversion.parfun'
updatepar(x, par=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updatepar.utility.conversion.parfun_+3A_x">x</code></td>
<td>

<p>node to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.conversion.parfun_+3A_par">par</code></td>
<td>

<p>parameter vector with labelled parameters to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.conversion.parfun_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The node hierarchy with updated parameters is returned.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code> for how to construct such a node and <br /><br />
<code><a href="#topic+updatepar.utility.endnode.discrete">updatepar.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol1d">updatepar.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.parfun1d">updatepar.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol2d">updatepar.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.cond">updatepar.utility.endnode.cond</a></code> <br />
<code><a href="#topic+updatepar.utility.aggregation">updatepar.utility.aggregation</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.intpol">updatepar.utility.conversion.intpol</a></code> <br />
for analogous updates of other nodes
</p>

<hr>
<h2 id='updatepar.utility.endnode.classcounts'>Update Parameters in Node Definitions</h2><span id='topic+updatepar.utility.endnode.classcounts'></span>

<h3>Description</h3>

<p>Update parameters in all node defintions used to define the node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.classcounts'
updatepar(x, par=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updatepar.utility.endnode.classcounts_+3A_x">x</code></td>
<td>

<p>node to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.endnode.classcounts_+3A_par">par</code></td>
<td>

<p>parameter vector with labelled parameters to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.endnode.classcounts_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The node with updated parameters is returned.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.classcounts.create">utility.endnode.classcounts.create</a></code> for how to construct such a node and <br /><br />
<code><a href="#topic+updatepar.utility.endnode.discrete">updatepar.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol1d">updatepar.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.parfun1d">updatepar.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol2d">updatepar.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.cond">updatepar.utility.endnode.cond</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.firstavail">updatepar.utility.endnode.firstavail</a></code> <br />
<code><a href="#topic+updatepar.utility.aggregation">updatepar.utility.aggregation</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.intpol">updatepar.utility.conversion.intpol</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.parfun">updatepar.utility.conversion.parfun</a></code> <br />
for analogous updates of other nodes
</p>

<hr>
<h2 id='updatepar.utility.endnode.cond'>Update Parameters in Node Definitions</h2><span id='topic+updatepar.utility.endnode.cond'></span>

<h3>Description</h3>

<p>Update parameters in all node defintions used to define the node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.cond'
updatepar(x, par=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updatepar.utility.endnode.cond_+3A_x">x</code></td>
<td>

<p>node to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.endnode.cond_+3A_par">par</code></td>
<td>

<p>parameter vector with labelled parameters to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.endnode.cond_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The node with updated parameters is returned.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code> for how to construct such a node and <br /><br />
<code><a href="#topic+updatepar.utility.endnode.discrete">updatepar.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol1d">updatepar.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.parfun1d">updatepar.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol2d">updatepar.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.firstavail">updatepar.utility.endnode.firstavail</a></code> <br />
<code><a href="#topic+updatepar.utility.aggregation">updatepar.utility.aggregation</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.intpol">updatepar.utility.conversion.intpol</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.parfun">updatepar.utility.conversion.parfun</a></code> <br />
for analogous updates of other nodes
</p>

<hr>
<h2 id='updatepar.utility.endnode.discrete'>Update Parameters in Node Definition</h2><span id='topic+updatepar.utility.endnode.discrete'></span>

<h3>Description</h3>

<p>Update parameters in node defintion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.discrete'
updatepar(x, par=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updatepar.utility.endnode.discrete_+3A_x">x</code></td>
<td>

<p>node to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.endnode.discrete_+3A_par">par</code></td>
<td>

<p>parameter vector with labelled parameters to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.endnode.discrete_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The node with updated parameters is returned.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code> for how to construct such a node and <br /><br />
<code><a href="#topic+updatepar.utility.endnode.intpol1d">updatepar.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.parfun1d">updatepar.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol2d">updatepar.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.cond">updatepar.utility.endnode.cond</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.firstavail">updatepar.utility.endnode.firstavail</a></code> <br />
<code><a href="#topic+updatepar.utility.aggregation">updatepar.utility.aggregation</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.intpol">updatepar.utility.conversion.intpol</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.parfun">updatepar.utility.conversion.parfun</a></code> <br />
for analogous updates of other nodes
</p>

<hr>
<h2 id='updatepar.utility.endnode.firstavail'>Update Parameters in Node Definitions</h2><span id='topic+updatepar.utility.endnode.firstavail'></span>

<h3>Description</h3>

<p>Update parameters in all node defintions used to define the node.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.firstavail'
updatepar(x, par=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updatepar.utility.endnode.firstavail_+3A_x">x</code></td>
<td>

<p>node to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.endnode.firstavail_+3A_par">par</code></td>
<td>

<p>parameter vector with labelled parameters to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.endnode.firstavail_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The node with updated parameters is returned.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code> for how to construct such a node and <br /><br />
<code><a href="#topic+updatepar.utility.endnode.discrete">updatepar.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol1d">updatepar.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.parfun1d">updatepar.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol2d">updatepar.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.cond">updatepar.utility.endnode.cond</a></code> <br />
<code><a href="#topic+updatepar.utility.aggregation">updatepar.utility.aggregation</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.intpol">updatepar.utility.conversion.intpol</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.parfun">updatepar.utility.conversion.parfun</a></code> <br />
for analogous updates of other nodes
</p>

<hr>
<h2 id='updatepar.utility.endnode.intpol1d'>Update Parameters in Node Definition</h2><span id='topic+updatepar.utility.endnode.intpol1d'></span>

<h3>Description</h3>

<p>Update parameters in node defintion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.intpol1d'
updatepar(x, par=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updatepar.utility.endnode.intpol1d_+3A_x">x</code></td>
<td>

<p>node to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.endnode.intpol1d_+3A_par">par</code></td>
<td>

<p>parameter vector with labelled parameters to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.endnode.intpol1d_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The node with updated parameters is returned.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code> for how to construct such a node and <br /><br />
<code><a href="#topic+updatepar.utility.endnode.discrete">updatepar.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.parfun1d">updatepar.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol2d">updatepar.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.cond">updatepar.utility.endnode.cond</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.firstavail">updatepar.utility.endnode.firstavail</a></code> <br />
<code><a href="#topic+updatepar.utility.aggregation">updatepar.utility.aggregation</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.intpol">updatepar.utility.conversion.intpol</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.parfun">updatepar.utility.conversion.parfun</a></code> <br />
for analogous updates of other nodes
</p>

<hr>
<h2 id='updatepar.utility.endnode.intpol2d'>Update Parameters in Node Definition</h2><span id='topic+updatepar.utility.endnode.intpol2d'></span>

<h3>Description</h3>

<p>Update parameters in node defintion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.intpol2d'
updatepar(x, par=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updatepar.utility.endnode.intpol2d_+3A_x">x</code></td>
<td>

<p>node to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.endnode.intpol2d_+3A_par">par</code></td>
<td>

<p>parameter vector with labelled parameters to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.endnode.intpol2d_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The node with updated parameters is returned.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code> for how to construct such a node and <br /><br />
<code><a href="#topic+updatepar.utility.endnode.discrete">updatepar.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol1d">updatepar.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.parfun1d">updatepar.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.cond">updatepar.utility.endnode.cond</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.firstavail">updatepar.utility.endnode.firstavail</a></code> <br />
<code><a href="#topic+updatepar.utility.aggregation">updatepar.utility.aggregation</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.intpol">updatepar.utility.conversion.intpol</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.parfun">updatepar.utility.conversion.parfun</a></code> <br />
for analogous updates of other nodes
</p>

<hr>
<h2 id='updatepar.utility.endnode.parfun1d'>Update Parameters in Node Definition</h2><span id='topic+updatepar.utility.endnode.parfun1d'></span>

<h3>Description</h3>

<p>Update parameters in node defintion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'utility.endnode.parfun1d'
updatepar(x, par=NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updatepar.utility.endnode.parfun1d_+3A_x">x</code></td>
<td>

<p>node to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.endnode.parfun1d_+3A_par">par</code></td>
<td>

<p>parameter vector with labelled parameters to be updated.
</p>
</td></tr>
<tr><td><code id="updatepar.utility.endnode.parfun1d_+3A_...">...</code></td>
<td>

<p>currently no other arguments are implemented or passed further.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The node with updated parameters is returned.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code> for how to construct such a node and <br /><br />
<code><a href="#topic+updatepar.utility.endnode.discrete">updatepar.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol1d">updatepar.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.intpol2d">updatepar.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.cond">updatepar.utility.endnode.cond</a></code> <br />
<code><a href="#topic+updatepar.utility.endnode.firstavail">updatepar.utility.endnode.firstavail</a></code> <br />
<code><a href="#topic+updatepar.utility.aggregation">updatepar.utility.aggregation</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.intpol">updatepar.utility.conversion.intpol</a></code> <br />
<code><a href="#topic+updatepar.utility.conversion.parfun">updatepar.utility.conversion.parfun</a></code> <br />
for analogous updates of other nodes
</p>

<hr>
<h2 id='utility-package'>Construct, Evaluate and Plot Value and Utility Functions</h2><span id='topic+utility-package'></span><span id='topic+utility'></span>

<h3>Description</h3>

<p>Construct and plot objective hierarchies and associated value and utility functions. Evaluate the values and utilities and visualize the results as colored objective hierarchies or tables. Visualize uncertainty by plotting median and quantile intervals within the nodes of the objective hierarchy. Get numerical results of the evaluations in standard <span class="rlang"><b>R</b></span> data types for further processing.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> utility</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.4.6</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-08-27</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>An objective hierarchy and an associated value or utility function 
is constructed by constructing the nodes of the hierarchy starting 
from the end nodes and proceeding to the higher hierarchies.
Five types of end nodes are distinguished:
End nodes of the class <code>utility.endnode.discrete</code> define a value 
or utility function for an attribute that has a finite number of
discrete numeric or non-numeric levels.
End nodes of the classes <code>utility.endnode.intpol1d</code> and 
<code>utility.endnode.parfun1d</code> implement single-attribute 
value or utility functions that accept a continuous argument.
The first of these functions allows the user to specify 
attribute-value pairs and performs linear interpolation between these
points.
The second function allows the user to specify any parameteric
function that is implemented as a function in R.
End nodes of the class <code>utility.endnode.intpol2d</code> implement
interpolated value or utility functions that are based on two
attributes.
End nodes of the class <code>utility.endnode.cond</code> implement
value or utility functions that assign different value or utility
functions to a finite set of attribute combinations.
End nodes of the class <code>utility.endnode.firstavail</code> implement
value or utility functions that try to evaluate a list of nodes and 
return the value of the first node that could be evaluated based
on the provided attribute data.
Finally, end nodes of the class <code>utility.endnode.classcounts</code> implement
value or utility functions that value counts e.g. of species of different classes
by assigning a basic value for the occurrence of at least one species of the best class
and incrementing this value by multiplicities of species of this class and of the next lower class.
These end nodes can be implemented by using the following constructors. <br /><br /> 
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code> <br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code> <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code> <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code> <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code> <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code> <br />
<code><a href="#topic+utility.endnode.classcounts.create">utility.endnode.classcounts.create</a></code> <br /><br />
To advance to higher hierarchical levels, values or utilities at lower
levels must be aggregated to the next higher level.
This is done ab aggregation nodes of the class <code>utility.aggregation</code>.
Such nodes can be implemented by using the following constructor: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Finally, to provide decision support under uncertainty, values at
an adequate level of the objectives hierarchy must be converted to
utilities by accounting for the risk attitude of the decision maker.
Similar to the single-attribute value or utility functions,
this can either be done by linear interpolation with a node of the class
<code>utility.conversion.intpol</code> or by using a parametric funciton in
a node of the class <code>utility.conversion.parfun</code>.
These conversion nodes can be implemented by the constructors: <br /><br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code> <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code> <br /><br />
The definition of the objective hierarchy and the associated value 
and utility function can then be listed or visualized by using the 
generic functions <br /><br />
<code>print</code> <br />
<code>summary</code> <br />
<code>plot</code> <br /><br /> 
which automaticall call the implementation corresponding to the node specified
as the first argument: <br /><br />
<code><a href="#topic+print.utility.endnode.discrete">print.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+print.utility.endnode.intpol1d">print.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+print.utility.endnode.parfun1d">print.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+print.utility.endnode.intpol2d">print.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+print.utility.endnode.cond">print.utility.endnode.cond</a></code> <br />
<code><a href="#topic+print.utility.endnode.firstavail">print.utility.endnode.firstavail</a></code> <br />
<code><a href="#topic+print.utility.endnode.classcounts">print.utility.endnode.classcounts</a></code> <br />
<code><a href="#topic+print.utility.aggregation">print.utility.aggregation</a></code> <br />
<code><a href="#topic+print.utility.conversion.intpol">print.utility.conversion.intpol</a></code> <br />
<code><a href="#topic+print.utility.conversion.parfun">print.utility.conversion.parfun</a></code> <br /><br />
<code><a href="#topic+summary.utility.endnode.discrete">summary.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+summary.utility.endnode.intpol1d">summary.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+summary.utility.endnode.parfun1d">summary.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+summary.utility.endnode.intpol2d">summary.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+summary.utility.endnode.cond">summary.utility.endnode.cond</a></code> <br />
<code><a href="#topic+summary.utility.endnode.firstavail">summary.utility.endnode.firstavail</a></code> <br />
<code><a href="#topic+summary.utility.endnode.classcounts">summary.utility.endnode.classcounts</a></code> <br />
<code><a href="#topic+summary.utility.aggregation">summary.utility.aggregation</a></code> <br />
<code><a href="#topic+summary.utility.conversion.intpol">summary.utility.conversion.intpol</a></code> <br />
<code><a href="#topic+summary.utility.conversion.parfun">summary.utility.conversion.parfun</a></code> <br /><br />
<code><a href="#topic+plot.utility.endnode.discrete">plot.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+plot.utility.endnode.intpol1d">plot.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.parfun1d">plot.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.intpol2d">plot.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.cond">plot.utility.endnode.cond</a></code> <br />
<code><a href="#topic+plot.utility.endnode.firstavail">plot.utility.endnode.firstavail</a></code> <br />
<code><a href="#topic+plot.utility.endnode.classcounts">plot.utility.endnode.classcounts</a></code> <br />
<code><a href="#topic+plot.utility.aggregation">plot.utility.aggregation</a></code> <br />
<code><a href="#topic+plot.utility.conversion.intpol">plot.utility.conversion.intpol</a></code> <br />
<code><a href="#topic+plot.utility.conversion.parfun">plot.utility.conversion.parfun</a></code> <br /><br />
The value or utility function can then be evaluated by applying the 
generic function <br /><br />
<code>evaluate</code> <br /><br />
that again calls automatically the corresponding class-specific function <br /><br />
<code><a href="#topic+evaluate.utility.endnode.discrete">evaluate.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+evaluate.utility.endnode.intpol1d">evaluate.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+evaluate.utility.endnode.parfun1d">evaluate.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+evaluate.utility.endnode.intpol2d">evaluate.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+evaluate.utility.endnode.cond">evaluate.utility.endnode.cond</a></code> <br />
<code><a href="#topic+evaluate.utility.endnode.firstavail">evaluate.utility.endnode.firstavail</a></code> <br />
<code><a href="#topic+evaluate.utility.endnode.classcounts">evaluate.utility.endnode.classcounts</a></code> <br />
<code><a href="#topic+evaluate.utility.aggregation">evaluate.utility.aggregation</a></code> <br />
<code><a href="#topic+evaluate.utility.conversion.intpol">evaluate.utility.conversion.intpol</a></code> <br />
<code><a href="#topic+evaluate.utility.conversion.parfun">evaluate.utility.conversion.parfun</a></code> <br /><br />
This function requires the provision of observed or predicted attributes
of the valued system and returns the corresponding values or utilities
of all nodes of the hierarchy.
These results can then be visualized by providing them to the generic 
function  <br /><br />
<code>plot</code> <br /><br />
in addition to the definition of the objective hierarchy stored in the
variable corresponding to the highest node of the hierarchy.
Again, this function automatically calls the correct class-specific
implementation (the root of the hierarchy will be an aggregation 
or a conversion node, not an end node): <br /><br />
<code><a href="#topic+plot.utility.aggregation">plot.utility.aggregation</a></code> <br />
<code><a href="#topic+plot.utility.conversion.intpol">plot.utility.conversion.intpol</a></code> <br />
<code><a href="#topic+plot.utility.conversion.parfun">plot.utility.conversion.parfun</a></code> <br /><br />
This proceedure guarantees easy handling with the simple commands
<code>print</code>, <code>summary</code>, <code>evaluate</code>, and <code>plot</code> and
the specific function descriptions provided above are only required
to check advanced attributes.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt; 
with contributions by Nele Schuwirth &lt;nele.schuwirth@eawag.ch&gt;
</p>
<p>Maintainer: Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define discrete end node for width variability
# (attribute "widthvariability_class" with levels "high", 
# "moderate" and "none")

widthvar &lt;- 
  utility.endnode.discrete.create(
    name.node     = "width variability",
    attrib.levels = data.frame(widthvariability_class=
      c("high","moderate","none")),
    u             = c(1,0.4125,0),
    names.u       = c("u.high","u_moderate","u.none"),
    required      = FALSE,
    utility       = FALSE)

# define 1d interpolation end node for bed modification with 
# riprap
# (attribute "bedmodfract_percent" with levels from 0 to 100)

bedmod_riprap &lt;-
  utility.endnode.intpol1d.create(
    name.node   = "bed modification riprap",
    name.attrib = "bedmodfract_percent",
    range       = c(0,100),
    x           = c(0,10,30,100),
    u           = c(1,0.775,0.5625,0.24),
    required    = FALSE,
    utility     = FALSE)

# define 1d interpolation end node for bed modification with 
# other material
# (attribute "bedmodfract_percent" with levels from 0 to 100)

bedmod_other &lt;-
  utility.endnode.intpol1d.create(
    name.node   = "bed modification other",
    name.attrib = "bedmodfract_percent",
    range       = c(0,100),
    x           = c(0,10,30,100),
    u           = c(1,0.775,0.5625,0),
    required    = FALSE,
    utility     = FALSE)

# define combination end node for bed modification
# (attributes "bedmodtype_class" and "bedmodfract_percent")

bedmod &lt;-
  utility.endnode.cond.create(
    name.node     = "bed modification",
    attrib.levels = data.frame(bedmodtype_class=
      c("riprap","other")),
    nodes         = list(bedmod_riprap,bedmod_other),
    required      = FALSE,
    utility       = FALSE)

# define 1d interpolation end node for bank modification with 
# permeable material
# (attribute "bankmodfract_percent" with levels from 0 to 100)

bankmod_perm &lt;-
  utility.endnode.intpol1d.create(
    name.node   = "bank modification perm",
    name.attrib = "bankmodfract_percent",
    range       = c(0,100),
    x           = c(0,10,30,60,100),
    u           = c(1,0.8667,0.675,0.4125,0.24),
    required    = FALSE,
    utility     = FALSE)

# define 1d interpolation end node for bank modification with 
# impermeable material
# (attribute "bankmodfract_percent" with levels from 0 to 100)

bankmod_imperm &lt;-
  utility.endnode.intpol1d.create(
    name.node   = "bank modification imperm",
    name.attrib = "bankmodfract_percent",
    range       = c(0,100),
    x           = c(0,10,30,60,100),
    u           = c(1,0.775,0.5625,0.24,0),
    required    = FALSE,
    utility     = FALSE)

# define combination end node for bank modification
# (attributes "bankmodtype_class" and "bankmodfract_percent")

bankmod &lt;-
  utility.endnode.cond.create(
    name.node     = "bank modification",
    attrib.levels = data.frame(bankmodtype_class=
      c("perm","imperm")),
    nodes         = list(bankmod_perm,bankmod_imperm),
    required      = FALSE,
    utility       = FALSE)

# define 2d interpolation end node for riparian zone width
# (attributes "riparianzonewidth_m" and "riparianzonewidth_m")

riparzone_width &lt;-
  utility.endnode.intpol2d.create(
    name.node   = "riparian zone width",
    name.attrib = c("riverbedwidth_m","riparianzonewidth_m"),
    ranges      = list(c(0,16),c(0,30)),
    isolines    = list(list(x=c(0,16),y=c(0,0)),
                       list(x=c(0,2,10,16),y=c(5,5,15,15)),
                       list(x=c(0,16),y=c(15,15)),
                       list(x=c(0,16),y=c(30,30))),
    u           = c(0.0,0.6,1.0,1.0),
    lead         = 1,
    utility      = FALSE)

# define discrete end node for riparian zone vegetation
# (attriute "riparianzoneveg_class" with levels "natural", 
# "seminatural" and "artificial")

riparzone_veg &lt;-
  utility.endnode.discrete.create(
    name.node     = "riparian zone veg.",
    attrib.levels = data.frame(riparianzoneveg_class=
      c("natural","seminatural","artificial")),
    u             = c(1,0.5625,0),
    required      = FALSE,
    utility       = FALSE)

# define aggregation node for riparian zone

riparzone &lt;-
  utility.aggregation.create(
    name.node = "riparian zone",
    nodes     = list(riparzone_width,riparzone_veg),
    name.fun  = "utility.aggregate.cobbdouglas",
    par       = c(1,1),
    required  = FALSE)

# define aggregation node for ecomorphological state

morphol &lt;-
  utility.aggregation.create(
    name.node = "ecomorphology",
    nodes     = list(widthvar,bedmod,bankmod,riparzone),
    name.fun  = "utility.aggregate.mix",
    par       = c(0.25,0.25,0.25,0.25,0,0,1),
    names.par = c("w_widthvar","w_bedmod","w_bankmod","w_riparzone",
                  "w_add","w_min","w_cobbdouglas"),
    required  = TRUE)

# print individual definitions

print(widthvar)
print(bedmod)

# print all definitions

print(morphol)

# plot objectives hierarchy with attributes

plot(morphol)

# plot individual nodes:

plot(widthvar)
plot(widthvar,par=c(u_moderate=0.2))
plot(bedmod_other)
plot(bankmod)
#plot(riparzone_width)   # too slow for package installation

# plot selected node definitions of a hierarchy

plot(morphol,type="nodes",nodes=c("width variability",
                                  "bed modification other",
                                  "bank modification"))

# evaluate value function for data sets and plot colored hierarchies
# and table

attrib_channelized &lt;- data.frame(widthvariability_class = "none",
                                 bedmodtype_class       = "riprap",
                                 bedmodfract_percent    = 50,
                                 bankmodtype_class      = "imperm",
                                 bankmodfract_percent   = 70,
                                 riverbedwidth_m        = 10,
                                 riparianzonewidth_m    = 5,
                                 riparianzoneveg_class  = "seminatural")
attrib_rehab       &lt;- data.frame(widthvariability_class = "high",
                                 bedmodtype_class       = "riprap",
                                 bedmodfract_percent    = 50,
                                 bankmodtype_class      = "imperm",
                                 bankmodfract_percent   = 20,
                                 riverbedwidth_m        = 15,
                                 riparianzonewidth_m    = 15,
                                 riparianzoneveg_class  = "natural")

res_channelized     &lt;- evaluate(morphol,attrib=attrib_channelized)
res_channelized_add &lt;- evaluate(morphol,attrib=attrib_channelized,
                                par=c(w_add=1,w_min=0,w_cobbdouglas=0))
res_rehab           &lt;- evaluate(morphol,attrib=attrib_rehab)
res_both            &lt;- rbind(res_channelized,res_rehab)
rownames(res_both)  &lt;- c("channelized","rehabilitated")

plot(morphol,u=res_channelized)
plot(morphol,u=res_channelized_add)
plot(morphol,u=res_rehab)
plot(morphol,u=res_rehab,uref=res_channelized)
plot(morphol,u=res_both,type="table",plot.val=FALSE)
plot(morphol,u=res_both,type="table",plot.val=TRUE,print.val=FALSE)
plot(morphol,u=res_both,uref=res_channelized,type="table",plot.val=FALSE)

# consideration of uncertain attribute levels 
# (Higher uncertainty for predicted state after rehabilitation than for 
# observed channelized state.
# Note that the normal distributions lead to a small probability of attribute 
# levels beyond the range for which the value function is defined. This could
# be corrected for by truncating or choosing another distribution. We keep 
# those values to demonstrate that this leads to warnings when evaluating the
# value function for these attribute levels,):

sampsize &lt;- 1000

attrib_channelized_unc &lt;- data.frame(
  widthvariability_class = rep("high",sampsize),
  bedmodtype_class       = rep("riprap",sampsize),
  bedmodfract_percent    = rnorm(sampsize,mean=50,sd=5),
  bankmodtype_class      = rep("imperm",sampsize),
  bankmodfract_percent   = rnorm(sampsize,mean=70,sd=5),
  riverbedwidth_m        = rep(10,sampsize),
  riparianzonewidth_m    = rep(5,sampsize),
  riparianzoneveg_class  = c("seminatural","artificial")[rbinom(sampsize,1,0.5)+1])

attrib_rehab_unc &lt;- data.frame(
  widthvariability_class = c("moderate","high")[rbinom(sampsize,1,0.5)+1],
  bedmodtype_class       = rep("riprap",sampsize),
  bedmodfract_percent    = rnorm(sampsize,mean=50,sd=15),
  bankmodtype_class      = rep("imperm",sampsize),
  bankmodfract_percent   = rnorm(sampsize,mean=20,sd=5),
  riverbedwidth_m        = rnorm(sampsize,mean=10,sd=2),
  riparianzonewidth_m    = rnorm(sampsize,mean=10,sd=2),
  riparianzoneveg_class  = c("natural","seminatural")[rbinom(sampsize,1,0.5)+1])

res_channelized_unc &lt;- evaluate(morphol,attrib=attrib_channelized_unc)
res_rehab_unc       &lt;- evaluate(morphol,attrib=attrib_rehab_unc)

plot(morphol,u=res_channelized_unc)
#plot(morphol,u=res_rehab_unc)
plot(morphol,u=res_rehab_unc,uref=res_channelized_unc)
plot(morphol,u=list(channelized=res_channelized_unc,rehabilitated=res_rehab_unc),
     type="table")
plot(morphol,u=list(channelized=res_channelized_unc,rehabilitated=res_rehab_unc),
     type="table",nodes=c("ecomorphology","riparian zone"))
plot(morphol,u=list(channelized=res_channelized_unc,rehabilitated=res_rehab_unc),
     type="table",levels=2)
plot(morphol,u=list(channelized=res_channelized_unc,rehabilitated=res_rehab_unc),
     uref=res_channelized_unc,
     type="table")
</code></pre>

<hr>
<h2 id='utility.aggregate.add'>Additive aggregation of values or utilities</h2><span id='topic+utility.aggregate.add'></span>

<h3>Description</h3>

<p>Function to perform an additive aggregation (weighted mean) 
of values or utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.add(u, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.add_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.add_+3A_par">par</code></td>
<td>

<p>numeric vector of weights for calculating the weighted mean of the
values provided in the argument <code>u</code>.
The weights need not be normalized, they will be normalized before use.
In case of missing values in the vector <code>u</code>, the weights of the
non-missing components will be rescaled to sum to unity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is defined by
</p>
<p style="text-align: center;"><code class="reqn">u = \sum_{i=1}^n w_i u_i</code>
</p>

<p>The following figure shows examples of the behaviour of this aggregation function for the two-dimensional case:<br />
<img src="../help/figures/aggregationadd.png" width=80% alt="aggregationadd.png" />

</p>


<h3>Value</h3>

<p>numeric value representing the weighted mean of the components 
of <code>u</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.add(c(0.2,0.8), par=c(1,1))
</code></pre>

<hr>
<h2 id='utility.aggregate.addmin'>Mixture of additive and minimum aggregation</h2><span id='topic+utility.aggregate.addmin'></span>

<h3>Description</h3>

<p>Function to perform a mixture of additive and minimum aggregation.
The parameter vector must contain the weights for additive aggregation 
followed by the weight of additive aggregation.
The weight for minimum aggregation is then unity minus the weight for 
additive aggregation.
If this additional weight is zero, we return to minimum aggregation,
if it is unity, we will have additive aggregation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.addmin(u, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.addmin_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.addmin_+3A_par">par</code></td>
<td>

<p>numeric vector of weights for additive aggregation appended by the weight for additive aggregation.
The weight for minimum aggregation is then unity minus the weight for 
additive aggregation.
If this additional weight is zero, we return to minimum aggregation,
if it is unity, we will have additive aggregation.
The weights for additive aggregation need not be normalized, they will be 
normalized before use.
In case of missing values in the vector <code>u</code>, the weights of the
non-missing components will be rescaled to sum to unity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is a mixture of the functions 
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> and
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code>.
The following figure shows examples of the behaviour of this aggregation function for the two-dimensional case:<br />
<img src="../help/figures/aggregationaddmin.png" width=80% alt="aggregationaddmin.png" />

</p>


<h3>Value</h3>

<p>The function returns the aggregated value or utility.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.addmin(c(0.2,0.8), par=c(1,1,0.5))
</code></pre>

<hr>
<h2 id='utility.aggregate.addpower'>Additive power aggregation of values or utilities</h2><span id='topic+utility.aggregate.addpower'></span>

<h3>Description</h3>

<p>Function to perform a weighted power aggregation of values or utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.addpower(u, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.addpower_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.addpower_+3A_par">par</code></td>
<td>

<p>numeric vector of weights appended by the power of the aggregation function (see details below).
The weights need not be normalized, they will be normalized before use.
In case of missing values in the vector <code>u</code>, the weights of the
non-missing components will be rescaled to sum to unity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is defined by
</p>
<p style="text-align: center;"><code class="reqn">u = \left( \sum_{i=1}^n w_i u_i^{\alpha} \right)^{1/{\alpha}}</code>
</p>

<p>where <code class="reqn">\alpha</code> is the last parameter appended to the weights.<br />
The following figure shows examples of the behaviour of this aggregation function for the two-dimensional case:<br />
<img src="../help/figures/aggregationaddpower.png" width=80% alt="aggregationaddpower.png" />

</p>


<h3>Value</h3>

<p>The function returns the aggregated value or utility.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.addpower(c(0.2,0.8), par=c(1,1,2))
</code></pre>

<hr>
<h2 id='utility.aggregate.addsplitpower'>Splitted weighted power aggregation of values or utilities</h2><span id='topic+utility.aggregate.addsplitpower'></span>

<h3>Description</h3>

<p>Function to perform a splitted weighted power aggregation of values or utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.addsplitpower(u, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.addsplitpower_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.addsplitpower_+3A_par">par</code></td>
<td>

<p>numeric vector of weights appended by the power of the aggregation function and the position of the split between concave and convex transformation (see details below).
The weights need not be normalized, they will be normalized before use.
In case of missing values in the vector <code>u</code>, the weights of the
non-missing components will be rescaled to sum to unity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is defined by
</p>
<p style="text-align: center;"><code class="reqn">u = g^{-1}\left( \sum_{i=1}^n w_i g(u_i) \right)</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">g(v) = \left\{ \begin{array}{ll} s \left( \displaystyle \frac{v}{s} \right)^{\alpha} &amp; \mbox{for } v \le s\\ 1 - (1-s) \left( \displaystyle \frac{1-v}{1-s} \right)^{\alpha} &amp; \mbox{for } v \ge s \end{array} \right.</code>
</p>

<p style="text-align: center;"><code class="reqn">g^{-1}(v) = \left\{ \begin{array}{ll} s \left( \displaystyle \frac{v}{s} \right)^{1/\alpha} &amp; \mbox{for } v \le s\\ 1 - (1-s) \left( \displaystyle \frac{1-v}{1-s} \right)^{1/\alpha} &amp; \mbox{for } v \ge s \end{array} \right.</code>
</p>

<p>where <code class="reqn">\alpha</code> and <code class="reqn">s</code> are the two last parameters appended to the weights.<br />
The following figure shows examples of the behaviour of this aggregation function for the two-dimensional case (the split parameter, <code class="reqn">s</code>, is chosen to be 1/2 in all four plots):<br />
<img src="../help/figures/aggregationaddsplitpower.png" width=80% alt="aggregationaddsplitpower.png" />

</p>


<h3>Value</h3>

<p>The function returns the aggregated value or utility.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.addsplitpower(c(0.2,0.8), par=c(1,1,2,0.5))
</code></pre>

<hr>
<h2 id='utility.aggregate.bonusmalus'>Bonus-malus aggregation of values or utilities</h2><span id='topic+utility.aggregate.bonusmalus'></span>

<h3>Description</h3>

<p>Function to perform an aggregation of valus or utilities that considers some of the 
inputs only as bonus (only considered if value is larger then the aggregated value
of the non bonus or malus input) or malus (only considered if value is smaller then 
the aggregated value of the non bonus or malus input).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.bonusmalus(u,par,def.agg="utility.aggregate.add")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.bonusmalus_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.bonusmalus_+3A_par">par</code></td>
<td>

<p>numeric vector combining the parameters of the default aggregation technique
(see argument <code>def.agg</code>) with those specifying the bonus-malus behaviour.
The arguments of <code>def.agg</code>) must match the number of arguments of this
function for the number of inputs reduced to those that are not treated as 
bonus or malus.
This parameter vector is then appended by the parameters characterizing the
bonus-malus behavior. 
This is a parameter vector of the same length as the number of sub-objectives.
Its elements must be NA for the sub-objectives onsidered for the default aggregation
technique, the weights relative to the aggregated value of the non-bonus and non-malus sub-objectives for the sub-objectives to be considered as bonus objectives, and the weights with a negative sign for those to be considered as malus objectives.
Note that the weights of the bonus or malus attributes are relative to the 
aggregated result of the non-bonus and non-malus inputs and the negative signs will only be used for identifying malus sub-objectives and will be eliminated when calculating the weighted mean.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.bonusmalus_+3A_def.agg">def.agg</code></td>
<td>

<p>(optional) character string specifying the name of the function used for aggregation
of the non-bonus and non-malus sub-objectives. 
Note that for use of this aggregation technique in the function 
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, this argument has to be specified as the
input argument <code>def.agg</code> (default aggregation) unless it should be additive (default).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is defined by
</p>
<p style="text-align: center;"><code class="reqn">u = \frac{\displaystyle u^{\mathrm{agg}}_{i \notin b,i \notin m} + \sum_{\begin{array}{l}i \in b \wedge u_i &gt; u^{\mathrm{agg}}_{i \notin b,i \notin m}\\i \in m \wedge u_i &lt; u^{\mathrm{agg}}_{i \notin b,i \notin m}\end{array}}\mid w_i \mid u_i}{\displaystyle 1 + \sum_{\begin{array}{l}i \in b \wedge u_i &gt; u^{\mathrm{agg}}_{i \notin b,i \notin m}\\i \in m \wedge u_i &lt; u^{\mathrm{agg}}_{i \notin b,i \notin m}\end{array}}\mid w_i \mid}</code>
</p>

<p>The following figure shows examples of the behaviour of this aggregation function for the two-dimensional case:<br />
<img src="../help/figures/aggregationbonusmalus.png" width=80% alt="aggregationbonusmalus.png" />

</p>


<h3>Value</h3>

<p>The function returns the aggregated value or utility.
</p>


<h3>Note</h3>

<p>This is the same function as <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code>
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.bonusmalus(c(0.2,0.8), par=c(1,NA,1))
utility.aggregate.bonusmalus(c(0.2,0.8), par=c(1,1,NA))
utility.aggregate.bonusmalus(c(0.2,0.8), par=c(1,NA,-1))
utility.aggregate.bonusmalus(c(0.2,0.8), par=c(1,-1,NA))
</code></pre>

<hr>
<h2 id='utility.aggregate.cobbdouglas'>Cobb-Douglas aggregation of values or utilities</h2><span id='topic+utility.aggregate.cobbdouglas'></span>

<h3>Description</h3>

<p>Function to perform a Cobb-Douglas aggregation 
(weighted geometric mean) of values or utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.cobbdouglas(u, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.cobbdouglas_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.cobbdouglas_+3A_par">par</code></td>
<td>

<p>numeric vector of weights for calculating the weighted geometric mean 
of the values provided in the argument <code>u</code>.
The weights need not be normalized, they will be normalized before use.
In case of missing values in the vector <code>u</code>, the weights of the
non-missing components will be rescaled to sum to unity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is defined by
</p>
<p style="text-align: center;"><code class="reqn">u = \prod_{i=1}^n u_i^{w_i}</code>
</p>

<p>The following figure shows examples of the behaviour of this aggregation function and its generalization to <code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for the two-dimensional case:<br />
<img src="../help/figures/aggregationgeo.png" width=80% alt="aggregationgeo.png" />

</p>


<h3>Value</h3>

<p>The function returns the aggregated value or utility.
</p>


<h3>Note</h3>

<p>This is the same function as <code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code>
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.cobbdouglas(c(0.2,0.8), par=c(1,1))
</code></pre>

<hr>
<h2 id='utility.aggregate.geo'>Geometric aggregation of values or utilities</h2><span id='topic+utility.aggregate.geo'></span>

<h3>Description</h3>

<p>Function to perform a geometric aggregation 
(weighted geometric mean) of values or utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.geo(u, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.geo_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.geo_+3A_par">par</code></td>
<td>

<p>numeric vector of weights for calculating the weighted geometric mean 
of the values provided in the argument <code>u</code>.
The weights need not be normalized, they will be normalized before use.
In case of missing values in the vector <code>u</code>, the weights of the
non-missing components will be rescaled to sum to unity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is defined by
</p>
<p style="text-align: center;"><code class="reqn">u = \prod_{i=1}^n u_i^{w_i}</code>
</p>

<p>The following figure shows examples of the behaviour of this aggregation function and its generalization to <code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for the two-dimensional case:<br />
<img src="../help/figures/aggregationgeo.png" width=80% alt="aggregationgeo.png" />

</p>


<h3>Value</h3>

<p>The function returns the aggregated value or utility.
</p>


<h3>Note</h3>

<p>This is the same function as <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code>
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.geo(c(0.2,0.8), par=c(1,1))
</code></pre>

<hr>
<h2 id='utility.aggregate.geooff'>Geometric aggregation of values or utilities with offset</h2><span id='topic+utility.aggregate.geooff'></span>

<h3>Description</h3>

<p>Function to perform a geometric aggregation 
(weighted geometric mean) of values or utilities
with offset.
The offset is added to the arguments and subtracted from the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.geooff(u, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.geooff_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.geooff_+3A_par">par</code></td>
<td>

<p>numeric vector of weights appended by an offset for calculating the 
weighted geometric mean minus an offset of the values provided in the 
argument <code>u</code> plus the offset.
The weights need not be normalized, they will be normalized before use.
In case of missing values in the vector <code>u</code>, the weights of the
non-missing components will be rescaled to sum to unity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is defined by
</p>
<p style="text-align: center;"><code class="reqn">u = \prod_{i=1}^n (u_i+\delta)^{w_i} - \delta</code>
</p>

<p>where <code class="reqn">\delta</code> is the last parameter appended to the weights.<br />
The following figure shows examples of the behaviour of this aggregation function and its special case <code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> for the two-dimensional case:<br />
<img src="../help/figures/aggregationgeo.png" width=80% alt="aggregationgeo.png" />

</p>


<h3>Value</h3>

<p>The function returns the aggregated value or utility.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.geooff(c(0.2,0.8), par=c(1,1,0.1))
</code></pre>

<hr>
<h2 id='utility.aggregate.harmo'>Harmonic aggregation of values or utilities</h2><span id='topic+utility.aggregate.harmo'></span>

<h3>Description</h3>

<p>Function to perform a harmonic aggregation 
(weighted harmonic mean) of values or utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.harmo(u, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.harmo_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.harmo_+3A_par">par</code></td>
<td>

<p>numeric vector of weights for calculating the weighted harmonic mean 
of the values provided in the argument <code>u</code>.
The weights need not be normalized, they will be normalized before use.
In case of missing values in the vector <code>u</code>, the weights of the
non-missing components will be rescaled to sum to unity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is defined by
</p>
<p style="text-align: center;"><code class="reqn">u = \frac{1}{\displaystyle \sum_{i=1}^n \frac{w_i}{u_i}}</code>
</p>

<p>The following figure shows examples of the behaviour of this aggregation function and its generalization to <code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for the two-dimensional case:<br />
<img src="../help/figures/aggregationharmo.png" width=80% alt="aggregationharmo.png" />

</p>


<h3>Value</h3>

<p>The function returns the aggregated value or utility.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.harmo(c(0.2,0.8), par=c(1,1))
</code></pre>

<hr>
<h2 id='utility.aggregate.harmooff'>Harmonic aggregation of values or utilities with offset</h2><span id='topic+utility.aggregate.harmooff'></span>

<h3>Description</h3>

<p>Function to perform a harmonic aggregation 
(weighted harmonic mean) of values or utilities
with offset.
The offset is added to the arguments and subtracted from the result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.harmooff(u, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.harmooff_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.harmooff_+3A_par">par</code></td>
<td>

<p>numeric vector of weights appended by an offset for calculating the 
weighted harmonic mean minus an offset of the values provided in the 
argument <code>u</code> plus the offset.
The weights need not be normalized, they will be normalized before use.
In case of missing values in the vector <code>u</code>, the weights of the
non-missing components will be rescaled to sum to unity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is defined by
</p>
<p style="text-align: center;"><code class="reqn">u = \frac{1}{\displaystyle \sum_{i=1}^n \frac{w_i}{u_i+\delta}} - \delta</code>
</p>

<p>where <code class="reqn">\delta</code> is the last parameter appended to the weights.<br />
The following figure shows examples of the behaviour of this aggregation function and its special case <code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for the two-dimensional case:<br />
<img src="../help/figures/aggregationharmo.png" width=80% alt="aggregationharmo.png" />

</p>


<h3>Value</h3>

<p>The function returns the aggregated value or utility.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.harmooff(c(0.2,0.8), par=c(1,1,0.1))
</code></pre>

<hr>
<h2 id='utility.aggregate.max'>Maximum aggregation of values or utilities</h2><span id='topic+utility.aggregate.max'></span>

<h3>Description</h3>

<p>Function to perform a maximum aggregation of values or utilities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.max(u, par = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.max_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.max_+3A_par">par</code></td>
<td>

<p>unused argument used for compatibility with other aggregation techniques
that require parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is defined by
</p>
<p style="text-align: center;"><code class="reqn">u = \max_{i=1}^n u_i</code>
</p>

<p>The following figure shows the behaviour of this aggregation function for the two-dimensional case:<br />
<img src="../help/figures/aggregationmax.png" width=40% alt="aggregationmax.png" />

</p>


<h3>Value</h3>

<p>maximum of the components of <code>u</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.max(c(0.2,0.8))
</code></pre>

<hr>
<h2 id='utility.aggregate.min'>Minimum aggregation of values or utilities</h2><span id='topic+utility.aggregate.min'></span>

<h3>Description</h3>

<p>Function to perform a minimum aggregation of values or utilities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.min(u, par = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.min_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.min_+3A_par">par</code></td>
<td>

<p>unused argument used for compatibility with other aggregation techniques
that require parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is defined by
</p>
<p style="text-align: center;"><code class="reqn">u = \min_{i=1}^n u_i</code>
</p>

<p>The following figure shows the behaviour of this aggregation function for the two-dimensional case:<br />
<img src="../help/figures/aggregationmin.png" width=40% alt="aggregationmin.png" />

</p>


<h3>Value</h3>

<p>minimum of the components of <code>u</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.min(c(0.2,0.8))
</code></pre>

<hr>
<h2 id='utility.aggregate.mix'>Mixed aggregation of values and utilities</h2><span id='topic+utility.aggregate.mix'></span>

<h3>Description</h3>

<p>Function to perform a mixed aggregation of values and utilities.
The mixture consists of a weighted mean of the additive, minimum
and geometric aggregation techniques.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.mix(u, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.mix_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.mix_+3A_par">par</code></td>
<td>

<p>numeric vector of weights for calculating the weighted mean of the
values provided in the argument <code>u</code> followed by the three 
weights of the additive, minimum and geometric aggregation 
techniques.
The weights need not be normalized, they will be normalized before use.
In case of missing values in the vector <code>u</code>, the weights of the
non-missing components will be rescaled to sum to unity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is a mixture of the functions 
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code>,
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code>, and
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code>.
The following figure shows examples of the behaviour of this aggregation function for the two-dimensional case:<br />
<img src="../help/figures/aggregationmix.png" width=80% alt="aggregationmix.png" />

</p>


<h3>Value</h3>

<p>The function returns the aggregated value or utility.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.mix(c(0.2,0.8),par=c(1,1 , 1,0,0))
utility.aggregate.mix(c(0.2,0.8),par=c(1,1 , 0,1,0))
utility.aggregate.mix(c(0.2,0.8),par=c(1,1 , 0,0,1))
utility.aggregate.mix(c(0.2,0.8),par=c(1,1 , 1,1,1))
</code></pre>

<hr>
<h2 id='utility.aggregate.mult'>Multiplicative aggregation of values or utilities</h2><span id='topic+utility.aggregate.mult'></span>

<h3>Description</h3>

<p>Function to perform a multiplicative aggregation of values or utilities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.mult(u, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.mult_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.mult_+3A_par">par</code></td>
<td>

<p>numeric vector of weights for calculating the multiplicative
combination of the values provided in the argument <code>u</code>.
Note that for this aggregation technique, the result depends on the sum of the weights that need not be unity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To derive the aggregated value, we first solve the implicit equation
</p>
<p style="text-align: center;"><code class="reqn">k + 1 = \prod_{i=1}^n (1 + k w_i)</code>
</p>

<p>for <code class="reqn">k</code> and then calculate the aggregated value as
</p>
<p style="text-align: center;"><code class="reqn">u = \frac{\displaystyle \prod_{i=1}^n (1 + k w_i u_i)}{k}</code>
</p>

<p>See Keeney and Raiffa, Decisions with multiple objectives, 1976, pp. 307, 347-348 for details.<br />
The following figure shows examples of the behaviour of this aggregation function for the two-dimensional case:<br />
<img src="../help/figures/aggregationmult.png" width=80% alt="aggregationmult.png" />

</p>


<h3>Value</h3>

<p>numeric value corresponding to the multiplicative aggregation
of the values provided in the vector <code>u</code>.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.mult(c(0.2,0.8),par=c(0.3,0.3))
</code></pre>

<hr>
<h2 id='utility.aggregate.revaddpower'>Reverse additive power aggregation of values or utilities</h2><span id='topic+utility.aggregate.revaddpower'></span>

<h3>Description</h3>

<p>Function to perform a reverse weighted power aggregation of values or utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.revaddpower(u, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.revaddpower_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.revaddpower_+3A_par">par</code></td>
<td>

<p>numeric vector of weights appended by the power of the aggregation function (see details below).
The weights need not be normalized, they will be normalized before use.
In case of missing values in the vector <code>u</code>, the weights of the
non-missing components will be rescaled to sum to unity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is defined by
</p>
<p style="text-align: center;"><code class="reqn">u = 1 - \left( \sum_{i=1}^n w_i (1-u_i)^{\alpha} \right)^{1/{\alpha}}</code>
</p>

<p>where <code class="reqn">\alpha</code> is the last parameter appended to the weights.<br />
The following figure shows examples of the behaviour of this aggregation function for the two-dimensional case:<br />
<img src="../help/figures/aggregationrevaddpower.png" width=80% alt="aggregationrevaddpower.png" />

</p>


<h3>Value</h3>

<p>The function returns the aggregated value or utility.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.revaddpower(c(0.2,0.8), par=c(1,1,2))
</code></pre>

<hr>
<h2 id='utility.aggregate.revaddsplitpower'>Reverse splitted additive power aggregation of values or utilities</h2><span id='topic+utility.aggregate.revaddsplitpower'></span>

<h3>Description</h3>

<p>Function to perform a reverse splitted weighted power aggregation of values or utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.revaddsplitpower(u, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.revaddsplitpower_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.revaddsplitpower_+3A_par">par</code></td>
<td>

<p>numeric vector of weights appended by the power of the aggregation function and the position of the split between concave and convex transformation (see details below).
The weights need not be normalized, they will be normalized before use.
In case of missing values in the vector <code>u</code>, the weights of the
non-missing components will be rescaled to sum to unity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is defined by
</p>
<p style="text-align: center;"><code class="reqn">u = 1 - g^{-1}\left( \sum_{i=1}^n w_i g(1-u_i) \right)</code>
</p>

<p>with
</p>
<p style="text-align: center;"><code class="reqn">g(v) = \left\{ \begin{array}{ll} s \left( \displaystyle \frac{v}{s} \right)^{\alpha} &amp; \mbox{for } v \le s\\ 1 - (1-s) \left( \displaystyle \frac{1-v}{1-s} \right)^{\alpha} &amp; \mbox{for } v \ge s \end{array} \right.</code>
</p>

<p style="text-align: center;"><code class="reqn">g^{-1}(v) = \left\{ \begin{array}{ll} s \left( \displaystyle \frac{v}{s} \right)^{1/\alpha} &amp; \mbox{for } v \le s\\ 1 - (1-s) \left( \displaystyle \frac{1-v}{1-s} \right)^{1/\alpha} &amp; \mbox{for } v \ge s \end{array} \right.</code>
</p>

<p>where <code class="reqn">\alpha</code> and <code class="reqn">s</code> are the two last parameters appended to the weights.<br />
The following figure shows examples of the behaviour of this aggregation function for the two-dimensional case (the split parameter, <code class="reqn">s</code>, is chosen to be 1/2 in all four plots):<br />
<img src="../help/figures/aggregationrevaddsplitpower.png" width=80% alt="aggregationrevaddsplitpower.png" />

</p>


<h3>Value</h3>

<p>The function returns the aggregated value or utility.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.revaddsplitpower(c(0.2,0.8,0.5), par=c(1,1,2,0.5))
</code></pre>

<hr>
<h2 id='utility.aggregate.revgeo'>Reverse geometric aggregation of values or utilities</h2><span id='topic+utility.aggregate.revgeo'></span>

<h3>Description</h3>

<p>Function to perform a reverse geometric aggregation 
(unity minus the weighted geometric mean of unity minus the arguments) 
of values or utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.revgeo(u, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.revgeo_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.revgeo_+3A_par">par</code></td>
<td>

<p>numeric vector of weights for calculating the reverse weighted geometric mean 
of the values provided in the argument <code>u</code>.
The weights need not be normalized, they will be normalized before use.
In case of missing values in the vector <code>u</code>, the weights of the
non-missing components will be rescaled to sum to unity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is defined by
</p>
<p style="text-align: center;"><code class="reqn">u = 1 - \prod_{i=1}^n (1-u_i)^{w_i}</code>
</p>

<p>The following figure shows examples of the behaviour of this aggregation function and its generalization to <code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for the two-dimensional case:<br />
<img src="../help/figures/aggregationrevgeo.png" width=80% alt="aggregationrevgeo.png" />

</p>


<h3>Value</h3>

<p>The function returns the aggregated value or utility.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.revgeo(c(0.2,0.8), par=c(1,1))
</code></pre>

<hr>
<h2 id='utility.aggregate.revgeooff'>Reverse geometric aggregation of values or utilities with offset</h2><span id='topic+utility.aggregate.revgeooff'></span>

<h3>Description</h3>

<p>Function to perform a reverse geometric aggregation 
(unity minus the weighted geometric mean of unity minus the arguments) 
of values or utilities with offset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.revgeooff(u, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.revgeooff_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.revgeooff_+3A_par">par</code></td>
<td>

<p>numeric vector of weights for calculating the reverse weighted geometric mean 
of the values provided in the argument <code>u</code>.
The weights need not be normalized, they will be normalized before use.
In case of missing values in the vector <code>u</code>, the weights of the
non-missing components will be rescaled to sum to unity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is defined by
</p>
<p style="text-align: center;"><code class="reqn">u = 1 - \prod_{i=1}^n (1-u_i+\delta)^{w_i} + \delta</code>
</p>

<p>where <code class="reqn">\delta</code> is the last parameter appended to the weights.<br />
The following figure shows examples of the behaviour of this aggregation function and its special case <code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for the two-dimensional case:<br />
<img src="../help/figures/aggregationrevgeo.png" width=80% alt="aggregationrevgeo.png" />

</p>


<h3>Value</h3>

<p>The function returns the aggregated value or utility.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.revgeooff(c(0.2,0.8), par=c(1,1,0.1))
</code></pre>

<hr>
<h2 id='utility.aggregate.revharmo'>Reverse harmonic aggregation of values or utilities</h2><span id='topic+utility.aggregate.revharmo'></span>

<h3>Description</h3>

<p>Function to perform a reverse harmonic aggregation 
(unity minus the weighted harmonic mean of unity minus the arguments) 
of values or utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.revharmo(u, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.revharmo_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.revharmo_+3A_par">par</code></td>
<td>

<p>numeric vector of weights for calculating the reverse weighted harmonic mean 
of the values provided in the argument <code>u</code>.
The weights need not be normalized, they will be normalized before use.
In case of missing values in the vector <code>u</code>, the weights of the
non-missing components will be rescaled to sum to unity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is defined by
</p>
<p style="text-align: center;"><code class="reqn">u = 1 - \frac{1}{\displaystyle \sum_{i=1}^n \frac{w_i}{1-u_i}}</code>
</p>

<p>The following figure shows examples of the behaviour of this aggregation function and its generalization to <code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for the two-dimensional case:<br />
<img src="../help/figures/aggregationrevharmo.png" width=80% alt="aggregationrevharmo.png" />

</p>


<h3>Value</h3>

<p>The function returns the aggregated value or utility.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.revharmo(c(0.2,0.8), par=c(1,1))
</code></pre>

<hr>
<h2 id='utility.aggregate.revharmooff'>Reverse harmonic aggregation of values or utilities with offset</h2><span id='topic+utility.aggregate.revharmooff'></span>

<h3>Description</h3>

<p>Function to perform a reverse harmonic aggregation 
(unity minus the weighted harmonic mean of unity minus the arguments) 
of values or utilities with offset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregate.revharmooff(u, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregate.revharmooff_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregate.revharmooff_+3A_par">par</code></td>
<td>

<p>numeric vector of weights for calculating the reverse weighted harmonic mean 
of the values provided in the argument <code>u</code>.
The weights need not be normalized, they will be normalized before use.
In case of missing values in the vector <code>u</code>, the weights of the
non-missing components will be rescaled to sum to unity.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The aggregation function is defined by
</p>
<p style="text-align: center;"><code class="reqn">u = 1 - \frac{1}{\displaystyle \sum_{i=1}^n \frac{w_i}{1-u_i+\delta}} + \delta</code>
</p>

<p>where <code class="reqn">\delta</code> is the last parameter appended to the weights.<br />
The following figure shows examples of the behaviour of this aggregation function and its special case <code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for the two-dimensional case:<br />
<img src="../help/figures/aggregationrevharmo.png" width=80% alt="aggregationrevharmo.png" />

</p>


<h3>Value</h3>

<p>The function returns the aggregated value or utility.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Constructor of aggregation node: <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code> <br /><br />
Aggregation techniques provided by uncsim: <br /><br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.aggregate.revharmooff(c(0.2,0.8), par=c(1,1,0.1))
</code></pre>

<hr>
<h2 id='utility.aggregation.create'>Construct an aggregation node</h2><span id='topic+utility.aggregation.create'></span>

<h3>Description</h3>

<p>Function to construct an aggregation node for value or utlity functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.aggregation.create(name.node, 
                           nodes, 
                           name.fun, 
                           par, 
                           names.par    = rep(NA, length(par)), 
                           required     = FALSE, 
                           num.required = 1, 
                           col          = "black", 
                           shift.levels = 0,
                           add.arg.fun  = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.aggregation.create_+3A_name.node">name.node</code></td>
<td>

<p>name of the node to be constructed as a character string.
</p>
</td></tr>
<tr><td><code id="utility.aggregation.create_+3A_nodes">nodes</code></td>
<td>

<p>list of nodes to be aggregated.
</p>
</td></tr>
<tr><td><code id="utility.aggregation.create_+3A_name.fun">name.fun</code></td>
<td>

<p>name of the function to be used for aggregation.
This function must accept the arguments <code>u</code> and <code>par</code> which
pass a vector of values or utilities to be aggregated and the parameters
of the function, respectively.
The function can have an additional argument specified below as <code>add.arg.fun</code>.
The function must then return the corresponding aggregated value or utility.<br />
Examples of functions provided by the package are <br />
<code><a href="#topic+utility.aggregate.add">utility.aggregate.add</a></code> for additive aggregation (weighted arithmetic mean), <br />
<code><a href="#topic+utility.aggregate.min">utility.aggregate.min</a></code> for minimum aggregation, <br />
<code><a href="#topic+utility.aggregate.max">utility.aggregate.max</a></code> for maximum aggregation, <br />
<code><a href="#topic+utility.aggregate.geo">utility.aggregate.geo</a></code> or <code><a href="#topic+utility.aggregate.cobbdouglas">utility.aggregate.cobbdouglas</a></code> for geometric or Cobb-Douglas aggregation (weighted geometric mean), <br />
<code><a href="#topic+utility.aggregate.geooff">utility.aggregate.geooff</a></code> for geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revgeo">utility.aggregate.revgeo</a></code> for reverse geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.revgeooff">utility.aggregate.revgeooff</a></code> for reverse geometric aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.harmo">utility.aggregate.harmo</a></code> for harmonic aggregation (weighted harmonic mean), <br />
<code><a href="#topic+utility.aggregate.harmooff">utility.aggregate.harmooff</a></code> for harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.revharmo">utility.aggregate.revharmo</a></code> for reverse harmonic aggregation, <br />
<code><a href="#topic+utility.aggregate.revharmooff">utility.aggregate.revharmooff</a></code> for reverse harmonic aggregation with offset, <br />
<code><a href="#topic+utility.aggregate.mult">utility.aggregate.mult</a></code> for multiplicative aggregation, <br />
<code><a href="#topic+utility.aggregate.mix">utility.aggregate.mix</a></code> for a mixture of additive, minimum, and geometric aggregation, <br />
<code><a href="#topic+utility.aggregate.addmin">utility.aggregate.addmin</a></code> for a mixture of additive and minimum aggregation. <br />
<code><a href="#topic+utility.aggregate.addpower">utility.aggregate.addpower</a></code> for additive power aggregation (weighted power mean), <br />
<code><a href="#topic+utility.aggregate.revaddpower">utility.aggregate.revaddpower</a></code> for reverse additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.addsplitpower">utility.aggregate.addsplitpower</a></code> for splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.revaddsplitpower">utility.aggregate.revaddsplitpower</a></code> for reverse splitted additive power aggregation, <br />
<code><a href="#topic+utility.aggregate.bonusmalus">utility.aggregate.bonusmalus</a></code> for an aggregation technique that considers some of the values or utilities of sub-objectives only as bonus or malus. <br />
Follow the links for the aggregation functions for their use, for the underlying mathematical expressions and for graphical illustrations.
</p>
</td></tr>                                                          
<tr><td><code id="utility.aggregation.create_+3A_par">par</code></td>
<td>

<p>numeric vector of parameter values to be passed to the function specified unter <code>name.fun</code>.
</p>
</td></tr>
<tr><td><code id="utility.aggregation.create_+3A_names.par">names.par</code></td>
<td>

<p>(optional) vector of parameter names corresponging to the vector of values specified under <code>par</code>.
Only required to provide access to the values through a named parameter vector.
</p>
</td></tr>
<tr><td><code id="utility.aggregation.create_+3A_required">required</code></td>
<td>

<p>(optional) logical variable indicating if the value of this node is required for aggregation at the next higher level.
If this variable is <code>TRUE</code>, aggregation at the next higher level is not possible if this node returns NA.
Default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="utility.aggregation.create_+3A_num.required">num.required</code></td>
<td>

<p>number of lower-level values or utilities that must at least be available to make the evaluation possible.
</p>
</td></tr>
<tr><td><code id="utility.aggregation.create_+3A_col">col</code></td>
<td>

<p>(optional) color used for plotting the bounding box of the node in the objective hierarchy.
Default value is <code>"black"</code>.
</p>
</td></tr>
<tr><td><code id="utility.aggregation.create_+3A_shift.levels">shift.levels</code></td>
<td>

<p>(optional) number of hierarchical levels by which the node in the objective hierarchy is shifted to make a branch fit better to other branches.
Default value is <code>0</code>.
</p>
</td></tr>
<tr><td><code id="utility.aggregation.create_+3A_add.arg.fun">add.arg.fun</code></td>
<td>

<p>(optional) an additional argument to the aggregation function <code>name.fun</code>.
The value(s) given here will alway be passed to the aggregation function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the created object of type <code>utility.aggregation</code> with the properties specified in the arguments of the function.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Description of aggregation techniques: <br /><br />
Langhans, S.D., Reichert, P. and Schuwirth, N.,
The method matters: A guide for indicator aggregation in ecological assessments. 
Ecological Indicators 45, 494-507, 2014. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Print, evaluate and plot the node with <br /><br />
<code><a href="#topic+print.utility.aggregation">print.utility.aggregation</a></code>, <br />
<code><a href="#topic+summary.utility.aggregation">summary.utility.aggregation</a></code>, <br />
<code><a href="#topic+evaluate.utility.aggregation">evaluate.utility.aggregation</a></code> and <br />
<code><a href="#topic+plot.utility.aggregation">plot.utility.aggregation</a></code>. <br /><br />
Create end nodes with <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, or <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>. <br /><br />
Create conversion nodes with <br /><br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, or <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # define discrete end node for width variability
  # (attribute "widthvariability_class" with levels "high", 
  # "moderate" and "none")
  
  widthvar &lt;- 
    utility.endnode.discrete.create(
      name.node     = "width variability",
      attrib.levels = data.frame(widthvariability_class=
                                 c("high","moderate","none")),
      u             = c(1,0.4125,0),
      names.u       = c("u.high","u_moderate","u.none"),
      required      = FALSE,
      utility       = FALSE)

  # define 1d interpolation end node for bed modification with 
  # riprap
  # (attribute "bedmodfract_percent" with levels from 0 to 100)
  
  bedmod_riprap &lt;-
    utility.endnode.intpol1d.create(
      name.node   = "bed modification riprap",
      name.attrib = "bedmodfract_percent",
      range       = c(0,100),
      x           = c(0,10,30,100),
      u           = c(1,0.775,0.5625,0.24),
      required    = FALSE,
      utility     = FALSE)
  
  # define 1d interpolation end node for bed modification with 
  # other material
  # (attribute "bedmodfract_percent" with levels from 0 to 100)
  
  bedmod_other &lt;-
    utility.endnode.intpol1d.create(
      name.node   = "bed modification other",
      name.attrib = "bedmodfract_percent",
      range       = c(0,100),
      x           = c(0,10,30,100),
      u           = c(1,0.775,0.5625,0),
      required    = FALSE,
      utility     = FALSE)
  
  # define combination end node for bed modification
  # (attributes "bedmodtype_class" and "bedmodfract_percent")
  
  bedmod &lt;-
    utility.endnode.cond.create(
      name.node     = "bed modification",
      attrib.levels = data.frame(bedmodtype_class=
                                 c("riprap","other")),
      nodes         = list(bedmod_riprap,bedmod_other),
      required      = FALSE,
      utility       = FALSE)
 
  # define 1d interpolation end node for bank modification with 
  # permeable material
  # (attribute "bankmodfract_percent" with levels from 0 to 100)
  
  bankmod_perm &lt;-
    utility.endnode.intpol1d.create(
      name.node   = "bank modification perm",
      name.attrib = "bankmodfract_percent",
      range       = c(0,100),
      x           = c(0,10,30,60,100),
      u           = c(1,0.8667,0.675,0.4125,0.24),
      required    = FALSE,
      utility     = FALSE)
  
  # define 1d interpolation end node for bank modification with 
  # impermeable material
  # (attribute "bankmodfract_percent" with levels from 0 to 100)
  
  bankmod_imperm &lt;-
    utility.endnode.intpol1d.create(
      name.node   = "bank modification imperm",
      name.attrib = "bankmodfract_percent",
      range       = c(0,100),
      x           = c(0,10,30,60,100),
      u           = c(1,0.775,0.5625,0.24,0),
      required    = FALSE,
      utility     = FALSE)
  
  # define combination end node for bank modification
  # (attributes "bankmodtype_class" and "bankmodfract_percent")
  
  bankmod &lt;-
    utility.endnode.cond.create(
      name.node     = "bank modification",
      attrib.levels = data.frame(bankmodtype_class=
                                 c("perm","imperm")),
      nodes         = list(bankmod_perm,bankmod_imperm),
      required      = FALSE,
      utility       = FALSE)

  # define 2d interpolation end node for riparian zone width
  # (attributes "riparianzonewidth_m" and "riparianzonewidth_m")

  riparzone_width &lt;-
    utility.endnode.intpol2d.create(
      name.node   = "riparian zone width",
      name.attrib = c("riverbedwidth_m","riparianzonewidth_m"),
      ranges      = list(c(0,16),c(0,30)),
      isolines    = list(list(x=c(0,16),y=c(0,0)),
                         list(x=c(0,2,10,16),y=c(5,5,15,15)),
                         list(x=c(0,16),y=c(15,15)),
                         list(x=c(0,16),y=c(30,30))),
      u           = c(0.0,0.6,1.0,1.0),
      lead         = 1,
      utility      = FALSE)

  # define discrete end node for riparian zone vegetation
  # (attriute "riparianzoneveg_class" with levels "natural", 
  # "seminatural" and "artificial")

  riparzone_veg &lt;-
    utility.endnode.discrete.create(
      name.node     = "riparian zone veg.",
      attrib.levels = data.frame(riparianzoneveg_class=
                                 c("natural","seminatural","artificial")),
      u             = c(1,0.5625,0),
      required      = FALSE,
      utility       = FALSE)
  
  # define aggregation node for riparian zone
  
  riparzone &lt;-
    utility.aggregation.create(
      name.node = "riparian zone",
      nodes     = list(riparzone_width,riparzone_veg),
      name.fun  = "utility.aggregate.cobbdouglas",
      par       = c(1,1),
      required  = FALSE)
  
  # define aggregation node for ecomorphological state
  
  morphol &lt;-
    utility.aggregation.create(
      name.node = "ecomorphology",
      nodes     = list(widthvar,bedmod,bankmod,riparzone),
      name.fun  = "utility.aggregate.mix",
      par       = c(0.25,0.25,0.25,0.25,0,0,1),
      names.par = c("w_widthvar","w_bedmod","w_bankmod","w_riparzone",
                    "w_add","w_min","w_cobbdouglas"),
      required  = TRUE)
      
  # print individual definitions
  
  print(widthvar)
  print(bedmod)
      
  # print all definitions
  
  print(morphol)
  
  # plot objectives hierarchy with attributes
  
  plot(morphol)
  
  # plot individual nodes:

  plot(widthvar)
  plot(widthvar,par=c(u_moderate=0.2))
  plot(bedmod_other)
  plot(bankmod)
  #plot(riparzone_width)
  
  # plot selected node definitions of a hierarchy
  
  plot(morphol,type="nodes",nodes=c("width variability",
                                    "bed modification other",
                                    "bank modification"))

  # evaluate value function for data sets and plot colored hierarchies
  # and table
  
  attrib_channelized &lt;- data.frame(widthvariability_class = "none",
                                   bedmodtype_class       = "riprap",
                                   bedmodfract_percent    = 50,
                                   bankmodtype_class      = "imperm",
                                   bankmodfract_percent   = 70,
                                   riverbedwidth_m        = 10,
                                   riparianzonewidth_m    = 5,
                                   riparianzoneveg_class  = "seminatural")
  attrib_rehab       &lt;- data.frame(widthvariability_class = "high",
                                   bedmodtype_class       = "riprap",
                                   bedmodfract_percent    = 50,
                                   bankmodtype_class      = "imperm",
                                   bankmodfract_percent   = 20,
                                   riverbedwidth_m        = 15,
                                   riparianzonewidth_m    = 15,
                                   riparianzoneveg_class  = "natural")
                                   
  res_channelized     &lt;- evaluate(morphol,attrib=attrib_channelized)
  res_channelized_add &lt;- evaluate(morphol,attrib=attrib_channelized,
                                  par=c(w_add=1,w_min=0,w_cobbdouglas=0))
  res_rehab           &lt;- evaluate(morphol,attrib=attrib_rehab)
  res_both            &lt;- rbind(res_channelized,res_rehab)
  rownames(res_both)  &lt;- c("channelized","rehabilitated")
  
  plot(morphol,u=res_channelized)
  plot(morphol,u=res_channelized_add)
  plot(morphol,u=res_rehab)
  plot(morphol,u=res_rehab,uref=res_channelized)
  plot(morphol,u=res_both,type="table")

  # consideration of uncertain attribute levels (higher uncertainty for 
  # predicted state after rehabilitation than for observed channelized state):
  
  sampsize &lt;- 2000
  
  attrib_channelized_unc &lt;- data.frame(
    widthvariability_class = rep("high",sampsize),
    bedmodtype_class       = rep("riprap",sampsize),
    bedmodfract_percent    = rnorm(sampsize,mean=50,sd=5),
    bankmodtype_class      = rep("imperm",sampsize),
    bankmodfract_percent   = rnorm(sampsize,mean=70,sd=5),
    riverbedwidth_m        = rep(10,sampsize),
    riparianzonewidth_m    = rep(5,sampsize),
    riparianzoneveg_class  = c("seminatural","artificial")[rbinom(sampsize,1,0.5)+1])

  attrib_rehab_unc &lt;- data.frame(
    widthvariability_class = c("moderate","high")[rbinom(sampsize,1,0.5)+1],
    bedmodtype_class       = rep("riprap",sampsize),
    bedmodfract_percent    = rnorm(sampsize,mean=50,sd=15),
    bankmodtype_class      = rep("imperm",sampsize),
    bankmodfract_percent   = rnorm(sampsize,mean=20,sd=5),
    riverbedwidth_m        = rnorm(sampsize,mean=10,sd=2),
    riparianzonewidth_m    = rnorm(sampsize,mean=10,sd=2),
    riparianzoneveg_class  = c("natural","seminatural")[rbinom(sampsize,1,0.5)+1])

  res_channelized_unc &lt;- evaluate(morphol,attrib=attrib_channelized_unc)
  res_rehab_unc       &lt;- evaluate(morphol,attrib=attrib_rehab_unc)

  plot(morphol,u=res_channelized_unc)
  plot(morphol,u=res_rehab_unc)
  plot(morphol,u=res_rehab_unc,uref=res_channelized_unc)
</code></pre>

<hr>
<h2 id='utility.calc.colors'>Color Scheme for Value Functions</h2><span id='topic+utility.calc.colors'></span>

<h3>Description</h3>

<p>Function to calculate a color scheme for value functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.calc.colors(n = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.calc.colors_+3A_n">n</code></td>
<td>

<p>number of colors.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>n = 5</code> this function produces the standard colors red, orange, yellow, green and blue as used in river assessment programs.
These colors are provided in a lighter version to improve readability of black text in front of the colored background.
For large values of <code>n</code> quasi-continuous transitions are defined between these colors.
Any other vector of colors can be used by the plotting routines.
</p>


<h3>Value</h3>

<p>Character vector of colors.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <br />
<code><a href="#topic+plot.utility.endnode.discrete">plot.utility.endnode.discrete</a></code> <br />
<code><a href="#topic+plot.utility.endnode.intpol1d">plot.utility.endnode.intpol1d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.parfun1d">plot.utility.endnode.parfun1d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.intpol2d">plot.utility.endnode.intpol2d</a></code> <br />
<code><a href="#topic+plot.utility.endnode.cond">plot.utility.endnode.cond</a></code> <br />
<code><a href="#topic+plot.utility.aggregation">plot.utility.aggregation</a></code> <br />
<code><a href="#topic+plot.utility.conversion.intpol">plot.utility.conversion.intpol</a></code> <br />
<code><a href="#topic+plot.utility.conversion.parfun">plot.utility.conversion.parfun</a></code> <br />
for the use of such color vectors in plotting functions and <br />
<code><a href="#topic+utility.get.colors">utility.get.colors</a></code> <br />
for getting colors corresponding to specified values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.calc.colors(5)
utility.calc.colors(100)
</code></pre>

<hr>
<h2 id='utility.conversion.intpol.create'>Construct an interpolation conversion node</h2><span id='topic+utility.conversion.intpol.create'></span>

<h3>Description</h3>

<p>Function to construct a node converting values into utilities by interpolation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.conversion.intpol.create(name.node, 
                                 node, 
                                 x, 
                                 u, 
                                 names.x      = rep(NA, length(x)), 
                                 names.u      = rep(NA, length(u)), 
                                 required     = FALSE, 
                                 col          = "black", 
                                 shift.levels = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.conversion.intpol.create_+3A_name.node">name.node</code></td>
<td>

<p>name of the node to be constructed as a character string.
</p>
</td></tr>
<tr><td><code id="utility.conversion.intpol.create_+3A_node">node</code></td>
<td>

<p>value node that is to be converted into a utility node.
</p>
</td></tr>
<tr><td><code id="utility.conversion.intpol.create_+3A_x">x</code></td>
<td>

<p>numeric vector of values for which the utility is known.
</p>
</td></tr>
<tr><td><code id="utility.conversion.intpol.create_+3A_u">u</code></td>
<td>

<p>numeric vector of utilities corresponding to the values given in the previous argument <code>x</code>.
</p>
</td></tr>
<tr><td><code id="utility.conversion.intpol.create_+3A_names.x">names.x</code></td>
<td>

<p>(optional) vector of character strings with names of the components of the numeric vector <code>x</code> specified above.
Only required to provide access to the values through a named parameter vector.
</p>
</td></tr>
<tr><td><code id="utility.conversion.intpol.create_+3A_names.u">names.u</code></td>
<td>

<p>(optional) vector of character strings with names of the components of the numeric vector <code>u</code> specified above.
Only required to provide acces through a named parameter vector.
</p>
</td></tr>
<tr><td><code id="utility.conversion.intpol.create_+3A_required">required</code></td>
<td>

<p>(optional) logical variable indicating if the value of this node is required for aggregation at the next higher level.
If this variable is <code>TRUE</code>, aggregation at the next higher level is not possible if this node returns NA.
Default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="utility.conversion.intpol.create_+3A_col">col</code></td>
<td>

<p>(optional) color used for plotting the bounding box of the node in the objective hierarchy.
Default value is <code>"black"</code>.
</p>
</td></tr>
<tr><td><code id="utility.conversion.intpol.create_+3A_shift.levels">shift.levels</code></td>
<td>

<p>(optional) number of hierarchical levels by which the node in the objective hierarchy is shifted to make a branch fit better to other branches.
Default value is <code>0</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the created object of type <code>utility.conversion.intpol1</code> with the properties specified in the arguments of the function.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Print, evaluate and plot the node with <br /><br />
<code><a href="#topic+print.utility.conversion.intpol">print.utility.conversion.intpol</a></code>, <br />
<code><a href="#topic+summary.utility.conversion.intpol">summary.utility.conversion.intpol</a></code>, <br />
<code><a href="#topic+evaluate.utility.conversion.intpol">evaluate.utility.conversion.intpol</a></code> and <br />
<code><a href="#topic+plot.utility.conversion.intpol">plot.utility.conversion.intpol</a></code>. <br /><br />
Create other conversion nodes with
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code>.
Create end nodes with <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, or <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>. <br /><br />
Create aggregation nodes with <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>.
</p>

<hr>
<h2 id='utility.conversion.parfun.create'>Construct a parametric function conversion node</h2><span id='topic+utility.conversion.parfun.create'></span>

<h3>Description</h3>

<p>Function to construct a node converting values into utilities by a parametric function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.conversion.parfun.create(name.node, 
                                 node, 
                                 name.fun, 
                                 par, 
                                 names.par    = rep(NA, length(par)), 
                                 required     = FALSE, 
                                 col          = "black", 
                                 shift.levels = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.conversion.parfun.create_+3A_name.node">name.node</code></td>
<td>

<p>name of the node to be constructed as a character string.
</p>
</td></tr>
<tr><td><code id="utility.conversion.parfun.create_+3A_node">node</code></td>
<td>

<p>value node that is to be converted into a utility node.
</p>
</td></tr>
<tr><td><code id="utility.conversion.parfun.create_+3A_name.fun">name.fun</code></td>
<td>

<p>name of the parametric function to be evaluated as a character string.
The parametric function must have the arguments <code>u</code> and <code>par</code> 
which pass a vector of values and a vector of parameters
to the function, respectively.
The function has to return a vector of corresponding utilities.
</p>
</td></tr>
<tr><td><code id="utility.conversion.parfun.create_+3A_par">par</code></td>
<td>

<p>numeric vector of parameter values to be passed to the function specified unter <code>name.fun</code>.
</p>
</td></tr>
<tr><td><code id="utility.conversion.parfun.create_+3A_names.par">names.par</code></td>
<td>

<p>(optional) vector of parameter names corresponging to the vector of values specified under <code>par</code>.
Only required to provide access to the values through a named parameter vector.
</p>
</td></tr>
<tr><td><code id="utility.conversion.parfun.create_+3A_required">required</code></td>
<td>

<p>(optional) logical variable indicating if the value of this node is required for aggregation at the next higher level.
If this variable is <code>TRUE</code>, aggregation at the next higher level is not possible if this node returns NA.
Default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="utility.conversion.parfun.create_+3A_col">col</code></td>
<td>

<p>(optional) color used for plotting the bounding box of the node in the objective hierarchy.
Default value is <code>"black"</code>.
</p>
</td></tr>
<tr><td><code id="utility.conversion.parfun.create_+3A_shift.levels">shift.levels</code></td>
<td>

<p>(optional) number of hierarchical levels by which the node in the objective hierarchy is shifted to make a branch fit better to other branches.
Default value is <code>0</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the created object of type <code>utility.conversion.parfun</code> with the properties specified in the arguments of the function.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Print, evaluate and plot the node with <br /><br />
<code><a href="#topic+print.utility.conversion.parfun">print.utility.conversion.parfun</a></code>, <br />
<code><a href="#topic+summary.utility.conversion.parfun">summary.utility.conversion.parfun</a></code>, <br />
<code><a href="#topic+evaluate.utility.conversion.parfun">evaluate.utility.conversion.parfun</a></code> and <br />
<code><a href="#topic+plot.utility.conversion.parfun">plot.utility.conversion.parfun</a></code>. <br /><br />
Create other conversion nodes with
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>.
Create end nodes with <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, or <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>. <br /><br />
Create aggregation nodes with <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>.
</p>

<hr>
<h2 id='utility.endnode.classcounts.create'>Construct an end node that evaluates counts in different quality classes.</h2><span id='topic+utility.endnode.classcounts.create'></span>

<h3>Description</h3>

<p>Function to construct a node that evaluates counts in different quality classes by assigning
a value to the highest class with counts &gt; 0 and optionally increments this value with the
counts in this and lower classses and given increments per count unit.
The user can choose whether these increments can lead to a value higher than the basic value
for counts in the next better class or if this value limits the potential increase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.endnode.classcounts.create(name.node,        # character(1)
                                   name.attrib,      # character(n)
                                   u.max.inc,        # list (n) of vect (&gt;=1)
                                   names.u.max.inc = list(),
                                   exceed.next     = TRUE,
                                   utility         = TRUE,
                                   required        = FALSE,
                                   col             = "black",
                                   shift.levels    = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.endnode.classcounts.create_+3A_name.node">name.node</code></td>
<td>

<p>name of the node to be constructed as a character string.
</p>
</td></tr>
<tr><td><code id="utility.endnode.classcounts.create_+3A_name.attrib">name.attrib</code></td>
<td>

<p>vector of names of attributes (counts in classes in decreasing order of value of the classes).
</p>
</td></tr>
<tr><td><code id="utility.endnode.classcounts.create_+3A_u.max.inc">u.max.inc</code></td>
<td>

<p>list of vectors specifying the basic value and the increments for each class and classes of less value.
</p>
</td></tr>
<tr><td><code id="utility.endnode.classcounts.create_+3A_names.u.max.inc">names.u.max.inc</code></td>
<td>

<p>(optional) list of vectors of names of parameters u.max.inc.
</p>
</td></tr>
<tr><td><code id="utility.endnode.classcounts.create_+3A_exceed.next">exceed.next</code></td>
<td>

<p>(optional) logical variable to indicate whether the level corresponding to the species
classified at the next higher level can be exceeded with increments; 
default value is TRUE.
</p>
</td></tr>
<tr><td><code id="utility.endnode.classcounts.create_+3A_utility">utility</code></td>
<td>

<p>(optional) logical variable indicating if a value function (<code>FALSE</code>) or a utility function (<code>TRUE</code>) is created.
Default value is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.classcounts.create_+3A_required">required</code></td>
<td>

<p>(optional) logical variable indicating if the value of this node is required for aggregation at the next higher level.
If this variable is <code>TRUE</code>, aggregation at the next higher level is not possible if this node returns NA.
Default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.classcounts.create_+3A_col">col</code></td>
<td>

<p>(optional) color used for plotting the bounding box of the node in the objective hierarchy.
Default value is <code>"black"</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.classcounts.create_+3A_shift.levels">shift.levels</code></td>
<td>

<p>(optional) number of hierarchical levels by which the node in the objective hierarchy is shifted to make a branch fit better to other branches.
Default value is <code>0</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the created object of type <code>utility.endnode.classcounts</code> with the properties specified in the arguments of the function.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Print, evaluate and plot the node with <br /><br />
<code><a href="#topic+print.utility.endnode.classcounts">print.utility.endnode.classcounts</a></code>, <br />
<code><a href="#topic+summary.utility.endnode.classcounts">summary.utility.endnode.classcounts</a></code>, <br />
<code><a href="#topic+evaluate.utility.endnode.classcounts">evaluate.utility.endnode.classcounts</a></code> and <br />
<code><a href="#topic+plot.utility.endnode.classcounts">plot.utility.endnode.classcounts</a></code>. <br /><br />
Create other end nodes with  <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, or <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>, <br /><br />
Create other types of nodes with <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, or <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code>.
</p>

<hr>
<h2 id='utility.endnode.cond.create'>Construct a conditional end node</h2><span id='topic+utility.endnode.cond.create'></span>

<h3>Description</h3>

<p>Function to construct a node that makes a choice between given end 
nodes based on the levels of discrete attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.endnode.cond.create(name.node, 
                            attrib.levels, 
                            nodes, 
                            utility      = TRUE, 
                            required     = FALSE, 
                            col          = "black", 
                            shift.levels = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.endnode.cond.create_+3A_name.node">name.node</code></td>
<td>

<p>name of the node to be constructed as a character string.
</p>
</td></tr>
<tr><td><code id="utility.endnode.cond.create_+3A_attrib.levels">attrib.levels</code></td>
<td>

<p>data frame with attribute names as column names and all discrete attribute level combinations in the rows.
This may be a dependence on any number of attributes.
As combinatorics can lead to a very large number of possible combinations, the node should not depend on a too large number of attributes, in particular if each attribute has many different levels expressed by numbers or character strings.
</p>
</td></tr>
<tr><td><code id="utility.endnode.cond.create_+3A_nodes">nodes</code></td>
<td>

<p>list of the length of the number of columns of the data frame specifed as argument <code>attrib.levels</code> above containing the nodes to be associated with the attribute level combinations specified in the rows of <code>attrib.levels</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.cond.create_+3A_utility">utility</code></td>
<td>

<p>(optional) logical variable indicating if a value function (<code>FALSE</code>) or a utility function (<code>TRUE</code>) is created.
Default value is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.cond.create_+3A_required">required</code></td>
<td>

<p>(optional) logical variable indicating if the value of this node is required for aggregation at the next higher level.
If this variable is <code>TRUE</code>, aggregation at the next higher level is not possible if this node returns NA.
Default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.cond.create_+3A_col">col</code></td>
<td>

<p>(optional) color used for plotting the bounding box of the node in the objective hierarchy.
Default value is <code>"black"</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.cond.create_+3A_shift.levels">shift.levels</code></td>
<td>

<p>(optional) number of hierarchical levels by which the node in the objective hierarchy is shifted to make a branch fit better to other branches.
Default value is <code>0</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the created object of type <code>utility.endnode.cond</code> with the properties specified in the arguments of the function.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Print, evaluate and plot the node with <br /><br />
<code><a href="#topic+print.utility.endnode.cond">print.utility.endnode.cond</a></code>, <br />
<code><a href="#topic+summary.utility.endnode.cond">summary.utility.endnode.cond</a></code>, <br />
<code><a href="#topic+evaluate.utility.endnode.cond">evaluate.utility.endnode.cond</a></code> and <br />
<code><a href="#topic+plot.utility.endnode.cond">plot.utility.endnode.cond</a></code>. <br /><br />
Create other end nodes with  <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, or <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>. <br /><br />
Create other types of nodes with <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, or <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  bedmod_riprap &lt;-
    utility.endnode.intpol1d.create(
      name.node   = "bed modification riprap",
      name.attrib = "bedmodfract_percent",
      range       = c(0,100),
      x           = c(0,10,30,100),
      u           = c(1,0.775,0.5625,0.24),
      required    = FALSE,
      utility     = FALSE)
  
  bedmod_other &lt;-
    utility.endnode.intpol1d.create(
      name.node   = "bed modification other",
      name.attrib = "bedmodfract_percent",
      range       = c(0,100),
      x           = c(0,10,30,100),
      u           = c(1,0.775,0.5625,0),
      required    = FALSE,
      utility     = FALSE)
  
  bedmod &lt;-
    utility.endnode.cond.create(
      name.node     = "bed modification",
      attrib.levels = data.frame(bedmodtype_class=
                                 c("riprap","other")),
      nodes         = list(bedmod_riprap,bedmod_other),
      required      = FALSE,
      utility       = FALSE)

  print(bedmod)
  plot(bedmod)
</code></pre>

<hr>
<h2 id='utility.endnode.discrete.create'>Construct a discrete value or utility end node</h2><span id='topic+utility.endnode.discrete.create'></span>

<h3>Description</h3>

<p>Function to construct a discrete value or utility end node.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.endnode.discrete.create(name.node, 
                                attrib.levels, 
                                u, 
                                names.u      = rep(NA, length(u)), 
                                utility      = TRUE, 
                                required     = FALSE, 
                                col          = "black", 
                                shift.levels = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.endnode.discrete.create_+3A_name.node">name.node</code></td>
<td>

<p>name of the node to be constructed as a character string.
</p>
</td></tr>
<tr><td><code id="utility.endnode.discrete.create_+3A_attrib.levels">attrib.levels</code></td>
<td>

<p>data frame with attribute names as column names and all discrete attribute level combinations in the rows.
This may be a dependence on any number of attributes.
As combinatorics can lead to a very large number of possible combinations, the node should not depend on a too large number of attributes, in particular if each attribute has many different levels expressed by numbers or character strings.
</p>
</td></tr>
<tr><td><code id="utility.endnode.discrete.create_+3A_u">u</code></td>
<td>

<p>numeric vector of the length of the number of columns of the data frame specifed as argument <code>attrib.levels</code> above specifying the values or utilities corresponding to the rows of <code>attrib.levels</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.discrete.create_+3A_names.u">names.u</code></td>
<td>

<p>(optional) vector of character strings with names of the components of the numeric vector <code>u</code> specified above.
Only required to provide access to the values through a named parameter vector.
</p>
</td></tr>
<tr><td><code id="utility.endnode.discrete.create_+3A_utility">utility</code></td>
<td>

<p>(optional) logical variable indicating if a value function (<code>FALSE</code>) or a utility function (<code>TRUE</code>) is created.
Default value is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.discrete.create_+3A_required">required</code></td>
<td>

<p>(optional) logical variable indicating if the value of this node is required for aggregation at the next higher level.
If this variable is <code>TRUE</code>, aggregation at the next higher level is not possible if this node returns NA.
Default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.discrete.create_+3A_col">col</code></td>
<td>

<p>(optional) color used for plotting the bounding box of the node in the objective hierarchy.
Default value is <code>"black"</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.discrete.create_+3A_shift.levels">shift.levels</code></td>
<td>

<p>(optional) number of hierarchical levels by which the node in the objective hierarchy is shifted to make a branch fit better to other branches.
Default value is <code>0</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the created object of type <code>utility.endnode.discrete</code> with the properties specified in the arguments of the function.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Print, evaluate and plot the node with <br /><br />
<code><a href="#topic+print.utility.endnode.discrete">print.utility.endnode.discrete</a></code>, <br />
<code><a href="#topic+summary.utility.endnode.discrete">summary.utility.endnode.discrete</a></code>, <br />
<code><a href="#topic+evaluate.utility.endnode.discrete">evaluate.utility.endnode.discrete</a></code> and <br />
<code><a href="#topic+plot.utility.endnode.discrete">plot.utility.endnode.discrete</a></code>. <br /><br />
Create other end nodes with <br /><br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, or <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>. <br /><br />
Create other types of nodes with <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, or <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  widthvar &lt;- 
    utility.endnode.discrete.create(
      name.node     = "width variability",
      attrib.levels = data.frame(widthvariability_class=
                                 c("high","moderate","none")),
      u             = c(1,0.4125,0),
      names.u       = c("u.high","u_moderate","u.none"),
      required      = FALSE,
      utility       = FALSE)

  print(widthvar)
  plot(widthvar)
</code></pre>

<hr>
<h2 id='utility.endnode.firstavail.create'>Construct an end node to get the results of the first available sub-node</h2><span id='topic+utility.endnode.firstavail.create'></span>

<h3>Description</h3>

<p>Function to construct a node that returns the results of the first sub-node for
which results are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.endnode.firstavail.create(name.node, 
                                  nodes, 
                                  utility      = TRUE, 
                                  required     = FALSE, 
                                  col          = "black", 
                                  shift.levels = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.endnode.firstavail.create_+3A_name.node">name.node</code></td>
<td>

<p>name of the node to be constructed as a character string.
</p>
</td></tr>
<tr><td><code id="utility.endnode.firstavail.create_+3A_nodes">nodes</code></td>
<td>

<p>list of nodes to be tried.
</p>
</td></tr>
<tr><td><code id="utility.endnode.firstavail.create_+3A_utility">utility</code></td>
<td>

<p>(optional) logical variable indicating if a value function (<code>FALSE</code>) or a utility function (<code>TRUE</code>) is created.
Default value is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.firstavail.create_+3A_required">required</code></td>
<td>

<p>(optional) logical variable indicating if the value of this node is required for aggregation at the next higher level.
If this variable is <code>TRUE</code>, aggregation at the next higher level is not possible if this node returns NA.
Default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.firstavail.create_+3A_col">col</code></td>
<td>

<p>(optional) color used for plotting the bounding box of the node in the objective hierarchy.
Default value is <code>"black"</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.firstavail.create_+3A_shift.levels">shift.levels</code></td>
<td>

<p>(optional) number of hierarchical levels by which the node in the objective hierarchy is shifted to make a branch fit better to other branches.
Default value is <code>0</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the created object of type <code>utility.endnode.firstavail</code> with the properties specified in the arguments of the function.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Print, evaluate and plot the node with <br /><br />
<code><a href="#topic+print.utility.endnode.firstavail">print.utility.endnode.firstavail</a></code>, <br />
<code><a href="#topic+summary.utility.endnode.firstavail">summary.utility.endnode.firstavail</a></code>, <br />
<code><a href="#topic+evaluate.utility.endnode.firstavail">evaluate.utility.endnode.firstavail</a></code> and <br />
<code><a href="#topic+plot.utility.endnode.firstavail">plot.utility.endnode.firstavail</a></code>. <br /><br />
Create other end nodes with  <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, or <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, <br /><br />
Create other types of nodes with <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, or <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code>.
</p>

<hr>
<h2 id='utility.endnode.intpol1d.create'>Construct a single-attribute interpolation end node</h2><span id='topic+utility.endnode.intpol1d.create'></span>

<h3>Description</h3>

<p>Function to construct a single-attribute interpolation end node.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.endnode.intpol1d.create(name.node, 
                                name.attrib, 
                                range, 
                                x, 
                                u, 
                                names.x      = rep(NA, length(x)), 
                                names.u      = rep(NA, length(u)), 
                                utility      = TRUE, 
                                required     = FALSE, 
                                col          = "black", 
                                shift.levels = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.endnode.intpol1d.create_+3A_name.node">name.node</code></td>
<td>

<p>name of the node to be constructed as a character string.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol1d.create_+3A_name.attrib">name.attrib</code></td>
<td>

<p>name of the attribute on which the value or utility function depends as a character string.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol1d.create_+3A_range">range</code></td>
<td>

<p>numeric vector with two components specifying the minimum and the maximum of the attribute range.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol1d.create_+3A_x">x</code></td>
<td>

<p>numeric vector of attribute values for which the value or utility is known.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol1d.create_+3A_u">u</code></td>
<td>

<p>numeric vector of values or utilities corresponding to the attribute values given in the previous argument <code>x</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol1d.create_+3A_names.x">names.x</code></td>
<td>

<p>(optional) vector of character strings with names of the components of the numeric vector <code>x</code> specified above.
Only required to provide access to the values through a named parameter vector.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol1d.create_+3A_names.u">names.u</code></td>
<td>

<p>(optional) vector of character strings with names of the components of the numeric vector <code>u</code> specified above.
Only required to provide acces through a named parameter vector.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol1d.create_+3A_utility">utility</code></td>
<td>

<p>(optional) logical variable indicating if a value function (<code>FALSE</code>) or a utility function (<code>TRUE</code>) is created.
Default value is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol1d.create_+3A_required">required</code></td>
<td>

<p>(optional) logical variable indicating if the value of this node is required for aggregation at the next higher level.
If this variable is <code>TRUE</code>, aggregation at the next higher level is not possible if this node returns NA.
Default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol1d.create_+3A_col">col</code></td>
<td>

<p>(optional) color used for plotting the bounding box of the node in the objective hierarchy.
Default value is <code>"black"</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol1d.create_+3A_shift.levels">shift.levels</code></td>
<td>

<p>(optional) number of hierarchical levels by which the node in the objective hierarchy is shifted to make a branch fit better to other branches.
Default value is <code>0</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the created object of type <code>utility.endnode.intpol1d</code> with the properties specified in the arguments of the function.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Print, evaluate and plot the node with <br /><br />
<code><a href="#topic+print.utility.endnode.intpol1d">print.utility.endnode.intpol1d</a></code>, <br />
<code><a href="#topic+summary.utility.endnode.intpol1d">summary.utility.endnode.intpol1d</a></code>, <br />
<code><a href="#topic+evaluate.utility.endnode.intpol1d">evaluate.utility.endnode.intpol1d</a></code> and <br />
<code><a href="#topic+plot.utility.endnode.intpol1d">plot.utility.endnode.intpol1d</a></code>. <br /><br />
Create other end nodes with <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, or<br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>. <br /><br />
Create other types of nodes with <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, or <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  bedmod_other &lt;-
    utility.endnode.intpol1d.create(
      name.node   = "bed modification other",
      name.attrib = "bedmodfract_percent",
      range       = c(0,100),
      x           = c(0,10,30,100),
      u           = c(1,0.775,0.5625,0),
      required    = FALSE,
      utility     = FALSE)
      
  print(bedmod_other)
  plot(bedmod_other)
</code></pre>

<hr>
<h2 id='utility.endnode.intpol2d.create'>Construct a two-attribute interpolation end node</h2><span id='topic+utility.endnode.intpol2d.create'></span>

<h3>Description</h3>

<p>Function to construct a two-attribute interpolation end node.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.endnode.intpol2d.create(name.node, 
                                name.attrib, 
                                ranges, 
                                isolines, 
                                u, 
                                names.u      = rep(NA, length(u)), 
                                lead         = 0, 
                                utility      = TRUE, 
                                required     = FALSE, 
                                col          = "black", 
                                shift.levels = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.endnode.intpol2d.create_+3A_name.node">name.node</code></td>
<td>

<p>name of the node to be constructed as a character string.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol2d.create_+3A_name.attrib">name.attrib</code></td>
<td>

<p>names of the attributes on which the value or utility function depends as a vector of two character strings.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol2d.create_+3A_ranges">ranges</code></td>
<td>

<p>list of two numeric vectors with two components each specifying the minimum and the maximum of the range of the corresponding attribute.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol2d.create_+3A_isolines">isolines</code></td>
<td>

<p>list of isoline definitions.
Each definition consists of a list with elements <code>x</code> and <code>y</code> that each represents a numeric vector of x- (=first attribute) and y- (second attribute) values to characterize the shape of the isoline.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol2d.create_+3A_u">u</code></td>
<td>

<p>numeric vector of the same length as the outer list of the argument <code>isolines</code> specifying the corresponding values or utilities.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol2d.create_+3A_names.u">names.u</code></td>
<td>

<p>(optional) vector of character strings with names of the components of the numeric vector <code>u</code> specified above.
Only required to provide acces through a named parameter vector.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol2d.create_+3A_lead">lead</code></td>
<td>

<p>numeric value specifying which variable is the lead variable for interpolation.
1 indicates linear interpolation between isolines along lines with constant value of the first attribute, 2 along lines with constant values of the second attribute, and zero indicates to take the average of these two interpolation schemes.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol2d.create_+3A_utility">utility</code></td>
<td>

<p>(optional) logical variable indicating if a value function (<code>FALSE</code>) or a utility function (<code>TRUE</code>) is created.
Default value is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol2d.create_+3A_required">required</code></td>
<td>

<p>(optional) logical variable indicating if the value of this node is required for aggregation at the next higher level.
If this variable is <code>TRUE</code>, aggregation at the next higher level is not possible if this node returns NA.
Default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol2d.create_+3A_col">col</code></td>
<td>

<p>(optional) color used for plotting the bounding box of the node in the objective hierarchy.
Default value is <code>"black"</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.intpol2d.create_+3A_shift.levels">shift.levels</code></td>
<td>

<p>(optional) number of hierarchical levels by which the node in the objective hierarchy is shifted to make a branch fit better to other branches.
Default value is <code>0</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the created object of type <code>utility.endnode.intpol2d</code> with the properties specified in the arguments of the function.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Print, evaluate and plot the node with <br /><br />
<code><a href="#topic+print.utility.endnode.intpol2d">print.utility.endnode.intpol2d</a></code>, <br />
<code><a href="#topic+summary.utility.endnode.intpol2d">summary.utility.endnode.intpol2d</a></code>, <br />
<code><a href="#topic+evaluate.utility.endnode.intpol2d">evaluate.utility.endnode.intpol2d</a></code> and <br />
<code><a href="#topic+plot.utility.endnode.intpol2d">plot.utility.endnode.intpol2d</a></code>. <br /><br />
Create other end nodes with <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.parfun1d.create">utility.endnode.parfun1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, or <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>. <br /><br />
Create other types of nodes with <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, or <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  riparzone_width &lt;-
    utility.endnode.intpol2d.create(
      name.node   = "riparian zone width",
      name.attrib = c("riverbedwidth_m","riparianzonewidth_m"),
      ranges      = list(c(0,16),c(0,30)),
      isolines    = list(list(x=c(0,16),y=c(0,0)),
                         list(x=c(0,2,10,16),y=c(5,5,15,15)),
                         list(x=c(0,16),y=c(15,15)),
                         list(x=c(0,16),y=c(30,30))),
      u           = c(0.0,0.6,1.0,1.0),
      lead         = 1,
      utility      = FALSE)

  print(riparzone_width)
  plot(riparzone_width)
</code></pre>

<hr>
<h2 id='utility.endnode.parfun1d.create'>Construct a single-attribute parametric function end node</h2><span id='topic+utility.endnode.parfun1d.create'></span>

<h3>Description</h3>

<p>Function to construct a single-attribute parametric function end node.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.endnode.parfun1d.create(name.node, 
                                name.attrib, 
                                range, 
                                name.fun, 
                                par, 
                                names.par    = rep(NA, length(par)), 
                                utility      = TRUE, 
                                required     = FALSE, 
                                col          = "black", 
                                shift.levels = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.endnode.parfun1d.create_+3A_name.node">name.node</code></td>
<td>

<p>name of the node to be constructed as a character string.
</p>
</td></tr>
<tr><td><code id="utility.endnode.parfun1d.create_+3A_name.attrib">name.attrib</code></td>
<td>

<p>name of the attribute on which the value or utility function depends as a character string.
</p>
</td></tr>
<tr><td><code id="utility.endnode.parfun1d.create_+3A_range">range</code></td>
<td>

<p>numeric vector with two components specifying the minimum and the maximum of the attribute range.
</p>
</td></tr>
<tr><td><code id="utility.endnode.parfun1d.create_+3A_name.fun">name.fun</code></td>
<td>

<p>name of the parametric function to be evaluated as a character string.
The parametric function must have the arguments <code>attrib</code> and <code>par</code> 
which pass a vector of attribute levels and a vector of parameters
to the function, respectively.
The function has to return a vector of corresponding values or utilities.
</p>
</td></tr>
<tr><td><code id="utility.endnode.parfun1d.create_+3A_par">par</code></td>
<td>

<p>numeric vector of parameter values to be passed to the function specified unter <code>name.fun</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.parfun1d.create_+3A_names.par">names.par</code></td>
<td>

<p>(optional) vector of parameter names corresponging to the vector of values specified under <code>par</code>.
Only required to provide access to the values through a named parameter vector.
</p>
</td></tr>
<tr><td><code id="utility.endnode.parfun1d.create_+3A_utility">utility</code></td>
<td>

<p>(optional) logical variable indicating if a value function (<code>FALSE</code>) or a utility function (<code>TRUE</code>) is created.
Default value is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.parfun1d.create_+3A_required">required</code></td>
<td>

<p>(optional) logical variable indicating if the value of this node is required for aggregation at the next higher level.
If this variable is <code>TRUE</code>, aggregation at the next higher level is not possible if this node returns NA.
Default value is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.parfun1d.create_+3A_col">col</code></td>
<td>

<p>(optional) color used for plotting the bounding box of the node in the objective hierarchy.
Default value is <code>"black"</code>.
</p>
</td></tr>
<tr><td><code id="utility.endnode.parfun1d.create_+3A_shift.levels">shift.levels</code></td>
<td>

<p>(optional) number of hierarchical levels by which the node in the objective hierarchy is shifted to make a branch fit better to other branches.
Default value is <code>0</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the created object of type <code>utility.endnode.parfun1d</code> with the properties specified in the arguments of the function.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>Print, evaluate and plot the node with <br /><br />
<code><a href="#topic+print.utility.endnode.parfun1d">print.utility.endnode.parfun1d</a></code>, <br />
<code><a href="#topic+summary.utility.endnode.parfun1d">summary.utility.endnode.parfun1d</a></code>, <br />
<code><a href="#topic+evaluate.utility.endnode.parfun1d">evaluate.utility.endnode.parfun1d</a></code> and <br />
<code><a href="#topic+plot.utility.endnode.parfun1d">plot.utility.endnode.parfun1d</a></code>. <br /><br />
Create other end nodes with <br /><br />
<code><a href="#topic+utility.endnode.discrete.create">utility.endnode.discrete.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.intpol2d.create">utility.endnode.intpol2d.create</a></code>, <br />
<code><a href="#topic+utility.endnode.cond.create">utility.endnode.cond.create</a></code>, or <br />
<code><a href="#topic+utility.endnode.firstavail.create">utility.endnode.firstavail.create</a></code>. <br /><br />
Create other types of nodes with <br /><br />
<code><a href="#topic+utility.aggregation.create">utility.aggregation.create</a></code>, <br />
<code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code>, or <br />
<code><a href="#topic+utility.conversion.parfun.create">utility.conversion.parfun.create</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  bedmod_other &lt;-
    utility.endnode.parfun1d.create(
      name.node   = "bed modification other",
      name.attrib = "bedmodfract_percent",
      range       = c(0,100),
      name.fun    = "utility.fun.exp",
      par         = c(-1,100,0),
      required    = FALSE,
      utility     = FALSE)
      
  print(bedmod_other)
  plot(bedmod_other)
</code></pre>

<hr>
<h2 id='utility.fun.exp'>Exponential function for value or utility functions</h2><span id='topic+utility.fun.exp'></span>

<h3>Description</h3>

<p>Exponential function for value or utility functions.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.fun.exp(attrib, par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.fun.exp_+3A_attrib">attrib</code></td>
<td>

<p>vector of attribute levels to calculate corresponding value or utility.
</p>
</td></tr>
<tr><td><code id="utility.fun.exp_+3A_par">par</code></td>
<td>

<p>Vector of parameters: <br />
<code>par[1]</code>: absolute risk aversion <br />
<code>par[2]</code>: minimum of attribute range (default = 0) <br />
<code>par[3]</code>: maximum of attribute range (default = 1) 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function evaluates the expression <br />
<code>(1-exp(-par[1]*(a-par[2])/(par[3]-par[2])))/(1-exp(-par[1]))</code>.
</p>


<h3>Value</h3>

<p>Vector of values or utilities corresponding to the attributes passed by argument <code>a</code>
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See the node constructors <br />
<code><a href="#topic+utility.endnode.intpol1d.create">utility.endnode.intpol1d.create</a></code> and <code><a href="#topic+utility.conversion.intpol.create">utility.conversion.intpol.create</a></code> <br />
in which this function can be used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.fun.exp(0:10/10,par=c(2,0,1))
</code></pre>

<hr>
<h2 id='utility.get.attrib.names'>Get Names of Attributes Used by a Value Functions</h2><span id='topic+utility.get.attrib.names'></span>

<h3>Description</h3>

<p>Function to get the names of the attributes used by a given value function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.get.attrib.names(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.get.attrib.names_+3A_node">node</code></td>
<td>

<p>node of an objectives hierarchy with its associated value function (object of class <code>utility</code>).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of names of attributes.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>

<hr>
<h2 id='utility.get.colors'>Get Color Corresponding to Specified Value Levels</h2><span id='topic+utility.get.colors'></span>

<h3>Description</h3>

<p>Function to get the colors from a given color scheme at specific value levels.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.get.colors(u,col=utility.calc.colors())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.get.colors_+3A_u">u</code></td>
<td>

<p>value level representing the evaluation ot a value function (this value level has to be between zero and unity).
</p>
</td></tr>
<tr><td><code id="utility.get.colors_+3A_col">col</code></td>
<td>

<p>color scheme (vector of colors to be used for a division of the interval between zero and unity into equal intervals)).
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of colors.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>


<h3>See Also</h3>

<p>See <br />
<code><a href="#topic+utility.calc.colors">utility.calc.colors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>utility.get.colors(c(0,0.5,1))
</code></pre>

<hr>
<h2 id='utility.structure'>Extract Structure of Objectives Hierarchy</h2><span id='topic+utility.structure'></span>

<h3>Description</h3>

<p>Function to extract the structure of an objectives hierarchy.</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility.structure(node)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility.structure_+3A_node">node</code></td>
<td>

<p>object containing the utility or value function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame containing structural information of the objectives hierarchy.
</p>


<h3>Author(s)</h3>

<p>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>References</h3>

<p>Short description of the package: <br /><br />
Reichert, P., Schuwirth, N. and Langhans, S., 
Constructing, evaluating and visualizing value and utility functions for decision support, Environmental Modelling &amp; Software 46, 283-291, 2013. <br /><br />
Textbooks on the use of utility and value functions in decision analysis: <br /><br />
Keeney, R. L. and Raiffa, H. Decisions with Multiple Objectives - Preferences and Value Tradeoffs. John Wiley &amp; Sons, 1976. <br /><br />
Eisenfuehr, F., Weber, M. and Langer, T., Rational Decision Making, Springer, Berlin, 2010.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
