<!DOCTYPE html><html><head><title>Help for package landest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {landest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cumsum2'>

<p>Helper function</p></a></li>
<li><a href='#delper.si'>

<p>Helper function</p></a></li>
<li><a href='#delta.iptw.km'>
<p>Estimates survival and treatment effect using inverse probability of treatment weighted (IPTW) Kaplan-Meier estimation</p></a></li>
<li><a href='#delta.km'>
<p>Estimates survival and treatment effect using Kaplan-Meier estimation</p>
</p></a></li>
<li><a href='#delta.land.obs'>
<p>Estimates survival and treatment effect using landmark estimation</p></a></li>
<li><a href='#delta.land.rct'>
<p>Estimates survival and treatment effect using landmark estimation</p></a></li>
<li><a href='#Est.KM.FUN.weighted'>
<p>Nonparametric Nelson-Aalen estimate of survival</p></a></li>
<li><a href='#example_obs'>
<p>Hypothetical data from an observational study</p></a></li>
<li><a href='#example_rct'>
<p>Hypothetical data from a randomized trial</p></a></li>
<li><a href='#Kern.FUN'>

<p>Calculates kernel matrix</p></a></li>
<li><a href='#landest-package'>
<p>Survival and treatment effect estimation</p></a></li>
<li><a href='#ps.wgt.fun'>
<p>Calculates propensity score weights</p></a></li>
<li><a href='#surv.iptw.km'>
<p>Estimates survival using inverse probability of treatment weighted (IPTW) Kaplan-Meier estimation</p></a></li>
<li><a href='#surv.iptw.km.base'>
<p>Estimates survival using inverse probability of treatment weighted (IPTW) Kaplan-Meier estimation</p>
</p></a></li>
<li><a href='#surv.km'>
<p>Estimates survival using Kaplan-Meier estimation</p></a></li>
<li><a href='#surv.km.base'>
<p>Estimates survival using Kaplan-Meier estimation</p></a></li>
<li><a href='#surv.land.obs'>
<p>Estimates survival using landmark estimation</p></a></li>
<li><a href='#surv.land.obs.base'>
<p>Estimates survival using landmark estimation</p></a></li>
<li><a href='#surv.land.rct'>
<p>Estimates survival using landmark estimation</p></a></li>
<li><a href='#surv.land.rct.base'>
<p>Estimates survival using landmark estimation</p></a></li>
<li><a href='#VTM'>

<p>Repeats a row.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Landmark Estimation of Survival and Treatment Effect</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Layla Parast</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Layla Parast &lt;parast@austin.utexas.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to estimate survival and a treatment effect using a landmark estimation approach.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, survival</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-25 23:24:38 UTC; parastlm</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-25 23:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='cumsum2'>

Helper function
</h2><span id='topic+cumsum2'></span>

<h3>Description</h3>


<p>Helper function; should not be called directly by user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cumsum2(mydat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cumsum2_+3A_mydat">mydat</code></td>
<td>

<p>mydat</p>
</td></tr>
</table>


<h3>Value</h3>






<table>
<tr><td><code>out</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>


<p>Layla Parast
</p>

<hr>
<h2 id='delper.si'>

Helper function
</h2><span id='topic+helper.si'></span>

<h3>Description</h3>


<p>Helper function; should not be called directly by user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>helper.si(yy,FUN,Yi,Vi=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delper.si_+3A_yy">yy</code></td>
<td>

<p>yy
</p>
</td></tr>
<tr><td><code id="delper.si_+3A_fun">FUN</code></td>
<td>

<p>FUN</p>
</td></tr>
<tr><td><code id="delper.si_+3A_yi">Yi</code></td>
<td>

<p>Yi</p>
</td></tr>
<tr><td><code id="delper.si_+3A_vi">Vi</code></td>
<td>

<p>Vi</p>
</td></tr>
</table>


<h3>Value</h3>






<table>
<tr><td><code>out</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>


<p>Layla Parast
</p>

<hr>
<h2 id='delta.iptw.km'>
Estimates survival and treatment effect using inverse probability of treatment weighted (IPTW) Kaplan-Meier estimation
</h2><span id='topic+delta.iptw.km'></span>

<h3>Description</h3>

<p>Estimates the probability of survival past some specified time and the treatment effect, defined as the difference in survival at the specified time, using inverse probability of treatment weighted (IPTW) Kaplan-Meier estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta.iptw.km(tl, dl, treat, tt, var = FALSE, conf.int = FALSE, ps.weights = NULL, 
weight.perturb = NULL, perturb.ps = FALSE, cov.for.ps = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta.iptw.km_+3A_tl">tl</code></td>
<td>

<p>observed event time of primary outcome, equal to min(T, C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.iptw.km_+3A_dl">dl</code></td>
<td>

<p>event indicator, equal to I(T&lt;C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.iptw.km_+3A_treat">treat</code></td>
<td>

<p>treatment indicator, should be 0/1.
</p>
</td></tr>
<tr><td><code id="delta.iptw.km_+3A_tt">tt</code></td>
<td>

<p>the time of interest, function estimates the probability of survival past this time	
</p>
</td></tr>
<tr><td><code id="delta.iptw.km_+3A_var">var</code></td>
<td>

<p>TRUE or FALSE; indicates whether variance estimates for the treatment effect and survival in each group are requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="delta.iptw.km_+3A_conf.int">conf.int</code></td>
<td>

<p>TRUE or FALSE; indicates whether 95% confidence intervals for the treatment effect and survival in each group are requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="delta.iptw.km_+3A_ps.weights">ps.weights</code></td>
<td>

<p>propensity score (or inverse probability of treatment) weights
</p>
</td></tr>
<tr><td><code id="delta.iptw.km_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>a (n1+n0) by x matrix of weights where n1 = length of tl for treatment group 1 and n0 =  length of tl for treatment group 0; used for perturbation-resampling, default is null. If var or conf.int is TRUE and weight.perturb is not provided, the function generates exponential(1) weights. 
</p>
</td></tr>
<tr><td><code id="delta.iptw.km_+3A_perturb.ps">perturb.ps</code></td>
<td>

<p>TRUE or FALSE indicating whether the weight.perturb matrix includes the perturbed propensity score (or inverse probability of treatment) weights; if cov.for.ps is supplied instead of ps.weights, this is forced to be TRUE.
</p>
</td></tr>
<tr><td><code id="delta.iptw.km_+3A_cov.for.ps">cov.for.ps</code></td>
<td>

<p>matrix of covariates to be used to estimate propensity score (or inverse probability of treatment) weights; either ps.weights or cov.for.ps must be supplied. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let  <code class="reqn">T_{Li}</code> denote the time of the primary event of interest for person <code class="reqn">i</code>, <code class="reqn">C_i</code> denote the censoring time,  <code class="reqn">Z_{i}</code> denote the vector of baseline (pretreatment) covariates, and <code class="reqn">G_i</code> be the treatment group indicator such that <code class="reqn">G_i = 1</code> indicates treatment and <code class="reqn">G_i = 0</code> indicates control. Due to censoring, we observe <code class="reqn">X_{Li}= min(T_{Li}, C_{i})</code> and <code class="reqn">\delta_{Li} = I(T_{Li}\leq C_{i})</code>. This function estimates survival at time t within each treatment group, <code class="reqn">S_j(t) = P(T_{L} &gt; t | G = j)</code> for <code class="reqn">j = 1,0</code> and the treatment effect defined as <code class="reqn">\Delta(t) = S_1(t) - S_0(t)</code>.
</p>
<p>The inverse probability of treatment weighted (IPTW) Kaplan-Meier (KM) estimate of survival at time t for each treatment group is 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{S}_{IPTW,KM, j}(t) = 
       \prod _{t_{kj} \leq t} \left [1-\frac{d_{kj}^w}{y_{kj}^w}\right ]  \mbox{ if } t\geq t_{1j}, \mbox{ or } 
         1  \mbox{ if } t&lt;t_{1j}</code>
</p>
      
<p>where <code class="reqn">t_{1j},...,t_{Dj}</code> are the distinct observed event times of the primary outcome in treatment group j, <code class="reqn">d_{kj}^w = \sum_{i: X_{Li} = t_{kj}, \delta_{Li} = 1} {\hat{W}_j(Z_i)}^{-1}\delta_{Li} I(G_i = j)</code> and  <code class="reqn">y_{kj}^w = \sum_{i: X_{Li}  \geq  t_{kj}} {\hat{W}_j(Z_i)}^{-1} I(G_i = j), W_j(Z_i) = {P(G_{i} = j | Z_i)}</code>, and <code class="reqn">\hat{W}_j(Z_i)</code> is the estimated propensity score (see ps.wgt.fun for more information).  The IPTW KM estimate of treatment effect at time t is <code class="reqn">\hat{\Delta}_{IPTW,KM}(t) = \hat{S}_{IPTW,KM, 1}(t) - \hat{S}_{IPTW,KM, 0}(t)</code>.
</p>
<p>To obtain variance estimates and construct confidence intervals, we  use a perturbation-resampling method. Specifically, let <code class="reqn">\{V^{(b)}=(V_1^{(b)}, . . . ,V_n^{(b)})^{T}, b=1,...B\}</code> be 
<code class="reqn">n\times B</code> independent copies of a positive random variable U from a known distribution with unit mean and unit variance such as an Exp(1) distribution.  To estimate the variance of our estimates, we appropriately weight the estimates using these perturbation weights to obtain perturbed values: <code class="reqn">\hat{S}_{IPTW,KM,0} (t)^{(b)}</code>, <code class="reqn">\hat{S}_{IPTW,KM,1} (t)^{(b)}</code>, and <code class="reqn">\hat{\Delta}_{IPTW,KM} (t)^{(b)}, b=1,...B</code>. We then estimate the variance of each estimate as the empirical variance of the perturbed quantities. To construct confidence intervals, one can either use the empirical percentiles of the perturbed samples  or a normal approximation.
</p>


<h3>Value</h3>

<p>A list is returned:
</p>
<table>
<tr><td><code>S.estimate.1</code></td>
<td>
<p>the estimate of survival at the time of interest for treatment group 1, <code class="reqn">\hat{S}_1(t) = P(T&gt;t | G=1)</code></p>
</td></tr>
<tr><td><code>S.estimate.0</code></td>
<td>
<p>the estimate of survival at the time of interest for treatment group 0, <code class="reqn">\hat{S}_0(t) = P(T&gt;t | G=0)</code></p>
</td></tr>
<tr><td><code>delta.estimate</code></td>
<td>
<p>the estimate of treatment effect at the time of interest</p>
</td></tr>
<tr><td><code>S.var.1</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{S}_1(t)</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>S.var.0</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{S}_0(t)</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>delta.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}(t)</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value from testing <code class="reqn">\Delta(t) = 0</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.normal.S.1</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}_1(t)</code> based on a normal approximation; if conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.normal.S.0</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}_0(t)</code> based on a normal approximation; if conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.normal.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on a normal approximation; if conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.quantile.S.1</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}_1(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE</p>
</td></tr> 
<tr><td><code>conf.int.quantile.S.0</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}_0(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE</p>
</td></tr> 
<tr><td><code>conf.int.quantile.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Xie, J., &amp; Liu, C. (2005). Adjusted Kaplan-Meier estimator and log-rank test with inverse probability of treatment weighting for survival data. Statistics in Medicine, 24(20), 3089-3110.
</p>
<p>Rosenbaum, P. R., &amp; Rubin, D. B. (1983). The central role of the propensity score in observational studies for causal effects. Biometrika, 70(1), 41-55.
</p>
<p>Rosenbaum, P. R., &amp; Rubin, D. B. (1984). Reducing bias in observational studies using subclassification on the propensity score. Journal of the American Statistical Association, 79(387), 516-524.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_obs)
W.weight = ps.wgt.fun(treat = example_obs$treat, cov.for.ps = as.matrix(example_obs$Z))	
delta.iptw.km(tl=example_obs$TL, dl = example_obs$DL, treat = example_obs$treat, tt=2, 
ps.weights = W.weight) 
delta.iptw.km(tl=example_obs$TL, dl = example_obs$DL, treat = example_obs$treat, tt=2,
cov.for.ps = as.matrix(example_obs$Z)) 
</code></pre>

<hr>
<h2 id='delta.km'>
Estimates survival and treatment effect using Kaplan-Meier estimation
</h2><span id='topic+delta.km'></span>

<h3>Description</h3>

<p>Estimates the probability of survival past some specified time and the treatment effect, defined as the difference in survival at the specified time, using Kaplan-Meier estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta.km(tl, dl, treat, tt, var = FALSE, conf.int = FALSE, weight.perturb = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta.km_+3A_tl">tl</code></td>
<td>

<p>observed event time of primary outcome, equal to min(T, C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.km_+3A_dl">dl</code></td>
<td>

<p>event indicator, equal to I(T&lt;C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.km_+3A_treat">treat</code></td>
<td>

<p>treatment indicator, should be 0/1.
</p>
</td></tr>
<tr><td><code id="delta.km_+3A_tt">tt</code></td>
<td>

<p>the time of interest, function estimates the probability of survival past this time	
</p>
</td></tr>
<tr><td><code id="delta.km_+3A_var">var</code></td>
<td>

<p>TRUE or FALSE; indicates whether variance estimates for the treatment effect and survival in each group are requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="delta.km_+3A_conf.int">conf.int</code></td>
<td>

<p>TRUE or FALSE; indicates whether 95% confidence intervals for the treatment effect and survival in each group are requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="delta.km_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>a (n1+n0) by x matrix of weights where n1 = length of tl for treatment group 1 and n0 =  length of tl for treatment group 0; used for perturbation-resampling, default is null. If var or conf.int is TRUE and weight.perturb is not provided, the function generates exponential(1) weights. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let  <code class="reqn">T_{Li}</code> denote the time of the primary event of interest for person <code class="reqn">i</code>, <code class="reqn">C_i</code> denote the censoring time and <code class="reqn">G_i</code> be the treatment group indicator such that <code class="reqn">G_i = 1</code> indicates treatment and <code class="reqn">G_i = 0</code> indicates control. Due to censoring, we observe <code class="reqn">X_{Li}= min(T_{Li}, C_{i})</code> and <code class="reqn">\delta_{Li} = I(T_{Li}\leq C_{i})</code>. This function estimates survival at time t within each treatment group, <code class="reqn">S_j(t) = P(T_{L} &gt; t | G = j)</code> for <code class="reqn">j = 1,0</code> and the treatment effect defined as <code class="reqn">\Delta(t) = S_1(t) - S_0(t)</code>.
</p>
<p>The Kaplan-Meier (KM) estimate of survival at time t for each treatment group is 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{S}_{KM, j}(t) = 
        \prod _{t_{kj} \leq t} \left [1-\frac{d_{kj}}{y_{kj}}\right ] \mbox{ if } t\geq t_{1j}, \mbox{ or } 
         1  \mbox{ if } t&lt;t_{1j}</code>
</p>
      
<p>where <code class="reqn">t_{1j},...,t_{Dj}</code> are the distinct observed event times of the primary outcome in treatment group j, <code class="reqn">d_{kj}</code> is the number of events at time <code class="reqn">t_{kj}</code> in treatment group j, and <code class="reqn">y_{kj}</code> is the number of patients at risk at <code class="reqn">t_{kj}</code> in treatment group j. The Kaplan-Meier (KM) estimate of treatment effect at time t is <code class="reqn">\hat{\Delta}_{KM}(t) = \hat{S}_{KM, 1}(t) - \hat{S}_{KM, 0}(t)</code>.
</p>
<p>To obtain variance estimates and construct confidence intervals, we  use a perturbation-resampling method. Specifically, let <code class="reqn">\{V^{(b)}=(V_1^{(b)}, . . . ,V_n^{(b)})^{T}, b=1,...B\}</code> be 
<code class="reqn">n\times B</code> independent copies of a positive random variable U from a known distribution with unit mean and unit variance such as an Exp(1) distribution.  To estimate the variance of our estimates, we appropriately weight the estimates using these perturbation weights to obtain perturbed values: <code class="reqn">\hat{S}_{KM,0} (t)^{(b)}</code>, <code class="reqn">\hat{S}_{KM,1} (t)^{(b)}</code>, and <code class="reqn">\hat{\Delta}_{KM} (t)^{(b)}, b=1,...B</code>. We then estimate the variance of each estimate as the empirical variance of the perturbed quantities. To construct confidence intervals, one can either use the empirical percentiles of the perturbed samples  or a normal approximation.
</p>


<h3>Value</h3>

<p>A list is returned:
</p>
<table>
<tr><td><code>S.estimate.1</code></td>
<td>
<p>the estimate of survival at the time of interest for treatment group 1, <code class="reqn">\hat{S}_1(t) = P(T&gt;t | G=1)</code></p>
</td></tr>
<tr><td><code>S.estimate.0</code></td>
<td>
<p>the estimate of survival at the time of interest for treatment group 0, <code class="reqn">\hat{S}_0(t) = P(T&gt;t | G=0)</code></p>
</td></tr>
<tr><td><code>delta.estimate</code></td>
<td>
<p>the estimate of treatment effect at the time of interest</p>
</td></tr>
<tr><td><code>S.var.1</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{S}_1(t)</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>S.var.0</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{S}_0(t)</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>delta.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}(t)</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value from testing <code class="reqn">\Delta(t) = 0</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.normal.S.1</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}_1(t)</code> based on a normal approximation; if conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.normal.S.0</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}_0(t)</code> based on a normal approximation; if conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.normal.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on a normal approximation; if conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.quantile.S.1</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}_1(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE</p>
</td></tr> 
<tr><td><code>conf.int.quantile.S.0</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}_0(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE</p>
</td></tr> 
<tr><td><code>conf.int.quantile.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Kaplan, E. L., &amp; Meier, P. (1958). Nonparametric estimation from incomplete observations. Journal of the American Statistical Association, 53(282), 457-481.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_rct)
delta.km(tl=example_rct$TL, dl = example_rct$DL, treat = example_rct$treat, tt=2)

</code></pre>

<hr>
<h2 id='delta.land.obs'>
Estimates survival and treatment effect using landmark estimation
</h2><span id='topic+delta.land.obs'></span>

<h3>Description</h3>

<p>Estimates the probability of survival past some specified time and the treatment effect, defined as the difference in survival at the specified time, using landmark estimation for an observational study setting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta.land.obs(tl, dl, treat, tt, landmark, short = NULL, z.cov = NULL, 
var = FALSE, conf.int = FALSE, ps.weights = NULL, weight.perturb = NULL, 
perturb.ps = FALSE, cov.for.ps = NULL, bw = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta.land.obs_+3A_tl">tl</code></td>
<td>

<p>observed event time of primary outcome, equal to min(T, C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.land.obs_+3A_dl">dl</code></td>
<td>

<p>event indicator, equal to I(T&lt;C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.land.obs_+3A_treat">treat</code></td>
<td>

<p>treatment indicator, should be 0/1.
</p>
</td></tr>
<tr><td><code id="delta.land.obs_+3A_tt">tt</code></td>
<td>

<p>the time of interest, function estimates the probability of survival past this time	
</p>
</td></tr>
<tr><td><code id="delta.land.obs_+3A_landmark">landmark</code></td>
<td>

<p>the landmark time
</p>
</td></tr>
<tr><td><code id="delta.land.obs_+3A_short">short</code></td>
<td>

<p>a matrix of intermediate event information, there should be two columns for each intermediate event, the first column contains the observed intermediate event time, equal to min(TS, C) where TS is the event time and C is the censoring time, and the second column contains the event indicator, equal to I(TS&lt;C)</p>
</td></tr>
<tr><td><code id="delta.land.obs_+3A_z.cov">z.cov</code></td>
<td>

<p>matrix of baseline covariate information
</p>
</td></tr>
<tr><td><code id="delta.land.obs_+3A_var">var</code></td>
<td>

<p>TRUE or FALSE; indicates whether variance estimates for the treatment effect and survival in each group are requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="delta.land.obs_+3A_conf.int">conf.int</code></td>
<td>

<p>TRUE or FALSE; indicates whether 95% confidence intervals for the treatment effect and survival in each group are requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="delta.land.obs_+3A_ps.weights">ps.weights</code></td>
<td>

<p>propensity score (or inverse probability of treatment) weights
</p>
</td></tr>
<tr><td><code id="delta.land.obs_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>a (n1+n0) by x matrix of weights where n1 = length of tl for treatment group 1 and n0 =  length of tl for treatment group 0; used for perturbation-resampling, default is null. If var or conf.int is TRUE and weight.perturb is not provided, the function generates exponential(1) weights. 
</p>
</td></tr>
<tr><td><code id="delta.land.obs_+3A_perturb.ps">perturb.ps</code></td>
<td>

<p>TRUE or FALSE indicating whether the weight.perturb matrix includes the perturbed propensity score (or inverse probability of treatment) weights; if cov.for.ps is supplied instead of ps.weights, this is forced to be TRUE.
</p>
</td></tr>
<tr><td><code id="delta.land.obs_+3A_cov.for.ps">cov.for.ps</code></td>
<td>

<p>matrix of covariates to be used to estimate propensity score (or inverse probability of treatment) weights; either ps.weights or cov.for.ps must be supplied. 
</p>
</td></tr>
<tr><td><code id="delta.land.obs_+3A_bw">bw</code></td>
<td>

<p>bandwidth used for kernel estimation, default is NULL
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let  <code class="reqn">T_{Li}</code> denote the time of the primary event of interest for person <code class="reqn">i</code>, <code class="reqn">T_{Si}</code> denote the time of the available intermediate event(s), <code class="reqn">C_i</code> denote the censoring time, <code class="reqn">Z_{i}</code> denote the vector of baseline (pretreatment) covariates, and <code class="reqn">G_i</code> be the treatment group indicator such that <code class="reqn">G_i = 1</code> indicates treatment and <code class="reqn">G_i = 0</code> indicates control. Due to censoring, we observe <code class="reqn">X_{Li}= min(T_{Li}, C_{i})</code> and <code class="reqn">\delta_{Li} = I(T_{Li}\leq C_{i})</code> and <code class="reqn">X_{Si}= min(T_{Si}, C_{i})</code> and <code class="reqn">\delta_{Si} = I(T_{Si}\leq C_{i})</code>. This function estimates survival at time t within each treatment group, <code class="reqn">S_j(t) = P(T_{L} &gt; t | G = j)</code> for <code class="reqn">j = 1,0</code> and the treatment effect defined as <code class="reqn">\Delta(t) = S_1(t) - S_0(t)</code>.
</p>
<p>To derive these estimates using landmark estimation for an observational study setting, we first decompose the quantity into two components <code class="reqn">S_j (t)= S_j(t|t_0) S_j(t_0)</code> using a landmark time <code class="reqn">t_0</code> and estimate each component separately incorporating inverse probability of treatment weights (IPTW) to account for potential selection bias. Let <code class="reqn">W_j(Z_i) = {P(G_{i} = j | Z_i)}</code>, and <code class="reqn">\hat{W}_j(Z_i)</code> be the estimated propensity score (or probability of treatment, see ps.wgt.fun for more information). In this presentation, we assume <code class="reqn">Z_i</code> indicates the vector of baseline (pretreatment) covariates and that <code class="reqn">Z_i</code> is used to estimate the propensity scores and incorporated into the survival and treatment effect estimation. However, the function allows one to use different subsets of <code class="reqn">Z_i</code> for the propensity score estimation vs. survival estimation, as is appropriate in the setting of interest. Intermediate event information is used in estimation of the conditional component <code class="reqn">S_j(t|t_0)</code>, 
</p>
<p style="text-align: center;"><code class="reqn">S_j(t|t_0)= P(T_L&gt;t |T_L&gt; t_0,G=j)=E[E[I(T_L&gt;t | T_L&gt; t_0,G=j,H)]]=E[S_{j,H} (t|t_0)]</code>
</p>

<p>where <code class="reqn">S_{j,H}(t|t_0) = P(T_L&gt;t | T_L&gt; t_0,G=j,H)</code> and <code class="reqn">H = \{Z, I(T_S \leq t_0), min(T_S, t_0) \}.</code> Then <code class="reqn">S_{j,H}(t|t_0)</code> is estimated in two stages. The first stage involves fitting a weighted Cox proportional hazards model  among individuals with <code class="reqn">X_L&gt; t_0</code> to obtain an estimate of <code class="reqn">\beta</code>, denoted as <code class="reqn">\hat{\beta}</code>, </p>
<p style="text-align: center;"><code class="reqn">S_{j,H}(t|t_0)=\exp \{-\Lambda_{j,0} (t|t_0) \exp(\beta^{T} H) \} </code>
</p>

<p>where <code class="reqn">\Lambda_{j,0} (t|t_0)</code> is the cumulative baseline hazard in group <code class="reqn">j</code>. Specifically,  <code class="reqn">\hat{\beta}</code> is the solution to the weighted Cox partial likelhoodand, with weights <code class="reqn">\hat{W}_j(Z_i)^{-1}</code>. The second stage uses a weighted nonparametric kernel Nelson-Aalen estimator to obtain a local constant estimator for the conditional hazard <code class="reqn">\Lambda_{j,u}(t|t_0) = -\log [S_{j,u}(t|t_0)]</code> as 
</p>
<p style="text-align: center;"><code class="reqn">\hat{\Lambda}_{j,u}(t|t_0) = \int_{t_0}^t \frac{\sum_i \hat{W}_j(Z_i)^{-1} K_h(\hat{U}_i - u) dN_i(z)}{\sum_i \hat{W}_j(Z_i)^{-1} K_h(\hat{U}_i - u) Y_i(z)}</code>
</p>

<p>where <code class="reqn">S_{j,u}(t|t_0)=P(T_L&gt;t | T_L&gt; t_0,G=j,\hat{U}=u), \hat{U} = \hat{\beta}^{T} H, Y_i(t)=I(T_L \geq t),N_i (t)=I(T_L\leq t)I(T_L&lt;C),K(\cdot)</code> is a smooth symmetric density function, <code class="reqn">K_h (x/h)/h</code>,  <code class="reqn">h=O(n^{-v})</code> is a bandwidth with <code class="reqn">1/2 &gt; v &gt; 1/4</code>, and the summation is over all individuals with <code class="reqn">G=j</code> and <code class="reqn">X_L&gt;t_0</code>.  The resulting estimate for <code class="reqn">S_{j,u}(t|t_0)</code> is <code class="reqn">\hat{S}_{j,u}(t|t_0) = \exp \{-\hat{\Lambda}_{j,u}(t|t_0)\}</code>, and the final estimate </p>
<p style="text-align: center;"><code class="reqn">\hat{S}_j(t|t_0) = \frac{n^{-1} \sum_{i =1}^n   \hat{W}_j(Z_i)^{-1} \hat{S}_j(t|t_0, H_i) I(G_i=1)I(X_{Li} &gt; t_0)}{n^{-1} \sum_{i =1}^n  \hat{W}_j(Z_i)^{-1} I(G_i=1)I(X_{Li} &gt; t_0) }</code>
</p>

<p>is a consistent estimate of <code class="reqn">S_j(t|t_0)</code>.
</p>
<p>Estimation of <code class="reqn">S_j(t_0)</code> uses a similar two-stage approach but using only baseline covariates, to obtain  <code class="reqn">\hat{S}_j(t_0)</code>. The final overall estimate of survival at time <code class="reqn">t</code> is, <code class="reqn">\hat{S}_{LM,j} (t)=  \hat{S}_j(t|t_0) \hat{S}_j(t_0)</code>. The treatment effect in terms of the difference in survival at time <code class="reqn">t</code> is estimated as <code class="reqn">\hat{\Delta}_{LM}(t) = \hat{S}_{LM,1}(t) - \hat{S}_{LM,0}(t).</code>   To obtain an appropriate <code class="reqn">h</code> we first use the bandwidth selection procedure given by Scott(1992) to obtain <code class="reqn">h_{opt}</code>; and then we let <code class="reqn">h = h_{opt}n_j^{-0.10}</code>. 
</p>
<p>To obtain variance estimates and construct confidence intervals, we  use a perturbation-resampling method. Specifically, let <code class="reqn">\{V^{(b)}=(V_1^{(b)}, . . . ,V_n^{(b)})^{T}, b=1,...B\}</code> be 
<code class="reqn">n\times B</code> independent copies of a positive random variable U from a known distribution with unit mean and unit variance such as an Exp(1) distribution.  To estimate the variance of our estimates, we appropriately weight the estimates using these perturbation weights to obtain perturbed values: <code class="reqn">\hat{S}_{LM,0} (t)^{(b)}</code>, <code class="reqn">\hat{S}_{LM,1} (t)^{(b)}</code>, and <code class="reqn">\hat{\Delta}_{LM} (t)^{(b)}, b=1,...B</code>. We then estimate the variance of each estimate as the empirical variance of the perturbed quantities. To construct confidence intervals, one can either use the empirical percentiles of the perturbed samples  or a normal approximation.
</p>


<h3>Value</h3>

<p>A list is returned:
</p>
<table>
<tr><td><code>S.estimate.1</code></td>
<td>
<p>the estimate of survival at the time of interest for treatment group 1, <code class="reqn">\hat{S}_1(t) = P(T&gt;t | G=1)</code></p>
</td></tr>
<tr><td><code>S.estimate.0</code></td>
<td>
<p>the estimate of survival at the time of interest for treatment group 0, <code class="reqn">\hat{S}_0(t) = P(T&gt;t | G=0)</code></p>
</td></tr>
<tr><td><code>delta.estimate</code></td>
<td>
<p>the estimate of treatment effect at the time of interest</p>
</td></tr>
<tr><td><code>S.var.1</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{S}_1(t)</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>S.var.0</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{S}_0(t)</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>delta.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}(t)</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value from testing <code class="reqn">\Delta(t) = 0</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.normal.S.1</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}_1(t)</code> based on a normal approximation; if conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.normal.S.0</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}_0(t)</code> based on a normal approximation; if conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.normal.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on a normal approximation; if conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.quantile.S.1</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}_1(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE</p>
</td></tr> 
<tr><td><code>conf.int.quantile.S.0</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}_0(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE</p>
</td></tr> 
<tr><td><code>conf.int.quantile.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Parast, L. &amp; Griffin B.A. (2017). Landmark Estimation of Survival and Treatment Effects in Observational Studies. Lifetime Data Analysis, 23:161-182.
</p>
<p>Rosenbaum, P. R., &amp; Rubin, D. B. (1983). The central role of the propensity score in observational studies for causal effects. Biometrika, 70(1), 41-55.
</p>
<p>Rosenbaum, P. R., &amp; Rubin, D. B. (1984). Reducing bias in observational studies using subclassification on the propensity score. Journal of the American Statistical Association, 79(387), 516-524.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_obs)
W.weight = ps.wgt.fun(treat = example_obs$treat, cov.for.ps = as.matrix(example_obs$Z))	
#executable but takes time
#delta.land.obs(tl=example_obs$TL, dl = example_obs$DL, treat = example_obs$treat, tt=2, 
#landmark = 1, short = cbind(example_obs$TS,example_obs$DS), z.cov = as.matrix(example_obs$Z),
#ps.weights = W.weight)
#delta.land.obs(tl=example_obs$TL, dl = example_obs$DL, treat = example_obs$treat, tt=2, 
#landmark = 1, short = cbind(example_obs$TS,example_obs$DS), z.cov = as.matrix(example_obs$Z),
#cov.for.ps = as.matrix(example_obs$Z))

</code></pre>

<hr>
<h2 id='delta.land.rct'>
Estimates survival and treatment effect using landmark estimation
</h2><span id='topic+delta.land.rct'></span>

<h3>Description</h3>

<p>Estimates the probability of survival past some specified time and the treatment effect, defined as the difference in survival at the specified time, using landmark estimation for a randomized trial setting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta.land.rct(tl, dl, treat, tt, landmark, short = NULL, z.cov = NULL, 
var = FALSE, conf.int = FALSE, weight.perturb = NULL, bw = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta.land.rct_+3A_tl">tl</code></td>
<td>

<p>observed event time of primary outcome, equal to min(T, C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.land.rct_+3A_dl">dl</code></td>
<td>

<p>event indicator, equal to I(T&lt;C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="delta.land.rct_+3A_treat">treat</code></td>
<td>

<p>treatment indicator, should be 0/1.
</p>
</td></tr>
<tr><td><code id="delta.land.rct_+3A_tt">tt</code></td>
<td>

<p>the time of interest, function estimates the probability of survival past this time	
</p>
</td></tr>
<tr><td><code id="delta.land.rct_+3A_landmark">landmark</code></td>
<td>

<p>the landmark time
</p>
</td></tr>
<tr><td><code id="delta.land.rct_+3A_short">short</code></td>
<td>

<p>a matrix of intermediate event information, there should be two columns for each intermediate event, the first column contains the observed intermediate event time, equal to min(TS, C) where TS is the event time and C is the censoring time, and the second column contains the event indicator, equal to I(TS&lt;C)</p>
</td></tr>
<tr><td><code id="delta.land.rct_+3A_z.cov">z.cov</code></td>
<td>

<p>matrix of baseline covariate information
</p>
</td></tr>
<tr><td><code id="delta.land.rct_+3A_var">var</code></td>
<td>

<p>TRUE or FALSE; indicates whether variance estimates for the treatment effect and survival in each group are requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="delta.land.rct_+3A_conf.int">conf.int</code></td>
<td>

<p>TRUE or FALSE; indicates whether 95% confidence intervals for the treatment effect and survival in each group are requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="delta.land.rct_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>a (n1+n0) by x matrix of weights where n1 = length of tl for treatment group 1 and n0 =  length of tl for treatment group 0; used for perturbation-resampling, default is null. If var or conf.int is TRUE and weight.perturb is not provided, the function generates exponential(1) weights. 
</p>
</td></tr>
<tr><td><code id="delta.land.rct_+3A_bw">bw</code></td>
<td>

<p>bandwidth used for kernel estimation, default is NULL
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let  <code class="reqn">T_{Li}</code> denote the time of the primary event of interest for person <code class="reqn">i</code>, <code class="reqn">T_{Si}</code> denote the time of the available intermediate event(s), <code class="reqn">C_i</code> denote the censoring time, <code class="reqn">Z_{i}</code> denote the vector of baseline (pretreatment) covariates, and <code class="reqn">G_i</code> be the treatment group indicator such that <code class="reqn">G_i = 1</code> indicates treatment and <code class="reqn">G_i = 0</code> indicates control. Due to censoring, we observe <code class="reqn">X_{Li}= min(T_{Li}, C_{i})</code> and <code class="reqn">\delta_{Li} = I(T_{Li}\leq C_{i})</code> and <code class="reqn">X_{Si}= min(T_{Si}, C_{i})</code> and <code class="reqn">\delta_{Si} = I(T_{Si}\leq C_{i})</code>. This function estimates survival at time t within each treatment group, <code class="reqn">S_j(t) = P(T_{L} &gt; t | G = j)</code> for <code class="reqn">j = 1,0</code> and the treatment effect defined as <code class="reqn">\Delta(t) = S_1(t) - S_0(t)</code>.
</p>
<p>To derive these estimates using landmark estimation, we first decompose the quantity into two components <code class="reqn">S_j (t)= S_j(t|t_0) S_j(t_0)</code> using a landmark time <code class="reqn">t_0</code> and estimate each component separately. Intermediate event information is used in estimation of the conditional component <code class="reqn">S_j(t|t_0)</code>, 
</p>
<p style="text-align: center;"><code class="reqn">S_j(t|t_0)= P(T_L&gt;t |T_L&gt; t_0,G=j)=E[E[I(T_L&gt;t | T_L&gt; t_0,G=j,H)]]=E[S_{j,H} (t|t_0)]</code>
</p>

<p>where <code class="reqn">S_{j,H}(t|t_0) = P(T_L&gt;t | T_L&gt; t_0,G=j,H)</code> and <code class="reqn">H = \{Z, I(T_S \leq t_0), min(T_S, t_0) \}.</code> Then <code class="reqn">S_{j,H}(t|t_0)</code> is estimated in two stages: 1) fitting the Cox proportional hazards model  among individuals with <code class="reqn">X_L&gt; t_0</code> to obtain an estimate of <code class="reqn">\beta</code>, denoted as <code class="reqn">\hat{\beta}</code>, </p>
<p style="text-align: center;"><code class="reqn">S_{j,H}(t|t_0)=\exp \{-\Lambda_{j,0} (t|t_0) \exp(\beta^{T} H) \} </code>
</p>

<p>where <code class="reqn">\Lambda_{j,0} (t|t_0)</code> is the cumulative baseline hazard in group <code class="reqn">j</code> and then 2) using a nonparametric kernel Nelson-Aalen estimator to obtain a local constant estimator for the conditional hazard <code class="reqn">\Lambda_{j,u}(t|t_0) = -\log [S_{j,u}(t|t_0)]</code> as 
</p>
<p style="text-align: center;"><code class="reqn">\hat{\Lambda}_{j,u}(t|t_0) = \int_{t_0}^t \frac{\sum_i K_h(\hat{U}_i - u) dN_i(z)}{\sum_i K_h(\hat{U}_i - u) Y_i(z)}</code>
</p>

<p>where <code class="reqn">S_{j,u}(t|t_0)=P(T_L&gt;t | T_L&gt; t_0,G=j,\hat{U}=u), \hat{U} = \hat{\beta}^{T} H, Y_i(t)=I(T_L \geq t),N_i (t)=I(T_L\leq t)I(T_L&lt;C),K(\cdot)</code> is a smooth symmetric density function, <code class="reqn">K_h (x/h)/h</code>,  <code class="reqn">h=O(n^{-v})</code> is a bandwidth with <code class="reqn">1/2 &gt; v &gt; 1/4</code>, and the summation is over all individuals with <code class="reqn">G=j</code> and <code class="reqn">X_L&gt;t_0</code>.  The resulting estimate for <code class="reqn">S_{j,u}(t|t_0)</code> is <code class="reqn">\hat{S}_{j,u}(t|t_0) = \exp \{-\hat{\Lambda}_{j,u}(t|t_0)\}</code>, and the final estimate </p>
<p style="text-align: center;"><code class="reqn">\hat{S}_j(t|t_0) =\frac{n^{-1} \sum_{i =1}^n  \hat{S}_j(t|t_0, H_i) I(G_i=1)I(X_{Li} &gt; t_0)}{n^{-1} \sum_{i =1}^n  I(G_i=1)I(X_{Li} &gt; t_0) }</code>
</p>
<p> is a consistent estimate of <code class="reqn">S_j(t|t_0)</code>.
</p>
<p>Estimation of <code class="reqn">S_j(t_0)</code> uses a similar two-stage approach but using only baseline covariates, to obtain  <code class="reqn">\hat{S}_j(t_0)</code>. The final overall estimate of survival at time <code class="reqn">t</code> is, <code class="reqn">\hat{S}_{LM,j} (t)=  \hat{S}_j(t|t_0) \hat{S}_j(t_0)</code>. The treatment effect in terms of the difference in survival at time <code class="reqn">t</code> is estimated as <code class="reqn">\hat{\Delta}_{LM}(t) = \hat{S}_{LM,1}(t) - \hat{S}_{LM,0}(t).</code>   To obtain an appropriate <code class="reqn">h</code> we first use the bandwidth selection procedure given by Scott(1992) to obtain <code class="reqn">h_{opt}</code>; and then we let <code class="reqn">h = h_{opt}n^{-0.10}</code>. 
</p>
<p>To obtain variance estimates and construct confidence intervals, we  use a perturbation-resampling method. Specifically, let <code class="reqn">\{V^{(b)}=(V_1^{(b)}, . . . ,V_n^{(b)})^{T}, b=1,...B\}</code> be 
<code class="reqn">n\times B</code> independent copies of a positive random variable U from a known distribution with unit mean and unit variance such as an Exp(1) distribution.  To estimate the variance of our estimates, we appropriately weight the estimates using these perturbation weights to obtain perturbed values: <code class="reqn">\hat{S}_{LM,0} (t)^{(b)}</code>, <code class="reqn">\hat{S}_{LM,1} (t)^{(b)}</code>, and <code class="reqn">\hat{\Delta}_{LM} (t)^{(b)}, b=1,...B</code>. We then estimate the variance of each estimate as the empirical variance of the perturbed quantities. To construct confidence intervals, one can either use the empirical percentiles of the perturbed samples  or a normal approximation.
</p>


<h3>Value</h3>

<p>A list is returned:
</p>
<table>
<tr><td><code>S.estimate.1</code></td>
<td>
<p>the estimate of survival at the time of interest for treatment group 1, <code class="reqn">\hat{S}_1(t) = P(T&gt;t | G=1)</code></p>
</td></tr>
<tr><td><code>S.estimate.0</code></td>
<td>
<p>the estimate of survival at the time of interest for treatment group 0, <code class="reqn">\hat{S}_0(t) = P(T&gt;t | G=0)</code></p>
</td></tr>
<tr><td><code>delta.estimate</code></td>
<td>
<p>the estimate of treatment effect at the time of interest</p>
</td></tr>
<tr><td><code>S.var.1</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{S}_1(t)</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>S.var.0</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{S}_0(t)</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>delta.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{\Delta}(t)</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value from testing <code class="reqn">\Delta(t) = 0</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.normal.S.1</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}_1(t)</code> based on a normal approximation; if conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.normal.S.0</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}_0(t)</code> based on a normal approximation; if conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.normal.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on a normal approximation; if conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.quantile.S.1</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}_1(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE</p>
</td></tr> 
<tr><td><code>conf.int.quantile.S.0</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}_0(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE</p>
</td></tr> 
<tr><td><code>conf.int.quantile.delta</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{\Delta}(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Parast, L., Tian, L., &amp; Cai, T. (2014). Landmark Estimation of Survival and Treatment Effect in a Randomized Clinical Trial. Journal of the American Statistical Association, 109(505), 384-394.
</p>
<p>Beran, R. (1981). Nonparametric regression with randomly censored survival data. Technical report, University of California Berkeley.
</p>
<p>Scott, D. (1992). Multivariate density estimation. Wiley.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_rct)
#executable but takes time
#delta.land.rct(tl=example_rct$TL, dl = example_rct$DL, treat = example_rct$treat, tt=2, 
#landmark = 1, short = cbind(example_rct$TS,example_rct$DS), z.cov = as.matrix(example_rct$Z))

</code></pre>

<hr>
<h2 id='Est.KM.FUN.weighted'>
Nonparametric Nelson-Aalen estimate of survival</h2><span id='topic+Est.KM.FUN.weighted'></span>

<h3>Description</h3>

<p>Nonparametric Nelson-Aalen estimate of survival</p>


<h3>Usage</h3>

<pre><code class='language-R'>Est.KM.FUN.weighted(xi, di, si, myt, weight.perturb = NULL, bw = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Est.KM.FUN.weighted_+3A_xi">xi</code></td>
<td>

<p>xi
</p>
</td></tr>
<tr><td><code id="Est.KM.FUN.weighted_+3A_di">di</code></td>
<td>

<p>di
</p>
</td></tr>
<tr><td><code id="Est.KM.FUN.weighted_+3A_si">si</code></td>
<td>

<p>si
</p>
</td></tr>
<tr><td><code id="Est.KM.FUN.weighted_+3A_myt">myt</code></td>
<td>

<p>myt
</p>
</td></tr>
<tr><td><code id="Est.KM.FUN.weighted_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>weight.perturb
</p>
</td></tr>
<tr><td><code id="Est.KM.FUN.weighted_+3A_bw">bw</code></td>
<td>

<p>bw
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Smoothed survival estimate.
</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>

<hr>
<h2 id='example_obs'>
Hypothetical data from an observational study
</h2><span id='topic+example_obs'></span>

<h3>Description</h3>

<p>Hypothetical data from an observational study to be used in examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(example_obs)</code></pre>


<h3>Format</h3>

<p>A data frame with 4000 observations on the following 6 variables.
</p>

<dl>
<dt><code>TL</code></dt><dd><p>the observed event or censoring time for the primary outcome, equal to min(T, C) where T is the time of the primary outcome and C is the censoring time.</p>
</dd>
<dt><code>DL</code></dt><dd><p>the indicator telling whether the individual was observed to have the event or was censored, equal to 1*(T&lt;C) where T is the time of the primary outcome and C is the censoring time.</p>
</dd>
<dt><code>TS</code></dt><dd><p>the observed event or censoring time for the intermediate event, equal to min(TS, C) where TS is the time of the intermediate event and C is the censoring time.</p>
</dd>
<dt><code>DS</code></dt><dd><p>the indicator telling whether the individual was observed to have the intermediate event or was censored, equal to 1*(TS&lt;C) where TS is the time of the primary outcome and C is the censoring time.</p>
</dd>
<dt><code>Z</code></dt><dd><p>a baseline covariate vector</p>
</dd>
<dt><code>treat</code></dt><dd><p>treatment indicator</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(example_obs)
names(example_obs)
</code></pre>

<hr>
<h2 id='example_rct'>
Hypothetical data from a randomized trial
</h2><span id='topic+example_rct'></span>

<h3>Description</h3>

<p>Hypothetical data from a randomized trial to be used in examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(example_rct)</code></pre>


<h3>Format</h3>

<p>A data frame with 3000 observations on the following 6 variables.
</p>

<dl>
<dt><code>TL</code></dt><dd><p>the observed event or censoring time for the primary outcome, equal to min(T, C) where T is the time of the primary outcome and C is the censoring time.</p>
</dd>
<dt><code>DL</code></dt><dd><p>the indicator telling whether the individual was observed to have the event or was censored, equal to 1*(T&lt;C) where T is the time of the primary outcome and C is the censoring time.</p>
</dd>
<dt><code>TS</code></dt><dd><p>the observed event or censoring time for the intermediate event, equal to min(TS, C) where TS is the time of the intermediate event and C is the censoring time.</p>
</dd>
<dt><code>DS</code></dt><dd><p>the indicator telling whether the individual was observed to have the intermediate event or was censored, equal to 1*(TS&lt;C) where TS is the time of the primary outcome and C is the censoring time.</p>
</dd>
<dt><code>Z</code></dt><dd><p>a baseline covariate vector</p>
</dd>
<dt><code>treat</code></dt><dd><p>treatment indicator</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(example_rct)
names(example_rct)
</code></pre>

<hr>
<h2 id='Kern.FUN'>

Calculates kernel matrix
</h2><span id='topic+Kern.FUN'></span>

<h3>Description</h3>


<p>Helper function; this calculates the kernel matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kern.FUN(zz, zi, bw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kern.FUN_+3A_zz">zz</code></td>
<td>


<p>zz
</p>
</td></tr>
<tr><td><code id="Kern.FUN_+3A_zi">zi</code></td>
<td>


<p>zi
</p>
</td></tr>
<tr><td><code id="Kern.FUN_+3A_bw">bw</code></td>
<td>


<p>bandwidth
</p>
</td></tr>
</table>


<h3>Value</h3>






<p>the kernel matrix
</p>


<h3>Author(s)</h3>


<p>Layla Parast
</p>

<hr>
<h2 id='landest-package'>
Survival and treatment effect estimation
</h2><span id='topic+landest-package'></span><span id='topic+landest'></span>

<h3>Description</h3>

<p>Provides functions to estimate the probability of survival past some specified time and the treatment effect, defined as the difference in survival at the specified time, using Kaplan-Meier estimation, landmark estimation for a randomized trial setting, inverse probability of treatment weighted (IPTW) Kaplan-Meier estimation, and landmark estimation for an observational study setting. The landmark estimation approaches provide improved efficiency by incorporating intermediate event information and are robust to model misspecification. The IPTW Kaplan-Meier approach and landmark estimation in an observational study setting approach account for potential selection bias.
</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Kaplan, E. L., &amp; Meier, P. (1958). Nonparametric estimation from incomplete observations. Journal of the American Statistical Association, 53(282), 457-481.
</p>
<p>Xie, J., &amp; Liu, C. (2005). Adjusted Kaplan-Meier estimator and log-rank test with inverse probability of treatment weighting for survival data. Statistics in Medicine, 24(20), 3089-3110.
</p>
<p>Parast, L., Tian, L., &amp; Cai, T. (2014). Landmark Estimation of Survival and Treatment Effect in a Randomized Clinical Trial. Journal of the American Statistical Association, 109(505), 384-394.
</p>
<p>Parast, L. &amp; Griffin B.A. (2017). Landmark Estimation of Survival and Treatment Effects in Observational Studies. Lifetime Data Analysis, 23:161-182.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_rct)
delta.km(tl=example_rct$TL, dl = example_rct$DL, treat = example_rct$treat, tt=2)
#executable but takes time
#delta.land.rct(tl=example_rct$TL, dl = example_rct$DL, treat = example_rct$treat, tt=2, 
#landmark = 1, short = cbind(example_rct$TS,example_rct$DS), z.cov = as.matrix(example_rct$Z))
data(example_obs)
delta.iptw.km(tl=example_obs$TL, dl = example_obs$DL, treat = example_obs$treat, tt=2,
cov.for.ps = as.matrix(example_obs$Z)) 
#executable but takes time
#delta.land.obs(tl=example_obs$TL, dl = example_obs$DL, treat = example_obs$treat, tt=2, 
#landmark = 1, short = cbind(example_obs$TS,example_obs$DS), z.cov = as.matrix(example_obs$Z),
#cov.for.ps = as.matrix(example_obs$Z))
</code></pre>

<hr>
<h2 id='ps.wgt.fun'>
Calculates propensity score weights</h2><span id='topic+ps.wgt.fun'></span>

<h3>Description</h3>

<p>Calculates propensity score (or inverse probability of treatment) weights given the treatment indicator and available baseline (pretreatment) covariates.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ps.wgt.fun(treat, cov.for.ps, weight = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ps.wgt.fun_+3A_treat">treat</code></td>
<td>

<p>treatment indicator, should be 0/1.</p>
</td></tr>
<tr><td><code id="ps.wgt.fun_+3A_cov.for.ps">cov.for.ps</code></td>
<td>

<p>matrix of covariates to be used to estimate propensity score (or inverse probability of treatment) weights
</p>
</td></tr>
<tr><td><code id="ps.wgt.fun_+3A_weight">weight</code></td>
<td>

<p>a (n1+n0) by x matrix of weights where n1 = number of observations in treatment group 1 and n0 =  number of observations in treatment group 0; used for perturbation-resampling, default is null.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">Z_{i}</code> denote the matrix of baseline (pretreatment) covariates and <code class="reqn">G_i</code> be the treatment group indicator such that <code class="reqn">G_i = 1</code> indicates treatment and <code class="reqn">G_i = 0</code> indicates control. This function estimates <code class="reqn">P = P(G_i = 1 | Z_i)</code> using logistic regression. The propensity score (or inverse probability of treatment) weights are then equal to <code class="reqn">1/\hat{P}</code> for those in treatment group 1 and <code class="reqn">1/(1-\hat{P})</code> for those in treatment group 0. These weights reflect the situation where the average treatment effect (ATE) is of interest, not average treatment effect in the treated (ATT).</p>


<h3>Value</h3>

<p>propensity score (or inverse probability of treatment) weights
</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Rosenbaum, P. R., &amp; Rubin, D. B. (1983). The central role of the propensity score in observational studies for causal effects. Biometrika, 70(1), 41-55.
</p>
<p>Rosenbaum, P. R., &amp; Rubin, D. B. (1984). Reducing bias in observational studies using subclassification on the propensity score. Journal of the American Statistical Association, 79(387), 516-524.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_obs)
W.weight = ps.wgt.fun(treat = example_obs$treat, cov.for.ps = as.matrix(example_obs$Z))	
delta.iptw.km(tl=example_obs$TL, dl = example_obs$DL, treat = example_obs$treat, tt=2, 
ps.weights = W.weight) 
</code></pre>

<hr>
<h2 id='surv.iptw.km'>
Estimates survival using inverse probability of treatment weighted (IPTW) Kaplan-Meier estimation
</h2><span id='topic+surv.iptw.km'></span>

<h3>Description</h3>

<p>Estimates the probability of survival past some specified time using inverse probability of treatment weighted (IPTW) Kaplan-Meier estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv.iptw.km(tl, dl, tt, var = FALSE, conf.int = FALSE, ps.weights, 
weight.perturb = NULL,perturb.ps = FALSE, perturb.vector = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv.iptw.km_+3A_tl">tl</code></td>
<td>

<p>observed event time of primary outcome, equal to min(T, C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="surv.iptw.km_+3A_dl">dl</code></td>
<td>

<p>event indicator, equal to I(T&lt;C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="surv.iptw.km_+3A_tt">tt</code></td>
<td>

<p>the time of interest, function estimates the probability of survival past this time	
</p>
</td></tr>
<tr><td><code id="surv.iptw.km_+3A_var">var</code></td>
<td>

<p>TRUE or FALSE; indicates whether a variance estimate for survival is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="surv.iptw.km_+3A_conf.int">conf.int</code></td>
<td>

<p>TRUE or FALSE; indicates whether a 95% confidence interval for survival is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="surv.iptw.km_+3A_ps.weights">ps.weights</code></td>
<td>

<p>propensity score (or inverse probability of treatment) weights
</p>
</td></tr>
<tr><td><code id="surv.iptw.km_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>a n by x matrix of weights where n = length of tl; used for perturbation-resampling, default is null. If var or conf.int is TRUE and weight.perturb is not provided, the function generates exponential(1) weights. 
</p>
</td></tr>
<tr><td><code id="surv.iptw.km_+3A_perturb.ps">perturb.ps</code></td>
<td>

<p>TRUE or FALSE indicating whether the weight.perturb matrix includes the perturbed propensity score (or inverse probability of treatment) weights
</p>
</td></tr>
<tr><td><code id="surv.iptw.km_+3A_perturb.vector">perturb.vector</code></td>
<td>

<p>TRUE or FALSE; indicates whether a vector of the perturbed values of the survival estimate is requested, default is FALSE. This argument is ignored if both var and conf.int are FALSE. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See documentation for delta.iptw.km for details.</p>


<h3>Value</h3>

<p>A list is returned:
</p>
<table>
<tr><td><code>S.estimate</code></td>
<td>
<p>the estimate of survival at the time of interest, <code class="reqn">\hat{S}(t) = P(T&gt;t)</code></p>
</td></tr>
<tr><td><code>S.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{S}(t)</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.normal.S</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}(t)</code> based on a normal approximation; if conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.quantile.S</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE</p>
</td></tr> 
<tr><td><code>perturb.vector</code></td>
<td>
<p>a vector of size x where x is the number of columns of the provided weight.perturb matrix (or x=500 if weight.perturb is not provided); the perturbed values of <code class="reqn">\hat{S}(t)</code>; if perturb.vector = TRUE and either var=TRUE or conf.int = TRUE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Xie, J., &amp; Liu, C. (2005). Adjusted Kaplan-Meier estimator and log-rank test with inverse probability of treatment weighting for survival data. Statistics in Medicine, 24(20), 3089-3110.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_obs)
W.weight = ps.wgt.fun(treat = example_obs$treat, cov.for.ps = as.matrix(example_obs$Z))	
example_obs.treat = example_obs[example_obs$treat == 1,]
surv.iptw.km(tl=example_obs.treat$TL, dl = example_obs.treat$DL, tt=2, ps.weights = 
W.weight[example_obs$treat == 1]) 
</code></pre>

<hr>
<h2 id='surv.iptw.km.base'>
Estimates survival using inverse probability of treatment weighted (IPTW) Kaplan-Meier estimation
</h2><span id='topic+surv.iptw.km.base'></span>

<h3>Description</h3>

<p>Estimates the probability of survival past some specified time using inverse probability of treatment weighted (IPTW) Kaplan-Meier estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv.iptw.km.base(tl, dl, tt, ps.weights, weight.perturb = NULL, perturb.ps = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv.iptw.km.base_+3A_tl">tl</code></td>
<td>

<p>observed event time of primary outcome, equal to min(T, C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="surv.iptw.km.base_+3A_dl">dl</code></td>
<td>

<p>event indicator, equal to I(T&lt;C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="surv.iptw.km.base_+3A_tt">tt</code></td>
<td>

<p>the time of interest, function estimates the probability of survival past this time	
</p>
</td></tr>
<tr><td><code id="surv.iptw.km.base_+3A_ps.weights">ps.weights</code></td>
<td>

<p>propensity score (or inverse probability of treatment) weights
</p>
</td></tr>
<tr><td><code id="surv.iptw.km.base_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>an optional weight matrix to be incorporated in estimation.
</p>
</td></tr>
<tr><td><code id="surv.iptw.km.base_+3A_perturb.ps">perturb.ps</code></td>
<td>

<p>TRUE or FALSE indicating whether the weight.perturb matrix includes the perturbed propensity score (or inverse probability of treatment) weights
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimate of survival at the specified time
</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>

<hr>
<h2 id='surv.km'>
Estimates survival using Kaplan-Meier estimation
</h2><span id='topic+surv.km'></span>

<h3>Description</h3>

<p>Estimates the probability of survival past some specified time using Kaplan-Meier estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv.km(tl, dl, tt, var = FALSE, conf.int = FALSE, weight.perturb = NULL, 
perturb.vector = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv.km_+3A_tl">tl</code></td>
<td>

<p>observed event time of primary outcome, equal to min(T, C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="surv.km_+3A_dl">dl</code></td>
<td>

<p>event indicator, equal to I(T&lt;C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="surv.km_+3A_tt">tt</code></td>
<td>

<p>the time of interest, function estimates the probability of survival past this time	
</p>
</td></tr>
<tr><td><code id="surv.km_+3A_var">var</code></td>
<td>

<p>TRUE or FALSE; indicates whether a variance estimate for survival is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="surv.km_+3A_conf.int">conf.int</code></td>
<td>

<p>TRUE or FALSE; indicates whether a 95% confidence interval for survival is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="surv.km_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>a n by x matrix of weights where n = length of tl; used for perturbation-resampling, default is null. If var or conf.int is TRUE and weight.perturb is not provided, the function generates exponential(1) weights. 
</p>
</td></tr>
<tr><td><code id="surv.km_+3A_perturb.vector">perturb.vector</code></td>
<td>

<p>TRUE or FALSE; indicates whether a vector of the perturbed values of the survival estimate is requested, default is FALSE. This argument is ignored if both var and conf.int are FALSE. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>See documentation for delta.km for details.
</p>


<h3>Value</h3>

<p>A list is returned:
</p>
<table>
<tr><td><code>S.estimate</code></td>
<td>
<p>the estimate of survival at the time of interest, <code class="reqn">\hat{S}(t) = P(T&gt;t)</code></p>
</td></tr>
<tr><td><code>S.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{S}(t)</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.normal.S</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}(t)</code> based on a normal approximation; if conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.quantile.S</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE</p>
</td></tr> 
<tr><td><code>perturb.vector</code></td>
<td>
<p>a vector of size x where x is the number of columns of the provided weight.perturb matrix (or x=500 if weight.perturb is not provided); the perturbed values of <code class="reqn">\hat{S}(t)</code>; if perturb.vector = TRUE and either var=TRUE or conf.int = TRUE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Kaplan, E. L., &amp; Meier, P. (1958). Nonparametric estimation from incomplete observations. Journal of the American Statistical Association, 53(282), 457-481.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_rct)
example_rct.treat = example_rct[example_rct$treat == 1,]
surv.km(tl=example_rct.treat$TL, dl = example_rct.treat$DL, tt=2)
</code></pre>

<hr>
<h2 id='surv.km.base'>
Estimates survival using Kaplan-Meier estimation
</h2><span id='topic+surv.km.base'></span>

<h3>Description</h3>

<p>Estimates the probability of survival past some specified time using Kaplan-Meier estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv.km.base(tl, dl, tt, weight.perturb = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv.km.base_+3A_tl">tl</code></td>
<td>

<p>observed event time of primary outcome, equal to min(T, C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="surv.km.base_+3A_dl">dl</code></td>
<td>

<p>event indicator, equal to I(T&lt;C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="surv.km.base_+3A_tt">tt</code></td>
<td>

<p>the time of interest, function estimates the probability of survival past this time	
</p>
</td></tr>
<tr><td><code id="surv.km.base_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>an optional weight matrix to be incorporated in estimation.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimate of survival at the specified time
</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>

<hr>
<h2 id='surv.land.obs'>
Estimates survival using landmark estimation
</h2><span id='topic+surv.land.obs'></span>

<h3>Description</h3>

<p>Estimates the probability of survival past some specified time using landmark estimation for an observational study setting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv.land.obs(tl, dl, tt, landmark, short = NULL, z.cov = NULL, var = FALSE, 
conf.int = FALSE, ps.weights, weight.perturb = NULL, perturb.ps = FALSE, 
perturb.vector = FALSE, bw = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv.land.obs_+3A_tl">tl</code></td>
<td>

<p>observed event time of primary outcome, equal to min(T, C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="surv.land.obs_+3A_dl">dl</code></td>
<td>

<p>event indicator, equal to I(T&lt;C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="surv.land.obs_+3A_tt">tt</code></td>
<td>

<p>the time of interest, function estimates the probability of survival past this time	
</p>
</td></tr>
<tr><td><code id="surv.land.obs_+3A_landmark">landmark</code></td>
<td>

<p>the landmark time
</p>
</td></tr>
<tr><td><code id="surv.land.obs_+3A_short">short</code></td>
<td>

<p>a matrix of intermediate event information, there should be two columns for each intermediate event, the first column contains the observed intermediate event time, equal to min(TS, C) where TS is the event time and C is the censoring time, and the second column contains the event indicator, equal to I(TS&lt;C)</p>
</td></tr>
<tr><td><code id="surv.land.obs_+3A_z.cov">z.cov</code></td>
<td>

<p>matrix of baseline covariate information</p>
</td></tr>
<tr><td><code id="surv.land.obs_+3A_var">var</code></td>
<td>

<p>TRUE or FALSE; indicates whether a variance estimate for survival is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="surv.land.obs_+3A_conf.int">conf.int</code></td>
<td>

<p>TRUE or FALSE; indicates whether a 95% confidence interval for survival is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="surv.land.obs_+3A_ps.weights">ps.weights</code></td>
<td>

<p>propensity score (or inverse probability of treatment) weights
</p>
</td></tr>
<tr><td><code id="surv.land.obs_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>a n by x matrix of weights where n = length of tl; used for perturbation-resampling, default is null. If var or conf.int is TRUE and weight.perturb is not provided, the function generates exponential(1) weights. 
</p>
</td></tr>
<tr><td><code id="surv.land.obs_+3A_perturb.ps">perturb.ps</code></td>
<td>

<p>TRUE or FALSE indicating whether the weight.perturb matrix includes the perturbed propensity score (or inverse probability of treatment) weights
</p>
</td></tr>
<tr><td><code id="surv.land.obs_+3A_perturb.vector">perturb.vector</code></td>
<td>

<p>TRUE or FALSE; indicates whether a vector of the perturbed values of the survival estimate is requested, default is FALSE. This argument is ignored if both var and conf.int are FALSE. </p>
</td></tr>
<tr><td><code id="surv.land.obs_+3A_bw">bw</code></td>
<td>

<p>bandwidth used for kernel estimation, default is NULL
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See documentation for delta.land.obs for details.
</p>


<h3>Value</h3>

<p>A list is returned:
</p>
<table>
<tr><td><code>S.estimate</code></td>
<td>
<p>the estimate of survival at the time of interest, <code class="reqn">\hat{S}(t) = P(T&gt;t)</code></p>
</td></tr>
<tr><td><code>S.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{S}(t)</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.normal.S</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}(t)</code> based on a normal approximation; if conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.quantile.S</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE</p>
</td></tr> 
<tr><td><code>perturb.vector</code></td>
<td>
<p>a vector of size x where x is the number of columns of the provided weight.perturb matrix (or x=500 if weight.perturb is not provided); the perturbed values of <code class="reqn">\hat{S}(t)</code>; if perturb.vector = TRUE and either var=TRUE or conf.int = TRUE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Parast, L. &amp; Griffin B.A. (2017). Landmark Estimation of Survival and Treatment Effects in Observational Studies. Lifetime Data Analysis, 23:161-182.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_obs)
W.weight = ps.wgt.fun(treat = example_obs$treat, cov.for.ps = as.matrix(example_obs$Z))	
example_obs.treat = example_obs[example_obs$treat == 1,]
#executable but takes time
#surv.land.obs(tl=example_obs.treat$TL, dl = example_obs.treat$DL, tt=2, landmark = 1, 
#short = cbind(example_obs.treat$TS,example_obs.treat$DS), z.cov = example_obs.treat$Z, 
#ps.weights = W.weight[example_obs$treat == 1])
</code></pre>

<hr>
<h2 id='surv.land.obs.base'>
Estimates survival using landmark estimation
</h2><span id='topic+surv.land.obs.base'></span>

<h3>Description</h3>

<p>Estimates the probability of survival past some specified time using landmark estimation for an observational study setting</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv.land.obs.base(tl, dl, tt, landmark, short = NULL, z.cov = NULL, 
ps.weights, weight.perturb = NULL, perturb.ps = FALSE, bw = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv.land.obs.base_+3A_tl">tl</code></td>
<td>

<p>observed event time of primary outcome, equal to min(T, C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="surv.land.obs.base_+3A_dl">dl</code></td>
<td>

<p>event indicator, equal to I(T&lt;C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="surv.land.obs.base_+3A_tt">tt</code></td>
<td>

<p>the time of interest, function estimates the probability of survival past this time	
</p>
</td></tr>
<tr><td><code id="surv.land.obs.base_+3A_landmark">landmark</code></td>
<td>

<p>the landmark time
</p>
</td></tr>
<tr><td><code id="surv.land.obs.base_+3A_short">short</code></td>
<td>

<p>a matrix of intermediate event information, there should be two columns for each intermediate event, the first column contains the observed intermediate event time, equal to min(TS, C) where TS is the event time and C is the censoring time, and the second column contains the event indicator, equal to I(TS&lt;C)</p>
</td></tr>
<tr><td><code id="surv.land.obs.base_+3A_z.cov">z.cov</code></td>
<td>

<p>matrix of baseline covariate information</p>
</td></tr>
<tr><td><code id="surv.land.obs.base_+3A_ps.weights">ps.weights</code></td>
<td>

<p>propensity score (or inverse probability of treatment) weights
</p>
</td></tr>
<tr><td><code id="surv.land.obs.base_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>a n by x matrix of weights where n = length of tl; used for perturbation-resampling, default is null. If var or conf.int is TRUE and weight.perturb is not provided, the function generates exponential(1) weights. 
</p>
</td></tr>
<tr><td><code id="surv.land.obs.base_+3A_perturb.ps">perturb.ps</code></td>
<td>

<p>TRUE or FALSE indicating whether the weight.perturb matrix includes the perturbed propensity score (or inverse probability of treatment) weights
</p>
</td></tr>
<tr><td><code id="surv.land.obs.base_+3A_bw">bw</code></td>
<td>

<p>bandwidth used for kernel estimation, default is NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>estimate of survival at the specified time
</p>


<h3>Author(s)</h3>

<p>Layla Parast </p>

<hr>
<h2 id='surv.land.rct'>
Estimates survival using landmark estimation
</h2><span id='topic+surv.land.rct'></span>

<h3>Description</h3>

<p>Estimates the probability of survival past some specified time using landmark estimation for a randomized trial setting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv.land.rct(tl, dl, tt, landmark, short = NULL, z.cov = NULL, var = FALSE, 
conf.int = FALSE, weight.perturb = NULL, perturb.vector = FALSE, bw = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv.land.rct_+3A_tl">tl</code></td>
<td>

<p>observed event time of primary outcome, equal to min(T, C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="surv.land.rct_+3A_dl">dl</code></td>
<td>

<p>event indicator, equal to I(T&lt;C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="surv.land.rct_+3A_tt">tt</code></td>
<td>

<p>the time of interest, function estimates the probability of survival past this time	
</p>
</td></tr>
<tr><td><code id="surv.land.rct_+3A_landmark">landmark</code></td>
<td>

<p>the landmark time
</p>
</td></tr>
<tr><td><code id="surv.land.rct_+3A_short">short</code></td>
<td>

<p>a matrix of intermediate event information, there should be two columns for each intermediate event, the first column contains the observed intermediate event time, equal to min(TS, C) where TS is the event time and C is the censoring time, and the second column contains the event indicator, equal to I(TS&lt;C)</p>
</td></tr>
<tr><td><code id="surv.land.rct_+3A_z.cov">z.cov</code></td>
<td>

<p>matrix of baseline covariate information</p>
</td></tr>
<tr><td><code id="surv.land.rct_+3A_var">var</code></td>
<td>

<p>TRUE or FALSE; indicates whether a variance estimate for survival is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="surv.land.rct_+3A_conf.int">conf.int</code></td>
<td>

<p>TRUE or FALSE; indicates whether a 95% confidence interval for survival is requested, default is FALSE.
</p>
</td></tr>
<tr><td><code id="surv.land.rct_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>a n by x matrix of weights where n = length of tl; used for perturbation-resampling, default is null. If var or conf.int is TRUE and weight.perturb is not provided, the function generates exponential(1) weights. 
</p>
</td></tr>
<tr><td><code id="surv.land.rct_+3A_perturb.vector">perturb.vector</code></td>
<td>

<p>TRUE or FALSE; indicates whether a vector of the perturbed values of the survival estimate is requested, default is FALSE. This argument is ignored if both var and conf.int are FALSE. </p>
</td></tr>
<tr><td><code id="surv.land.rct_+3A_bw">bw</code></td>
<td>

<p>bandwidth used for kernel estimation, default is NULL
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See documentation for delta.land.rct for details.
</p>


<h3>Value</h3>

<p>A list is returned:
</p>
<table>
<tr><td><code>S.estimate</code></td>
<td>
<p>the estimate of survival at the time of interest, <code class="reqn">\hat{S}(t) = P(T&gt;t)</code></p>
</td></tr>
<tr><td><code>S.var</code></td>
<td>
<p>the variance estimate of <code class="reqn">\hat{S}(t)</code>; if var = TRUE or conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.normal.S</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}(t)</code> based on a normal approximation; if conf.int = TRUE</p>
</td></tr>
<tr><td><code>conf.int.quantile.S</code></td>
<td>
<p>a vector of size 2; the 95% confidence interval for <code class="reqn">\hat{S}(t)</code> based on sample quantiles of the perturbed values, described above; if conf.int = TRUE</p>
</td></tr> 
<tr><td><code>perturb.vector</code></td>
<td>
<p>a vector of size x where x is the number of columns of the provided weight.perturb matrix (or x=500 if weight.perturb is not provided); the perturbed values of <code class="reqn">\hat{S}(t)</code>; if perturb.vector = TRUE and either var=TRUE or conf.int = TRUE</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Layla Parast
</p>


<h3>References</h3>

<p>Parast, L., Tian, L., &amp; Cai, T. (2014). Landmark Estimation of Survival and Treatment Effect in a Randomized Clinical Trial. Journal of the American Statistical Association, 109(505), 384-394.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(example_rct)
example_rct.treat = example_rct[example_rct$treat == 1,]
#executable but takes time
#surv.land.rct(tl=example_rct.treat$TL, dl = example_rct.treat$DL, tt=2, landmark = 1, 
#short = cbind(example_rct.treat$TS,example_rct.treat$DS), z.cov = example_rct.treat$Z)

</code></pre>

<hr>
<h2 id='surv.land.rct.base'>
Estimates survival using landmark estimation
</h2><span id='topic+surv.land.rct.base'></span>

<h3>Description</h3>

<p>Estimates the probability of survival past some specified time using landmark estimation for a randomized trial setting</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv.land.rct.base(tl, dl, tt, landmark, short = NULL, z.cov = NULL, 
weight.perturb = NULL, bw = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv.land.rct.base_+3A_tl">tl</code></td>
<td>

<p>observed event time of primary outcome, equal to min(T, C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="surv.land.rct.base_+3A_dl">dl</code></td>
<td>

<p>event indicator, equal to I(T&lt;C) where T is the event time and C is the censoring time.
</p>
</td></tr>
<tr><td><code id="surv.land.rct.base_+3A_tt">tt</code></td>
<td>

<p>the time of interest, function estimates the probability of survival past this time	
</p>
</td></tr>
<tr><td><code id="surv.land.rct.base_+3A_landmark">landmark</code></td>
<td>

<p>the landmark time
</p>
</td></tr>
<tr><td><code id="surv.land.rct.base_+3A_short">short</code></td>
<td>

<p>a matrix of intermediate event information, there should be two columns for each intermediate event, the first column contains the observed intermediate event time, equal to min(TS, C) where TS is the event time and C is the censoring time, and the second column contains the event indicator, equal to I(TS&lt;C)</p>
</td></tr>
<tr><td><code id="surv.land.rct.base_+3A_z.cov">z.cov</code></td>
<td>

<p>matrix of baseline covariate information</p>
</td></tr>
<tr><td><code id="surv.land.rct.base_+3A_weight.perturb">weight.perturb</code></td>
<td>

<p>a n by x matrix of weights where n = length of tl; used for perturbation-resampling, default is null. If var or conf.int is TRUE and weight.perturb is not provided, the function generates exponential(1) weights. 
</p>
</td></tr>
<tr><td><code id="surv.land.rct.base_+3A_bw">bw</code></td>
<td>

<p>bandwidth used for kernel estimation, default is NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See documentation for delta.land.rct for details.</p>


<h3>Value</h3>

<p>estimate of survival at the specified time
</p>


<h3>Author(s)</h3>

<p>Layla Parast
</p>

<hr>
<h2 id='VTM'>

Repeats a row.
</h2><span id='topic+VTM'></span>

<h3>Description</h3>


<p>Helper function; this function creates a matrix that repeats vc, dm times where each row is equal to the vc vector. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VTM(vc, dm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VTM_+3A_vc">vc</code></td>
<td>


<p>the vector to repeat.
</p>
</td></tr>
<tr><td><code id="VTM_+3A_dm">dm</code></td>
<td>


<p>number of rows.
</p>
</td></tr>
</table>


<h3>Value</h3>






<p>a matrix that repeats vc, dm times where each row is equal to the vc vector
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
