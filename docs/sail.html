<!DOCTYPE html><html><head><title>Help for package sail</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sail}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#createfolds'><p>Create CV Folds</p></a></li>
<li><a href='#cv.lspath'><p>Compute cross validation error</p></a></li>
<li><a href='#cv.sail'><p>Cross-validation for sail</p></a></li>
<li><a href='#design_sail'><p>Sail design matrix</p></a></li>
<li><a href='#gendata'><p>Simulation Scenario from Bhatnagar et al. (2018+) sail paper</p></a></li>
<li><a href='#gendataPaper'><p>Simulation Scenario from Bhatnagar et al. (2018+) sail paper</p></a></li>
<li><a href='#oasis'><p>OASIS Brain Data</p></a></li>
<li><a href='#plot.cv.sail'><p>Plot the cross-validation curve produced by <code>cv.sail</code></p></a></li>
<li><a href='#plot.sail'><p>Plot Method for <code>sail</code> object</p></a></li>
<li><a href='#plotInter'><p>Plot Interaction Effects from sail object</p></a></li>
<li><a href='#plotMain'><p>Plot Estimated Component Smooth Functions for Main Effects</p></a></li>
<li><a href='#predict.cv.sail'><p>Make predictions from a <code>cv.sail</code> object</p></a></li>
<li><a href='#predict.sail'><p>Make predictions from a sail object</p></a></li>
<li><a href='#print.sail'><p>Print Method for <code>sail</code> object</p></a></li>
<li><a href='#Q_theta'><p>Objective function</p></a></li>
<li><a href='#sail'><p>Fit Sparse Additive Interaction Model with Strong Heredity</p></a></li>
<li><a href='#sail-internal'><p>Internal sail functions</p></a></li>
<li><a href='#sailsim'><p>Simulated Data Used in Bhatnagar et al. (2018+) Paper</p></a></li>
<li><a href='#standardize'><p>Standardize Data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Sparse Additive Interaction Learning</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Sparse additive interaction learning with the strong heredity property, i.e., 
    an interaction is selected only if its corresponding main effects are also included. 
    Fits a linear model with non-linear interactions via penalized maximum likelihood. 
    Interactions are limited to a single exposure or environment variable. For more information, 
    see the website below and the accompanying paper: Bhatnagar et al., "A sparse additive model for 
    high-dimensional interactions with an exposure variable", 2019, &lt;<a href="https://doi.org/10.1101%2F445304">doi:10.1101/445304</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>glmnet, gglasso, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>grpreg, truncnorm, foreach, doParallel, testthat, covr,
vdiffr, knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sahirbhatnagar/sail/issues">https://github.com/sahirbhatnagar/sail/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sahirbhatnagar.com/sail">https://sahirbhatnagar.com/sail</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-05 04:59:48 UTC; sahir</td>
</tr>
<tr>
<td>Author:</td>
<td>Sahir Bhatnagar [aut, cre] (http://sahirbhatnagar.com/),
  Yi Yang [aut] (http://www.math.mcgill.ca/yyang/),
  Celia Greenwood [aut] (https://www.mcgill.ca/statisticalgenetics/)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sahir Bhatnagar &lt;sahir.bhatnagar@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-13 15:00:02 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; ; 2023-03-28 04:59:14 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='createfolds'>Create CV Folds</h2><span id='topic+createfolds'></span>

<h3>Description</h3>

<p><code>createfolds</code> splits the data into <code>k</code> groups. Taken
from the <code>caret</code> package (see references for details)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createfolds(y, k = 10, list = FALSE, returnTrain = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createfolds_+3A_y">y</code></td>
<td>
<p>vector of response</p>
</td></tr>
<tr><td><code id="createfolds_+3A_k">k</code></td>
<td>
<p>integer for the number of folds.</p>
</td></tr>
<tr><td><code id="createfolds_+3A_list">list</code></td>
<td>
<p>logical - should the results be in a list (TRUE) or a matrix</p>
</td></tr>
<tr><td><code id="createfolds_+3A_returntrain">returnTrain</code></td>
<td>
<p>a logical. When true, the values returned are the sample
positions corresponding to the data used during training. This argument
only works in conjunction with <code>list = TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For numeric y, the sample is split into groups sections based on
percentiles and sampling is done within these subgroups
</p>


<h3>Value</h3>

<p>A vector of CV fold ID's for each observation in <code>y</code>
</p>


<h3>References</h3>

<p><a href="https://topepo.github.io/caret/data-splitting.html">https://topepo.github.io/caret/data-splitting.html</a>
</p>

<hr>
<h2 id='cv.lspath'>Compute cross validation error</h2><span id='topic+cv.lspath'></span><span id='topic+cvcompute'></span><span id='topic+getmin'></span><span id='topic+lambda.interp'></span>

<h3>Description</h3>

<p>functions used to calculate cross validation error and used by
the <code><a href="sail.html#topic+cv.sail">cv.sail</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.lspath(outlist, lambda, x, y, e, weights, foldid, type.measure, grouped,
  keep = FALSE)

cvcompute(mat, weights, foldid, nlams)

getmin(lambda, cvm, cvsd)

lambda.interp(lambda, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.lspath_+3A_outlist">outlist</code></td>
<td>
<p>list of cross validated fitted models. List is of length equal
to <code>nfolds</code> argument in <code><a href="sail.html#topic+cv.sail">cv.sail</a></code> function</p>
</td></tr>
<tr><td><code id="cv.lspath_+3A_lambda">lambda</code></td>
<td>
<p>a user supplied lambda sequence. Typically, by leaving this
option unspecified users can have the program compute its own lambda
sequence based on <code>nlambda</code> and <code>lambda.factor</code>. Supplying a
value of lambda overrides this. It is better to supply a decreasing
sequence of lambda values than a single (small) value, if not, the program
will sort user-defined lambda sequence in decreasing order automatically.
Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="cv.lspath_+3A_x">x</code></td>
<td>
<p>input matrix of dimension <code>n x p</code>, where <code>n</code> is the number
of subjects and p is number of X variables. Each row is an observation
vector. Can be a high-dimensional (n &lt; p) matrix. Can be a user defined
design matrix of main effects only (without intercept) if
<code>expand=FALSE</code></p>
</td></tr>
<tr><td><code id="cv.lspath_+3A_y">y</code></td>
<td>
<p>response variable. For <code>family="gaussian"</code> should be a 1 column
matrix or numeric vector. For <code>family="binomial"</code>, should be a 1
column matrix or numeric vector with -1 for failure and 1 for success.</p>
</td></tr>
<tr><td><code id="cv.lspath_+3A_e">e</code></td>
<td>
<p>exposure or environment vector. Must be a numeric vector. Factors
must be converted to numeric.</p>
</td></tr>
<tr><td><code id="cv.lspath_+3A_weights">weights</code></td>
<td>
<p>observation weights. Default is 1 for each observation.
Currently NOT IMPLEMENTED.</p>
</td></tr>
<tr><td><code id="cv.lspath_+3A_foldid">foldid</code></td>
<td>
<p>numeric vector indicating which fold each observation belongs
to</p>
</td></tr>
<tr><td><code id="cv.lspath_+3A_type.measure">type.measure</code></td>
<td>
<p>loss to use for cross-validation. Currently only 3
options are implemented. The default is <code>type.measure="deviance"</code>,
which uses squared-error for gaussian models (and is equivalent to
<code>type.measure="mse"</code>) there). <code>type.measure="mae"</code> (mean absolute
error) can also be used which measures the absolute deviation from the
fitted mean to the response (<code class="reqn">|y-\hat{y}|</code>).</p>
</td></tr>
<tr><td><code id="cv.lspath_+3A_grouped">grouped</code></td>
<td>
<p>This is an experimental argument, with default <code>TRUE</code>,
and can be ignored by most users. This refers to computing <code>nfolds</code>
separate statistics, and then using their mean and estimated standard error
to describe the CV curve. If <code>grouped=FALSE</code>, an error matrix is built
up at the observation level from the predictions from the <code>nfold</code>
fits, and then summarized (does not apply to <code>type.measure="auc"</code>).
Default: TRUE.</p>
</td></tr>
<tr><td><code id="cv.lspath_+3A_keep">keep</code></td>
<td>
<p>If <code>keep=TRUE</code>, a <em>prevalidated</em> array is returned
containing fitted values for each observation and each value of
<code>lambda</code>. This means these fits are computed with this observation and
the rest of its fold omitted. The <code>folid</code> vector is also returned.
Default: FALSE</p>
</td></tr>
<tr><td><code id="cv.lspath_+3A_mat">mat</code></td>
<td>
<p>matrix of predictions</p>
</td></tr>
<tr><td><code id="cv.lspath_+3A_nlams">nlams</code></td>
<td>
<p>number of lambdas fit</p>
</td></tr>
<tr><td><code id="cv.lspath_+3A_cvm">cvm</code></td>
<td>
<p>mean cv error</p>
</td></tr>
<tr><td><code id="cv.lspath_+3A_cvsd">cvsd</code></td>
<td>
<p>sd of cv error</p>
</td></tr>
<tr><td><code id="cv.lspath_+3A_s">s</code></td>
<td>
<p>numeric value of lambda</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of the <code>cv.lspath</code> function only returns values for
those tuning parameters that converged. <code>cvcompute, getmin,
  lambda.interp</code> are taken verbatim from the <code>glmnet</code> package
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>cvcompute</code>: Computations for crossvalidation error
</p>
</li>
<li> <p><code>getmin</code>: get lambda.min and lambda.1se
</p>
</li>
<li> <p><code>lambda.interp</code>: Interpolation function.
</p>
</li></ul>


<h3>References</h3>

<p>Jerome Friedman, Trevor Hastie, Robert Tibshirani (2010).
Regularization Paths for Generalized Linear Models via Coordinate Descent.
Journal of Statistical Software, 33(1), 1-22.
<a href="http://www.jstatsoft.org/v33/i01/">http://www.jstatsoft.org/v33/i01/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="sail.html#topic+cv.sail">cv.sail</a></code>
</p>

<hr>
<h2 id='cv.sail'>Cross-validation for sail</h2><span id='topic+cv.sail'></span>

<h3>Description</h3>

<p>Does k-fold cross-validation for sail and determines the optimal
tuning parameter <code class="reqn">\lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.sail(x, y, e, ..., weights, lambda = NULL, type.measure = c("mse",
  "deviance", "class", "auc", "mae"), nfolds = 10, foldid,
  grouped = TRUE, keep = FALSE, parallel = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.sail_+3A_x">x</code></td>
<td>
<p>input matrix of dimension <code>n x p</code>, where <code>n</code> is the number
of subjects and p is number of X variables. Each row is an observation
vector. Can be a high-dimensional (n &lt; p) matrix. Can be a user defined
design matrix of main effects only (without intercept) if
<code>expand=FALSE</code></p>
</td></tr>
<tr><td><code id="cv.sail_+3A_y">y</code></td>
<td>
<p>response variable. For <code>family="gaussian"</code> should be a 1 column
matrix or numeric vector. For <code>family="binomial"</code>, should be a 1
column matrix or numeric vector with -1 for failure and 1 for success.</p>
</td></tr>
<tr><td><code id="cv.sail_+3A_e">e</code></td>
<td>
<p>exposure or environment vector. Must be a numeric vector. Factors
must be converted to numeric.</p>
</td></tr>
<tr><td><code id="cv.sail_+3A_...">...</code></td>
<td>
<p>other arguments that can be passed to <code><a href="sail.html#topic+sail">sail</a></code></p>
</td></tr>
<tr><td><code id="cv.sail_+3A_weights">weights</code></td>
<td>
<p>observation weights. Default is 1 for each observation.
Currently NOT IMPLEMENTED.</p>
</td></tr>
<tr><td><code id="cv.sail_+3A_lambda">lambda</code></td>
<td>
<p>Optional user-supplied lambda sequence; default is NULL, and
<code><a href="sail.html#topic+sail">sail</a></code> chooses its own sequence</p>
</td></tr>
<tr><td><code id="cv.sail_+3A_type.measure">type.measure</code></td>
<td>
<p>loss to use for cross-validation. Currently only 3
options are implemented. The default is <code>type.measure="deviance"</code>,
which uses squared-error for gaussian models (and is equivalent to
<code>type.measure="mse"</code>) there). <code>type.measure="mae"</code> (mean absolute
error) can also be used which measures the absolute deviation from the
fitted mean to the response (<code class="reqn">|y-\hat{y}|</code>).</p>
</td></tr>
<tr><td><code id="cv.sail_+3A_nfolds">nfolds</code></td>
<td>
<p>number of folds. Although <code>nfolds</code> can be as large as the
sample size (leave-one-out CV), it is not recommended for large datasets.
Smallest value allowable is <code>nfolds=3</code>. Default: 10</p>
</td></tr>
<tr><td><code id="cv.sail_+3A_foldid">foldid</code></td>
<td>
<p>an optional vector of values between 1 and <code>nfold</code>
identifying what fold each observation is in. If supplied,<code>nfold</code> can
be missing. Often used when wanting to tune the second tuning parameter
(<code class="reqn">\alpha</code>) as well (see details).</p>
</td></tr>
<tr><td><code id="cv.sail_+3A_grouped">grouped</code></td>
<td>
<p>This is an experimental argument, with default <code>TRUE</code>,
and can be ignored by most users. This refers to computing <code>nfolds</code>
separate statistics, and then using their mean and estimated standard error
to describe the CV curve. If <code>grouped=FALSE</code>, an error matrix is built
up at the observation level from the predictions from the <code>nfold</code>
fits, and then summarized (does not apply to <code>type.measure="auc"</code>).
Default: TRUE.</p>
</td></tr>
<tr><td><code id="cv.sail_+3A_keep">keep</code></td>
<td>
<p>If <code>keep=TRUE</code>, a <em>prevalidated</em> array is returned
containing fitted values for each observation and each value of
<code>lambda</code>. This means these fits are computed with this observation and
the rest of its fold omitted. The <code>folid</code> vector is also returned.
Default: FALSE</p>
</td></tr>
<tr><td><code id="cv.sail_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code>, use parallel <code>foreach</code> to fit each fold.
Must register parallel before hand using the
<code><a href="doParallel.html#topic+registerDoParallel">registerDoParallel</a></code> function from the <code>doParallel</code> package. See
the example below for details. Default: FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function runs <code><a href="sail.html#topic+sail">sail</a></code> <code>nfolds</code>+1 times; the
first to get the <code>lambda</code> sequence, and then the remainder to compute
the fit with each of the folds omitted. Note that a new lambda sequence is
computed for each of the folds and then we use the <code>predict</code> method to
get the solution path at each value of the original lambda sequence. The
error is accumulated, and the average error and standard deviation over the
folds is computed. Note that <code>cv.sail</code> does NOT search for values for
<code>alpha</code>. A specific value should be supplied, else <code>alpha=0.5</code> is
assumed by default. If users would like to cross-validate <code>alpha</code> as
well, they should call <code>cv.sail</code> with a pre-computed vector
<code>foldid</code>, and then use this same fold vector in separate calls to
<code>cv.sail</code> with different values of <code>alpha</code>. Note also that the
results of <code>cv.sail</code> are random, since the folds are selected at
random. Users can reduce this randomness by running <code>cv.sail</code> many
times, and averaging the error curves.
</p>


<h3>Value</h3>

<p>an object of class <code>"cv.sail"</code> is returned, which is a list with
the ingredients of the cross-validation fit. </p>
 <dl>
<dt>lambda</dt><dd><p>the
values of converged <code>lambda</code> used in the fits.</p>
</dd> <dt>cvm</dt><dd><p>The mean
cross-validated error - a vector of length <code>length(lambda)</code>.</p>
</dd>
<dt>cvsd</dt><dd><p>estimate of standard error of <code>cvm</code>.</p>
</dd> <dt>cvup</dt><dd><p>upper
curve = <code>cvm+cvsd</code>.</p>
</dd> <dt>cvlo</dt><dd><p>lower curve = <code>cvm-cvsd</code>.</p>
</dd>
<dt>nzero</dt><dd><p>number of non-zero coefficients at each <code>lambda</code>. This is
the sum of the total non-zero main effects and interactions. Note that when
<code>expand=TRUE</code>, we only count a variable once in the calculation of
<code>nzero</code>, i.e., if a variable is expanded to three columns, then this
is only counted once even though all three coefficients are estimated to be
non-zero</p>
</dd> <dt>name</dt><dd><p>a text string indicating type of measure (for
plotting purposes).</p>
</dd> <dt>sail.fit</dt><dd><p>a fitted <code>sail</code> object for the full
data.</p>
</dd> <dt>lambda.min</dt><dd><p>value of <code>lambda</code> that gives minimum
<code>cvm</code>.</p>
</dd> <dt>lambda.1se</dt><dd><p>largest value of <code>lambda</code> such that
error is within 1 standard error of the minimum.</p>
</dd> <dt>fit.preval</dt><dd><p>if
<code>keep=TRUE</code>, this is the array of prevalidated fits. Some entries can
be <code>NA</code>, if that and subsequent values of <code>lambda</code> are not
reached for that fold</p>
</dd> <dt>foldid</dt><dd><p>if <code>keep=TRUE</code>, the fold
assignments used</p>
</dd></dl>



<h3>Note</h3>

<p>The skeleton of this function and the documentation were taken straight
from the <code>glmnet</code> package. See references for details.
</p>


<h3>References</h3>

<p>Jerome Friedman, Trevor Hastie, Robert Tibshirani (2010).
Regularization Paths for Generalized Linear Models via Coordinate Descent.
Journal of Statistical Software, 33(1), 1-22.
<a href="http://www.jstatsoft.org/v33/i01/">http://www.jstatsoft.org/v33/i01/</a>.
</p>
<p>Bhatnagar SR, Yang Y, Greenwood CMT. Sparse additive interaction
models with the strong heredity property (2018+). Preprint.
</p>


<h3>See Also</h3>

<p><code><a href="splines.html#topic+bs">bs</a></code> <code><a href="sail.html#topic+sail">sail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f.basis &lt;- function(i) splines::bs(i, degree = 3)
data("sailsim")
# Parallel
library(doParallel)
cl &lt;- makeCluster(2)
registerDoParallel(cl)
cvfit &lt;- cv.sail(x = sailsim$x, y = sailsim$y, e = sailsim$e,
                 parallel = TRUE, nlambda = 10,
                 maxit = 25, basis = f.basis,
                 nfolds = 3, dfmax = 5)
stopCluster(cl)
# plot cross validated curve
plot(cvfit)
# solution at lambda.min
coef(cvfit, s = "lambda.min")
# solution at lambda.1se
coef(cvfit, s = "lambda.1se")
# non-zero coefficients at lambda.min
predict(cvfit, s = "lambda.min", type = "nonzero")


</code></pre>

<hr>
<h2 id='design_sail'>Sail design matrix</h2><span id='topic+design_sail'></span>

<h3>Description</h3>

<p>Create design matrix used in <code><a href="sail.html#topic+sail">sail</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design_sail(x, e, expand, group, basis, nvars, vnames, center.x, center.e)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="design_sail_+3A_x">x</code></td>
<td>
<p>input matrix of dimension <code>n x p</code>, where <code>n</code> is the number
of subjects and p is number of X variables. Each row is an observation
vector. Can be a high-dimensional (n &lt; p) matrix. Can be a user defined
design matrix of main effects only (without intercept) if
<code>expand=FALSE</code></p>
</td></tr>
<tr><td><code id="design_sail_+3A_e">e</code></td>
<td>
<p>exposure or environment vector. Must be a numeric vector. Factors
must be converted to numeric.</p>
</td></tr>
<tr><td><code id="design_sail_+3A_expand">expand</code></td>
<td>
<p>should <code>basis</code> be applied to every column of <code>x</code>
(logical). Set to <code>FALSE</code> if you want a user defined main effects
design matrix. If <code>FALSE</code> the <code>group</code> membership argument must
also be supplied. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="design_sail_+3A_group">group</code></td>
<td>
<p>a vector of consecutive integers, starting from 1, describing
the grouping of the coefficients. Only required when <code>expand=FALSE</code>.</p>
</td></tr>
<tr><td><code id="design_sail_+3A_basis">basis</code></td>
<td>
<p>user defined basis expansion function. This function will be
applied to every column in <code>x</code>. Specify <code>function(i) i</code> if no
expansion is desired. Default: <code>function(i) splines::bs(i, df = 5)</code>.</p>
</td></tr>
<tr><td><code id="design_sail_+3A_nvars">nvars</code></td>
<td>
<p>number of variables</p>
</td></tr>
<tr><td><code id="design_sail_+3A_vnames">vnames</code></td>
<td>
<p>variable names</p>
</td></tr>
<tr><td><code id="design_sail_+3A_center.x">center.x</code></td>
<td>
<p>should the columns of <code>x</code> (after basis expansion) be
centered (logical). Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="design_sail_+3A_center.e">center.e</code></td>
<td>
<p>should exposure variable <code>e</code> be centered. Default:
<code>TRUE</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='gendata'>Simulation Scenario from Bhatnagar et al. (2018+) sail paper</h2><span id='topic+gendata'></span>

<h3>Description</h3>

<p>Function that generates data of the different simulation studies
presented in the accompanying paper. This function requires the
<code>truncnorm</code> package to be installed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendata(n, p, corr, E = truncnorm::rtruncnorm(n, a = -1, b = 1), betaE,
  SNR, parameterIndex)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gendata_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="gendata_+3A_p">p</code></td>
<td>
<p>number of main effect variables (X)</p>
</td></tr>
<tr><td><code id="gendata_+3A_corr">corr</code></td>
<td>
<p>correlation between predictors</p>
</td></tr>
<tr><td><code id="gendata_+3A_e">E</code></td>
<td>
<p>simulated environment vector of length <code>n</code>. Can be continuous
or integer valued. Factors must be converted to numeric. Default:
<code>truncnorm::rtruncnorm(n, a = -1, b = 1)</code></p>
</td></tr>
<tr><td><code id="gendata_+3A_betae">betaE</code></td>
<td>
<p>exposure effect size</p>
</td></tr>
<tr><td><code id="gendata_+3A_snr">SNR</code></td>
<td>
<p>signal to noise ratio</p>
</td></tr>
<tr><td><code id="gendata_+3A_parameterindex">parameterIndex</code></td>
<td>
<p>simulation scenario index. See details for more
information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We evaluate the performance of our method on three of its defining
characteristics: 1) the strong heredity property, 2) non-linearity of
predictor effects and 3) interactions. </p>
 <dl>
<dt>Heredity
Property</dt><dd><dl>
<dt></dt><dd><p>Truth obeys strong hierarchy
(<code>parameterIndex = 1</code>) </p>
<p style="text-align: center;"><code class="reqn">Y* = \sum_{j=1}^{4} f_j(X_{j}) + \beta_E
  * X_{E} +  X_{E} * f_3(X_{3}) + X_{E} * f_4(X_{4}) </code>
</p>
</dd> <dt></dt><dd><p>Truth obeys
weak hierarchy (<code>parameterIndex = 2</code>) </p>
<p style="text-align: center;"><code class="reqn">Y* = f_1(X_{1}) +
  f_2(X_{2}) + \beta_E * X_{E} +  X_{E} * f_3(X_{3}) + X_{E} * f_4(X_{4}) </code>
</p>
</dd>
<dt></dt><dd><p>Truth only has interactions (<code>parameterIndex = 3</code>)</p>
<p style="text-align: center;"><code class="reqn">Y* =
  X_{E} * f_3(X_{3}) + X_{E} * f_4(X_{4}) </code>
</p>
</dd></dl>
</dd> <dt>Non-linearity</dt><dd><p>Truth is
linear (<code>parameterIndex = 4</code>) </p>
<p style="text-align: center;"><code class="reqn">Y* = \sum_{j=1}^{4}\beta_j X_{j} +
  \beta_E * X_{E} +  X_{E} * X_{3} + X_{E} * X_{4} </code>
</p>
</dd>
<dt>Interactions</dt><dd><p>Truth only has main effects (<code>parameterIndex = 5</code>)
</p>
<p style="text-align: center;"><code class="reqn">Y* = \sum_{j=1}^{4} f_j(X_{j}) + \beta_E * X_{E} </code>
</p>
</dd> </dl>
<p>.
</p>
<p>The functions are from the paper by Lin and Zhang (2006):
</p>
<dl>
<dt>f1</dt><dd><p>f1 &lt;- function(t) 5 * t</p>
</dd> <dt>f2</dt><dd><p>  f2 &lt;- function(t)
3 * (2 * t - 1)^2</p>
</dd> <dt>f3</dt><dd><p>  f3 &lt;- function(t) 4 * sin(2 * pi * t) / (2 -
sin(2 * pi * t))</p>
</dd> <dt>f4</dt><dd><p>  f4 &lt;- function(t) 6 * (0.1 * sin(2 * pi * t)
+ 0.2 * cos(2 * pi * t) + 0.3 * sin(2 * pi * t)^2 + 0.4 * cos(2 * pi * t)^3
+ 0.5 * sin(2 * pi * t)^3)</p>
</dd></dl>

<p>The response is generated as </p>
<p style="text-align: center;"><code class="reqn">Y = Y* + k*error</code>
</p>
<p> where Y* is the linear
predictor, the error term is generated from a standard normal distribution,
and k is chosen such that the signal-to-noise ratio is SNR =
Var(Y*)/Var(error), i.e., the variance of the response variable Y due to
error is 1/SNR of the variance of Y due to Y*
</p>
<p>The covariates are simulated as follows as described in Huang et al.
(2010). First, we generate <code class="reqn">w1,\ldots, wp, u,v</code> independently from
<code class="reqn">Normal(0,1)</code> truncated to the interval <code>[0,1]</code> for
<code class="reqn">i=1,\ldots,n</code>. Then we set <code class="reqn">x_j = (w_j + t*u)/(1 + t)</code> for <code class="reqn">j
  = 1,\ldots, 4</code> and <code class="reqn">x_j = (w_j + t*v)/(1 + t)</code> for <code class="reqn">j = 5,\ldots,
  p</code>, where the parameter <code class="reqn">t</code> controls the amount of correlation among
predictors. This leads to a compound symmetry correlation structure where
<code class="reqn">Corr(x_j,x_k) = t^2/(1+t^2)</code>, for <code class="reqn">1 \le j \le 4, 1 \le k \le 4</code>,
and <code class="reqn">Corr(x_j,x_k) = t^2/(1+t^2)</code>, for <code class="reqn">5 \le j \le p, 5 \le k \le
  p</code>, but the covariates of the nonzero and zero components are independent.
</p>


<h3>Value</h3>

<p>A list with the following elements: </p>
 <dl>
<dt>x</dt><dd><p>matrix of
dimension <code>nxp</code> of simulated main effects</p>
</dd> <dt>y</dt><dd><p>simulated response
vector of length <code>n</code></p>
</dd> <dt>e</dt><dd><p>simulated exposure vector of length
<code>n</code></p>
</dd> <dt>Y.star</dt><dd><p>linear predictor vector of length <code>n</code></p>
</dd>
<dt>f1</dt><dd><p>the function <code>f1</code> evaluated at <code>x_1</code> (<code>f1(X1)</code>)</p>
</dd>
<dt>f2</dt><dd><p>the function <code>f1</code> evaluated at <code>x_1</code> (<code>f1(X1)</code>)</p>
</dd>
<dt>f3</dt><dd><p>the function <code>f1</code> evaluated at <code>x_1</code> (<code>f1(X1)</code>)</p>
</dd>
<dt>f4</dt><dd><p>the function <code>f1</code> evaluated at <code>x_1</code> (<code>f1(X1)</code>)</p>
</dd>
<dt>betaE</dt><dd><p>the value for <code class="reqn">\beta_E</code></p>
</dd> <dt>f1.f</dt><dd><p>the function
<code>f1</code></p>
</dd> <dt>f2.f</dt><dd><p>the function <code>f2</code></p>
</dd> <dt>f3.f</dt><dd><p>the function
<code>f3</code></p>
</dd> <dt>f4.f</dt><dd><p>the function <code>f4</code></p>
</dd> <dt>X1</dt><dd><p>an <code>n</code> length
vector of the first predictor</p>
</dd> <dt>X2</dt><dd><p>an <code>n</code> length vector of the
second predictor</p>
</dd> <dt>X3</dt><dd><p>an <code>n</code> length vector of the third
predictor</p>
</dd> <dt>X4</dt><dd><p>an <code>n</code> length vector of the fourth predictor</p>
</dd>
<dt>scenario</dt><dd><p>a character representing the simulation scenario identifier
as described in Bhatnagar et al. (2018+)</p>
</dd><dt>causal</dt><dd><p>character vector of
causal variable names</p>
</dd><dt>not_causal</dt><dd><p>character vector of noise
variables</p>
</dd> </dl>



<h3>References</h3>

<p>Lin, Y., &amp; Zhang, H. H. (2006). Component selection and smoothing
in multivariate nonparametric regression. The Annals of Statistics, 34(5),
2272-2297.
</p>
<p>Huang J, Horowitz JL, Wei F. Variable selection in nonparametric
additive models (2010). Annals of statistics. Aug 1;38(4):2282.
</p>
<p>Bhatnagar SR, Yang Y, Greenwood CMT. Sparse additive interaction
models with the strong heredity property (2018+). Preprint.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DT &lt;- gendata(n = 75, p = 100, corr = 0, betaE = 2, SNR = 1, parameterIndex = 1)
</code></pre>

<hr>
<h2 id='gendataPaper'>Simulation Scenario from Bhatnagar et al. (2018+) sail paper</h2><span id='topic+gendataPaper'></span>

<h3>Description</h3>

<p>generates the different simulation scenarios. This function is
not intended to be called directly by users. See <code><a href="sail.html#topic+gendata">gendata</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gendataPaper(n, p, corr = 0, E = truncnorm::rtruncnorm(n, a = -1, b =
  1), betaE = 2, SNR = 2, hierarchy = c("strong", "weak", "none"),
  nonlinear = TRUE, interactions = TRUE, causal, not_causal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gendataPaper_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="gendataPaper_+3A_p">p</code></td>
<td>
<p>number of main effect variables (X)</p>
</td></tr>
<tr><td><code id="gendataPaper_+3A_corr">corr</code></td>
<td>
<p>correlation between predictors</p>
</td></tr>
<tr><td><code id="gendataPaper_+3A_e">E</code></td>
<td>
<p>simulated environment vector of length <code>n</code>. Can be continuous
or integer valued. Factors must be converted to numeric. Default:
<code>truncnorm::rtruncnorm(n, a = -1, b = 1)</code></p>
</td></tr>
<tr><td><code id="gendataPaper_+3A_betae">betaE</code></td>
<td>
<p>exposure effect size</p>
</td></tr>
<tr><td><code id="gendataPaper_+3A_snr">SNR</code></td>
<td>
<p>signal to noise ratio</p>
</td></tr>
<tr><td><code id="gendataPaper_+3A_hierarchy">hierarchy</code></td>
<td>
<p>type of hierarchy. Can be one of <code>c("strong", "weak",
"none")</code>. Default: &quot;strong&quot;</p>
</td></tr>
<tr><td><code id="gendataPaper_+3A_nonlinear">nonlinear</code></td>
<td>
<p>simulate non-linear terms (logical). Default: TRUE</p>
</td></tr>
<tr><td><code id="gendataPaper_+3A_interactions">interactions</code></td>
<td>
<p>simulate interaction (logical). Default: TRUE</p>
</td></tr>
<tr><td><code id="gendataPaper_+3A_causal">causal</code></td>
<td>
<p>character vector of causal variable names</p>
</td></tr>
<tr><td><code id="gendataPaper_+3A_not_causal">not_causal</code></td>
<td>
<p>character vector of noise variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires installation of <code>truncnorm</code> package. Not meant to be
called directly by user. Use <code><a href="sail.html#topic+gendata">gendata</a></code>.
</p>


<h3>Value</h3>

<p>A list with the following elements: </p>
 <dl>
<dt>x</dt><dd><p>matrix of
dimension <code>nxp</code> of simulated main effects</p>
</dd> <dt>y</dt><dd><p>simulated response
vector of length <code>n</code></p>
</dd> <dt>e</dt><dd><p>simulated exposure vector of length
<code>n</code></p>
</dd> <dt>Y.star</dt><dd><p>linear predictor vector of length <code>n</code></p>
</dd>
<dt>f1</dt><dd><p>the function <code>f1</code> evaluated at <code>x_1</code> (<code>f1(X1)</code>)</p>
</dd>
<dt>f2</dt><dd><p>the function <code>f1</code> evaluated at <code>x_1</code> (<code>f1(X1)</code>)</p>
</dd>
<dt>f3</dt><dd><p>the function <code>f1</code> evaluated at <code>x_1</code> (<code>f1(X1)</code>)</p>
</dd>
<dt>f4</dt><dd><p>the function <code>f1</code> evaluated at <code>x_1</code> (<code>f1(X1)</code>)</p>
</dd>
<dt>betaE</dt><dd><p>the value for <code class="reqn">\beta_E</code></p>
</dd> <dt>f1.f</dt><dd><p>the function
<code>f1</code></p>
</dd> <dt>f2.f</dt><dd><p>the function <code>f2</code></p>
</dd> <dt>f3.f</dt><dd><p>the function
<code>f3</code></p>
</dd> <dt>f4.f</dt><dd><p>the function <code>f4</code></p>
</dd> <dt>X1</dt><dd><p>an <code>n</code> length
vector of the first predictor</p>
</dd> <dt>X2</dt><dd><p>an <code>n</code> length vector of the
second predictor</p>
</dd> <dt>X3</dt><dd><p>an <code>n</code> length vector of the third
predictor</p>
</dd> <dt>X4</dt><dd><p>an <code>n</code> length vector of the fourth predictor</p>
</dd>
<dt>scenario</dt><dd><p>a character representing the simulation scenario identifier
as described in Bhatnagar et al. (2018+)</p>
</dd> <dt>causal</dt><dd><p>character vector of
causal variable names</p>
</dd><dt>not_causal</dt><dd><p>character vector of noise
variables</p>
</dd> </dl>



<h3>See Also</h3>

<p><code><a href="stats.html#topic+rnorm">rnorm</a></code>,<code><a href="stats.html#topic+cor">cor</a></code>,
<code><a href="sail.html#topic+gendata">gendata</a></code>
</p>

<hr>
<h2 id='oasis'>OASIS Brain Data</h2><span id='topic+oasis'></span>

<h3>Description</h3>

<p>A dataset containing a small subset of the OASIS Brain Data project. Noise
variables have been added to increase the number of predictors and show the
utility of the sail package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oasis
</code></pre>


<h3>Format</h3>

<p>A list with 3 elements: </p>
 <dl>
<dt>x</dt><dd><p>a matrix of dimension
<code>136 x 30</code> with the following colums:</p>
<dl>
<dt>Age</dt><dd><p>Patient's
age</p>
</dd> <dt>EDUC</dt><dd><p>Education</p>
</dd> <dt>MMSE</dt><dd><p>Mini-Mental State Exam</p>
</dd>
<dt>eTIV</dt><dd><p>Estimated Total Intracranial Volume</p>
</dd> <dt>nWBV</dt><dd><p>Normalized
Whole Brain Volume</p>
</dd> <dt>ASF</dt><dd><p>Atlas scaling factor</p>
</dd>
<dt>noise[1-24]</dt><dd><p>24 independent standard normal noise variables</p>
</dd></dl>
</dd><dt>y</dt><dd><p>a
numeric vector of length 136 representing the right Hippocampal volume for
each patient</p>
</dd><dt>e</dt><dd><p>a binary 0/1 vector of length 136, representing
Dementia status. 0: Non-demented, 1: Demented</p>
</dd> </dl>


<h3>Source</h3>

<p><a href="https://github.com/stnava/RMI/tree/master/tomfletcher">https://github.com/stnava/RMI/tree/master/tomfletcher</a>
</p>
<p><a href="http://www.oasis-brains.org/">http://www.oasis-brains.org/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oasis
</code></pre>

<hr>
<h2 id='plot.cv.sail'>Plot the cross-validation curve produced by <code>cv.sail</code></h2><span id='topic+plot.cv.sail'></span>

<h3>Description</h3>

<p>Plots the cross-validation curve, and upper and lower standard
deviation curves, as a function of the <code>lambda</code> values used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.sail'
plot(x, sign.lambda = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cv.sail_+3A_x">x</code></td>
<td>
<p>fitted <code>cv.sail</code> object</p>
</td></tr>
<tr><td><code id="plot.cv.sail_+3A_sign.lambda">sign.lambda</code></td>
<td>
<p>Either plot against <code>log(lambda)</code> (default) or its
negative if <code>sign.lambda=-1</code>.</p>
</td></tr>
<tr><td><code id="plot.cv.sail_+3A_...">...</code></td>
<td>
<p>Other graphical parameters to plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a port of <code>plot.cv.glmnet</code>
</p>


<h3>Value</h3>

<p>A plot is produced and nothing is returned
</p>


<h3>References</h3>

<p>Jerome Friedman, Trevor Hastie, Robert Tibshirani (2010).
Regularization Paths for Generalized Linear Models via Coordinate Descent.
Journal of Statistical Software, 33(1), 1-22.
<a href="http://www.jstatsoft.org/v33/i01/">http://www.jstatsoft.org/v33/i01/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="sail.html#topic+sail">sail</a></code>, <code><a href="sail.html#topic+cv.sail">cv.sail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sailsim")
f.basis &lt;- function(i) splines::bs(i, degree = 3)
library(doParallel)
cl &lt;- makeCluster(2)
registerDoParallel(cl)
cvfit &lt;- cv.sail(x = sailsim$x, y = sailsim$y, e = sailsim$e,
                 parallel = TRUE, nlambda = 10,
                 maxit = 100, basis = f.basis,
                 nfolds = 3, dfmax = 10)
stopCluster(cl)
plot(cvfit)
</code></pre>

<hr>
<h2 id='plot.sail'>Plot Method for <code>sail</code> object</h2><span id='topic+plot.sail'></span>

<h3>Description</h3>

<p>Produces a coefficient profile plot of the coefficient paths for
a fitted <code>sail</code> object. Both main effects and interactions (if
present) are plotted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sail'
plot(x, type = c("both", "main", "interaction"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.sail_+3A_x">x</code></td>
<td>
<p>fitted <code>sail</code> object</p>
</td></tr>
<tr><td><code id="plot.sail_+3A_type">type</code></td>
<td>
<p>which type of predictors should be plotted. <code>type="both"</code>
will plot the solution path for main effects and interactions,
<code>type="main"</code> will only plot solution path of main effects (this also
includes the exposure variable) and <code>type="interaction"</code> will only
plot solution path for interaction effects Default: c(&quot;both&quot;, &quot;main&quot;,
&quot;interaction&quot;). Default: <code>type="both"</code>.</p>
</td></tr>
<tr><td><code id="plot.sail_+3A_...">...</code></td>
<td>
<p>other graphical paramters passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A coefficient profile plot is produced
</p>


<h3>Value</h3>

<p>A plot is produced and nothing is returned
</p>


<h3>See Also</h3>

<p><code><a href="sail.html#topic+sail">sail</a></code>, <code><a href="sail.html#topic+cv.sail">cv.sail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sailsim")
f.basis &lt;- function(i) splines::bs(i, degree = 3)
fit &lt;- sail(x = sailsim$x, y = sailsim$y, e = sailsim$e,
            basis = f.basis, dfmax = 10, nlambda = 10, maxit = 100)
plot(fit)
</code></pre>

<hr>
<h2 id='plotInter'>Plot Interaction Effects from sail object</h2><span id='topic+plotInter'></span>

<h3>Description</h3>

<p>Takes a fitted sail object produced by <code>sail()</code> or
<code>cv.sail()$sail.fit</code> and plots a <code><a href="graphics.html#topic+persp">persp</a></code> for a
pre-specified variable at a given value of lambda and on the scale of the
linear predictor. Currently only implemented for <code>type="gaussian"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotInter(object, x, xvar, s, f.truth, interation.only = TRUE,
  truthonly = FALSE, npoints = 30, col = c("#56B4E9", "#D55E00"),
  title_z = "", xlab, ylab, zlab, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotInter_+3A_object">object</code></td>
<td>
<p>a fitted <code>sail</code> object as produced by <code>sail()</code> or
<code>cv.sail()$sail.fit</code></p>
</td></tr>
<tr><td><code id="plotInter_+3A_x">x</code></td>
<td>
<p>original data supplied to the original call to <code><a href="sail.html#topic+sail">sail</a></code></p>
</td></tr>
<tr><td><code id="plotInter_+3A_xvar">xvar</code></td>
<td>
<p>a character corresponding to the predictor to be plotted. Only
one variable name should be supplied, if more than one is supplied, only
the first element will be plotted. This variable name must be in
<code>colnames(x)</code>.</p>
</td></tr>
<tr><td><code id="plotInter_+3A_s">s</code></td>
<td>
<p>a single value of the penalty parameter <code>lambda</code> at which
coefficients will be extracted via the <code>coef</code> method for objects of
class <code>"sail"</code>. If more than one is supplied, only the first one will
be used.</p>
</td></tr>
<tr><td><code id="plotInter_+3A_f.truth">f.truth</code></td>
<td>
<p>true function. Only used for simulation purposes when the
truth is known. The function takes as a input two numeric vectors e.g.
<code>f(x,e)</code> corresponding the <code>xvar</code> column in <code>x</code> of length
<code>nrow(x)</code> and the exposure variable contained in the <code>sail
object</code>. A second <code>persp</code> will be plotted for the truth</p>
</td></tr>
<tr><td><code id="plotInter_+3A_interation.only">interation.only</code></td>
<td>
<p>if <code>TRUE</code> only the interaction part is used to
calculate the linear predictor, i.e., <code class="reqn">linear predictor = E * f(X) *
interaction_effects</code>. If <code>FALSE</code>, then <code class="reqn">linear predictor = E *
\beta_E + f(X) * interaction_effects + E * f(X) * interaction_effects</code>.
Default: TRUE</p>
</td></tr>
<tr><td><code id="plotInter_+3A_truthonly">truthonly</code></td>
<td>
<p>only plot the truth. <code>f.truth</code> must be specified if
this argument is set to <code>TRUE</code>. Default: FALSE</p>
</td></tr>
<tr><td><code id="plotInter_+3A_npoints">npoints</code></td>
<td>
<p>number of points in the grid to calculate the perspective
plot. Default: 30</p>
</td></tr>
<tr><td><code id="plotInter_+3A_col">col</code></td>
<td>
<p>color of the line. The first element corresponds to the color used
for the estimated function and the second element is for the true function
(if <code>f.truth</code> is specified). Default: c(&quot;#D55E00&quot;, &quot;#009E73&quot;)</p>
</td></tr>
<tr><td><code id="plotInter_+3A_title_z">title_z</code></td>
<td>
<p>title for the plot, Default: &rdquo;</p>
</td></tr>
<tr><td><code id="plotInter_+3A_xlab">xlab</code></td>
<td>
<p>character for xlabel. if missing, variable name is used</p>
</td></tr>
<tr><td><code id="plotInter_+3A_ylab">ylab</code></td>
<td>
<p>character for ylabel. if missing, variable name is used</p>
</td></tr>
<tr><td><code id="plotInter_+3A_zlab">zlab</code></td>
<td>
<p>character for zlabel. if missing, variable name is used</p>
</td></tr>
<tr><td><code id="plotInter_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot is produced and nothing is returned
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+persp">persp</a></code> <code><a href="sail.html#topic+coef.sail">coef.sail</a></code>
<code><a href="sail.html#topic+predict.sail">predict.sail</a></code>, <code><a href="graphics.html#topic+rug">rug</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f.basis &lt;- function(i) splines::bs(i, degree = 3)
# Parallel
library(doParallel)
cl &lt;- makeCluster(2)
registerDoParallel(cl)
cvfit &lt;- cv.sail(x = sailsim$x, y = sailsim$y, e = sailsim$e,
                 parallel = TRUE, nlambda = 10,
                 maxit = 100, basis = f.basis,
                 nfolds = 3, dfmax = 10)
stopCluster(cl)
# plot cv-error curve
plot(cvfit)
# non-zero estimated coefficients at lambda.min
predict(cvfit, type = "nonzero", s="lambda.min")
# plot interaction effect for X4 and the true interaction effect also
plotInter(cvfit$sail.fit, x = sailsim$x, xvar = "X3",
          f.truth = sailsim$f4.inter,
          s = cvfit$lambda.min,
          title_z = "Estimated")
</code></pre>

<hr>
<h2 id='plotMain'>Plot Estimated Component Smooth Functions for Main Effects</h2><span id='topic+plotMain'></span>

<h3>Description</h3>

<p>Takes a fitted sail object produced by <code>sail()</code> or
<code>cv.sail()$sail.fit</code> and plots the component smooth function for a
pre-specified variable at a given value of lambda and on the scale of the
linear predictor. Currently only implemented for <code>type="gaussian"</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMain(object, x, xvar, s, f.truth, col = c("#D55E00", "#009E73"),
  legend.position = "bottomleft", rug = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMain_+3A_object">object</code></td>
<td>
<p>a fitted <code>sail</code> object as produced by <code>sail()</code> or
<code>cv.sail()$sail.fit</code></p>
</td></tr>
<tr><td><code id="plotMain_+3A_x">x</code></td>
<td>
<p>original data supplied to the original call to <code><a href="sail.html#topic+sail">sail</a></code></p>
</td></tr>
<tr><td><code id="plotMain_+3A_xvar">xvar</code></td>
<td>
<p>a character corresponding to the predictor to be plotted. Only
one variable name should be supplied, if more than one is supplied, only
the first element will be plotted. This variable name must be in
<code>colnames(x)</code>.</p>
</td></tr>
<tr><td><code id="plotMain_+3A_s">s</code></td>
<td>
<p>a single value of the penalty parameter <code>lambda</code> at which
coefficients will be extracted via the <code>coef</code> method for objects of
class <code>"sail"</code>. If more than one is supplied, only the first one will
be used.</p>
</td></tr>
<tr><td><code id="plotMain_+3A_f.truth">f.truth</code></td>
<td>
<p>true function. Only used for simulation purposes when the
truth is known. The function takes as a input a numeric vector
corresponding the <code>xvar</code> column in <code>x</code> of length <code>nrow(x)</code>.
A second line will be plotted for the truth and a legend is added to the
plot.</p>
</td></tr>
<tr><td><code id="plotMain_+3A_col">col</code></td>
<td>
<p>color of the line. The first element corresponds to the color used
for the estimated function and the second element is for the true function
(if <code>f.truth</code> is specified). Default: c(&quot;#D55E00&quot;, &quot;#009E73&quot;)</p>
</td></tr>
<tr><td><code id="plotMain_+3A_legend.position">legend.position</code></td>
<td>
<p>position of the legend. Only used when <code>f.truth</code>
is specified. Default: 'bottomleft'. Can be a single keyword from the list
&quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;,
&quot;topright&quot;, &quot;right&quot; and &quot;center&quot;. This places the legend on the inside of
the plot frame at the given location. Partial argument matching is used.</p>
</td></tr>
<tr><td><code id="plotMain_+3A_rug">rug</code></td>
<td>
<p>adds a rug representation (1-d plot) of the data to the plot, logical. Default: TRUE.</p>
</td></tr>
<tr><td><code id="plotMain_+3A_...">...</code></td>
<td>
<p>other graphical paramters passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The linear predictor <code class="reqn">basis(xvar) * \beta_xvar</code> is
plotted against <code>xvar</code>, where <code>basis</code> is the expansion provided
in the original call to <code>sail</code>.
</p>


<h3>Value</h3>

<p>A plot is produced and nothing is returned
</p>


<h3>See Also</h3>

<p><code><a href="sail.html#topic+coef.sail">coef.sail</a></code> <code><a href="sail.html#topic+predict.sail">predict.sail</a></code>, <code><a href="graphics.html#topic+rug">rug</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f.basis &lt;- function(i) splines::bs(i, degree = 3)
# Parallel
library(doParallel)
cl &lt;- makeCluster(2)
registerDoParallel(cl)
cvfit &lt;- cv.sail(x = sailsim$x, y = sailsim$y, e = sailsim$e,
                 parallel = TRUE, nlambda = 10,
                 maxit = 100, basis = f.basis,
                 nfolds = 3, dfmax = 10)
stopCluster(cl)
# plot cv-error curve
plot(cvfit)
# non-zero estimated coefficients at lambda.min
predict(cvfit, type = "nonzero", s="lambda.min")
# plot main effect for X4 with a line for the truth also
plotMain(cvfit$sail.fit, x = sailsim$x, xvar = "X4",
         s = cvfit$lambda.min, f.truth = sailsim$f4)
</code></pre>

<hr>
<h2 id='predict.cv.sail'>Make predictions from a <code>cv.sail</code> object</h2><span id='topic+predict.cv.sail'></span><span id='topic+coef.cv.sail'></span>

<h3>Description</h3>

<p>This function makes predictions from a cross-validated sail
model, using the stored &quot;sail.fit&quot; object, and the optimal value chosen for
lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.sail'
predict(object, newx, newe, s = c("lambda.1se",
  "lambda.min"), ...)

## S3 method for class 'cv.sail'
coef(object, s = c("lambda.1se", "lambda.min"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.cv.sail_+3A_object">object</code></td>
<td>
<p>fitted <code>cv.sail</code> object</p>
</td></tr>
<tr><td><code id="predict.cv.sail_+3A_newx">newx</code></td>
<td>
<p>matrix of new values for <code>x</code> at which predictions are to be
made. Do not include the intercept (this function takes care of that). Must
be a matrix. This argument is not used for
<code>type=c("coefficients","nonzero")</code>. This matrix will be passed to
<code><a href="sail.html#topic+design_sail">design_sail</a></code> to create the design matrix necessary for
predictions. This matrix must have the same number of columns originally
supplied to the <code>sail</code> fitting function.</p>
</td></tr>
<tr><td><code id="predict.cv.sail_+3A_newe">newe</code></td>
<td>
<p>vector of new values for the exposure variable <code>e</code>. This is
passed to the <code>design_sail</code> function.</p>
</td></tr>
<tr><td><code id="predict.cv.sail_+3A_s">s</code></td>
<td>
<p>Value(s) of the penalty parameter <code>lambda</code> at which predictions
are required. Default is the value <code>s="lambda.1se"</code> stored on the CV
<code>object</code>. Alternatively <code>s="lambda.min"</code> can be used. If <code>s</code>
is numeric, it is taken as the value(s) of <code>lambda</code> to be used.</p>
</td></tr>
<tr><td><code id="predict.cv.sail_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="sail.html#topic+predict.sail">predict.sail</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes it easier to use the results of cross-validation
to make a prediction.
</p>


<h3>Value</h3>

<p>The object returned depends the ... argument which is passed on to
the predict method for <code>sail</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="sail.html#topic+predict.sail">predict.sail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sailsim")
f.basis &lt;- function(i) splines::bs(i, degree = 3)
library(doParallel)
cl &lt;- makeCluster(2)
registerDoParallel(cl)
cvfit &lt;- cv.sail(x = sailsim$x, y = sailsim$y, e = sailsim$e,
                 parallel = TRUE, nlambda = 10,
                 maxit = 20, basis = f.basis,
                 nfolds = 3, dfmax = 5)
stopCluster(cl)
predict(cvfit) # predict at "lambda.1se"
predict(cvfit, s = "lambda.min") # predict at "lambda.min"
predict(cvfit, s = 0.5) # predict at specific value of lambda
predict(cvfit, type = "nonzero") # non-zero coefficients at lambda.1se

# predict response for new data set
newx &lt;- sailsim$x * 1.10
newe &lt;- sailsim$e * 2
predict(cvfit, newx = newx, newe = newe, s = "lambda.min")

</code></pre>

<hr>
<h2 id='predict.sail'>Make predictions from a sail object</h2><span id='topic+predict.sail'></span><span id='topic+coef.sail'></span>

<h3>Description</h3>

<p>Similar to other predict methods, this functions predicts fitted
values, logits, coefficients and more from a fitted <code>sail</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sail'
predict(object, newx, newe, s = NULL, type = c("link",
  "response", "coefficients", "nonzero", "class"), ...)

## S3 method for class 'sail'
coef(object, s = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.sail_+3A_object">object</code></td>
<td>
<p>Fitted <code>sail</code> model object</p>
</td></tr>
<tr><td><code id="predict.sail_+3A_newx">newx</code></td>
<td>
<p>matrix of new values for <code>x</code> at which predictions are to be
made. Do not include the intercept (this function takes care of that). Must
be a matrix. This argument is not used for
<code>type=c("coefficients","nonzero")</code>. This matrix will be passed to
<code><a href="sail.html#topic+design_sail">design_sail</a></code> to create the design matrix necessary for
predictions. This matrix must have the same number of columns originally
supplied to the <code>sail</code> fitting function.</p>
</td></tr>
<tr><td><code id="predict.sail_+3A_newe">newe</code></td>
<td>
<p>vector of new values for the exposure variable <code>e</code>. This is
passed to the <code>design_sail</code> function.</p>
</td></tr>
<tr><td><code id="predict.sail_+3A_s">s</code></td>
<td>
<p>Value(s) of the penalty parameter <code>lambda</code> at which predictions
are required. Default is the entire sequence used to create the model.</p>
</td></tr>
<tr><td><code id="predict.sail_+3A_type">type</code></td>
<td>
<p>Type of prediction required. Type <code>"link"</code> gives the linear
predictors for <code>"binomial"</code> (not implemented yet); for
<code>"gaussian"</code> models it gives the fitted values. Type <code>"response"</code>
gives the fitted probabilities for <code>"binomial"</code> (not implemented yet),
for <code>"gaussian"</code> type <code>"response"</code> is equivalent to type
<code>"link"</code>. Type <code>"coefficients"</code> computes the coefficients at the
requested values for <code>s</code>.  Note that for <code>"binomial"</code> models,
results are returned only for the class corresponding to the second level
of the factor response (not implemented yet). Type <code>"class"</code> applies
only to <code>"binomial"</code> models, and produces the class label
corresponding to the maximum probability (not implemented yet). Type
<code>"nonzero"</code> returns a list of the the nonzero coefficients for each
value of <code>s</code>. Default: &quot;link&quot;</p>
</td></tr>
<tr><td><code id="predict.sail_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>R Source code file for predict, coef, plot and print methods for the sail package
Author: Sahir Bhatnagar
Created: 2016
Updated: April 6, 2018
</p>
<p><code>s</code> is the new vector at which predictions are requested. If
<code>s</code> is not in the lambda sequence used for fitting the model, the
predict function will use linear interpolation to make predictions. The new
values are interpolated using a fraction of predicted values from both left
and right lambda indices. <code>coef(...)</code> is equivalent to
<code>predict(sail.object, type="coefficients",...)</code>
</p>


<h3>Value</h3>

<p>The object returned depends on type.
</p>


<h3>See Also</h3>

<p><code><a href="sail.html#topic+predict.cv.sail">predict.cv.sail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f.basis &lt;- function(i) splines::bs(i, degree = 3)
fit &lt;- sail(x = sailsim$x, y = sailsim$y, e = sailsim$e,
            basis = f.basis, dfmax = 5, nlambda = 10, maxit = 20)
predict(fit) # predicted response for whole solution path
predict(fit, s = 0.45) # predicted response for a single lambda value
predict(fit, s = c(2.15, 0.32, 0.40), type="nonzero") # nonzero coefficients
</code></pre>

<hr>
<h2 id='print.sail'>Print Method for <code>sail</code> object</h2><span id='topic+print.sail'></span>

<h3>Description</h3>

<p>Print a summary of the <code>sail</code> path at each step along the
path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sail'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.sail_+3A_x">x</code></td>
<td>
<p>fitted <code>sail</code> object</p>
</td></tr>
<tr><td><code id="print.sail_+3A_digits">digits</code></td>
<td>
<p>significant digits in printout. Default: <code>max(3,
getOption("digits") - 3)</code></p>
</td></tr>
<tr><td><code id="print.sail_+3A_...">...</code></td>
<td>
<p>additional print arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The call that produced the object <code>x</code> is printed, followed by a
five-column matrix with columns <code>df_main</code>, <code>df_interaction</code>,
<code>df_environment</code>, <code>%Dev</code> and <code>Lambda</code>. The <code>df_</code>
columns are the corresponding number of nonzero coefficients for main
effects, interactions and exposure, respectively. <code>%dev</code> is the
percent deviance explained (relative to the null deviance). For
<code>type="gaussian"</code> this is the r-squared.
</p>


<h3>Value</h3>

<p>OUTPUT_DESCRIPTION
</p>


<h3>See Also</h3>

<p><code><a href="sail.html#topic+sail">sail</a></code>, <code><a href="sail.html#topic+cv.sail">cv.sail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("sailsim")
f.basis &lt;- function(i) splines::bs(i, degree = 3)
fit &lt;- sail(x = sailsim$x, y = sailsim$y, e = sailsim$e,
            basis = f.basis, dfmax = 5, nlambda = 10,
            maxit = 20)
fit
</code></pre>

<hr>
<h2 id='Q_theta'>Objective function</h2><span id='topic+Q_theta'></span>

<h3>Description</h3>

<p>calculates likelihood function. Used to assess convergence of
fitting algorithm. This corresponds to the Q(theta) function in the paper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Q_theta(R, nobs, lambda, alpha, we, wj, wje, betaE, theta_list, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Q_theta_+3A_r">R</code></td>
<td>
<p>residual</p>
</td></tr>
<tr><td><code id="Q_theta_+3A_nobs">nobs</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="Q_theta_+3A_lambda">lambda</code></td>
<td>
<p>a user supplied lambda sequence. Typically, by leaving this
option unspecified users can have the program compute its own lambda
sequence based on <code>nlambda</code> and <code>lambda.factor</code>. Supplying a
value of lambda overrides this. It is better to supply a decreasing
sequence of lambda values than a single (small) value, if not, the program
will sort user-defined lambda sequence in decreasing order automatically.
Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="Q_theta_+3A_alpha">alpha</code></td>
<td>
<p>the mixing tuning parameter, with <code class="reqn">0&lt;\alpha&lt;1</code>. It controls
the penalization strength between the main effects and the interactions.
The penalty is defined as </p>
<p style="text-align: center;"><code class="reqn">\lambda(1-\alpha)(w_e|\beta_e|+ \sum w_j
||\beta_j||_2) + \lambda\alpha(\sum w_{je} |\gamma_j|)</code>
</p>
<p>Larger values of
<code>alpha</code> will favor selection of main effects over interactions.
Smaller values of <code>alpha</code> will allow more interactions to enter the
final model. Default: <code>0.5</code></p>
</td></tr>
<tr><td><code id="Q_theta_+3A_we">we</code></td>
<td>
<p>penalty factor for exposure variable</p>
</td></tr>
<tr><td><code id="Q_theta_+3A_wj">wj</code></td>
<td>
<p>penalty factor for main effects</p>
</td></tr>
<tr><td><code id="Q_theta_+3A_wje">wje</code></td>
<td>
<p>penalty factor for interactions</p>
</td></tr>
<tr><td><code id="Q_theta_+3A_betae">betaE</code></td>
<td>
<p>estimate of exposure effect</p>
</td></tr>
<tr><td><code id="Q_theta_+3A_theta_list">theta_list</code></td>
<td>
<p>estimates of main effects</p>
</td></tr>
<tr><td><code id="Q_theta_+3A_gamma">gamma</code></td>
<td>
<p>estimates of gamma parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of the objective function
</p>

<hr>
<h2 id='sail'>Fit Sparse Additive Interaction Model with Strong Heredity</h2><span id='topic+sail'></span>

<h3>Description</h3>

<p>Function to fit the Sparse Additive Interaction Model with
strong heredity for a sequence of tuning parameters. This is a penalized
regression method that ensures the interaction term is non-zero only if its
corresponding main-effects are non-zero. This model only considers the
interactions between a single exposure (E) variable and a high-dimensional
matrix (X). Additive (non-linear) main effects and interactions can be
specified by the user. This can also be seen as a varying-coefficient
model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sail(x, y, e, basis = function(i) splines::bs(i, df = 5),
  strong = TRUE, group.penalty = c("gglasso", "grMCP", "grSCAD"),
  family = c("gaussian", "binomial"), center.x = TRUE,
  center.e = TRUE, expand = TRUE, group, weights,
  penalty.factor = rep(1, 1 + 2 * nvars), lambda.factor = ifelse(nobs &lt;
  (1 + 2 * bscols * nvars), 0.01, 1e-04), lambda = NULL, alpha = 0.5,
  nlambda = 100, thresh = 1e-04, fdev = 1e-05, maxit = 1000,
  dfmax = 2 * nvars + 1, verbose = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sail_+3A_x">x</code></td>
<td>
<p>input matrix of dimension <code>n x p</code>, where <code>n</code> is the number
of subjects and p is number of X variables. Each row is an observation
vector. Can be a high-dimensional (n &lt; p) matrix. Can be a user defined
design matrix of main effects only (without intercept) if
<code>expand=FALSE</code></p>
</td></tr>
<tr><td><code id="sail_+3A_y">y</code></td>
<td>
<p>response variable. For <code>family="gaussian"</code> should be a 1 column
matrix or numeric vector. For <code>family="binomial"</code>, should be a 1
column matrix or numeric vector with -1 for failure and 1 for success.</p>
</td></tr>
<tr><td><code id="sail_+3A_e">e</code></td>
<td>
<p>exposure or environment vector. Must be a numeric vector. Factors
must be converted to numeric.</p>
</td></tr>
<tr><td><code id="sail_+3A_basis">basis</code></td>
<td>
<p>user defined basis expansion function. This function will be
applied to every column in <code>x</code>. Specify <code>function(i) i</code> if no
expansion is desired. Default: <code>function(i) splines::bs(i, df = 5)</code>.</p>
</td></tr>
<tr><td><code id="sail_+3A_strong">strong</code></td>
<td>
<p>Flag specifying strong hierarchy (TRUE) or weak hierarchy
(FALSE). Default FALSE.</p>
</td></tr>
<tr><td><code id="sail_+3A_group.penalty">group.penalty</code></td>
<td>
<p>group lasso penalty. Can be one of <code>"gglasso"</code>
(group lasso), <code>"grMCP"</code> (group MCP) or <code>"grSCAD"</code> (group SCAD).
See references for details. Default: <code>"gglasso"</code>.</p>
</td></tr>
<tr><td><code id="sail_+3A_family">family</code></td>
<td>
<p>response type. See <code>y</code> for details. Currently only
<code>family = "gaussian"</code> is implemented. Default: <code>"gaussian"</code>.</p>
</td></tr>
<tr><td><code id="sail_+3A_center.x">center.x</code></td>
<td>
<p>should the columns of <code>x</code> (after basis expansion) be
centered (logical). Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sail_+3A_center.e">center.e</code></td>
<td>
<p>should exposure variable <code>e</code> be centered. Default:
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sail_+3A_expand">expand</code></td>
<td>
<p>should <code>basis</code> be applied to every column of <code>x</code>
(logical). Set to <code>FALSE</code> if you want a user defined main effects
design matrix. If <code>FALSE</code> the <code>group</code> membership argument must
also be supplied. Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sail_+3A_group">group</code></td>
<td>
<p>a vector of consecutive integers, starting from 1, describing
the grouping of the coefficients. Only required when <code>expand=FALSE</code>.</p>
</td></tr>
<tr><td><code id="sail_+3A_weights">weights</code></td>
<td>
<p>observation weights. Default is 1 for each observation.
Currently NOT IMPLEMENTED.</p>
</td></tr>
<tr><td><code id="sail_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>separate penalty factors can be applied to each
coefficient. This is a number that multiplies lambda to allow differential
shrinkage. Can be 0 for some variables, which implies no shrinkage, and
that variable is always included in the model. Default is 1 for all
variables. Must be of length <code>1 + 2*ncol(x)</code> where the first entry
corresponds to the penalty.factor for <code>e</code>, the next <code>ncol(x)</code>
entries correspond to main effects, and the following <code>ncol(x)</code>
entries correspond to the interactions.</p>
</td></tr>
<tr><td><code id="sail_+3A_lambda.factor">lambda.factor</code></td>
<td>
<p>the factor for getting the minimal lambda in the lambda
sequence, where <code>min(lambda) = lambda.factor * max(lambda)</code>.
<code>max(lambda)</code> is the smallest value of lambda for which all
coefficients are zero. The default depends on the relationship between
<code>N</code> (the number of rows in the matrix of predictors) and <code>q</code> (the
total number of predictors in the design matrix - including interactions).
If <code>N &gt; q</code>, the default is <code>1e-4</code>, close to zero. If <code>N &lt;
p</code>, the default is <code>0.01</code>. A very small value of lambda.factor will
lead to a saturated fit.</p>
</td></tr>
<tr><td><code id="sail_+3A_lambda">lambda</code></td>
<td>
<p>a user supplied lambda sequence. Typically, by leaving this
option unspecified users can have the program compute its own lambda
sequence based on <code>nlambda</code> and <code>lambda.factor</code>. Supplying a
value of lambda overrides this. It is better to supply a decreasing
sequence of lambda values than a single (small) value, if not, the program
will sort user-defined lambda sequence in decreasing order automatically.
Default: <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="sail_+3A_alpha">alpha</code></td>
<td>
<p>the mixing tuning parameter, with <code class="reqn">0&lt;\alpha&lt;1</code>. It controls
the penalization strength between the main effects and the interactions.
The penalty is defined as </p>
<p style="text-align: center;"><code class="reqn">\lambda(1-\alpha)(w_e|\beta_e|+ \sum w_j
||\beta_j||_2) + \lambda\alpha(\sum w_{je} |\gamma_j|)</code>
</p>
<p>Larger values of
<code>alpha</code> will favor selection of main effects over interactions.
Smaller values of <code>alpha</code> will allow more interactions to enter the
final model. Default: <code>0.5</code></p>
</td></tr>
<tr><td><code id="sail_+3A_nlambda">nlambda</code></td>
<td>
<p>the number of lambda values. Default: 100</p>
</td></tr>
<tr><td><code id="sail_+3A_thresh">thresh</code></td>
<td>
<p>convergence threshold for coordinate descent. Each
coordinate-descent loop continues until the change in the objective
function after all coefficient updates is less than <code>thresh</code>. Default:
<code>1e-04</code>.</p>
</td></tr>
<tr><td><code id="sail_+3A_fdev">fdev</code></td>
<td>
<p>minimum fractional change in deviance for stopping path. Default:
<code>1e-5</code>.</p>
</td></tr>
<tr><td><code id="sail_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of outer-loop iterations allowed at fixed lambda
value. If models do not converge, consider increasing <code>maxit</code>.
Default: 1000.</p>
</td></tr>
<tr><td><code id="sail_+3A_dfmax">dfmax</code></td>
<td>
<p>limit the maximum number of variables in the model. Useful for
very large <code>q</code> (the total number of predictors in the design matrix -
including interactions), if a partial path is desired. Default: <code>2 * p
+ 1</code> where p is the number of columns in <code>x</code>.</p>
</td></tr>
<tr><td><code id="sail_+3A_verbose">verbose</code></td>
<td>
<p>display progress. Can be either 0,1 or 2. 0 will not display
any progress, 2 will display very detailed progress and 1 is somewhere in
between. Default: 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The objective function for <code>family="gaussian"</code> is </p>
<p style="text-align: center;"><code class="reqn">RSS/2n
  + \lambda(1-\alpha)(w_e|\beta_e|+ \sum w_j ||\beta_j||_2) +
  \lambda\alpha(\sum w_{je} |\gamma_j|)</code>
</p>
<p> where <code>RSS</code> is the residual sum
of squares and <code>n</code> is the number of observations. See Bhatnagar et al.
(2018+) for details.
</p>
<p>It is highly recommended to specify <code>center.x = TRUE</code> and
<code>center.e = TRUE</code> for both convergence and interpretation reasons. If
centered, the final estimates can be interpreted as the effect of the
predictor on the response while holding all other predictors at their mean
value. For computing speed reasons, if models are not converging or running
slow, consider increasing <code>thresh</code>, decreasing <code>nlambda</code>, or
increasing <code>lambda.factor</code> before increasing <code>maxit</code>. Then try
increasing the value of <code>alpha</code> (which translates to more penalization
on the interactions).
</p>
<p>By default, <code>sail</code> uses the group lasso penalty on the basis
expansions of <code>x</code>. To use the group MCP and group SCAD penalties (see
Breheny and Huang 2015), the <code>grpreg</code> package must be installed.
</p>


<h3>Value</h3>

<p>an object with S3 class &quot;sail&quot;, <code>"*"</code>, where <code>"*"</code> is
&quot;lspath&quot; or &quot;logitreg&quot;. Results are provided for converged values of lambda
only. </p>
<dl>
<dt>call</dt><dd><p>the call that produced this object</p>
</dd>
<dt>a0</dt><dd><p>intercept sequence of length <code>nlambda</code></p>
</dd> <dt>beta</dt><dd><p>a (#
main effects after basis expansion x <code>nlambda</code>) matrix of main effects
coefficients, stored in sparse column format <code>("dgCMatrix")</code></p>
</dd>
<dt>alpha</dt><dd><p>a (# interaction effects after basis expansion x
<code>nlambda</code>) matrix of interaction effects coefficients, stored in
sparse column format <code>("dgCMatrix")</code></p>
</dd> <dt>gamma</dt><dd><p>A <code>p x
  nlambda</code> matrix of (<code class="reqn">\gamma</code>) coefficients, stored in sparse column
format <code>("dgCMatrix")</code></p>
</dd> <dt>bE</dt><dd><p>exposure effect estimates of length
<code>nlambda</code></p>
</dd> <dt>active</dt><dd><p>list of length <code>nlambda</code> containing
character vector of selected variables</p>
</dd> <dt>lambda</dt><dd><p>the actual sequence
of lambda values used</p>
</dd> <dt>lambda2</dt><dd><p>value for the mixing tuning parameter
<code class="reqn">0&lt;\alpha&lt;1</code></p>
</dd> <dt>dfbeta</dt><dd><p>the number of nonzero main effect
coefficients for each value of lambda</p>
</dd> <dt>dfalpha</dt><dd><p>the number of nonzero
interaction coefficients for each value of lambda</p>
</dd> <dt>dfenviron</dt><dd><p>the
number of nonzero exposure (<code>e</code>) coefficients for each value of
lambda</p>
</dd> <dt>dev.ratio</dt><dd><p>the fraction of (null) deviance explained (for
&quot;lspath&quot;, this is the R-square). The deviance calculations incorporate
weights if present in the model. The deviance is defined to be
2*(loglike_sat - loglike), where loglike_sat is the log-likelihood for the
saturated model (a model with a free parameter per observation). Hence
dev.ratio=1-dev/nulldev.</p>
</dd> <dt>converged</dt><dd><p>vector of logicals of length
<code>nlambda</code> indicating if the algorithm converged</p>
</dd> <dt>nlambda</dt><dd><p>number
of converged lambdas</p>
</dd> <dt>design</dt><dd><p>design matrix (X, E, X:E), of dimension
<code>n x (2*ncols*p+1)</code> if <code>expand=TRUE</code>. This is used in the
<code>predict</code> method.</p>
</dd> <dt>nobs</dt><dd><p>number of observations</p>
</dd>
<dt>nvars</dt><dd><p>number of main effect variables</p>
</dd> <dt>vnames</dt><dd><p>character of
variable names for main effects (without expansion)</p>
</dd> <dt>ncols</dt><dd><p>an
integer of basis for each column of x if <code>expand=TRUE</code>, or an integer
vector of basis for each variable if <code>expand=FALSE</code></p>
</dd>
<dt>center.x</dt><dd><p>were the columns of x (after expansion) centered?</p>
</dd>
<dt>center.e</dt><dd><p>was <code>e</code> centered?</p>
</dd> <dt>basis</dt><dd><p>user defined basis
expansion function</p>
</dd> <dt>expand</dt><dd><p>was the basis function applied to each
column of x?</p>
</dd> <dt>group</dt><dd><p>a vector of consecutive integers describing the
grouping of the coefficients. Only if expand=FALSE</p>
</dd>
<dt>interaction.names</dt><dd><p>character vector of names of interaction
variables</p>
</dd> <dt>main.effect.names</dt><dd><p>character vector of names of main
effect variables (with expansion)</p>
</dd> </dl>



<h3>Author(s)</h3>

<p>Sahir Bhatnagar
</p>
<p>Maintainer: Sahir Bhatnagar <a href="mailto:sahir.bhatnagar@gmail.com">sahir.bhatnagar@gmail.com</a>
</p>


<h3>References</h3>

<p>Jerome Friedman, Trevor Hastie, Robert Tibshirani (2010).
Regularization Paths for Generalized Linear Models via Coordinate Descent.
Journal of Statistical Software, 33(1), 1-22.
<a href="http://www.jstatsoft.org/v33/i01/">http://www.jstatsoft.org/v33/i01/</a>.
</p>
<p>Breheny P and Huang J (2015). Group descent algorithms for
nonconvex penalized linear and logistic regression models with grouped
predictors. Statistics and Computing, 25: 173-187.
</p>
<p>Yang Y, Zou H (2015). A fast unified algorithm for solving
group-lasso penalize learning problems. Statistics and Computing. Nov
1;25(6):1129-41.
<a href="http://www.math.mcgill.ca/yyang/resources/papers/STCO_gglasso.pdf">http://www.math.mcgill.ca/yyang/resources/papers/STCO_gglasso.pdf</a>
</p>
<p>Bhatnagar SR, Yang Y, Greenwood CMT. Sparse additive interaction
models with the strong heredity property (2018+). Preprint.
</p>


<h3>See Also</h3>

<p><code><a href="splines.html#topic+bs">bs</a></code> <code><a href="sail.html#topic+cv.sail">cv.sail</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f.basis &lt;- function(i) splines::bs(i, degree = 3)
# we specify dfmax to early stop the solution path to
# limit the execution time of the example
fit &lt;- sail(x = sailsim$x, y = sailsim$y, e = sailsim$e,
            basis = f.basis, nlambda = 10, dfmax = 10,
            maxit = 100)

# estimated coefficients at each value of lambda
coef(fit)

# predicted response at each value of lambda
predict(fit)

#predicted response at a specific value of lambda
predict(fit, s = 0.5)
# plot solution path for main effects and interactions
plot(fit)
# plot solution path only for main effects
plot(fit, type = "main")
# plot solution path only for interactions
plot(fit, type = "interaction")

</code></pre>

<hr>
<h2 id='sail-internal'>Internal sail functions</h2><span id='topic+sail-internal'></span><span id='topic+SoftThreshold'></span><span id='topic+l2norm'></span><span id='topic+cbbPalette'></span><span id='topic+nonzero'></span><span id='topic+check_col_0'></span>

<h3>Description</h3>

<p>Internal sail helper functions
</p>
<p><code>cbbPalette</code> gives a Color Blind Palette
</p>
<p><code>nonzero</code> is to determine which coefficients are non-zero
</p>
<p><code>check_col_0</code> is to check how many columns are 0 and is
used in the fitting functions <code>lspath</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SoftThreshold(x, lambda)

l2norm(x)

cbbPalette

nonzero(beta, bystep = FALSE)

check_col_0(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sail-internal_+3A_x">x</code></td>
<td>
<p>numeric value of a coefficient</p>
</td></tr>
<tr><td><code id="sail-internal_+3A_lambda">lambda</code></td>
<td>
<p>tuning parameter value</p>
</td></tr>
<tr><td><code id="sail-internal_+3A_beta">beta</code></td>
<td>
<p>vector or 1 column matrix of regression coefficients</p>
</td></tr>
<tr><td><code id="sail-internal_+3A_bystep">bystep</code></td>
<td>
<p><code>bystep = FALSE</code> means which variables were ever nonzero.
<code>bystep = TRUE</code> means which variables are nonzero for each step</p>
</td></tr>
<tr><td><code id="sail-internal_+3A_m">M</code></td>
<td>
<p>is a matrix</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 8.</p>


<h3>Details</h3>

<p>These functions are not intended for use by users.
</p>

<hr>
<h2 id='sailsim'>Simulated Data Used in Bhatnagar et al. (2018+) Paper</h2><span id='topic+sailsim'></span>

<h3>Description</h3>

<p>A dataset containing simulated data used in the accompanying paper to this
package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sailsim
</code></pre>


<h3>Format</h3>

<p>A list with 7 elements: </p>
 <dl>
<dt>x</dt><dd><p>a matrix of dimension
<code>100 x 20</code> where rows are observations and columns are
predictors</p>
</dd><dt>y</dt><dd><p>a numeric response vector of length 100 </p>
</dd><dt>e</dt><dd><p>a
numeric exposure vector of length 100</p>
</dd><dt>f1,f2,f3,f4</dt><dd><p>the true
functions</p>
</dd> </dl>


<h3>Details</h3>

<p>The code used to simulate the data is available at
<a href="https://github.com/sahirbhatnagar/sail/blob/master/data-raw/SIMULATED_data.R">https://github.com/sahirbhatnagar/sail/blob/master/data-raw/SIMULATED_data.R</a>.
See <code><a href="sail.html#topic+gendata">gendata</a></code> for more details. The true model is given by
</p>
<p style="text-align: center;"><code class="reqn">Y = f1(X1) + f2(X2) +  f3(X3) + f4(X4) +  E * (2 +  f3(X3) +
  f4(X4))</code>
</p>
<p> where </p>
<dl>
<dt></dt><dd><p>f1(t)=5t</p>
</dd><dt></dt><dd><p>f2(t)=3(2t -
1)^2</p>
</dd><dt></dt><dd><p>f3(t)= 4sin(2pi*t) /
(2-sin(2pi*t)</p>
</dd><dt></dt><dd><p>f4(t)=6(0.1sin(2pi*t) + 0.2cos(2pi*t) +
0.3sin(2pi*t)^2 + 0.4cos(2pi*t)^3 + 0.5sin(2pi*t)^3)</p>
</dd></dl>



<h3>References</h3>

<p>Lin, Y., &amp; Zhang, H. H. (2006). Component selection and smoothing
in multivariate nonparametric regression. The Annals of Statistics, 34(5),
2272-2297.
</p>
<p>Huang J, Horowitz JL, Wei F. Variable selection in nonparametric
additive models (2010). Annals of statistics. Aug 1;38(4):2282.
</p>
<p>Bhatnagar SR, Yang Y, Greenwood CMT. Sparse additive interaction
models with the strong heredity property (2018+). Preprint.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sailsim
</code></pre>

<hr>
<h2 id='standardize'>Standardize Data</h2><span id='topic+standardize'></span>

<h3>Description</h3>

<p>Function that standardizes the data before running the fitting
algorithm. This is used in the <code><a href="sail.html#topic+sail">sail</a></code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize(x, center = TRUE, normalize = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_+3A_x">x</code></td>
<td>
<p>data to be standardized</p>
</td></tr>
<tr><td><code id="standardize_+3A_center">center</code></td>
<td>
<p>Should <code>x</code> be centered. Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="standardize_+3A_normalize">normalize</code></td>
<td>
<p>Should <code>x</code> be scaled to have unit variance. Default is
<code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of length 3: </p>
 <dl>
<dt>x</dt><dd><p>centered and possibly
normalized <code>x</code> matrix</p>
</dd> <dt>bx</dt><dd><p>numeric vector of column means of
<code>x</code> matrix</p>
</dd> <dt>sx</dt><dd><p>standard deviations (using a divisor of
<code>n</code> observations) of columns of <code>x</code> matrix</p>
</dd> </dl>


</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
