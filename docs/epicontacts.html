<!DOCTYPE html><html><head><title>Help for package epicontacts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {epicontacts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#[.epicontacts'><p>Subset epicontacts objects based on case identifiers</p></a></li>
<li><a href='#as.igraph.epicontacts'><p>Create igraph object from contact data</p></a></li>
<li><a href='#codeawesome'><p>Reference codes for fontawesome</p></a></li>
<li><a href='#get_clusters'><p>Assign cluster IDs to epicontacts data</p></a></li>
<li><a href='#get_degree'><p>Find node degree for epicontacts objects</p></a></li>
<li><a href='#get_id'><p>Access unique identifiers in epicontacts objects</p></a></li>
<li><a href='#get_pairwise'><p>Characterise contacts by comparing case attributes</p></a></li>
<li><a href='#graph3D'><p>Interactive 3D Force-directed graph from epicontacts object</p></a></li>
<li><a href='#make_epicontacts'><p>Read linelist and contact data</p></a></li>
<li><a href='#plot.epicontacts'><p>Plot epicontacts objects</p></a></li>
<li><a href='#print.epicontacts'><p>Print method for epicontacts objects</p></a></li>
<li><a href='#print.summary_epicontacts'><p>Print method for summary_epicontacts objects</p></a></li>
<li><a href='#subset_clusters_by_id'><p>Subset epicontacts by case-specified clusters</p></a></li>
<li><a href='#subset_clusters_by_size'><p>Subset clusters from epicontacts object by cluster size</p></a></li>
<li><a href='#subset.epicontacts'><p>Subset an epicontact object by factors</p></a></li>
<li><a href='#summary.epicontacts'><p>Summary method for epicontacts objects</p></a></li>
<li><a href='#thin'><p>Thin data to retain matching linelist / contacts</p></a></li>
<li><a href='#transp'><p>Color tools and palettes for epicontacts</p></a></li>
<li><a href='#vis_epicontacts'><p>Plot epicontacts objects using visNetwork</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Handling, Visualisation and Analysis of Epidemiological Contacts</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-03-28</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of tools for representing epidemiological contact data, composed of case line lists and contacts between cases. Also contains procedures for data handling, interactive graphics, and statistics.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, dplyr, igraph, visNetwork, threejs, colorspace,
methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>outbreaks, testthat, covr, shiny, readr, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.repidemicsconsortium.org/epicontacts/">https://www.repidemicsconsortium.org/epicontacts/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/reconhub/epicontacts/issues">https://github.com/reconhub/epicontacts/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-28 12:50:37 UTC; campbellf</td>
</tr>
<tr>
<td>Author:</td>
<td>Finlay Campbell [aut, cre],
  Thibaut Jombart [aut],
  Nistara Randhawa [aut],
  Bertrand Sudre [aut],
  VP Nagraj [aut],
  Thomas Crellen [aut],
  Zhian N. Kamvar [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Finlay Campbell &lt;finlaycampbell93@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-28 13:10:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.epicontacts'>Subset epicontacts objects based on case identifiers</h2><span id='topic++5B.epicontacts'></span>

<h3>Description</h3>

<p>The &quot;[&quot; operator can be used to subset <code><a href="#topic+epicontacts">epicontacts</a></code> objects,
retaining a specified set of case identifiers (<code>i</code> for the linelist,
<code>j</code> for contacts). Note that unlike most classical R objects, there is
no replacement method for <code><a href="#topic+epicontacts">epicontacts</a></code> objects, i.e. no
operations such as <code>foo[i] &lt;- bar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epicontacts'

  x[
  i,
  j,
  k = TRUE,
  l = TRUE,
  contacts = c("both", "either", "from", "to"),
  ...
]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.epicontacts_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+epicontacts">epicontacts</a></code> object</p>
</td></tr>
<tr><td><code id="+2B5B.epicontacts_+3A_i">i</code></td>
<td>
<p>A character vector containing case ID to be retained in the
linelist; alternatively, an integer or logical vector used to subset the
rows of the <code>$linelist</code> component.</p>
</td></tr>
<tr><td><code id="+2B5B.epicontacts_+3A_j">j</code></td>
<td>
<p>A character vector containing case ID to be retained in the
contacts; alternatively, an integer or logical vector used to subset
the rows of the <code>$contacts</code> component.</p>
</td></tr>
<tr><td><code id="+2B5B.epicontacts_+3A_k">k</code></td>
<td>
<p>An integer, logical, or character vector subsetting the
supplementary columns of <code>x$linelist</code>, i.e. the columns after 'id';
i.e. <code>k=1</code> refers to the column immediately after 'id'.</p>
</td></tr>
<tr><td><code id="+2B5B.epicontacts_+3A_l">l</code></td>
<td>
<p>An integer, logical, or character vector subsetting the
supplementary columns of <code>x$contacts</code>, i.e. the columns after 'from'
and 'to'; i.e. <code>l=1</code> refers to the column immediately after 'to'.</p>
</td></tr>
<tr><td><code id="+2B5B.epicontacts_+3A_contacts">contacts</code></td>
<td>
<p>A character string indicating the rules for retaining
contacts when <code>j</code> indicates case IDs (see details).</p>
</td></tr>
<tr><td><code id="+2B5B.epicontacts_+3A_...">...</code></td>
<td>
<p>Not used (there for compatibility with generic).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details on the 'contacts' argument; possible values are:
</p>

<ul>
<li><p> 'both': contacts are retained only if both cases are in <code>j</code>
</p>
</li>
<li><p> 'either': contacts are retained if at least one of the cases is in
<code>j</code>
</p>
</li>
<li><p> 'from': contacts are retained only if the source ('from') is in
<code>j</code>
</p>
</li>
<li><p> 'to': contacts are retained only if the recipient ('to') is in <code>j</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thibaut Jombart (<a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+thin">thin</a></code> to retain matching cases in linelist or contacts.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(outbreaks)) {
## build data
x &lt;- make_epicontacts(ebola_sim$linelist, ebola_sim$contacts,
                       id = "case_id", to = "case_id", from = "infector",
                       directed = TRUE)

## subset first 10 linelist cases
x[1:10]

## same, remove contacts
x[1:10, j = FALSE]

## subset first 10 contacts
x[j = 1:10]

## remove the metadata
x[k = FALSE, j = FALSE]

## keep contacts where both cases are in linelist
x[j = get_id(x, "linelist"), contacts = "both"]

## keep contacts from a specific case '916d0a'
x[j = "916d0a", contacts = "from"]

## more complex: keep all cases and contacts with &gt; 4 secondary contacts
## i) find cases to keep
temp &lt;- table(x$contacts$from)
temp[temp &gt; 4]
to.keep &lt;- names(temp)[temp &gt; 4]
to.keep

## subset the contacts
y &lt;- x[j = to.keep, contacts = "either"]
y

## keep only relevant entries in the linelist
y &lt;- thin(y)

## visualise result
plot(y)
}
</code></pre>

<hr>
<h2 id='as.igraph.epicontacts'>Create igraph object from contact data</h2><span id='topic+as.igraph.epicontacts'></span>

<h3>Description</h3>

<p>This function creates an igraph object from a given <code><a href="#topic+epicontacts">epicontacts</a></code>
object containing a 'contacts' dataframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epicontacts'
as.igraph(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.igraph.epicontacts_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+epicontacts">epicontacts</a></code> object.</p>
</td></tr>
<tr><td><code id="as.igraph.epicontacts_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>as.igraph</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>igraph</code> object (from the <code>igraph</code> package).  Note: any
column called &quot;name&quot; in the original linelist will be stored as a new
vertex attribute in the <code>igraph</code> object named 'epicontacts_name'.
This is due to the inherent behaviour of igraph creating its own 'name'
vertex attribute.
</p>


<h3>Author(s)</h3>

<p>Nistara Randhawa (<a href="mailto:nrandhawa@ucdavis.edu">nrandhawa@ucdavis.edu</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(outbreaks) &amp;&amp; require(igraph)) {
## build data

x &lt;- make_epicontacts(ebola_sim$linelist, ebola_sim$contacts,
                      id = "case_id", to = "case_id", from ="infector",
                      directed = TRUE)


## subset data - keep 50 cases from linelist with contacts

ids &lt;- get_id(x, "common")[1:50]
ids
x &lt;- x[ids, ids]


## make igraph object with associated attributes from epicontacts object

net &lt;- as.igraph(x)
net
plot(net, vertex.label = "", vertex.size = 10,
     vertex.color = cases_pal(50))
}
</code></pre>

<hr>
<h2 id='codeawesome'>Reference codes for fontawesome</h2><span id='topic+codeawesome'></span>

<h3>Description</h3>

<p>The object <code>codeawesome</code> is a character vector of fontawesome codes,
named after their aliases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>codeawesome
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 519.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart
</p>

<hr>
<h2 id='get_clusters'>Assign cluster IDs to epicontacts data</h2><span id='topic+get_clusters'></span>

<h3>Description</h3>

<p>This function identifies transitive clusters (i.e. connected components) as well
as the number of members in each cluster, and adds this information to the
linelist data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_clusters(
  x,
  output = c("epicontacts", "data.frame"),
  member_col = "cluster_member",
  size_col = "cluster_size",
  override = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_clusters_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+epicontacts">epicontacts</a></code> object.</p>
</td></tr>
<tr><td><code id="get_clusters_+3A_output">output</code></td>
<td>
<p>A character string indicating the type of output: either an
<code><a href="#topic+epicontacts">epicontacts</a></code> object (default) or a <a href="base.html#topic+data.frame">data.frame</a> containing
cluster memberships to which members of <code><a href="#topic+epicontacts">epicontacts</a></code> linelist belong
to.</p>
</td></tr>
<tr><td><code id="get_clusters_+3A_member_col">member_col</code></td>
<td>
<p>Name of column to which cluster membership is assigned to in the
linelist. Default name is 'cluster_member'.</p>
</td></tr>
<tr><td><code id="get_clusters_+3A_size_col">size_col</code></td>
<td>
<p>Name of column to which cluster sizes are assigned to in the
linelist. Default name is 'cluster_size'.</p>
</td></tr>
<tr><td><code id="get_clusters_+3A_override">override</code></td>
<td>
<p>Logical value indicating whether cluster member and size columns
should be overwritten if they already exist in the linelist. Default is 'FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+epicontacts">epicontacts</a></code> object whose 'linelist' dataframe
contains new columns corresponding to cluster membership and size, or a
<a href="base.html#topic+data.frame">data.frame</a> containing member ids, cluster memberships as factors,
and associated cluster sizes. All ids that were originally in the 'contacts'
dataframe but not in the linelist will also be added to the linelist.
</p>


<h3>Author(s)</h3>

<p>Nistara Randhawa (<a href="mailto:nrandhawa@ucdavis.edu">nrandhawa@ucdavis.edu</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(outbreaks)) {
## build data
x &lt;- make_epicontacts(ebola_sim$linelist, ebola_sim$contacts,
                       id = "case_id",
                       to = "case_id",
                       from = "infector",
                       directed = TRUE)


## add cluster membership and sizes to epicontacts 'linelist'
y &lt;- get_clusters(x, output = "epicontacts")
y

## return a data.frame with linelist member ids and cluster memberships as
## factors
z &lt;- get_clusters(x, output = "data.frame")
head(z)

}
</code></pre>

<hr>
<h2 id='get_degree'>Find node degree for epicontacts objects</h2><span id='topic+get_degree'></span>

<h3>Description</h3>

<p>This function computes the number of contacts per cases in a
<code><a href="#topic+epicontacts">epicontacts</a></code> dataset. Whenever contacts are directed, the
argument 'type' can be used to specify which kind of contact should be
considered: 'in' (towards the case), 'out' (from the case), or 'both'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_degree(x, type = c("in", "out", "both"), only_linelist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_degree_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+epicontacts">epicontacts</a></code> object</p>
</td></tr>
<tr><td><code id="get_degree_+3A_type">type</code></td>
<td>
<p>the type of degree to be computed (see description); if contacts
are not directed, this will be forced to 'both'</p>
</td></tr>
<tr><td><code id="get_degree_+3A_only_linelist">only_linelist</code></td>
<td>
<p>a logical indicating if cases whose degree is computed
should be from the linelist exclusively</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thibaut Jombart (<a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## make epicontacts object
if (require(outbreaks)) {
x &lt;- make_epicontacts(ebola_sim$linelist, ebola_sim$contacts,
                       id="case_id", to="case_id", from="infector",
                       directed=TRUE)
x

## compute in-degree
deg_in &lt;- get_degree(x)
table(deg_in)

## compute out-degree
deg_out &lt;- get_degree(x, "out")
barplot(table(deg_out), main = "Reproduction number distribution")
mtext(side = 3, "(based on case out-degree)")

}

</code></pre>

<hr>
<h2 id='get_id'>Access unique identifiers in epicontacts objects</h2><span id='topic+get_id'></span>

<h3>Description</h3>

<p>This accessor is used to extract unique identifiers from
<code><a href="#topic+epicontacts">epicontacts</a></code> objects. The argument 'which' can be used to
specify if IDs should include: linelist only ('linelist'), contacts only
('contacts'), the union of both ('all'), or the intersection of both
('common'); two additional options are 'from' (ID 'giving' contacts) and 'to'
(ID 'receiving' contacts).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_id(
  x,
  which = c("linelist", "contacts", "all", "common", "from", "to"),
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_id_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+epicontacts">epicontacts</a></code> object</p>
</td></tr>
<tr><td><code id="get_id_+3A_which">which</code></td>
<td>
<p>the type of ID to return (see description); value can be
'linelist', 'contacts', 'all', 'common', 'from' or 'to'.</p>
</td></tr>
<tr><td><code id="get_id_+3A_na.rm">na.rm</code></td>
<td>
<p>a 'logical' indicating if 'NA' should be removed from the output
('TRUE', default) or not.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x a character vector of unique identifiers
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart (<a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (require(outbreaks)) {
## build data
x &lt;- make_epicontacts(ebola_sim$linelist, ebola_sim$contacts,
                       id="case_id", to="case_id", from="infector",
                       directed=TRUE)

## get identifiers
id1 &lt;- get_id(x, "linelist")
id2 &lt;- get_id(x, "contacts")
id3 &lt;- get_id(x, "all")
id4 &lt;- get_id(x, "common")

## check intersections and unions
all.equal(union(id1, id2), id3)
all.equal(intersect(id1, id2), id4)

}

</code></pre>

<hr>
<h2 id='get_pairwise'>Characterise contacts by comparing case attributes</h2><span id='topic+get_pairwise'></span>

<h3>Description</h3>

<p>This function extract attributes of cases involved in contacts using case
information provided in the linelist of an <code><a href="#topic+epicontacts">epicontacts</a></code>
dataset. If not provided, the function used to process attributes will adjust
to the type of attribute selected (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_pairwise(x, attribute, f = NULL, hard_NA = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_pairwise_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+epicontacts">epicontacts</a></code> object</p>
</td></tr>
<tr><td><code id="get_pairwise_+3A_attribute">attribute</code></td>
<td>
<p>the attribute to be examined between contact pairs</p>
</td></tr>
<tr><td><code id="get_pairwise_+3A_f">f</code></td>
<td>
<p>a function processing the attributes of 'from' and 'to'</p>
</td></tr>
<tr><td><code id="get_pairwise_+3A_hard_na">hard_NA</code></td>
<td>
<p>a logical indicating if the output should be NA whenever one
of the paired values is NA (TRUE, default); otherwise, 'NA' may be
treated as another character (e.g. when pasting paired values)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thibaut Jombart (<a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>)
Tom Crellen (<a href="mailto:tomcrellen@gmail.com">tomcrellen@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(outbreaks)) {
## example using MERS outbreak in Korea, 2014
head(mers_korea_2015[[1]])
head(mers_korea_2015[[2]])

x &lt;- make_epicontacts(linelist=mers_korea_2015[[1]],
contacts=mers_korea_2015[[2]], directed=TRUE)

## estimate serial interval (onset-&gt;onset)
SI &lt;- get_pairwise(x, "dt_onset")
SI
summary(SI)
hist(SI, col="grey", border="white", xlab="Days after symptoms",
     main="MERS Korea 2014 - Serial Interval")

## check gender mixing:
get_pairwise(x, "sex") # not good, we want 2-way table

get_pairwise(x, "sex", f=table) # use custom function
fisher.test(get_pairwise(x, "sex", f=table)) # test association
}
</code></pre>

<hr>
<h2 id='graph3D'>Interactive 3D Force-directed graph from epicontacts object</h2><span id='topic+graph3D'></span>

<h3>Description</h3>

<p>This function creates a 3D graph from an epicontacts object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph3D(
  x,
  node_color = "id",
  annot = TRUE,
  col_pal = cases_pal,
  NA_col = "lightgrey",
  g_title = "",
  bg_col = "white",
  label_col = "darkgrey",
  node_size = 1,
  edge_size = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph3D_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+epicontacts">epicontacts</a></code> object</p>
</td></tr>
<tr><td><code id="graph3D_+3A_node_color">node_color</code></td>
<td>
<p>An index or character string indicating which field of the
linelist should be used to color the nodes. Default is <code>id</code></p>
</td></tr>
<tr><td><code id="graph3D_+3A_annot">annot</code></td>
<td>
<p>An index, logical, or character string indicating which fields
of the linelist should be used for annotating the nodes upon mouseover. The default
<code>TRUE</code> shows the 'id' and 'node_color' (if the grouping column is different from 'id').</p>
</td></tr>
<tr><td><code id="graph3D_+3A_col_pal">col_pal</code></td>
<td>
<p>A color palette for the node_colors.</p>
</td></tr>
<tr><td><code id="graph3D_+3A_na_col">NA_col</code></td>
<td>
<p>The color used for unknown node_color.</p>
</td></tr>
<tr><td><code id="graph3D_+3A_g_title">g_title</code></td>
<td>
<p>The title of the graph.</p>
</td></tr>
<tr><td><code id="graph3D_+3A_bg_col">bg_col</code></td>
<td>
<p>The background color of graph.</p>
</td></tr>
<tr><td><code id="graph3D_+3A_label_col">label_col</code></td>
<td>
<p>The color of the graph title and labels of groups.</p>
</td></tr>
<tr><td><code id="graph3D_+3A_node_size">node_size</code></td>
<td>
<p>The sizes of graph nodes.</p>
</td></tr>
<tr><td><code id="graph3D_+3A_edge_size">edge_size</code></td>
<td>
<p>The width of graph edges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An htmlwidget object that is displayed using the object's show or print method.
(If you don't see your widget plot, try printing it with the <code>print</code> function.)
</p>


<h3>Note</h3>

<p>All colors must be specified as color names like &quot;red&quot;, &quot;blue&quot;, etc. or
as hexadecimal color values without opacity channel, for example &quot;#FF0000&quot;, &quot;#0a3e55&quot;
(upper or lower case hex digits are allowed).
</p>
<p>Double-click or tap on the plot to reset the view.
</p>


<h3>Author(s)</h3>

<p>Nistara Randhawa (<a href="mailto:nrandhawa@ucdavis.edu">nrandhawa@ucdavis.edu</a>)
Thibaut Jombart (<a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>)
VP Nagraj (<a href="mailto:vpnagraj@virginia.edu">vpnagraj@virginia.edu</a>)
</p>


<h3>References</h3>

<p>Original rthreejs code by B. W. Lewis:
<a href="https://github.com/bwlewis/rthreejs">https://github.com/bwlewis/rthreejs</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(outbreaks)) {

## example using MERS outbreak in Korea, 2014
head(mers_korea_2015[[1]])
head(mers_korea_2015[[2]])

x &lt;- make_epicontacts(linelist = mers_korea_2015$linelist,
                      contacts = mers_korea_2015$contacts,
                      directed = FALSE)

## Not run: 
graph3D(x)
graph3D(x, annot = FALSE)
graph3D(x, node_color = "sex", g_title = "MERS Korea 2014")
graph3D(x, node_color = "sex", annot = c("sex", "age"),
        g_title = "MERS Korea 2014")

## End(Not run)
}
</code></pre>

<hr>
<h2 id='make_epicontacts'>Read linelist and contact data</h2><span id='topic+make_epicontacts'></span><span id='topic+epicontacts'></span>

<h3>Description</h3>

<p>This function reads data stored as data.frame containing linelist (case
information, where each row corresponds to a unique patient), and contacts
between patients. Common identifiers should be used in the two data sources
for matching to be achieved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_epicontacts(
  linelist,
  contacts,
  id = 1L,
  from = 1L,
  to = 2L,
  directed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_epicontacts_+3A_linelist">linelist</code></td>
<td>
<p>a <a href="base.html#topic+data.frame">data.frame</a> with at least one column providing unique
patient identifiers</p>
</td></tr>
<tr><td><code id="make_epicontacts_+3A_contacts">contacts</code></td>
<td>
<p>a <a href="base.html#topic+data.frame">data.frame</a> that needs at least two columns
indicating patients between which cases take place; these need not be
referenced in the linelist</p>
</td></tr>
<tr><td><code id="make_epicontacts_+3A_id">id</code></td>
<td>
<p>an index or name indicating which column in <code>linelist</code>
contains unique identifiers; default is first column in <code>linelist</code>
data frame</p>
</td></tr>
<tr><td><code id="make_epicontacts_+3A_from">from</code></td>
<td>
<p>an index or name indicating which column in <code>contacts</code>
contains the first case of a contact</p>
</td></tr>
<tr><td><code id="make_epicontacts_+3A_to">to</code></td>
<td>
<p>an index or name indicating which column in <code>contacts</code>
contains the second case of a contact</p>
</td></tr>
<tr><td><code id="make_epicontacts_+3A_directed">directed</code></td>
<td>
<p>a logical indicating if contacts are directed or not; default
is <code>FALSE</code> but note that contacts will be indicated as 'from' and
'to' even in non-directed contacts</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An <code>epicontacts</code> object can be created from two components:
</p>

<ul>
<li><p> a linelist provided as a <code>data.frame</code> where columns are
different variables describing cases, and where each row is a different case.
and a contact list.
</p>
</li>
<li><p> a contact list provided as a <code>data.frame</code> where each row contains
unique pairs of contacts with unique features of contact in columns. The line
list and contact list should share an identification scheme for individuals.
</p>
</li></ul>



<h3>Value</h3>

<p>An <code>epicontacts</code> object in list format with three elements:
</p>

<ul>
<li> <p><code>linelist</code>: data.frame of cases with first column 'id'
containing character vector of unique identifiers
</p>
</li>
<li> <p><code>contacts</code>: data.frame of contacts with first two columns named
'from' and 'to' indicating unique pairs of contact between individuals
</p>
</li>
<li> <p><code>directed</code>: indicator as to whether or not the contacts are to be
considered directed or not
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thibaut Jombart (<a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>)
</p>


<h3>References</h3>

<p><a href="https://foodborne.unl.edu/public/role/epidemiologist/lineLists.html">https://foodborne.unl.edu/public/role/epidemiologist/lineLists.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(outbreaks)) {
## make epicontacts object from simulated Ebola data
x &lt;- make_epicontacts(ebola_sim$linelist, ebola_sim$contacts)

## test reordering of columns
linelist &lt;- ebola_sim$linelist[,rev(seq_len(ncol(ebola_sim$linelist)))]
contacts &lt;- ebola_sim$contacts[,rev(seq_len(ncol(ebola_sim$contacts)))]
head(linelist)
head(contacts)

## make object
x &lt;- make_epicontacts(linelist, contacts, id = "case_id",
                       to = "case_id", from = "infector")
head(x$linelist)
head(x$contacts)
}
</code></pre>

<hr>
<h2 id='plot.epicontacts'>Plot epicontacts objects</h2><span id='topic+plot.epicontacts'></span>

<h3>Description</h3>

<p>This function plots <code><a href="#topic+epicontacts">epicontacts</a></code> objects using various
approaches. The default method uses <code><a href="#topic+vis_epicontacts">vis_epicontacts</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epicontacts'
plot(
  x,
  node_color = "id",
  method = c("visNetwork", "graph3D"),
  thin = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.epicontacts_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+epicontacts">epicontacts</a></code> object</p>
</td></tr>
<tr><td><code id="plot.epicontacts_+3A_node_color">node_color</code></td>
<td>
<p>An integer or a character string indicating which attribute column
in the linelist should be used to color the nodes.</p>
</td></tr>
<tr><td><code id="plot.epicontacts_+3A_method">method</code></td>
<td>
<p>A character string indicating the plotting method to be used;
available values are &quot;visNetwork&quot; and &quot;graph3D&quot;; see details.</p>
</td></tr>
<tr><td><code id="plot.epicontacts_+3A_thin">thin</code></td>
<td>
<p>A logical indicating if the data should be thinned with <code><a href="#topic+thin">thin</a></code> so that only cases with contacts should be plotted.</p>
</td></tr>
<tr><td><code id="plot.epicontacts_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the plotting methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is merely a wrapper for other plotting functions in
the package, depending on the value of <code>method</code>:
</p>

<ul>
<li> <p><code>visNetwork</code>: calls the function <code><a href="#topic+vis_epicontacts">vis_epicontacts</a></code>
</p>
</li>
<li> <p><code>graph3D</code>: calls the function <code><a href="#topic+graph3D">graph3D</a></code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thibaut Jombart (<a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vis_epicontacts">vis_epicontacts</a></code>, which uses the package
<code>visNetwork</code>, and <code><a href="#topic+codeawesome">codeawesome</a></code> for icon codes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(outbreaks)) {
## example using MERS outbreak in Korea, 2014
head(mers_korea_2015[[1]])
head(mers_korea_2015[[2]])

x &lt;- make_epicontacts(linelist = mers_korea_2015[[1]],
                      contacts = mers_korea_2015[[2]], directed=TRUE)

## Not run: 
plot(x)
plot(x, "place_infect")
plot(x, "loc_hosp", legend_max = 20, annot = TRUE)
plot(x, "place_infect", node_shape = "sex",
     shapes = c(M = "male", F = "female"))
plot(x, 4)
plot(x, 4, method = "graph3D")

## End(Not run)
}
</code></pre>

<hr>
<h2 id='print.epicontacts'>Print method for epicontacts objects</h2><span id='topic+print.epicontacts'></span>

<h3>Description</h3>

<p>This method prints the content of <code>epicontacts</code> objects, giving a brief
summary of the reported cases and contacts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epicontacts'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.epicontacts_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+epicontacts">epicontacts</a></code> object</p>
</td></tr>
<tr><td><code id="print.epicontacts_+3A_...">...</code></td>
<td>
<p>further parameters to be passed to other methods (currently not used)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thibaut Jombart (<a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>)
</p>

<hr>
<h2 id='print.summary_epicontacts'>Print method for summary_epicontacts objects</h2><span id='topic+print.summary_epicontacts'></span>

<h3>Description</h3>

<p>This method outputs a printed summary of the content of
<code>summary_epicontacts</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary_epicontacts'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary_epicontacts_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+summary_epicontacts">summary_epicontacts</a></code> object</p>
</td></tr>
<tr><td><code id="print.summary_epicontacts_+3A_...">...</code></td>
<td>
<p>further parameters to be passed to other methods (currently not used)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>VP Nagraj (<a href="mailto:vpnagraj@virginia.edu">vpnagraj@virginia.edu</a>)
</p>

<hr>
<h2 id='subset_clusters_by_id'>Subset epicontacts by case-specified clusters</h2><span id='topic+subset_clusters_by_id'></span>

<h3>Description</h3>

<p>This function subsets an <code><a href="#topic+epicontacts">epicontacts</a></code> object by identifying
clusters of cases connected to specified cases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_clusters_by_id(x, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_clusters_by_id_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+epicontacts">epicontacts</a></code> object</p>
</td></tr>
<tr><td><code id="subset_clusters_by_id_+3A_id">id</code></td>
<td>
<p>a character vector of case identifiers; the connected components
attached to these cases will be retained in the output object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+epicontacts">epicontacts</a></code> object whose contact dataframe
corresponds to all clusters containing specified case id.
</p>


<h3>Author(s)</h3>

<p>Nistara Randhawa (<a href="mailto:nrandhawa@ucdavis.edu">nrandhawa@ucdavis.edu</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(outbreaks)) {
## build data
x &lt;- make_epicontacts(ebola_sim$linelist, ebola_sim$contacts,
                       id="case_id", to="case_id", from="infector",
                       directed=TRUE)


id &lt;- "cac51e" ## it can be a vector of id as well


## subset based on cluster to which "cac51e" belongs
x_subset &lt;- subset_clusters_by_id(x, id)

}
</code></pre>

<hr>
<h2 id='subset_clusters_by_size'>Subset clusters from epicontacts object by cluster size</h2><span id='topic+subset_clusters_by_size'></span>

<h3>Description</h3>

<p>This function subsets an <code><a href="#topic+epicontacts">epicontacts</a></code> object based on defined
size(s) of clusters (clusters being groups of connected
individuals/nodes). Subsetting may be done by specifying a particular cluster
size of interest, minimum cluster size, maximum cluster size, or a range
(minimum and maximum) of cluster sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_clusters_by_size(x, cs = NULL, cs_min = NULL, cs_max = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_clusters_by_size_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+epicontacts">epicontacts</a></code> object</p>
</td></tr>
<tr><td><code id="subset_clusters_by_size_+3A_cs">cs</code></td>
<td>
<p>cluster size to be used for subsetting</p>
</td></tr>
<tr><td><code id="subset_clusters_by_size_+3A_cs_min">cs_min</code></td>
<td>
<p>minimum cluster size for subsetting</p>
</td></tr>
<tr><td><code id="subset_clusters_by_size_+3A_cs_max">cs_max</code></td>
<td>
<p>maximum cluster size for subsetting</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code><a href="#topic+epicontacts">epicontacts</a></code> object whose contact dataframe corresponds to
all clusters of specified cluster sizes.
</p>


<h3>Author(s)</h3>

<p>Nistara Randhawa (<a href="mailto:nrandhawa@ucdavis.edu">nrandhawa@ucdavis.edu</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(outbreaks)) {
## build data
x &lt;- make_epicontacts(ebola_sim$linelist, ebola_sim$contacts,
                       id="case_id", to="case_id", from="infector",
                       directed=TRUE)


## subset based on cluster size range
x_subset &lt;- subset_clusters_by_size(x, cs_min = 12, cs_max = 15)


## subset based on single cluster size
x_subset &lt;- subset_clusters_by_size(x, cs = 12)


## subset based on minimum cluster size
x_subset &lt;- subset_clusters_by_size(x, cs_min = 10)


## subset based on maximum cluster size
x_subset &lt;- subset_clusters_by_size(x, cs_max = 9)
}
</code></pre>

<hr>
<h2 id='subset.epicontacts'>Subset an epicontact object by factors</h2><span id='topic+subset.epicontacts'></span>

<h3>Description</h3>

<p>This function subsets an <code><a href="#topic+epicontacts">epicontacts</a></code> object based on node,
edge and/or cluster attributes. Specifying node attributes will return an
<code><a href="#topic+epicontacts">epicontacts</a></code> object containing only individuals with these
given attributes in the linelist. Specifying edge attributes will return
contacts with the attributes provided. Specifying cluster attributes will
return clusters of connected cases, and can be defined by ids (returning
clusters of cases connected to specified cases) or cluster sizes (returning
cluster of a specific, minimum or maximum size).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epicontacts'
subset(
  x,
  node_attribute = NULL,
  edge_attribute = NULL,
  cluster_id = NULL,
  cs = NULL,
  cs_min = NULL,
  cs_max = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.epicontacts_+3A_x">x</code></td>
<td>
<p>an epi_contact object to be subsetted</p>
</td></tr>
<tr><td><code id="subset.epicontacts_+3A_node_attribute">node_attribute</code></td>
<td>
<p>a named list defining the node attribute name and node
attribute value (as a single value or vector of values).  Dates must be
provided as a vector of date objects, defining the range of dates
included in the subset. If only one date is provided, only node
attributes with that date will be returned.</p>
</td></tr>
<tr><td><code id="subset.epicontacts_+3A_edge_attribute">edge_attribute</code></td>
<td>
<p>a named list defining the edge attribute name and edge
attribute value (as a single value or vector of values).  Dates must be
provided as a vector of date objects, defining the range of dates
included in the subset. If only one date is provided, only edge
attributes with that date will be returned.</p>
</td></tr>
<tr><td><code id="subset.epicontacts_+3A_cluster_id">cluster_id</code></td>
<td>
<p>a character vector of case identifiers; the connected
components attached to these cases will be retained in the output object.</p>
</td></tr>
<tr><td><code id="subset.epicontacts_+3A_cs">cs</code></td>
<td>
<p>cluster size to be used for subsetting</p>
</td></tr>
<tr><td><code id="subset.epicontacts_+3A_cs_min">cs_min</code></td>
<td>
<p>minimum cluster size for subsetting</p>
</td></tr>
<tr><td><code id="subset.epicontacts_+3A_cs_max">cs_max</code></td>
<td>
<p>maximum cluster size for subsetting</p>
</td></tr>
<tr><td><code id="subset.epicontacts_+3A_...">...</code></td>
<td>
<p>further arguments passed on to other methods</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Finlay Campbell (<a href="mailto:f.campbell15@imperial.ac.uk">f.campbell15@imperial.ac.uk</a>), Nistara
Randhawa (<a href="mailto:nrandhawa@ucdavis.edu">nrandhawa@ucdavis.edu</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(outbreaks)) {
## build data

x &lt;- make_epicontacts(ebola_sim$linelist, ebola_sim$contacts,
                      id = "case_id", to = "case_id",
                      from = "infector", directed = FALSE)

## subset based on node and edge attributes
x_subset &lt;- subset(x, node_attribute = list("gender" = "f"),
                   edge_attribute = list("source" = "funeral"))


## subset a cluster connected to a given id
## (can be a vector of ids as well)
## here picking node with highest out-degree

id &lt;- names(which.max(get_degree(x, "out")))
x_subset &lt;- thin(subset(x, cluster_id = id), 2)
x_subset
plot(x_subset)


## subset based on cluster size range

x_subset &lt;- subset(x, cs_min = 12, cs_max = 15)


## subset based on single cluster size

x_subset &lt;- subset(x, cs = 12)


## subset based on minimum cluster size

x_subset &lt;- subset(x, cs_min = 10)


## subset based on maximum cluster size

x_subset &lt;- subset(x, cs_max = 9)


}
</code></pre>

<hr>
<h2 id='summary.epicontacts'>Summary method for epicontacts objects</h2><span id='topic+summary.epicontacts'></span><span id='topic+summary_epicontacts'></span>

<h3>Description</h3>

<p>This method outputs a summary of the content of <code>epicontacts</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'epicontacts'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.epicontacts_+3A_object">object</code></td>
<td>
<p>an <code><a href="#topic+epicontacts">epicontacts</a></code> object</p>
</td></tr>
<tr><td><code id="summary.epicontacts_+3A_...">...</code></td>
<td>
<p>further parameters to be passed to other methods (currently not used)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>VP Nagraj (<a href="mailto:vpnagraj@virginia.edu">vpnagraj@virginia.edu</a>)
</p>

<hr>
<h2 id='thin'>Thin data to retain matching linelist / contacts</h2><span id='topic+thin'></span>

<h3>Description</h3>

<p>This function can be used to remove ('thin') data from
<code><a href="#topic+epicontacts">epicontacts</a></code> objects to ensure stricter matching of linelists
and contacts. It has two behaviours, triggered by the argument <code>what</code>:
either it thins data from <code>$linelist</code>, keeping only cases that are in
<code>$contacts</code> (<code>thin = "linelist"</code>, default), or the converse,
i.e. removing contacts which are not fully documented in the linelist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thin(x, what = "linelist")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thin_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+epicontacts">epicontacts</a></code> object.</p>
</td></tr>
<tr><td><code id="thin_+3A_what">what</code></td>
<td>
<p>A character string or integer determining which type of data is
removed ('thinned'). &quot;linelist&quot; / 1 indicates that only cases appearing
in <code>$contacts</code> are kept in <code>$linelist</code>. &quot;contacts / 2&quot;
indicates that only cases appearing in <code>$linelist</code> are kept in
<code>$contacts</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thibaut Jombart (<a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(outbreaks)) {
## build data
x &lt;- make_epicontacts(ebola_sim$linelist, ebola_sim$contacts,
                       id = "case_id", to = "case_id", from = "infector",
                       directed = TRUE)

## keep contacts from a specific case '916d0a'
x &lt;- x[j = "916d0a", contacts = "from"]

}
</code></pre>

<hr>
<h2 id='transp'>Color tools and palettes for epicontacts</h2><span id='topic+transp'></span><span id='topic+edges_pal'></span><span id='topic+cases_pal'></span><span id='topic+spectral'></span><span id='topic+fac2col'></span>

<h3>Description</h3>

<p>These functions are used for defining palettes or colors in the
<code>epicontacts</code> package. They include:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transp(col, alpha = 0.5)

edges_pal(n)

cases_pal(n)

spectral(n)

fac2col(x, pal = cases_pal, NA_col = "lightgrey", legend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transp_+3A_col">col</code></td>
<td>
<p>A color vector to which transparency should be added.</p>
</td></tr>
<tr><td><code id="transp_+3A_alpha">alpha</code></td>
<td>
<p>The threshold to be used for transparency: 0 for full
transparency, and 1 for full opacity.</p>
</td></tr>
<tr><td><code id="transp_+3A_n">n</code></td>
<td>
<p>An integer indicating the number of colors.</p>
</td></tr>
<tr><td><code id="transp_+3A_x">x</code></td>
<td>
<p>A character or a factor to be converted to colors.</p>
</td></tr>
<tr><td><code id="transp_+3A_pal">pal</code></td>
<td>
<p>A color palette.</p>
</td></tr>
<tr><td><code id="transp_+3A_na_col">NA_col</code></td>
<td>
<p>The color to be used for NA values.</p>
</td></tr>
<tr><td><code id="transp_+3A_legend">legend</code></td>
<td>
<p>A logical indicating if legend info should be added to the
output. If TRUE, the output will be a list, with colors in the
<code>$color</code> component.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>cases_pal</code>: discrete color palette used for cases (comes from the
<code>dibbler</code> package)
</p>
</li>
<li> <p><code>spectral</code>: continuous color palette (comes from the
<code>adegenet</code> package)
</p>
</li>
<li> <p><code>transp</code>: makes colors transparent (comes from the
<code>adegenet</code> package)
</p>
</li>
<li> <p><code>fac2col</code>: translates a character or a factor to a color using a
palette (comes from the <code>adegenet</code> package)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Thibaut Jombart <a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
barplot(1:5, col = cases_pal(5))
barplot(1:50, col = cases_pal(50))

</code></pre>

<hr>
<h2 id='vis_epicontacts'>Plot epicontacts objects using visNetwork</h2><span id='topic+vis_epicontacts'></span>

<h3>Description</h3>

<p>This function plots <code><a href="#topic+epicontacts">epicontacts</a></code> objects using the
<code>visNetwork</code> package. The produced object is an <code>htmlwidget</code> which
will need rendering within a web browser.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vis_epicontacts(
  x,
  thin = TRUE,
  node_color = "id",
  label = "id",
  annot = TRUE,
  node_shape = NULL,
  shapes = NULL,
  edge_label = NULL,
  edge_color = NULL,
  legend = TRUE,
  legend_max = 10,
  x_axis = NULL,
  col_pal = cases_pal,
  NA_col = "lightgrey",
  edge_col_pal = edges_pal,
  width = "90%",
  height = "700px",
  selector = TRUE,
  editor = FALSE,
  edge_width = 3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vis_epicontacts_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+epicontacts">epicontacts</a></code> object.</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_thin">thin</code></td>
<td>
<p>A logical indicating if the data should be thinned with <code><a href="#topic+thin">thin</a></code> so that only cases with contacts should be plotted.</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_node_color">node_color</code></td>
<td>
<p>An index or character string indicating which field of the
linelist should be used to color the nodes.</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_label">label</code></td>
<td>
<p>An index, logical, or character string indicating which fields
of the linelist should be used for labelling the nodes. Logical will be
recycled if necessary, so that the default <code>TRUE</code> effectively uses all
columns of the linelist.</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_annot">annot</code></td>
<td>
<p>An index, logical, or character string indicating which fields
of the linelist should be used for annotating the nodes. Logical will be
recycled if necessary, so that the default <code>TRUE</code> effectively uses all
columns of the linelist.</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_node_shape">node_shape</code></td>
<td>
<p>An index or character string indicating which field of the
linelist should be used to determine the shapes of the nodes.</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_shapes">shapes</code></td>
<td>
<p>A named vector of characters indicating which icon code should
be used for each value <code>node_shape</code>, e.g. <code>c(m = "male", f =
"female")</code> if 'm' amd 'f' are values from <code>node_shape</code>. See
<code><a href="#topic+codeawesome">codeawesome</a></code> for all available codes.</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_edge_label">edge_label</code></td>
<td>
<p>An index or character string indicating which field of the
contacts data should be used to label the edges of the graph.</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_edge_color">edge_color</code></td>
<td>
<p>An index or character string indicating which field of the
contacts data should be used to color the edges of the graph.</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_legend">legend</code></td>
<td>
<p>A logical indicating whether a legend should be added to the
plot.</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_legend_max">legend_max</code></td>
<td>
<p>The maximum number of groups for a legend to be displayed.</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_x_axis">x_axis</code></td>
<td>
<p>A character string indicating which field of the linelist data
should be used to specify the x axis position (must be numeric or Date)</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_col_pal">col_pal</code></td>
<td>
<p>A color palette for the nodes.</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_na_col">NA_col</code></td>
<td>
<p>The color used for unknown group.</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_edge_col_pal">edge_col_pal</code></td>
<td>
<p>A color palette for the edges.</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_width">width</code></td>
<td>
<p>The width of the output, in html compatible format (e.g. '90%'
or '800px').</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_height">height</code></td>
<td>
<p>The height of the output, in html compatible format
(e.g. '800px').</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_selector">selector</code></td>
<td>
<p>A logical indicating if the selector tool should be used;
defaults to TRUE.</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_editor">editor</code></td>
<td>
<p>A logical indicating if the editor tool should be used;
defaults to FALSE.</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_edge_width">edge_width</code></td>
<td>
<p>An integer indicating the width of the edges. Defaults to
3.</p>
</td></tr>
<tr><td><code id="vis_epicontacts_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code>visNetwork</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same output as <code>visNetwork</code>.
</p>


<h3>Author(s)</h3>

<p>Thibaut Jombart (<a href="mailto:thibautjombart@gmail.com">thibautjombart@gmail.com</a>)
VP Nagraj (<a href="mailto:vpnagraj@virginia.edu">vpnagraj@virginia.edu</a>)
Zhian N. Kamvar (<a href="mailto:zkamvar@gmail.com">zkamvar@gmail.com</a>)
</p>


<h3>See Also</h3>

<p><code><a href="visNetwork.html#topic+visNetwork">visNetwork</a></code> in the package <code>visNetwork</code>.
<code><a href="#topic+edges_pal">edges_pal</a></code> and <code><a href="#topic+cases_pal">cases_pal</a></code> for color palettes used
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(outbreaks)) {

## example using MERS outbreak in Korea, 2014
head(mers_korea_2015[[1]])
head(mers_korea_2015[[2]])

x &lt;- make_epicontacts(linelist=mers_korea_2015[[1]],
                       contacts = mers_korea_2015[[2]],
                       directed=TRUE)

## Not run: 
plot(x)
plot(x, node_color = "place_infect")
# show transmission tree with time as the horizontal axis, showing all nodes
vis_epicontacts(x, x_axis = "dt_onset", thin = FALSE) 
plot(x, node_color = "loc_hosp", legend_max=20, annot=TRUE)
plot(x, node_color = "loc_hosp", legend_max=20, annot=TRUE, x_axis = "dt_onset")
plot(x, "place_infect", node_shape = "sex",
     shapes = c(M = "male", F = "female"))

plot(x, "sex", node_shape = "sex", shapes = c(F = "female", M = "male"),
     edge_label = "exposure", edge_color = "exposure")

## End(Not run)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
