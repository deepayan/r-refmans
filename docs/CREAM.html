<!DOCTYPE html><html><head><title>Help for package CREAM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CREAM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CREAM'><p>CREAM is the main function for CORE identification</p></a></li>
<li><a href='#ElementRecog'><p>ElementRecog is a function to identify COREs</p></a></li>
<li><a href='#PeakMinFilt'><p>PeakMinFilt is a function to filter the lowest Order of COREs which distance</p>
between functional regions is close to the corresponding Window Size</a></li>
<li><a href='#WindowSizeRecog'><p>WindowSizeRecog is a function to specify window size for each order of COREs</p></a></li>
<li><a href='#WindowVec'><p>WindowVec is a function to specify window size for each order of COREs</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Clustering of Genomic Regions Analysis Method</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2018-05-30</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a new method for identification of clusters of genomic
 regions within chromosomes. Primarily, it is used for calling clusters of 
 cis-regulatory elements (COREs). 'CREAM' uses genome-wide maps of genomic regions
 in the tissue or cell type of interest, such as those generated from chromatin-based 
 assays including DNaseI, ATAC or ChIP-Seq. 'CREAM' considers proximity of the elements 
 within chromosomes of a given sample to identify COREs in the following steps:
 1) It identifies window size or the maximum allowed distance between the elements 
 within each CORE, 2) It identifies number of elements which should be clustered 
 as a CORE, 3) It calls COREs, 4) It filters the COREs with lowest order which 
 does not pass the threshold considered in the approach.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bhklab/CREAM">https://github.com/bhklab/CREAM</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.0.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>biocViews:</td>
<td>PeakDetection, FunctionalPrediction, BiomedicalInformatics,
Clustering</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bhklab/CREAM/issues">https://github.com/bhklab/CREAM/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-06-04 13:45:12 UTC; root</td>
</tr>
<tr>
<td>Author:</td>
<td>Seyed Ali Madani Tonekaboni [aut],
  Victor Kofia [aut],
  Mathieu Lupien [aut],
  Benjamin Haibe-Kains [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benjamin Haibe-Kains &lt;benjamin.haibe.kains@utoronto.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-06-06 09:07:56 UTC</td>
</tr>
</table>
<hr>
<h2 id='CREAM'>CREAM is the main function for CORE identification</h2><span id='topic+CREAM'></span>

<h3>Description</h3>

<p>CREAM is the main function for CORE identification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CREAM(in_path, WScutoff = 1.5, MinLength = 1000, peakNumMin = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CREAM_+3A_in_path">in_path</code></td>
<td>
<p>Path to the input file (The file inclusing the functional
regions)
Note. You have to make sure that there is no overlapping regions within the
input file</p>
</td></tr>
<tr><td><code id="CREAM_+3A_wscutoff">WScutoff</code></td>
<td>
<p>Threshold used to identify WS within distribution of maximum
distance between peaks for each order of CORE</p>
</td></tr>
<tr><td><code id="CREAM_+3A_minlength">MinLength</code></td>
<td>
<p>Criteria for the minimum number of functional regions in the
input file</p>
</td></tr>
<tr><td><code id="CREAM_+3A_peaknummin">peakNumMin</code></td>
<td>
<p>Minimum number of peaks for CORE identification</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Bed file including the identified COREs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>CREAM(system.file("extdata", "A549_Chr21.bed", package = "CREAM"),
MinLength = 1000, peakNumMin = 2)
</code></pre>

<hr>
<h2 id='ElementRecog'>ElementRecog is a function to identify COREs</h2><span id='topic+ElementRecog'></span>

<h3>Description</h3>

<p>ElementRecog is a function to identify COREs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ElementRecog(InputData, windowSize_Vec, peakNumMax, peakNumMin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ElementRecog_+3A_inputdata">InputData</code></td>
<td>
<p>The input data as a table including chromosome regions
in which the first column is chromosome annotation, and second and third
columns are start and ending positions.</p>
</td></tr>
<tr><td><code id="ElementRecog_+3A_windowsize_vec">windowSize_Vec</code></td>
<td>
<p>Vector of window sizes ordered based on order of CORE</p>
</td></tr>
<tr><td><code id="ElementRecog_+3A_peaknummax">peakNumMax</code></td>
<td>
<p>Maximum order of COREs (e.g. maximum number of peaks within COREs)</p>
</td></tr>
<tr><td><code id="ElementRecog_+3A_peaknummin">peakNumMin</code></td>
<td>
<p>Minimum order of COREs (e.g. minimum number of peaks within COREs)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Identified COREs for the given input regions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>InputData &lt;- read.table(system.file("extdata", "A549_Chr21.bed",
package = "CREAM"), sep="\t")
colnames(InputData) &lt;- c("chr", "start", "end")
MinLength &lt;- 1000
if(nrow(InputData) &lt; MinLength){
   stop(paste( "Number of functional regions is less than ", MinLength,
   ".", sep = "", collapse = ""))
}
peakNumMin &lt;- 2
WScutoff &lt;- 1.5
WindowVecFinal &lt;- WindowVec(InputData, peakNumMin, WScutoff)
OutputList &lt;- ElementRecog(InputData, WindowVecFinal,
(1+length(WindowVecFinal)), peakNumMin)
</code></pre>

<hr>
<h2 id='PeakMinFilt'>PeakMinFilt is a function to filter the lowest Order of COREs which distance
between functional regions is close to the corresponding Window Size</h2><span id='topic+PeakMinFilt'></span>

<h3>Description</h3>

<p>PeakMinFilt is a function to filter the lowest Order of COREs which distance
between functional regions is close to the corresponding Window Size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PeakMinFilt(Clusters_init, WindowVecFinal)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PeakMinFilt_+3A_clusters_init">Clusters_init</code></td>
<td>
<p>Table of indetified COREs before filteration</p>
</td></tr>
<tr><td><code id="PeakMinFilt_+3A_windowvecfinal">WindowVecFinal</code></td>
<td>
<p>Vector of window sizes ordered based on order of CORE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Minimum order of COREs
</p>

<hr>
<h2 id='WindowSizeRecog'>WindowSizeRecog is a function to specify window size for each order of COREs</h2><span id='topic+WindowSizeRecog'></span>

<h3>Description</h3>

<p>WindowSizeRecog is a function to specify window size for each order of COREs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WindowSizeRecog(InputData, COREorder, WScutoff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WindowSizeRecog_+3A_inputdata">InputData</code></td>
<td>
<p>The input data as a table including chromosome regions
in which the first column is chromosome annotation, and second and third
columns are start and ending positions.</p>
</td></tr>
<tr><td><code id="WindowSizeRecog_+3A_coreorder">COREorder</code></td>
<td>
<p>Order of the COREs which window size has to be determined for.</p>
</td></tr>
<tr><td><code id="WindowSizeRecog_+3A_wscutoff">WScutoff</code></td>
<td>
<p>Threshold used to identify WS within distribution of maximum distance between peaks for each order of CORE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Window size identified for each order of CORE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>InputData &lt;- read.table(system.file("extdata", "A549_Chr21.bed",
package = "CREAM"), sep="\t")
colnames(InputData) &lt;- c("chr", "start", "end")
MinLength &lt;- 1000
if(nrow(InputData) &lt; MinLength){
   stop(paste( "Number of functional regions is less than ", MinLength,
   ".", sep = "", collapse = ""))
}
peakNumMin &lt;- 2
WScutoff &lt;- 1.5
WindowSize &lt;- WindowSizeRecog(InputData, peakNumMin, WScutoff)
</code></pre>

<hr>
<h2 id='WindowVec'>WindowVec is a function to specify window size for each order of COREs</h2><span id='topic+WindowVec'></span>

<h3>Description</h3>

<p>WindowVec is a function to specify window size for each order of COREs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WindowVec(InputData, peakNumMin, WScutoff)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WindowVec_+3A_inputdata">InputData</code></td>
<td>
<p>The input data as a table including chromosome regions in
which the first column is chromosome annotation,  and second and third
columns are start and ending positions.</p>
</td></tr>
<tr><td><code id="WindowVec_+3A_peaknummin">peakNumMin</code></td>
<td>
<p>Minimum order of COREs</p>
</td></tr>
<tr><td><code id="WindowVec_+3A_wscutoff">WScutoff</code></td>
<td>
<p>Threshold used to identify WS within distribution of maximum distance between peaks for each order of CORE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of window sizes from order 2 up to maximum order of COREs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>InputData &lt;- read.table(system.file("extdata", "A549_Chr21.bed",
package = "CREAM"), sep="\t")
colnames(InputData) &lt;- c("chr", "start", "end")
MinLength &lt;- 1000
if(nrow(InputData) &lt; MinLength){
   stop(paste( "Number of functional regions is less than ", MinLength,
   ".", sep = "", collapse = ""))
}
peakNumMin &lt;- 2
WScutoff &lt;- 1.5
WindowVecFinal &lt;- WindowVec(InputData, peakNumMin, WScutoff)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
