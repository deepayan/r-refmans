<!DOCTYPE html><html lang="en"><head><title>Help for package signnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {signnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_adj_complex'><p>Convert a signed graph to a complex adjacency matrix</p></a></li>
<li><a href='#as_adj_signed'><p>Convert a signed graph to a signed adjacency matrix</p></a></li>
<li><a href='#as_complex_edges'><p>Convert Signed Network to Complex</p></a></li>
<li><a href='#as_incidence_complex'><p>Complex Incidence Matrix</p></a></li>
<li><a href='#as_incidence_signed'><p>Convert a signed two-mode network to a signed matrix</p></a></li>
<li><a href='#as_signed_proj'><p>convert unsigned projection to signed</p></a></li>
<li><a href='#as_unsigned_2mode'><p>convert signed two-mode network to unsigned</p></a></li>
<li><a href='#avatar'><p>Signed networks from Avatar: The Last Airbender</p></a></li>
<li><a href='#balance_score'><p>balancedness of signed network</p></a></li>
<li><a href='#complex_walks'><p>Count Walks in complex signed network</p></a></li>
<li><a href='#count_complex_triangles'><p>count complex triangles</p></a></li>
<li><a href='#count_signed_triangles'><p>count signed triangles</p></a></li>
<li><a href='#cowList'><p>Signed networks from Correlates of War</p></a></li>
<li><a href='#degree_signed'><p>Signed Degree</p></a></li>
<li><a href='#eigen_centrality_signed'><p>Signed Eigenvector centrality</p></a></li>
<li><a href='#frustration_exact'><p>Exact frustration index of a signed network</p></a></li>
<li><a href='#ggblock'><p>Plot Blockmodel matrix</p></a></li>
<li><a href='#ggsigned'><p>Plot a signed or complex network</p></a></li>
<li><a href='#graph_circular_signed'><p>circular signed graph</p></a></li>
<li><a href='#graph_from_adjacency_matrix_signed'><p>Create signed graphs from adjacency matrices</p></a></li>
<li><a href='#graph_from_edgelist_signed'><p>Create a signed graph from an edgelist matrix</p></a></li>
<li><a href='#is_signed'><p>Check if network is a signed network</p></a></li>
<li><a href='#laplacian_matrix_complex'><p>Complex Graph Laplacian</p></a></li>
<li><a href='#laplacian_matrix_signed'><p>Signed Graph Laplacian</p></a></li>
<li><a href='#pn_index'><p>PN Centrality Index</p></a></li>
<li><a href='#sample_bipartite_signed'><p>Bipartite random signed graphs</p></a></li>
<li><a href='#sample_gnp_signed'><p>Generate random signed graphs according to the G(n,p) Erdos-Renyi model</p></a></li>
<li><a href='#sample_islands_signed'><p>A graph with random subgraphs connected by negative edges</p></a></li>
<li><a href='#signed_blockmodel'><p>Blockmodeling for signed networks</p></a></li>
<li><a href='#signed_blockmodel_general'><p>Generalized blockmodeling for signed networks</p></a></li>
<li><a href='#signed_triangles'><p>list signed triangles</p></a></li>
<li><a href='#triad_census_signed'><p>signed triad census</p></a></li>
<li><a href='#tribes'><p>Signed network of New Guinean highland tribes</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Methods to Analyse Signed Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for the analysis of signed networks. This includes
    several measures for structural balance as introduced by Cartwright
    and Harary (1956) &lt;<a href="https://doi.org/10.1037%2Fh0046049">doi:10.1037/h0046049</a>&gt;, blockmodeling algorithms
    from Doreian (2008) &lt;<a href="https://doi.org/10.1016%2Fj.socnet.2008.03.005">doi:10.1016/j.socnet.2008.03.005</a>&gt;, various
    centrality indices, and projections of signed two-mode networks
    introduced by Schoch (2020) &lt;<a href="https://doi.org/10.1080%2F0022250X.2019.1711376">doi:10.1080/0022250X.2019.1711376</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/schochastics/signnet">https://github.com/schochastics/signnet</a>,
<a href="https://schochastics.github.io/signnet/">https://schochastics.github.io/signnet/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/schochastics/signnet/issues">https://github.com/schochastics/signnet/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, Matrix, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, ggplot2, ggraph, knitr, ompr, ompr.roi, rmarkdown, ROI,
ROI.plugin.glpk, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-05 19:38:20 UTC; david</td>
</tr>
<tr>
<td>Author:</td>
<td>David Schoch <a href="https://orcid.org/0000-0003-2952-4812"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Schoch &lt;david@schochastics.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-05 20:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_adj_complex'>Convert a signed graph to a complex adjacency matrix</h2><span id='topic+as_adj_complex'></span>

<h3>Description</h3>

<p>This function returns the adjacency matrix for a signed graph that contains ambivalent ties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_adj_complex(g, attr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_adj_complex_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="as_adj_complex_+3A_attr">attr</code></td>
<td>
<p>edge attribute name that encodes positive (&quot;P&quot;), negative (&quot;N&quot;) and ambivalent (&quot;A&quot;) ties.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>complex adjacency matrix
</p>


<h3>See Also</h3>

<p><a href="#topic+as_adj_signed">as_adj_signed</a>
</p>

<hr>
<h2 id='as_adj_signed'>Convert a signed graph to a signed adjacency matrix</h2><span id='topic+as_adj_signed'></span>

<h3>Description</h3>

<p>This function returns the adjacency matrix for a signed graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_adj_signed(g, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_adj_signed_+3A_g">g</code></td>
<td>
<p>igraph object. Must have a &quot;sign&quot; edge attribute.</p>
</td></tr>
<tr><td><code id="as_adj_signed_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, whether to return the result as a sparse matrix. The Matrix package is required for sparse matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>signed adjacency matrix
</p>


<h3>See Also</h3>

<p><a href="#topic+as_adj_complex">as_adj_complex</a>
</p>

<hr>
<h2 id='as_complex_edges'>Convert Signed Network to Complex</h2><span id='topic+as_complex_edges'></span>

<h3>Description</h3>

<p>Convert Signed Network to Complex
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_complex_edges(g, attr = "type")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_complex_edges_+3A_g">g</code></td>
<td>
<p>igraph object. Must have a &quot;sign&quot; edge attribute.</p>
</td></tr>
<tr><td><code id="as_complex_edges_+3A_attr">attr</code></td>
<td>
<p>new edge attribute name that encodes positive (&quot;P&quot;), negative (&quot;N&quot;) and ambivalent (&quot;A&quot;) ties.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph object
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- sample_islands_signed(2, 10, 1, 10)
as_complex_edges(g)
</code></pre>

<hr>
<h2 id='as_incidence_complex'>Complex Incidence Matrix</h2><span id='topic+as_incidence_complex'></span>

<h3>Description</h3>

<p>The complex incidence matrix of a signed graph containing ambivalent ties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_incidence_complex(g, attr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_incidence_complex_+3A_g">g</code></td>
<td>
<p>igraph object.</p>
</td></tr>
<tr><td><code id="as_incidence_complex_+3A_attr">attr</code></td>
<td>
<p>edge attribute name that encodes positive (&quot;P&quot;), negative (&quot;N&quot;) and ambivalent (&quot;A&quot;) ties.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is slightly different than <a href="igraph.html#topic+as_incidence_matrix">as_incidence_matrix</a> since it is defined for bipartite graphs.
The incidence matrix here is defined as a <code class="reqn">S \in C^{n,m}</code>, where n is the number of vertices and m the number of edges. Edges (i,j) are oriented such that i&lt;j and entries are defined as
</p>
<p style="text-align: center;"><code class="reqn">S_{i(i,j)}=\sqrt{A_{ij}}</code>
</p>

<p style="text-align: center;"><code class="reqn">S_{j(i,j)}=-\sqrt{A_{ji}} if (i,j) is an ambivalent tie</code>
</p>

<p style="text-align: center;"><code class="reqn">S_{j(i,j)}=-A_{ji}\sqrt{A_{ji}} else</code>
</p>



<h3>Value</h3>

<p>a complex matrix
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>See Also</h3>

<p><a href="#topic+laplacian_matrix_complex">laplacian_matrix_complex</a>,<a href="#topic+as_adj_complex">as_adj_complex</a>
</p>

<hr>
<h2 id='as_incidence_signed'>Convert a signed two-mode network to a signed matrix</h2><span id='topic+as_incidence_signed'></span>

<h3>Description</h3>

<p>This function returns the incidence matrix for a signed two-mode network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_incidence_signed(g, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_incidence_signed_+3A_g">g</code></td>
<td>
<p>igraph object (bipartite). Must have a &quot;sign&quot; edge attribute.</p>
</td></tr>
<tr><td><code id="as_incidence_signed_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, whether to return the result as a sparse matrix. The Matrix package is required for sparse matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>signed incidence matrix
</p>

<hr>
<h2 id='as_signed_proj'>convert unsigned projection to signed</h2><span id='topic+as_signed_proj'></span>

<h3>Description</h3>

<p>convert unsigned projection to signed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_signed_proj(g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_signed_proj_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph object
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>See Also</h3>

<p><a href="#topic+as_unsigned_2mode">as_unsigned_2mode</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)

# create a simple signed two mode network
el &lt;- matrix(c(1, "a", 1, "b", 1, "c", 2, "a", 2, "b"), ncol = 2, byrow = TRUE)
g &lt;- graph_from_edgelist(el, directed = FALSE)
E(g)$sign &lt;- c(1, 1, -1, 1, -1)
V(g)$type &lt;- c(FALSE, TRUE, TRUE, TRUE, FALSE)

# convert to unsigned two-mode network and project
l &lt;- as_unsigned_2mode(g, primary = TRUE)
p &lt;- bipartite_projection(l, which = "true")

# turn the unsigned projection back to a signed network
as_signed_proj(p)
</code></pre>

<hr>
<h2 id='as_unsigned_2mode'>convert signed two-mode network to unsigned</h2><span id='topic+as_unsigned_2mode'></span>

<h3>Description</h3>

<p>convert signed two-mode network to unsigned
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_unsigned_2mode(g, primary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_unsigned_2mode_+3A_g">g</code></td>
<td>
<p>igraph object. Two-mode network, must have a &quot;sign&quot; edge attribute.</p>
</td></tr>
<tr><td><code id="as_unsigned_2mode_+3A_primary">primary</code></td>
<td>
<p>logical. Which mode to transform</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph object
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>See Also</h3>

<p><a href="#topic+as_signed_proj">as_signed_proj</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)

# create a simple signed two mode network
el &lt;- matrix(c(1, "a", 1, "b", 1, "c", 2, "a", 2, "b"), ncol = 2, byrow = TRUE)
g &lt;- graph_from_edgelist(el, directed = FALSE)
E(g)$sign &lt;- c(1, 1, -1, 1, -1)
V(g)$type &lt;- c(FALSE, TRUE, TRUE, TRUE, FALSE)

# convert to unsigned two-mode network and project
l &lt;- as_unsigned_2mode(g, primary = TRUE)
p &lt;- bipartite_projection(l, which = "true")

# turn the unsigned projection back to a signed network
as_signed_proj(p)
</code></pre>

<hr>
<h2 id='avatar'>Signed networks from Avatar: The Last Airbender</h2><span id='topic+avatar'></span>

<h3>Description</h3>

<p>Allies/Enemy relations from Avatar: The Last Airbender
</p>


<h3>Usage</h3>

<pre><code class='language-R'>avatar
</code></pre>


<h3>Format</h3>

<p>igraph object
</p>


<h3>Source</h3>

<p>scraped from Avatar Wiki (https://avatar.fandom.com/wiki/Category:Characters)
</p>

<hr>
<h2 id='balance_score'>balancedness of signed network</h2><span id='topic+balance_score'></span>

<h3>Description</h3>

<p>Implements several indices to assess the balancedness of a network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balance_score(g, method = "triangles")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="balance_score_+3A_g">g</code></td>
<td>
<p>igraph object with a sign edge attribute.</p>
</td></tr>
<tr><td><code id="balance_score_+3A_method">method</code></td>
<td>
<p>string indicating the method to be used. See details for options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method parameter can be one of
</p>

<dl>
<dt><em>triangles</em></dt><dd><p>Fraction of balanced triangles. Maximal (=1) if all triangles are balanced.</p>
</dd>
<dt><em>walk</em></dt><dd><p><code class="reqn">\sum exp(\lambda_i) / \sum exp(\mu_i)</code></p>
</dd></dl>
<p> where <code class="reqn">\lambda_i</code> are the eigenvalues of the
signed adjacency matrix and <code class="reqn">\mu_i</code> of the unsigned adjacency matrix. Maximal (=1) if all walks are balanced.
</p>
<dl>
<dt><em>frustration</em></dt><dd><p>The frustration index assumes that the network can be partitioned into two groups, where intra group edges are positive and inter group edges are negative. The index is defined as the sum of intra group negative and inter group positive edges. Note that the problem is NP complete and only an upper bound is returned (based on simulated annealing). Exact methods can be found in the work of Aref. The index is normalized such that it is maximal (=1) if the network is balanced.</p>
</dd>
</dl>



<h3>Value</h3>

<p>numeric balancedness score between 0 and 1
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Estrada, E. (2019). Rethinking structural balance in signed social networks. <em>Discrete Applied Mathematics</em>.
</p>
<p>Samin Aref, Mark C Wilson (2018). Measuring partial balance in signed networks. <em>Journal of Complex Networks</em>, 6(4): 566–595, https://doi.org/10.1093/comnet/cnx044
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- graph.full(4)
E(g)$sign &lt;- c(-1, 1, 1, -1, -1, 1)

balance_score(g, method = "triangles")
balance_score(g, method = "walk")
</code></pre>

<hr>
<h2 id='complex_walks'>Count Walks in complex signed network</h2><span id='topic+complex_walks'></span>

<h3>Description</h3>

<p>Count Walks in complex signed network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complex_walks(g, attr, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="complex_walks_+3A_g">g</code></td>
<td>
<p>igraph object.</p>
</td></tr>
<tr><td><code id="complex_walks_+3A_attr">attr</code></td>
<td>
<p>edge attribute that encodes positive (&quot;P&quot;), negative (&quot;N&quot;) and ambivalent (&quot;A&quot;) ties.</p>
</td></tr>
<tr><td><code id="complex_walks_+3A_k">k</code></td>
<td>
<p>integer. length of walks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph object
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- sample_islands_signed(2, 10, 1, 10)
g &lt;- as_complex_edges(g, attr = "type")
complex_walks(g, attr = "type", k = 3)
</code></pre>

<hr>
<h2 id='count_complex_triangles'>count complex triangles</h2><span id='topic+count_complex_triangles'></span>

<h3>Description</h3>

<p>Counts the number of all possible signed triangles (+++),(++-), (+&ndash;) and (&mdash;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_complex_triangles(g, attr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_complex_triangles_+3A_g">g</code></td>
<td>
<p>igraph object.</p>
</td></tr>
<tr><td><code id="count_complex_triangles_+3A_attr">attr</code></td>
<td>
<p>edge attribute name that encodes positive (&quot;P&quot;), negative (&quot;N&quot;) and ambivalent (&quot;A&quot;) ties.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>counts for all complex triangle types
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>See Also</h3>

<p><a href="#topic+signed_triangles">signed_triangles</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- make_full_graph(4)
E(g)$type &lt;- c("P", "N", "A", "A", "P", "N")
count_complex_triangles(g, attr = "type")
</code></pre>

<hr>
<h2 id='count_signed_triangles'>count signed triangles</h2><span id='topic+count_signed_triangles'></span>

<h3>Description</h3>

<p>Counts the number of all possible signed triangles (+++),(++-), (+&ndash;) and (&mdash;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_signed_triangles(g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="count_signed_triangles_+3A_g">g</code></td>
<td>
<p>igraph object with a sign edge attribute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>counts for all 4 signed triangle types
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>See Also</h3>

<p><a href="#topic+signed_triangles">signed_triangles</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- make_full_graph(4)
E(g)$sign &lt;- c(-1, 1, 1, -1, -1, 1)
count_signed_triangles(g)
</code></pre>

<hr>
<h2 id='cowList'>Signed networks from Correlates of War</h2><span id='topic+cowList'></span>

<h3>Description</h3>

<p>51 signed networks of inter state relations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cowList
</code></pre>


<h3>Format</h3>

<p>List of igraph objects
</p>


<h3>Source</h3>

<p>http://mrvar.fdv.uni-lj.si/pajek/SVG/CoW/default.htm
</p>


<h3>References</h3>

<p>Doreian, P. and Mrvar, A. (2015). &quot;Structural Balance and Signed International Relations&quot;. <em>Journal of Social Structure</em>, 16(2)
</p>

<hr>
<h2 id='degree_signed'>Signed Degree</h2><span id='topic+degree_signed'></span>

<h3>Description</h3>

<p>several options to calculate the signed degree of vertices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>degree_signed(
  g,
  mode = c("all", "in", "out"),
  type = c("pos", "neg", "ratio", "net")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="degree_signed_+3A_g">g</code></td>
<td>
<p>igraph object with a sign edge attribute.</p>
</td></tr>
<tr><td><code id="degree_signed_+3A_mode">mode</code></td>
<td>
<p>character string, “out” for out-degree, “in” for in-degree or “all” for undirected networks.</p>
</td></tr>
<tr><td><code id="degree_signed_+3A_type">type</code></td>
<td>
<p>character string, “pos” or “neg” for counting positive or negative neighbors only,
&quot;ratio&quot; for pos/(pos+neg), or &quot;net&quot; for pos-neg.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>centrality scores as numeric vector.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>

<hr>
<h2 id='eigen_centrality_signed'>Signed Eigenvector centrality</h2><span id='topic+eigen_centrality_signed'></span>

<h3>Description</h3>

<p>returns the eigenvector associated with the dominant eigenvalue from the adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eigen_centrality_signed(g, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eigen_centrality_signed_+3A_g">g</code></td>
<td>
<p>igraph object with a sign edge attribute.</p>
</td></tr>
<tr><td><code id="eigen_centrality_signed_+3A_scale">scale</code></td>
<td>
<p>Logical scalar, whether to scale the result to have a maximum score of one. If no scaling is used then the result vector is the same as returned by <code>eigen()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that, with negative values, the adjacency matrix may not have a dominant eigenvalue.
This means it is not clear which eigenvector should be used. In addition it is possible for the adjacency matrix to have repeated eigenvalues and hence multiple linearly independent eigenvectors. In this case certain centralities can be arbitrarily assigned. The function returns an error if this is the case.
</p>


<h3>Value</h3>

<p>centrality scores as numeric vector.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Bonacich, P. and Lloyd, P. (2004). &quot;Calculating Status with Negative Relations.&quot; <em>Social Networks</em> 26 (4): 331–38.
</p>
<p>Everett, M. and Borgatti, S.P. (2014). &quot;Networks Containing Negative Ties.&quot; <em>Social Networks</em> 38: 111–20.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
data("tribes")
eigen_centrality_signed(tribes)
</code></pre>

<hr>
<h2 id='frustration_exact'>Exact frustration index of a signed network</h2><span id='topic+frustration_exact'></span>

<h3>Description</h3>

<p>Computes the exact frustration index of a signed network using linear programming
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frustration_exact(g, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frustration_exact_+3A_g">g</code></td>
<td>
<p>signed network</p>
</td></tr>
<tr><td><code id="frustration_exact_+3A_...">...</code></td>
<td>
<p>additional parameters for the ompr solver</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The frustration index indicates the minimum number of edges whose removal results in a balance
network. The function needs the following packages to be installed: <code>ompr</code>, <code>ompr.roi</code>,<code>ROI</code>, and <code>ROI.plugin.glpk</code>.
The function Implements the AND model in Aref et al., 2020
</p>


<h3>Value</h3>

<p>list containing the frustration index and the bipartition of nodes
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Aref, Samin, Andrew J. Mason, and Mark C. Wilson. &quot;Computing the line index of balance using linear programming optimisation.&quot;
Optimization problems in graph theory. Springer, Cham, 2018. 65-84.
</p>
<p>Aref, Samin, Andrew J. Mason, and Mark C. Wilson. &quot;A modeling and computational study of the frustration index in signed networks.&quot; Networks 75.1 (2020): 95-110.
</p>

<hr>
<h2 id='ggblock'>Plot Blockmodel matrix</h2><span id='topic+ggblock'></span>

<h3>Description</h3>

<p>Plot Blockmodel matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggblock(
  g,
  blocks = NULL,
  cols = NULL,
  show_blocks = FALSE,
  show_labels = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggblock_+3A_g">g</code></td>
<td>
<p>igraph object with a sign edge attribute.</p>
</td></tr>
<tr><td><code id="ggblock_+3A_blocks">blocks</code></td>
<td>
<p>vector of block membership as obtained, e.g. from <a href="#topic+signed_blockmodel">signed_blockmodel</a></p>
</td></tr>
<tr><td><code id="ggblock_+3A_cols">cols</code></td>
<td>
<p>colors used for negative and positive ties</p>
</td></tr>
<tr><td><code id="ggblock_+3A_show_blocks">show_blocks</code></td>
<td>
<p>logical. Should block borders be displayed? (Default: FALSE)</p>
</td></tr>
<tr><td><code id="ggblock_+3A_show_labels">show_labels</code></td>
<td>
<p>logical. Should node labels be displayed? (Default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(igraph)
data("tribes")
clu &lt;- signed_blockmodel(tribes, k = 3, alpha = 0.5, annealing = TRUE)
ggblock(tribes, clu$membership, show_blocks = TRUE, show_labels = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='ggsigned'>Plot a signed or complex network</h2><span id='topic+ggsigned'></span>

<h3>Description</h3>

<p>Plot a signed or complex network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggsigned(g, type = "signed", attr = NULL, edge_cols = NULL, weights = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggsigned_+3A_g">g</code></td>
<td>
<p>igraph object. Must have a &quot;sign&quot; edge attribute or an attribute containing &quot;P&quot;, &quot;N&quot;, &quot;A&quot;</p>
</td></tr>
<tr><td><code id="ggsigned_+3A_type">type</code></td>
<td>
<p>character string. either &quot;signed&quot; or &quot;complex&quot;</p>
</td></tr>
<tr><td><code id="ggsigned_+3A_attr">attr</code></td>
<td>
<p>character string. edge attribute that containing &quot;P&quot;, &quot;N&quot;, &quot;A&quot; if type=&quot;complex&quot;</p>
</td></tr>
<tr><td><code id="ggsigned_+3A_edge_cols">edge_cols</code></td>
<td>
<p>colors used for negative and positive (and ambivalent) ties</p>
</td></tr>
<tr><td><code id="ggsigned_+3A_weights">weights</code></td>
<td>
<p>logical. If TRUE, weights are computed based on sign. Defaults to FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a very rudimentary visualization of a signed network. If you are fluent in 'ggraph', you can probably cook up something more sophisticated. The function is thus mostly meant to give a quick overview of the network.
</p>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>

<hr>
<h2 id='graph_circular_signed'>circular signed graph</h2><span id='topic+graph_circular_signed'></span>

<h3>Description</h3>

<p>circular graph with positive and negative edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_circular_signed(n, r = 1, pos = 0.1, neg = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_circular_signed_+3A_n">n</code></td>
<td>
<p>number of nodes</p>
</td></tr>
<tr><td><code id="graph_circular_signed_+3A_r">r</code></td>
<td>
<p>radius</p>
</td></tr>
<tr><td><code id="graph_circular_signed_+3A_pos">pos</code></td>
<td>
<p>distance fraction between positive edges</p>
</td></tr>
<tr><td><code id="graph_circular_signed_+3A_neg">neg</code></td>
<td>
<p>distance fraction between negative edges</p>
</td></tr>
</table>


<h3>Value</h3>

<p>igraph graph
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
graph_circular_signed(n = 50)
</code></pre>

<hr>
<h2 id='graph_from_adjacency_matrix_signed'>Create signed graphs from adjacency matrices</h2><span id='topic+graph_from_adjacency_matrix_signed'></span>

<h3>Description</h3>

<p>Create signed graphs from adjacency matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_from_adjacency_matrix_signed(A, mode = "undirected", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_from_adjacency_matrix_signed_+3A_a">A</code></td>
<td>
<p>square adjacency matrix of a signed graph</p>
</td></tr>
<tr><td><code id="graph_from_adjacency_matrix_signed_+3A_mode">mode</code></td>
<td>
<p>Character scalar, specifies how to interpret the supplied matrix.  Possible values are: directed, undirected</p>
</td></tr>
<tr><td><code id="graph_from_adjacency_matrix_signed_+3A_...">...</code></td>
<td>
<p>additional parameters for <code>from_adjacency()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a signed network as igraph object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(0, 1, -1, 1, 0, 1, -1, 1, 0), 3, 3)
graph_from_adjacency_matrix_signed(A)
</code></pre>

<hr>
<h2 id='graph_from_edgelist_signed'>Create a signed graph from an edgelist matrix</h2><span id='topic+graph_from_edgelist_signed'></span>

<h3>Description</h3>

<p>Create a signed graph from an edgelist matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>graph_from_edgelist_signed(el, signs, directed = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_from_edgelist_signed_+3A_el">el</code></td>
<td>
<p>The edgelist, a two column matrix, character or numeric.</p>
</td></tr>
<tr><td><code id="graph_from_edgelist_signed_+3A_signs">signs</code></td>
<td>
<p>vector indicating the sign of edges. Entries must be 1 or -1.</p>
</td></tr>
<tr><td><code id="graph_from_edgelist_signed_+3A_directed">directed</code></td>
<td>
<p>whether to create a directed graph.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a signed network as igraph object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>el &lt;- matrix(c("foo", "bar", "bar", "foobar"), ncol = 2, byrow = TRUE)
signs &lt;- c(-1, 1)
graph_from_edgelist_signed(el, signs)
</code></pre>

<hr>
<h2 id='is_signed'>Check if network is a signed network</h2><span id='topic+is_signed'></span>

<h3>Description</h3>

<p>Check if network is a signed network
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_signed(g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_signed_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical scalar
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- sample_islands_signed(2, 5, 1, 5)
is_signed(g)
</code></pre>

<hr>
<h2 id='laplacian_matrix_complex'>Complex Graph Laplacian</h2><span id='topic+laplacian_matrix_complex'></span>

<h3>Description</h3>

<p>The Laplacian of a signed graph containing ambivalent ties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laplacian_matrix_complex(g, attr, norm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="laplacian_matrix_complex_+3A_g">g</code></td>
<td>
<p>igraph object.</p>
</td></tr>
<tr><td><code id="laplacian_matrix_complex_+3A_attr">attr</code></td>
<td>
<p>edge attribute name that encodes positive (&quot;P&quot;), negative (&quot;N&quot;) and ambivalent (&quot;A&quot;) ties.</p>
</td></tr>
<tr><td><code id="laplacian_matrix_complex_+3A_norm">norm</code></td>
<td>
<p>Whether to calculate the normalized Laplacian. See definitions below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="igraph.html#topic+laplacian_matrix">laplacian_matrix</a> of igraph for more details. In the complex case, D is a diagonal matrix containing the absolute values of row sums of the complex adjacency matrix.
</p>


<h3>Value</h3>

<p>a complex matrix
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>See Also</h3>

<p><a href="#topic+laplacian_matrix_signed">laplacian_matrix_signed</a>
</p>

<hr>
<h2 id='laplacian_matrix_signed'>Signed Graph Laplacian</h2><span id='topic+laplacian_matrix_signed'></span>

<h3>Description</h3>

<p>The Laplacian of a signed graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>laplacian_matrix_signed(g, norm = FALSE, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="laplacian_matrix_signed_+3A_g">g</code></td>
<td>
<p>igraph object with a sign edge attribute.</p>
</td></tr>
<tr><td><code id="laplacian_matrix_signed_+3A_norm">norm</code></td>
<td>
<p>Whether to calculate the normalized Laplacian. See definitions below.</p>
</td></tr>
<tr><td><code id="laplacian_matrix_signed_+3A_sparse">sparse</code></td>
<td>
<p>Logical scalar, whether to return the result as a sparse matrix. The Matrix package is required for sparse matrices.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="igraph.html#topic+laplacian_matrix">laplacian_matrix</a> of igraph for more details. In the signed case, D is a diagonal matrix containing the absolute values of row sums of the signed adjacency matrix.
</p>


<h3>Value</h3>

<p>a numeric matrix
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- sample_islands_signed(3, 10, 5 / 10, 1)
laplacian_matrix_signed(g)
laplacian_matrix_signed(g, norm = TRUE)
</code></pre>

<hr>
<h2 id='pn_index'>PN Centrality Index</h2><span id='topic+pn_index'></span>

<h3>Description</h3>

<p>centrality index for signed networks by Everett and Borgatti
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pn_index(g, mode = c("all", "in", "out"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pn_index_+3A_g">g</code></td>
<td>
<p>igraph object with a sign edge attribute.</p>
</td></tr>
<tr><td><code id="pn_index_+3A_mode">mode</code></td>
<td>
<p>character string, “out” for out-pn, “in” for in-pn or “all” for undirected networks.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>centrality scores as numeric vector.
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Everett, M. and Borgatti, S. (2014) Networks containing negative ties. <em>Social Networks</em> 38 111-120
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- matrix(c(
    0, 1, 0, 1, 0, 0, 0, -1, -1, 0,
    1, 0, 1, -1, 1, -1, -1, 0, 0, 0,
    0, 1, 0, 1, -1, 0, 0, 0, -1, 0,
    1, -1, 1, 0, 1, -1, -1, 0, 0, 0,
    0, 1, -1, 1, 0, 1, 0, -1, 0, -1,
    0, -1, 0, -1, 1, 0, 1, 0, 1, -1,
    0, -1, 0, -1, 0, 1, 0, 1, -1, 1,
    -1, 0, 0, 0, -1, 0, 1, 0, 1, 0,
    -1, 0, -1, 0, 0, 1, -1, 1, 0, 1,
    0, 0, 0, 0, -1, -1, 1, 0, 1, 0
), 10, 10)
g &lt;- graph_from_adjacency_matrix_signed(A,"undirected")
pn_index(g)
</code></pre>

<hr>
<h2 id='sample_bipartite_signed'>Bipartite random signed graphs</h2><span id='topic+sample_bipartite_signed'></span>

<h3>Description</h3>

<p>Bipartite random signed graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_bipartite_signed(
  n1,
  n2,
  p,
  p_neg,
  directed = FALSE,
  mode = c("out", "in", "all")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_bipartite_signed_+3A_n1">n1</code></td>
<td>
<p>Integer scalar, the number of bottom vertices.</p>
</td></tr>
<tr><td><code id="sample_bipartite_signed_+3A_n2">n2</code></td>
<td>
<p>Integer scalar, the number of top vertices.</p>
</td></tr>
<tr><td><code id="sample_bipartite_signed_+3A_p">p</code></td>
<td>
<p>The probability for drawing an edge between two arbitrary vertices.</p>
</td></tr>
<tr><td><code id="sample_bipartite_signed_+3A_p_neg">p_neg</code></td>
<td>
<p>The probability of a drawn edge to be a negative tie</p>
</td></tr>
<tr><td><code id="sample_bipartite_signed_+3A_directed">directed</code></td>
<td>
<p>logical, whether the graph will be directed. defaults to FALSE.</p>
</td></tr>
<tr><td><code id="sample_bipartite_signed_+3A_mode">mode</code></td>
<td>
<p>Character scalar, specifies how to direct the edges in directed graphs. If it is ‘out’, then directed edges point from bottom vertices to top vertices. If it is ‘in’, edges point from top vertices to bottom vertices. ‘out’ and ‘in’ do not generate mutual edges. If this argument is ‘all’, then each edge direction is considered independently and mutual edges might be generated. This argument is ignored for undirected graphs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A signed bipartite igraph graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_bipartite_signed(10, 10, 0.5, 0.5)
</code></pre>

<hr>
<h2 id='sample_gnp_signed'>Generate random signed graphs according to the G(n,p) Erdos-Renyi model</h2><span id='topic+sample_gnp_signed'></span>

<h3>Description</h3>

<p>Generate random signed graphs according to the G(n,p) Erdos-Renyi model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_gnp_signed(n, p, p_neg, directed = FALSE, loops = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_gnp_signed_+3A_n">n</code></td>
<td>
<p>The number of vertices in the graph.</p>
</td></tr>
<tr><td><code id="sample_gnp_signed_+3A_p">p</code></td>
<td>
<p>The probability for drawing an edge between two arbitrary vertices.</p>
</td></tr>
<tr><td><code id="sample_gnp_signed_+3A_p_neg">p_neg</code></td>
<td>
<p>The probability of a drawn edge to be a negative tie</p>
</td></tr>
<tr><td><code id="sample_gnp_signed_+3A_directed">directed</code></td>
<td>
<p>logical, whether the graph will be directed. defaults to FALSE.</p>
</td></tr>
<tr><td><code id="sample_gnp_signed_+3A_loops">loops</code></td>
<td>
<p>logical, whether to add loop edges, defaults to FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a signed igraph graph object
</p>


<h3>References</h3>

<p>Erdos, P. and Renyi, A., On random graphs, <em>Publicationes Mathematicae 6</em>, 290–297 (1959).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample_gnp_signed(10, 0.4, 0.5)
</code></pre>

<hr>
<h2 id='sample_islands_signed'>A graph with random subgraphs connected by negative edges</h2><span id='topic+sample_islands_signed'></span>

<h3>Description</h3>

<p>Create a number of Erdos-Renyi random graphs with identical parameters, and connect them with the specified number of negative ties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_islands_signed(islands.n, islands.size, islands.pin, n.inter)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sample_islands_signed_+3A_islands.n">islands.n</code></td>
<td>
<p>The number of islands in the graph.</p>
</td></tr>
<tr><td><code id="sample_islands_signed_+3A_islands.size">islands.size</code></td>
<td>
<p>The size of the islands in the graph.</p>
</td></tr>
<tr><td><code id="sample_islands_signed_+3A_islands.pin">islands.pin</code></td>
<td>
<p>The probability of intra-island edges.</p>
</td></tr>
<tr><td><code id="sample_islands_signed_+3A_n.inter">n.inter</code></td>
<td>
<p>number of negative edges between two islands.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a signed igraph graph
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
sample_islands_signed(3, 10, 0.5, 1)
</code></pre>

<hr>
<h2 id='signed_blockmodel'>Blockmodeling for signed networks</h2><span id='topic+signed_blockmodel'></span>

<h3>Description</h3>

<p>Finds blocks of nodes with intra-positive and inter-negative edges
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signed_blockmodel(g, k, alpha = 0.5, annealing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="signed_blockmodel_+3A_g">g</code></td>
<td>
<p>igraph object with a sign edge attribute.</p>
</td></tr>
<tr><td><code id="signed_blockmodel_+3A_k">k</code></td>
<td>
<p>number of blocks</p>
</td></tr>
<tr><td><code id="signed_blockmodel_+3A_alpha">alpha</code></td>
<td>
<p>see details</p>
</td></tr>
<tr><td><code id="signed_blockmodel_+3A_annealing">annealing</code></td>
<td>
<p>logical. if TRUE, use simulated annealing (Default: FALSE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function minimizes P(C)=<code class="reqn">\alpha</code>N+(1-<code class="reqn">\alpha</code>)P,
where N is the total number of negative ties within plus-sets and P be the total number of
positive ties between plus-sets. This function implements the structural balance model. That is,
all diagonal blocks are positive and off-diagonal blocks negative.
For the generalized version see <a href="#topic+signed_blockmodel_general">signed_blockmodel_general</a>.
</p>


<h3>Value</h3>

<p>numeric vector of block assignments and the associated criterion value
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Doreian, Patrick and Andrej Mrvar (2009). Partitioning signed social networks. <em>Social Networks</em> 31(1) 1-11
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)

g &lt;- sample_islands_signed(10, 10, 1, 20)
clu &lt;- signed_blockmodel(g, k = 10, alpha = 0.5)
table(clu$membership)
clu$criterion

# Using simulated annealing (less change of getting trapped in local optima)
data("tribes")
clu &lt;- signed_blockmodel(tribes, k = 3, alpha = 0.5, annealing = TRUE)
table(clu$membership)
clu$criterion
</code></pre>

<hr>
<h2 id='signed_blockmodel_general'>Generalized blockmodeling for signed networks</h2><span id='topic+signed_blockmodel_general'></span>

<h3>Description</h3>

<p>Finds blocks of nodes with specified inter/intra group ties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signed_blockmodel_general(g, blockmat, alpha = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="signed_blockmodel_general_+3A_g">g</code></td>
<td>
<p>igraph object with a sign edge attribute.</p>
</td></tr>
<tr><td><code id="signed_blockmodel_general_+3A_blockmat">blockmat</code></td>
<td>
<p>Integer Matrix. Specifies the inter/intra group patterns of ties</p>
</td></tr>
<tr><td><code id="signed_blockmodel_general_+3A_alpha">alpha</code></td>
<td>
<p>see details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function minimizes P(C)=<code class="reqn">\alpha</code>N+(1-<code class="reqn">\alpha</code>)P,
where N is the total number of negative ties within plus-sets and P be the total number of
positive ties between plus-sets. This function implements the generalized model. For the structural balance
version see <a href="#topic+signed_blockmodel">signed_blockmodel</a>.
</p>


<h3>Value</h3>

<p>numeric vector of block assignments and the associated criterion value
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Doreian, Patrick and Andrej Mrvar (2009). Partitioning signed social networks. <em>Social Networks</em> 31(1) 1-11
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
# create a signed network with three groups and different inter/intra group ties
g1 &lt;- g2 &lt;- g3 &lt;- make_full_graph(5)

V(g1)$name &lt;- as.character(1:5)
V(g2)$name &lt;- as.character(6:10)
V(g3)$name &lt;- as.character(11:15)

g &lt;- Reduce("%u%", list(g1, g2, g3))
E(g)$sign &lt;- 1
E(g)$sign[1:10] &lt;- -1
g &lt;- add_edges(g, c(rbind(1:5, 6:10)), attr = list(sign = -1))
g &lt;- add_edges(g, c(rbind(1:5, 11:15)), attr = list(sign = -1))
g &lt;- add_edges(g, c(rbind(11:15, 6:10)), attr = list(sign = 1))

# specify the link patterns between groups
blockmat &lt;- matrix(c(1, -1, -1, -1, 1, 1, -1, 1, -1), 3, 3, byrow = TRUE)
signed_blockmodel_general(g, blockmat, 0.5)
</code></pre>

<hr>
<h2 id='signed_triangles'>list signed triangles</h2><span id='topic+signed_triangles'></span>

<h3>Description</h3>

<p>lists all possible signed triangles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signed_triangles(g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="signed_triangles_+3A_g">g</code></td>
<td>
<p>igraph object with a sign edge attribute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of vertex ids and the number of positive ties per triangle
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>See Also</h3>

<p><a href="#topic+count_signed_triangles">count_signed_triangles</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- make_full_graph(4)
E(g)$sign &lt;- c(-1, 1, 1, -1, -1, 1)
signed_triangles(g)
</code></pre>

<hr>
<h2 id='triad_census_signed'>signed triad census</h2><span id='topic+triad_census_signed'></span>

<h3>Description</h3>

<p>triad census for signed graphs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>triad_census_signed(g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="triad_census_signed_+3A_g">g</code></td>
<td>
<p>igraph object with a sign edge attribute.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>counts for all 139 signed directed triangle types
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- make_full_graph(4, directed = TRUE)
E(g)$sign &lt;- rep(c(-1, 1, 1, -1, -1, 1), 2)
triad_census_signed(g)
</code></pre>

<hr>
<h2 id='tribes'>Signed network of New Guinean highland tribes</h2><span id='topic+tribes'></span>

<h3>Description</h3>

<p>Signed social network of tribes of the Gahuku–Gama alliance structure of the Eastern Central Highlands of New Guinea, from Kenneth Read.
The network contains sixteen tribes connected by friendship (&quot;rova&quot;) and enmity (&quot;hina&quot;).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tribes
</code></pre>


<h3>Format</h3>

<p>An igraph object
</p>


<h3>Source</h3>

<p>http://vlado.fmf.uni-lj.si/pub/networks/data/ucinet/gama.dat
</p>


<h3>References</h3>

<p>Read, K. E. (1954) Cultures of the central highlands, New Guinea. <em>Southwestern Journal of Anthropology</em>, 1–43.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
