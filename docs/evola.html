<!DOCTYPE html><html lang="en"><head><title>Help for package evola</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {evola}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#A.mat'>
<p>Additive relationship matrix</p></a></li>
<li><a href='#bestSol'>
<p>Extract the index of the best solution</p></a></li>
<li><a href='#DT_cpdata'>
<p>Genotypic and Phenotypic data for a CP population</p></a></li>
<li><a href='#DT_technow'>
<p>Genotypic and Phenotypic data from single cross hybrids (Technow et al.,2014)</p></a></li>
<li><a href='#DT_wheat'><p>wheat lines dataset</p></a></li>
<li><a href='#evola-package'>
<p><strong>EVOL</strong>utionary <strong>A</strong>lgorithm</p>
<br />
</p></a></li>
<li><a href='#evolafit'>
<p>Fits a genetic algorithm for a set of traits and constraints.</p></a></li>
<li><a href='#fitnessf'>
<p>Fitness function from contribution theory</p></a></li>
<li><a href='#Jc'>
<p>Matrix of ones</p></a></li>
<li><a href='#Jr'>
<p>Matrix of ones</p></a></li>
<li><a href='#overlay'><p>Overlay Matrix</p></a></li>
<li><a href='#pareto'><p>plot the change of values across iterations</p></a></li>
<li><a href='#pmonitor'><p>plot the change of values across iterations</p></a></li>
<li><a href='#stan'>
<p>Standardize a vector of values in range 0 to 1</p></a></li>
<li><a href='#varM'>
<p>Extract the variance existing in the genome solutions</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-01</td>
</tr>
<tr>
<td>Title:</td>
<td>Evolutionary Algorithm</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giovanny Covarrubias-Pazaran &lt;cova_ruber@live.com.mx&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Runs a genetic algorithm using the 'AlphaSimR' machinery &lt;<a href="https://doi.org/10.1093%2Fg3journal%2Fjkaa017">doi:10.1093/g3journal/jkaa017</a>&gt; and the coalescent simulator 'MaCS' &lt;<a href="https://doi.org/10.1101%2Fgr.083634.108">doi:10.1101/gr.083634.108</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 3.5.0), AlphaSimR (&ge; 1.4.2), Matrix (&ge; 1.0), methods,
crayon</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Giovanny Covarrubias-Pazaran
    <a href="https://orcid.org/0000-0002-7194-3837"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmarkdown, knitr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-18 21:53:37 UTC; giovannycovarrubias</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-18 22:20:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='A.mat'>
Additive relationship matrix
</h2><span id='topic+A.mat'></span>

<h3>Description</h3>

<p>Calculates the realized additive relationship matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A.mat(X,min.MAF=NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A.mat_+3A_x">X</code></td>
<td>

<p>Matrix (<code class="reqn">n \times m</code>) of unphased genotypes for <code class="reqn">n</code> lines and <code class="reqn">m</code> biallelic markers, 
coded as {-1,0,1}. Fractional (imputed) and missing values (NA) are allowed.
</p>
</td></tr>
<tr><td><code id="A.mat_+3A_min.maf">min.MAF</code></td>
<td>

<p>Minimum minor allele frequency. The A matrix is not sensitive to rare alleles, so by default only monomorphic markers are removed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For vanraden method: the marker matrix is centered by subtracting column means <code class="reqn">M= X - ms</code> where ms is the coumn means. Then <code class="reqn">A=M M'/c</code>, where <code class="reqn">c = \sum_k{d_k}/k</code>, the mean value of the diagonal values of the <code class="reqn">M M'</code> portion.
</p>


<h3>Value</h3>

<p>If return.imputed = FALSE, the <code class="reqn">n \times n</code> additive relationship matrix is returned.
</p>
<p>If return.imputed = TRUE, the function returns a list containing
</p>

<dl>
<dt>$A</dt><dd><p>the A matrix</p>
</dd>
</dl>



<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  evola: a simple evolutionary algorithm for complex problems. To be submitted to Bioinformatics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evolafit">evolafit</a></code> &ndash; the core function of the package </p>


<h3>Examples</h3>

<pre><code class='language-R'>
## random population of 200 lines with 1000 markers
X &lt;- matrix(rep(0,200*1000),200,1000)
for (i in 1:200) {
  X[i,] &lt;- ifelse(runif(1000)&lt;0.5,-1,1)
}

A &lt;- A.mat(X)

 
## take a look at the Genomic relationship matrix 
 colfunc &lt;- colorRampPalette(c("steelblue4","springgreen","yellow"))
 hv &lt;- heatmap(A[1:15,1:15], col = colfunc(100),Colv = "Rowv")
 str(hv)
 

</code></pre>

<hr>
<h2 id='bestSol'>
Extract the index of the best solution
</h2><span id='topic+bestSol'></span>

<h3>Description</h3>

<p>Extracts the index of the best solution for all traits under the constraints specified. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestSol(object, selectTop=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bestSol_+3A_object">object</code></td>
<td>

<p>A resulting object from the function evolafit.
</p>
</td></tr>
<tr><td><code id="bestSol_+3A_selecttop">selectTop</code></td>
<td>

<p>Selects highest values for the fitness value if TRUE. Selects lowest values if FALSE.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple apply function looking at the fitness value of all the solution in the last generation to find the maximum value.
</p>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p>the vector of best solutions in M for each trait in the problem</p>
</dd>
</dl>



<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  evola: a simple evolutionary algorithm for complex problems. To be submitted to Bioinformatics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evolafit">evolafit</a></code> &ndash; the core function of the package </p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(1)
# Data
Gems &lt;- data.frame(
  Color = c("Red", "Blue", "Purple", "Orange",
            "Green", "Pink", "White", "Black", 
            "Yellow"),
  Weight = round(runif(9,0.5,5),2),
  Value = round(abs(rnorm(9,0,5))+0.5,2),
  Times=c(rep(1,8),0)
)
head(Gems)

 
# Task: Gem selection. 
# Aim: Get highest combined value.
# Restriction: Max weight of the gem combined = 10. 
res0&lt;-evolafit(cbind(Weight,Value)~Color, dt= Gems,
               # constraints: if greater than this ignore
               constraintsUB = c(10,Inf), 
               # constraints: if smaller than this ignore
               constraintsLB= c(-Inf,-Inf), 
               # weight the traits for the selection
               traitWeight = c(0,1), 
               # population parameters
               nCrosses = 100, nProgeny = 20, recombGens = 1, 
               # coancestry parameters
               A=NULL, lambda=c(0,0), nQTLperInd = 1, 
               # selection parameters
               propSelBetween = .9, propSelWithin =0.9, 
               nGenerations = 50
) 

bestSol(res0)


</code></pre>

<hr>
<h2 id='DT_cpdata'>
Genotypic and Phenotypic data for a CP population
</h2><span id='topic+DT_cpdata'></span><span id='topic+A'></span>

<h3>Description</h3>

<p>A CP population or F1 cross is the designation for a cross between 2 highly heterozygote individuals; i.e. humans, fruit crops, bredding populations in recurrent selection.
</p>
<p>This dataset contains phenotpic data for 363 siblings for an F1 cross. These are averages over 2 environments evaluated for 4 traits; color, yield, fruit average weight, and firmness. The columns in the CPgeno file are the markers whereas the rows are the individuals. The CPpheno data frame contains the measurements for the 363 siblings, and as mentioned before are averages over 2 environments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_cpdata")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_cpdata&quot;
</p>


<h3>Source</h3>

<p>This data was simulated for fruit breeding applications.
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  evola: a simple evolutionary algorithm for complex problems. To be submitted to Bioinformatics.
</p>
<p>Gaynor, R. Chris, Gregor Gorjanc, and John M. Hickey. 2021. AlphaSimR: an R package for breeding program simulations. G3 Gene|Genomes|Genetics 11(2):jkaa017. https://doi.org/10.1093/g3journal/jkaa017.
</p>
<p>Chen GK, Marjoram P, Wall JD (2009). Fast and Flexible Simulation of DNA Sequence Data. Genome Research, 19, 136-142. http://genome.cshlp.org/content/19/1/136.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_cpdata)
DT &lt;- DT_cpdata


# get best 20 individuals weighting variance by ~0.5=(30*pi)/180
res&lt;-evolafit(formula=cbind(Yield, occ)~id, dt= DT, 
              # constraints: if sum is greater than this ignore 
              constraintsUB = c(Inf,20), 
              # constraints: if sum is smaller than this ignore
              constraintsLB= c(-Inf,-Inf), 
              # weight the traits for the selection
              traitWeight = c(1,0), 
              # population parameters
              nCrosses = 100, nProgeny = 10, 
              recombGens=1, nChr=1, mutRate=0,
              # coancestry parameters
              A=A, lambda= (30*pi)/180 , nQTLperInd = 2, 
              # selection parameters
              propSelBetween = 0.5, propSelWithin =0.5, 
              nGenerations = 40, keepBest=FALSE) 

best = bestSol(res)["pop","Yield"];best
xa = (res$M %*% DT$Yield)[best,]; xa 
xAx = res$M[best,] %*% A %*% res$M[best,]; xAx 
sum(res$M[best,]) # total # of inds selected

pmonitor(res)

plot(DT$Yield, col=as.factor(res$M[best,]), 
     pch=(res$M[best,]*19)+1)

pareto(res)
 


</code></pre>

<hr>
<h2 id='DT_technow'>
Genotypic and Phenotypic data from single cross hybrids (Technow et al.,2014)
</h2><span id='topic+DT_technow'></span><span id='topic+M_technow'></span>

<h3>Description</h3>

<p>This dataset contains phenotpic data for 2 traits measured in 1254 single cross hybrids coming from the cross of Flint x Dent heterotic groups. In addition contains the genotipic data (35,478 markers) for each of the 123 Dent lines and 86 Flint lines. The purpose of this data is to demosntrate the prediction of unrealized crosses (9324 unrealized crosses, 1254 evaluated, total 10578 single crosses). We have added the additive relationship matrix (A) but can be easily obtained using the A.mat function on the marker data. Please if using this data for your own research cite Technow et al. (2014) publication (see References).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("DT_technow")</code></pre>


<h3>Format</h3>

<p>The format is:
chr &quot;DT_technow&quot;
</p>


<h3>Source</h3>

<p>This data was extracted from Technow et al. (2014).
</p>


<h3>References</h3>

<p>If using this data for your own research please cite:
</p>
<p>Technow et al. 2014. Genome properties and prospects of genomic predictions of hybrid performance in a Breeding program of maize. Genetics 197:1343-1355.
</p>
<p>Giovanny Covarrubias-Pazaran (2024).  evola: a simple evolutionary algorithm for complex problems. To be submitted to Bioinformatics.
</p>
<p>Gaynor, R. Chris, Gregor Gorjanc, and John M. Hickey. 2021. AlphaSimR: an R package for breeding program simulations. G3 Gene|Genomes|Genetics 11(2):jkaa017. https://doi.org/10.1093/g3journal/jkaa017.
</p>
<p>Chen GK, Marjoram P, Wall JD (2009). Fast and Flexible Simulation of DNA Sequence Data. Genome Research, 19, 136-142. http://genome.cshlp.org/content/19/1/136.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(DT_technow)
DT &lt;- DT_technow
DT$occ &lt;- 1; DT$occ[1]=0
M &lt;- M_technow


  A &lt;- A.mat(M)
  # run the genetic algorithm
  # we assig a weight to x'Ax of (20*pi)/180=0.34
  res&lt;-evolafit(formula = c(GY, occ)~hy,
                dt= DT, 
                # constraints: if sum is greater than this ignore
                constraintsUB = c(Inf,100), 
                # constraints: if sum is smaller than this ignore
                constraintsLB= c(-Inf,-Inf),
                # weight the traits for the selection
                traitWeight = c(1,0), 
                # population parameters
                nCrosses = 100, nProgeny = 10, 
                recombGens=1, nChr=1, mutRate=0,
                # coancestry parameters
                A=A, lambda= (20*pi)/180 , nQTLperInd = 70, 
                # selection parameters
                propSelBetween = 0.5, propSelWithin =0.5, 
                nGenerations = 20, keepBest=FALSE) 
  
  best = bestSol(res)["pop","GY"]
  xa = (res$M %*% DT$GY)[best,]; xa 
  xAx = res$M[best,] %*% A %*% res$M[best,]; xAx 
  sum(res$M[best,]) # total # of inds selected
  
  pmonitor(res)
  plot(DT$GY, col=as.factor(res$M[best,]), 
       pch=(res$M[best,]*19)+1)
       
  pareto(res)




</code></pre>

<hr>
<h2 id='DT_wheat'>wheat lines dataset</h2><span id='topic+DT_wheat'></span><span id='topic+GT_wheat'></span><span id='topic+A_wheat'></span>

<h3>Description</h3>

<p>Information from a collection of 599 historical CIMMYT wheat lines.  The wheat data set is from 
CIMMYT's Global Wheat Program. Historically, this program has conducted numerous international 
trials across a wide variety of wheat-producing environments. The environments represented in 
these trials were grouped into four basic target sets of environments comprising four 
main agroclimatic regions previously defined and widely used by CIMMYT's Global Wheat Breeding Program. 
The phenotypic trait considered here was the average grain yield (GY) of the 599 wheat lines evaluated 
in each of these four mega-environments. 
</p>
<p>A pedigree tracing back many generations was available, and the Browse application of 
the International Crop Information System (ICIS), as described in  (McLaren <em>et al.</em> 2000, 2005) was used 
for deriving the relationship matrix A among the 599 lines; it accounts for selection and inbreeding.
</p>
<p>Wheat lines were recently genotyped using 1447 Diversity Array Technology (DArT) generated by 
Triticarte Pty. Ltd. (Canberra, Australia; http://www.triticarte.com.au). The DArT markers 
may take on two values, denoted by their presence or absence. Markers with a minor allele frequency 
lower than 0.05 were removed, and missing genotypes were imputed with samples from the marginal 
distribution of marker genotypes, that is, <code class="reqn">x_{ij}=Bernoulli(\hat p_j)</code>, where  <code class="reqn">\hat p_j</code>  
is the estimated allele frequency computed from the non-missing genotypes. The number of DArT 
MMs after edition was 1279.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  data(DT_wheat)
</code></pre>


<h3>Format</h3>

<p>Matrix Y contains the average grain yield, column 1: Grain yield for environment 1 and so on. 
</p>


<h3>Source</h3>

<p>International Maize and Wheat Improvement Center (CIMMYT), Mexico.
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  evola: a simple evolutionary algorithm for complex problems. To be submitted to Bioinformatics.
</p>
<p>Gaynor, R. Chris, Gregor Gorjanc, and John M. Hickey. 2021. AlphaSimR: an R package for breeding program simulations. G3 Gene|Genomes|Genetics 11(2):jkaa017. https://doi.org/10.1093/g3journal/jkaa017.
</p>
<p>Chen GK, Marjoram P, Wall JD (2009). Fast and Flexible Simulation of DNA Sequence Data. Genome Research, 19, 136-142. http://genome.cshlp.org/content/19/1/136.
</p>
<p>McLaren, C. G., L. Ramos, C. Lopez, and W. Eusebio. 2000. &ldquo;Applications of the geneaology manegment system.&rdquo; 
In <em>International Crop Information System. Technical  Development Manual, version VI</em>, edited by McLaren, C. G., J.W. White 
and P.N. Fox. pp. 5.8-5.13. CIMMyT, Mexico: CIMMyT and IRRI. 
</p>
<p>McLaren, C. G., R. Bruskiewich, A.M. Portugal, and A.B. Cosico. 2005. The International Rice Information System. 
A platform for meta-analysis of rice crop data. <em>Plant Physiology</em> <b>139</b>: 637-642.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# example to optimize a training pop for a validation pop
data(DT_wheat)
DT &lt;- as.data.frame(DT_wheat)
DT$id &lt;- rownames(DT) # IDs
DT$occ &lt;- 1; DT$occ[1]=0 # to track occurrences
DT$dummy &lt;- 1; DT$dummy[1]=0 # dummy trait

# if genomic
GT &lt;- GT_wheat + 1; rownames(GT) &lt;- rownames(DT)
G &lt;-  GT%*%t(GT)
G &lt;- G/mean(diag(G))
# if pedigree
A &lt;- A_wheat
A[1:4,1:4]
##Perform eigenvalue decomposition for clustering
##And select cluster 5 as target set to predict
pcNum=25
svdWheat &lt;- svd(A, nu = pcNum, nv = pcNum)
PCWheat &lt;- A %*% svdWheat$v
rownames(PCWheat) &lt;- rownames(A)
DistWheat &lt;- dist(PCWheat)
TreeWheat &lt;- cutree(hclust(DistWheat), k = 5 )
plot(PCWheat[,1], PCWheat[,2], col = TreeWheat, 
     pch = as.character(TreeWheat), xlab = "pc1", ylab = "pc2")
vp &lt;- rownames(PCWheat)[TreeWheat == 3]; length(vp)
tp &lt;- setdiff(rownames(PCWheat),vp)

As &lt;- A[tp,tp]
DT2 &lt;- DT[rownames(As),]
DT2$cov &lt;- apply(A[tp,vp],1,mean)

head(DT2)


# we assign a weight to x'Ax of (60*pi)/180=1
res&lt;-evolafit(formula=cbind(cov, occ)~id, dt= DT2, 
              # constraints: if sum is greater than this ignore 
              constraintsUB = c(Inf, 100), 
              # constraints: if sum is smaller than this ignore
              constraintsLB= c(-Inf, -Inf), 
              # weight the traits for the selection
              traitWeight = c(1,0), 
              # population parameters
              nCrosses = 100, nProgeny = 10, 
              recombGens=1, nChr=1, mutRate=0,
              # coancestry parameters
              A=As, lambda= (60*pi)/180 , nQTLperInd = 80, 
              # selection parameters
              propSelBetween = 0.5, propSelWithin =0.5, 
              nGenerations = 30, verbose = TRUE, keepBest=FALSE) 


best &lt;- bestSol(res)["pop","cov"]
sum(res$M[best,]) # total # of inds selected
pareto(res)


</code></pre>

<hr>
<h2 id='evola-package'>
<strong>EVOL</strong>utionary <strong>A</strong>lgorithm
<br />
</h2><span id='topic+evola'></span>

<h3>Description</h3>

<p>The evola package is nice wrapper of the AlphaSimR package that enables the use of the evolutionary algorithm to solve complex questions in a simple form.
</p>
<p>The <code><a href="#topic+evolafit">evolafit</a></code> function is the core function of the package which allows the user to specify the problem and constraints to find a close-to-optimal solution using the evolutionary forces.
</p>


<h3>Keeping evola updated</h3>

<p>The evola package is updated on CRAN every 4-months due to CRAN policies but you can find the latest source at https://github.com/covaruber/evola. This can be easily installed typing the following in the R console:
</p>
<p>library(devtools)
</p>
<p>install_github(&quot;covaruber/evola&quot;)
</p>
<p>This is recommended if you reported a bug, was fixed and was immediately pushed to GitHub but not in CRAN until the next update.
</p>


<h3>Tutorials</h3>

<p>For tutorials on how to perform different analysis with evola please look at the vignettes by typing in the terminal:
</p>
<p><strong>vignette(&quot;evola.intro&quot;)</strong>
</p>


<h3>Getting started</h3>

<p>The package has been equiped with a couple of datasets to learn how to use the evola package: 
</p>
<p>* <code><a href="#topic+DT_technow">DT_technow</a></code> dataset to perform optimal cross selection. 
</p>
<p>* <code><a href="#topic+DT_wheat">DT_wheat</a></code> dataset to perform optimal training population selection.
</p>
<p>* <code><a href="#topic+DT_cpdata">DT_cpdata</a></code> dataset to perform optimal individual. 
</p>


<h3>Models Enabled</h3>

<p>The machinery behind the scenes is AlphaSimR.
</p>


<h3>Bug report and contact</h3>

<p>If you have any questions or suggestions please post it in https://stackoverflow.com or https://stats.stackexchange.com
</p>
<p>I'll be glad to help or answer any question. I have spent a valuable amount of time developing this package. Please cite this package in your publication. Type 'citation(&quot;evola&quot;)' to know how to cite it.
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  evola: a simple evolutionary algorithm for complex problems. To be submitted to Bioinformatics.
</p>
<p>Gaynor, R. Chris, Gregor Gorjanc, and John M. Hickey. 2021. AlphaSimR: an R package for breeding program simulations. G3 Gene|Genomes|Genetics 11(2):jkaa017. https://doi.org/10.1093/g3journal/jkaa017.
</p>
<p>Chen GK, Marjoram P, Wall JD (2009). Fast and Flexible Simulation of DNA Sequence Data. Genome Research, 19, 136-142. http://genome.cshlp.org/content/19/1/136.
</p>

<hr>
<h2 id='evolafit'>
Fits a genetic algorithm for a set of traits and constraints.
</h2><span id='topic+evolafit'></span>

<h3>Description</h3>

<p>Using the AlphaSimR machinery it recreates the evolutionary forces applied to a problem where possible solutions replace individuals and combinations of variables to optimize in the problem replace the genes or QTLs. Then evolutionary forces (mutation, selection and drift) are applied to find a close-to-optimal solution. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
evolafit(formula, dt, 
     constraintsUB, constraintsLB, traitWeight,
     nCrosses=50, nProgeny=20,nGenerations=20, 
     recombGens=1, nChr=1, mutRate=0,
     nQTLperInd=NULL, A=NULL, lambda=NULL,
     propSelBetween=1,propSelWithin=0.5,
     fitnessf=NULL, verbose=TRUE, dateWarning=TRUE,
     selectTop=TRUE, tolVarG=1e-6, keepBest=FALSE,
     ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evolafit_+3A_formula">formula</code></td>
<td>

<p>Formula of the form y~x where 'y' refers to the traits or features defining the average allelic substitution effects of the QTLs, and 'x'refers to the variable defining the genes or QTLs to be combined in the possible solutions.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_dt">dt</code></td>
<td>

<p>A dataset containing the features/traits and classifiers/genes/QTLs.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_constraintsub">constraintsUB</code></td>
<td>

<p>A numeric vector specifying the upper bound constraints in the traits/features (y). The length is equal to the number of traits/features in the formula. If missing is assume an infinite value for all traits. Solutions with higher value than the upper bound are assigned a -infinite value if the argument selectTop=TRUE and to +infinite when selectTop=FALSE, which is equivalent to reject/discard a solution based on the fitness function.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_constraintslb">constraintsLB</code></td>
<td>

<p>A numeric vector specifying the lower bound constraints in the traits/features (y). The length is equal to the number of traits/features in the formula. If missing is assume a -infinite value for all traits. Solutions with lower value than the lower bound are assigned a +infinite value if the argument selectTop=TRUE and to -infinite when selectTop=FALSE, which is equivalent to reject/discard a solution based on the fitness function.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_traitweight">traitWeight</code></td>
<td>

<p>A numeric vector specifying the weights that each trait has in the fitness function (e.g., a selection index). The length is equal to the number of traits/features. If missing is assumed equal weight (1) for all traits.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_ncrosses">nCrosses</code></td>
<td>

<p>A numeric value indicating how many crosses should occur in the population of solutions at every generation.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_nprogeny">nProgeny</code></td>
<td>

<p>A numeric value indicating how many progeny (solutions) each cross should generate in the population of solutions at every generation.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_ngenerations">nGenerations</code></td>
<td>

<p>The number of generations that the evolutionary process should run for.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_recombgens">recombGens</code></td>
<td>

<p>The number of recombination generations that should occur before selection is applied. This is in case the user wants to allow for more recombination before selection operates. The default is 1.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_nchr">nChr</code></td>
<td>

<p>The number of chromosomes where features/genes should be allocated to. The default value is 1 but this number can be increased to mimic more recombination events at every generation and avoid linkage disequilibrium. 
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_mutrate">mutRate</code></td>
<td>

<p>A value between 0 and 1 to indicate the proportion of random QTLs that should mutate in each individual. For example, a value of 0.1 means that a random 10% of the QTLs will mutate in each individual randomly taking values of 0 or 1. Is important to notice that this implies that the stopping criteria based in variance will never be reached because we keep introducing variance through random mutation. 
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_nqtlperind">nQTLperInd</code></td>
<td>

<p>The number of QTLs/genes (classifier x) that should be fixed for the positive allele at the begginning of the simulation. If not specified it will be equal to the 20% of the QTLs (calculated as the number of rows in the dt argument over 5). See details section.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_a">A</code></td>
<td>

<p>A relationship matrix between the levels of the 'x' variable or QTLs (not between the solutions). It is a kind of a linkage disequilibrium matrix. This function can be used or ignored in the fitness function. By default the weight to the x'Ax component is 0 though the lambda argument, where x is an individual/solution.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_lambda">lambda</code></td>
<td>

<p>A numeric value indicating the weight assigned to the relationship between levels of the classifiers in comparison with the trait value. If not specified is assumed to be 0. This can be used or ignored in your customized fitness function.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_propselbetween">propSelBetween</code></td>
<td>

<p>A numeric value between 0 and 1 indicating the proportion of families/crosses of solutions/individuals that should be selected. The default is 1, meaning all crosses are selected or passed to the next generation.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_propselwithin">propSelWithin</code></td>
<td>

<p>A numeric value between 0 and 1 indicating the proportion of individuals/solutions within families/crosses that should be selected. The default value is 0.5, meaning that 50% of the top individuals are selected.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_fitnessf">fitnessf</code></td>
<td>

<p>An alternative fitness function for a linear combination of the traits specified in 'y' in the formula argument. If NULL, the default function will be:
</p>
<p>function(Y,b,d,Q){(Y%*%b) - d}
</p>
<p>where Y%*%b is equivalent to xa in contribution theory, and d is equal to x'Ax, being x the contribution vector to the solution, a are the QTL effects, and A is the covariance between QTLs, Q is the QTL matrix for the solution, b are the weights for each trait, Y is the matrix of trait-values for each solution. If you provide your own fitness function please keep in mind that the variables Y, b, d and Q are already reserved and should always be added to your function (even if not used) in addition to your new variables.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_verbose">verbose</code></td>
<td>

<p>A logical value indicating if we should print logs.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_datewarning">dateWarning</code></td>
<td>

<p>A logical value indicating if you should be warned when there is a new version on CRAN.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_selecttop">selectTop</code></td>
<td>

<p>Selects highest values for the fitness value if TRUE. Selects lowest values if FALSE.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_tolvarg">tolVarG</code></td>
<td>

<p>A stopping criteria (tolerance for genetic variance) when the variance across traits is smaller than this value, which is equivalent to assume that all solutions having the same QTL profile (depleted variance). The default value is 1e-6 and is computed as the sum of the diagonal values of the genetic variance covariance matrix between traits.
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_keepbest">keepBest</code></td>
<td>

<p>A TRUE/FALSE value to indicate if we should store the QTL matrix and pedigree of the solutions selected across generations. This can be useful if we want to recreate the path to the best solution (e.g., best crossing path to a product).
</p>
</td></tr>
<tr><td><code id="evolafit_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the fitness function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using the AlphaSimR machinery (runMacs) it recreates the evolutionary forces applied to a problem where possible solutions replace individuals and combinations of variables in the problem replace the genes. Then evolutionary forces are applied to find a close-to-optimal solution. The number of solutions are controlled with the nCrosses and nProgeny parameters, whereas the number of initial QTLs activated in a solution is controlled by the nQTLperInd parameter. The number of activated QTLs of course will increase if has a positive effect in the fitness of the solutions. The drift force can be controlled by the recombGens parameter. The mutation rate can be controlled with the mutRate parameter. The recombination rate can be controlled with the nChr argument.
</p>
<p>The indivPerformance output contains the columns x'a, x'Ax, deltaC and nQTLs. These mean the following:
</p>
<p>In x'a or score : 'x' represents the contribution vector, 'a' is the vector of QTN effects, so x'a is the breeding value of a solution. Internally, we multiply all the matrix of solutions (Q) by the QTN effects (a).
In deltaC : it represents the change in coancestry (e.g., inbreeding), it can be thought as the rate of coancestry.
In x'Ax : 'x' represents the contribution vector, 'A' is the linkage disequilibrium matrix between QTNs (whatever the QTNs represent for your specific problem). In practice we do QAQ' and extract the diagonal values.
In generation : it represents the generation at which this solution appeared.
In nQTNs : it represent the final number of QTNs that are activated in homozygote state for the positive effect.
</p>


<h3>Value</h3>


<dl>
<dt>indivPerformance</dt><dd><p>the matrix of x'a (score), deltaC, x'Ax, generation, nQTNs per solution per generation. See details section above. </p>
</dd>
<dt>pedBest</dt><dd><p>if the argument keepBest=TRUE this contains the pedigree of the selected solutions across iterations.</p>
</dd>
<dt>$M</dt><dd><p>the matrix of QTN genotypes for the solutions/individuals selected at the end of the run.</p>
</dd>
<dt>$Mb</dt><dd><p>the matrix of top (parents) QTN genotypes for the solutions/individuals at the end of the run.</p>
</dd>
<dt>$score</dt><dd><p>a matrix with scores for different metrics across n generations of evolution.</p>
</dd>
<dt>$pheno</dt><dd><p>the matrix of phenotypes of individuals/solutions present in the last generation.</p>
</dd>
<dt>$phenoBest</dt><dd><p>the matrix of phenotypes of top (parents) individuals/solutions present in the last generation.</p>
</dd>
<dt>pop</dt><dd><p>AlphaSimR object used for the evolutionary algorithm at the last iteration.</p>
</dd>
<dt>best</dt><dd><p>AlphaSimR object corresponding to the best parental haplotypes/solutions selected for new crosses across all cycles.</p>
</dd>
<dt>constCheckUB</dt><dd><p>A matrix with as many rows as solutions and columns as traits to be constrained. 0s indicate that such trait went beyond the bound in that particular solution.</p>
</dd>
<dt>constCheckLB</dt><dd><p>A matrix with as many rows as solutions and columns as traits to be constrained. 0s indicate that such trait went beyond the bound in that particular solution.</p>
</dd>
<dt>traits</dt><dd><p>a character vector corresponding to the name of the variables used in the fitness function.</p>
</dd>
</dl>



<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  evola: a simple evolutionary algorithm for complex problems. To be submitted to Bioinformatics.
</p>
<p>Gaynor, R. Chris, Gregor Gorjanc, and John M. Hickey. 2021. AlphaSimR: an R package for breeding program simulations. G3 Gene|Genomes|Genetics 11(2):jkaa017. https://doi.org/10.1093/g3journal/jkaa017.
</p>
<p>Chen GK, Marjoram P, Wall JD (2009). Fast and Flexible Simulation of DNA Sequence Data. Genome Research, 19, 136-142. http://genome.cshlp.org/content/19/1/136.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evolafit">evolafit</a></code> &ndash; the information of the package </p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(1)

# Data
Gems &lt;- data.frame(
  Color = c("Red", "Blue", "Purple", "Orange",
            "Green", "Pink", "White", "Black", 
            "Yellow"),
  Weight = round(runif(9,0.5,5),2),
  Value = round(abs(rnorm(9,0,5))+0.5,2),
  Times=c(rep(1,8),0)
)
head(Gems)
#     Color Weight Value
# 1    Red   4.88  9.95
# 2   Blue   1.43  2.73
# 3 Purple   1.52  2.60
# 4 Orange   3.11  0.61
# 5  Green   2.49  0.77
# 6   Pink   3.53  1.99
# 7  White   0.62  9.64
# 8  Black   2.59  1.14
# 9 Yellow   1.77 10.21

 

# Task: Gem selection. 
# Aim: Get highest combined value.
# Restriction: Max weight of the gem combined = 10. 

# simple specification
res00&lt;-evolafit(formula=cbind(Weight,Value)~Color, dt= Gems,
               # constraints on traits: if greater than this ignore
               constraintsUB = c(10,Inf), nGenerations = 10
)
best = bestSol(res00)["pop","Value"]
xa = res00$M[best,] %*% as.matrix(Gems[,c("Weight","Value")]); xa
res00$M[best,]
res00$score[nrow(res00$score),]

# more complete specification
res0&lt;-evolafit(formula=cbind(Weight,Value)~Color, dt= Gems,
               # constraints on traits: if greater than this ignore
               constraintsUB = c(10,Inf), 
               # constraints on traits: if smaller than this ignore
               constraintsLB= c(-Inf,-Inf), 
               # weight the traits for the selection (fitness function)
               traitWeight = c(0,1), 
               # population parameters
               nCrosses = 100, nProgeny = 20, 
               # genome parameters
               recombGens = 1, nChr=1, mutRate=0, nQTLperInd = 1, 
               # coancestry parameters
               A=NULL, lambda=0, 
               # selection parameters
               propSelBetween = .9, propSelWithin =0.9, 
               nGenerations = 50
) 

best = bestSol(res0)["pop","Value"]
xa = res0$M[best,] %*% as.matrix(Gems[,c("Weight","Value")]); xa
res0$M[best,]
res0$score[nrow(res0$score),]

# $`Genes`
# Red   Blue Purple Orange  Green   Pink  White  Black Yellow 
# 1      1      0      0      1      0      0      1      0 
# 
# $Result
# Weight  Value 
# 8.74  32.10 
pmonitor(res0)
pareto(res0)

 

</code></pre>

<hr>
<h2 id='fitnessf'>
Fitness function from contribution theory
</h2><span id='topic+fitnessf'></span>

<h3>Description</h3>

<p>Simple function for fitness where an index of traits is weighted by the group relationship. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitnessf(Y,b,d,Q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitnessf_+3A_y">Y</code></td>
<td>

<p>A matrix of trait values. See details.
</p>
</td></tr>
<tr><td><code id="fitnessf_+3A_b">b</code></td>
<td>

<p>A vector of trait weights. See details.
</p>
</td></tr>
<tr><td><code id="fitnessf_+3A_d">d</code></td>
<td>

<p>A vector of group relationships. See details.
</p>
</td></tr>
<tr><td><code id="fitnessf_+3A_q">Q</code></td>
<td>

<p>A QTL matrix. See details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple apply function of a regular index weighted by a vector of relationships.
</p>
<p>Y%*%b - d
</p>
<p>Internally, we use this function in the following way:
</p>
<p>The Y matrix is the matrix of trait-GEBVs and b is the user-specified trait weights. 
</p>
<p>d = xtAx * lambda; where xtAx is equal to Matrix::diag(Q%*%Matrix::tcrossprod(A,Q)) of dimensions n x n
</p>
<p>Notice that Q represents the marker of QTLs (columns) for all solutions (rows) and A the LD between QTLs. The user can modify this function as needed and provide it to the evolafit function along with other arguments.
</p>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p>a vector of values</p>
</dd>
</dl>



<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  evola: a simple evolutionary algorithm for complex problems. To be submitted to Bioinformatics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evolafit">evolafit</a></code> &ndash; the core function of the package </p>


<h3>Examples</h3>

<pre><code class='language-R'>

Y=matrix(1:12,4,3) # 4 solutions with 3 traits
b=c(1,2,3) # weights for each trait
d=c(1,1,1,1) # coancestry for each solution
fitnessf(Y,b,d) # Yb - d where d is QAQ' and A is the LD between QTNs

</code></pre>

<hr>
<h2 id='Jc'>
Matrix of ones
</h2><span id='topic+Jc'></span>

<h3>Description</h3>

<p>Makes a matrix of ones with a single row and nc columns. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jc(nc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Jc_+3A_nc">nc</code></td>
<td>

<p>Number of columns to create.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple apply function to make a matrix of one row and nc columns.
</p>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p>a matrix</p>
</dd>
</dl>



<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  evola: a simple evolutionary algorithm for complex problems. To be submitted to Bioinformatics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evolafit">evolafit</a></code> &ndash; the core function of the package </p>


<h3>Examples</h3>

<pre><code class='language-R'>
Jc(5)

</code></pre>

<hr>
<h2 id='Jr'>
Matrix of ones
</h2><span id='topic+Jr'></span>

<h3>Description</h3>

<p>Makes a matrix of ones with a single column and nr rows. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Jr(nr)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Jr_+3A_nr">nr</code></td>
<td>

<p>Number of rows to create.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple apply function to make a matrix of one column and nr rows.
</p>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p>a matrix</p>
</dd>
</dl>



<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  evola: a simple evolutionary algorithm for complex problems. To be submitted to Bioinformatics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evolafit">evolafit</a></code> &ndash; the core function of the package </p>


<h3>Examples</h3>

<pre><code class='language-R'>
Jr(5)

</code></pre>

<hr>
<h2 id='overlay'>Overlay Matrix</h2><span id='topic+overlay'></span>

<h3>Description</h3>

<p>'overlay' adds r times the design matrix for model term t to the existing design matrix. Specifically, if the model up to this point has p effects and t has a effects, the a columns of the design matrix for t are multiplied by the scalar r (default value 1.0). This can be used to force a correlation of 1 between two terms as in a diallel analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  overlay(..., rlist=NULL, prefix=NULL, sparse=FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="overlay_+3A_...">...</code></td>
<td>
<p>as many vectors as desired to overlay.</p>
</td></tr>
<tr><td><code id="overlay_+3A_rlist">rlist</code></td>
<td>
<p>a list of scalar values indicating the times that each incidence matrix overlayed should be multiplied by. By default r=1.</p>
</td></tr>
<tr><td><code id="overlay_+3A_prefix">prefix</code></td>
<td>
<p>a character name to be added before the column names of the final overlay matrix. This may be useful if you have entries with names starting with numbers which programs such as asreml doesn't like, or for posterior extraction of parameters, that way 'grep'ing is easier.</p>
</td></tr>
<tr><td><code id="overlay_+3A_sparse">sparse</code></td>
<td>
<p>a TRUE/FALSE statement specifying if the matrices should be built as sparse or regular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>$S3</dt><dd><p> an incidence matrix with as many columns levels in the vectors provided to build the incidence matrix.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Giovanny Covarrubias-Pazaran
</p>


<h3>References</h3>

<p>Fikret Isik. 2009. Analysis of Diallel Mating Designs. North Carolina State University, Raleigh, USA.
</p>
<p>Covarrubias-Pazaran G (2016) Genome assisted prediction of quantitative traits using the R package soevolafit. PLoS ONE 11(6): doi:10.1371/journal.pone.0156744 
</p>


<h3>See Also</h3>

<p>The core functions of the package <code><a href="#topic+evolafit">evolafit</a></code>. </p>


<h3>Examples</h3>

<pre><code class='language-R'>  
####=========================================####
#### For CRAN time limitations most lines in the 
#### examples are silenced with one '#' mark, 
#### remove them and run the examples
####=========================================####
data("DT_technow")
DT &lt;- DT_technow
head(DT)
DT$dentf &lt;- as.factor(DT$dent)
DT$flintf &lt;- as.factor(DT$flint)

with(DT, overlay(dentf,flintf, sparse = TRUE))
with(DT, overlay(dentf,flintf, sparse = FALSE))

</code></pre>

<hr>
<h2 id='pareto'>plot the change of values across iterations</h2><span id='topic+pareto'></span>

<h3>Description</h3>

<p><code>plot</code> for monitoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pareto(object, scaled=TRUE,pch=20, xlim, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pareto_+3A_object">object</code></td>
<td>
<p>model object of class <code>"evolafit"</code></p>
</td></tr>
<tr><td><code id="pareto_+3A_scaled">scaled</code></td>
<td>
<p>a logical value to specify the scale of the y-axis (gain in merit).</p>
</td></tr>
<tr><td><code id="pareto_+3A_pch">pch</code></td>
<td>
<p>symbol for plotting points as desribed in par</p>
</td></tr>
<tr><td><code id="pareto_+3A_xlim">xlim</code></td>
<td>
<p>upper and lower bound in the x-axis</p>
</td></tr>
<tr><td><code id="pareto_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of plot
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+plot">plot</a></code>, <code><a href="#topic+evolafit">evolafit</a></code></p>

<hr>
<h2 id='pmonitor'>plot the change of values across iterations</h2><span id='topic+pmonitor'></span>

<h3>Description</h3>

<p><code>plot</code> for monitoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmonitor(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pmonitor_+3A_object">object</code></td>
<td>
<p>model object of class <code>"evolafit"</code></p>
</td></tr>
<tr><td><code id="pmonitor_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the plot function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of plot
</p>


<h3>Author(s)</h3>

<p>Giovanny Covarrubias</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+plot">plot</a></code>, <code><a href="#topic+evolafit">evolafit</a></code></p>

<hr>
<h2 id='stan'>
Standardize a vector of values in range 0 to 1
</h2><span id='topic+stan'></span>

<h3>Description</h3>

<p>Simple function to map a vector of values to the range of 0 and 1 values to have a better behavior of the algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stan_+3A_x">x</code></td>
<td>

<p>A vector of numeric values.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple function to map a vector of values to the range of 0 and 1 values to have a better behavior of the algorithm.
</p>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p>new values in range 0 to 1</p>
</dd>
</dl>



<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  evola: a simple evolutionary algorithm for complex problems. To be submitted to Bioinformatics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evolafit">evolafit</a></code> &ndash; the core function of the package </p>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- rnorm(20, 10, 3);x
stan(x)


</code></pre>

<hr>
<h2 id='varM'>
Extract the variance existing in the genome solutions
</h2><span id='topic+varM'></span>

<h3>Description</h3>

<p>Extracts the variance found across the M element of the resulting object of the evolafit() function which contains the different solution and somehow represents the genome of the population. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varM(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="varM_+3A_object">object</code></td>
<td>

<p>A resulting object from the function evolafit.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A simple apply function looking at the variance in each column of the M element of the resulting object of the evolafit function.
</p>


<h3>Value</h3>


<dl>
<dt>$res</dt><dd><p>a value of variance</p>
</dd>
</dl>



<h3>References</h3>

<p>Giovanny Covarrubias-Pazaran (2024).  evola: a simple evolutionary algorithm for complex problems. To be submitted to Bioinformatics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+evolafit">evolafit</a></code> &ndash; the core function of the package </p>


<h3>Examples</h3>

<pre><code class='language-R'>

set.seed(1)
# Data
Gems &lt;- data.frame(
  Color = c("Red", "Blue", "Purple", "Orange",
            "Green", "Pink", "White", "Black", 
            "Yellow"),
  Weight = round(runif(9,0.5,5),2),
  Value = round(abs(rnorm(9,0,5))+0.5,2),
  Times=c(rep(1,8),0)
)
head(Gems)

 
# Task: Gem selection. 
# Aim: Get highest combined value.
# Restriction: Max weight of the gem combined = 10. 
res0&lt;-evolafit(cbind(Weight,Value)~Color, dt= Gems,
               # constraints: if greater than this ignore
               constraintsUB = c(10,Inf), 
               # constraints: if smaller than this ignore
               constraintsLB= c(-Inf,-Inf), 
               # weight the traits for the selection
               traitWeight = c(0,1), 
               # population parameters
               nCrosses = 100, nProgeny = 20, recombGens = 1, 
               # coancestry parameters
               A=NULL, lambda=c(0,0), nQTLperInd = 1, 
               # selection parameters
               propSelBetween = .9, propSelWithin =0.9, 
               nGenerations = 50
) 

varM(res0)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
