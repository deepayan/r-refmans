<!DOCTYPE html><html><head><title>Help for package LassoNet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LassoNet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#beta.update.net'>
<p>Updates <code class="reqn">\beta</code> coefficients.</p></a></li>
<li><a href='#betanew_lasso_cpp'>
<p>C++ subroutine that updates <code class="reqn">\beta</code> coefficients.</p></a></li>
<li><a href='#fastols'>
<p>Fast least squares estimate.</p>
</p></a></li>
<li><a href='#get.BxBy'>
<p>Computes decomposition elements.</p></a></li>
<li><a href='#get.signs.M'>
<p>Vetorizes connection sign matrix.</p></a></li>
<li><a href='#get.xi'>
<p>Updates the estimates of the connection signs by running mini OLS models.</p></a></li>
<li><a href='#lasso.net.fixed'>
<p>Estimates coefficients over the grid values of penalty parameters.</p></a></li>
<li><a href='#lasso.net.grid'>
<p>Estimates coefficients and connection signs over the grid of values  of penalty parameters <code class="reqn">\lambda</code>1 and <code class="reqn">\lambda</code>2.</p></a></li>
<li><a href='#LassoNet-package'>
<p>LassoNet: package for 3CoSE algorithm.</p>
</p></a></li>
<li><a href='#mat.to.laplacian'>
<p>Computes Laplacian matrix.</p></a></li>
<li><a href='#matrix.M.update'>
<p>Updates connection sign matrix.</p></a></li>
<li><a href='#soft.thresh'>
<p>Soft thresholding operator.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>3CoSE Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-12-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonas Striaukas [aut, trl, cre] and Matthias Weber [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonas Striaukas &lt;jonas.striaukas@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains functions to estimate a penalized regression model using 3CoSE algorithm, see Weber, Striaukas, Schumacher Binder (2018) &lt;<a href="https://doi.org/10.2139%2Fssrn.3211163">doi:10.2139/ssrn.3211163</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.11.5)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>snowfall</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-01-14 12:37:39 UTC; striaukas</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-01-19 15:30:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='beta.update.net'>
Updates <code class="reqn">\beta</code> coefficients.
</h2><span id='topic+beta.update.net'></span>

<h3>Description</h3>

<p>This function updates <code class="reqn">\beta</code> for given penalty parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta.update.net(x,y,beta,lambda1,lambda2,M1,n.iter,iscpp,tol)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta.update.net_+3A_x">x</code></td>
<td>
<p>input data matrix of size <code class="reqn">n \times p</code>; n - number of observations; p - number of covariates</p>
</td></tr>
<tr><td><code id="beta.update.net_+3A_y">y</code></td>
<td>
<p>response vector or size <code class="reqn">n \times 1</code></p>
</td></tr>
<tr><td><code id="beta.update.net_+3A_beta">beta</code></td>
<td>
<p>initial value for <code class="reqn">\beta</code>; default - zero vector of size <code class="reqn">n \times 1</code></p>
</td></tr>
<tr><td><code id="beta.update.net_+3A_lambda1">lambda1</code></td>
<td>
<p>lasso penalty parameter</p>
</td></tr>
<tr><td><code id="beta.update.net_+3A_lambda2">lambda2</code></td>
<td>
<p>network penalty parameter</p>
</td></tr>
<tr><td><code id="beta.update.net_+3A_m1">M1</code></td>
<td>
<p>penalty matrix</p>
</td></tr>
<tr><td><code id="beta.update.net_+3A_n.iter">n.iter</code></td>
<td>
<p>maximum number of iterations for <code class="reqn">\beta</code> step; default - 1e5</p>
</td></tr>
<tr><td><code id="beta.update.net_+3A_iscpp">iscpp</code></td>
<td>
<p>binary choice for using cpp function in coordinate updates; 1 - use C++ (default), 0 - use R</p>
</td></tr>
<tr><td><code id="beta.update.net_+3A_tol">tol</code></td>
<td>
<p>convergence tolerance level; default - 1e-6</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Updates the coefficient vector <code class="reqn">\beta</code> given the data and penalty parameters <code class="reqn">\lambda</code>1 and <code class="reqn">\lambda</code>2.
Convergence criterion is defined as <code class="reqn">\sum_{i=1}^p |\beta_{i,j} - \beta_{i,j-1}| \leq</code> to.</p>


<h3>Value</h3>

<table>
<tr><td><code>beta</code></td>
<td>
<p>updated <code class="reqn">\beta</code> vector</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>binary variable; 1 - yes</p>
</td></tr>
<tr><td><code>steps</code></td>
<td>
<p>number of steps until convergence</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maintainer: Jonas Striaukas &lt;jonas.striaukas@gmail.com&gt;
</p>


<h3>References</h3>

<p>Weber, M., Striaukas, J., Schumacher, M., Binder, H. &quot;Network-Constrained Covariate Coefficient and Connection Sign Estimation&quot; (2018) &lt;doi:10.2139/ssrn.3211163&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>p&lt;-200
n&lt;-100
beta.0=array(1,c(p,1))
x&lt;-matrix(rnorm(n*p),n,p)
y&lt;-rnorm(n,mean=0,sd=1)
lambda1&lt;-1
lambda2&lt;-1
M1&lt;-diag(p)
updates&lt;-beta.update.net(x, y, beta.0, lambda1, lambda2, M1)
</code></pre>

<hr>
<h2 id='betanew_lasso_cpp'>
C++ subroutine that updates <code class="reqn">\beta</code> coefficients.
</h2><span id='topic+betanew_lasso_cpp'></span>

<h3>Description</h3>

<p>This function updates <code class="reqn">\beta</code> for given penalty parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>betanew_lasso_cpp(xx, xy, beta, M, y, Lambda1, Lambda2, iter, tol)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="betanew_lasso_cpp_+3A_xx">xx</code></td>
<td>
<p>Bx matrix</p>
</td></tr>
<tr><td><code id="betanew_lasso_cpp_+3A_xy">xy</code></td>
<td>
<p>By vector</p>
</td></tr>
<tr><td><code id="betanew_lasso_cpp_+3A_beta">beta</code></td>
<td>
<p>initial value for <code class="reqn">\beta</code>; default - zero vector of size <code class="reqn">p \times 1</code></p>
</td></tr>
<tr><td><code id="betanew_lasso_cpp_+3A_m">M</code></td>
<td>
<p>penalty matrix</p>
</td></tr>
<tr><td><code id="betanew_lasso_cpp_+3A_y">y</code></td>
<td>
<p>response vector or size <code class="reqn">n \times 1</code></p>
</td></tr>
<tr><td><code id="betanew_lasso_cpp_+3A_lambda1">Lambda1</code></td>
<td>
<p>lasso penalty parameter</p>
</td></tr>
<tr><td><code id="betanew_lasso_cpp_+3A_lambda2">Lambda2</code></td>
<td>
<p>network penalty parameter</p>
</td></tr>
<tr><td><code id="betanew_lasso_cpp_+3A_iter">iter</code></td>
<td>
<p>maximum number of iterations for <code class="reqn">\beta</code> step</p>
</td></tr>
<tr><td><code id="betanew_lasso_cpp_+3A_tol">tol</code></td>
<td>
<p>convergence tolerance level</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See beta.update.net</p>


<h3>Value</h3>

<table>
<tr><td><code>beta</code></td>
<td>
<p>updated <code class="reqn">\beta</code> vector</p>
</td></tr>
<tr><td><code>steps</code></td>
<td>
<p>number of steps until convergence</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maintainer: Jonas Striaukas &lt;jonas.striaukas@gmail.com&gt;
</p>


<h3>References</h3>

<p>Weber, M., Striaukas, J., Schumacher, M., Binder, H. &quot;Network-Constrained Covariate Coefficient and Connection Sign Estimation&quot; (2018) &lt;doi:10.2139/ssrn.3211163&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>p&lt;-200
n&lt;-100
beta.0=array(1,c(p,1))
x&lt;-matrix(rnorm(n*p),n,p)
y&lt;-rnorm(n,mean=0,sd=1)
lambda1&lt;-1
lambda2&lt;-1
M1&lt;-diag(p)
updates&lt;-beta.update.net(x, y, beta.0, lambda1, lambda2, M1)
</code></pre>

<hr>
<h2 id='fastols'>
Fast least squares estimate.
</h2><span id='topic+fastols'></span>

<h3>Description</h3>

<p>Computes least squares estimate in an efficient way.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastols(y, x)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastols_+3A_y">y</code></td>
<td>
<p>dependent variable</p>
</td></tr>
<tr><td><code id="fastols_+3A_x">x</code></td>
<td>
<p>response variable</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maintainer: Jonas Striaukas &lt;jonas.striaukas@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p&lt;-10
n&lt;-100
x&lt;-matrix(rnorm(n*p),n,p)
beta&lt;-array(5, c(p,1))
y&lt;-x%*%beta + rnorm(n,mean=0,sd=0.1)
fastols(y,x)
</code></pre>

<hr>
<h2 id='get.BxBy'>
Computes decomposition elements.
</h2><span id='topic+get.BxBy'></span>

<h3>Description</h3>

<p>Computes matrices <code class="reqn">B^{ij}_X</code> and <code class="reqn">B^{ij}_y</code> to speed up estimation of connection signs. These matrices are stored only for indices that have non zero entries in penalty matrix M. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.BxBy(x, y, M)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.BxBy_+3A_x">x</code></td>
<td>
<p>Input data matrix of size <code class="reqn">n \times p</code>, n - number of observations, p - number of covariates</p>
</td></tr>
<tr><td><code id="get.BxBy_+3A_y">y</code></td>
<td>
<p>y Response vector or size <code class="reqn">n \times 1</code></p>
</td></tr>
<tr><td><code id="get.BxBy_+3A_m">M</code></td>
<td>
<p>penalty matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates matrices all for i and j indices that have non zero
values in a given penalty matrix.</p>


<h3>Value</h3>

<table>
<tr><td><code>Bx</code></td>
<td>
<p>array of <code class="reqn">B^{ij}_X</code> stored matrices. <code class="reqn">Bx[,,k]</code> are the k-th combination of i and j non zero entry in the penalty matrix M</p>
</td></tr>
<tr><td><code>By</code></td>
<td>
<p>array of <code class="reqn">B^{ij}_y</code> stored matrices. <code class="reqn">By[,k]</code> are the k-th combination of i and j non zero entry in the penalty matrix M</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maintainer: Jonas Striaukas &lt;jonas.striaukas@gmail.com&gt;
</p>


<h3>References</h3>

<p>Weber, M., Striaukas, J., Schumacher, M., Binder, H. &quot;Network-Constrained Covariate Coefficient and Connection Sign Estimation&quot; (2018) &lt;doi:10.2139/ssrn.3211163&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>p&lt;-200
n&lt;-100
x&lt;-matrix(rnorm(n*p),n,p)
y&lt;-rnorm(n,mean=0,sd=1)
M&lt;-diag(p)
get.BxBy(x, y, M)
</code></pre>

<hr>
<h2 id='get.signs.M'>
Vetorizes connection sign matrix.
</h2><span id='topic+get.signs.M'></span>

<h3>Description</h3>

<p>Stores a matrix of connection signs to a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.signs.M(MAT)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.signs.M_+3A_mat">MAT</code></td>
<td>
<p>matrix of connection signs that contains -1, 1 or 0</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>vec.out</code></td>
<td>
<p>vectorized MAT matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maintainer: Jonas Striaukas &lt;jonas.striaukas@gmail.com&gt;
</p>

<hr>
<h2 id='get.xi'>
Updates the estimates of the connection signs by running mini OLS models.
</h2><span id='topic+get.xi'></span>

<h3>Description</h3>

<p>Updates connection signs <code class="reqn">\hat{\xi}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.xi(Bx,By,beta,xi,M)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.xi_+3A_bx">Bx</code></td>
<td>
<p>Bx element </p>
</td></tr>
<tr><td><code id="get.xi_+3A_by">By</code></td>
<td>
<p>By element</p>
</td></tr>
<tr><td><code id="get.xi_+3A_beta">beta</code></td>
<td>
<p><code class="reqn">\hat{\beta}</code> estimated value</p>
</td></tr>
<tr><td><code id="get.xi_+3A_xi">xi</code></td>
<td>
<p><code class="reqn">\hat{\xi}</code> matrix estimated at the previous step</p>
</td></tr>
<tr><td><code id="get.xi_+3A_m">M</code></td>
<td>
<p>penalty matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>xi</code></td>
<td>
<p><code class="reqn">\hat{\xi}</code> matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maintainer: Jonas Striaukas &lt;jonas.striaukas@gmail.com&gt;
</p>


<h3>References</h3>

<p>Weber, M., Striaukas, J., Schumacher, M., Binder, H. &quot;Network-Constrained Covariate Coefficient and Connection Sign Estimation&quot; (2018) &lt;doi:10.2139/ssrn.3211163&gt;</p>

<hr>
<h2 id='lasso.net.fixed'>
Estimates coefficients over the grid values of penalty parameters.</h2><span id='topic+lasso.net.fixed'></span>

<h3>Description</h3>

<p>See lasso.net.grid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasso.net.fixed(x,y,beta.0,lambda1,lambda2,M1,n.iter,iscpp,tol)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lasso.net.fixed_+3A_x">x</code></td>
<td>
<p><code class="reqn">n \times p</code> input data matrix</p>
</td></tr>
<tr><td><code id="lasso.net.fixed_+3A_y">y</code></td>
<td>
<p>response vector or size <code class="reqn">n \times 1</code></p>
</td></tr>
<tr><td><code id="lasso.net.fixed_+3A_beta.0">beta.0</code></td>
<td>
<p>initial value for <code class="reqn">\beta</code>; default - zero vector of size <code class="reqn">n \times 1</code></p>
</td></tr>
<tr><td><code id="lasso.net.fixed_+3A_lambda1">lambda1</code></td>
<td>
<p>lasso penalty coefficient</p>
</td></tr>
<tr><td><code id="lasso.net.fixed_+3A_lambda2">lambda2</code></td>
<td>
<p>network penalty coefficient</p>
</td></tr>
<tr><td><code id="lasso.net.fixed_+3A_m1">M1</code></td>
<td>
<p>penalty matrix</p>
</td></tr>
<tr><td><code id="lasso.net.fixed_+3A_n.iter">n.iter</code></td>
<td>
<p>maximum number of iterations for <code class="reqn">\beta</code> updating; default - 1e5</p>
</td></tr>
<tr><td><code id="lasso.net.fixed_+3A_iscpp">iscpp</code></td>
<td>
<p>binary choice for using cpp function in coordinate updates; 1 - use C++ (default), 0 - use R.</p>
</td></tr>
<tr><td><code id="lasso.net.fixed_+3A_tol">tol</code></td>
<td>
<p>convergence in <code class="reqn">\beta</code> tolerance level; default - 1e-6</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function loops through the grid of values of penalty parameters <code class="reqn">\lambda</code>1 and <code class="reqn">\lambda</code>2 until convergence is reached. Warm starts are stored for each iterator. The warm starts are stored once the coordinate updating converges.</p>


<h3>Value</h3>

<table>
<tr><td><code>beta</code></td>
<td>
<p>Matrix of <code class="reqn">\beta</code> coefficients. Columns denote different <code class="reqn">\lambda</code>1
coefficients, rows - <code class="reqn">\lambda</code>2 coefficients</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>Mean squared error value</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>matrix with stored number of steps for sign matrix to converge</p>
</td></tr>
<tr><td><code>update.steps</code></td>
<td>
<p>matrix with stored number of steps for <code class="reqn">\beta</code> updates to converge. (only stores the last values from connection signs iterations)</p>
</td></tr>
<tr><td><code>convergence.in.grid</code></td>
<td>
<p>matrix with stored values for convergence in <code class="reqn">\beta</code> coefficients. If at least one <code class="reqn">\beta</code> did not converge in sign matrix iterations, 0 (false) is stored, otherwise 1 (true)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maintainer: Jonas Striaukas &lt;jonas.striaukas@gmail.com&gt;
</p>


<h3>References</h3>

<p>Weber, M., Striaukas, J., Schumacher, M., Binder, H. &quot;Network-Constrained Covariate Coefficient and Connection Sign Estimation&quot; (2018) &lt;doi:10.2139/ssrn.3211163&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>p=200
n=100
beta.0=array(1,c(p,1))
x=matrix(rnorm(n*p),n,p)
y=rnorm(n,mean=0,sd=1)
lambda1=c(0,1)
lambda2=c(0,1)
M1=diag(p)
lasso.net.fixed(x, y, beta.0, lambda1, lambda2, M1)
</code></pre>

<hr>
<h2 id='lasso.net.grid'>
Estimates coefficients and connection signs over the grid of values  of penalty parameters <code class="reqn">\lambda</code>1 and <code class="reqn">\lambda</code>2.
</h2><span id='topic+lasso.net.grid'></span>

<h3>Description</h3>

<p>Fits network regressions over the grid of values of penalty parameters <code class="reqn">\lambda</code>1 and <code class="reqn">\lambda</code>2, stores connection signs, number of iterations until convergence and convergence outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lasso.net.grid(x,y ,beta.0,lambda1,lambda2,M1,m.iter,n.iter,iscpp=TRUE,tol,alt.num)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lasso.net.grid_+3A_x">x</code></td>
<td>
<p><code class="reqn">n \times p</code> input data matrix</p>
</td></tr>
<tr><td><code id="lasso.net.grid_+3A_y">y</code></td>
<td>
<p>response vector or size <code class="reqn">n \times 1</code></p>
</td></tr>
<tr><td><code id="lasso.net.grid_+3A_beta.0">beta.0</code></td>
<td>
<p>initial value for <code class="reqn">\beta</code>. default - zero vector of size <code class="reqn">n \times 1</code></p>
</td></tr>
<tr><td><code id="lasso.net.grid_+3A_lambda1">lambda1</code></td>
<td>
<p>lasso penalty coefficient</p>
</td></tr>
<tr><td><code id="lasso.net.grid_+3A_lambda2">lambda2</code></td>
<td>
<p>network penalty coefficient</p>
</td></tr>
<tr><td><code id="lasso.net.grid_+3A_m1">M1</code></td>
<td>
<p>penalty matrix</p>
</td></tr>
<tr><td><code id="lasso.net.grid_+3A_m.iter">m.iter</code></td>
<td>
<p>maximum number of iterations for sign matrix updating; default - 100</p>
</td></tr>
<tr><td><code id="lasso.net.grid_+3A_n.iter">n.iter</code></td>
<td>
<p>maximum number of iterations for <code class="reqn">\beta</code> updating; default - 1e5</p>
</td></tr>
<tr><td><code id="lasso.net.grid_+3A_iscpp">iscpp</code></td>
<td>
<p>binary choice for using cpp function in coordinate updates; 1 - use C++ (default), 0 - use R</p>
</td></tr>
<tr><td><code id="lasso.net.grid_+3A_tol">tol</code></td>
<td>
<p>convergence in <code class="reqn">\beta</code> tolerance level; default - 1e-6</p>
</td></tr>
<tr><td><code id="lasso.net.grid_+3A_alt.num">alt.num</code></td>
<td>
<p>alt.num remaining iterataions are stored; default - 12</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits network regression for the grid values of <code class="reqn">\lambda</code>1 and <code class="reqn">\lambda</code>2 using warm starts.</p>


<h3>Value</h3>

<table>
<tr><td><code>beta</code></td>
<td>
<p>matrix of <code class="reqn">\beta</code> coefficients, columns are for different <code class="reqn">\lambda</code>1
parameters, rows <code class="reqn">\lambda</code>2 parameters</p>
</td></tr>
<tr><td><code>mse</code></td>
<td>
<p>mean squared error value</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>array of connection signs. <code class="reqn">M[,,i,j]</code> is the connection sign matrix for j-th <code class="reqn">\lambda</code>1 value and i-th <code class="reqn">\lambda</code>2 value</p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p>matrix with stored number of steps for sign matrix to converge</p>
</td></tr>
<tr><td><code>update.steps</code></td>
<td>
<p>matrix with stored number of steps for <code class="reqn">\beta</code> updates to converge. (only stores the last values from connection signs iterations)</p>
</td></tr>
<tr><td><code>convergence.in.M</code></td>
<td>
<p>matrix with stored values for convergence in sign matrix</p>
</td></tr>
<tr><td><code>convergence.in.grid</code></td>
<td>
<p>matrix with stored values for convergence in <code class="reqn">\beta</code> coefficients. If at least one <code class="reqn">\beta</code> did not converge in sign matrix iterations, 0 (false) is stored, otherwise 1 (true)</p>
</td></tr>
<tr><td><code>xi.conv</code></td>
<td>
<p>array with stored connection signs changes in each iteration</p>
</td></tr>
<tr><td><code>beta.alt</code></td>
<td>
<p>array of coefficient vectors in case connection signs alternate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maintainer: Jonas Striaukas &lt;jonas.striaukas@gmail.com&gt;
</p>


<h3>References</h3>

<p>Weber, M., Striaukas, J., Schumacher, M., Binder, H. &quot;Network-Constrained Covariate Coefficient and Connection Sign Estimation&quot; (2018) &lt;doi:10.2139/ssrn.3211163&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>p=200
n=100
beta.0=array(1,c(p,1))
x=matrix(rnorm(n*p),n,p)
y=rnorm(n,mean=0,sd=1)
lambda1=c(0,1)
lambda2=c(0,1)
M1=diag(p)
lasso.net.grid(x, y, beta.0, lambda1, lambda2, M1)
</code></pre>

<hr>
<h2 id='LassoNet-package'>
LassoNet: package for 3CoSE algorithm. 
</h2><span id='topic+LassoNet-package'></span>

<h3>Description</h3>

<p>LassoNet contains functions to estimate a penalized regression model using 3CoSE algorithm described in the paper Weber, Striaukas, Schumacher and Binder (2018). The main function of the package is the function lasso.net.grid, see the example below.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> LassoNet</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.8.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2019-12-16 </td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> Open source </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Maintainer: Jonas Striaukas &lt;jonas.striaukas@gmail.com&gt;
</p>


<h3>References</h3>

<p>Weber, M., Striaukas, J., Schumacher, M., Binder, H. &quot;Network-Constrained Covariate Coefficient and Connection Sign Estimation&quot; (2018) &lt;doi:10.2139/ssrn.3211163&gt;</p>


<h3>See Also</h3>

<p><code><a href="Rcpp.html#topic+Rcpp-package">Rcpp</a></code>, <code><a href="glmnet.html#topic+glmnet-package">glmnet</a></code>
</p>

<hr>
<h2 id='mat.to.laplacian'>
Computes Laplacian matrix. 
</h2><span id='topic+mat.to.laplacian'></span>

<h3>Description</h3>

<p>Computes Laplacian matrix. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat.to.laplacian(M1,type)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat.to.laplacian_+3A_m1">M1</code></td>
<td>
<p><code class="reqn">p \times p</code> matrix</p>
</td></tr>
<tr><td><code id="mat.to.laplacian_+3A_type">type</code></td>
<td>
<p>Laplacian types: 1) &quot;normalized&quot; (default) - normalized Laplacian, 2) &quot;combinatorial&quot; - combinatorial Laplacian</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>L</code></td>
<td>
<p>Laplacian</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maintainer: Jonas Striaukas &lt;jonas.striaukas@gmail.com&gt;
</p>

<hr>
<h2 id='matrix.M.update'>
Updates connection sign matrix.
</h2><span id='topic+matrix.M.update'></span>

<h3>Description</h3>

<p>Updates M using relation <code class="reqn">(M)_{ij} = -\hat{\xi}_{ij} |(M_1)|_{ij}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix.M.update(M, xi)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix.M.update_+3A_m">M</code></td>
<td>
<p>penalty matrix</p>
</td></tr>
<tr><td><code id="matrix.M.update_+3A_xi">xi</code></td>
<td>
<p>estimated <code class="reqn">\hat{\xi}_{ij}</code> matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Updates M</p>


<h3>Value</h3>

<table>
<tr><td><code>M</code></td>
<td>
<p>updated M</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maintainer: Jonas Striaukas &lt;jonas.striaukas@gmail.com&gt;
</p>


<h3>References</h3>

<p>Weber, M., Striaukas, J., Schumacher, M., Binder, H. &quot;Network-Constrained Covariate Coefficient and Connection Sign Estimation&quot; (2018) &lt;doi:10.2139/ssrn.3211163&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>p&lt;-100
M&lt;-diag(p)
xi&lt;-matrix(rnorm(p*p), p, p)
matrix.M.update(M,xi)
</code></pre>

<hr>
<h2 id='soft.thresh'>
Soft thresholding operator.
</h2><span id='topic+soft.thresh'></span>

<h3>Description</h3>

<p>Soft thresholding operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soft.thresh(x, kappa)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="soft.thresh_+3A_x">x</code></td>
<td>
<p><code class="reqn">\beta</code> coordinate</p>
</td></tr>
<tr><td><code id="soft.thresh_+3A_kappa">kappa</code></td>
<td>
<p><code class="reqn">\kappa</code> value in general or <code class="reqn">\lambda_1</code> for covariance updating</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Soft thresholding definition: <code class="reqn">S(x,\kappa) = sign(x) (|x| - \kappa)_{+}</code></p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>value after applying soft thresholding operator</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maintainer: Jonas Striaukas &lt;jonas.striaukas@gmail.com&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kappa&lt;-0.2
x&lt;-0.7
soft.thresh(x, kappa)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
