<!DOCTYPE html><html lang="en"><head><title>Help for package OutSeekR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OutSeekR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calculate.p.values'><p>Calculate p-values</p></a></li>
<li><a href='#calculate.residuals'><p>Calculate residuals</p></a></li>
<li><a href='#detect.outliers'><p>Detect outliers</p></a></li>
<li><a href='#example.data.for.calculate.p.values'><p>example.data.for.calculate.p.values</p></a></li>
<li><a href='#identify.bic.optimal.data.distribution'><p>Identify optimal distribution of data</p></a></li>
<li><a href='#identify.bic.optimal.residuals.distribution'><p>Identify optimal distribution of residuals</p></a></li>
<li><a href='#kmeans.fraction'><p>k-means fraction</p></a></li>
<li><a href='#outlier.detection.cosine'><p>Cosine similarity</p></a></li>
<li><a href='#outliers'><p>Example data set for outlier testing</p></a></li>
<li><a href='#quantify.outliers'><p>Compute quantities for outlier detection</p></a></li>
<li><a href='#simulate.null'><p>Simulate from a null distribution</p></a></li>
<li><a href='#trim.sample'><p>Trim a vector of numbers</p></a></li>
<li><a href='#zrange'><p>Range of z-scores</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Statistical Approach to Outlier Detection in RNA-Seq and Related
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-11-15</td>
</tr>
<tr>
<td>Description:</td>
<td>An approach to outlier detection in RNA-seq and related data
    based on five statistics. 'OutSeekR' implements an outlier test by comparing
    the distributions of these statistics in observed data with those of
    simulated null data.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>future.apply, gamlss, gamlss.dist, lsa, truncnorm</td>
</tr>
<tr>
<td>Suggests:</td>
<td>future, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-15 23:56:34 UTC; danknight</td>
</tr>
<tr>
<td>Author:</td>
<td>Jee Yun Han [aut],
  John Sahrmann [aut],
  Jaron Arbet [ctb],
  Paul Boutros [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Paul Boutros &lt;pboutros@mednet.ucla.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-19 09:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='calculate.p.values'>Calculate p-values</h2><span id='topic+calculate.p.values'></span>

<h3>Description</h3>

<p>Calculate p-values for each sample of a single transcript.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate.p.values(
  x,
  x.distribution,
  x.zrange.mean,
  x.zrange.median,
  x.zrange.trimmean,
  x.fraction.kmeans,
  x.cosine.similarity,
  null.zrange.mean,
  null.zrange.median,
  null.zrange.trimmean,
  null.fraction.kmeans,
  null.cosine.similarity,
  kmeans.nstart = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate.p.values_+3A_x">x</code></td>
<td>
<p>A numeric vector of values for an observed transcript.</p>
</td></tr>
<tr><td><code id="calculate.p.values_+3A_x.distribution">x.distribution</code></td>
<td>
<p>A numeric code corresponding to the optimal distribution of <code>x</code> as returned by <code>identify.bic.optimal.data.distribution()</code>.</p>
</td></tr>
<tr><td><code id="calculate.p.values_+3A_x.zrange.mean">x.zrange.mean</code></td>
<td>
<p>A number, the range of the z-scores calculated using the mean and standard deviation of <code>x</code>.</p>
</td></tr>
<tr><td><code id="calculate.p.values_+3A_x.zrange.median">x.zrange.median</code></td>
<td>
<p>A number, the range of the z-scores calculated using the median and median absolute deviation of <code>x</code>.</p>
</td></tr>
<tr><td><code id="calculate.p.values_+3A_x.zrange.trimmean">x.zrange.trimmean</code></td>
<td>
<p>A number, the range of the z-scores calculated using the trimmed mean and trimmed standard deviation of <code>x</code>.</p>
</td></tr>
<tr><td><code id="calculate.p.values_+3A_x.fraction.kmeans">x.fraction.kmeans</code></td>
<td>
<p>A number, the k-means fraction of <code>x</code>.</p>
</td></tr>
<tr><td><code id="calculate.p.values_+3A_x.cosine.similarity">x.cosine.similarity</code></td>
<td>
<p>A number, the cosine similarity of <code>x</code>.</p>
</td></tr>
<tr><td><code id="calculate.p.values_+3A_null.zrange.mean">null.zrange.mean</code></td>
<td>
<p>A numeric vector, the ranges of the z-scores calculated using the mean and standard deviation of each transcript in the null data.</p>
</td></tr>
<tr><td><code id="calculate.p.values_+3A_null.zrange.median">null.zrange.median</code></td>
<td>
<p>A numeric vector, the ranges of the z-scores calculated using the median and median absolute deviation of each transcript in the null data.</p>
</td></tr>
<tr><td><code id="calculate.p.values_+3A_null.zrange.trimmean">null.zrange.trimmean</code></td>
<td>
<p>A numeric vector, the ranges of the z-scores calculated using the trimmed mean and trimmed standard deviation of each transcript in the null data.</p>
</td></tr>
<tr><td><code id="calculate.p.values_+3A_null.fraction.kmeans">null.fraction.kmeans</code></td>
<td>
<p>A numeric vector, the k-means fraction of each transcript in the null data.</p>
</td></tr>
<tr><td><code id="calculate.p.values_+3A_null.cosine.similarity">null.cosine.similarity</code></td>
<td>
<p>A numeric vector, the cosine similarity of each transcript in the null data.</p>
</td></tr>
<tr><td><code id="calculate.p.values_+3A_kmeans.nstart">kmeans.nstart</code></td>
<td>
<p>The number of random starts when computing k-means fraction; default is 1.  See <code>?stats::kmeans</code> for further details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of the following entries:
</p>

<ul>
<li> <p><code>p.values</code>: a vector of p-values for the outlier test run on each sample (up until the p-value exceeds <code>p.value.threshold</code>); and
</p>
</li>
<li> <p><code>outlier.statistics.list</code>, a list of vectors containing the values of the outlier statistics calculated from the remaining samples.  The list will be of length equal to one plus the total number of outliers (i.e., the number of samples with an outlier test p-value less than <code>p.value.threshold</code>) and will contain entries <code>outlier.statistics.N</code>, where <code>N</code> is between zero and the total number of outliers.  <code>outlier.statistics.N</code> is the vector of outlier statistics after excluding the <code>N</code>th outlier sample, with <code>outlier.statistics.0</code> being for the complete transcript.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(example.data.for.calculate.p.values);
i &lt;- 1; # row index of transcript to test
calculate.p.values(
   x = example.data.for.calculate.p.values$data[i,],
   x.distribution = example.data.for.calculate.p.values$x.distribution[i],
   x.zrange.mean = example.data.for.calculate.p.values$x.zrange.mean[i],
   x.zrange.median = example.data.for.calculate.p.values$x.zrange.median[i],
   x.zrange.trimmean = example.data.for.calculate.p.values$x.zrange.trimmean[i],
   x.fraction.kmeans = example.data.for.calculate.p.values$x.fraction.kmeans[i],
   x.cosine.similarity = example.data.for.calculate.p.values$x.cosine.similarity[i],
   null.zrange.mean = example.data.for.calculate.p.values$null.zrange.mean,
   null.zrange.median = example.data.for.calculate.p.values$null.zrange.median,
   null.zrange.trimmean = example.data.for.calculate.p.values$null.zrange.trimmean,
   null.fraction.kmeans = example.data.for.calculate.p.values$null.fraction.kmeans,
   null.cosine.similarity = example.data.for.calculate.p.values$null.cosine.similarity,
   kmeans.nstart = example.data.for.calculate.p.values$kmeans.nstart
   );
</code></pre>

<hr>
<h2 id='calculate.residuals'>Calculate residuals</h2><span id='topic+calculate.residuals'></span>

<h3>Description</h3>

<p>Calculate residuals between quantiles of the input and quantiles of one of four distributions: normal, log-normal, exponential, or gamma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate.residuals(x, distribution)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calculate.residuals_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="calculate.residuals_+3A_distribution">distribution</code></td>
<td>
<p>A number corresponding to the optimal distribution of <code>x</code> as returned by, e.g., <code>identify.bic.optimal.data.distribution()</code>.  One of
</p>

<ul>
<li><p> 1 = normal,
</p>
</li>
<li><p> 2 = log-normal,
</p>
</li>
<li><p> 3 = exponential, and
</p>
</li>
<li><p> 4 = gamma.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as <code>x</code>.  Names are not retained.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate fake data.
set.seed(1234);
x &lt;- rgamma(
    n = 20,
    shape = 2,
    scale = 2
    );
names(x) &lt;- paste(
    'Sample',
    seq_along(x),
    sep = '.'
    );
calculate.residuals(
    x = x,
    distribution = 4
    );

</code></pre>

<hr>
<h2 id='detect.outliers'>Detect outliers</h2><span id='topic+detect.outliers'></span>

<h3>Description</h3>

<p>Detect outliers in normalized RNA-seq data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect.outliers(
  data,
  num.null = 1000,
  initial.screen.method = c("fdr", "p.value"),
  p.value.threshold = 0.05,
  fdr.threshold = 0.01,
  kmeans.nstart = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="detect.outliers_+3A_data">data</code></td>
<td>
<p>A matrix or data frame of normalized RNA-seq data, organized with transcripts on rows and samples on columns.  Transcript identifiers should be stored as <code>rownames(data)</code>.</p>
</td></tr>
<tr><td><code id="detect.outliers_+3A_num.null">num.null</code></td>
<td>
<p>The number of transcripts to generate when simulating from null distributions; default is 1000. We recommend using at least 10,000 iterations for publication-level results, with 100,000 or even one million iterations providing more robust estimates.</p>
</td></tr>
<tr><td><code id="detect.outliers_+3A_initial.screen.method">initial.screen.method</code></td>
<td>
<p>The statistical criterion for initial gene selection; valid options are 'FDR' and 'p-value'.</p>
</td></tr>
<tr><td><code id="detect.outliers_+3A_p.value.threshold">p.value.threshold</code></td>
<td>
<p>The p-value threshold for the outlier test; default is 0.05.  Once the p-value for a sample exceeds <code>p.value.threshold</code>, testing for that transcript ceases, and all remaining samples will have p-values equal to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="detect.outliers_+3A_fdr.threshold">fdr.threshold</code></td>
<td>
<p>The false discovery rate (FDR)-adjusted p-value threshold for determining the final count of outliers; default is 0.01.</p>
</td></tr>
<tr><td><code id="detect.outliers_+3A_kmeans.nstart">kmeans.nstart</code></td>
<td>
<p>The number of random starts when computing k-means fraction; default is 1.  See <code>?stats::kmeans</code> for further details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of the following entries:
</p>

<ul>
<li> <p><code>p.values</code>: a matrix of unadjusted p-values for the outlier test run on each transcript in <code>data</code>.
</p>
</li>
<li> <p><code>fdr</code>: a matrix of FDR-adjusted p-values for the outlier test run on each transcript in <code>data</code>.
</p>
</li>
<li> <p><code>num.outliers</code>: a vector giving the number of outliers detected for each transcript based on the threshold.
</p>
</li>
<li> <p><code>outlier.test.results.list</code>: a list of length <code>max(num.outliers) + 1</code> containing entries <code>roundN</code>, where <code>N</code> is between one and <code>max(num.outliers) + 1</code>.  <code>roundN</code> is the data frame of results for the outlier test after excluding the (N-1)th outlier sample, with <code>round1</code> being for the original data set (i.e., before excluding any outlier samples).
</p>
</li>
<li> <p><code>distributions</code>: a numeric vector indicating the optimal distribution for each transcript.  Possible values are 1 (normal), 2 (log-normal), 3 (exponential), and 4 (gamma).
</p>
</li>
<li> <p><code>initial.screen.method</code>: Specifies the statistical criterion for initial feature selection. Valid options are 'p-value' and 'FDR' (p-value used by default).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(outliers);
outliers.subset &lt;- outliers[1:10,];
results &lt;- detect.outliers(
   data = outliers.subset,
   num.null = 10
   );
</code></pre>

<hr>
<h2 id='example.data.for.calculate.p.values'>example.data.for.calculate.p.values</h2><span id='topic+example.data.for.calculate.p.values'></span>

<h3>Description</h3>

<p>Example data (list object) for testing <code>calculate.p.values()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example.data.for.calculate.p.values
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 13.
</p>

<hr>
<h2 id='identify.bic.optimal.data.distribution'>Identify optimal distribution of data</h2><span id='topic+identify.bic.optimal.data.distribution'></span>

<h3>Description</h3>

<p>Identify which of four distributions&mdash;normal, log-normal, exponential, or gamma&mdash;best fits the given data according to BIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bic.optimal.data.distribution'
identify(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identify.bic.optimal.data.distribution_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric code representing which distribution optimally fits <code>x</code>.  Possible values are
</p>

<ul>
<li><p> 1 = normal,
</p>
</li>
<li><p> 2 = log-normal,
</p>
</li>
<li><p> 3 = exponential, and
</p>
</li>
<li><p> 4 = gamma.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Generate fake data.
set.seed(1234);
x &lt;- rgamma(
    n = 20,
    shape = 2,
    scale = 2
    );
identify.bic.optimal.data.distribution(
    x = x
    );
</code></pre>

<hr>
<h2 id='identify.bic.optimal.residuals.distribution'>Identify optimal distribution of residuals</h2><span id='topic+identify.bic.optimal.residuals.distribution'></span>

<h3>Description</h3>

<p>Identify which of four distributions&mdash;normal, log-normal, exponential, or gamma&mdash;best fits the given vector of residuals according to BIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bic.optimal.residuals.distribution'
identify(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="identify.bic.optimal.residuals.distribution_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric code representing which distribution optimally fits <code>x</code>.  Possible values are
</p>

<ul>
<li><p> 1 = normal,
</p>
</li>
<li><p> 2 = log-normal,
</p>
</li>
<li><p> 3 = exponential, and
</p>
</li>
<li><p> 4 = gamma.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Generate fake data.
set.seed(1234);
x &lt;- rgamma(
    n = 20,
    shape = 2,
    scale = 2
    );
identify.bic.optimal.residuals.distribution(
    x = x
    );
</code></pre>

<hr>
<h2 id='kmeans.fraction'>k-means fraction</h2><span id='topic+kmeans.fraction'></span>

<h3>Description</h3>

<p>Given a vector of cluster assigments from <code>quantify.outliers()</code> run with <code>method = 'kmeans'</code>, compute the fraction of observations belonging to the smaller of the two clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kmeans.fraction(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kmeans.fraction_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function only considers clusters 1 and 2 even if <code>quantify.outliers()</code> was run with <code>exclude.zero = TRUE</code>.  In that case, zeros are effectively excluded from the counts used to define the k-means fraction.  See examples.
</p>


<h3>Value</h3>

<p>A number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(1, 1, 2, 2, 2, 2, 2, 2, 2, 2);
names(x) &lt;- letters[1:length(x)];
kmeans.fraction(x);
</code></pre>

<hr>
<h2 id='outlier.detection.cosine'>Cosine similarity</h2><span id='topic+outlier.detection.cosine'></span>

<h3>Description</h3>

<p>Compute cosine similarity for detection of outliers.  Generate theoretical quantiles based on the optimal distribution of the data, and compute cosine similarity between a point made up of the largest observed quantile and the largest theoretical quantile and a point on the line y = x.
.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outlier.detection.cosine(x, distribution)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="outlier.detection.cosine_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="outlier.detection.cosine_+3A_distribution">distribution</code></td>
<td>
<p>A numeric code corresponding to the optimal distribution of <code>x</code> as returned by <code>identify.bic.optimal.data.distribution()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate fake data.
set.seed(1234);
x &lt;- rgamma(
    n = 20,
    shape = 2,
    scale = 2
    );
outlier.detection.cosine(
    x = x,
    distribution = 4
    );
</code></pre>

<hr>
<h2 id='outliers'>Example data set for outlier testing</h2><span id='topic+outliers'></span>

<h3>Description</h3>

<p>Example data set for outlier testing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>outliers
</code></pre>


<h3>Format</h3>

<p>A data frame with 500 rows and 50 columns:
</p>

<dl>
<dt>S01</dt><dd><p>simulated fragments per kilobase of transcript per million fragments mapped (FPKM) values for sample 1</p>
</dd>
<dt>S02</dt><dd><p>simulated FPKM values for sample 2</p>
</dd>
<dt>S03</dt><dd><p>simulated FPKM values for sample 3</p>
</dd>
<dt>S04</dt><dd><p>simulated FPKM values for sample 4</p>
</dd>
<dt>S05</dt><dd><p>simulated FPKM values for sample 5</p>
</dd>
<dt>S06</dt><dd><p>simulated FPKM values for sample 6</p>
</dd>
<dt>S07</dt><dd><p>simulated FPKM values for sample 7</p>
</dd>
<dt>S08</dt><dd><p>simulated FPKM values for sample 8</p>
</dd>
<dt>S09</dt><dd><p>simulated FPKM values for sample 9</p>
</dd>
<dt>S10</dt><dd><p>simulated FPKM values for sample 10</p>
</dd>
<dt>S11</dt><dd><p>simulated FPKM values for sample 11</p>
</dd>
<dt>S12</dt><dd><p>simulated FPKM values for sample 12</p>
</dd>
<dt>S13</dt><dd><p>simulated FPKM values for sample 13</p>
</dd>
<dt>S14</dt><dd><p>simulated FPKM values for sample 14</p>
</dd>
<dt>S15</dt><dd><p>simulated FPKM values for sample 15</p>
</dd>
<dt>S16</dt><dd><p>simulated FPKM values for sample 16</p>
</dd>
<dt>S17</dt><dd><p>simulated FPKM values for sample 17</p>
</dd>
<dt>S18</dt><dd><p>simulated FPKM values for sample 18</p>
</dd>
<dt>S19</dt><dd><p>simulated FPKM values for sample 19</p>
</dd>
<dt>S20</dt><dd><p>simulated FPKM values for sample 20</p>
</dd>
<dt>S21</dt><dd><p>simulated FPKM values for sample 21</p>
</dd>
<dt>S22</dt><dd><p>simulated FPKM values for sample 22</p>
</dd>
<dt>S23</dt><dd><p>simulated FPKM values for sample 23</p>
</dd>
<dt>S24</dt><dd><p>simulated FPKM values for sample 24</p>
</dd>
<dt>S25</dt><dd><p>simulated FPKM values for sample 25</p>
</dd>
<dt>S26</dt><dd><p>simulated FPKM values for sample 26</p>
</dd>
<dt>S27</dt><dd><p>simulated FPKM values for sample 27</p>
</dd>
<dt>S28</dt><dd><p>simulated FPKM values for sample 28</p>
</dd>
<dt>S29</dt><dd><p>simulated FPKM values for sample 29</p>
</dd>
<dt>S30</dt><dd><p>simulated FPKM values for sample 30</p>
</dd>
<dt>S31</dt><dd><p>simulated FPKM values for sample 31</p>
</dd>
<dt>S32</dt><dd><p>simulated FPKM values for sample 32</p>
</dd>
<dt>S33</dt><dd><p>simulated FPKM values for sample 33</p>
</dd>
<dt>S34</dt><dd><p>simulated FPKM values for sample 34</p>
</dd>
<dt>S35</dt><dd><p>simulated FPKM values for sample 35</p>
</dd>
<dt>S36</dt><dd><p>simulated FPKM values for sample 36</p>
</dd>
<dt>S37</dt><dd><p>simulated FPKM values for sample 37</p>
</dd>
<dt>S38</dt><dd><p>simulated FPKM values for sample 38</p>
</dd>
<dt>S39</dt><dd><p>simulated FPKM values for sample 39</p>
</dd>
<dt>S40</dt><dd><p>simulated FPKM values for sample 40</p>
</dd>
<dt>S41</dt><dd><p>simulated FPKM values for sample 41</p>
</dd>
<dt>S42</dt><dd><p>simulated FPKM values for sample 42</p>
</dd>
<dt>S43</dt><dd><p>simulated FPKM values for sample 43</p>
</dd>
<dt>S44</dt><dd><p>simulated FPKM values for sample 44</p>
</dd>
<dt>S45</dt><dd><p>simulated FPKM values for sample 45</p>
</dd>
<dt>S46</dt><dd><p>simulated FPKM values for sample 46</p>
</dd>
<dt>S47</dt><dd><p>simulated FPKM values for sample 47</p>
</dd>
<dt>S48</dt><dd><p>simulated FPKM values for sample 48</p>
</dd>
<dt>S49</dt><dd><p>simulated FPKM values for sample 49</p>
</dd>
<dt>S50</dt><dd><p>simulated FPKM values for sample 50</p>
</dd>
</dl>


<hr>
<h2 id='quantify.outliers'>Compute quantities for outlier detection</h2><span id='topic+quantify.outliers'></span>

<h3>Description</h3>

<p>Compute quantities for use in the detection of outliers.  Specifically, compute z-scores based on the mean / standard deviation, the trimmed mean / trimmed standard deviation, or the median / median absolute deviation, or the cluster assignment from k-means with two clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantify.outliers(
  x,
  method = "mean",
  trim = 0,
  nstart = 1,
  exclude.zero = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quantify.outliers_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="quantify.outliers_+3A_method">method</code></td>
<td>
<p>A string indicating the quantities to be computed.  Possible values are
</p>

<ul>
<li> <p><code>'mean'</code> : z-scores based on mean and standard deviation or trimmed mean and trimmed standard deviation if <code>trim &gt; 0</code>,
</p>
</li>
<li> <p><code>'median'</code> : z-scores based on median and median absolute deviation, or
</p>
</li>
<li> <p><code>'kmeans'</code> : cluster assignment from k-means with two clusters.
The default is z-scores based on the mean and standard deviation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="quantify.outliers_+3A_trim">trim</code></td>
<td>
<p>A number, the fraction of observations to be trimmed from each end of <code>x</code>.  Default is no trimming.</p>
</td></tr>
<tr><td><code id="quantify.outliers_+3A_nstart">nstart</code></td>
<td>
<p>A number, for k-means clustering, the number of random initial centers for the clusters.  Default is <code>1</code>.  See <code><a href="stats.html#topic+kmeans">stats::kmeans()</a></code> for further information.</p>
</td></tr>
<tr><td><code id="quantify.outliers_+3A_exclude.zero">exclude.zero</code></td>
<td>
<p>A logical, whether zeros should be excluded (<code>TRUE</code>) or not excluded (<code>FALSE</code>, the default) from computations.  For <code>method = 'mean'</code> and <code>method = 'median'</code>, this means zeros will not be included in computing the summary statistics; for <code>method = 'kmeans'</code>, this means zeros will be placed in their own cluster, coded <code>0</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector the same size as <code>x</code> whose values are the requested quantities computed on the corresponding elements of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate fake data.
set.seed(1234);
x &lt;- rgamma(
    n = 20,
    shape = 2,
    scale = 2
    );
# Add missing values and zeros for demonstration.  Missing values are
# ignored, and zeros can be ignored with `exclude.zeros = TRUE`.
x[1:5] &lt;- NA;
x[6:10] &lt;- 0;

# Compute z-scores based on mean and standard deviation.
quantify.outliers(
    x = x,
    method = 'mean',
    trim = 0
    );
# Exclude zeros from the calculation of the mean and standard
# deviation.
quantify.outliers(
    x = x,
    method = 'mean',
    trim = 0,
    exclude.zero = TRUE
    );

# Compute z-scores based on the 5% trimmed mean and 5% trimmed
# standard deviation.
quantify.outliers(
    x = x,
    method = 'mean',
    trim = 0.05
    );

# Compute z-scores based on the median and median absolute deviation.
quantify.outliers(
    x = x,
    method = 'median'
    );

# Compute cluster assignments using k-means with k = 2.
quantify.outliers(
    x = x,
    method = 'kmeans'
    );
# Try different initial cluster assignments.
quantify.outliers(
    x = x,
    method = 'kmeans',
    nstart = 10
    );
# Assign zeros to their own cluster.
quantify.outliers(
    x = x,
    method = 'kmeans',
    exclude.zero = TRUE
    );
</code></pre>

<hr>
<h2 id='simulate.null'>Simulate from a null distribution</h2><span id='topic+simulate.null'></span>

<h3>Description</h3>

<p>Simulate transcripts from a specified null distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'null'
simulate(x, x.distribution, r, r.distribution)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.null_+3A_x">x</code></td>
<td>
<p>A numeric vector of transcripts.</p>
</td></tr>
<tr><td><code id="simulate.null_+3A_x.distribution">x.distribution</code></td>
<td>
<p>A numeric code corresponding to the optimal distribution of <code>x</code> as returned by <code>identify.bic.optimal.data.distribution()</code>.  Possible values are
</p>

<ul>
<li><p> 1 = normal,
</p>
</li>
<li><p> 2 = log-normal,
</p>
</li>
<li><p> 3 = exponential, and
</p>
</li>
<li><p> 4 = gamma.
</p>
</li></ul>
</td></tr>
<tr><td><code id="simulate.null_+3A_r">r</code></td>
<td>
<p>A numeric vector of residuals calculated for this transcript.</p>
</td></tr>
<tr><td><code id="simulate.null_+3A_r.distribution">r.distribution</code></td>
<td>
<p>A numeric code corresponding to the optimal distribution of <code>x</code> as returned by <code>identify.bic.optimal.residuals.distribution()</code>.  Possible values are the same as those for <code>x.distribution</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as <code>x</code>.  Names are not retained.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Prepare fake data.
set.seed(1234);
x &lt;- rgamma(
    n = 20,
    shape = 2,
    scale = 2
    );
names(x) &lt;- paste('Sample', seq_along(x), sep = '.');
x.dist &lt;- identify.bic.optimal.data.distribution(
    x = x
    );
r &lt;- calculate.residuals(
    x = x,
    distribution = x.dist
    );
r.trimmed &lt;- trim.sample(
    x = r
    );
r.dist &lt;- identify.bic.optimal.residuals.distribution(
    x = r.trimmed
    );
null &lt;- simulate.null(
    x = x,
    x.distribution = x.dist,
    r = r.trimmed,
    r.distribution = r.dist
    );
</code></pre>

<hr>
<h2 id='trim.sample'>Trim a vector of numbers</h2><span id='topic+trim.sample'></span>

<h3>Description</h3>

<p>Symmetrically trim a vector of numbers after sorting it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trim.sample(x, trim = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trim.sample_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="trim.sample_+3A_trim">trim</code></td>
<td>
<p>A number, the fraction of observations to be trimmed from each end of <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>length(x) &lt;= 10</code>, the function returns <code>x[2:(length(x) - 1)]</code>.
</p>


<h3>Value</h3>

<p>A sorted, trimmed copy of <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trim.sample(
    x = 1:20,
    trim = 0.05
    );
</code></pre>

<hr>
<h2 id='zrange'>Range of z-scores</h2><span id='topic+zrange'></span>

<h3>Description</h3>

<p>Compute the range of a vector of z-scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zrange(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zrange_+3A_x">x</code></td>
<td>
<p>A numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234);
x &lt;- rnorm(
    n = 10
    );
zrange(
    x = x
    );
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
