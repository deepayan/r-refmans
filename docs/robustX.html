<!DOCTYPE html><html><head><title>Help for package robustX</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {robustX}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#robustX-package'><p>eXperimental eXtraneous ... Functionality for Robust Statistics</p></a></li>
<li><a href='#BACON'><p>BACON for Regression or Multivariate Covariance Estimation</p></a></li>
<li><a href='#covNNC'><p>Robust Covariance Estimation via Nearest Neighbor Cleaning</p></a></li>
<li><a href='#L1median'><p>Compute the Multivariate L1-Median aka 'Spatial Median'</p></a></li>
<li><a href='#mvBACON'><p>BACON: Blocked Adaptive Computationally-Efficient Outlier Nominators</p></a></li>
<li><a href='#Qrot'><p>Rotation Matrix to Specific Direction</p></a></li>
<li><a href='#rbwheel'><p>Multivariate Barrow Wheel Distribution Random Vectors</p></a></li>
<li><a href='#reclas'><p>Recursive Robust Median-like Location and Scale</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'eXtra' / 'eXperimental' Functionality for Robust Statistics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-14</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Robustness &ndash; 'eXperimental', 'eXtraneous', or 'eXtraordinary'
  Functionality for Robust Statistics.  Hence methods which are not well established,
  often related to methods in package 'robustbase'.  Amazingly, 'BACON()', originally by
  Billor, Hadi, and Velleman (2000) &lt;<a href="https://doi.org/10.1016%2FS0167-9473%2899%2900101-2">doi:10.1016/S0167-9473(99)00101-2</a>&gt;
  has become established in places.  The "barrow wheel" 'rbwheel()' is from
  Stahel and Mächler (2009) &lt;<a href="https://doi.org/10.1111%2Fj.1467-9868.2009.00706.x">doi:10.1111/j.1467-9868.2009.00706.x</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, stats, utils, robustbase (&ge; 0.92-3)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, lattice, pcaPP</td>
</tr>
<tr>
<td>Enhances:</td>
<td>ICS</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-14 21:41:58 UTC; maechler</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Maechler <a href="https://orcid.org/0000-0002-8685-9910"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Werner A. Stahel [aut],
  Rolf Turner [ctb] (reclas()),
  Ueli Oetliker [ctb] (original version of BACON() and mvBACON for S+),
  Tobias Schoch [ctb] (init.sel="V2" for BACON; fix alpha)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-16 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='robustX-package'>eXperimental eXtraneous ... Functionality for Robust Statistics</h2><span id='topic+robustX-package'></span><span id='topic+robustX'></span>

<h3>Description</h3>

<p>The package <span class="pkg">robustX</span> aims to be a collection of <span class="rlang"><b>R</b></span> functionality
for robust statistics of methods and ideas that are considered
as proposals, experimental, for experiences or just too much
specialized to be part of the &ldquo;Robust Basics&rdquo; package
<span class="pkg">robustbase</span>.
</p>


<h3>Details</h3>



<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> robustX</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> 'eXtra' / 'eXperimental' Functionality for Robust Statistics</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2-7</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-06-14</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> c(person("Martin","Maechler", role=c("aut","cre"), email="maechler@stat.math.ethz.ch", comment = c(ORCID = "0000-0002-8685-9910"))
         , person("Werner A.", "Stahel", role="aut", email="stahel@stat.math.ethz.ch")
         , person("Rolf", "Turner",   role="ctb", email="r.turner@auckland.ac.nz", comment = "reclas()")
         , person("Ueli", "Oetliker", role="ctb", comment = "original version of BACON() and mvBACON for S+")
         , person("Tobias", "Schoch", role="ctb", comment = "init.sel=\"V2\" for BACON; fix alpha")
	 )</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Martin Maechler &lt;maechler@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> Robustness -- 'eXperimental', 'eXtraneous', or 'eXtraordinary'
  Functionality for Robust Statistics.  Hence methods which are not well established,
  often related to methods in package 'robustbase'.  Amazingly, 'BACON()', originally by
  Billor, Hadi, and Velleman (2000) &lt;doi:10.1016/S0167-9473(99)00101-2&gt;
  has become established in places.  The "barrow wheel" `rbwheel()` is from
  Stahel and Mächler (2009) &lt;doi:10.1111/j.1467-9868.2009.00706.x&gt;.</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> grDevices, graphics, stats, utils, robustbase (&gt;= 0.92-3)</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> MASS, lattice, pcaPP</td>
</tr>
<tr>
 <td style="text-align: left;">
Enhances: </td><td style="text-align: left;"> ICS</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 2)</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Martin Maechler [aut, cre] (&lt;https://orcid.org/0000-0002-8685-9910&gt;),
  Werner A. Stahel [aut],
  Rolf Turner [ctb] (reclas()),
  Ueli Oetliker [ctb] (original version of BACON() and mvBACON for S+),
  Tobias Schoch [ctb] (init.sel="V2" for BACON; fix alpha)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<p>Index of help topics:
</p>
<pre>
BACON                   BACON for Regression or Multivariate Covariance
                        Estimation
L1median                Compute the Multivariate L1-Median aka 'Spatial
                        Median'
Qrot                    Rotation Matrix to Specific Direction
covNNC                  Robust Covariance Estimation via Nearest
                        Neighbor Cleaning
mvBACON                 BACON: Blocked Adaptive
                        Computationally-Efficient Outlier Nominators
rbwheel                 Multivariate Barrow Wheel Distribution Random
                        Vectors
reclas                  Recursive Robust Median-like Location and Scale
robustX-package         eXperimental eXtraneous ... Functionality for
                        Robust Statistics
</pre>


<h3>Author(s)</h3>

<p>Werner Stahel, Martin Maechler and potentially others
</p>
<p>Maintainer: Martin Maechler
</p>


<h3>See Also</h3>

<p>Package <span class="pkg">robustbase</span> which it complements and on which it depends;
further package <span class="pkg">robust</span> and the whole CRAN task view on robust
statistics,
<a href="https://cran.r-project.org/view=Robust">https://cran.r-project.org/view=Robust</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pairs( rbwheel(100, 4) )
</code></pre>

<hr>
<h2 id='BACON'>BACON for Regression or Multivariate Covariance Estimation</h2><span id='topic+BACON'></span><span id='topic+.lmBACON'></span>

<h3>Description</h3>

<p>BACON, short for &lsquo;<b>B</b>locked <b>A</b>daptive
<b>C</b>omputationally-Efficient <b>O</b>utlier <b>N</b>ominators&rsquo;,
is a somewhat robust algorithm (set), with an implementation for
regression or multivariate covariance estimation.
</p>
<p><code>BACON()</code> applies the multivariate (covariance estimation)
algorithm, using <code><a href="#topic+mvBACON">mvBACON</a>(x)</code> in any case, and when
<code>y</code> is not <code>NULL</code> adds a regression iteration phase,
using the auxiliary <code>.lmBACON()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BACON(x, y = NULL, intercept = TRUE,
      m = min(collect * p, n * 0.5),
      init.sel = c("Mahalanobis", "dUniMedian", "random", "manual", "V2"),
      man.sel, init.fraction = 0, collect = 4,
      alpha = 0.05, alphaLM = alpha, maxsteps = 100, verbose = TRUE)

## *Auxiliary* function:
.lmBACON(x, y, intercept = TRUE,
         init.dis, init.fraction = 0, collect = 4,
         alpha = 0.05, maxsteps = 100, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BACON_+3A_x">x</code></td>
<td>
<p>a multivariate matrix of dimension [n x p]
considered as containing no missing values.</p>
</td></tr>
<tr><td><code id="BACON_+3A_y">y</code></td>
<td>
<p>the response (n vector) in the case of regression, or
<code>NULL</code> for the multivariate case, where just
<code><a href="#topic+mvBACON">mvBACON</a>()</code> is returned.</p>
</td></tr>
<tr><td><code id="BACON_+3A_intercept">intercept</code></td>
<td>
<p>logical indicating if an intercept has to be used
for the regression.</p>
</td></tr>
<tr><td><code id="BACON_+3A_m">m</code></td>
<td>
<p>integer in <code>1:n</code> specifying the size of the initial basic
subset; used only when <code>init.sel</code> is not <code>"manual"</code>; see
<code><a href="#topic+mvBACON">mvBACON</a></code>.</p>
</td></tr>
<tr><td><code id="BACON_+3A_init.sel">init.sel</code></td>
<td>
<p>character string, specifying the initial selection
mode; see <code><a href="#topic+mvBACON">mvBACON</a></code>.</p>
</td></tr>
<tr><td><code id="BACON_+3A_man.sel">man.sel</code></td>
<td>
<p>only when <code>init.sel == "manual"</code>, the indices of
observations determining the initial basic subset (and <code>m &lt;-
      length(man.sel)</code>).</p>
</td></tr>
<tr><td><code id="BACON_+3A_init.dis">init.dis</code></td>
<td>
<p>the distances of the x matrix used for the initial
subset determined by <code><a href="#topic+mvBACON">mvBACON</a></code>.</p>
</td></tr>
<tr><td><code id="BACON_+3A_init.fraction">init.fraction</code></td>
<td>
<p>if this parameter is &gt; 0 then the tedious steps
of selecting the initial subset are skipped and an initial subset of
size n * init.fraction is chosen (with smallest dis)</p>
</td></tr>
<tr><td><code id="BACON_+3A_collect">collect</code></td>
<td>
<p>numeric factor chosen by the user to define the size of
the initial subset (p * collect)</p>
</td></tr>
<tr><td><code id="BACON_+3A_alpha">alpha</code></td>
<td>
<p>number in <code class="reqn">(0, 1)</code> determining the cutoff value for the
Mahalanobis distances (multivariate outlier nomination in
<code><a href="#topic+mvBACON">mvBACON</a>()</code>), or the discrepancies for regression, see <code>alphaLM</code>.</p>
</td></tr>
<tr><td><code id="BACON_+3A_alphalm">alphaLM</code></td>
<td>
<p>number in <code class="reqn">(0, 1)</code> where a <code>1-alphaM</code> t-quantile
is the cutoff for the discrepancies (for regression, <code>.lmBACON()</code>); see details.</p>
</td></tr>
<tr><td><code id="BACON_+3A_maxsteps">maxsteps</code></td>
<td>
<p>the maximal number of iteration steps
(to prevent infinite loops)</p>
</td></tr>
<tr><td><code id="BACON_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if messages are printed which trace
progress of the algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notably about the initial selection mode, <code>init.sel</code>, see its
description in the <code><a href="#topic+mvBACON">mvBACON</a></code> arguments list.
</p>
<p>The choice of <code>alpha</code> and <code>alphaLM</code>:
</p>

<ul>
<li><p> Multivariate outlier nomination: see the Details section of
<code><a href="#topic+mvBACON">mvBACON</a></code>.
</p>
</li>
<li><p> Regression: Let <code class="reqn">t_r(\alpha)</code> denote the <code class="reqn">1-\alpha</code> quantile of the
Student <code class="reqn">t</code>-distribution with <code class="reqn">r</code> degrees of freedom,
where <code class="reqn">r</code> is the number of elements in the current subset;
e.g., <code class="reqn">t_r(0.05)</code> is the 0.95 quantile.  Following Billor et
al. (2000), the cutoff value for the discrepancies is defined
as <code class="reqn">t_r(\alpha/(2r + 2))</code>, and
they use <code class="reqn">\alpha=0.05</code>.   Note that this is argument
<code>alphaLM</code> (defualting to <code>alpha</code>) for <code>BACON()</code>.
</p>
</li></ul>



<h3>Value</h3>

<p><code>BACON(x,y,..)</code> (for regression) returns a <code><a href="base.html#topic+list">list</a></code> with
components
</p>
<table>
<tr><td><code>subset</code></td>
<td>
<p>the observation indices (in <code>1:n</code>) denoting a
subset of &ldquo;good&rdquo; supposedly outlier-free observations.</p>
</td></tr>
<tr><td><code>tis</code></td>
<td>
<p>the <code class="reqn">t_i(y_m, X_m)</code> of eq (6) in the
reference; the clean &ldquo;basic subset&rdquo; in the algorithm is defined
the observations <code class="reqn">i</code> with the smallest <code class="reqn">|t_i|</code>, and the
<code class="reqn">t_i</code> can be regarded as scaled predicted errors.</p>
</td></tr>
<tr><td><code>mv.dis</code></td>
<td>
<p>the (final) discrepancies or distances of
<code>mvBACON()</code>.</p>
</td></tr>
<tr><td><code>mv.subset</code></td>
<td>
<p>the &ldquo;good&rdquo; subset from <code><a href="#topic+mvBACON">mvBACON</a>()</code>,
used to start the regression iterations.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>&ldquo;BACON&rdquo; was also chosen in honor of Francis Bacon:
</p>
<p><em>Whoever knows the ways of Nature will more easily notice her deviations;
and, on the other hand, whoever knows her deviations will more accurately
describe her ways.</em>
<br /> Francis Bacon (1620), Novum Organum II 29.
</p>


<h3>Author(s)</h3>

<p>Ueli Oetliker, Swiss Federal Statistical Office, for S-plus 5.1;
25.05.2001; modified six times till 17.6.2001.
</p>
<p>Port to <span class="rlang"><b>R</b></span>, testing etc, by Martin Maechler.
Daniel Weeks (at pitt.edu) proposed a fix to a long standing buglet in
<code>GiveTis()</code> computing the <code class="reqn">t_i</code>, which was further improved
Maechler, for <a href="https://CRAN.R-project.org/package=robustX"><span class="pkg">robustX</span></a> version 1.2-3 (Feb. 2019).
</p>
<p>Correction of <code>alpha</code> default, from 0.95 to 0.05, by Tobias Schoch,
see <code><a href="#topic+mvBACON">mvBACON</a></code>.
</p>


<h3>References</h3>

<p>Billor, N., Hadi, A. S., and Velleman , P. F. (2000).
BACON: Blocked Adaptive Computationally-Efficient Outlier Nominators;
<em>Computational Statistics and Data Analysis</em> <b>34</b>, 279&ndash;298.
<a href="https://doi.org/10.1016/S0167-9473%2899%2900101-2">doi:10.1016/S0167-9473(99)00101-2</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvBACON">mvBACON</a></code>, the multivariate version of the BACON
algorithm.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(starsCYG, package = "robustbase")
## Plot simple data and fitted lines
plot(starsCYG)
lmST &lt;- lm(log.light ~ log.Te, data = starsCYG)
abline(lmST, col = "gray") # least squares line
str(B.ST &lt;- with(starsCYG,  BACON(x = log.Te, y = log.light)))
## 'subset': A good set of of points (to determine regression):
colB &lt;- adjustcolor(2, 1/2)
points(log.light ~ log.Te, data = starsCYG, subset = B.ST$subset,
       pch = 19, cex = 1.5, col = colB)
## A BACON-derived line:
lmB &lt;- lm(log.light ~ log.Te, data = starsCYG, subset = B.ST$subset)
abline(lmB, col = colB, lwd = 2)

require(robustbase)
(RlmST &lt;- lmrob(log.light ~ log.Te, data = starsCYG))
abline(RlmST, col = "blue")
</code></pre>

<hr>
<h2 id='covNNC'>Robust Covariance Estimation via Nearest Neighbor Cleaning</h2><span id='topic+covNNC'></span><span id='topic+cov.nnve'></span>

<h3>Description</h3>

<p><code>covNNC()</code> estimates robust covariance/dispersion matrices by the
nearest neighbor variance estimation (NNVE) or (rather)
&ldquo;Nearest Neighbor Cleaning&rdquo; (NNC) method of Wang and Raftery
(2002, <em>JASA</em>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>covNNC(X, k = min(12, n - 1), pnoise = 0.05, emconv = 0.001,
       bound = 1.5, extension = TRUE, devsm = 0.01)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="covNNC_+3A_x">X</code></td>
<td>
<p>matrix in which each row represents an observation or point
and each column represents a variable.</p>
</td></tr>
<tr><td><code id="covNNC_+3A_k">k</code></td>
<td>
<p>desired number of nearest neighbors (default is 12)</p>
</td></tr>
<tr><td><code id="covNNC_+3A_pnoise">pnoise</code></td>
<td>
<p>percent of added noise</p>
</td></tr>
<tr><td><code id="covNNC_+3A_emconv">emconv</code></td>
<td>
<p>convergence tolerance for EM</p>
</td></tr>
<tr><td><code id="covNNC_+3A_bound">bound</code></td>
<td>
<p>value used to identify surges in variance caused by
outliers wrongly included as signal points (<code>bound = 1.5</code>
means a 50 percent increase)</p>
</td></tr>
<tr><td><code id="covNNC_+3A_extension">extension</code></td>
<td>
<p>whether or not to continue after reaching the last
chi-square distance.  The default is to continue,
which is indicated by setting <code>extension = TRUE</code>.</p>
</td></tr>
<tr><td><code id="covNNC_+3A_devsm">devsm</code></td>
<td>
<p>when <code>extension = TRUE</code>, the algorithm stops if the
relative difference in variance is less than <code>devsm</code>.
(default is 0.01)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>cov</code></td>
<td>
<p>covariance matrix</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>mean vector</p>
</td></tr>
<tr><td><code>postprob</code></td>
<td>
<p>posterior probability</p>
</td></tr>
<tr><td><code>classification</code></td>
<td>
<p>classification (0=noise otherwise 1) obtained
by rounding <code>postprob</code></p>
</td></tr>
<tr><td><code>innc</code></td>
<td>
<p>list of initial nearest neighbor cleaning results
(components are the covariance, mean, posterior probability
and classification)</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Terms of use: GPL version 2 or newer.
</p>
<p>MM: Even though <code>covNNC()</code> is backed by a serious scientific
publication, I cannot recommend its use at all.
</p>


<h3>Author(s)</h3>

<p>Naisyin Wang <a href="mailto:nwang@stat.tamu.edu">nwang@stat.tamu.edu</a> and
Adrian Raftery <a href="mailto:raftery@stat.washington.edu">raftery@stat.washington.edu</a>
with contributions from
Chris Fraley <a href="mailto:fraley@stat.washington.edu">fraley@stat.washington.edu</a>.
</p>
<p><code>covNNC()</code>, then named <code>cov.nnve()</code>, used to be (the only
function) in CRAN package <span class="pkg">covRobust</span> (2003), which was archived
in 2012.
</p>
<p>Martin Maechler allowed <code>ncol(X) == 1</code>,
sped up the original code, by reducing the amount of scaling;
further, the accuracy was increased (using internal <code>q.dDk()</code>).
The original version is available, unexported as
<code>robustX:::covNNC1</code>.
</p>


<h3>References</h3>

<p>Wang, N. and Raftery, A. (2002)
Nearest neighbor variance estimation (NNVE):
Robust covariance estimation via nearest neighbor cleaning (with discussion).
<em>Journal of the American Statistical Association</em> <b>97</b>, 994&ndash;1019.
</p>
<p>See also University of Washington Statistics Technical Report 368 (2000);
see at 
https://stat.uw.edu/research/tech-reports/ 
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+cov.mcd">cov.mcd</a></code> from package <a href="https://CRAN.R-project.org/package=MASS"><span class="pkg">MASS</span></a>;
<code><a href="robustbase.html#topic+covMcd">covMcd</a></code>, and <code><a href="robustbase.html#topic+covOGK">covOGK</a></code>
from package <a href="https://CRAN.R-project.org/package=robustbase"><span class="pkg">robustbase</span></a>.
</p>
<p>The whole package <a href="https://CRAN.R-project.org/package=rrcov"><span class="pkg">rrcov</span></a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(iris)
covNNC(iris[-5])

data(hbk, package="robustbase")
hbk.x &lt;- data.matrix(hbk[, 1:3])
covNNC(hbk.x)
</code></pre>

<hr>
<h2 id='L1median'>Compute the Multivariate L1-Median aka 'Spatial Median'</h2><span id='topic+L1median'></span><span id='topic+optimMethods'></span><span id='topic+nlminbMethods'></span>

<h3>Description</h3>

<p>Compute the multivariate <code class="reqn">L_1</code>-median <code class="reqn">m</code>, also called
&ldquo;Spatial Median&rdquo;, i.e., the
minimizer of
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^n \| x_i - m \|,</code>
</p>

<p>where <code class="reqn">\|u\| = \sqrt{\sum_{j=1}^p u_j^2}</code>.
</p>
<p>As a convex problem, there's always a global minimizer, computable not
by a closed formula but rather an iterative search.  As the
(partial) first derivatives of the objective function is
undefined at the data points, the minimization is not entirely trivial.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>L1median(X, m.init = colMedians(X), weights = NULL,
	method = c("nlm", "HoCrJo", "VardiZhang", optimMethods, nlminbMethods),
	pscale = apply(abs(centr(X, m.init)), 2, mean, trim = 0.40),
	tol = 1e-08, maxit = 200, trace = FALSE,
	zero.tol = 1e-15, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="L1median_+3A_x">X</code></td>
<td>
<p>numeric <code><a href="base.html#topic+matrix">matrix</a></code> of dimension <code class="reqn">n \times p</code>,
say.</p>
</td></tr>
<tr><td><code id="L1median_+3A_m.init">m.init</code></td>
<td>
<p>starting value for <code class="reqn">m</code>; typically and by default the
coordinatewise median.</p>
</td></tr>
<tr><td><code id="L1median_+3A_weights">weights</code></td>
<td>
<p>optional numeric vector of non-negative weights;
currently only implemented for method <code>"VardiZhang"</code>.</p>
</td></tr>
<tr><td><code id="L1median_+3A_method">method</code></td>
<td>
<p>character string specifying the computational method,
i.e., the algorithm to be used (can be abbreviated).</p>
</td></tr>
<tr><td><code id="L1median_+3A_pscale">pscale</code></td>
<td>
<p>numeric p-vector of positive numbers,
the coordinate-wise scale (typical size of
<code class="reqn">\delta{m_j}</code>), where <code class="reqn">m</code> is the problem's solution.</p>
</td></tr>
<tr><td><code id="L1median_+3A_tol">tol</code></td>
<td>
<p>positive number specifying the (relative) convergence
tolerance.</p>
</td></tr>
<tr><td><code id="L1median_+3A_maxit">maxit</code></td>
<td>
<p>positive integer specifying the maximal number of
iterations (before the iterations are stopped prematurely if necessary).</p>
</td></tr>
<tr><td><code id="L1median_+3A_trace">trace</code></td>
<td>
<p>an integer specifying the tracing level of the
iterations; <code>0</code> does no tracing</p>
</td></tr>
<tr><td><code id="L1median_+3A_zero.tol">zero.tol</code></td>
<td>
<p>for method <code>"VardiZhang"</code>, a small positive
number specifying the tolerance for determining that the iteration
is &lsquo;exactly&rsquo; at a data point (which is a singularity).</p>
</td></tr>
<tr><td><code id="L1median_+3A_...">...</code></td>
<td>
<p>optional arguments to <code><a href="stats.html#topic+nlm">nlm</a>()</code> or the
<code>control</code> (list) arguments of <code><a href="stats.html#topic+optim">optim</a>()</code>, or
<code><a href="stats.html#topic+nlminb">nlminb</a>()</code>, respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, we have to refer to the &ldquo;References&rdquo; below.

</p>


<h3>Value</h3>

<p>currently the result <em>depends</em> strongly on the <code>method</code>
used.
</p>
<p>FIXME. This will change considerably.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler.  Method <code>"HoCrJo"</code> is mostly based on Kristel
Joossens' <span class="rlang"><b>R</b></span> function, implementing Hossjer and Croux (1995).
</p>


<h3>References</h3>

<p>Hossjer and Croux, C. (1995).
Generalizing Univariate Signed Rank Statistics for Testing
and Estimating a Multivariate Location Parameter.
<em>Non-parametric Statistics</em> <b>4</b>, 293&ndash;308.
</p>
<p>Vardi, Y. and Zhang, C.-H. (2000).
The multivariate <code class="reqn">L_1</code>-median and associated data depth.
<em>Proc. National Academy of Science</em> <b>97</b>(4), 1423&ndash;1426.
</p>
<p>Fritz, H. and Filzmoser, P. and Croux, C. (2012)
A comparison of algorithms for the multivariate L1-median.
<em>Computational Statistics</em> <b>27</b>, 393&ndash;410.
</p>
<p>Kent, J. T., Er, F. and Constable, P. D. L. (2015)
Algorithms for the spatial median;, in K. Nordhausen and
S. Taskinen (eds), <em>Modern Nonparametric, Robust and Multivariate
Methods: Festschrift in Honour of Hannu Oja</em>,
Springer International Publishing, chapter 12, pp. 205&ndash;224.
<a href="https://doi.org/10.1007/978-3-319-22404-6_12">doi:10.1007/978-3-319-22404-6_12</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+median">median</a></code>, <code><a href="robustbase.html#topic+covMcd">covMcd</a></code>
</p>
<p>CRAN package <a href="https://CRAN.R-project.org/package=pcaPP"><span class="pkg">pcaPP</span></a> added more L1 median methods,
re-implementing our <span class="rlang"><b>R</b></span> versions in C++, see Fritz et al.(2012) and
e.g., <code><a href="pcaPP.html#topic+l1median_NLM">l1median_NLM</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stackloss)
L1median(stackloss)
L1median(stackloss, method = "HoCrJo")

## Explore all methods:
m &lt;- eval(formals(L1median)$method); allMeths &lt;- m[m != "Brent"]
L1m &lt;- sapply(allMeths, function(meth) L1median(stackloss, method = meth))
## --&gt; with a warning for L-BFGS-B
str(L1m)
pm &lt;- sapply(L1m, function(.) if(is.numeric(.)) . else .$par)
t(pm) # SANN differs a bit; same objective ?
</code></pre>

<hr>
<h2 id='mvBACON'>BACON: Blocked Adaptive Computationally-Efficient Outlier Nominators</h2><span id='topic+mvBACON'></span>

<h3>Description</h3>

<p>This function performs an outlier identification
algorithm to the data in the x array [n x p] and y vector [n]
following the lines described by Hadi et al. for their
BACON outlier procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvBACON(x, collect = 4, m = min(collect * p, n * 0.5), alpha = 0.05,
        init.sel = c("Mahalanobis", "dUniMedian", "random", "manual", "V2"),
        man.sel, maxsteps = 100, allowSingular = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvBACON_+3A_x">x</code></td>
<td>
<p>numeric matrix (of dimension <code class="reqn">[n x p]</code>),
not supposed to contain missing values.</p>
</td></tr>
<tr><td><code id="mvBACON_+3A_collect">collect</code></td>
<td>
<p>a multiplication factor <code class="reqn">c</code>, when <code>init.sel</code> is not
<code>"manual"</code>, to define <code class="reqn">m</code>, the size of the initial basic
subset, as <code class="reqn">m := c \cdot p</code>, in practice,
<code>m &lt;- min(p * collect, n/2)</code>.</p>
</td></tr>
<tr><td><code id="mvBACON_+3A_m">m</code></td>
<td>
<p>integer in <code>1:n</code> specifying the <em>size</em> of the initial basic
subset; used only when <code>init.sel</code> is not <code>"manual"</code>.</p>
</td></tr>
<tr><td><code id="mvBACON_+3A_alpha">alpha</code></td>
<td>
<p>determines the cutoff value for the Mahalanobis
distances (see details).</p>
</td></tr>
<tr><td><code id="mvBACON_+3A_init.sel">init.sel</code></td>
<td>
<p>character string, specifying the initial selection
mode; implemented modes are:
</p>

<dl>
<dt>&quot;Mahalanobis&quot;</dt><dd><p>based on Mahalanobis distances (default); the
version <code class="reqn">V1</code> of the reference; affine invariant but not robust.</p>
</dd>
<dt>&quot;dUniMedian&quot;</dt><dd><p>based on the distances from the
<b>uni</b>variate medians; similar to the version <code class="reqn">V2</code> of the reference;
robust but not affine invariant.</p>
</dd>
<dt>&quot;random&quot;</dt><dd><p>based on a random selection, i.e., reproducible only
via <code><a href="base.html#topic+set.seed">set.seed</a>()</code>.</p>
</dd>
<dt>&quot;manual&quot;</dt><dd><p>based on manual selection; in this case, a vector
<code>man.sel</code> containing the indices of the selected
observations must be specified.</p>
</dd>
<dt>&quot;V2&quot;</dt><dd><p>based on the Euclidean norm from the <b>uni</b>variate
medians; this is the version <code class="reqn">V2</code> of the reference; robust but not
affine invariant.</p>
</dd>
</dl>

<p><code>"Mahalanobis"</code> and <code>"V2"</code> where proposed by Hadi
and the other authors in the reference as versions &lsquo;V_1&rsquo;
and &lsquo;V_2&rsquo;, as well as <code>"manual"</code>,
while <code>"random"</code> is provided in order to study the behaviour of
BACON.  Option <code>"dUniMedian"</code> is similar to <code>"V2"</code> and is due
to U. Oetliker.
</p>
</td></tr>
<tr><td><code id="mvBACON_+3A_man.sel">man.sel</code></td>
<td>
<p>only when <code>init.sel == "manual"</code>, the indices of
observations determining the initial basic subset (and <code>m &lt;-
      length(man.sel)</code>).</p>
</td></tr>
<tr><td><code id="mvBACON_+3A_maxsteps">maxsteps</code></td>
<td>
<p>maximal number of iteration steps.</p>
</td></tr>
<tr><td><code id="mvBACON_+3A_allowsingular">allowSingular</code></td>
<td>
<p>logical indicating a solution should be sought
also when no matrix of rank <code class="reqn">p</code> is found.</p>
</td></tr>
<tr><td><code id="mvBACON_+3A_verbose">verbose</code></td>
<td>
<p>logical indicating if messages are printed which trace
progress of the algorithm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Remarks on the tuning parameter <code>alpha</code>: Let <code class="reqn">\chi^2_p</code>
be a chi-square distributed random variable with <code class="reqn">p</code> degrees
of freedom (<code class="reqn">p</code> is the number of variables; <code class="reqn">n</code> is the
number of observations).  Denote the <code class="reqn">(1-\alpha)</code> quantile by
<code class="reqn">\chi^2_p(\alpha)</code>, e.g., <code class="reqn">\chi^2_p(0.05)</code> is the 0.95 quantile.
Following Billor et al. (2000), the cutoff value for the
Mahalanobis distances is defined as <code class="reqn">\chi_p(\alpha/n)</code> (the square
root of <code class="reqn">chi^2_p</code>) times a correction factor <code class="reqn">c(n,p)</code>,
<code class="reqn">n</code> and <code class="reqn">p</code>,
and they use <code class="reqn">\alpha=0.05</code>.
</p>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+list">list</a></code> with components
</p>
<table>
<tr><td><code>subset</code></td>
<td>
<p>logical vector of length <code>n</code> where the <code>i</code>-th
entry is true iff the i-th observation is part of the final selection.</p>
</td></tr>
<tr><td><code>dis</code></td>
<td>
<p>numeric vector of length <code>n</code> with the (Mahalanobis)
distances.</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p><code class="reqn">p \times p</code> matrix, the corresponding robust
estimate of covariance.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ueli Oetliker, Swiss Federal Statistical Office, for S-plus 5.1.
Port to <span class="rlang"><b>R</b></span>, testing etc, by Martin Maechler;
Init selection <code>"V2"</code> and correction of default <code>alpha</code> from 0.95 to 0.05,
by Tobias Schoch, FHNW Olten, Switzerland.
</p>


<h3>References</h3>

<p>Billor, N., Hadi, A. S., and Velleman , P. F. (2000).
BACON: Blocked Adaptive Computationally-Efficient Outlier Nominators;
<em>Computational Statistics and Data Analysis</em> <b>34</b>, 279&ndash;298.
<a href="https://doi.org/10.1016/S0167-9473%2899%2900101-2">doi:10.1016/S0167-9473(99)00101-2</a>
</p>


<h3>See Also</h3>

<p><code><a href="robustbase.html#topic+covMcd">covMcd</a></code> for a high-breakdown (but more computer
intensive) method;
<code><a href="#topic+BACON">BACON</a></code> for a &ldquo;generalization&rdquo;, notably to
<em>regression</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> require(robustbase) # for example data and covMcd():
 ## simple 2D example :
 plot(starsCYG, main = "starsCYG  data  (n=47)")
 B.st &lt;- mvBACON(starsCYG)
 points(starsCYG[ ! B.st$subset,], pch = 4, col = 2, cex = 1.5)
 stopifnot(identical(which(!B.st$subset), c(7L,11L,20L,30L,34L)))
 ## finds the 4 clear outliers (and 1 "borderline");
 ## it does not find obs. 14 which is an outlier according to covMcd(.)

 iniS &lt;- setNames(, eval(formals(mvBACON)$init.sel)) # all initialization methods, incl "random"
 set.seed(123)
 Bs.st &lt;- lapply(iniS[iniS != "manual"], function(s)
                 mvBACON(as.matrix(starsCYG), init.sel = s, verbose=FALSE))
 ii &lt;- - match("steps", names(Bs.st[[1]]))
 Bs.s1 &lt;- lapply(Bs.st, `[`, ii)
 stopifnot(exprs = {
    length(Bs.s1) &gt;= 4
    length(unique(Bs.s1)) == 1 # all 4 methods give the same
 })

 ## Example where "dUniMedian" and "V2" differ :
 data(pulpfiber, package="robustbase")
 dU.plp &lt;- mvBACON(as.matrix(pulpfiber), init.sel = "dUniMedian")
 V2.plp &lt;- mvBACON(as.matrix(pulpfiber), init.sel = "V2")
 (oU &lt;- which(! dU.plp$subset))
 (o2 &lt;- which(! V2.plp$subset))
 stopifnot(setdiff(o2, oU) %in% c(57L,58L,59L,62L))
 ## and 57, 58, 59, and 62 *are* outliers according to covMcd(.)

 ## 'coleman' from pkg 'robustbase'
 coleman.x &lt;- data.matrix(coleman[, 1:6])
 Cc &lt;- covMcd (coleman.x) # truly robust
 summary(Cc) # -&gt; 6 outliers (1,3,10,12,17,18)
 Cb1 &lt;- mvBACON(coleman.x) ##-&gt; subset is all TRUE hmm??
 Cb2 &lt;- mvBACON(coleman.x, init.sel = "dUniMedian")
 stopifnot(all.equal(Cb1, Cb2))
 ## try 20 different random starts:
 Cb.r &lt;- lapply(1:20, function(i) { set.seed(i)
                     mvBACON(coleman.x, init.sel="random", verbose=FALSE) })
 nm &lt;- names(Cb.r[[1]]); nm &lt;- nm[nm != "steps"]
 all(eqC &lt;- sapply(Cb.r[-1], function(CC) all.equal(CC[nm], Cb.r[[1]][nm]))) # TRUE
 ## --&gt; BACON always  breaks down, i.e., does not see the outliers here
 
 ## breaks down even when manually starting with all the non-outliers:
 Cb.man &lt;- mvBACON(coleman.x, init.sel = "manual",
                   man.sel = setdiff(1:20, c(1,3,10,12,17,18)))
 which( ! Cb.man$subset) # the outliers according to mvBACON : _none_
</code></pre>

<hr>
<h2 id='Qrot'>Rotation Matrix to Specific Direction</h2><span id='topic+Qrot'></span>

<h3>Description</h3>

<p>Construct the <code class="reqn">p \times p</code> rotation matrix that rotates the
unit vector (1,0,....0), i.e., the <code class="reqn">x_1</code>-axis,
onto (1,1,1,...1)/<code class="reqn">\sqrt{p}</code>, or more generally to
<code class="reqn">u/{\left\|u\right\|}</code>  (<code class="reqn">u :=</code><code>unit.image</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qrot(p, transpose = FALSE, unit.image = rep(1, p))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Qrot_+3A_p">p</code></td>
<td>
<p>integer; the dimension (of the vectors involved).</p>
</td></tr>
<tr><td><code id="Qrot_+3A_transpose">transpose</code></td>
<td>
<p>logical indicating if the <em>transposed</em> matrix is
to returned.</p>
</td></tr>
<tr><td><code id="Qrot_+3A_unit.image">unit.image</code></td>
<td>
<p>numeric vector of length <code class="reqn">p</code> onto which the unit
vector should be rotated; defaults to <em>&ldquo;the diagonal&rdquo;</em>
<code class="reqn">\propto</code><code class="reqn">(1,1,1,...,1)</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="Matrix.html#topic+qr">qr</a></code> decomposition is used for a Gram-Schmitt basis
orthogonalization.
</p>


<h3>Value</h3>

<p><code class="reqn">p \times p</code> orthogonal matrix which rotates
<code class="reqn">(1,0,...,0)</code> onto a vector proportional to <code>unit.image</code>.
</p>


<h3>Author(s)</h3>

<p>Martin Maechler</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+qr">qr</a></code>, matrix (and vector) multiplication,
<code><a href="Matrix.html#topic++25+2A+25">%*%</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Q &lt;- Qrot(6)
zapsmall(crossprod(Q)) # 6 x 6 unity &lt;==&gt; Q'Q = I  &lt;==&gt; Q orthogonal

if(require("MASS")) {
  Qt &lt;- Qrot(6, transpose = TRUE)
  stopifnot(all.equal(Qt, t(Q)))
  fractions(Qt ^2) # --&gt; 1/6  1/30  etc, in an almost lower-triagonal matrix
}
</code></pre>

<hr>
<h2 id='rbwheel'>Multivariate Barrow Wheel Distribution Random Vectors</h2><span id='topic+rbwheel'></span>

<h3>Description</h3>

<p>Generate <code class="reqn">p</code>-dimensional random vectors according to Stahel's
Barrow Wheel Distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rbwheel(n, p, frac = 1/p, sig1 = 0.05, sig2 = 1/10,
        rGood = rnorm,
        rOut = function(n) sqrt(rchisq(n, p - 1)) * sign(runif(n, -1, 1)),
        U1 = rep(1, p),
        scaleAfter = TRUE, scaleBefore = FALSE, spherize = FALSE,
        fullResult = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rbwheel_+3A_n">n</code></td>
<td>
<p>integer, specifying the sample size.</p>
</td></tr>
<tr><td><code id="rbwheel_+3A_p">p</code></td>
<td>
<p>integer, specifying the dimension (aka number of variables).</p>
</td></tr>
<tr><td><code id="rbwheel_+3A_frac">frac</code></td>
<td>
<p>numeric, the proportion of outliers.
The default, <code class="reqn">1/p</code>, corresponds to the (asymptotic) breakdown
point of M-estimators.</p>
</td></tr>
<tr><td><code id="rbwheel_+3A_sig1">sig1</code></td>
<td>
<p>thickness of the &ldquo;wheel&rdquo;, (<code class="reqn">= \sigma</code>
<code>(good[,1])</code>), a non-negative numeric.</p>
</td></tr>
<tr><td><code id="rbwheel_+3A_sig2">sig2</code></td>
<td>
<p>thickness of the &ldquo;axis&rdquo; (compared to 1).</p>
</td></tr>
<tr><td><code id="rbwheel_+3A_rgood">rGood</code></td>
<td>
<p>function; the generator for &ldquo;good&rdquo; observations.</p>
</td></tr>
<tr><td><code id="rbwheel_+3A_rout">rOut</code></td>
<td>
<p>function, generating the outlier observations.</p>
</td></tr>
<tr><td><code id="rbwheel_+3A_u1">U1</code></td>
<td>
<p>p-vector to which <code class="reqn">(1,0,\dots,0)</code> is rotated.</p>
</td></tr>
<tr><td><code id="rbwheel_+3A_scaleafter">scaleAfter</code></td>
<td>
<p>logical indicating if the matrix is re-scaled <em>after</em>
rotation (via <code><a href="base.html#topic+scale">scale</a>()</code>)..  Default <code>TRUE</code>; note
that this used to be false by default in the first public version.</p>
</td></tr>
<tr><td><code id="rbwheel_+3A_scalebefore">scaleBefore</code></td>
<td>
<p>logical indicating if the matrix is re-scaled before
rotation (via <code><a href="base.html#topic+scale">scale</a>()</code>).</p>
</td></tr>
<tr><td><code id="rbwheel_+3A_spherize">spherize</code></td>
<td>
<p>logical indicating if the matrix is to be
&ldquo;spherized&rdquo;, i.e., rotated and scaled to have empirical
covariance <code class="reqn">I_p</code>.  This means that the principal components are
used (before rotation).</p>
</td></tr>
<tr><td><code id="rbwheel_+3A_fullresult">fullResult</code></td>
<td>
<p>logical indicating if in addition to the <code class="reqn">n
      \times p</code> matrix, some intermediate quantities are returned as
well.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>....  
</p>


<h3>Value</h3>

<p>By default (when <code>fullResult</code> is <code>FALSE</code>), an
<code class="reqn">n \times p</code> matrix of <code class="reqn">n</code> sample vectors of the
<code class="reqn">p</code> dimensional barrow wheel distribution, with an attribute,
<code>n1</code> specifying the exact number of &ldquo;good&rdquo; observations,
<code class="reqn">n1 \approx (1-f)\cdot n</code>,  <code class="reqn">f = </code><code>frac</code>.
</p>
<p>If <code>fullResult</code> is <code>TRUE</code>, a list with components
</p>
<table>
<tr><td><code>X</code></td>
<td>
<p>the <code class="reqn">n \times p</code> matrix of above,
<code>X = X0 %*% A</code>, where <code>A &lt;- <a href="#topic+Qrot">Qrot</a>(p, u = U1)</code>, and
<code>X0</code> is the corresponding matrix before rotation, see below.</p>
</td></tr>
<tr><td><code>X0</code></td>
<td>
<p>.........</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>the <code class="reqn">p \times p</code> rotation matrix, see above.</p>
</td></tr>
<tr><td><code>n1</code></td>
<td>
<p>the number of &ldquo;good&rdquo; observations, see above.</p>
</td></tr>
<tr><td><code>n2</code></td>
<td>
<p>the number of &ldquo;outlying&rdquo; observations, <code class="reqn">n2 = n - n1</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Werner Stahel and Martin Maechler</p>


<h3>References</h3>

<p><a href="http://stat.ethz.ch/people/maechler/robustness">http://stat.ethz.ch/people/maechler/robustness</a>

</p>
<p>Stahel, W.~A. and Mächler, M. (2009).
Comment on &ldquo;invariant co-ordinate selection&rdquo;,
<em>Journal of the Royal Statistical Society B</em> <b>71</b>, 584&ndash;586.
<a href="https://doi.org/10.1111/j.1467-9868.2009.00706.x">doi:10.1111/j.1467-9868.2009.00706.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(17)
rX8 &lt;- rbwheel(1000,8, fullResult = TRUE, scaleAfter=FALSE)
with(rX8, stopifnot(all.equal(X, X0 %*% A,    tol = 1e-15),
                    all.equal(X0, X %*% t(A), tol = 1e-15)))
##--&gt; here, don't need to keep X0 (nor A, since that is Qrot(p))

## for n = 100,  you  don't see "it", but may guess .. :
n &lt;- 100
pairs(r &lt;- rbwheel(n,6))
n1 &lt;- attr(r,"n1") ; pairs(r, col=1+((1:n) &gt; n1))

## for n = 500, you *do* see it :
n &lt;- 500
pairs(r &lt;- rbwheel(n,6))
## show explicitly
n1 &lt;- attr(r,"n1") ; pairs(r, col=1+((1:n) &gt; n1))

## but increasing sig2 does help:
pairs(r &lt;- rbwheel(n,6, sig2 = .2))

## show explicitly
n1 &lt;- attr(r,"n1") ; pairs(r, col=1+((1:n) &gt; n1))

set.seed(12)
pairs(X &lt;- rbwheel(n, 7, spherize=TRUE))
colSums(X) # already centered

if(require("ICS") &amp;&amp; require("robustbase")) {
  # ICS: Compare M-estimate [Max.Lik. of t_{df = 2}] with high-breakdown :
  stopifnot(require("MASS"))
  X.paM &lt;- ics(X, S1 = cov, S2 = function(.) cov.trob(., nu=2)$cov, stdKurt = FALSE)
  X.paM.&lt;- ics(X, S1 = cov, S2 = function(.) tM(., df=2)$V, stdKurt = FALSE)
  X.paR &lt;- ics(X, S1 = cov, S2 = function(.) covMcd(.)$cov, stdKurt = FALSE)
  plot(X.paM) # not at all clear
  plot(X.paM.)# ditto
  plot(X.paR)# very clear
}
## Similar such experiments ---&gt;  demo(rbwheel_d)  and   demo(rbwheel_ics)
##                                --------------         -----------------
</code></pre>

<hr>
<h2 id='reclas'>Recursive Robust Median-like Location and Scale</h2><span id='topic+reclas'></span><span id='topic+plot.reclas'></span>

<h3>Description</h3>

<p>Calculate an estimate of location, asymptotically
equivalent to the median, and an estimate of scale
equal to the <b>MEAN</b> absolute deviation.  Both
done recursively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
reclas(y, b = 0.2, mfn = function(n) 0.1 * n^(-0.25),
     nstart = 30, m0 = median(y0),
     scon=NULL, updateScale = is.null(scon))

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reclas_+3A_y">y</code></td>
<td>
<p>numeric vector of i.i.d. data whose location and scale
parameters are to be estimated.</p>
</td></tr>
<tr><td><code id="reclas_+3A_b">b</code></td>
<td>
<p>numeric tuning parameter (default value equal to that used by
Holst, 1987).</p>
</td></tr>
<tr><td><code id="reclas_+3A_mfn">mfn</code></td>
<td>
<p>a <code><a href="base.html#topic+function">function</a></code> of the index of the data which
must be positive and and tend to 0 as the index tends to infinity.
The default function is that used by Holst, 1987.</p>
</td></tr>
<tr><td><code id="reclas_+3A_nstart">nstart</code></td>
<td>
<p>number of starting values: Starting values for the
algorithm are formed from the first <code>nstart</code> values of
<code>y</code>.  The default value is that used in Cameron and Turner, 1993.</p>
</td></tr>
<tr><td><code id="reclas_+3A_m0">m0</code></td>
<td>
<p>value for the initial approximate median; by default, the
<code><a href="stats.html#topic+median">median</a></code> of the first <code>nstart</code> observations.</p>
</td></tr>
<tr><td><code id="reclas_+3A_scon">scon</code></td>
<td>
<p>value for the scale parameter <code>s</code>, a
<code><a href="base.html#topic+function">function</a></code> or <code>NULL</code>. When <code>NULL</code>, as by
default, the scale is initialized to the mean of the absolute
differences between the first <code>nstart</code> y values and <code>m0</code>.
If scon is a function, the initial scale is set to <code>scon(y0, m0)</code>,
where <code>y0</code> is the vector of the first <code>nstart</code> y values.
Note that <code>scon</code> also determines the default for <code>updateScale</code>.</p>
</td></tr>
<tr><td><code id="reclas_+3A_updatescale">updateScale</code></td>
<td>
<p>a logical indicating if the scale, initialized
from <code>scon</code> should be updated in each iteration.  Otherwise, the
the scale is held constant throughout and the algorithm becomes
equivalent to the algorithm of Holst.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 &ldquo;object&rdquo; of <code><a href="base.html#topic+class">class</a></code> <code>"reclas"</code>; simply a
list with entries
</p>
<table>
<tr><td><code>locn</code></td>
<td>
<p>the successive recursive estimates of location.  The
first <code>nstart - 1</code> of these are <code>NA</code>.</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p>the successive recursive estimates of scale <b>if</b>
<code>updateScale</code> is true; otherwise the constant value used for
the scale.</p>
</td></tr>
<tr><td><code>updateScale</code></td>
<td>
<p>the same as the function argument.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call, i.e., <code><a href="base.html#topic+match.call">match.call</a></code>.</p>
</td></tr>
</table>
<p>There is a <code><a href="graphics.html#topic+plot">plot</a></code> method for <code>"reclas"</code>, see the
examples.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
<a href="http://www.stat.auckland.ac.nz/~rolf">http://www.stat.auckland.ac.nz/~rolf</a>
</p>
<p>Extensions by Martin Maechler (<code>scon</code> as function;
<code>updateScale</code>, <code>plot()</code>).
</p>


<h3>References</h3>

<p>Cameron, Murray A. and Turner, T. Rolf (1993).
Recursive location and scale estimators.
<em>Commun. Statist. &mdash; Theory Meth.</em> <b>22</b>(9) 2503&ndash;2515.
</p>
<p>Holst, U. (1987).
Recursive estimators of location.
<em>Commun. Statist. &mdash; Theory Meth.</em> <b>16</b> (8) 2201&ndash;2226.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
y &lt;- rt(10000, df = 1.5) # not quite Gaussian ...
z1 &lt;- reclas(y)
z3 &lt;- reclas(y, scon= 1  ) # correct fixed scale
z4 &lt;- reclas(y, scon= 100) # wrong fixed scale
z2 &lt;- reclas(y, # a more robust initial scale:
           scon = function(y0, m0) robustbase::Qn(y0 - m0),
           updateScale = TRUE) # still updated

## Visualizing -- using the plot() method for "reclas":
M &lt;- median(y) ; yl &lt;- c(-1,1)* 0.5
OP &lt;- par(mfrow=c(2,2), mar=.1+c(3,3,1,1), mgp=c(1.5, .6, 0))
 plot(z1, M=M, ylim=yl)
 plot(z2, M=M, ylim=yl)
 plot(z3, M=M, ylim=yl)
 plot(z4, M=M, ylim=yl)
par(OP)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
