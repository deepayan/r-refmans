<!DOCTYPE html><html><head><title>Help for package RItools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RItools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aggregateDesigns'><p>Aggregate DesignOptions</p></a></li>
<li><a href='#alignDesignsByStrata'><p>Align DesignOptions by Strata</p></a></li>
<li><a href='#balanceplot'><p>Create a plot of the balance on variables across different stratifications.</p></a></li>
<li><a href='#balanceTest'><p>Standardized Differences for Stratified Comparisons</p></a></li>
<li><a href='#balanceTest.make.stratwts'><p>balanceTest helper function</p></a></li>
<li><a href='#balanceTestEngine'><p>xBalance helper function</p></a></li>
<li><a href='#CovsAlignedToADesign-class'><p>CovsAlignedToADesign S4 class</p></a></li>
<li><a href='#DesignOptions-class'><p>DesignOptions S4 class</p></a></li>
<li><a href='#designToDescriptives'><p>Generate Descriptives</p></a></li>
<li><a href='#DesignWeights'><p>Create stratum weights to be associated with a DesignOptions</p></a></li>
<li><a href='#effectOfTreatmentOnTreated'><p>Number of treatment clusters by stratum</p></a></li>
<li><a href='#flatten.xbalresult'><p>Flattens xBalance output.</p></a></li>
<li><a href='#formula.xbal'><p>Returns <code>formula</code> attribute of an <code>xbal</code> object.</p></a></li>
<li><a href='#harmonic'><p>Harmonic mean</p></a></li>
<li><a href='#harmonic_times_mean_weight'><p>Harmonic mean times mean of weights</p></a></li>
<li><a href='#HB08'><p>Adjusted &amp; combined differences as in Hansen &amp; Bowers (2008)</p></a></li>
<li><a href='#HB08_2016'><p>Hansen &amp; Bowers (2008) inferentials 2016 [81e3ecf] version</p></a></li>
<li><a href='#identify_NM_vars'><p>Identify vars recording not-missing (NM) info</p></a></li>
<li><a href='#makeDesigns'><p>Create a DesignOptions object from a formula and some data</p></a></li>
<li><a href='#makePval'><p>Get p-value for Z-stats</p></a></li>
<li><a href='#model_matrix'><p>Model matrices along with compact encodings of data availability/missingness</p></a></li>
<li><a href='#ModelMatrixPlus-class'><p>ModelMatrixPlus S4 class</p></a></li>
<li><a href='#naImpute'><p>Impute NA's</p></a></li>
<li><a href='#nuclearplants'><p>Nuclear Power Station Construction Data</p></a></li>
<li><a href='#original_units_var_formatter'><p>Formatting suitable for stat expressed in units specific to var</p></a></li>
<li><a href='#plot.balancetest'><p>Plot of balance across multiple strata</p></a></li>
<li><a href='#plot.xbal'><p>Plot of balance across multiple strata</p></a></li>
<li><a href='#print.xbal'><p>Printing xBalance and balanceTest Objects</p></a></li>
<li><a href='#scale.DesignOptions'><p>Scale DesignOptions</p></a></li>
<li><a href='#sparseToVec'><p>Convert Matrix to vector</p></a></li>
<li><a href='#StratumWeightedDesignOptions-class'><p>Stratum Weighted DesignOptions</p></a></li>
<li><a href='#subset.xbal'><p>Select variables, strata, and statistics from a <code>xbal</code> or <code>balancetest</code> object</p></a></li>
<li><a href='#tidy.xbal'><p><code>broom::tidy()</code>/<code>glance()</code> methods for <code>balanceTest()</code> results</p></a></li>
<li><a href='#withOptions'><p>Safe way to temporarily override options()</p></a></li>
<li><a href='#xBalance'><p>Standardized Differences for Stratified Comparisons</p></a></li>
<li><a href='#xBalance.find.goodstrats'><p>xBalance helper function</p></a></li>
<li><a href='#xBalance.makepooledsd'><p>xBalance helper function</p></a></li>
<li><a href='#xtable.xbal'><p>An <code>xtable</code> method for <code>xbal</code> and <code>balancetest</code> objects</p></a></li>
<li><a href='#ym_long'><p>ASSIST Trial Data from Yudkin and Moher 2001</p></a></li>
<li><a href='#ym_short'><p>ASSIST Trial Data from Yudkin and Moher 2001</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.3-3</td>
</tr>
<tr>
<td>Title:</td>
<td>Randomization Inference Tools</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for randomization-based inference. Current focus is on the d^2 omnibus test of differences of means following Hansen and Bowers (2008)  &lt;<a href="https://doi.org/10.1214%2F08-STS254">doi:10.1214/08-STS254</a>&gt; . This test is useful for assessing balance in matched observational studies or for analysis of outcomes in block-randomized experiments.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), ggplot2</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, abind, xtable, svd, stats, graphics, methods,
survival, SparseM, tidyr, tibble, dplyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat, roxygen2, MASS</td>
</tr>
<tr>
<td>Enhances:</td>
<td>optmatch</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org/package=RItools">https://cran.r-project.org/package=RItools</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-10 01:10:47 UTC; jwbowers</td>
</tr>
<tr>
<td>Author:</td>
<td>Jake Bowers [aut, cre],
  Mark Fredrickson [aut],
  Ben Hansen [aut],
  Josh Errickson [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jake Bowers &lt;jwbowers@illinois.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-10 08:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='aggregateDesigns'>Aggregate DesignOptions</h2><span id='topic+aggregateDesigns'></span>

<h3>Description</h3>

<p>Totals up all the covariates, as well as user-provided unit weights.
(What it does to NotMissing entries is described in docs for DesignOptions class.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregateDesigns(design)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregateDesigns_+3A_design">design</code></td>
<td>
<p>DesignOptions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>design@Cluster</code> has extraneous (non-represented) levels, they will be dropped.
</p>


<h3>Value</h3>

<p>another DesignOptions representing the clusters
</p>

<hr>
<h2 id='alignDesignsByStrata'>Align DesignOptions by Strata</h2><span id='topic+alignDesignsByStrata'></span>

<h3>Description</h3>

<p>Align DesignOptions by Strata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alignDesignsByStrata(a_stratification, design, post.align.transform = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alignDesignsByStrata_+3A_a_stratification">a_stratification</code></td>
<td>
<p>name of a column of 'design@strataFrame'/ element of 'design@Sweights'</p>
</td></tr>
<tr><td><code id="alignDesignsByStrata_+3A_design">design</code></td>
<td>
<p>DesignOptions</p>
</td></tr>
<tr><td><code id="alignDesignsByStrata_+3A_post.align.transform">post.align.transform</code></td>
<td>
<p>A post-align transform (cf <code><a href="#topic+balanceTest">balanceTest</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>CovsAlignedToADesign
</p>

<hr>
<h2 id='balanceplot'>Create a plot of the balance on variables across different stratifications.</h2><span id='topic+balanceplot'></span>

<h3>Description</h3>

<p>This plotting function summarizes variable by stratification matrices. For
each variable (a row in the <code>x</code> argument), the values are under each
stratification (the columns of <code>x</code>) plotted on the same line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balanceplot(
  x,
  ordered = FALSE,
  segments = TRUE,
  colors = "black",
  shapes = c(15, 16, 17, 18, 0, 1, 10, 12, 13, 14),
  segments.args = list(col = "grey"),
  points.args = list(cex = 1),
  xlab = "Balance",
  xrange = NULL,
  groups = NULL,
  tiptext = NULL,
  include.legend = TRUE,
  legend.title = NULL,
  plotfun = .balanceplot,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balanceplot_+3A_x">x</code></td>
<td>
<p>A matrix of variables (rows) by strata (columns).</p>
</td></tr>
<tr><td><code id="balanceplot_+3A_ordered">ordered</code></td>
<td>
<p>Should the variables be ordered from
most to least imbalance on the first statistic?</p>
</td></tr>
<tr><td><code id="balanceplot_+3A_segments">segments</code></td>
<td>
<p>Should lines be drawn between points for each
variable?</p>
</td></tr>
<tr><td><code id="balanceplot_+3A_colors">colors</code></td>
<td>
<p>Either a vector or a matrix of shape indicators
suitable to use as a <code>col</code> argument to the
<code><a href="graphics.html#topic+points">points</a></code> function. If the argument is a vector, the
length should be the same as the number of columns in <code>x</code>. If
the argument is a matrix, it should have the same dims as <code>x</code>.</p>
</td></tr>
<tr><td><code id="balanceplot_+3A_shapes">shapes</code></td>
<td>
<p>Either a vector or a matrix of shape indicators
suitable to use as a <code>pch</code> argument to the
<code><a href="graphics.html#topic+points">points</a></code> function. If the argument is a vector, the
length should be the same as the number of columns in <code>x</code>. If
the argument is a matrix, it should have the same dims as
<code>x</code>.
&lt;!&ndash; The suggested vector has been selected to work with
RSVGTipsDevice tool tips.&ndash;&gt;</p>
</td></tr>
<tr><td><code id="balanceplot_+3A_segments.args">segments.args</code></td>
<td>
<p>A list of arguments to pass to the
<code><a href="graphics.html#topic+segments">segments</a></code> function.</p>
</td></tr>
<tr><td><code id="balanceplot_+3A_points.args">points.args</code></td>
<td>
<p>A list of arguments to pass to the <code><a href="graphics.html#topic+points">points</a></code> function.</p>
</td></tr>
<tr><td><code id="balanceplot_+3A_xlab">xlab</code></td>
<td>
<p>The label of the x-axis of the plot.</p>
</td></tr>
<tr><td><code id="balanceplot_+3A_xrange">xrange</code></td>
<td>
<p>The range of x-axis. By default, it is 1.25 times the range of <code>x</code>.</p>
</td></tr>
<tr><td><code id="balanceplot_+3A_groups">groups</code></td>
<td>
<p>A factor that indicates the group of each row in
<code>x</code>. Groups are printed under a common header.</p>
</td></tr>
<tr><td><code id="balanceplot_+3A_tiptext">tiptext</code></td>
<td>
<p>ignored (legacy argument retained for internal reasons)
&lt;!&ndash; If you are using the <code>RSVGTipsDevice</code> library for
rendering, you can include an array of the dimensions of x
with another dimension of length 2. For example, if there are 4
observations and 2 strata, the array should be 4 by 2 by 2. The
<code>tiptext[i, j, 1]</code> entry will be the first line of the tool
tip for the data in <code>x[i, j]</code>. Likewise for the second row of
the tool tip. &ndash;&gt;</p>
</td></tr>
<tr><td><code id="balanceplot_+3A_include.legend">include.legend</code></td>
<td>
<p>Should a legend be included?</p>
</td></tr>
<tr><td><code id="balanceplot_+3A_legend.title">legend.title</code></td>
<td>
<p>An optional title to attach to the legend.</p>
</td></tr>
<tr><td><code id="balanceplot_+3A_plotfun">plotfun</code></td>
<td>
<p>Function to do the plotting; defaults to [RItools:::.balanceplot]</p>
</td></tr>
<tr><td><code id="balanceplot_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is conventional to standardize the differences to common scale
(e.g.  z-scores), but this is not required. When <code>ordered</code> is
set to true, plotting will automatically order the data from
largest imbalance to smallest based on the first column of
<code>x</code>.
</p>
<p>You can fine tune the colors and shapes with the like named
arguments. Any other arguments to the <code><a href="graphics.html#topic+points">points</a></code> function
can be passed in a list as <code>points.args</code>. Likewise, you can
fine tune the segments between points with <code>segments.args</code>.
</p>


<h3>Value</h3>

<p>Returns NULL, displays plot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.xbal">plot.xbal</a></code>, <code><a href="#topic+xBalance">xBalance</a></code>,
<code><a href="graphics.html#topic+segments">segments</a></code>, <code><a href="graphics.html#topic+points">points</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(20121204)

# generate some balance data
nvars &lt;- 10
varnames &lt;- paste("V", letters[1:nvars])

balance_data &lt;- matrix(c(rnorm(n = nvars, mean = 1, sd = 0.5), 
                         rnorm(n = nvars, mean = 0, sd = 0.5)),
                       ncol = 2)

colnames(balance_data) &lt;- c("Before Adjustment", "After Matching")

rownames(balance_data) &lt;- varnames

balanceplot(balance_data,
                      colors = c("red", "green"),
                      xlab = "Balance Before/After Matching")

# base R graphics are allowed

abline(v = colMeans(balance_data), lty = 3, col = "grey")

</code></pre>

<hr>
<h2 id='balanceTest'>Standardized Differences for Stratified Comparisons</h2><span id='topic+balanceTest'></span>

<h3>Description</h3>

<p>Covariate balance, with treatment/covariate association tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balanceTest(
  fmla,
  data,
  strata = NULL,
  unit.weights,
  stratum.weights = harmonic_times_mean_weight,
  subset,
  include.NA.flags = TRUE,
  covariate.scales = setNames(numeric(0), character(0)),
  post.alignment.transform = NULL,
  inferentials.calculator = HB08,
  p.adjust.method = "holm"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balanceTest_+3A_fmla">fmla</code></td>
<td>
<p>A formula containing an indicator of treatment
assignment on the left hand side and covariates at right.</p>
</td></tr>
<tr><td><code id="balanceTest_+3A_data">data</code></td>
<td>
<p>A data frame in which <code>fmla</code> and <code>strata</code>
are to be evaluated.</p>
</td></tr>
<tr><td><code id="balanceTest_+3A_strata">strata</code></td>
<td>
<p>A list of right-hand-side-only formulas containing
the factor(s) identifying the strata, with <code>NULL</code> entries
interpreted as no stratification; or a factor with length equal
to the number of rows in data; or a data frame of such
factors. See below for examples.</p>
</td></tr>
<tr><td><code id="balanceTest_+3A_unit.weights">unit.weights</code></td>
<td>
<p>Per-unit weight, or 0 if unit does not meet condition specified by subset argument. If there are clusters, the cluster weight is the sum of unit weights of elements within the cluster.  Within each stratum, unit weights will be normalized to sum to the number of clusters in the stratum.</p>
</td></tr>
<tr><td><code id="balanceTest_+3A_stratum.weights">stratum.weights</code></td>
<td>
<p>Function returning non-negative weight for each stratum; see details.</p>
</td></tr>
<tr><td><code id="balanceTest_+3A_subset">subset</code></td>
<td>
<p>Optional: condition or vector specifying a subset of observations to be permitted to have positive unit weights.</p>
</td></tr>
<tr><td><code id="balanceTest_+3A_include.na.flags">include.NA.flags</code></td>
<td>
<p>Present item missingness comparisons as well as covariates themselves?</p>
</td></tr>
<tr><td><code id="balanceTest_+3A_covariate.scales">covariate.scales</code></td>
<td>
<p>covariate dispersion estimates to use
as denominators of<code>std.diffs</code> (optional).</p>
</td></tr>
<tr><td><code id="balanceTest_+3A_post.alignment.transform">post.alignment.transform</code></td>
<td>
<p>Optional transformation applied to
covariates just after their stratum means are subtracted off.
Should accept a vector of weights as its second argument.</p>
</td></tr>
<tr><td><code id="balanceTest_+3A_inferentials.calculator">inferentials.calculator</code></td>
<td>
<p>Function; calculates &lsquo;inferential&rsquo; statistics. (Not currently intended for use by end-users.)</p>
</td></tr>
<tr><td><code id="balanceTest_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>Method of p-value adjustment for the univariate tests. See the <code><a href="stats.html#topic+p.adjust">p.adjust</a></code> function for available methods. By default the &quot;holm&quot; method is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a grouping variable (treatment assignment, exposure status, etc)
and variables on which to compare the groups, compare averages across groups
and test hypothesis of no selection into groups on the basis of that variable.
The multivariate test is the method of combined differences discussed by
Hansen and Bowers (2008, Statist. Sci.), a variant of Hotelling's T-squared
test; the univariate tests are presented with multiplicity adjustments, the
details of which can be controlled by the user. Clustering, weighting and/or
stratification variables can be provided, and are addressed by the tests.
</p>
<p>The function assembles various univariate descriptive statistics
for the groups to be compared: (weighted) means of treatment and
control groups; differences of these (adjusted differences); and
adjusted differences as multiples of a pooled s.d. of the variable
in the treatment and control groups (standard differences). Pooled
s.d.s are calculated with weights but without attention to clustering,
and ordinarily without attention to stratification.  (If the user does
not request unstratified comparisons, overriding the default setting,
then pooled s.d.s are calculated with weights corresponding to the first
stratification for which comparison is requested.  In this case as
in the default setting, the same pooled s.d.s are used for standardization
under each stratification considered. This facilitates comparison of
standard differences across stratification schemes.)  Means
are contrasted separately for each provided stratifying factor and, by
default, for the unstratified comparison, in each case with weights
reflecting a standardization appropriate to the designated (post-)
stratification of the sample.  In the case without stratification
or clustering, the only weighting used to calculate treatment and
control group means is that provided by the user as
<code>unit.weights</code>; in the absence of such an argument, these
means are unweighted.  When there are strata, within-stratum means
of treatment or of control observations are calculated using
<code>unit.weights</code>, if provided, and then these are combined
across strata according to a &lsquo;effect of treatment on
treated&rsquo;-type weighting scheme. (The function's
<code>stratum.weights</code> argument figures in the function's
inferential calculations but not these descriptive calculations.)
To figure a stratum's effect of treatment on treated weight, the
sum of all <code>unit.weights</code> associated with treatment or
control group observations within the stratum is multiplied by the
fraction of clusters in that stratum that are associated with the
treatment rather than the control condition.  (Unless this
fraction is 0 or 1, in which case the stratum is downweighted to
0.)
</p>
<p>The function also calculates univariate and multivariate inferential
statistics, targeting the hypothesis that assignment was random within strata. These
calculations also pool <code>unit.weights</code>-weighted, within-stratum group means across strata,
but the default weighting of strata differs from that of the descriptive calculations.
With <code>stratum.weights=harmonic_times_mean_weight</code> (the default), each stratum
is weighted in proportion to the product of the stratum mean of <code>unit.weights</code>
and the harmonic mean <code class="reqn">1/[(1/a + 1/b)/2]=2*a*b/(a+b)</code> of the number of
treated units (a) and control units (b) in the stratum; this weighting is optimal
under certain modeling assumptions (discussed in Kalton 1968 and Hansen and
Bowers 2008, Sections 3.2 and 5).  The multivariate assessment is based on a Mahalanobis-type
distance that combines each of the univariate mean differences while accounting
for correlations among them. It's similar to the Hotelling's T-squared statistic,
except standardized using a permutation covariance.  See Hansen and Bowers (2008).
</p>
<p>In contrast to the earlier function <code>xBalance</code> that it is intended to replace,
<code>balanceTest</code> accepts only binary assignment variables (for now).
</p>
<p><code>stratum.weights</code> must be a function of a single argument,
a data frame containing the variables in <code>data</code> and
additionally <code>Tx.grp</code>, <code>stratum.code</code>, and <code>unit.weights</code>,
returning a named numeric vector of non-negative weights identified by stratum.
(For an example, enter <code>getFromNamespace("harmonic", "RItools")</code>.)
the data  <code>stratum.weights</code> function.
</p>
<p>If the stratifying factor has NAs, these cases are dropped.  On the other
hand, if NAs in a covariate are found then those observations are dropped for descriptive
calculations and &quot;imputed&quot; to the stratum mean of the variable for inferential calculations.
When covariate values are dropped due to missingness, proportions of observations not missing on
that variable are recorded and returned.  The printed output presents non-missing proportions alongside of
the variables themselves, distinguishing the former by placing them at the bottom of the list and enclosing the
variable's name in parentheses.  If a variable shares a missingness pattern with other another variable,
its missingness information may be labeled with the name of the other variable in the output.
</p>


<h3>Value</h3>

<p>An object of class <code>c("balancetest", "xbal", "list")</code>. Several
methods are inherited from the &quot;xbal&quot; class returned by
<code><a href="#topic+xBalance">xBalance</a></code> function.
</p>


<h3>Note</h3>

<p>Evidence pertaining to the hypothesis that a treatment
variable is not associated with differences in covariate values
is assessed by comparing the differences of means, without standardization, to their distributions
under hypothetical shuffles of the treatment variable, a
permutation or randomization distribution.  For the unstratified
comparison, this reference distribution consists of differences
as the treatment
assignments of clusters are freely permuted.  For
stratified comparisons, the reference distributions describes re-randomizations of
this type performed separately in each stratum. Significance
assessments are based on large-sample approximations
to these reference distributions.
</p>


<h3>Author(s)</h3>

<p>Ben Hansen and Jake Bowers and Mark Fredrickson
</p>


<h3>References</h3>

<p>Hansen, B.B. and Bowers, J. (2008), &ldquo;Covariate
Balance in Simple, Stratified and Clustered Comparative
Studies,&rdquo; <em>Statistical Science</em> <b>23</b>.
</p>
<p>Kalton, G. (1968), &ldquo;Standardization: A technique to control for
extraneous variables,&rdquo; <em>Applied Statistics</em> <b>17</b>,
118&ndash;136.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+HB08">HB08</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuclearplants)
## No strata
balanceTest(pr ~ date + t1 + t2 + cap + ne + ct + bw + cum.n,
         data=nuclearplants)

## Stratified
## Note use of the `. - cost` to use all columns except `cost`
balanceTest(pr ~ . - cost + strata(pt),
         data=nuclearplants)

##Missing data handling.
testdata &lt;- nuclearplants
testdata$date[testdata$date &lt; 68] &lt;- NA
balanceTest(pr ~ . - cost + strata(pt),
            data = testdata)

## Variable-by-variable Wilcoxon rank sum tests, with an omnibus test
## of multivariate differences on rank scale.
balanceTest(pr ~ date + t1 + t2 + cap + ne + ct + bw + cum.n,
         data = nuclearplants,
	       post.alignment.transform = function(x, weights) rank(x))

## (Note that the post alignment transform is expected to be a function
## accepting a second argument, even if the argument is not used.
## The unit weights vector will be provided as this second argument,
## enabling use of e.g. `post.alignment.transform=Hmisc::wtd.rank`
## to furnish a version of the Wilcoxon test even when there are clusters and/or weights.)

## An experiment where clusters of individuals are assigned to treatment within strata
## assessing balance of cluster level treatment on both cluster
## and individual level baseline attributes
data(ym_long)
## Look at balance on teriles of cluster size as well as other variables
teriles &lt;- quantile(ym_long$n_practice, seq(1/3,1,by=1/3))
teriles &lt;- c(0, teriles)

balanceTest(trt ~ cut(n_practice, teriles)+assessed+hypo+lipid+
            aspirin+strata(assess_strata)+cluster(practice),
            data=ym_long)
</code></pre>

<hr>
<h2 id='balanceTest.make.stratwts'>balanceTest helper function</h2><span id='topic+balanceTest.make.stratwts'></span>

<h3>Description</h3>

<p>Makes strata weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balanceTest.make.stratwts(stratum.weights, ss.df, zz, data, normalize.weights)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balanceTest.make.stratwts_+3A_stratum.weights">stratum.weights</code></td>
<td>
<p>Weights</p>
</td></tr>
<tr><td><code id="balanceTest.make.stratwts_+3A_ss.df">ss.df</code></td>
<td>
<p>df.</p>
</td></tr>
<tr><td><code id="balanceTest.make.stratwts_+3A_zz">zz</code></td>
<td>
<p>treatment</p>
</td></tr>
<tr><td><code id="balanceTest.make.stratwts_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="balanceTest.make.stratwts_+3A_normalize.weights">normalize.weights</code></td>
<td>
<p>weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='balanceTestEngine'>xBalance helper function</h2><span id='topic+balanceTestEngine'></span>

<h3>Description</h3>

<p>Make engine
</p>


<h3>Usage</h3>

<pre><code class='language-R'>balanceTestEngine(
  ss,
  zz,
  mm,
  report,
  swt,
  s.p,
  normalize.weights,
  zzname,
  post.align.trans,
  p.adjust.method
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="balanceTestEngine_+3A_ss">ss</code></td>
<td>
<p>ss</p>
</td></tr>
<tr><td><code id="balanceTestEngine_+3A_zz">zz</code></td>
<td>
<p>zz</p>
</td></tr>
<tr><td><code id="balanceTestEngine_+3A_mm">mm</code></td>
<td>
<p>mm</p>
</td></tr>
<tr><td><code id="balanceTestEngine_+3A_report">report</code></td>
<td>
<p>report</p>
</td></tr>
<tr><td><code id="balanceTestEngine_+3A_swt">swt</code></td>
<td>
<p>swt</p>
</td></tr>
<tr><td><code id="balanceTestEngine_+3A_s.p">s.p</code></td>
<td>
<p>s.p</p>
</td></tr>
<tr><td><code id="balanceTestEngine_+3A_normalize.weights">normalize.weights</code></td>
<td>
<p>normalize.weights</p>
</td></tr>
<tr><td><code id="balanceTestEngine_+3A_zzname">zzname</code></td>
<td>
<p>zzname</p>
</td></tr>
<tr><td><code id="balanceTestEngine_+3A_post.align.trans">post.align.trans</code></td>
<td>
<p>post.align.trans</p>
</td></tr>
<tr><td><code id="balanceTestEngine_+3A_p.adjust.method">p.adjust.method</code></td>
<td>
<p>Method to adjust P.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List
</p>

<hr>
<h2 id='CovsAlignedToADesign-class'>CovsAlignedToADesign S4 class</h2><span id='topic+CovsAlignedToADesign-class'></span>

<h3>Description</h3>

<p>A class for representing covariate matrices after alignment within stratum,
for a (single) given stratifying factor.  There can also be a clustering variable,
assumed to be nested within the stratifying variable.
</p>


<h3>Details</h3>

<p>In contrast to DesignOptions, this class represents the combination of a single Covariates
table, realized treatment assignment and treatment assignment scheme, not multiple treatment
assignment schemes (designs). These Covariates are assumed to reflect regularization, s.t.
missings have been patched with a value and then all of the covariate values have been aligned
within each stratum.  In lieu of a NotMissing slot there will be Covariates columns, also
centered within a stratum, recording
non-missingness of the original data.
</p>
<p>Ordinarily the StrataWeightRatio slot has an entry for each unit, representing ratio of
specified stratum weight to the product of h_b (the harmonic mean of n_tb and
n_cb, the counts of treatment and control clusters in stratum b) with bar-w_b,
(the arithmetic mean of aggregated cluster weights within that stratum). It can also
be the numeric vector 1, without names, meaning the intended weight ratio is always 1.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Covariates</code></dt><dd><p>Numeric matrix, as in ModelMatrixPlus, except: will include NM columns; all columns presumed to have been stratum-centered (aligned)</p>
</dd>
<dt><code>UnitWeights</code></dt><dd><p>vector of weights associated w/ rows of Covariates</p>
</dd>
<dt><code>Z</code></dt><dd><p>Logical indicating treatment assignment</p>
</dd>
<dt><code>StrataMatrix</code></dt><dd><p>A sparse matrix with n rows and s columns, with 1 if the unit is in that stratification</p>
</dd>
<dt><code>StrataWeightRatio</code></dt><dd><p>For each unit, ratio of stratum weight to h_b; but see Details.</p>
</dd>
<dt><code>Cluster</code></dt><dd><p>Factor indicating who's in the same cluster with who</p>
</dd>
<dt><code>OriginalVariables</code></dt><dd><p>Look up table associating Covariates cols to terms in the calling formula, as in ModelMatrixPlus</p>
</dd>
</dl>

<hr>
<h2 id='DesignOptions-class'>DesignOptions S4 class</h2><span id='topic+DesignOptions-class'></span>

<h3>Description</h3>

<p>Extends the ModelMatrixPlus class
</p>


<h3>Details</h3>

<p>If the DesignOptions represents clusters of elements, as when it was created
by aggregating another DesignOptions or ModelMatrixPlus object, then its Covariates
and NotMissing slots are populated with (weighted) averages, not totals.  E.g.,
NotMissing columns consist of weighted averages of element-wise non-missingness indicators
over clusters, with weights given by (the element-level precursor to) the UnitWeights
vector.  As otherwise, columns of the NotMissing matrix represent terms
from a model formula, rather than columns the terms may have expanded to.
</p>
<p>If present, the null stratification (all units in same stratum) in indicated
by the corresponding column of the <code>StrataFrame</code> slot bearing the name
&lsquo;<code>--</code>&rsquo;.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Z</code></dt><dd><p>Logical indicating treatment assignment</p>
</dd>
<dt><code>StrataFrame</code></dt><dd><p>Factors indicating strata</p>
</dd>
<dt><code>Cluster</code></dt><dd><p>Factor indicating who's in the same cluster with who</p>
</dd>
</dl>

<hr>
<h2 id='designToDescriptives'>Generate Descriptives</h2><span id='topic+designToDescriptives'></span>

<h3>Description</h3>

<p>Use a design object to generate descriptive statistics that ignore clustering.
Stratum weights are respected if provided (by passing a design arg of
class StratumWeightedDesignOptions). If not provided, stratum weights
default to &quot;Effect of Treatment on Treated&quot; weighting.  That is, when
combining within-stratum averages (which will themselves have been
weighted by unit weights), each stratum receives a weight equal to
the product of the stratum sum of unit weights with the fraction
of clusters within the stratum that were assigned to the treatment
condition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designToDescriptives(design, covariate.scales = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="designToDescriptives_+3A_design">design</code></td>
<td>
<p>A DesignOptions object</p>
</td></tr>
<tr><td><code id="designToDescriptives_+3A_covariate.scales">covariate.scales</code></td>
<td>
<p>Scale estimates for covariates, a named numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, covariates are scaled by their pooled s.d.s, square roots
of half of their treatment group variances plus half of their control
group variances.  If weights are provided, these are weighted variances.
If descriptives are requested for an unstratified setup, i.e. a 
stratification named &lsquo;<code>--</code>&rsquo;, then covariate s.d.s
are calculated against it; otherwise the variances reflect stratification,
and are calculated against the first stratification found.  Either way,
if descriptives are calculated for multiple stratifications, only one
set of covariate s.d.s will have been calculated, and these underlie
standard difference calculations for each of the stratifications.
</p>
<p>If a named numeric <code>covariate.scales</code> argument is provided, any
covariates named in the vector will have their pooled s.d.s taken from
it, rather than from the internal calculation.
</p>


<h3>Value</h3>

<p>Descriptives
</p>

<hr>
<h2 id='DesignWeights'>Create stratum weights to be associated with a DesignOptions</h2><span id='topic+DesignWeights'></span>

<h3>Description</h3>

<p>Apply weighting function to a DesignOptions by stratum, returning results in a format
suitable to be associated with an existing design and used in further calcs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DesignWeights(design, stratum.weights = harmonic_times_mean_weight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DesignWeights_+3A_design">design</code></td>
<td>
<p>DesignOptions</p>
</td></tr>
<tr><td><code id="DesignWeights_+3A_stratum.weights">stratum.weights</code></td>
<td>
<p>Stratum weights function. Will be fed a count data.frame with Tx.grp (indicating the treatment group), stratum.code, all other covariates and unit.weights.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function expects its DesignOptions argument to represent aggregated data,
i.e. clusters not elements within clusters.  Its <code>stratum.weights</code> argument
is a function that is applied to a data frame representing clusters,
with variables <code>Tx.grp</code>, <code>stratum.code</code>, covariates as named in the
<code>design</code> argument (a DesignOptions object), and <code>unit.weights</code> (either as
culled or inferred from originating <code><a href="#topic+balanceTest">balanceTest</a></code> call or as aggregated up
from those unit weights).  Returns a
weighting factor to be associated with each stratum, this factor determining the stratum
weight by being multiplied by mean of unit weights over clusters in that stratum.
</p>
<p>Specifically, the function's value is a data frame of two variables,
<code>sweights</code>  and <code>wtratio</code>, with rows representing strata.
The <code>sweights</code> vector represents internally
calculated or user-provided <code>stratum.weights</code>, one for each
stratum, scaled so that their sum is 1; in Hansen &amp; Bowers (2008), these
weights are denoted <code class="reqn">w_{b}</code>. <code>wtratio</code> is the ratio of
<code>sweights</code> to the product of half the harmonic
mean of n_tb and n_cb, the number of treatment and control
clusters in stratum b, with the mean of the weights associated with
each of these clusters.  In the notation of Hansen &amp; Bowers
(2008), this is <code class="reqn">w_{b}/(h_b \bar{m}_b)</code>. Despite the name
&lsquo;<code>wtratio</code>&rsquo;, this ratio's denominator is not a weight
in the sense of summing to 1 across strata.  The ratio is expected
downstream in <code>HB08</code> (in internal calculations
involving &lsquo;<code>wtr</code>&rsquo;).
</p>


<h3>Value</h3>

<p>data frame w/ rows for strata, cols <code>sweights</code> and <code>wtratio</code>.
</p>

<hr>
<h2 id='effectOfTreatmentOnTreated'>Number of treatment clusters by stratum</h2><span id='topic+effectOfTreatmentOnTreated'></span>

<h3>Description</h3>

<p>Calculate the number of treatment clusters by stratum &ndash;
these being proportional to &quot;effect of treatment on treated&quot; weights
when assignment probabilities are uniform within each stratum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effectOfTreatmentOnTreated(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effectOfTreatmentOnTreated_+3A_data">data</code></td>
<td>
<p>Data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NB: currently, i.e. as of this inline note's commit,
this function is used only in testing.
</p>


<h3>Value</h3>

<p>Cluster count
</p>

<hr>
<h2 id='flatten.xbalresult'>Flattens xBalance output.</h2><span id='topic+flatten.xbalresult'></span>

<h3>Description</h3>

<p>Details...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten.xbalresult(
  x,
  show.signif.stars = getOption("show.signif.stars"),
  show.pvals = !show.signif.stars,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten.xbalresult_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="flatten.xbalresult_+3A_show.signif.stars">show.signif.stars</code></td>
<td>
<p>Should signif stars be shown?</p>
</td></tr>
<tr><td><code id="flatten.xbalresult_+3A_show.pvals">show.pvals</code></td>
<td>
<p>Should p-vals be shown?</p>
</td></tr>
<tr><td><code id="flatten.xbalresult_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Structure
</p>

<hr>
<h2 id='formula.xbal'>Returns <code>formula</code> attribute of an <code>xbal</code> object.</h2><span id='topic+formula.xbal'></span><span id='topic+formula.balancetest'></span>

<h3>Description</h3>

<p>Returns <code>formula</code> attribute of an <code>xbal</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xbal'
formula(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.xbal_+3A_x">x</code></td>
<td>
<p>An <code>xbal</code> object.</p>
</td></tr>
<tr><td><code id="formula.xbal_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The formula corresponding to <code>xbal</code>.
</p>

<hr>
<h2 id='harmonic'>Harmonic mean</h2><span id='topic+harmonic'></span>

<h3>Description</h3>

<p>Calculate harmonic mean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harmonic(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmonic_+3A_data">data</code></td>
<td>
<p>Data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of length <code>nlevels(data$stratum.code)</code>
</p>

<hr>
<h2 id='harmonic_times_mean_weight'>Harmonic mean times mean of weights</h2><span id='topic+harmonic_times_mean_weight'></span>

<h3>Description</h3>

<p>Harmonic mean times mean of weights
</p>


<h3>Usage</h3>

<pre><code class='language-R'>harmonic_times_mean_weight(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="harmonic_times_mean_weight_+3A_data">data</code></td>
<td>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of length <code>nlevels(data$stratum.code)</code>
</p>

<hr>
<h2 id='HB08'>Adjusted &amp; combined differences as in Hansen &amp; Bowers (2008)</h2><span id='topic+HB08'></span>

<h3>Description</h3>

<p>Adjusted &amp; combined differences as in Hansen &amp; Bowers (2008)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HB08(alignedcovs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HB08_+3A_alignedcovs">alignedcovs</code></td>
<td>
<p>A CovsAlignedToADesign object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with components:
</p>

<dl>
<dt>z</dt><dd><p>First item</p>
</dd>
<dt>p</dt><dd><p>Second item</p>
</dd>
<dt>Msq</dt><dd><p>Squared Mahalanobis distance of combined differences from origin</p>
</dd>
<dt>DF</dt><dd><p>degrees of freedom</p>
</dd>
<dt>adj.diff.of.totals</dt><dd><p>Vector of sum statistics z't - E(Z't), where t represents cluster totals of the product of the covariate with unit weights.  Hansen &amp; Bowers (2008) refer to this as the adjusted difference vector, or d(z,x). </p>
</dd>
<dt>tcov</dt><dd><p>Matrix of null covariances of Z'x-tilde vector, as above.</p>
</dd>
</dl>



<h3>References</h3>

<p>Hansen, B.B. and Bowers, J. (2008), &ldquo;Covariate
Balance in Simple, Stratified and Clustered Comparative
Studies,&rdquo; <em>Statistical Science</em> <b>23</b>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+balanceTest">balanceTest</a></code>, <code><a href="#topic+alignDesignsByStrata">alignDesignsByStrata</a></code>
</p>

<hr>
<h2 id='HB08_2016'>Hansen &amp; Bowers (2008) inferentials 2016 [81e3ecf] version</h2><span id='topic+HB08_2016'></span>

<h3>Description</h3>

<p>Hansen &amp; Bowers (2008) inferentials 2016 [81e3ecf] version
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HB08_2016(alignedcovs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HB08_2016_+3A_alignedcovs">alignedcovs</code></td>
<td>
<p>A CovsAlignedToADesign object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list, as in <code><a href="#topic+HB08">HB08</a></code>
</p>

<hr>
<h2 id='identify_NM_vars'>Identify vars recording not-missing (NM) info</h2><span id='topic+identify_NM_vars'></span>

<h3>Description</h3>

<p>ID variables recording NM information, from
names and positions in the variable list.
Presumption is that the NM cols appear at the
end of the list of vars and are encased in
&lsquo;()&rsquo;.  If something in the code changes
to make this assumption untrue, then this
helper is designed to err on the side of not
identifying other columns as NM cols.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>identify_NM_vars(vnames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="identify_NM_vars_+3A_vnames">vnames</code></td>
<td>
<p>character, variable names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of names of NM vars, possibly of length 0
</p>


<h3>Author(s)</h3>

<p>Hansen
</p>

<hr>
<h2 id='makeDesigns'>Create a DesignOptions object from a formula and some data</h2><span id='topic+makeDesigns'></span>

<h3>Description</h3>

<p>The formula must have a left hand side that can be converted to a logical.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDesigns(fmla, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDesigns_+3A_fmla">fmla</code></td>
<td>
<p>Formula</p>
</td></tr>
<tr><td><code id="makeDesigns_+3A_data">data</code></td>
<td>
<p>Data</p>
</td></tr>
</table>


<h3>Details</h3>

<p>On the RHS:
- It may have at most one cluster() argument.
- It may have one or more strata() arguments.
- All other variables are considered covariates.
</p>
<p>NAs in a cluster() or strata() variable will be dropped.
NAs in covariates will be passed through, but without
being flagged as NotMissing (as available data items will)
</p>


<h3>Value</h3>

<p>DesignOptions
</p>

<hr>
<h2 id='makePval'>Get p-value for Z-stats</h2><span id='topic+makePval'></span>

<h3>Description</h3>

<p>Get p-value for Z-stats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePval(zs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePval_+3A_zs">zs</code></td>
<td>
<p>A Z-statistic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A P-value
</p>

<hr>
<h2 id='model_matrix'>Model matrices along with compact encodings of data availability/missingness</h2><span id='topic+model_matrix'></span>

<h3>Description</h3>

<p>Grow a model matrix while at the same time compactly
encoding missingness patterns in RHS variables of a model frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model_matrix(object, data = environment(object), remove.intercept = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model_matrix_+3A_object">object</code></td>
<td>
<p>Model formula or terms object (as in 'model.matrix')</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_data">data</code></td>
<td>
<p>data.frame, as in 'model.matrix()' but has to have &lsquo;<code>(weights)</code>&rsquo; column</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_remove.intercept">remove.intercept</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="model_matrix_+3A_...">...</code></td>
<td>
<p>passed to 'model.matrix.default' (and further)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ModelMatrixPlus, i.e. model matrix enriched with missing data info
</p>


<h3>Author(s)</h3>

<p>Ben B Hansen
</p>

<hr>
<h2 id='ModelMatrixPlus-class'>ModelMatrixPlus S4 class</h2><span id='topic+ModelMatrixPlus-class'></span>

<h3>Description</h3>

<p>If the Covariates matrix has an intercept, it will only be in the first column.
</p>


<h3>Details</h3>

<p>More on NotMissing slot: It's matrix of numbers in [0,1].
First col is entirely <code>TRUE</code> or 1, like an intercept, unless corresponding
UnitWeight is 0, in which case it may also be 0 (see below). Subsequent cols
present only if there are missing covariate values, in which case these cols are
named for terms (of the original calling formula or data frame) that possess
missing values.  Terms with the same missing data pattern are mapped to a single
column of this matrix.  If the ModelMatrixPlus is representing elements, each column should
be all 1s and 0s, indicating which elements have non-missing values for the term
represented by that column.  If the ModelMatrixPlus as a whole represents clusters,
then there can be fractional values, but that situation should only arise in the
DesignOptions class exension of this class, so it's documented there.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Covariates</code></dt><dd><p>The numeric matrix that 'model.matrix' would have returned.</p>
</dd>
<dt><code>OriginalVariables</code></dt><dd><p>look-up table associating Covariates columns with terms of the originating model formula</p>
</dd>
<dt><code>TermLabels</code></dt><dd><p>labels of terms of the originating model formula</p>
</dd>
<dt><code>contrasts</code></dt><dd><p>Contrasts, a list of contrasts or NULL, as returned by 'model.matrix.default'</p>
</dd>
<dt><code>NotMissing</code></dt><dd><p>Matrix of numbers in [0,1] with as many rows as the Covariates table but only one more col than there are distinct covariate missingness patterns (at least 1, nothing missing). First col is entirely T or 1, like an intercept.</p>
</dd>
<dt><code>NM.Covariates</code></dt><dd><p>integer look-up table mapping Covariates columns to columns of NotMissing.  (If nothing missing for that column, this is 0.)</p>
</dd>
<dt><code>NM.terms</code></dt><dd><p>integer look-up table mapping term labels to columns of NotMissing (0 means nothing missing in that column)</p>
</dd>
<dt><code>UnitWeights</code></dt><dd><p>vector of weights associated w/ rows of the ModelMatrixPlus</p>
</dd>
</dl>

<hr>
<h2 id='naImpute'>Impute NA's</h2><span id='topic+naImpute'></span>

<h3>Description</h3>

<p>Function used to fill NAs with imputation values, while adding NA flags to the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>naImpute(FMLA, DATA, impfn = median, na.rm = TRUE, include.NA.flags = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="naImpute_+3A_fmla">FMLA</code></td>
<td>
<p>Formula</p>
</td></tr>
<tr><td><code id="naImpute_+3A_data">DATA</code></td>
<td>
<p>Data</p>
</td></tr>
<tr><td><code id="naImpute_+3A_impfn">impfn</code></td>
<td>
<p>Function for imputing.</p>
</td></tr>
<tr><td><code id="naImpute_+3A_na.rm">na.rm</code></td>
<td>
<p>What to do with NA's</p>
</td></tr>
<tr><td><code id="naImpute_+3A_include.na.flags">include.NA.flags</code></td>
<td>
<p>Should NA flags be included</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Structure
</p>

<hr>
<h2 id='nuclearplants'>Nuclear Power Station Construction Data</h2><span id='topic+nuclearplants'></span>

<h3>Description</h3>

<p>The data relate to the construction of 32 light water reactor (LWR)
plants constructed in the U.S.A in the late 1960's and early
1970's.  The data was collected with the aim of predicting the cost
of construction of further LWR plants.  6 of the power plants had
partial turnkey guarantees and it is possible that, for these
plants, some manufacturers' subsidies may be hidden in the quoted
capital costs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nuclearplants
</code></pre>


<h3>Format</h3>

<p>A data frame with 32 rows and 11 columns
</p>

<ul>
<li><p> cost: The capital cost of construction in millions of
dollars adjusted to 1976 base.
</p>
</li>
<li><p> date: The date on which the construction permit was issued.
The data are measured in years since January 1 1990 to the
nearest month.
</p>
</li>
<li><p> t1: The time between application for and issue of the
construction permit.
</p>
</li>
<li><p> t2: The time between issue of operating license and
construction permit.
</p>
</li>
<li><p> cap: The net capacity of the power plant (MWe).
</p>
</li>
<li><p> pr: A binary variable where <code>1</code> indicates the prior
existence of a LWR plant at the same site.
</p>
</li>
<li><p> ne: A binary variable where <code>1</code> indicates that the
plant was constructed in the north-east region of the U.S.A.
</p>
</li>
<li><p> ct: A binary variable where <code>1</code> indicates the use of a
cooling tower in the plant.
</p>
</li>
<li><p> bw: A binary variable where <code>1</code> indicates that the
nuclear steam supply system was manufactured by Babcock-Wilcox.
</p>
</li>
<li><p> cum.n: The cumulative number of power plants constructed by
each architect-engineer.
</p>
</li>
<li><p> pt: A binary variable where <code>1</code> indicates those plants
with partial turnkey guarantees.
</p>
</li></ul>



<h3>Source</h3>

<p>The data were obtained from the <code>boot</code> package, for
which they were in turn taken from Cox and Snell (1981). Although
the data themselves are the same as those in the <code>nuclear</code>
data frame in the <code>boot</code> package, the row names of the data
frame have been changed.  (The new row names were selected to
ease certain demonstrations in <code>optmatch</code>.)
</p>
<p>This documentation page is also adapted from the <code>boot</code>
package, written by Angelo Canty and ported to R by Brian Ripley.
</p>


<h3>References</h3>

<p>Cox, D.R. and Snell, E.J. (1981) <em>Applied Statistics:
Principles and Examples</em>. Chapman and Hall.
</p>

<hr>
<h2 id='original_units_var_formatter'>Formatting suitable for stat expressed in units specific to var</h2><span id='topic+original_units_var_formatter'></span>

<h3>Description</h3>

<p>formats a var-stat-strata array by var, with rounding
potentially rounding a bit less for an &quot;adj.diff&quot; column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>original_units_var_formatter(arr, digits, var_format = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="original_units_var_formatter_+3A_arr">arr</code></td>
<td>
<p>numeric array</p>
</td></tr>
<tr><td><code id="original_units_var_formatter_+3A_digits">digits</code></td>
<td>
<p>number of digits for rounding</p>
</td></tr>
<tr><td><code id="original_units_var_formatter_+3A_var_format">var_format</code></td>
<td>
<p>A list of lists. Each named item of the outer list will be matched to a variable. The inner lists should have two items, 'mean' and 'diff'. The first formats statistics based on averages. The 'diff' item should format statistics that are differences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of same dimension as arr but of type character
</p>


<h3>Author(s)</h3>

<p>Hansen
</p>

<hr>
<h2 id='plot.balancetest'>Plot of balance across multiple strata</h2><span id='topic+plot.balancetest'></span>

<h3>Description</h3>

<p>The plot allows a quick visual comparison of the effect of different
stratification designs on the comparability of different
variables. This is not a replacement for the omnibus statistical test
reported as part of <code><a href="#topic+print.xbal">print.xbal</a></code>. This plot does allow the
analyst an easy way to identify variables that might be the primary culprits
of overall imbalances and/or a way to assess whether certain important
covariates might be imbalanced even if the omnibus test reports that
the stratification overall produces balance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'balancetest'
plot(
  x,
  xlab = "Standardized Differences",
  statistic = "std.diff",
  absolute = FALSE,
  strata.labels = NULL,
  variable.labels = NULL,
  groups = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.balancetest_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+xBalance">xBalance</a></code></p>
</td></tr>
<tr><td><code id="plot.balancetest_+3A_xlab">xlab</code></td>
<td>
<p>The label for the x-axis of the plot</p>
</td></tr>
<tr><td><code id="plot.balancetest_+3A_statistic">statistic</code></td>
<td>
<p>The statistic to plot. The default choice of standardized
difference is a good choice as it will have roughly the same scale for all
plotted variables.</p>
</td></tr>
<tr><td><code id="plot.balancetest_+3A_absolute">absolute</code></td>
<td>
<p>Convert the results to the absolute value of the statistic.</p>
</td></tr>
<tr><td><code id="plot.balancetest_+3A_strata.labels">strata.labels</code></td>
<td>
<p>A named vector of the from <code>c(strata1 = "Strata Label 1", ...)</code>
that maps the stratification schemes to textual labels.</p>
</td></tr>
<tr><td><code id="plot.balancetest_+3A_variable.labels">variable.labels</code></td>
<td>
<p>A named vector of the from <code>c(var1 = "Var Label1", ...)</code>
that maps the variables to textual labels.</p>
</td></tr>
<tr><td><code id="plot.balancetest_+3A_groups">groups</code></td>
<td>
<p>A vector of group names for each variable in
<code>x$results</code>. By default, factor level variables will be
grouped.</p>
</td></tr>
<tr><td><code id="plot.balancetest_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code><a href="#topic+balanceplot">balanceplot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default all variables and all strata are plotted. The scope
of the plot can be reduced by using the <code><a href="#topic+subset.xbal">subset.xbal</a></code> function to
make a smaller <code>xbal</code> object with only the desired variables or
strata.
</p>
<p><code><a href="#topic+balanceTest">balanceTest</a></code> can produce several different summary statistics for
each variable, any of which can serve as the data for this plot. By default,
the standardized differences between treated and control units makes a good
choice as all variables are on the same scale. Other statistics can be
selected using the <code>statistic</code> argument.
</p>
<p>The result of this function is a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object. Most display of
the plot can be manipulated using additional commands appended to the plot
option. For example, the entire theme of the plot can be changed to black and
white using <code>plot(b) + theme_bw()</code>, where <code>b</code> is the result of a
call to <code><a href="#topic+balanceTest">balanceTest</a></code>. The points on the plot are known as
&quot;values&quot;, so colors or symbols used for each strata can be updated using the
<code><a href="ggplot2.html#topic+scale_color_manual">scale_color_manual</a></code> function. For example, <code>plot(b) +
scale_color_manaual(values = c('red', 'green', 'blue'))</code> for a balance test
of three stratification variables.
</p>


<h3>Value</h3>

<p>A <code>ggplot2</code> object that can be further manipulated (e.g., to set the colors or text).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+balanceTest">balanceTest</a></code>, <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>
</p>

<hr>
<h2 id='plot.xbal'>Plot of balance across multiple strata</h2><span id='topic+plot.xbal'></span>

<h3>Description</h3>

<p>The plot allows a quick visual comparison of the effect of different
stratification designs on the comparability of different
variables. This is not a replacement for the omnibus statistical test
reported as part of <code><a href="#topic+print.xbal">print.xbal</a></code>. This plot does allow the
analyst an easy way to identify variables that might be the primary culprits
of overall imbalances and/or a way to assess whether certain important
covariates might be imbalanced even if the omnibus test reports that
the stratification overall produces balance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xbal'
plot(
  x,
  xlab = "Standardized Differences",
  statistic = "std.diff",
  absolute = FALSE,
  strata.labels = NULL,
  variable.labels = NULL,
  groups = NULL,
  ggplot = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.xbal_+3A_x">x</code></td>
<td>
<p>An object returned by <code><a href="#topic+xBalance">xBalance</a></code></p>
</td></tr>
<tr><td><code id="plot.xbal_+3A_xlab">xlab</code></td>
<td>
<p>The label for the x-axis of the plot</p>
</td></tr>
<tr><td><code id="plot.xbal_+3A_statistic">statistic</code></td>
<td>
<p>The statistic to plot. The default choice of standardized
difference is a good choice as it will have roughly the same scale for all
plotted variables.</p>
</td></tr>
<tr><td><code id="plot.xbal_+3A_absolute">absolute</code></td>
<td>
<p>Convert the results to the absolute value of the statistic.</p>
</td></tr>
<tr><td><code id="plot.xbal_+3A_strata.labels">strata.labels</code></td>
<td>
<p>A named vector of the from <code>c(strata1 = "Strata Label 1", ...)</code>
that maps the stratification schemes to textual labels.</p>
</td></tr>
<tr><td><code id="plot.xbal_+3A_variable.labels">variable.labels</code></td>
<td>
<p>A named vector of the from <code>c(var1 = "Var Label1", ...)</code>
that maps the variables to textual labels.</p>
</td></tr>
<tr><td><code id="plot.xbal_+3A_groups">groups</code></td>
<td>
<p>A vector of group names for each variable in
<code>x$results</code>. By default, factor level variables will be
grouped.</p>
</td></tr>
<tr><td><code id="plot.xbal_+3A_ggplot">ggplot</code></td>
<td>
<p>Use ggplot2 to create figure. By default, uses base R graphics.</p>
</td></tr>
<tr><td><code id="plot.xbal_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to <code><a href="#topic+balanceplot">balanceplot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default all variables and all strata are plotted. The scope
of the plot can be reduced by using the <code><a href="#topic+subset.xbal">subset.xbal</a></code> function to
make a smaller <code>xbal</code> object with only the desired variables or
strata.
</p>
<p><code><a href="#topic+xBalance">xBalance</a></code> can produce several different summary statistics for
each variable, any of which can serve as the data for this plot. By default,
the standardized differences between treated and control units makes a good
choice as all variables are on the same scale. Other statistics can be
selected using the <code>statistic</code> argument.
</p>


<h3>Value</h3>

<p>Returns NULL, displays plot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xBalance">xBalance</a></code>, <code><a href="#topic+subset.xbal">subset.xbal</a></code>, <code><a href="#topic+balanceplot">balanceplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuclearplants)

xb &lt;- xBalance(pr ~ date + t1 + t2 + cap + ne + ct + bw + cum.n,
               strata = list(none = NULL, pt = ~pt),
               data = nuclearplants)

# Using the default grouping:
plot(xb, variable.labels = c(date = "Date",
             t1 = "Time 1",
             t2 = "Time 2",
             cap = "Capacity",
             ne = "In North East",
             ct = "Cooling Tower",
             bw = "Babcock-Wilcox",
             cum.n = "Total Plants Built"),
     strata.labels = c("--" = "Raw Data", "pt" = "Partial Turn-key"),
     absolute = TRUE)

# Using user supplied grouping
plot(xb, variable.labels = c(date = "Date",
             t1 = "Time 1",
             t2 = "Time 2",
             cap = "Capacity",
             ne = "In North East",
             ct = "Cooling Tower",
             bw = "Babcock-Wilcox",
             cum.n = "Total Plants Built"),
     strata.labels = c("--" = "Raw Data", "pt" = "Partial Turn-key"),
     absolute = TRUE,
     groups = c("Group A", "Group A", "Group A", "Group B",
                "Group B", "Group B", "Group A", "Group B"))
</code></pre>

<hr>
<h2 id='print.xbal'>Printing xBalance and balanceTest Objects</h2><span id='topic+print.xbal'></span><span id='topic+print'></span><span id='topic+print.balancetest'></span>

<h3>Description</h3>

<p>A <code>print</code> method for balance test objects produced by <code>xBalance</code> and <code>balanceTest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xbal'
print(
  x,
  which.strata = dimnames(x$results)[["strata"]],
  which.stats = dimnames(x$results)[["stat"]],
  which.vars = dimnames(x$results)[["vars"]],
  print.overall = TRUE,
  digits = NULL,
  printme = TRUE,
  show.signif.stars = getOption("show.signif.stars"),
  show.pvals = !show.signif.stars,
  horizontal = TRUE,
  report = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.xbal_+3A_x">x</code></td>
<td>
<p>An object of class &quot;xbal&quot; which is the result of a call
to <code>xBalance</code>.</p>
</td></tr>
<tr><td><code id="print.xbal_+3A_which.strata">which.strata</code></td>
<td>
<p>The stratification candidates to include in
the printout. Default is all.</p>
</td></tr>
<tr><td><code id="print.xbal_+3A_which.stats">which.stats</code></td>
<td>
<p>The test statistics to include. Default is all
those requested from the call to <code>xBalance</code>.</p>
</td></tr>
<tr><td><code id="print.xbal_+3A_which.vars">which.vars</code></td>
<td>
<p>The variables for which test information should
be displayed. Default is all.</p>
</td></tr>
<tr><td><code id="print.xbal_+3A_print.overall">print.overall</code></td>
<td>
<p>Should the omnibus test be reported? Default
is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.xbal_+3A_digits">digits</code></td>
<td>
<p>To how many digits should the results be displayed?
Default is <code>max(2,getOptions("digits")-4)</code>.</p>
</td></tr>
<tr><td><code id="print.xbal_+3A_printme">printme</code></td>
<td>
<p>Print the table to the console? Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.xbal_+3A_show.signif.stars">show.signif.stars</code></td>
<td>
<p>Use stars to indicate z-statistics larger
than conventional thresholds. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.xbal_+3A_show.pvals">show.pvals</code></td>
<td>
<p>Instead of stars, use p-values to summarize the
information in the z-statistics. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="print.xbal_+3A_horizontal">horizontal</code></td>
<td>
<p>Display the results for different candidate
stratifications side-by-side (Default, <code>TRUE</code>), or as a
list for each stratification (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="print.xbal_+3A_report">report</code></td>
<td>
<p>What to report.</p>
</td></tr>
<tr><td><code id="print.xbal_+3A_...">...</code></td>
<td>
<p>Other arguements. Not currently used.</p>
</td></tr>
</table>


<h3>Value</h3>


<dl>
<dt>vartable</dt><dd><p>The formatted table of variable-by-variable
statistics for each stratification.</p>
</dd>
<dt>overalltable</dt><dd><p>If the overall Chi-squared statistic is
requested, a formatted version of that table is returned.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+xBalance">xBalance</a></code>, <code><a href="#topic+balanceTest">balanceTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuclearplants)


xb1 &lt;- balanceTest(pr ~ date + t1 + t2 + cap + ne + ct + bw + cum.n + strata(pt),
         data = nuclearplants)

print(xb1)

print(xb1, show.pvals = TRUE)

print(xb1, horizontal = FALSE)

## The following doesn't work yet.
## Not run: print(xb1, which.vars=c("date","t1"),
         which.stats=c("adj.means","z.scores","p.values"))
## End(Not run)

## The following example prints the adjusted means
## labeled as "treatmentvar=0" and "treatmentvar=1" using the
## formula provided to xBalance().

# This is erroring with the change to devtools, FIXME
## Not run: print(xb1,
      which.vars = c("date", "t1"),
      which.stats = c("pr=0", "pr=1", "z", "p"))
## End(Not run)

## Only printing out a specific stratification factor
xb2 &lt;- balanceTest(pr~ date + t1 + t2 + cap + ne + ct + bw + cum.n + strata(pt),
         data = nuclearplants)

print(xb2, which.strata = "pt")
</code></pre>

<hr>
<h2 id='scale.DesignOptions'>Scale DesignOptions</h2><span id='topic+scale.DesignOptions'></span>

<h3>Description</h3>

<p>Scale DesignOptions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DesignOptions'
scale(x, center = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale.DesignOptions_+3A_x">x</code></td>
<td>
<p>DesignOptions object</p>
</td></tr>
<tr><td><code id="scale.DesignOptions_+3A_center">center</code></td>
<td>
<p>logical, or a function acceptable as <code>post.alignment.transform</code> arg of <code>alignDesignsByStrata()</code></p>
</td></tr>
<tr><td><code id="scale.DesignOptions_+3A_scale">scale</code></td>
<td>
<p>logical, whether to scale</p>
</td></tr>
</table>

<hr>
<h2 id='sparseToVec'>Convert Matrix to vector</h2><span id='topic+sparseToVec'></span>

<h3>Description</h3>

<p>Convert Matrix to vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sparseToVec(s, column = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseToVec_+3A_s">s</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="sparseToVec_+3A_column">column</code></td>
<td>
<p>Column (TRUE) or row (FALSE)?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>

<hr>
<h2 id='StratumWeightedDesignOptions-class'>Stratum Weighted DesignOptions</h2><span id='topic+StratumWeightedDesignOptions-class'></span>

<h3>Description</h3>

<p>Stratum Weighted DesignOptions
</p>


<h3>Slots</h3>


<dl>
<dt><code>Sweights</code></dt><dd><p>stratum weights</p>
</dd>
</dl>

<hr>
<h2 id='subset.xbal'>Select variables, strata, and statistics from a <code>xbal</code> or <code>balancetest</code> object</h2><span id='topic+subset.xbal'></span><span id='topic+subset.balancetest'></span>

<h3>Description</h3>

<p>If any of the arguments are not specified, all the of relevant
items are included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xbal'
subset(x, vars = NULL, strata = NULL, stats = NULL, tests = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset.xbal_+3A_x">x</code></td>
<td>
<p>The <code>xbal</code> object, the result of a call to
<code><a href="#topic+xBalance">xBalance</a></code> or <code><a href="#topic+balanceTest">balanceTest</a></code></p>
</td></tr>
<tr><td><code id="subset.xbal_+3A_vars">vars</code></td>
<td>
<p>The variable names to select.</p>
</td></tr>
<tr><td><code id="subset.xbal_+3A_strata">strata</code></td>
<td>
<p>The strata names to select.</p>
</td></tr>
<tr><td><code id="subset.xbal_+3A_stats">stats</code></td>
<td>
<p>The names of the variable level statistics to select.</p>
</td></tr>
<tr><td><code id="subset.xbal_+3A_tests">tests</code></td>
<td>
<p>The names of the group level tests to select.</p>
</td></tr>
<tr><td><code id="subset.xbal_+3A_...">...</code></td>
<td>
<p>Other arguments (ignored)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>xbal</code> object with just the appropriate items
selected.
</p>

<hr>
<h2 id='tidy.xbal'><code>broom::tidy()</code>/<code>glance()</code> methods for <code>balanceTest()</code> results</h2><span id='topic+tidy.xbal'></span><span id='topic+glance.xbal'></span>

<h3>Description</h3>

<p>Portion out the value of a <code><a href="#topic+balanceTest">balanceTest()</a></code> call in a manner consistent
with assumptions of the broom package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy.xbal(
  x,
  strata = dimnames(x[["results"]])[["strata"]][1],
  varnames_crosswalk = c(z = "statistic", p = "p.value"),
  format = FALSE,
  digits = max(2, getOption("digits") - 4),
  ...
)

glance.xbal(x, strata = dimnames(x[["results"]])[["strata"]][1], ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy.xbal_+3A_x">x</code></td>
<td>
<p>object of class <code>"xbal"</code>, result of <code><a href="#topic+balanceTest">balanceTest()</a></code>
or <code><a href="#topic+xBalance">xBalance()</a></code></p>
</td></tr>
<tr><td><code id="tidy.xbal_+3A_strata">strata</code></td>
<td>
<p>which stratification to return info about? Defaults
to last one specified in originating function call (which appears first in the xbal array).</p>
</td></tr>
<tr><td><code id="tidy.xbal_+3A_varnames_crosswalk">varnames_crosswalk</code></td>
<td>
<p>character vector of new names for xbal columns, named by the xbal column</p>
</td></tr>
<tr><td><code id="tidy.xbal_+3A_format">format</code></td>
<td>
<p>if true, apply <code style="white-space: pre;">&#8288;[RItools:::original_units_var_formatter()]&#8288;</code> to suitable sub-array en route</p>
</td></tr>
<tr><td><code id="tidy.xbal_+3A_digits">digits</code></td>
<td>
<p>passed to <code style="white-space: pre;">&#8288;[RItools:::original_units_var_formatter()]&#8288;</code></p>
</td></tr>
<tr><td><code id="tidy.xbal_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code style="white-space: pre;">&#8288;[RItools:::original_units_var_formatter()]&#8288;</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+tidy.xbal">tidy.xbal()</a></code> gives per-variable
statistics whereas <code><a href="#topic+glance.xbal">glance.xbal()</a></code> extracts combined-difference related
calculations. In both cases one has to specify which stratification one wants
statistics about, as xbal objects can store info about several stratifications.
<code><a href="#topic+tidy.xbal">tidy.xbal()</a></code> has a parameter <code>varnames_crosswalk</code> not shared with
<code><a href="#topic+glance.xbal">glance.xbal()</a></code>. It should be a named character vector, the elements
of which give names of columns to be returned and the names of which correspond
to columns of xbal objects' &lsquo;results&rsquo; entry.  Its ordering dictates the order
of the result. The default value translates between conventional xbal
column names and broom package conventional names.
</p>

<dl>
<dt>vars</dt><dd><p>variable name</p>
</dd>
<dt>Control</dt><dd><p>mean of LHS variable = 0 group</p>
</dd>
<dt>Treatment</dt><dd><p> mean of LHS variable = 1 group</p>
</dd>
<dt>adj.diff</dt><dd><p>T - C diff w/ direct standardization for strata if applicable</p>
</dd>
<dt>std.diff</dt><dd><p>adj.diff/pooled.sd</p>
</dd>
<dt>pooled.sd</dt><dd><p>pooled SD</p>
</dd>
<dt>statistic</dt><dd><p><code>z</code> column from the xbal object</p>
</dd>
<dt>p.value</dt><dd><p><code>p</code> column from the xbal object</p>
</dd>
</dl>

<p>Additional parameters beyond those listed here are ignored (at this time).
</p>


<h3>Value</h3>

<p>data frame composed of: for <code style="white-space: pre;">&#8288;[RItools::tidy()]&#8288;</code>, a column of variable labels (<code>vars</code>) and
additional columns of balance-related stats; for <code style="white-space: pre;">&#8288;[RItools::glance()]&#8288;</code>, scalars describing
a combined differences test, if found, and otherwise <code>NULL</code>.
</p>

<hr>
<h2 id='withOptions'>Safe way to temporarily override options()</h2><span id='topic+withOptions'></span>

<h3>Description</h3>

<p>Safe way to temporarily override options()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>withOptions(optionsToChange, fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="withOptions_+3A_optionstochange">optionsToChange</code></td>
<td>
<p>Which options.</p>
</td></tr>
<tr><td><code id="withOptions_+3A_fun">fun</code></td>
<td>
<p>Function to run with new options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Result of <code>fun</code>.
</p>

<hr>
<h2 id='xBalance'>Standardized Differences for Stratified Comparisons</h2><span id='topic+xBalance'></span>

<h3>Description</h3>

<p>Given covariates, a treatment variable, and a stratifying factor,
calculates standardized mean differences along each covariate,
with and without the stratification and tests for conditional
independence of the treatment variable and the covariates within
strata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xBalance(
  fmla,
  strata = list(unstrat = NULL),
  data,
  report = c("std.diffs", "z.scores", "adj.means", "adj.mean.diffs",
    "adj.mean.diffs.null.sd", "chisquare.test", "p.values", "all")[1:2],
  stratum.weights = harmonic,
  na.rm = FALSE,
  covariate.scaling = NULL,
  normalize.weights = TRUE,
  impfn = median,
  post.alignment.transform = NULL,
  pseudoinversion_tol = .Machine$double.eps
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xBalance_+3A_fmla">fmla</code></td>
<td>
<p>A formula containing an indicator of treatment
assignment on the left hand side and covariates at right.</p>
</td></tr>
<tr><td><code id="xBalance_+3A_strata">strata</code></td>
<td>
<p>A list of right-hand-side-only formulas containing
the factor(s) identifying the strata, with <code>NULL</code> entries
interpreted as no stratification; or a factor with length equal
to the number of rows in data; or a data frame of such
factors. See below for examples.</p>
</td></tr>
<tr><td><code id="xBalance_+3A_data">data</code></td>
<td>
<p>A data frame in which <code>fmla</code> and <code>strata</code>
are to be evaluated.</p>
</td></tr>
<tr><td><code id="xBalance_+3A_report">report</code></td>
<td>
<p>Character vector listing measures to report for each
stratification; a subset of <code>c("adj.means",
"adj.mean.diffs", "adj.mean.diffs.null.sd", "chisquare.test",
"std.diffs", "z.scores", "p.values", "all")</code>. P-values reported
are two-sided for the null-hypothesis of no effect. The option
&quot;all&quot; requests all measures.</p>
</td></tr>
<tr><td><code id="xBalance_+3A_stratum.weights">stratum.weights</code></td>
<td>
<p>Weights to be applied when aggregating
across strata specified by <code>strata</code>, defaulting to weights
proportional to the harmonic mean of treatment and control group
sizes within strata.  This can be either a function used to
calculate the weights or the weights themselves; if
<code>strata</code> is a data frame, then it can be such a function, a
list of such functions, or a data frame of stratum weighting
schemes corresponding to the different stratifying factors of
<code>strata</code>.  See details.</p>
</td></tr>
<tr><td><code id="xBalance_+3A_na.rm">na.rm</code></td>
<td>
<p>Whether to remove rows with NAs on any variables
mentioned on the RHS of <code>fmla</code> (i.e. listwise deletion).
Defaults to <code>FALSE</code>, wherein rows aren't deleted but for
each variable with <code>NA</code>s a missing-data indicator variable
is added to the variables on which balance is calculated and
medians are imputed for the variable with missing data (in
RItools versions 0.1-9 and before the default imputation was the
mean, in RItools versions 0.1-11 and henceforth the default is
the median). See the example below.</p>
</td></tr>
<tr><td><code id="xBalance_+3A_covariate.scaling">covariate.scaling</code></td>
<td>
<p>A scale factor to apply to covariates in
calculating <code>std.diffs</code>.  If <code>NULL</code>, <code>xBalance</code>
pools standard deviations of each variable in the treatment and
control group (defining these groups according to whether the
LHS of <code>formula</code> is greater than or equal to 0).  Also, see
details.</p>
</td></tr>
<tr><td><code id="xBalance_+3A_normalize.weights">normalize.weights</code></td>
<td>
<p>If <code>TRUE</code>, then stratum weights are
normalized so as to sum to 1.  Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="xBalance_+3A_impfn">impfn</code></td>
<td>
<p>A function to impute missing values when
<code>na.rm=FALSE</code>. Currently <code><a href="stats.html#topic+median">median</a></code>. To impute
means use <code><a href="base.html#topic+mean.default">mean.default</a></code>.</p>
</td></tr>
<tr><td><code id="xBalance_+3A_post.alignment.transform">post.alignment.transform</code></td>
<td>
<p>Optional transformation applied to
covariates just after their stratum means are subtracted off.</p>
</td></tr>
<tr><td><code id="xBalance_+3A_pseudoinversion_tol">pseudoinversion_tol</code></td>
<td>
<p>The function uses a singular value decomposition
to invert a covariance matrix. Singular values less than this tolerance
will be treated as zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: the newer <code><a href="#topic+balanceTest">balanceTest</a></code> function provides the same
functionality as <code>xBalance</code> with additional support for clustered
designs. While there are no plans to deprecate <code>xBalance</code>, users are
encouraged to use <code>balanceTest</code> going forward.
</p>
<p>In the unstratified case, the standardized difference of covariate
means is the mean in the treatment group minus the mean in the
control group, divided by the S.D. (standard deviation) in the
same variable estimated by pooling treatment and control group
S.D.s on the same variable.  In the stratified case, the
denominator of the standardized difference remains the same but
the numerator is a weighted average of within-stratum differences
in means on the covariate.  By default, each stratum is weighted
in proportion to the harmonic mean <code class="reqn">1/[(1/a +
1/b)/2]=2*a*b/(a+b)</code> of the number of treated units (a) and
control units (b) in the stratum; this weighting is optimal under
certain modeling assumptions (discussed in Kalton 1968, Hansen and
Bowers 2008).  This weighting can be modified using the
<code>stratum.weights</code> argument; see below.
</p>
<p>When the treatment variable, the variable specified by the
left-hand side of <code>fmla</code>, is not binary, <code>xBalance</code>
calculates the covariates' regressions on the treatment variable,
in the stratified case pooling these regressions across strata
using weights that default to the stratum-wise sum of squared
deviations of the treatment variable from its stratum mean.
(Applied to binary treatment variables, this recipe gives the same
result as the one given above.)  In the numerator of the
standardized difference, we get a &ldquo;pooled S.D.&rdquo; from separating
units into two groups, one in which the treatment variable is 0 or
less and another in which it is positive.  If <code>report</code>
includes &quot;adj.means&quot;, covariate means for the former of these
groups are reported, along with the sums of these means and the
covariates' regressions on either the treatment variable, in the
unstratified (&ldquo;pre&rdquo;) case, or the treatment variable and the
strata, in the stratified (&ldquo;post&rdquo;) case.
</p>
<p><code>stratum.weights</code> can be either a function or a numeric
vector of weights.  If it is a numeric vector, it should be
non-negative and it should have stratum names as its names. (i.e.,
its names should be equal to the levels of the factor specified by
<code>strata</code>.) If it is a function, it should accept one
argument, a data frame containing the variables in <code>data</code> and
additionally <code>Tx.grp</code> and <code>stratum.code</code>, and return a
vector of non-negative weights with stratum codes as names; for an
example, do <code>getFromNamespace("harmonic", "RItools")</code>.
</p>
<p>If <code>covariate.scaling</code> is not <code>NULL</code>, no scaling is
applied. This behavior is likely to change in future versions.
(If you want no scaling, set <code>covariate.scaling=1</code>, as this
is likely to retain this meaning in the future.)
</p>
<p><code>adj.mean.diffs.null.sd</code> returns the standard deviation of
the Normal approximated randomization distribution of the
strata-adjusted difference of means under the strict null of no
effect.
</p>


<h3>Value</h3>

<p>An object of class <code>c("xbal", "list")</code>.  There are
<code>plot</code>, <code>print</code>, and <code>xtable</code> methods for class
<code>"xbal"</code>; the <code>print</code> method is demonstrated in the
examples.
</p>


<h3>Note</h3>

<p>Evidence pertaining to the hypothesis that a treatment
variable is not associated with differences in covariate values
is assessed by comparing the differences of means (or regression
coefficients), without standardization, to their distributions
under hypothetical shuffles of the treatment variable, a
permutation or randomization distribution.  For the unstratified
comparison, this reference distribution consists of differences
(more generally, regression coefficients) when the treatment
variable is permuted without regard to strata.  For the
stratified comparison, the reference distribution is determined
by randomly permuting the treatment variable within strata, then
re-calculating the treatment-control differences (regressions of
each covariate on the permuted treatment variable). Significance
assessments are based on the large-sample Normal approximation
to these reference distributions.
</p>


<h3>Author(s)</h3>

<p>Ben Hansen and Jake Bowers and Mark Fredrickson
</p>


<h3>References</h3>

<p>Hansen, B.B. and Bowers, J. (2008), &ldquo;Covariate
Balance in Simple, Stratified and Clustered Comparative
Studies,&rdquo; <em>Statistical Science</em> <b>23</b>.
</p>
<p>Kalton, G. (1968), &ldquo;Standardization: A technique to control for
extraneous variables,&rdquo; <em>Applied Statistics</em> <b>17</b>,
118&ndash;136.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+balanceTest">balanceTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuclearplants)
##No strata, default output
xBalance(pr~ date + t1 + t2 + cap + ne + ct + bw + cum.n,
         data=nuclearplants)

##No strata, all output
xBalance(pr~ date + t1 + t2 + cap + ne + ct + bw + cum.n,
         data=nuclearplants,
         report=c("all"))

##Stratified, all output
xBalance(pr~.-cost-pt, strata=factor(nuclearplants$pt),
         data=nuclearplants,
         report=c("adj.means", "adj.mean.diffs",
                  "adj.mean.diffs.null.sd",
                  "chisquare.test", "std.diffs",
                  "z.scores", "p.values"))

##Comparing unstratified to stratified, just adjusted means and
#omnibus test
xBalance(pr~ date + t1 + t2 + cap + ne + ct + bw + cum.n,
         strata=list(unstrat=NULL, pt=~pt),
         data=nuclearplants,
         report=c("adj.means", "chisquare.test"))

##Comparing unstratified to stratified, just adjusted means and
#omnibus test
xBalance(pr~ date + t1 + t2 + cap + ne + ct + bw + cum.n,
         strata=data.frame(unstrat=factor('none'),
           pt=factor(nuclearplants$pt)),
         data=nuclearplants,
         report=c("adj.means", "chisquare.test"))

##Missing data handling.
testdata&lt;-nuclearplants
testdata$date[testdata$date&lt;68]&lt;-NA

##na.rm=FALSE by default
xBalance(pr ~ date, data = testdata, report="all")
xBalance(pr ~ date, data = testdata, na.rm = TRUE,report="all")

##To match versions of RItools 0.1-9 and older, impute means
#rather than medians.
##Not run, impfn option is not implemented in the most recent version
## Not run: xBalance(pr ~ date, data = testdata, na.rm = FALSE,
           report="all", impfn=mean.default)
## End(Not run)

##Comparing unstratified to stratified, just one-by-one wilcoxon
#rank sum tests and omnibus test of multivariate differences on
#rank scale.
xBalance(pr~ date + t1 + t2 + cap + ne + ct + bw + cum.n,
         strata=data.frame(unstrat=factor('none'),
           pt=factor(nuclearplants$pt)),
         data=nuclearplants,
         report=c("adj.means", "chisquare.test"),
	 post.alignment.transform=rank)
</code></pre>

<hr>
<h2 id='xBalance.find.goodstrats'>xBalance helper function</h2><span id='topic+xBalance.find.goodstrats'></span>

<h3>Description</h3>

<p>Finds good strata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xBalance.find.goodstrats(ss.df, zz, mm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xBalance.find.goodstrats_+3A_ss.df">ss.df</code></td>
<td>
<p>Degrees of freedom.</p>
</td></tr>
<tr><td><code id="xBalance.find.goodstrats_+3A_zz">zz</code></td>
<td>
<p>Treatment</p>
</td></tr>
<tr><td><code id="xBalance.find.goodstrats_+3A_mm">mm</code></td>
<td>
<p>mm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data.frame
</p>

<hr>
<h2 id='xBalance.makepooledsd'>xBalance helper function</h2><span id='topic+xBalance.makepooledsd'></span>

<h3>Description</h3>

<p>Make pooled SD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xBalance.makepooledsd(zz, mm, pre.n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xBalance.makepooledsd_+3A_zz">zz</code></td>
<td>
<p>Treatment</p>
</td></tr>
<tr><td><code id="xBalance.makepooledsd_+3A_mm">mm</code></td>
<td>
<p>mm</p>
</td></tr>
<tr><td><code id="xBalance.makepooledsd_+3A_pre.n">pre.n</code></td>
<td>
<p>pre.n</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pooled SD
</p>

<hr>
<h2 id='xtable.xbal'>An <code>xtable</code> method for <code>xbal</code> and <code>balancetest</code> objects</h2><span id='topic+xtable.xbal'></span><span id='topic+xtable.balancetest'></span>

<h3>Description</h3>

<p>This function uses the <code><a href="xtable.html#topic+xtable">xtable</a></code> package
framework to display the results of a call to
<code><a href="#topic+balanceTest">balanceTest</a></code> in LaTeX format. At the moment, it ignores
the omnibus chi-squared test information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'xbal'
xtable(
  x,
  caption = NULL,
  label = NULL,
  align = c("l", rep("r", ncol(xvardf))),
  digits = 2,
  display = NULL,
  auto = FALSE,
  col.labels = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xtable.xbal_+3A_x">x</code></td>
<td>
<p>An object resulting from a call to
<code><a href="#topic+balanceTest">balanceTest</a></code> or <code><a href="#topic+xBalance">xBalance</a></code>.</p>
</td></tr>
<tr><td><code id="xtable.xbal_+3A_caption">caption</code></td>
<td>
<p>See <code><a href="xtable.html#topic+xtable">xtable</a></code>.</p>
</td></tr>
<tr><td><code id="xtable.xbal_+3A_label">label</code></td>
<td>
<p>See <code><a href="xtable.html#topic+xtable">xtable</a></code>.</p>
</td></tr>
<tr><td><code id="xtable.xbal_+3A_align">align</code></td>
<td>
<p>See <code><a href="xtable.html#topic+xtable">xtable</a></code>. Our default (as of
version 0.1-7) is right-aligned columns; for decimal aligned
columns, see details, below.</p>
</td></tr>
<tr><td><code id="xtable.xbal_+3A_digits">digits</code></td>
<td>
<p>See <code><a href="xtable.html#topic+xtable">xtable</a></code>. Default is 2.</p>
</td></tr>
<tr><td><code id="xtable.xbal_+3A_display">display</code></td>
<td>
<p>See <code><a href="xtable.html#topic+xtable">xtable</a></code>.</p>
</td></tr>
<tr><td><code id="xtable.xbal_+3A_auto">auto</code></td>
<td>
<p>See <code><a href="xtable.html#topic+xtable">xtable</a></code>.</p>
</td></tr>
<tr><td><code id="xtable.xbal_+3A_col.labels">col.labels</code></td>
<td>
<p>Labels for the columns (the test
statistics). Default are come from the call to
<code><a href="#topic+print.xbal">print.xbal</a></code>.</p>
</td></tr>
<tr><td><code id="xtable.xbal_+3A_...">...</code></td>
<td>
<p>Other arguments to <code><a href="#topic+print.xbal">print.xbal</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting LaTeX will present one row for each variable in the
formula originally passed to <code><a href="#topic+balanceTest">balanceTest</a></code>, using the
variable name used in the original formula. If you wish to have
reader friendly labels instead of the original variables names,
see the code examples below.
</p>
<p>To get decimal aligned columns, specify <code>align=c("l",
rep(".", &lt;ncols&gt;))</code>, where <code>&lt;ncols&gt;</code> is the number of columns
to be printed, in your call to <code>xtable</code>.  Then use the
<code>dcolumn</code> package and define &lsquo;<span class="samp">&#8288;'.'&#8288;</span>&rsquo; within LaTeX: add the
lines <code>\usepackage{dcolumn}</code> and
<code>\newcolumntype{.}{D{.}{.}{2.2}}</code> to your LaTeX
document's preamble.
</p>


<h3>Value</h3>

<p>This function produces an <code>xtable</code> object which can
then be printed with the appropriate <code>print</code> method (see
<code><a href="xtable.html#topic+print.xtable">print.xtable</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(nuclearplants)
require(xtable)

# Test balance on a variety of variables, with the 'pr' factor
# indicating which sites are control and treatment units, with
# stratification by the 'pt' factor to group similar sites
xb1 &lt;- balanceTest(pr ~ date + t1 + t2 + cap + ne + ct + bw + cum.n + strata(pt),
                data = nuclearplants)

xb1.xtab &lt;- xtable(xb1) # This table has right aligned columns

# Add user friendly names in the final table
rownames(xb1.xtab) &lt;- c("Date", "Application to Contruction Time",
"License to Construction Time", "Net Capacity", "Northeast Region", "Cooling Tower",
"Babcock-Wilcox Steam", "Cumlative Plants")

print(xb1.xtab,
      add.to.row = attr(xb1.xtab, "latex.add.to.row"),
      hline.after = c(0, nrow(xb1.xtab)),
      sanitize.text.function = function(x){x},
      floating = TRUE,
      floating.environment = "sidewaystable")
</code></pre>

<hr>
<h2 id='ym_long'>ASSIST Trial Data from Yudkin and Moher 2001</h2><span id='topic+ym_long'></span>

<h3>Description</h3>

<p>The ASSIST Trial baseline data from Yudkin and Moher 2001 consist of 21
general practices containing 2142 patients used for the design of a
randomized trial which assigned to three treatments aiming to compare methods
of preventing coronary heart disease. We have expanded the aggregated data
from the practice level to the individual level and added a simulated
randomized treatment variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ym_long
</code></pre>


<h3>Format</h3>

<p>A data frame with  2142 rows and 9 columns
</p>

<ul>
<li><p> practice: Identifier for the practice
</p>
</li>
<li><p> id: Identifier for patients
</p>
</li>
<li><p> n_practice: Number of patients with CHD in the practice
</p>
</li>
<li><p> assessed: Whether a patient was coded as &quot;adequately assessed&quot; (the
outcome of the study, measured here at baseline).
</p>
</li>
<li><p> aspirin: Whether a patient was treated with aspirin at baseline.
</p>
</li>
<li><p> hypo: Whether a patient was treated with hypotensives at
baseline.
</p>
</li>
<li><p> lipid: Whether patient was treated with lipid-lowering drugs
at baseline.
</p>
</li>
<li><p> assess_strata: Strata of the practice defined by the proportion of
people adequately assessed at baseline (three strata, following Yudkin
and Moher 2001).
</p>
</li>
<li><p> trt: A simulated binary treatment, assigned at random at the practice
level within levels of assess_strata.
</p>
</li></ul>



<h3>Source</h3>

<p>The data come from Table II on page 345 of Yudkin and Moher 2001,
Statistics in Medicine.
</p>


<h3>References</h3>

<p>Yudkin, P. L. and Moher, M. 2001. &quot;Putting theory into practice:
a cluster randomized trial with a small number of clusters&quot; <em>Statistics
in Medicine</em>, 20:341-349.
</p>

<hr>
<h2 id='ym_short'>ASSIST Trial Data from Yudkin and Moher 2001</h2><span id='topic+ym_short'></span>

<h3>Description</h3>

<p>The ASSIST Trial baseline data from Yudkin and Moher 2001 consist of 21
general practices containing 2142 patients used for the design of a
randomized trial which assigned to three treatments aiming to compare methods
of preventing coronary heart disease. This data frame is aggregated
to the practice level. We added a simulated randomized treatment variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ym_short
</code></pre>


<h3>Format</h3>

<p>A data frame with  21 rows and 8 columns
</p>

<ul>
<li><p> practice: Identifier for the practice
</p>
</li>
<li><p> n_practice: Number of patients with CHD in the practice
</p>
</li>
<li><p> assessed: Whether a patient was coded as &quot;adequately assessed&quot; (the
outcome of the study, measured here at baseline).
</p>
</li>
<li><p> aspirin: Whether a patient was treated with aspirin at baseline.
</p>
</li>
<li><p> hypo: Whether a patient was treated with hypotensives at
baseline.
</p>
</li>
<li><p> lipid: Whether patient was treated with lipid-lowering drugs
at baseline.
</p>
</li>
<li><p> assess_strata: Strata of the practice defined by the proportion of
people adequately assessed at baseline (three strata, following Yudkin
and Moher 2001).
</p>
</li>
<li><p> trt: A simulated binary treatment, assigned at random at the practice
level within levels of assess_strata.
</p>
</li></ul>



<h3>Source</h3>

<p>The data come from Table II on page 345 of Yudkin and Moher 2001,
Statistics in Medicine.
</p>


<h3>References</h3>

<p>Yudkin, P. L. and Moher, M. 2001. &quot;Putting theory into practice:
a cluster randomized trial with a small number of clusters&quot; <em>Statistics
in Medicine</em>, 20:341-349.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
