<!DOCTYPE html><html><head><title>Help for package complexlm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {complexlm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anova.zlm'><p>ANOVA for Complex Linear Fits</p></a></li>
<li><a href='#complexdqlrs'><p>An alternative to <code style="white-space: pre;">&#8288;.Call(C_Cdqlrs, x * wts, y * wts, tol, FALSE))&#8288;</code> that is compatible with complex variables</p></a></li>
<li><a href='#complexlm-package'><p>complexlm: Linear Fitting for Complex Valued Data</p></a></li>
<li><a href='#cooks.distance.zlm'><p>Cook's Distance for Complex Linear Models</p></a></li>
<li><a href='#cov'><p>Variance, Covariance, and Correlation for Complex Data</p></a></li>
<li><a href='#CuHallData'><p>AC (Complex) Hall effect data measured from a thin-film copper sample.</p></a></li>
<li><a href='#lm'><p>Linear Model Fitting for Complex or Numeric Variables</p></a></li>
<li><a href='#lm.fit'><p>Complex Variable Compatible Wrappers for <code>stats::lm.fit()</code> and <code>stats::lm.wfit()</code></p></a></li>
<li><a href='#mad'><p>Median Absolute Deviation, compatible with complex variables</p></a></li>
<li><a href='#mahalanobis'><p>Mahalanobis Distance, with better complex behavior</p></a></li>
<li><a href='#matrixweave'><p>Combine covariance matrix and pseudo covariance matrix into a &quot;double covariance matrix&quot;</p></a></li>
<li><a href='#median.complex'><p>Improved Median for Complex Numbers</p></a></li>
<li><a href='#plot.zlm'><p>Plot Diagnostics for a Complex Linear Model Objects</p></a></li>
<li><a href='#psi.huber'><p>Weighting functions for robust fitting</p></a></li>
<li><a href='#range'><p>Range For Complex Objects</p></a></li>
<li><a href='#rlm'><p>Robust Fitting of Linear Models, Compatible with Complex Variables</p></a></li>
<li><a href='#rstandard.zlm'><p>Standardized Residuals from Ordinary or Robust Linear fits with Complex Variables</p></a></li>
<li><a href='#summary.complex'><p>summary method for complex objects</p></a></li>
<li><a href='#summary.rzlm'><p>Summary Method for Robust Linear Models</p></a></li>
<li><a href='#summary.zlm'><p>Summarize Complex Linear Model Fits.</p></a></li>
<li><a href='#vcov.rzlm'><p>Calculate Variance-Covariance Matrix and Pseudo Variance-Covariance Matrix for a Complex Fitted Model Object</p></a></li>
<li><a href='#vcov.zlm'><p>Calculate Variance-Covariance Matrix and Pseudo Variance-Covariance Matrix for a Complex Fitted Model Object</p></a></li>
<li><a href='#wmedian'><p>Weighted Median</p></a></li>
<li><a href='#zhatvalues'><p>Generate the Hat Matrix or Leverage Scores of a Complex Linear Model</p></a></li>
<li><a href='#zlm.wfit'><p>Least-Squares Linear Fitting for Complex Variables</p></a></li>
<li><a href='#zmodel.matrix'><p>Generate a Model Matrix (Design Matrix) Using Complex Variables</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-18</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), MASS</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, pracma, graphics, stats, mathjaxr, methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dplyr, ggforce, ggplot2, reshape2, utils</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for linear fitting with complex variables. Includes ordinary least-squares (zlm()) and robust M-estimation (rzlm()), and complex methods for oft used generics. Originally adapted from the rlm() functions of 'MASS' and the lm() functions of 'stats'.</td>
</tr>
<tr>
<td>Title:</td>
<td>Linear Fitting for Complex Valued Data</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/QuantumOfMoose/complexlm">https://github.com/QuantumOfMoose/complexlm</a></td>
</tr>
<tr>
<td>Contact:</td>
<td>&lt;wryan1@binghamton.edu&gt;</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-22 18:37:21 UTC; billy</td>
</tr>
<tr>
<td>Author:</td>
<td>William Ryan [aut, cre, cph],
  Bruce White [ths],
  Brian Ripley [ctb, cph] (Wrote 'MASS' rlm() code upon which complexlm
    rlm() is based),
  Bill Venables [ctb] (Wrote 'MASS' rlm() code upon which complexlm rlm()
    is based),
  John Maindonald [ctb] (Wrote plot.lm() on which plot.zlm() is based),
  Martin Maechler [ctb] (Wrote plot.lm() on which plot.zlm() is based),
  R Core Team [ctb, cph] (Several functions in 'complexlm' are based on
    similar functions in 'base' or 'stats')</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>William Ryan &lt;wryan1@binghamton.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-14 03:20:02 UTC</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
</table>
<hr>
<h2 id='anova.zlm'>ANOVA for Complex Linear Fits</h2><span id='topic+anova.zlm'></span><span id='topic+anova.zlmlist'></span>

<h3>Description</h3>

<p>A very simple adaptation of <a href="stats.html#topic+anova.lm">stats::anova.lm</a> which can handle fits of complex variables.
The only change was to take the absolute value of squared residuals, and eliminate quantile based features.
Note that this function uses the variance, not the pseudo-variance. An analysis of pseudo-variance (ANOPVA)
is also possible (and maybe useful), but not yet implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zlm'
anova(object, ...)

## S3 method for class 'zlmlist'
anova(object, ..., scale = 0, test = "F")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anova.zlm_+3A_object">object</code></td>
<td>
<p>objects of class &quot;zlm&quot;, usually produced by <a href="#topic+lm">lm</a>.</p>
</td></tr>
<tr><td><code id="anova.zlm_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
<tr><td><code id="anova.zlm_+3A_scale">scale</code></td>
<td>
<p>numeric. An estimate of the noise variance
<code class="reqn">\sigma^2</code>. If zero this will be estimated from the
largest model considered.
</p>
</td></tr>
<tr><td><code id="anova.zlm_+3A_test">test</code></td>
<td>
<p>a character string specifying the test statistic to be
used. Can be one of <code>"F"</code>, <code>"Chisq"</code> or <code>"Cp"</code>,
with partial matching allowed, or <code>NULL</code> for no test.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Specifying a single object gives a sequential analysis of variance
table for that fit.  That is, the reductions in the residual sum of
squares as each term of the formula is added in turn are given in as
the rows of a table, plus the residual sum of squares.
</p>
<p>The table will contain F statistics (and P values) comparing the
mean square for the row to the residual mean square.
</p>
<p>If more than one object is specified, the table has a row for the
residual degrees of freedom and sum of squares for each model.
For all but the first model, the change in degrees of freedom and sum
of squares is also given. (This only make statistical sense if the
models are nested.)  It is conventional to list the models from
smallest to largest, but this is up to the user.
</p>
<p>Optionally the table can include test statistics.  Normally the
F statistic is most appropriate, which compares the mean square for a
row to the residual sum of squares for the largest model considered.
If <code>scale</code> is specified chi-squared tests can be used. Mallows'
<code class="reqn">C_p</code> statistic is the residual sum of squares plus twice the
estimate of <code class="reqn">\sigma^2</code> times the residual degrees of freedom.
</p>


<h3>Value</h3>

<p>An object of class &quot;anova&quot;, which inherits from class &quot;data.frame&quot;. Contains a analysis of variance table, except for those components that rely on quantiles.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>anova.zlmlist</code>: s3 method for class 'zlmlist'
</p>
</li></ul>


<h3>References</h3>

<p>Chambers, J. M. (1992)
<em>Linear models.</em>
Chapter 4 of <em>Statistical Models in S</em>
eds J. M. Chambers and T. J. Hastie, Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><a href="#topic+lm">lm</a>, <a href="stats.html#topic+anova">anova</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 8
slop &lt;- complex(real = 4.23, imaginary = 2.323)
interc &lt;- complex(real = 1.4, imaginary = 1.804)
err &lt;- complex(real = rnorm(n)/16, imaginary = rnorm(n)/16)
tframe &lt;- data.frame(x= x &lt;- complex(real=rnorm(n), imaginary= rnorm(n)), y=slop*x + interc+err)
fit &lt;- lm(y ~ x, data = tframe, weights = rep(1,n))
anova(fit)
robfit &lt;- rlm(y ~ x, data = tframe)
anova(fit, robfit)
</code></pre>

<hr>
<h2 id='complexdqlrs'>An alternative to <code style="white-space: pre;">&#8288;.Call(C_Cdqlrs, x * wts, y * wts, tol, FALSE))&#8288;</code> that is compatible with complex variables</h2><span id='topic+complexdqlrs'></span>

<h3>Description</h3>

<p>This serves as a wrapper for qr, replicating the behavior and output of the C++ function <code>C_Cdqlrs</code>. It is used in <code>zlm.wfit</code>,
and is unlikely to be needed by end users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>complexdqlrs(x, y, tol = 1e-07, chk)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="complexdqlrs_+3A_x">x</code></td>
<td>
<p>a complex matrix (will also accept numeric, but in that case you might as well use <code>C_Cdqlrs</code>) whose QR decomposition is to be computed.</p>
</td></tr>
<tr><td><code id="complexdqlrs_+3A_y">y</code></td>
<td>
<p>a complex vector or matrix of right-hand side quantities.</p>
</td></tr>
<tr><td><code id="complexdqlrs_+3A_tol">tol</code></td>
<td>
<p>the tolerance for detecting linear dependencies in the columns of x. Not used for complex <code>x</code>.</p>
</td></tr>
<tr><td><code id="complexdqlrs_+3A_chk">chk</code></td>
<td>
<p>not used. Included to better imitate <code>C_Cdqlrs</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that includes the qr decomposition, its coeffcionts, residuals, effects, rank, pivot information, qraux vector,
tolerance, and whether or not it was pivoted. This is the same output as <code>C_Cdqlrs</code>.
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+qr">base::qr</a>, <a href="#topic+lm">lm</a>, <a href="#topic+zlm.wfit">zlm.wfit</a>, <a href="#topic+rlm">rlm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 8
slope &lt;- complex(real = 4.23, imaginary = 2.323)
intercept &lt;- complex(real = 1.4, imaginary = 1.804)
x &lt;- complex(real = rnorm(n), imaginary = rnorm(n))
y &lt;- slope * x + intercept
complexdqlrs(x, y, 10^-4, 1.2)
</code></pre>

<hr>
<h2 id='complexlm-package'>complexlm: Linear Fitting for Complex Valued Data</h2><span id='topic+complexlm'></span><span id='topic+complexlm-package'></span>

<h3>Description</h3>

<p>Tools for linear fitting with complex variables. Includes ordinary least-squares (zlm()) and robust M-estimation (rzlm()), and complex methods for oft used generics. Originally adapted from the rlm() functions of 'MASS' and the lm() functions of 'stats'.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: William Ryan <a href="mailto:wryan1@binghamton.edu">wryan1@binghamton.edu</a> [copyright holder]
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Bruce White [thesis advisor]
</p>
</li>
<li><p> Brian Ripley (Wrote 'MASS' rlm() code upon which complexlm rlm() is based) [contributor, copyright holder]
</p>
</li>
<li><p> Bill Venables (Wrote 'MASS' rlm() code upon which complexlm rlm() is based) [contributor]
</p>
</li>
<li><p> John Maindonald (Wrote plot.lm() on which plot.zlm() is based) [contributor]
</p>
</li>
<li><p> Martin Maechler (Wrote plot.lm() on which plot.zlm() is based) [contributor]
</p>
</li>
<li><p> R Core Team (Several functions in 'complexlm' are based on similar functions in 'base' or 'stats') [contributor, copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/QuantumOfMoose/complexlm">https://github.com/QuantumOfMoose/complexlm</a>
</p>
</li></ul>


<hr>
<h2 id='cooks.distance.zlm'>Cook's Distance for Complex Linear Models</h2><span id='topic+cooks.distance.zlm'></span>

<h3>Description</h3>

<p>Calculates the Cook's distances (technically a divergence, i.e. distance squared) of a complex linear model.
These serve as a measurement of how much each input data point had on the model.<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zlm'
cooks.distance(model, lever = zhatvalues(model), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cooks.distance.zlm_+3A_model">model</code></td>
<td>
<p>An object of class &quot;lm&quot; or &quot;rlm&quot;. Can be complex or numeric.</p>
</td></tr>
<tr><td><code id="cooks.distance.zlm_+3A_lever">lever</code></td>
<td>
<p>A list of leverage scores with the same length as <code>model$residuals</code>. By default <a href="#topic+zhatvalues">zhatvalues</a> is called on <code>model</code>.</p>
</td></tr>
<tr><td><code id="cooks.distance.zlm_+3A_...">...</code></td>
<td>
<p>Other parameters. Only used if <code>model</code> is numeric; in which case they are passed to <code>stats::cooks.distance</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider a linear model relating a response vector <code>y</code> to a predictor vector <code>x</code>, both of length <code>n</code>. Using the model and predictor vector we can
calculate a vector of predicted values <code>yh</code>. <code>y</code> and <code>yh</code> are points in a <code>n</code> dimensional output space. If we drop the <code>i</code>-th element of <code>x</code> and <code>y</code>, then fit another
model using the &quot;dropped <code>i</code>&quot; vectors, we can get another point in output space, <code>yhi</code>. The squared Euclidean distance between <code>yh</code> and <code>yhi</code>, divided by the
rank of the model (<code>p</code>) times its mean squared error <code>s^2</code>, is the <code>i</code>-th Cook's distance.<br />
\[D_i = (yh - yhi)^t (yh - yhi) / p s^2\]<br />
A more elegant way to calculate it, which this function uses, is with the influence scores, <code>hii</code>.<br />
\[D_i = |r_i|^2 / p s^2 hii / (1 - hii)\]<br />
Where <i>r_i</i> is the <i>i</i>-th residual, and <i>^t</i> is the conjugate transpose.
</p>


<h3>Value</h3>

<p>A numeric vector. The elements are the Cook's distances of each data point in <code>model</code>.
</p>


<h3>Note</h3>

<p>This is a simpler function than <a href="stats.html#topic+influence.measures">stats::cooks.distance</a>, and does not understand any additional parameters not listed in this entry.
</p>


<h3>References</h3>

<p>R. D. Cook, Influential Observations in Linear Regression, Journal of the American Statistical Association 74, 169 (1979).
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+influence.measures">stats::cooks.distance</a>, <a href="#topic+zhatvalues">zhatvalues</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 8
slop &lt;- complex(real = 4.23, imaginary = 2.323)
interc &lt;- complex(real = 1.4, imaginary = 1.804)
e &lt;- complex(real=rnorm(n)/6, imaginary=rnorm(n)/6)
xx &lt;- complex(real= rnorm(n), imaginary= rnorm(n))
tframe &lt;- data.frame(x = xx, y= slop*xx + interc + e)
fit &lt;- lm(y ~ x, data = tframe, weights = rep(1,n))
cooks.distance(fit)
</code></pre>

<hr>
<h2 id='cov'>Variance, Covariance, and Correlation for Complex Data</h2><span id='topic+cov'></span><span id='topic+cor'></span><span id='topic+var'></span>

<h3>Description</h3>

<p>Wrappers of <a href="stats.html#topic+cor">stats::var</a>, <a href="stats.html#topic+cor">stats::cov</a>, and <a href="stats.html#topic+cor">stats::cor</a> that are capable of handling complex input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov(
  x,
  y = NULL,
  na.rm = FALSE,
  method = "pearson",
  use = "everything",
  pseudo = FALSE,
  ...
)

cor(
  x,
  y = NULL,
  na.rm = FALSE,
  use = "everything",
  method = "pearson",
  pseudo = FALSE,
  ...
)

var(x, y = NULL, na.rm = FALSE, use = "everything", pseudo = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_+3A_x">x</code></td>
<td>
<p>a numeric or complex vector, matrix, or dataframe.</p>
</td></tr>
<tr><td><code id="cov_+3A_y">y</code></td>
<td>
<p>NULL (default) or a numeric vector, matrix, or dataframe with dimensions compatible with x.</p>
</td></tr>
<tr><td><code id="cov_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should missing values be removed? Only considered when <code>x</code> is a vector.</p>
</td></tr>
<tr><td><code id="cov_+3A_method">method</code></td>
<td>
<p>The method for calculating correlation coefficient. Only <code>"pearson"</code> is supported for complex variables, so this parameter is ignored.</p>
</td></tr>
<tr><td><code id="cov_+3A_use">use</code></td>
<td>
<p>character string giving the desired method of computing covariances in the presence of missing values. Options are &quot;everything&quot; (default),
&quot;all.obs&quot;, &quot;complete.obs&quot;, or &quot;na.or.complete&quot;. See <a href="stats.html#topic+cor">stats::cov</a> for explanation of what each one does. Note that &quot;pairwise.complete.obs&quot; is not available for this complex method.</p>
</td></tr>
<tr><td><code id="cov_+3A_pseudo">pseudo</code></td>
<td>
<p>logical, if <code>TRUE</code> the pseudo variance, covariance, or correlation is calculated. i.e. no complex conjugation is performed.</p>
</td></tr>
<tr><td><code id="cov_+3A_...">...</code></td>
<td>
<p>Other parameters, ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For vector input, the sample variance is calculated as,<br />
<code class="reqn">sum(Conj( mean(x) - x ) * ( mean(x) - x )) / (length(x) - 1)</code><br />
And the sample covariance is calculated as, <br />
<code class="reqn">sum(Conj( mean(x) - x ) * ( mean(y) - y )) / (length(x) - 1)</code><br />
The Pearson correlation coefficient, which is the only kind available for complex data,
is the covariance divided by the product of the standard deviations of all variables.
If <code>pseudo = TRUE</code>, these same expressions, sans <code>Conj()</code>, are used to calculate the pseudo, AKA relational,
versions of variance, covariance, or correlation.
</p>


<h3>Value</h3>

<p>numeric or complex the sample variance, covariance, or correlation of the input data.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>cor</code>: Correlation coefficient of complex variables.
</p>
</li>
<li> <p><code>var</code>: S3 Variance or Pseudo Variance of Complex Variables, a synonym for <a href="#topic+cov">cov</a>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 9
foo &lt;- complex(real = rnorm(n), imaginary = rnorm(n))
var(foo)
bar &lt;- complex(real = rnorm(n), imaginary = rnorm(n))
var(x = foo, y = bar)
foobar &lt;- data.frame(foo, bar)
cov(foobar)
cor(foobar)
</code></pre>

<hr>
<h2 id='CuHallData'>AC (Complex) Hall effect data measured from a thin-film copper sample.</h2><span id='topic+CuHallData'></span>

<h3>Description</h3>

<p>This data serves as a 'real-world' example of complex valued measurements that can be analyzed by the methods contained
in 'complexlm'. The Hall effect is a perpendicular (to the magnetic field and current) voltage that appears across an
electrically conductive material when it is placed in an external magnetic field. It is commonly used to determine the
mobility and density of charge carriers (electrons and/or holes) within materials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CuHallData
</code></pre>


<h3>Format</h3>

<p>A dataframe with 240 rows and 11 columns. Most names contain the units of the column after the last or second to last period.
</p>


<h3>Details</h3>

<p>The AC Hall effect is a more advanced technique that uses a time varying (sinusoidal) magnetic field and lock-in voltage
measurement. The measured output signal is thus a wave, and best described by complex numbers. This strategy drastically
lowers the noise floor, enabling measurement of difficult, low-mobility, materials.
</p>
<p>This data was take at room temperature in a vacuum chamber using a custom built and programmed system. A Keithley 2636
sourcemeter provided the excitation current, while an SRS 830 lock-in amplifier measured the voltage signal from the sample.
The sample consisted of a 0.8 mm square of 1000 Angstroms thick evaporated copper film on a 1.5 centimeter square die of oxidized crystalline silicon.
</p>
<p>The variables included in the dataframe are as follows:
</p>

<dl>
<dt>Temperature.K.</dt><dd><p> The temperature of the sample during this measurement. Units of Kelvin.</p>
</dd>
<dt>Magnet.Field.Frequency.Hz.</dt><dd><p> The frequency of the oscillating magnetic field used for this measurement. Units are Hertz.</p>
</dd>
<dt>Magnetic.Field.T.</dt><dd><p> The amplitude of the magnetic field during this measurement. Units of Tesla.</p>
</dd>
<dt>Contact.Arrangement</dt><dd><p> This measurement involves four electrical contacts (current in and out, and voltage hi and lo), placed at the corners.
Corresponding contacts must be opposite each other, so there are two possible arrangements: &quot;D&quot; and &quot;F&quot;.</p>
</dd>
<dt>Current.Set.A.</dt><dd><p> The desired current to be sent through the sample for this measurement. There was an error in recording beyond the 8th row. Units of Amperes.</p>
</dd>
<dt>Current.In.meas.A.</dt><dd><p> The current measured leaving the sourcemeter, towards the sample. Units of Amperes.</p>
</dd>
<dt>Current.Out.meas.A.</dt><dd><p> The current measured exiting the sample. Units of Amperes.</p>
</dd>
<dt>Source.V.V.</dt><dd><p> The voltage generated across the sample in order to produce the desired current. Units of Volts.</p>
</dd>
<dt>OutputV</dt><dd><p> The complex voltage measured across the sample. Ideally proportional to the current and magnetic field. Units of Volts.</p>
</dd>
<dt>Current.leak</dt><dd><p> The difference between the input and output currents. Units of Amperes.</p>
</dd>
<dt>Resistivity.Ohm.cm</dt><dd><p> The resistivity of the sample as calculated by the Van Der Pauw method from previous DC current-voltage sweeps. Units of Ohm*centimeter.</p>
</dd>
<dt>thickness.cm.</dt><dd><p> The thickness of the copper film in centimeters.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>William Ryan <a href="mailto:wryan1@binghamton.edu">wryan1@binghamton.edu</a>
</p>

<hr>
<h2 id='lm'>Linear Model Fitting for Complex or Numeric Variables</h2><span id='topic+lm'></span>

<h3>Description</h3>

<p>An adaptation of lm that is compatible with complex variables. If the response is not complex, it calls the standard <code><a href="stats.html#topic+lm">stats::lm()</a></code>
Note: It is not capable of dealing with contrasts in the complex case.
The formula interpretation is also unable of handle algebraic expressions in <code>formula</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm(
  formula,
  data,
  subset,
  weights,
  na.action,
  method = "qr",
  model = TRUE,
  x = TRUE,
  y = FALSE,
  qr = TRUE,
  singular.ok = TRUE,
  contrasts = NULL,
  offset,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm_+3A_formula">formula</code></td>
<td>
<p>an object of class &quot;formula&quot; (or one that can be coerced to that class): a symbolic description of the model to be fitted.
For complex variables there are restrictions on what kinds of formula can be comprehended. See <a href="#topic+zmodel.matrix">zmodel.matrix</a> for details.</p>
</td></tr>
<tr><td><code id="lm_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment (or object
coercible by <code><a href="base.html#topic+as.data.frame">as.data.frame</a></code> to a data frame) containing
the variables in the model.  If not found in <code>data</code>, the
variables are taken from <code>environment(formula)</code>,
typically the environment from which <code>lm</code> is called.</p>
</td></tr>
<tr><td><code id="lm_+3A_subset">subset</code></td>
<td>
<p>an optional vector specifying a subset of observations
to be used in the fitting process.</p>
</td></tr>
<tr><td><code id="lm_+3A_weights">weights</code></td>
<td>
<p>an optional vector of weights to be used in the fitting
process.  Should be <code>NULL</code> or a numeric vector.
If non-NULL, weighted least squares is used with weights
<code>weights</code> (that is, minimizing <code>sum(w*e^2)</code>); otherwise
ordinary least squares is used.  See also &lsquo;Details&rsquo;,</p>
</td></tr>
<tr><td><code id="lm_+3A_na.action">na.action</code></td>
<td>
<p>a function which indicates what should happen
when the data contain <code>NA</code>s.  The default is set by
the <code>na.action</code> setting of <code><a href="base.html#topic+options">options</a></code>, and is
<code><a href="stats.html#topic+na.fail">na.fail</a></code> if that is unset.  The &lsquo;factory-fresh&rsquo;
default is <code><a href="stats.html#topic+na.omit">na.omit</a></code>.  Another possible value is
<code>NULL</code>, no action.  Value <code><a href="stats.html#topic+na.exclude">na.exclude</a></code> can be useful.</p>
</td></tr>
<tr><td><code id="lm_+3A_method">method</code></td>
<td>
<p>the method to be used; for fitting, currently only
<code>method = "qr"</code> is supported; <code>method = "model.frame"</code> returns
the model frame (the same as with <code>model = TRUE</code>, see below).</p>
</td></tr>
<tr><td><code id="lm_+3A_model">model</code></td>
<td>
<p>logicals.  If <code>TRUE</code> the corresponding
components of the fit (the model frame, the model matrix, the
response, the QR decomposition) are returned.
</p>
</td></tr>
<tr><td><code id="lm_+3A_x">x</code></td>
<td>
<p>logical. If <code>TRUE</code> return the model matrix of the fit. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="lm_+3A_y">y</code></td>
<td>
<p>logicals.  If <code>TRUE</code> the corresponding
components of the fit (the model frame, the model matrix, the
response, the QR decomposition) are returned.
</p>
</td></tr>
<tr><td><code id="lm_+3A_qr">qr</code></td>
<td>
<p>logicals.  If <code>TRUE</code> the corresponding
components of the fit (the model frame, the model matrix, the
response, the QR decomposition) are returned.
</p>
</td></tr>
<tr><td><code id="lm_+3A_singular.ok">singular.ok</code></td>
<td>
<p>logical. If <code>FALSE</code> (the default in S but
not in <span class="rlang"><b>R</b></span>) a singular fit is an error.</p>
</td></tr>
<tr><td><code id="lm_+3A_contrasts">contrasts</code></td>
<td>
<p>Not implemented for complex variables. See <a href="#topic+zmodel.matrix">zmodel.matrix</a> for details. Default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="lm_+3A_offset">offset</code></td>
<td>
<p>this can be used to specify an <em>a priori</em> known
component to be included in the linear predictor during fitting.
This should be <code>NULL</code> or a numeric vector or matrix of extents
matching those of the response.  One or more <code><a href="stats.html#topic+offset">offset</a></code> terms can be
included in the formula instead or as well, and if more than one are
specified their sum is used.  See <code><a href="stats.html#topic+model.offset">model.offset</a></code>.</p>
</td></tr>
<tr><td><code id="lm_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to the low level
regression fitting functions (see below).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Like <a href="stats.html#topic+lm">stats::lm</a> the models are specified symbolically using the standard R formula notation:
<code>response ~ terms</code>
Meaning <code>response</code> is a linear combination of the predictor variables in <code>terms</code>.
For compatibility with complex numbers <code>complexlm::lm</code> uses <a href="#topic+zmodel.matrix">zmodel.matrix</a> to build the model matrix
from the model formula. As such it is limited to terms consisting of predictor names connected by <code>+</code> and/or <code>:</code> operators.
Anything more complicated will result in an error.
</p>
<p>If response is a matrix, then then <code>lm()</code> fits a model to each column, and returns an object with class &quot;mlm&quot;.
</p>
<p>For complex input, this function calls <a href="#topic+zlm.wfit">zlm.wfit</a>.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>c("zlm", "lm")</code>, or for multiple responses <code>c("zlm", "mlm", "lm")</code>.
</p>
<p>The functions <a href="base.html#topic+summary">summary</a> and <a href="stats.html#topic+anova">anova</a> are used to obtain and print a summary and analysis of variance table of the results.
The generic functions <a href="stats.html#topic+coefficients">coefficients</a>, <a href="stats.html#topic+effects">effects</a>, <a href="stats.html#topic+fitted.values">fitted.values</a> and <a href="stats.html#topic+residuals">residuals</a> extract various useful features of the value returned by lm.
Of course these things can also be accessed by simply using the get element symbol <code>$</code>.
</p>
<p>Objects of class &quot;zlm&quot; are lists with the following components.
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector of coefficients.</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the residuals, that is response minus fitted values.</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The fitted values, which are response values obtained by feeding the predictors into the model.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>The numeric rank of the fitted linear model.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>Numeric. The user supplied weights for the linear fit. If none were given, a vector of <code>1</code>s of length equal to that of the input data.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>The residual degrees of freedom.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <a href="stats.html#topic+terms">terms</a> object used.</p>
</td></tr>
<tr><td><code>contrasts</code></td>
<td>
<p>The contrasts used, as these are not supported this component will probably be <code>NULL</code>.</p>
</td></tr>
<tr><td><code>xlevels</code></td>
<td>
<p>(only where relevant) a record of the levels of the factors used in fitting.</p>
</td></tr>
<tr><td><code>offset</code></td>
<td>
<p>the offset used (missing if none were used).</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>if requested, the response used.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>the model matrix used, unless requested to not return it.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>if requested, the model frame used.</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>(where relevant) information returned by <a href="stats.html#topic+model.frame">model.frame</a> on the special handling of NAs.</p>
</td></tr>
<tr><td><code>assign</code></td>
<td>
<p>Used by extractor functions like <a href="base.html#topic+summary">summary</a> and <a href="stats.html#topic+effects">effects</a> to understand variable names. Not included in null fits.</p>
</td></tr>
<tr><td><code>effects</code></td>
<td>
<p>Complex list. See <a href="stats.html#topic+effects">effects</a> for explanation. Not included in null fits.</p>
</td></tr>
<tr><td><code>qr</code></td>
<td>
<p>unless declined, the output of the <a href="Matrix.html#topic+qr">qr</a> object created in the process of fitting. Not included in null fits.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>In <code>complexlm</code>, the <code>x</code> parameter defaults to <code>TRUE</code> so that followup
methods such as <a href="stats.html#topic+predict.lm">predict.lm</a> have access to the model matrix.
</p>


<h3>See Also</h3>

<p><a href="#topic+lm.fit">lm.fit</a>, <a href="#topic+lm.wfit">lm.wfit</a>, <a href="#topic+zlm.wfit">zlm.wfit</a>, <a href="#topic+zmodel.matrix">zmodel.matrix</a>, <a href="#topic+complexdqlrs">complexdqlrs</a>, <a href="stats.html#topic+lm">stats::lm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 8
slop &lt;- complex(real = 4.23, imaginary = 2.323)
interc &lt;- complex(real = 1.4, imaginary = 1.804)
e &lt;- complex(real=rnorm(n)/6, imaginary=rnorm(n)/6)
xx &lt;- complex(real= rnorm(n), imaginary= rnorm(n))
tframe &lt;- data.frame(x= xx, y= slop*xx + interc + e)
lm(y ~ x, data = tframe, weights = rep(1,n))
</code></pre>

<hr>
<h2 id='lm.fit'>Complex Variable Compatible Wrappers for <code><a href="stats.html#topic+lmfit">stats::lm.fit()</a></code> and <code><a href="stats.html#topic+lmfit">stats::lm.wfit()</a></code></h2><span id='topic+lm.fit'></span><span id='topic+lm.wfit'></span>

<h3>Description</h3>

<p>This function is just an if statement.
If the design matrix <code>x</code> is complex, <code><a href="#topic+zlm.wfit">zlm.wfit()</a></code> is called.
Otherwise <code><a href="stats.html#topic+lmfit">stats::lm.fit()</a></code> or <code><a href="stats.html#topic+lmfit">stats::lm.wfit()</a></code> is called.
These functions are unlikely to be needed by end users, as they are called by <code><a href="#topic+lm">lm()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lm.fit(
  x,
  y,
  offset = NULL,
  method = "qr",
  tol = 1e-07,
  singular.ok = TRUE,
  ...
)

lm.wfit(
  x,
  y,
  w,
  offset = NULL,
  method = "qr",
  tol = 1e-07,
  singular.ok = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lm.fit_+3A_x">x</code></td>
<td>
<p>design matrix of dimension <code>n * p</code>.</p>
</td></tr>
<tr><td><code id="lm.fit_+3A_y">y</code></td>
<td>
<p>vector of observations of length <code>n</code>, or a matrix with
<code>n</code> rows.</p>
</td></tr>
<tr><td><code id="lm.fit_+3A_offset">offset</code></td>
<td>
<p>(numeric of length <code>n</code>).  This can be used to
specify an <em>a priori</em> known component to be included in the
linear predictor during fitting.</p>
</td></tr>
<tr><td><code id="lm.fit_+3A_method">method</code></td>
<td>
<p>currently, only <code>method = "qr"</code> is supported.</p>
</td></tr>
<tr><td><code id="lm.fit_+3A_tol">tol</code></td>
<td>
<p>tolerance for the <code><a href="Matrix.html#topic+qr">qr</a></code> decomposition.  Default
is 1e-7.</p>
</td></tr>
<tr><td><code id="lm.fit_+3A_singular.ok">singular.ok</code></td>
<td>
<p>logical. If <code>FALSE</code>, a singular model is an
error.</p>
</td></tr>
<tr><td><code id="lm.fit_+3A_...">...</code></td>
<td>
<p>currently disregarded.</p>
</td></tr>
<tr><td><code id="lm.fit_+3A_w">w</code></td>
<td>
<p>vector of weights (length <code>n</code>) to be used in the fitting
process for the <code>wfit</code> functions.  Weighted least squares is
used with weights <code>w</code>, i.e., <code>sum(w * e^2)</code> is minimized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+list">list</a></code> with components (for <code>lm.fit</code> and <code>lm.wfit</code>)
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p><code>p</code> vector</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p><code>n</code> vector or matrix</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p><code>n</code> vector or matrix</p>
</td></tr>
<tr><td><code>effects</code></td>
<td>
<p><code>n</code> vector of orthogonal single-df
effects.  The first <code>rank</code> of them correspond to non-aliased
coefficients, and are named accordingly.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p><code>n</code> vector &mdash; <em>only</em> for the <code>*wfit*</code>
functions.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>integer, giving the rank</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>degrees of freedom of residuals</p>
</td></tr>
<tr><td><code>qr</code></td>
<td>
<p>the QR decomposition, see <code><a href="Matrix.html#topic+qr">qr</a></code>.</p>
</td></tr>
</table>
<p>Fits without any columns or non-zero weights do not have the
<code>effects</code> and <code>qr</code> components.
</p>
<p><code>.lm.fit()</code> returns a subset of the above, the <code>qr</code> part
unwrapped, plus a logical component <code>pivoted</code> indicating if the
underlying QR algorithm did pivot.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>lm.wfit</code>: wrapper for weighted linear fitting function.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 6
p &lt;- 2
slop &lt;- complex(real = 4.23, imaginary = 2.323)
slop2 = complex(real = 2.1, imaginary = -3.9)
interc &lt;- complex(real = 1.4, imaginary = 1.804)
e &lt;- complex(real=rnorm(n)/6, imaginary=rnorm(n)/6)
desmat &lt;- matrix(c(complex(real = rnorm(n * p), imaginary = rnorm(n * p)), rep(1, n)), n, p + 1)
y = desmat %*% c(slop, slop2, interc) + e
lm.fit(desmat, y)
</code></pre>

<hr>
<h2 id='mad'>Median Absolute Deviation, compatible with complex variables</h2><span id='topic+mad'></span>

<h3>Description</h3>

<p>Median absolute deviation, adapted to operate on complex data as well as numeric.
In the later case it simply calls <code><a href="stats.html#topic+mad">stats::mad()</a></code>.
For complex x it uses the geometric median, <code><a href="pracma.html#topic+geo_median">pracma::geo_median()</a></code>, as the center,
then returns the median absolute difference between center and each element of x, multiplied by <code>constant</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mad(
  x,
  center = median(x),
  constant = 1.4826,
  na.rm = FALSE,
  low = FALSE,
  high = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mad_+3A_x">x</code></td>
<td>
<p>a numeric or complex vector.</p>
</td></tr>
<tr><td><code id="mad_+3A_center">center</code></td>
<td>
<p>optional, numeric or complex. The center about which to calculate MAD. Defaults to median for numeric, and geo_median for complex.</p>
</td></tr>
<tr><td><code id="mad_+3A_constant">constant</code></td>
<td>
<p>a constant by which to multiply the median absolute deviation from center. Default is 1.4826, which is the inverse of the 3/4 quantile for the normal distribution.</p>
</td></tr>
<tr><td><code id="mad_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should NAs be removed from x before calculating.</p>
</td></tr>
<tr><td><code id="mad_+3A_low">low</code></td>
<td>
<p>logical. If TRUE, compute the &quot;lo-median&quot;, i.e., for even sample size, do not average the two middle values, but take the smaller one. Not used if x is complex.</p>
</td></tr>
<tr><td><code id="mad_+3A_high">high</code></td>
<td>
<p>logical. If TRUE, compute the &quot;hi-median&quot;, i.e., take the larger of the two middle values for even sample size. Not used if x is complex.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric. The median absolute deviation (MAD) from center.
</p>


<h3>Note</h3>

<p>The concept of quantile requires ordering to be defined, which the complex numbers lack.
The usefulness of multiplying by <code>constant</code> is thus called into question. However, for no more rigorous
reason than consistency, the default behavior of this function is to do so.
</p>


<h3>See Also</h3>

<p><a href="#topic+median.complex">median.complex</a>, <a href="stats.html#topic+mad">stats::mad</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 8
foo &lt;- complex(real = rnorm(n), imaginary = rnorm(n))
mad(foo)
</code></pre>

<hr>
<h2 id='mahalanobis'>Mahalanobis Distance, with better complex behavior</h2><span id='topic+mahalanobis'></span>

<h3>Description</h3>

<p>The Mahalanobis distance function included in the <code>stats</code> package returns a complex number when given complex values of <code>x</code>.
But a distance (and thus its square) is always positive real. This function calculates the Mahalanobis distance using
the conjugate transpose if given complex data, otherwise it calls <a href="stats.html#topic+mahalanobis">stats::mahalanobis</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mahalanobis(x, center, cov, pcov = NULL, inverted = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mahalanobis_+3A_x">x</code></td>
<td>
<p>A length <code class="reqn">p</code> vector or matrix with row length <code class="reqn">p</code>. Or, a length <code class="reqn">2p</code> vector or matrix with row length <code class="reqn">2p</code>.</p>
</td></tr>
<tr><td><code id="mahalanobis_+3A_center">center</code></td>
<td>
<p>A vector of length equal to that of <code>x</code>.</p>
</td></tr>
<tr><td><code id="mahalanobis_+3A_cov">cov</code></td>
<td>
<p>The covariance matrix <code class="reqn">(p x p)</code> of the distribution. Or, the &quot;double covariance matrix&quot; of the distribution, which contains the information from <code>cov</code> and <code>pcov</code> in a single <code class="reqn">(2p x 2p)</code> matrix.
Can be generated by <a href="#topic+matrixweave">matrixweave</a>, <a href="#topic+vcov.zlm">vcov.zlm</a>, or <a href="#topic+vcov.rzlm">vcov.rzlm</a>.
vcov.rzlm].</p>
</td></tr>
<tr><td><code id="mahalanobis_+3A_pcov">pcov</code></td>
<td>
<p>The pseudo covariance matrix <code class="reqn">(p x p)</code> of the distribution. Optional.</p>
</td></tr>
<tr><td><code id="mahalanobis_+3A_inverted">inverted</code></td>
<td>
<p>Boolean, if TRUE, <code>cov</code> and <code>pcov</code> are not taken to be the <em>inverse</em> covariance and pseudo covariance matrices.</p>
</td></tr>
<tr><td><code id="mahalanobis_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to <a href="Matrix.html#topic+solve">solve</a>, which is used for computing the inverse of <code>cov</code>. If <code>inverted = TRUE</code>, unused.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the relative sizes of <code>x</code>, <code>cov</code>, and <code>pcov</code>, the function will perform slightly different calculations. If <code>pcov</code> is not included,
the Mahalanobis distance is calculated using only <code>cov</code>. In this case if the dimension of <code>cov</code> is twice that of <code>x</code>, <code>x</code> is interleaved with its complex conjugate
so that it becomes the same length as <code>cov</code>. Note that in this case the resulting Mahalanobis distance will only incorporate information about the interactions between
the real and imaginary components if the &quot;double covariance matrix is given as <code>cov</code> . If <code>pcov</code> is included in the input, <code>pcov</code> and <code>cov</code> are interleaved to form the &quot;double covariance&quot;, and this is used to
calculate the Mahalanobis distance, interleaving <code>x</code> if necessary. This gives the user a great deal of flexibility when it comes to input.
</p>


<h3>Value</h3>

<p>numeric. The squared Mahalanobis distance (divergence) between <code>x</code> and <code>center</code>.
</p>


<h3>References</h3>

<p>D. Dai and Y. Liang, High-Dimensional Mahalanobis Distances of Complex Random Vectors, Mathematics 9, 1877 (2021).
</p>


<h3>See Also</h3>

<p><a href="#topic+matrixweave">matrixweave</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 8
x &lt;- matrix(complex(real = rnorm(n), imaginary = rnorm(n)), ncol = 2)
mu &lt;- complex(real = 1.4, imaginary = 0.4)
sigma &lt;- 3.4
mahalanobis(x, mu, sigma * diag(2))
</code></pre>

<hr>
<h2 id='matrixweave'>Combine covariance matrix and pseudo covariance matrix into a &quot;double covariance matrix&quot;</h2><span id='topic+matrixweave'></span>

<h3>Description</h3>

<p>Interleaves the elements of a <code class="reqn">(p x p)</code> matrix with those of a different <code class="reqn">(p x p)</code> matrix to form a <code class="reqn">(2p x 2p)</code> matrix.
This function was originally made to combine the covariance and pseudo covariance matrices of a
complex random vector into a single &quot;double covariance matrix&quot;, as described in (van den Bos 1995). However, it will accept
and operate on matrices of any storage mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrixweave(cov, pcov, FUNC = Conj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrixweave_+3A_cov">cov</code></td>
<td>
<p>A square matrix, such as one describing the covariance between two complex random vectors.</p>
</td></tr>
<tr><td><code id="matrixweave_+3A_pcov">pcov</code></td>
<td>
<p>A square matrix with the same size as cov. Perhaps a pseudo covariance matrix.</p>
</td></tr>
<tr><td><code id="matrixweave_+3A_func">FUNC</code></td>
<td>
<p>A function to operate on the elements of <code>pcov</code>. The results of which will be a quarter of the elements of the returned matrix. Default is <code>Conj</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A square matrix with dimension twice that of the input matrices. Each element of which is an element from one of the inputs, and its nearest non-diagonal neighbors are from the other input.
Half of the elements from <code>pcov</code> present in the output matrix are replaced by <code>FUNC</code> operated on them. Thus if two 2x2 matrices, <code>A</code> and <code>B</code> are given to <code>matrixweave()</code>, the elements of the result are:<br />
<code style="white-space: pre;">&#8288;matrixweave(A,B)[i,j] = if(i+j is even) A[ceiling(i/2), ceiling(j/2)]&#8288;</code><br />
<code style="white-space: pre;">&#8288;                        if(i+j is odd and i &gt; j) B[ceiling(i/2), ceiling(j/2)]&#8288;</code><br />
<code style="white-space: pre;">&#8288;                        if(i+j is odd and i &lt; j) FUNC(B[ceiling(i/2),ceiling(j/2)])&#8288;</code>
</p>


<h3>References</h3>

<p>A. van den Bos, The Multivariate Complex Normal Distribution-a Generalization, IEEE Trans. Inform. Theory 41, 537 (1995).
</p>


<h3>See Also</h3>

<p><a href="#topic+mahalanobis">mahalanobis</a>, <a href="#topic+vcov.zlm">vcov.zlm</a>, <a href="#topic+vcov.rzlm">vcov.rzlm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
mata &lt;- matrix(rnorm(9), nrow = 3)
matb &lt;- matrix(rnorm(9), nrow = 3)
matrixweave(mata, matb)
</code></pre>

<hr>
<h2 id='median.complex'>Improved Median for Complex Numbers</h2><span id='topic+median.complex'></span>

<h3>Description</h3>

<p>By default <a href="stats.html#topic+median">stats::median</a> handles complex numbers by computing the medians of the real and imaginary components separately.
This is not ideal as the result is not rotationally invariant (the same set of numbers will have a different median if the coordinates are rotated).
This method calculates the complex median as the geometric median, as implemented in <a href="pracma.html#topic+geo_median">pracma::geo_median</a>, which is rotationally invariant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'complex'
median(x, na.rm = FALSE, tol = 1e-07, maxiter = 200, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="median.complex_+3A_x">x</code></td>
<td>
<p>a numeric or complex vector, of which the median is to be calculated.</p>
</td></tr>
<tr><td><code id="median.complex_+3A_na.rm">na.rm</code></td>
<td>
<p>logical. Should NA values be removed before finding the median?</p>
</td></tr>
<tr><td><code id="median.complex_+3A_tol">tol</code></td>
<td>
<p>numeric. Relative tolerance to be passed to <a href="pracma.html#topic+geo_median">pracma::geo_median</a>. Default is 1e-07.</p>
</td></tr>
<tr><td><code id="median.complex_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations for calculating geometric median. Not used if x is numeric.</p>
</td></tr>
<tr><td><code id="median.complex_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently ignored.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The geometric median fails if any of the input data are colinear. Meaning that a straight line on the complex plane
can be drawn which intersects with one or more element of <code>x</code>. If this function encounters such an error, it adds a small
amount of random jitter to the data, then calculates the geometric medium again. The jitter is generated by a normal distribution
with a standard deviation equal to the absolute minimum real or imaginary component of <code>x</code>, divided by <code class="reqn">10^8</code> (or 10^-9 if the minimum is zero).
</p>


<h3>Value</h3>

<p>The median of x. If x is complex, the geometric median as calculated by Weiszfeld's algorithm.
</p>


<h3>Note</h3>

<p>This method masks the default method for complex numbers.
</p>


<h3>References</h3>

<p>Becker, R. A., Chambers, J. M. and Wilks, A. R. (1988)
<em>The New S Language</em>.
Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+median">stats::median</a> and <a href="pracma.html#topic+geo_median">pracma::geo_median</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 7
foo &lt;- complex(real = rnorm(n), imaginary = rnorm(n))
median(foo)
</code></pre>

<hr>
<h2 id='plot.zlm'>Plot Diagnostics for a Complex Linear Model Objects</h2><span id='topic+plot.zlm'></span>

<h3>Description</h3>

<p>A modified version of <a href="stats.html#topic+plot.lm">stats::plot.lm</a> used for visualizing ordinary (&quot;zlm&quot;) and robust (&quot;rzlm&quot;)
linear models of complex variables. This documentation entry describes the complex version, focusing on the
differences and changes from the numeric. For further explanation of the plots please see <a href="stats.html#topic+plot.lm">stats::plot.lm</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zlm'
plot(
  x,
  which = c(1, 3, 5),
  caption = list("Residuals vs Fitted", "Scale-Location", "Cook's distance",
    "Residuals vs Leverage", expression("Cook's dist vs Leverage  " * h[ii]/(1 - h[ii]))),
  panel = if (add.smooth) function(x, y, ...) panel.smooth(x, y, iter = iter.smooth,
    ...) else points,
  sub.caption = NULL,
  main = "",
  ask = prod(par("mfcol")) &lt; length(which) &amp;&amp; dev.interactive(),
  ...,
  id.n = 3,
  labels.id = names(residuals(x)),
  cex.id = 0.75,
  cook.levels = c(0.5, 1),
  add.smooth = getOption("add.smooth"),
  iter.smooth = if (isGlm) 0 else 3,
  label.pos = c(4, 2),
  cex.caption = 1,
  cex.oma.main = 1.25
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.zlm_+3A_x">x</code></td>
<td>
<p>complex lm object (&quot;zlm&quot; or &quot;rzlm&quot;). Typically produced by <a href="#topic+lm">lm</a> or <a href="#topic+rlm">rlm</a>.</p>
</td></tr>
<tr><td><code id="plot.zlm_+3A_which">which</code></td>
<td>
<p>If a subset of the plots is required, specify a subset of the numbers 1:6, except 2. See <a href="stats.html#topic+plot.lm">stats::plot.lm</a>, and below, for the different kinds. Default is c(1,3,5).</p>
</td></tr>
<tr><td><code id="plot.zlm_+3A_caption">caption</code></td>
<td>
<p>captions to appear above the plots;
<code><a href="base.html#topic+character">character</a></code> vector or <code><a href="base.html#topic+list">list</a></code> of valid
graphics annotations, see <code><a href="grDevices.html#topic+as.graphicsAnnot">as.graphicsAnnot</a></code>, of length
6, the j-th entry corresponding to <code>which[j]</code>.  Can be set to
<code>""</code> or <code>NA</code> to suppress all captions.
</p>
</td></tr>
<tr><td><code id="plot.zlm_+3A_panel">panel</code></td>
<td>
<p>panel function.  The useful alternative to
<code><a href="graphics.html#topic+points">points</a></code>, <code><a href="graphics.html#topic+panel.smooth">panel.smooth</a></code> can be chosen
by <code>add.smooth = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot.zlm_+3A_sub.caption">sub.caption</code></td>
<td>
<p>common title&mdash;above the figures if there are more
than one; used as <code>sub</code> (s.<code><a href="graphics.html#topic+title">title</a></code>) otherwise.  If
<code>NULL</code>, as by default, a possible abbreviated version of
<code>deparse(x$call)</code> is used.</p>
</td></tr>
<tr><td><code id="plot.zlm_+3A_main">main</code></td>
<td>
<p>title to each plot&mdash;in addition to <code>caption</code>.</p>
</td></tr>
<tr><td><code id="plot.zlm_+3A_ask">ask</code></td>
<td>
<p>logical; if <code>TRUE</code>, the user is <em>ask</em>ed before
each plot, see <code><a href="graphics.html#topic+par">par</a>(ask=.)</code>.</p>
</td></tr>
<tr><td><code id="plot.zlm_+3A_...">...</code></td>
<td>
<p>other parameters to be passed through to plotting
functions.</p>
</td></tr>
<tr><td><code id="plot.zlm_+3A_id.n">id.n</code></td>
<td>
<p>number of points to be labelled in each plot, starting
with the most extreme.</p>
</td></tr>
<tr><td><code id="plot.zlm_+3A_labels.id">labels.id</code></td>
<td>
<p>vector of labels, from which the labels for extreme
points will be chosen.  <code>NULL</code> uses observation numbers.</p>
</td></tr>
<tr><td><code id="plot.zlm_+3A_cex.id">cex.id</code></td>
<td>
<p>magnification of point labels.</p>
</td></tr>
<tr><td><code id="plot.zlm_+3A_cook.levels">cook.levels</code></td>
<td>
<p>levels of Cook's distance at which to draw contours.</p>
</td></tr>
<tr><td><code id="plot.zlm_+3A_add.smooth">add.smooth</code></td>
<td>
<p>logical indicating if a smoother should be added to
most plots; see also <code>panel</code> above.</p>
</td></tr>
<tr><td><code id="plot.zlm_+3A_iter.smooth">iter.smooth</code></td>
<td>
<p>the number of robustness iterations, the argument
<code>iter</code> in <code><a href="graphics.html#topic+panel.smooth">panel.smooth</a>()</code>; the default uses no such
iterations for <code><a href="stats.html#topic+glm">glm</a></code> fits which is
particularly desirable for the (predominant) case of binary
observations, but also for other models where the response
distribution can be highly skewed.</p>
</td></tr>
<tr><td><code id="plot.zlm_+3A_label.pos">label.pos</code></td>
<td>
<p>positioning of labels, for the left half and right
half of the graph respectively, for plots 1-3.</p>
</td></tr>
<tr><td><code id="plot.zlm_+3A_cex.caption">cex.caption</code></td>
<td>
<p>controls the size of <code>caption</code>.</p>
</td></tr>
<tr><td><code id="plot.zlm_+3A_cex.oma.main">cex.oma.main</code></td>
<td>
<p>controls the size of the <code>sub.caption</code> only if
that is <em>above</em> the figures when there is more than one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Five of the six plots generated by <a href="stats.html#topic+plot.lm">stats::plot.lm</a> can be produced by this function:
The residuals vs. fitted values plot, the scale-location plot, the plot of Cook's distances vs. row labels,
the plot of residuals vs. leverages, and the plot of Cook's distances vs. leverage/(1-leverage). The Q-Q plot is
<em>not</em> drawn because it requires quantiles, which are not unambiguously defined for complex numbers.
Because complex numbers are two dimensional, <a href="graphics.html#topic+pairs">pairs</a> is used to create multiple scatter plots of the real
and imaginary components for the residuals vs. fitted values and scale-location plots.
</p>


<h3>Value</h3>

<p>Several diagnostic plots.
</p>


<h3>References</h3>

<p>Belsley, D. A., Kuh, E. and Welsch, R. E. (1980). Regression Diagnostics. New York: Wiley.
</p>
<p>Cook, R. D. and Weisberg, S. (1982). Residuals and Influence in Regression. London: Chapman and Hall.
</p>
<p>Firth, D. (1991) Generalized Linear Models. In Hinkley, D. V. and Reid, N. and Snell, E. J., eds: Pp. 55-82 in Statistical Theory and Modelling. In Honour of Sir David Cox, FRS. London: Chapman and Hall.
</p>
<p>Hinkley, D. V. (1975). On power transformations to symmetry. Biometrika, 62, 101-111. doi: 10.2307/2334491.
</p>
<p>McCullagh, P. and Nelder, J. A. (1989). Generalized Linear Models. London: Chapman and Hall.
</p>


<h3>See Also</h3>

<p><a href="#topic+zhatvalues">zhatvalues</a>, <a href="stats.html#topic+cooks.distance">cooks.distance</a>, <a href="#topic+lm">lm</a>, <a href="#topic+rlm">rlm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 8
slop &lt;- complex(real = 4.23, imaginary = 2.323)
interc &lt;- complex(real = 1.4, imaginary = 1.804)
e &lt;- complex(real=rnorm(n)/6, imaginary=rnorm(n)/6)
xx &lt;- complex(real= rnorm(n), imaginary= rnorm(n))
tframe &lt;- data.frame(x = xx, y= slop*xx + interc + e)
fit &lt;- lm(y ~ x, data = tframe, weights = rep(1,n))
plot(fit)
</code></pre>

<hr>
<h2 id='psi.huber'>Weighting functions for robust fitting</h2><span id='topic+psi.huber'></span><span id='topic+psi.hampel'></span><span id='topic+psi.bisquare'></span>

<h3>Description</h3>

<p>Weighting functions used in <code>rlm</code> for iteratively reweighted least squares.
Based on the same functions from MASS, modified to accept complex variables.
While named 'psi', these are actually weight functions, weight(u) = abs( influence(u) / u).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>psi.huber(u, k = 1.345, deriv = 0)

psi.hampel(u, a = 2, b = 4, c = 8, deriv = 0)

psi.bisquare(u, c = 4.685, deriv = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="psi.huber_+3A_u">u</code></td>
<td>
<p>Numeric or complex. When used in M-estimation, a residual.</p>
</td></tr>
<tr><td><code id="psi.huber_+3A_k">k</code></td>
<td>
<p>Numeric. A scaling constant for <code>psi.huber</code>. Default value is 1.345</p>
</td></tr>
<tr><td><code id="psi.huber_+3A_deriv">deriv</code></td>
<td>
<p>Numeric. If <code>0</code>, return the weight at <code>u</code>. If <code>1</code> return the first derivative of the influence function at <code>u</code>.</p>
</td></tr>
<tr><td><code id="psi.huber_+3A_a">a</code></td>
<td>
<p>Numeric. A scaling constant for <code>psi.hampel</code>. Default value is 2</p>
</td></tr>
<tr><td><code id="psi.huber_+3A_b">b</code></td>
<td>
<p>Numeric. A scaling constant for <code>psi.hampel</code>. Default value is 4</p>
</td></tr>
<tr><td><code id="psi.huber_+3A_c">c</code></td>
<td>
<p>Numeric. A scaling constant for 'psi.hampel<code>or</code>psi.bisquare'. Default is 8 for the former and 4.685 for the later.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Three weight functions for iteratively (re)weighted least squares. When used in M-estimation, <code>psi.huber</code> has
a unique solution. <code>psi.hampel</code> and <code>psi.bisquare</code>, which are redescending M-estimators, do not have a unique solution.
These are capable of completely rejecting outliers, but need a good starting point to avoid falling into unhelpful local minima.
If <code>deriv</code> is set to <code>1</code>, the functions return the value of the first derivative of the influence function at <code>u</code>.
Note that they do not return the derivative of the weight function, as might be expected.
</p>


<h3>Value</h3>

<p>A numeric or complex that is either the value of the weight function at <code>u</code> (numeric) or the first derivative of the influence function at <code>u</code> (can be complex).
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>psi.hampel</code>: The weight function of the hampel objective function.
</p>
</li>
<li> <p><code>psi.bisquare</code>: The weight function of Tukey's bisquare objective function.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
z &lt;- complex(real = rnorm(3), imaginary = rnorm(3))
psi.huber(z)
psi.hampel(z)
psi.bisquare(z)
psi.huber(z, deriv=1)
psi.hampel(z, deriv=1)
</code></pre>

<hr>
<h2 id='range'>Range For Complex Objects</h2><span id='topic+range'></span>

<h3>Description</h3>

<p>This function extends <a href="base.html#topic+range">base::range</a> to the field of complex numbers.
It returns a vector containing two complex numbers that are the diagonal points of a rectangle,
with sides parallel to the real and imaginary axes, that just contains all the complex numbers
given as arguments. If given non complex input it calls <a href="base.html#topic+range">base::range</a>, please see the documentation
for that function for an explanation of its behavior with other input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>range(..., na.rm = FALSE, finite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="range_+3A_...">...</code></td>
<td>
<p>Any complex, numeric, or character object</p>
</td></tr>
<tr><td><code id="range_+3A_na.rm">na.rm</code></td>
<td>
<p>logical, indicates if <code>NA</code>'s should be removed.</p>
</td></tr>
<tr><td><code id="range_+3A_finite">finite</code></td>
<td>
<p>logical, indicates if non-finite elements should be omitted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A complex vector describing a rectangle that all input values fall within.
</p>


<h3>See Also</h3>

<p><a href="base.html#topic+range">base::range</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 8
foo &lt;- complex(real = rnorm(n), imaginary = rnorm(n))
range(foo)
</code></pre>

<hr>
<h2 id='rlm'>Robust Fitting of Linear Models, Compatible with Complex Variables</h2><span id='topic+rlm'></span><span id='topic+rlm.formula'></span><span id='topic+rlm.complex'></span>

<h3>Description</h3>

<p>Uses robust M-estimation to fit a linear model to numeric or complex data. Based on <a href="MASS.html#topic+rlm">MASS::rlm</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlm(x, ...)

## S3 method for class 'formula'
rlm(
  formula,
  data,
  weights,
  ...,
  subset,
  na.action,
  method = c("M", "MM", "model.frame"),
  wt.method = c("inv.var", "case"),
  model = TRUE,
  x.ret = TRUE,
  y.ret = FALSE,
  contrasts = NULL
)

## S3 method for class 'complex'
rlm(
  x,
  y,
  weights,
  ...,
  w = rep(1, nrow(x)),
  init = "ls",
  psi = psi.huber,
  scale.est = c("MAD", "Huber", "proposal 2"),
  k2 = 1.345,
  method = c("M", "MM"),
  wt.method = c("inv.var", "case"),
  maxit = 20,
  acc = 1e-04,
  test.vec = "resid",
  lqs.control = NULL,
  interc = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlm_+3A_x">x</code></td>
<td>
<p>numeric or complex. A matrix, dataframe, or vector containing the explanatory / independent / predictor variables.</p>
</td></tr>
<tr><td><code id="rlm_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to rlm.default or to the psi function.</p>
</td></tr>
<tr><td><code id="rlm_+3A_formula">formula</code></td>
<td>
<p>a <a href="stats.html#topic+formula">formula</a> object of the form y ~ x1 + x2. Note that algebraic expressions in formula cannot currently be used with complex data.</p>
</td></tr>
<tr><td><code id="rlm_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables upon which a robust fit is to be applied.</p>
</td></tr>
<tr><td><code id="rlm_+3A_weights">weights</code></td>
<td>
<p>numeric. A vector of weights to apply to the residuals.</p>
</td></tr>
<tr><td><code id="rlm_+3A_subset">subset</code></td>
<td>
<p>an index vector specifying the cases (rows of data or x and y) to be used for fitting.</p>
</td></tr>
<tr><td><code id="rlm_+3A_na.action">na.action</code></td>
<td>
<p>a function that specifies what to do if NAs are found in the fitting data. The default is to omit them via <a href="stats.html#topic+na.omit">na.omit</a>. Can also be changed by <a href="base.html#topic+options">options</a> (na.action =).</p>
</td></tr>
<tr><td><code id="rlm_+3A_method">method</code></td>
<td>
<p>string. What method of robust estimation should be used. Options are &quot;M&quot;, &quot;MM&quot;, or &quot;model.frame&quot;. The default is M-estimation. MM-estimation has a high breakdown point but is not compatible with complex variables or case weights. model.frame just constructs the model frame, and only works with the formula method.</p>
</td></tr>
<tr><td><code id="rlm_+3A_wt.method">wt.method</code></td>
<td>
<p>string, either &quot;inv.var&quot; or &quot;case&quot;. Specifies whether the weights are case weights that give the relative importance of each observation (higher weight means more important) / case, or the inverse variances of the cases (higher weight means that observation is less variable / uncertain).</p>
</td></tr>
<tr><td><code id="rlm_+3A_model">model</code></td>
<td>
<p>logical. Should the model frame be included in the returned object?</p>
</td></tr>
<tr><td><code id="rlm_+3A_x.ret">x.ret</code></td>
<td>
<p>logical. Should the model (design) matrix be included in the returned object?</p>
</td></tr>
<tr><td><code id="rlm_+3A_y.ret">y.ret</code></td>
<td>
<p>logical. Should the response be included in the returned object?</p>
</td></tr>
<tr><td><code id="rlm_+3A_contrasts">contrasts</code></td>
<td>
<p>optional contrast specifications: see <a href="stats.html#topic+lm">stats::lm</a>. Not compatible with complex data.</p>
</td></tr>
<tr><td><code id="rlm_+3A_y">y</code></td>
<td>
<p>numeric or complex. A vector containing the dependent / response variables, the same length as x.</p>
</td></tr>
<tr><td><code id="rlm_+3A_w">w</code></td>
<td>
<p>(optional) initial down-weighting for each case</p>
</td></tr>
<tr><td><code id="rlm_+3A_init">init</code></td>
<td>
<p>(optional) initial values for the coefficients OR a method to find initial values OR the result of a fit with a coef component. Known methods are &quot;ls&quot; (the default) for an initial least-squares fit using weights w*weights, and &quot;lts&quot; for an unweighted least-trimmed squares fit with 200 samples.</p>
</td></tr>
<tr><td><code id="rlm_+3A_psi">psi</code></td>
<td>
<p>the psi function is specified by this argument. It must give (possibly by name) a function g(x, ..., deriv) that for deriv=0 returns psi(x)/x and for deriv=1 returns psi'(x). Tuning constants will be passed in via ...</p>
</td></tr>
<tr><td><code id="rlm_+3A_scale.est">scale.est</code></td>
<td>
<p>method of scale estimation: re-scaled MAD of the residuals (default) or Huber's proposal 2 (which can be selected by either &quot;Huber&quot; or &quot;proposal 2&quot;). Only MAD is implemented for complex variables.</p>
</td></tr>
<tr><td><code id="rlm_+3A_k2">k2</code></td>
<td>
<p>tuning constant used for Huber proposal 2 scale estimation.</p>
</td></tr>
<tr><td><code id="rlm_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of IWLS iterations.</p>
</td></tr>
<tr><td><code id="rlm_+3A_acc">acc</code></td>
<td>
<p>the accuracy for the stopping criterion.</p>
</td></tr>
<tr><td><code id="rlm_+3A_test.vec">test.vec</code></td>
<td>
<p>the stopping criterion is based on changes in this vector.</p>
</td></tr>
<tr><td><code id="rlm_+3A_lqs.control">lqs.control</code></td>
<td>
<p>An optional list of control values for <a href="MASS.html#topic+lqs">lqs</a>, ignored.</p>
</td></tr>
<tr><td><code id="rlm_+3A_interc">interc</code></td>
<td>
<p>TRUE or FALSE, default is FALSE. Used with rlm.default when fitting complex valued data. If true, a y-intercept is calculated during fitting. Otherwise, the intercept is set to zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>M-estimation works by finding the model coefficients that minimize the sum of a function of the residuals.
This function, called the objective function rho(), is a kind of statistical distance (AKA divergence), and a semimetric.
As a semimetric it is a function of the measured value <code>y</code> and the modeled value <code>Y</code> (residual <code class="reqn">r = y - Y</code>) which maps from
the space of the data to the positive real numbers. Semimetrics can be defined for domains of any dimensionality, including the
two dimensional complex numbers, and thus so can M-estimation.
What's more, all the standard algebraic operations used in the itteratively (re)weighted least-squares M-estimator robust regression
algorithm are defined over the set of complex numbers. While ordering is not defined for them, it is the output of rho(), a real number, that must be
in M-estimation.
</p>


<h3>Value</h3>

<p>An object of class <code>c("rzlm", "zlm", "rlm", "lm")</code>, or for numeric data <code>c("rlm", "lm")</code>.
</p>
<p>Objects of class &quot;rzlm&quot; are lists with the same components as &quot;zlm&quot; objects, as well as,
</p>
<table>
<tr><td><code>df.residual</code></td>
<td>
<p><code>NA</code> For &quot;rzlm&quot; objects the residual degrees of freedom are always set to <code>NA</code> in order to avoid estimation of residual scale by &quot;zlm&quot; or &quot;lm&quot; methods.</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>The robust scale estimate used.</p>
</td></tr>
<tr><td><code>w</code></td>
<td>
<p>The weights used in the IWLS process.</p>
</td></tr>
<tr><td><code>psi</code></td>
<td>
<p>The psi (itterative weighting) function with parameters substituted in.</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>The value of the convergence criteria at each iteration.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Did the IWLS process converge?</p>
</td></tr>
<tr><td><code>wresid</code></td>
<td>
<p>A 'working residual', the residuals of the last re-weighted least-squares. Weighted by <code>weights</code> if &quot;inv.var&quot; weights were used. </p>
</td></tr>
</table>
<p>See <a href="MASS.html#topic+rlm">MASS::rlm</a> for a description of &quot;rlm&quot; objects.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>formula</code>: S3 method for class 'formula'
</p>
</li>
<li> <p><code>complex</code>: Complex Default S3 method
</p>
</li></ul>


<h3>References</h3>

<p>P. J. Huber (1981)
<em>Robust Statistics</em>.
Wiley.
</p>
<p>F. R. Hampel, E. M. Ronchetti, P. J. Rousseeuw and W. A. Stahel (1986)
<em>Robust Statistics: The Approach based on Influence Functions</em>.
Wiley.
</p>
<p>A. Marazzi (1993)
<em>Algorithms, Routines and S Functions for Robust Statistics</em>.
Wadsworth &amp; Brooks/Cole.
</p>
<p>Venables, W. N. and Ripley, B. D. (2002)
<em>Modern Applied Statistics with S.</em>  Fourth edition.  Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 8
slope &lt;- complex(real = 4.23, imaginary = 2.323)
interc &lt;- complex(real = 1.4, imaginary = 1.804)
e &lt;- complex(real=rnorm(n)/6, imaginary=rnorm(n)/6)
xx &lt;- complex(real= rnorm(n), imaginary= rnorm(n))
tframe &lt;- data.frame(x = xx, y= slope*xx + interc + e)
rlm(y ~ x, data = tframe, weights = rep(1,n))
set.seed(4242)
n &lt;- 8
slope &lt;- complex(real = 4.23, imaginary = 2.323)
intercept &lt;- complex(real = 1.4, imaginary = 1.804)
e &lt;- complex(real=rnorm(n)/6, imaginary=rnorm(n)/6)
x &lt;- complex(real = rnorm(n), imaginary = rnorm(n))
y &lt;- slope * x + intercept + e
rlm(x = x, y = y, weights = rep(1,n), interc = TRUE)
</code></pre>

<hr>
<h2 id='rstandard.zlm'>Standardized Residuals from Ordinary or Robust Linear fits with Complex Variables</h2><span id='topic+rstandard.zlm'></span>

<h3>Description</h3>

<p>Generates a vector of residuals from the given complex linear model that are normalized to have unit variance.
Similar to <a href="stats.html#topic+influence.measures">stats::rstandard</a>, which this function calls if given numeric input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zlm'
rstandard(model, lever = zhatvalues(model), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstandard.zlm_+3A_model">model</code></td>
<td>
<p>An object of class &quot;zlm&quot;, &quot;rzlm&quot;, &quot;lm&quot;, or &quot;rlm&quot;. Can be complex or numeric.</p>
</td></tr>
<tr><td><code id="rstandard.zlm_+3A_lever">lever</code></td>
<td>
<p>A list of leverage scores with the same length as <code>model$residuals</code>. By default <a href="#topic+zhatvalues">zhatvalues</a> is called on <code>model</code>.</p>
</td></tr>
<tr><td><code id="rstandard.zlm_+3A_...">...</code></td>
<td>
<p>Other parameters. Only used if <code>model</code> is numeric; in which case they are passed to <code>stats::rstandard</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standardized residuals are calculated as,<br />
</p>
<p style="text-align: center;"><code class="reqn">r' = r / ( s \sqrt{1 - lever} )</code>
</p>
<p><br />
Where <code class="reqn">r</code> is the residual vector and <code class="reqn">s</code> is the residual standard error for &quot;zlm&quot; objects
or the robust scale estimate for &quot;rzlm&quot; objects.
</p>


<h3>Value</h3>

<p>A complex vector of length equal to that of the residuals of <code>model</code>. Numeric for numeric input.
</p>


<h3>Note</h3>

<p>This is a much simpler function than <a href="stats.html#topic+influence.measures">stats::rstandard</a>.
It cannot perform leave-one-out cross validation residuals, or anything else not mentioned here.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+influence.measures">stats::rstandard</a>, <a href="stats.html#topic+influence.measures">stats::rstandard.lm</a>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 8
slop &lt;- complex(real = 4.23, imaginary = 2.323)
interc &lt;- complex(real = 1.4, imaginary = 1.804)
e &lt;- complex(real=rnorm(n)/6, imaginary=rnorm(n)/6)
xx &lt;- complex(real= rnorm(n), imaginary= rnorm(n))
tframe &lt;- data.frame(x = xx, y= slop*xx + interc + e)
fit &lt;- lm(y ~ x, data = tframe, weights = rep(1,n))
rstandard(fit)
</code></pre>

<hr>
<h2 id='summary.complex'>summary method for complex objects</h2><span id='topic+summary.complex'></span>

<h3>Description</h3>

<p>The base summary method for complex objects only reports their length and that they are complex..
This improved method returns the length, as well as the mean, median, variance, and pseudo variance of the given complex object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'complex'
summary(object, ..., digits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.complex_+3A_object">object</code></td>
<td>
<p>a complex vector or scalar.</p>
</td></tr>
<tr><td><code id="summary.complex_+3A_...">...</code></td>
<td>
<p>additional arguments, not used.</p>
</td></tr>
<tr><td><code id="summary.complex_+3A_digits">digits</code></td>
<td>
<p>integer specifying the number of digits to include in the summary values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the length of the object, and a complex named vector containing in the median, mean, variance, and pseudo variance of the object; in that order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 8
foo &lt;- complex(real = rnorm(n), imaginary = rnorm(n))
summary(foo)
</code></pre>

<hr>
<h2 id='summary.rzlm'>Summary Method for Robust Linear Models</h2><span id='topic+summary.rzlm'></span>

<h3>Description</h3>

<p>Summary method for objects of class &quot;rzlm&quot;, capable of processing complex variable fits.
If the residuals in the passed object are numeric, this function just calls <code><a href="MASS.html#topic+summary.rlm">MASS::summary.rlm()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rzlm'
summary(object, method = c("XtX", "XtWX"), correlation = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.rzlm_+3A_object">object</code></td>
<td>
<p>An object inheriting from the class 'rzlm'. That is, a fitted model that was generated by <a href="#topic+rlm">rlm</a>.</p>
</td></tr>
<tr><td><code id="summary.rzlm_+3A_method">method</code></td>
<td>
<p>Character string indicating if the IWLS weights should be used when calculating matrix cross-products. &quot;XtX&quot; does not include weights, &quot;XtWX&quot; does.</p>
</td></tr>
<tr><td><code id="summary.rzlm_+3A_correlation">correlation</code></td>
<td>
<p>Logical. Should the correlations be computed and printed?</p>
</td></tr>
<tr><td><code id="summary.rzlm_+3A_...">...</code></td>
<td>
<p>Other arguments, passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the generic <code>summary()</code> function. It is based on the function of the same name from MASS, but has been modified to accept complex numbers.
In addition to the standard error of the coefficients, it calculates a &quot;pseudo standard error&quot; or &quot;relational standard error&quot; as the square root of the &quot;pseudo-variance&quot;.
This is a complex number that quantifies the covariance between the real and imaginary parts. It can also be thought of as the amount and direction of anisotropy in the
(presumed complex normal) probability distribution in the complex plane. The argument of this number gives the direction of the semi-major axis.
</p>


<h3>Value</h3>

<p>Returns a list containing the following elements. If the list is printed by the function (<code>print.summary.rlm</code> or invoked as a method by <code>summary</code>), a null value is returned instead.
</p>
<table>
<tr><td><code>correlation</code></td>
<td>
<p>A numeric matrix. The computed correlation coefficient matrix for the coefficients in the model.</p>
</td></tr>
<tr><td><code>pseudocorrelation</code></td>
<td>
<p>A complex matrix. The computed pseudo-correlation coefficient matrix for the coefficients in the model.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>The unscaled covariance matrix; i.e, a numeric matrix such that multiplying it by an estimate of the error variance produces an estimated covariance matrix for the coefficients.</p>
</td></tr>
<tr><td><code>pcov.unscaled</code></td>
<td>
<p>The unscaled pseudo-covariance matrix; i.e, a complex matrix such that multiplying it by an estimate of the error pseudo-variance produces an estimated pseudo-covariance matrix for the coefficients.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Numeric. The scale estimate returned by <code>rlm</code>, which was used to scale the residuals before passing them to the <code>psi</code> weight function.</p>
</td></tr>
<tr><td><code>stddev</code></td>
<td>
<p>Numeric. A scale estimate used for the standard errors. Calculated from the working residuals, the <code>psi</code> weight function, and the derivative of the influence function (<code>psi.method(deriv = 1)</code>).</p>
</td></tr>
<tr><td><code>pstddev</code></td>
<td>
<p>Complex. A scale estimate used for the 'pseudo' standard errors. Calculated from the working residuals, the <code>psi</code> weight function, and the derivative of the influence function (<code>psi.method(deriv = 1)</code>). See details above.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The number of degrees of freedom for the model and for residuals.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>A 4 column matrix that contains the model coefficients, their standard errors, their pseudo standard errors (see details above), and their t statistics.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>The terms object used in fitting this model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>W. N. Venables and B. D. Ripley, Modern Applied Statistics with S, 4th ed (Springer, New York, 2002).
P. J. Huber and E. Ronchetti, Robust Statistics, 2nd ed (Wiley, Hoboken, N.J, 2009).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 8
slope &lt;- complex(real = 4.23, imaginary = 2.323)
intercept &lt;- complex(real = 1.4, imaginary = 1.804)
e &lt;- complex(real=rnorm(n)/6, imaginary=rnorm(n)/6)
x &lt;- complex(real = rnorm(n), imaginary = rnorm(n))
y &lt;- slope * x + intercept + e
robfit &lt;- rlm(x = x, y = y, weights = rep(1,n), interc = TRUE)
summary(robfit)
</code></pre>

<hr>
<h2 id='summary.zlm'>Summarize Complex Linear Model Fits.</h2><span id='topic+summary.zlm'></span><span id='topic+print.summary.zlm'></span>

<h3>Description</h3>

<p>Summary method for complex linear fits of class &quot;zlm&quot;.
Based off of, and very similar to <a href="stats.html#topic+summary.lm">stats::summary.lm</a>. However it does not delve into quantiles or 'significance stars', and includes the 'pseudo variance'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zlm'
summary(object, correlation = FALSE, symbolic.cor = FALSE, ...)

## S3 method for class 'summary.zlm'
print(
  x,
  digits = max(3L, getOption("digits") - 3L),
  symbolic.cor = x$symbolic.cor,
  quantiles = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.zlm_+3A_object">object</code></td>
<td>
<p>An object of class &quot;zlm&quot;. Presumably returned by <a href="#topic+lm">lm</a>. May contain complex variables.</p>
</td></tr>
<tr><td><code id="summary.zlm_+3A_correlation">correlation</code></td>
<td>
<p>Logical. If TRUE, the correlation matrix of the estimated parameters is returned and printed.</p>
</td></tr>
<tr><td><code id="summary.zlm_+3A_symbolic.cor">symbolic.cor</code></td>
<td>
<p>Logical. If TRUE, print the correlations in a symbolic form (see <a href="stats.html#topic+symnum">stats::symnum</a>) rather than as numbers. (This may not work.)</p>
</td></tr>
<tr><td><code id="summary.zlm_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="summary.zlm_+3A_x">x</code></td>
<td>
<p>a 'zlm' object or an 'zlm' summary object. Used for <code>print.summary.zlm</code></p>
</td></tr>
<tr><td><code id="summary.zlm_+3A_digits">digits</code></td>
<td>
<p>the number of digits to include in the printed report, default is three. Used for <code>print.summary.zlm</code></p>
</td></tr>
<tr><td><code id="summary.zlm_+3A_quantiles">quantiles</code></td>
<td>
<p>logical. Should the (inaccurate) quantiles of the residuals be printed? If <code>FALSE</code> <a href="#topic+summary.complex">summary.complex</a> is applied to the residuals instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <a href="stats.html#topic+summary.lm">stats::summary.lm</a> for more information.
In addition to the information returned by <code>stats::summary.lm</code>, this complex variable compatible version also returns
&quot;pseudo standard error&quot; or &quot;relational standard error&quot; which is the square root of the &quot;pseudo-variance&quot;.
This is a complex number that quantifies the covariance between the real and imaginary parts. Can also be thought of as the amount and direction of anisotropy of the
(presumed complex normal) probability distribution of the residuals in the complex plane. The argument of this number gives the direction of the semi-major axis of an iso-probability-density ellipse
centered on the mean, while its modulus is the length of the semi-major axis. The variance, meanwhile, gives the area of this ellipse, divided by pi. Together they fully describe it.
</p>


<h3>Value</h3>

<p>Returns an object of class &quot;summary.zlm&quot; and &quot;summary.lm&quot;, that is a list containing the following elements.
</p>
<table>
<tr><td><code>residuals</code></td>
<td>
<p>Complex or numeric. The weighted residuals, that is the measured value minus the fitted value, scaled by the square root of the weights given in the call to lm.</p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>
<p>A complex matrix with real diagonal elements. The computed correlation coefficient matrix for the coefficients in the model.</p>
</td></tr>
<tr><td><code>pseudocorrelation</code></td>
<td>
<p>A complex matrix. The computed pseudo-correlation coefficient matrix for the coefficients in the model.</p>
</td></tr>
<tr><td><code>cov.unscaled</code></td>
<td>
<p>The unscaled covariance matrix; i.e, a complex matrix with real diagonal elements such that multiplying it by an estimate of the error variance produces an estimated covariance matrix for the coefficients.</p>
</td></tr>
<tr><td><code>pcov.unscaled</code></td>
<td>
<p>The unscaled pseudo-covariance matrix; i.e, a complex matrix such that multiplying it by an estimate of the error pseudo-variance produces an estimated pseudo-covariance matrix for the coefficients.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Numeric. The square root of the estimated variance of the random error.</p>
</td></tr>
<tr><td><code>psigma</code></td>
<td>
<p>Complex. The square root of the estimated pseudo-variance of the random error. See details above.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The number of degrees of freedom for the model and for residuals. A 3 element vector (p, n-p, p*), the first being the number of non-aliased coefficients, the last being the total number of coefficients.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>A 5 column matrix that contains the model coefficients, their standard errors, their pseudo standard errors (see details above), their t statistics, and corresponding (two-sided) p-value. Aliased coefficients are omitted.</p>
</td></tr>
<tr><td><code>aliased</code></td>
<td>
<p>Named logical vector showing if the original coefficients are aliased.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>The terms object used in fitting this model.</p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>(for models including non-intercept terms) a 3 element numeric vector with the value of the F-statistic with its numerator and denominator degrees of freedom.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>Numeric. The fraction of variance explained by the model.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>the above R^2 statistic &quot;adjusted&quot;, penalizing for higher p.</p>
</td></tr>
<tr><td><code>symbolic.cor</code></td>
<td>
<p>(only if <code>correlation</code> is true.) The value of the argument symbolic.cor.</p>
</td></tr>
<tr><td><code>na.action</code></td>
<td>
<p>from <code>object</code>, if present there.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>print.summary.zlm</code>: S3 method for class 'summary.zlm'
</p>
</li></ul>


<h3>Note</h3>

<p><code>print.summary.zlm</code> calls <code>print.summary.rzlm</code>
</p>
<p>For complex fits the quantiles reported by this function are based on sorting the real parts of the residuals. They should not be considered reliable..
</p>


<h3>See Also</h3>

<p><a href="#topic+lm">lm</a>, <a href="#topic+rlm">rlm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 8
slop &lt;- complex(real = 4.23, imaginary = 2.323)
interc &lt;- complex(real = 1.4, imaginary = 1.804)
e &lt;- complex(real=rnorm(n)/6, imaginary=rnorm(n)/6)
xx &lt;- complex(real= rnorm(n), imaginary= rnorm(n))
tframe &lt;- data.frame(x = xx, y= slop*xx + interc + e)
fit &lt;- lm(y ~ x, data = tframe, weights = rep(1,n))
summ &lt;- summary(fit)
print(summ)
</code></pre>

<hr>
<h2 id='vcov.rzlm'>Calculate Variance-Covariance Matrix and Pseudo Variance-Covariance Matrix for a Complex Fitted Model Object</h2><span id='topic+vcov.rzlm'></span>

<h3>Description</h3>

<p>A version of <a href="stats.html#topic+vcov">stats::vcov</a> that is compatible with complex linear models. In addition to the variance-covariance matrix,
the pseudo variance-covariance matrix, which is a measure of the covariance between real and imaginary components, is returned as well.
Can also return the &quot;big covariance&quot; matrix, which combines the information of the covariance matrix and the pseudo-covariance matrix, as described in (van den Bos 1995).
While not as compact as two seperate smaller matrices, the big covariance matrix simplifies calculations such as the <a href="#topic+mahalanobis">mahalanobis</a> distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rzlm'
vcov(object, merge = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.rzlm_+3A_object">object</code></td>
<td>
<p>a fitted model object, typically. Sometimes also a summary() object of such a fitted model.</p>
</td></tr>
<tr><td><code id="vcov.rzlm_+3A_merge">merge</code></td>
<td>
<p>logical. Should the covariance matrix and pseudo-covariance / relational matrix be merged into one matrix of twice the dimensions? Default is TRUE.</p>
</td></tr>
<tr><td><code id="vcov.rzlm_+3A_...">...</code></td>
<td>
<p>Additional parameters, not currently used for anything.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>merge</code> is false, a list containing both the numeric variance-covariance matrix, and the complex pseudo variance-covariance matrix.
If <code>merge</code> is true, a large matrix (both dimensions twice the number of coefficients) containing both the variance-covariance matrix and the pseudo variance-covariance matrix, merged together.
</p>


<h3>References</h3>

<p>A. van den Bos, The Multivariate Complex Normal Distribution-a Generalization, IEEE Trans. Inform. Theory 41, 537 (1995).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 8
slope &lt;- complex(real = 4.23, imaginary = 2.323)
intercept &lt;- complex(real = 1.4, imaginary = 1.804)
e &lt;- complex(real=rnorm(n)/6, imaginary=rnorm(n)/6)
x &lt;- complex(real = rnorm(n), imaginary = rnorm(n))
y &lt;- slope * x + intercept + e
robfit &lt;- rlm(x = x, y = y, weights = rep(1,n), interc = TRUE)
summary(robfit)$stddev
vcov(robfit)
</code></pre>

<hr>
<h2 id='vcov.zlm'>Calculate Variance-Covariance Matrix and Pseudo Variance-Covariance Matrix for a Complex Fitted Model Object</h2><span id='topic+vcov.zlm'></span><span id='topic+.vcov.aliased.complex'></span>

<h3>Description</h3>

<p>A method for of <a href="stats.html#topic+vcov">stats::vcov</a> that is compatible with complex linear models. In addition to variance-covariance matrix,
the pseudo variance-covariance matrix, which is a measure of the covariance between real and imaginary components, is returned as well.
Can also return the &quot;double covariance&quot; matrix, which combines the information of the covariance matrix and the pseudo-covariance matrix, as described in (van den Bos 1995).
While not as compact as two separate smaller matrices, the double covariance matrix simplifies calculations such as the <a href="#topic+mahalanobis">mahalanobis</a> distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'zlm'
vcov(object, complete = TRUE, merge = TRUE, ...)

.vcov.aliased.complex(aliased, vc, complete = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.zlm_+3A_object">object</code></td>
<td>
<p>Typically a fitted model object of class &quot;zlm&quot; and/or &quot;rzlm&quot;. Sometimes also a summary() object of such a fitted model.</p>
</td></tr>
<tr><td><code id="vcov.zlm_+3A_complete">complete</code></td>
<td>
<p>logical. Indicates if the full covariance and pseudo-covariance matrices should be returned even in the case of an over-determined system, meaning that some coefficients are undefined.</p>
</td></tr>
<tr><td><code id="vcov.zlm_+3A_merge">merge</code></td>
<td>
<p>logical. Should the covariance matrix and pseudo-covariance / relational matrix be merged into one matrix of twice the dimensions? Default is TRUE.</p>
</td></tr>
<tr><td><code id="vcov.zlm_+3A_...">...</code></td>
<td>
<p>Additional parameters, not currently used for anything.</p>
</td></tr>
<tr><td><code id="vcov.zlm_+3A_aliased">aliased</code></td>
<td>
<p>a logical vector typically identical to <code>is.na(coef(.))</code> indicating which coefficients are 'aliased'.</p>
</td></tr>
<tr><td><code id="vcov.zlm_+3A_vc">vc</code></td>
<td>
<p>a variance-covariance matrix, typically &quot;incomplete&quot;, i.e., with no rows and columns for aliased coefficients.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>merge</code> is false, a list containing both the numeric variance-covariance matrix, and the complex pseudo variance-covariance matrix.
If <code>merge</code> is true, a large matrix (both dimensions being twice the number of coefficients) containing both the variance-covariance matrix and the pseudo variance-covariance matrix, merged together.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>.vcov.aliased.complex</code>: auxiliary function for dealing with singular model fits. See <a href="stats.html#topic+vcov">stats::vcov</a>.
</p>
</li></ul>


<h3>References</h3>

<p>A. van den Bos, The Multivariate Complex Normal Distribution-a Generalization, IEEE Trans. Inform. Theory 41, 537 (1995).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 8
slop &lt;- complex(real = 4.23, imaginary = 2.323)
interc &lt;- complex(real = 1.4, imaginary = 1.804)
err &lt;- complex(real = rnorm(n)/16, imaginary = rnorm(n)/16)
tframe &lt;- data.frame(x= x &lt;- complex(real=rnorm(n), imaginary= rnorm(n)), y=slop*x + interc+err)
fit &lt;- lm(y ~ x, data = tframe, weights = rep(1,n))
vcov(fit)
</code></pre>

<hr>
<h2 id='wmedian'>Weighted Median</h2><span id='topic+wmedian'></span>

<h3>Description</h3>

<p>This calculates the weighted median of a vector <code>x</code> using the weights in <code>w</code>. Weights are re-scaled based on their sum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wmedian(x, w = rep(1, length(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wmedian_+3A_x">x</code></td>
<td>
<p>numeric, a vector containing the data from which to calculate the weighted median.</p>
</td></tr>
<tr><td><code id="wmedian_+3A_w">w</code></td>
<td>
<p>numeric, a vector of weights to give the data in x.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sorts <code>x</code> and <code>w</code> by size of the elements of <code>x</code>. Then re-scales the elements of <code>w</code> to be between 0 and 1.
Then sets n equal to the sum of all scaled weights with values less than 0.5. If the (n+1)-th element of the
rescaled weights is greater than 0.5, the weighted median is the (n+1)-th element of the sorted <code>x</code>. Otherwise
it is the average of the (n+1)-th and (n+2)-th elements of the sorted <code>x</code>.
</p>


<h3>Value</h3>

<p>numeric. The weighted median of <code>x</code> using <code>w</code> as the weights.
</p>


<h3>Note</h3>

<p>This is not compatible with complex data.
</p>


<h3>References</h3>

<p>F. Y. Edgeworth, XXII. On a New Method of Reducing Observations Relating to Several Quantities, (1888).
Also see the Wikipedia article on weighted median for a very good explanation and a model algorithm.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+median">stats::median</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xx &lt;- rnorm(10, 4L, 1.5)
ww &lt;- runif(10)
wmedian(xx, ww)

</code></pre>

<hr>
<h2 id='zhatvalues'>Generate the Hat Matrix or Leverage Scores of a Complex Linear Model</h2><span id='topic+zhatvalues'></span>

<h3>Description</h3>

<p>This function returns either the full hat matrix (AKA the projection matrix) of a complex &quot;lm&quot; or &quot;rlm&quot; object, or the diagonal elements of same.
The later are also known as the influence scores.
It performs the same basic role as <a href="stats.html#topic+influence.measures">stats::hat</a> and <a href="stats.html#topic+influence.measures">stats::hatvalues</a> do for numeric fits, but is quite a bit simpler
and rather less versatile.
<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zhatvalues(model, full = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zhatvalues_+3A_model">model</code></td>
<td>
<p>A complex linear fit object, of class &quot;zlm&quot; or &quot;rzlm&quot;. An object with numeric residuals will produce a warning and NULL output.</p>
</td></tr>
<tr><td><code id="zhatvalues_+3A_full">full</code></td>
<td>
<p>Logical. If TRUE, return the entire hat matrix. If FALSE, return a vector of the diagonal elements of the hat matrix. These are the influence scores. Default is FALSE.</p>
</td></tr>
<tr><td><code id="zhatvalues_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For unweighted least-squares fits the hat matrix is calculated from the model matrix, <i>X = </i><code>model$x</code>, as <br />
\[H = X (X^t X)^{-1} X^t\]<br />
For rlm or weighted least-squares fits the hat matrix is calculated as<br />
\[H = X (X^t W X)^{-1} X^t W\]
Where <i>^t</i> represents conjugate transpose, and <i>W</i> is the identity matrix times the user provided weights and the final IWLS weights if present. <br />
Note that this function requires that the model matrix be returned when calling <a href="#topic+lm">lm</a> or <a href="#topic+rlm">rlm</a>.<br />
The diagonals will be purely real, and are converted to numeric if <code>full == FALSE</code>.
</p>


<h3>Value</h3>

<p>Either a <i>(n x n)</i> complex matrix or a length <i>n</i> numeric vector.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+influence.measures">stats::hatvalues</a>, <a href="stats.html#topic+influence.measures">stats::hat</a>, <a href="stats.html#topic+cooks.distance">cooks.distance</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 8
slop &lt;- complex(real = 4.23, imaginary = 2.323)
interc &lt;- complex(real = 1.4, imaginary = 1.804)
e &lt;- complex(real=rnorm(n)/6, imaginary=rnorm(n)/6)
xx &lt;- complex(real= rnorm(n), imaginary= rnorm(n))
tframe &lt;- data.frame(x = xx, y= slop*xx + interc + e)
fit &lt;- lm(y ~ x, data = tframe, weights = rep(1,n))
zhatvalues(fit)
</code></pre>

<hr>
<h2 id='zlm.wfit'>Least-Squares Linear Fitting for Complex Variables</h2><span id='topic+zlm.wfit'></span>

<h3>Description</h3>

<p>The function eventually called by <code><a href="#topic+lm">lm()</a></code>, <code><a href="#topic+lm.fit">lm.fit()</a></code>, and/or <code><a href="#topic+lm.wfit">lm.wfit()</a></code> if fed complex data.
Performs ordinary (least-squares) linear fitting on complex variable data.
Like <code><a href="stats.html#topic+lmfit">stats::lm.wfit()</a></code>, which it is based off of, it uses qr decomposition
for the matrix algebra. Unlike <code>stats::lm.wfit()</code> it also handles un-weighted
regression, by setting the weights to 1 by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zlm.wfit(
  x,
  y,
  w = rep(1L, ifelse(is.vector(x), length(x), nrow(x))),
  offset = NULL,
  method = "qr",
  tol = 1e-07,
  singular.ok = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zlm.wfit_+3A_x">x</code></td>
<td>
<p>a complex design matrix, <code>n</code> rows by <code>p</code> columns.</p>
</td></tr>
<tr><td><code id="zlm.wfit_+3A_y">y</code></td>
<td>
<p>a vector of observations/responses of length <code>n</code>, or a matrix with <code>n</code> rows.</p>
</td></tr>
<tr><td><code id="zlm.wfit_+3A_w">w</code></td>
<td>
<p>a vector of weights to be used in the fitting process. The sum of <code>w * r^2</code> is minimized, with <code>r</code> being the residuals. By default, <code>w</code> is a vector of length <code>n</code> with every element equal to 1, making this an unweighted fit.</p>
</td></tr>
<tr><td><code id="zlm.wfit_+3A_offset">offset</code></td>
<td>
<p>optional. A complex vector of length n that will be subtracted from y prior to fitting.</p>
</td></tr>
<tr><td><code id="zlm.wfit_+3A_method">method</code></td>
<td>
<p>optional. a string that can be used to choose any method you would like. As long as it is &quot;qr&quot;.</p>
</td></tr>
<tr><td><code id="zlm.wfit_+3A_tol">tol</code></td>
<td>
<p>tolerance for the <a href="Matrix.html#topic+qr">qr</a> decomposition. Default is 1e-7.</p>
</td></tr>
<tr><td><code id="zlm.wfit_+3A_singular.ok">singular.ok</code></td>
<td>
<p>logical. If false, a singular model is an error.</p>
</td></tr>
<tr><td><code id="zlm.wfit_+3A_...">...</code></td>
<td>
<p>currently disregarded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code><a href="base.html#topic+list">list</a></code> with components (for <code>lm.fit</code> and <code>lm.wfit</code>)
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p><code>p</code> vector</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p><code>n</code> vector or matrix</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p><code>n</code> vector or matrix</p>
</td></tr>
<tr><td><code>effects</code></td>
<td>
<p><code>n</code> vector of orthogonal single-df
effects.  The first <code>rank</code> of them correspond to non-aliased
coefficients, and are named accordingly.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p><code>n</code> vector &mdash; <em>only</em> for the <code>*wfit*</code>
functions.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>integer, giving the rank</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>degrees of freedom of residuals</p>
</td></tr>
<tr><td><code>qr</code></td>
<td>
<p>the QR decomposition, see <code><a href="Matrix.html#topic+qr">qr</a></code>.</p>
</td></tr>
</table>
<p>Fits without any columns or non-zero weights do not have the
<code>effects</code> and <code>qr</code> components.
</p>
<p><code>.lm.fit()</code> returns a subset of the above, the <code>qr</code> part
unwrapped, plus a logical component <code>pivoted</code> indicating if the
underlying QR algorithm did pivot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
n &lt;- 6
p &lt;- 2
slop &lt;- complex(real = 4.23, imaginary = 2.323)
slop2 = complex(real = 2.1, imaginary = -3.9)
interc &lt;- complex(real = 1.4, imaginary = 1.804)
e &lt;- complex(real=rnorm(n)/6, imaginary=rnorm(n)/6)
desmat &lt;- matrix(c(complex(real = rnorm(n * p), imaginary = rnorm(n * p)), rep(1, n)), n, p + 1)
y = desmat %*% c(slop, slop2, interc) + e
lm.fit(desmat, y)
</code></pre>

<hr>
<h2 id='zmodel.matrix'>Generate a Model Matrix (Design Matrix) Using Complex Variables</h2><span id='topic+zmodel.matrix'></span>

<h3>Description</h3>

<p>A function that somewhat replicates model.matrix(), but accepts complex valued data. It will probably be slower and less efficient, but mostly functional.
It cannot handle algebraic expressions in formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zmodel.matrix(trms, data, contrasts.arg = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zmodel.matrix_+3A_trms">trms</code></td>
<td>
<p>A &quot;terms&quot; object as generated by <code><a href="stats.html#topic+terms">stats::terms()</a></code>.</p>
</td></tr>
<tr><td><code id="zmodel.matrix_+3A_data">data</code></td>
<td>
<p>A data frame containing the data referenced by the symbolic formula / model in <code>trms</code>.</p>
</td></tr>
<tr><td><code id="zmodel.matrix_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>a list, default is NULL. Not currently supported. See <code><a href="stats.html#topic+model.matrix">stats::model.matrix()</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A model matrix, AKA a design matrix for a regression, containing the relevant information from <code>data</code>.
</p>


<h3>See Also</h3>

<p><a href="stats.html#topic+model.matrix">stats::model.matrix</a>, <a href="#topic+lm">lm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(4242)
slop &lt;- complex(real = 4.23, imaginary = 2.323)
interc &lt;- complex(real = 1.4, imaginary = 1.804)
tframe &lt;- expand.grid(-3:3,-3:3)
Xt &lt;- complex(real = tframe[[1]], imaginary = tframe[[2]])
tframe &lt;- data.frame(Xt=Xt, Yt= Xt * slop + interc + complex(real=rnorm(length(Xt)),
 imaginary=rnorm(length(Xt))))
testterms &lt;- terms(Yt ~ Xt)
zmodel.matrix(testterms, tframe)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
