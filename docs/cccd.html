<!DOCTYPE html><html><head><title>Help for package cccd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cccd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cccd'>
<p>Class Cover Catch Digraph</p></a></li>
<li><a href='#ccd'><p> Cluster Catch Digraphs</p></a></li>
<li><a href='#dominate'><p> Dominating Sets</p></a></li>
<li><a href='#gg'><p> Gabriel Graph</p></a></li>
<li><a href='#juggling'>
<p>Juggling</p></a></li>
<li><a href='#nng'><p> Nearest Neighbor Graphs</p></a></li>
<li><a href='#prune'><p> Prune Points</p></a></li>
<li><a href='#rng'><p> Relative Neighborhood Graph.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Class Cover Catch Digraphs</td>
</tr>
<tr>
<td>Author:</td>
<td>David J. Marchette &lt;dmarchette@gmail.com&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David J. Marchette &lt;dmarchette@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>igraph</td>
</tr>
<tr>
<td>Imports:</td>
<td>proxy, deldir, FNN</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Matrix</td>
</tr>
<tr>
<td>Description:</td>
<td>Class Cover Catch Digraphs, neighborhood graphs, and
        relatives.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-08 11:43:02 UTC; dmarchette</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-08 12:22:29 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
</table>
<hr>
<h2 id='cccd'>
Class Cover Catch Digraph
</h2><span id='topic+cccd'></span><span id='topic+cccd.rw'></span><span id='topic+cccd.classify'></span><span id='topic+cccd.classifier'></span><span id='topic+cccd.classifier.rw'></span><span id='topic+cccd.multiclass.classifier'></span><span id='topic+cccd.multiclass.classify'></span><span id='topic+plot.cccd'></span><span id='topic+plot.cccdClassifier'></span>

<h3>Description</h3>

<p>Constructs a class cover catch digraph from points or interpoint distance matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cccd(x = NULL, y = NULL, dxx = NULL, dyx = NULL, method = NULL, 
     k = NA, algorithm = 'cover_tree')
cccd.rw(x=NULL,y=NULL,dxx=NULL,dyx=NULL,method=NULL,m=1,d=2)
cccd.classifier(x,y,dom.method='greedy',proportion=1,...)
cccd.classify(data, C,method=NULL)
cccd.classifier.rw(x,y,m=1,d=2)
cccd.multiclass.classifier(data, classes, dom.method='greedy',proportion=1,...)
cccd.multiclass.classify(data,C,method=NULL)
## S3 method for class 'cccd'
plot(x, ..., plot.circles = FALSE, dominate.only = FALSE, 
          D = NULL, vertex.size = 2, vertex.label = NA, 
			 vertex.color = "SkyBlue2", dom.color = "Blue", 
			 ypch = 20, ycex = 1.5, ycol = 2, 
			 use.circle.radii = FALSE, balls = FALSE, 
			 ball.color = gray(0.8), square = FALSE, xlim, ylim)
## S3 method for class 'cccdClassifier'
plot(x, ..., xcol=1,ycol=2,xpch=20,ypch=xpch,
                                balls=FALSE,add=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cccd_+3A_x">x</code>, <code id="cccd_+3A_y">y</code></td>
<td>

<p>the target class and non-target class points. Either x,y
or dxx,dyx must be provided. In the case of <code>plot</code>, x is
an object of class cccd.
</p>
</td></tr>
<tr><td><code id="cccd_+3A_dxx">dxx</code>, <code id="cccd_+3A_dyx">dyx</code></td>
<td>

<p>interpoint distances (x against x and y against x). If these
are not provided they are computed using x and y.
</p>
</td></tr>
<tr><td><code id="cccd_+3A_method">method</code></td>
<td>
<p> the method used for the distance. 
See <code><a href="proxy.html#topic+dist">dist</a></code>.</p>
</td></tr>
<tr><td><code id="cccd_+3A_dom.method">dom.method</code>, <code id="cccd_+3A_proportion">proportion</code></td>
<td>
<p> the method used for the domination set 
computation, and the proportion of points required to dominate.  
See <code><a href="#topic+dominate">dominate</a></code>.</p>
</td></tr>
<tr><td><code id="cccd_+3A_k">k</code></td>
<td>
<p>If given, <code>get.knn</code> is used from FNN to approximate
the class cover catch graph. Each x covers no more than the <code>k</code> 
nearest neighbors to it.
This will be much faster and use less memory for large data sets, but 
is an approximation unless <code>k</code> is sufficiently large.</p>
</td></tr>
<tr><td><code id="cccd_+3A_algorithm">algorithm</code></td>
<td>
<p>See <code><a href="FNN.html#topic+get.knn">get.knn</a></code>.</p>
</td></tr>
<tr><td><code id="cccd_+3A_m">m</code></td>
<td>
<p>slope of the null hypothesis curve</p>
</td></tr>
<tr><td><code id="cccd_+3A_data">data</code></td>
<td>
<p>data to be classified</p>
</td></tr>
<tr><td><code id="cccd_+3A_d">d</code></td>
<td>
<p>dimension of the data</p>
</td></tr>
<tr><td><code id="cccd_+3A_classes">classes</code></td>
<td>
<p>class labels of the data</p>
</td></tr>
<tr><td><code id="cccd_+3A_c">C</code></td>
<td>
<p>cccd object</p>
</td></tr>
<tr><td><code id="cccd_+3A_plot.circles">plot.circles</code></td>
<td>
<p> logical. Plot the circles around the points if TRUE.</p>
</td></tr>
<tr><td><code id="cccd_+3A_dominate.only">dominate.only</code></td>
<td>
<p> logical. Only plot the digraph induced by the
dominating set.</p>
</td></tr>
<tr><td><code id="cccd_+3A_d">D</code></td>
<td>
<p> a dominating set. Only used if dominate.only is TRUE. If
dominate.only is TRUE and D is NULL, then <code>dominate</code>
is called.</p>
</td></tr>
<tr><td><code id="cccd_+3A_vertex.size">vertex.size</code>, <code id="cccd_+3A_vertex.color">vertex.color</code>, <code id="cccd_+3A_vertex.label">vertex.label</code>, <code id="cccd_+3A_dom.color">dom.color</code></td>
<td>
<p>parameters controling
the plotting of the vertices. <code>dom.color</code> is the color
of the vertices in the dominating set.</p>
</td></tr>
<tr><td><code id="cccd_+3A_balls">balls</code>, <code id="cccd_+3A_ball.color">ball.color</code></td>
<td>
<p>if <code>balls</code>=TRUE, the cover is plotted
as filled balls, with
<code>ball.color</code> controling their color. In the cass of
<code>cccdClassifier</code>, <code>balls</code> can be &quot;x&quot; or &quot;y&quot; indicating
that only one of the balls should be plotted.</p>
</td></tr>
<tr><td><code id="cccd_+3A_ypch">ypch</code>, <code id="cccd_+3A_ycex">ycex</code>, <code id="cccd_+3A_ycol">ycol</code></td>
<td>
<p> parameters for plotting the non-target points.</p>
</td></tr>
<tr><td><code id="cccd_+3A_xpch">xpch</code>, <code id="cccd_+3A_xcol">xcol</code></td>
<td>
<p>parameters for plotting the first class points.</p>
</td></tr>
<tr><td><code id="cccd_+3A_add">add</code></td>
<td>
<p>logical. Should the classifier plot be added to an existing plot?</p>
</td></tr>
<tr><td><code id="cccd_+3A_use.circle.radii">use.circle.radii</code></td>
<td>
<p> logical. Ensure that the circles fit
within the plot.</p>
</td></tr>
<tr><td><code id="cccd_+3A_square">square</code></td>
<td>
<p>logical. Make the plot square.</p>
</td></tr>
<tr><td><code id="cccd_+3A_xlim">xlim</code>, <code id="cccd_+3A_ylim">ylim</code></td>
<td>
<p>if present, these control the plotting region.</p>
</td></tr>
<tr><td><code id="cccd_+3A_...">...</code></td>
<td>
<p> arguments passed to <code>cccd</code> or <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The class cover catch digraph is a graph with vertices defined by the
points of <code>x</code> and edges defined according to the balls
<code class="reqn">B(x,d(x,Y))</code>. There is an edge between vertices
<code class="reqn">x_1,x_2</code> if <code class="reqn">x_2\in B(x_1,d(x_1,Y))</code>. If <code>dyx</code> is not
given and the method is 'euclidean', then <code>get.knnx</code> is used to
find the nearest <code>y</code> to each x. If <code>k</code> is given, only
the <code>k</code> nearest neighbors to each point are candidates for
covering. Thus the cccd will be approximate, but the computation will
(generally) be faster. Since <code>get.knn</code> uses Euclidean distance,
these choices will only be valid for this distance metric.
Since the graph will tend to be larger than
otherwise, the dominating set computation will be slower, so one
should trade-off speed of calculation, approximation, and the 
<code>proportion</code> option to the dominating set (which can make that
calculation faster at the cost of returning a subset of the dominating
set).
</p>


<h3>Value</h3>

<p>an object of class igraph. In addition, it contains the attributes:
</p>
<table>
<tr><td><code>R</code></td>
<td>
<p>a vector of radii.</p>
</td></tr>
<tr><td><code>Y</code></td>
<td>
<p>the y vectors.</p>
</td></tr>
<tr><td><code>layout</code></td>
<td>
<p>the x vectors.</p>
</td></tr>
</table>
<p>In the case of the classifier, the attributes are:
</p>
<table>
<tr><td><code>Rx</code>, <code>Ry</code></td>
<td>
<p>vectors of radii.</p>
</td></tr>
<tr><td><code>Cx</code>, <code>Cy</code></td>
<td>
<p>the ball centers.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The plotting assumes the cccd used Euclidean distance, and so the
balls/circles will be Euclidean balls/circles. If the 
method used in the distance was some other metric, you'll have
to plot the balls/circles yourself if you want them to be correct
on the plot.
</p>


<h3>Author(s)</h3>

<p>David J. Marchette, david.marchette@navy.mil
</p>


<h3>References</h3>

<p>D.J. Marchette,
&quot;Class Cover Catch Digraphs&quot;,
Wiley Interdisciplinary Reviews: Computational Statistics, 
2, 171-177, 2010.
</p>
<p>D.J. Marchette, Random Graphs for Statistical Pattern Recognition,
John Wiley &amp; Sons, 2004.
</p>
<p>C.E. Priebe, D.J. Marchette, J. DeVinney and D. Socolinsky, 
&quot;Classification Using Class Cover Catch Digraphs&quot;,
Journal of Classification,
20, 3-23, 2003.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ccd">ccd</a></code>, <code><a href="#topic+rng">rng</a></code>, <code><a href="#topic+gg">gg</a></code>, <code><a href="proxy.html#topic+dist">dist</a></code>,
<code><a href="FNN.html#topic+get.knn">get.knn</a></code>
<code><a href="#topic+dominate">dominate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(456330)
z &lt;- matrix(runif(1000),ncol=2)
ind &lt;- which(z[,1]&lt;.5 &amp; z[,2]&lt;.5)
x &lt;- z[ind,]
y &lt;- z[-ind,]
g &lt;- cccd(x,y)
C &lt;- cccd.classifier(x,y)
z2 &lt;- matrix(runif(1000),ncol=2)
ind &lt;- which(z2[,1]&lt;.5 &amp; z2[,2]&lt;.5)
cls &lt;- rep(0,nrow(z2))
cls[ind] &lt;- 1
out &lt;- cccd.classify(z2,C)
sum(out != cls)/nrow(z2)
## Not run: 
plot(g,plot.circles=TRUE,dominate.only=TRUE)
points(z2,col=2*(1-cls)+1,pch=20)

## End(Not run)
</code></pre>

<hr>
<h2 id='ccd'> Cluster Catch Digraphs</h2><span id='topic+ccd'></span><span id='topic+plot.ccd'></span>

<h3>Description</h3>

<p>construct the cluster catch digraph from a data matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccd(data, m = 1, alpha = 0.05, sequential = TRUE, method = NULL)
## S3 method for class 'ccd'
plot(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccd_+3A_data">data</code></td>
<td>
<p> a matrix of observations.</p>
</td></tr>
<tr><td><code id="ccd_+3A_m">m</code></td>
<td>
<p> slope of the null hypothesis curve.</p>
</td></tr>
<tr><td><code id="ccd_+3A_alpha">alpha</code></td>
<td>
<p> alpha for the K-S test if <code>sequential=T</code>.</p>
</td></tr>
<tr><td><code id="ccd_+3A_sequential">sequential</code></td>
<td>
<p> use the sequential or non-sequential version.</p>
</td></tr>
<tr><td><code id="ccd_+3A_method">method</code></td>
<td>
<p> the method used for the distance. 
See <code><a href="proxy.html#topic+dist">dist</a></code>.</p>
</td></tr>
<tr><td><code id="ccd_+3A_x">x</code></td>
<td>
<p>an object of class ccd.</p>
</td></tr>
<tr><td><code id="ccd_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>plot.cccd</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>cluster cover digraph. <code>plot.ccd</code> is just a call to <code>plot.cccd</code>.
</p>


<h3>Value</h3>

<p>an object of class igraph. In addition, this contains the attributes:
</p>
<table>
<tr><td><code>R</code></td>
<td>
<p>the radii.</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>
<p> the K-S statistics.</p>
</td></tr>
<tr><td><code>layout</code></td>
<td>
<p>the data vectors.</p>
</td></tr>
<tr><td><code>walks</code></td>
<td>
<p>the y-values of the random walks.</p>
</td></tr>
<tr><td><code>fs</code></td>
<td>
<p>the null hypothesis curve.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p> the adjacency matrix.</p>
</td></tr>
<tr><td><code>m</code>, <code>alpha</code></td>
<td>
<p>arguments passed to <code>ccd</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> David J. Marchette david.marchette@navy.mil</p>


<h3>References</h3>

 
<p>D.J. Marchette, Random Graphs for Statistical Pattern Recognition,
John Wiley &amp; Sons, 2004.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+cccd">cccd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(rnorm(100),ncol=2)
G &lt;- ccd(x)
## Not run: 
plot(G)

## End(Not run)
</code></pre>

<hr>
<h2 id='dominate'> Dominating Sets</h2><span id='topic+dominate'></span>

<h3>Description</h3>

<p>find maximum dominating sets in (di)graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dominate(g, method = "greedy",proportion=1.0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dominate_+3A_g">g</code></td>
<td>
<p> an adjacency matrix.</p>
</td></tr>
<tr><td><code id="dominate_+3A_method">method</code></td>
<td>
<p> one of &quot;greedy&quot;,&quot;random&quot;,&quot;byRadius&quot;, &quot;greedyProportion&quot;.</p>
</td></tr>
<tr><td><code id="dominate_+3A_proportion">proportion</code></td>
<td>
<p> proportion of points to cover.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dominate</code> is the main program which calls the others,
as indicated by <code>method</code>. Greedy is the greedy dominating
algorithm.  In the greedy method ties are broken by first index (a la 
<code>which.max</code>). 
The byRadius method uses the radii to break ties while
the random routine breaks ties randomly.
If <code>proportion</code> is given,
the algorithm stops 
after <code>proportion</code> points are covered.
</p>


<h3>Value</h3>

<p>a vector of vertices corresponding to the dominating set.
</p>


<h3>Author(s)</h3>

<p> David J. Marchette david.marchette@navy.mil</p>


<h3>References</h3>

 
<p>T.W. Haynes, S.T. Hedetniemi and P.J. Slater,
Fundamentals of Domination in Graphs,
Marcel Dekker,
1998,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(runif(100),ncol=2)
y &lt;- matrix(runif(100,-2,2),ncol=2)
G &lt;- cccd(x,y)
D &lt;- dominate(G)
## Not run: 
plot(G,balls=TRUE,D=D)

## End(Not run)

</code></pre>

<hr>
<h2 id='gg'> Gabriel Graph</h2><span id='topic+gg'></span>

<h3>Description</h3>

<p>A Gabriel graph is one where the vertices are points and there
is an edge between two points if the maximal ball between the points
contains no other points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg(x, r = 1, method = NULL, usedeldir = TRUE, open = TRUE, 
   k = NA, algorithm = 'cover_tree')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_+3A_x">x</code></td>
<td>
<p> a matrix of observations.</p>
</td></tr>
<tr><td><code id="gg_+3A_r">r</code></td>
<td>
<p> a multiplier on the ball radius.</p>
</td></tr>
<tr><td><code id="gg_+3A_method">method</code></td>
<td>
<p> the method used for the distance. 
See <code><a href="proxy.html#topic+dist">dist</a></code></p>
</td></tr>
<tr><td><code id="gg_+3A_usedeldir">usedeldir</code></td>
<td>
<p>logical. Whether to use the deldir package or not.</p>
</td></tr>
<tr><td><code id="gg_+3A_open">open</code></td>
<td>
<p>logical. If TRUE, open balls are used in the definition.</p>
</td></tr>
<tr><td><code id="gg_+3A_k">k</code></td>
<td>
<p>If given, <code>get.knn</code> is used from FNN to approximate
the Gabriel graph. Only the <code>k</code> nearest neighbors to
the points are used to determine whether an edge should be made or not.
This will be much faster and use less memory for large data sets, but 
is an approximation unless <code>k</code> is sufficiently large.</p>
</td></tr>
<tr><td><code id="gg_+3A_algorithm">algorithm</code></td>
<td>
<p>See <code><a href="FNN.html#topic+get.knn">get.knn</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>places an edge between two points <code class="reqn">i,j</code> if the ball centered between
the points with radius <code class="reqn">r d(i,j)/2</code> contains no other points.
</p>


<h3>Value</h3>

<p>an object of class igraph. In addition it contains the attributes:
</p>
<table>
<tr><td><code>layout</code></td>
<td>
<p> the data.</p>
</td></tr>
<tr><td><code>r</code>, <code>p</code></td>
<td>
<p>arguments passed to <code>gg</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> David J. Marchette</p>


<h3>References</h3>

 
<p>K.R. Gabriel and R.R. Sokal,
A New Statistical Approach to Geographic Variation Analysis,
Systemic Zoology, 18, 259-278, 1969
</p>
<p>D.J. Marchette, Random Graphs for Statistical Pattern Recognition,
John Wiley &amp; Sons, 2004.
</p>


<h3>See Also</h3>

 <p><code><a href="#topic+rng">rng</a></code>, <code><a href="proxy.html#topic+dist">dist</a></code>, <code><a href="FNN.html#topic+get.knn">get.knn</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(runif(100),ncol=2)

g &lt;- gg(x)
## Not run: 
plot(g)

## End(Not run)

</code></pre>

<hr>
<h2 id='juggling'>
Juggling
</h2><span id='topic+juggle'></span><span id='topic+juggle.classify'></span>

<h3>Description</h3>

<p>a resampled version of the CCCD classifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>juggle(data, classes, sampled = TRUE, sample.dim = FALSE, 
       num = 100, sample.proportion = 0.1, k = 2, method = NULL)
juggle.classify(data,J,tdata,indices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="juggling_+3A_data">data</code>, <code id="juggling_+3A_tdata">tdata</code></td>
<td>

<p>training data from which to build the classifier. In the case
of <code>juggle.classify</code>, <code>tdata</code> is the training data and
<code>data</code> is the test data.
</p>
</td></tr>
<tr><td><code id="juggling_+3A_classes">classes</code></td>
<td>

<p>class labels.
</p>
</td></tr>
<tr><td><code id="juggling_+3A_sampled">sampled</code></td>
<td>

<p>whether the data are subsampled.
</p>
</td></tr>
<tr><td><code id="juggling_+3A_sample.dim">sample.dim</code></td>
<td>

<p>if TRUE, the dimensions (variates) are also sampled.
</p>
</td></tr>
<tr><td><code id="juggling_+3A_num">num</code></td>
<td>

<p>number of juggles (resamples).
</p>
</td></tr>
<tr><td><code id="juggling_+3A_sample.proportion">sample.proportion</code></td>
<td>

<p>proportion of the data to sample. If 1 or greater, the data are sampled
with replacement.
</p>
</td></tr>
<tr><td><code id="juggling_+3A_k">k</code></td>
<td>

<p>number of variates to sample when <code>sample.dim</code> is TRUE.
</p>
</td></tr>
<tr><td><code id="juggling_+3A_j">J</code></td>
<td>

<p>the juggled classifier.
</p>
</td></tr>
<tr><td><code id="juggling_+3A_indices">indices</code></td>
<td>

<p>the indices of the juggles to use.
</p>
</td></tr>
<tr><td><code id="juggling_+3A_method">method</code></td>
<td>
<p> the method used for the distance. 
See <code><a href="proxy.html#topic+dist">dist</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea of juggling is to sample the data, compute a CCCD classifier,
then repeat. The resampling is controled by the two sampling variables,
which basically determine whether the data are sampled with replacement,
or whether a subsample is used. If <code>sample.dim</code> is TRUE, the 
variates are also sampled, with <code>k</code> indicating how many are sampled.
</p>


<h3>Value</h3>

<p><code>juggle.classify</code> returns a matrix holding the classification 
probabilities for each observation in <code>data</code>.
a list consisting of:
</p>
<table>
<tr><td><code>S</code></td>
<td>
<p>the dominating sets.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p>the radii.</p>
</td></tr>
<tr><td><code>dimension</code></td>
<td>
<p>the dimension of the data.</p>
</td></tr>
<tr><td><code>vars</code></td>
<td>
<p>in the case of <code>sample.dim</code>=TRUE, the variables sampled
each time.</p>
</td></tr>
</table>
<p>Only the indicies into the training data are stored in <code>J</code>, which
is why the classifier requires the original training data in <code>tdata</code>.
</p>


<h3>Author(s)</h3>

<p>David J. Marchette, david.marchette@navy.mil
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cccd">cccd</a></code>, <code><a href="proxy.html#topic+dist">dist</a></code>
</p>

<hr>
<h2 id='nng'> Nearest Neighbor Graphs</h2><span id='topic+nng'></span>

<h3>Description</h3>

<p>nearest neighbor, k-nearest neighbor, and mutual k-nearest neighbor 
(di)graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nng(x = NULL, dx = NULL, k = 1, mutual = FALSE, method = NULL, 
    use.fnn = FALSE, algorithm = 'cover_tree')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nng_+3A_x">x</code></td>
<td>
<p> a data matrix. Either x or dx is required</p>
</td></tr>
<tr><td><code id="nng_+3A_dx">dx</code></td>
<td>
<p> interpoint distance matrix</p>
</td></tr>
<tr><td><code id="nng_+3A_k">k</code></td>
<td>
<p> number of neighbors</p>
</td></tr>
<tr><td><code id="nng_+3A_mutual">mutual</code></td>
<td>
<p> logical. if true the neighbors must be mutual. See details.</p>
</td></tr>
<tr><td><code id="nng_+3A_method">method</code></td>
<td>
<p> the method used for the distance. 
See <code><a href="proxy.html#topic+dist">dist</a></code></p>
</td></tr>
<tr><td><code id="nng_+3A_use.fnn">use.fnn</code></td>
<td>
<p>logical. If TRUE, <code>get.knn</code> from the FNN package
is used to obtain the neighbors.</p>
</td></tr>
<tr><td><code id="nng_+3A_algorithm">algorithm</code></td>
<td>
<p>see <code><a href="FNN.html#topic+get.knn">get.knn</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a k-nearest neighbor graph is a digraph where each vertex is
associated with an observation and there is a directed edge between
the vertex and it's k nearest neighbors. A mutual k-nearest neighbor
graph is a graph where there is an edge between x and y if x is
one of the k nearest neighbors of y AND y is one of the k nearest
neighbors of x.
</p>


<h3>Value</h3>

<p>an object of class igraph with the extra attributes
</p>
<table>
<tr><td><code>layout</code></td>
<td>
<p> the x vectors.</p>
</td></tr>
<tr><td><code>k</code>, <code>mutual</code>, <code>p</code></td>
<td>
<p>arguments given to <code>nn</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> David J. Marchette david.marchette@navy.mil</p>


<h3>References</h3>

 
<p>D.J. Marchette, Random Graphs for Statistical Pattern Recognition,
John Wiley &amp; Sons, 2004.
</p>


<h3>See Also</h3>

<p><code><a href="proxy.html#topic+dist">dist</a></code>
<code><a href="FNN.html#topic+get.knn">get.knn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(runif(100),ncol=2)

G1 &lt;- nng(x,k=1)
## Not run: 
par(mfrow=c(2,2))
plot(G1)

## End(Not run)

G2 &lt;- nng(x,k=2)
## Not run: 
plot(G2)

## End(Not run)

G5 &lt;- nng(x,k=5)
## Not run: 
plot(G5)

## End(Not run)

G5m &lt;- nng(x,k=5,mutual=TRUE)
## Not run: 
plot(G5m)
par(mfrow=c(1,1))

## End(Not run)

</code></pre>

<hr>
<h2 id='prune'> Prune Points</h2><span id='topic+prune'></span>

<h3>Description</h3>

<p>a nearest neighbor pruning using neighborhood graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune(x, classes, prox = "Gabriel", ignore.ties = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_+3A_x">x</code></td>
<td>
<p> a data matrix.</p>
</td></tr>
<tr><td><code id="prune_+3A_classes">classes</code></td>
<td>
<p> a vector of class labels.</p>
</td></tr>
<tr><td><code id="prune_+3A_prox">prox</code></td>
<td>
<p> type of proximity graph.</p>
</td></tr>
<tr><td><code id="prune_+3A_ignore.ties">ignore.ties</code></td>
<td>
<p> do not prune if there is a tie vote.</p>
</td></tr>
<tr><td><code id="prune_+3A_...">...</code></td>
<td>
<p> arguments passed to the proximity graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First a proximity graph is computed on the data. Then points
are marked if their neighbors have a different class than they
do: if the most common class among the neighbors is different
than the point. Then all marked points are removed.
</p>


<h3>Value</h3>

<p>A list with attributes:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>the pruned data.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>the indices of the retained data.</p>
</td></tr>
<tr><td><code>g</code></td>
<td>
<p>the proximity graph.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> David J. Marchette, david.marchette@navy.mil</p>


<h3>References</h3>

 <p><a href="http://www.bic.mni.mcgill.ca/users/crisco/pgedit/">http://www.bic.mni.mcgill.ca/users/crisco/pgedit/</a></p>

<hr>
<h2 id='rng'> Relative Neighborhood Graph.</h2><span id='topic+rng'></span>

<h3>Description</h3>

<p>the relative neighborhood graph defined by a set of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rng(x=NULL, dx=NULL, r = 1, method = NULL, usedeldir = TRUE, open = TRUE, k = NA,
    algorithm = 'cover_tree')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rng_+3A_x">x</code></td>
<td>
<p> a data matrix. Either <code>x</code> or <code>dx</code> must be provided.</p>
</td></tr>
<tr><td><code id="rng_+3A_dx">dx</code></td>
<td>
<p> an interpoint distance matrix.</p>
</td></tr>
<tr><td><code id="rng_+3A_r">r</code></td>
<td>
<p> a multiplier to grow the balls.</p>
</td></tr>
<tr><td><code id="rng_+3A_method">method</code></td>
<td>
<p> the method used for the distance. 
See <code><a href="proxy.html#topic+dist">dist</a></code></p>
</td></tr>
<tr><td><code id="rng_+3A_usedeldir">usedeldir</code></td>
<td>
<p>a logical. If true and the data are two dimensional
and the deldir package is installed, the Delaunay triangularization
is first computed, and this is used to compute the relative
neighborhood graph.</p>
</td></tr>
<tr><td><code id="rng_+3A_open">open</code></td>
<td>
<p>logical. If TRUE, open balls are used in the definition.</p>
</td></tr>
<tr><td><code id="rng_+3A_k">k</code></td>
<td>
<p>If given, <code>get.knn</code> is used from FNN to approximate
the relative neighborhood graph. Only the <code>k</code> nearest neighbors to
the points are used to determine whether an edge should be made or not.
This will be much faster and use less memory for large data sets, but 
is an approximation unless <code>k</code> is sufficiently large.</p>
</td></tr>
<tr><td><code id="rng_+3A_algorithm">algorithm</code></td>
<td>
<p>See <code><a href="FNN.html#topic+get.knn">get.knn</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the relative neighborhood graph is defined in terms of balls
centered at observations. For two observations, the balls are
set to have radius equal to the distance between the observations
(or <code>r</code> times this distance if <code>r</code> is not 1). There is
an edge between the vertices associated with the observations if 
and only if there are no vertices in the lune defined by the
intersection of the balls.
</p>
<p>The flag <code>open</code> should make no difference for most applications,
but there are very specific cases (see the example section below)
where setting it to be TRUE will give the wrong answer (thanks to
Luke Mathieson for pointing this out to me).
</p>


<h3>Value</h3>

<p>an object of class igraph, with the additional attributes
</p>
<table>
<tr><td><code>layout</code></td>
<td>
<p>the x matrix.</p>
</td></tr>
<tr><td><code>r</code>, <code>p</code></td>
<td>
<p>arguments given to <code>rng</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> David J. Marchette david.marchette@navy.mil</p>


<h3>References</h3>

 
<p>J.W. Jaromczyk and G.T. Toussaint,
&quot;Relative neighborhood graphs and their relatives&quot;,
Proceedings of the IEEE, 
80, 1502-1517, 1992.
</p>
<p>G.T. Toussaint,
&quot;A Graph-Theoretic Primal Sketch&quot;,
Computational Morphology, 229-260, 1988.
</p>
<p>D.J. Marchette, Random Graphs for Statistical Pattern Recognition,
John Wiley &amp; Sons, 2004.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gg">gg</a></code>,<code><a href="#topic+cccd">cccd</a></code>,<code><a href="#topic+ccd">ccd</a></code>,
<code><a href="proxy.html#topic+dist">dist</a></code>
<code><a href="FNN.html#topic+get.knn">get.knn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- matrix(runif(100),ncol=2)

g &lt;- rng(x)
## Not run: 
plot(g)

## End(Not run)

## Example using 'open':
g &lt;- graph.full(5,directed=FALSE)

g1 &lt;- rng(x=get.adjacency(g,sparse=FALSE),open=TRUE)
ecount(g1)
g2 &lt;- rng(x=get.adjacency(g,sparse=FALSE),open=FALSE)
graph.isomorphic(g2,g)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
