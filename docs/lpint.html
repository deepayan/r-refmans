<!DOCTYPE html><html><head><title>Help for package lpint</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lpint}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lpint-package'>
<p>Local Polynomail Estimators of the Intensity Function of a Counting</p>
Process and Its Derivatives</a></li>
<li><a href='#lpint'>
<p>Martingale estimating equation local polynomial estimator of counting</p>
process intensity function and its derivatives</a></li>
<li><a href='#lplikint'>
<p>Partial likelihood based local polynomial estimators of the counting</p>
process intensity function and its derivatives</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Local Polynomial Estimators of the Intensity Function and Its
Derivatives</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-04-12</td>
</tr>
<tr>
<td>Author:</td>
<td>Feng Chen &lt;feng.chen@unsw.edu.au&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Feng Chen &lt;feng.chen@unsw.edu.au&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to estimate the intensity function and its derivative of a given order of a multiplicative counting process using the local polynomial method.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-12 03:32:24 UTC; z3243864</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-12 03:52:27 UTC</td>
</tr>
</table>
<hr>
<h2 id='lpint-package'>
Local Polynomail Estimators of the Intensity Function of a Counting
Process and Its Derivatives
</h2><span id='topic+lpint-package'></span>

<h3>Description</h3>

<p>Estimates the intensity function or its derivative of a give a given
order using the local polynomial method with automatic bandwidth
selection using a rule of thumb plug-in approach.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> lpint</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2012-09-21</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;=2.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au&gt;
Maintainer: Feng Chen &lt;feng.chen@unsw.edu.au&gt;
</p>


<h3>References</h3>

<p>Chen, F. (2011) Maximum local partial likelihood estimators for the
counting process intensity function and its derivatives. Statistica
Sinica 21(1): 107
-128. http://www3.stat.sinica.edu.tw/statistica/j21n1/J21N14/J21N14.html 
</p>
<p>Chen, F., Yip, P.S.F., &amp; Lam, K.F. (2011) On the Local Polynomial
Estimators of the Counting Process Intensity Function and its
Derivatives. Scandinavian Journal of Statistics 38(4): 631 -
649. http://dx.doi.org/10.1111/j.1467-9469.2011.00733.x
</p>
<p>Chen, F., Higgins, R.M., Yip, P.S.F. &amp; Lam, K.F. (2008) Nonparametric
estimation of multiplicative counting process intensity functions with
an application to the Beijing SARS epidemic, Communications in
Statistics - Theory and Methods 37: 294 -
306. http://www.tandfonline.com/doi/abs/10.1080/03610920701649035  
</p>
<p>Chen, F., Higgins, R.M., Yip, P.S.F. &amp; Lam, K.F. (2008) Local polynomial
estimation of Poisson intensities in the presence of reporting
delays, Journal of the Royal Statistical Society Series C (Applied
Statistics) 57(4): 447 -
459. http://onlinelibrary.wiley.com/doi/10.1111/j.1467-9876.2008.00624.x/full 
</p>

<hr>
<h2 id='lpint'>
Martingale estimating equation local polynomial estimator of counting
process intensity function and its derivatives 
</h2><span id='topic+lpint'></span>

<h3>Description</h3>

<p>This local polynomial estimator is based on a biased martingale
estimating equation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpint(jmptimes, jmpsizes = rep(1, length(jmptimes)),
      Y = rep(1,length(jmptimes)), bw = NULL,
      adjust = 1, Tau = max(1, jmptimes), p = nu + 1,
      nu = 0, K = function(x) 3/4 * (1 - x^2) * (x &lt;= 1 &amp; x &gt;= -1),
      n = 101, bw.only=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpint_+3A_jmptimes">jmptimes</code></td>
<td>
<p>a numeric vector giving the jump times of the counting process

</p>
</td></tr>
<tr><td><code id="lpint_+3A_jmpsizes">jmpsizes</code></td>
<td>
<p>a numeric vector giving the jump sizes at each jump
time. Need to be of the same length as jmptimes

</p>
</td></tr>
<tr><td><code id="lpint_+3A_y">Y</code></td>
<td>
<p>a numeric vector giving the value of the exposure process
(or size of the risk set) at each jump times. Need to be of the same
length as jmptimes

</p>
</td></tr>
<tr><td><code id="lpint_+3A_bw">bw</code></td>
<td>
<p>a numeric constant specifying the bandwidth used in the
estimator. If left unspecified the automatic bandwidth selector will
be used to calculate one. 

</p>
</td></tr>
<tr><td><code id="lpint_+3A_adjust">adjust</code></td>
<td>
<p>a positive constant giving the adjust factor to be
multiplied to the default bandwith parameter or the supplied
bandwith

</p>
</td></tr>
<tr><td><code id="lpint_+3A_tau">Tau</code></td>
<td>
<p>a numric constant &gt;0 giving the censoring time (when
observation of the counting process is terminated)

</p>
</td></tr>
<tr><td><code id="lpint_+3A_p">p</code></td>
<td>
<p>the degree of the local polynomial used in constructing the
estimator. Default to 1 plus the degree of the derivative to be
estimated

</p>
</td></tr>
<tr><td><code id="lpint_+3A_nu">nu</code></td>
<td>
<p>the degree of the derivative of the intensity function to be
estimated. Default to 0 for estimation of the intensity itself.

</p>
</td></tr>
<tr><td><code id="lpint_+3A_k">K</code></td>
<td>
<p>the kernel function 

</p>
</td></tr>
<tr><td><code id="lpint_+3A_n">n</code></td>
<td>
<p>the number of evenly spaced time points to evaluate the
estimator at

</p>
</td></tr>
<tr><td><code id="lpint_+3A_bw.only">bw.only</code></td>
<td>
<p>TRUE or FALSE according as if the rule of thumb
bandwidth is the only required output or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a list containing
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>the vector of times at which the estimator is evaluated</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the vector giving the values of the estimator at times given
in <code>x</code></p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>the vector giving the standard errors of the estimates given
in <code>y</code></p>
</td></tr> 
<tr><td><code>bw</code></td>
<td>
<p>the bandwidth actually used in defining the estimator equal
the automatically calculated or supplied multiplied by
<code>adjust</code></p>
</td></tr>
</table>
<p>or a numeric constant equal to the rule of thumb bandwidth estimate
</p>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au.&gt;
</p>


<h3>References</h3>

<p>Chen, F., Yip, P.S.F., &amp; Lam, K.F. (2011) On the Local Polynomial
Estimators of the Counting Process Intensity Function and its
Derivatives. Scandinavian Journal of Statistics 38(4): 631 -
649. http://dx.doi.org/10.1111/j.1467-9469.2011.00733.x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lplikint">lplikint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate a Poisson process on [0,1] with given intensity
int &lt;- function(x)100*(1+0.5*cos(2*pi*x))
censor &lt;- 1
set.seed(2)
N &lt;- rpois(1,150*censor);
jtms &lt;- runif(N,0,censor);
jtms &lt;- jtms[as.logical(mapply(rbinom,n=1,size=1,prob=int(jtms)/150))];

##estimate the intensity
intest &lt;- lpint(jtms,Tau=censor)
##plot and compare
plot(intest,xlab="time",ylab="intensity",type="l",lty=1)
curve(int,add=TRUE,lty=2)

## Example estimating the hazard function from right censored data:
## First simulate the (not directly observable) life times and censoring
## times:
lt &lt;- rweibull(500,2.5,3); ct &lt;- rlnorm(500,1,0.5)
## Now the censored times and censorship indicators delta (the
## observables): 
ot &lt;- pmin(lt,ct); dlt &lt;- as.numeric(lt &lt;= ct);
## Estimate the hazard rate based on the censored observations:
jtms &lt;- sort(ot[dlt==1]);
Y &lt;- sapply(jtms,function(x)sum(ot&gt;=x));
haz.est &lt;- lpint(jtms,Y=Y);
## plot the estimated hazard function:
matplot(haz.est$x,
        pmax(haz.est$y+outer(haz.est$se,c(-1,0,1)*qnorm(0.975)),0),
        type="l",lty=c(2,1,2),
        xlab="t",ylab="h(t)",
        col=1);
## add the truth:
haz &lt;- function(x)dweibull(x,2.5,3)/pweibull(x,2.5,3,lower.tail=FALSE)
curve(haz, add=TRUE,col=2)
</code></pre>

<hr>
<h2 id='lplikint'>
Partial likelihood based local polynomial estimators of the counting
process intensity function and its derivatives 
</h2><span id='topic+lplikint'></span>

<h3>Description</h3>

<p>This local polynomial estimator is based on the (localized) partial
likelihood 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lplikint(jmptimes, jmpsizes = rep(1, length(jmptimes)),
         Y = rep(1,length(jmptimes)),
         K = function(x) 3/4 * (1 - x^2) * (x &lt;= 1 &amp; x &gt;= -1),
         bw, adjust = 1, nu = 0, p = 1, Tau = 1, n = 101,
         tseq = seq(from = 0, to = Tau, length = n), tol = 1e-05,
         maxit = 100, us = 10, gd = 5) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lplikint_+3A_jmptimes">jmptimes</code></td>
<td>
<p>a numeric vector giving the jump times of the counting process

</p>
</td></tr>
<tr><td><code id="lplikint_+3A_jmpsizes">jmpsizes</code></td>
<td>
<p>a numeric vector giving the jump sizes at each jump
time. Need to be of the same length as jmptimes

</p>
</td></tr>
<tr><td><code id="lplikint_+3A_y">Y</code></td>
<td>
<p>a numeric vector giving the value of the exposure process
(or size of the risk set) at each jump times. Need to be of the same
length as jmptimes

</p>
</td></tr>
<tr><td><code id="lplikint_+3A_k">K</code></td>
<td>
<p>the kernel function 

</p>
</td></tr>
<tr><td><code id="lplikint_+3A_bw">bw</code></td>
<td>
<p>a numeric constant specifying the bandwidth used in the
estimator. If left unspecified the automatic bandwidth selector will
be used to calculate one. 

</p>
</td></tr>
<tr><td><code id="lplikint_+3A_adjust">adjust</code></td>
<td>
<p>a positive constant giving the adjust factor to be
multiplied to the default bandwith parameter or the supplied
bandwith

</p>
</td></tr>
<tr><td><code id="lplikint_+3A_nu">nu</code></td>
<td>
<p>the degree of the derivative of the intensity function to be
estimated. Default to 0 for estimation of the intensity itself.

</p>
</td></tr>
<tr><td><code id="lplikint_+3A_p">p</code></td>
<td>
<p>the degree of the local polynomial used in constructing the
estimator. Default to 1 plus the degree of the derivative to be
estimated

</p>
</td></tr>
<tr><td><code id="lplikint_+3A_tau">Tau</code></td>
<td>
<p>a numric constant &gt;0 giving the censoring time (when
observation of the counting process is terminated)

</p>
</td></tr>
<tr><td><code id="lplikint_+3A_n">n</code></td>
<td>
<p>the number of evenly spaced time points to evaluate the
estimator at. Not used when <code>tseq</code> is provided.

</p>
</td></tr>
<tr><td><code id="lplikint_+3A_tseq">tseq</code></td>
<td>
<p>the time sequence at which to evaluate the estimator

</p>
</td></tr>
<tr><td><code id="lplikint_+3A_tol">tol</code></td>
<td>
<p>the parameter error tolerance used to stop the iterations
in optimizing the local likelihood

</p>
</td></tr>
<tr><td><code id="lplikint_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations allowed in the optimization
used in a single estimation point

</p>
</td></tr>
<tr><td><code id="lplikint_+3A_us">us</code></td>
<td>
<p>a numeric constants used together with
<code>gd</code> to grid search for a decent start value in solving the
local score equation. The starting value is 0 except on its first
dimension, which was chosen so that the starting value is the
minimizer of the L^1 norm of the score function among the values:
average intensity X <code>us^(-gd:gd)</code> 

</p>
</td></tr>
<tr><td><code id="lplikint_+3A_gd">gd</code></td>
<td>
<p>a numeric constant used together with <code>us</code> to search
for a decent start value in solving the local score equation

</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimator is based on solving the local score equation using the
Newton-Raphson method and extract the appropriate dimension.

</p>


<h3>Value</h3>

<p>a list containing
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>the vector of times at which the estimator is evaluated</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the vector giving the values of the estimator at times given
in <code>x</code></p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>the vector giving the standard errors of the estimates given
in <code>y</code></p>
</td></tr> 
<tr><td><code>bw</code></td>
<td>
<p>the bandwidth actually used in defining the estimator equal
the automatically calculated or supplied multiplied by <code>adjust</code></p>
</td></tr>
<tr><td><code>fun</code></td>
<td>
<p>the intensity (or derivative) estimator as a function of
the estimation point, which can be called to evaluate the estimator
at points not included in <code>tseq</code>





</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Feng Chen &lt;feng.chen@unsw.edu.au.&gt;
</p>


<h3>References</h3>

<p>Chen, F. (2011) Maximum local partial likelihood estimators for the
counting process intensity function and its derivatives. Statistica
Sinica 21(1): 107
-128. http://www3.stat.sinica.edu.tw/statistica/j21n1/J21N14/J21N14.html 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpint">lpint</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##simulate a Poisson process on [0,1] with given intensity
int &lt;- function(x)100*(1+0.5*cos(2*pi*x))
censor &lt;- 1
set.seed(2)
N &lt;- rpois(1,150*censor);
jtms &lt;- runif(N,0,censor);
jtms &lt;- jtms[as.logical(mapply(rbinom,n=1,size=1,prob=int(jtms)/150))];

##estimate the intensity
intest &lt;- lplikint(jtms,bw=0.15,Tau=censor)
#plot and compare
plot(intest,xlab="time",ylab="intensity",type="l",lty=1)
curve(int,add=TRUE,lty=2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
