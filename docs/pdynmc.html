<!DOCTYPE html><html><head><title>Help for package pdynmc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pdynmc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ABdata'><p>Employment, wages, capital, and output for companies based in the UK</p></a></li>
<li><a href='#case.names.pdynmc'><p>Case and Variable Names of Fitted Model.</p></a></li>
<li><a href='#cigDemand'><p>Cigarette consumption in the US</p></a></li>
<li><a href='#coef.pdynmc'><p>Extract Coefficient Estimates of Fitted Model.</p></a></li>
<li><a href='#data.info'><p>Show Basic Structure of Panel Dataset.</p></a></li>
<li><a href='#dummy.coef.pdynmc'><p>Extract Coefficient Estimates of Time Dummies of Fitted Model.</p></a></li>
<li><a href='#FDLS'><p>First Difference Least Squares (FDLS) Estimator of Han and Phillips (2010).</p></a></li>
<li><a href='#fitted.pdynmc'><p>Extract Fitted Values of Fitted Model.</p></a></li>
<li><a href='#jtest.fct'><p>Hansen J-Test.</p></a></li>
<li><a href='#model.matrix.pdynmc'><p>Extract Instrument Matrix of Fitted Model.</p></a></li>
<li><a href='#mtest.fct'><p>Arellano and Bond Serial Correlation Test.</p></a></li>
<li><a href='#ninst'><p>Extract Instrument Count of Fitted Model.</p></a></li>
<li><a href='#ninst.pdynmc'><p>Extract Instrument Count of Fitted Model.</p></a></li>
<li><a href='#NLIV'><p>Nonlinear Instrumental Variables Estimator - T-Version (NLIV).</p></a></li>
<li><a href='#NLIV.alt'><p>Nonlinear Instrumental Variables Estimator - t-Version (NLIV.alt).</p></a></li>
<li><a href='#nobs.pdynmc'><p>Extract Number of Observations of Fitted Model.</p></a></li>
<li><a href='#optimIn'><p>Extract Input Parameters of Numeric Optimization of Fitted Model.</p></a></li>
<li><a href='#optimIn.pdynmc'><p>Extract Input Parameters of Numeric Optimization of Fitted Model.</p></a></li>
<li><a href='#package-pdynmc'><p>pdynmc: A package for moment conditions based estimation of linear dynamic</p>
panel data models</a></li>
<li><a href='#pDensTime.plot'><p>Plot Empirical Density of a Column of a Panel Dataset over Time.</p></a></li>
<li><a href='#pdynmc'><p>Generalized Method of Moments (GMM) Estimation of Linear Dynamic Panel Data</p>
Models.</a></li>
<li><a href='#plot.pdynmc'><p>Plot Coefficient Estimates and Corresponding Ranges of Fitted Model.</p></a></li>
<li><a href='#print.pdynmc'><p>Print Fitted Model Object.</p></a></li>
<li><a href='#print.summary.pdynmc'><p>Print Summary of Fitted Model Object.</p></a></li>
<li><a href='#residuals.pdynmc'><p>Extract Residuals of Fitted Model.</p></a></li>
<li><a href='#strucUPD.plot'><p>Plot on Structure of Unbalanced Panel Dataset.</p></a></li>
<li><a href='#summary.pdynmc'><p>Summary for Fitted Model Object.</p></a></li>
<li><a href='#variable.names.pdynmc'><p>Extract Names of Explanatory Variables of Fitted Model.</p></a></li>
<li><a href='#vcov.pdynmc'><p>Extract Variance Covariance Matrix of Fitted Model.</p></a></li>
<li><a href='#wald.fct'><p>Wald Test.</p></a></li>
<li><a href='#wmat'><p>Extract Weighting Matrix of Fitted Model.</p></a></li>
<li><a href='#wmat.pdynmc'><p>Extract Weighting Matrix of Fitted Model.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Moment Condition Based Estimation of Linear Dynamic Panel Data
Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.11</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-12</td>
</tr>
<tr>
<td>Author:</td>
<td>Markus Fritsch [aut, cre],
  Joachim Schnurbus [aut],
  Andrew Adrian Yu Pua [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Markus Fritsch &lt;Markus.Fritsch@uni-Passau.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.12.2), MASS (&ge; 7.3-51.4), Matrix (&ge;
1.2-17), methods(&ge; 3.6.2), optimx (&ge; 2018-07.10), stats (&ge;
3.6.0), Rdpack (&ge; 0.11-0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pder (&ge; 1.0-1), testthat (&ge; 2.3.2), R.rsp (&ge; 0.43.2)</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Description:</td>
<td>Linear dynamic panel data modeling based on linear and
    nonlinear moment conditions as proposed by
    Holtz-Eakin, Newey, and Rosen (1988) &lt;<a href="https://doi.org/10.2307%2F1913103">doi:10.2307/1913103</a>&gt;,
    Ahn and Schmidt (1995) &lt;<a href="https://doi.org/10.1016%2F0304-4076%2894%2901641-C">doi:10.1016/0304-4076(94)01641-C</a>&gt;,
    and Arellano and Bover (1995) &lt;<a href="https://doi.org/10.1016%2F0304-4076%2894%2901642-D">doi:10.1016/0304-4076(94)01642-D</a>&gt;.
    Estimation of the model parameters relies on the Generalized
    Method of Moments (GMM) and instrumental variables (IV) estimation,
    numerical optimization (when nonlinear moment conditions are
    employed) and the computation of closed form solutions (when
    estimation is based on linear moment conditions). One-step,
    two-step and iterated estimation is available. For inference
    and specification
    testing, Windmeijer (2005) &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2004.02.005">doi:10.1016/j.jeconom.2004.02.005</a>&gt;
    and doubly corrected standard errors
    (Hwang, Kang, Lee, 2021 &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2020.09.010">doi:10.1016/j.jeconom.2020.09.010</a>&gt;)
    are available. Additionally, serial correlation tests, tests for
    overidentification, and Wald tests are provided. Functions for
    visualizing panel data structures and modeling results obtained
    from GMM estimation are also available. The plot methods include
    functions to plot unbalanced panel structure, coefficient ranges
    and coefficient paths across GMM iterations (the latter is
    implemented according to the plot shown in
    Hansen and Lee, 2021 &lt;<a href="https://doi.org/10.3982%2FECTA16274">doi:10.3982/ECTA16274</a>&gt;).
    For a more detailed description of the GMM-based functionality,
    please see Fritsch, Pua, Schnurbus (2021) &lt;<a href="https://doi.org/10.32614%2FRJ-2021-035">doi:10.32614/RJ-2021-035</a>&gt;.
    For more detail on the IV-based estimation routines,
    see Fritsch, Pua, and Schnurbus (WP, 2024) and
    Han and Phillips (2010) &lt;<a href="https://doi.org/10.1017%2FS026646660909063X">doi:10.1017/S026646660909063X</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/markusfritsch/pdynmc">https://github.com/markusfritsch/pdynmc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/markusfritsch/pdynmc/issues">https://github.com/markusfritsch/pdynmc/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Classification/JEL:</td>
<td>C23, C26, C87</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-12 14:51:16 UTC; Markus</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-12 15:30:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='ABdata'>Employment, wages, capital, and output for companies based in the UK</h2><span id='topic+ABdata'></span>

<h3>Description</h3>

<p>Unbalanced panel dataset of 140 firms from different sectors
located in the UK which were observed over the years 1976
until 1984. The dataset contains the variables firm, year,
sector, employment, wages, capital, and output and was used
in Arellano and Bond (1991) which also
provides more details on the different variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ABdata)
</code></pre>


<h3>Format</h3>

<p>A dataset with 1031 rows and 7 variables containing:
</p>

<dl>
<dt>firm</dt><dd><p>firm identifier</p>
</dd>
<dt>year</dt><dd><p>year</p>
</dd>
<dt>sector</dt><dd><p>sector</p>
</dd>
<dt>emp</dt><dd><p>number of firm employees in the UK</p>
</dd>
<dt>wage</dt><dd><p>real wage</p>
</dd>
<dt>capital</dt><dd><p>gross capital stock</p>
</dd>
<dt>output</dt><dd><p>industry output</p>
</dd>
</dl>



<h3>References</h3>

<p>Arellano M, Bond S (1991).
&ldquo;Some Tests of Specification for Panel Data: Monte Carlo Evidence and an Application to Employment Equations.&rdquo;
<em>The Review of Economic Studies</em>, <b>58</b>(2), 277&ndash;297.
<a href="https://doi.org/10.2307/2297968">doi:10.2307/2297968</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  data(ABdata, package = "pdynmc")
  n &lt;- ABdata$emp
  w &lt;- ABdata$wage
  \donttest{plot(y = n, x = w)}

## End(Not run)

</code></pre>

<hr>
<h2 id='case.names.pdynmc'>Case and Variable Names of Fitted Model.</h2><span id='topic+case.names.pdynmc'></span>

<h3>Description</h3>

<p><code>case.names</code> extracts variable names of cross-sectional and
longitudinal identifiers of an object of class 'pdynmc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdynmc'
case.names(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="case.names.pdynmc_+3A_object">object</code></td>
<td>
<p>An object of class 'pdynmc'.</p>
</td></tr>
<tr><td><code id="case.names.pdynmc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing tow character vectors with the variable
names of the cross-sectional and the longitudinal identifiers
from object of class 'pdynmc'.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
case.names(m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

## Further code example
 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 case.names(m1)



</code></pre>

<hr>
<h2 id='cigDemand'>Cigarette consumption in the US</h2><span id='topic+cigDemand'></span>

<h3>Description</h3>

<p>Balanced panel dataset on annual cigarette consumption in the
US for the 48 continental states in the years 1985 until 1995.
The dataset is available from Stock and Watson (2003)
and used in Stock and Watson (2019) and
Fritsch et al. (2024).
Gratitude is owed to Jonathan Gruber of MIT for
providing the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cigDemand)
</code></pre>


<h3>Format</h3>

<p>A dataset with 528 rows and 9 variables containing:
</p>

<dl>
<dt>state</dt><dd><p>state</p>
</dd>
<dt>year</dt><dd><p>year</p>
</dd>
<dt>cpi</dt><dd><p>consumer price index (US)</p>
</dd>
<dt>pop</dt><dd><p>state population</p>
</dd>
<dt>packpc</dt><dd><p>number of cigarette packs sold per capita and year</p>
</dd>
<dt>income</dt><dd><p>state personal income (total, nominal)</p>
</dd>
<dt>tax</dt><dd><p>average federal, state, and local excise taxes on cigarettes for fiscal year in cents per pack</p>
</dd>
<dt>avgprs</dt><dd><p>average price during fiscal year in cents per pack (including sales taxes)</p>
</dd>
<dt>taxs</dt><dd><p>average excise tax for fiscal year in cents per pack (including sales taxes)</p>
</dd>
</dl>



<h3>References</h3>

<p>Fritsch M, Pua AAY, Schnurbus J (2024).
&ldquo;Teaching Advanced Topics in Econometrics using Introductory Textbooks: The Case of Dynamic Panel Data Methods.&rdquo;
Working Paper.<br /><br /> Stock JH, Watson MM (2019).
<em>Introduction to Econometrics</em>, Fourth edition.
Pearson.<br /><br /> Stock JH, Watson MW (2003).
&ldquo;cig_ ch10, cig85_95, Instructional Stata datasets for econometrics cig8595.&rdquo;
<a href="https://ideas.repec.org/p/boc/bocins/cig8595.html">https://ideas.repec.org/p/boc/bocins/cig8595.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  data(cigDemand, package = "pdynmc")
  packs &lt;- cigDemand$packpc
  tax &lt;- cigDemand$tax
  \donttest{plot(y = packs, x = tax)}

## End(Not run)

</code></pre>

<hr>
<h2 id='coef.pdynmc'>Extract Coefficient Estimates of Fitted Model.</h2><span id='topic+coef.pdynmc'></span>

<h3>Description</h3>

<p><code>coef.pdynmc</code> extracts coefficient estimates of an object
of class 'pdynmc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdynmc'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.pdynmc_+3A_object">object</code></td>
<td>
<p>An object of class 'pdynmc'.</p>
</td></tr>
<tr><td><code id="coef.pdynmc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extract coefficient estimates from object of class
'pdynmc'.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
coef(m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

## Further code example
 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 coef(m1)



</code></pre>

<hr>
<h2 id='data.info'>Show Basic Structure of Panel Dataset.</h2><span id='topic+data.info'></span>

<h3>Description</h3>

<p><code>data.info</code> shows basic structure of a balanced/unbalanced
panel dataset contained in a 'data.frame'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.info(object, i.name = NULL, t.name = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data.info_+3A_object">object</code></td>
<td>
<p>An object of class 'data.frame'.</p>
</td></tr>
<tr><td><code id="data.info_+3A_i.name">i.name</code></td>
<td>
<p>Column name of cross-section identifier.</p>
</td></tr>
<tr><td><code id="data.info_+3A_t.name">t.name</code></td>
<td>
<p>Column name of time-series identifier.</p>
</td></tr>
<tr><td><code id="data.info_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns information if panel dataset contained
in an object of class 'data.frame' is a balanced or
unbalanced panel dataset.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch, Joachim Schnurbus
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
data.info(dat, i.name = "firm", t.name = "year")

data.info(dat[dat$year %in% 1979:1981, ], i.name = "firm", t.name = "year")


</code></pre>

<hr>
<h2 id='dummy.coef.pdynmc'>Extract Coefficient Estimates of Time Dummies of Fitted Model.</h2><span id='topic+dummy.coef.pdynmc'></span>

<h3>Description</h3>

<p><code>dummy.coef.pdynmc</code> extracts coefficient estimates of
time dummies of an object of class 'pdynmc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdynmc'
dummy.coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummy.coef.pdynmc_+3A_object">object</code></td>
<td>
<p>An object of class 'pdynmc'.</p>
</td></tr>
<tr><td><code id="dummy.coef.pdynmc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extract coefficient estimates of time dummies from
object of class 'pdynmc'.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
dummy.coef(m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

## Further code example
 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 dummy.coef(m1)



</code></pre>

<hr>
<h2 id='FDLS'>First Difference Least Squares (FDLS) Estimator of Han and Phillips (2010).</h2><span id='topic+FDLS'></span>

<h3>Description</h3>

<p><code>FDLS</code> computes closed form estimator for lag parameter of linear
dynamic panel data model based on first difference least squares (FDLS)
estimator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FDLS(dat, varname.i, varname.t, varname.y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FDLS_+3A_dat">dat</code></td>
<td>
<p>A dataset.</p>
</td></tr>
<tr><td><code id="FDLS_+3A_varname.i">varname.i</code></td>
<td>
<p>The name of the cross-section identifier.</p>
</td></tr>
<tr><td><code id="FDLS_+3A_varname.t">varname.t</code></td>
<td>
<p>The name of the time-series identifier.</p>
</td></tr>
<tr><td><code id="FDLS_+3A_varname.y">varname.y</code></td>
<td>
<p>A character string denoting the name of the dependent variable
in the dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates a linear dynamic panel data model of the form
</p>
<p style="text-align: center;"><code class="reqn">y_{i,t} = y_{i,t-1} \rho_1 + a_i + \varepsilon_{i,t}</code>
</p>

<p>where <code class="reqn">y_{i,t-1}</code> is the lagged dependent variable, <code class="reqn">\rho_1</code> is
the lag parameter, <code class="reqn">a_i</code> is an unobserved individual specific effect,
and <code class="reqn">\varepsilon_{i,t}</code> is an idiosyncratic remainder component. The
model structure accounts for unobserved individual specific heterogeneity
and dynamics. Note that more general lag structures and further covariates
are beyond the scope of the current implementation in <code>pdynmc</code>.
</p>
<p>More details on the FDLS estimator and its properties are provided
in Han and Phillips (2010).
</p>


<h3>Value</h3>

<p>An object of class 'numeric' that contains the coefficient estimate for
the lag parameter according to the two roots of the quadratic equation.
</p>


<h3>Author(s)</h3>

<p>Joachim Schnurbus, Markus Fritsch
</p>


<h3>References</h3>

<p>Han C, Phillips PCB (2010).
&ldquo;GMM Estimation For Dynamic Panels With Fixed Effects And Strong Instruments At Unity.&rdquo;
<em>Econometric Theory</em>, <b>26</b>(1), 119&ndash;151.
<a href="https://doi.org/10.1017/S026646660909063X">doi:10.1017/S026646660909063X</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(cigDemand, package = "pdynmc")
dat &lt;- cigDemand

## Code example
m1 &lt;- FDLS(dat = dat, varname.i = "state", varname.t = "year", varname.y = "packpc")


</code></pre>

<hr>
<h2 id='fitted.pdynmc'>Extract Fitted Values of Fitted Model.</h2><span id='topic+fitted.pdynmc'></span>

<h3>Description</h3>

<p><code>fitted.pdynmc</code> extracts fitted values of an object of class
'pdynmc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdynmc'
fitted(object, step = object$iter, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.pdynmc_+3A_object">object</code></td>
<td>
<p>An object of class 'pdynmc'.</p>
</td></tr>
<tr><td><code id="fitted.pdynmc_+3A_step">step</code></td>
<td>
<p>An integer denoting the iteration step for which
fitted values are extracted (defaults to last iteration step
used for obtaining parameter estimates).</p>
</td></tr>
<tr><td><code id="fitted.pdynmc_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical variable indicating whether missing values
should be removed from the vector of fitted values (defaults
to 'FALSE').</p>
</td></tr>
<tr><td><code id="fitted.pdynmc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extract fitted values from object of class 'pdynmc'.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
fitted(m1, na.rm = TRUE)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

## Further code example
 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 fitted(m1, na.rm = TRUE)



</code></pre>

<hr>
<h2 id='jtest.fct'>Hansen J-Test.</h2><span id='topic+jtest.fct'></span>

<h3>Description</h3>

<p><code>jtest.fct</code> tests the validity of the overidentifying restrictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jtest.fct(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jtest.fct_+3A_object">object</code></td>
<td>
<p>An object of class 'pdynmc'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis is that the overidentifying restrictions are valid.
The test statistic is computed as proposed by
Hansen (1982). As noted by
Bowsher (2002) and
Windmeijer (2005)
the test statistic is weakened by many instruments.
</p>


<h3>Value</h3>

<p>An object of class 'htest' which contains the Hansen J-test statistic
and corresponding p-value for the null hypothesis that the overidentifying
restrictions are valid.
</p>


<h3>References</h3>

<p>Bowsher CG (2002).
&ldquo;On testing overidentifying restrictions in dynamic panel data models.&rdquo;
<em>Economics Letters</em>, <b>77</b>(2), 211&ndash;220.
<a href="https://doi.org/10.1016/S0165-1765%2802%2900130-1">doi:10.1016/S0165-1765(02)00130-1</a>.<br /><br /> Hansen LP (1982).
&ldquo;Large Sample Properties of Generalized Method of Moments Estimators.&rdquo;
<em>Econometrica</em>, <b>50</b>(4), 1029&ndash;1054.
<a href="https://doi.org/10.2307/1912775">doi:10.2307/1912775</a>.<br /><br /> Windmeijer F (2005).
&ldquo;A finite sample correction for the variance of linear efficient two-step GMM estimators.&rdquo;
<em>Journal of Econometrics</em>, <b>126</b>(1), 25&ndash;51.
<a href="https://doi.org/10.1016/j.jeconom.2004.02.005">doi:10.1016/j.jeconom.2004.02.005</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(140:0), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
jtest.fct(m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

## Further code example
 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 jtest.fct(m1)



</code></pre>

<hr>
<h2 id='model.matrix.pdynmc'>Extract Instrument Matrix of Fitted Model.</h2><span id='topic+model.matrix.pdynmc'></span>

<h3>Description</h3>

<p><code>model.matrix.pdynmc</code> extracts instrument matrix of an
object of class 'pdynmc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdynmc'
model.matrix(object, sparse = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.pdynmc_+3A_object">object</code></td>
<td>
<p>An object of class 'pdynmc'.</p>
</td></tr>
<tr><td><code id="model.matrix.pdynmc_+3A_sparse">sparse</code></td>
<td>
<p>Whether to return a sparse matrix (if set to 'TRUE')
or a regular matrix (if set to 'FALSE').</p>
</td></tr>
<tr><td><code id="model.matrix.pdynmc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extracts instrument matrix from an object of class 'pdynmc'.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
model.matrix(m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 model.matrix(m1)



</code></pre>

<hr>
<h2 id='mtest.fct'>Arellano and Bond Serial Correlation Test.</h2><span id='topic+mtest.fct'></span>

<h3>Description</h3>

<p><code>mtest.pdynmc</code> Methods to test for serial correlation in the error terms
for objects of class 'pdynmc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mtest.fct(object, order = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mtest.fct_+3A_object">object</code></td>
<td>
<p>An object of class 'pdynmc'.</p>
</td></tr>
<tr><td><code id="mtest.fct_+3A_order">order</code></td>
<td>
<p>A number denoting the order of serial correlation to test for
(defaults to '2').</p>
</td></tr>
<tr><td><code id="mtest.fct_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The null hypothesis is that there is no serial correlation of a
particular order. The test statistic is computed as proposed by
Arellano and Bond (1991) and
Arellano (2003).
</p>


<h3>Value</h3>

<p>An object of class 'htest' which contains the Arellano and Bond m test
statistic and corresponding p-value for the null hypothesis that there is no
serial correlation of the given order.
</p>


<h3>References</h3>

<p>Arellano M (2003).
<em>Panel Data Econometrics</em>.
Oxford University Press.
<a href="https://doi.org/10.1093/0199245282.001.0001">doi:10.1093/0199245282.001.0001</a>.<br /><br /> Arellano M, Bond S (1991).
&ldquo;Some Tests of Specification for Panel Data: Monte Carlo Evidence and an Application to Employment Equations.&rdquo;
<em>The Review of Economic Studies</em>, <b>58</b>(2), 277&ndash;297.
<a href="https://doi.org/10.2307/2297968">doi:10.2307/2297968</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(140:0), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
mtest.fct(m1, order = 2)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

## Further code example
 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 mtest.fct(m1, order = 2)



</code></pre>

<hr>
<h2 id='ninst'>Extract Instrument Count of Fitted Model.</h2><span id='topic+ninst'></span>

<h3>Description</h3>

<p><code>ninst</code> is a generic function fo extracting the instrument
count of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ninst(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ninst_+3A_object">object</code></td>
<td>
<p>An object for which the instrument count is desired.</p>
</td></tr>
<tr><td><code id="ninst_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extracts instrument count from an object.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
ninst(m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 ninst(m1)



</code></pre>

<hr>
<h2 id='ninst.pdynmc'>Extract Instrument Count of Fitted Model.</h2><span id='topic+ninst.pdynmc'></span>

<h3>Description</h3>

<p><code>ninst.pdynmc</code> extracts instrument count of an object of
class 'pdynmc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdynmc'
ninst(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ninst.pdynmc_+3A_object">object</code></td>
<td>
<p>An object of class 'pdynmc'.</p>
</td></tr>
<tr><td><code id="ninst.pdynmc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extracts instrument count from an object of class 'pdynmc'.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
ninst(m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 ninst(m1)



</code></pre>

<hr>
<h2 id='NLIV'>Nonlinear Instrumental Variables Estimator - T-Version (NLIV).</h2><span id='topic+NLIV'></span>

<h3>Description</h3>

<p><code>NLIV</code> Computes closed form solution for lag parameter of linear
dynamic panel data model based on instrumental variables (IV) estimator
employing nonlinear moment conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NLIV(dat, varname.i, varname.t, varname.y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NLIV_+3A_dat">dat</code></td>
<td>
<p>A dataset.</p>
</td></tr>
<tr><td><code id="NLIV_+3A_varname.i">varname.i</code></td>
<td>
<p>The name of the cross-section identifier.</p>
</td></tr>
<tr><td><code id="NLIV_+3A_varname.t">varname.t</code></td>
<td>
<p>The name of the time-series identifier.</p>
</td></tr>
<tr><td><code id="NLIV_+3A_varname.y">varname.y</code></td>
<td>
<p>A character string denoting the name of the dependent
variable in the dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates a linear dynamic panel data model of the form
</p>
<p style="text-align: center;"><code class="reqn">y_{i,t} = y_{i,t-1} \rho_1 + a_i + \varepsilon_{i,t}</code>
</p>

<p>where <code class="reqn">y_{i,t-1}</code> is the lagged dependent variable, <code class="reqn">\rho_1</code> is
the lag parameter, <code class="reqn">a_i</code> is an unobserved individual specific effect,
and <code class="reqn">\varepsilon_{i,t}</code> is an idiosyncratic remainder component. The
model structure accounts for unobserved individual specific heterogeneity
and dynamics. Note that more general lag structures and further covariates
are beyond the scope of the current implementation in <code>pdynmc</code>.
</p>
<p>The nonlinear IV estimator employs the original version of the nonlinear
moment conditions of Ahn and Schmidt (1995).
More details on the implementation and the properties of the estimator
are provided in Fritsch et al. (2024).
</p>


<h3>Value</h3>

<p>An object of class 'numeric' that contains the coefficient estimate for
the lag parameter according to the two roots of the quadratic equation.
</p>


<h3>Author(s)</h3>

<p>Joachim Schnurbus, Markus Fritsch
</p>


<h3>References</h3>

<p>Ahn SC, Schmidt P (1995).
&ldquo;Efficient estimation of models for dynamic panel data.&rdquo;
<em>Journal of Econometrics</em>, <b>68</b>(1), 5&ndash;27.
<a href="https://doi.org/10.1016/0304-4076%2894%2901641-C">doi:10.1016/0304-4076(94)01641-C</a>.<br /><br /> Fritsch M, Pua AAY, Schnurbus J (2024).
&ldquo;Properties of an estimator for linear dynamic panel data models based on nonlinear moment conditions.&rdquo;
Working Paper.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(cigDemand, package = "pdynmc")
dat &lt;- cigDemand

## Code example
m1 &lt;- NLIV(dat = dat, varname.i = "state", varname.t = "year", varname.y = "packpc")


</code></pre>

<hr>
<h2 id='NLIV.alt'>Nonlinear Instrumental Variables Estimator - t-Version (NLIV.alt).</h2><span id='topic+NLIV.alt'></span>

<h3>Description</h3>

<p><code>NLIV.alt</code> Computes closed form solution for lag parameter of linear
dynamic panel data model based on instrumental variables (IV) estimator
employing alternative formulation of nonlinear moment conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NLIV.alt(dat, varname.i, varname.t, varname.y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NLIV.alt_+3A_dat">dat</code></td>
<td>
<p>A dataset.</p>
</td></tr>
<tr><td><code id="NLIV.alt_+3A_varname.i">varname.i</code></td>
<td>
<p>The name of the cross-section identifier.</p>
</td></tr>
<tr><td><code id="NLIV.alt_+3A_varname.t">varname.t</code></td>
<td>
<p>The name of the time-series identifier.</p>
</td></tr>
<tr><td><code id="NLIV.alt_+3A_varname.y">varname.y</code></td>
<td>
<p>A character string denoting the name of the dependent
variable in the dataset.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates a linear dynamic panel data model of the form
</p>
<p style="text-align: center;"><code class="reqn">y_{i,t} = y_{i,t-1} \rho_1 + a_i + \varepsilon_{i,t}</code>
</p>

<p>where <code class="reqn">y_{i,t-1}</code> is the lagged dependent variable, <code class="reqn">\rho_1</code> is
the lag parameter, <code class="reqn">a_i</code> is an unobserved individual specific effect,
and <code class="reqn">\varepsilon_{i,t}</code> is an idiosyncratic remainder component. The
model structure accounts for unobserved individual specific heterogeneity
and dynamics. Note that more general lag structures and further covariates
are beyond the scope of the current implementation in <code>pdynmc</code>.
</p>
<p>The nonlinear IV estimator employs an alternative formulation of the
nonlinear moment conditions of Ahn and Schmidt (1995).
More details on the implementation and the properties of the estimator
are provided in Fritsch et al. (2024).
</p>


<h3>Value</h3>

<p>An object of class 'numeric' that contains the coefficient estimate for
the lag parameter according to the two roots of the quadratic equation.
</p>


<h3>Author(s)</h3>

<p>Joachim Schnurbus, Markus Fritsch
</p>


<h3>References</h3>

<p>Ahn SC, Schmidt P (1995).
&ldquo;Efficient estimation of models for dynamic panel data.&rdquo;
<em>Journal of Econometrics</em>, <b>68</b>(1), 5&ndash;27.
<a href="https://doi.org/10.1016/0304-4076%2894%2901641-C">doi:10.1016/0304-4076(94)01641-C</a>.<br /><br /> Fritsch M, Pua AAY, Schnurbus J (2024).
&ldquo;Properties of an estimator for linear dynamic panel data models based on nonlinear moment conditions.&rdquo;
Working Paper.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(cigDemand, package = "pdynmc")
dat &lt;- cigDemand

## Code example
m1 &lt;- NLIV.alt(dat = dat, varname.i = "state", varname.t = "year", varname.y = "packpc")


</code></pre>

<hr>
<h2 id='nobs.pdynmc'>Extract Number of Observations of Fitted Model.</h2><span id='topic+nobs.pdynmc'></span>

<h3>Description</h3>

<p><code>nobs.pdynmc</code> extracts number of observations in cross-section
dimension and longitudinal dimension of an object of class
'pdynmc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdynmc'
nobs(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nobs.pdynmc_+3A_object">object</code></td>
<td>
<p>An object of class 'pdynmc'.</p>
</td></tr>
<tr><td><code id="nobs.pdynmc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extracts number of observations in cross-section dimension
and longitudinal dimension of an object of class 'pdynmc'.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
nobs(m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 nobs(m1)



</code></pre>

<hr>
<h2 id='optimIn'>Extract Input Parameters of Numeric Optimization of Fitted Model.</h2><span id='topic+optimIn'></span>

<h3>Description</h3>

<p><code>optimIn</code> is a generic function for extracting input parameters
of numeric optimization for an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimIn(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimIn_+3A_object">object</code></td>
<td>
<p>An object for which input parameters of numeric
optimization are desired.</p>
</td></tr>
<tr><td><code id="optimIn_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>optimIn</code> extracts input parameters used in numeric
optimization from object.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
optimIn(m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

## Further code example
 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "BFGS")
 optimIn(m1)



</code></pre>

<hr>
<h2 id='optimIn.pdynmc'>Extract Input Parameters of Numeric Optimization of Fitted Model.</h2><span id='topic+optimIn.pdynmc'></span>

<h3>Description</h3>

<p><code>optimIn.pdynmc</code> extracts input parameters of numeric
optimization for an object of class 'pdynmc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdynmc'
optimIn(object, step = object$iter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optimIn.pdynmc_+3A_object">object</code></td>
<td>
<p>An object of class 'pdynmc'.</p>
</td></tr>
<tr><td><code id="optimIn.pdynmc_+3A_step">step</code></td>
<td>
<p>An integer denoting the iteration step for which input
parameters are extracted (defaults to last iteration step used
for obtaining parameter estimates).</p>
</td></tr>
<tr><td><code id="optimIn.pdynmc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extracts input parameters of numeric optimization from
object of class 'pdynmc'.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
optimIn(m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

## Further code example
 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "BFGS")
 optimIn(m1)



</code></pre>

<hr>
<h2 id='package-pdynmc'>pdynmc: A package for moment conditions based estimation of linear dynamic
panel data models</h2><span id='topic+package-pdynmc'></span>

<h3>Description</h3>

<p>The pdynmc package provides four categories of functions that are available
to the user: A function for model fitting, functions for visualizing
estimation results and panel data structures, functions for
specification testing, and functions that extract and summarize particular
information from fitted model objects.
</p>

<hr>
<h2 id='pDensTime.plot'>Plot Empirical Density of a Column of a Panel Dataset over Time.</h2><span id='topic+pDensTime.plot'></span>

<h3>Description</h3>

<p><code>pDensTime.plot</code> Plot the empirical density
of a column of an object of class 'data.frame'
containing a panel dataset across time
periods/aggregates of time periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pDensTime.plot(
  object,
  var.name,
  i.name,
  t.name,
  aggregate.t = NULL,
  plot.quantiles = TRUE,
  plot.mean_ci = TRUE,
  plot.extrema = TRUE,
  col.set = c("gray", "navy", "darkorange1", "red"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pDensTime.plot_+3A_object">object</code></td>
<td>
<p>An object of class 'data.frame'.</p>
</td></tr>
<tr><td><code id="pDensTime.plot_+3A_var.name">var.name</code></td>
<td>
<p>Column name of the variable that is
plotted (see &lsquo;Details&rsquo;).</p>
</td></tr>
<tr><td><code id="pDensTime.plot_+3A_i.name">i.name</code></td>
<td>
<p>Column name of cross-section identifier.</p>
</td></tr>
<tr><td><code id="pDensTime.plot_+3A_t.name">t.name</code></td>
<td>
<p>Column name of time-series identifier.</p>
</td></tr>
<tr><td><code id="pDensTime.plot_+3A_aggregate.t">aggregate.t</code></td>
<td>
<p>Argument of data type &lsquo;numeric&rsquo;.
If argument is specified, the corresponding number
of time periods is merged (approximately); (defaults
to 'NULL').</p>
</td></tr>
<tr><td><code id="pDensTime.plot_+3A_plot.quantiles">plot.quantiles</code></td>
<td>
<p>Argument of data type &lsquo;logical&rsquo;,
indicating whether the 5%- and 95%-quantiles and
the quartiles should be plotted (as specified by
&lsquo;col.set[2]&rsquo;; defaults to 'TRUE').</p>
</td></tr>
<tr><td><code id="pDensTime.plot_+3A_plot.mean_ci">plot.mean_ci</code></td>
<td>
<p>Argument of data type &lsquo;logical&rsquo;,
indicating whether the mean and the approximate
confidence intervals (mean plus/minus 2 standard
deviations) should be plotted (as specified by
&lsquo;col.set[3]&rsquo;; defaults to 'TRUE').</p>
</td></tr>
<tr><td><code id="pDensTime.plot_+3A_plot.extrema">plot.extrema</code></td>
<td>
<p>Argument of data type &lsquo;logical&rsquo;,
indicating whether the minimal and maximal observed
value (per time period/group) should be plotted
(as specified by &lsquo;col.set[4]&rsquo;; defaults to 'TRUE').</p>
</td></tr>
<tr><td><code id="pDensTime.plot_+3A_col.set">col.set</code></td>
<td>
<p>Vector of length 4 with entries of
data type &lsquo;character&rsquo; used to visualize the entities
of &lsquo;pDensTime.plot&rsquo; (see &lsquo;Details&rsquo;); must be a
valid argument to &lsquo;col2rgb&rsquo;; defaults to
&lsquo;c(&quot;gray&quot;, &quot;navy&quot;, &quot;darkorange1&quot;, &quot;red&quot;)&rsquo;.</p>
</td></tr>
<tr><td><code id="pDensTime.plot_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot that visualizes the empirical
density for a column of a panel dataset
contained in an object of class 'data.frame'. The
variable of interest is plotted on the ordinate,
the longitudinal dimension on the abscissa. For each
time period or aggregate of time periods, one
empirical density is computed and plotted.
Corresponding summary statistics on empirical
quantiles and the sample size per longitudinal
dimension are included in the plot.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch, Joachim Schnurbus
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

## Minimal set of arguments
pDensTime.plot(object = ABdata, var.name = "emp", i.name = "firm", t.name = "year")

## All arguments explicitly stated
pDensTime.plot(object	= ABdata, var.name	= "emp", i.name	= "firm", t.name	= "year",
 aggregate.t	= NULL,	plot.quantiles	= TRUE, plot.mean_ci	= TRUE, plot.extrema	= TRUE,
 col.set		= c("gray", "navy", "darkorange1", "red"))

## Aggregation over time periods (3 time periods per group)
pDensTime.plot(object = ABdata, var.name = "emp", i.name = "firm", t.name = "year",
 aggregate.t = 3)

## Employ alternative colouring scheme
pDensTime.plot(object = ABdata, var.name = "emp", i.name = "firm", t.name = "year",
 col.set		= c("pink", "blue", "purple", "black"))

## Plot only density, mean, and asymptotic confidence interval
pDensTime.plot(object = ABdata, var.name = "emp", i.name = "firm", t.name = "year",
 plot.quantiles	= FALSE, plot.extrema	= FALSE)

</code></pre>

<hr>
<h2 id='pdynmc'>Generalized Method of Moments (GMM) Estimation of Linear Dynamic Panel Data
Models.</h2><span id='topic+pdynmc'></span>

<h3>Description</h3>

<p><code>pdynmc</code> fits a linear dynamic panel data model based on moment
conditions with the Generalized Method of Moments (GMM).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdynmc(
  dat = NULL,
  varname.i = NULL,
  varname.t = NULL,
  use.mc.diff = NULL,
  use.mc.lev = NULL,
  use.mc.nonlin = NULL,
  use.mc.nonlinAS = NULL,
  inst.collapse = FALSE,
  inst.stata = FALSE,
  include.y,
  varname.y = NULL,
  lagTerms.y = NULL,
  maxLags.y = NULL,
  include.x = FALSE,
  varname.reg.end = NULL,
  lagTerms.reg.end = NULL,
  maxLags.reg.end = NULL,
  varname.reg.pre = NULL,
  lagTerms.reg.pre = NULL,
  maxLags.reg.pre = NULL,
  varname.reg.ex = NULL,
  lagTerms.reg.ex = NULL,
  maxLags.reg.ex = NULL,
  inst.reg.ex.expand = TRUE,
  include.x.instr = FALSE,
  varname.reg.instr = NULL,
  include.x.toInstr = FALSE,
  varname.reg.toInstr = NULL,
  fur.con = FALSE,
  fur.con.diff = NULL,
  fur.con.lev = NULL,
  varname.reg.fur = NULL,
  lagTerms.reg.fur = NULL,
  include.dum = FALSE,
  dum.diff = NULL,
  dum.lev = NULL,
  varname.dum = NULL,
  col_tol = 0.65,
  w.mat = "iid.err",
  w.mat.stata = FALSE,
  std.err = "corrected",
  estimation = "iterative",
  max.iter = 100,
  iter.tol = 0.01,
  inst.thresh = NULL,
  opt.meth = "BFGS",
  hessian = FALSE,
  optCtrl = list(kkt = FALSE, kkttol = .Machine$double.eps^(1/3), kkt2tol =
    .Machine$double.eps^(1/3), starttests = TRUE, dowarn = TRUE, badval = (0.25) *
    .Machine$double.xmax, usenumDeriv = FALSE, reltol = 1e-12, maxit = 200, trace = TRUE,
    follow.on = FALSE, save.failures = TRUE, maximize = FALSE, factr = 1e+07, pgtol = 0,
    all.methods = FALSE),
  custom.start.val = FALSE,
  start.val = NULL,
  start.val.lo = -1,
  start.val.up = 1,
  seed.input = 42
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdynmc_+3A_dat">dat</code></td>
<td>
<p>A dataset.</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_varname.i">varname.i</code></td>
<td>
<p>The name of the cross-section identifier.</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_varname.t">varname.t</code></td>
<td>
<p>The name of the time-series identifier.</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_use.mc.diff">use.mc.diff</code></td>
<td>
<p>A logical variable indicating whether moment conditions from
equations in differences (i.e. instruments in levels) should be used.</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_use.mc.lev">use.mc.lev</code></td>
<td>
<p>A logical variable indicating whether moment conditions from
equations in levels (i.e. instruments in differences) should be used.</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_use.mc.nonlin">use.mc.nonlin</code></td>
<td>
<p>A logical variable indicating whether nonlinear (quadratic)
moment conditions should be used.</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_use.mc.nonlinas">use.mc.nonlinAS</code></td>
<td>
<p>A logical variable indicating whether only the nonlinear
(quadratic) moment conditions in the form proposed by
Ahn and Schmidt (1995) should be used (is set to 'TRUE'
when nonlinear moment conditions are employed).</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_inst.collapse">inst.collapse</code></td>
<td>
<p>A logical variable indicating whether to collapse the set
of moment conditions as proposed by (Roodman 2009)
(defaults to 'FALSE').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_inst.stata">inst.stata</code></td>
<td>
<p>A logical variable indicating whether to use the moment
conditions from equations in levels as in Stata implementations xtabond2
Roodman (2018) and xtdpdgmm
Kripfganz (2019).</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_include.y">include.y</code></td>
<td>
<p>A logical variable indicating whether instruments should be
derived from the lags of the dependent variable.</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_varname.y">varname.y</code></td>
<td>
<p>A character string denoting the name of the dependent variable
in the dataset.</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_lagterms.y">lagTerms.y</code></td>
<td>
<p>An integer indicating the number of lags of the dependent
variable. Note that setting 'lagTerms.y' to zero excludes the dependent
variable from the right-hand-side of the model specification.</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_maxlags.y">maxLags.y</code></td>
<td>
<p>An integer indicating the maximum number of lags of the
dependent variable from which instruments should be derived.</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_include.x">include.x</code></td>
<td>
<p>A logical variable indicating whether instruments should be
derived from the covariates. Setting the argument to 'TRUE' requires
specifying whether the covariates are endogenous, predetermined, or
(strictly) exogenous (defaults to 'FALSE').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_varname.reg.end">varname.reg.end</code></td>
<td>
<p>One or more character strings denoting the covariate(s)
in the dataset to be treated as endogenous (defaults to 'NULL').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_lagterms.reg.end">lagTerms.reg.end</code></td>
<td>
<p>One or more integers indicating the number of lags of
the endogenous covariate(s). One integer per covariate needs to be given
in the same order as the covariate names (defaults to 'NULL').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_maxlags.reg.end">maxLags.reg.end</code></td>
<td>
<p>One or more integers indicating the maximum number of
lags of the endogenous covariate(s) used for deriving instruments.</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_varname.reg.pre">varname.reg.pre</code></td>
<td>
<p>One or more character strings denoting the covariate(s)
in the dataset to be treated as predetermined (defaults to 'NULL').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_lagterms.reg.pre">lagTerms.reg.pre</code></td>
<td>
<p>One or more integers indicating the number of lags of
the predetermined covariate(s).</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_maxlags.reg.pre">maxLags.reg.pre</code></td>
<td>
<p>One or more integers indicating the maximum number of
lags of the predetermined covariate(s) used for deriving instruments. One
integer per covariate needs to be given in the same order as the covariate
names (defaults to 'NULL').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_varname.reg.ex">varname.reg.ex</code></td>
<td>
<p>One or more character strings denoting the covariate(s)
in the dataset to be treated as (strictly) exogenous (defaults to 'NULL').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_lagterms.reg.ex">lagTerms.reg.ex</code></td>
<td>
<p>One or more integers indicating the number of lags of
the (strictly) exogenous covariate(s). One integer per covariate needs to
be given in the same order as the covariate name (defaults to 'NULL').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_maxlags.reg.ex">maxLags.reg.ex</code></td>
<td>
<p>One or more integers indicating the maximum number of
lags of the (strictly) exogenous covariate(s) used for deriving instruments.</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_inst.reg.ex.expand">inst.reg.ex.expand</code></td>
<td>
<p>A logical variable that allows for using all past,
present, and future observations of 'varname.reg.ex' to derive instruments
(defaults to 'TRUE'). If set to 'FALSE', only past and present time periods
are used to derive instruments.</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_include.x.instr">include.x.instr</code></td>
<td>
<p>A logical variable that allows to include additional
IV-type instruments (i.e., include covariates which are used as instruments
but for which no parameters are estimated; defaults to 'FALSE').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_varname.reg.instr">varname.reg.instr</code></td>
<td>
<p>One or more character strings denoting the covariate(s)
in the dataset treated as instruments in estimation (defaults to 'NULL').
Note that the instrument type needs to be specified by including the names
of the covariate(s) in any of the arguments 'varname.reg.end',
'varname.reg.pre', or 'varname.reg.ex'.</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_include.x.toinstr">include.x.toInstr</code></td>
<td>
<p>A logical variable that allows to instrument covariate(s)
(i.e., covariates which are not used as instruments but for which parameters
are estimated; defaults to 'FALSE').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_varname.reg.toinstr">varname.reg.toInstr</code></td>
<td>
<p>One or more character strings denoting the covariate(s)
in the dataset to be instrumented (defaults to 'NULL'). Note that the names of
the covariate(s) should not be included in any other function argument.</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_fur.con">fur.con</code></td>
<td>
<p>A logical variable indicating whether further control variables
(covariates) are included (defaults to 'FALSE').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_fur.con.diff">fur.con.diff</code></td>
<td>
<p>A logical variable indicating whether to include further
control variables in equations from differences (defaults to 'NULL').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_fur.con.lev">fur.con.lev</code></td>
<td>
<p>A logical variable indicating whether to include further
control variables in equations from level (defaults to 'NULL').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_varname.reg.fur">varname.reg.fur</code></td>
<td>
<p>One or more character strings denoting covariate(s) in
the dataset to treat as further controls (defaults to 'NULL').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_lagterms.reg.fur">lagTerms.reg.fur</code></td>
<td>
<p>One or more integers indicating the number of lags of
the further controls. One integer per further control needs to be given in
the same order as the corresponding variable names (defaults to 'NULL').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_include.dum">include.dum</code></td>
<td>
<p>A logical variable indicating whether dummy variables for
the time periods are included (defaults to 'FALSE').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_dum.diff">dum.diff</code></td>
<td>
<p>A logical variable indicating whether dummy variables are
included in the equations in first differences (defaults to 'NULL').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_dum.lev">dum.lev</code></td>
<td>
<p>A logical variable indicating whether dummy variables are
included in the equations in levels (defaults to 'NULL').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_varname.dum">varname.dum</code></td>
<td>
<p>One or more character strings from which time dummies should
be derived (can be different from varname.t; defaults to 'NULL').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_col_tol">col_tol</code></td>
<td>
<p>A numeric variable in [0,1] indicating the absolute correlation
threshold for collinearity checks (columns are omitted when pairwise
correlations are above the threshold; defaults to 0.65).</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_w.mat">w.mat</code></td>
<td>
<p>One of the character strings c('&quot;iid.err&quot;', '&quot;identity&quot;',
'&quot;zero.cov&quot;') indicating the type of weighting matrix to use (defaults to
'&quot;iid.err&quot;').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_w.mat.stata">w.mat.stata</code></td>
<td>
<p>A logical variable that slightly adjusts the weighting
matrix according to the Stata function xtdpdgmm (defaults to 'FALSE').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_std.err">std.err</code></td>
<td>
<p>One of the character strings c('&quot;corrected&quot;', '&quot;unadjusted&quot;',
'&quot;dbl.corrected&quot;').
The second and third options compute corrected standard error according
to Windmeijer (2005) and
Hwang et al. (2021), respectively
(defaults to '&quot;corrected&quot;').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_estimation">estimation</code></td>
<td>
<p>One of the character strings c('&quot;onestep&quot;', '&quot;twostep&quot;',
'&quot;iterative&quot;'). Denotes the number of iterations of the parameter procedure
(defaults to '&quot;twostep&quot;').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_max.iter">max.iter</code></td>
<td>
<p>An integer indicating the maximum number of iterations
(defaults to 'NULL'; if estimation is set to '&quot;iterative&quot;', 'max.iter'
defaults to 100).</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_iter.tol">iter.tol</code></td>
<td>
<p>A numeric variable in [0,1] indicating the tolerance for
determining convergence of the iterative approach (defaults to 'NULL';
if estimation is set to '&quot;iterative&quot;', iter.tol defaults to 0.01).</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_inst.thresh">inst.thresh</code></td>
<td>
<p>An integer denoting above which instrument count a
generalized inverse is used to invert the weighting matrix (defaults to
'NULL').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_opt.meth">opt.meth</code></td>
<td>
<p>A character string denoting the numerical optimization procedure.
When no nonlinear moment conditions are employed in estimation, closed form
estimates can be computed by setting the argument to '&quot;none&quot;' (defaults to
'&quot;BFGS&quot;'; for details on the further available optimizers see the
documentation of package <span class="pkg">optimx</span>).</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_hessian">hessian</code></td>
<td>
<p>A logical variable indicating if the hessian matrix should be
approximated in optimization (defaults to 'FALSE').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_optctrl">optCtrl</code></td>
<td>
<p>A list of arguments that are passed to <span class="pkg">optimx</span>.
For details on the arguments and the available options see the package
documentation.</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_custom.start.val">custom.start.val</code></td>
<td>
<p>A logical variable indicating whether prespecified
starting values for the parameters are provided by the user (defaults to
'FALSE'; if set to 'TRUE', starting values need to be provided via argument
'start.val').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_start.val">start.val</code></td>
<td>
<p>A vector of numeric variables denoting the starting values
for the parameter vector for numeric optimization (defaults to 'NULL').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_start.val.lo">start.val.lo</code></td>
<td>
<p>A numeric variable denoting the lower limit for drawing
starting values with uniform density (defaults to -1; ignored if
'custom.start.val' is set to 'TRUE').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_start.val.up">start.val.up</code></td>
<td>
<p>A numeric variable denoting the lower limit for drawing
starting values with uniform density (defaults to 1; ignored if
'custom.start.val' is set to 'TRUE').</p>
</td></tr>
<tr><td><code id="pdynmc_+3A_seed.input">seed.input</code></td>
<td>
<p>An integer used as seed for drawing starting values (defaults
to 42; required if custom.start.val is set to 'FALSE').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function estimates a linear dynamic panel data model of the form
</p>
<p style="text-align: center;"><code class="reqn">y_{i,t} = y_{i,t-1} \rho_1 + \boldsymbol{x}_{i,t}' \boldsymbol{\beta} + a_i + \varepsilon_{i,t}</code>
</p>

<p>where <code class="reqn">y_{i,t-1}</code> is the lagged dependent variable, <code class="reqn">\rho_1</code> is
the lag parameter, <code class="reqn">\boldsymbol{x}_{i,t}</code> are further covariates,
<code class="reqn">\boldsymbol{\beta}</code> are the corresponding parameters, <code class="reqn">a_i</code>
is an unobserved individual specific effect, and
<code class="reqn">\varepsilon_{i,t}</code> is an idiosyncratic remainder component. The
model structure accounts for unobserved individual specific heterogeneity
and dynamics. Note that the specification given above is simplified for
illustatory purposes and more general lag structures are allowed in
<code>pdynmc</code>.
</p>
<p>Estimation of the model parameters in <code>pdynmc</code> is based on
moment conditions with the generalized method of moments (GMM). Linear
dynamic panel data models  The moment conditions employed in estimation can be linear and
nonlinear in parameters and estimation is carried out iteratively. In case
only linear moment conditions are used in estimation, closed form solutions
can be for computing parameter estimates &ndash; while when nonlinear moment
conditions are employed, parameter estimation relies on numerical
optimization of the objective function.
</p>
<p>'pdynmc' provides an implementation of some of the functionality available
in the Stata library xtdpdgmm Kripfganz (2019) and allows
for '&quot;onestep&quot;', '&quot;twostep&quot;', and '&quot;iterative&quot;' GMM estimation based on the
moment conditions of Holtz-Eakin et al. (1988),
Arellano and Bover (1995), and
Ahn and Schmidt (1995). Standard error corrections
according to Windmeijer (2005) and
Hwang et al. (2021) are available.
For further details, please see
Fritsch et al. (2021).
</p>


<h3>Value</h3>

<p>An object of class 'pdynmc' with the following elements:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a vector containing the coefficient estimates</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>a list of elements on which computation of the model fit is based</p>
</td></tr>
<tr><td><code>dep.clF</code></td>
<td>
<p>a list of vectors containing the dependent variable for the
cross-sectional observations</p>
</td></tr>
<tr><td><code>dat.clF</code></td>
<td>
<p>a list of matrices containing the covariates for the
cross-sectional observations</p>
</td></tr>
<tr><td><code>w.mat</code></td>
<td>
<p>a list of weighting matrices for the different estimation steps</p>
</td></tr>
<tr><td><code>H_i</code></td>
<td>
<p>a matrix used to create the weighting matrix for the first estimation
step</p>
</td></tr>
<tr><td><code>par.optim</code></td>
<td>
<p>a list of vectors containing the parameter estimates obtained
from numerical optimization for the estimation steps</p>
</td></tr>
<tr><td><code>ctrl.optim</code></td>
<td>
<p>a list of control parameters used in numerical optimization for
the estimation steps</p>
</td></tr>
<tr><td><code>par.clForm</code></td>
<td>
<p>a list of vectors containing the parameter estimates obtained
from the closed form for the estimation steps</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>a scalar denoting the number of iteration steps carried out to
obtain parameter estimates</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>a list for each estimation step that contains a list of
vectors of fitted values for each cross-sectional observation</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>a list for each estimation step that contains a list of vectors
of residuals for each cross-sectional observation</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>a list of matrices containing the variance covariance matrix of the
parameter estimates for each estimation step</p>
</td></tr>
<tr><td><code>stderr</code></td>
<td>
<p>a list of vectors containing the standard errors of the parameter
estimates for each estimation step</p>
</td></tr>
<tr><td><code>zvalue</code></td>
<td>
<p>a list of vectors containing the z scores for the parameter
estimates for each estimation step</p>
</td></tr>
<tr><td><code>pvalue</code></td>
<td>
<p>a list of vectors containing the p-values for the parameter
estimates for each estimation step</p>
</td></tr>
</table>
<p>It has 'case.names', 'coef', 'dum.coef', 'fitted', 'model.matrix', 'ninst',
'nobs', 'optimIn', 'plot', 'print','residuals', 'summary', 'variable.names',
'vcov', and 'wmat' methods.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>References</h3>

<p>Ahn SC, Schmidt P (1995).
&ldquo;Efficient estimation of models for dynamic panel data.&rdquo;
<em>Journal of Econometrics</em>, <b>68</b>(1), 5&ndash;27.
<a href="https://doi.org/10.1016/0304-4076%2894%2901641-C">doi:10.1016/0304-4076(94)01641-C</a>.<br /><br /> Arellano M, Bover O (1995).
&ldquo;Another look at the instrumental variable estimation of error-components models.&rdquo;
<em>Journal of Econometrics</em>, <b>68</b>(1), 29&ndash;51.
<a href="https://doi.org/10.1016/0304-4076%2894%2901642-D">doi:10.1016/0304-4076(94)01642-D</a>.<br /><br /> Fritsch M, Pua AAY, Schnurbus J (2021).
&ldquo;pdynmc: A Package for Estimating Linear Dynamic Panel Data Models Based on Nonlinear Moment Conditions.&rdquo;
<em>The R Journal</em>, <b>13</b>(1), 218&ndash;231.
<a href="https://doi.org/10.32614/RJ-2021-035">doi:10.32614/RJ-2021-035</a>.<br /><br /> Holtz-Eakin D, Newey WK, Rosen HS (1988).
&ldquo;Estimating Vector Autoregressions with Panel Data.&rdquo;
<em>Econometrica</em>, <b>56</b>(6), 1371&ndash;1395.
<a href="https://doi.org/10.2307/1913103">doi:10.2307/1913103</a>.<br /><br /> Hwang J, Kang B, Lee S (2021).
&ldquo;A doubly corrected robust variance estimator for linear GMM.&rdquo;
<em>Journal of Econometrics</em>, <b>forthcoming</b>.
<a href="https://doi.org/10.1016/j.jeconom.2020.09.010">doi:10.1016/j.jeconom.2020.09.010</a>.<br /><br /> Kripfganz S (2019).
&ldquo;XTDPDGMM: Stata module to perform generalized method of moments estimation of linear dynamic panel data models.&rdquo;
<a href="https://econpapers.repec.org/RePEc:boc:bocode:s458395">https://econpapers.repec.org/RePEc:boc:bocode:s458395</a>.<br /><br /> Roodman D (2009).
&ldquo;A Note on the Theme of Too Many Instruments.&rdquo;
<em>Oxford Bulletin of Economics and Statistics</em>, <b>71</b>(1), 135&ndash;158.
<a href="https://doi.org/10.1111/j.1468-0084.2008.00542.x">doi:10.1111/j.1468-0084.2008.00542.x</a>.<br /><br /> Roodman D (2018).
&ldquo;xtabond2: Stata module to extend xtabond dynamic panel data estimator.&rdquo;
<a href="https://econpapers.repec.org/software/bocbocode/s435901.htm">https://econpapers.repec.org/software/bocbocode/s435901.htm</a>.<br /><br /> Windmeijer F (2005).
&ldquo;A finite sample correction for the variance of linear efficient two-step GMM estimators.&rdquo;
<em>Journal of Econometrics</em>, <b>126</b>(1), 25&ndash;51.
<a href="https://doi.org/10.1016/j.jeconom.2004.02.005">doi:10.1016/j.jeconom.2004.02.005</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+wald.fct">wald.fct</a></code> for Wald tests,
<code><a href="#topic+jtest.fct">jtest.fct</a></code> for the Hansen J test, and
<code><a href="#topic+mtest.fct">mtest.fct</a></code> for serial correlation tests.
<code><a href="optimx.html#topic+optimx">optimx</a></code> for details on alternative routines and options
for numerical optimization
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
         use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
         include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
         fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
         varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
         include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
         w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
         opt.meth = "none")
summary(m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

## Arellano and Bond (1991) estimation in Table 4, column (a1)
 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
         use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
         include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
         fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
         varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
         include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
         w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
         opt.meth = "none")
 summary(m1)

## Arellano and Bond (1991) estimation in Table 4, column (a2)
 m2 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
         use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
         include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
         fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
         varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
         include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
         w.mat = "iid.err", std.err = "corrected", estimation = "twostep",
         opt.meth = "none")
 summary(m2)

## Arellano and Bond (1991) twostep estimation extended by nonlinear moment
## conditions
 m3 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
         use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = TRUE,
         include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
         fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
         varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
         include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
         w.mat = "iid.err", std.err = "corrected", estimation = "twostep",
         opt.meth = "BFGS")
 summary(m3)

## Arellano and Bond (1991) iterative estimation extended by nonlinear moment
## conditions
 m4 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
         use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = TRUE,
         include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
         fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
         varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
         include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
         w.mat = "iid.err", std.err = "corrected", estimation = "iterative",
         max.iter = 4, opt.meth = "BFGS")
 summary(m4)

## Arellano and Bond (1991) twostep estimation extended by linear moment
## conditions from equations in levels
 m5 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
         use.mc.diff = TRUE, use.mc.lev = TRUE, use.mc.nonlin = FALSE,
         include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
         fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
         varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
         include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
         w.mat = "iid.err", std.err = "corrected", estimation = "twostep",
         opt.meth = "none")
 summary(m5)



</code></pre>

<hr>
<h2 id='plot.pdynmc'>Plot Coefficient Estimates and Corresponding Ranges of Fitted Model.</h2><span id='topic+plot.pdynmc'></span>

<h3>Description</h3>

<p><code>plot.pdynmc</code> Plot methods for objects of class 'pdynmc'. The
available plot options visualize: Fitted values versus residuals,
coefficient ranges across GMM iterations, coefficient paths and
objective function values across GMM iterations as proposed by
Hansen and Lee (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdynmc'
plot(
  x,
  type = "fire",
  include.dum = FALSE,
  include.fur.con = FALSE,
  col.coefRange = 1,
  col.coefInitial = "darkgrey",
  col.coefEst = "royalblue",
  omit1step = FALSE,
  boxplot.coef = FALSE,
  co = NULL,
  add.se.approx = NULL,
  conf.lev = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.pdynmc_+3A_x">x</code></td>
<td>
<p>An object of class 'pdynmc'. The function requires
twostep or iterative GMM estimates.</p>
</td></tr>
<tr><td><code id="plot.pdynmc_+3A_type">type</code></td>
<td>
<p>Whether to plot fitted values against residuals (argument
'fire'; default), coefficient ranges (argument 'coef.range';
this requires twostep or iterative GMM estimates), path of
coefficient estimates across GMM iterations (argument 'coef.path';
this requires twostep or iterative GMM estimates).</p>
</td></tr>
<tr><td><code id="plot.pdynmc_+3A_include.dum">include.dum</code></td>
<td>
<p>Include estimates of parameters corresponding to time
dummies (defaults to 'black'; requires 'type = coef.range').</p>
</td></tr>
<tr><td><code id="plot.pdynmc_+3A_include.fur.con">include.fur.con</code></td>
<td>
<p>Include estimates of parameters corresponding to
further controls (defaults to 'FALSE'; requires 'type = coef.range').</p>
</td></tr>
<tr><td><code id="plot.pdynmc_+3A_col.coefrange">col.coefRange</code></td>
<td>
<p>Specify color for plotting range of coefficient
estimates (defaults to 'NULL'; requires 'type = coef.range').</p>
</td></tr>
<tr><td><code id="plot.pdynmc_+3A_col.coefinitial">col.coefInitial</code></td>
<td>
<p>Specify color for plotting initial coefficient
estimates (defaults to 'darkgrey'; requires 'type = coef.range').</p>
</td></tr>
<tr><td><code id="plot.pdynmc_+3A_col.coefest">col.coefEst</code></td>
<td>
<p>Specify color for plotting coefficient estimate
(defaults to 'royalblue'; requires 'type = coef.range').</p>
</td></tr>
<tr><td><code id="plot.pdynmc_+3A_omit1step">omit1step</code></td>
<td>
<p>Omit coefficient estimates from one-step GMM
estimation in coefficient range plot. The argument can after
obtaining coefficient estimates from numerical optimization
methods to exclude the randomly drawn starting values from the
plotted coefficient range (defaults to 'FALSE'). Set to 'TRUE' to
exert the option; this argument requires iterative GMM estimates
and argument 'type = coef.range'.</p>
</td></tr>
<tr><td><code id="plot.pdynmc_+3A_boxplot.coef">boxplot.coef</code></td>
<td>
<p>Whether to draw boxplots for coefficient estimates
(defaults to 'FALSE'); requires iterative GMM with at least 10
iterations and argument 'type = coef.range'. Proceed with caution
as this argument is experimental.</p>
</td></tr>
<tr><td><code id="plot.pdynmc_+3A_co">co</code></td>
<td>
<p>Character string denoting the variable name(s) for which to
plot the path of coefficient estimate(s) across GMM iterations
(defaults to 'NULL') as proposed in Hansen and Lee (2021);
if no coefficient name is given, all coefficient paths are plotted;
requires at least two iterations and argument 'type = coef.path'.</p>
</td></tr>
<tr><td><code id="plot.pdynmc_+3A_add.se.approx">add.se.approx</code></td>
<td>
<p>A logical variable indicating if standard errors
should be added to the plot of the path of coefficient estimate(s)
across GMM iterations (defaults to 'NULL'); requires at least
two iterations and argument 'type = coef.path'. This option is
only available when plotting a single coefficient path (i.e.,
when 'co' contains only a single variable name).</p>
</td></tr>
<tr><td><code id="plot.pdynmc_+3A_conf.lev">conf.lev</code></td>
<td>
<p>A numeric variable indicating the confidence
level for approximating standard errors in the plot of the path
of coefficient estimate(s) across GMM iterations (defaults to
0.95; sensible values lie in the interval ]0,1[); requires
argument 'type = coef.path' and argument 'add.se.approx = TRUE'.</p>
</td></tr>
<tr><td><code id="plot.pdynmc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot fitted values against residuals ('type = fire') or
coefficient estimates and coefficient estimate ranges
('type = coef.range') for object of class 'pdynmc'. The latter
plot requires twostep or iterative GMM estimates.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch and Joachim Schnurbus
</p>


<h3>References</h3>

<p>Hansen BE, Lee S (2021).
&ldquo;Inference for Iterated GMM Under Misspecification.&rdquo;
<em>Econometrica</em>, <b>89</b>(3), 1419&ndash;1447.
<a href="https://doi.org/10.3982/ECTA16274">doi:10.3982/ECTA16274</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "twostep",
    opt.meth = "none")
plot(m1)
plot(m1, type = "coef.range")
plot(m1, type = "coef.path")


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

## Further code example
 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "iterative",
    opt.meth = "none")
 plot(m1)
 plot(m1, type = "coef.range")
 plot(m1, type = "coef.path")



</code></pre>

<hr>
<h2 id='print.pdynmc'>Print Fitted Model Object.</h2><span id='topic+print.pdynmc'></span>

<h3>Description</h3>

<p><code>print.pdynmc</code> prints objects of class 'pdynmc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdynmc'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.pdynmc_+3A_x">x</code></td>
<td>
<p>An object of class 'pdynmc'.</p>
</td></tr>
<tr><td><code id="print.pdynmc_+3A_digits">digits</code></td>
<td>
<p>An integer indicating the maximum number of digits to
display in the object.</p>
</td></tr>
<tr><td><code id="print.pdynmc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print objects of class 'pdynmc'.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
m1


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 m1




</code></pre>

<hr>
<h2 id='print.summary.pdynmc'>Print Summary of Fitted Model Object.</h2><span id='topic+print.summary.pdynmc'></span>

<h3>Description</h3>

<p><code>print.summary.pdynmc</code> prints the summary for objects of class
'pdynmc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.pdynmc'
print(
  x,
  digits = max(3, getOption("digits") - 3),
  signif.stars = getOption("show.signif.stars"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.pdynmc_+3A_x">x</code></td>
<td>
<p>An object of class 'summary.pdynmc'.</p>
</td></tr>
<tr><td><code id="print.summary.pdynmc_+3A_digits">digits</code></td>
<td>
<p>An integer indicating the maximum number of digits to
display in the object.</p>
</td></tr>
<tr><td><code id="print.summary.pdynmc_+3A_signif.stars">signif.stars</code></td>
<td>
<p>Argument is defined as in <code><a href="base.html#topic+options">options</a></code>.</p>
</td></tr>
<tr><td><code id="print.summary.pdynmc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Print information on objects of class 'summary.pdynmc'.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
summary(m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 summary(m1)



</code></pre>

<hr>
<h2 id='residuals.pdynmc'>Extract Residuals of Fitted Model.</h2><span id='topic+residuals.pdynmc'></span>

<h3>Description</h3>

<p><code>residuals.pdynmc</code> extracts residuals from an object of class
'pdynmc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdynmc'
residuals(object, step = object$iter, na.rm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.pdynmc_+3A_object">object</code></td>
<td>
<p>An object of class 'pdynmc'.</p>
</td></tr>
<tr><td><code id="residuals.pdynmc_+3A_step">step</code></td>
<td>
<p>An integer denoting the iteration step for which fitted
values are extracted (defaults to last iteration step used for
obtaining parameter estimates).</p>
</td></tr>
<tr><td><code id="residuals.pdynmc_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical variable indicating whether missing values
should be removed from the vector of fitted values (defaults to
'FALSE').</p>
</td></tr>
<tr><td><code id="residuals.pdynmc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extract residuals from object of class 'pdynmc'.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
residuals(m1, na.rm = TRUE)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

## Further code example
 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 residuals(m1, na.rm = TRUE)



</code></pre>

<hr>
<h2 id='strucUPD.plot'>Plot on Structure of Unbalanced Panel Dataset.</h2><span id='topic+strucUPD.plot'></span>

<h3>Description</h3>

<p><code>strucUPD.plot</code> Plot on cross-section and longtudinal
structure of an object of class 'data.frame' containing
an unbalanced panel dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strucUPD.plot(
  object,
  i.name = NULL,
  t.name = NULL,
  col.range = c("gold", "darkblue"),
  plot.name = "Unbalanced panel structure",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strucUPD.plot_+3A_object">object</code></td>
<td>
<p>An object of class 'data.frame'.</p>
</td></tr>
<tr><td><code id="strucUPD.plot_+3A_i.name">i.name</code></td>
<td>
<p>Column name of cross-section identifier.</p>
</td></tr>
<tr><td><code id="strucUPD.plot_+3A_t.name">t.name</code></td>
<td>
<p>Column name of time-series identifier.</p>
</td></tr>
<tr><td><code id="strucUPD.plot_+3A_col.range">col.range</code></td>
<td>
<p>A vector of at least two colors used to
visualize the structure of the unbalanced panel data
set (defaults to 'gold' and 'darkblue'); must be a
valid argument to <a href="grDevices.html#topic+col2rgb">col2rgb</a>.</p>
</td></tr>
<tr><td><code id="strucUPD.plot_+3A_plot.name">plot.name</code></td>
<td>
<p>A vector indicating the title of the plot
(defaults to 'Unbalanced panel structure').</p>
</td></tr>
<tr><td><code id="strucUPD.plot_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a plot for an unbalanced panel dataset
contained in an object of class 'data.frame' that
visualizes the structure of the data. Cross-section
dimension is plotted on the ordinate, longitudinal
dimension on the abscissa. Each cross-sectional
observation is represented by a bar. Breaks in the
bars represent missing longitudinal observations.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch, Joachim Schnurbus
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

## Code example
strucUPD.plot(dat, i.name = "firm", t.name = "year")



</code></pre>

<hr>
<h2 id='summary.pdynmc'>Summary for Fitted Model Object.</h2><span id='topic+summary.pdynmc'></span>

<h3>Description</h3>

<p><code>summary.pdynmc</code> generates the summary for objects of class
'pdynmc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdynmc'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.pdynmc_+3A_object">object</code></td>
<td>
<p>An object of class 'pdynmc'.</p>
</td></tr>
<tr><td><code id="summary.pdynmc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class 'summary.pdynmc'.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
summary(m1, na.rm = TRUE)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 summary(m1)



</code></pre>

<hr>
<h2 id='variable.names.pdynmc'>Extract Names of Explanatory Variables of Fitted Model.</h2><span id='topic+variable.names.pdynmc'></span>

<h3>Description</h3>

<p><code>variable.names.pdynmc</code> extracts explanatory variables
from an object of class 'pdynmc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdynmc'
variable.names(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="variable.names.pdynmc_+3A_object">object</code></td>
<td>
<p>An object of class 'pdynmc'.</p>
</td></tr>
<tr><td><code id="variable.names.pdynmc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extract explanatory variables from an object of class
'pdynmc'.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
variable.names(m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 variable.names(m1)



</code></pre>

<hr>
<h2 id='vcov.pdynmc'>Extract Variance Covariance Matrix of Fitted Model.</h2><span id='topic+vcov.pdynmc'></span>

<h3>Description</h3>

<p><code>vcov.pdynmc</code> extracts variance covariance matrix of the
paramter estimates from an object of class 'pdynmc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdynmc'
vcov(object, step = object$iter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.pdynmc_+3A_object">object</code></td>
<td>
<p>An object of class 'pdynmc'.</p>
</td></tr>
<tr><td><code id="vcov.pdynmc_+3A_step">step</code></td>
<td>
<p>An integer denoting the iteration step for which
fitted values are extracted (defaults to last iteration step
used for obtaining parameter estimates).</p>
</td></tr>
<tr><td><code id="vcov.pdynmc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extract variance covariance matrix of the paramter estimates
from an object of class 'pdynmc'.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
vcov(m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 vcov(m1)



</code></pre>

<hr>
<h2 id='wald.fct'>Wald Test.</h2><span id='topic+wald.fct'></span>

<h3>Description</h3>

<p><code>wald.fct</code> computes F test statistics and corresponding p-values for
'pdynmc' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wald.fct(object, param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wald.fct_+3A_object">object</code></td>
<td>
<p>An object of class 'pdynmc'.</p>
</td></tr>
<tr><td><code id="wald.fct_+3A_param">param</code></td>
<td>
<p>A character string that denotes the null hypothesis. Choices are
time.dum (i.e., all time dummies are jointly zero), slope (i.e., all slope
coefficients are jointly zero), and all (i.e., all dummies and slope
coefficients are jointly zero).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The three available null hypothesis are: All time dummies are jointly zero,
all slope coefficients are jointly zero, all times dummies and slope
coefficients are jointly zero.
</p>


<h3>Value</h3>

<p>An object of class 'htest' which contains the F test statistic and
corresponding p-value for the tested null hypothesis.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(140:0), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
wald.fct(param = "all", m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

## Further code example
 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 wald.fct(m1, param = "all")



</code></pre>

<hr>
<h2 id='wmat'>Extract Weighting Matrix of Fitted Model.</h2><span id='topic+wmat'></span>

<h3>Description</h3>

<p><code>wmat</code> is a generic function for extracting the
weighting matrix of an object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wmat(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wmat_+3A_object">object</code></td>
<td>
<p>An object for which the weighting matrix is
desired.</p>
</td></tr>
<tr><td><code id="wmat_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extract weighting matrix from an object.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
wmat(m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 wmat(m1)



</code></pre>

<hr>
<h2 id='wmat.pdynmc'>Extract Weighting Matrix of Fitted Model.</h2><span id='topic+wmat.pdynmc'></span>

<h3>Description</h3>

<p><code>wmat.pdynmc</code> extracts weighting matrix from an object of
class 'pdynmc'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'pdynmc'
wmat(object, step = object$iter, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wmat.pdynmc_+3A_object">object</code></td>
<td>
<p>An object of class 'pdynmc'.</p>
</td></tr>
<tr><td><code id="wmat.pdynmc_+3A_step">step</code></td>
<td>
<p>An integer denoting the iteration step for which
fitted values are extracted (defaults to last iteration step
used for obtaining parameter estimates).</p>
</td></tr>
<tr><td><code id="wmat.pdynmc_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extract weighting matrix from an object of class
'pdynmc'.
</p>


<h3>Author(s)</h3>

<p>Markus Fritsch
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pdynmc">pdynmc</a></code> for fitting a linear dynamic panel data model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load data
data(ABdata, package = "pdynmc")
dat &lt;- ABdata
dat[,c(4:7)] &lt;- log(dat[,c(4:7)])
dat &lt;- dat[c(1:140), ]

## Code example
m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
wmat(m1)


## Load data
 data(ABdata, package = "pdynmc")
 dat &lt;- ABdata
 dat[,c(4:7)] &lt;- log(dat[,c(4:7)])

 m1 &lt;- pdynmc(dat = dat, varname.i = "firm", varname.t = "year",
    use.mc.diff = TRUE, use.mc.lev = FALSE, use.mc.nonlin = FALSE,
    include.y = TRUE, varname.y = "emp", lagTerms.y = 2,
    fur.con = TRUE, fur.con.diff = TRUE, fur.con.lev = FALSE,
    varname.reg.fur = c("wage", "capital", "output"), lagTerms.reg.fur = c(1,2,2),
    include.dum = TRUE, dum.diff = TRUE, dum.lev = FALSE, varname.dum = "year",
    w.mat = "iid.err", std.err = "corrected", estimation = "onestep",
    opt.meth = "none")
 wmat(m1)



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
