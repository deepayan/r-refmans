<!DOCTYPE html><html><head><title>Help for package kStatistics</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {kStatistics}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#countP'><p>Multiplicity of a multi-index partition.</p></a></li>
<li><a href='#cum2mom'><p>Cumulants in terms of moments</p></a></li>
<li><a href='#e_eBellPol'>
<p>Evaluation of exponential Bell polynomials</p></a></li>
<li><a href='#e_GCBellPol'><p>Evaluation of Generalized Complete Bell Polynomials</p></a></li>
<li><a href='#e_MFB'><p>Evaluation of Faa di Bruno's formula</p></a></li>
<li><a href='#eBellPol'>
<p>Exponential Bell polynomials</p></a></li>
<li><a href='#ff'><p>Falling factorial</p></a></li>
<li><a href='#GCBellPol'><p>Generalized Complete Bell Polynomial</p></a></li>
<li><a href='#gpPart'><p>General partition polynomial</p></a></li>
<li><a href='#intPart'><p>Integer partitions</p></a></li>
<li><a href='#kStatistics-package'>
<p>Unbiased Estimators for Cumulant Products and Faa Di Bruno's Formula</p></a></li>
<li><a href='#list2m'><p>List To Multiset</p></a></li>
<li><a href='#list2Set'><p>List To Set</p></a></li>
<li><a href='#m2Set'><p>Detecting equal columns in multi-index partitions</p></a></li>
<li><a href='#mCoeff'><p>Extraction of a number from a list</p></a></li>
<li><a href='#MFB'><p>Multivariate Faa di Bruno's formula</p></a></li>
<li><a href='#MFB2Set'><p>Convert the output of the MFB function into a vector</p></a></li>
<li><a href='#mkmSet'><p>Partitions of a multi-index</p></a></li>
<li><a href='#mkT'><p>Scomposition of a multi-index</p></a></li>
<li><a href='#mom2cum'><p>Moments in terms of cumulants</p></a></li>
<li><a href='#mpCart'><p>Join two lists</p></a></li>
<li><a href='#nKM'><p>Multivariate K-Statistics</p></a></li>
<li><a href='#nKS'><p>Simple K-Statistics</p></a></li>
<li><a href='#nPerm'><p>Permutations of a list or a vector</p></a></li>
<li><a href='#nPM'><p>Multivariate Polykays</p></a></li>
<li><a href='#nPolyk'><p>K-Statistics Master function</p></a></li>
<li><a href='#nPS'><p>Simple Polykays</p></a></li>
<li><a href='#nStirling2'><p>Stirling number of second kind</p></a></li>
<li><a href='#oBellPol'>
<p>Ordinary Bell polynomials</p></a></li>
<li><a href='#pCart'><p>Cartesian product</p></a></li>
<li><a href='#powS'><p>Power sums</p></a></li>
<li><a href='#pPart'><p>Partition polynomials</p></a></li>
<li><a href='#pPoly'><p>Product of Polynomials</p></a></li>
<li><a href='#Set2expr'><p>Conversion of a vector into a string</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Unbiased Estimators for Cumulant Products and Faa Di Bruno's
Formula</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-8</td>
</tr>
<tr>
<td>Author:</td>
<td>Elvira Di Nardo &lt;elvira.dinardo@unito.it&gt;, Giuseppe Guarino &lt;giuseppe.guarino@rete.basilicata.it&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Giuseppe Guarino &lt;giuseppe.guarino@rete.basilicata.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for estimate (joint) cumulants and (joint) products of cumulants of a random sample using (multivariate) k-statistics and (multivariate) polykays, unbiased estimators with minimum variance. Tools for generating univariate and multivariate Faa di Bruno's formula and related polynomials, such as Bell polynomials, generalized complete Bell polynomials, partition polynomials and generalized partition polynomials. For more details see Di Nardo E., Guarino G., Senato D. (2009) &lt;<a href="https://arxiv.org/abs/0807.5008">arXiv:0807.5008</a>&gt;, &lt;<a href="https://arxiv.org/abs/1012.6008">arXiv:1012.6008</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-08 10:19:06 UTC; giuseppe.guarino</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-08 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='countP'>Multiplicity of a multi-index partition.</h2><span id='topic+countP'></span>

<h3>Description</h3>

<p>The function computes the multiplicity of a multi-index partition. Note that a
multi-index partition corresponds to a subdivision of a multiset having the input multi-index 
as multiplicities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>countP( v=c(1) )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countP_+3A_v">v</code></td>
<td>
<p>vector or list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the partitions of an integer, let's say 3, that are <code>[1,1,1],[1,2],[3]</code> such that
<code>1+1+1=1+2=3</code>. Consider the partitions of a set with cardinality 3, let's say <code>[a1, a2, a3]</code>
</p>

<table>
<tr>
 <td style="text-align: left;"><code>(I)</code> </td><td style="text-align: left;">   <code>[[a1], [a2], [a3]], [[a1],[a2,a3]], [[a2],[a1,a3]], [[a3],[a1,a2]], [[a1,a2,a3]]</code>.</td>
</tr>

</table>

<p>The multiplicity of a partition of 3 is the number of partitions of <code>[a1, a2, a3]</code> in blocks having that
partition as cardinalities. In the example, we have 
</p>

<table>
<tr>
 <td style="text-align: center;">
 a) </td><td style="text-align: left;"> 1 partition in 3 blocks of cardinalities 1, that is 
<code>[[a1], [a2], [a3]]</code> corresponding to <code>[1,1,1]</code> </td>
</tr>
<tr>
 <td style="text-align: center;"> 
b) </td><td style="text-align: left;"> 1 partition in 1 block of cardinalities 3, that is 
<code>[[a1,a2,a3]]</code> corresponding to <code>[3]</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
c) </td><td style="text-align: left;"> 3 partitions in 2 blocks of cardinalities 1 and 2 respectively, that is</td>
</tr>
<tr>
 <td style="text-align: center;">
   </td><td style="text-align: left;"> <code>[[a1],[a2,a3]], [[a2],[a1,a3]], [[a3],[a1,a2]]</code>.</td>
</tr>

</table>

<p>So running <code>countP(c(1,2))</code> we get 3, running <code>countP(c(1,1,1))</code> or <code>countP(c(3))</code> we get 1. <br /> <br />
The same device can be used to find the multiplicity of a subdivision. The subdivisions of a multiset are 
obtained as follows: assume all distinct the elements of the multiset, determine all the corresponding set partitions 
and then replace each element in each block with the original one. For example, consider the multiset <code>[a, a, a]</code>
having the integer 3 as multiplicity. Assuming all distinct the elements of the multiset, the partitions of <code>[a1, a2, a3]</code>
are given in <code>(I)</code>. Now replace <code>a1&lt;-a, a2&lt;-a, a3&lt;-a</code> and get 
</p>

<table>
<tr>
 <td style="text-align: left;"><code>[[a], [a], [a]], [[a], [a,a]], [[a], [a,a]], [[a], [a,a]], [[a,a,a]]</code></td>
</tr>

</table>
<p>.
Note that the partitions 
</p>

<table>
<tr>
 <td style="text-align: left;"><code>[[a1,a2], [a3]], [[a1,a3], [a2]], [[a2,a3], [a1]]</code></td>
</tr>

</table>

<p>give rise to the same subdivision <code>[[a,a], [a]]</code>. Then the multiplicity of <code>[[a,a], [a]]</code> is 3. Therefore 
the subdivisions of <code>[a, a, a,]</code>  are 
</p>

<table>
<tr>
 <td style="text-align: left;"><code>[[a], [a], [a]], [[a], [a,a]], [[a,a,a]]</code>.</td>
</tr>

</table>

<p>The multiplicity of the subdivision <code>[[a], [a,a]]</code> is 3, as for the partition <code>[1,2]</code> of the integer 3. 
The multiplicity of the subdivisions <code>[[a], [a], [a]]</code> and <code>[[a,a,a]]</code> is 1, as for the partitions 
<code>[1,1,1]</code> and <code>[3]</code> of the integer 3 respectively. Thus running <code>countP(c(1,2))</code> we get 3, that is 
<br />
</p>

<table>
<tr>
 <td style="text-align: center;">
a) </td><td style="text-align: left;"> the multiplicity of the subdivision <code>[[a,a], [a]]</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
b) </td><td style="text-align: left;"> the number of partitions of the set <code>[a1, a2, a3]</code> in two blocks, one of cardinality 1 and the other </td>
</tr>
<tr>
 <td style="text-align: center;"> 
   </td><td style="text-align: left;"> of cardinality 2 </td>
</tr>
<tr>
 <td style="text-align: center;">
c) </td><td style="text-align: left;"> the number of partitions of the set <code>[a1, a2, a3]</code> corresponding to the partition <code>[1,2]</code> of </td>
</tr>
<tr>
 <td style="text-align: center;">
   </td><td style="text-align: left;"> the integer 3. 
</td>
</tr>

</table>

<p>Now consider the partition of a multi-index, let's say (4,2). One of the partitions of (4,2) is the matrix 
(see the output of the <code><a href="#topic+mkmSet">mkmSet</a></code> function) <br />  
<code style="white-space: pre;">&#8288;        
               0  1  1  2
(II)          1  0  0  1&#8288;</code>
<br /> <br />
as <code>1+1+2=4</code> and <code>1+1=2</code>. The partition <code>(II)</code> corresponds to the subdivision <code>[[b], [a], [a], [a,a,b]]</code> 
of the multiset <code>[a,a,a,a,b,b]</code> having the multi-index (4,2) as multiplicities. Indeed each column <code>(i,j)</code> gives 
the instances <code>i</code> and <code>j</code> of <code>a</code> and <code>b</code> in a block of the subdivision. Running <code>countP</code>
<code>(list(c(0,1), c(1,0), c(1,0), c(2,1)))</code> we get 12. This multiplicity gives the number of partitions of the set <code>[a1,a2,a3,</code>
<code>a4,b1,b2]</code> corresponding to the subdivision <code>[[b], [a], [a], [a,a,b]]</code> after the 
replacement 
<code>a1&lt;-a, a2&lt;-a,</code> <code>a3&lt;-a, a4&lt;-a, b1&lt;-b, b2&lt;-b.</code> <br /> <br />
Note that the input of the <code><a href="#topic+countP">countP</a></code> function does not necessarily be in lexicographic order. To find all the partitions 
of a multi-index see the <code><a href="#topic+mkmSet">mkmSet</a></code> function.</p>


<h3>Value</h3>

<table>
<tr><td><code>integer</code></td>
<td>
<p>the multiplicity of the given item</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Called by the <code><a href="#topic+mkmSet">mkmSet</a></code> and <code><a href="#topic+nPS">nPS</a></code> functions in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>E. Di Nardo, G. Guarino, D. Senato (2008) An unifying framework for k-statistics, polykays and their generalizations. 
Bernoulli. 14(2), 440-468. (download from <a href="https://arxiv.org/pdf/math/0607623.pdf">https://arxiv.org/pdf/math/0607623.pdf</a>) 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkmSet">mkmSet</a></code>,
<code><a href="#topic+mCoeff">mCoeff</a></code>,
<code><a href="#topic+nStirling2">nStirling2</a></code>,
<code><a href="#topic+intPart">intPart</a></code>,
<code><a href="#topic+ff">ff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Return 3 which is the multiplicity of [1,2], partition of the integer 3, or 
# of [[a],[a,a]], subdivision of the multiset [a,a,a]
countP(c(1,2))
  
# Return 15 which is the multiplicity of [4,2], partition of the integer 6, or
# of [[a,a,a,a],[a,a]], subdivision of the multiset [a,a,a,a,a,a]
countP(c(4,2))
  
# Return 18 which is the multiplicity of 
#  0 0 1 1 2
#  1 2 0 0 0
# partition of the multi-index (4,3), or of [[b],[b,b],[a],[a],[a,a]], subdivision  of 
# the multiset [a,a,a,a,b,b,b]
countP( list(c(2,0), c(1,0), c(1,0), c(0,1),c(0,2)) )
 
</code></pre>

<hr>
<h2 id='cum2mom'>Cumulants in terms of moments
</h2><span id='topic+cum2mom'></span>

<h3>Description</h3>

<p>The function computes a simple or a multivariate cumulant in terms of simple or multivariate moments.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cum2mom(n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cum2mom_+3A_n">n</code></td>
<td>
<p>integer or vector of integers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Faa di Bruno's formula (the  <code><a href="#topic+MFB">MFB</a></code> function) gives the coefficients of the exponential formal power series 
<code>f[g()]</code> where <code>f</code> and <code>g</code> are exponential formal power series too. Simple cumulants 
are expressed in terms of simple moments using the Faa di Bruno's formula obtained from the  <code><a href="#topic+MFB">MFB</a></code> function in the case 
&quot;composition of univariate <code>f</code> with univariate <code>g</code>&quot; with <code>f[i]=(-1)^(i-1)*(i-1)!, g[i]=m[i]</code> 
for <code>i</code> from 1 to <code>n</code> and <code>m[i]</code> moments. Multivariate cumulants are expressed in terms 
of multivariate moments using the Faa di Bruno's formula obtained from the  <code><a href="#topic+MFB">MFB</a></code> function in the case &quot;composition 
of univariate <code>f</code> with multivariate <code>g</code>&quot;. In such a case the coefficients of <code>g</code> are the multivariate moments.</p>


<h3>Value</h3>

<table>
<tr><td><code>string</code></td>
<td>
<p>the expression of the cumulant in terms of moments</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The value of the first parameter is the same as the <code><a href="#topic+MFB">MFB</a></code> function in the univariate with 
univariate case composition and in the univariate with multivariate case composition.</p>


<h3>Note</h3>

<p>This function calls the <code><a href="#topic+MFB">MFB</a></code> function in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>E. Di Nardo, G. Guarino, D. Senato (2008) An unifying framework for k-statistics, polykays and their generalizations. 
Bernoulli. 14(2), 440-468. (download from <a href="https://arxiv.org/pdf/math/0607623.pdf">https://arxiv.org/pdf/math/0607623.pdf</a>) 
</p>
<p>E. Di Nardo E., G. Guarino, D. Senato (2011) A new algorithm for computing the multivariate Faa di Bruno's formula. 
Appl. Math. Comp. 217, 6286&ndash;6295. (download from <a href="https://arxiv.org/abs/1012.6008">https://arxiv.org/abs/1012.6008</a>)
</p>
<p>P. McCullagh, J. Kolassa (2009) Scholarpedia, 4(3):4699. <a href="http://www.scholarpedia.org/article/Cumulants">http://www.scholarpedia.org/article/Cumulants</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFB">MFB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return the simple cumulant k[5] in terms of the simple moments m[1],..., m[5].
cum2mom(5)

# Return the multivariate cumulant k[3,1] in terms of the multivariate moments m[i,j] for 
# i=0,1,2,3 and j=0,1.
cum2mom(c(3,1))
</code></pre>

<hr>
<h2 id='e_eBellPol'>
Evaluation of exponential Bell polynomials
</h2><span id='topic+e_eBellPol'></span>

<h3>Description</h3>

<p>The function evaluates a complete or a partial exponential Bell polynomial 
(output of the <code><a href="#topic+eBellPol">eBellPol</a></code> function) when its variables are substituted with 
numerical values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>e_eBellPol(n=1,m=0,v=c(rep(1,n)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e_eBellPol_+3A_n">n</code></td>
<td>
<p>integer, the degree of the polynomial</p>
</td></tr>
<tr><td><code id="e_eBellPol_+3A_m">m</code></td>
<td>
<p>integer, the fixed degree of each monomial in the polynomial</p>
</td></tr>
<tr><td><code id="e_eBellPol_+3A_v">v</code></td>
<td>
<p>vector,  the numerical values in place of the variables of the polynomial</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The <code><a href="#topic+eBellPol">eBellPol</a></code> function generates a complete or a partial exponential Bell polynomial
in the variables <code>y[1],..., y[n-m+1]</code>. The <code><a href="#topic+e_eBellPol">e_eBellPol</a></code> function computes the value assumed 
by this polynomial when its variables are substituted with numerical values.</p>


<h3>Value</h3>

<table>
<tr><td><code>numerical value</code></td>
<td>
<p>the value assumed by the polynomial.</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>By default, the function returns the Stirling numbers of second kind.</p>


<h3>Note</h3>

<p>This function calls the <code><a href="#topic+eBellPol">eBellPol</a></code> function in the <code>kStatistics</code> package.</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>C.A. Charalambides (2002) Enumerative Combinatoris, Chapman &amp; Haii/CRC. 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2008) An unifying framework for k-statistics, polykays and their generalizations. 
Bernoulli. 14(2), 440-468. (download from <a href="https://arxiv.org/pdf/math/0607623.pdf">https://arxiv.org/pdf/math/0607623.pdf</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2008) Symbolic computation of moments of sampling distributions. 
Comp. Stat. Data Analysis. 52(11), 4909-4922. (download from <a href="https://arxiv.org/abs/0806.0129">https://arxiv.org/abs/0806.0129</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2011) A new algorithm for computing the multivariate Faa di Bruno's formula. 
Appl. Math. Comp. 217, 6286&ndash;6295. (download from <a href="https://arxiv.org/abs/1012.6008">https://arxiv.org/abs/1012.6008</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eBellPol">eBellPol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Return S(5,3) = 25 (where S=Stirling number of second kind)  
e_eBellPol(5,3) 
#
# OR (same output) 
#
e_eBellPol(5,3,c(1,1,1,1,1))

# Return  B5=52 (where B5 is the 5-th Bell number)   
e_eBellPol(5) 
#
# OR (same output) 
#  
e_eBellPol(5,0) 
#
# OR (same output) 
# 
e_eBellPol(5,0,c(1,1,1,1,1))

# Return  s(5,3) = 35 (where s=Stirling number of first kind)  
e_eBellPol(5,3,c(1,-1,2,-6,24))

</code></pre>

<hr>
<h2 id='e_GCBellPol'>Evaluation of Generalized Complete Bell Polynomials</h2><span id='topic+e_GCBellPol'></span>

<h3>Description</h3>

<p>The function evaluates a generalized complete Bell polynomial (output of the <code><a href="#topic+GCBellPol">GCBellPol</a></code> function) when its variables and/or its coefficients are substituted with 
numerical values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>e_GCBellPol(pv = c(), pn = 0, pyc = c(), pc = c(), b = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e_GCBellPol_+3A_pv">pv</code></td>
<td>
<p>vector of integers, the subscript of the polynomial</p>
</td></tr>
<tr><td><code id="e_GCBellPol_+3A_pn">pn</code></td>
<td>
<p>integer, the number of variables</p>
</td></tr>
<tr><td><code id="e_GCBellPol_+3A_pyc">pyc</code></td>
<td>
<p>vector, the numerical values into the variables [optional], or the string with 
the direct assignment into the variables and/or the coefficients</p>
</td></tr>
<tr><td><code id="e_GCBellPol_+3A_pc">pc</code></td>
<td>
<p>vector, the numerical values into the coefficients, [optional if <code>pyc</code> is 
a string]</p>
</td></tr>
<tr><td><code id="e_GCBellPol_+3A_b">b</code></td>
<td>
<p>boolean, if <code>TRUE</code> the function prints the list of all the assignments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code><a href="#topic+GCBellPol">GCBellPol</a></code> returns the coefficient of the multivariate exponential formal power series 
<code>exp(y[1] g1(z1,...,zm) + ... + y[n] gn(z1,...,zm))</code>, where <code>y[1],...,y[n]</code> are variables corresponding to the
subscript <code>pv</code>. The function <code><a href="#topic+e_GCBellPol">e_GCBellPol</a></code> allows us to substitute the coefficients of 
the power series <code>g1,...,gn</code> and/or  the variables <code>y[1],...,y[n]</code> with numerical values. These 
values are passed to the <code><a href="#topic+e_GCBellPol">e_GCBellPol</a></code> function through the third and the fourth input 
parameter. In the resulting expression, the <code>y</code>'s and the <code>g</code>'s are managed in lexicographic order. 
There is one further input boolean parameter: when equal to <code>TRUE</code>, the function prints the list of all 
the assignments. See the examples for more details on the employment of this boolean parameter 
when the coefficients and/or the variables of the polynomial are substituted with numerical values.</p>


<h3>Value</h3>

<table>
<tr><td><code>string or numerical</code></td>
<td>
<p>the evaluation of the polynomial</p>
</td></tr></table>


<h3>Warning</h3>

<p>The value of the first parameter is the same as the <code><a href="#topic+mkmSet">mkmSet</a></code> function.</p>


<h3>Note</h3>

<p>Called by the <code><a href="#topic+GCBellPol">GCBellPol</a></code> function in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>E. Di Nardo (2016) On multivariable cumulant polynomial sequence with applications. Jour. 
Algebraic Statistics 7(1), 72-89.  (download from <a href="https://arxiv.org/abs/1606.01004">https://arxiv.org/abs/1606.01004</a>)
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2011) A new algorithm for computing the multivariate Faa di Bruno's formula. 
Appl. Math. Comp. 217, 6286&ndash;6295. (download from <a href="https://arxiv.org/abs/1012.6008">https://arxiv.org/abs/1012.6008</a>)
</p>
<p>E. Di Nardo, M. Marena, P. Semeraro (2020) On non-linear dependence of multivariate subordinated Levy processes.
In press Stat. Prob. Letters (download from <a href="https://arxiv.org/abs/2004.03933">https://arxiv.org/abs/2004.03933</a>) 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkmSet">mkmSet</a></code>,
<code><a href="#topic+MFB">MFB</a></code>,
<code><a href="#topic+GCBellPol">GCBellPol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#-------------------------------------------------------------------------------#
# Evaluation of the generalized complete Bell polynomial with subscript 2
#-------------------------------------------------------------------------------#
#
# The polynomial (y^2)g[1]^2 + (y^1)g[2], output of GCBellPol( c(2),1 ), when
# g[1]=3 and g[2]=4, that is 9(y^2) + 4(y)
#
e_GCBellPol( c(2),1,,c(3,4) )
#
# OR (same output)
#
e_GCBellPol( c(2),1,"g[1]=3,g[2]=4" )

# Check the assignments setting the boolean parameter equals to TRUE, that is g[1]=3 
# and g[2]=4
e_GCBellPol( c(2),1,,c(3,4),TRUE )

# The numerical value of (y^2)g[1]^2 + (y^1)g[2], output of GCBellPol( c(2),1 ), when 
# g[1]=3 and g[2]=4 and y=7, that is 469
#
e_GCBellPol( c(2),1,c(7),c(3,4) )
#
# OR (same output)
#
e_GCBellPol( c(2),1,"y=7, g[1]=3,g[2]=4" )

# Check the assignments setting the boolean parameter equals to TRUE, that is g[1]=3 
# and g[2]=4 and y=7
e_GCBellPol( c(2),1,c(7),c(3,4),TRUE )

#-------------------------------------------------------------------------------#
# Evaluation of the generalized complete Bell polynomial with subscript (2,1)
#-------------------------------------------------------------------------------#
#
# The polynomial 2(y^2)g[1,1]g[1,0] + (y^3)g[1,0]^2g[0,1] + (y)g[2,1] + (y^2)
# g[2,0]g[0,1], output of GCBellPol( c(2,1),1 ), when g[0,1]=1, g[1,0]=2, g[1,1]=3, 
# g[2,0]=4, g[2,1]=5, that is 16(y^2) + 4(y^3) + 5(y)
#
e_GCBellPol(c(2,1),1,,c(1:5))
#
# OR (same output)
#
e_GCBellPol(c(2,1),1,,c(1,2,3,4,5))
#
# OR (same output)
#
e_GCBellPol( c(2,1),1,"g[0,1]=1, g[1,0]=2, g[1,1]=3, g[2,0]=4, g[2,1]=5" )

# Check the assignments setting the boolean parameter equals to TRUE, that is
# g[0,1]=1, g[1,0]=2, g[1,1]=3, g[2,0]=4, g[2,1]=5
e_GCBellPol( c(2,1),1,,c(1:5), TRUE )

# The numerical value of 2(y^2)g[1,1]g[1,0] + (y^3)g[1,0]^2g[0,1] + (y)g[2,1] + (y^2)
# g[2,0]g[0,1], output of \code{\link{GCBellPol}}( c(2,1),1 ) when g[0,1]=1, g[1,0]=2, 
# g[1,1]=3, g[2,0]=4, g[2,1]=5 and y=7, that is 2191
#
e_GCBellPol( c(2,1),1,c(7),c(1:5) )
#
# OR (same output)
#
e_GCBellPol( c(2,1),1,"y=7, g[0,1]=1, g[1,0]=2, g[1,1]=3, g[2,0]=4, g[2,1]=5" )

# Check the assignments setting the boolean parameter equals to TRUE, that is 
# g[0,1]=1, g[1,0]=2, g[1,1]=3, g[2,0]=4, g[2,1]=5, y=7
e_GCBellPol( c(2,1),1,c(7),c(1:5) )

#-----------------------------------------------------------------------------------#
# Evaluation of the generalized complete Bell Polynomial with subscript (1,1)
#-----------------------------------------------------------------------------------#

# The polynomial (y1)g1[1,1] + (y1^2)g1[1,0]g1[0,1] + (y2)g2[1,1] + (y2^2)g2[1,0]
# g2[0,1] + (y1)(y2)g1[1,0]g2[0,1] + (y1)(y2)g1[0,1]g2[1,0], output of GCBellPol(c(1,1),2) 
# when g1[0,1]=1, g1[1,0]=2, g1[1,1]=3, g2[0,1]=4, g2[1,0]=5, g2[1,1]=6, that is 
# 3(y1) + 2(y1^2) + 6(y2) + 20(y2^2) + 13(y1)(y2)
#
e_GCBellPol( c(1,1),2,,c(1:6))
#
# OR (same output)
#
e_GCBellPol(c(1,1),2,,c(1,2,3,4,5,6))
#
# OR (same output)
# 
e_GCBellPol( c(1,1),2,"g1[0,1]=1, g1[1,0]=2, g1[1,1]=3, g2[0,1]=4, g2[1,0]=5, g2[1,1]=6" )


# Check the assignments setting the boolean parameter equals to TRUE, that is 
# g1[0,1]=1, g1[1,0]=2, g1[1,1]=3, g2[0,1]=4, g2[1,0]=5, g2[1,1]=6
e_GCBellPol( c(1,1),2,,c(1:6), TRUE )

# The numerical value of (y1)g1[1,1] + (y1^2)g1[1,0]g1[0,1] + (y2)g2[1,1] + (y2^2)g2[1,0]
# g2[0,1] + (y1)(y2)g1[1,0]g2[0,1] + (y1)(y2)g1[0,1]g2[1,0], output of GCBellPol(c(1,1),2) 
# when g1[0,1]=1, g1[1,0]=2, g1[1,1]=3, g2[0,1]=4, g2[1,0]=5, y1=7 and y2=8, that is 2175
e_GCBellPol( c(1,1),2,c(7,8),c(1:6))
#
# OR (same output)
# 
cVal&lt;-"y1=7, y2=8, g1[0,1]=1, g1[1,0]=2, g1[1,1]=3, g2[0,1]=4, g2[1,0]=5,g2[1,1]=6"
e_GCBellPol(c(1,1),2,cVal)

# To recover which coefficients and variables are involved in the generalized complete 
# Bell polynomial, run the e_GCBellPol function without any assignment. 
# The error message prints which coefficients and variables are involved, that is
# Error in e_GCBellPol(c(1, 1), 2) : 
#   The third parameter must contain the 2 values of y: y1 y2. 
#   The fourth parameter must contain the 6 values of g: 
#       g1[0,1] g1[1,0] g1[1,1] g2[0,1] g2[1,0] g2[1,1]

# To assign correctly the values to the coefficients and the variables: 
# 1) run e_GCBellPol(c(1, 1), 2) and get the errors with the indication of the involved 
#    coefficients and variables, that is 
#      The third parameter must contain the 2 values of y: y1 y2
#      The fourth parameter must contain the 6 values of g: 
#          g1[0,1] g1[1,0] g1[1,1] g2[0,1] g2[1,0] g2[1,1]
# 2) initialize g1[0,1] g1[1,0] g1[1,1] g2[0,1] g2[1,0] g2[1,1] with - for example - the 
#    first 6 integer numbers and do the same for y1 and y2, that is
#          e_GCBellPol(c(1,1),2, c(1,2), c(1,2,3,4,5,6), TRUE)
# 3) trought the boolean value TRUE, recover the string y1=1, y2=1, g1[0,1]=1, g1[1,0]=2, 
#    g1[1,1]=3, g2[0,1]=4, g2[1,0]=5, g2[1,1]=6 
# 4) copy and past the string in place of "..." when run 
#    e_GCBellPol(c(1,1),2,"...")
# 5) change the assignments if necessary
cVal&lt;-"y1=10,y2=11,g1[0,1]=1.1,g1[1,0]=-2,g1[1,1]=3.2,g2[0,1]=-4,g2[1,0]=10,g2[1,1]=6"
e_GCBellPol(c(1,1), 2,cVal) 
</code></pre>

<hr>
<h2 id='e_MFB'>Evaluation of Faa di Bruno's formula</h2><span id='topic+e_MFB'></span>

<h3>Description</h3>

<p>The function evaluates the Faa di Bruno's formula, output of the <code><a href="#topic+MFB">MFB</a></code> 
function, when the coefficients of the exponential formal power series <code>f</code> and <code>g1,...,gn</code> 
in the composition <code>f[g1(),...,gn()]</code> are substituted with numerical values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>e_MFB(pv = c(), pn = 0, pf = c(), pg = c(), b = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e_MFB_+3A_pv">pv</code></td>
<td>
<p>vector of integers, the subscript of Faa di Bruno's formula</p>
</td></tr>
<tr><td><code id="e_MFB_+3A_pn">pn</code></td>
<td>
<p>integer, the number of the inner formal power series <code>"g"</code></p>
</td></tr>
<tr><td><code id="e_MFB_+3A_pf">pf</code></td>
<td>
<p>vector, the numerical values in place of the coefficients of the outer formal power series 
<code>"f"</code> or the string with the direct assignments in place of the coefficients of both <code>"f"</code> and <code>"g"</code></p>
</td></tr>
<tr><td><code id="e_MFB_+3A_pg">pg</code></td>
<td>
<p>vector, the numerical values in place of the coefficients of the inner formal power series <code>"g"</code>  
[Optional if <code>pf</code> is a string]</p>
</td></tr>
<tr><td><code id="e_MFB_+3A_b">b</code></td>
<td>
<p>boolean</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of the <code><a href="#topic+MFB">MFB</a></code> function is a coefficient of the exponential formal 
power series compositions in the cases 
</p>

<table>
<tr>
 <td style="text-align: center;">
a) </td><td style="text-align: left;"> univariate <code>f</code> with univariate <code>g</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
b) </td><td style="text-align: left;"> univariate <code>f</code> with multivariate <code>g</code> </td>
</tr>
<tr>
 <td style="text-align: center;">
c) </td><td style="text-align: left;"> multivariate <code>f</code> with multivariates <code>{gi}</code></td>
</tr>

</table>

<p>The <code><a href="#topic+e_MFB">e_MFB</a></code> function evaluates this coefficient when the coefficients of <code>f</code> and 
<code>{gi}</code> are substituted with numerical values. These values are passed to the <code><a href="#topic+e_MFB">e_MFB</a></code> 
function trough the third and the fourth input parameter. There is one 
further input boolean parameter: when equal to <code>TRUE</code>, the function prints the list of all 
the assignments. See the examples for more details on how to use this boolean parameter when the expression 
of the coefficients of <code>f</code> and <code>{gi}</code> becomes more complex.</p>


<h3>Value</h3>

<table>
<tr><td><code>numerical</code></td>
<td>
<p>the evaluation of Faa di Bruno's formula</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The value of the first parameter is the same as the <code><a href="#topic+mkmSet">mkmSet</a></code> function.</p>


<h3>Note</h3>

<p>Called from the <code><a href="#topic+MFB">MFB</a></code> function in the <code>kStatistics</code> package.</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>E. Di Nardo, G. Guarino, D. Senato (2008) An unifying framework for k-statistics, polykays and their generalizations. 
Bernoulli. Vol. 14(2), 440-468. (download from <a href="http://www.elviradinardo.it/lavori1.html">http://www.elviradinardo.it/lavori1.html</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2008) Symbolic computation of moments of sampling distributions. 
Comp. Stat. Data Analysis Vol. 52(11), 4909-4922, (download from <a href="http://www.elviradinardo.it/lavori1.html">http://www.elviradinardo.it/lavori1.html</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2011) A new algorithm for computing the multivariate Faa di Bruno's formula. 
Appl. Math. Comp. 217, 6286&ndash;6295. (download from <a href="https://arxiv.org/abs/1012.6008">https://arxiv.org/abs/1012.6008</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkmSet">mkmSet</a></code>,
<code><a href="#topic+MFB">MFB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# The numerical value of f[1]g[1,1] + f[2]g[1,0]g[0,1], that is the coefficient of z1z2 in 
# f(g1(z1,z2),g2(z1,z2))) output of MFB(c(1,1),1) when 
# f[1] = 5 and f[2] = 10 
# g[0,1]=3,  g[1,0]=6,  g[1,1]=9
e_MFB(c(1,1),1, c(5,10), c(3,6,9))

# Same as the previous example, with a string of assignments as third input parameter
e_MFB(c(1,1),1, "f[1]=5, f[2]=10, g[0,1]=3, g[1,0]=6, g[1,1]=9")


# Use the boolean parameter to verify the assignments to the coefficients of "f" and "g", 
# that is f[1]=5, f[2]=10, g[0,1]=3, g[1,0]=6, g[1,1]=9
e_MFB(c(1,1),1, c(5,10), c(3,6,9), TRUE)

# To recover which coefficients are involved, run the function without any assignment. 
# The error message recalls which coefficients are necessary, that is
# e_MFB(c(1,1),1)
# Error in e_MFB(c(1, 1), 1) : 
#   The third parameter must contain the 2 values of f: f[1] f[2]. 
#   The fourth parameter must contain the 3 values of g: g[0,1] g[1,0] g[1,1]

# To assign correctly the values to the coefficients of "f" and "g" when the functions 
# become more complex:
# 1) run e_MFB(c(1,1),2) and get the errors with the indication of the involved coefficients 
#    of "f" and "g", that is 
#      The third parameter must contain the 5 values of f: 
#                      f[0,1] f[0,2] f[1,0] f[1,1] f[2,0]
#      The fourth parameter must contain the 6 values of g: 
#                      g1[0,1] g1[1,0] g1[1,1] g2[0,1] g2[1,0] g2[1,1]"
# 2) initialize f[0,1] f[0,2] f[1,0] f[1,1] f[2,0] with - for example - the first 5 integer 
#    numbers and do the same for g1[0,1] g1[1,0] g1[1,1] g2[0,1] g2[1,0] g2[1,1], that is
#    e_MFB(c(1,1),2, c(1:5), c(1:6), TRUE)
# 3) trought the boolean value TRUE, recover the string f[0,1]=1, f[0,2]=2, f[1,0]=3, f[1,1]=4, 
#    f[2,0]=5, g1[0,1]=1, g1[1,0]=2, g1[1,1]=3, g2[0,1]=4, g2[1,0]=5, g2[1,1]=6
# 4) copy and past the string in place of " ... " when run 
#    e_MFB(c(1,1),1," ... ")
# 5) change the assignments if necessary
cfVal&lt;-"f[0,1]=2, f[0,2]=5, f[1,0]=13, f[1,1]=-4, f[2,0]=0"
cgVal&lt;-"g1[0,1]=-2.1, g1[1,0]=2,g1[1,1]=3.1, g2[0,1]=5, g2[1,0]=0, g2[1,1]=6.1"
cVal&lt;-paste0(cfVal,",",cgVal)
e_MFB(c(1,1),2,cVal)
</code></pre>

<hr>
<h2 id='eBellPol'>
Exponential Bell polynomials
</h2><span id='topic+eBellPol'></span>

<h3>Description</h3>

<p>The function generates a complete or a partial exponential Bell polynomial.</p>


<h3>Usage</h3>

<pre><code class='language-R'>eBellPol(n = 1, m = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eBellPol_+3A_n">n</code></td>
<td>
<p>integer, the degree of the polynomial</p>
</td></tr>
<tr><td><code id="eBellPol_+3A_m">m</code></td>
<td>
<p>integer, the fixed degree of each monomial in the polynomial</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Faa di Bruno's formula gives the coefficients of the exponential formal power series composition 
<code>f[g()]</code> obtained from the composition of the exponential formal power series <code>f</code> with <code>g</code>. 
Complete exponential Bell polynomials in the variables <code>y[1],...,y[n]</code> are generated by setting 
<code>f[i]=1</code> and <code>g[i]=y[i]</code>, for each <code>i</code> from <code>1</code> to <code>n</code>. Partial exponential Bell 
polynomials are polynomials in the variables <code>y[1],...,y[n-m+1]</code> with fixed degree <code>m</code>
for each of the involved monomials. Partial exponential Bell polynomials are recovered from 
Faa di Bruno's formula by setting <code>g[i]=y[i]</code> for each <code>i</code> from <code>1</code> to <code>n</code> and 
<code>f[i]=1</code> if <code>i=m, f[i]=0</code> otherwise.
</p>


<h3>Value</h3>

<table>
<tr><td><code>string</code></td>
<td>
<p>the expression of the exponential Bell polynomial</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The value of the first parameter is the same as the <code><a href="#topic+MFB">MFB</a></code> function in 
the univariate with univariate composition.</p>


<h3>Note</h3>

<p>This function calls the <code><a href="#topic+MFB">MFB</a></code> function in the <code>kStatistics</code> package.</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>C.A. Charalambides (2002) Enumerative Combinatoris, Chapman &amp; Haii/CRC. 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2008) An unifying framework for k-statistics, polykays and their generalizations. 
Bernoulli. 14(2), 440-468. (download from <a href="https://arxiv.org/pdf/math/0607623.pdf">https://arxiv.org/pdf/math/0607623.pdf</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2008) Symbolic computation of moments of sampling distributions. 
Comp. Stat. Data Analysis. 52(11), 4909-4922. (download from <a href="https://arxiv.org/abs/0806.0129">https://arxiv.org/abs/0806.0129</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2011) A new algorithm for computing the multivariate Faa di Bruno's formula. 
Appl. Math. Comp. 217, 6286&ndash;6295. (download from <a href="https://arxiv.org/abs/1012.6008">https://arxiv.org/abs/1012.6008</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFB">MFB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Return the complete exponential Bell Polynomial for n=5, that is 
# (y1^5) + 10(y1^3)(y2) + 15(y1)(y2^2) + 10(y1^2)(y3) + 10(y2)(y3) + 5(y1)(y4) + (y5)
eBellPol(5) 
# OR (same output)
eBellPol(5,0)

# Return the partial exponential Bell Polynomial for n=5 and m=3, that is 
# 15(y1)(y2^2) + 10(y1^2)(y3)
eBellPol(5,3)

</code></pre>

<hr>
<h2 id='ff'>Falling factorial</h2><span id='topic+ff'></span>

<h3>Description</h3>

<p>The function computes the descending (falling) factorial of a positive integer <code>n</code> 
with respect to a positive integer <code>k</code> less or equal to <code>n</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff( n=1, k ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_+3A_n">n</code></td>
<td>
<p>integer</p>
</td></tr>
<tr><td><code id="ff_+3A_k">k</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Run <code>ff(n, k)</code> to get <code>n(n-1)(n-2).....(n-k+1)</code>.
</p>


<h3>Value</h3>

<table>
<tr><td><code>integer</code></td>
<td>
<p>the descending factorial</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkmSet">mkmSet</a></code>,
<code><a href="#topic+countP">countP</a></code>,
<code><a href="#topic+nStirling2">nStirling2</a></code>,
<code><a href="#topic+intPart">intPart</a></code>,
<code><a href="#topic+mCoeff">mCoeff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return 6*5*4 = 120
ff(6,3) 
</code></pre>

<hr>
<h2 id='GCBellPol'>Generalized Complete Bell Polynomial</h2><span id='topic+GCBellPol'></span>

<h3>Description</h3>

<p>The function generates a generalized complete Bell polynomial, that is a coefficient 
of the composition <code>exp(y[1] g1(z1,...,zm) + ... + y[n] gn(z1,...,zm))</code>, where <code>y[1],...,y[n]</code> are 
variables. The input vector of integers identifies the subscript of the polynomial.</p>


<h3>Usage</h3>

<pre><code class='language-R'>GCBellPol(nv = c(), m = 1, b = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GCBellPol_+3A_nv">nv</code></td>
<td>
<p>vector of integers, the subscript of the polynomial, corresponding to the powers of the product
among <code>z1, z2, ..., zm</code></p>
</td></tr>
<tr><td><code id="GCBellPol_+3A_m">m</code></td>
<td>
<p>integer, the number of <code>z</code>'s variables</p>
</td></tr>
<tr><td><code id="GCBellPol_+3A_b">b</code></td>
<td>
<p>boolean, <code>TRUE</code> if the inner formal power series <code>"g"</code> are all equal</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The multivariate Faa di Bruno's formula, output of the <code><a href="#topic+MFB">MFB</a></code> function, gives 
a coefficient of the multivariate exponential power series obtained from the composition of 
the multivariate exponential power series <code>f(x1,...,xn)</code> with <code>xi=gi(z1,...,zm)</code> for each 
<code>i</code> from <code>1</code> to <code>n</code>. Now, set <code>f(y[1],...,y[n];x1,...,xn)=exp(y[1] x1 + ... + y[n] xn)</code>.
In such a case, the coefficients are the generalized complete Bell polynomials, 
see the referred papers. In particular, the <code><a href="#topic+GCBellPol">GCBellPol</a></code> function  gives 
the expression of these polynomials when <code>n=1</code> or when <code>n&gt;1</code> and <code>g1=...=gn=g</code> or when 
<code>n&gt;1</code> and  <code>g1, ..., gn</code> are all different. See the <code><a href="#topic+e_GCBellPol">e_GCBellPol</a></code> function for 
evaluating this polynomial when its variables <code>y[1], ..., y[n]</code> or/and its coefficients are substituted
with numerical values.</p>


<h3>Value</h3>

<table>
<tr><td><code>string</code></td>
<td>
<p>the expression of the polynomial</p>
</td></tr></table>


<h3>Warning</h3>

<p>The value of the first parameter is the same as the <code><a href="#topic+mkmSet">mkmSet</a></code> 
function.</p>


<h3>Note</h3>

<p>This function calls the <code><a href="#topic+MFB">MFB</a></code> function in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>G. M. Constantine, T. H. Savits  (1996) A Multivariate Faa Di Bruno Formula With 
Applications. Trans. Amer. Math. Soc. 348(2), 503&ndash;520.
</p>
<p>E. Di Nardo (2016) On multivariable cumulant polynomial sequence with applications. Jour. 
Algebraic Statistics 7(1), 72-89.  (download from <a href="https://arxiv.org/abs/1606.01004">https://arxiv.org/abs/1606.01004</a>)
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2011) A new algorithm for computing the multivariate Faa di Bruno's formula. 
Appl. Math. Comp. 217, 6286&ndash;6295. (download from <a href="https://arxiv.org/abs/1012.6008">https://arxiv.org/abs/1012.6008</a>)
</p>
<p>E. Di Nardo, M. Marena, P. Semeraro (2020) On non-linear dependence of multivariate subordinated Levy processes.
In press Stat. Prob. Letters (download from <a href="https://arxiv.org/abs/2004.03933">https://arxiv.org/abs/2004.03933</a>) 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkmSet">mkmSet</a></code>,
<code><a href="#topic+MFB">MFB</a></code>,
<code><a href="#topic+e_GCBellPol">e_GCBellPol</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Return the generalized complete Bell Polynomial for n=1, m=1 and g1=g, 
# that is (y^2)g[1]^2 + (y)g[2]
#
GCBellPol( c(2),1 )

# Return the generalized complete Bell Polynomial for n=1, m=2 and g1=g, 
# 2(y^2)g[1,0]g[1,1] + (y^3)g[0,1]g[1,0]^2 + (y)g[2,1] + (y^2)g[0,1]g[2,0]
#
GCBellPol( c(2,1),1 )

# Return the generalized complete Bell Polynomial for n=2, m=2 and g1=g2=g, 
# (y1)g[1,1] + (y1^2)g[0,1]g[1,0] + (y2)g[1,1] + (y2^2)g[0,1]g[1,0] + 2(y1)(y2)g[0,1]g[1,0]
#
GCBellPol( c(1,1),2, TRUE )

# Return the generalized complete Bell Polynomial for n=2, m=2 and g1 different from g2, 
# that is (y1)g1[1,1] + (y1^2)g1[1,0]g1[0,1] + (y2)g2[1,1] + (y2^2)g2[1,0]g2[0,1] + 
# (y1)(y2)g1[1,0]g2[0,1] + (y1)(y2)g1[0,1]g2[1,0]
#
GCBellPol( c(1,1),2 )

</code></pre>

<hr>
<h2 id='gpPart'>General partition polynomial</h2><span id='topic+gpPart'></span>

<h3>Description</h3>

<p>The function returns a general partition polynomial.</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpPart(n = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpPart_+3A_n">n</code></td>
<td>
<p>integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Faa di Bruno's formula gives the coefficients of the exponential formal power series composition 
<code>f[g()]</code> obtained from the composition of the exponential formal power series <code>f</code> with <code>g</code>. 
General partition polynomials in the variables <code>y[1],...,y[n]</code> are recovered from the Faa di Bruno's 
formula (output of the <code><a href="#topic+MFB">MFB</a></code> function) in the case &quot;composition of univariate 
<code>f</code> with univariate <code>g</code>&quot; by setting <code>f[i]=ai</code> and <code>g[i]=y[i]</code>, for <code>i</code> 
from <code>1</code> to <code>n</code>.</p>


<h3>Value</h3>

<table>
<tr><td><code>string</code></td>
<td>
<p>the expression of the polynomial</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The value of the first parameter is the same as the <code><a href="#topic+MFB">MFB</a></code> function 
in the univariate with univariate composition.</p>


<h3>Note</h3>

<p>This function calls the <code><a href="#topic+MFB">MFB</a></code> function in the <code>kStatistics</code> package.</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

 
<p>C.A. Charalambides (2002) Enumerative Combinatoris, Chapman &amp; Haii/CRC. 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2011) A new algorithm for computing the multivariate Faa di Bruno's formula. 
Appl. Math. Comp. 217, 6286&ndash;6295. (download from <a href="https://arxiv.org/abs/1012.6008">https://arxiv.org/abs/1012.6008</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFB">MFB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Return the general partition polynomial G[a1,a2; y1,y2], that is a2(y1^2) + a1(y2)
gpPart(2)

# Return the general partition polynomial G[a1,a2,a3,a4,a5; y1,y2,y3,y4,y5], that is 
# a5(y1^5) + 10a4(y1^3)(y2) + 15a3(y1)(y2^2) + 10a3(y1^2)(y3) + 10a2(y2)(y3) + 5a2(y1)(y4) 
# + a1(y5)
gpPart(5)

</code></pre>

<hr>
<h2 id='intPart'>Integer partitions</h2><span id='topic+intPart'></span>

<h3>Description</h3>

<p>The function generates all possible (unique) decomposition of a positive integer <code>n</code> in the 
sum of positive integers less or equal to <code>n</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>intPart(n=0 ,vOutput = FALSE) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intPart_+3A_n">n</code></td>
<td>
<p>integer</p>
</td></tr>
<tr><td><code id="intPart_+3A_voutput">vOutput</code></td>
<td>
<p>optional boolean parameter, if equal to <code>TRUE</code> the function produces a 
compact output that is easy to read.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A partition of an integer <code>n</code> is a sequence of weakly increasing integers such 
that their sum returns <code>n</code>. The <code><a href="#topic+intPart">intPart</a></code> function generates all the partitions of a given integer 
in increasing order.</p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>all the partitions of <code>n</code></p>
</td></tr>
</table>


<h3>Note</h3>

<p>Called by the <code><a href="#topic+mkmSet">mkmSet</a></code> function in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>A. Nijenhuis, H. Wilf. (1978) Combinatorial Algorithms for Computers and Calculators. 
Academic Press, Orlando FL, II edition.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkmSet">mkmSet</a></code>,
<code><a href="#topic+mCoeff">mCoeff</a></code>,
<code><a href="#topic+nStirling2">nStirling2</a></code>,
<code><a href="#topic+countP">countP</a></code>,
<code><a href="#topic+ff">ff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return the partition of the integer 3, that is 
# [1,1,1],[1,2],[3]
intPart(3) 

# Return the partition of the integer 4, that is 
# [1,1,1,1],[1,1,2],[1,3],[2,2],[4]
intPart(4) 
# OR (same output) 
intPart(4, FALSE) 

# Return the same output as the previous example but in a compact expression
intPart(4, TRUE)

</code></pre>

<hr>
<h2 id='kStatistics-package'>
Unbiased Estimators for Cumulant Products and Faa Di Bruno's Formula
</h2><span id='topic+kStatistics-package'></span><span id='topic+kStatistics'></span><span id='topic+kstatistics'></span><span id='topic+k-Statistics'></span><span id='topic+k-statistics'></span>

<h3>Description</h3>

<p><code><a href="#topic+kStatistics">kStatistics</a></code> is a package producing estimates of (joint) cumulants and (joint) cumulant products
of a given dataset, using (multivariate) k-statistics and (multivariate) polykays, which are symmetric unbiased estimators. The 
procedures rely on a symbolic method arising from the classical umbral calculus and described in the referred papers. In 
the package, a set of combinatorial tools are given useful in the construction of these estimations such as integer partitions, set partitions, multiset subdivisions or
multi-index partitions, pairing and merging of multisets. In the package, there are also functions to recover univariate and 
multivariate cumulants from a sequence of univariate and multivariate moments (and vice-versa), using Faa di Bruno's 
formula. The function producing Faa di Bruno's formula returns coefficients of exponential power series compositions
such as <code>f[g(z)]</code> with <code>f</code> and <code>g</code> both univariate, or <code>f[g(z1,...,zm)]</code> with <code>f</code> univariate and 
<code>g</code> multivariate, or <code>f[g1(z1,...,zm),...,gn(z1,...,zm)]</code> with <code>f</code> and <code>g</code> both multivariate. Let us
recall that Faa di Bruno's formula might also be employed to recover iterated (partial) derivatives of all these compositions. 
Lastly, using Faa di Bruno's formula, some special families of polynomials are also generated, such as Bell polynomials, 
generalized complete Bell polynomials, partition polynomials and generalized partition polynomials. Applications of these 
polynomials are described in the referred papers.</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>
<p>Elvira Di Nardo &lt;elvira.dinardo@unito.it&gt;, Giuseppe Guarino &lt;giuseppe.guarino@rete.basilicata.it&gt;
</p>
<p>Maintainer: Giuseppe Guarino &lt;giuseppe.guarino@rete.basilicata.it&gt;
</p>


<h3>References</h3>

<p>C.A. Charalambides (2002) Enumerative Combinatoris, Chapman &amp; Haii/CRC. 
</p>
<p>G. M. Constantine, T. H. Savits  (1996) A Multivariate Faa Di Bruno Formula With 
Applications. Trans. Amer. Math. Soc. 348(2), 503-520.
</p>
<p>E. Di Nardo (2016) On multivariable cumulant polynomial sequence with applications. Jour. 
Algebraic Statistics 7(1), 72-89.  (download from <a href="https://arxiv.org/abs/1606.01004">https://arxiv.org/abs/1606.01004</a>)
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2008) An unifying framework for k-statistics, polykays and their generalizations. 
Bernoulli. 14(2), 440-468. (download from <a href="https://arxiv.org/pdf/math/0607623.pdf">https://arxiv.org/pdf/math/0607623.pdf</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2008) Symbolic computation of moments of sampling distributions. 
Comp. Stat. Data Analysis. 52(11), 4909-4922. (download from <a href="https://arxiv.org/abs/0806.0129">https://arxiv.org/abs/0806.0129</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2009) A new method for fast computing unbiased estimators of cumulants. 
Statistics and Computing, 19, 155-165.  (download from <a href="https://arxiv.org/abs/0807.5008">https://arxiv.org/abs/0807.5008</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2011) A new algorithm for computing the multivariate Faa di Bruno's formula. 
Appl. Math. Comp. 217, 6286-6295. (download from <a href="https://arxiv.org/abs/1012.6008">https://arxiv.org/abs/1012.6008</a>)
</p>
<p>E. Di Nardo, M. Marena, P. Semeraro (2020) On non-linear dependence of multivariate subordinated Levy processes.
In press Stat. Prob. Letters (download from <a href="https://arxiv.org/abs/2004.03933">https://arxiv.org/abs/2004.03933</a>) 
</p>
<p>P. McCullagh, J. Kolassa (2009) Scholarpedia, 4(3):4699. <a href="http://www.scholarpedia.org/article/Cumulants">http://www.scholarpedia.org/article/Cumulants</a>
</p>
<p>A. Nijenhuis, H. Wilf. (1978) Combinatorial Algorithms for Computers and Calculators. Academic 
Press, Orlando FL, II edition.
</p>
<p>R. P. Stanley (2012) Enumerative combinatorics. Vol.1. II edition. Cambridge Studies in Advanced Mathematics, 49. 
Cambridge University Press, Cambridge.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Some of the most important functions:

# Data assignment
data1&lt;-c(16.34, 10.76, 11.84, 13.55, 15.85, 18.20, 7.51, 10.22, 12.52, 14.68, 
16.08, 19.43,8.12, 11.20, 12.95, 14.77, 16.83, 19.80, 8.55, 11.58, 12.10, 
15.02, 16.83, 16.98, 19.92, 9.47, 11.68, 13.41, 15.35, 19.11)

# Data assignment
data2&lt;-list(c(5.31,11.16),c(3.26,3.26),c(2.35,2.35),c(8.32,14.34),c(13.48,49.45),
c(6.25,15.05),c(7.01,7.01),c(8.52,8.52),c(0.45,0.45),c(12.08,12.08),c(19.39,10.42))

# Return an estimate of the third cumulant of the random sample data1 with the indication 
# of which function has been employed
# KS:[1] -1.44706
nPolyk(c(3), data1, TRUE)

# Return an estimate of the product of the mean and the variance of the random sample data1
# with the indication of which function has been employed 
# PS:[1] 177.4233
nPolyk( list(  c(2), c(1) ), data1, TRUE)

# Return an estimate of the joint cumulant c[2,1] of the random sample data2  with the 
# indication of which function has been employed
# KM:[1] -23.7379
nPolyk(c(2,1), data2, TRUE);

# Return an estimate of the product of joint cumulants c[2,1]*c[1,0] of the random sample data2
# with the indication of which function has been employed
# PM:[1] 48.43243
nPolyk( list(  c(2,1), c(1,0) ), data2, TRUE)

# Return all the subdivisions of a multiset with only one element of multiplicity 3
mkmSet(3)

# Return all the subdivisions of a multiset with two elements, 
# having multiplicity respectively 2 and 1
mkmSet(c(2,1)) 
# OR (same output)
mkmSet(c(2,1), FALSE)

# Return the same output of the previous example but in a compact expression.
mkmSet(c(2,1), TRUE)  

# Return the scompositions of the vector (1,0,1) in 2 vectors of 3 non-negative integers 
# such that their sum gives (1,0,1), that is
# ([1,0,1],[0,0,0]) - ([0,0,0],[1,0,1]) - ([1,0,0],[0,0,1]) - ([0,0,1],[1,0,0]).
# Note that the second value in each resulting vector is always zero.
mkT(c(1,0,1),2) 
# OR (same output)
mkT(c(1,0,1),2, FALSE) 

# Return the same output of the previous example but in a compact expression.
mkT(c(1,0,1),2, TRUE) 

# Return all the partitions of the integer 4, that is 
# [1,1,1,1],[1,1,2],[1,3],[2,2],[4]
intPart(4) 
# OR (same output) 
intPart(4, FALSE) 

# Return the same output of the previous example but in a compact expression.
intPart(4, TRUE)

# Faa di Bruno's formula (Univariate with Univariate Case)
# The coefficient of z^2 in f[g(z)], that is f[2]g[1]^2 + f[1]g[2], where 
# f[1] is the coefficient of x in f(x) with x=g(z) 
# f[2] is the coefficient of x^2 in f(x) with  x=g(z) 
# g[1] is the coefficient of z in g(z)   
# g[2] is the coefficient of z^2 in g(z)   
# 
MFB( c(2), 1 )

# Faa di Bruno's formula (Univariate with Multivariate Case)    
# The coefficient of z1 z2 in f[g(z1,z2)], that is f[1]g[1,1] + f[2]g[1,0]g[0,1] 
# where 
# f[1]   is the coefficient of x in f(x) with x=g(z1,z2)
# f[2]   is the coefficient of x^2 in f(x) with x=g(z1,z2) 
# g[1,0] is the coefficient of z1 in g(z1,z2) 
# g[0,1] is the coefficient of z2 in g(z1,z2)  
# g[1,1] is the coefficient of z1z2 in g(z1,z2)  
# 
MFB( c(1,1), 1 )

# Faa di Bruno's formula (Multivariate with Multivariate Case) 
# The coefficient of z in f[g1(z),g2(z)], that is  f[1,0]g1[1] + f[0,1]g2[1] where 
# f[1,0] is the coefficient of x1 in f(x1,x2) with x1=g1(z) and x2=g2(z)
# f[0,1] is the coefficient of x2 in f(x1,x2) with x1=g1(z) and x2=g2(z)
# g1[1]  is the coefficient of z of g1(z)  
# g2[1]  is the coefficient of z of g2(z)  
MFB( c(1), 2 )

# The numerical value of f[1]g[1,1] + f[2]g[1,0]g[0,1], that is the coefficient of z1z2 
# in f[g1(z1,z2),g2(z1,z2)] output of MFB(c(1,1),1) when 
# f[1] = 5 and f[2] = 10 
# g[0,1]=3,  g[1,0]=6,  g[1,1]=9
e_MFB(c(1,1),1, c(5,10), c(3,6,9))

# The multivariate cumulant k[3,1] in terms of the multivariate moments m[i,j] for i=0,1,2,3 
# and j=0,1.
cum2mom(c(3,1))

# The multivariate moment m[3,1] in terms of the multivariate cumulants k[i,j] for i=0,1,2,3
# and j=0,1.
mom2cum(c(3,1))

# The partition polynomial F[5]
pPart(5)

#  The general partition polynomial G[a1, a2; y1, y2], that is a2(y1^2) + a1(y2)
gpPart(2)

# The complete ordinary Bell Polynomial for n=5, that is 
# (y1^5) + 20(y1^3)(y2) + 30(y1)(y2^2) + 60(y1^2)(y3) + 120(y2)(y3) + 120(y1)(y4) + 120(y5)
oBellPol(5,)
# OR (same output)
oBellPol(5,0)

# The partial ordinary Bell polynomial for n=5 and m=3, that is 
# 30(y1)(y2^2) + 60(y1^2)(y3)
oBellPol(5,3)

# The complete exponential Bell Polynomial for n=5, that is 
# (y1^5) + 10(y1^3)(y2) + 15(y1)(y2^2) + 10(y1^2)(y3) + 10(y2)(y3) + 5(y1)(y4) + (y5)
eBellPol(5) 
# OR (same output)
eBellPol(5,0)

# The partial exponential Bell Polynomial for n=5 and m=3, that is 
# 15(y1)(y2^2) + 10(y1^2)(y3)
eBellPol(5,3)

# The Stirling number of second kind S(5,3) = 25   
e_eBellPol(5,3) 
# OR (same output) 
e_eBellPol(5,3,c(1,1,1,1,1))

# The Bell number B5 = 52   
e_eBellPol(5) 
# OR (same output) 
e_eBellPol(5,0)
# OR (same output)
e_eBellPol(5,0,c(1,1,1,1,1) )

# The generalized complete Bell Polynomial for n=1, m=1 and g1=g, 
# that is (y^2)g[1]^2 + (y)g[2]
#
GCBellPol( c(2),1 )

# The generalized complete Bell Polynomial for n=1, m=2 and g1=g 
# that is 2(y^2)g[1,0]g[1,1] + (y^3)g[0,1]g[1,0]^2 + (y)g[2,1] + (y^2)g[0,1]g[2,0]
#
GCBellPol( c(2,1),1 )

# The generalized complete Bell Polynomial for n=2, m=2 and g1=g2=g 
# that is (y1)g[1,1] + (y1^2)g[0,1]g[1,0] + (y2)g[1,1] + (y2^2)g[0,1]g[1,0] + 2(y1)(y2)
# g[0,1]g[1,0]
#
GCBellPol( c(1,1),2, TRUE )

# The polynomial 2(y^2)g[1,1]g[1,0] + (y^3)g[1,0]^2g[0,1] + (y)g[2,1] + (y^2)g[2,0]g[0,1], 
# output of GCBellPol( c(2,1),1 ), when g[0,1]=1, g[1,0]=2, g[1,1]=3, g[2,0]=4, g[2,1]=5, 
# that is 16(y^2) + 4(y^3) + 5(y)
#
e_GCBellPol(c(2,1),1,,c(1:5))
#
# OR (same output)
#
e_GCBellPol(c(2,1),1,,c(1,2,3,4,5))
#
# OR (same output)
#
e_GCBellPol( c(2,1),1,"g[0,1]=1, g[1,0]=2, g[1,1]=3, g[2,0]=4, g[2,1]=5" )

# The polynomial 2(y^2)g[1,1]g[1,0] + (y^3)g[1,0]^2g[0,1] + (y)g[2,1] + (y^2)g[2,0]g[0,1], 
# output of GCBellPol( c(2,1),1 ) when g[0,1]=1, g[1,0]=2, g[1,1]=3, g[2,0]=4, g[2,1]=5 and 
# y=7, that is 2191
#
e_GCBellPol( c(2,1),1,c(7),c(1:5) )
#
# OR (same output)
#
e_GCBellPol( c(2,1),1,"y=7, g[0,1]=1, g[1,0]=2, g[1,1]=3, g[2,0]=4, g[2,1]=5" )

 
</code></pre>

<hr>
<h2 id='list2m'>List To Multiset</h2><span id='topic+list2m'></span>

<h3>Description</h3>

<p>The function returns the multiset representation of a vector or a list, in 
increasing order.</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2m( v=c(0) ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list2m_+3A_v">v</code></td>
<td>
<p>single vector or list of vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a list in input, the <code><a href="#topic+list2m">list2m</a></code> function returns a structure as 
<code>[[e1,e2,...], m1], [[f1,f2,...], m2],...</code> where <code>m1, m2,...</code> are the instances 
of <code>c(e1,e2,...), c(f1,f2,...), ...</code> in the input vector <code>v</code>.</p>


<h3>Value</h3>

<table>
<tr><td><code>multiset</code></td>
<td>
<p>the list of multisets</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Called by the <code>countP</code> function in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>D.E. Knuth  (1998) The Art of Computer Programming. (3rd ed.) Addison Wesley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list2Set">list2Set</a></code>,
<code><a href="#topic+m2Set">m2Set</a></code>,
<code><a href="#topic+countP">countP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Return the list of multisets [[1],3], [[2],1] from the input vector (1,2,1,1)  
list2m(c(1,2,1,1 )) 

# Return the list of multisets [[1,2],2], [[2,3],1] from the input list (c(1,2),c(2,3),c(1,2))  
list2m(list(c(1,2),c(2,3),c(1,2))) 

</code></pre>

<hr>
<h2 id='list2Set'>List To Set</h2><span id='topic+list2Set'></span>

<h3>Description</h3>

<p>Given a list, the function deletes the instances of an element in the list, leaving the order inalterated.</p>


<h3>Usage</h3>

<pre><code class='language-R'>list2Set(v=c(0)) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list2Set_+3A_v">v</code></td>
<td>
<p>single vector or list of vectors</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>set</code></td>
<td>
<p>the sequence of distinct elements</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Called by the <code><a href="#topic+list2m">list2m</a></code> function in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list2m">list2m</a></code>,
<code><a href="#topic+m2Set">m2Set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Return the vector c(1,2,3,5,6)
list2Set(c(1,2,3,1,2,5,6)) 
 
# Return the list (c(1,2),c(10,11),c(7,8))
list2Set(list(c(1,2),c(1,2),c(10,11),c(1,2),c(7,8))) 

</code></pre>

<hr>
<h2 id='m2Set'>Detecting equal columns in multi-index partitions</h2><span id='topic+m2Set'></span>

<h3>Description</h3>

<p>The function returns the vectors (only counted once) of all the multi-index 
partitions output of the <code><a href="#topic+mkmSet">mkmSet</a></code> function. These vectors correspond also to the blocks 
of the subdivisions of the multiset having the given multi-index as multeplicites.</p>


<h3>Usage</h3>

<pre><code class='language-R'>m2Set( v=c(0) ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m2Set_+3A_v">v</code></td>
<td>
<p>sequence of type <code>[[e1,e2,...], m1], [[f1,f2,...], m2],...</code> with 
<code>m1, m2,...</code> multiplicities</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the multi-index (2,1). The partitions are<br />  
<code style="white-space: pre;">&#8288;
0 1 1      0 2      1 1     2
1 0 0      1 0      0 1     1&#8288;</code>
<br /> <br />
with multiplicities 1, 1, 2, 1 respectively. The <code><a href="#topic+m2Set">m2Set</a></code> function 
deletes column repetitions, that is transforms the given list in 
<code>[[0,1],[1,0],[2,0],[1,1],[2,1]]</code> 
according to the order given in the input. In terms of subdivisions, suppose to consider 
the multiset <code>[a,a,b]</code> with multiplicities (2,1). The subdivisions are  
</p>

<table>
<tr>
 <td style="text-align: center;"><code>[[[b],[a],[a]],1], [[[a,a],[b]],1], [[[a],[a,b]],2], [[a,a,b],1].</code></td>
</tr>

</table>

<p>The <code><a href="#topic+m2Set">m2Set</a></code> function deletes block repetitions, that is transforms the given list 
in 
</p>

<table>
<tr>
 <td style="text-align: center;"><code>[[b],[a],[a,a],[a,b],[a,a,b]]</code></td>
</tr>

</table>

<p>according to the order given in the input. See also the examples.</p>


<h3>Value</h3>

<table>
<tr><td><code>set</code></td>
<td>
<p>the sequence with distinct elements</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Called by the <code><a href="#topic+nKM">nKM</a></code> and <code><a href="#topic+nPM">nPM</a></code> functions in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+list2m">list2m</a></code>,
<code><a href="#topic+list2Set">list2Set</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
M1 &lt;- mkmSet(c(2,1))
# M1 is  
#  list(   
#       list( list(  c(0,1), c(1,0), c(1,0) )  ,1),
#       list( list(  c(0,1), c(2,0)         )  ,1), 
#       list( list(  c(1,0), c(1,1)         )  ,2),            
#       list( list(  c(2,1)                 )  ,1),    
#      )
# To print all the partitions of the multi-index (2,1) run mkmSet(c(2,1),TRUE)
#   [( 0 1 )( 1 0 )( 1 0 ),  1 ]
#   [( 0 1 )( 2 0 ),  1 ]
#   [( 1 0 )( 1 1 ),  2 ] 
#   [( 2 1 ),  1 ]
#
# Then m2Set(M1) returns the following set:  [[0,1],[1,0],[2,0],[1,1],[2,1]]
# 
m2Set( M1 )

</code></pre>

<hr>
<h2 id='mCoeff'>Extraction of a number from a list</h2><span id='topic+mCoeff'></span>

<h3>Description</h3>

<p>Given a list containing vectors paired with numbers, the function returns 
the number paired with the vector matching the one passed in input.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mCoeff( v=NULL,L=NULL ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mCoeff_+3A_v">v</code></td>
<td>
<p>vector to be searched in the list</p>
</td></tr>
<tr><td><code id="mCoeff_+3A_l">L</code></td>
<td>
<p>two-dimensional list: in the first there is a vector and in the second 
a number</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input variable <code>L</code> of the <code><a href="#topic+mCoeff">mCoeff</a></code> function is a list 
containing vectors and numbers. The  input variable <code>v</code> of the <code><a href="#topic+mCoeff">mCoeff</a></code> 
function is one of vectors contained in the list. The function searches the vector 
<code>v</code> in the list and returns the number which is paired with <code>v</code> in the list.
This function is useful in the construction of k-statistics but also to manage monomials 
and their coefficients.</p>


<h3>Value</h3>

<table>
<tr><td><code>float</code></td>
<td>
<p>the number paired with the input vector</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Called by the <code><a href="#topic+nPS">nPS</a></code>, <code><a href="#topic+nKM">nKM</a></code> and <code><a href="#topic+nPM">nPM</a></code> functions 
in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>E. Di Nardo, G. Guarino, D. Senato (2008) An unifying framework for k-statistics, polykays and their generalizations. 
Bernoulli. 14(2), 440-468. (download from <a href="https://arxiv.org/pdf/math/0607623.pdf">https://arxiv.org/pdf/math/0607623.pdf</a>) 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkmSet">mkmSet</a></code>,
<code><a href="#topic+countP">countP</a></code>,
<code><a href="#topic+nStirling2">nStirling2</a></code>,
<code><a href="#topic+intPart">intPart</a></code>,
<code><a href="#topic+ff">ff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Run mkmSet(c(3)) to get the list L1 = [[1,1,1],1], [[1,2],3], [[3],1]
L1 &lt;- mkmSet(c(3))   

# Return the number 3, which is the number paired with [1,2] in L1
mCoeff( c(1,2), L1)  
 
</code></pre>

<hr>
<h2 id='MFB'>Multivariate Faa di Bruno's formula</h2><span id='topic+MFB'></span>

<h3>Description</h3>

<p>The function returns the coefficient indexed by the integers <code>i1,i2,...</code> of an exponential 
formal power series composition through the univariate or multivariate Faa di Bruno's formula.</p>


<h3>Usage</h3>

<pre><code class='language-R'>MFB(v = c(), n = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MFB_+3A_v">v</code></td>
<td>
<p>vector of integers, the subscript of the coefficient</p>
</td></tr>
<tr><td><code id="MFB_+3A_n">n</code></td>
<td>
<p>integer, the number of inner functions <code>g</code>'s</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+MFB">MFB</a></code> function computes a coefficient of an exponential formal power series composition: 
</p>

<table>
<tr>
 <td style="text-align: left;">a) </td><td style="text-align: left;"> univariate <code>f</code> with univariate <code>g</code>, that is <code>f[g(z)]</code>,  </td>
</tr>
<tr>
 <td style="text-align: left;">
             b) </td><td style="text-align: left;"> univariate <code>f</code> with multivariate <code>g</code>, that is <code>f[g(z1,z2,...,zm)]</code>,  </td>
</tr>
<tr>
 <td style="text-align: left;">
             c) </td><td style="text-align: left;"> multivariate <code>f</code> with multivariate <code>g</code>'s, that is <code>f[g1(z1,z2,...,zm),...,gn(z1,z2,...,gm)].</code>
</td>
</tr>

</table>

<p>If <code>i1</code> is the power of <code>z1</code>, <code>i2</code> is the power of <code>z2</code> and so on up to <code>im</code> power of <code>zm</code>, then 
<code>(i1,i2,....im)</code> is the subscript of the output coefficient corresponding to the product <code>z1^i1 z2^i2 ....zm^im.</code> 
Note that this coefficient gives also the (partial) derivative of order <code>(i1,i2,...,im)</code> of the composition of 
the multivariate functions <code>f</code> and <code>g</code>'s in terms of the partial derivatives of <code>f</code> and <code>g</code>'s respectively. 
See the <code><a href="#topic+e_MFB">e_MFB</a></code> function, for evaluating this coefficient when the coefficients of 
<code>f</code> and to the coefficients of <code>g</code>'s are substituted with numerical values.</p>


<h3>Value</h3>

<table>
<tr><td><code>string</code></td>
<td>
<p>the expression of Faa di Bruno's formula</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The value of the first parameter is the same as the <code><a href="#topic+mkmSet">mkmSet</a></code> function</p>


<h3>Note</h3>

<p>Called by the <code><a href="#topic+e_MFB">e_MFB</a></code> function in the <code>kStatistics</code> package.
The routine uses the <code><a href="#topic+mkmSet">mkmSet</a></code> function in the same package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>G. M. Constantine, T. H. Savits  (1996) A Multivariate Faa Di Bruno Formula With 
Applications. Trans. Amer. Math. Soc. 348(2), 503-520.
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2008) An unifying framework for k-statistics, polykays and their generalizations. 
Bernoulli. 14(2), 440-468. (download from <a href="https://arxiv.org/pdf/math/0607623.pdf">https://arxiv.org/pdf/math/0607623.pdf</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2008) Symbolic computation of moments of sampling distributions. 
Comp. Stat. Data Analysis. 52(11), 4909-4922. (download from <a href="https://arxiv.org/abs/0806.0129">https://arxiv.org/abs/0806.0129</a>) 
</p>
<p>E. Di Nardo E., G. Guarino, D. Senato (2011) A new algorithm for computing the multivariate Faa di Bruno's formula. 
Appl. Math. Comp. 217, 6286-6295. (download from <a href="https://arxiv.org/abs/1012.6008">https://arxiv.org/abs/1012.6008</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkmSet">mkmSet</a></code>,
<code><a href="#topic+e_MFB">e_MFB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#----------------------------------------#
# Univariate f with Univariate g         #
#----------------------------------------#

# The coefficient of z^2 in f[g(z)], that is f[2]g[1]^2 + f[1]g[2], where 
# f[1] is the coefficient of x in f(x) with x=g(z) 
# f[2] is the coefficient of x^2 in f(x) with  x=g(z) 
# g[1] is the coefficient of z in g(z)   
# g[2] is the coefficient of z^2 in g(z)   
# 
MFB( c(2), 1 )

# The coefficient of z^3 in f[g(z)], that is f[3]g[1]^3 + 3f[2]g[1]g[2] + f[1]g[3] 
#
MFB( c(3), 1 )

#----------------------------------------#
#  Univariate f with Multivariate g      #
#----------------------------------------#

# The coefficient of z1 z2 in f[g(z1,z2)], that is f[1]g[1,1] + f[2]g[1,0]g[0,1] 
# where 
# f[1]   is the coefficient of x in f(x) with x=g(z1,z2)
# f[2]   is the coefficient of x^2 in f(x) with x=g(z1,z2) 
# g[1,0] is the coefficient of z1 in g(z1,z2) 
# g[0,1] is the coefficient of z2 in g(z1,z2)  
# g[1,1] is the coefficient of z1 z2 in g(z1,z2)  
# 
MFB( c(1,1), 1 )

# The coefficient of z1^2 z2 in f[g(z1,z2)] 
#
MFB( c(2,1), 1 )

# The coefficient of z1 z2 z3 in f[g(z1,z2,z3)] 
#
MFB( c(1,1,1), 1 )

#----------------------------------------------------------------#
#  Multivariate f with Univariate/Multivariate g1, g2, ..., gn   #
#----------------------------------------------------------------#

# The coefficient of z in f[g1(z),g2(z)], that is  f[1,0]g1[1] + f[0,1]g2[1] where 
# f[1,0] is the coefficient of x1 in f(x1,x2) with x1=g1(z) and x2=g2(z)
# f[0,1] is the coefficient of x2 in f(x1,x2) with x1=g1(z) and x2=g2(z)
# g1[1]  is the coefficient of z of g1(z)  
# g2[1]  is the coefficient of z of g2(z)  
MFB( c(1), 2 )

# The coefficient of z1 z2 in f[g1(z1,z2),g2(z1,z2)], that is
# f[1,0]g1[1,1] + f[2,0]g1[1,0]g1[0,1] + f[0,1]g2[1,1] + f[0,2]g2[1,0]g2[0,1] + 
# f[1,1]g1[1,0]g2[0,1] + f[1,1]g1[0,1]g2[1,0] where 
# f[1,0]  is the coefficient of x1 in f(x1,x2) with x1=g1(z1,z2) and x2=g2(z1,z2)
# f[0,1]  is the coefficient of x2 in f(x1,x2) with x1=g1(z1,z2) and x2=g2(z1,z2)
# g1[1,1] is the coefficient of z1z2 in g1(z1,z2)  
# g1[1,0] is the coefficient of z1 in g1(z1,z2)   
# g1[0,1] is the coefficient of z2 in g1(z1,z2)  
# g2[1,1] is the coefficient of z1 z2 in g2(z1,z2)  
# g2[1,0] is the coefficient of z1 in g2(z1,z2)  
# g2[0,1] is the coefficient of z2 in g1(z1,z2)  
MFB( c(1,1), 2 )

# The coefficient of z1 in f[g1(z1,z2),g2(z1,z2),g3(z1,z2)] 
MFB( c(1,0), 3 )

# The coefficient of z1 z2 in f[g1(z1,z2),g2(z1,z2),g3(z1,z2)] 
MFB( c(1,1), 3 )

# The coefficient of z1^2 z2 in f[g1(z1,z2),g2(z1,z2)]  
MFB( c(2,1), 2 )

# The coefficient of z1^2 z2 in f[g1(z1,z2),g2(z1,z2),g3(z1,z2)]  
MFB( c(2,1), 3 )

# The previous result expressed in a compact form
for (m in unlist(strsplit( MFB(c(2,1),3), " + ", fixed=TRUE)) ) cat( m,"\n" )

# The coefficient of z1 z2 z3 in f[g1(z1,z2,z3),g2(z1,z2,z3),g3(z1,z2,z3)]  
MFB( c(1,1,1), 3 )

# The previous result expressed in a compact form
for (m in unlist(strsplit( MFB(c(1,1,1),3), " + ", fixed=TRUE)) ) cat( m,"\n" )

</code></pre>

<hr>
<h2 id='MFB2Set'>Convert the output of the MFB function into a vector
</h2><span id='topic+MFB2Set'></span>

<h3>Description</h3>

<p>Secondary function useful for manipulating the result of the <code><a href="#topic+MFB">MFB</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MFB2Set(sExpr="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MFB2Set_+3A_sexpr">sExpr</code></td>
<td>
<p>the output of the <code><a href="#topic+MFB">MFB</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>set</code></td>
<td>
<p>a set</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFB">MFB</a></code>,
<code><a href="#topic+Set2expr">Set2expr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Run MFB(c(3),1) to generate f[3]g[1]^3 + 3f[2]g[1]g[2] + f[1]g[3]
# Convert the output of the MFB(c(3),1) into a vector using
# MFB2Set(MFB(c(3),1)). The result is the following:
# "1" "1" "f" "3" "1"
# "1" "1" "g" "1" "3"
# "2" "3" "f" "2" "1"
# "2" "1" "g" "1" "1"
# "2" "1" "g" "2" "1"
# "3" "1" "f" "1" "1"
# "3" "1" "g" "3" "1"
MFB2Set(MFB(c(3),1))
</code></pre>

<hr>
<h2 id='mkmSet'>Partitions of a multi-index</h2><span id='topic+mkmSet'></span>

<h3>Description</h3>

<p>The function returns  all the partitions of a multi-index, that is a vector of non-negative integers. Note that these partitions correspond 
to the subdivisions of a multiset having the input multi-index as multiplicities.</p>


<h3>Usage</h3>

<pre><code class='language-R'>      mkmSet(vPar = NULL, vOutput = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkmSet_+3A_vpar">vPar</code></td>
<td>
<p>vector of non-negative integers</p>
</td></tr>
<tr><td><code id="mkmSet_+3A_voutput">vOutput</code></td>
<td>
<p>optional boolean variable. If equal to <code>TRUE</code>, the function produces a compact 
output that is easy to read.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+mkmSet">mkmSet</a></code> function finds all the vectors, different from the zero vector, whose 
sum (in column) is equal to the vector (in column) of nonnegative integers given in input. When the input 
vector is just an integer, let's say <code>n</code>, the function returns the partitions of <code>n</code>. 
Each partition is paired with the number of set partitions having that partition as their class. 
For example, if <code>n=3</code> the output is 
</p>

<table>
<tr>
 <td style="text-align: center;"><code>[[1,1,1],1], [[1,2],3], [[3],1]</code>,</td>
</tr>

</table>

<p>where <code>1+1+1=1+2=3</code>. From this output, the subdivisions of a multiset with multiplicity 3 can be 
recovered. For example, the subdivisions of <code>[a,a,a]</code> are <code>[[a], [a], [a]]</code> corresponding to
<code>[1,1,1]</code>, <code>[[a], [a,a]]</code> corresponds to <code>[1,2]</code> and <code>[[a,a,a]]</code> corresponds to 
<code>[3]</code>. When the input vector is a multi-index, the function returns all the partitions of the 
multi-index. For example, if the input is (2,1) then the function returns <br /> 
<code style="white-space: pre;">&#8288;
0 1 1     0 2     1 1     2
1 0 0     1 0     0 1     1&#8288;</code>
<br /> <br />
with multiplicities 1, 1, 2, 1 respectively, which corresponds to the output (the columns become rows) 
of the <code><a href="#topic+mkmSet">mkmSet</a></code> function when the flag variable <code>vOutput</code> is set equal to <code>TRUE</code>  
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>[( 0 1 )( 1 0 )( 1 0 ),  1 ]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 0 1 )( 2 0 ),  1 ]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 1 0 )( 1 1 ),  2 ]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 2 1 ),  1 ]</code></td>
</tr>

</table>

<p>From this output, the subdivisions of a multiset with multiplicity (2,1) can be easily recovered. 
For example the previous partitions correspond to the following subdivisions of the multiset 
<code>[a,a,b]</code>  
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>[[b], [a], [a]]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">     
<code>[[b], [a,a]]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">  
<code>[[a], [a,b]]</code> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
<code>[[a,a,b]]</code></td>
</tr>

</table>

<p>The <code><a href="#topic+mkmSet">mkmSet</a></code> function is the core of the <code><a href="#topic+kStatistics">kStatistics</a></code> package. The strategy to find 
all the partitions of a multi-index is described in the refereed papers. To find the multiplicities of the 
multi-index partitions see the <code><a href="#topic+countP">countP</a></code> function. </p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>two-dimensional list: in the first there is the partition, while in the second there is 
its multiplicity</p>
</td></tr></table>


<h3>Note</h3>

<p>Called by the <code><a href="#topic+nKS">nKS</a></code>, <code><a href="#topic+nKM">nKM</a></code>, <code><a href="#topic+nPS">nPS</a></code> and <code><a href="#topic+nPM">nPM</a></code> functions  in 
the <code>kStatistics</code> package. <br /> <br /> 
In the output list, the sum of all multiplicities is the Bell Number whereas the sum of all 
multiplicities of the partitions with the same lenght is the Stirling number of the second kind. 
For example, <code>mkmSet(4, TRUE)</code> returns  
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>[( 1 )( 1 )( 1 )( 1 ),  1 ]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 1 )( 1 )( 2 ),  6 ]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 2 )( 2 ),  3 ]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 1 )( 3 ),  4 ]</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>[( 4 ),  1 ]</code></td>
</tr>

</table>

<p>Observe that <code>3 + 4 = 7 =  S(4,2)</code>, where 4 is the input integer, 2 is the length of the 
partitions <code>[1,3]</code> and <code>[2,2]</code> and <code>S(i,j)</code> denotes the Stirling numbers of the second 
kind, see also the <code><a href="#topic+nStirling2">nStirling2</a></code> function. Similarly, we have <code>1 =  S(4,4) =  S(4,1)</code> 
and <code>6 =  S(4,3)</code>. Note that <code>1 + 6 + 4 + 3 + 1 = 15 = Bell(4)</code> which is the number of 
partitions of the integer 4.</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>E. Di Nardo, G. Guarino, D. Senato (2008) An unifying framework for k-statistics, polykays and their generalizations. 
Bernoulli. 14(2), 440-468. (download from <a href="https://arxiv.org/pdf/math/0607623.pdf">https://arxiv.org/pdf/math/0607623.pdf</a>)
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2008) Symbolic computation of moments of sampling distributions. 
Comp. Stat. Data Analysis. 52(11), 4909-4922. (download from <a href="https://arxiv.org/abs/0806.0129">https://arxiv.org/abs/0806.0129</a>) 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mCoeff">mCoeff</a></code>,
<code><a href="#topic+countP">countP</a></code>,
<code><a href="#topic+nStirling2">nStirling2</a></code>,
<code><a href="#topic+intPart">intPart</a></code>,
<code><a href="#topic+ff">ff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Return [ [[1,1,1],1], [[1,2],3], [[3],1]  ]
# 3 is the multiplicity of a multiset with 3 elements all equal
mkmSet(3)

# Return [ [[1,1],[1,0],2], [[1,0],[1,0],[0,1],1],[[2,0],[0,1],1], [[2,1],1] ]
# (2,1) is the multiplicity of a multiset with 2 equal elements and a third distinct element 
mkmSet(c(2,1)) 
# OR (same output)
mkmSet(c(2,1), FALSE)  

# Returns the same output of the previous example but in a compact form.
mkmSet(c(2,1), TRUE)  

</code></pre>

<hr>
<h2 id='mkT'>Scomposition of a multi-index</h2><span id='topic+mkT'></span>

<h3>Description</h3>

<p>Given a multi-index, that is a vector of non-negative integers and a positive integer <code>n</code>, the function returns all 
the lists <code>(v1,...,vn)</code> of non-negative integer vectors, with the same lenght of the multi-index and such that <code>v=v1+...+vn</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mkT(v = c(), n = 0, vOutput = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mkT_+3A_v">v</code></td>
<td>
<p>vector of integers</p>
</td></tr>
<tr><td><code id="mkT_+3A_n">n</code></td>
<td>
<p>integer, number of addends</p>
</td></tr>
<tr><td><code id="mkT_+3A_voutput">vOutput</code></td>
<td>
<p>optional boolean variable. If equal to <code>TRUE</code>, the function produces a compact output that is easy to read.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From the input vector <code>v</code> of non-negative integers, which represents the multi-index, 
the function produces all the 
lists of <code>n</code> vectors <code>(v1,...,vn)</code> of non-negative integers, including the zero vector, having the same lenght of 
<code>v</code> and such that their sum gives <code>v</code>. Note that two lists are different if they contain the same vectors but permuted.</p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>the list of <code>n</code> vectors <code>(v1,...,vn)</code></p>
</td></tr></table>


<h3>Warning</h3>

<p>The vector in the first variable must be not empty and must contain all non-negative integers.
The second parameter must be a positive integer.</p>


<h3>Note</h3>

<p>Called by the <code><a href="#topic+MFB">MFB</a></code> function in the <code>kStatistics</code> package.
The routine uses the <code><a href="#topic+mkmSet">mkmSet</a></code> function in the same package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>Di Nardo E., Guarino G., Senato D. (2011) A new algorithm for computing the multivariate Faa di Bruno's formula. 
Appl. Math. Comp. 217, 6286-6295. (download from <a href="https://arxiv.org/abs/1012.6008">https://arxiv.org/abs/1012.6008</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkmSet">mkmSet</a></code>,
<code><a href="#topic+MFB">MFB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Return the scompositions of the vector (1,1) in 2 vectors of 2 non-negative integers 
# such that their sum is (1,1), that is 
# ([1,1],[0,0]) - ([0,0],[1,1]) - ([1,0],[0,1]) - ([0,1],[1,0])
mkT(c(1,1),2)  
# OR (same output) 
mkT(c(1,1),2,FALSE)

# Return the scompositions of the vector (1,0,1) in 2 vectors of 3 non-negative integers 
# such that their sum gives (1,0,1), that is 
# ([1,0,1],[0,0,0]) - ([0,0,0],[1,0,1]) - ([1,0,0],[0,0,1]) - ([0,0,1],[1,0,0]).
# Note that the second value in each resulting vector is always zero.
mkT(c(1,0,1),2) 
# OR (same output) 
mkT(c(1,0,1),2, FALSE) 

# Return the same output of the previous example but in a compact form.
mkT(c(1,0,1),2, TRUE) 

# Return the scompositions of the vector (1,1,1) in 3 vectors of 3 non-negative integers 
# such that  their sum gives (1,1,1). The result is given in a compact form.
for (m in mkT(c(1,1,1),3)) {for (n in m) cat(n," - "); cat("\n")}

</code></pre>

<hr>
<h2 id='mom2cum'>Moments in terms of cumulants 
</h2><span id='topic+mom2cum'></span>

<h3>Description</h3>

<p>The function compute a simple or a multivariate moment in terms of simple or multivariate cumulants.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mom2cum(n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mom2cum_+3A_n">n</code></td>
<td>
<p>integer or vector of integers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Faa di Bruno's formula (the  <code><a href="#topic+MFB">MFB</a></code> function) gives the coefficients of the exponential formal
power series <code>f[g()]</code>  where <code>f</code> and <code>g</code> are exponential formal power series too. Simple moments 
are expressed in terms of simple cumulants using the Faa di Bruno's formula obtained from the  <code><a href="#topic+MFB">MFB</a></code> function 
in the case &quot;composition of univariate <code>f</code> with univariate <code>g</code>&quot; with <code>f[i]=1, g[i]=k[i]</code> 
for each <code>i</code> from 1 to <code>n</code> and <code>k[i]</code> cumulants. Multivariate moments are expressed in terms 
of multivariate cumulants using the Faa di Bruno's formula obtained from the  <code><a href="#topic+MFB">MFB</a></code> function in 
the case &quot;composition of univariate <code>f</code> with multivariate <code>g</code>&quot;. In such a case the coefficients of 
<code>g</code> are the multivariate cumulants.</p>


<h3>Value</h3>

<table>
<tr><td><code>string</code></td>
<td>
<p>the expression of the moment in terms of cumulants</p>
</td></tr></table>


<h3>Warning</h3>

<p>The value of the first parameter is the same as the <code><a href="#topic+MFB">MFB</a></code> function in the univariate with 
univariate case composition and in the univariate with multivariate case composition.</p>


<h3>Note</h3>

<p>This function calls the <code><a href="#topic+MFB">MFB</a></code> function in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>E. Di Nardo, G. Guarino, D. Senato (2008) An unifying framework for k-statistics, polykays and their generalizations. 
Bernoulli. 14(2), 440-468. (download from <a href="https://arxiv.org/pdf/math/0607623.pdf">https://arxiv.org/pdf/math/0607623.pdf</a>) 
</p>
<p>E. Di Nardo E., G. Guarino, D. Senato (2011) A new algorithm for computing the multivariate Faa di Bruno's formula. 
Appl. Math. Comp. 217, 6286-6295. (download from <a href="https://arxiv.org/abs/1012.6008">https://arxiv.org/abs/1012.6008</a>)
</p>
<p>P. McCullagh, J. Kolassa (2009) Scholarpedia, 4(3):4699. <a href="http://www.scholarpedia.org/article/Cumulants">http://www.scholarpedia.org/article/Cumulants</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFB">MFB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return the simple moment m[5] in terms of the simple cumulants k[1],...,k[5].
mom2cum(5)

# Return the multivariate moment m[3,1] in terms of the multivariate cumulants k[i,j] for 
# i=0,1,2,3 and j=0,1.
mom2cum(c(3,1))
</code></pre>

<hr>
<h2 id='mpCart'>Join two lists</h2><span id='topic+mpCart'></span>

<h3>Description</h3>

<p>Given two lists with elements of the same type, the function returns a new list whose elements are the joining of 
the two original lists, except for the last elements, which are multiplied.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpCart( M1 = NULL, M2 = NULL ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpCart_+3A_m1">M1</code></td>
<td>
<p>list of vectors</p>
</td></tr>
<tr><td><code id="mpCart_+3A_m2">M2</code></td>
<td>
<p>list of vectors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input of the <code><a href="#topic+mpCart">mpCart</a></code> function are two lists. Each list might contain multiple lists 
of two vectors: the first vector contains multisets whose elements are of the same type (integers or vectors
with the same lenght), the second vector is a number (for example a multiplicity if the multiset is a 
subdivision). The <code><a href="#topic+mpCart">mpCart</a></code> function generates a new list of two vectors: the first is 
obtained by joining the first vectors in the two input lists, the second is just the product 
of the numbers in the second vectors. See the examples.</p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>the list with the joined input lists</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Called by the function <code><a href="#topic+nPM">nPM</a></code> in the package <code>kStatistics</code>.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>E. Di Nardo, G. Guarino, D. Senato (2008) An unifying framework for k-statistics, polykays and their generalizations. 
Bernoulli. 14(2), 440-468. (download from <a href="https://arxiv.org/pdf/math/0607623.pdf">https://arxiv.org/pdf/math/0607623.pdf</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2008) Symbolic computation of moments of sampling distributions. 
Comp. Stat. Data Analysis. 52(11), 4909-4922. (download from <a href="https://arxiv.org/abs/0806.0129">https://arxiv.org/abs/0806.0129</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2009) A new method for fast computing unbiased estimators of cumulants. 
Statistics and Computing, 19, 155-165.  (download from <a href="https://arxiv.org/abs/0807.5008">https://arxiv.org/abs/0807.5008</a>) 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pCart">pCart</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- list(  list( list(c(1),c(2) ),c(-1)), list(list(c(3)),c(1))  )
# where 
# -1 is the multiplicative factor of list(c(1),c(2) ) 
#  1 is the multiplicative factor of list(c(3))
B &lt;- list( list( list(c(5)),c(7)))
# where 7 is the multiplicative factor of list(c(5))
 
# Return [[[1],[2],[5]], -7] , [[[3],[5]], 7]
mpCart(A,B) 

A &lt;- list( list( list( c(1,0),c(1,0) ), c(-1)),  list( list( c(2,0)), c(1) ))
# where
# - 1 is the multiplicative factor of list( c(1,0),c(1,0) )
#   1 is the multiplicative factor of list( c(2,0) )
B &lt;- list( list( list( c(1,0)), c(1)) )
# where 1 is the multiplicative factor of list( c(1,0))

# Return [[[1,0],[1,0],[1,0]], -1], [[[2,0],[1,0]],1]
mpCart(A,B)
 

</code></pre>

<hr>
<h2 id='nKM'>Multivariate K-Statistics</h2><span id='topic+nKM'></span>

<h3>Description</h3>

<p>Given a multivariate data sample, the function returns an estimate of a joint 
(or multivariate) cumulant with a fixed order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nKM( v = NULL, V = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nKM_+3A_v">v</code></td>
<td>
<p>vector of integers</p>
</td></tr>
<tr><td><code id="nKM_+3A_v">V</code></td>
<td>
<p>vector of a multivariate data sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a sample of i.i.d. random vectors, multivariate k-statistics are unbiased estimators of 
the population joint cumulants with minimum variance and are expressed in terms of power sum symmetric polynomials
in the random vectors of the sample. See the referred papers to read more about these estimators. 
Thus, for the input multivariate sample <code>data</code>, running
<code>nKM( c(r, s, ...), data)</code> with fixed order <code>v=(r, s, ...)</code> returns an estimate of the joint cumulant 
<code>k[r, s, ...]</code> of the population distribution.
</p>


<h3>Value</h3>

<table>
<tr><td><code>float</code></td>
<td>
<p>the value of the multivariate k-statistics</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The size of each data vector must be equal to the length of the vector
passed trough the first input variable.</p>


<h3>Note</h3>

<p>Called by the master <code><a href="#topic+nPolyk">nPolyk</a></code> function in the  <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>E. Di Nardo, G. Guarino, D. Senato (2008) An unifying framework for k-statistics, polykays and their generalizations. 
Bernoulli. 14(2), 440-468. (download from <a href="https://arxiv.org/pdf/math/0607623.pdf">https://arxiv.org/pdf/math/0607623.pdf</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2008) Symbolic computation of moments of sampling distributions. 
Comp. Stat. Data Analysis. 52(11), 4909-4922. (download from <a href="https://arxiv.org/abs/0806.0129">https://arxiv.org/abs/0806.0129</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2009) A new method for fast computing unbiased estimators of cumulants. 
Statistics and Computing, 19, 155-165.  (download from <a href="https://arxiv.org/abs/0807.5008">https://arxiv.org/abs/0807.5008</a>) 
</p>
<p>P. McCullagh, J. Kolassa (2009), Scholarpedia, 4(3):4699. <a href="http://www.scholarpedia.org/article/Cumulants">http://www.scholarpedia.org/article/Cumulants</a>
</p>


<h3>See Also</h3>


<p><code><a href="#topic+nKS">nKS</a></code>,
<code><a href="#topic+nPS">nPS</a></code>,
<code><a href="#topic+nPM">nPM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data assignment
data1&lt;-list(c(5.31,11.16),c(3.26,3.26),c(2.35,2.35),c(8.32,14.34),c(13.48,49.45),
c(6.25,15.05),c(7.01,7.01),c(8.52,8.52),c(0.45,0.45),c(12.08,12.08),c(19.39,10.42))

# Return an estimate of the joint cumulant k[2,1]
nKM(c(2,1),data1)

# Data assignment
data2&lt;-list(c(5.31,11.16,4.23),c(3.26,3.26,4.10),c(2.35,2.35,2.27),
c(4.31,10.16,6.45),c(3.1,2.3,3.2),c(3.20, 2.31, 7.3))

# Return an estimate of the joint cumulant k[2,2,2]
nKM(c(2,2,2),data2)
  
# Data assignment
data3&lt;-list(c(5.31,11.16,4.23,4.22),c(3.26,3.26,4.10,4.9),c(2.35,2.35,2.27,2.26),
c(4.31,10.16,6.45,6.44),c(3.1,2.3,3.2,3.1),c(3.20, 2.31, 7.3,7.2))

# Return an estimate of the joint cumulant k[2,1,1,1]
nKM(c(2,1,1,1),data3)
 
</code></pre>

<hr>
<h2 id='nKS'>Simple K-Statistics</h2><span id='topic+nKS'></span>

<h3>Description</h3>

<p>Given a data sample, the function returns an estimate of a cumulant with a fixed order.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nKS( v = NULL, V = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nKS_+3A_v">v</code></td>
<td>
<p>integer or one-dimensional vector</p>
</td></tr>
<tr><td><code id="nKS_+3A_v">V</code></td>
<td>
<p>vector of a data sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a sample of i.i.d. random variables, k-statistics are unbiased estimators with minimum variance of the population 
cumulants and are expressed in terms of power sum symmetric polynomials in the random variables 
of the sample. See the referred papers to read more about these estimators. Thus, for the input 
sample <code>data</code>, running <code>nKS(v,data)</code> or <code>nKS(c(v),data)</code> 
returns an estimate of the <code>v</code>-th cumulant of the population distribution.</p>


<h3>Value</h3>

<table>
<tr><td><code>float</code></td>
<td>
<p>the value of the k-statistics</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Called by the master <code><a href="#topic+nPolyk">nPolyk</a></code> function in the <code>kStatistics</code> package. 
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>E. Di Nardo, G. Guarino, D. Senato (2008) An unifying framework for k-statistics, polykays and their generalizations. 
Bernoulli. 14(2), 440-468. (download from <a href="https://arxiv.org/pdf/math/0607623.pdf">https://arxiv.org/pdf/math/0607623.pdf</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2008) Symbolic computation of moments of sampling distributions. 
Comp. Stat. Data Analysis. 52(11), 4909-4922. (download from <a href="https://arxiv.org/abs/0806.0129">https://arxiv.org/abs/0806.0129</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2009) A new method for fast computing unbiased estimators of cumulants. 
Statistics and Computing, 19, 155-165.  (download from <a href="https://arxiv.org/abs/0807.5008">https://arxiv.org/abs/0807.5008</a>) 
</p>
<p>P. McCullagh, J. Kolassa (2009), Scholarpedia, 4(3):4699. <a href="http://www.scholarpedia.org/article/Cumulants">http://www.scholarpedia.org/article/Cumulants</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nPolyk">nPolyk</a></code>,
<code><a href="#topic+nKM">nKM</a></code>,
<code><a href="#topic+nPS">nPS</a></code>,
<code><a href="#topic+nPM">nPM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data assignment
data&lt;-c(16.34, 10.76, 11.84, 13.55, 15.85, 18.20, 7.51, 10.22, 12.52, 14.68, 16.08, 
19.43,8.12, 11.20, 12.95, 14.77, 16.83, 19.80, 8.55, 11.58, 12.10, 15.02, 16.83, 
16.98, 19.92, 9.47, 11.68, 13.41, 15.35, 19.11)

# Return an estimate of the cumulant of order 7
nKS(7, data) 

# Return an estimate of the cumulant of order 1, that is the mean (R command: mean(data))
nKS(1, data) 

# Return an estimate of the cumulant of order 2, that is the variance (R command: var(data))
nKS(2, data) 

# Return an estimate of the skewness (R command: skewnes(data) in the library "moments")
nKS(3, data)/sqrt(nKS(2, data))^3 

# Return an estimate of the kurtosis (R command: kurtosis(data) in the library "moments")
nKS(4, data)/nKS(2, data)^2 + 3 

</code></pre>

<hr>
<h2 id='nPerm'>Permutations of a list or a vector</h2><span id='topic+nPerm'></span>

<h3>Description</h3>

<p>The function returns all possible different permutations of objects in a list or in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nPerm(L = c())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nPerm_+3A_l">L</code></td>
<td>
<p>List/Vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to manage permutations of numbers or vectors, the standard permutation process is applied.
</p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>all the permutations of <code>L</code></p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>C. A. Charalambides (2002) Enumerative Combinatoris, Chapman &amp; Haii/CRC. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# permutations of 1,2,3  
nPerm( c(1,2,3) )

# permutations of 1,2,1 (two elements are equal) 
nPerm( c(1,2,1) )

# permutations of the words "Alice", "Bob","Jack"
nPerm( c("Alice", "Bob","Jack") )

# permutations of the vectors c(0,1), c(2,3), c(7,3)
nPerm( list(c(0,1), c(2,3), c(7,3)) )
</code></pre>

<hr>
<h2 id='nPM'>Multivariate Polykays</h2><span id='topic+nPM'></span>

<h3>Description</h3>

<p>Given a multivariate data sample, the function returns an estimate of a product of 
joint cumulants with fixed orders.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nPM( v = NULL, V = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nPM_+3A_v">v</code></td>
<td>
<p>list of integer vectors</p>
</td></tr>
<tr><td><code id="nPM_+3A_v">V</code></td>
<td>
<p>vector of a multivariate data sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multivariate polykays or multivariate generalized k-statistics are unbiased estimators of 
joint cumulant products with minimum variance. See the referred papers to read more about these estimators. Multivariate polykays
are usually expressed in terms of power sum symmetric polynomials in the random vectors of the sample. 
Thus, for the input multivariate sample <code>data</code>, running 
<code>nPM( list( c(r1, s1, ...), c(r1, s2, ...),..  ), data)</code>  returns an estimate of the product 
<code>k[r1, s1,....]*k[r2, s2, ...]*...</code> where <code>k[r1, s1,....], k[r2, s2, ...], ...</code> are 
the joint cumulants of the population distribution. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>float</code></td>
<td>
<p>the estimate of the multivariate polykay</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The size of each data vector must be equal to the length of the vector
passed trough the first input variable. The vectors in the list must have the same length.</p>


<h3>Note</h3>

<p>Called by the master <code><a href="#topic+nPolyk">nPolyk</a></code> function in the <code>kStatistics</code> package. 
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>E. Di Nardo, G. Guarino, D. Senato (2008) An unifying framework for k-statistics, polykays and their generalizations. 
Bernoulli. 14(2), 440-468. (download from <a href="https://arxiv.org/pdf/math/0607623.pdf">https://arxiv.org/pdf/math/0607623.pdf</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2008) Symbolic computation of moments of sampling distributions. 
Comp. Stat. Data Analysis. 52(11), 4909-4922. (download from <a href="https://arxiv.org/abs/0806.0129">https://arxiv.org/abs/0806.0129</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2009) A new method for fast computing unbiased estimators of cumulants. 
Statistics and Computing, 19, 155-165.  (download from <a href="https://arxiv.org/abs/0807.5008">https://arxiv.org/abs/0807.5008</a>) 
</p>
<p>P. McCullagh, J. Kolassa (2009), Scholarpedia, 4(3):4699. <a href="http://www.scholarpedia.org/article/Cumulants">http://www.scholarpedia.org/article/Cumulants</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nPolyk">nPolyk</a></code>,
<code><a href="#topic+nKS">nKS</a></code>,
<code><a href="#topic+nKM">nKM</a></code>,
<code><a href="#topic+nPS">nPS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data assignment
data1&lt;-list(c(5.31,11.16),c(3.26,3.26),c(2.35,2.35),c(8.32,14.34),c(13.48,49.45),
c(6.25,15.05),c(7.01,7.01),c(8.52,8.52),c(0.45,0.45),c(12.08,12.08),c(19.39,10.42))

# Return an estimate of the product k[2,1]*k[1,0],  where k[2,1] and k[1,0] are the 
# cross-correlation of order (2,1) and the marginal mean of the population distribution 
# respectively 
nPM( list( c(2,1), c(1,0) ), data1)

# Data assignment
data2&lt;-list(c(5.31,11.16,4.23),c(3.26,3.26,4.10),c(2.35,2.35,2.27),
c(4.31,10.16,6.45),c(3.1,2.3,3.2),c(3.20, 2.31, 7.3))

# Return an estimate of the product k[2,0,1]*k[1,1,0], where k[2,0,1] and k[1,1,0] 
# are joint cumulants of the population distribution
nPM( list( c(2,0,1), c(1,1,0) ), data2) 

</code></pre>

<hr>
<h2 id='nPolyk'>K-Statistics Master function</h2><span id='topic+nPolyk'></span>

<h3>Description</h3>

<p>The master function executes one of the functions to compute simple k-statistics <code>(nKS)</code>, 
multivariate k-statistics <code>(nKM)</code>, simple polykays <code>(nPS)</code> or multivariate polykays <code>(nPM)</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nPolyk( L = NULL, data = NULL, bhelp=NULL ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nPolyk_+3A_l">L</code></td>
<td>
<p>vector of orders</p>
</td></tr>
<tr><td><code id="nPolyk_+3A_data">data</code></td>
<td>
<p>vector of a (univariate or multivariate) sample data</p>
</td></tr>
<tr><td><code id="nPolyk_+3A_bhelp">bhelp</code></td>
<td>
<p><code>T=true</code> or <code>F=false</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The master function analizes the first two input variables and recalls one of the <code>nKS</code>, <code>nKM</code>, 
<code>nPS</code> or <code>nPM</code>  functions in the <code>kStatistics</code> package. <br /> <br /> 
Given a sample data:
</p>

<ol>
<li><p> simple       k-statistics are computed using <code>nPolyk(c(r), data))</code> or <code>nPolyk(list(c(r)), data))</code> 
<br />
</p>
</li>
<li><p> multivariate k-statistics are computed using <code>nPolyk(c(r, s), data))</code> or <code>nPolyk( list(c(r, s)), 
data))</code> <br />
</p>
</li>
<li><p> simple       polykays     are computed using <code>nPolyk(list(c(r),c(s)...),data))</code> <br />
</p>
</li>
<li><p> multivariate polykays     are computed using <code>nPolyk(list(c(r1, r2,...),c(s1, s2,...),...),data))</code></p>
</li></ol>
          


<h3>Value</h3>

<table>
<tr><td><code>float</code></td>
<td>
<p>the estimate of the (joint) cumulant or of the (joint) cumulant product</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The dimension of the vector with the sample data depends on the first parameter.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>E. Di Nardo, G. Guarino, D. Senato (2008) An unifying framework for k-statistics, polykays and their generalizations. 
Bernoulli. 14(2), 440-468. (download from <a href="https://arxiv.org/pdf/math/0607623.pdf">https://arxiv.org/pdf/math/0607623.pdf</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2008) Symbolic computation of moments of sampling distributions. 
Comp. Stat. Data Analysis. 52(11), 4909-4922. (download from <a href="https://arxiv.org/abs/0806.0129">https://arxiv.org/abs/0806.0129</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2009) A new method for fast computing unbiased estimators of cumulants. 
Statistics and Computing, 19, 155-165.  (download from <a href="https://arxiv.org/abs/0807.5008">https://arxiv.org/abs/0807.5008</a>) 
</p>
<p>P. McCullagh, J. Kolassa (2009), Scholarpedia, 4(3):4699. <a href="http://www.scholarpedia.org/article/Cumulants">http://www.scholarpedia.org/article/Cumulants</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nKS">nKS</a></code>,
<code><a href="#topic+nKM">nKM</a></code>,
<code><a href="#topic+nPS">nPS</a></code>,
<code><a href="#topic+nPM">nPM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data assignment
data1&lt;-c(16.34, 10.76, 11.84, 13.55, 15.85, 18.20, 7.51, 10.22, 12.52, 14.68, 16.08,
19.43,8.12, 11.20, 12.95, 14.77, 16.83, 19.80, 8.55, 11.58, 12.10, 15.02, 16.83, 
16.98, 19.92, 9.47, 11.68, 13.41, 15.35, 19.11)

# Display "KS:[1] -1.44706" which indicates the type of subfunction (nKS) called by 
# the master function nPolyk and gives the estimate of the third cumulant 
nPolyk(c(3),data1, TRUE) 
 
# Display "[1] -1.44706" (without the indication of the employed subfunction)
nPolyk(c(3),data1, FALSE)

# Display "PS:[1] 177.4233" which indicates the type of subfunction (nPS) called by 
# the master function nPolyk and gives the estimate of the product between the 
# variance k[2] and the mean k[1] 
nPolyk( list(  c(2), c(1) ),data1,TRUE)

# Data assignment
data2&lt;-list(c(5.31,11.16),c(3.26,3.26),c(2.35,2.35),c(8.32,14.34),c(13.48,49.45),
c(6.25,15.05),c(7.01,7.01),c(8.52,8.52),c(0.45,0.45),c(12.08,12.08),c(19.39,10.42))

# Display "KM:[1] -23.7379" which indicates the type of subfunction (nKM) called by 
# the master function nPolyk and gives the estimate of k[2,1]  
nPolyk(c(2,1),data2,TRUE)

# Display "PM:[1] 48.43243" which indicates the type of subfunction (nPM) called by 
# the master function nPolyk and gives the estimate of k[2,1]*k[1,0]  
nPolyk( list(  c(2,1), c(1,0) ),data2,TRUE)

</code></pre>

<hr>
<h2 id='nPS'>Simple Polykays</h2><span id='topic+nPS'></span>

<h3>Description</h3>

<p>Given a data sample, the function returns an estimate of a product of cumulants with fixed orders.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nPS( v = NULL, V = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nPS_+3A_v">v</code></td>
<td>
<p>vector of integers</p>
</td></tr>
<tr><td><code id="nPS_+3A_v">V</code></td>
<td>
<p>vector of a data sample</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simple polykays or generalized k-statistics are unbiased estimators of cumulant products
with minimum variance.
See the referred papers to read more about these estimators. Simple polykays are usually expressed 
in terms of power sum symmetric polynomials in the i.i.d. random variables of the sample. Thus, 
for the input sample <code>data</code>, running <code>nPS(c(i,j,...),data)</code> returns an estimate of 
the product <code>k[i]*k[j]*...</code> with <code>k[i], k[j], ...</code> the cumulants of the population 
distribution and <code>v=(i,j,...)</code> their fixed orders.
</p>


<h3>Value</h3>

<table>
<tr><td><code>float</code></td>
<td>
<p>the estimate of the polykay</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Called by the master <code><a href="#topic+nPolyk">nPolyk</a></code> function in the <code>kStatistics</code> package. 
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>E. Di Nardo, G. Guarino, D. Senato (2008) An unifying framework for k-statistics, polykays and their generalizations. 
Bernoulli. 14(2), 440-468. (download from <a href="https://arxiv.org/pdf/math/0607623.pdf">https://arxiv.org/pdf/math/0607623.pdf</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2008) Symbolic computation of moments of sampling distributions. 
Comp. Stat. Data Analysis. 52(11), 4909-4922. (download from <a href="https://arxiv.org/abs/0806.0129">https://arxiv.org/abs/0806.0129</a>) 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2009) A new method for fast computing unbiased estimators of cumulants. 
Statistics and Computing, 19, 155-165.  (download from <a href="https://arxiv.org/abs/0807.5008">https://arxiv.org/abs/0807.5008</a>) 
</p>
<p>P. McCullagh, J. Kolassa (2009), Scholarpedia, 4(3):4699. <a href="http://www.scholarpedia.org/article/Cumulants">http://www.scholarpedia.org/article/Cumulants</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nPolyk">nPolyk</a></code>,
<code><a href="#topic+nKS">nKS</a></code>,
<code><a href="#topic+nKM">nKM</a></code>,
<code><a href="#topic+nPM">nPM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data assignment
data&lt;-c(16.34, 10.76, 11.84, 13.55, 15.85, 18.20, 7.51, 10.22, 12.52, 14.68, 16.08, 
19.43,8.12, 11.20, 12.95, 14.77, 16.83, 19.80, 8.55, 11.58, 12.10, 15.02, 16.83, 
16.98, 19.92, 9.47, 11.68, 13.41, 15.35, 19.11)

# Return an estimate of the product k[2]*k[1], where k[1] and k[2] are the mean and 
# the variance of the population distribution respectively
nPS(c(2,1), data) 

</code></pre>

<hr>
<h2 id='nStirling2'>Stirling number of second kind</h2><span id='topic+nStirling2'></span>

<h3>Description</h3>

<p>The function computes the Stirling number of the second kind.</p>


<h3>Usage</h3>

<pre><code class='language-R'>nStirling2( n, k ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nStirling2_+3A_n">n</code></td>
<td>
<p>integer</p>
</td></tr>
<tr><td><code id="nStirling2_+3A_k">k</code></td>
<td>
<p>integer less or equal to <code>n</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Stirling number of the second kind <code>S(n,k)</code> is equal to the number of ways to split a 
set of cardinality <code>n</code> into <code>k</code> nonempty subsets. For example, if the set is <code>[a,b,c,d]</code>, then
the partitions in 2 blocks are: <code>[[a], [bcd]], [[b], [acd]], [[c], [abd]], [[d],[abc]]</code> with 
cardinalities (1,3) and <code>[ab, cd], [ac, bd], [ad, bc]</code> with cardinalities (2,2). Then <code>S(4,2)</code> 
is equal to 7. Note that (1,3) and (2,2) are also the partitions of the integer 4 in 2 parts.</p>


<h3>Value</h3>

<table>
<tr><td><code>integer</code></td>
<td>
<p>the Stirling number of the second kind</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Called by the <code><a href="#topic+nKS">nKS</a></code> and <code><a href="#topic+nKM">nKM</a></code> functions in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>R. P. Stanley (2012) Enumerative combinatorics. Vol.1. II edition. Cambridge Studies in Advanced Mathematics, 49. 
Cambridge University Press, Cambridge. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mkmSet">mkmSet</a></code>,
<code><a href="#topic+mCoeff">mCoeff</a></code>,
<code><a href="#topic+intPart">intPart</a></code>,
<code><a href="#topic+countP">countP</a></code>,
<code><a href="#topic+ff">ff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return the number of ways to split a set of 6 objects into 2 nonempty subsets
nStirling2(6,2) 

</code></pre>

<hr>
<h2 id='oBellPol'>
Ordinary Bell polynomials
</h2><span id='topic+oBellPol'></span>

<h3>Description</h3>

<p>The function generates a complete or a partial ordinary Bell polynomial.</p>


<h3>Usage</h3>

<pre><code class='language-R'>oBellPol(n = 1, m = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oBellPol_+3A_n">n</code></td>
<td>
<p>integer, the degree of the polynomial</p>
</td></tr>
<tr><td><code id="oBellPol_+3A_m">m</code></td>
<td>
<p>integer, the fixed degree of each monomial in the polynomial</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Faa di Bruno's formula gives the coefficients of the exponential formal power series obtained 
from the composition <code>f[g()]</code> of the exponential formal power series <code>f</code> with <code>g</code>. The 
partial ordinary Bell polynomials <code>B[n,m]</code> can be expressed 
in the terms of the partial exponential Bell polynomials <code>B(n,m)(y[1],...,y[n-m+1])</code>  using the 
following formula:  
</p>

<table>
<tr>
 <td style="text-align: left;"><code>B[n,m](y[1],...,y[n-m+1])=k!/n!B(n,m)(y[1],...,y[n-m+1]).</code></td>
</tr>

</table>
  
<p>The complete ordinary Bell polynomials are given by <code>B[n]=B[n,1]+B[n,2]+...B[n,n]</code>, where 
<code>B[n,m]</code> is the partial ordinary  Bell polynomial of order <code>(n,m)</code> for <code>m</code> from <code>1</code>
to <code>n</code>.</p>


<h3>Value</h3>

<table>
<tr><td><code>string</code></td>
<td>
<p>the expression of the polynomial</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The value of the first parameter is the same as the <code><a href="#topic+MFB">MFB</a></code> function in the univariate with 
univariate composition.</p>


<h3>Note</h3>

<p>This function calls the <code><a href="#topic+MFB">MFB</a></code> function in the <code>kStatistics</code> package.</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>C.A. Charalambides (2002) Enumerative Combinatoris, Chapman &amp; Haii/CRC. 
</p>
<p>E. Di Nardo, G. Guarino, D. Senato (2011) A new algorithm for computing the multivariate Faa di Bruno's formula. 
Appl. Math. Comp. 217, 6286-6295. (download from <a href="https://arxiv.org/abs/1012.6008">https://arxiv.org/abs/1012.6008</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFB">MFB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Return the complete ordinary Bell Polynomial for n=5, that is 
# (y1^5) + 20(y1^3)(y2) + 30(y1)(y2^2) + 60(y1^2)(y3) + 120(y2)(y3) + 120(y1)(y4) + 120(y5)
oBellPol(5)
#
# OR (same output)
#
oBellPol(5,0)

# Return the partial ordinary Bell polynomial for n=5 and m=3, that is 
# 30(y1)(y2^2) + 60(y1^2)(y3)
oBellPol(5,3)

</code></pre>

<hr>
<h2 id='pCart'>Cartesian product</h2><span id='topic+pCart'></span>

<h3>Description</h3>

<p>The function returns the cartesian product between vectors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pCart( L ) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pCart_+3A_l">L</code></td>
<td>
<p>vectors in a list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code><a href="#topic+pCart">pCart</a></code> function pairs any element of the first vector with any element of 
the second vector, iteratively, if there are more than two vectors in input. Repetitions are allowed. 
See examples. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>list</code></td>
<td>
<p>the list with the cartesian product</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Called by the <code><a href="#topic+nPS">nPS</a></code> function in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>D. E. Knuth (1998) The Art of Computer Programming. (3rd ed.) Addison Wesley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mpCart">mpCart</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- c(1,2)
B &lt;- c(3,4,5) 
# Return the cartesian product [[1,3],[1,4],[1,5],[2,3],[2,4],[2,5]]
pCart( list( A, B) ) 
 

L1&lt;-list( c(1,1), c(2)) 
L2&lt;-list( c(5,5), c(7) )
# Return the cartesian product [[1,1],[5,5]], [[1,1],[7]], [[2],[5,5]], [[2],[7]]
# and assign the result to L3
L3&lt;-pCart ( list(L1, L2) )
 
# Return the cartesian product between L3 and [7].
# The result is [[1,1],[5,5],[7]], [[1,1],[7],[7]], [[2],[5,5],[7]], [[2],[7],[7]]
pCart ( list(L3, c(7)) ) 

</code></pre>

<hr>
<h2 id='powS'>Power sums</h2><span id='topic+powS'></span>

<h3>Description</h3>

<p>The function returns the value of the power sum symmetric 
polynomial, with fixed degrees and in one or more sets of variables, when the 
variables are substituted with the input lists of numerical values.</p>


<h3>Usage</h3>

<pre><code class='language-R'>powS(vn = NULL, lvd = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powS_+3A_vn">vn</code></td>
<td>
<p>vector of integers (the powers of the indeterminates)</p>
</td></tr>
<tr><td><code id="powS_+3A_lvd">lvd</code></td>
<td>
<p>list of numerical values in place of the variables</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given the lists of numerical values <code>(x[1],x[2],...), (y[1],y[2],...), (z[1],z[2],...), ...</code> 
in the input parameter <code>lvd</code> and the integers <code>(n,m,j,...)</code> in the input parameter <code>vn</code>, 
the <code><a href="#topic+powS">powS</a></code> function returns the value of 
<code>(x[1]^n)*(y[1]^m)*(z[1]^j)*...+(x[2]^n)*(y[2]^m)*(z[2]^j)*+...</code>. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>integer</code></td>
<td>
<p>the value of the polynomial</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Called by the  <code><a href="#topic+nKS">nKS</a></code>, <code><a href="#topic+nKM">nKM</a></code>, <code><a href="#topic+nPS">nPS</a></code> and <code><a href="#topic+nPM">nPM</a></code> functions 
in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>E. Di Nardo, G. Guarino, D. Senato (2008) Symbolic computation of moments of sampling distributions. 
Comp. Stat. Data Analysis. 52(11), 4909-4922. (download from <a href="https://arxiv.org/abs/0806.0129">https://arxiv.org/abs/0806.0129</a>) 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Return 1^3 + 2^3 + 3^3 = 36
powS(c(3), list(c(1),c(2),c(3))) 

# Return (1^3 * 4^2) + (2^3 * 5^2) + (3^3 * 6^2) = 1188
powS(c(3,2),list(c(1,4),c(2,5),c(3,6))) 

</code></pre>

<hr>
<h2 id='pPart'>Partition polynomials</h2><span id='topic+pPart'></span>

<h3>Description</h3>

<p>The function generates the partition polynomial of degree <code>n</code>, whose 
coefficients are the number of partitions of <code>n</code> into <code>k</code> parts for <code>k</code> 
from <code>1</code> to <code>n</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>pPart(n = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pPart_+3A_n">n</code></td>
<td>
<p>integer, the degree of the polynomial </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Faa di Bruno's formula gives the coefficients of the exponential formal 
power series obtained from the composition <code>f[g()]</code> of the exponential formal power 
series <code>f</code> and <code>g</code>. The partition polynomial <code>F[n]</code> of degree <code>n</code> 
is obtained using the Faa di Bruno's formula, output of the <code><a href="#topic+MFB">MFB</a></code> function, 
in the case &quot;composition of univariate <code>f</code> with univariate <code>g</code>&quot; with <code>f[i]=1/n!, 
g[i]^k=(i!)^k*k!*y^k</code> for <code>i</code> and <code>k</code> from <code>1</code> to <code>n</code>. Note the 
symbolic substitution of <code>g[i]</code>, as the power of <code>g[i]</code> appears 
in the substitution. This function is an example of application of Faa di Bruno's formula 
and the symbolic calculus with two indexes.</p>


<h3>Value</h3>

<table>
<tr><td><code>string</code></td>
<td>
<p>the expression of the polynomial</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>The value of the first parameter is the same as the <code><a href="#topic+MFB">MFB</a></code> function 
in the univariate with univariate case composition.</p>


<h3>Note</h3>

<p>This function calls the <code><a href="#topic+MFB">MFB</a></code> function in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>References</h3>

<p>E. Di Nardo E., G. Guarino, D. Senato (2011) A new algorithm for computing the multivariate Faa di Bruno's formula. 
Appl. Math. Comp. 217, 6286-6295. (download from <a href="https://arxiv.org/abs/1012.6008">https://arxiv.org/abs/1012.6008</a>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+MFB">MFB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Return the partition polynomial F[5]
pPart(5)

# Return the partition polynomial F[11] and its evaluation when y=7  
#
s&lt;-pPart(11)          # run the command
s&lt;-paste0("1",s)      # add the coefficient to the first term (fixed command)
s&lt;-gsub(" y","1y",s)  # replace the variable y without coefficient (fixed command)
s&lt;-gsub("y", "*7",s)  # assignment y = 7
eval(parse(text=s))   # evaluation of the expression (fixed command)
</code></pre>

<hr>
<h2 id='pPoly'>Product of Polynomials</h2><span id='topic+pPoly'></span>

<h3>Description</h3>

<p>The function returns the product between polynomials without constant term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pPoly( L = NULL) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pPoly_+3A_l">L</code></td>
<td>
<p>lists of the coefficients of the polynomials</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>vector</code></td>
<td>
<p>the coefficients of the polynomial output of the product</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Called by the <code><a href="#topic+nKS">nKS</a></code> and <code><a href="#topic+nKM">nKM</a></code> functions in the <code>kStatistics</code> package.
</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# c(1,-3) are the coefficients of (x-3x^2), c(2) is the coefficient of 2x
# Return c(0, 2,-6), coefficients of 2x^2-6x^3 =(x-3x^2)*(2x) 
pPoly(list(c(1,-3), c(2)))

# c(0,3,-2) are the coefficients of 3x^2-2x^3, c(0,2,-1) are the coefficients of (2x^2-x^3)
# Return c(0,0,0,6,-7,2), coefficients of 6x^4-7x^5+2x^6=(3x^2-2x^3)*(2x^2-x^3)
pPoly(list(c(0,3,-2),c(0,2,-1)))                       

</code></pre>

<hr>
<h2 id='Set2expr'>Conversion of a vector into a string</h2><span id='topic+Set2expr'></span>

<h3>Description</h3>

<p>The function converts a set into a string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Set2expr(v = NULL )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Set2expr_+3A_v">v</code></td>
<td>
<p>Set</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>string</code></td>
<td>
<p>the string</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Called by the <code><a href="#topic+MFB">MFB</a></code> and <code><a href="#topic+MFB">MFB</a></code>  functions in the <code><a href="#topic+kStatistics">kStatistics</a></code> package
being useful for manipulating the result before its print.</p>


<h3>Author(s)</h3>

<p>Elvira Di Nardo <a href="mailto:elvira.dinardo@unito.it">elvira.dinardo@unito.it</a>,<br /> 
Giuseppe Guarino <a href="mailto:giuseppe.guarino@rete.basilicata.it">giuseppe.guarino@rete.basilicata.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# To print 6f[3]^2g[2]^5 run 
Set2expr( list(c("1","2","f","3","2"),c("1","3","g","2","5"))) 

# Run MFB(c(3),1) to recover f[3]g[1]^3 + 3f[2]g[1]g[2] + f[1]g[3]
# Run S&lt;-MFB2Set(MFB(c(3),1)) to convert the output of MFB(c(3),1) into a vector.  
# The result is
# "1" "1" "f" "3" "1"
# "1" "1" "g" "1" "3"
# "2" "3" "f" "2" "1"
# "2" "1" "g" "1" "1"
# "2" "1" "g" "2" "1"
# "3" "1" "f" "1" "1"
# "3" "1" "g" "3" "1"
# To set f[2]=1, run S[[3]][4]&lt;-"" and S[[3]][3]&lt;-"".
# Then run Set2expr(S) to recover  
# f[3]g[1]^3 + 3g[1]g[2] + f[1]g[3]
#
S&lt;-MFB2Set(MFB(c(3),1))
S[[3]][4]&lt;-""
S[[3]][3]&lt;-""
Set2expr(S)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
