<!DOCTYPE html><html><head><title>Help for package lpcde</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lpcde}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#b_x'><p>bx</p></a></li>
<li><a href='#basis_vec'><p>Unit basis vector</p></a></li>
<li><a href='#bw_irot'><p>IROT Bandwidth selection</p></a></li>
<li><a href='#bw_rot'><p>ROT Bandwidth selection</p></a></li>
<li><a href='#c_exact'><p>C matrix</p>
Internal Function</a></li>
<li><a href='#c_x'><p>c_x vector (Internal Function)</p></a></li>
<li><a href='#check_inv'><p>Matrix invertibility check</p></a></li>
<li><a href='#coef.lpbwcde'><p>Coef method for local polynomial density bandwidth selection</p></a></li>
<li><a href='#coef.lpcde'><p>Coef method for local polynomial density conditional estimation</p></a></li>
<li><a href='#confint.lpcde'><p>Confint method for local polynomial density conditional estimation</p></a></li>
<li><a href='#cov_hat'><p>cov_hat: covariance estimator</p></a></li>
<li><a href='#fhat'><p>Estimator construction</p></a></li>
<li><a href='#int_val'><p>Lp integral (Internal Function)</p></a></li>
<li><a href='#kernel_eval'><p>Kernel Evaluation function (Internal Function)</p></a></li>
<li><a href='#lpbwcde'><p>Data-driven bandwidth selection for local polynomial conditional density estimators</p></a></li>
<li><a href='#lpcde'><p>Local polynomial conditional density estimation</p></a></li>
<li><a href='#lpcde_fn'><p>lpcde_fn: Conditional density estimator.</p></a></li>
<li><a href='#mvec'><p>Polynomial order vector</p></a></li>
<li><a href='#normal_dgps'><p>Internal function.</p></a></li>
<li><a href='#plot.lpcde'><p>Plot method for local polynomial density conditional estimation</p></a></li>
<li><a href='#poly_base'><p>Polynomial basis vector expansion</p></a></li>
<li><a href='#print_all_sumC'><p>All Sums in C++ (Internal Function)</p></a></li>
<li><a href='#print.lpbwcde'><p>Print method for local polynomial conditional density bandwidth selection</p></a></li>
<li><a href='#print.lpcde'><p>Print method for local polynomial conditional density estimation</p></a></li>
<li><a href='#S_exact'><p>S matrix</p>
Internal Function
</p>
<p>Generate Matrix</p></a></li>
<li><a href='#S_x'><p>Sx Matrix (Internal Function)</p></a></li>
<li><a href='#summary.lpbwcde'><p>Summary method for local polynomial conditional density bandwidth selection</p></a></li>
<li><a href='#summary.lpcde'><p>Summary method for local polynomial density conditional estimation</p></a></li>
<li><a href='#T_x'><p>T_x matrix (Internal Function)</p></a></li>
<li><a href='#T_y'><p>T_y matrix (Internal Function)</p></a></li>
<li><a href='#T_y_exact'><p>T matrix</p>
Internal Function
Generate Matrix</a></li>
<li><a href='#vcov.lpcde'><p>Variance-Covariance</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Boundary Adaptive Local Polynomial Conditional Density Estimator</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rajita Chandak &lt;rchandak@princeton.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for estimation and inference of conditional densities, derivatives and functions. This is the companion software for Cattaneo, Chandak, Jansson and Ma (2024) &lt;<a href="https://arxiv.org/abs/2204.10359">arXiv:2204.10359</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.8), ggplot2, purrr, MASS, mvtnorm, combinat,
Matrix, Rdpack, stats</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), covr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-28 17:20:48 UTC; rajitachandak</td>
</tr>
<tr>
<td>Author:</td>
<td>Rajita Chandak [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-28 18:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='b_x'>bx</h2><span id='topic+b_x'></span>

<h3>Description</h3>

<p>Function for estimating the constants in the estimation formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>b_x(datavec, s_mat, e_vec, q, kernel_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="b_x_+3A_datavec">datavec</code></td>
<td>
<p>Dataset, vector.</p>
</td></tr>
<tr><td><code id="b_x_+3A_s_mat">s_mat</code></td>
<td>
<p>S_hat matrix.</p>
</td></tr>
<tr><td><code id="b_x_+3A_q">q</code></td>
<td>
<p>Polynomial order.</p>
</td></tr>
<tr><td><code id="b_x_+3A_kernel_type">kernel_type</code></td>
<td>
<p>Kernel function choice.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of products for each data point.
</p>

<hr>
<h2 id='basis_vec'>Unit basis vector</h2><span id='topic+basis_vec'></span>

<h3>Description</h3>

<p>Function to generate unit basis vector according to polynomial order
and derivative order. This function returns unit vector that is the same size
as the vector returned by <code>poly_base(x, p)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis_vec(x, p, mu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basis_vec_+3A_x">x</code></td>
<td>
<p>Sample input scalar or vector.</p>
</td></tr>
<tr><td><code id="basis_vec_+3A_p">p</code></td>
<td>
<p>Polynomial order.</p>
</td></tr>
<tr><td><code id="basis_vec_+3A_mu">mu</code></td>
<td>
<p>Derivative order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of appropriate length with ones corresponding to entries of order <code>mu</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>basis_vec(x = 2, p = 5, mu = 1)
</code></pre>

<hr>
<h2 id='bw_irot'>IROT Bandwidth selection</h2><span id='topic+bw_irot'></span>

<h3>Description</h3>

<p>Internal Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_irot(y_data, x_data, y_grid, x, p, q, mu, nu, kernel_type, regularize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_irot_+3A_y_data">y_data</code></td>
<td>
<p>Numeric matrix/data frame, the raw data of independent.</p>
</td></tr>
<tr><td><code id="bw_irot_+3A_x_data">x_data</code></td>
<td>
<p>Numeric matrix/data frame, the raw data of covariates.</p>
</td></tr>
<tr><td><code id="bw_irot_+3A_y_grid">y_grid</code></td>
<td>
<p>Numeric vector, the evaluation points.</p>
</td></tr>
<tr><td><code id="bw_irot_+3A_x">x</code></td>
<td>
<p>Numeric, specifies the evaluation point(s) in the x-direction.</p>
</td></tr>
<tr><td><code id="bw_irot_+3A_p">p</code></td>
<td>
<p>Integer, polynomial order.</p>
</td></tr>
<tr><td><code id="bw_irot_+3A_q">q</code></td>
<td>
<p>Integer, polynomial order.</p>
</td></tr>
<tr><td><code id="bw_irot_+3A_mu">mu</code></td>
<td>
<p>Integer, order of derivative.</p>
</td></tr>
<tr><td><code id="bw_irot_+3A_nu">nu</code></td>
<td>
<p>Integer, order of derivative.</p>
</td></tr>
<tr><td><code id="bw_irot_+3A_kernel_type">kernel_type</code></td>
<td>
<p>String, the kernel.</p>
</td></tr>
<tr><td><code id="bw_irot_+3A_regularize">regularize</code></td>
<td>
<p>Boolean.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bandwidth sequence
</p>

<hr>
<h2 id='bw_rot'>ROT Bandwidth selection</h2><span id='topic+bw_rot'></span>

<h3>Description</h3>

<p>Internal Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bw_rot(y_data, x_data, y_grid, x, p, q, mu, nu, kernel_type, regularize)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bw_rot_+3A_y_data">y_data</code></td>
<td>
<p>Numeric matrix/data frame, the raw data of independent.</p>
</td></tr>
<tr><td><code id="bw_rot_+3A_x_data">x_data</code></td>
<td>
<p>Numeric matrix/data frame, the raw data of covariates.</p>
</td></tr>
<tr><td><code id="bw_rot_+3A_y_grid">y_grid</code></td>
<td>
<p>Numeric vector, the evaluation points.</p>
</td></tr>
<tr><td><code id="bw_rot_+3A_x">x</code></td>
<td>
<p>Numeric, specifies the evaluation point(s) in the x-direction.</p>
</td></tr>
<tr><td><code id="bw_rot_+3A_p">p</code></td>
<td>
<p>Integer, polynomial order.</p>
</td></tr>
<tr><td><code id="bw_rot_+3A_q">q</code></td>
<td>
<p>Integer, polynomial order.</p>
</td></tr>
<tr><td><code id="bw_rot_+3A_mu">mu</code></td>
<td>
<p>Integer, order of derivative.</p>
</td></tr>
<tr><td><code id="bw_rot_+3A_nu">nu</code></td>
<td>
<p>Integer, order of derivative.</p>
</td></tr>
<tr><td><code id="bw_rot_+3A_kernel_type">kernel_type</code></td>
<td>
<p>String, the kernel.</p>
</td></tr>
<tr><td><code id="bw_rot_+3A_regularize">regularize</code></td>
<td>
<p>Boolean.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bandwidth sequence
</p>

<hr>
<h2 id='c_exact'>C matrix
Internal Function</h2><span id='topic+c_exact'></span>

<h3>Description</h3>

<p>C matrix
Internal Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_exact(lower = -1, upper = -1, eval_pt, m, p, kernel_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_exact_+3A_eval_pt">eval_pt</code></td>
<td>
<p>evaluation point.</p>
</td></tr>
<tr><td><code id="c_exact_+3A_m">m</code></td>
<td>
<p>derivative order.</p>
</td></tr>
<tr><td><code id="c_exact_+3A_p">p</code></td>
<td>
<p>Nonnegative integer, polynomial order.</p>
</td></tr>
<tr><td><code id="c_exact_+3A_kernel_type">kernel_type</code></td>
<td>
<p>String, kernel type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a (p+1)-by-1 matrix
</p>

<hr>
<h2 id='c_x'>c_x vector (Internal Function)</h2><span id='topic+c_x'></span>

<h3>Description</h3>

<p>c_x vector generated as described in main paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c_x(x_data, eval_pt, m, q, h, kernel_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c_x_+3A_x_data">x_data</code></td>
<td>
<p>Data of covariates.</p>
</td></tr>
<tr><td><code id="c_x_+3A_eval_pt">eval_pt</code></td>
<td>
<p>Evaluation point.</p>
</td></tr>
<tr><td><code id="c_x_+3A_m">m</code></td>
<td>
<p>Order of polynomial.</p>
</td></tr>
<tr><td><code id="c_x_+3A_q">q</code></td>
<td>
<p>Maximum degree for x.</p>
</td></tr>
<tr><td><code id="c_x_+3A_h">h</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
<tr><td><code id="c_x_+3A_kernel_type">kernel_type</code></td>
<td>
<p>Type of kernel function.</p>
</td></tr>
</table>

<hr>
<h2 id='check_inv'>Matrix invertibility check</h2><span id='topic+check_inv'></span>

<h3>Description</h3>

<p>Function to check intertibility of matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_inv(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_inv_+3A_m">m</code></td>
<td>
<p>Matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if matrix is invertible.
</p>

<hr>
<h2 id='coef.lpbwcde'>Coef method for local polynomial density bandwidth selection</h2><span id='topic+coef.lpbwcde'></span>

<h3>Description</h3>

<p>The coef method for local polynomial density bandwidth selection objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpbwcde'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.lpbwcde_+3A_object">object</code></td>
<td>
<p>Class &quot;lpbwcde&quot; object, obtained by calling <code><a href="#topic+lpbwcde">lpbwcde</a></code>.</p>
</td></tr>
<tr><td><code id="coef.lpbwcde_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Matrix</code></td>
<td>
<p>A matrix containing y_grid points and selected bandwidths.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Rajita Chandak (maintainer), Princeton University. <a href="mailto:rchandak@princeton.edu">rchandak@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma, University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpbwcde">lpbwcde</a></code> for data-driven bandwidth selection.
</p>
<p>Supported methods: <code><a href="#topic+coef.lpbwcde">coef.lpbwcde</a></code>, <code><a href="#topic+print.lpbwcde">print.lpbwcde</a></code>, <code><a href="#topic+summary.lpbwcde">summary.lpbwcde</a></code>.
</p>
<p>n=100
x_data = as.matrix(rnorm(n, mean=0, sd=1))
y_data = as.matrix(rnorm(n, mean=0, sd=1))
y_grid = stats::quantile(y_data, seq(from=0.1, to=0.9, by=0.1))bandwidth selection
</p>
<p>y_grid = stats::quantile(y_data, seq(from=0.1, to=0.9, by=0.1))
model2 = lpcde::lpbwcde(y_data=y_data, x_data=x_data, x=0, y_grid = y_grid, bw_type = &quot;mse-rot&quot;)
coef(model2)
</p>

<hr>
<h2 id='coef.lpcde'>Coef method for local polynomial density conditional estimation</h2><span id='topic+coef.lpcde'></span>

<h3>Description</h3>

<p>The coef method for local polynomial conditional density objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpcde'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.lpcde_+3A_object">object</code></td>
<td>
<p>Class &quot;lpcde&quot; object, obtained by calling <code><a href="#topic+lpcde">lpcde</a></code>.</p>
</td></tr>
<tr><td><code id="coef.lpcde_+3A_...">...</code></td>
<td>
<p>Additional options.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>outputs</code></td>
<td>
<p>A matrix containing the estimates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Rajita Chandak (maintainer), Princeton University. <a href="mailto:rchandak@princeton.edu">rchandak@princeton.edu</a>
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma, University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpcde">lpcde</a></code> for local polynomial conditional density estimation.
</p>
<p>Supported methods: <code><a href="#topic+coef.lpcde">coef.lpcde</a></code>, <code><a href="#topic+confint.lpcde">confint.lpcde</a></code>,
<code><a href="#topic+plot.lpcde">plot.lpcde</a></code>, <code><a href="#topic+print.lpcde">print.lpcde</a></code>,
<code><a href="#topic+summary.lpcde">summary.lpcde</a></code>, <code><a href="#topic+vcov.lpcde">vcov.lpcde</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=100
x_data = as.matrix(rnorm(n, mean=0, sd=1))
y_data = as.matrix(rnorm(n, mean=0, sd=1))
y_grid = stats::quantile(y_data, seq(from=0.1, to=0.9, by=0.1))
# density estimation
model1 = lpcde::lpcde(x_data=x_data, y_data=y_data, y_grid=y_grid, x=0, bw=0.5)
coef(model1)

</code></pre>

<hr>
<h2 id='confint.lpcde'>Confint method for local polynomial density conditional estimation</h2><span id='topic+confint.lpcde'></span>

<h3>Description</h3>

<p>The confint method for local polynomial conditional density objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpcde'
confint(
  object,
  parm = NULL,
  level = NULL,
  CIuniform = FALSE,
  CIsimul = 2000,
  alpha = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.lpcde_+3A_object">object</code></td>
<td>
<p>Class &quot;lpdensity&quot; object, obtained by calling <code><a href="#topic+lpcde">lpcde</a></code>.</p>
</td></tr>
<tr><td><code id="confint.lpcde_+3A_parm">parm</code></td>
<td>
<p>Integer, indicating which parameters are to be given confidence intervals.</p>
</td></tr>
<tr><td><code id="confint.lpcde_+3A_level">level</code></td>
<td>
<p>Numeric scalar between 0 and 1, the significance level for computing
confidence intervals</p>
</td></tr>
<tr><td><code id="confint.lpcde_+3A_ciuniform">CIuniform</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> (default), plotting either pointwise confidence intervals (<code>FALSE</code>) or
uniform confidence bands (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="confint.lpcde_+3A_cisimul">CIsimul</code></td>
<td>
<p>Positive integer, specifies the number of simulations used to construct critical values (default is <code>2000</code>). This
option is ignored if <code>CIuniform=FALSE</code>.</p>
</td></tr>
<tr><td><code id="confint.lpcde_+3A_alpha">alpha</code></td>
<td>
<p>Numeric scalar between 0 and 1, specifies the significance level for plotting
confidence intervals/bands.</p>
</td></tr>
<tr><td><code id="confint.lpcde_+3A_...">...</code></td>
<td>
<p>Additional options, including (i) <code>grid</code> specifies a subset of grid points
to display the bandwidth; (ii) <code>gridIndex</code> specifies the indices of grid points
to display the bandwidth (this is the same as <code>parm</code>);(iii)
<code>CIuniform</code> specifies whether displaying pointwise confidence intervals
(<code>FALSE</code>, default) or
the uniform confidence band (<code>TRUE</code>); (iv) <code>CIsimul</code> specifies the number of
simulations used to construct critical values (default is 2000).</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Estimate</code></td>
<td>
<p>A matrix containing grid points, estimates and confidence interval end points using p- and q-th order local polynomials
as well as bias-corrected estimates and corresponding confidence intervals.</p>
</td></tr>
<tr><td><code>crit_val</code></td>
<td>
<p>The critical value used in computing the confidence interval end points.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Rajita Chandak (maintainer), Princeton University. <a href="mailto:rchandak@princeton.edu">rchandak@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma, University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpcde">lpcde</a></code> for local polynomial conditional density estimation.
</p>
<p>Supported methods: <code><a href="#topic+coef.lpcde">coef.lpcde</a></code>, <code><a href="#topic+confint.lpcde">confint.lpcde</a></code>,
<code><a href="#topic+plot.lpcde">plot.lpcde</a></code>, <code><a href="#topic+print.lpcde">print.lpcde</a></code>,
<code><a href="#topic+summary.lpcde">summary.lpcde</a></code>, <code><a href="#topic+vcov.lpcde">vcov.lpcde</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=100
x_data = as.matrix(rnorm(n, mean=0, sd=1))
y_data = as.matrix(rnorm(n, mean=0, sd=1))
y_grid = stats::quantile(y_data, seq(from=0.1, to=0.9, by=0.1))
# density estimation
model1 = lpcde::lpcde(x_data=x_data, y_data=y_data, y_grid=y_grid, x=0, bw=0.5)
confint(model1)

</code></pre>

<hr>
<h2 id='cov_hat'>cov_hat: covariance estimator</h2><span id='topic+cov_hat'></span>

<h3>Description</h3>

<p>Function for estimating the variance-covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_hat(x_data, y_data, x, y_grid, p, q, mu, nu, h, kernel_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cov_hat_+3A_x_data">x_data</code></td>
<td>
<p>Covariate dataset, vector or matrix.</p>
</td></tr>
<tr><td><code id="cov_hat_+3A_y_data">y_data</code></td>
<td>
<p>Response variable dataset, vector.</p>
</td></tr>
<tr><td><code id="cov_hat_+3A_x">x</code></td>
<td>
<p>Numeric vector or matrix, specifies the grid of evaluation points
along x-direction.</p>
</td></tr>
<tr><td><code id="cov_hat_+3A_y_grid">y_grid</code></td>
<td>
<p>Numeric vector, specifies the grid of evaluation points along
y-direction.</p>
</td></tr>
<tr><td><code id="cov_hat_+3A_p">p</code></td>
<td>
<p>Polynomial order for y.</p>
</td></tr>
<tr><td><code id="cov_hat_+3A_q">q</code></td>
<td>
<p>Polynomial order for covariates.</p>
</td></tr>
<tr><td><code id="cov_hat_+3A_mu">mu</code></td>
<td>
<p>Degree of derivative with respect to y.</p>
</td></tr>
<tr><td><code id="cov_hat_+3A_nu">nu</code></td>
<td>
<p>Degree of derivative with respect to x.</p>
</td></tr>
<tr><td><code id="cov_hat_+3A_h">h</code></td>
<td>
<p>Numeric, bandwidth vector.</p>
</td></tr>
<tr><td><code id="cov_hat_+3A_kernel_type">kernel_type</code></td>
<td>
<p>Kernel function choice.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Covariance matrix for all the grid points
</p>

<hr>
<h2 id='fhat'>Estimator construction</h2><span id='topic+fhat'></span>

<h3>Description</h3>

<p>Function for estimating the density function and its derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fhat(x_data, y_data, x, y_grid, p, q, mu, nu, h, kernel_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fhat_+3A_x_data">x_data</code></td>
<td>
<p>Covariate dataset, vector or matrix.</p>
</td></tr>
<tr><td><code id="fhat_+3A_y_data">y_data</code></td>
<td>
<p>Response variable dataset, vector.</p>
</td></tr>
<tr><td><code id="fhat_+3A_x">x</code></td>
<td>
<p>Numeric vector or matrix, specifies the grid of evaluation points along x-direction.</p>
</td></tr>
<tr><td><code id="fhat_+3A_y_grid">y_grid</code></td>
<td>
<p>Numeric vector, specifies the grid of evaluation points along y-direction.</p>
</td></tr>
<tr><td><code id="fhat_+3A_p">p</code></td>
<td>
<p>Polynomial order for y.</p>
</td></tr>
<tr><td><code id="fhat_+3A_q">q</code></td>
<td>
<p>Polynomial order for covariates.</p>
</td></tr>
<tr><td><code id="fhat_+3A_mu">mu</code></td>
<td>
<p>Degree of derivative with respect to y.</p>
</td></tr>
<tr><td><code id="fhat_+3A_nu">nu</code></td>
<td>
<p>Degree of derivative with respect to x.</p>
</td></tr>
<tr><td><code id="fhat_+3A_h">h</code></td>
<td>
<p>Numeric, bandwidth vector.</p>
</td></tr>
<tr><td><code id="fhat_+3A_kernel_type">kernel_type</code></td>
<td>
<p>Kernel function choice.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Conditional density estimate at all grid points.
</p>

<hr>
<h2 id='int_val'>Lp integral (Internal Function)</h2><span id='topic+int_val'></span>

<h3>Description</h3>

<p>Local polynomial integral evaluation
calculation of elements of S_y and middle integral (evaluating integral at end points).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_val(l, a, b, kernel_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int_val_+3A_l">l</code></td>
<td>
<p>Degree of polynomial being integrated.</p>
</td></tr>
<tr><td><code id="int_val_+3A_a">a</code></td>
<td>
<p>Lower limit of integration.</p>
</td></tr>
<tr><td><code id="int_val_+3A_b">b</code></td>
<td>
<p>Upper limit of integration.</p>
</td></tr>
<tr><td><code id="int_val_+3A_kernel_type">kernel_type</code></td>
<td>
<p>Type of kernel function. Choose from &quot;uniform&quot;, &quot;triangular&quot;, &quot;epanechnikov&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of integral.
</p>

<hr>
<h2 id='kernel_eval'>Kernel Evaluation function (Internal Function)</h2><span id='topic+kernel_eval'></span>

<h3>Description</h3>

<p>Function that evaluates product kernel at x based on the chosen function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_eval(x, kernel_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_eval_+3A_x">x</code></td>
<td>
<p>Evaluation point.</p>
</td></tr>
<tr><td><code id="kernel_eval_+3A_kernel_type">kernel_type</code></td>
<td>
<p>Type of kernel function. Choose from &quot;uniform&quot;, &quot;triangular&quot;, &quot;epanechnikov&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Kernel evaluated at <code>x</code>.
</p>

<hr>
<h2 id='lpbwcde'>Data-driven bandwidth selection for local polynomial conditional density estimators</h2><span id='topic+lpbwcde'></span>

<h3>Description</h3>

<p><code><a href="#topic+lpbwcde">lpbwcde</a></code> implements the bandwidth selection methods for local
polynomial based conditionaldensity (and derivatives) estimation proposed and studied
in (Cattaneo et al. 2024).
</p>
<p>Companion command: <code><a href="#topic+lpcde">lpcde</a></code> for estimation and robust bias-corrected inference.
</p>
<p>Related <code>Stata</code> and <code>R</code> packages useful for nonparametric estimation and inference are
available at <a href="https://nppackages.github.io/">https://nppackages.github.io/</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpbwcde(
  y_data,
  x_data,
  x,
  y_grid = NULL,
  p = NULL,
  q = NULL,
  grid_spacing = "",
  ng = NULL,
  mu = NULL,
  nu = NULL,
  kernel_type = c("epanechnikov", "triangular", "uniform"),
  bw_type = c("mse-rot", "imse-rot"),
  regularize = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpbwcde_+3A_y_data">y_data</code></td>
<td>
<p>Numeric matrix/data frame, the raw data of independent.</p>
</td></tr>
<tr><td><code id="lpbwcde_+3A_x_data">x_data</code></td>
<td>
<p>Numeric matrix/data frame, the raw data of covariates.</p>
</td></tr>
<tr><td><code id="lpbwcde_+3A_x">x</code></td>
<td>
<p>Numeric, specifies the evaluation point in the x-direction. Default is median of the dataset.</p>
</td></tr>
<tr><td><code id="lpbwcde_+3A_y_grid">y_grid</code></td>
<td>
<p>Numeric, specifies the grid of evaluation points. When set to default, grid points
will be chosen as 0.05-0.95 percentiles of the data, with a step size of 0.05.</p>
</td></tr>
<tr><td><code id="lpbwcde_+3A_p">p</code></td>
<td>
<p>Nonnegative integer, specifies the order of the local polynomial for <code>Y</code> used to
construct point estimates. (Default is <code>2</code>.)</p>
</td></tr>
<tr><td><code id="lpbwcde_+3A_q">q</code></td>
<td>
<p>Nonnegative integer, specifies the order of the local polynomial for <code>X</code> used to
construct point estimates. (Default is <code>1</code>.)</p>
</td></tr>
<tr><td><code id="lpbwcde_+3A_grid_spacing">grid_spacing</code></td>
<td>
<p>String, If equal to &quot;quantile&quot; will generate quantile-spaced grid evaluation points, otherwise will generate equally spaced points.</p>
</td></tr>
<tr><td><code id="lpbwcde_+3A_ng">ng</code></td>
<td>
<p>Int, number of grid points to be used in generating bandwidth estimates.</p>
</td></tr>
<tr><td><code id="lpbwcde_+3A_mu">mu</code></td>
<td>
<p>Nonnegative integer, specifies the derivative with respect to <code>Y</code> of the
distribution function to be estimated. <code>0</code> for the distribution function,
<code>1</code> (default) for the density funtion, etc.</p>
</td></tr>
<tr><td><code id="lpbwcde_+3A_nu">nu</code></td>
<td>
<p>Nonnegative integer, specifies the derivative with respect to <code>X</code> of the
distribution function to be estimated.</p>
</td></tr>
<tr><td><code id="lpbwcde_+3A_kernel_type">kernel_type</code></td>
<td>
<p>String, specifies the kernel function, should be one of
<code>"triangular"</code>, <code>"uniform"</code> or <code>"epanechnikov"</code>.</p>
</td></tr>
<tr><td><code id="lpbwcde_+3A_bw_type">bw_type</code></td>
<td>
<p>String, specifies the method for data-driven bandwidth selection. This option will be
ignored if <code>bw</code> is provided. Implementable with <code>"mse-rot"</code> (default, mean squared error-optimal
bandwidth selected for each grid point)</p>
</td></tr>
<tr><td><code id="lpbwcde_+3A_regularize">regularize</code></td>
<td>
<p>Boolean (default TRUE). Option to regularize bandwidth selection to have atleast
20+max(p, q)+1 datapoints when evaluating the estimator.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>BW</code></td>
<td>
<p>A matrix containing (1) <code>y_grid</code> (grid point), (2) <code>bw</code> (bandwidth)</p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p>A list containing options passed to the function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Rajita Chandak (maintainer), Princeton University. <a href="mailto:rchandak@princeton.edu">rchandak@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma, University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>References</h3>

<p>Cattaneo MD, Chandak R, Jansson M, Ma X (2024).
&ldquo;Local Polynomial Conditional Density Estimators.&rdquo;
<em>Bernoulli</em>.
</p>


<h3>See Also</h3>

<p>Supported methods: <code><a href="#topic+coef.lpbwcde">coef.lpbwcde</a></code>,
<code><a href="#topic+print.lpbwcde">print.lpbwcde</a></code>, <code><a href="#topic+summary.lpbwcde">summary.lpbwcde</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a random sample
set.seed(42);
x_data = rnorm(2000)
y_data = rnorm(2000, mean=x_data)
x = 0

# Construct bandwidth
bw1 &lt;- lpbwcde(y_data = y_data, x_data = x_data, x=x, bw_type = "mse-rot")
summary(bw1)

# Display bandwidths for a subset of y_grid points
summary(bw1, y_grid=bw1$BW[2:5, "y_grid"])

</code></pre>

<hr>
<h2 id='lpcde'>Local polynomial conditional density estimation</h2><span id='topic+lpcde'></span>

<h3>Description</h3>

<p><code><a href="#topic+lpcde">lpcde</a></code> implements the local polynomial regression based
conditional density (and derivatives). The estimator proposed in
(Cattaneo et al. 2024).
Robust bias-corrected inference methods, both pointwise (confidence intervals) and
uniform (confidence bands), are also implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpcde(
  x_data,
  y_data,
  y_grid = NULL,
  x = NULL,
  bw = NULL,
  p = NULL,
  q = NULL,
  p_RBC = NULL,
  q_RBC = NULL,
  mu = NULL,
  nu = NULL,
  rbc = TRUE,
  ng = NULL,
  normalize = FALSE,
  nonneg = FALSE,
  grid_spacing = "",
  kernel_type = c("epanechnikov", "triangular", "uniform"),
  bw_type = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpcde_+3A_x_data">x_data</code></td>
<td>
<p>Numeric matrix/data frame, the raw data of covariates.</p>
</td></tr>
<tr><td><code id="lpcde_+3A_y_data">y_data</code></td>
<td>
<p>Numeric matrix/data frame, the raw data of independent.</p>
</td></tr>
<tr><td><code id="lpcde_+3A_y_grid">y_grid</code></td>
<td>
<p>Numeric, specifies the grid of evaluation points in the y-direction. When set to default, grid
points will be chosen as 0.05-0.95 percentiles of the data, with a step size of 0.05 in
y-direction.</p>
</td></tr>
<tr><td><code id="lpcde_+3A_x">x</code></td>
<td>
<p>Numeric, specifies the grid of evaluation points in the x-direction. When set to default,
the evaluation point will be chosen as the median of the x data.</p>
</td></tr>
<tr><td><code id="lpcde_+3A_bw">bw</code></td>
<td>
<p>Numeric, specifies the bandwidth used for estimation. Can be (1) a positive
scalar (common bandwidth for all grid points); or (2) a positive numeric vector/matrix
specifying bandwidths for each grid point (should be the same dimension as <code>grid</code>).</p>
</td></tr>
<tr><td><code id="lpcde_+3A_p">p</code></td>
<td>
<p>Nonnegative integer, specifies the order of the local polynomial for <code>Y</code> used to
construct point estimates. (Default is <code>2</code>.)</p>
</td></tr>
<tr><td><code id="lpcde_+3A_q">q</code></td>
<td>
<p>Nonnegative integer, specifies the order of the local polynomial for <code>X</code> used to
construct point estimates. (Default is <code>1</code>.)</p>
</td></tr>
<tr><td><code id="lpcde_+3A_p_rbc">p_RBC</code></td>
<td>
<p>Nonnegative integer, specifies the order of the local polynomial for <code>Y</code> used to
construct bias-corrected point estimates. (Default is <code>p+1</code>.)</p>
</td></tr>
<tr><td><code id="lpcde_+3A_q_rbc">q_RBC</code></td>
<td>
<p>Nonnegative integer, specifies the order of the local polynomial for <code>X</code> used to
construct bias-corrected point estimates. (Default is <code>q+1</code>.)</p>
</td></tr>
<tr><td><code id="lpcde_+3A_mu">mu</code></td>
<td>
<p>Nonnegative integer, specifies the derivative with respect to <code>Y</code> of the
distribution function to be estimated. <code>0</code> for the distribution function,
<code>1</code> (default) for the density funtion, etc.</p>
</td></tr>
<tr><td><code id="lpcde_+3A_nu">nu</code></td>
<td>
<p>Nonnegative integer, specifies the derivative with respect to <code>X</code> of the
distribution function to be estimated. Default value is <code>0</code>.</p>
</td></tr>
<tr><td><code id="lpcde_+3A_rbc">rbc</code></td>
<td>
<p>Boolean. TRUE (default) for rbc calcuations, required for valid uniform inference.</p>
</td></tr>
<tr><td><code id="lpcde_+3A_ng">ng</code></td>
<td>
<p>Int, number of grid points to be used. generates evenly space points over the support of the data.</p>
</td></tr>
<tr><td><code id="lpcde_+3A_normalize">normalize</code></td>
<td>
<p>Boolean, False (default) returns original estimator, True normalizes estimates to integrate to 1.</p>
</td></tr>
<tr><td><code id="lpcde_+3A_nonneg">nonneg</code></td>
<td>
<p>Boolean, False (default) returns original estimator, True returns maximum of estimate and 0.</p>
</td></tr>
<tr><td><code id="lpcde_+3A_grid_spacing">grid_spacing</code></td>
<td>
<p>String, If equal to &quot;quantile&quot; will generate quantile-spaced grid evaluation points, otherwise will generate equally spaced points.</p>
</td></tr>
<tr><td><code id="lpcde_+3A_kernel_type">kernel_type</code></td>
<td>
<p>String, specifies the kernel function, should be one of
<code>"triangular"</code>, <code>"uniform"</code>, and <code>"epanechnikov"</code>(default).</p>
</td></tr>
<tr><td><code id="lpcde_+3A_bw_type">bw_type</code></td>
<td>
<p>String, specifies the method for data-driven bandwidth selection. This option will be
ignored if <code>bw</code> is provided. Implementable with <code>"mse-dpi"</code> (default, mean squared error-optimal
bandwidth selected for each grid point)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Bias correction is only used for the construction of confidence intervals/bands, but not for point estimation.
The point estimates, denoted by <code>est</code>, are constructed using local polynomial estimates of order <code>p</code> and <code>q</code>,
while the centering of the confidence intervals/bands, denoted by <code>est_RBC</code>,
are constructed using local polynomial estimates of order
<code>p_RBC</code> and <code>q_RBC</code>. The confidence intervals/bands take the form:
<code>[est_RBC - cv * SE(est_RBC) , est_RBC + cv * SE(est_RBC)]</code>, where <code>cv</code> denotes
the appropriate critical value and <code>SE(est_RBC)</code> denotes an standard error estimate for
the centering of the confidence interval/band. As a result, the confidence intervals/bands
may not be centered at the point estimates because they have been bias-corrected.
Setting <code>p_RBC</code> equal to <code>p</code> and <code>q_RBC</code> to <code>q</code>, results on centered
at the point estimate confidence intervals/bands, but requires undersmoothing for
valid inference (i.e., (I)MSE-optimal bandwdith for the density point estimator cannot
be used). Hence the bandwidth would need to be specified manually when <code>q=p</code>,
and the point estimates will not be (I)MSE optimal. See Cattaneo, Jansson and Ma
(2020a, 2020b) for details, and also Calonico, Cattaneo, and Farrell (2018, 2020)
for robust bias correction methods.
</p>
<p>Sometimes the density point estimates may lie outside
of the confidence intervals/bands, which can happen if the underlying distribution exhibits
high curvature at some evaluation point(s). One possible solution in this case is to
increase the polynomial order <code>p</code> or to employ a smaller bandwidth.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Estimate</code></td>
<td>
<p> A matrix containing (1) <code>grid</code> (grid points),<br />
(2) <code>bw</code> (bandwidths),<br />
(3) <code>est</code> (point estimates with p-th and q-th order local polynomial),<br />
(4) <code>est_RBC</code> (point estimates with p_RBC-th and q_RBC-th order local polynomial),<br />
(5) <code>se</code> (standard error corresponding to <code>est</code>).
(6) <code>se_RBC</code> (standard error corresponding to <code>est_RBC</code>).</p>
</td></tr>
<tr><td><code>CovMat</code></td>
<td>
<p>The variance-covariance matrix corresponding to <code>est</code>.</p>
</td></tr>
<tr><td><code>opt</code></td>
<td>
<p>A list containing options passed to the function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Rajita Chandak (maintainer), Princeton University. <a href="mailto:rchandak@princeton.edu">rchandak@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma, University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>References</h3>

<p>Cattaneo MD, Chandak R, Jansson M, Ma X (2024).
&ldquo;Local Polynomial Conditional Density Estimators.&rdquo;
<em>Bernoulli</em>.<br />
Calonico S, Cattaneo MD, Farrell MH (2018).
&ldquo;On the Effect of Bias Estimation on Coverage Accuracy in Nonparametric Inference.&rdquo;
<em>Journal of the American Statistical Association</em>, <b>113</b>(522), 767&ndash;779.<br />
Calonico S, Cattaneo MD, Farrell MH (2022).
&ldquo;Coverage Error Optimal Confidence Intervals for Local Polynomial Regression.&rdquo;
<em>Bernoulli</em>, <b>28</b>(4), 2998&ndash;3022.<br />
Cattaneo MD, Jansson M, Ma X (2020).
&ldquo;Simple local polynomial density estimators.&rdquo;
<em>J. Amer. Statist. Assoc.</em>, <b>115</b>(531), 1449&ndash;1455.
</p>


<h3>See Also</h3>

<p>Supported methods: <code><a href="#topic+coef.lpcde">coef.lpcde</a></code>, <code><a href="#topic+confint.lpcde">confint.lpcde</a></code>,
<code><a href="#topic+plot.lpcde">plot.lpcde</a></code>, <code><a href="#topic+print.lpcde">print.lpcde</a></code>,
<code><a href="#topic+summary.lpcde">summary.lpcde</a></code>, <code><a href="#topic+vcov.lpcde">vcov.lpcde</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Density estimation example
n=500
x_data = matrix(rnorm(n, mean=0, sd=1))
y_data = matrix(rnorm(n, mean=x_data, sd=1))
y_grid = seq(from=-1, to=1, length.out=5)
model1 = lpcde::lpcde(x_data=x_data, y_data=y_data, y_grid=y_grid, x=0, bw=0.5)
#summary of estimation
summary(model1)

</code></pre>

<hr>
<h2 id='lpcde_fn'>lpcde_fn: Conditional density estimator.</h2><span id='topic+lpcde_fn'></span>

<h3>Description</h3>

<p>Function for estimating the density function and its derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpcde_fn(
  y_data,
  x_data,
  y_grid,
  x,
  p,
  q,
  p_RBC,
  q_RBC,
  bw,
  mu,
  nu,
  kernel_type,
  rbc = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpcde_fn_+3A_y_data">y_data</code></td>
<td>
<p>Response variable dataset, vector.</p>
</td></tr>
<tr><td><code id="lpcde_fn_+3A_x_data">x_data</code></td>
<td>
<p>Covariate dataset, vector or matrix.</p>
</td></tr>
<tr><td><code id="lpcde_fn_+3A_y_grid">y_grid</code></td>
<td>
<p>Numeric vector, specifies the grid of evaluation points along y-direction.</p>
</td></tr>
<tr><td><code id="lpcde_fn_+3A_x">x</code></td>
<td>
<p>Numeric vector or matrix, specifies the grid of evaluation points along x-direction.</p>
</td></tr>
<tr><td><code id="lpcde_fn_+3A_p">p</code></td>
<td>
<p>Polynomial order for y.</p>
</td></tr>
<tr><td><code id="lpcde_fn_+3A_q">q</code></td>
<td>
<p>Polynomial order for covariates.</p>
</td></tr>
<tr><td><code id="lpcde_fn_+3A_p_rbc">p_RBC</code></td>
<td>
<p>Nonnegative integer, specifies the order of the local polynomial for <code>Y</code> used to
construct bias-corrected point estimates. (Default is <code>p+1</code>.)</p>
</td></tr>
<tr><td><code id="lpcde_fn_+3A_q_rbc">q_RBC</code></td>
<td>
<p>Nonnegative integer, specifies the order of the local polynomial for <code>X</code> used to
construct bias-corrected point estimates. (Default is <code>q+1</code>.)</p>
</td></tr>
<tr><td><code id="lpcde_fn_+3A_bw">bw</code></td>
<td>
<p>Numeric, bandwidth vector.</p>
</td></tr>
<tr><td><code id="lpcde_fn_+3A_mu">mu</code></td>
<td>
<p>Degree of derivative with respect to y.</p>
</td></tr>
<tr><td><code id="lpcde_fn_+3A_nu">nu</code></td>
<td>
<p>Degree of derivative with respect to x.</p>
</td></tr>
<tr><td><code id="lpcde_fn_+3A_kernel_type">kernel_type</code></td>
<td>
<p>Kernel function choice.</p>
</td></tr>
<tr><td><code id="lpcde_fn_+3A_rbc">rbc</code></td>
<td>
<p>Boolean for whether to return RBC estimate and standard errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Conditional density estimate at all grid points.
</p>

<hr>
<h2 id='mvec'>Polynomial order vector</h2><span id='topic+mvec'></span>

<h3>Description</h3>

<p>Generates list of all combinations
of length less than or equal to d of numbers that add up to n.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvec(n, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvec_+3A_n">n</code></td>
<td>
<p>Total value of each combination</p>
</td></tr>
<tr><td><code id="mvec_+3A_d">d</code></td>
<td>
<p>Maximum length of combinations</p>
</td></tr>
</table>

<hr>
<h2 id='normal_dgps'>Internal function.</h2><span id='topic+normal_dgps'></span>

<h3>Description</h3>

<p>Calculates density and higher order derivatives for Gaussian models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal_dgps(x, v, mean, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normal_dgps_+3A_x">x</code></td>
<td>
<p>Scalar, point of evaluation.</p>
</td></tr>
<tr><td><code id="normal_dgps_+3A_v">v</code></td>
<td>
<p>Nonnegative integer, the derivative order (0 indicates cdf, 1 indicates pdf, etc.).</p>
</td></tr>
<tr><td><code id="normal_dgps_+3A_mean">mean</code></td>
<td>
<p>Scalar, the mean of the normal distribution.</p>
</td></tr>
<tr><td><code id="normal_dgps_+3A_sd">sd</code></td>
<td>
<p>Strictly positive scalar, the standard deviation of the normal distribution.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.lpcde'>Plot method for local polynomial density conditional estimation</h2><span id='topic+plot.lpcde'></span>

<h3>Description</h3>

<p>The plot method for local polynomial density objects.
A standard <code>ggplot2</code> object is returned, hence can be used for further customization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpcde'
plot(
  ...,
  alpha = NULL,
  type = NULL,
  lty = NULL,
  lwd = NULL,
  lcol = NULL,
  pty = NULL,
  pwd = NULL,
  pcol = NULL,
  y_grid = NULL,
  CItype = NULL,
  CIuniform = FALSE,
  CIsimul = 2000,
  CIshade = NULL,
  CIcol = NULL,
  title = NULL,
  xlabel = NULL,
  ylabel = NULL,
  legendTitle = NULL,
  legendGroups = NULL,
  rbc = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lpcde_+3A_...">...</code></td>
<td>
<p>Class &quot;lpcde&quot; object, obtained from calling <code><a href="#topic+lpcde">lpcde</a></code>.</p>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_alpha">alpha</code></td>
<td>
<p>Numeric scalar between 0 and 1, specifies the significance level for plotting
confidence intervals/bands.</p>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_type">type</code></td>
<td>
<p>String, one of <code>"line"</code> (default), <code>"points"</code> and <code>"both"</code>,
specifies how the point estimates are plotted. If more than one is provided,
they will be applied to each data series accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_lty">lty</code></td>
<td>
<p>Line type for point estimates, only effective if <code>type</code> is <code>"line"</code> or
<code>"both"</code>. <code>1</code> for solid line, <code>2</code> for dashed line, <code>3</code> for dotted line.
For other options, see the instructions for <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> . If
more than one is provided, they will be applied to each data series accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_lwd">lwd</code></td>
<td>
<p>Line width for point estimates, only effective if <code>type</code> is <code>"line"</code> or
<code>"both"</code>. Should be strictly positive. For other options, see the instructions for
<code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> . If more than one is provided, they will be applied
to each data series accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_lcol">lcol</code></td>
<td>
<p>Line color for point estimates, only effective if <code>type</code> is <code>"line"</code> or
<code>"both"</code>. <code>1</code> for black, <code>2</code> for red, <code>3</code> for green, <code>4</code> for blue.
For other options, see the instructions for <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> . If
more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_pty">pty</code></td>
<td>
<p>Scatter plot type for point estimates, only effective if <code>type</code> is <code>"points"</code> or
<code>"both"</code>. For options, see the instructions for <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> . If
more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_pwd">pwd</code></td>
<td>
<p>Scatter plot size for point estimates, only effective if <code>type</code> is <code>"points"</code> or
<code>"both"</code>. Should be strictly positive. If more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_pcol">pcol</code></td>
<td>
<p>Scatter plot color for point estimates, only effective if <code>type</code> is <code>"points"</code> or
<code>"both"</code>. <code>1</code> for black, <code>2</code> for red, <code>3</code>
for green, <code>4</code> for blue.
For other options, see the instructions for <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> . If
more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_y_grid">y_grid</code></td>
<td>
<p>Numeric vector, specifies a subset of grid points
to plot point estimates. This option is effective only if <code>type</code> is <code>"points"</code> or
<code>"both"</code>; or if <code>CItype</code> is <code>"ebar"</code> or
<code>"all"</code>.</p>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_citype">CItype</code></td>
<td>
<p>String, one of <code>"region"</code> (shaded region, default), <code>"line"</code> (dashed lines),
<code>"ebar"</code> (error bars), <code>"all"</code> (all of the previous) or <code>"none"</code> (no confidence region),
how the confidence region should be plotted. If more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_ciuniform">CIuniform</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> (default), plotting either pointwise confidence intervals (<code>FALSE</code>) or
uniform confidence bands (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_cisimul">CIsimul</code></td>
<td>
<p>Positive integer, specifies the number of simulations used to construct critical values (default is <code>2000</code>). This
option is ignored if <code>CIuniform=FALSE</code>.</p>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_cishade">CIshade</code></td>
<td>
<p>Numeric, specifies the opaqueness of the confidence region, should be between 0 (transparent) and
</p>

<ol>
<li><p> Default is 0.2. If more than one is provided, they will be applied to each data series
accordingly.
</p>
</li></ol>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_cicol">CIcol</code></td>
<td>
<p>Color of the confidence region. <code>1</code> for black, <code>2</code> for red, <code>3</code>
for green, <code>4</code> for blue.
For other options, see the instructions for <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code> . If
more than one is provided, they will be applied to each data series
accordingly.</p>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_title">title</code>, <code id="plot.lpcde_+3A_xlabel">xlabel</code>, <code id="plot.lpcde_+3A_ylabel">ylabel</code></td>
<td>
<p>Strings, specifies the title of the plot and labels for the x- and y-axis.</p>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_legendtitle">legendTitle</code></td>
<td>
<p>String, specifies the legend title.</p>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_legendgroups">legendGroups</code></td>
<td>
<p>String vector, specifies the group names used in legend.</p>
</td></tr>
<tr><td><code id="plot.lpcde_+3A_rbc">rbc</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code> (default), plotting confidence intervals and bands with
standard estimates (<code>FALSE</code>) or RBC estimates (<code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Figure</code></td>
<td>
<p>A standard <code>ggplot2</code> object is returned, hence can be used for further customization.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Rajita Chandak (maintainer), Princeton University. <a href="mailto:rchandak@princeton.edu">rchandak@princeton.edu</a>
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma, University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpcde">lpcde</a></code> for local polynomial density estimation.
Supported methods: <code><a href="#topic+coef.lpcde">coef.lpcde</a></code>, <code><a href="#topic+confint.lpcde">confint.lpcde</a></code>,
<code><a href="#topic+plot.lpcde">plot.lpcde</a></code>, <code><a href="#topic+print.lpcde">print.lpcde</a></code>,
<code><a href="#topic+summary.lpcde">summary.lpcde</a></code>, <code><a href="#topic+vcov.lpcde">vcov.lpcde</a></code>
</p>

<hr>
<h2 id='poly_base'>Polynomial basis vector expansion</h2><span id='topic+poly_base'></span>

<h3>Description</h3>

<p>Generate polynomial basis vector up to order p.
has multivariate functionality as described in the main paper
normalized by factorials in denominator.
NOTE: currently works only up to 4th degree polynomial expansion for multivariate <code>x</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly_base(x, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly_base_+3A_x">x</code></td>
<td>
<p>A number or vector.</p>
</td></tr>
<tr><td><code id="poly_base_+3A_p">p</code></td>
<td>
<p>A number (integer).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Polynomial basis of <code>x</code> up to degree <code>p</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>poly_base(x = 2, p = 5)
</code></pre>

<hr>
<h2 id='print_all_sumC'>All Sums in C++ (Internal Function)</h2><span id='topic+print_all_sumC'></span>

<h3>Description</h3>

<p>Function that prints all combinations of natural numbers that
add up to target value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_all_sumC(target)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_all_sumC_+3A_target">target</code></td>
<td>
<p>Target value for sum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of combinations that add up to target value.
</p>

<hr>
<h2 id='print.lpbwcde'>Print method for local polynomial conditional density bandwidth selection</h2><span id='topic+print.lpbwcde'></span>

<h3>Description</h3>

<p>The print method for local polynomial conditional density bandwidth selection objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpbwcde'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lpbwcde_+3A_x">x</code></td>
<td>
<p>Class &quot;lpbwcde&quot; object, obtained by calling <code><a href="#topic+lpbwcde">lpbwcde</a></code>.</p>
</td></tr>
<tr><td><code id="print.lpbwcde_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Display output</code></td>
<td>
<p>A list of specified options provided to the function.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Rajita Chandak (maintainer), Princeton University. <a href="mailto:rchandak@princeton.edu">rchandak@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma, University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpbwcde">lpbwcde</a></code> for data-driven bandwidth selection.
</p>
<p>Supported methods: <code><a href="#topic+coef.lpbwcde">coef.lpbwcde</a></code>, <code><a href="#topic+print.lpbwcde">print.lpbwcde</a></code>, <code><a href="#topic+summary.lpbwcde">summary.lpbwcde</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=100
x_data = as.matrix(rnorm(n, mean=0, sd=1))
y_data = as.matrix(rnorm(n, mean=0, sd=1))
y_grid = stats::quantile(y_data, seq(from=0.1, to=0.9, by=0.1))
# bandwidth selection
y_grid = stats::quantile(y_data, seq(from=0.1, to=0.9, by=0.1))
model2 = lpcde::lpbwcde(y_data=y_data, x_data=x_data, x=0, y_grid = y_grid, bw_type = "mse-rot")
print(model2)

</code></pre>

<hr>
<h2 id='print.lpcde'>Print method for local polynomial conditional density estimation</h2><span id='topic+print.lpcde'></span>

<h3>Description</h3>

<p>The print method for local polynomial conditional density objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpcde'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.lpcde_+3A_x">x</code></td>
<td>
<p>Class &quot;lpcde&quot; object, obtained from calling <code><a href="#topic+lpcde">lpcde</a></code>.</p>
</td></tr>
<tr><td><code id="print.lpcde_+3A_...">...</code></td>
<td>
<p>Additional options.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Display output</code></td>
<td>
<p>summary of inputs to <code>lpcde</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Rajita Chandak (maintainer), Princeton University. <a href="mailto:rchandak@princeton.edu">rchandak@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma, University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpcde">lpcde</a></code> for local polynomial conditional density estimation.
Supported methods: <code><a href="#topic+coef.lpcde">coef.lpcde</a></code>, <code><a href="#topic+confint.lpcde">confint.lpcde</a></code>,
<code><a href="#topic+plot.lpcde">plot.lpcde</a></code>, <code><a href="#topic+print.lpcde">print.lpcde</a></code>,
<code><a href="#topic+summary.lpcde">summary.lpcde</a></code>, <code><a href="#topic+vcov.lpcde">vcov.lpcde</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=100
x_data = as.matrix(rnorm(n, mean=0, sd=1))
y_data = as.matrix(rnorm(n, mean=0, sd=1))
y_grid = stats::quantile(y_data, seq(from=0.1, to=0.9, by=0.1))
# density estimation
model1 = lpcde::lpcde(x_data=x_data, y_data=y_data, y_grid=y_grid, x=0, bw=0.5)
print(model1)

</code></pre>

<hr>
<h2 id='S_exact'>S matrix
Internal Function
Generate Matrix</h2><span id='topic+S_exact'></span>

<h3>Description</h3>

<p>S matrix
Internal Function
</p>
<p>Generate Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S_exact(lower = -1, upper = 1, eval_pt, p, kernel_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S_exact_+3A_eval_pt">eval_pt</code></td>
<td>
<p>evaluation point</p>
</td></tr>
<tr><td><code id="S_exact_+3A_p">p</code></td>
<td>
<p>Nonnegative integer, polynomial order.</p>
</td></tr>
<tr><td><code id="S_exact_+3A_kernel_type">kernel_type</code></td>
<td>
<p>String, kernel type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a (p+1)-by-(p+1) matrix
</p>

<hr>
<h2 id='S_x'>Sx Matrix (Internal Function)</h2><span id='topic+S_x'></span>

<h3>Description</h3>

<p>S_x matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>S_x(x_data, q, kernel_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="S_x_+3A_x_data">x_data</code></td>
<td>
<p>Data of covariates.</p>
</td></tr>
<tr><td><code id="S_x_+3A_q">q</code></td>
<td>
<p>Maximum degree for x.</p>
</td></tr>
<tr><td><code id="S_x_+3A_kernel_type">kernel_type</code></td>
<td>
<p>Type of kernel function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>S_x matrix
</p>

<hr>
<h2 id='summary.lpbwcde'>Summary method for local polynomial conditional density bandwidth selection</h2><span id='topic+summary.lpbwcde'></span>

<h3>Description</h3>

<p>The summary method for local polynomial conditional density bandwidth selection objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpbwcde'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lpbwcde_+3A_object">object</code></td>
<td>
<p>Class &quot;lpbwcde&quot; object, obtained by calling <code><a href="#topic+lpbwcde">lpbwcde</a></code>.</p>
</td></tr>
<tr><td><code id="summary.lpbwcde_+3A_...">...</code></td>
<td>
<p>Additional options, including (i) <code>y_grid</code> specifies a subset of y_grid points
to display the bandwidth; (ii) <code>gridIndex</code> specifies the indices of y_grid points
to display the bandwidth.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Display output</code></td>
<td>
<p>A list of specified options and a matrix of grid points, bandwidth, and effective sample size.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Rajita Chandak (maintainer), Princeton University. <a href="mailto:rchandak@princeton.edu">rchandak@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma, University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpbwcde">lpbwcde</a></code> for data-driven bandwidth selection.
</p>
<p>Supported methods: <code><a href="#topic+coef.lpbwcde">coef.lpbwcde</a></code>, <code><a href="#topic+print.lpbwcde">print.lpbwcde</a></code>, <code><a href="#topic+summary.lpbwcde">summary.lpbwcde</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=100
x_data = as.matrix(rnorm(n, mean=0, sd=1))
y_data = as.matrix(rnorm(n, mean=0, sd=1))
y_grid = stats::quantile(y_data, seq(from=0.1, to=0.9, by=0.1))
# bandwidth selection
y_grid = stats::quantile(y_data, seq(from=0.1, to=0.9, by=0.1))
model2 = lpcde::lpbwcde(y_data=y_data, x_data=x_data, x=0, y_grid = y_grid, bw_type = "mse-rot")
summary(model2)

</code></pre>

<hr>
<h2 id='summary.lpcde'>Summary method for local polynomial density conditional estimation</h2><span id='topic+summary.lpcde'></span>

<h3>Description</h3>

<p>The summary method for local polynomial conditional density objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpcde'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lpcde_+3A_object">object</code></td>
<td>
<p>Class &quot;lpcde&quot; object, obtained from calling <code><a href="#topic+lpcde">lpcde</a></code>.</p>
</td></tr>
<tr><td><code id="summary.lpcde_+3A_...">...</code></td>
<td>
<p>Additional options, including (i)<code>y_grid</code> specifies
a subset of grid points in y- directions
to display results; (ii) <code>gridIndex</code> specifies the indices of grid points
to display results; (iii) <code>alpha</code> specifies the significance level; (iv)
<code>CIuniform</code> specifies whether displaying pointwise confidence intervals (<code>FALSE</code>, default) or
the uniform confidence band (<code>TRUE</code>); (v) <code>CIsimul</code> specifies the number of simulations used
to construct critical values (default is <code>2000</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Display output</code></td>
<td>
<p>A list of specified options and a matrix of grid points and estimates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Rajita Chandak (maintainer), Princeton University. <a href="mailto:rchandak@princeton.edu">rchandak@princeton.edu</a>
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma, University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpcde">lpcde</a></code> for local polynomial conditional density estimation.
Supported methods: <code><a href="#topic+coef.lpcde">coef.lpcde</a></code>, <code><a href="#topic+confint.lpcde">confint.lpcde</a></code>,
<code><a href="#topic+plot.lpcde">plot.lpcde</a></code>, <code><a href="#topic+print.lpcde">print.lpcde</a></code>,
<code><a href="#topic+summary.lpcde">summary.lpcde</a></code>, <code><a href="#topic+vcov.lpcde">vcov.lpcde</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=100
x_data = as.matrix(rnorm(n, mean=0, sd=1))
y_data = as.matrix(rnorm(n, mean=0, sd=1))
y_grid = stats::quantile(y_data, seq(from=0.1, to=0.9, by=0.1))
# density estimation
model1 = lpcde::lpcde(x_data=x_data, y_data=y_data, y_grid=y_grid, x=0, bw=0.5)
summary(model1)

</code></pre>

<hr>
<h2 id='T_x'>T_x matrix (Internal Function)</h2><span id='topic+T_x'></span>

<h3>Description</h3>

<p>Constructing the Tx matrix as described in the supplemental appendix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T_x(x_data, eval_pt, q, h, kernel_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T_x_+3A_x_data">x_data</code></td>
<td>
<p>Data of covariates.</p>
</td></tr>
<tr><td><code id="T_x_+3A_eval_pt">eval_pt</code></td>
<td>
<p>Evaluation point.</p>
</td></tr>
<tr><td><code id="T_x_+3A_q">q</code></td>
<td>
<p>Polynomial order for covariates.</p>
</td></tr>
<tr><td><code id="T_x_+3A_h">h</code></td>
<td>
<p>Bandwidth.</p>
</td></tr>
<tr><td><code id="T_x_+3A_kernel_type">kernel_type</code></td>
<td>
<p>Type of kernel function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix.
</p>

<hr>
<h2 id='T_y'>T_y matrix (Internal Function)</h2><span id='topic+T_y'></span>

<h3>Description</h3>

<p>Constructing the Ty matrix as described in the supplemental appendix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T_y(y_data, yp_data, p, kernel_type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T_y_+3A_y_data">y_data</code></td>
<td>
<p>Vector of data points.</p>
</td></tr>
<tr><td><code id="T_y_+3A_p">p</code></td>
<td>
<p>Polynomial order.</p>
</td></tr>
<tr><td><code id="T_y_+3A_kernel_type">kernel_type</code></td>
<td>
<p>Type of kernel function. Currently only works with uniform kernel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix Ty.
</p>

<hr>
<h2 id='T_y_exact'>T matrix
Internal Function
Generate Matrix</h2><span id='topic+T_y_exact'></span>

<h3>Description</h3>

<p>T matrix
Internal Function
Generate Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>T_y_exact(lower = -1, upper = 1, eval_pt, p, kernel_type = "uniform")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="T_y_exact_+3A_eval_pt">eval_pt</code></td>
<td>
<p>evaluation point</p>
</td></tr>
<tr><td><code id="T_y_exact_+3A_p">p</code></td>
<td>
<p>Nonnegative integer, polynomial order.</p>
</td></tr>
<tr><td><code id="T_y_exact_+3A_kernel_type">kernel_type</code></td>
<td>
<p>String, kernel type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a (p+1)-by-(p+1) matrix
</p>

<hr>
<h2 id='vcov.lpcde'>Variance-Covariance</h2><span id='topic+vcov.lpcde'></span>

<h3>Description</h3>

<p>The vcov method for local polynomial conditional density objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpcde'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.lpcde_+3A_object">object</code></td>
<td>
<p>Class &quot;lpdensity&quot; object, obtained by calling <code><a href="#topic+lpcde">lpcde</a></code>.</p>
</td></tr>
<tr><td><code id="vcov.lpcde_+3A_...">...</code></td>
<td>
<p>Additional options.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Vcov method for local polynomial density conditional estimation
</p>


<h3>Value</h3>

<table>
<tr><td><code>stdErr</code></td>
<td>
<p>A matrix containing grid points and standard errors using p- and q-th order local polynomials.</p>
</td></tr>
<tr><td><code>CovMat</code></td>
<td>
<p>The variance-covariance matrix corresponding to <code>est</code>.</p>
</td></tr>
<tr><td><code>CovMat_RBC</code></td>
<td>
<p>The variance-covariance matrix corresponding to <code>est_RBC</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Matias D. Cattaneo, Princeton University. <a href="mailto:cattaneo@princeton.edu">cattaneo@princeton.edu</a>.
</p>
<p>Rajita Chandak (maintainer), Princeton University. <a href="mailto:rchandak@princeton.edu">rchandak@princeton.edu</a>.
</p>
<p>Michael Jansson, University of California Berkeley. <a href="mailto:mjansson@econ.berkeley.edu">mjansson@econ.berkeley.edu</a>.
</p>
<p>Xinwei Ma, University of California San Diego. <a href="mailto:x1ma@ucsd.edu">x1ma@ucsd.edu</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lpcde">lpcde</a></code> for local polynomial conditional density estimation.
</p>
<p>Supported methods: <code><a href="#topic+plot.lpcde">plot.lpcde</a></code>, <code><a href="#topic+print.lpcde">print.lpcde</a></code>,
<code><a href="#topic+summary.lpcde">summary.lpcde</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=100
x_data = as.matrix(rnorm(n, mean=0, sd=1))
y_data = as.matrix(rnorm(n, mean=0, sd=1))
y_grid = stats::quantile(y_data, seq(from=0.1, to=0.9, by=0.1))
# density estimation
model1 = lpcde::lpcde(x_data=x_data, y_data=y_data, y_grid=y_grid, x=0, bw=0.5)
vcov(model1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
