<!DOCTYPE html><html lang="en"><head><title>Help for package sjSDM</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {sjSDM}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#installation_help'><p>Installation help</p></a></li>
<li><a href='#AccSGD'><p>AccSGD</p></a></li>
<li><a href='#AdaBound'><p>AdaBound</p></a></li>
<li><a href='#Adamax'><p>Adamax</p></a></li>
<li><a href='#anova.sjSDM'><p>Anova / Variation partitioning</p></a></li>
<li><a href='#bioticStruct'><p>biotic structure</p></a></li>
<li><a href='#butterflies'><p>butterflies</p></a></li>
<li><a href='#check_module'><p>check module</p></a></li>
<li><a href='#checkModel'><p>check model</p>
check model and rebuild if necessary</a></li>
<li><a href='#coef.sjSDM'><p>Return coefficients from a fitted sjSDM model</p></a></li>
<li><a href='#DiffGrad'><p>DiffGrad</p></a></li>
<li><a href='#DNN'><p>Non-linear model (deep neural network) of environmental responses</p></a></li>
<li><a href='#eucalypts'><p>eucalypts</p></a></li>
<li><a href='#generateSpatialEV'><p>Generate spatial eigenvectors</p></a></li>
<li><a href='#getCor'><p>getCor</p></a></li>
<li><a href='#getCov'><p>getCov</p></a></li>
<li><a href='#getImportance'><p>getImportance</p></a></li>
<li><a href='#getSe'><p>Post hoc calculation of standard errors</p></a></li>
<li><a href='#getWeights'><p>Get weights</p></a></li>
<li><a href='#importance'><p>Importance of environmental, spatial and association components</p></a></li>
<li><a href='#install_diagnostic'><p>install diagnostic</p></a></li>
<li><a href='#install_sjSDM'><p>Install sjSDM and its dependencies</p></a></li>
<li><a href='#internalStructure'><p>Plot internal metacommunity structure</p></a></li>
<li><a href='#is_torch_available'><p>is_torch_available</p></a></li>
<li><a href='#linear'><p>Linear model of environmental response</p></a></li>
<li><a href='#logLik.sjSDM'><p>Extract negative-log-Likelihood from a fitted sjSDM model</p></a></li>
<li><a href='#madgrad'><p>madgrad</p></a></li>
<li><a href='#new_image'><p>new_image function</p></a></li>
<li><a href='#plot.sjSDM'><p>Coefficients plot</p></a></li>
<li><a href='#plot.sjSDM_cv'><p>Plot elastic net tuning</p></a></li>
<li><a href='#plot.sjSDM.DNN'><p>Training history</p></a></li>
<li><a href='#plot.sjSDManova'><p>Plot anova results</p></a></li>
<li><a href='#plot.sjSDMimportance'><p>Plot importance</p></a></li>
<li><a href='#plot.sjSDMinternalStructure'><p>Plot internal structure</p></a></li>
<li><a href='#plotAssemblyEffects'><p>Plot predictors of assembly processes</p></a></li>
<li><a href='#plotsjSDMcoef'><p>Internal coefficients plot</p></a></li>
<li><a href='#predict.sjSDM'><p>Predict from a fitted sjSDM model</p></a></li>
<li><a href='#print.bioticStruct'><p>Print a bioticStruct object</p></a></li>
<li><a href='#print.DNN'><p>Print a DNN object</p></a></li>
<li><a href='#print.linear'><p>Print a linear object</p></a></li>
<li><a href='#print.sjSDM'><p>Print a fitted sjSDM model</p></a></li>
<li><a href='#print.sjSDM_cv'><p>Print a fitted sjSDM_cv model</p></a></li>
<li><a href='#print.sjSDManova'><p>Print sjSDM anova object</p></a></li>
<li><a href='#print.sjSDMimportance'><p>Print importance</p></a></li>
<li><a href='#print.sjSDMinternalStructure'><p>Print internal structure object</p></a></li>
<li><a href='#residuals.sjSDM'><p>Residuals for a sjSDM model</p></a></li>
<li><a href='#RMSprop'><p>RMSprop</p></a></li>
<li><a href='#Rsquared'><p>R-squared</p></a></li>
<li><a href='#setWeights'><p>Set weights</p></a></li>
<li><a href='#SGD'><p>SGD</p></a></li>
<li><a href='#simulate_SDM'><p>Simulate joint Species Distribution Models</p></a></li>
<li><a href='#simulate.sjSDM'><p>Generates simulations from sjSDM model</p></a></li>
<li><a href='#sjSDM'><p>Fitting scalable joint Species Distribution Models (sjSDM)</p></a></li>
<li><a href='#sjSDM_cv'><p>Cross validation of elastic net tuning</p></a></li>
<li><a href='#sjSDMControl'><p>sjSDM control object</p></a></li>
<li><a href='#summary.sjSDM'><p>Return summary of a fitted sjSDM model</p></a></li>
<li><a href='#summary.sjSDM_cv'><p>Return summary of a fitted sjSDM_cv model</p></a></li>
<li><a href='#summary.sjSDManova'><p>Summary table of sjSDM anova</p></a></li>
<li><a href='#update.sjSDM'><p>Update and re-fit a model call</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Scalable Joint Species Distribution Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Description:</td>
<td>A scalable and fast method for estimating joint Species Distribution Models (jSDMs) for big community data, including eDNA data. The package estimates a full (i.e. non-latent) jSDM with different response distributions (including the traditional multivariate probit model). The package allows to perform variation partitioning (VP) / ANOVA on the fitted models to separate the contribution of environmental, spatial, and biotic associations. In addition, the total R-squared can be further partitioned per species and site to reveal the internal metacommunity structure, see Leibold et al., &lt;<a href="https://doi.org/10.1111%2Foik.08618">doi:10.1111/oik.08618</a>&gt;. The internal structure can then be regressed against environmental and spatial distinctiveness, richness, and traits to analyze metacommunity assembly processes.  The package includes support for accounting for spatial autocorrelation and the option to fit responses using deep neural networks instead of a standard linear predictor. As described in Pichler &amp; Hartig (2021) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13687">doi:10.1111/2041-210X.13687</a>&gt;, scalability is achieved by using a Monte Carlo approximation of the joint likelihood implemented via 'PyTorch' and 'reticulate', which can be run on CPUs or GPUs.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>reticulate, stats, mvtnorm, utils, rstudioapi, abind,
graphics, grDevices, Metrics, parallel, mgcv, cli, crayon,
ggplot2, checkmate, mathjaxr, ggtern, beeswarm, qgam, scales</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, iml, fields</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/TheoreticalEcology/s-jSDM/">https://github.com/TheoreticalEcology/s-jSDM/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/TheoreticalEcology/s-jSDM/issues">https://github.com/TheoreticalEcology/s-jSDM/issues</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>mathjaxr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-08-19 07:14:56 UTC; maximilianpichler</td>
</tr>
<tr>
<td>Author:</td>
<td>Maximilian Pichler
    <a href="https://orcid.org/0000-0003-2252-8327"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Florian Hartig <a href="https://orcid.org/0000-0002-6255-9059"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Wang Cai [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Maximilian Pichler &lt;maximilian.pichler@biologie.uni-regensburg.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-08-19 12:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='installation_help'>Installation help</h2><span id='topic+sjSDM-package'></span><span id='topic+installation_help'></span>

<h3>Description</h3>

<p>Trouble shooting guide for the installation of the sjSDM package
</p>
<p>We provide a function <code><a href="#topic+install_sjSDM">install_sjSDM</a></code> to install automatically
all necessary python dependencies but it can fail sometimes because of
individual system settings or if other python/conda installations get into
the way.
</p>


<h3>'PyTorch' Installation - Before you start</h3>

<p>A few notes before you start with the installation (skip this point if you
do not know 'conda'):
</p>

<ul>
<li><p> existing 'conda' installations:
make sure you have the latest conda3/miniconda3 version and
remove unnecessary 'conda' installations.
</p>
</li>
<li><p> existing 'conda'/'virtualenv' environments (skip this point if you do not know 'conda'):
we currently enforce the usage of a specific environment called 'r-sjsdm',
so if you want use a custom environment it should be named 'r-sjsdm'
</p>
</li></ul>



<h3>Windows - automatic installation</h3>

<p>Sometimes the automatic 'miniconda' installation
(via <code><a href="#topic+install_sjSDM">install_sjSDM</a></code>) doesn't work because of white
spaces in the user's name. But you can easily download and install 'conda' on
your own:
</p>
<p>Download and install the latest
<a href="https://www.anaconda.com/download/">'conda' version</a>
</p>
<p>Afterwards run:<br />
<code>install_sjSDM(version = c("gpu")) # or "cpu" if you do not have a proper gpu device </code>
</p>
<p>Reload the package and run the example , if this doesn't work:
</p>

<ul>
<li><p> Restart RStudio
</p>
</li>
<li><p> Install manually 'pytorch', see the following section
</p>
</li></ul>



<h3>Windows - manual installation</h3>

<p>Download and install the latest 'conda' version:
</p>

<ul>
<li><p> Install the latest
<a href="https://www.anaconda.com/download/">'conda' version</a>
</p>
</li>
<li><p> Open the command window (cmd.exe - hit windows key + r and write cmd)
</p>
</li></ul>

<p>Run in cmd.exe:<br />
</p>
<pre>
$ conda create --name r-sjsdm python=3.7
$ conda activate r-sjsdm
$ conda install pytorch torchvision cpuonly -c pytorch # cpu
$ conda install pytorch torchvision cudatoolkit=11.3 -c pytorch #gpu
$ python -m pip install pyro-ppl torch_optimizer madgrad
</pre>
<p>Restart R, try to run the example, and if this doesn't work:
</p>

<ul>
<li><p> Restart RStudio
</p>
</li>
<li><p> See the 'Help and bugs' section
</p>
</li></ul>



<h3>Linux - automatic installation</h3>

<p>Run in R:<br />
<code>install_sjSDM(version = c("gpu")) # or "cpu" if 
you do not have a proper 'gpu' device </code>
</p>
<p>Restart R try to run the example, if this doesn't work:
</p>

<ul>
<li><p> Restart RStudio
</p>
</li>
<li><p> Install manually 'PyTorch', see the following section
</p>
</li></ul>



<h3>Linux - manual installation</h3>

<p>We strongly advise to use a 'conda' environment but a virtual env should also
work. The only requirement is that it is named 'r-sjsdm'
</p>
<p>Download and install the latest 'conda' version:
</p>

<ul>
<li><p> Install the latest
<a href="https://www.anaconda.com/download/">'conda' version</a>
</p>
</li>
<li><p> Open your terminal
</p>
</li></ul>

<p>Run in your terminal:<br />
</p>
<pre>
$ conda create --name r-sjsdm python=3.7
$ conda activate r-sjsdm
$ conda install pytorch torchvision cpuonly -c pytorch # cpu
$ conda install pytorch torchvision cudatoolkit=11.3 -c pytorch #gpu
$ python -m pip install pyro-ppl torch_optimizer madgrad
</pre>
<p>Restart R try to run the example, if this doesn't work:
</p>

<ul>
<li><p> Restart RStudio
</p>
</li>
<li><p> See the 'Help and bugs' section
</p>
</li></ul>



<h3>MacOS - automatic installation</h3>

<p>Run in R:<br />
<code>install_sjSDM(version = c("cpu"))</code>
</p>
<p>Restart R try to run the example, if this doesn't work:
</p>

<ul>
<li><p> Restart RStudio
</p>
</li>
<li><p> Install manually 'PyTorch', see the following section
</p>
</li></ul>



<h3>MacOS - manual installation</h3>

<p>Download and install the latest 'conda' version:
</p>

<ul>
<li><p> Install the latest
<a href="https://www.anaconda.com/download/">'conda' version</a>
</p>
</li>
<li><p> Open your terminal
</p>
</li></ul>

<p>Run in your terminal:<br />
</p>
<pre>
$ conda create --name r-sjsdm python=3.7
$ conda activate r-sjsdm
$ python -m pip install torch torchvision torchaudio 
$ python -m pip install pyro-ppl torch_optimizer madgrad
</pre>
<p>Restart R try to run the example from, if this doesn't work:
</p>

<ul>
<li><p> Restart RStudio
</p>
</li>
<li><p> See the 'Help and bugs' section
</p>
</li></ul>



<h3>Help and bugs</h3>

<p>To report bugs or ask for help, post a
<a href="https://stackoverflow.com/questions/5963269/how-to-make-a-great-r-reproducible-example/">reproducible example</a>
via the sjSDM <a href="https://github.com/TheoreticalEcology/s-jSDM/issues/">issue tracker</a>
with a copy of the <code><a href="#topic+install_diagnostic">install_diagnostic</a></code> output as a quote.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Maximilian Pichler <a href="mailto:maximilian.pichler@biologie.uni-regensburg.de">maximilian.pichler@biologie.uni-regensburg.de</a> (<a href="https://orcid.org/0000-0003-2252-8327">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Florian Hartig <a href="mailto:florian.hartig@biologie.uni-regensburg.de">florian.hartig@biologie.uni-regensburg.de</a> (<a href="https://orcid.org/0000-0002-6255-9059">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Wang Cai <a href="mailto:caiwang0503@163.com">caiwang0503@163.com</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/TheoreticalEcology/s-jSDM/">https://github.com/TheoreticalEcology/s-jSDM/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/TheoreticalEcology/s-jSDM/issues">https://github.com/TheoreticalEcology/s-jSDM/issues</a>
</p>
</li></ul>


<hr>
<h2 id='AccSGD'>AccSGD</h2><span id='topic+AccSGD'></span>

<h3>Description</h3>

<p>accelerated stochastic gradient, see Kidambi et al., 2018 for details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AccSGD(kappa = 1000, xi = 10, small_const = 0.7, weight_decay = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AccSGD_+3A_kappa">kappa</code></td>
<td>
<p>long step</p>
</td></tr>
<tr><td><code id="AccSGD_+3A_xi">xi</code></td>
<td>
<p>advantage parameter</p>
</td></tr>
<tr><td><code id="AccSGD_+3A_small_const">small_const</code></td>
<td>
<p>small constant</p>
</td></tr>
<tr><td><code id="AccSGD_+3A_weight_decay">weight_decay</code></td>
<td>
<p>l2 penalty on weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Anonymous function that returns optimizer when called.
</p>


<h3>References</h3>

<p>Kidambi, R., Netrapalli, P., Jain, P., &amp; Kakade, S. (2018, February). On the insufficiency of existing momentum schemes for stochastic optimization. In 2018 Information Theory and Applications Workshop (ITA) (pp. 1-9). IEEE.
</p>

<hr>
<h2 id='AdaBound'>AdaBound</h2><span id='topic+AdaBound'></span>

<h3>Description</h3>

<p>adaptive gradient methods with dynamic bound of learning rate, see Luo et al., 2019 for details
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AdaBound(
  betas = c(0.9, 0.999),
  final_lr = 0.1,
  gamma = 0.001,
  eps = 1e-08,
  weight_decay = 0,
  amsbound = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AdaBound_+3A_betas">betas</code></td>
<td>
<p>betas</p>
</td></tr>
<tr><td><code id="AdaBound_+3A_final_lr">final_lr</code></td>
<td>
<p>eps</p>
</td></tr>
<tr><td><code id="AdaBound_+3A_gamma">gamma</code></td>
<td>
<p>small_const</p>
</td></tr>
<tr><td><code id="AdaBound_+3A_eps">eps</code></td>
<td>
<p>eps</p>
</td></tr>
<tr><td><code id="AdaBound_+3A_weight_decay">weight_decay</code></td>
<td>
<p>weight_decay</p>
</td></tr>
<tr><td><code id="AdaBound_+3A_amsbound">amsbound</code></td>
<td>
<p>amsbound</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Anonymous function that returns optimizer when called.
</p>


<h3>References</h3>

<p>Luo, L., Xiong, Y., Liu, Y., &amp; Sun, X. (2019). Adaptive gradient methods with dynamic bound of learning rate. arXiv preprint arXiv:1902.09843.
</p>

<hr>
<h2 id='Adamax'>Adamax</h2><span id='topic+Adamax'></span>

<h3>Description</h3>

<p>Adamax optimizer, see Kingma and Ba, 2014
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Adamax(betas = c(0.9, 0.999), eps = 1e-08, weight_decay = 0.002)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Adamax_+3A_betas">betas</code></td>
<td>
<p>exponential decay rates</p>
</td></tr>
<tr><td><code id="Adamax_+3A_eps">eps</code></td>
<td>
<p>fuzz factor</p>
</td></tr>
<tr><td><code id="Adamax_+3A_weight_decay">weight_decay</code></td>
<td>
<p>l2 penalty on weights</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Anonymous function that returns optimizer when called.
</p>


<h3>References</h3>

<p>Kingma, D. P., &amp; Ba, J. (2014). Adam: A method for stochastic optimization. arXiv preprint arXiv:1412.6980.
</p>

<hr>
<h2 id='anova.sjSDM'>Anova / Variation partitioning</h2><span id='topic+anova.sjSDM'></span>

<h3>Description</h3>

<p>Compute variance explained by the three fractions env, space, associations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDM'
anova(object, samples = 5000L, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anova.sjSDM_+3A_object">object</code></td>
<td>
<p>model of object <code><a href="#topic+sjSDM">sjSDM</a></code></p>
</td></tr>
<tr><td><code id="anova.sjSDM_+3A_samples">samples</code></td>
<td>
<p>Number of Monte Carlo samples</p>
</td></tr>
<tr><td><code id="anova.sjSDM_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>, indicating whether progress should be printed or not</p>
</td></tr>
<tr><td><code id="anova.sjSDM_+3A_...">...</code></td>
<td>
<p>optional arguments which are passed to the calculation of the logLikelihood</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ANOVA function removes each of the three fractions (Environment, Space, Associations) and measures the drop in variance explained, and thus the importance of the three fractions.
</p>
<p>Variance explained is measured by Deviance as well as the pseudo-R2 metrics of Nagelkerke and McFadden
</p>
<p>In downstream functions such as <code><a href="#topic+plot.sjSDManova">plot.sjSDManova</a></code> or <code><a href="#topic+plot.sjSDManova">plot.sjSDManova</a></code> with <code>add_shared=TRUE</code>.
The anova can get unstable for many species and few occurrences/observations. We recommend using large numbers for 'samples'.
</p>


<h3>Value</h3>

<p>An S3 class of type 'sjSDManova' including the following components:
</p>
<table role = "presentation">
<tr><td><code>results</code></td>
<td>
<p>Data frame of results.</p>
</td></tr>
<tr><td><code>to_print</code></td>
<td>
<p>Data frame, summarized results for type I anova.</p>
</td></tr>
<tr><td><code>N</code></td>
<td>
<p>Number of observations (sites).</p>
</td></tr>
<tr><td><code>spatial</code></td>
<td>
<p>Logical, spatial model or not.</p>
</td></tr>
<tr><td><code>species</code></td>
<td>
<p>individual species R2s.</p>
</td></tr>
<tr><td><code>sites</code></td>
<td>
<p>individual site R2s.</p>
</td></tr>
<tr><td><code>lls</code></td>
<td>
<p>individual site by species negative-log-likelihood values.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>model</p>
</td></tr>
</table>
<p>Implemented S3 methods are <code><a href="#topic+print.sjSDManova">print.sjSDManova</a></code> and <code><a href="#topic+plot.sjSDManova">plot.sjSDManova</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.sjSDManova">plot.sjSDManova</a></code>, <code><a href="#topic+print.sjSDManova">print.sjSDManova</a></code>,<code><a href="#topic+summary.sjSDManova">summary.sjSDManova</a></code>, <code><a href="#topic+plot.sjSDMinternalStructure">plot.sjSDMinternalStructure</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sjSDM)
# simulate community:
community = simulate_SDM(env = 3L, species = 10L, sites = 100L)

Occ &lt;- community$response
Env &lt;- community$env_weights
SP &lt;- data.frame(matrix(rnorm(200, 0, 0.3), 100, 2)) # spatial coordinates


# fit model:
model &lt;- sjSDM(Y = Occ, 
               env = linear(data = Env, formula = ~X1+X2+X3), 
               spatial = linear(data = SP, formula = ~0+X1*X2), 
               family=binomial("probit"),
               verbose = FALSE,
               iter = 20) # increase iter for real analysis

# Calculate ANOVA for env, space, associations, for details see ?anova.sjSDM
an = anova(model, samples = 10, verbose = FALSE) # increase iter for real analysis

# Show anova fractions
plot(an)

# ANOVA tables with different way to handle fractions
summary(an)
summary(an, fractions = "discard")
summary(an, fractions = "proportional")
summary(an, fractions = "equal")

# Internal structure
int = internalStructure(an, fractions = "proportional")

print(int)

plot(int) # default is negative values will be set to 0
plot(int, negatives = "scale") # global rescaling of all values to range 0-1
plot(int, negatives = "raw") # negative values will be discarded

plotAssemblyEffects(int)
plotAssemblyEffects(int, negatives = "floor")
plotAssemblyEffects(int, response = "sites", pred = as.factor(c(rep(1, 50), rep(2, 50))))
plotAssemblyEffects(int, response = "species", pred = runif(10))
plotAssemblyEffects(int, response = "species", pred = as.factor(c(rep(1, 5), rep(2, 5))))

## End(Not run)
</code></pre>

<hr>
<h2 id='bioticStruct'>biotic structure</h2><span id='topic+bioticStruct'></span>

<h3>Description</h3>

<p>define biotic (species-species) association (interaction) structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bioticStruct(
  df = NULL,
  lambda = 0,
  alpha = 0.5,
  on_diag = FALSE,
  reg_on_Cov = TRUE,
  inverse = FALSE,
  diag = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bioticStruct_+3A_df">df</code></td>
<td>
<p>degree of freedom for covariance parametrization, if <code>NULL</code> df is set to <code>ncol(Y)/2</code></p>
</td></tr>
<tr><td><code id="bioticStruct_+3A_lambda">lambda</code></td>
<td>
<p>lambda penalty, strength of regularization: <code class="reqn">\lambda * (lasso + ridge)</code></p>
</td></tr>
<tr><td><code id="bioticStruct_+3A_alpha">alpha</code></td>
<td>
<p>weighting between lasso and ridge: <code class="reqn">(1 - \alpha) * |covariances| + \alpha ||covariances||^2</code></p>
</td></tr>
<tr><td><code id="bioticStruct_+3A_on_diag">on_diag</code></td>
<td>
<p>regularization on diagonals</p>
</td></tr>
<tr><td><code id="bioticStruct_+3A_reg_on_cov">reg_on_Cov</code></td>
<td>
<p>regularization on covariance matrix</p>
</td></tr>
<tr><td><code id="bioticStruct_+3A_inverse">inverse</code></td>
<td>
<p>regularization on the inverse covariance matrix</p>
</td></tr>
<tr><td><code id="bioticStruct_+3A_diag">diag</code></td>
<td>
<p>use diagonal matrix with zeros (internal usage)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 class of type 'bioticStruct' including the following components:
</p>
<table role = "presentation">
<tr><td><code>l1_cov</code></td>
<td>
<p>L1 regularization strength.</p>
</td></tr>
<tr><td><code>l2_cov</code></td>
<td>
<p>L2 regularization strength.</p>
</td></tr>
<tr><td><code>inverse</code></td>
<td>
<p>Logical, use inverse covariance matrix or not.</p>
</td></tr>
<tr><td><code>diag</code></td>
<td>
<p>Logical, use diagonal matrix or not.</p>
</td></tr>
<tr><td><code>reg_on_Cov</code></td>
<td>
<p>Logical, regularize covariance matrix or not.</p>
</td></tr>
<tr><td><code>on_diag</code></td>
<td>
<p>Logical, regularize diagonals or not.</p>
</td></tr>
</table>
<p>Implemented S3 methods include <code><a href="#topic+print.bioticStruct">print.bioticStruct</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sjSDM">sjSDM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  
# Basic workflow:
## simulate community:
com = simulate_SDM(env = 3L, species = 7L, sites = 100L)

## fit model:
model = sjSDM(Y = com$response,env = com$env_weights, iter = 50L,
              verbose = FALSE) 
# increase iter for your own data 

# Default distribution is binomial("probit"). Alternatively, you can use
# binomial(logit), poisson("log"), "nbinom" (with log, still somewhat 
# experimental) and gaussian("identity")

coef(model)
summary(model)
getCov(model)

## plot results
species=c("sp1","sp2","sp3","sp4","sp5","sp6","sp7")
group=c("mammal","bird","fish","fish","mammal","amphibian","amphibian")
group = data.frame(species=species,group=group)
plot(model,group=group)

## calculate post-hoc p-values:
p = getSe(model)
summary(p)

## or turn on the option in the sjSDM function:
model = sjSDM(Y = com$response, env = com$env_weights, se = TRUE, 
              family = binomial("probit"), 
              iter = 2L,
              verbose = FALSE)
summary(model)

## fit model with interactions:
model = sjSDM(Y = com$response,
              env = linear(data = com$env_weights, formula = ~X1:X2 + X3), 
              se = TRUE,
              iter = 2L,
              verbose = FALSE) # increase iter for your own data 
summary(model)

## without intercept:
model = update(model, env_formula = ~0+X1:X2 + X3,
               verbose = FALSE)

summary(model)

## predict with model:
preds = predict(model, newdata = com$env_weights)

## calculate R-squared:
R2 = Rsquared(model)
print(R2)

# With spatial terms:
## linear spatial model
XY = matrix(rnorm(200), 100, 2)
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = linear(XY, ~0+X1:X2),
              iter = 50L,
              verbose = FALSE) # increase iter for your own data 
summary(model)
predict(model, newdata = com$env_weights, SP = XY)
R2 = Rsquared(model)
print(R2)

## Using spatial eigenvectors as predictors to account 
## for spatial autocorrelation is a common approach:
SPV = generateSpatialEV(XY)
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = linear(SPV, ~0+., lambda = 0.1),
              iter = 50L,
              verbose = FALSE) # increase iter for your own data 
summary(model)
predict(model, newdata = com$env_weights, SP = SPV)

## Visualize internal meta-community structure
an = anova(model,
           verbose = FALSE)

internal = internalStructure(an)
plot(internal)

## Visualize community assemlby effects 

plotAssemblyEffects(internal)

### see ?anova.sjSDM for mroe details


## non-linear(deep neural network) model
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = DNN(SPV,hidden = c(5L, 5L), ~0+.),
              iter = 2L,# increase iter for your own data 
              verbose = FALSE) 
summary(model)
predict(model, newdata = com$env_weights, SP = SPV)


# Regularization
## lambda is the regularization strength
## alpha weights the lasso or ridge penalty:
## - alpha = 0 --&gt; pure lasso
## - alpha = 1.0 --&gt; pure ridge
model = sjSDM(Y = com$response, 
              # mix of lasso and ridge
              env = linear(com$env_weights, lambda = 0.01, alpha = 0.5), 
              # we can do the same for the species-species associations
              biotic = bioticStruct(lambda = 0.01, alpha = 0.5),
              iter = 2L,# increase iter for your own data 
              verbose = FALSE) 
summary(model)
coef(model)
getCov(model)



# Anova 
com = simulate_SDM(env = 3L, species = 15L, sites = 200L, correlation = TRUE)

XY = matrix(rnorm(400), 200, 2)
SPV = generateSpatialEV(XY)
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = linear(SPV, ~0+.), 
              verbose = FALSE,
              iter = 50L) # increase iter for your own data 
result = anova(model, verbose = FALSE)
print(result)
plot(result)

## visualize internal meta-community structure
internal = internalStructure(an)
plot(internal)



# Deep neural networks
## we can fit also a deep neural network instead of a linear model:
model = sjSDM(Y = com$response,
              env = DNN(com$env_weights, hidden = c(10L, 10L, 10L)),
              verbose = FALSE,
              iter = 2L) # increase iter for your own data 
summary(model)
getCov(model)
pred = predict(model, newdata = com$env_weights)

## extract weights
weights = getWeights(model)

## we can also assign weights:
setWeights(model, weights)

## with regularization:
model = sjSDM(Y = com$response, 
              # mix of lasso and ridge
              env = DNN(com$env_weights, lambda = 0.01, alpha = 0.5), 
              # we can do the same for the species-species associations
              biotic = bioticStruct(lambda = 0.01, alpha = 0.5),
              verbose = FALSE,
              iter = 2L) # increase iter for your own data 
getCov(model)
getWeights(model)

## End(Not run)
</code></pre>

<hr>
<h2 id='butterflies'>butterflies</h2><span id='topic+butterflies'></span>

<h3>Description</h3>

<p>This dataset is from <a href="https://doi.org/10.1111/2041-210X.13106">doi:10.1111/2041-210X.13106</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>butterflies
</code></pre>


<h3>Format</h3>

<p>A 'list': List of 3.
</p>

<dl>
<dt>env</dt><dd><p>data.frame with 4 environmental covariates</p>
</dd>
<dt>PA</dt><dd><p>Presence-absence data for 55 butterfly species</p>
</dd>
<dt>lat_lon</dt><dd><p>Coordinates for the sites</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is a dataset about butterfly communities. It consists of 2609 sites and 55 species.
</p>


<h3>Author(s)</h3>

<p>Maximilian Pichler
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1111/2041-210X.13106">doi:10.1111/2041-210X.13106</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  PA = butterflies$PA
  E = butterflies$env
  LatLon = butterflies$lat_lon
  
  m = sjSDM(PA, 
            scale(E), 
            spatial = DNN(scale(LatLon), formula = ~0+.), 
            se = TRUE,
            iter = 20L, # increase to 100
            step_size = 200L,
            verbose = FALSE)
  summary(m)
  plot(m)


## End(Not run)
</code></pre>

<hr>
<h2 id='check_module'>check module</h2><span id='topic+check_module'></span>

<h3>Description</h3>

<p>check if module is loaded
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_module()
</code></pre>

<hr>
<h2 id='checkModel'>check model
check model and rebuild if necessary</h2><span id='topic+checkModel'></span>

<h3>Description</h3>

<p>check model
check model and rebuild if necessary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkModel(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="checkModel_+3A_object">object</code></td>
<td>
<p>of class sjSDM</p>
</td></tr>
</table>

<hr>
<h2 id='coef.sjSDM'>Return coefficients from a fitted sjSDM model</h2><span id='topic+coef.sjSDM'></span>

<h3>Description</h3>

<p>Return coefficients from a fitted sjSDM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDM'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.sjSDM_+3A_object">object</code></td>
<td>
<p>a model fitted by <code><a href="#topic+sjSDM">sjSDM</a></code></p>
</td></tr>
<tr><td><code id="coef.sjSDM_+3A_...">...</code></td>
<td>
<p>optional arguments for compatibility with the generic function, no function implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of environmental coefficients or list of environmental and spatial coefficients for spatial models.
</p>

<hr>
<h2 id='DiffGrad'>DiffGrad</h2><span id='topic+DiffGrad'></span>

<h3>Description</h3>

<p>DiffGrad
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DiffGrad(betas = c(0.9, 0.999), eps = 1e-08, weight_decay = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DiffGrad_+3A_betas">betas</code></td>
<td>
<p>betas</p>
</td></tr>
<tr><td><code id="DiffGrad_+3A_eps">eps</code></td>
<td>
<p>eps</p>
</td></tr>
<tr><td><code id="DiffGrad_+3A_weight_decay">weight_decay</code></td>
<td>
<p>weight_decay</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Anonymous function that returns optimizer when called.
</p>

<hr>
<h2 id='DNN'>Non-linear model (deep neural network) of environmental responses</h2><span id='topic+DNN'></span>

<h3>Description</h3>

<p>specify the model to be fitted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DNN(
  data = NULL,
  formula = NULL,
  hidden = c(10L, 10L, 10L),
  activation = "selu",
  bias = TRUE,
  lambda = 0,
  alpha = 0.5,
  dropout = 0
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="DNN_+3A_data">data</code></td>
<td>
<p>matrix of environmental predictors</p>
</td></tr>
<tr><td><code id="DNN_+3A_formula">formula</code></td>
<td>
<p>formula object for predictors</p>
</td></tr>
<tr><td><code id="DNN_+3A_hidden">hidden</code></td>
<td>
<p>hidden units in layers, length of hidden corresponds to number of layers</p>
</td></tr>
<tr><td><code id="DNN_+3A_activation">activation</code></td>
<td>
<p>activation functions, can be of length one, or a vector of activation functions for each layer. Currently supported: tanh, relu, leakyrelu, selu, or sigmoid</p>
</td></tr>
<tr><td><code id="DNN_+3A_bias">bias</code></td>
<td>
<p>whether use biases in the layers, can be of length one, or a vector (number of hidden layers including (last layer) but not first layer (intercept in first layer is specified by formula)) of logicals for each layer.</p>
</td></tr>
<tr><td><code id="DNN_+3A_lambda">lambda</code></td>
<td>
<p>lambda penalty, strength of regularization: <code class="reqn">\lambda * (lasso + ridge)</code></p>
</td></tr>
<tr><td><code id="DNN_+3A_alpha">alpha</code></td>
<td>
<p>weighting between lasso and ridge: <code class="reqn">(1 - \alpha) * |weights| + \alpha ||weights||^2</code></p>
</td></tr>
<tr><td><code id="DNN_+3A_dropout">dropout</code></td>
<td>
<p>probability of dropout rate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 class of type 'DNN' including the following components:
</p>
<table role = "presentation">
<tr><td><code>formula</code></td>
<td>
<p>Model matrix formula</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Model matrix of covariates</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>l1_coef</code></td>
<td>
<p>L1 regularization strength, can be -99 if <code>lambda = 0.0</code></p>
</td></tr>
<tr><td><code>l2_coef</code></td>
<td>
<p>L2 regularization strength, can be -99 if <code>lambda = 0.0</code></p>
</td></tr>
<tr><td><code>hidden</code></td>
<td>
<p>Integer vector of hidden neurons in the deep neural network. Length of vector corresponds to the number of hidden layers.</p>
</td></tr>
<tr><td><code>activation</code></td>
<td>
<p>Character vector of activation functions.</p>
</td></tr>
<tr><td><code>bias</code></td>
<td>
<p>Logical vector whether to use bias or not in each hidden layer.</p>
</td></tr>
</table>
<p>Implemented S3 methods include <code><a href="#topic+print.DNN">print.DNN</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linear">linear</a></code>, <code><a href="#topic+sjSDM">sjSDM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  
# Basic workflow:
## simulate community:
com = simulate_SDM(env = 3L, species = 7L, sites = 100L)

## fit model:
model = sjSDM(Y = com$response,env = com$env_weights, iter = 50L,
              verbose = FALSE) 
# increase iter for your own data 

# Default distribution is binomial("probit"). Alternatively, you can use
# binomial(logit), poisson("log"), "nbinom" (with log, still somewhat 
# experimental) and gaussian("identity")

coef(model)
summary(model)
getCov(model)

## plot results
species=c("sp1","sp2","sp3","sp4","sp5","sp6","sp7")
group=c("mammal","bird","fish","fish","mammal","amphibian","amphibian")
group = data.frame(species=species,group=group)
plot(model,group=group)

## calculate post-hoc p-values:
p = getSe(model)
summary(p)

## or turn on the option in the sjSDM function:
model = sjSDM(Y = com$response, env = com$env_weights, se = TRUE, 
              family = binomial("probit"), 
              iter = 2L,
              verbose = FALSE)
summary(model)

## fit model with interactions:
model = sjSDM(Y = com$response,
              env = linear(data = com$env_weights, formula = ~X1:X2 + X3), 
              se = TRUE,
              iter = 2L,
              verbose = FALSE) # increase iter for your own data 
summary(model)

## without intercept:
model = update(model, env_formula = ~0+X1:X2 + X3,
               verbose = FALSE)

summary(model)

## predict with model:
preds = predict(model, newdata = com$env_weights)

## calculate R-squared:
R2 = Rsquared(model)
print(R2)

# With spatial terms:
## linear spatial model
XY = matrix(rnorm(200), 100, 2)
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = linear(XY, ~0+X1:X2),
              iter = 50L,
              verbose = FALSE) # increase iter for your own data 
summary(model)
predict(model, newdata = com$env_weights, SP = XY)
R2 = Rsquared(model)
print(R2)

## Using spatial eigenvectors as predictors to account 
## for spatial autocorrelation is a common approach:
SPV = generateSpatialEV(XY)
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = linear(SPV, ~0+., lambda = 0.1),
              iter = 50L,
              verbose = FALSE) # increase iter for your own data 
summary(model)
predict(model, newdata = com$env_weights, SP = SPV)

## Visualize internal meta-community structure
an = anova(model,
           verbose = FALSE)

internal = internalStructure(an)
plot(internal)

## Visualize community assemlby effects 

plotAssemblyEffects(internal)

### see ?anova.sjSDM for mroe details


## non-linear(deep neural network) model
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = DNN(SPV,hidden = c(5L, 5L), ~0+.),
              iter = 2L,# increase iter for your own data 
              verbose = FALSE) 
summary(model)
predict(model, newdata = com$env_weights, SP = SPV)


# Regularization
## lambda is the regularization strength
## alpha weights the lasso or ridge penalty:
## - alpha = 0 --&gt; pure lasso
## - alpha = 1.0 --&gt; pure ridge
model = sjSDM(Y = com$response, 
              # mix of lasso and ridge
              env = linear(com$env_weights, lambda = 0.01, alpha = 0.5), 
              # we can do the same for the species-species associations
              biotic = bioticStruct(lambda = 0.01, alpha = 0.5),
              iter = 2L,# increase iter for your own data 
              verbose = FALSE) 
summary(model)
coef(model)
getCov(model)



# Anova 
com = simulate_SDM(env = 3L, species = 15L, sites = 200L, correlation = TRUE)

XY = matrix(rnorm(400), 200, 2)
SPV = generateSpatialEV(XY)
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = linear(SPV, ~0+.), 
              verbose = FALSE,
              iter = 50L) # increase iter for your own data 
result = anova(model, verbose = FALSE)
print(result)
plot(result)

## visualize internal meta-community structure
internal = internalStructure(an)
plot(internal)



# Deep neural networks
## we can fit also a deep neural network instead of a linear model:
model = sjSDM(Y = com$response,
              env = DNN(com$env_weights, hidden = c(10L, 10L, 10L)),
              verbose = FALSE,
              iter = 2L) # increase iter for your own data 
summary(model)
getCov(model)
pred = predict(model, newdata = com$env_weights)

## extract weights
weights = getWeights(model)

## we can also assign weights:
setWeights(model, weights)

## with regularization:
model = sjSDM(Y = com$response, 
              # mix of lasso and ridge
              env = DNN(com$env_weights, lambda = 0.01, alpha = 0.5), 
              # we can do the same for the species-species associations
              biotic = bioticStruct(lambda = 0.01, alpha = 0.5),
              verbose = FALSE,
              iter = 2L) # increase iter for your own data 
getCov(model)
getWeights(model)

## End(Not run)
</code></pre>

<hr>
<h2 id='eucalypts'>eucalypts</h2><span id='topic+eucalypts'></span>

<h3>Description</h3>

<p>This dataset is from <a href="https://doi.org/10.1111/2041-210x.12180">doi:10.1111/2041-210x.12180</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eucalypts
</code></pre>


<h3>Format</h3>

<p>A 'list': List of 3.
</p>

<dl>
<dt>env</dt><dd><p>data.frame with 7 environmental covariates</p>
</dd>
<dt>PA</dt><dd><p>Presence-absence data for 12 eucalypts species</p>
</dd>
<dt>lat_lon</dt><dd><p>Coordinates for the sites</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is a dataset about butterfly communities. It consists of 458 sites and 12 species.
</p>


<h3>Author(s)</h3>

<p>Maximilian Pichler
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1111/2041-210x.12180">doi:10.1111/2041-210x.12180</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  PA = eucalypts$PA
  E = eucalypts$env
  LatLon = eucalypts$lat_lon
  
  m = sjSDM(PA, 
            scale(E), 
            spatial = DNN(scale(LatLon), formula = ~0+.), 
            se = TRUE,
            verbose = FALSE)
  summary(m)
  plot(m)
  

## End(Not run)
</code></pre>

<hr>
<h2 id='generateSpatialEV'>Generate spatial eigenvectors</h2><span id='topic+generateSpatialEV'></span>

<h3>Description</h3>

<p>Generates a Moran's eigenvector map of the distance matrix. See Dray, Legendre, and Peres-Neto, 2006 for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generateSpatialEV(coords = NULL, threshold = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="generateSpatialEV_+3A_coords">coords</code></td>
<td>
<p>matrix or data.frame of coordinates</p>
</td></tr>
<tr><td><code id="generateSpatialEV_+3A_threshold">threshold</code></td>
<td>
<p>ignore distances greater than threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of spatial eigenvectors.
</p>


<h3>References</h3>

<p>Dray, S., Legendre, P., &amp; Peres-Neto, P. R. (2006). Spatial modelling: a comprehensive framework for principal coordinate analysis of neighbour matrices (PCNM). Ecological modelling, 196(3-4), 483-493.
</p>

<hr>
<h2 id='getCor'>getCor</h2><span id='topic+getCor'></span><span id='topic+getCor.sjSDM'></span>

<h3>Description</h3>

<p>get species-species association correlation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCor(object)

## S3 method for class 'sjSDM'
getCor(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCor_+3A_object">object</code></td>
<td>
<p>a model fitted by <code><a href="#topic+sjSDM">sjSDM</a></code>, or <code><a href="#topic+sjSDM">sjSDM</a></code> with <code><a href="#topic+DNN">DNN</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of dimensions species by species corresponding to the covariance (occurrence) matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sjSDM">sjSDM</a></code>,<code><a href="#topic+DNN">DNN</a></code>
</p>

<hr>
<h2 id='getCov'>getCov</h2><span id='topic+getCov'></span><span id='topic+getCov.sjSDM'></span>

<h3>Description</h3>

<p>get species-species association (covariance) matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCov(object)

## S3 method for class 'sjSDM'
getCov(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCov_+3A_object">object</code></td>
<td>
<p>a model fitted by <code><a href="#topic+sjSDM">sjSDM</a></code>, or <code><a href="#topic+sjSDM">sjSDM</a></code> with <code><a href="#topic+DNN">DNN</a></code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of dimensions species by species corresponding to the covariance (occurrence) matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sjSDM">sjSDM</a></code>,<code><a href="#topic+DNN">DNN</a></code>
</p>

<hr>
<h2 id='getImportance'>getImportance</h2><span id='topic+getImportance'></span>

<h3>Description</h3>

<p>variation partitioning with coefficients
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getImportance(beta, sp = NULL, association, covX, covSP = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getImportance_+3A_beta">beta</code></td>
<td>
<p>abiotic weights</p>
</td></tr>
<tr><td><code id="getImportance_+3A_sp">sp</code></td>
<td>
<p>spatial weights</p>
</td></tr>
<tr><td><code id="getImportance_+3A_association">association</code></td>
<td>
<p>species associations</p>
</td></tr>
<tr><td><code id="getImportance_+3A_covx">covX</code></td>
<td>
<p>environmental covariance matrix</p>
</td></tr>
<tr><td><code id="getImportance_+3A_covsp">covSP</code></td>
<td>
<p>spatial covariance matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maximilian Pichler
</p>

<hr>
<h2 id='getSe'>Post hoc calculation of standard errors</h2><span id='topic+getSe'></span>

<h3>Description</h3>

<p>Post hoc calculation of standard errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSe(object, step_size = NULL, parallel = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getSe_+3A_object">object</code></td>
<td>
<p>a model fitted by <code><a href="#topic+sjSDM">sjSDM</a></code></p>
</td></tr>
<tr><td><code id="getSe_+3A_step_size">step_size</code></td>
<td>
<p>batch size for stochastic gradient descent</p>
</td></tr>
<tr><td><code id="getSe_+3A_parallel">parallel</code></td>
<td>
<p>number of cpu cores for the data loader, only necessary for large datasets</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The object passed to this function but the <code>object$se</code> field contains the standard errors now
</p>

<hr>
<h2 id='getWeights'>Get weights</h2><span id='topic+getWeights'></span><span id='topic+getWeights.sjSDM'></span>

<h3>Description</h3>

<p>return weights of each layer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getWeights(object)

## S3 method for class 'sjSDM'
getWeights(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getWeights_+3A_object">object</code></td>
<td>
<p>object of class <code><a href="#topic+sjSDM">sjSDM</a></code> with <code><a href="#topic+DNN">DNN</a></code></p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> layers - list of layer weights
</p>
</li>
<li><p> sigma - weight to construct covariance matrix
</p>
</li></ul>


<hr>
<h2 id='importance'>Importance of environmental, spatial and association components</h2><span id='topic+importance'></span>

<h3>Description</h3>

<p>Computes standardized variance components with respect to abiotic, biotic, and spatial effect groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>importance(x, save_memory = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="importance_+3A_x">x</code></td>
<td>
<p>object fitted by <code><a href="#topic+sjSDM">sjSDM</a></code> or a list with beta, the association matrix, and the correlation matrix of the predictors, see details below</p>
</td></tr>
<tr><td><code id="importance_+3A_save_memory">save_memory</code></td>
<td>
<p>use torch backend to calculate importance with single precision floats</p>
</td></tr>
<tr><td><code id="importance_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This approach is based on Ovaskainen et al., 2017, and also used in  Leibold et al., 2021. Unlike the <code><a href="#topic+anova.sjSDM">anova.sjSDM</a></code> function in the sjSDM package, importance is not calculated by explicitly switching a particular model component of and refitting the model, but essentially by setting it ineffective.
</p>
<p>Although we have no hard reasons to discourage the use of this function, we have decided in sjSDM to measure importance maninly based on a traditional ANOVA approach. We therefore recommend users to use the <code><a href="#topic+anova.sjSDM">anova.sjSDM</a></code>.
</p>
<p>This function is maintained hidden for comparison / benchmarking purpose, and in case there is a need to use it in the future. If you want to access it, use sjSDM:::importance.
</p>


<h3>Value</h3>

<p>An S3 class of type 'sjSDMimportance' including the following components:
</p>
<table role = "presentation">
<tr><td><code>names</code></td>
<td>
<p>Character vector, species names.</p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>Data frame of results.</p>
</td></tr>
<tr><td><code>spatial</code></td>
<td>
<p>Logical, spatial model or not.</p>
</td></tr>
</table>
<p>Implemented S3 methods include <code><a href="#topic+print.sjSDMimportance">print.sjSDMimportance</a></code> and <code><a href="#topic+plot.sjSDMimportance">plot.sjSDMimportance</a></code>
</p>


<h3>Author(s)</h3>

<p>Maximilian Pichler
</p>


<h3>References</h3>

<p>Ovaskainen, O., Tikhonov, G., Norberg, A., Guillaume Blanchet, F., Duan, L., Dunson, D., ... &amp; Abrego, N. (2017). How to make more out of community data? A conceptual framework and its implementation as models and software. Ecology letters, 20(5), 561-576.
</p>
<p>Leibold, M. A., Rudolph, F. J., Blanchet, F. G., De Meester, L., Gravel, D., Hartig, F., ... &amp; Chase, J. M. (2021). The internal structure of metacommunities. Oikos.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.sjSDMimportance">print.sjSDMimportance</a></code>, <code><a href="#topic+plot.sjSDMimportance">plot.sjSDMimportance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sjSDM)
com = simulate_SDM(sites = 300L, species = 12L, 
                   link = "identical", response = "identical")
Raw = com$response
SP = matrix(rnorm(300*2), 300, 2)
SPweights = matrix(rnorm(12L), 1L)
SPweights[1,1:6] = 0
Y = Raw + (SP[,1,drop=FALSE]*SP[,2,drop=FALSE]) %*% SPweights
Y = ifelse(Y &gt; 0, 1, 0)

model = sjSDM(Y = Y,env = linear(com$env_weights, lambda = 0.001), 
              spatial = linear(SP,formula = ~0+X1:X2, lambda = 0.001), 
              biotic = bioticStruct(lambda = 0.001),iter = 40L, verbose = FALSE)
imp = importance(model)
plot(imp)

## End(Not run)
</code></pre>

<hr>
<h2 id='install_diagnostic'>install diagnostic</h2><span id='topic+install_diagnostic'></span>

<h3>Description</h3>

<p>Print information about available conda environments, python configs, and pytorch versions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_diagnostic()
</code></pre>


<h3>Details</h3>

<p>If the trouble shooting guide <code><a href="#topic+installation_help">installation_help</a></code> did not help with the installation, please create an issue on <a href="https://github.com/TheoreticalEcology/s-jSDM/issues">issue tracker</a> with the output of this function as a quote.
</p>


<h3>Value</h3>

<p>No return value, called to extract dependency information.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+installation_help">installation_help</a></code>, <code><a href="#topic+install_sjSDM">install_sjSDM</a></code>
</p>

<hr>
<h2 id='install_sjSDM'>Install sjSDM and its dependencies</h2><span id='topic+install_sjSDM'></span>

<h3>Description</h3>

<p>Install sjSDM and its dependencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_sjSDM(
  conda = "auto",
  version = c("cpu", "gpu"),
  restart_session = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="install_sjSDM_+3A_conda">conda</code></td>
<td>
<p>path to conda</p>
</td></tr>
<tr><td><code id="install_sjSDM_+3A_version">version</code></td>
<td>
<p>version = &quot;cpu&quot; for CPU version, or &quot;gpu&quot; for GPU version. (note MacOS users have to install 'cuda' binaries by themselves)</p>
</td></tr>
<tr><td><code id="install_sjSDM_+3A_restart_session">restart_session</code></td>
<td>
<p>Restart R session after installing (note this will
only occur within RStudio).</p>
</td></tr>
<tr><td><code id="install_sjSDM_+3A_...">...</code></td>
<td>
<p>not supported</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects (installation of 'python' dependencies).
</p>

<hr>
<h2 id='internalStructure'>Plot internal metacommunity structure</h2><span id='topic+internalStructure'></span>

<h3>Description</h3>

<p>Plot internal metacommunity structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>internalStructure(
  object,
  Rsquared = c("McFadden", "Nagelkerke"),
  fractions = c("discard", "proportional", "equal"),
  negatives = c("floor", "scale", "raw"),
  plot = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="internalStructure_+3A_object">object</code></td>
<td>
<p>anova object from <code><a href="#topic+anova.sjSDM">anova.sjSDM</a></code></p>
</td></tr>
<tr><td><code id="internalStructure_+3A_rsquared">Rsquared</code></td>
<td>
<p>which R squared should be used, McFadden or Nagelkerke (McFadden is default)</p>
</td></tr>
<tr><td><code id="internalStructure_+3A_fractions">fractions</code></td>
<td>
<p>how to handle shared fractions</p>
</td></tr>
<tr><td><code id="internalStructure_+3A_negatives">negatives</code></td>
<td>
<p>how to handle negative R squareds</p>
</td></tr>
<tr><td><code id="internalStructure_+3A_plot">plot</code></td>
<td>
<p>should the plots be suppressed or not.
</p>
<p>Plots and returns the internal metacommunity structure of species and sites (see Leibold et al., 2022).
Plots were heavily inspired by Leibold et al., 2022</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class sjSDMinternalStructure consisting of a list of data.frames with the internal structure.
</p>


<h3>References</h3>

<p>Leibold, M. A., Rudolph, F. J., Blanchet, F. G., De Meester, L., Gravel, D., Hartig, F., ... &amp; Chase, J. M. (2022). The internal structure of metacommunities. Oikos, 2022(1).
</p>


<h3>See Also</h3>

<p><a href="#topic+plot.sjSDMinternalStructure">plot.sjSDMinternalStructure</a>, <a href="#topic+print.sjSDMinternalStructure">print.sjSDMinternalStructure</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sjSDM)
# simulate community:
community = simulate_SDM(env = 3L, species = 10L, sites = 100L)

Occ &lt;- community$response
Env &lt;- community$env_weights
SP &lt;- data.frame(matrix(rnorm(200, 0, 0.3), 100, 2)) # spatial coordinates


# fit model:
model &lt;- sjSDM(Y = Occ, 
               env = linear(data = Env, formula = ~X1+X2+X3), 
               spatial = linear(data = SP, formula = ~0+X1*X2), 
               family=binomial("probit"),
               verbose = FALSE,
               iter = 20) # increase iter for real analysis

# Calculate ANOVA for env, space, associations, for details see ?anova.sjSDM
an = anova(model, samples = 10, verbose = FALSE) # increase iter for real analysis

# Show anova fractions
plot(an)

# ANOVA tables with different way to handle fractions
summary(an)
summary(an, fractions = "discard")
summary(an, fractions = "proportional")
summary(an, fractions = "equal")

# Internal structure
int = internalStructure(an, fractions = "proportional")

print(int)

plot(int) # default is negative values will be set to 0
plot(int, negatives = "scale") # global rescaling of all values to range 0-1
plot(int, negatives = "raw") # negative values will be discarded

plotAssemblyEffects(int)
plotAssemblyEffects(int, negatives = "floor")
plotAssemblyEffects(int, response = "sites", pred = as.factor(c(rep(1, 50), rep(2, 50))))
plotAssemblyEffects(int, response = "species", pred = runif(10))
plotAssemblyEffects(int, response = "species", pred = as.factor(c(rep(1, 5), rep(2, 5))))

## End(Not run)
</code></pre>

<hr>
<h2 id='is_torch_available'>is_torch_available</h2><span id='topic+is_torch_available'></span>

<h3>Description</h3>

<p>is_torch_available
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_torch_available()
</code></pre>


<h3>Details</h3>

<p>check whether torch is available
</p>


<h3>Value</h3>

<p>Logical, is torch module available or not.
</p>

<hr>
<h2 id='linear'>Linear model of environmental response</h2><span id='topic+linear'></span>

<h3>Description</h3>

<p>specify the model to be fitted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linear(data = NULL, formula = NULL, lambda = 0, alpha = 0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linear_+3A_data">data</code></td>
<td>
<p>matrix of environmental predictors</p>
</td></tr>
<tr><td><code id="linear_+3A_formula">formula</code></td>
<td>
<p>formula object for predictors</p>
</td></tr>
<tr><td><code id="linear_+3A_lambda">lambda</code></td>
<td>
<p>lambda penalty, strength of regularization: <code class="reqn">\lambda * (lasso + ridge)</code></p>
</td></tr>
<tr><td><code id="linear_+3A_alpha">alpha</code></td>
<td>
<p>weighting between lasso and ridge: <code class="reqn">(1 - \alpha) * |coefficients| + \alpha ||coefficients||^2</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 class of type 'linear' including the following components:
</p>
<table role = "presentation">
<tr><td><code>formula</code></td>
<td>
<p>Model matrix formula</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>Model matrix of covariates</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>Raw data</p>
</td></tr>
<tr><td><code>l1_coef</code></td>
<td>
<p>L1 regularization strength, can be -99 if <code>lambda = 0.0</code></p>
</td></tr>
<tr><td><code>l2_coef</code></td>
<td>
<p>L2 regularization strength, can be -99 if <code>lambda = 0.0</code></p>
</td></tr>
</table>
<p>Implemented S3 methods include <code><a href="#topic+print.linear">print.linear</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+DNN">DNN</a></code>, <code><a href="#topic+sjSDM">sjSDM</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  
# Basic workflow:
## simulate community:
com = simulate_SDM(env = 3L, species = 7L, sites = 100L)

## fit model:
model = sjSDM(Y = com$response,env = com$env_weights, iter = 50L,
              verbose = FALSE) 
# increase iter for your own data 

# Default distribution is binomial("probit"). Alternatively, you can use
# binomial(logit), poisson("log"), "nbinom" (with log, still somewhat 
# experimental) and gaussian("identity")

coef(model)
summary(model)
getCov(model)

## plot results
species=c("sp1","sp2","sp3","sp4","sp5","sp6","sp7")
group=c("mammal","bird","fish","fish","mammal","amphibian","amphibian")
group = data.frame(species=species,group=group)
plot(model,group=group)

## calculate post-hoc p-values:
p = getSe(model)
summary(p)

## or turn on the option in the sjSDM function:
model = sjSDM(Y = com$response, env = com$env_weights, se = TRUE, 
              family = binomial("probit"), 
              iter = 2L,
              verbose = FALSE)
summary(model)

## fit model with interactions:
model = sjSDM(Y = com$response,
              env = linear(data = com$env_weights, formula = ~X1:X2 + X3), 
              se = TRUE,
              iter = 2L,
              verbose = FALSE) # increase iter for your own data 
summary(model)

## without intercept:
model = update(model, env_formula = ~0+X1:X2 + X3,
               verbose = FALSE)

summary(model)

## predict with model:
preds = predict(model, newdata = com$env_weights)

## calculate R-squared:
R2 = Rsquared(model)
print(R2)

# With spatial terms:
## linear spatial model
XY = matrix(rnorm(200), 100, 2)
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = linear(XY, ~0+X1:X2),
              iter = 50L,
              verbose = FALSE) # increase iter for your own data 
summary(model)
predict(model, newdata = com$env_weights, SP = XY)
R2 = Rsquared(model)
print(R2)

## Using spatial eigenvectors as predictors to account 
## for spatial autocorrelation is a common approach:
SPV = generateSpatialEV(XY)
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = linear(SPV, ~0+., lambda = 0.1),
              iter = 50L,
              verbose = FALSE) # increase iter for your own data 
summary(model)
predict(model, newdata = com$env_weights, SP = SPV)

## Visualize internal meta-community structure
an = anova(model,
           verbose = FALSE)

internal = internalStructure(an)
plot(internal)

## Visualize community assemlby effects 

plotAssemblyEffects(internal)

### see ?anova.sjSDM for mroe details


## non-linear(deep neural network) model
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = DNN(SPV,hidden = c(5L, 5L), ~0+.),
              iter = 2L,# increase iter for your own data 
              verbose = FALSE) 
summary(model)
predict(model, newdata = com$env_weights, SP = SPV)


# Regularization
## lambda is the regularization strength
## alpha weights the lasso or ridge penalty:
## - alpha = 0 --&gt; pure lasso
## - alpha = 1.0 --&gt; pure ridge
model = sjSDM(Y = com$response, 
              # mix of lasso and ridge
              env = linear(com$env_weights, lambda = 0.01, alpha = 0.5), 
              # we can do the same for the species-species associations
              biotic = bioticStruct(lambda = 0.01, alpha = 0.5),
              iter = 2L,# increase iter for your own data 
              verbose = FALSE) 
summary(model)
coef(model)
getCov(model)



# Anova 
com = simulate_SDM(env = 3L, species = 15L, sites = 200L, correlation = TRUE)

XY = matrix(rnorm(400), 200, 2)
SPV = generateSpatialEV(XY)
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = linear(SPV, ~0+.), 
              verbose = FALSE,
              iter = 50L) # increase iter for your own data 
result = anova(model, verbose = FALSE)
print(result)
plot(result)

## visualize internal meta-community structure
internal = internalStructure(an)
plot(internal)



# Deep neural networks
## we can fit also a deep neural network instead of a linear model:
model = sjSDM(Y = com$response,
              env = DNN(com$env_weights, hidden = c(10L, 10L, 10L)),
              verbose = FALSE,
              iter = 2L) # increase iter for your own data 
summary(model)
getCov(model)
pred = predict(model, newdata = com$env_weights)

## extract weights
weights = getWeights(model)

## we can also assign weights:
setWeights(model, weights)

## with regularization:
model = sjSDM(Y = com$response, 
              # mix of lasso and ridge
              env = DNN(com$env_weights, lambda = 0.01, alpha = 0.5), 
              # we can do the same for the species-species associations
              biotic = bioticStruct(lambda = 0.01, alpha = 0.5),
              verbose = FALSE,
              iter = 2L) # increase iter for your own data 
getCov(model)
getWeights(model)

## End(Not run)
</code></pre>

<hr>
<h2 id='logLik.sjSDM'>Extract negative-log-Likelihood from a fitted sjSDM model</h2><span id='topic+logLik.sjSDM'></span>

<h3>Description</h3>

<p>Extract negative-log-Likelihood from a fitted sjSDM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDM'
logLik(object, individual = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.sjSDM_+3A_object">object</code></td>
<td>
<p>a model fitted by <code><a href="#topic+sjSDM">sjSDM</a></code></p>
</td></tr>
<tr><td><code id="logLik.sjSDM_+3A_individual">individual</code></td>
<td>
<p>returns internal ll structure, mostly for internal useage</p>
</td></tr>
<tr><td><code id="logLik.sjSDM_+3A_...">...</code></td>
<td>
<p>optional arguments passed to internal logLik function (only used if <code>individual=TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric value or numeric matrix if individual is true.
</p>

<hr>
<h2 id='madgrad'>madgrad</h2><span id='topic+madgrad'></span>

<h3>Description</h3>

<p>stochastic gradient descent optimizer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>madgrad(momentum = 0.9, weight_decay = 0, eps = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="madgrad_+3A_momentum">momentum</code></td>
<td>
<p>strength of momentum</p>
</td></tr>
<tr><td><code id="madgrad_+3A_weight_decay">weight_decay</code></td>
<td>
<p>l2 penalty on weights</p>
</td></tr>
<tr><td><code id="madgrad_+3A_eps">eps</code></td>
<td>
<p>epsilon</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Anonymous function that returns optimizer when called.
</p>


<h3>References</h3>

<p>Defazio, A., &amp; Jelassi, S. (2021). Adaptivity without Compromise: A Momentumized, Adaptive, Dual Averaged Gradient Method for Stochastic Optimization. arXiv preprint arXiv:2101.11075.
</p>

<hr>
<h2 id='new_image'>new_image function</h2><span id='topic+new_image'></span>

<h3>Description</h3>

<p>new_image function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_image(
  z,
  cols = (grDevices::colorRampPalette(c("white", "#24526E"), bias = 1.5))(10),
  range = c(0.5, 1)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="new_image_+3A_z">z</code></td>
<td>
<p>z matrix</p>
</td></tr>
<tr><td><code id="new_image_+3A_cols">cols</code></td>
<td>
<p>cols for gradient</p>
</td></tr>
<tr><td><code id="new_image_+3A_range">range</code></td>
<td>
<p>rescale to range</p>
</td></tr>
</table>

<hr>
<h2 id='plot.sjSDM'>Coefficients plot</h2><span id='topic+plot.sjSDM'></span>

<h3>Description</h3>

<p>Plotting coefficients returned by sjSDM model.
This function only for model fitted by linear, fitted by DNN is not yet supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDM'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sjSDM_+3A_x">x</code></td>
<td>
<p>a model fitted by <code><a href="#topic+sjSDM">sjSDM</a></code></p>
</td></tr>
<tr><td><code id="plot.sjSDM_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code><a href="#topic+plotsjSDMcoef">plotsjSDMcoef</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object for linear sjSDM model and nothing for DNN sjSDM model.
</p>


<h3>Author(s)</h3>

<p>CAI Wang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotsjSDMcoef">plotsjSDMcoef</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sjSDM)
# simulate community:
com = simulate_SDM(env = 6L, species = 7L, sites = 100L)

# fit model:
model = sjSDM(Y = com$response,env = com$env_weights, iter = 2L, se = TRUE,
              verbose = FALSE) 

# normal plot
plot(model)

# colored by groups
species=c("sp1","sp2","sp3","sp4","sp5","sp6","sp7")
group=c("mammal","bird","fish","fish","mammal","amphibian","amphibian")
group = data.frame(species=species,group=group)

plot(model,group=group)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.sjSDM_cv'>Plot elastic net tuning</h2><span id='topic+plot.sjSDM_cv'></span>

<h3>Description</h3>

<p>Plot elastic net tuning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDM_cv'
plot(x, y, perf = c("logLik", "AUC", "AUC_macro"), resolution = 6, k = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sjSDM_cv_+3A_x">x</code></td>
<td>
<p>a model fitted by <code><a href="#topic+sjSDM_cv">sjSDM_cv</a></code></p>
</td></tr>
<tr><td><code id="plot.sjSDM_cv_+3A_y">y</code></td>
<td>
<p>unused argument</p>
</td></tr>
<tr><td><code id="plot.sjSDM_cv_+3A_perf">perf</code></td>
<td>
<p>performance measurement to plot</p>
</td></tr>
<tr><td><code id="plot.sjSDM_cv_+3A_resolution">resolution</code></td>
<td>
<p>resolution of grid</p>
</td></tr>
<tr><td><code id="plot.sjSDM_cv_+3A_k">k</code></td>
<td>
<p>number of knots for the gm</p>
</td></tr>
<tr><td><code id="plot.sjSDM_cv_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>plot()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Named vector of optimized regularization parameters.
</p>
<p>Without space:
</p>
<table role = "presentation">
<tr><td><code>lambda_cov</code></td>
<td>
<p>Regularization strength in the <code><a href="#topic+bioticStruct">bioticStruct</a></code> object.</p>
</td></tr>
<tr><td><code>alpha_cov</code></td>
<td>
<p>Weigthing between L1 and L2 in the <code><a href="#topic+bioticStruct">bioticStruct</a></code> object.</p>
</td></tr>
<tr><td><code>lambda_coef</code></td>
<td>
<p>Regularization strength in the <code><a href="#topic+linear">linear</a></code> or <code><a href="#topic+DNN">DNN</a></code> object.</p>
</td></tr>
<tr><td><code>alpha_coef</code></td>
<td>
<p>Weigthing between L1 and L2 in the <code><a href="#topic+linear">linear</a></code> or <code><a href="#topic+DNN">DNN</a></code> object.</p>
</td></tr>
</table>
<p>With space:
</p>
<table role = "presentation">
<tr><td><code>lambda_cov</code></td>
<td>
<p>Regularization strength in the <code><a href="#topic+bioticStruct">bioticStruct</a></code> object.</p>
</td></tr>
<tr><td><code>alpha_cov</code></td>
<td>
<p>Weigthing between L1 and L2 in the <code><a href="#topic+bioticStruct">bioticStruct</a></code> object.</p>
</td></tr>
<tr><td><code>lambda_coef</code></td>
<td>
<p>Regularization strength in the <code><a href="#topic+linear">linear</a></code> or <code><a href="#topic+DNN">DNN</a></code> object.</p>
</td></tr>
<tr><td><code>alpha_coef</code></td>
<td>
<p>Weigthing between L1 and L2 in the <code><a href="#topic+linear">linear</a></code> or <code><a href="#topic+DNN">DNN</a></code> object.</p>
</td></tr>
<tr><td><code>lambda_spatial</code></td>
<td>
<p>Regularization strength in the <code><a href="#topic+linear">linear</a></code> or <code><a href="#topic+DNN">DNN</a></code> object for the spatial component.</p>
</td></tr>
<tr><td><code>alpha_spatial</code></td>
<td>
<p>Weigthing between L1 and L2 in the<code><a href="#topic+linear">linear</a></code> or <code><a href="#topic+DNN">DNN</a></code> object for the spatial component.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.sjSDM.DNN'>Training history</h2><span id='topic+plot.sjSDM.DNN'></span>

<h3>Description</h3>

<p>Plot training loss history
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDM.DNN'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sjSDM.DNN_+3A_x">x</code></td>
<td>
<p>a model fitted by <code><a href="#topic+sjSDM">sjSDM</a></code> with <code><a href="#topic+DNN">DNN</a></code> object</p>
</td></tr>
<tr><td><code id="plot.sjSDM.DNN_+3A_...">...</code></td>
<td>
<p>passed to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sjSDM)
# simulate community:
com = simulate_SDM(env = 6L, species = 7L, sites = 100L)

# fit model:
model = sjSDM(Y = com$response,env = com$env_weights, iter = 2L, se = TRUE,
              verbose = FALSE) 

# normal plot
plot(model)

# colored by groups
species=c("sp1","sp2","sp3","sp4","sp5","sp6","sp7")
group=c("mammal","bird","fish","fish","mammal","amphibian","amphibian")
group = data.frame(species=species,group=group)

plot(model,group=group)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.sjSDManova'>Plot anova results</h2><span id='topic+plot.sjSDManova'></span>

<h3>Description</h3>

<p>Plot anova results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDManova'
plot(
  x,
  y,
  type = c("McFadden", "Deviance", "Nagelkerke"),
  fractions = c("discard", "proportional", "equal"),
  cols = c("#7FC97F", "#BEAED4", "#FDC086"),
  alpha = 0.15,
  env_deviance = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sjSDManova_+3A_x">x</code></td>
<td>
<p>anova object from <code><a href="#topic+anova.sjSDM">anova.sjSDM</a></code></p>
</td></tr>
<tr><td><code id="plot.sjSDManova_+3A_y">y</code></td>
<td>
<p>unused argument</p>
</td></tr>
<tr><td><code id="plot.sjSDManova_+3A_type">type</code></td>
<td>
<p>deviance, Nagelkerke or McFadden R-squared</p>
</td></tr>
<tr><td><code id="plot.sjSDManova_+3A_fractions">fractions</code></td>
<td>
<p>how to handle shared fractions</p>
</td></tr>
<tr><td><code id="plot.sjSDManova_+3A_cols">cols</code></td>
<td>
<p>colors for the groups</p>
</td></tr>
<tr><td><code id="plot.sjSDManova_+3A_alpha">alpha</code></td>
<td>
<p>alpha for colors</p>
</td></tr>
<tr><td><code id="plot.sjSDManova_+3A_env_deviance">env_deviance</code></td>
<td>
<p>environmental deviance</p>
</td></tr>
<tr><td><code id="plot.sjSDManova_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>plot()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following components:
</p>
<table role = "presentation">
<tr><td><code>VENN</code></td>
<td>
<p>Matrix of shown results.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Leibold, M. A., Rudolph, F. J., Blanchet, F. G., De Meester, L., Gravel, D., Hartig, F., ... &amp; Chase, J. M. (2022). The internal structure of metacommunities. Oikos, 2022(1).
</p>

<hr>
<h2 id='plot.sjSDMimportance'>Plot importance</h2><span id='topic+plot.sjSDMimportance'></span>

<h3>Description</h3>

<p>Plot importance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDMimportance'
plot(x, y, col.points = "#24526e", cex.points = 1.2, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sjSDMimportance_+3A_x">x</code></td>
<td>
<p>a model fitted by <code><a href="#topic+importance">importance</a></code></p>
</td></tr>
<tr><td><code id="plot.sjSDMimportance_+3A_y">y</code></td>
<td>
<p>unused argument</p>
</td></tr>
<tr><td><code id="plot.sjSDMimportance_+3A_col.points">col.points</code></td>
<td>
<p>point color</p>
</td></tr>
<tr><td><code id="plot.sjSDMimportance_+3A_cex.points">cex.points</code></td>
<td>
<p>point size</p>
</td></tr>
<tr><td><code id="plot.sjSDMimportance_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to <code>plot()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The visualized matrix is silently returned.
</p>

<hr>
<h2 id='plot.sjSDMinternalStructure'>Plot internal structure</h2><span id='topic+plot.sjSDMinternalStructure'></span>

<h3>Description</h3>

<p>Creates a ternary diagram of an object of class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDMinternalStructure'
plot(
  x,
  alpha = 0.15,
  env_deviance = NULL,
  negatives = c("floor", "scale", "raw"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.sjSDMinternalStructure_+3A_x">x</code></td>
<td>
<p>and object of class sjSDMinternalStructure create by anova object from <code><a href="#topic+internalStructure">internalStructure</a></code></p>
</td></tr>
<tr><td><code id="plot.sjSDMinternalStructure_+3A_alpha">alpha</code></td>
<td>
<p>alpha of points</p>
</td></tr>
<tr><td><code id="plot.sjSDMinternalStructure_+3A_env_deviance">env_deviance</code></td>
<td>
<p>environmental deviance/gradient (points will be colored)</p>
</td></tr>
<tr><td><code id="plot.sjSDMinternalStructure_+3A_negatives">negatives</code></td>
<td>
<p>how to handle negative R squareds</p>
</td></tr>
<tr><td><code id="plot.sjSDMinternalStructure_+3A_...">...</code></td>
<td>
<p>no function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sjSDM)
# simulate community:
community = simulate_SDM(env = 3L, species = 10L, sites = 100L)

Occ &lt;- community$response
Env &lt;- community$env_weights
SP &lt;- data.frame(matrix(rnorm(200, 0, 0.3), 100, 2)) # spatial coordinates


# fit model:
model &lt;- sjSDM(Y = Occ, 
               env = linear(data = Env, formula = ~X1+X2+X3), 
               spatial = linear(data = SP, formula = ~0+X1*X2), 
               family=binomial("probit"),
               verbose = FALSE,
               iter = 20) # increase iter for real analysis

# Calculate ANOVA for env, space, associations, for details see ?anova.sjSDM
an = anova(model, samples = 10, verbose = FALSE) # increase iter for real analysis

# Show anova fractions
plot(an)

# ANOVA tables with different way to handle fractions
summary(an)
summary(an, fractions = "discard")
summary(an, fractions = "proportional")
summary(an, fractions = "equal")

# Internal structure
int = internalStructure(an, fractions = "proportional")

print(int)

plot(int) # default is negative values will be set to 0
plot(int, negatives = "scale") # global rescaling of all values to range 0-1
plot(int, negatives = "raw") # negative values will be discarded

plotAssemblyEffects(int)
plotAssemblyEffects(int, negatives = "floor")
plotAssemblyEffects(int, response = "sites", pred = as.factor(c(rep(1, 50), rep(2, 50))))
plotAssemblyEffects(int, response = "species", pred = runif(10))
plotAssemblyEffects(int, response = "species", pred = as.factor(c(rep(1, 5), rep(2, 5))))

## End(Not run)
</code></pre>

<hr>
<h2 id='plotAssemblyEffects'>Plot predictors of assembly processes</h2><span id='topic+plotAssemblyEffects'></span>

<h3>Description</h3>

<p>The function plots correlations between assembly processes and predictors or traits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotAssemblyEffects(
  object,
  response = c("sites", "species"),
  pred = NULL,
  cols = c("#A38310", "#B42398", "#20A382"),
  negatives = c("raw", "scale", "floor")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotAssemblyEffects_+3A_object">object</code></td>
<td>
<p>An <code>sjSDManova</code> object from the <code><a href="#topic+anova.sjSDM">anova.sjSDM</a></code> function.</p>
</td></tr>
<tr><td><code id="plotAssemblyEffects_+3A_response">response</code></td>
<td>
<p>whether to use sites or species. Default is sites</p>
</td></tr>
<tr><td><code id="plotAssemblyEffects_+3A_pred">pred</code></td>
<td>
<p>predictor variable. If <code>NULL</code>, environment uniqueness, spatial uniqueness, and richness is calculated from the fitted object and used as predictor.</p>
</td></tr>
<tr><td><code id="plotAssemblyEffects_+3A_cols">cols</code></td>
<td>
<p>Colors for the three assembly processes.</p>
</td></tr>
<tr><td><code id="plotAssemblyEffects_+3A_negatives">negatives</code></td>
<td>
<p>how to handle negative R squareds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Correlation and plots of the three assembly processes (environment, space, and codist) against environmental and spatial uniqueness and richness. The importance of the three assembly processes is measured by the partial R-squared (shown in the internal structure plots).
</p>
<p>Importances are available for species and sites. Custom environmental predictors or traits can be specified. Environmental predictors are plotted against site R-squared and traits are plotted against species R-squared.
Regression lines are estimated by 50\
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table role = "presentation">
<tr><td><code>env</code></td>
<td>
<p>A list of summary tables for env, space, and codist R-squared.</p>
</td></tr>
<tr><td><code>space</code></td>
<td>
<p>A list of summary tables for env, space, and codist R-squared.</p>
</td></tr>
<tr><td><code>codist</code></td>
<td>
<p>A list of summary tables for env, space, and codist R-squared.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Defaults for negative values are different than for <a href="#topic+plot.sjSDMinternalStructure">plot.sjSDMinternalStructure</a>
</p>


<h3>References</h3>

<p>Leibold, M. A., Rudolph, F. J., Blanchet, F. G., De Meester, L., Gravel, D., Hartig, F., ... &amp; Chase, J. M. (2022). The internal structure of metacommunities. <em>Oikos</em>, 2022(1).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sjSDM)
# simulate community:
community = simulate_SDM(env = 3L, species = 10L, sites = 100L)

Occ &lt;- community$response
Env &lt;- community$env_weights
SP &lt;- data.frame(matrix(rnorm(200, 0, 0.3), 100, 2)) # spatial coordinates


# fit model:
model &lt;- sjSDM(Y = Occ, 
               env = linear(data = Env, formula = ~X1+X2+X3), 
               spatial = linear(data = SP, formula = ~0+X1*X2), 
               family=binomial("probit"),
               verbose = FALSE,
               iter = 20) # increase iter for real analysis

# Calculate ANOVA for env, space, associations, for details see ?anova.sjSDM
an = anova(model, samples = 10, verbose = FALSE) # increase iter for real analysis

# Show anova fractions
plot(an)

# ANOVA tables with different way to handle fractions
summary(an)
summary(an, fractions = "discard")
summary(an, fractions = "proportional")
summary(an, fractions = "equal")

# Internal structure
int = internalStructure(an, fractions = "proportional")

print(int)

plot(int) # default is negative values will be set to 0
plot(int, negatives = "scale") # global rescaling of all values to range 0-1
plot(int, negatives = "raw") # negative values will be discarded

plotAssemblyEffects(int)
plotAssemblyEffects(int, negatives = "floor")
plotAssemblyEffects(int, response = "sites", pred = as.factor(c(rep(1, 50), rep(2, 50))))
plotAssemblyEffects(int, response = "species", pred = runif(10))
plotAssemblyEffects(int, response = "species", pred = as.factor(c(rep(1, 5), rep(2, 5))))

## End(Not run)
</code></pre>

<hr>
<h2 id='plotsjSDMcoef'>Internal coefficients plot</h2><span id='topic+plotsjSDMcoef'></span>

<h3>Description</h3>

<p>Plotting coefficients returned by sjSDM model.
This function only for model fitted by linear, fitted by DNN is not yet supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotsjSDMcoef(object, wrap_col = NULL, group = NULL, col = NULL, slist = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotsjSDMcoef_+3A_object">object</code></td>
<td>
<p>a model fitted by <code><a href="#topic+sjSDM">sjSDM</a></code></p>
</td></tr>
<tr><td><code id="plotsjSDMcoef_+3A_wrap_col">wrap_col</code></td>
<td>
<p>Scales argument passed to wrap_col</p>
</td></tr>
<tr><td><code id="plotsjSDMcoef_+3A_group">group</code></td>
<td>
<p>Define the taxonomic characteristics of a species, you need to provide a dataframe with column1 named species and column2 named group, default is NULL. For example, <code>group[1,1]== "sp1"</code>, <code>group[1,2]== "Mammal"</code>.</p>
</td></tr>
<tr><td><code id="plotsjSDMcoef_+3A_col">col</code></td>
<td>
<p>Define colors for groups, default is NULL.</p>
</td></tr>
<tr><td><code id="plotsjSDMcoef_+3A_slist">slist</code></td>
<td>
<p>Select the species you want to plot, default is all, parameter is not supported yet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object
</p>


<h3>Author(s)</h3>

<p>CAI Wang
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sjSDM)
# simulate community:
com = simulate_SDM(env = 6L, species = 7L, sites = 100L)

# fit model:
model = sjSDM(Y = com$response,env = com$env_weights, iter = 2L, se = TRUE,
              verbose = FALSE) 

# normal plot
plot(model)

# colored by groups
species=c("sp1","sp2","sp3","sp4","sp5","sp6","sp7")
group=c("mammal","bird","fish","fish","mammal","amphibian","amphibian")
group = data.frame(species=species,group=group)

plot(model,group=group)

## End(Not run)
</code></pre>

<hr>
<h2 id='predict.sjSDM'>Predict from a fitted sjSDM model</h2><span id='topic+predict.sjSDM'></span>

<h3>Description</h3>

<p>Predict from a fitted sjSDM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDM'
predict(
  object,
  newdata = NULL,
  SP = NULL,
  Y = NULL,
  type = c("link", "raw"),
  dropout = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.sjSDM_+3A_object">object</code></td>
<td>
<p>a model fitted by <code><a href="#topic+sjSDM">sjSDM</a></code></p>
</td></tr>
<tr><td><code id="predict.sjSDM_+3A_newdata">newdata</code></td>
<td>
<p>newdata for predictions</p>
</td></tr>
<tr><td><code id="predict.sjSDM_+3A_sp">SP</code></td>
<td>
<p>spatial predictors (e.g. X and Y coordinates)</p>
</td></tr>
<tr><td><code id="predict.sjSDM_+3A_y">Y</code></td>
<td>
<p>Known occurrences of species, must be a matrix of the original size, species to be predicted must consist of NAs</p>
</td></tr>
<tr><td><code id="predict.sjSDM_+3A_type">type</code></td>
<td>
<p>raw or link</p>
</td></tr>
<tr><td><code id="predict.sjSDM_+3A_dropout">dropout</code></td>
<td>
<p>use dropout for predictions or not, only supported for DNNs</p>
</td></tr>
<tr><td><code id="predict.sjSDM_+3A_...">...</code></td>
<td>
<p>optional arguments for compatibility with the generic function, no function implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of predictions (sites by species)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## Conditional predictions based on focal species
com = simulate_SDM(sites = 200L)
## first 100 observations are the training data
model = sjSDM(com$response[1:100, ], com$env_weights[1:100,])
## Assume that for the other 100 observations, only the first species is missing 
## and we want to use the other 4 species to improve the predictions:
Y_focal = com$response[101:200, ]
Y_focal[,1] = NA # set to NA because occurrences are unknown

pred_conditional = predict(model, newdata = com$env_weights[101:200,], Y = Y_focal)
pred_unconditional = predict(model, newdata = com$env_weights[101:200,])[,1]

## Compare performance:
Metrics::auc(com$response[101:200, 1], pred_conditional)
Metrics::auc(com$response[101:200, 1], pred_unconditional)

## Conditional predictions are better, however, it only works if occurrences of
## other species for new sites are known!


## End(Not run)
</code></pre>

<hr>
<h2 id='print.bioticStruct'>Print a bioticStruct object</h2><span id='topic+print.bioticStruct'></span>

<h3>Description</h3>

<p>Print a bioticStruct object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bioticStruct'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.bioticStruct_+3A_x">x</code></td>
<td>
<p>object created by <code><a href="#topic+bioticStruct">bioticStruct</a></code></p>
</td></tr>
<tr><td><code id="print.bioticStruct_+3A_...">...</code></td>
<td>
<p>optional arguments for compatibility with the generic function, no function implemented</p>
</td></tr>
</table>

<hr>
<h2 id='print.DNN'>Print a DNN object</h2><span id='topic+print.DNN'></span>

<h3>Description</h3>

<p>Print a DNN object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DNN'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.DNN_+3A_x">x</code></td>
<td>
<p>object created by <code><a href="#topic+DNN">DNN</a></code></p>
</td></tr>
<tr><td><code id="print.DNN_+3A_...">...</code></td>
<td>
<p>optional arguments for compatibility with the generic function, no function implemented</p>
</td></tr>
</table>

<hr>
<h2 id='print.linear'>Print a linear object</h2><span id='topic+print.linear'></span>

<h3>Description</h3>

<p>Print a linear object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linear'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.linear_+3A_x">x</code></td>
<td>
<p>object created by <code><a href="#topic+linear">linear</a></code></p>
</td></tr>
<tr><td><code id="print.linear_+3A_...">...</code></td>
<td>
<p>optional arguments for compatibility with the generic function, no function implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisible formula object
</p>

<hr>
<h2 id='print.sjSDM'>Print a fitted sjSDM model</h2><span id='topic+print.sjSDM'></span>

<h3>Description</h3>

<p>Print a fitted sjSDM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sjSDM_+3A_x">x</code></td>
<td>
<p>a model fitted by <code><a href="#topic+sjSDM">sjSDM</a></code></p>
</td></tr>
<tr><td><code id="print.sjSDM_+3A_...">...</code></td>
<td>
<p>optional arguments for compatibility with the generic function, no function implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value
</p>

<hr>
<h2 id='print.sjSDM_cv'>Print a fitted sjSDM_cv model</h2><span id='topic+print.sjSDM_cv'></span>

<h3>Description</h3>

<p>Print a fitted sjSDM_cv model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDM_cv'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sjSDM_cv_+3A_x">x</code></td>
<td>
<p>a model fitted by <code><a href="#topic+sjSDM_cv">sjSDM_cv</a></code></p>
</td></tr>
<tr><td><code id="print.sjSDM_cv_+3A_...">...</code></td>
<td>
<p>optional arguments for compatibility with the generic function, no function implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Above data frame is silently returned.
</p>

<hr>
<h2 id='print.sjSDManova'>Print sjSDM anova object</h2><span id='topic+print.sjSDManova'></span>

<h3>Description</h3>

<p>This is a wrapper for <code><a href="#topic+summary.sjSDManova">summary.sjSDManova</a></code>, maintained for backwards compatibility - prefer to use summary() instead
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDManova'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sjSDManova_+3A_x">x</code></td>
<td>
<p>an object of type sjSDManova created by <code><a href="#topic+anova.sjSDM">anova.sjSDM</a></code></p>
</td></tr>
<tr><td><code id="print.sjSDManova_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="#topic+summary.sjSDManova">summary.sjSDManova</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sjSDM)
# simulate community:
community = simulate_SDM(env = 3L, species = 10L, sites = 100L)

Occ &lt;- community$response
Env &lt;- community$env_weights
SP &lt;- data.frame(matrix(rnorm(200, 0, 0.3), 100, 2)) # spatial coordinates


# fit model:
model &lt;- sjSDM(Y = Occ, 
               env = linear(data = Env, formula = ~X1+X2+X3), 
               spatial = linear(data = SP, formula = ~0+X1*X2), 
               family=binomial("probit"),
               verbose = FALSE,
               iter = 20) # increase iter for real analysis

# Calculate ANOVA for env, space, associations, for details see ?anova.sjSDM
an = anova(model, samples = 10, verbose = FALSE) # increase iter for real analysis

# Show anova fractions
plot(an)

# ANOVA tables with different way to handle fractions
summary(an)
summary(an, fractions = "discard")
summary(an, fractions = "proportional")
summary(an, fractions = "equal")

# Internal structure
int = internalStructure(an, fractions = "proportional")

print(int)

plot(int) # default is negative values will be set to 0
plot(int, negatives = "scale") # global rescaling of all values to range 0-1
plot(int, negatives = "raw") # negative values will be discarded

plotAssemblyEffects(int)
plotAssemblyEffects(int, negatives = "floor")
plotAssemblyEffects(int, response = "sites", pred = as.factor(c(rep(1, 50), rep(2, 50))))
plotAssemblyEffects(int, response = "species", pred = runif(10))
plotAssemblyEffects(int, response = "species", pred = as.factor(c(rep(1, 5), rep(2, 5))))

## End(Not run)
</code></pre>

<hr>
<h2 id='print.sjSDMimportance'>Print importance</h2><span id='topic+print.sjSDMimportance'></span>

<h3>Description</h3>

<p>Print importance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDMimportance'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sjSDMimportance_+3A_x">x</code></td>
<td>
<p>an object of <code><a href="#topic+importance">importance</a></code></p>
</td></tr>
<tr><td><code id="print.sjSDMimportance_+3A_...">...</code></td>
<td>
<p>optional arguments for compatibility with the generic function, no function implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix above is silently returned
</p>

<hr>
<h2 id='print.sjSDMinternalStructure'>Print internal structure object</h2><span id='topic+print.sjSDMinternalStructure'></span>

<h3>Description</h3>

<p>Print internal structure object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDMinternalStructure'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.sjSDMinternalStructure_+3A_x">x</code></td>
<td>
<p>object of class sjSDMinternalStructure</p>
</td></tr>
<tr><td><code id="print.sjSDMinternalStructure_+3A_...">...</code></td>
<td>
<p>no function</p>
</td></tr>
</table>

<hr>
<h2 id='residuals.sjSDM'>Residuals for a sjSDM model</h2><span id='topic+residuals.sjSDM'></span>

<h3>Description</h3>

<p>Returns residuals for a fitted sjSDM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDM'
residuals(object, type = "raw", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.sjSDM_+3A_object">object</code></td>
<td>
<p>a model fitted by <code><a href="#topic+sjSDM">sjSDM</a></code></p>
</td></tr>
<tr><td><code id="residuals.sjSDM_+3A_type">type</code></td>
<td>
<p>residual type. Currently only supports raw</p>
</td></tr>
<tr><td><code id="residuals.sjSDM_+3A_...">...</code></td>
<td>
<p>further arguments, not supported yet.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>residuals in the format of the provided community matrix
</p>

<hr>
<h2 id='RMSprop'>RMSprop</h2><span id='topic+RMSprop'></span>

<h3>Description</h3>

<p>RMSprop optimizer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RMSprop(
  alpha = 0.99,
  eps = 1e-08,
  weight_decay = 1e-04,
  momentum = 0.1,
  centered = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RMSprop_+3A_alpha">alpha</code></td>
<td>
<p>decay factor</p>
</td></tr>
<tr><td><code id="RMSprop_+3A_eps">eps</code></td>
<td>
<p>fuzz factor</p>
</td></tr>
<tr><td><code id="RMSprop_+3A_weight_decay">weight_decay</code></td>
<td>
<p>l2 penalty on weights</p>
</td></tr>
<tr><td><code id="RMSprop_+3A_momentum">momentum</code></td>
<td>
<p>momentum</p>
</td></tr>
<tr><td><code id="RMSprop_+3A_centered">centered</code></td>
<td>
<p>centered or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Anonymous function that returns optimizer when called.
</p>

<hr>
<h2 id='Rsquared'>R-squared</h2><span id='topic+Rsquared'></span>

<h3>Description</h3>

<p>calculate R-squared following McFadden or Nagelkerke
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Rsquared(model, method = c("McFadden", "Nagelkerke"), verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Rsquared_+3A_model">model</code></td>
<td>
<p>model</p>
</td></tr>
<tr><td><code id="Rsquared_+3A_method">method</code></td>
<td>
<p>McFadden or Nagelkerke</p>
</td></tr>
<tr><td><code id="Rsquared_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>, indicating whether progress should be printed or not</p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>Calculate R-squared following Nagelkerke or McFadden:
</p>

<ul>
<li><p> Nagelkerke: \(R^2 = 1 - \exp(2/N \cdot (log\mathcal{L}_0 - log\mathcal{L}_1 ) )\)
</p>
</li>
<li><p> McFadden: \(R^2 = 1 - log\mathcal{L}_1 / log\mathcal{L}_0  \)
</p>
</li></ul>



<h3>Value</h3>

<p>R-squared as numeric value
</p>


<h3>Author(s)</h3>

<p>Maximilian Pichler
</p>

<hr>
<h2 id='setWeights'>Set weights</h2><span id='topic+setWeights'></span><span id='topic+setWeights.sjSDM'></span>

<h3>Description</h3>

<p>set layer weights and sigma in <code><a href="#topic+sjSDM">sjSDM</a></code> with <code><a href="#topic+DNN">DNN</a></code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setWeights(object, weights)

## S3 method for class 'sjSDM'
setWeights(object, weights = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setWeights_+3A_object">object</code></td>
<td>
<p>object of class  <code><a href="#topic+sjSDM">sjSDM</a></code> with <code><a href="#topic+DNN">DNN</a></code> object</p>
</td></tr>
<tr><td><code id="setWeights_+3A_weights">weights</code></td>
<td>
<p>list of layer weights:  <code>list(env=list(matrix(...)), spatial=list(matrix(...)), sigma=matrix(...))</code>, see <code><a href="#topic+getWeights">getWeights</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, weights are changed in place.
</p>

<hr>
<h2 id='SGD'>SGD</h2><span id='topic+SGD'></span>

<h3>Description</h3>

<p>stochastic gradient descent optimizer
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SGD(momentum = 0.5, dampening = 0, weight_decay = 0, nesterov = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SGD_+3A_momentum">momentum</code></td>
<td>
<p>strength of momentum</p>
</td></tr>
<tr><td><code id="SGD_+3A_dampening">dampening</code></td>
<td>
<p>decay</p>
</td></tr>
<tr><td><code id="SGD_+3A_weight_decay">weight_decay</code></td>
<td>
<p>l2 penalty on weights</p>
</td></tr>
<tr><td><code id="SGD_+3A_nesterov">nesterov</code></td>
<td>
<p>Nesterov momentum or not</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Anonymous function that returns optimizer when called.
</p>

<hr>
<h2 id='simulate_SDM'>Simulate joint Species Distribution Models</h2><span id='topic+simulate_SDM'></span>

<h3>Description</h3>

<p>Simulate species distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_SDM(
  env = 5L,
  sites = 100L,
  species = 5L,
  correlation = TRUE,
  weight_range = c(-1, 1),
  link = "probit",
  response = "pa",
  sparse = NULL,
  tolerance = 0.05,
  iter = 20L,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate_SDM_+3A_env">env</code></td>
<td>
<p>number of environment variables</p>
</td></tr>
<tr><td><code id="simulate_SDM_+3A_sites">sites</code></td>
<td>
<p>number of sites</p>
</td></tr>
<tr><td><code id="simulate_SDM_+3A_species">species</code></td>
<td>
<p>number of species</p>
</td></tr>
<tr><td><code id="simulate_SDM_+3A_correlation">correlation</code></td>
<td>
<p>correlated species TRUE or FALSE, can be also a function or a matrix</p>
</td></tr>
<tr><td><code id="simulate_SDM_+3A_weight_range">weight_range</code></td>
<td>
<p>sample true weights from uniform range, default -1,1</p>
</td></tr>
<tr><td><code id="simulate_SDM_+3A_link">link</code></td>
<td>
<p>probit, logit or identical</p>
</td></tr>
<tr><td><code id="simulate_SDM_+3A_response">response</code></td>
<td>
<p>pa (presence-absence) or count</p>
</td></tr>
<tr><td><code id="simulate_SDM_+3A_sparse">sparse</code></td>
<td>
<p>sparse rate</p>
</td></tr>
<tr><td><code id="simulate_SDM_+3A_tolerance">tolerance</code></td>
<td>
<p>tolerance for sparsity check</p>
</td></tr>
<tr><td><code id="simulate_SDM_+3A_iter">iter</code></td>
<td>
<p>tries until sparse rate is achieved</p>
</td></tr>
<tr><td><code id="simulate_SDM_+3A_seed">seed</code></td>
<td>
<p>random seed. Default = 42</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Probit is not possible for abundance response (response = 'count')
</p>


<h3>Value</h3>

<p>List of simulation results:
</p>
<table role = "presentation">
<tr><td><code>env</code></td>
<td>
<p>Number of environmental covariates</p>
</td></tr>
<tr><td><code>species</code></td>
<td>
<p>Number of species</p>
</td></tr>
<tr><td><code>sites</code></td>
<td>
<p>Number of sites</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>Which link</p>
</td></tr>
<tr><td><code>response_type</code></td>
<td>
<p>Which response type</p>
</td></tr>
<tr><td><code>response</code></td>
<td>
<p>Species occurrence matrix</p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>
<p>Species covariance matrix</p>
</td></tr>
<tr><td><code>species_weights</code></td>
<td>
<p>Species-environment coefficients</p>
</td></tr>
<tr><td><code>env_weights</code></td>
<td>
<p>Environmental covariates</p>
</td></tr>
<tr><td><code>corr_acc</code></td>
<td>
<p>Method to calculate sign accurracy</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Maximilian Pichler
</p>

<hr>
<h2 id='simulate.sjSDM'>Generates simulations from sjSDM model</h2><span id='topic+simulate.sjSDM'></span>

<h3>Description</h3>

<p>Simulate nsim responses from the fitted model following a multivariate probit model.
So currently only supported for <code>family = stats::binomial("probit")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDM'
simulate(object, nsim = 1, seed = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.sjSDM_+3A_object">object</code></td>
<td>
<p>a model fitted by <code><a href="#topic+sjSDM">sjSDM</a></code></p>
</td></tr>
<tr><td><code id="simulate.sjSDM_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="simulate.sjSDM_+3A_seed">seed</code></td>
<td>
<p>seed for random number generator</p>
</td></tr>
<tr><td><code id="simulate.sjSDM_+3A_...">...</code></td>
<td>
<p>optional arguments for compatibility with the generic function, no functionality implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of simulated species occurrences of dimension order (nsim, sites, species)
</p>

<hr>
<h2 id='sjSDM'>Fitting scalable joint Species Distribution Models (sjSDM)</h2><span id='topic+sjSDM'></span><span id='topic+sjSDM.tune'></span>

<h3>Description</h3>

<p><code>sjSDM</code> is used to fit joint Species Distribution models (jSDMs) using the central processing unit (CPU) or the graphical processing unit (GPU).
The default is a multivariate probit model based on a Monte-Carlo approximation of the joint likelihood.
<code>sjSDM</code> can be used to fit linear but also deep neural networks and supports the well known formula syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sjSDM(
  Y = NULL,
  env = NULL,
  biotic = bioticStruct(),
  spatial = NULL,
  family = stats::binomial("probit"),
  iter = 100L,
  step_size = NULL,
  learning_rate = 0.01,
  se = FALSE,
  sampling = 100L,
  parallel = 0L,
  control = sjSDMControl(),
  device = "cpu",
  dtype = "float32",
  seed = 758341678,
  verbose = TRUE
)

sjSDM.tune(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sjSDM_+3A_y">Y</code></td>
<td>
<p>matrix of species occurrences/responses in range</p>
</td></tr>
<tr><td><code id="sjSDM_+3A_env">env</code></td>
<td>
<p>matrix of environmental predictors, object of type <code><a href="#topic+linear">linear</a></code> or <code><a href="#topic+DNN">DNN</a></code></p>
</td></tr>
<tr><td><code id="sjSDM_+3A_biotic">biotic</code></td>
<td>
<p>defines biotic (species-species associations) structure, object of type <code><a href="#topic+bioticStruct">bioticStruct</a></code></p>
</td></tr>
<tr><td><code id="sjSDM_+3A_spatial">spatial</code></td>
<td>
<p>defines spatial structure, object of type <code><a href="#topic+linear">linear</a></code> or <code><a href="#topic+DNN">DNN</a></code></p>
</td></tr>
<tr><td><code id="sjSDM_+3A_family">family</code></td>
<td>
<p>error distribution with link function, see details for supported distributions</p>
</td></tr>
<tr><td><code id="sjSDM_+3A_iter">iter</code></td>
<td>
<p>number of fitting iterations</p>
</td></tr>
<tr><td><code id="sjSDM_+3A_step_size">step_size</code></td>
<td>
<p>batch size for stochastic gradient descent, if <code>NULL</code> then step_size is set to: <code>step_size = 0.1*nrow(X)</code></p>
</td></tr>
<tr><td><code id="sjSDM_+3A_learning_rate">learning_rate</code></td>
<td>
<p>learning rate for Adamax optimizer</p>
</td></tr>
<tr><td><code id="sjSDM_+3A_se">se</code></td>
<td>
<p>calculate standard errors for environmental coefficients</p>
</td></tr>
<tr><td><code id="sjSDM_+3A_sampling">sampling</code></td>
<td>
<p>number of sampling steps for Monte Carlo integration</p>
</td></tr>
<tr><td><code id="sjSDM_+3A_parallel">parallel</code></td>
<td>
<p>number of cpu cores for the data loader, only necessary for large datasets</p>
</td></tr>
<tr><td><code id="sjSDM_+3A_control">control</code></td>
<td>
<p>control parameters for optimizer, see <code><a href="#topic+sjSDMControl">sjSDMControl</a></code></p>
</td></tr>
<tr><td><code id="sjSDM_+3A_device">device</code></td>
<td>
<p>which device to be used, &quot;cpu&quot; or &quot;gpu&quot;</p>
</td></tr>
<tr><td><code id="sjSDM_+3A_dtype">dtype</code></td>
<td>
<p>which data type, most GPUs support only 32 bit floats.</p>
</td></tr>
<tr><td><code id="sjSDM_+3A_seed">seed</code></td>
<td>
<p>seed for random operations</p>
</td></tr>
<tr><td><code id="sjSDM_+3A_verbose">verbose</code></td>
<td>
<p><code>TRUE</code> or <code>FALSE</code>, indicating whether progress should be printed or not</p>
</td></tr>
<tr><td><code id="sjSDM_+3A_object">object</code></td>
<td>
<p>object of type <code><a href="#topic+sjSDM_cv">sjSDM_cv</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<script id="MathJax-script" async src="../../mathjaxr/doc/mathjax/es5/tex-chtml-full.js"></script>
<p>The function fits per default a multivariate probit model via Monte-Carlo integration (see Chen et al., 2018) of the joint likelihood for all species.
</p>


<h4>Model description</h4>

<p>The most common jSDM structure describes the site (\(i = 1, ..., I\))  by species (\(j = 1, ..., J\)) matrix \(Y_{ij}\) as a function of
environmental covariates \(X_{in}\)(\(n=1,...,N\) covariates), and the species-species covariance matrix
\(\Sigma\) accounts for correlations in \(e_{ij}\):
</p>
\[g(Z_{ij}) = \beta_{j0} + \Sigma^{N}_{n=1}X_{in}\beta_{nj} + e_{ij}\]
<p>with \(g(.)\) as link function. For the multivariate probit model, the link function is:
</p>
\[Y_{ij}=1(Z_{ij} > 0)\]
<p>The probability to observe the occurrence vector \(\bf{Y_i}\) is:
</p>
\[Pr(\bf{Y}_i|\bf{X}_i\beta, \Sigma) = \int_{A_{iJ}}...\int_{A_{i1}} \phi_J(\bf{Y}_i^{\ast};\bf{X}_i\beta, \Sigma)  dY_{i1}^{\ast}... dY_{iJ}^{\ast}\]
<p>in the interval \(A_{ij}\) with \((-\inf, 0]\) if \(Y_{ij}=0\) and \( [0, +\inf) \)  if \(Y_{ij}=1\).
</p>
<p>and \(\phi\) being the density function of the multivariate normal distribution.
</p>
<p>The probability of \(\bf{Y_i}\) requires to integrate over \(\bf{Y_i^{\ast}}\) which has no closed analytical expression for more than two species
which makes the evaluation of the likelihood computationally costly and needs a numerical approximation.
The previous equation can be expressed more generally as:
</p>
\[ \mathcal{L}(\beta, \Sigma; \bf{Y}_i, \bf{X}_i) = \int_{\Omega} \prod_{j=1}^J Pr(Y_{ij}|\bf{X}_i\beta+\zeta) Pr(\zeta|\Sigma) d\zeta  \]
<p><code>sjSDM</code> approximates this integral by \(M\) Monte-Carlo samples from the multivariate normal species-species covariance.
After integrating out the covariance term, the remaining part of the likelihood can be calculated as in an univariate case and the average
of the \(M\) samples are used to get an approximation of the integral:
</p>
\[ \mathcal{L}(\beta, \Sigma; \bf{Y}_i, \bf{X}_i) \approx \frac{1}{M} \Sigma_{m=1}^M \prod_{j=1}^J Pr(Y_{ij}|\bf{X}_i\beta+\zeta_m)\]
<p>with \( \zeta_m \sim MVN(0, \Sigma)\).
</p>
<p><code>sjSDM</code> uses 'PyTorch' to run optionally the model on the graphical processing unit (GPU). Python dependencies needs to be
installed before being able to use the <code>sjSDM</code> function. We provide a function which installs automatically python and the python dependencies.
See <code><a href="#topic+install_sjSDM">install_sjSDM</a></code>, <code>vignette("Dependencies", package = "sjSDM")</code>
</p>
<p>See Pichler and Hartig, 2020 for benchmark results.
</p>



<h4>Supported distributions</h4>

<p>Currently supported distributions and link functions, which are :
</p>

<ul>
<li> <p><code><a href="stats.html#topic+binomial">binomial</a></code>: <code>"probit"</code> or <code>"logit"</code>
</p>
</li>
<li> <p><code><a href="stats.html#topic+poisson">poisson</a></code>: <code>"log"</code>
</p>
</li>
<li> <p><code>"nbinom"</code>: <code>"log"</code>
</p>
</li>
<li> <p><code><a href="stats.html#topic+gaussian">gaussian</a></code>: <code>"identity"</code>
</p>
</li></ul>




<h4>Space</h4>

<p>We can extend the model to account for spatial auto-correlation between the sites by:
</p>
\[g(Z_{ij}) = \beta_{j0} + \Sigma^{N}_{n=1}X_{in}\beta_{nj} + \Sigma^{M}_{m=1}S_{im}\alpha_{mj} + e_{ij}\]
<p>There are two ways to generate spatial predictors \(S\):
</p>

<ul>
<li><p> trend surface model - using spatial coordinates in a polynomial:
</p>
<p><code>linear(data=Coords, ~0+poly(X, Y, degree = 2))</code>
</p>
</li>
<li><p> eigenvector spatial filtering - using spatial eigenvectors.
Spatial eigenvectors can be generated by the <code><a href="#topic+generateSpatialEV">generateSpatialEV</a></code> function:
</p>
<p><code>SPV = generateSpatialEV(Coords)</code>
</p>
<p>Then we use, for example, the first 20 spatial eigenvectors:
</p>
<p><code>linear(data=SPV[ ,1:20], ~0+.)</code>
</p>
</li></ul>

<p>It is important to set the intercept to 0 in the spatial term (e.g. via <code>~0+.</code>) because the intercept is already set in the environmental object.
</p>



<h4>Installation</h4>

<p><code><a href="#topic+install_sjSDM">install_sjSDM</a></code> should be theoretically able to install conda and 'PyTorch' automatically. If <code><a href="#topic+sjSDM">sjSDM</a></code> still does not work after reloading RStudio, you can try to solve this on your following our trouble shooting guide <code><a href="#topic+installation_help">installation_help</a></code>.
If the problem remains, please create an issue on <a href="https://github.com/TheoreticalEcology/s-jSDM/issues">issue tracker</a> with a copy of the <code><a href="#topic+install_diagnostic">install_diagnostic</a></code> output as a quote.
</p>



<h3>Value</h3>

<p>An S3 class of type 'sjSDM' including the following components:
</p>
<table role = "presentation">
<tr><td><code>cl</code></td>
<td>
<p>Model call</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>Formula object for environmental covariates.</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>Names of environmental covariates.</p>
</td></tr>
<tr><td><code>species</code></td>
<td>
<p>Names of species (can be <code>NULL</code> if columns of Y are not named).</p>
</td></tr>
<tr><td><code>get_model</code></td>
<td>
<p>Method which builds and returns the underlying 'python' model.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>negative log-Likelihood of the model and the regularization loss.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>The actual model.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>List of model settings, see arguments of <code><a href="#topic+sjSDM">sjSDM</a></code>.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>Response family.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>Runtime.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>List of Y, X (and spatial) model matrices.</p>
</td></tr>
<tr><td><code>sessionInfo</code></td>
<td>
<p>Output of <code><a href="utils.html#topic+sessionInfo">sessionInfo</a></code>.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>List of model coefficients (environmental (and spatial)).</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>Lower triangular weight matrix for the covariance matrix.</p>
</td></tr>
<tr><td><code>history</code></td>
<td>
<p>History of iteration losses.</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>Matrix of standard errors, if <code>se = FALSE</code> the field 'se' is <code>NULL</code>.</p>
</td></tr>
</table>
<p>Implemented S3 methods include <code><a href="#topic+summary.sjSDM">summary.sjSDM</a></code>, <code><a href="#topic+plot.sjSDM">plot.sjSDM</a></code>, <code><a href="#topic+print.sjSDM">print.sjSDM</a></code>, <code><a href="#topic+predict.sjSDM">predict.sjSDM</a></code>, and <code><a href="#topic+coef.sjSDM">coef.sjSDM</a></code>. For other methods, see section 'See Also'.
</p>
<p><code><a href="#topic+sjSDM.tune">sjSDM.tune</a></code> returns an S3 object of class 'sjSDM', see above for information about values.
</p>


<h3>Author(s)</h3>

<p>Maximilian Pichler
</p>


<h3>References</h3>

<p>Chen, D., Xue, Y., &amp; Gomes, C. P. (2018). End-to-end learning for the deep multivariate probit model. arXiv preprint arXiv:1803.08591.
</p>
<p>Pichler, M., &amp; Hartig, F. (2021). A new joint species distribution model for faster and more accurate inference of species associations from big community data. Methods in Ecology and Evolution, 12(11), 2159-2173.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getCor">getCor</a></code>,  <code><a href="#topic+getCov">getCov</a></code>, <code><a href="#topic+update.sjSDM">update.sjSDM</a></code>, <code><a href="#topic+sjSDM_cv">sjSDM_cv</a></code>, <code><a href="#topic+DNN">DNN</a></code>, <code><a href="#topic+plot.sjSDM">plot.sjSDM</a></code>, <code><a href="#topic+print.sjSDM">print.sjSDM</a></code>, <code><a href="#topic+predict.sjSDM">predict.sjSDM</a></code>, <code><a href="#topic+coef.sjSDM">coef.sjSDM</a></code>, <code><a href="#topic+summary.sjSDM">summary.sjSDM</a></code>, <code><a href="#topic+simulate.sjSDM">simulate.sjSDM</a></code>, <code><a href="#topic+getSe">getSe</a></code>, <code><a href="#topic+anova.sjSDM">anova.sjSDM</a></code>, <code><a href="#topic+importance">importance</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  
# Basic workflow:
## simulate community:
com = simulate_SDM(env = 3L, species = 7L, sites = 100L)

## fit model:
model = sjSDM(Y = com$response,env = com$env_weights, iter = 50L,
              verbose = FALSE) 
# increase iter for your own data 

# Default distribution is binomial("probit"). Alternatively, you can use
# binomial(logit), poisson("log"), "nbinom" (with log, still somewhat 
# experimental) and gaussian("identity")

coef(model)
summary(model)
getCov(model)

## plot results
species=c("sp1","sp2","sp3","sp4","sp5","sp6","sp7")
group=c("mammal","bird","fish","fish","mammal","amphibian","amphibian")
group = data.frame(species=species,group=group)
plot(model,group=group)

## calculate post-hoc p-values:
p = getSe(model)
summary(p)

## or turn on the option in the sjSDM function:
model = sjSDM(Y = com$response, env = com$env_weights, se = TRUE, 
              family = binomial("probit"), 
              iter = 2L,
              verbose = FALSE)
summary(model)

## fit model with interactions:
model = sjSDM(Y = com$response,
              env = linear(data = com$env_weights, formula = ~X1:X2 + X3), 
              se = TRUE,
              iter = 2L,
              verbose = FALSE) # increase iter for your own data 
summary(model)

## without intercept:
model = update(model, env_formula = ~0+X1:X2 + X3,
               verbose = FALSE)

summary(model)

## predict with model:
preds = predict(model, newdata = com$env_weights)

## calculate R-squared:
R2 = Rsquared(model)
print(R2)

# With spatial terms:
## linear spatial model
XY = matrix(rnorm(200), 100, 2)
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = linear(XY, ~0+X1:X2),
              iter = 50L,
              verbose = FALSE) # increase iter for your own data 
summary(model)
predict(model, newdata = com$env_weights, SP = XY)
R2 = Rsquared(model)
print(R2)

## Using spatial eigenvectors as predictors to account 
## for spatial autocorrelation is a common approach:
SPV = generateSpatialEV(XY)
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = linear(SPV, ~0+., lambda = 0.1),
              iter = 50L,
              verbose = FALSE) # increase iter for your own data 
summary(model)
predict(model, newdata = com$env_weights, SP = SPV)

## Visualize internal meta-community structure
an = anova(model,
           verbose = FALSE)

internal = internalStructure(an)
plot(internal)

## Visualize community assemlby effects 

plotAssemblyEffects(internal)

### see ?anova.sjSDM for mroe details


## non-linear(deep neural network) model
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = DNN(SPV,hidden = c(5L, 5L), ~0+.),
              iter = 2L,# increase iter for your own data 
              verbose = FALSE) 
summary(model)
predict(model, newdata = com$env_weights, SP = SPV)


# Regularization
## lambda is the regularization strength
## alpha weights the lasso or ridge penalty:
## - alpha = 0 --&gt; pure lasso
## - alpha = 1.0 --&gt; pure ridge
model = sjSDM(Y = com$response, 
              # mix of lasso and ridge
              env = linear(com$env_weights, lambda = 0.01, alpha = 0.5), 
              # we can do the same for the species-species associations
              biotic = bioticStruct(lambda = 0.01, alpha = 0.5),
              iter = 2L,# increase iter for your own data 
              verbose = FALSE) 
summary(model)
coef(model)
getCov(model)



# Anova 
com = simulate_SDM(env = 3L, species = 15L, sites = 200L, correlation = TRUE)

XY = matrix(rnorm(400), 200, 2)
SPV = generateSpatialEV(XY)
model = sjSDM(Y = com$response, env = linear(com$env_weights), 
              spatial = linear(SPV, ~0+.), 
              verbose = FALSE,
              iter = 50L) # increase iter for your own data 
result = anova(model, verbose = FALSE)
print(result)
plot(result)

## visualize internal meta-community structure
internal = internalStructure(an)
plot(internal)



# Deep neural networks
## we can fit also a deep neural network instead of a linear model:
model = sjSDM(Y = com$response,
              env = DNN(com$env_weights, hidden = c(10L, 10L, 10L)),
              verbose = FALSE,
              iter = 2L) # increase iter for your own data 
summary(model)
getCov(model)
pred = predict(model, newdata = com$env_weights)

## extract weights
weights = getWeights(model)

## we can also assign weights:
setWeights(model, weights)

## with regularization:
model = sjSDM(Y = com$response, 
              # mix of lasso and ridge
              env = DNN(com$env_weights, lambda = 0.01, alpha = 0.5), 
              # we can do the same for the species-species associations
              biotic = bioticStruct(lambda = 0.01, alpha = 0.5),
              verbose = FALSE,
              iter = 2L) # increase iter for your own data 
getCov(model)
getWeights(model)

## End(Not run)
</code></pre>

<hr>
<h2 id='sjSDM_cv'>Cross validation of elastic net tuning</h2><span id='topic+sjSDM_cv'></span>

<h3>Description</h3>

<p>Cross validation of elastic net tuning
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sjSDM_cv(
  Y,
  env = NULL,
  biotic = bioticStruct(),
  spatial = NULL,
  tune = c("random", "grid"),
  CV = 5L,
  tune_steps = 20L,
  alpha_cov = seq(0, 1, 0.1),
  alpha_coef = seq(0, 1, 0.1),
  alpha_spatial = seq(0, 1, 0.1),
  lambda_cov = 2^seq(-10, -1, length.out = 20),
  lambda_coef = 2^seq(-10, -0.5, length.out = 20),
  lambda_spatial = 2^seq(-10, -0.5, length.out = 20),
  device = "cpu",
  n_cores = NULL,
  n_gpu = NULL,
  sampling = 5000L,
  blocks = 1L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sjSDM_cv_+3A_y">Y</code></td>
<td>
<p>species occurrence matrix</p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_env">env</code></td>
<td>
<p>matrix of environmental predictors or object of type <code><a href="#topic+linear">linear</a></code>, or <code><a href="#topic+DNN">DNN</a></code></p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_biotic">biotic</code></td>
<td>
<p>defines biotic (species-species associations) structure, object of type <code><a href="#topic+bioticStruct">bioticStruct</a></code>. Alpha and lambda have no influence</p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_spatial">spatial</code></td>
<td>
<p>defines spatial structure, object of type <code><a href="#topic+linear">linear</a></code>, or <code><a href="#topic+DNN">DNN</a></code></p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_tune">tune</code></td>
<td>
<p>tuning strategy, random or grid search</p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_cv">CV</code></td>
<td>
<p>n-fold cross validation or list of test indices</p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_tune_steps">tune_steps</code></td>
<td>
<p>number of tuning steps</p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_alpha_cov">alpha_cov</code></td>
<td>
<p>weighting of l1 and l2 on covariances: <code class="reqn">(1 - \alpha) * |cov| + \alpha ||cov||^2</code></p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_alpha_coef">alpha_coef</code></td>
<td>
<p>weighting of l1 and l2 on coefficients: <code class="reqn">(1 - \alpha) * |coef| + \alpha ||coef||^2</code></p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_alpha_spatial">alpha_spatial</code></td>
<td>
<p>weighting of l1 and l2 on spatial coefficients: <code class="reqn">(1 - \alpha) * |coef_sp| + \alpha ||coef_sp||^2</code></p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_lambda_cov">lambda_cov</code></td>
<td>
<p>overall regularization strength on covariances</p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_lambda_coef">lambda_coef</code></td>
<td>
<p>overall regularization strength on coefficients</p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_lambda_spatial">lambda_spatial</code></td>
<td>
<p>overall regularization strength on spatial coefficients</p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_device">device</code></td>
<td>
<p>device, default cpu</p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_n_cores">n_cores</code></td>
<td>
<p>number of cores for parallelization</p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_n_gpu">n_gpu</code></td>
<td>
<p>number of GPUs</p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_sampling">sampling</code></td>
<td>
<p>number of sampling steps for Monte Carlo integration</p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_blocks">blocks</code></td>
<td>
<p>blocks of parallel tuning steps</p>
</td></tr>
<tr><td><code id="sjSDM_cv_+3A_...">...</code></td>
<td>
<p>arguments passed to sjSDM, see <code><a href="#topic+sjSDM">sjSDM</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 class of type 'sjSDM_cv' including the following components:
</p>
<table role = "presentation">
<tr><td><code>tune_results</code></td>
<td>
<p>Data frame with tuning results.</p>
</td></tr>
<tr><td><code>short_summary</code></td>
<td>
<p>Data frame with averaged tuning results.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>Data frame with summarized averaged results.</p>
</td></tr>
<tr><td><code>settings</code></td>
<td>
<p>List of tuning settings, see the arguments in <code><a href="#topic+DNN">DNN</a></code>.</p>
</td></tr>
<tr><td><code>data</code></td>
<td>
<p>List of Y, env (and spatial) objects.</p>
</td></tr>
<tr><td><code>config</code></td>
<td>
<p>List of <code><a href="#topic+sjSDM">sjSDM</a></code> settings, see arguments of <code><a href="#topic+sjSDM">sjSDM</a></code>.</p>
</td></tr>
<tr><td><code>spatial</code></td>
<td>
<p>Logical, spatial model or not.</p>
</td></tr>
</table>
<p>Implemented S3 methods include <code><a href="#topic+sjSDM.tune">sjSDM.tune</a></code>, <code><a href="#topic+plot.sjSDM_cv">plot.sjSDM_cv</a></code>, <code><a href="#topic+print.sjSDM_cv">print.sjSDM_cv</a></code>, and <code><a href="#topic+summary.sjSDM_cv">summary.sjSDM_cv</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.sjSDM_cv">plot.sjSDM_cv</a></code>, <code><a href="#topic+print.sjSDM_cv">print.sjSDM_cv</a></code>, <code><a href="#topic+summary.sjSDM_cv">summary.sjSDM_cv</a></code>, <code><a href="#topic+sjSDM.tune">sjSDM.tune</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# simulate sparse community:
com = simulate_SDM(env = 5L, species = 25L, sites = 50L, sparse = 0.5)

# tune regularization:
tune_results = sjSDM_cv(Y = com$response,
                        env = com$env_weights, 
                        tune = "random", # random steps in tune-paramter space
                        CV = 2L, # 3-fold cross validation
                        tune_steps = 2L,
                        alpha_cov = seq(0, 1, 0.1),
                        alpha_coef = seq(0, 1, 0.1),
                        lambda_cov = seq(0, 0.1, 0.001), 
                        lambda_coef = seq(0, 0.1, 0.001),
                        n_cores = 2L,
                        sampling = 100L,
                        # small models can be also run in parallel on the GPU
                        iter = 2L # we can pass arguments to sjSDM via... 
                        )

# print overall results:
tune_results

# summary (mean values over CV for each tuning step)
summary(tune_results)

# visualize tuning and best points:
# best = plot(tune_results, perf = "logLik")

# fit model with best regularization paramter:
model = sjSDM.tune(tune_results)

summary(model)

## End(Not run)
</code></pre>

<hr>
<h2 id='sjSDMControl'>sjSDM control object</h2><span id='topic+sjSDMControl'></span>

<h3>Description</h3>

<p>sjSDM control object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sjSDMControl(
  optimizer = RMSprop(),
  scheduler = 0,
  lr_reduce_factor = 0.99,
  early_stopping_training = 0,
  mixed = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sjSDMControl_+3A_optimizer">optimizer</code></td>
<td>
<p>object of type <code><a href="#topic+RMSprop">RMSprop</a></code>, <code><a href="#topic+Adamax">Adamax</a></code>, <code><a href="#topic+SGD">SGD</a></code>, <code><a href="#topic+AccSGD">AccSGD</a></code>, <code><a href="#topic+madgrad">madgrad</a></code>, or <code><a href="#topic+AdaBound">AdaBound</a></code></p>
</td></tr>
<tr><td><code id="sjSDMControl_+3A_scheduler">scheduler</code></td>
<td>
<p>reduce lr on plateau scheduler or not (0 means no scheduler, &gt; 0 number of epochs before reducing learning rate)</p>
</td></tr>
<tr><td><code id="sjSDMControl_+3A_lr_reduce_factor">lr_reduce_factor</code></td>
<td>
<p>factor to reduce learning rate in scheduler</p>
</td></tr>
<tr><td><code id="sjSDMControl_+3A_early_stopping_training">early_stopping_training</code></td>
<td>
<p>number of epochs without decrease in training loss before invoking early stopping (0 means no early stopping).</p>
</td></tr>
<tr><td><code id="sjSDMControl_+3A_mixed">mixed</code></td>
<td>
<p>mixed (half-precision) training or not. Only recommended for GPUs &gt; 2000 series</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following fields:
</p>
<table role = "presentation">
<tr><td><code>optimizer</code></td>
<td>
<p>Function which returns an optimizer.</p>
</td></tr>
<tr><td><code>scheduler_boolean</code></td>
<td>
<p>Logical, use scheduler or not.</p>
</td></tr>
<tr><td><code>scheduler_patience</code></td>
<td>
<p>Integer, number of epochs to wait before applying plateau scheduler.</p>
</td></tr>
<tr><td><code>lr_reduce_factor</code></td>
<td>
<p>Numerical, learning rate reduce factor.</p>
</td></tr>
<tr><td><code>mixed</code></td>
<td>
<p>Logical, use mixed training or not.</p>
</td></tr>
<tr><td><code>early_stopping_training</code></td>
<td>
<p>Numerical, early stopping after n epochs.</p>
</td></tr>
</table>

<hr>
<h2 id='summary.sjSDM'>Return summary of a fitted sjSDM model</h2><span id='topic+summary.sjSDM'></span>

<h3>Description</h3>

<p>Return summary of a fitted sjSDM model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDM'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.sjSDM_+3A_object">object</code></td>
<td>
<p>a model fitted by <code><a href="#topic+sjSDM">sjSDM</a></code></p>
</td></tr>
<tr><td><code id="summary.sjSDM_+3A_...">...</code></td>
<td>
<p>optional arguments for compatibility with the generic function, no functionality implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The above matrix is silently returned.
</p>

<hr>
<h2 id='summary.sjSDM_cv'>Return summary of a fitted sjSDM_cv model</h2><span id='topic+summary.sjSDM_cv'></span>

<h3>Description</h3>

<p>Return summary of a fitted sjSDM_cv model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDM_cv'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.sjSDM_cv_+3A_object">object</code></td>
<td>
<p>a model fitted by <code><a href="#topic+sjSDM_cv">sjSDM_cv</a></code></p>
</td></tr>
<tr><td><code id="summary.sjSDM_cv_+3A_...">...</code></td>
<td>
<p>optional arguments for compatibility with the generic function, no functionality implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Above data frame is silently returned.
</p>

<hr>
<h2 id='summary.sjSDManova'>Summary table of sjSDM anova</h2><span id='topic+summary.sjSDManova'></span>

<h3>Description</h3>

<p>The function prints and returns invisible a summary table of an sjSDM ANOVA, created by <code><a href="#topic+anova.sjSDM">anova.sjSDM</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDManova'
summary(
  object,
  method = c("ANOVA"),
  fractions = c("all", "discard", "proportional", "equal"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.sjSDManova_+3A_object">object</code></td>
<td>
<p>an object of <code><a href="#topic+anova.sjSDM">anova.sjSDM</a></code></p>
</td></tr>
<tr><td><code id="summary.sjSDManova_+3A_method">method</code></td>
<td>
<p>method used to calculate the ANOVA</p>
</td></tr>
<tr><td><code id="summary.sjSDManova_+3A_fractions">fractions</code></td>
<td>
<p>how to handle the shared fractions. See details</p>
</td></tr>
<tr><td><code id="summary.sjSDManova_+3A_...">...</code></td>
<td>
<p>optional arguments for compatibility with the generic function, no function implemented</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a ANOVA table with Deviance as well as the pseudo-R2 metrics of Nagelkerke and McFadden
</p>
<p>There are four options to handle shared ANOVA fractions, which is variance that can be explained, typically as a result of collinearity, by several of the fractions:
</p>

<ol>
<li><p> &quot;all&quot; returns the shared fractions explicitly
</p>
</li>
<li><p> &quot;discard&quot; discards the fractions, as typically in a type II Anova
</p>
</li>
<li><p> &quot;proportional&quot; distributes shared fractions proportional to the unique fractions
</p>
</li>
<li><p> &quot;equal&quot; distributions shared fractions equally to the unique fractions
</p>
</li></ol>



<h3>Value</h3>

<p>The matrix that is printed out is silently returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(sjSDM)
# simulate community:
community = simulate_SDM(env = 3L, species = 10L, sites = 100L)

Occ &lt;- community$response
Env &lt;- community$env_weights
SP &lt;- data.frame(matrix(rnorm(200, 0, 0.3), 100, 2)) # spatial coordinates


# fit model:
model &lt;- sjSDM(Y = Occ, 
               env = linear(data = Env, formula = ~X1+X2+X3), 
               spatial = linear(data = SP, formula = ~0+X1*X2), 
               family=binomial("probit"),
               verbose = FALSE,
               iter = 20) # increase iter for real analysis

# Calculate ANOVA for env, space, associations, for details see ?anova.sjSDM
an = anova(model, samples = 10, verbose = FALSE) # increase iter for real analysis

# Show anova fractions
plot(an)

# ANOVA tables with different way to handle fractions
summary(an)
summary(an, fractions = "discard")
summary(an, fractions = "proportional")
summary(an, fractions = "equal")

# Internal structure
int = internalStructure(an, fractions = "proportional")

print(int)

plot(int) # default is negative values will be set to 0
plot(int, negatives = "scale") # global rescaling of all values to range 0-1
plot(int, negatives = "raw") # negative values will be discarded

plotAssemblyEffects(int)
plotAssemblyEffects(int, negatives = "floor")
plotAssemblyEffects(int, response = "sites", pred = as.factor(c(rep(1, 50), rep(2, 50))))
plotAssemblyEffects(int, response = "species", pred = runif(10))
plotAssemblyEffects(int, response = "species", pred = as.factor(c(rep(1, 5), rep(2, 5))))

## End(Not run)
</code></pre>

<hr>
<h2 id='update.sjSDM'>Update and re-fit a model call</h2><span id='topic+update.sjSDM'></span>

<h3>Description</h3>

<p>Update and re-fit a model call
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sjSDM'
update(object, env_formula = NULL, spatial_formula = NULL, biotic = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.sjSDM_+3A_object">object</code></td>
<td>
<p>of class 'sjSDM'</p>
</td></tr>
<tr><td><code id="update.sjSDM_+3A_env_formula">env_formula</code></td>
<td>
<p>new environmental formula</p>
</td></tr>
<tr><td><code id="update.sjSDM_+3A_spatial_formula">spatial_formula</code></td>
<td>
<p>new spatial formula</p>
</td></tr>
<tr><td><code id="update.sjSDM_+3A_biotic">biotic</code></td>
<td>
<p>new biotic config</p>
</td></tr>
<tr><td><code id="update.sjSDM_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An S3 class of type 'sjSDM'. See <code><a href="#topic+sjSDM">sjSDM</a></code> for more information.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
