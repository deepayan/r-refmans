<!DOCTYPE html><html><head><title>Help for package graphlayouts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {graphlayouts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#annotate_circle'><p>annotate concentric circles</p></a></li>
<li><a href='#draw_circle'><p>Draw concentric circles</p></a></li>
<li><a href='#graph_manipulate'><p>Manipulate graph</p></a></li>
<li><a href='#graphlayouts-package'><p>graphlayouts: layout algorithms for network visualizations</p></a></li>
<li><a href='#layout_as_metromap'><p>Metro Map Layout</p></a></li>
<li><a href='#layout_backbone'><p>backbone graph layout</p></a></li>
<li><a href='#layout_centrality'><p>radial centrality layout</p></a></li>
<li><a href='#layout_centrality_group'><p>radial centrality group layout</p></a></li>
<li><a href='#layout_constrained_stress'><p>constrained stress layout</p></a></li>
<li><a href='#layout_constrained_stress3D'><p>constrained stress layout in 3D</p></a></li>
<li><a href='#layout_dynamic'><p>dynamic graph layout</p></a></li>
<li><a href='#layout_fixed_coords'><p>Layout with fixed coordinates</p></a></li>
<li><a href='#layout_focus'><p>radial focus layout</p></a></li>
<li><a href='#layout_focus_group'><p>radial focus group layout</p></a></li>
<li><a href='#layout_manipulate'><p>manipulate layout</p></a></li>
<li><a href='#layout_multilevel'><p>multilevel layout</p></a></li>
<li><a href='#layout_pmds'><p>pivot MDS graph layout</p></a></li>
<li><a href='#layout_sparse_stress'><p>sparse stress graph layout</p></a></li>
<li><a href='#layout_spectral'><p>spectral graph layouts</p></a></li>
<li><a href='#layout_stress'><p>stress majorization layout</p></a></li>
<li><a href='#layout_stress3D'><p>stress majorization layout in 3D</p></a></li>
<li><a href='#layout_umap'><p>UMAP graph layouts</p></a></li>
<li><a href='#metro_berlin'><p>Subway network of Berlin</p></a></li>
<li><a href='#multilvl_ex'><p>Multilevel example Network</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Additional Layout Algorithms for Network Visualizations</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Several new layout algorithms to visualize networks are provided which are not part of 'igraph'. 
    Most are based on the concept of stress majorization by Gansner et al. (2004) &lt;<a href="https://doi.org/10.1007%2F978-3-540-31843-9_25">doi:10.1007/978-3-540-31843-9_25</a>&gt;. 
    Some more specific algorithms allow the user to emphasize hidden group structures in networks or focus on specific nodes.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/schochastics/graphlayouts">https://github.com/schochastics/graphlayouts</a>,
<a href="https://schochastics.github.io/graphlayouts/">https://schochastics.github.io/graphlayouts/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/schochastics/graphlayouts/issues">https://github.com/schochastics/graphlayouts/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>oaqc, testthat, ggraph, ggplot2, knitr, rmarkdown, uwot</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.0</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-09 18:26:00 UTC; david</td>
</tr>
<tr>
<td>Author:</td>
<td>David Schoch <a href="https://orcid.org/0000-0003-2952-4812"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Schoch &lt;david@schochastics.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-09 20:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='annotate_circle'>annotate concentric circles</h2><span id='topic+annotate_circle'></span>

<h3>Description</h3>

<p>annotate concentric circles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>annotate_circle(cent, col = "#00BFFF", format = "", pos = "top", text_size = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_circle_+3A_cent">cent</code></td>
<td>
<p>centrality scores used for layout</p>
</td></tr>
<tr><td><code id="annotate_circle_+3A_col">col</code></td>
<td>
<p>color of text</p>
</td></tr>
<tr><td><code id="annotate_circle_+3A_format">format</code></td>
<td>
<p>either empty string or 'scientific'</p>
</td></tr>
<tr><td><code id="annotate_circle_+3A_pos">pos</code></td>
<td>
<p>position of text ('top' or 'bottom')</p>
</td></tr>
<tr><td><code id="annotate_circle_+3A_text_size">text_size</code></td>
<td>
<p>font size for annotations</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function is best used with <a href="#topic+layout_with_centrality">layout_with_centrality</a> together with <a href="#topic+draw_circle">draw_circle</a>.
</p>


<h3>Value</h3>

<p>annotated concentric circles around origin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
library(ggraph)

g &lt;- sample_gnp(10, 0.4)
## Not run: 
ggraph(g, layout = "centrality", centrality = closeness(g)) +
  draw_circle(use = "cent") +
  annotate_circle(closeness(g), pos = "bottom", format = "scientific") +
  geom_edge_link() +
  geom_node_point(shape = 21, fill = "grey25", size = 5) +
  theme_graph() +
  coord_fixed()

## End(Not run)
</code></pre>

<hr>
<h2 id='draw_circle'>Draw concentric circles</h2><span id='topic+draw_circle'></span>

<h3>Description</h3>

<p>Draw concentric circles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_circle(col = "#00BFFF", use = "focus", max.circle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_circle_+3A_col">col</code></td>
<td>
<p>color of circles</p>
</td></tr>
<tr><td><code id="draw_circle_+3A_use">use</code></td>
<td>
<p>one of 'focus' or 'cent'</p>
</td></tr>
<tr><td><code id="draw_circle_+3A_max.circle">max.circle</code></td>
<td>
<p>if use = 'focus' specifies the number of circles to draw</p>
</td></tr>
</table>


<h3>Details</h3>

<p>this function is best used with a concentric layout such as <a href="#topic+layout_with_focus">layout_with_focus</a> and <a href="#topic+layout_with_centrality">layout_with_centrality</a>.
</p>


<h3>Value</h3>

<p>concentric circles around origin
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
library(ggraph)
g &lt;- sample_gnp(10,0.4)

## Not run: 
ggraph(g,layout = "centrality",centrality = degree(g))+
  draw_circle(use = "cent")+
  geom_edge_link()+
  geom_node_point(shape = 21,fill = "grey25",size = 5)+
  theme_graph()+
  coord_fixed()

## End(Not run)
</code></pre>

<hr>
<h2 id='graph_manipulate'>Manipulate graph</h2><span id='topic+graph_manipulate'></span><span id='topic+reorder_edges'></span>

<h3>Description</h3>

<p>functions to manipulate a graph
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reorder_edges(g, attr, desc = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="graph_manipulate_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="graph_manipulate_+3A_attr">attr</code></td>
<td>
<p>edge attribute name used to sort edges</p>
</td></tr>
<tr><td><code id="graph_manipulate_+3A_desc">desc</code></td>
<td>
<p>logical. sort in descending (default) or ascending order</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>reorder_edges()</code> allows to reorder edges according to an attribute so that edges are
drawn in the given order.
</p>


<h3>Value</h3>

<p>manipulated graph
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
library(ggraph)

g &lt;- sample_gnp(10, 0.5)
E(g)$attr &lt;- 1:ecount(g)
gn &lt;- reorder_edges(g,"attr")

</code></pre>

<hr>
<h2 id='graphlayouts-package'>graphlayouts: layout algorithms for network visualizations</h2><span id='topic+graphlayouts'></span><span id='topic+graphlayouts-package'></span>

<h3>Description</h3>

<p>The package implements several new layout algorithms to visualize networks.
Most are based on the concept of stress majorization. Some more specific algorithms allow to emphasize
hidden group structures in networks or focus on specific nodes. The package is best used in conjunction with
ggraph.
</p>
<p>Some features of the package are:
</p>

<ul>
<li> <p><code>layout_with_stress()</code> is a state of the art deterministic layout algorithms.
</p>
</li>
<li> <p><code>layout_as_backbone()</code> uncovers hidden group structures (if they exist) by emphasizing strongly embedded edges.
</p>
</li>
<li> <p><code>layout_with_focus()</code> and <code>layout_with_centrality()</code> produce concentric layouts with a focal or most central nodes in the center.
</p>
</li>
<li> <p><code>layout_with_eigen()</code> implements some layout algorithms on the basis of eigenvectors
</p>
</li>
<li> <p><code>layout_with_sparse_stress()</code> sparse stress for large graphs
</p>
</li>
<li> <p><code>layout_with_pmds()</code> pivot MDS for large graphs.
</p>
</li>
<li> <p><code>layout_as_dynamic()</code> for longitudinal network data
</p>
</li></ul>

<p>A detailed tutorial can be found at <a href="https://www.mr.schochastics.net/material/netVizR/">https://www.mr.schochastics.net/material/netVizR/</a>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: David Schoch <a href="mailto:david@schochastics.net">david@schochastics.net</a> (<a href="https://orcid.org/0000-0003-2952-4812">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/schochastics/graphlayouts">https://github.com/schochastics/graphlayouts</a>
</p>
</li>
<li> <p><a href="https://schochastics.github.io/graphlayouts/">https://schochastics.github.io/graphlayouts/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/schochastics/graphlayouts/issues">https://github.com/schochastics/graphlayouts/issues</a>
</p>
</li></ul>


<hr>
<h2 id='layout_as_metromap'>Metro Map Layout</h2><span id='topic+layout_as_metromap'></span>

<h3>Description</h3>

<p>Metro map layout based on multicriteria optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_as_metromap(object, xy, l = 2, gr = 0.0025, w = rep(1, 5), bsize = 5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_as_metromap_+3A_object">object</code></td>
<td>
<p>original graph</p>
</td></tr>
<tr><td><code id="layout_as_metromap_+3A_xy">xy</code></td>
<td>
<p>initial layout of the original graph</p>
</td></tr>
<tr><td><code id="layout_as_metromap_+3A_l">l</code></td>
<td>
<p>desired multiple of grid point spacing. (l*gr determines desired edge length)</p>
</td></tr>
<tr><td><code id="layout_as_metromap_+3A_gr">gr</code></td>
<td>
<p>grid spacing. (l*gr determines desired edge length)</p>
</td></tr>
<tr><td><code id="layout_as_metromap_+3A_w">w</code></td>
<td>
<p>weight vector for criteria (see details)</p>
</td></tr>
<tr><td><code id="layout_as_metromap_+3A_bsize">bsize</code></td>
<td>
<p>number of grid points a station can move away rom its original position</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function optimizes the following five criteria using a hill climbing algorithm:
</p>

<ul>
<li> <p><em>Angular Resolution Criterion</em>: The angles of incident edges at each station should be maximized, because if there is only a small angle between any two adjacent edges, then it can become difficult to distinguish between them
</p>
</li>
<li> <p><em>Edge Length Criterion</em>: The edge lengths across the whole map should be approximately equal to ensure regular spacing between stations. It is based on the preferred multiple, l, of the grid spacing, g. The purpose of the criterion is to penalize edges that are longer than or shorter than lg.
</p>
</li>
<li> <p><em>Balanced Edge Length Criterion</em>: The length of edges incident to a particular station should be similar
</p>
</li>
<li> <p><em>Line Straightness Criterion</em>: (not yet implemented) Edges that form part of a line should, where possible, be co-linear either side of each station that the line passes through
</p>
</li>
<li> <p><em>Octiinearity Criterion</em>: Each edge should be drawn horizontally, vertically, or diagonally at 45 degree, so we penalize edges that are not at a desired angle
</p>
</li></ul>



<h3>Value</h3>

<p>new coordinates for stations
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Stott, Jonathan, et al. &quot;Automatic metro map layout using multicriteria optimization.&quot; IEEE Transactions on Visualization and Computer Graphics 17.1 (2010): 101-114.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the algorithm has problems with parallel edges
library(igraph)
g &lt;- simplify(metro_berlin)
xy &lt;- cbind(V(g)$lon, V(g)$lat) * 100

# the algorithm is not very stable. try playing with the parameters
xy_new &lt;- layout_as_metromap(g, xy, l = 2, gr = 0.5, w = c(100, 100, 1, 1, 100), bsize = 35)
</code></pre>

<hr>
<h2 id='layout_backbone'>backbone graph layout</h2><span id='topic+layout_backbone'></span><span id='topic+layout_as_backbone'></span><span id='topic+layout_igraph_backbone'></span>

<h3>Description</h3>

<p>emphasizes a hidden group structure if it exists in the graph. Calculates a layout for a sparsified network only including the most embedded edges. Deleted edges are added back after the layout is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_as_backbone(g, keep = 0.2, backbone = TRUE)

layout_igraph_backbone(g, keep = 0.2, backbone = TRUE, circular)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_backbone_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="layout_backbone_+3A_keep">keep</code></td>
<td>
<p>fraction of edges to keep during backbone calculation</p>
</td></tr>
<tr><td><code id="layout_backbone_+3A_backbone">backbone</code></td>
<td>
<p>logical. Return edge ids of the backbone (Default: TRUE)</p>
</td></tr>
<tr><td><code id="layout_backbone_+3A_circular">circular</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The layout_igraph_* function should not be used directly. It is only used as an argument for plotting with 'igraph'.
'ggraph' natively supports the layout.
</p>


<h3>Value</h3>

<p>list of xy coordinates and vector of edge ids included in the backbone
</p>


<h3>References</h3>

<p>Nocaj, A., Ortmann, M., &amp; Brandes, U. (2015). Untangling the hairballs of multi-centered, small-world online social media networks. Journal of Graph Algorithms and Applications: JGAA, 19(2), 595-618.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)

g &lt;- sample_islands(9, 20, 0.4, 9)
g &lt;- simplify(g)
V(g)$grp &lt;- as.character(rep(1:9, each = 20))
bb &lt;- layout_as_backbone(g, keep = 0.4)

# add backbone links as edge attribute
E(g)$col &lt;- FALSE
E(g)$col[bb$backbone] &lt;- TRUE

</code></pre>

<hr>
<h2 id='layout_centrality'>radial centrality layout</h2><span id='topic+layout_centrality'></span><span id='topic+layout_with_centrality'></span><span id='topic+layout_igraph_centrality'></span>

<h3>Description</h3>

<p>arranges nodes in concentric circles according to a centrality index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_centrality(
  g,
  cent,
  scale = TRUE,
  iter = 500,
  tol = 1e-04,
  tseq = seq(0, 1, 0.2)
)

layout_igraph_centrality(
  g,
  cent,
  scale = TRUE,
  iter = 500,
  tol = 1e-04,
  tseq = seq(0, 1, 0.2),
  circular
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_centrality_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="layout_centrality_+3A_cent">cent</code></td>
<td>
<p>centrality scores</p>
</td></tr>
<tr><td><code id="layout_centrality_+3A_scale">scale</code></td>
<td>
<p>logical. should centrality scores be scaled to <code class="reqn">[0,100]</code>? (Default: TRUE)</p>
</td></tr>
<tr><td><code id="layout_centrality_+3A_iter">iter</code></td>
<td>
<p>number of iterations during stress optimization</p>
</td></tr>
<tr><td><code id="layout_centrality_+3A_tol">tol</code></td>
<td>
<p>stopping criterion for stress optimization</p>
</td></tr>
<tr><td><code id="layout_centrality_+3A_tseq">tseq</code></td>
<td>
<p>numeric vector. increasing sequence of coefficients to combine regular stress and constraint stress. See details.</p>
</td></tr>
<tr><td><code id="layout_centrality_+3A_circular">circular</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function optimizes a convex combination of regular stress and a constrained stress function which forces
nodes to be arranged on concentric circles. The vector <code>tseq</code> is the sequence of parameters used for the convex combination.
In iteration i of the algorithm <code class="reqn">tseq[i]</code> is used to combine regular and constraint stress as <code class="reqn">(1-tseq[i])*stress_{regular}+tseq[i]*stress_{constraint}</code>. The sequence must be increasing, start at zero and end at one. The default setting should be a good choice for most graphs.
</p>
<p>The layout_igraph_* function should not be used directly. It is only used as an argument for plotting with 'igraph'.
'ggraph' natively supports the layout.
</p>


<h3>Value</h3>

<p>matrix of xy coordinates
</p>


<h3>References</h3>

<p>Brandes, U., &amp; Pich, C. (2011). More flexible radial layout. Journal of Graph Algorithms and Applications, 15(1), 157-173.
</p>


<h3>See Also</h3>

<p><a href="#topic+layout_centrality_group">layout_centrality_group</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
library(ggraph)

g &lt;- sample_gnp(10, 0.4)
## Not run: 
ggraph(g, layout = "centrality", centrality = closeness(g)) +
    draw_circle(use = "cent") +
    geom_edge_link0() +
    geom_node_point(shape = 21, fill = "grey25", size = 5) +
    theme_graph() +
    coord_fixed()

## End(Not run)
</code></pre>

<hr>
<h2 id='layout_centrality_group'>radial centrality group layout</h2><span id='topic+layout_centrality_group'></span><span id='topic+layout_with_centrality_group'></span><span id='topic+layout_igraph_centrality_group'></span>

<h3>Description</h3>

<p>arranges nodes in concentric circles according to a centrality index and keeping groups within a angle range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_centrality_group(g, cent, group, shrink = 10, ...)

layout_igraph_centrality_group(g, cent, group, shrink = 10, circular, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_centrality_group_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="layout_centrality_group_+3A_cent">cent</code></td>
<td>
<p>centrality scores</p>
</td></tr>
<tr><td><code id="layout_centrality_group_+3A_group">group</code></td>
<td>
<p>vector indicating grouping of nodes</p>
</td></tr>
<tr><td><code id="layout_centrality_group_+3A_shrink">shrink</code></td>
<td>
<p>shrink the reserved angle range for a group to increase the gaps between groups</p>
</td></tr>
<tr><td><code id="layout_centrality_group_+3A_...">...</code></td>
<td>
<p>additional arguments to layout_with_centrality
The layout_igraph_* function should not be used directly. It is only used as an argument for plotting with 'igraph'.
'ggraph' natively supports the layout.</p>
</td></tr>
<tr><td><code id="layout_centrality_group_+3A_circular">circular</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of xy coordinates
</p>


<h3>See Also</h3>

<p><a href="#topic+layout_centrality">layout_centrality</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
</code></pre>

<hr>
<h2 id='layout_constrained_stress'>constrained stress layout</h2><span id='topic+layout_constrained_stress'></span><span id='topic+layout_with_constrained_stress'></span><span id='topic+layout_igraph_constrained_stress'></span>

<h3>Description</h3>

<p>force-directed graph layout based on stress majorization with variable constrained
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_constrained_stress(
  g,
  coord,
  fixdim = "x",
  weights = NA,
  iter = 500,
  tol = 1e-04,
  mds = TRUE,
  bbox = 30
)

layout_igraph_constrained_stress(
  g,
  coord,
  fixdim = "x",
  weights = NA,
  iter = 500,
  tol = 1e-04,
  mds = TRUE,
  bbox = 30,
  circular
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_constrained_stress_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="layout_constrained_stress_+3A_coord">coord</code></td>
<td>
<p>numeric vector. fixed coordinates for dimension specified in <code>fixdim</code>.</p>
</td></tr>
<tr><td><code id="layout_constrained_stress_+3A_fixdim">fixdim</code></td>
<td>
<p>string. which dimension should be fixed. Either &quot;x&quot; or &quot;y&quot;.</p>
</td></tr>
<tr><td><code id="layout_constrained_stress_+3A_weights">weights</code></td>
<td>
<p>possibly a numeric vector with edge weights. If this is NULL and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute). By default, weights are ignored. See details for more.</p>
</td></tr>
<tr><td><code id="layout_constrained_stress_+3A_iter">iter</code></td>
<td>
<p>number of iterations during stress optimization</p>
</td></tr>
<tr><td><code id="layout_constrained_stress_+3A_tol">tol</code></td>
<td>
<p>stopping criterion for stress optimization</p>
</td></tr>
<tr><td><code id="layout_constrained_stress_+3A_mds">mds</code></td>
<td>
<p>should an MDS layout be used as initial layout (default: TRUE)</p>
</td></tr>
<tr><td><code id="layout_constrained_stress_+3A_bbox">bbox</code></td>
<td>
<p>constrain dimension of output. Only relevant to determine the placement of disconnected graphs</p>
</td></tr>
<tr><td><code id="layout_constrained_stress_+3A_circular">circular</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be careful when using weights. In most cases, the inverse of the edge weights should be used to ensure that the endpoints of an edges with higher weights are closer together (weights=1/E(g)$weight).
</p>
<p>The layout_igraph_* function should not be used directly. It is only used as an argument for plotting with 'igraph'.
'ggraph' natively supports the layout.
</p>


<h3>Value</h3>

<p>matrix of xy coordinates
</p>


<h3>References</h3>

<p>Gansner, E. R., Koren, Y., &amp; North, S. (2004). Graph drawing by stress majorization. <em>In International Symposium on Graph Drawing</em> (pp. 239-250). Springer, Berlin, Heidelberg.
</p>


<h3>See Also</h3>

<p><a href="#topic+layout_constrained_stress3D">layout_constrained_stress3D</a>
</p>

<hr>
<h2 id='layout_constrained_stress3D'>constrained stress layout in 3D</h2><span id='topic+layout_constrained_stress3D'></span><span id='topic+layout_with_constrained_stress3D'></span>

<h3>Description</h3>

<p>force-directed graph layout based on stress majorization with variable constrained in 3D
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_constrained_stress3D(
  g,
  coord,
  fixdim = "x",
  weights = NA,
  iter = 500,
  tol = 1e-04,
  mds = TRUE,
  bbox = 30
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_constrained_stress3D_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="layout_constrained_stress3D_+3A_coord">coord</code></td>
<td>
<p>numeric vector. fixed coordinates for dimension specified in <code>fixdim</code>.</p>
</td></tr>
<tr><td><code id="layout_constrained_stress3D_+3A_fixdim">fixdim</code></td>
<td>
<p>string. which dimension should be fixed. Either &quot;x&quot;, &quot;y&quot; or &quot;z&quot;.</p>
</td></tr>
<tr><td><code id="layout_constrained_stress3D_+3A_weights">weights</code></td>
<td>
<p>possibly a numeric vector with edge weights. If this is NULL and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute). By default, weights are ignored. See details for more.</p>
</td></tr>
<tr><td><code id="layout_constrained_stress3D_+3A_iter">iter</code></td>
<td>
<p>number of iterations during stress optimization</p>
</td></tr>
<tr><td><code id="layout_constrained_stress3D_+3A_tol">tol</code></td>
<td>
<p>stopping criterion for stress optimization</p>
</td></tr>
<tr><td><code id="layout_constrained_stress3D_+3A_mds">mds</code></td>
<td>
<p>should an MDS layout be used as initial layout (default: TRUE)</p>
</td></tr>
<tr><td><code id="layout_constrained_stress3D_+3A_bbox">bbox</code></td>
<td>
<p>constrain dimension of output. Only relevant to determine the placement of disconnected graphs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be careful when using weights. In most cases, the inverse of the edge weights should be used to ensure that the endpoints of an edges with higher weights are closer together (weights=1/E(g)$weight).
</p>
<p>This function does not come with direct support for igraph or ggraph.
</p>


<h3>Value</h3>

<p>matrix of xyz coordinates
</p>


<h3>References</h3>

<p>Gansner, E. R., Koren, Y., &amp; North, S. (2004). Graph drawing by stress majorization. <em>In International Symposium on Graph Drawing</em> (pp. 239-250). Springer, Berlin, Heidelberg.
</p>


<h3>See Also</h3>

<p><a href="#topic+layout_constrained_stress">layout_constrained_stress</a>
</p>

<hr>
<h2 id='layout_dynamic'>dynamic graph layout</h2><span id='topic+layout_dynamic'></span><span id='topic+layout_as_dynamic'></span>

<h3>Description</h3>

<p>Create layouts for longitudinal networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_as_dynamic(gList, weights = NA, alpha = 0.5, iter = 500, tol = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_dynamic_+3A_glist">gList</code></td>
<td>
<p>list of igraph objects. Each network must contain the same set of nodes.</p>
</td></tr>
<tr><td><code id="layout_dynamic_+3A_weights">weights</code></td>
<td>
<p>possibly a numeric vector with edge weights. If this is NULL and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute). By default, weights are ignored. See details for more.</p>
</td></tr>
<tr><td><code id="layout_dynamic_+3A_alpha">alpha</code></td>
<td>
<p>weighting of reference layout. See details.</p>
</td></tr>
<tr><td><code id="layout_dynamic_+3A_iter">iter</code></td>
<td>
<p>number of iterations during stress optimization</p>
</td></tr>
<tr><td><code id="layout_dynamic_+3A_tol">tol</code></td>
<td>
<p>stopping criterion for stress optimization</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The reference layout is calculated based on the union of all graphs. The parameter alpha controls the influence of the reference layout.
For alpha=1, only the reference layout is used and all graphs have the same layout. For alpha=0, the stress layout of each individual graph is used. Values in-between interpolate between the two layouts.
</p>
<p>Be careful when using weights. In most cases, the inverse of the edge weights should be used to ensure that the endpoints of an edges with higher weights are closer together (weights=1/E(g)$weight).
</p>


<h3>Value</h3>

<p>list of coordinates for each graph
</p>


<h3>References</h3>

<p>Brandes, U. and Indlekofer, N. and Mader, M. (2012). Visualization methods for longitudinal social networks and stochastic actor-oriented modeling. <em>Social Networks</em> 34 (3) 291-308
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g1 &lt;- sample_gnp(20, 0.2)
g2 &lt;- sample_gnp(20, 0.2)
g3 &lt;- sample_gnp(20, 0.2)

xy &lt;- layout_as_dynamic(list(g1, g2, g3))

# layout for first network
xy[[1]]
</code></pre>

<hr>
<h2 id='layout_fixed_coords'>Layout with fixed coordinates</h2><span id='topic+layout_fixed_coords'></span><span id='topic+layout_with_fixed_coords'></span><span id='topic+layout_igraph_fixed_coords'></span>

<h3>Description</h3>

<p>force-directed graph layout based on stress majorization with
fixed coordinates for some nodes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_fixed_coords(
  g,
  coords,
  weights = NA,
  iter = 500,
  tol = 1e-04,
  mds = TRUE,
  bbox = 30
)

layout_igraph_fixed_coords(
  g,
  coords,
  weights = NA,
  iter = 500,
  tol = 1e-04,
  mds = TRUE,
  bbox = 30,
  circular
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_fixed_coords_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="layout_fixed_coords_+3A_coords">coords</code></td>
<td>
<p>numeric n x 2 matrix, where n is the number of nodes. values
are either NA or fixed coordinates. coordinates are only calculated for the
NA values.</p>
</td></tr>
<tr><td><code id="layout_fixed_coords_+3A_weights">weights</code></td>
<td>
<p>possibly a numeric vector with edge weights. If this is NULL and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute). By default, weights are ignored. See details for more.</p>
</td></tr>
<tr><td><code id="layout_fixed_coords_+3A_iter">iter</code></td>
<td>
<p>number of iterations during stress optimization</p>
</td></tr>
<tr><td><code id="layout_fixed_coords_+3A_tol">tol</code></td>
<td>
<p>stopping criterion for stress optimization</p>
</td></tr>
<tr><td><code id="layout_fixed_coords_+3A_mds">mds</code></td>
<td>
<p>should an MDS layout be used as initial layout (default: TRUE)</p>
</td></tr>
<tr><td><code id="layout_fixed_coords_+3A_bbox">bbox</code></td>
<td>
<p>constrain dimension of output. Only relevant to determine the placement of disconnected graphs</p>
</td></tr>
<tr><td><code id="layout_fixed_coords_+3A_circular">circular</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be careful when using weights. In most cases, the inverse of the edge weights should be used to ensure that the endpoints of an edges with higher weights are closer together (weights=1/E(g)$weight).
</p>
<p>The layout_igraph_* function should not be used directly. It is only used as an argument for plotting with 'igraph'.
'ggraph' natively supports the layout.
</p>


<h3>Value</h3>

<p>matrix of xy coordinates
</p>


<h3>See Also</h3>

<p><a href="#topic+layout_constrained_stress">layout_constrained_stress</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
set.seed(12)
g &lt;- sample_bipartite(10, 5, "gnp", 0.5)
fxy &lt;- cbind(c(rep(0, 10), rep(1, 5)), NA)
xy &lt;- layout_with_fixed_coords(g, fxy)
</code></pre>

<hr>
<h2 id='layout_focus'>radial focus layout</h2><span id='topic+layout_focus'></span><span id='topic+layout_with_focus'></span><span id='topic+layout_igraph_focus'></span>

<h3>Description</h3>

<p>arrange nodes in concentric circles around a focal node according to their distance from the focus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_focus(g, v, weights = NA, iter = 500, tol = 1e-04)

layout_igraph_focus(g, v, weights = NA, iter = 500, tol = 1e-04, circular)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_focus_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="layout_focus_+3A_v">v</code></td>
<td>
<p>id of focal node to be placed in the center</p>
</td></tr>
<tr><td><code id="layout_focus_+3A_weights">weights</code></td>
<td>
<p>possibly a numeric vector with edge weights. If this is NULL and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute). By default, weights are ignored. See details for more.</p>
</td></tr>
<tr><td><code id="layout_focus_+3A_iter">iter</code></td>
<td>
<p>number of iterations during stress optimization</p>
</td></tr>
<tr><td><code id="layout_focus_+3A_tol">tol</code></td>
<td>
<p>stopping criterion for stress optimization</p>
</td></tr>
<tr><td><code id="layout_focus_+3A_circular">circular</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be careful when using weights. In most cases, the inverse of the edge weights should be used to ensure that the endpoints of an edges with higher weights are closer together (weights=1/E(g)$weight).
</p>


<h3>Value</h3>

<p>a list containing xy coordinates and the distances to the focal node
</p>


<h3>References</h3>

<p>Brandes, U., &amp; Pich, C. (2011). More flexible radial layout. <em>Journal of Graph Algorithms and Applications</em>, 15(1), 157-173.
</p>


<h3>See Also</h3>

<p><a href="#topic+layout_focus_group">layout_focus_group</a>
The layout_igraph_* function should not be used directly. It is only used as an argument for plotting with 'igraph'.
'ggraph' natively supports the layout.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- sample_gnp(10, 0.4)
coords &lt;- layout_with_focus(g, v = 1)
coords
</code></pre>

<hr>
<h2 id='layout_focus_group'>radial focus group layout</h2><span id='topic+layout_focus_group'></span><span id='topic+layout_with_focus_group'></span><span id='topic+layout_igraph_focus_group'></span>

<h3>Description</h3>

<p>arrange nodes in concentric circles around a focal node according to their distance from the focus and keep predefined groups in the same angle range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_focus_group(
  g,
  v,
  group,
  shrink = 10,
  weights = NA,
  iter = 500,
  tol = 1e-04
)

layout_igraph_focus_group(
  g,
  v,
  group,
  shrink = 10,
  weights = NA,
  iter = 500,
  tol = 1e-04,
  circular
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_focus_group_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="layout_focus_group_+3A_v">v</code></td>
<td>
<p>id of focal node to be placed in the center</p>
</td></tr>
<tr><td><code id="layout_focus_group_+3A_group">group</code></td>
<td>
<p>vector indicating grouping of nodes</p>
</td></tr>
<tr><td><code id="layout_focus_group_+3A_shrink">shrink</code></td>
<td>
<p>shrink the reserved angle range for a group to increase the gaps between groups</p>
</td></tr>
<tr><td><code id="layout_focus_group_+3A_weights">weights</code></td>
<td>
<p>possibly a numeric vector with edge weights. If this is NULL and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute). By default, weights are ignored. See details for more.</p>
</td></tr>
<tr><td><code id="layout_focus_group_+3A_iter">iter</code></td>
<td>
<p>number of iterations during stress optimization</p>
</td></tr>
<tr><td><code id="layout_focus_group_+3A_tol">tol</code></td>
<td>
<p>stopping criterion for stress optimization</p>
</td></tr>
<tr><td><code id="layout_focus_group_+3A_circular">circular</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be careful when using weights. In most cases, the inverse of the edge weights should be used to ensure that the endpoints of an edges with higher weights are closer together (weights=1/E(g)$weight).
</p>


<h3>Value</h3>

<p>matrix of xy coordinates
</p>


<h3>See Also</h3>

<p><a href="#topic+layout_focus">layout_focus</a>
The layout_igraph_* function should not be used directly. It is only used as an argument for plotting with 'igraph'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- sample_islands(4, 5, 0.8, 2)
grp &lt;- as.character(rep(1:4, each = 5))
layout_with_focus_group(g, v = 1, group = grp, shrink = 10)
</code></pre>

<hr>
<h2 id='layout_manipulate'>manipulate layout</h2><span id='topic+layout_manipulate'></span><span id='topic+layout_rotate'></span><span id='topic+layout_mirror'></span>

<h3>Description</h3>

<p>functions to manipulate an existing layout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_rotate(xy, angle)

layout_mirror(xy, axis = "vertical")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_manipulate_+3A_xy">xy</code></td>
<td>
<p>graph layout</p>
</td></tr>
<tr><td><code id="layout_manipulate_+3A_angle">angle</code></td>
<td>
<p>angle for rotation</p>
</td></tr>
<tr><td><code id="layout_manipulate_+3A_axis">axis</code></td>
<td>
<p>mirror horizontal or vertical</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are mostly useful for deterministic layouts such as <a href="#topic+layout_with_stress">layout_with_stress</a>
</p>


<h3>Value</h3>

<p>manipulated matrix of xy coordinates
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
g &lt;- sample_gnp(50, 0.3)

xy &lt;- layout_with_stress(g)

# rotate 90 degrees
xy &lt;- layout_rotate(xy, 90)

# flip horizontally
xy &lt;- layout_mirror(xy, "horizontal")

</code></pre>

<hr>
<h2 id='layout_multilevel'>multilevel layout</h2><span id='topic+layout_multilevel'></span><span id='topic+layout_as_multilevel'></span><span id='topic+layout_igraph_multilevel'></span>

<h3>Description</h3>

<p>Layout algorithm to visualize multilevel networks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_as_multilevel(
  g,
  type = "all",
  FUN1,
  FUN2,
  params1 = NULL,
  params2 = NULL,
  ignore_iso = TRUE,
  project2D = TRUE,
  alpha = 35,
  beta = 45
)

layout_igraph_multilevel(
  g,
  type = "all",
  FUN1,
  FUN2,
  params1 = NULL,
  params2 = NULL,
  ignore_iso = TRUE,
  alpha = 35,
  beta = 45,
  circular
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_multilevel_+3A_g">g</code></td>
<td>
<p>igraph object. Must have a vertex attribute &quot;lvl&quot; which is 1 or 2.</p>
</td></tr>
<tr><td><code id="layout_multilevel_+3A_type">type</code></td>
<td>
<p>one of &quot;all&quot;, &quot;separate&quot;,&quot;fix1&quot; or &quot;fix2&quot;. see details</p>
</td></tr>
<tr><td><code id="layout_multilevel_+3A_fun1">FUN1</code></td>
<td>
<p>if type=&quot;separate&quot;, the layout function to be used for level 1</p>
</td></tr>
<tr><td><code id="layout_multilevel_+3A_fun2">FUN2</code></td>
<td>
<p>if type=&quot;separate&quot;, the layout function to be used for level 2</p>
</td></tr>
<tr><td><code id="layout_multilevel_+3A_params1">params1</code></td>
<td>
<p>named list of parameters for FUN1</p>
</td></tr>
<tr><td><code id="layout_multilevel_+3A_params2">params2</code></td>
<td>
<p>named list of parameters for FUN2</p>
</td></tr>
<tr><td><code id="layout_multilevel_+3A_ignore_iso">ignore_iso</code></td>
<td>
<p>treatment of isolates within levels. see details</p>
</td></tr>
<tr><td><code id="layout_multilevel_+3A_project2d">project2D</code></td>
<td>
<p>logical. Defaults to TRUE (project to 2D).</p>
</td></tr>
<tr><td><code id="layout_multilevel_+3A_alpha">alpha</code></td>
<td>
<p>angle for isometric projection between 0 and 90</p>
</td></tr>
<tr><td><code id="layout_multilevel_+3A_beta">beta</code></td>
<td>
<p>angle for isometric projection between 0 and 90</p>
</td></tr>
<tr><td><code id="layout_multilevel_+3A_circular">circular</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm internally computes a 3D layout where each level is in a separate y-plane.
The layout is then projected into 2D via an isometric mapping, controlled by the parameters
<code>alpha</code> and <code>beta</code>. It may take some adjusting to <code>alpha</code> and <code>beta</code> to find a good perspective.
</p>
<p>If type=&quot;all&quot;, the layout is computed at once for the complete network.
For type=&quot;separate&quot;, two user specified layout algorithms (<code>FUN1</code> and <code>FUN2</code>) are used for the levels.
The named lists <code>param1</code> and <code>param2</code> can be used to set parameters for <code>FUN1</code> and <code>FUN2</code>.
This option helpful for situations where different structural features of the levels should be emphasized.
</p>
<p>For type=&quot;fix1&quot; and type=&quot;fix2&quot; only one of the level layouts is fixed. The other one is calculated by optimizing the
inter level ties, such that they are drawn (almost) vertical.
</p>
<p>The <code>ignore_iso</code> parameter controls the handling of isolates. If TRUE, nodes without inter level edges are ignored during the layout process
and added at the end. If FALSE they are left unchanged
</p>
<p>The layout_igraph_* function should not be used directly. It is only used as an argument for plotting with 'igraph'.
</p>


<h3>Value</h3>

<p>matrix of xy coordinates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
data("multilvl_ex")

# compute a layout for the whole network
xy &lt;- layout_as_multilevel(multilvl_ex, type = "all", alpha = 25, beta = 45)

# compute a layout for each level separately and combine them
xy &lt;- layout_as_multilevel(multilvl_ex,
    type = "separate",
    FUN1 = layout_as_backbone,
    FUN2 = layout_with_stress,
    alpha = 25, beta = 45
)

</code></pre>

<hr>
<h2 id='layout_pmds'>pivot MDS graph layout</h2><span id='topic+layout_pmds'></span><span id='topic+layout_with_pmds'></span><span id='topic+layout_igraph_pmds'></span>

<h3>Description</h3>

<p>similar to <a href="igraph.html#topic+layout_with_mds">layout_with_mds</a> but uses only a small set of pivots for MDS. Considerably faster than MDS and thus applicable for larger graphs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_pmds(g, pivots, weights = NA, D = NULL, dim = 2)

layout_igraph_pmds(g, pivots, weights = NA, D = NULL, circular)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_pmds_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="layout_pmds_+3A_pivots">pivots</code></td>
<td>
<p>number of pivots</p>
</td></tr>
<tr><td><code id="layout_pmds_+3A_weights">weights</code></td>
<td>
<p>possibly a numeric vector with edge weights. If this is NULL and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute). By default, weights are ignored. See details for more.</p>
</td></tr>
<tr><td><code id="layout_pmds_+3A_d">D</code></td>
<td>
<p>precomputed distances from pivots to all nodes (if available, default: NULL)</p>
</td></tr>
<tr><td><code id="layout_pmds_+3A_dim">dim</code></td>
<td>
<p>dimensionality of layout (defaults to 2)</p>
</td></tr>
<tr><td><code id="layout_pmds_+3A_circular">circular</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be careful when using weights. In most cases, the inverse of the edge weights should be used to ensure that the endpoints of an edges with higher weights are closer together (weights=1/E(g)$weight)
</p>
<p>The layout_igraph_* function should not be used directly. It is only used as an argument for plotting with 'igraph'.
'ggraph' natively supports the layout.
</p>


<h3>Value</h3>

<p>matrix of coordinates
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Brandes, U. and Pich, C. (2006). Eigensolver Methods for Progressive Multidimensional Scaling of Large Data. In <em>International Symposium on Graph Drawing</em> (pp. 42-53). Springer
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(igraph)
library(ggraph)

g &lt;- sample_gnp(1000, 0.01)

xy &lt;- layout_with_pmds(g, pivots = 100)

## End(Not run)
</code></pre>

<hr>
<h2 id='layout_sparse_stress'>sparse stress graph layout</h2><span id='topic+layout_sparse_stress'></span><span id='topic+layout_with_sparse_stress'></span><span id='topic+layout_igraph_sparse_stress'></span>

<h3>Description</h3>

<p>stress majorization for larger graphs based on a set of pivot nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_sparse_stress(g, pivots, weights = NA, iter = 500)

layout_igraph_sparse_stress(g, pivots, weights = NA, iter = 500, circular)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_sparse_stress_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="layout_sparse_stress_+3A_pivots">pivots</code></td>
<td>
<p>number of pivots</p>
</td></tr>
<tr><td><code id="layout_sparse_stress_+3A_weights">weights</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="layout_sparse_stress_+3A_iter">iter</code></td>
<td>
<p>number of iterations during stress optimization</p>
</td></tr>
<tr><td><code id="layout_sparse_stress_+3A_circular">circular</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The layout_igraph_* function should not be used directly. It is only used as an argument for plotting with 'igraph'.
'ggraph' natively supports the layout.
</p>


<h3>Value</h3>

<p>matrix of xy coordinates
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>Ortmann, M. and Klimenta, M. and Brandes, U. (2016). A Sparse Stress Model. https://arxiv.org/pdf/1608.08909.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(igraph)
library(ggraph)

g &lt;- sample_gnp(1000, 0.005)

ggraph(g, layout = "sparse_stress", pivots = 100) +
    geom_edge_link0(edge_colour = "grey66") +
    geom_node_point(shape = 21, fill = "grey25", size = 5) +
    theme_graph()

## End(Not run)
</code></pre>

<hr>
<h2 id='layout_spectral'>spectral graph layouts</h2><span id='topic+layout_spectral'></span><span id='topic+layout_with_eigen'></span><span id='topic+layout_igraph_eigen'></span>

<h3>Description</h3>

<p>Using a set of eigenvectors of matrices associated with a graph as coordinates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_eigen(g, type = "laplacian", ev = "smallest")

layout_igraph_eigen(g, type = "laplacian", ev = "smallest", circular)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_spectral_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="layout_spectral_+3A_type">type</code></td>
<td>
<p>matrix to be used for spectral decomposition. either 'adjacency' or 'laplacian'</p>
</td></tr>
<tr><td><code id="layout_spectral_+3A_ev">ev</code></td>
<td>
<p>eigenvectors to be used. Either 'smallest' or 'largest'.</p>
</td></tr>
<tr><td><code id="layout_spectral_+3A_circular">circular</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The layout_igraph_* function should not be used directly. It is only used as an argument for plotting with 'igraph'.
'ggraph' natively supports the layout.
</p>


<h3>Value</h3>

<p>matrix of xy coordinates
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)

g &lt;- sample_gnp(50, 0.2)

xy &lt;- layout_with_eigen(g, type = "adjacency", ev = "largest")

xy &lt;- layout_with_eigen(g, type = "adjacency", ev = "smallest")

xy &lt;- layout_with_eigen(g, type = "laplacian", ev = "largest")

xy &lt;- layout_with_eigen(g, type = "laplacian", ev = "smallest")
</code></pre>

<hr>
<h2 id='layout_stress'>stress majorization layout</h2><span id='topic+layout_stress'></span><span id='topic+layout_with_stress'></span><span id='topic+layout_igraph_stress'></span>

<h3>Description</h3>

<p>force-directed graph layout based on stress majorization.
Similar to Kamada-Kawai, but generally faster and with better results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_stress(
  g,
  weights = NA,
  iter = 500,
  tol = 1e-04,
  mds = TRUE,
  bbox = 30
)

layout_igraph_stress(
  g,
  weights = NA,
  iter = 500,
  tol = 1e-04,
  mds = TRUE,
  bbox = 30,
  circular
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_stress_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="layout_stress_+3A_weights">weights</code></td>
<td>
<p>possibly a numeric vector with edge weights. If this is NULL and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute). By default, weights are ignored. See details for more.</p>
</td></tr>
<tr><td><code id="layout_stress_+3A_iter">iter</code></td>
<td>
<p>number of iterations during stress optimization</p>
</td></tr>
<tr><td><code id="layout_stress_+3A_tol">tol</code></td>
<td>
<p>stopping criterion for stress optimization</p>
</td></tr>
<tr><td><code id="layout_stress_+3A_mds">mds</code></td>
<td>
<p>should an MDS layout be used as initial layout (default: TRUE)</p>
</td></tr>
<tr><td><code id="layout_stress_+3A_bbox">bbox</code></td>
<td>
<p>width of layout. Only relevant to determine the placement of disconnected graphs</p>
</td></tr>
<tr><td><code id="layout_stress_+3A_circular">circular</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be careful when using weights. In most cases, the inverse of the edge weights should be used to ensure that the endpoints of an edges with higher weights are closer together (weights=1/E(g)$weight).
</p>
<p>The layout_igraph_* function should not be used directly. It is only used as an argument for plotting with 'igraph'.
'ggraph' natively supports the layout.
</p>


<h3>Value</h3>

<p>matrix of xy coordinates
</p>


<h3>References</h3>

<p>Gansner, E. R., Koren, Y., &amp; North, S. (2004). Graph drawing by stress majorization. <em>In International Symposium on Graph Drawing</em> (pp. 239-250). Springer, Berlin, Heidelberg.
</p>


<h3>See Also</h3>

<p><a href="#topic+layout_stress3D">layout_stress3D</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)
library(ggraph)
set.seed(665)

g &lt;- sample_pa(100, 1, 1, directed = FALSE)

# calculate layout manually
xy &lt;- layout_with_stress(g)

# use it with ggraph
## Not run: 
ggraph(g, layout = "stress") +
    geom_edge_link0(edge_width = 0.2, colour = "grey") +
    geom_node_point(col = "black", size = 0.3) +
    theme_graph()

## End(Not run)
</code></pre>

<hr>
<h2 id='layout_stress3D'>stress majorization layout in 3D</h2><span id='topic+layout_stress3D'></span><span id='topic+layout_with_stress3D'></span>

<h3>Description</h3>

<p>force-directed graph layout based on stress majorization in 3D.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_stress3D(
  g,
  weights = NA,
  iter = 500,
  tol = 1e-04,
  mds = TRUE,
  bbox = 30
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_stress3D_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="layout_stress3D_+3A_weights">weights</code></td>
<td>
<p>possibly a numeric vector with edge weights. If this is NULL and the graph has a weight edge attribute, then the attribute is used. If this is NA then no weights are used (even if the graph has a weight attribute). By default, weights are ignored. See details for more.</p>
</td></tr>
<tr><td><code id="layout_stress3D_+3A_iter">iter</code></td>
<td>
<p>number of iterations during stress optimization</p>
</td></tr>
<tr><td><code id="layout_stress3D_+3A_tol">tol</code></td>
<td>
<p>stopping criterion for stress optimization</p>
</td></tr>
<tr><td><code id="layout_stress3D_+3A_mds">mds</code></td>
<td>
<p>should an MDS layout be used as initial layout (default: TRUE)</p>
</td></tr>
<tr><td><code id="layout_stress3D_+3A_bbox">bbox</code></td>
<td>
<p>width of layout. Only relevant to determine the placement of disconnected graphs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Be careful when using weights. In most cases, the inverse of the edge weights should be used to ensure that the endpoints of an edges with higher weights are closer together (weights=1/E(g)$weight).
</p>


<h3>Value</h3>

<p>matrix of xyz coordinates
</p>


<h3>References</h3>

<p>Gansner, E. R., Koren, Y., &amp; North, S. (2004). Graph drawing by stress majorization. <em>In International Symposium on Graph Drawing</em> (pp. 239-250). Springer, Berlin, Heidelberg.
</p>


<h3>See Also</h3>

<p><a href="#topic+layout_stress">layout_stress</a>
</p>

<hr>
<h2 id='layout_umap'>UMAP graph layouts</h2><span id='topic+layout_umap'></span><span id='topic+layout_with_umap'></span><span id='topic+layout_igraph_umap'></span>

<h3>Description</h3>

<p>Using the UMAP dimensionality reduction algorithm as a graph layout
</p>


<h3>Usage</h3>

<pre><code class='language-R'>layout_with_umap(g, pivots = NULL, ...)

layout_igraph_umap(g, circular, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="layout_umap_+3A_g">g</code></td>
<td>
<p>igraph object</p>
</td></tr>
<tr><td><code id="layout_umap_+3A_pivots">pivots</code></td>
<td>
<p>if not NULL, number of pivot nodes to use for distance calculation (for large graphs).</p>
</td></tr>
<tr><td><code id="layout_umap_+3A_...">...</code></td>
<td>
<p>additional parameters for umap. See the <code>?uwot::umap</code> for help.</p>
</td></tr>
<tr><td><code id="layout_umap_+3A_circular">circular</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The layout_igraph_* function should not be used directly. It is only used as an argument for plotting with 'igraph'. UMAP can be tuned by many different parameters. Refer to the documentation at https://github.com/jlmelville/uwot for help
</p>


<h3>Value</h3>

<p>matrix of xy coordinates
</p>


<h3>Author(s)</h3>

<p>David Schoch
</p>


<h3>References</h3>

<p>McInnes, Leland, John Healy, and James Melville. &quot;Umap: Uniform manifold approximation and projection for dimension reduction.&quot; arXiv preprint arXiv:1802.03426 (2018).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(igraph)

g &lt;- sample_islands(10, 20, 0.6, 10)
# xy &lt;- layout_with_umap(g, min_dist = 0.5)
</code></pre>

<hr>
<h2 id='metro_berlin'>Subway network of Berlin</h2><span id='topic+metro_berlin'></span>

<h3>Description</h3>

<p>A dataset containing the subway network of Berlin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metro_berlin
</code></pre>


<h3>Format</h3>

<p>igraph object
</p>


<h3>References</h3>

<p>Kujala, Rainer, et al. &quot;A collection of public transport network data sets for 25 cities.&quot; Scientific data 5 (2018): 180089.
</p>

<hr>
<h2 id='multilvl_ex'>Multilevel example Network</h2><span id='topic+multilvl_ex'></span>

<h3>Description</h3>

<p>Multilevel network, where both levels have different structural features
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multilvl_ex
</code></pre>


<h3>Format</h3>

<p>igraph object
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
