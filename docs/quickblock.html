<!DOCTYPE html><html lang="en"><head><title>Help for package quickblock</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {quickblock}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#quickblock-package'><p>quickblock: Quick Threshold Blocking</p></a></li>
<li><a href='#assign_treatment'><p>Random treatment assignment with blocks</p></a></li>
<li><a href='#blocking_estimator'><p>Estimator for treatment effects in blocked experiments</p></a></li>
<li><a href='#is.qb_blocking'><p>Check qb_blocking object</p></a></li>
<li><a href='#qb_blocking'><p>Constructor for qb_blocking objects</p></a></li>
<li><a href='#quickblock'><p>Construct threshold blockings</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quick Threshold Blocking</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-31</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Provides functions for assigning treatments in randomized experiments using
    near-optimal threshold blocking. The package is made with large data sets in
    mind and derives blocks more than an order of magnitude quicker than other
    methods.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), distances</td>
</tr>
<tr>
<td>Imports:</td>
<td>scclust (&ge; 0.2.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/fsavje/quickblock">https://github.com/fsavje/quickblock</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/fsavje/quickblock/issues">https://github.com/fsavje/quickblock/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-31 15:53:09 UTC; fredriksavje</td>
</tr>
<tr>
<td>Author:</td>
<td>Fredrik Savje [aut, cre],
  Jasjeet Sekhon [aut],
  Michael Higgins [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fredrik Savje &lt;rpackages@fredriksavje.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-31 22:30:27 UTC</td>
</tr>
</table>
<hr>
<h2 id='quickblock-package'>quickblock: Quick Threshold Blocking</h2><span id='topic+quickblock-package'></span>

<h3>Description</h3>

<p>Provides functions for assigning treatments in randomized experiments using
near-optimal threshold blocking. The package is made with large data sets in
mind and derives blocks more than an order of magnitude quicker than other
methods.
</p>


<h3>Details</h3>

<p>See <code><a href="#topic+quickblock">quickblock</a></code> for the main blocking function.
</p>
<p>See the package's website for more information:
<a href="https://github.com/fsavje/quickblock">https://github.com/fsavje/quickblock</a>.
</p>
<p>Bug reports and suggestions are greatly appreciated. They are best reported
here: <a href="https://github.com/fsavje/quickblock/issues">https://github.com/fsavje/quickblock/issues</a>.
</p>


<h3>References</h3>

<p>Higgins, Michael J., Fredrik Sävje and Jasjeet S. Sekhon (2016),
&lsquo;Improving massive experiments with threshold blocking&rsquo;,
<em>Proceedings of the National Academy of Sciences</em>, <b>113:27</b>, 7369&ndash;7376.
</p>

<hr>
<h2 id='assign_treatment'>Random treatment assignment with blocks</h2><span id='topic+assign_treatment'></span>

<h3>Description</h3>

<p><code>assign_treatment</code> randomly assigns treatments to the units in the sample
so to best maintain the equal proportions of conditions within each block. The
function expects the user to provide a blocking object and treatment conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_treatment(blocking, treatments = c("Treated", "Control"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assign_treatment_+3A_blocking">blocking</code></td>
<td>
<p><code><a href="#topic+qb_blocking">qb_blocking</a></code> or <code><a href="scclust.html#topic+scclust">scclust</a></code> object with
the blocked units.</p>
</td></tr>
<tr><td><code id="assign_treatment_+3A_treatments">treatments</code></td>
<td>
<p>character vector with treatment conditions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the number of treatment conditions evenly divides the size of a block,
the conditions will be repeated that many times within the block. For example,
with three conditions, <code>c("T1", "T2", "C")</code>, and a block with six units,
two units will be assigned to each condition.
</p>
<p>When the number of treatment conditions does not evenly divide the block size,
the conditions are repeated up to the closest multiple lower than the block
size and the remaining conditions are chosen at random. For example, with the
three conditions from above and a block with four units, each condition will be
repeated once (since <code>floor(4/3) == 1</code>). One additional condition is needed
to assign all units in the block, and that condition is selected at random from
<code>c("T1", "T2", "C")</code> with equal probability. In a block with 8 units, each
condition will be repeated twice (<code>floor(8/3) == 2</code>). Two additional
conditions are now needed, and they are chosen from <code>c("T1", "T2", "C")</code>
without replacement.
</p>
<p>In all cases, the treatment conditions within a block are shuffled so that all
units have the same probability of being assigned to each condition. Units not
assigned to blocks will not be assigned treatments (indicated by <code>NA</code>).
</p>


<h3>Value</h3>

<p>Returns a factor with the assigned treatments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example blocking
my_blocking &lt;- qb_blocking(c("A", "A", "B", "C", "B",
                             "C", "C", "A", "B", "B"))

# Two treatment conditions
assign_treatment(my_blocking)

# Three treatment conditions
assign_treatment(my_blocking, c("T1", "T2", "C"))

# Four treatment conditions
# (This throws warning because some blocks contain less than four units)
## Not run: assign_treatment(my_blocking, c("T1", "T2", "T3", "C"))

</code></pre>

<hr>
<h2 id='blocking_estimator'>Estimator for treatment effects in blocked experiments</h2><span id='topic+blocking_estimator'></span>

<h3>Description</h3>

<p><code>blocking_estimator</code> estimates treatment effects in blocked experiments.
The function expects the user to provide the outcomes, a blocking object
and treatment assignments. It returns point estimates of sample average
treatment effects and variance estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blocking_estimator(outcomes, blocking, treatments)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="blocking_estimator_+3A_outcomes">outcomes</code></td>
<td>
<p>numeric vector with observed outcomes.</p>
</td></tr>
<tr><td><code id="blocking_estimator_+3A_blocking">blocking</code></td>
<td>
<p><code><a href="#topic+qb_blocking">qb_blocking</a></code> or <code><a href="scclust.html#topic+scclust">scclust</a></code> object with
the block assignments.</p>
</td></tr>
<tr><td><code id="blocking_estimator_+3A_treatments">treatments</code></td>
<td>
<p>factor specifying the units' treatment assignments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To produce point estimates, <code>blocking_estimator</code> requires that each block
contains at least one unit assigned to each treatment condition. For variance
estimation, it requires that each block contains at least two units assigned to
each condition. When treatments have been assigned with the
<code><a href="#topic+assign_treatment">assign_treatment</a></code> function (or an equivalent procedure), the
variance estimators are conservative in expectation (see the referenced
note below for details). If treatment is assigned with another method, the
estimator might not be valid.
</p>
<p>The function estimates treatment effects by aggregating block-level
effect estimates. It estimates effects within each block by taking the difference
in mean outcomes in the block. The sample-level estimate is then derived as the
weighted average of the block-level effects using the size of the blocks as weights.
In detail, let <code class="reqn">n_b</code> be the number of units assigned to block <code class="reqn">b</code>, and
<code class="reqn">n</code> be the total number of units in the sample. Let <code class="reqn">Y(t, b)</code> be the
average outcome for units assigned to treatment <code class="reqn">t</code> in block <code class="reqn">b</code>. The
effect of treatment <code class="reqn">t</code> versus treatment <code class="reqn">s</code> is then estimated as:
</p>
<p style="text-align: center;"><code class="reqn">\sum\frac{n_b}{n}[Y(t, b) - Y(s, b)],</code>
</p>

<p>where the sum is taken over the blocks in the experiment. See the referenced note
for more details.
</p>


<h3>Value</h3>

<p>A list with two numeric matrices with estimated treatment effects and
their estimated variances is returned. The first matrix (<code>effects</code>)
contains estimated treatment effects. Rows in this matrix indicate minuends
in the treatment effect contrast and columns indicate subtrahends. For
example, in the matrix:
</p>

<table>
<tr>
 <td style="text-align: right;">
     </td><td style="text-align: right;"> a </td><td style="text-align: right;"> b </td><td style="text-align: right;"> c</td>
</tr>
<tr>
 <td style="text-align: right;">
     a </td><td style="text-align: right;"> 0.0 </td><td style="text-align: right;"> 4.5 </td><td style="text-align: right;"> 5.5</td>
</tr>
<tr>
 <td style="text-align: right;">
     b </td><td style="text-align: right;"> -4.5 </td><td style="text-align: right;"> 0.0 </td><td style="text-align: right;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: right;">
     c </td><td style="text-align: right;"> -5.5 </td><td style="text-align: right;"> -1.0 </td><td style="text-align: right;"> 0.0</td>
</tr>
<tr>
 <td style="text-align: right;">
   </td>
</tr>

</table>

<p>the estimated treatment effect between conditions <code class="reqn">a</code> and <code class="reqn">b</code> is
<code class="reqn">4.5</code>, and the estimated treatment effect between conditions <code class="reqn">c</code>
and <code class="reqn">b</code> is <code class="reqn">-1.0</code>.
</p>
<p>The second matrix (<code>effect_variances</code>) contains estimates of
variances of the corresponding effect estimators.
</p>


<h3>References</h3>

<p>Higgins, Michael J., Fredrik Sävje and Jasjeet S. Sekhon (2015),
&lsquo;Blocking estimators and inference under the Neyman-Rubin model&rsquo;,
arXiv 1510.01103. <a href="https://arxiv.org/abs/1510.01103">https://arxiv.org/abs/1510.01103</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example blocking
my_blocking &lt;- qb_blocking(c("A", "A", "B", "C", "B",
                             "C", "B", "C", "B", "A",
                             "C", "C", "A", "B", "B",
                             "B", "B", "A", "A", "C"))

# Two treatment conditions
my_treatments &lt;- assign_treatment(my_blocking)
my_outcomes &lt;- rnorm(20)
blocking_estimator(my_outcomes, my_blocking, my_treatments)

# Three treatment conditions
my_treatments &lt;- assign_treatment(my_blocking, c("T1", "T2", "C"))
my_outcomes &lt;- rnorm(20)
blocking_estimator(my_outcomes, my_blocking, my_treatments)

# Four treatment conditions
# (This will throw an error because variances cannot be estimated)
my_treatments &lt;- assign_treatment(my_blocking, c("T1", "T2", "T3", "C"))
my_outcomes &lt;- rnorm(20)
## Not run: blocking_estimator(my_outcomes, my_blocking, my_treatments)

</code></pre>

<hr>
<h2 id='is.qb_blocking'>Check qb_blocking object</h2><span id='topic+is.qb_blocking'></span>

<h3>Description</h3>

<p><code>is.qb_blocking</code> checks whether the provided object is a valid instance
of the <code><a href="#topic+qb_blocking">qb_blocking</a></code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.qb_blocking(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.qb_blocking_+3A_x">x</code></td>
<td>
<p>object to check.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>is.qb_blocking</code> does not check whether the blocking itself is sensible
or whether it satisfies some set of constraints. See
<code><a href="scclust.html#topic+check_clustering">check_clustering</a></code> for that functionality.
</p>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if <code>x</code> is a valid <code><a href="#topic+qb_blocking">qb_blocking</a></code>
object, otherwise <code>FALSE</code>.
</p>

<hr>
<h2 id='qb_blocking'>Constructor for qb_blocking objects</h2><span id='topic+qb_blocking'></span>

<h3>Description</h3>

<p>The <code>qb_blocking</code> function constructs a <code>qb_blocking</code> object from
existing block labels. The function does not derive blockings from
sets of data points; see <code><a href="#topic+quickblock">quickblock</a></code> for that functionality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qb_blocking(block_labels, unassigned_labels = NULL, ids = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qb_blocking_+3A_block_labels">block_labels</code></td>
<td>
<p>a vector containing each unit's block label.</p>
</td></tr>
<tr><td><code id="qb_blocking_+3A_unassigned_labels">unassigned_labels</code></td>
<td>
<p>labels that denote unassigned units. If <code>NULL</code>, <code>NA</code> values in
<code>block_labels</code> are used to denote unassigned units.</p>
</td></tr>
<tr><td><code id="qb_blocking_+3A_ids">ids</code></td>
<td>
<p>IDs of the units. Should be a vector of the same length as
<code>block_labels</code> or <code>NULL</code>. If <code>NULL</code>, the IDs are set to
<code>1:length(group_labels)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>qb_blocking</code> objects are based on integer vectors, and it indexes
the blocks starting with zero. The <code>qb_blocking</code> class inherits
from the <code><a href="scclust.html#topic+scclust">scclust</a></code> class.
</p>


<h3>Value</h3>

<p>Returns a <code>qb_blocking</code> object with the blocking described by the
provided labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 10 units in 3 blocks
blocking1 &lt;- qb_blocking(c("A", "A", "B", "C", "B",
                           "C", "C", "A", "B", "B"))

# 8 units in 3 blocks, 2 units unassigned
blocking2 &lt;- qb_blocking(c(1, 1, 2, 3, 2,
                           NA, 3, 1, NA, 2))

# Custom labels indicating unassigned units
blocking3 &lt;- qb_blocking(c("A", "A", "B", "C", "NONE",
                           "C", "C", "NONE", "B", "B"),
                        unassigned_labels = "NONE")

# Two different labels indicating unassigned units
blocking4 &lt;- qb_blocking(c("A", "A", "B", "C", "NONE",
                           "C", "C", "0", "B", "B"),
                        unassigned_labels = c("NONE", "0"))

# Custom unit IDs
blocking5 &lt;- qb_blocking(c("A", "A", "B", "C", "B",
                           "C", "C", "A", "B", "B"),
                        ids = letters[1:10])

</code></pre>

<hr>
<h2 id='quickblock'>Construct threshold blockings</h2><span id='topic+quickblock'></span>

<h3>Description</h3>

<p><code>quickblock</code> constructs near-optimal threshold blockings. The function
expects the user to provide distances measuring the similarity of
units and a required minimum block size. It then constructs a blocking
so that units assigned to the same block are as similar as possible while
satisfying the minimum block size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quickblock(
  distances,
  size_constraint = 2L,
  caliper = NULL,
  break_large_blocks = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="quickblock_+3A_distances">distances</code></td>
<td>
<p><code><a href="distances.html#topic+distances">distances</a></code> object or a numeric vector, matrix
or data frame. The parameter describes the similarity of the units to be
blocked. It can either be preprocessed distance information using a
<code><a href="distances.html#topic+distances">distances</a></code> object, or raw covariate data. When
called with covariate data, Euclidean distances are calculated unless
otherwise specified.</p>
</td></tr>
<tr><td><code id="quickblock_+3A_size_constraint">size_constraint</code></td>
<td>
<p>integer with the required minimum number of units in each block.</p>
</td></tr>
<tr><td><code id="quickblock_+3A_caliper">caliper</code></td>
<td>
<p>restrict the maximum within-block distance.</p>
</td></tr>
<tr><td><code id="quickblock_+3A_break_large_blocks">break_large_blocks</code></td>
<td>
<p>logical indicating whether large blocks should be broken up into smaller blocks.</p>
</td></tr>
<tr><td><code id="quickblock_+3A_...">...</code></td>
<td>
<p>additional parameters to be sent either to the <code><a href="distances.html#topic+distances">distances</a></code>
function when the <code>distances</code> parameter contains covariate data, or
to the underlying <code><a href="scclust.html#topic+sc_clustering">sc_clustering</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>caliper</code> parameter constrains the maximum distance between units
assigned to the same block. This is implemented by restricting the
edge weight in the graph used to construct the blocks (see
<code><a href="scclust.html#topic+sc_clustering">sc_clustering</a></code> for details). As a result, the caliper
will affect all blocks and, in general, make it harder for
the function to find good matches even for blocks where the caliper is not
binding. In particular, a too tight <code>caliper</code> can lead to discarded
units that otherwise would be assigned to a block satisfying both the
matching constraints and the caliper. For this reason, it is recommended
to set the <code>caliper</code> value quite high and only use it to avoid particularly
poor blocks. It strongly recommended to use the <code>caliper</code> parameter only
when <code>primary_unassigned_method = "closest_seed"</code> in the underlying
<code><a href="scclust.html#topic+sc_clustering">sc_clustering</a></code> function (which is the default
behavior).
</p>
<p>The main algorithm used to construct the blocking may produce
some blocks that are much larger than the minimum size constraint. If
<code>break_large_blocks</code> is <code>TRUE</code>, all blocks twice as large as
<code>size_constraint</code> will be broken into two or more smaller blocks. Block
are broken so to ensure that the new blocks satisfy the size constraint.
In general, large blocks are produced when units are highly clustered,
so breaking up large blocks will often only lead to small improvements. The
blocks are broken using the <code><a href="scclust.html#topic+hierarchical_clustering">hierarchical_clustering</a></code>
function.
</p>
<p><code>quickblock</code> calls <code><a href="scclust.html#topic+sc_clustering">sc_clustering</a></code> with
<code>seed_method = "inwards_updating"</code>. The <code>seed_method</code> parameter
governs how the seeds are selected in the nearest neighborhood graph that
is used to construct the blocks (see <code><a href="scclust.html#topic+sc_clustering">sc_clustering</a></code>
for details). The <code>"inwards_updating"</code> option generally works well
and is safe with most datasets. Using <code>seed_method = "exclusion_updating"</code>
often leads to better performance (in the sense of blocks with more
similar units), but it may increase run time. Discrete data (or more generally
when units tend to be at equal distance to many other units) will lead to
particularly poor run time with this option. If the dataset has at least one
continuous covariate, <code>"exclusion_updating"</code> is typically quick. A third
option is <code>seed_method = "lexical"</code>, which decreases the run time relative
to <code>"inwards_updating"</code> (sometimes considerably) at the cost of performance.
<code>quickblock</code> passes parameters on to <code><a href="scclust.html#topic+sc_clustering">sc_clustering</a></code>,
so to change <code>seed_method</code>, call <code>quickblock</code> with the parameter
specified as usual: <code>quickblock(..., seed_method = "exclusion_updating")</code>.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="#topic+qb_blocking">qb_blocking</a></code> object with the constructed blocks.
</p>


<h3>References</h3>

<p>Higgins, Michael J., Fredrik Sävje and Jasjeet S. Sekhon (2016),
&lsquo;Improving massive experiments with threshold blocking&rsquo;,
<em>Proceedings of the National Academy of Sciences</em>, <b>113:27</b>, 7369&ndash;7376.
</p>


<h3>See Also</h3>

<p>See <code><a href="scclust.html#topic+sc_clustering">sc_clustering</a></code> for the underlying function used
to construct the blocks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct example data
my_data &lt;- data.frame(x1 = runif(100),
                      x2 = runif(100))

# Make distances
my_distances &lt;- distances(my_data, dist_variables = c("x1", "x2"))

# Make blocking with at least two units in each block
quickblock(my_distances)

# Require at least three units in each block
quickblock(my_distances, size_constraint = 3)

# Impose caliper
quickblock(my_distances, caliper = 0.2)

# Break large block
quickblock(my_distances, break_large_blocks = TRUE)

# Call `quickblock` directly with covariate data (ie., not pre-calculating distances)
quickblock(my_data[c("x1", "x2")])

# Call `quickblock` directly with covariate data using Mahalanobis distances
quickblock(my_data[c("x1", "x2")], normalize = "mahalanobize")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
