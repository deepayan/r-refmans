<!DOCTYPE html><html lang="en"><head><title>Help for package CEGO</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {CEGO}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CEGO-package'><p>Combinatorial Efficient Global Optimization in R</p></a></li>
<li><a href='#benchmarkGeneratorFSP'><p>Create Flow shop Scheduling Problem (FSP) Benchmark</p></a></li>
<li><a href='#benchmarkGeneratorMaxCut'><p>MaxCut Benchmark Creation</p></a></li>
<li><a href='#benchmarkGeneratorNKL'><p>NK-Landscape Benchmark Creation</p></a></li>
<li><a href='#benchmarkGeneratorQAP'><p>Create Quadratic Assignment Problem (QAP) Benchmark</p></a></li>
<li><a href='#benchmarkGeneratorTSP'><p>Create (Asymmetric) Travelling Salesperson Problem (TSP) Benchmark</p></a></li>
<li><a href='#benchmarkGeneratorWT'><p>Create single-machine total Weighted Tardiness (WT) Problem Benchmark</p></a></li>
<li><a href='#buildModel'><p>Model building</p></a></li>
<li><a href='#combinatorialLM'><p>Linear Distance-Based Model</p></a></li>
<li><a href='#combinatorialRBFN'><p>Radial Basis Function Network</p></a></li>
<li><a href='#computeCorrelationMatrix'><p>Compute Correlation Matrix</p></a></li>
<li><a href='#correctionAugmentedDistanceVector'><p>Augmented Distance Correction</p></a></li>
<li><a href='#correctionAugmentedKernelVector'><p>Augmented Kernel Correction</p></a></li>
<li><a href='#correctionCNSD'><p>Correcting Conditional Negative Semi-Definiteness</p></a></li>
<li><a href='#correctionDefinite'><p>Correcting Definiteness of a Matrix</p></a></li>
<li><a href='#correctionDistanceMatrix'><p>Correction of a Distance Matrix</p></a></li>
<li><a href='#correctionKernelMatrix'><p>Correction of a Kernel (Correlation) Matrix</p></a></li>
<li><a href='#createSimulatedTestFunction'><p>Simulation-based Test Function Generator, Object Interface</p></a></li>
<li><a href='#designMaxMinDist'><p>Max-Min-Distance Design</p></a></li>
<li><a href='#designRandom'><p>Random Design</p></a></li>
<li><a href='#distanceMatrix'><p>Calculate Distance Matrix</p></a></li>
<li><a href='#distanceMatrixUpdate'><p>Update distance matrix</p></a></li>
<li><a href='#distanceMatrixWrapper'><p>Distance Matrix Wrapper</p></a></li>
<li><a href='#distanceNumericHamming'><p>Hamming Distance for Vectors</p></a></li>
<li><a href='#distanceNumericLCStr'><p>Longest Common Substring for Numeric Vectors</p></a></li>
<li><a href='#distanceNumericLevenshtein'><p>Levenshtein Distance for Numeric Vectors</p></a></li>
<li><a href='#distancePermutationAdjacency'><p>Adjacency Distance for Permutations</p></a></li>
<li><a href='#distancePermutationChebyshev'><p>Chebyshev Distance for Permutations</p></a></li>
<li><a href='#distancePermutationCos'><p>Cosine Distance for Permutations</p></a></li>
<li><a href='#distancePermutationEuclidean'><p>Euclidean Distance for Permutations</p></a></li>
<li><a href='#distancePermutationHamming'><p>Hamming Distance for Permutations</p></a></li>
<li><a href='#distancePermutationInsert'><p>Insert Distance for Permutations</p></a></li>
<li><a href='#distancePermutationInterchange'><p>Interchange Distance for Permutations</p></a></li>
<li><a href='#distancePermutationLCStr'><p>Longest Common Substring Distance for Permutations</p></a></li>
<li><a href='#distancePermutationLee'><p>Lee Distance for Permutations</p></a></li>
<li><a href='#distancePermutationLevenshtein'><p>Levenshtein Distance for Permutations</p></a></li>
<li><a href='#distancePermutationLex'><p>Lexicographic permutation distance</p></a></li>
<li><a href='#distancePermutationManhattan'><p>Manhattan Distance for Permutations</p></a></li>
<li><a href='#distancePermutationPosition'><p>Position Distance for Permutations</p></a></li>
<li><a href='#distancePermutationPosition2'><p>Squared Position Distance for Permutations</p></a></li>
<li><a href='#distancePermutationR'><p>R-Distance for Permutations</p></a></li>
<li><a href='#distancePermutationSwap'><p>Swap-Distance for Permutations</p></a></li>
<li><a href='#distancePermutationSwapInv'><p>Inverse-Swap-Distance for Permutations</p></a></li>
<li><a href='#distanceRealEuclidean'><p>Euclidean Distance</p></a></li>
<li><a href='#distanceSequenceLevenshtein'><p>Levenshtein Distance forsSequences of numbers</p></a></li>
<li><a href='#distanceStringHamming'><p>Hamming Distance for Strings</p></a></li>
<li><a href='#distanceStringLCStr'><p>Longest Common Substring distance</p></a></li>
<li><a href='#distanceStringLevenshtein'><p>Levenshtein Distance for Strings</p></a></li>
<li><a href='#distanceVector'><p>Calculate Distance Vector</p></a></li>
<li><a href='#fcorrCubic'><p>Cubic Kernel for Kriging</p></a></li>
<li><a href='#fcorrGauss'><p>Gaussian Kernel for Kriging</p></a></li>
<li><a href='#fcorrLinear'><p>Linear Kernel for Kriging</p></a></li>
<li><a href='#fcorrSphere'><p>Spherical Kernel for Kriging</p></a></li>
<li><a href='#infillExpectedImprovement'><p>Negative Logarithm of Expected Improvement</p></a></li>
<li><a href='#is.CNSD'><p>Check for Conditional Negative Semi-Definiteness</p></a></li>
<li><a href='#is.NSD'><p>Check for Negative Semi-Definiteness</p></a></li>
<li><a href='#is.PSD'><p>Check for Positive Semi-Definiteness</p></a></li>
<li><a href='#kernelMatrix'><p>Calculate Kernel Matrix</p></a></li>
<li><a href='#landscapeGeneratorGaussian'><p>Create Gaussian Landscape</p></a></li>
<li><a href='#landscapeGeneratorGaussianBuild'><p>Gaussian Landscape Core function</p></a></li>
<li><a href='#landscapeGeneratorGaussianEval'><p>Gaussian Landscape Evaluation</p></a></li>
<li><a href='#landscapeGeneratorMUL'><p>Multimodal Fitness Landscape</p></a></li>
<li><a href='#landscapeGeneratorUNI'><p>Unimodal Fitness Landscape</p></a></li>
<li><a href='#lexicographicPermutationOrderNumber'><p>Lexicographic order number</p></a></li>
<li><a href='#modelKriging'><p>Kriging Model</p></a></li>
<li><a href='#modelKrigingClust'><p>Build clustered model</p></a></li>
<li><a href='#modelKrigingDistanceCalculation'><p>Kriging: Distance Matrix Calculation</p></a></li>
<li><a href='#modelKrigingInit'><p>Kriging: Initial guess and bounds</p></a></li>
<li><a href='#modelKrigingInternalPredictor'><p>Kriging Prediction (internal)</p></a></li>
<li><a href='#modelKrigingLikelihood'><p>Calculate negative log-likelihood</p></a></li>
<li><a href='#modelKrigingParameterizedLikelihood'><p>Calculate negative log-likelihood</p></a></li>
<li><a href='#modelLinear'><p>Distance based Linear Model</p></a></li>
<li><a href='#modelRBFN'><p>RBFN Model</p></a></li>
<li><a href='#mutationBinaryBitFlip'><p>Bit-flip Mutation for Bit-strings</p></a></li>
<li><a href='#mutationBinaryBlockInversion'><p>Block Inversion Mutation for Bit-strings</p></a></li>
<li><a href='#mutationBinaryCycle'><p>Cycle Mutation for Bit-strings</p></a></li>
<li><a href='#mutationBinarySingleBitFlip'><p>Single Bit-flip Mutation for Bit-strings</p></a></li>
<li><a href='#mutationPermutationInsert'><p>Insert Mutation for Permutations</p></a></li>
<li><a href='#mutationPermutationInterchange'><p>Interchange Mutation for Permutations</p></a></li>
<li><a href='#mutationPermutationInterchangeCore'><p>Interchange of permutation elements</p></a></li>
<li><a href='#mutationPermutationReversal'><p>Reversal Mutation for Permutations</p></a></li>
<li><a href='#mutationPermutationSwap'><p>Swap Mutation for Permutations</p></a></li>
<li><a href='#mutationSelfAdapt'><p>Self-adaptive mutation operator</p></a></li>
<li><a href='#mutationStringRandomChange'><p>Mutation for Strings</p></a></li>
<li><a href='#nearCNSD'><p>Nearest CNSD matrix</p></a></li>
<li><a href='#optim2Opt'><p>Two-Opt</p></a></li>
<li><a href='#optimCEGO'><p>Combinatorial Efficient Global Optimization</p></a></li>
<li><a href='#optimEA'><p>Evolutionary Algorithm for Combinatorial Optimization</p></a></li>
<li><a href='#optimInterface'><p>Optimization Interface (continuous, bounded)</p></a></li>
<li><a href='#optimizeModel'><p>Optimize Surrogate Model</p></a></li>
<li><a href='#optimMaxMinDist'><p>Max-Min-Distance Optimizer</p></a></li>
<li><a href='#optimMIES'><p>Mixed Integer Evolution Strategy (MIES)</p></a></li>
<li><a href='#optimRS'><p>Combinatorial Random Search</p></a></li>
<li><a href='#predict.modelKriging'><p>Kriging Prediction</p></a></li>
<li><a href='#predict.modelKrigingClust'><p>Clustered Kriging Prediction</p></a></li>
<li><a href='#predict.modelLinear'><p>Predict: Combinatorial Kriging</p></a></li>
<li><a href='#predict.modelRBFN'><p>Predict: Combinatorial RBFN</p></a></li>
<li><a href='#print.modelKriging'><p>Print Function: modelKriging</p></a></li>
<li><a href='#recombinationBinary1Point'><p>Single Point Crossover for Bit Strings</p></a></li>
<li><a href='#recombinationBinary2Point'><p>Two Point Crossover for Bit Strings</p></a></li>
<li><a href='#recombinationBinaryAnd'><p>Arithmetic (AND) Crossover for Bit Strings</p></a></li>
<li><a href='#recombinationBinaryUniform'><p>Uniform Crossover for Bit Strings</p></a></li>
<li><a href='#recombinationPermutationAlternatingPosition'><p>Alternating Position Crossover (AP) for Permutations</p></a></li>
<li><a href='#recombinationPermutationCycleCrossover'><p>Cycle Crossover (CX) for Permutations</p></a></li>
<li><a href='#recombinationPermutationOrderCrossover1'><p>Order Crossover 1 (OX1) for Permutations</p></a></li>
<li><a href='#recombinationPermutationPositionBased'><p>Position Based Crossover (POS) for Permutations</p></a></li>
<li><a href='#recombinationSelfAdapt'><p>Self-adaptive recombination operator</p></a></li>
<li><a href='#recombinationStringSinglePointCrossover'><p>Single Point Crossover for Strings</p></a></li>
<li><a href='#removeDuplicates'><p>Remove Duplicates</p></a></li>
<li><a href='#removeDuplicatesOffspring'><p>Remove Duplicates from Offsprings</p></a></li>
<li><a href='#repairConditionsCorrelationMatrix'><p>Repair Conditions of a Correlation Matrix</p></a></li>
<li><a href='#repairConditionsDistanceMatrix'><p>Repair Conditions of a Distance Matrix</p></a></li>
<li><a href='#selfAdapt'><p>Self-adaption of EA parameters.</p></a></li>
<li><a href='#simulate.modelKriging'><p>Kriging Simulation</p></a></li>
<li><a href='#solutionFunctionGeneratorBinary'><p>Binary String Generator Function</p></a></li>
<li><a href='#solutionFunctionGeneratorPermutation'><p>Permutation Generator Function</p></a></li>
<li><a href='#solutionFunctionGeneratorString'><p>String Generator Function</p></a></li>
<li><a href='#step2Opt'><p>2-Opt Step</p></a></li>
<li><a href='#testFunctionGeneratorSim'><p>Simulation-based Test Function Generator, Data Interface</p></a></li>
<li><a href='#tournamentSelection'><p>Tournament Selection</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>2.4.4</td>
</tr>
<tr>
<td>Title:</td>
<td>Combinatorial Efficient Global Optimization</td>
</tr>
<tr>
<td>Description:</td>
<td>Model building, surrogate model
    based optimization and Efficient Global Optimization in combinatorial
    or mixed search spaces.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>MASS, stats, DEoptim, graphics, quadprog, Matrix, methods,
fastmatch, anticlust</td>
</tr>
<tr>
<td>Suggests:</td>
<td>nloptr</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-09</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-09 20:31:05 UTC; Martin</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Zaefferer [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Zaefferer &lt;mzaefferer@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-09 21:10:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='CEGO-package'>Combinatorial Efficient Global Optimization in R</h2><span id='topic+CEGO'></span><span id='topic+CEGO-package'></span>

<h3>Description</h3>

<p>Combinatorial Efficient Global Optimization
</p>


<h3>Details</h3>

<p>Model building, surrogate model
based optimization and Efficient Global Optimization in combinatorial
or mixed search spaces. This includes methods for distance calculation,
modeling and handling of indefinite kernels/distances.
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> CEGO</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.4.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2024-01-27</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (&gt;= 3)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Acknowledgments</h3>

<p>This work has been partially supported by the Federal Ministry of Education
and Research (BMBF) under the grants CIMO (FKZ 17002X11) and
MCIOP (FKZ 17N0311).
</p>


<h3>Author(s)</h3>

<p>Martin Zaefferer <a href="mailto:mzaefferer@gmail.com">mzaefferer@gmail.com</a>
</p>


<h3>References</h3>

<p>Zaefferer, Martin; Stork, Joerg; Friese, Martina; Fischbach, Andreas; Naujoks, Boris; Bartz-Beielstein, Thomas. (2014). Efficient global optimization for combinatorial problems. In Proceedings of the 2014 conference on Genetic and evolutionary computation (GECCO '14). ACM, New York, NY, USA, 871-878. DOI=10.1145/2576768.2598282
</p>
<p>Zaefferer, Martin; Stork, Joerg; Bartz-Beielstein, Thomas. (2014). Distance Measures for Permutations in Combinatorial Efficient Global Optimization. In Parallel Problem Solving from Nature - PPSN XIII (p. 373-383). Springer International Publishing.
</p>
<p>Zaefferer, Martin and Bartz-Beielstein, Thomas (2016). Efficient Global Optimization with Indefinite Kernels. Parallel Problem Solving from Nature-PPSN XIV. Accepted, in press. Springer.
</p>


<h3>See Also</h3>

<p>Interface of main function: <code><a href="#topic+optimCEGO">optimCEGO</a></code>
</p>

<hr>
<h2 id='benchmarkGeneratorFSP'>Create Flow shop Scheduling Problem (FSP) Benchmark</h2><span id='topic+benchmarkGeneratorFSP'></span>

<h3>Description</h3>

<p>Creates a benchmark function for the Flow shop Scheduling Problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benchmarkGeneratorFSP(a, n, m)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="benchmarkGeneratorFSP_+3A_a">a</code></td>
<td>
<p>matrix of processing times for each step and each machine</p>
</td></tr>
<tr><td><code id="benchmarkGeneratorFSP_+3A_n">n</code></td>
<td>
<p>number of jobs</p>
</td></tr>
<tr><td><code id="benchmarkGeneratorFSP_+3A_m">m</code></td>
<td>
<p>number of machines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function of type cost=f(permutation)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+benchmarkGeneratorQAP">benchmarkGeneratorQAP</a></code>, <code><a href="#topic+benchmarkGeneratorTSP">benchmarkGeneratorTSP</a></code>, <code><a href="#topic+benchmarkGeneratorWT">benchmarkGeneratorWT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=10
m=4
#ceate a matrix of processing times
A &lt;- matrix(sample(n*m,replace=TRUE),n,m) 
#create FSP objective function 
fun &lt;- benchmarkGeneratorFSP(A,n,m)
#evaluate
fun(1:n)
fun(n:1)

</code></pre>

<hr>
<h2 id='benchmarkGeneratorMaxCut'>MaxCut Benchmark Creation</h2><span id='topic+benchmarkGeneratorMaxCut'></span>

<h3>Description</h3>

<p>Generates MaxCut problems, with binary decision variables.
The MaxCut Problems are transformed to minimization problems by negation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benchmarkGeneratorMaxCut(N, A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="benchmarkGeneratorMaxCut_+3A_n">N</code></td>
<td>
<p>length of the bit strings</p>
</td></tr>
<tr><td><code id="benchmarkGeneratorMaxCut_+3A_a">A</code></td>
<td>
<p>The adjacency matrix of the graph. Will be created at random if not provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function of type cost=f(bitstring). Returned fitness values will be negative, for purpose of minimization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fun &lt;- benchmarkGeneratorMaxCut(N=6)
fun(c(1,0,1,1,0,0))
fun(c(1,0,1,1,0,1))
fun(c(0,1,0,0,1,1))
fun &lt;- benchmarkGeneratorMaxCut(A=matrix(c(0,1,0,1,1,0,1,0,0,1,0,1,1,0,1,0),4,4))
fun(c(1,0,1,0))
fun(c(1,0,1,1))
fun(c(0,1,0,1))

</code></pre>

<hr>
<h2 id='benchmarkGeneratorNKL'>NK-Landscape Benchmark Creation</h2><span id='topic+benchmarkGeneratorNKL'></span>

<h3>Description</h3>

<p>Function that generates a NK-Landscapes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benchmarkGeneratorNKL(N = 10, K = 1, PI = 1:K, g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="benchmarkGeneratorNKL_+3A_n">N</code></td>
<td>
<p>length of the bit strings</p>
</td></tr>
<tr><td><code id="benchmarkGeneratorNKL_+3A_k">K</code></td>
<td>
<p>number of neighbours contributing to fitness of one position</p>
</td></tr>
<tr><td><code id="benchmarkGeneratorNKL_+3A_pi">PI</code></td>
<td>
<p>vector, giving relative positions of each neighbour in the bit-string</p>
</td></tr>
<tr><td><code id="benchmarkGeneratorNKL_+3A_g">g</code></td>
<td>
<p>set of fitness functions for each possible combination of string components. Will be randomly determined if not specified. Should have N rows, and 2^(K+1) columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function of type cost=f(bitstring). Returned fitness values will be negative, for purpose of minimization.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fun &lt;- benchmarkGeneratorNKL(6,2)
fun(c(1,0,1,1,0,0))
fun(c(1,0,1,1,0,1))
fun(c(0,1,0,0,1,1))
fun &lt;- benchmarkGeneratorNKL(6,3)
fun(c(1,0,1,1,0,0))
fun &lt;- benchmarkGeneratorNKL(6,2,c(-1,1))
fun(c(1,0,1,1,0,0))
fun &lt;- benchmarkGeneratorNKL(6,2,c(-1,1),g=matrix(runif(48),6))
fun(c(1,0,1,1,0,0))
fun(sample(c(0,1),6,TRUE))

</code></pre>

<hr>
<h2 id='benchmarkGeneratorQAP'>Create Quadratic Assignment Problem (QAP) Benchmark</h2><span id='topic+benchmarkGeneratorQAP'></span>

<h3>Description</h3>

<p>Creates a benchmark function for the Quadratic Assignment Problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benchmarkGeneratorQAP(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="benchmarkGeneratorQAP_+3A_a">a</code></td>
<td>
<p>distance matrix</p>
</td></tr>
<tr><td><code id="benchmarkGeneratorQAP_+3A_b">b</code></td>
<td>
<p>flow matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function of type cost=f(permutation)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+benchmarkGeneratorFSP">benchmarkGeneratorFSP</a></code>, <code><a href="#topic+benchmarkGeneratorTSP">benchmarkGeneratorTSP</a></code>, <code><a href="#topic+benchmarkGeneratorWT">benchmarkGeneratorWT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
n=5
#ceate a flow matrix
A &lt;- matrix(0,n,n) 
for(i in 1:n){
	for(j in i:n){
		if(i!=j){
			A[i,j] &lt;- sample(100,1)
			A[j,i] &lt;- A[i,j]
 	}
	}
}
#create a distance matrix
locations &lt;- matrix(runif(n*2)*10,,2)
B &lt;- as.matrix(dist(locations))
#create QAP objective function 
fun &lt;- benchmarkGeneratorQAP(A,B)
#evaluate
fun(1:n)
fun(n:1)

</code></pre>

<hr>
<h2 id='benchmarkGeneratorTSP'>Create (Asymmetric) Travelling Salesperson Problem (TSP) Benchmark</h2><span id='topic+benchmarkGeneratorTSP'></span>

<h3>Description</h3>

<p>Creates a benchmark function for the (Asymmetric) Travelling Salesperson Problem.
Path (Do not return to start of tour. Start and end of tour not fixed.) 
or Cycle (Return to start of tour). Symmetry depends on supplied distance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benchmarkGeneratorTSP(distanceMatrix, type = "Cycle")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="benchmarkGeneratorTSP_+3A_distancematrix">distanceMatrix</code></td>
<td>
<p>Matrix that collects the distances between travelled locations.</p>
</td></tr>
<tr><td><code id="benchmarkGeneratorTSP_+3A_type">type</code></td>
<td>
<p>Can be &quot;Cycle&quot; (return to start, default) or &quot;Path&quot; (no return to start).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function of type cost=f(permutation)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+benchmarkGeneratorQAP">benchmarkGeneratorQAP</a></code>, <code><a href="#topic+benchmarkGeneratorFSP">benchmarkGeneratorFSP</a></code>, <code><a href="#topic+benchmarkGeneratorWT">benchmarkGeneratorWT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
#create 5 random locations to be part of a tour
n=5
cities &lt;- matrix(runif(2*n),,2)
#calculate distances between cities
cdist &lt;- as.matrix(dist(cities))
#create objective functions (for path or cycle)
fun1 &lt;- benchmarkGeneratorTSP(cdist, "Path") 
fun2 &lt;- benchmarkGeneratorTSP(cdist, "Cycle") 
#evaluate
fun1(1:n)
fun1(n:1)
fun2(n:1)
fun2(1:n)

</code></pre>

<hr>
<h2 id='benchmarkGeneratorWT'>Create single-machine total Weighted Tardiness (WT) Problem Benchmark</h2><span id='topic+benchmarkGeneratorWT'></span>

<h3>Description</h3>

<p>Creates a benchmark function for the single-machine total Weighted Tardiness Problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benchmarkGeneratorWT(p, w, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="benchmarkGeneratorWT_+3A_p">p</code></td>
<td>
<p>processing times</p>
</td></tr>
<tr><td><code id="benchmarkGeneratorWT_+3A_w">w</code></td>
<td>
<p>weights</p>
</td></tr>
<tr><td><code id="benchmarkGeneratorWT_+3A_d">d</code></td>
<td>
<p>due dates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the function of type cost=f(permutation)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+benchmarkGeneratorQAP">benchmarkGeneratorQAP</a></code>, <code><a href="#topic+benchmarkGeneratorTSP">benchmarkGeneratorTSP</a></code>, <code><a href="#topic+benchmarkGeneratorFSP">benchmarkGeneratorFSP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n=6
#processing times
p &lt;- sample(100,n,replace=TRUE)
#weights
w &lt;- sample(10,n,replace=TRUE)
#due dates
RDD &lt;- c(0.2, 0.4, 0.6,0.8,1.0)
TF &lt;- c(0.2, 0.4, 0.6,0.8,1.0)
i &lt;- 1
j &lt;- 1
P &lt;- sum(p)
d &lt;- runif(n,min=P*(1-TF[i]-RDD[j]/2),max=P*(1-TF[i]+RDD[j]/2))
#create WT objective function
fun &lt;- benchmarkGeneratorWT(p,w,d)
fun(1:n)
fun(n:1)	

</code></pre>

<hr>
<h2 id='buildModel'>Model building</h2><span id='topic+buildModel'></span>

<h3>Description</h3>

<p>Model building support function for optimCEGO. Should not be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildModel(res, distanceFunction, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildModel_+3A_res">res</code></td>
<td>
<p>list with elements: (x) list of samples in input space and (y)
matrix, column vector of observations for each sample</p>
</td></tr>
<tr><td><code id="buildModel_+3A_distancefunction">distanceFunction</code></td>
<td>
<p>a suitable distance function of type f(x1,x2), returning a scalar distance value, preferably between 0 and 1.
Maximum distances larger 1 are no problem, but may yield scaling bias when different measures are compared.
Should be non-negative and symmetric.  In case Kriging is chosen, it can also be a list of several distance functions. In this case, MLE is used 
to determine the most suited distance measure (see the last reference).</p>
</td></tr>
<tr><td><code id="buildModel_+3A_control">control</code></td>
<td>
<p>list with options:
</p>

<dl>
<dt><code>model</code></dt><dd><p> Model to be used as a surrogate of the target function. Default is &quot;K&quot; (Kriging). Also
available are: &quot;LM&quot; (linear, distance-based model), &quot;RBFN&quot; Radial Basis Function Network.</p>
</dd>
<dt><code>modelSettings</code></dt><dd><p> List of settings for model building, passed on as the control argument to the model training functions <code><a href="#topic+modelKriging">modelKriging</a></code>, <code><a href="#topic+modelLinear">modelLinear</a></code>, <code><a href="#topic+modelRBFN">modelRBFN</a></code>.</p>
</dd>
<dt><code>infill</code></dt><dd><p> This parameter specifies a function to be used for the infill criterion (e.g., the default is expected improvement <code>infillExpectedImprovement</code>).
To use no specific infill criterion this has to be set to <code>NA</code>. Infill criteria are only used with models that may provide some error estimate with predictions.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a list:
</p>

<dl>
<dt><code>fit</code></dt><dd><p> model-fit </p>
</dd>
<dt><code>fpred</code></dt><dd><p> prediction function</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+optimCEGO">optimCEGO</a></code>
</p>

<hr>
<h2 id='combinatorialLM'>Linear Distance-Based Model</h2><span id='topic+combinatorialLM'></span>

<h3>Description</h3>

<p>DEPRECATED version of the linear, distance-based model, please use <code><a href="#topic+modelLinear">modelLinear</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combinatorialLM(x, y, distanceFunction, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combinatorialLM_+3A_x">x</code></td>
<td>
<p>list of samples in input space</p>
</td></tr>
<tr><td><code id="combinatorialLM_+3A_y">y</code></td>
<td>
<p>column vector of observations for each sample</p>
</td></tr>
<tr><td><code id="combinatorialLM_+3A_distancefunction">distanceFunction</code></td>
<td>
<p>a suitable distance function of type f(x1,x2), returning a scalar distance value</p>
</td></tr>
<tr><td><code id="combinatorialLM_+3A_control">control</code></td>
<td>
<p>options for the model building procedure</p>
</td></tr>
</table>

<hr>
<h2 id='combinatorialRBFN'>Radial Basis Function Network</h2><span id='topic+combinatorialRBFN'></span>

<h3>Description</h3>

<p>DEPRECATED version of the RBFN model, please use <code><a href="#topic+modelRBFN">modelRBFN</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combinatorialRBFN(x, y, distanceFunction, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combinatorialRBFN_+3A_x">x</code></td>
<td>
<p>list of samples in input space</p>
</td></tr>
<tr><td><code id="combinatorialRBFN_+3A_y">y</code></td>
<td>
<p>column vector of observations for each sample</p>
</td></tr>
<tr><td><code id="combinatorialRBFN_+3A_distancefunction">distanceFunction</code></td>
<td>
<p>a suitable distance function of type f(x1,x2), returning a scalar distance value</p>
</td></tr>
<tr><td><code id="combinatorialRBFN_+3A_control">control</code></td>
<td>
<p>options for the model building procedure</p>
</td></tr>
</table>

<hr>
<h2 id='computeCorrelationMatrix'>Compute Correlation Matrix</h2><span id='topic+computeCorrelationMatrix'></span>

<h3>Description</h3>

<p>Compute the correlation matrix of samples x, given the model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>computeCorrelationMatrix(object, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="computeCorrelationMatrix_+3A_object">object</code></td>
<td>
<p>fit of the Kriging model (settings and parameters), of class <code>modelKriging</code>.</p>
</td></tr>
<tr><td><code id="computeCorrelationMatrix_+3A_x">x</code></td>
<td>
<p>list of samples / data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the correlation matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.modelKriging">simulate.modelKriging</a></code>
</p>
<p><code><a href="#topic+predict.modelKriging">predict.modelKriging</a></code>
</p>

<hr>
<h2 id='correctionAugmentedDistanceVector'>Augmented Distance Correction</h2><span id='topic+correctionAugmentedDistanceVector'></span>

<h3>Description</h3>

<p>Correct new (test) distances, via correcting the augmented distance matrix. Internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctionAugmentedDistanceVector(d, object, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correctionAugmentedDistanceVector_+3A_d">d</code></td>
<td>
<p>new distance vector</p>
</td></tr>
<tr><td><code id="correctionAugmentedDistanceVector_+3A_object">object</code></td>
<td>
<p>a modelKriging fit</p>
</td></tr>
<tr><td><code id="correctionAugmentedDistanceVector_+3A_x">x</code></td>
<td>
<p>new samples (belonging to distances d)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of augmented, corrected distances
</p>


<h3>References</h3>

<p>Martin Zaefferer and Thomas Bartz-Beielstein. (2016). Efficient Global Optimization with Indefinite Kernels. Parallel Problem Solving from Nature-PPSN XIV. Accepted, in press. Springer.
</p>

<hr>
<h2 id='correctionAugmentedKernelVector'>Augmented Kernel Correction</h2><span id='topic+correctionAugmentedKernelVector'></span>

<h3>Description</h3>

<p>Correct new (test) kernel values, via correcting the augmented kernel matrix. Internal use only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctionAugmentedKernelVector(k, object, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correctionAugmentedKernelVector_+3A_k">k</code></td>
<td>
<p>new kernel value vector</p>
</td></tr>
<tr><td><code id="correctionAugmentedKernelVector_+3A_object">object</code></td>
<td>
<p>a modelKriging fit</p>
</td></tr>
<tr><td><code id="correctionAugmentedKernelVector_+3A_x">x</code></td>
<td>
<p>new samples (belonging to kernel values k)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of augmented, corrected kernel values
</p>


<h3>References</h3>

<p>Martin Zaefferer and Thomas Bartz-Beielstein. (2016). Efficient Global Optimization with Indefinite Kernels. Parallel Problem Solving from Nature-PPSN XIV. Accepted, in press. Springer.
</p>

<hr>
<h2 id='correctionCNSD'>Correcting Conditional Negative Semi-Definiteness</h2><span id='topic+correctionCNSD'></span>

<h3>Description</h3>

<p>Correcting, e.g., a distance matrix with chosen methods so that it becomes a CNSD matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctionCNSD(mat, method = "flip", tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correctionCNSD_+3A_mat">mat</code></td>
<td>
<p>symmetric matrix, which should be at least of size 3x3</p>
</td></tr>
<tr><td><code id="correctionCNSD_+3A_method">method</code></td>
<td>
<p>string that specifies method for correction: spectrum clip <code>"clip"</code>, spectrum flip <code>"flip"</code>, nearest definite matrix <code>"near"</code>, spectrum square<code>"square"</code>, spectrum diffusion <code>"diffusion"</code>.</p>
</td></tr>
<tr><td><code id="correctionCNSD_+3A_tol">tol</code></td>
<td>
<p>torelance value. Eigenvalues between <code>-tol</code> and <code>tol</code> are assumed to be zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the corrected CNSD matrix
</p>


<h3>References</h3>

<p>Martin Zaefferer and Thomas Bartz-Beielstein. (2016). Efficient Global Optimization with Indefinite Kernels. Parallel Problem Solving from Nature-PPSN XIV. Accepted, in press. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelKriging">modelKriging</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(c(2,1,4,3),c(2,4,3,1),c(4,2,1,3),c(4,3,2,1),c(1,4,3,2))
D &lt;- distanceMatrix(x,distancePermutationInsert)
is.CNSD(D) #matrix should not be CNSD
D &lt;- correctionCNSD(D)
is.CNSD(D) #matrix should now be CNSD
D
# note: to fix the negative distances, use repairConditionsDistanceMatrix. 
# Or else, use correctionDistanceMatrix.
</code></pre>

<hr>
<h2 id='correctionDefinite'>Correcting Definiteness of a Matrix</h2><span id='topic+correctionDefinite'></span>

<h3>Description</h3>

<p>Correcting a (possibly indefinite) symmetric matrix with chosen approach so that it will have desired definiteness type: positive or negative semi-definite (PSD, NSD).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctionDefinite(mat, type = "PSD", method = "flip", tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correctionDefinite_+3A_mat">mat</code></td>
<td>
<p>symmetric matrix</p>
</td></tr>
<tr><td><code id="correctionDefinite_+3A_type">type</code></td>
<td>
<p>string that specifies type of correction: <code>"PSD"</code>,<code>"NSD"</code> to enforce PSD or NSD matrices respectively.</p>
</td></tr>
<tr><td><code id="correctionDefinite_+3A_method">method</code></td>
<td>
<p>string that specifies method for correction: spectrum clip <code>"clip"</code>, spectrum flip <code>"flip"</code>, nearest definite matrix <code>"near"</code>, spectrum square<code>"square"</code>, spectrum diffusion <code>"diffusion"</code>.</p>
</td></tr>
<tr><td><code id="correctionDefinite_+3A_tol">tol</code></td>
<td>
<p>torelance value. Eigenvalues between <code>-tol</code> and <code>tol</code> are assumed to be zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with
</p>
 
<dl>
<dt><code>mat</code></dt><dd><p> corrected matrix</p>
</dd>
<dt><code>isIndefinite</code></dt><dd><p> boolean, whether original matrix was indefinite</p>
</dd>
<dt><code>lambda</code></dt><dd><p> the eigenvalues of the original matrix</p>
</dd>
<dt><code>lambdanew</code></dt><dd><p> the eigenvalues of the corrected matrix </p>
</dd>
<dt><code>U</code></dt><dd><p> the matrix of eigenvectors</p>
</dd>
<dt><code>a</code></dt><dd><p> the transformation vector</p>
</dd>
</dl>



<h3>References</h3>

<p>Martin Zaefferer and Thomas Bartz-Beielstein. (2016). Efficient Global Optimization with Indefinite Kernels. Parallel Problem Solving from Nature-PPSN XIV. Accepted, in press. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelKriging">modelKriging</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(c(2,1,4,3),c(2,4,3,1),c(4,2,1,3),c(4,3,2,1),c(1,4,3,2))
D &lt;- distanceMatrix(x,distancePermutationInsert)
is.NSD(D) #matrix should not be CNSD
D &lt;- correctionDefinite(D,type="NSD")$mat
is.NSD(D) #matrix should now be CNSD
# different example: PSD kernel
D &lt;- distanceMatrix(x,distancePermutationInsert)
K &lt;- exp(-0.01*D)
is.PSD(K)
K &lt;- correctionDefinite(K,type="PSD")$mat
is.PSD(K)
</code></pre>

<hr>
<h2 id='correctionDistanceMatrix'>Correction of a Distance Matrix</h2><span id='topic+correctionDistanceMatrix'></span>

<h3>Description</h3>

<p>Convert (possibly non-euclidean or non-metric) distance matrix with chosen approach so that it becomes a CNSD matrix.
Optionally, the resulting matrix is enforced to have positive elements and zero diagonal, with the <code>repair</code> parameter.
Essentially, this is a combination of functions <code><a href="#topic+correctionDefinite">correctionDefinite</a></code> or <code><a href="#topic+correctionCNSD">correctionCNSD</a></code> with <code><a href="#topic+repairConditionsDistanceMatrix">repairConditionsDistanceMatrix</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctionDistanceMatrix(
  mat,
  type = "NSD",
  method = "flip",
  repair = TRUE,
  tol = 1e-08
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correctionDistanceMatrix_+3A_mat">mat</code></td>
<td>
<p>symmetric distance matrix</p>
</td></tr>
<tr><td><code id="correctionDistanceMatrix_+3A_type">type</code></td>
<td>
<p>string that specifies type of correction: <code>"CNSD"</code>,<code>"NSD"</code> to enforce CNSD or NSD matrices respectively.</p>
</td></tr>
<tr><td><code id="correctionDistanceMatrix_+3A_method">method</code></td>
<td>
<p>string that specifies method for correction: spectrum clip <code>"clip"</code>, spectrum flip <code>"flip"</code>, nearest definite matrix <code>"near"</code>, spectrum square<code>"square"</code>, spectrum diffusion <code>"diffusion"</code>, feature embedding <code>"feature"</code>.</p>
</td></tr>
<tr><td><code id="correctionDistanceMatrix_+3A_repair">repair</code></td>
<td>
<p>boolean, whether or not to use condition repair, so that elements are positive, and diagonal is zero.</p>
</td></tr>
<tr><td><code id="correctionDistanceMatrix_+3A_tol">tol</code></td>
<td>
<p>torelance value. Eigenvalues between <code>-tol</code> and <code>tol</code> are assumed to be zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with corrected distance matrix <code>mat</code>, <code>isCNSD</code> (boolean, whether original matrix was CNSD) and transformation matrix <code>A</code>.
</p>


<h3>References</h3>

<p>Martin Zaefferer and Thomas Bartz-Beielstein. (2016). Efficient Global Optimization with Indefinite Kernels. Parallel Problem Solving from Nature-PPSN XIV. Accepted, in press. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+correctionDefinite">correctionDefinite</a></code>,<code><a href="#topic+correctionCNSD">correctionCNSD</a></code>,<code><a href="#topic+repairConditionsDistanceMatrix">repairConditionsDistanceMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(c(2,1,4,3),c(2,4,3,1),c(4,2,1,3),c(4,3,2,1),c(1,4,3,2))
D &lt;- distanceMatrix(x,distancePermutationInsert)
is.CNSD(D) #matrix should not be CNSD
D &lt;- correctionDistanceMatrix(D)$mat
is.CNSD(D) #matrix should now be CNSD
D
</code></pre>

<hr>
<h2 id='correctionKernelMatrix'>Correction of a Kernel (Correlation) Matrix</h2><span id='topic+correctionKernelMatrix'></span>

<h3>Description</h3>

<p>Convert a non-PSD kernel matrix with chosen approach so that it becomes a PSD matrix.
Optionally, the resulting matrix is enforced to have values between -1 and 1 and a diagonal of 1s, with the <code>repair</code> parameter.
That means, it is (optionally) converted to a valid correlation matrix.
Essentially, this is a combination of <code><a href="#topic+correctionDefinite">correctionDefinite</a></code> with <code><a href="#topic+repairConditionsCorrelationMatrix">repairConditionsCorrelationMatrix</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctionKernelMatrix(mat, method = "flip", repair = TRUE, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correctionKernelMatrix_+3A_mat">mat</code></td>
<td>
<p>symmetric kernel matrix</p>
</td></tr>
<tr><td><code id="correctionKernelMatrix_+3A_method">method</code></td>
<td>
<p>string that specifies method for correction: spectrum clip <code>"clip"</code>, spectrum flip <code>"flip"</code>, nearest definite matrix <code>"near"</code>, spectrum square<code>"square"</code>, spectrum diffusion <code>"diffusion"</code>.</p>
</td></tr>
<tr><td><code id="correctionKernelMatrix_+3A_repair">repair</code></td>
<td>
<p>boolean, whether or not to use condition repair, so that elements between -1 and 1, and the diagonal values are 1.</p>
</td></tr>
<tr><td><code id="correctionKernelMatrix_+3A_tol">tol</code></td>
<td>
<p>torelance value. Eigenvalues between <code>-tol</code> and <code>tol</code> are assumed to be zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with corrected kernel matrix <code>mat</code>, <code>isPSD</code> (boolean, whether original matrix was PSD), transformation matrix <code>A</code>,
the matrix of eigenvectors (<code>U</code>) and the transformation vector (<code>a</code>)
</p>


<h3>References</h3>

<p>Martin Zaefferer and Thomas Bartz-Beielstein. (2016). Efficient Global Optimization with Indefinite Kernels. Parallel Problem Solving from Nature-PPSN XIV. Accepted, in press. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+correctionDefinite">correctionDefinite</a></code>, <code><a href="#topic+repairConditionsCorrelationMatrix">repairConditionsCorrelationMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(c(2,1,4,3),c(2,4,3,1),c(4,2,1,3),c(4,3,2,1),c(1,4,3,2))
D &lt;- distanceMatrix(x,distancePermutationInsert)
K &lt;- exp(-0.01*D)
is.PSD(K) #matrix should not be PSD
K &lt;- correctionKernelMatrix(K)$mat
is.PSD(K) #matrix should now be CNSD
K
</code></pre>

<hr>
<h2 id='createSimulatedTestFunction'>Simulation-based Test Function Generator, Object Interface</h2><span id='topic+createSimulatedTestFunction'></span>

<h3>Description</h3>

<p>Generate test functions for assessment of optimization algorithms with
non-conditional or conditional simulation, based on real-world data.
For a more streamlined interface, see <code><a href="#topic+testFunctionGeneratorSim">testFunctionGeneratorSim</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSimulatedTestFunction(
  xsim,
  fit,
  nsim = 10,
  conditionalSimulation = TRUE,
  seed = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="createSimulatedTestFunction_+3A_xsim">xsim</code></td>
<td>
<p>list of samples in input space, for simulation</p>
</td></tr>
<tr><td><code id="createSimulatedTestFunction_+3A_fit">fit</code></td>
<td>
<p>an object generated by <code><a href="#topic+modelKriging">modelKriging</a></code></p>
</td></tr>
<tr><td><code id="createSimulatedTestFunction_+3A_nsim">nsim</code></td>
<td>
<p>the number of simulations, or test functions, to be created</p>
</td></tr>
<tr><td><code id="createSimulatedTestFunction_+3A_conditionalsimulation">conditionalSimulation</code></td>
<td>
<p>whether (TRUE) or not (FALSE) to use conditional simulation</p>
</td></tr>
<tr><td><code id="createSimulatedTestFunction_+3A_seed">seed</code></td>
<td>
<p>a random number generator seed. Defaults to NA; which means no seed is set. For sake of reproducibility, set this to some integer value.<br /></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of functions, where each function is the interpolation of one simulation realization. The length of the list depends on the nsim parameter.
</p>


<h3>References</h3>

<p>N. A. Cressie. Statistics for Spatial Data. JOHN WILEY &amp; SONS INC, 1993.
</p>
<p>C. Lantuejoul. Geostatistical Simulation - Models and Algorithms. Springer-Verlag Berlin Heidelberg, 2002.
</p>
<p>Zaefferer, M.; Fischbach, A.; Naujoks, B. &amp; Bartz-Beielstein, T. Simulation Based Test Functions for Optimization Algorithms Proceedings of the Genetic and Evolutionary Computation Conference 2017, ACM, 2017, 8.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelKriging">modelKriging</a></code>, <code><a href="#topic+simulate.modelKriging">simulate.modelKriging</a></code>, <code><a href="#topic+testFunctionGeneratorSim">testFunctionGeneratorSim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nsim &lt;- 10
seed &lt;- 12345
n &lt;- 6
set.seed(seed)
#target function:
fun &lt;- function(x){
  exp(-20* x) + sin(6*x^2) + x
}
# "vectorize" target
f &lt;- function(x){sapply(x,fun)}
# distance function
dF &lt;- function(x,y)(sum((x-y)^2)) #sum of squares 
#start pdf creation
# plot params
par(mfrow=c(4,1),mar=c(2.3,2.5,0.2,0.2),mgp=c(1.4,0.5,0))
#test samples for plots
xtest &lt;- as.list(seq(from=-0,by=0.005,to=1))
plot(xtest,f(xtest),type="l",xlab="x",ylab="Obj. function")
#evaluation samples (training)
xb &lt;- as.list(runif(n)) 
yb &lt;- f(xb)
# support samples for simulation
x &lt;- as.list(sort(c(runif(100),unlist(xb))))
# fit the model	
fit &lt;- modelKriging(xb,yb,dF,control=list(
   algThetaControl=list(method="NLOPT_GN_DIRECT_L",funEvals=100),useLambda=FALSE))
fit
#predicted obj. function values
ypred &lt;- predict(fit,as.list(xtest))$y
plot(unlist(xtest),ypred,type="l",xlab="x",ylab="Estimation")
points(unlist(xb),yb,pch=19)
##############################	
# create test function non conditional
##############################
fun &lt;- createSimulatedTestFunction(x,fit,nsim,FALSE,seed=1)
ynew &lt;- NULL
for(i in 1:nsim)
  ynew &lt;- cbind(ynew,fun[[i]](xtest))
rangeY &lt;- range(ynew)
plot(unlist(xtest),ynew[,1],type="l",ylim=rangeY,xlab="x",ylab="Simulation")
for(i in 2:nsim){
  lines(unlist(xtest),ynew[,i],col=i,type="l")
}
##############################	
# create test function conditional
##############################
fun &lt;- createSimulatedTestFunction(x,fit,nsim,TRUE,seed=1)
ynew &lt;- NULL
for(i in 1:nsim)
  ynew &lt;- cbind(ynew,fun[[i]](xtest))
rangeY &lt;- range(ynew)
plot(unlist(xtest),ynew[,1],type="l",ylim=rangeY,xlab="x",ylab="Conditional sim.")
for(i in 2:nsim){
  lines(unlist(xtest),ynew[,i],col=i,type="l")
}
points(unlist(xb),yb,pch=19)
dev.off()

</code></pre>

<hr>
<h2 id='designMaxMinDist'>Max-Min-Distance Design</h2><span id='topic+designMaxMinDist'></span>

<h3>Description</h3>

<p>Build a design of experiments in a sequential manner: First candidate solution is created at random.
Afterwards, candidates are added sequentially, maximizing the minimum distances to the existing candidates.
Each max-min problem is resolved by random sampling.
The aim is to get a rather diverse design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designMaxMinDist(x = NULL, cf, size, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="designMaxMinDist_+3A_x">x</code></td>
<td>
<p>Optional list of user specified solutions to be added to the design/population, defaults to NULL</p>
</td></tr>
<tr><td><code id="designMaxMinDist_+3A_cf">cf</code></td>
<td>
<p>Creation function, creates random new individuals</p>
</td></tr>
<tr><td><code id="designMaxMinDist_+3A_size">size</code></td>
<td>
<p>size of the design</p>
</td></tr>
<tr><td><code id="designMaxMinDist_+3A_control">control</code></td>
<td>
<p>list of controls. <code>control$distanceFunction</code> requires a distance function to compare two candidates created by cf. 
<code>control$budget</code> is the number of candidates for the random sampling, defaults to 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list with experimental design without duplicates
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimMaxMinDist">optimMaxMinDist</a></code>, <code><a href="#topic+designRandom">designRandom</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a design of 10 permutations, each with n=5 elements, 
# and with 50 candidates for each sample.
# Note, that in this specific case the number of candidates 
# should be no larger than factorial(n).
# The default (hamming distance) is used.
design &lt;- designMaxMinDist(NULL,function()sample(5),10,
		control=list(budget=50))
# Create a design of 20 real valued 2d vectors, 
# with 100 candidates for each sample
# using euclidean distance.
design &lt;- designMaxMinDist(NULL,function()runif(2),20,
	control=list(budget=100,
	distanceFunction=function(x,y)sqrt(sum((x-y)^2))))
# plot the resulting design
plot(matrix(unlist(design),,2,byrow=TRUE))
</code></pre>

<hr>
<h2 id='designRandom'>Random Design</h2><span id='topic+designRandom'></span>

<h3>Description</h3>

<p>Create a random initial population or experimental design, given a specifed creation function,
as well as a optional set of user-specified design members and a maximum design size.
Also removes duplicates from the design/population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>designRandom(x = NULL, cf, size, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="designRandom_+3A_x">x</code></td>
<td>
<p>Optional list of user specified solutions to be added to the design, defaults to NULL</p>
</td></tr>
<tr><td><code id="designRandom_+3A_cf">cf</code></td>
<td>
<p>Creation function, creates random new individuals</p>
</td></tr>
<tr><td><code id="designRandom_+3A_size">size</code></td>
<td>
<p>size of the design</p>
</td></tr>
<tr><td><code id="designRandom_+3A_control">control</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns list with experimental design without duplicates
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimRS">optimRS</a></code>, <code><a href="#topic+designMaxMinDist">designMaxMinDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a design of 10 permutations, each with 5 elements
design &lt;- designRandom(NULL,function()sample(5),10)
# Create a design of 20 real valued 2d vectors
design &lt;- designRandom(NULL,function()runif(2),20)
</code></pre>

<hr>
<h2 id='distanceMatrix'>Calculate Distance Matrix</h2><span id='topic+distanceMatrix'></span>

<h3>Description</h3>

<p>Calculate the distance between all samples in a list, and return as matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceMatrix(X, distFun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distanceMatrix_+3A_x">X</code></td>
<td>
<p>list of samples, where each list element is a suitable input for <code>distFun</code></p>
</td></tr>
<tr><td><code id="distanceMatrix_+3A_distfun">distFun</code></td>
<td>
<p>Distance function of type f(x,y)=r, where r is a scalar and x and y are elements whose distance is evaluated.</p>
</td></tr>
<tr><td><code id="distanceMatrix_+3A_...">...</code></td>
<td>
<p>further arguments passed to distFun</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(5:1,c(2,4,5,1,3),c(5,4,3,1,2), sample(5))
distanceMatrix(x,distancePermutationHamming)

</code></pre>

<hr>
<h2 id='distanceMatrixUpdate'>Update distance matrix</h2><span id='topic+distanceMatrixUpdate'></span>

<h3>Description</h3>

<p>Update an existing distance matrix <code>D_mat</code> by adding distances
of all previous candidate solutions to one new candidate solution, <code>d_vec= d(x_i,x_new)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceMatrixUpdate(distanceMat, x, distanceFunction, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distanceMatrixUpdate_+3A_distancemat">distanceMat</code></td>
<td>
<p>original distance matrix <code>D_mat</code></p>
</td></tr>
<tr><td><code id="distanceMatrixUpdate_+3A_x">x</code></td>
<td>
<p>list of candidate solutions, last in list is the new solution</p>
</td></tr>
<tr><td><code id="distanceMatrixUpdate_+3A_distancefunction">distanceFunction</code></td>
<td>
<p>Distance function of type f(x,y)=r, where r is a scalar and x and y are candidate solutions whose distance is evaluated.</p>
</td></tr>
<tr><td><code id="distanceMatrixUpdate_+3A_...">...</code></td>
<td>
<p>further arguments passed to distanceFunction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of distances between all solutions x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(5:1,c(2,4,5,1,3),c(5,4,3,1,2))
dm &lt;- distanceMatrix(x,distancePermutationHamming)
x &lt;- append(x,list(1:5))
dmUp &lt;- distanceMatrixUpdate(dm,x,distancePermutationHamming)

</code></pre>

<hr>
<h2 id='distanceMatrixWrapper'>Distance Matrix Wrapper</h2><span id='topic+distanceMatrixWrapper'></span>

<h3>Description</h3>

<p>Wrapper to calculate the distance matrix, with one or multiple distance functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceMatrixWrapper(x, distanceFunction, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distanceMatrixWrapper_+3A_x">x</code></td>
<td>
<p>list of candidate solutions whose distance is evaluated</p>
</td></tr>
<tr><td><code id="distanceMatrixWrapper_+3A_distancefunction">distanceFunction</code></td>
<td>
<p>Distance function of type f(x,y)=r, where r is a scalar and x and y are candidate solutions whose distance is evaluated.</p>
</td></tr>
<tr><td><code id="distanceMatrixWrapper_+3A_...">...</code></td>
<td>
<p>further arguments passed to distanceFunction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of distances between all solutions in list x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(5:1,c(2,4,5,1,3),c(5,4,3,1,2))
dm1 &lt;- distanceMatrix(x,distancePermutationHamming)
dm2 &lt;- distanceMatrix(x,distancePermutationInsert)
dmBoth &lt;- distanceMatrixWrapper(x,list(distancePermutationHamming,distancePermutationInsert))

</code></pre>

<hr>
<h2 id='distanceNumericHamming'>Hamming Distance for Vectors</h2><span id='topic+distanceNumericHamming'></span>

<h3>Description</h3>

<p>The number of unequal elements of two vectors (which may be of unequal length), divided by the number of elements (of the larger vector).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceNumericHamming(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distanceNumericHamming_+3A_x">x</code></td>
<td>
<p>first vector</p>
</td></tr>
<tr><td><code id="distanceNumericHamming_+3A_y">y</code></td>
<td>
<p>second vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#e.g., used for distance between bit strings
x &lt;- c(0,1,0,1,0)
y &lt;- c(1,1,0,0,1)
distanceNumericHamming(x,y)
p &lt;- replicate(10,sample(c(0,1),5,replace=TRUE),simplify=FALSE)
distanceMatrix(p,distanceNumericHamming)

</code></pre>

<hr>
<h2 id='distanceNumericLCStr'>Longest Common Substring for Numeric Vectors</h2><span id='topic+distanceNumericLCStr'></span>

<h3>Description</h3>

<p>Longest common substring distance for two numeric vectors, e.g., bit vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceNumericLCStr(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distanceNumericLCStr_+3A_x">x</code></td>
<td>
<p>first vector (numeric)</p>
</td></tr>
<tr><td><code id="distanceNumericLCStr_+3A_y">y</code></td>
<td>
<p>second vector (numeric)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#e.g., used for distance between bit strings
x &lt;- c(0,1,0,1,0)
y &lt;- c(1,1,0,0,1)
distanceNumericLCStr(x,y)
p &lt;- replicate(10,sample(c(0,1),5,replace=TRUE),simplify=FALSE)
distanceMatrix(p,distanceNumericLCStr)

</code></pre>

<hr>
<h2 id='distanceNumericLevenshtein'>Levenshtein Distance for Numeric Vectors</h2><span id='topic+distanceNumericLevenshtein'></span>

<h3>Description</h3>

<p>Levenshtein distance for two numeric vectors, e.g., bit vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceNumericLevenshtein(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distanceNumericLevenshtein_+3A_x">x</code></td>
<td>
<p>first vector (numeric)</p>
</td></tr>
<tr><td><code id="distanceNumericLevenshtein_+3A_y">y</code></td>
<td>
<p>second vector (numeric)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#e.g., used for distance between bit strings
x &lt;- c(0,1,0,1,0)
y &lt;- c(1,1,0,0,1)
distanceNumericLevenshtein(x,y)
p &lt;- replicate(10,sample(c(0,1),5,replace=TRUE),simplify=FALSE)
distanceMatrix(p,distanceNumericLevenshtein)

</code></pre>

<hr>
<h2 id='distancePermutationAdjacency'>Adjacency Distance for Permutations</h2><span id='topic+distancePermutationAdjacency'></span>

<h3>Description</h3>

<p>Bi-directional adjacency distance for permutations, depending on how often two elements are neighbours in both permutations x and y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePermutationAdjacency(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePermutationAdjacency_+3A_x">x</code></td>
<td>
<p>first permutation (integer vector)</p>
</td></tr>
<tr><td><code id="distancePermutationAdjacency_+3A_y">y</code></td>
<td>
<p>second permutation (integer vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1 (based on the maximum possible distance between two permutations)
</p>


<h3>References</h3>

<p>Sevaux, Marc, and Kenneth Soerensen. &quot;Permutation distance measures for memetic algorithms with population management.&quot; Proceedings of 6th Metaheuristics International Conference (MIC'05). 2005.
</p>
<p>Reeves, Colin R. &quot;Landscapes, operators and heuristic search.&quot; Annals of Operations Research 86 (1999): 473-490.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- 5:1
distancePermutationAdjacency(x,y)
p &lt;- replicate(10,sample(1:5),simplify=FALSE)
distanceMatrix(p,distancePermutationAdjacency)

</code></pre>

<hr>
<h2 id='distancePermutationChebyshev'>Chebyshev Distance for Permutations</h2><span id='topic+distancePermutationChebyshev'></span>

<h3>Description</h3>

<p>Chebyshev distance for permutations. Specific to permutations is only the scaling to values of 0 to 1:
</p>
<p style="text-align: center;"><code class="reqn">d(x,y) = \frac{max(|x - y|) }{ (n-1) } </code>
</p>

<p>where n is the length of the permutations x and y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePermutationChebyshev(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePermutationChebyshev_+3A_x">x</code></td>
<td>
<p>first permutation (integer vector)</p>
</td></tr>
<tr><td><code id="distancePermutationChebyshev_+3A_y">y</code></td>
<td>
<p>second permutation (integer vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1 (based on the maximum possible distance between two permutations)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(5,1,2,3,4)
distancePermutationChebyshev(x,y)
p &lt;- replicate(10,sample(1:5),simplify=FALSE)
distanceMatrix(p,distancePermutationChebyshev)

</code></pre>

<hr>
<h2 id='distancePermutationCos'>Cosine Distance for Permutations</h2><span id='topic+distancePermutationCos'></span>

<h3>Description</h3>

<p>The Cosine distance for permutations is derived from the Cosine similarity measure
which has been applied in fields like text mining.
It is based on the scalar product of two vectors (here: permutations).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePermutationCos(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePermutationCos_+3A_x">x</code></td>
<td>
<p>first permutation (integer vector)</p>
</td></tr>
<tr><td><code id="distancePermutationCos_+3A_y">y</code></td>
<td>
<p>second permutation (integer vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1 (based on the maximum possible distance between two permutations)
</p>


<h3>References</h3>

<p>Singhal, Amit (2001).&quot;Modern Information Retrieval: A Brief Overview&quot;. Bulletin of the IEEE Computer Society Technical Committee on Data Engineering 24 (4): 35-43
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(5,1,2,3,4)
distancePermutationCos(x,y)
p &lt;- replicate(10,sample(1:5),simplify=FALSE)
distanceMatrix(p,distancePermutationCos)

</code></pre>

<hr>
<h2 id='distancePermutationEuclidean'>Euclidean Distance for Permutations</h2><span id='topic+distancePermutationEuclidean'></span>

<h3>Description</h3>

<p>Euclidean distance for permutations, scaled to values between 0 and 1:
</p>
<p style="text-align: center;"><code class="reqn">d(x,y) = \frac{1}{r} \sqrt(\sum_{i=1}^n (x_i - y_i)^2) </code>
</p>

<p>where n is the length of the permutations x and y, and scaling factor <code class="reqn">r=sqrt(2*4*c*(c+1)*(2*c+1)/6)</code> with <code class="reqn">c=(n-1)/2</code> (if n is odd)
or <code class="reqn">r=sqrt(2*c*(2*c-1)*(2*c+1)/3)</code> with <code class="reqn">c=n/2</code>  (if n is even).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePermutationEuclidean(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePermutationEuclidean_+3A_x">x</code></td>
<td>
<p>first permutation (integer vector)</p>
</td></tr>
<tr><td><code id="distancePermutationEuclidean_+3A_y">y</code></td>
<td>
<p>second permutation (integer vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1 (based on the maximum possible distance between two permutations)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(5,1,2,3,4)
distancePermutationEuclidean(x,y)
p &lt;- replicate(10,sample(1:5),simplify=FALSE)
distanceMatrix(p,distancePermutationEuclidean)

</code></pre>

<hr>
<h2 id='distancePermutationHamming'>Hamming Distance for Permutations</h2><span id='topic+distancePermutationHamming'></span>

<h3>Description</h3>

<p>Hamming distance for permutations, scaled to values between 0 and 1.
That is, the number of unequal elements of two permutations, divided by the permutations length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePermutationHamming(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePermutationHamming_+3A_x">x</code></td>
<td>
<p>first permutation (integer vector)</p>
</td></tr>
<tr><td><code id="distancePermutationHamming_+3A_y">y</code></td>
<td>
<p>second permutation (integer vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1 (based on the maximum possible distance between two permutations)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(5,1,2,3,4)
distancePermutationHamming(x,y)
p &lt;- replicate(10,sample(1:5),simplify=FALSE)
distanceMatrix(p,distancePermutationHamming)

</code></pre>

<hr>
<h2 id='distancePermutationInsert'>Insert Distance for Permutations</h2><span id='topic+distancePermutationInsert'></span>

<h3>Description</h3>

<p>The Insert Distance is an edit distance. It counts the minimum number of delete/insert operations
required to transform one permutation into another. A delete/insert operation shifts one element to a new position.
All other elements move accordingly to make place for the element. E.g., the following shows a single delete/insert move that
sorts the corresponding permutation: 1 4 2 3 5 -&gt; 1 2 3 4 5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePermutationInsert(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePermutationInsert_+3A_x">x</code></td>
<td>
<p>first permutation (integer vector)</p>
</td></tr>
<tr><td><code id="distancePermutationInsert_+3A_y">y</code></td>
<td>
<p>second permutation (integer vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1 (based on the maximum possible distance between two permutations)
</p>


<h3>References</h3>

<p>Schiavinotto, Tommaso, and Thomas Stuetzle. &quot;A review of metrics on permutations for search landscape analysis.&quot; Computers &amp; operations research 34.10 (2007): 3143-3153.
</p>
<p>Wikipedia contributors, &quot;Longest increasing subsequence&quot;, Wikipedia, The Free Encyclopedia, 12 November 2014, 19:38 UTC, [accessed 13 November 2014]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(5,1,2,3,4)
distancePermutationInsert(x,y)
p &lt;- replicate(10,sample(1:5),simplify=FALSE)
distanceMatrix(p,distancePermutationInsert)

</code></pre>

<hr>
<h2 id='distancePermutationInterchange'>Interchange Distance for Permutations</h2><span id='topic+distancePermutationInterchange'></span>

<h3>Description</h3>

<p>The interchange distance is an edit-distance, counting how many edit operation (here: interchanges, i.e., transposition of two arbitrary elements) have to be
performed to transform permutation x into permutation y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePermutationInterchange(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePermutationInterchange_+3A_x">x</code></td>
<td>
<p>first permutation (integer vector)</p>
</td></tr>
<tr><td><code id="distancePermutationInterchange_+3A_y">y</code></td>
<td>
<p>second permutation (integer vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1 (based on the maximum possible distance between two permutations)
</p>


<h3>References</h3>

<p>Schiavinotto, Tommaso, and Thomas Stuetzle. &quot;A review of metrics on permutations for search landscape analysis.&quot; Computers &amp; operations research 34.10 (2007): 3143-3153.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(1,4,3,2,5)
distancePermutationInterchange(x,y)
p &lt;- replicate(10,sample(1:5),simplify=FALSE)
distanceMatrix(p,distancePermutationInterchange)

</code></pre>

<hr>
<h2 id='distancePermutationLCStr'>Longest Common Substring Distance for Permutations</h2><span id='topic+distancePermutationLCStr'></span>

<h3>Description</h3>

<p>Distance of permutations. Based on the longest string of adjacent elements that two permutations have in common.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePermutationLCStr(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePermutationLCStr_+3A_x">x</code></td>
<td>
<p>first permutation (integer vector)</p>
</td></tr>
<tr><td><code id="distancePermutationLCStr_+3A_y">y</code></td>
<td>
<p>second permutation (integer vector)
</p>
<p>#' @return numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1 (based on the maximum possible distance between two permutations)</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hirschberg, Daniel S. &quot;A linear space algorithm for computing maximal common subsequences.&quot; Communications of the ACM 18.6 (1975): 341-343.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(5,1,2,3,4)
distancePermutationLCStr(x,y)
p &lt;- replicate(10,sample(1:5),simplify=FALSE)
distanceMatrix(p,distancePermutationLCStr)

</code></pre>

<hr>
<h2 id='distancePermutationLee'>Lee Distance for Permutations</h2><span id='topic+distancePermutationLee'></span>

<h3>Description</h3>

<p>Usually a string distance, with slightly different definition.
Adapted to permutations as: 
</p>
<p style="text-align: center;"><code class="reqn">d(x,y) = \sum_{i=1}^n min(|x_i - y_i|), n- |x_i - y_i|)</code>
</p>

<p>where n is the length of the permutations x and y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePermutationLee(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePermutationLee_+3A_x">x</code></td>
<td>
<p>first permutation (integer vector)</p>
</td></tr>
<tr><td><code id="distancePermutationLee_+3A_y">y</code></td>
<td>
<p>second permutation (integer vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1 (based on the maximum possible distance between two permutations)
</p>


<h3>References</h3>

<p>Lee, C., &quot;Some properties of nonbinary error-correcting codes,&quot; Information Theory, IRE Transactions on, vol.4, no.2, pp.77,82, June 1958
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(5,1,2,3,4)
distancePermutationLee(x,y)
p &lt;- replicate(10,sample(1:5),simplify=FALSE)
distanceMatrix(p,distancePermutationLee)

</code></pre>

<hr>
<h2 id='distancePermutationLevenshtein'>Levenshtein Distance for Permutations</h2><span id='topic+distancePermutationLevenshtein'></span>

<h3>Description</h3>

<p>Levenshtein Distance, often just called &quot;Edit Distance&quot;. The number of insertions, substitutions or deletions to turn one permutation (or string of equal length) into another.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePermutationLevenshtein(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePermutationLevenshtein_+3A_x">x</code></td>
<td>
<p>first permutation (integer vector)</p>
</td></tr>
<tr><td><code id="distancePermutationLevenshtein_+3A_y">y</code></td>
<td>
<p>second permutation (integer vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1 (based on the maximum possible distance between two permutations)
</p>


<h3>References</h3>

<p>Levenshtein, Vladimir I. &quot;Binary codes capable of correcting deletions, insertions and reversals.&quot; Soviet physics doklady. Vol. 10. 1966.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(1,2,5,4,3)
distancePermutationLevenshtein(x,y)
p &lt;- replicate(10,sample(1:5),simplify=FALSE)
distanceMatrix(p,distancePermutationLevenshtein)

</code></pre>

<hr>
<h2 id='distancePermutationLex'>Lexicographic permutation distance</h2><span id='topic+distancePermutationLex'></span>

<h3>Description</h3>

<p>This function calculates the lexicographic permutation distance. That is the difference of positions
that both positions would receive in a lexicographic ordering. Note, that this distance
measure can quickly become inaccurate if the length of the permutations grows too large, due
to being based on the factorial of the length. In general, permutations longer than 100 elements should
be avoided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePermutationLex(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePermutationLex_+3A_x">x</code></td>
<td>
<p>first permutation (integer vector)</p>
</td></tr>
<tr><td><code id="distancePermutationLex_+3A_y">y</code></td>
<td>
<p>second permutation (integer vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1 (based on the maximum possible distance between two permutations)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lexicographicPermutationOrderNumber">lexicographicPermutationOrderNumber</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(1,2,3,5,4)
distancePermutationLex(x,y)
p &lt;- replicate(10,sample(1:5),simplify=FALSE)
distanceMatrix(p,distancePermutationLex)

</code></pre>

<hr>
<h2 id='distancePermutationManhattan'>Manhattan Distance for Permutations</h2><span id='topic+distancePermutationManhattan'></span>

<h3>Description</h3>

<p>Manhattan distance for permutations, scaled to values between 0 and 1:
</p>
<p style="text-align: center;"><code class="reqn">d(x,y) = \frac{1}{r} \sum_{i=1}^n |x_i - y_i| </code>
</p>

<p>where n is the length of the permutations x and y, and scaling factor <code class="reqn">r=(n^2-1)/2</code> (if n is odd)
or <code class="reqn">r=((n^2)/2</code> (if n is even).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePermutationManhattan(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePermutationManhattan_+3A_x">x</code></td>
<td>
<p>first permutation (integer vector)</p>
</td></tr>
<tr><td><code id="distancePermutationManhattan_+3A_y">y</code></td>
<td>
<p>second permutation (integer vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1 (based on the maximum possible distance between two permutations)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(5,1,2,3,4)
distancePermutationManhattan(x,y)
p &lt;- replicate(10,sample(1:5),simplify=FALSE)
distanceMatrix(p,distancePermutationManhattan)

</code></pre>

<hr>
<h2 id='distancePermutationPosition'>Position Distance for Permutations</h2><span id='topic+distancePermutationPosition'></span>

<h3>Description</h3>

<p>Position distance (or Spearmans Correlation Coefficient), scaled to values between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePermutationPosition(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePermutationPosition_+3A_x">x</code></td>
<td>
<p>first permutation (integer vector)</p>
</td></tr>
<tr><td><code id="distancePermutationPosition_+3A_y">y</code></td>
<td>
<p>second permutation (integer vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1 (based on the maximum possible distance between two permutations)
</p>


<h3>References</h3>

<p>Schiavinotto, Tommaso, and Thomas Stuetzle. &quot;A review of metrics on permutations for search landscape analysis.&quot; Computers &amp; operations research 34.10 (2007): 3143-3153.
</p>
<p>Reeves, Colin R. &quot;Landscapes, operators and heuristic search.&quot; Annals of Operations Research 86 (1999): 473-490.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(1,3,5,4,2)
distancePermutationPosition(x,y)
p &lt;- replicate(10,sample(1:5),simplify=FALSE)
distanceMatrix(p,distancePermutationPosition)

</code></pre>

<hr>
<h2 id='distancePermutationPosition2'>Squared Position Distance for Permutations</h2><span id='topic+distancePermutationPosition2'></span>

<h3>Description</h3>

<p>Squared position distance (or Spearmans Footrule), scaled to values between 0 and 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePermutationPosition2(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePermutationPosition2_+3A_x">x</code></td>
<td>
<p>first permutation (integer vector)</p>
</td></tr>
<tr><td><code id="distancePermutationPosition2_+3A_y">y</code></td>
<td>
<p>second permutation (integer vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1 (based on the maximum possible distance between two permutations)
</p>


<h3>References</h3>

<p>Schiavinotto, Tommaso, and Thomas Stuetzle. &quot;A review of metrics on permutations for search landscape analysis.&quot; Computers &amp; operations research 34.10 (2007): 3143-3153.
</p>
<p>Reeves, Colin R. &quot;Landscapes, operators and heuristic search.&quot; Annals of Operations Research 86 (1999): 473-490.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(1,3,5,4,2)
distancePermutationPosition2(x,y)
p &lt;- replicate(10,sample(1:5),simplify=FALSE)
distanceMatrix(p,distancePermutationPosition2)

</code></pre>

<hr>
<h2 id='distancePermutationR'>R-Distance for Permutations</h2><span id='topic+distancePermutationR'></span>

<h3>Description</h3>

<p>R distance or unidirectional adjacency distance. Based on count of number of times that a two element sequence in x also occurs in y, in the same order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePermutationR(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePermutationR_+3A_x">x</code></td>
<td>
<p>first permutation (integer vector)</p>
</td></tr>
<tr><td><code id="distancePermutationR_+3A_y">y</code></td>
<td>
<p>second permutation (integer vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1 (based on the maximum possible distance between two permutations)
</p>


<h3>References</h3>

<p>Sevaux, Marc, and Kenneth Soerensen. &quot;Permutation distance measures for memetic algorithms with population management.&quot; Proceedings of 6th Metaheuristics International Conference (MIC'05). 2005.
</p>
<p>Reeves, Colin R. &quot;Landscapes, operators and heuristic search.&quot; Annals of Operations Research 86 (1999): 473-490.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(1,2,3,5,4)
distancePermutationR(x,y)
p &lt;- replicate(10,sample(1:5),simplify=FALSE)
distanceMatrix(p,distancePermutationR)

</code></pre>

<hr>
<h2 id='distancePermutationSwap'>Swap-Distance for Permutations</h2><span id='topic+distancePermutationSwap'></span>

<h3>Description</h3>

<p>The swap distance is an edit-distance, counting how many edit operation (here: swaps, i.e., transposition of two adjacent elements) have to be
performed to transform permutation x into permutation y.
Note: In v2.4.0 of CEGO and earlier, this function actually computed the swap distance on the inverted permutations 
(i.e., on the rankings, rather than orderin).
This is now (v2.4.2 and later) corrected by inverting the permutations x and y before computing the distance (ie. computing ordering first).
The original behavior can be reproduced by <code><a href="#topic+distancePermutationSwapInv">distancePermutationSwapInv</a></code>.
This issue was kindly reported by Manuel Lopez-Ibanez and the difference in terms of behavior is discussed by Ekhine Irurozki and him (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePermutationSwap(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePermutationSwap_+3A_x">x</code></td>
<td>
<p>first permutation (integer vector)</p>
</td></tr>
<tr><td><code id="distancePermutationSwap_+3A_y">y</code></td>
<td>
<p>second permutation (integer vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1 (based on the maximum possible distance between two permutations)
</p>


<h3>References</h3>

<p>Schiavinotto, Tommaso, and Thomas Stuetzle. &quot;A review of metrics on permutations for search landscape analysis.&quot; Computers &amp; operations research 34.10 (2007): 3143-3153.
</p>
<p>Irurozki, Ekhine and Ibanez-Lopez Unbalanced Mallows Models for Optimizing Expensive Black-Box Permutation Problems. In Proceedings of the Genetic and Evolutionary Computation Conference, GECCO 2021. ACM Press, New York, NY, 2021. doi: 10.1145/3449639.3459366
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(1,2,3,5,4)
distancePermutationSwap(x,y)
p &lt;- replicate(10,sample(1:5),simplify=FALSE)
distanceMatrix(p,distancePermutationSwap)

</code></pre>

<hr>
<h2 id='distancePermutationSwapInv'>Inverse-Swap-Distance for Permutations</h2><span id='topic+distancePermutationSwapInv'></span>

<h3>Description</h3>

<p>The swap distance on the inverse of permutations x and y.
See <code><a href="#topic+distancePermutationSwap">distancePermutationSwap</a></code> for non-inversed version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distancePermutationSwapInv(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distancePermutationSwapInv_+3A_x">x</code></td>
<td>
<p>first permutation (integer vector)</p>
</td></tr>
<tr><td><code id="distancePermutationSwapInv_+3A_y">y</code></td>
<td>
<p>second permutation (integer vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>
<p>, scaled to values between 0 and 1 (based on the maximum possible distance between two permutations)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- c(1,2,3,5,4)
distancePermutationSwapInv(x,y)
p &lt;- replicate(10,sample(1:5),simplify=FALSE)
distanceMatrix(p,distancePermutationSwapInv)

</code></pre>

<hr>
<h2 id='distanceRealEuclidean'>Euclidean Distance</h2><span id='topic+distanceRealEuclidean'></span>

<h3>Description</h3>

<p>The Euclidean distance for real vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceRealEuclidean(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distanceRealEuclidean_+3A_x">x</code></td>
<td>
<p>first real vector</p>
</td></tr>
<tr><td><code id="distanceRealEuclidean_+3A_y">y</code></td>
<td>
<p>second real vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(5)
y &lt;- runif(5)
distanceRealEuclidean(x,y)

</code></pre>

<hr>
<h2 id='distanceSequenceLevenshtein'>Levenshtein Distance forsSequences of numbers</h2><span id='topic+distanceSequenceLevenshtein'></span>

<h3>Description</h3>

<p>Levenshtein distance for two sequences of numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceSequenceLevenshtein(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distanceSequenceLevenshtein_+3A_x">x</code></td>
<td>
<p>first vector (numeric vector)</p>
</td></tr>
<tr><td><code id="distanceSequenceLevenshtein_+3A_y">y</code></td>
<td>
<p>second vector (numeric vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>#e.g., used for distance between integer sequence
x &lt;- c(0,1,10,2,4)
y &lt;- c(10,1,0,4,-4)
distanceSequenceLevenshtein(x,y)
p &lt;- replicate(10,sample(1:5,3,replace=TRUE),simplify=FALSE)
distanceMatrix(p,distanceSequenceLevenshtein)

</code></pre>

<hr>
<h2 id='distanceStringHamming'>Hamming Distance for Strings</h2><span id='topic+distanceStringHamming'></span>

<h3>Description</h3>

<p>Number of unequal letters in two strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceStringHamming(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distanceStringHamming_+3A_x">x</code></td>
<td>
<p>first string (class: character)</p>
</td></tr>
<tr><td><code id="distanceStringHamming_+3A_y">y</code></td>
<td>
<p>second string (class: character)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>distanceStringHamming("ABCD","AACC")

</code></pre>

<hr>
<h2 id='distanceStringLCStr'>Longest Common Substring distance</h2><span id='topic+distanceStringLCStr'></span>

<h3>Description</h3>

<p>Distance between strings, based on the longest common substring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceStringLCStr(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distanceStringLCStr_+3A_x">x</code></td>
<td>
<p>first string (class: character)</p>
</td></tr>
<tr><td><code id="distanceStringLCStr_+3A_y">y</code></td>
<td>
<p>second string (class: character)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>distanceStringLCStr("ABCD","AACC")

</code></pre>

<hr>
<h2 id='distanceStringLevenshtein'>Levenshtein Distance for Strings</h2><span id='topic+distanceStringLevenshtein'></span>

<h3>Description</h3>

<p>Number of insertions, deletions and substitutions to transform one string into another
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceStringLevenshtein(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distanceStringLevenshtein_+3A_x">x</code></td>
<td>
<p>first string (class: character)</p>
</td></tr>
<tr><td><code id="distanceStringLevenshtein_+3A_y">y</code></td>
<td>
<p>second string (class: character)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric distance value </p>
<p style="text-align: center;"><code class="reqn">d(x,y)</code>
</p>



<h3>Examples</h3>

<pre><code class='language-R'>distanceStringLevenshtein("ABCD","AACC")

</code></pre>

<hr>
<h2 id='distanceVector'>Calculate Distance Vector</h2><span id='topic+distanceVector'></span>

<h3>Description</h3>

<p>Calculate the distance between a single sample and all samples in a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distanceVector(a, X, distFun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="distanceVector_+3A_a">a</code></td>
<td>
<p>A single sample which is a suitable input for <code>distFun</code></p>
</td></tr>
<tr><td><code id="distanceVector_+3A_x">X</code></td>
<td>
<p>list of samples, where each list element is a suitable input for <code>distFun</code></p>
</td></tr>
<tr><td><code id="distanceVector_+3A_distfun">distFun</code></td>
<td>
<p>Distance function of type f(x,y)=r, where r is a scalar and x and y are elements whose distance is evaluated.</p>
</td></tr>
<tr><td><code id="distanceVector_+3A_...">...</code></td>
<td>
<p>further arguments passed to distFun</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector of distances
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 1:5
y &lt;- list(5:1,c(2,4,5,1,3),c(5,4,3,1,2))
distanceVector(x,y,distancePermutationHamming)

</code></pre>

<hr>
<h2 id='fcorrCubic'>Cubic Kernel for Kriging</h2><span id='topic+fcorrCubic'></span>

<h3>Description</h3>

<p>Cubic Kernel for Kriging
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcorrCubic(D, theta = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fcorrCubic_+3A_d">D</code></td>
<td>
<p>distance matrix</p>
</td></tr>
<tr><td><code id="fcorrCubic_+3A_theta">theta</code></td>
<td>
<p>kernel parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix (Psi)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelKriging">modelKriging</a></code>
</p>

<hr>
<h2 id='fcorrGauss'>Gaussian Kernel for Kriging</h2><span id='topic+fcorrGauss'></span>

<h3>Description</h3>

<p>Gaussian Kernel for Kriging
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcorrGauss(D, theta = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fcorrGauss_+3A_d">D</code></td>
<td>
<p>distance matrix</p>
</td></tr>
<tr><td><code id="fcorrGauss_+3A_theta">theta</code></td>
<td>
<p>kernel parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix (Psi)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelKriging">modelKriging</a></code>
</p>

<hr>
<h2 id='fcorrLinear'>Linear Kernel for Kriging</h2><span id='topic+fcorrLinear'></span>

<h3>Description</h3>

<p>Linear Kernel for Kriging
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcorrLinear(D, theta = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fcorrLinear_+3A_d">D</code></td>
<td>
<p>distance matrix</p>
</td></tr>
<tr><td><code id="fcorrLinear_+3A_theta">theta</code></td>
<td>
<p>kernel parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix (Psi)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelKriging">modelKriging</a></code>
</p>

<hr>
<h2 id='fcorrSphere'>Spherical Kernel for Kriging</h2><span id='topic+fcorrSphere'></span>

<h3>Description</h3>

<p>Spherical Kernel for Kriging
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fcorrSphere(D, theta = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fcorrSphere_+3A_d">D</code></td>
<td>
<p>distance matrix</p>
</td></tr>
<tr><td><code id="fcorrSphere_+3A_theta">theta</code></td>
<td>
<p>kernel parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix (Psi)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelKriging">modelKriging</a></code>
</p>

<hr>
<h2 id='infillExpectedImprovement'>Negative Logarithm of Expected Improvement</h2><span id='topic+infillExpectedImprovement'></span>

<h3>Description</h3>

<p>This function calculates the Expected Improvement&quot; of candidate solutions,
based on predicted means, standard deviations (uncertainty) and
the best known objective function value so far.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infillExpectedImprovement(mean, sd, min)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="infillExpectedImprovement_+3A_mean">mean</code></td>
<td>
<p>predicted mean values</p>
</td></tr>
<tr><td><code id="infillExpectedImprovement_+3A_sd">sd</code></td>
<td>
<p>predicted standard deviation</p>
</td></tr>
<tr><td><code id="infillExpectedImprovement_+3A_min">min</code></td>
<td>
<p>minimum of all observations so far</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the negative logarithm of the Expected Improvement.
</p>

<hr>
<h2 id='is.CNSD'>Check for Conditional Negative Semi-Definiteness</h2><span id='topic+is.CNSD'></span>

<h3>Description</h3>

<p>This function checks whether a symmetric matrix is Conditionally Negative Semi-Definite (CNSD).
Note that this function does not check whether the matrix is actually symmetric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.CNSD(X, method = "alg1", tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.CNSD_+3A_x">X</code></td>
<td>
<p>a symmetric matrix</p>
</td></tr>
<tr><td><code id="is.CNSD_+3A_method">method</code></td>
<td>
<p>a string, specifiying the method to be used. <code>"alg1"</code> is based on algorithm 1 in Ikramov and Savel'eva (2000). 
<code>"alg2"</code> is based on theorem 3.2 in Ikramov and Savel'eva (2000). <code>"eucl"</code> is based on Glunt (1990).</p>
</td></tr>
<tr><td><code id="is.CNSD_+3A_tol">tol</code></td>
<td>
<p>torelance value. Eigenvalues between <code>-tol</code> and <code>tol</code> are assumed to be zero.
</p>
<p>Symmetric, CNSD matrices are, e.g., euclidean distance matrices, whiche are required to produce Positive Semi-Definite correlation
or kernel matrices. Such matrices are used in models like Kriging or Support Vector Machines.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean, which is TRUE if X is CNSD
</p>


<h3>References</h3>

<p>Ikramov, K. and Savel'eva, N. Conditionally definite matrices, Journal of Mathematical Sciences, Kluwer Academic Publishers-Plenum Publishers, 2000, 98, 1-50
</p>
<p>Glunt, W.; Hayden, T. L.; Hong, S. and Wells, J. An alternating projection algorithm for computing the nearest Euclidean distance matrix, SIAM Journal on Matrix Analysis and Applications, SIAM, 1990, 11, 589-600
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.NSD">is.NSD</a></code>, <code><a href="#topic+is.PSD">is.PSD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following permutations will produce
# a non-CNSD distance matrix with Insert distance
# and a CNSD distance matrix with Hamming distance
x &lt;- list(c(2,1,4,3),c(2,4,3,1),c(4,2,1,3),c(4,3,2,1),c(1,4,3,2))
D &lt;- distanceMatrix(x,distancePermutationInsert)
is.CNSD(D,"alg1")
is.CNSD(D,"alg2")
is.CNSD(D,"eucl")
D &lt;- distanceMatrix(x,distancePermutationHamming)
is.CNSD(D,"alg1")
is.CNSD(D,"alg2")
is.CNSD(D,"eucl")
</code></pre>

<hr>
<h2 id='is.NSD'>Check for Negative Semi-Definiteness</h2><span id='topic+is.NSD'></span>

<h3>Description</h3>

<p>This function checks whether a symmetric matrix is Negative Semi-Definite (NSD).
That means, it is determined whether all eigenvalues of the matrix are non-positive.
Note that this function does not check whether the matrix is actually symmetric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.NSD(X, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.NSD_+3A_x">X</code></td>
<td>
<p>a symmetric matrix</p>
</td></tr>
<tr><td><code id="is.NSD_+3A_tol">tol</code></td>
<td>
<p>torelance value. Eigenvalues between <code>-tol</code> and <code>tol</code> are assumed to be zero.
</p>
<p>Symmetric, NSD matrices are, e.g., correlation
or kernel matrices. Such matrices are used in models like Kriging or Support Vector regression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean, which is TRUE if X is NSD
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.CNSD">is.CNSD</a></code>, <code><a href="#topic+is.PSD">is.PSD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following permutations will produce
# a non-PSD kernel matrix with Insert distance
# and a PSD distance matrix with Hamming distance
# (for the given theta value of 0.01)-
# The respective negative should be (non-) NSD
x &lt;- list(c(2,1,4,3),c(2,4,3,1),c(4,2,1,3),c(4,3,2,1),c(1,4,3,2))
K &lt;- exp(-0.01*distanceMatrix(x,distancePermutationInsert))
is.NSD(-K) 
K &lt;- exp(-0.01*distanceMatrix(x,distancePermutationHamming))
is.NSD(-K)
</code></pre>

<hr>
<h2 id='is.PSD'>Check for Positive Semi-Definiteness</h2><span id='topic+is.PSD'></span>

<h3>Description</h3>

<p>This function checks whether a symmetric matrix is Positive Semi-Definite (PSD).
That means, it is determined whether all eigenvalues of the matrix are non-negative.
Note that this function does not check whether the matrix is actually symmetric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.PSD(X, tol = 1e-08)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.PSD_+3A_x">X</code></td>
<td>
<p>a symmetric matrix</p>
</td></tr>
<tr><td><code id="is.PSD_+3A_tol">tol</code></td>
<td>
<p>torelance value. Eigenvalues between <code>-tol</code> and <code>tol</code> are assumed to be zero.
</p>
<p>Symmetric, PSD matrices are, e.g., correlation
or kernel matrices. Such matrices are used in models like Kriging or Support Vector regression.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean, which is TRUE if X is PSD
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.CNSD">is.CNSD</a></code>, <code><a href="#topic+is.NSD">is.NSD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following permutations will produce
# a non-PSD kernel matrix with Insert distance
# and a PSD distance matrix with Hamming distance
# (for the given theta value of 0.01)
x &lt;- list(c(2,1,4,3),c(2,4,3,1),c(4,2,1,3),c(4,3,2,1),c(1,4,3,2))
K &lt;- exp(-0.01*distanceMatrix(x,distancePermutationInsert))
is.PSD(K)
K &lt;- exp(-0.01*distanceMatrix(x,distancePermutationHamming))
is.PSD(K)
</code></pre>

<hr>
<h2 id='kernelMatrix'>Calculate Kernel Matrix</h2><span id='topic+kernelMatrix'></span>

<h3>Description</h3>

<p>Calculate the similarities between all samples in a list, and return as matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernelMatrix(X, kernFun, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="kernelMatrix_+3A_x">X</code></td>
<td>
<p>list of samples, where each list element is a suitable input for <code>kernFun</code></p>
</td></tr>
<tr><td><code id="kernelMatrix_+3A_kernfun">kernFun</code></td>
<td>
<p>Kernel function of type f(x,y)=r, where r is a scalar and x and y are elements whose similarity is evaluated.</p>
</td></tr>
<tr><td><code id="kernelMatrix_+3A_...">...</code></td>
<td>
<p>further arguments passed to distFun</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The similarity / kernel matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(5:1,c(2,4,5,1,3),c(5,4,3,1,2), sample(5))
kernFun &lt;- function(x,y){
		exp(-distancePermutationHamming(x,y))
}
kernelMatrix(x,distancePermutationHamming)

</code></pre>

<hr>
<h2 id='landscapeGeneratorGaussian'>Create Gaussian Landscape</h2><span id='topic+landscapeGeneratorGaussian'></span>

<h3>Description</h3>

<p>This function is loosely based on the Gaussian Landscape Generator by Bo Yuan and Marcus Gallagher.
It creates a Gaussian Landscape every time it is called. This Landscape can be evaluated like a function.
To adapt to combinatorial spaces, the Gaussians are here based on a user-specified distance measure.
Due to the expected nature of combinatorial spaces and their lack of direction, the resulting
Gaussians are much simplified in comparison to the continuous, vector-valued case (e.g., no rotation).
Since the <code>CEGO</code> package is tailored to minimization, the landscape is inverted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landscapeGeneratorGaussian(
  nGaussian = 10,
  theta = 1,
  ratio = 0.2,
  seed = 1,
  distanceFunction,
  creationFunction
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="landscapeGeneratorGaussian_+3A_ngaussian">nGaussian</code></td>
<td>
<p>number of Gaussian components in the landscape. Default is 10.</p>
</td></tr>
<tr><td><code id="landscapeGeneratorGaussian_+3A_theta">theta</code></td>
<td>
<p>controls width of Gaussian components as a multiplier. Default is 1.</p>
</td></tr>
<tr><td><code id="landscapeGeneratorGaussian_+3A_ratio">ratio</code></td>
<td>
<p>minimal function value of the local minima. Default is 0.2. (Note: Global minimum will be at zero, local minima will be in range <code>[ratio;1]</code>)</p>
</td></tr>
<tr><td><code id="landscapeGeneratorGaussian_+3A_seed">seed</code></td>
<td>
<p>seed for the random number generator used before creation of the landscape. Generator status will be saved and reset afterwards.</p>
</td></tr>
<tr><td><code id="landscapeGeneratorGaussian_+3A_distancefunction">distanceFunction</code></td>
<td>
<p>A function of type <code>f(x,y)</code>, to evaluate distance between to samples in their given representation.</p>
</td></tr>
<tr><td><code id="landscapeGeneratorGaussian_+3A_creationfunction">creationFunction</code></td>
<td>
<p>function to randomly generate the centers of the Gaussians, in form of their given representation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a function.The function requires a list of candidate solutions as its input, where each solution is suitable for use with the distance function.
</p>


<h3>References</h3>

<p>B. Yuan and M. Gallagher (2003) &quot;On Building a Principled Framework for Evaluating and Testing Evolutionary Algorithms: A Continuous Landscape Generator&quot;. 
In Proceedings of the 2003 Congress on Evolutionary Computation, IEEE, pp. 451-458, Canberra, Australia.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#rng seed
seed=101
# distance function
dF &lt;- function(x,y)(sum((x-y)^2)) #sum of squares 
#dF &lt;- function(x,y)sqrt(sum((x-y)^2)) #euclidean distance
# creation function
cF &lt;- function()runif(1)
# plot pars
par(mfrow=c(3,1),mar=c(3.5,3.5,0.2,0.2),mgp=c(2,1,0))
## uni modal distance landscape
# set seed
set.seed(seed)
#landscape
lF &lt;- landscapeGeneratorUNI(cF(),dF)
x &lt;- as.list(seq(from=0,by=0.001,to=1))
plot(x,lF(x),type="l")
## multi-modal distance landscape
# set seed
set.seed(seed)
#landscape
lF &lt;- landscapeGeneratorMUL(replicate(5,cF(),FALSE),dF)
plot(x,lF(x),type="l")
## glg landscape
#landscape
lF &lt;- landscapeGeneratorGaussian(nGaussian=20,theta=1,
ratio=0.3,seed=seed,dF,cF)
plot(x,lF(x),type="l")

</code></pre>

<hr>
<h2 id='landscapeGeneratorGaussianBuild'>Gaussian Landscape Core function</h2><span id='topic+landscapeGeneratorGaussianBuild'></span>

<h3>Description</h3>

<p>Core Gaussian landscape function. Should not be called directly, as it does not contain proper seed handling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landscapeGeneratorGaussianBuild(nGaussian = 10, ratio = 0.2, creationFunction)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="landscapeGeneratorGaussianBuild_+3A_ngaussian">nGaussian</code></td>
<td>
<p>number of Gaussian components in the landscape. Default is 10.</p>
</td></tr>
<tr><td><code id="landscapeGeneratorGaussianBuild_+3A_ratio">ratio</code></td>
<td>
<p>minimal function value of the local minima. Default is 0.2. (Note: Global minimum will be at zero, local minimal will be in range <code>[ratio;1]</code>)</p>
</td></tr>
<tr><td><code id="landscapeGeneratorGaussianBuild_+3A_creationfunction">creationFunction</code></td>
<td>
<p>function to randomly generate the centers of the gaussians</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list, with the following items:
</p>

<dl>
<dt><code>centers</code></dt><dd><p> samples which are the centers of each Gaussian</p>
</dd>
<dt><code>covinv</code></dt><dd><p> inverse of variance of each Gaussian</p>
</dd>
<dt><code>opt</code></dt><dd><p> value at randomly chosen optimum center</p>
</dd>
<dt><code>nGauss</code></dt><dd><p> number of Gaussian components</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+landscapeGeneratorGaussian">landscapeGeneratorGaussian</a></code>
</p>

<hr>
<h2 id='landscapeGeneratorGaussianEval'>Gaussian Landscape Evaluation</h2><span id='topic+landscapeGeneratorGaussianEval'></span>

<h3>Description</h3>

<p>Evaluate a Gaussian landscape. Should not be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landscapeGeneratorGaussianEval(x, glg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="landscapeGeneratorGaussianEval_+3A_x">x</code></td>
<td>
<p>list of samples to evaluate</p>
</td></tr>
<tr><td><code id="landscapeGeneratorGaussianEval_+3A_glg">glg</code></td>
<td>
<p>list of values defining the Gaussian Landscape, created by <code>landscapeGeneratorGaussianBuild</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list, with the following items:<br />
<code>value</code> value of the combined landscape
<code>components</code> value of each component
</p>


<h3>See Also</h3>

<p><code><a href="#topic+landscapeGeneratorGaussian">landscapeGeneratorGaussian</a></code>
</p>

<hr>
<h2 id='landscapeGeneratorMUL'>Multimodal Fitness Landscape</h2><span id='topic+landscapeGeneratorMUL'></span>

<h3>Description</h3>

<p>This function generates multi-modal fitness landscapes based on distance measures.
The fitness is the minimal distance to several reference individuals or centers. Hence, each reference individual
is an optimum of the landscape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landscapeGeneratorMUL(ref, distanceFunction)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="landscapeGeneratorMUL_+3A_ref">ref</code></td>
<td>
<p>list of reference individuals / centers</p>
</td></tr>
<tr><td><code id="landscapeGeneratorMUL_+3A_distancefunction">distanceFunction</code></td>
<td>
<p>Distance function, used to evaluate d(x,ref[[n]]), where x is an arbitrary new individual</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a function. The function requires a list of candidate solutions as its input, where each solution is suitable for use with the distance function. The function returns a numeric vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+landscapeGeneratorUNI">landscapeGeneratorUNI</a></code>, <code><a href="#topic+landscapeGeneratorGaussian">landscapeGeneratorGaussian</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fun &lt;- landscapeGeneratorMUL(ref=list(1:7,c(2,4,1,5,3,7,6)),distancePermutationCos)
x &lt;- 1:7
fun(list(x))
x &lt;- c(2,4,1,5,3,7,6)
fun(list(x))
x &lt;- 7:1
fun(list(x))
x &lt;- sample(7)
fun(list(x))
## multiple solutions at once:
x &lt;- append(list(1:7,c(2,4,1,5,3,7,6)),replicate(5,sample(7),FALSE))
fun(x)

</code></pre>

<hr>
<h2 id='landscapeGeneratorUNI'>Unimodal Fitness Landscape</h2><span id='topic+landscapeGeneratorUNI'></span>

<h3>Description</h3>

<p>This function generates uni-modal fitness landscapes based on distance measures.
The fitness is the distance to a reference individual or center. Hence, the reference individual
is the optimum of the landscape. This function is essentially a wrapper
for the <code><a href="#topic+landscapeGeneratorMUL">landscapeGeneratorMUL</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>landscapeGeneratorUNI(ref, distanceFunction)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="landscapeGeneratorUNI_+3A_ref">ref</code></td>
<td>
<p>reference individual</p>
</td></tr>
<tr><td><code id="landscapeGeneratorUNI_+3A_distancefunction">distanceFunction</code></td>
<td>
<p>Distance function, used to evaluate d(x,ref), where x is an arbitrary new individual</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a function. The function requires a list of candidate solutions as its input, where each solution is suitable for use with the distance function. The function returns a numeric vector.
</p>


<h3>References</h3>

<p>Moraglio, Alberto, Yong-Hyuk Kim, and Yourim Yoon. &quot;Geometric surrogate-based optimisation for permutation-based problems.&quot; Proceedings of the 13th annual conference companion on Genetic and evolutionary computation. ACM, 2011.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+landscapeGeneratorMUL">landscapeGeneratorMUL</a></code>, <code><a href="#topic+landscapeGeneratorGaussian">landscapeGeneratorGaussian</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fun &lt;- landscapeGeneratorUNI(ref=1:7,distancePermutationCos)
## for single solutions, note that the function still requires list input:
x &lt;- 1:7
fun(list(x))
x &lt;- 7:1
fun(list(x))
x &lt;- sample(7)
fun(list(x))
## multiple solutions at once:
x &lt;- replicate(5,sample(7),FALSE)
fun(x)

</code></pre>

<hr>
<h2 id='lexicographicPermutationOrderNumber'>Lexicographic order number</h2><span id='topic+lexicographicPermutationOrderNumber'></span>

<h3>Description</h3>

<p>This function returns the position-number that a permutation would receive in a lexicographic ordering.
It is used in the lexicographic distance measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lexicographicPermutationOrderNumber(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lexicographicPermutationOrderNumber_+3A_x">x</code></td>
<td>
<p>permutation (integer vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value giving position in lexicographic order.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+distancePermutationLex">distancePermutationLex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lexicographicPermutationOrderNumber(1:5)
lexicographicPermutationOrderNumber(c(1,2,3,5,4))
lexicographicPermutationOrderNumber(c(1,2,4,3,5))
lexicographicPermutationOrderNumber(c(1,2,4,5,3))
lexicographicPermutationOrderNumber(c(1,2,5,3,4))
lexicographicPermutationOrderNumber(c(1,2,5,4,3))
lexicographicPermutationOrderNumber(c(1,3,2,4,5))
lexicographicPermutationOrderNumber(5:1)
lexicographicPermutationOrderNumber(1:7)
lexicographicPermutationOrderNumber(7:1)

</code></pre>

<hr>
<h2 id='modelKriging'>Kriging Model</h2><span id='topic+modelKriging'></span>

<h3>Description</h3>

<p>Implementation of a distance-based Kriging model, e.g., for mixed or combinatorial input spaces.
It is based on employing suitable distance measures for the samples in input space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelKriging(x, y, distanceFunction, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelKriging_+3A_x">x</code></td>
<td>
<p>list of samples in input space</p>
</td></tr>
<tr><td><code id="modelKriging_+3A_y">y</code></td>
<td>
<p>column vector of observations for each sample</p>
</td></tr>
<tr><td><code id="modelKriging_+3A_distancefunction">distanceFunction</code></td>
<td>
<p>a suitable distance function of type f(x1,x2), returning a scalar distance value, preferably between 0 and 1.
Maximum distances larger 1 are no problem, but may yield scaling bias when different measures are compared.
Should be non-negative and symmetric.  It can also be a list of several distance functions. In this case, Maximum Likelihood Estimation (MLE) is used 
to determine the most suited distance measure.
The distance function may have additional parameters. For that case, see distanceParametersLower/Upper in the controls.
If distanceFunction is missing, it can also be provided in the control list.</p>
</td></tr>
<tr><td><code id="modelKriging_+3A_control">control</code></td>
<td>
<p>(list), with the options for the model building procedure:
</p>

<dl>
<dt><code>lower</code></dt><dd><p> lower boundary for theta, default is <code>1e-6</code></p>
</dd>
<dt><code>upper</code></dt><dd><p> upper boundary for theta, default is <code>100</code></p>
</dd>
<dt><code>corr</code></dt><dd><p> function to be used for correlation modelling, default is <code>fcorrGauss</code></p>
</dd>
<dt><code>algTheta</code></dt><dd><p> algorithm used to find theta (as well as p and lambda), default is <code><a href="#topic+optimInterface">optimInterface</a></code>.</p>
</dd>
<dt><code>algThetaControl</code></dt><dd><p> list of controls passed to <code>algTheta</code>.</p>
</dd>
<dt><code>useLambda</code></dt><dd><p> whether or not to use the regularization constant lambda (nugget effect). Default is <code>FALSE</code>.</p>
</dd>
<dt><code>lambdaLower</code></dt><dd><p> lower boundary for lambda (log scale), default is <code>-6</code></p>
</dd>
<dt><code>lambdaUpper</code></dt><dd><p> upper boundary for lambda (log scale), default is <code>0</code></p>
</dd>
<dt><code>distanceParametersLower</code></dt><dd><p> lower boundary for parameters of the distance function, default is <code>NA</code> which means there are no distance function parameters. If several distance functions are supplied, this should be a list of lower boundary vectors for each function.</p>
</dd>
<dt><code>distanceParametersUpper</code></dt><dd><p> upper boundary for parameters of the distance function, default is <code>NA</code> which means there are no distance function parameters. If several distance functions are supplied, this should be a list of upper boundary vectors for each function.</p>
</dd>
<dt><code>distances</code></dt><dd><p> a distance matrix. If available, this matrix is used for model building, instead of calculating the distance matrix using the parameters <code>distanceFunction</code>. Default is <code>NULL</code>.</p>
</dd>
<dt><code>scaling</code></dt><dd><p> If TRUE: Distances values are divided by maximum distance to avoid scale bias.</p>
</dd>
<dt><code>reinterpolate</code></dt><dd><p> If TRUE: reinterpolation is used to generate better uncertainty estimates in the presence of noise. </p>
</dd>
<dt><code>combineDistances</code></dt><dd><p> By default, several distance functions or matrices are subject to a likelihood based decision, choosing one. If this parameter is TRUE, they are instead combined by determining a weighted sum. The weighting parameters are determined by MLE.</p>
</dd>
<dt><code>userParameters</code></dt><dd><p> By default: (<code>NULL</code>). Else, this vector is used instead of MLE to specify the model parameters, in the following order: kernel parameters, distance weights, lambda, distance parameters.</p>
</dd>
<dt><code>indefiniteMethod</code></dt><dd><p> The specific method used for correction: spectrum <code>"clip"</code>, spectrum <code>"flip"</code>, spectrum <code>"square"</code>, spectrum <code>"diffusion"</code>, feature embedding &quot;feature&quot;, nearest definite matrix &quot;near&quot;. Default is no correction: <code>"none"</code>. See Zaefferer and Bartz-Beielstein (2016).</p>
</dd>
<dt><code>indefiniteType</code></dt><dd><p>  The general type of correction for indefiniteness: <code>"NSD"</code>,<code>"CNSD"</code> or the default <code>"PSD"</code>. See Zaefferer and Bartz-Beielstein (2016). Note, that feature embedding may not work in case of multiple distance functions.</p>
</dd>
<dt><code>indefiniteRepair</code></dt><dd><p> boolean, whether conditions of the distance matrix (in case of <code>"NSD"</code>,<code>"CNSD"</code> correction type) or correlation matrix (in case of <code>"PSD"</code> correction type) are repaired.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic Kriging implementation is based on the work of Forrester et al. (2008). 
For adaptation of Kriging to mixed or combinatorial spaces, as well as
choosing distance measures with Maximum Likelihood Estimation, see the other two references (Zaefferer et al., 2014).
</p>


<h3>Value</h3>

<p>an object of class <code>modelKriging</code> containing the options (see control parameter) and determined parameters for the model:
</p>

<dl>
<dt><code>theta</code></dt><dd><p> parameters of the kernel / correlation function determined with MLE.</p>
</dd>
<dt><code>lambda</code></dt><dd><p> regularization constant (nugget) lambda</p>
</dd>
<dt><code>yMu</code></dt><dd><p> vector of observations y, minus MLE of mu</p>
</dd>
<dt><code>SSQ</code></dt><dd><p> Maximum Likelihood Estimate (MLE) of model parameter sigma^2</p>
</dd>
<dt><code>mu</code></dt><dd><p> MLE of model parameter mu</p>
</dd>
<dt><code>Psi</code></dt><dd><p> correlation matrix Psi</p>
</dd>
<dt><code>Psinv</code></dt><dd><p> inverse of Psi</p>
</dd>
<dt><code>nevals</code></dt><dd><p> number of Likelihood evaluations during MLE of theta/lambda/p</p>
</dd>
<dt><code>distanceFunctionIndexMLE</code></dt><dd><p> If a list of several distance measures (<code>distanceFunction</code>) was given, this parameter contains the index value of the measure chosen with MLE.</p>
</dd>
</dl>



<h3>References</h3>

<p>Forrester, Alexander I.J.; Sobester, Andras; Keane, Andy J. (2008). Engineering Design via Surrogate Modelling - A Practical Guide. John Wiley &amp; Sons.
</p>
<p>Zaefferer, Martin; Stork, Joerg; Friese, Martina; Fischbach, Andreas; Naujoks, Boris; Bartz-Beielstein, Thomas. (2014). Efficient global optimization for combinatorial problems. In Proceedings of the 2014 conference on Genetic and evolutionary computation (GECCO '14). ACM, New York, NY, USA, 871-878. DOI=10.1145/2576768.2598282
</p>
<p>Zaefferer, Martin; Stork, Joerg; Bartz-Beielstein, Thomas. (2014). Distance Measures for Permutations in Combinatorial Efficient Global Optimization. In Parallel Problem Solving from Nature - PPSN XIII (p. 373-383). Springer International Publishing.
</p>
<p>Zaefferer, Martin and Bartz-Beielstein, Thomas (2016). Efficient Global Optimization with Indefinite Kernels. Parallel Problem Solving from Nature-PPSN XIV. Accepted, in press. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.modelKriging">predict.modelKriging</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set random number generator seed
set.seed(1)
# Simple test landscape
fn &lt;- landscapeGeneratorUNI(1:5,distancePermutationHamming)
# Generate data for training and test
x &lt;- unique(replicate(40,sample(5),FALSE))
xtest &lt;- x[-(1:15)]
x &lt;- x[1:15]
# Determin true objective function values
y &lt;- fn(x)
ytest &lt;- fn(xtest)
# Build model
fit &lt;- modelKriging(x,y,distancePermutationHamming,
    control=list(algThetaControl=list(method="L-BFGS-B"),useLambda=FALSE))
# Predicted obj. function values
ypred &lt;- predict(fit,xtest)$y
# Uncertainty estimate
fit$predAll &lt;- TRUE
spred &lt;- predict(fit,xtest)$s
# Plot
plot(ytest,ypred,xlab="true value",ylab="predicted value",
    pch=20,xlim=c(0.3,1),ylim=c(min(ypred)-0.1,max(ypred)+0.1))
segments(ytest, ypred-spred,ytest, ypred+spred)
epsilon = 0.02
segments(ytest-epsilon,ypred-spred,ytest+epsilon,ypred-spred)
segments(ytest-epsilon,ypred+spred,ytest+epsilon,ypred+spred)
abline(0,1,lty=2)
# Use a different/custom optimizer (here: SANN) for maximum likelihood estimation: 
# (Note: Bound constraints are recommended, to avoid Inf values.
# This is really just a demonstration. SANN does not respect bound constraints.)
optimizer1 &lt;- function(x,fun,lower=NULL,upper=NULL,control=NULL,...){
  res &lt;- optim(x,fun,method="SANN",control=list(maxit=100),...)
  list(xbest=res$par,ybest=res$value,count=res$counts)
}
fit &lt;- modelKriging(x,y,distancePermutationHamming,
                   control=list(algTheta=optimizer1,useLambda=FALSE))
#One-dimensional optimizer (Brent). Note, that Brent will not work when 
#several parameters have to be set, e.g., when using nugget effect (lambda).
#However, Brent may be quite efficient otherwise.
optimizer2 &lt;- function(x,fun,lower,upper,control=NULL,...){
 res &lt;- optim(x,fun,method="Brent",lower=lower,upper=upper,...)
 list(xbest=res$par,ybest=res$value,count=res$counts)
}
fit &lt;- modelKriging(x,y,distancePermutationHamming,
                    control=list(algTheta=optimizer2,useLambda=FALSE))
</code></pre>

<hr>
<h2 id='modelKrigingClust'>Build clustered model</h2><span id='topic+modelKrigingClust'></span>

<h3>Description</h3>

<p>This function builds an ensemble of Gaussian Process model, where
each individual model is fitted to a partition of the parameter space.
Partitions are generated by.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelKrigingClust(x, y, distanceFunction, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelKrigingClust_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="modelKrigingClust_+3A_y">y</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code id="modelKrigingClust_+3A_distancefunction">distanceFunction</code></td>
<td>
<p>distanceFunction</p>
</td></tr>
<tr><td><code id="modelKrigingClust_+3A_control">control</code></td>
<td>
<p>control</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object
</p>

<hr>
<h2 id='modelKrigingDistanceCalculation'>Kriging: Distance Matrix Calculation</h2><span id='topic+modelKrigingDistanceCalculation'></span>

<h3>Description</h3>

<p>Calculate and scale the distance matrix used in a Kriging model.
Include definiteness correction.
Not to be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelKrigingDistanceCalculation(
  x,
  distanceFunction,
  parameters = NA,
  distances,
  scaling,
  combineDistances,
  indefiniteMethod,
  indefiniteType,
  indefiniteRepair,
  lower
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelKrigingDistanceCalculation_+3A_x">x</code></td>
<td>
<p>list of samples in input space</p>
</td></tr>
<tr><td><code id="modelKrigingDistanceCalculation_+3A_distancefunction">distanceFunction</code></td>
<td>
<p>a suitable distance function of type f(x1,x2), returning a scalar distance value, preferably between 0 and 1.
Maximum distances larger 1 are no problem, but may yield scaling bias when different measures are compared.
Should be non-negative and symmetric.  It can also be a list of several distance functions. In this case, Maximum Likelihood Estimation (MLE) is used 
to determine the most suited distance measure.
The distance function may have additional parameters.</p>
</td></tr>
<tr><td><code id="modelKrigingDistanceCalculation_+3A_parameters">parameters</code></td>
<td>
<p>parameters passed to the distance function as a vector.</p>
</td></tr>
<tr><td><code id="modelKrigingDistanceCalculation_+3A_distances">distances</code></td>
<td>
<p>precomputed distances, set to NA if not available.</p>
</td></tr>
<tr><td><code id="modelKrigingDistanceCalculation_+3A_scaling">scaling</code></td>
<td>
<p>boolean, whether to scale the distance matrix.</p>
</td></tr>
<tr><td><code id="modelKrigingDistanceCalculation_+3A_combinedistances">combineDistances</code></td>
<td>
<p>boolean, whether to combine the distances of different functions.</p>
</td></tr>
<tr><td><code id="modelKrigingDistanceCalculation_+3A_indefinitemethod">indefiniteMethod</code></td>
<td>
<p>method for handling non-conditionally-definite matrices.</p>
</td></tr>
<tr><td><code id="modelKrigingDistanceCalculation_+3A_indefinitetype">indefiniteType</code></td>
<td>
<p>type of handling for non-conditionally-definite matrices.</p>
</td></tr>
<tr><td><code id="modelKrigingDistanceCalculation_+3A_indefiniterepair">indefiniteRepair</code></td>
<td>
<p>whether to further repair other conditions (beside definiteness).</p>
</td></tr>
<tr><td><code id="modelKrigingDistanceCalculation_+3A_lower">lower</code></td>
<td>
<p>lower boundary for distance function parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with elements <code>D</code> (distance matrix), <code>maxD</code> (maximal distance for scaling purpose).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelKriging">modelKriging</a></code>
</p>

<hr>
<h2 id='modelKrigingInit'>Kriging: Initial guess and bounds</h2><span id='topic+modelKrigingInit'></span>

<h3>Description</h3>

<p>Initialize parameter tuning for the Kriging model, setting the initial guess
as well as bound constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelKrigingInit(
  startTheta = NULL,
  lowerTheta = NULL,
  upperTheta = NULL,
  useLambda,
  lambdaLower,
  lambdaUpper,
  combineDistances,
  nd,
  distanceParameters = F,
  distanceParametersLower = NA,
  distanceParametersUpper = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelKrigingInit_+3A_starttheta">startTheta</code></td>
<td>
<p>user provided start guess (optional).</p>
</td></tr>
<tr><td><code id="modelKrigingInit_+3A_lowertheta">lowerTheta</code></td>
<td>
<p>lower boundary for theta values (log scale), the kernel parameters.</p>
</td></tr>
<tr><td><code id="modelKrigingInit_+3A_uppertheta">upperTheta</code></td>
<td>
<p>upper boundary for theta values (log scale), the kernel parameters.</p>
</td></tr>
<tr><td><code id="modelKrigingInit_+3A_uselambda">useLambda</code></td>
<td>
<p>boolean, whether nugget effect (lambda) is used.</p>
</td></tr>
<tr><td><code id="modelKrigingInit_+3A_lambdalower">lambdaLower</code></td>
<td>
<p>lower boundary for lambda (log scale).</p>
</td></tr>
<tr><td><code id="modelKrigingInit_+3A_lambdaupper">lambdaUpper</code></td>
<td>
<p>upper boundary for lambda (log scale).</p>
</td></tr>
<tr><td><code id="modelKrigingInit_+3A_combinedistances">combineDistances</code></td>
<td>
<p>boolean, whether multiple distances are combined.</p>
</td></tr>
<tr><td><code id="modelKrigingInit_+3A_nd">nd</code></td>
<td>
<p>number of distance function.</p>
</td></tr>
<tr><td><code id="modelKrigingInit_+3A_distanceparameters">distanceParameters</code></td>
<td>
<p>whether the distance function parameters should be optimized</p>
</td></tr>
<tr><td><code id="modelKrigingInit_+3A_distanceparameterslower">distanceParametersLower</code></td>
<td>
<p>lower boundary for parameters of the distance function, default is <code>NA</code> which means there are no distance function parameters. If several distance functions are supplied, this should be a list of lower boundary vectors for each function.</p>
</td></tr>
<tr><td><code id="modelKrigingInit_+3A_distanceparametersupper">distanceParametersUpper</code></td>
<td>
<p>upper boundary for parameters of the distance function, default is <code>NA</code> which means there are no distance function parameters. If several distance functions are supplied, this should be a list of upper boundary vectors for each function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with elements <code>x0</code> (start guess), <code>lower</code> (lower bound), <code>upper</code> (upper bound).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelKriging">modelKriging</a></code>
</p>

<hr>
<h2 id='modelKrigingInternalPredictor'>Kriging Prediction (internal)</h2><span id='topic+modelKrigingInternalPredictor'></span>

<h3>Description</h3>

<p>Predict with a model fit resulting from <code><a href="#topic+modelKriging">modelKriging</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelKrigingInternalPredictor(object, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelKrigingInternalPredictor_+3A_object">object</code></td>
<td>
<p>fit of the Kriging model (settings and parameters), of class <code>modelKriging</code>.</p>
</td></tr>
<tr><td><code id="modelKrigingInternalPredictor_+3A_x">x</code></td>
<td>
<p>list of samples to be predicted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a list with:
</p>

<dl>
<dt><code>y</code></dt><dd><p>predicted values</p>
</dd>
<dt><code>psi</code></dt><dd><p>correlations between x and training data</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+simulate.modelKriging">simulate.modelKriging</a></code>
</p>
<p><code><a href="#topic+predict.modelKriging">predict.modelKriging</a></code>
</p>

<hr>
<h2 id='modelKrigingLikelihood'>Calculate negative log-likelihood</h2><span id='topic+modelKrigingLikelihood'></span>

<h3>Description</h3>

<p>Used to determine theta/lambda/p values for the Kriging model in <code><a href="#topic+modelKriging">modelKriging</a></code>
with Maximum Likelihood Estimation (MLE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelKrigingLikelihood(
  xt,
  D,
  y,
  useLambda = FALSE,
  corr = fcorrGauss,
  indefiniteMethod = "none",
  indefiniteType = "PSD",
  indefiniteRepair = FALSE,
  returnLikelihoodOnly = TRUE,
  inverter = "chol",
  ntheta = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelKrigingLikelihood_+3A_xt">xt</code></td>
<td>
<p>vector, containing parameters like theta, p and lambda.</p>
</td></tr>
<tr><td><code id="modelKrigingLikelihood_+3A_d">D</code></td>
<td>
<p>matrix (or list of multiple matrices) of distances between training samples. In case of multiple distance matrices, theta (part of xt) has to be a vector, giving a weighting parameter for each matrix.</p>
</td></tr>
<tr><td><code id="modelKrigingLikelihood_+3A_y">y</code></td>
<td>
<p>vector of observations at sample locations.</p>
</td></tr>
<tr><td><code id="modelKrigingLikelihood_+3A_uselambda">useLambda</code></td>
<td>
<p>whether to use nugget effect, i.e., lambda (FALSE at default).</p>
</td></tr>
<tr><td><code id="modelKrigingLikelihood_+3A_corr">corr</code></td>
<td>
<p>whether to use nugget effect, i.e., lambda (fcorrGauss at default).</p>
</td></tr>
<tr><td><code id="modelKrigingLikelihood_+3A_indefinitemethod">indefiniteMethod</code></td>
<td>
<p>The specific method used for correction: spectrum <code>"clip"</code>, spectrum <code>"flip"</code>, spectrum <code>"square"</code>, spectrum <code>"diffusion"</code>, feature embedding &quot;feature&quot;, nearest definite matrix &quot;near&quot;. Default is no correction: <code>"none"</code>. See Zaefferer and Bartz-Beielstein (2016).</p>
</td></tr>
<tr><td><code id="modelKrigingLikelihood_+3A_indefinitetype">indefiniteType</code></td>
<td>
<p>The general type of correction for indefiniteness: <code>"NSD"</code>,<code>"CNSD"</code> or the default <code>"PSD"</code>. See Zaefferer and Bartz-Beielstein (2016).</p>
</td></tr>
<tr><td><code id="modelKrigingLikelihood_+3A_indefiniterepair">indefiniteRepair</code></td>
<td>
<p>boolean, whether conditions of the distance matrix (in case of <code>"NSD"</code>,<code>"CNSD"</code> correction type) or correlation matrix (in case of <code>"PSD"</code> correction type) are repaired.</p>
</td></tr>
<tr><td><code id="modelKrigingLikelihood_+3A_returnlikelihoodonly">returnLikelihoodOnly</code></td>
<td>
<p>boolean, whether the function should return only the likelihood, or a else a list (see return information below).</p>
</td></tr>
<tr><td><code id="modelKrigingLikelihood_+3A_inverter">inverter</code></td>
<td>
<p>string, defining the inverter to use. default <code>"chol"</code> is inversion via <code>chol2inv</code>. A different string will lead to use of <code>solve</code>.</p>
</td></tr>
<tr><td><code id="modelKrigingLikelihood_+3A_ntheta">ntheta</code></td>
<td>
<p>number of kernel parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric Likelihood value (if <code>returnLikelihoodOnly</code> is TRUE) or a list with elements:
</p>

<dl>
<dt><code>NegLnLike</code></dt><dd><p> concentrated log-likelihood *-1 for minimising </p>
</dd>
<dt><code>Psi</code></dt><dd><p> correlation matrix</p>
</dd>
<dt><code>Psinv</code></dt><dd><p> inverse of correlation matrix (to save computation time in forrRegPredictor)</p>
</dd>
<dt><code>mu</code></dt><dd><p> MLE of model parameter mu </p>
</dd>
<dt><code>yMu</code></dt><dd><p> vector of observations y minus mu</p>
</dd>
<dt><code>SSQ</code></dt><dd><p> MLE of model parameter sigma^2</p>
</dd>
<dt><code>a</code></dt><dd><p> transformation vector for eigenspectrum transformation, see Zaefferer and Bartz-Beielstein (2016)</p>
</dd>
<dt><code>U</code></dt><dd><p> Matrix of eigenvectors for eigenspectrum transformation, see Zaefferer and Bartz-Beielstein (2016)</p>
</dd>
<dt><code>isIndefinite</code></dt><dd><p> whether the uncorrected correlation (kernel) matrix is indefinite</p>
</dd>
</dl>



<h3>References</h3>

<p>Forrester, Alexander I.J.; Sobester, Andras; Keane, Andy J. (2008). Engineering Design via Surrogate Modelling - A Practical Guide. John Wiley &amp; Sons.
</p>
<p>Zaefferer, Martin; Stork, Joerg; Friese, Martina; Fischbach, Andreas; Naujoks, Boris; Bartz-Beielstein, Thomas. (2014). Efficient global optimization for combinatorial problems. In Proceedings of the 2014 conference on Genetic and evolutionary computation (GECCO '14). ACM, New York, NY, USA, 871-878. DOI=10.1145/2576768.2598282
</p>
<p>Zaefferer, Martin; Stork, Joerg; Bartz-Beielstein, Thomas. (2014). Distance Measures for Permutations in Combinatorial Efficient Global Optimization. In Parallel Problem Solving from Nature - PPSN XIII (p. 373-383). Springer International Publishing.
</p>
<p>Martin Zaefferer and Thomas Bartz-Beielstein. (2016). Efficient Global Optimization with Indefinite Kernels. Parallel Problem Solving from Nature-PPSN XIV. Accepted, in press. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelKriging">modelKriging</a></code>
</p>

<hr>
<h2 id='modelKrigingParameterizedLikelihood'>Calculate negative log-likelihood</h2><span id='topic+modelKrigingParameterizedLikelihood'></span>

<h3>Description</h3>

<p>This is a wrapper for the Kriging likelihood function <code><a href="#topic+modelKrigingLikelihood">modelKrigingLikelihood</a></code>.
It is intended for the case where parameters of the distance function are also optimized
during maximum likelihood estimation. Thus, the wrapper receives the data, computes the
parameterized distance matrix and passes it to the standard likelihood function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelKrigingParameterizedLikelihood(
  xt,
  xs,
  ys,
  useLambda = FALSE,
  corr = fcorrGauss,
  indefiniteMethod = "none",
  indefiniteType = "PSD",
  indefiniteRepair = FALSE,
  returnLikelihoodOnly = TRUE,
  inverter = "chol",
  distanceFunction,
  combineDistances,
  distanceParametersLower,
  ntheta,
  scaling
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelKrigingParameterizedLikelihood_+3A_xt">xt</code></td>
<td>
<p>vector, containing parameters like theta, p and lambda.</p>
</td></tr>
<tr><td><code id="modelKrigingParameterizedLikelihood_+3A_xs">xs</code></td>
<td>
<p>training samples, which are the input for the distance function. Should be in list format.</p>
</td></tr>
<tr><td><code id="modelKrigingParameterizedLikelihood_+3A_ys">ys</code></td>
<td>
<p>vector of observations at training sample locations.</p>
</td></tr>
<tr><td><code id="modelKrigingParameterizedLikelihood_+3A_uselambda">useLambda</code></td>
<td>
<p>whether to use nugget effect, i.e., lambda (FALSE at default).</p>
</td></tr>
<tr><td><code id="modelKrigingParameterizedLikelihood_+3A_corr">corr</code></td>
<td>
<p>whether to use nugget effect, i.e., lambda (fcorrGauss at default).</p>
</td></tr>
<tr><td><code id="modelKrigingParameterizedLikelihood_+3A_indefinitemethod">indefiniteMethod</code></td>
<td>
<p>The specific method used for correction: spectrum <code>"clip"</code>, spectrum <code>"flip"</code>, spectrum <code>"square"</code>, spectrum <code>"diffusion"</code>, feature embedding &quot;feature&quot;, nearest definite matrix &quot;near&quot;. Default is no correction: <code>"none"</code>. See Zaefferer and Bartz-Beielstein (2016).</p>
</td></tr>
<tr><td><code id="modelKrigingParameterizedLikelihood_+3A_indefinitetype">indefiniteType</code></td>
<td>
<p>The general type of correction for indefiniteness: <code>"NSD"</code>,<code>"CNSD"</code> or the default <code>"PSD"</code>. See Zaefferer and Bartz-Beielstein (2016).</p>
</td></tr>
<tr><td><code id="modelKrigingParameterizedLikelihood_+3A_indefiniterepair">indefiniteRepair</code></td>
<td>
<p>boolean, whether conditions of the distance matrix (in case of <code>"NSD"</code>,<code>"CNSD"</code> correction type) or correlation matrix (in case of <code>"PSD"</code> correction type) are repaired.</p>
</td></tr>
<tr><td><code id="modelKrigingParameterizedLikelihood_+3A_returnlikelihoodonly">returnLikelihoodOnly</code></td>
<td>
<p>boolean, whether the function should return only the likelihood, or a else a list (see return information below).</p>
</td></tr>
<tr><td><code id="modelKrigingParameterizedLikelihood_+3A_inverter">inverter</code></td>
<td>
<p>string specifying method for inversion of correlation matrix (&quot;chol&quot;, cholesky decomposition at default, any other string leads to using the solve function).</p>
</td></tr>
<tr><td><code id="modelKrigingParameterizedLikelihood_+3A_distancefunction">distanceFunction</code></td>
<td>
<p>the distance function.</p>
</td></tr>
<tr><td><code id="modelKrigingParameterizedLikelihood_+3A_combinedistances">combineDistances</code></td>
<td>
<p>boolean, whether to combine several distances provided as a list of distance functions.</p>
</td></tr>
<tr><td><code id="modelKrigingParameterizedLikelihood_+3A_distanceparameterslower">distanceParametersLower</code></td>
<td>
<p>lower boundary for the distance function(s) parameters. A vector in case of one distance, a list of vectors in case of several functions. The parameters are passed as a vector to each respective distance function.</p>
</td></tr>
<tr><td><code id="modelKrigingParameterizedLikelihood_+3A_ntheta">ntheta</code></td>
<td>
<p>number of kernel parameters.</p>
</td></tr>
<tr><td><code id="modelKrigingParameterizedLikelihood_+3A_scaling">scaling</code></td>
<td>
<p>boolean, whether to scale the distance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the numeric Likelihood value (if <code>returnLikelihoodOnly</code> is TRUE) or a list with elements:
</p>

<dl>
<dt><code>NegLnLike</code></dt><dd><p> concentrated log-likelihood *-1 for minimising</p>
</dd>
<dt><code>Psi</code></dt><dd><p> correlation matrix</p>
</dd>
<dt><code>Psinv</code></dt><dd><p> inverse of correlation matrix (to save computation time in forrRegPredictor)</p>
</dd>
<dt><code>mu</code></dt><dd><p> MLE of model parameter mu </p>
</dd>
<dt><code>yMu</code></dt><dd><p> vector of observations y minus mu</p>
</dd>
<dt><code>SSQ</code></dt><dd><p> MLE of model parameter sigma^2</p>
</dd>
<dt><code>a</code></dt><dd><p> transformation vector for eigenspectrum transformation, see Zaefferer and Bartz-Beielstein (2016)</p>
</dd>
<dt><code>U</code></dt><dd><p> Matrix of eigenvectors for eigenspectrum transformation, see Zaefferer and Bartz-Beielstein (2016)</p>
</dd>
<dt><code>isIndefinite</code></dt><dd><p> whether the uncorrected correlation (kernel) matrix is indefinite</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+modelKrigingLikelihood">modelKrigingLikelihood</a></code>
</p>

<hr>
<h2 id='modelLinear'>Distance based Linear Model</h2><span id='topic+modelLinear'></span>

<h3>Description</h3>

<p>A simple linear model based on arbitrary distances. Comparable to a k nearest neighbor model, but potentially able to extrapolate
into regions of improvement. Used as a simple baseline by Zaefferer et al.(2014).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelLinear(x, y, distanceFunction, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelLinear_+3A_x">x</code></td>
<td>
<p>list of samples in input space</p>
</td></tr>
<tr><td><code id="modelLinear_+3A_y">y</code></td>
<td>
<p>matrix, vector of observations for each sample</p>
</td></tr>
<tr><td><code id="modelLinear_+3A_distancefunction">distanceFunction</code></td>
<td>
<p>a suitable distance function of type f(x1,x2), returning a scalar distance value, preferably between 0 and 1.
Maximum distances larger 1 are no problem, but may yield scaling bias when different measures are compared.
Should be non-negative and symmetric.</p>
</td></tr>
<tr><td><code id="modelLinear_+3A_control">control</code></td>
<td>
<p>currently unused, defaults to <code>list()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a fit (list, modelLinear), with the options and found parameters for the model which has to be passed to the predictor function:
</p>

<dl>
<dt><code>x</code></dt><dd><p> samples in input space (see parameters)</p>
</dd>
<dt><code>y</code></dt><dd><p> observations for each sample (see parameters)</p>
</dd>
<dt><code>distanceFunction</code></dt><dd><p> distance function (see parameters)</p>
</dd>
</dl>



<h3>References</h3>

<p>Zaefferer, Martin; Stork, Joerg; Friese, Martina; Fischbach, Andreas; Naujoks, Boris; Bartz-Beielstein, Thomas. (2014). Efficient global optimization for combinatorial problems. In Proceedings of the 2014 conference on Genetic and evolutionary computation (GECCO '14). ACM, New York, NY, USA, 871-878. DOI=10.1145/2576768.2598282
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.modelLinear">predict.modelLinear</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#set random number generator seed
set.seed(1)
#simple test landscape
fn &lt;- landscapeGeneratorUNI(1:5,distancePermutationHamming)
#generate data for training and test
x &lt;- unique(replicate(40,sample(5),FALSE))
xtest &lt;- x[-(1:15)]
x &lt;- x[1:15]
#determin true objective function values
y &lt;- fn(x)
ytest &lt;- fn(xtest)
#build model
fit &lt;- modelLinear(x,y,distancePermutationHamming)
#predicted obj. function values
ypred &lt;- predict(fit,xtest)$y
#plot
plot(ytest,ypred,xlab="true value",ylab="predicted value",
    pch=20,xlim=c(0.3,1),ylim=c(min(ypred)-0.1,max(ypred)+0.1))
abline(0,1,lty=2)
</code></pre>

<hr>
<h2 id='modelRBFN'>RBFN Model</h2><span id='topic+modelRBFN'></span>

<h3>Description</h3>

<p>Implementation of a distance-based Radial Basis Function Network (RBFN) model, e.g., for mixed or combinatorial input spaces.
It is based on employing suitable distance measures for the samples in input space. For reference, see
the paper by Moraglio and Kattan (2011).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelRBFN(x, y, distanceFunction, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelRBFN_+3A_x">x</code></td>
<td>
<p>list of samples in input space</p>
</td></tr>
<tr><td><code id="modelRBFN_+3A_y">y</code></td>
<td>
<p>column vector of observations for each sample</p>
</td></tr>
<tr><td><code id="modelRBFN_+3A_distancefunction">distanceFunction</code></td>
<td>
<p>a suitable distance function of type f(x1,x2), returning a scalar distance value, preferably between 0 and 1.
Maximum distances larger 1 are no problem, but may yield scaling bias when different measures are compared.
Should be non-negative and symmetric.</p>
</td></tr>
<tr><td><code id="modelRBFN_+3A_control">control</code></td>
<td>
<p>(list), with the options for the model building procedure:
</p>

<dl>
<dt><code>beta</code></dt><dd><p> Parameter of the radial basis function: exp(-beta*D), where D is the distance matrix. If beta is not specified, the heuristic in fbeta will be used to determine it, which is default behavior.</p>
</dd>
<dt><code>fbeta</code></dt><dd><p> Function f(x) to calculate the beta parameter, x is the maximum distance observed in the input data. Default function is <code>1/(2*(x^2))</code>.</p>
</dd> 
<dt><code>distances</code></dt><dd><p> a distance matrix. If available, this matrix is used for model building, instead of calculating the distance matrix using the parameters <code>distanceFunction</code>. Default is <code>NULL</code>.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a fit (list, modelRBFN), with the options and found parameters for the model which has to be passed to the predictor function:
</p>

<dl>
<dt><code>SSQ</code></dt><dd><p> Variance of the observations (y)</p>
</dd>
<dt><code>centers</code></dt><dd><p> Centers of the RBFN model, samples in input space (see parameters)</p>
</dd>
<dt><code>w</code></dt><dd><p> Model parameters (weights) w</p>
</dd>
<dt><code>Phi</code></dt><dd><p> Gram matrix</p>
</dd>
<dt><code>Phinv</code></dt><dd><p> (Pseudo)-Inverse of Gram matrix</p>
</dd>
<dt><code>w0</code></dt><dd><p> Mean of observations (y)</p>
</dd>
<dt><code>dMax</code></dt><dd><p> Maximum observed distance</p>
</dd>
<dt><code>D</code></dt><dd><p> Matrix of distances between all samples</p>
</dd>
<dt><code>beta</code></dt><dd><p> See parameters</p>
</dd>
<dt><code>fbeta</code></dt><dd><p> See parameters</p>
</dd>
<dt><code>distanceFunction</code></dt><dd><p>See parameters</p>
</dd>
</dl>



<h3>References</h3>

<p>Moraglio, Alberto, and Ahmed Kattan. &quot;Geometric generalisation of surrogate model based optimisation to combinatorial spaces.&quot; Evolutionary Computation in Combinatorial Optimization. Springer Berlin Heidelberg, 2011. 142-154.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.modelRBFN">predict.modelRBFN</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#set random number generator seed
set.seed(1)
#simple test landscape
fn &lt;- landscapeGeneratorUNI(1:5,distancePermutationHamming)
#generate data for training and test
x &lt;- unique(replicate(40,sample(5),FALSE))
xtest &lt;- x[-(1:15)]
x &lt;- x[1:15]
#determin true objective function values
y &lt;- fn(x)
ytest &lt;- fn(xtest)
#build model
fit &lt;- modelRBFN(x,y,distancePermutationHamming)
#predicted obj. function values
ypred &lt;- predict(fit,xtest)$y
#plot
plot(ytest,ypred,xlab="true value",ylab="predicted value",
    pch=20,xlim=c(0.3,1),ylim=c(min(ypred)-0.1,max(ypred)+0.1))
abline(0,1,lty=2)
</code></pre>

<hr>
<h2 id='mutationBinaryBitFlip'>Bit-flip Mutation for Bit-strings</h2><span id='topic+mutationBinaryBitFlip'></span>

<h3>Description</h3>

<p>Given a population of bit-strings, this function mutates all 
individuals by randomly inverting one or more bits in each individual.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutationBinaryBitFlip(population, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutationBinaryBitFlip_+3A_population">population</code></td>
<td>
<p>List of bit-strings</p>
</td></tr>
<tr><td><code id="mutationBinaryBitFlip_+3A_parameters">parameters</code></td>
<td>
<p>list of parameters: parameters$mutationRate =&gt; mutation rate, specifying number of bits flipped. Should be in range between zero and one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mutated population
</p>

<hr>
<h2 id='mutationBinaryBlockInversion'>Block Inversion Mutation for Bit-strings</h2><span id='topic+mutationBinaryBlockInversion'></span>

<h3>Description</h3>

<p>Given a population of bit-strings, this function mutates all 
individuals by inverting a whole block, randomly selected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutationBinaryBlockInversion(population, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutationBinaryBlockInversion_+3A_population">population</code></td>
<td>
<p>List of bit-strings</p>
</td></tr>
<tr><td><code id="mutationBinaryBlockInversion_+3A_parameters">parameters</code></td>
<td>
<p>list of parameters: parameters$mutationRate =&gt; mutation rate, specifying number of bits flipped. Should be in range between zero and one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mutated population
</p>

<hr>
<h2 id='mutationBinaryCycle'>Cycle Mutation for Bit-strings</h2><span id='topic+mutationBinaryCycle'></span>

<h3>Description</h3>

<p>Given a population of bit-strings, this function mutates all 
individuals by cyclical shifting the string to the right or left.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutationBinaryCycle(population, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutationBinaryCycle_+3A_population">population</code></td>
<td>
<p>List of bit-strings</p>
</td></tr>
<tr><td><code id="mutationBinaryCycle_+3A_parameters">parameters</code></td>
<td>
<p>list of parameters: parameters$mutationRate =&gt; mutation rate, specifying number of bits flipped. Should be in range between zero and one</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mutated population
</p>

<hr>
<h2 id='mutationBinarySingleBitFlip'>Single Bit-flip Mutation for Bit-strings</h2><span id='topic+mutationBinarySingleBitFlip'></span>

<h3>Description</h3>

<p>Given a population of bit-strings, this function mutates all 
individuals by randomly inverting one bit in each individual. 
Due to the fixed mutation rate, this is computationally faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutationBinarySingleBitFlip(population, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutationBinarySingleBitFlip_+3A_population">population</code></td>
<td>
<p>List of bit-strings</p>
</td></tr>
<tr><td><code id="mutationBinarySingleBitFlip_+3A_parameters">parameters</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mutated population
</p>

<hr>
<h2 id='mutationPermutationInsert'>Insert Mutation for Permutations</h2><span id='topic+mutationPermutationInsert'></span>

<h3>Description</h3>

<p>Given a population of permutations, this function mutates all 
individuals by randomly selecting two indices.
The element at index1 is moved to positition index2, other elements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutationPermutationInsert(population, parameters = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutationPermutationInsert_+3A_population">population</code></td>
<td>
<p>List of permutations</p>
</td></tr>
<tr><td><code id="mutationPermutationInsert_+3A_parameters">parameters</code></td>
<td>
<p>list of parameters, currently only uses parameters$mutationRate, 
which should be between 0 and 1 (but can be larger than 1). The mutation rate determines the number of reversals
performed, relative to the permutation length (N). 0 means none. 1 means N reversals.
The default is 1/N.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mutated population
</p>

<hr>
<h2 id='mutationPermutationInterchange'>Interchange Mutation for Permutations</h2><span id='topic+mutationPermutationInterchange'></span>

<h3>Description</h3>

<p>Given a population of permutations, this function mutates all 
individuals by randomly interchanging two arbitrary elements of the permutation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutationPermutationInterchange(population, parameters = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutationPermutationInterchange_+3A_population">population</code></td>
<td>
<p>List of permutations</p>
</td></tr>
<tr><td><code id="mutationPermutationInterchange_+3A_parameters">parameters</code></td>
<td>
<p>list of parameters, currently only uses parameters$mutationRate, 
which should be between 0 and 1 (but can be larger than 1). The mutation rate determines the number of interchanges
performed, relative to the permutation length (N). 0 means none. 1 means N interchanges.
The default is 1/N.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mutated population
</p>

<hr>
<h2 id='mutationPermutationInterchangeCore'>Interchange of permutation elements</h2><span id='topic+mutationPermutationInterchangeCore'></span>

<h3>Description</h3>

<p>Support function for <code><a href="#topic+mutationPermutationInterchange">mutationPermutationInterchange</a></code> and <code><a href="#topic+mutationPermutationSwap">mutationPermutationSwap</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutationPermutationInterchangeCore(
  population,
  popsize,
  mutations,
  index1,
  index2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutationPermutationInterchangeCore_+3A_population">population</code></td>
<td>
<p>List of permutations</p>
</td></tr>
<tr><td><code id="mutationPermutationInterchangeCore_+3A_popsize">popsize</code></td>
<td>
<p>population size</p>
</td></tr>
<tr><td><code id="mutationPermutationInterchangeCore_+3A_mutations">mutations</code></td>
<td>
<p>number of mutated elements for each individual</p>
</td></tr>
<tr><td><code id="mutationPermutationInterchangeCore_+3A_index1">index1</code></td>
<td>
<p>vector of first indices, one element for each interchange</p>
</td></tr>
<tr><td><code id="mutationPermutationInterchangeCore_+3A_index2">index2</code></td>
<td>
<p>vector of second indices, one element for each interchange</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mutated population
</p>

<hr>
<h2 id='mutationPermutationReversal'>Reversal Mutation for Permutations</h2><span id='topic+mutationPermutationReversal'></span>

<h3>Description</h3>

<p>Given a population of permutations, this function mutates all 
individuals by randomly selecting two indices, and reversing the respective sub-permutation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutationPermutationReversal(population, parameters = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutationPermutationReversal_+3A_population">population</code></td>
<td>
<p>List of permutations</p>
</td></tr>
<tr><td><code id="mutationPermutationReversal_+3A_parameters">parameters</code></td>
<td>
<p>list of parameters, currently only uses parameters$mutationRate, 
which should be between 0 and 1 (but can be larger than 1). The mutation rate determines the number of reversals
performed, relative to the permutation length (N). 0 means none. 1 means N reversals.
The default is 1/N.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mutated population
</p>

<hr>
<h2 id='mutationPermutationSwap'>Swap Mutation for Permutations</h2><span id='topic+mutationPermutationSwap'></span>

<h3>Description</h3>

<p>Given a population of permutations, this function mutates all 
individuals by randomly interchanging two adjacent elements of the permutation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutationPermutationSwap(population, parameters = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutationPermutationSwap_+3A_population">population</code></td>
<td>
<p>List of permutations</p>
</td></tr>
<tr><td><code id="mutationPermutationSwap_+3A_parameters">parameters</code></td>
<td>
<p>list of parameters, currently only uses parameters$mutationRate, 
which should be between 0 and 1 (but can be larger than 1). The mutation rate determines the number of swaps
performed, relative to the permutation length (N). 0 means none. 1 means N swaps.
The default is 1/N.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mutated population
</p>

<hr>
<h2 id='mutationSelfAdapt'>Self-adaptive mutation operator</h2><span id='topic+mutationSelfAdapt'></span>

<h3>Description</h3>

<p>This mutation function selects an operator and mutationRate (provided in parameters$mutationFunctions)
based on self-adaptive parameters chosen for each individual separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutationSelfAdapt(population, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutationSelfAdapt_+3A_population">population</code></td>
<td>
<p>List of permutations</p>
</td></tr>
<tr><td><code id="mutationSelfAdapt_+3A_parameters">parameters</code></td>
<td>
<p>list, contains the available single mutation functions (<code>mutationFunctions</code>), 
and a data.frame that collects the chosen function and mutation rate for each individual (<code>selfAdapt</code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+optimEA">optimEA</a></code>, <code><a href="#topic+recombinationSelfAdapt">recombinationSelfAdapt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seed=0
N=5
#distance
dF &lt;- distancePermutationHamming
#mutation
mFs &lt;- c(mutationPermutationSwap,mutationPermutationInterchange,
mutationPermutationInsert,mutationPermutationReversal)
rFs &lt;- c(recombinationPermutationCycleCrossover,recombinationPermutationOrderCrossover1,
recombinationPermutationPositionBased,recombinationPermutationAlternatingPosition)
mF &lt;- mutationSelfAdapt
selfAdaptiveParameters &lt;- list(
	mutationRate = list(type="numeric", lower=1/N,upper=1, default=1/N),
	mutationOperator = list(type="discrete", values=1:4, default=expression(sample(4,1))), 
#1: swap, 2: interchange, 3: insert, 4: reversal mutation
recombinationOperator = list(type="discrete", values=1:4, default=expression(sample(4,1))) 
#1: CycleX, 2: OrderX, 3: PositionX, 4: AlternatingPosition
)
#recombination
rF &lt;-  recombinationSelfAdapt	 
#creation
cF &lt;- function()sample(N)
#objective function
lF &lt;- landscapeGeneratorUNI(1:N,dF)
#start optimization
set.seed(seed)
res &lt;- optimEA(,lF,list(parameters=list(mutationFunctions=mFs,recombinationFunctions=rFs),
	creationFunction=cF,mutationFunction=mF,recombinationFunction=rF,
	popsize=15,budget=100,targetY=0,verbosity=1,selfAdaption=selfAdaptiveParameters,
	vectorized=TRUE)) ##target function is "vectorized", expects list as input
res$xbest 
</code></pre>

<hr>
<h2 id='mutationStringRandomChange'>Mutation for Strings</h2><span id='topic+mutationStringRandomChange'></span>

<h3>Description</h3>

<p>Given a population of strings, this function mutates all 
individuals by randomly changing an element of the string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutationStringRandomChange(population, parameters = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mutationStringRandomChange_+3A_population">population</code></td>
<td>
<p>List of permutations</p>
</td></tr>
<tr><td><code id="mutationStringRandomChange_+3A_parameters">parameters</code></td>
<td>
<p>list of parameters, with <code>parameters$mutationRate</code> and <code>parameters$lts</code>.
<code>parameters$mutationRate</code> should be between 0 and 1 (but can be larger than 1). The mutation rate determines the number of interchanges
performed, relative to the permutation length (N). 0 means none. 1 means N interchanges.
The default is 1/N. <code>parameters$lts</code> are the possible letters in the string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mutated population
</p>

<hr>
<h2 id='nearCNSD'>Nearest CNSD matrix</h2><span id='topic+nearCNSD'></span>

<h3>Description</h3>

<p>This function
implements the alternating projection algorithm by Glunt et al. (1990) to calculate the nearest conditionally
negative semi-definite (CNSD) matrix (or: the nearest Euclidean distance matrix).
The function is similar to the <code><a href="Matrix.html#topic+nearPD">nearPD</a></code> function from the <code>Matrix</code> package, 
which implements a very similar algorithm for finding the nearest Positive Semi-Definite (PSD) matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearCNSD(
  x,
  eig.tol = 1e-08,
  conv.tol = 1e-08,
  maxit = 1000,
  conv.norm.type = "F"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nearCNSD_+3A_x">x</code></td>
<td>
<p>symmetric matrix, to be turned into a CNSD matrix.</p>
</td></tr>
<tr><td><code id="nearCNSD_+3A_eig.tol">eig.tol</code></td>
<td>
<p>eigenvalue torelance value. Eigenvalues between <code>-tol</code> and <code>tol</code> are assumed to be zero.</p>
</td></tr>
<tr><td><code id="nearCNSD_+3A_conv.tol">conv.tol</code></td>
<td>
<p>convergence torelance value. The algorithm stops if the norm of the difference between two iterations is below this value.</p>
</td></tr>
<tr><td><code id="nearCNSD_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations. The algorithm stops if this value is exceeded, even if not converged.</p>
</td></tr>
<tr><td><code id="nearCNSD_+3A_conv.norm.type">conv.norm.type</code></td>
<td>
<p>type of norm, by default the F-norm (Frobenius). See <code><a href="base.html#topic+norm">norm</a></code> for other choices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with:
</p>

<dl>
<dt><code>mat</code></dt><dd><p> nearestCNSD matrix</p>
</dd>
<dt><code>normF</code></dt><dd><p> F-norm between original and resulting matrices</p>
</dd>
<dt><code>iterations</code></dt><dd><p> the number of performed</p>
</dd>
<dt><code>rel.tol</code></dt><dd><p> the relative value used for the tolerance convergence criterion</p>
</dd>
<dt><code>converged</code></dt><dd><p> a boolean that records whether the algorithm</p>
</dd>
</dl>



<h3>References</h3>

<p>Glunt, W.; Hayden, T. L.; Hong, S. and Wells, J. An alternating projection algorithm for computing the nearest Euclidean distance matrix, SIAM Journal on Matrix Analysis and Applications, SIAM, 1990, 11, 589-600
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+nearPD">nearPD</a></code>, <code><a href="#topic+correctionCNSD">correctionCNSD</a></code>, <code><a href="#topic+correctionDistanceMatrix">correctionDistanceMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example using Insert distance with permutations:
x &lt;- list(c(2,1,4,3),c(2,4,3,1),c(4,2,1,3),c(4,3,2,1),c(1,4,3,2))
D &lt;- distanceMatrix(x,distancePermutationInsert)
print(D)
is.CNSD(D)
nearD &lt;- nearCNSD(D)
print(nearD)
is.CNSD(nearD$mat)
# or example matrix from Glunt et al. (1990):
D &lt;- matrix(c(0,1,1,1,0,9,1,9,0),3,3)
print(D)
is.CNSD(D)
nearD &lt;- nearCNSD(D)
print(nearD)
is.CNSD(nearD$mat)
# note, that the resulting values given by Glunt et al. (1990) are 19/9 and 76/9
</code></pre>

<hr>
<h2 id='optim2Opt'>Two-Opt</h2><span id='topic+optim2Opt'></span>

<h3>Description</h3>

<p>Implementation of a Two-Opt local search.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optim2Opt(x = NULL, fun, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optim2Opt_+3A_x">x</code></td>
<td>
<p>start solution of the local search</p>
</td></tr>
<tr><td><code id="optim2Opt_+3A_fun">fun</code></td>
<td>
<p>function that determines cost or length of a route/permutation</p>
</td></tr>
<tr><td><code id="optim2Opt_+3A_control">control</code></td>
<td>
<p>(list), with the options:
</p>

<dl>
<dt><code>archive</code></dt><dd><p> Whether to keep all candidate solutions and their fitness in an archive (TRUE) or not (FALSE). Default is TRUE.</p>
</dd>
<dt><code>budget</code></dt><dd><p> The limit on number of target function evaluations (stopping criterion) (default: 100)</p>
</dd>
<dt><code>creationFunction</code></dt><dd><p> Function to create individuals/solutions in search space. Default is a function that creates random permutations of length 6</p>
</dd>
<dt><code>vectorized</code></dt><dd><p> Boolean. Defines whether target function is vectorized (takes a list of solutions 
as argument) or not (takes single solution as argument). Default: FALSE</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with:
</p>

<dl>
<dt><code>xbest</code></dt><dd><p> best solution found</p>
</dd>
<dt><code>ybest</code></dt><dd><p> fitness of the best solution</p>
</dd>
<dt><code>count</code></dt><dd><p> number of performed target function evaluations </p>
</dd>
</dl>



<h3>References</h3>

<p>Wikipedia contributors. &quot;2-opt.&quot; Wikipedia, The Free Encyclopedia. Wikipedia, The Free Encyclopedia, 13 Jun. 2014. Web. 21 Oct. 2014.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimCEGO">optimCEGO</a></code>, <code><a href="#topic+optimEA">optimEA</a></code>, <code><a href="#topic+optimRS">optimRS</a></code>, <code><a href="#topic+optimMaxMinDist">optimMaxMinDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seed=0
#distance
dF &lt;- distancePermutationHamming
#creation
cF &lt;- function()sample(5)
#objective function
lF &lt;- landscapeGeneratorUNI(1:5,dF)
#start optimization
set.seed(seed)
res &lt;- optim2Opt(,lF,list(creationFunction=cF,budget=100,
   vectorized=TRUE)) ##target function is "vectorized", expects list of solutions as input
res

</code></pre>

<hr>
<h2 id='optimCEGO'>Combinatorial Efficient Global Optimization</h2><span id='topic+optimCEGO'></span>

<h3>Description</h3>

<p>Model-based optimization for combinatorial or mixed problems. Based on measures of distance or dissimilarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimCEGO(x = NULL, fun, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimCEGO_+3A_x">x</code></td>
<td>
<p>Optional initial design as a list. If NULL (default), <code>creationFunction</code> (in <code>control</code> list) is used to create initial design. 
If <code>x</code> has less individuals than specified by <code>control$evalInit</code>, <code>creationFunction</code> will fill up the design.</p>
</td></tr>
<tr><td><code id="optimCEGO_+3A_fun">fun</code></td>
<td>
<p>target function to be minimized</p>
</td></tr>
<tr><td><code id="optimCEGO_+3A_control">control</code></td>
<td>
<p>(list), with the options of optimization and model building approaches employed:
</p>

<dl>
<dt><code>evalInit</code></dt><dd><p> Number of initial evaluations (i.e., size of the initial design), integer, default is <code>2</code></p>
</dd>
<dt><code>vectorized</code></dt><dd><p> Boolean. Defines whether target function is vectorized (takes a list of solutions as argument) or not (takes single solution as argument). Default: FALSE</p>
</dd>
<dt><code>verbosity</code></dt><dd><p> Level of text output during run. Defaults to 0, no output.</p>
</dd>
<dt><code>plotting</code></dt><dd><p> Plot optimization progress during run (TRUE) or not (FALSE). Default is FALSE.</p>
</dd>
<dt><code>targetY</code></dt><dd><p> optimal value to be found, stopping criterion, default is <code>-Inf</code></p>
</dd>
<dt><code>budget</code></dt><dd><p> maximum number of target function evaluations, default is <code>100</code></p>
</dd>
<dt><code>creationRetries</code></dt><dd><p> When a model does not predict an actually improving solution, a random exploration step is performed. <code>creationRetries</code> solutions are created randomly. 
For each, distance to all known solutions is calculated. The minimum distance is recorded for each random solution. 
The random solution with maximal minimum distance is chosen doe be evaluated in the next iteration.</p>
</dd>
<dt><code>model</code></dt><dd><p> Model to be used as a surrogate of the target function. Default is &quot;K&quot; (Kriging). Also
available are: &quot;LM&quot; (linear, distance-based model), &quot;RBFN&quot; Radial Basis Function Network.</p>
</dd>
<dt><code>modelSettings</code></dt><dd><p> List of settings for <code>model</code> building, passed on as the <code>control</code> argument to the model training functions <code><a href="#topic+modelKriging">modelKriging</a></code>, <code><a href="#topic+modelLinear">modelLinear</a></code>, <code><a href="#topic+modelRBFN">modelRBFN</a></code>.</p>
</dd>
<dt><code>infill</code></dt><dd><p> This parameter specifies a function to be used for the infill criterion (e.g., the default is expected improvement <code>infillExpectedImprovement</code>).
To use no specific infill criterion this has to be set to <code>NA</code>, in which case the prediction of the surrogate model is used. Infill criteria are only used with models that may provide some error estimate with predictions.</p>
</dd>
<dt><code>optimizer</code></dt><dd><p> Optimizer that finds the minimum of the surrogate model. Default is <code><a href="#topic+optimEA">optimEA</a></code>, an Evolutionary Algorithm.</p>
</dd>
<dt><code>optimizerSettings</code></dt><dd><p> List of settings (<code>control</code>) for the <code>optimizer</code> function.</p>
</dd>
<dt><code>initialDesign</code></dt><dd><p> Design function that generates the initial design. Default is <code>designMaxMinDist</code>, which creates a design that maximizes the minimum distance between points.</p>
</dd>
<dt><code>initialDesignSettings</code></dt><dd><p> List of settings (<code>control</code>) for the <code>initialDesign</code> function.</p>
</dd>
<dt><code>creationFunction</code></dt><dd><p> Function to create individuals/solutions in search space. Default is a function that creates random permutations of length 6</p>
</dd>
<dt><code>distanceFunction</code></dt><dd><p> distanceFunction a suitable distance function of type f(x1,x2), returning a scalar distance value, preferably between 0 and 1.
Maximum distances larger 1 are not a problem, but may yield scaling bias when different measures are compared.
Should be non-negative and symmetric. With the setting <code>control$model="K"</code> this can also be a list of different fitness functions.
Default is Hamming distance for permutations: distancePermutationHamming.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a list:
</p>

<dl>
<dt><code>xbest</code></dt><dd><p> best solution found</p>
</dd>
<dt><code>ybest</code></dt><dd><p> fitness of the best solution</p>
</dd>
<dt><code>x</code></dt><dd><p> history of all evaluated solutions</p>
</dd>
<dt><code>y</code></dt><dd><p> corresponding target function values f(x)</p>
</dd>
<dt><code>fit</code></dt><dd><p> model-fit created in the last iteration</p>
</dd>
<dt><code>fpred</code></dt><dd><p> prediction function created in the last iteration</p>
</dd>
<dt><code>count</code></dt><dd><p> number of performed target function evaluations</p>
</dd>
<dt><code>message</code></dt><dd><p> message string, giving information on termination reason</p>
</dd>
<dt><code>convergence</code></dt><dd><p> error/status code: <code>-1</code> for termination due 
to failed model building, <code>0</code> for termination due to depleted budget, 
<code>1</code> if attained objective value is equal to or below target (<code>control$targetY</code>)</p>
</dd>
</dl>



<h3>References</h3>

<p>Zaefferer, Martin; Stork, Joerg; Friese, Martina; Fischbach, Andreas; Naujoks, Boris; Bartz-Beielstein, Thomas. (2014). Efficient global optimization for combinatorial problems. In Proceedings of the 2014 conference on Genetic and evolutionary computation (GECCO '14). ACM, New York, NY, USA, 871-878. DOI=10.1145/2576768.2598282
</p>
<p>Zaefferer, Martin; Stork, Joerg; Bartz-Beielstein, Thomas. (2014). Distance Measures for Permutations in Combinatorial Efficient Global Optimization. In Parallel Problem Solving from Nature - PPSN XIII (p. 373-383). Springer International Publishing.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelKriging">modelKriging</a></code>, <code><a href="#topic+modelLinear">modelLinear</a></code>, <code><a href="#topic+modelRBFN">modelRBFN</a></code>, <code><a href="#topic+buildModel">buildModel</a></code>, <code><a href="#topic+optimEA">optimEA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seed &lt;- 0
#distance
dF &lt;- distancePermutationHamming
#mutation
mF &lt;- mutationPermutationSwap
#recombination
rF &lt;-  recombinationPermutationCycleCrossover 
#creation
cF &lt;- function()sample(5)
#objective function
lF &lt;- landscapeGeneratorUNI(1:5,dF)
#start optimization
set.seed(seed)
res1 &lt;- optimCEGO(,lF,list(
			creationFunction=cF,
			distanceFunction=dF,
			optimizerSettings=list(budget=100,popsize=10,
			mutationFunction=mF,recombinationFunction=rF),
	evalInit=5,budget=15,targetY=0,verbosity=1,model=modelKriging,
	vectorized=TRUE)) ##target function is "vectorized", expects list as input
set.seed(seed)
res2 &lt;- optimCEGO(,lF,list(
			creationFunction=cF,
			distanceFunction=dF,
			optimizerSettings=list(budget=100,popsize=10,
			mutationFunction=mF,recombinationFunction=rF),
			evalInit=5,budget=15,targetY=0,verbosity=1,model=modelRBFN,
	vectorized=TRUE)) ##target function is "vectorized", expects list as input
res1$xbest 
res2$xbest 

</code></pre>

<hr>
<h2 id='optimEA'>Evolutionary Algorithm for Combinatorial Optimization</h2><span id='topic+optimEA'></span>

<h3>Description</h3>

<p>A basic implementation of a simple Evolutionary Algorithm for Combinatorial Optimization. Default evolutionary operators
aim at permutation optimization problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimEA(x = NULL, fun, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimEA_+3A_x">x</code></td>
<td>
<p>Optional start individual(s) as a list. If NULL (default), <code>creationFunction</code> (in <code>control</code> list) is used to create initial design. 
If <code>x</code> has less individuals than the population size, creationFunction will fill up the rest.</p>
</td></tr>
<tr><td><code id="optimEA_+3A_fun">fun</code></td>
<td>
<p>target function to be minimized</p>
</td></tr>
<tr><td><code id="optimEA_+3A_control">control</code></td>
<td>
<p>(list), with the options:
</p>

<dl>
<dt><code>budget</code></dt><dd><p>The limit on number of target function evaluations (stopping criterion) (default: 1000).</p>
</dd>
<dt><code>popsize</code></dt><dd><p>Population size (default: 100).</p>
</dd>
<dt><code>generations</code></dt><dd><p>Number of generations (stopping criterion) (default: Inf).</p>
</dd>
<dt><code>targetY</code></dt><dd><p>Target function value (stopping criterion) (default: -Inf).</p>
</dd>
<dt><code>vectorized</code></dt><dd><p>Boolean. Defines whether target function is vectorized (takes a list of solutions as argument) or not (takes single solution as argument). Default: FALSE.</p>
</dd>
<dt><code>verbosity</code></dt><dd><p>Level of text output during run. Defaults to 0, no output.</p>
</dd>
<dt><code>plotting</code></dt><dd><p>Plot optimization progress during run (TRUE) or not (FALSE). Default is FALSE.</p>
</dd>
<dt><code>archive</code></dt><dd><p>Whether to keep all candidate solutions and their fitness in an archive (TRUE) or not (FALSE). Default is TRUE. New solutions that are identical to an archived one, will not be evaluated. Instead, their fitness is taken from the archive.</p>
</dd>
<dt><code>recombinationFunction</code></dt><dd><p>Function that performs recombination, default: <code><a href="#topic+recombinationPermutationCycleCrossover">recombinationPermutationCycleCrossover</a></code>, which is cycle crossover for permutations.</p>
</dd>
<dt><code>recombinationRate</code></dt><dd><p>Number of offspring, defined by the fraction of the population (popsize) that will be recombined.</p>
</dd>
<dt><code>mutationFunction</code></dt><dd><p>Function that performs mutation, default: <code><a href="#topic+mutationPermutationSwap">mutationPermutationSwap</a></code>, which is swap mutation for permutations.</p>
</dd>
<dt><code>parameters</code></dt><dd><p>Default parameter list for the algorithm, e.g., mutation rate, etc.</p>
</dd>
<dt><code>selection</code></dt><dd><p>Survival selection process: &quot;tournament&quot; (default) or &quot;truncation&quot;.</p>
</dd>
<dt><code>tournamentSize</code></dt><dd><p>Tournament size (default: 2).</p>
</dd>
<dt><code>tournamentProbability</code></dt><dd><p>Tournament probability (default: 0.9).</p>
</dd>
<dt><code>localSearchFunction</code></dt><dd><p>If specified, this function is used for a local search step. Default is NULL. </p>
</dd>
<dt><code>localSearchRate</code></dt><dd><p>Specifies on what fraction of the population local search is applied. Default is zero. Maximum is 1 (100 percent).</p>
</dd>
<dt><code>localSearchSettings</code></dt><dd><p>List of settings passed to the local search function control parameter.</p>
</dd>
<dt><code>stoppingCriterionFunction</code></dt><dd><p>Custom additional stopping criterion. Function evaluated on the population, receiving all individuals (list) and their fitness (vector). If the result is FALSE, the algorithm stops.</p>
</dd>
<dt><code>verbosity</code></dt><dd><p>&gt;0 for text output.</p>
</dd>
<dt><code>creationFunction</code></dt><dd><p>Function to create individuals/solutions in search space. Default is a function that creates random permutations of length 6.</p>
</dd>
<dt><code>selfAdaption</code></dt><dd><p>An optional list object, that describes parameters of the optimization (see <code>parameters</code>) which are subject to self-adaption. An example is given in <a href="#topic+mutationSelfAdapt">mutationSelfAdapt</a>. Types of the parameters can be integer, discrete, or numeric.</p>
</dd>
<dt><code>selfAdaptTau</code></dt><dd><p>Positive numeric value, that controls the learning rate of numerical/integer self-adaptive parameters.</p>
</dd>
<dt><code>selfAdaptP</code></dt><dd><p>Value in [0,1]. A probability of mutation for all categorical, self-adaptive parameters.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a list:
</p>

<dl>
<dt><code>xbest</code></dt><dd><p>best solution found.</p>
</dd>
<dt><code>ybest</code></dt><dd><p>fitness of the best solution.</p>
</dd>
<dt><code>x</code></dt><dd><p>history of all evaluated solutions.</p>
</dd>
<dt><code>y</code></dt><dd><p>corresponding target function values f(x).</p>
</dd>
<dt><code>count</code></dt><dd><p>number of performed target function evaluations.</p>
</dd>
<dt><code>message</code></dt><dd><p>Termination message: Which stopping criterion was reached.</p>
</dd>
<dt><code>population</code></dt><dd><p>Last population.</p>
</dd>
<dt><code>fitness</code></dt><dd><p>Fitness of last population.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+optimCEGO">optimCEGO</a></code>, <code><a href="#topic+optimRS">optimRS</a></code>, <code><a href="#topic+optim2Opt">optim2Opt</a></code>, <code><a href="#topic+optimMaxMinDist">optimMaxMinDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#First example: permutation optimization
seed=0
#distance
dF &lt;- distancePermutationHamming
#mutation
mF &lt;- mutationPermutationSwap
#recombination
rF &lt;-  recombinationPermutationCycleCrossover 
#creation
cF &lt;- function()sample(5)
#objective function
lF &lt;- landscapeGeneratorUNI(1:5,dF)
#start optimization
set.seed(seed)
res &lt;- optimEA(,lF,list(creationFunction=cF,mutationFunction=mF,recombinationFunction=rF,
	popsize=6,budget=60,targetY=0,verbosity=1,
	vectorized=TRUE)) ##target function is "vectorized", expects list as input
res$xbest 
#Second example: binary string optimization
#number of bits
N &lt;- 50
#target function (simple example)
f &lt;- function(x){
 sum(x)
}
#function to create random Individuals
cf &lt;- function(){
		sample(c(FALSE,TRUE),N,replace=TRUE)
}
#control list
cntrl &lt;- list(
	budget = 100,
	popsize = 5,
	creationFunction = cf,
	vectorized = FALSE, #set to TRUE if f evaluates a list of individuals
	recombinationFunction = recombinationBinary2Point,
	recombinationRate = 0.1,
	mutationFunction = mutationBinaryBitFlip,
	parameters=list(mutationRate = 1/N),
	archive=FALSE #recommended for larger budgets. do not change.
)
#start algorithm
set.seed(1)
res &lt;- optimEA(fun=f,control=cntrl)
res$xbest
res$ybest

</code></pre>

<hr>
<h2 id='optimInterface'>Optimization Interface (continuous, bounded)</h2><span id='topic+optimInterface'></span>

<h3>Description</h3>

<p>This function is an interface fashioned like the <code><a href="stats.html#topic+optim">optim</a></code> function.
Unlike optim, it collects a set of bound-constrained optimization algorithms
with local as well as global approaches. It is, e.g., used in the CEGO package
to solve the optimization problem that occurs during parameter estimation
in the Kriging model (based on Maximum Likelihood Estimation).
Note that this function is NOT applicable to combinatorial optimization problems.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimInterface(x, fun, lower = -Inf, upper = Inf, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimInterface_+3A_x">x</code></td>
<td>
<p>is a point (vector) in the decision space of <code>fun</code></p>
</td></tr>
<tr><td><code id="optimInterface_+3A_fun">fun</code></td>
<td>
<p>is the target function of type <code>y = f(x, ...)</code></p>
</td></tr>
<tr><td><code id="optimInterface_+3A_lower">lower</code></td>
<td>
<p>is a vector that defines the lower boundary of search space</p>
</td></tr>
<tr><td><code id="optimInterface_+3A_upper">upper</code></td>
<td>
<p>is a vector that defines the upper boundary of search space</p>
</td></tr>
<tr><td><code id="optimInterface_+3A_control">control</code></td>
<td>
<p>is a list of additional settings. See details.</p>
</td></tr>
<tr><td><code id="optimInterface_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed on to <code>fun</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The control list contains:
</p>

<dl>
<dt><code>funEvals</code></dt><dd><p> stopping criterion, number of evaluations allowed for <code>fun</code>  (defaults to 100)</p>
</dd>
<dt><code>reltol</code></dt><dd><p> stopping criterion, relative tolerance  (default: 1e-6)</p>
</dd>
<dt><code>factr</code></dt><dd><p> stopping criterion, specifying relative tolerance parameter factr for the L-BFGS-B method in the optim function (default: 1e10) </p>
</dd>
<dt><code>popsize</code></dt><dd><p> population size or number of particles  (default: <code>10*dimension</code>, where <code>dimension</code> is derived from the length of the vector <code>lower</code>). </p>
</dd>
<dt><code>restarts</code></dt><dd><p> whether to perform restarts (Default: TRUE). Restarts will only be performed if some of the evaluation budget is left once the algorithm stopped due to some stopping criterion (e.g., reltol).</p>
</dd>
<dt><code>method</code></dt><dd><p> will be used to choose the optimization method from the following list:
&quot;L-BFGS-B&quot; - BFGS quasi-Newton: <code>stats</code> Package <code>optim</code> function<br />
&quot;nlminb&quot; - box-constrained optimization using PORT routines: <code>stats</code> Package <code>nlminb</code> function<br />
&quot;DEoptim&quot; - Differential Evolution implementation: <code>DEoptim</code> Package<br />
Additionally to the above methods, several methods from the package <code>nloptr</code> can be chosen. 
The complete list of suitable nlopt methods (non-gradient, bound constraints) is: <br />
&quot;NLOPT_GN_DIRECT&quot;,&quot;NLOPT_GN_DIRECT_L&quot;,&quot;NLOPT_GN_DIRECT_L_RAND&quot;,
&quot;NLOPT_GN_DIRECT_NOSCAL&quot;,&quot;NLOPT_GN_DIRECT_L_NOSCAL&quot;,&quot;NLOPT_GN_DIRECT_L_RAND_NOSCAL&quot;,
&quot;NLOPT_GN_ORIG_DIRECT&quot;,&quot;NLOPT_GN_ORIG_DIRECT_L&quot;,&quot;NLOPT_LN_PRAXIS&quot;,							
&quot;NLOPT_GN_CRS2_LM&quot;,&quot;NLOPT_LN_COBYLA&quot;,
&quot;NLOPT_LN_NELDERMEAD&quot;,&quot;NLOPT_LN_SBPLX&quot;,&quot;NLOPT_LN_BOBYQA&quot;,&quot;NLOPT_GN_ISRES&quot;<br /><br />
All of the above methods use bound constraints.
For references and details on the specific methods, please check the documentation of the packages that provide them.</p>
</dd>
</dl>



<h3>Value</h3>

<p>This function returns a list with:
</p>

<dl>
<dt><code>xbest</code></dt><dd><p> parameters of the found solution</p>
</dd>
<dt><code>ybest</code></dt><dd><p> target function value of the found solution</p>
</dd>
<dt><code>count</code></dt><dd><p> number of evaluations of <code>fun</code></p>
</dd>
</dl>


<hr>
<h2 id='optimizeModel'>Optimize Surrogate Model</h2><span id='topic+optimizeModel'></span>

<h3>Description</h3>

<p>Interface to the optimization of the surrogate model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimizeModel(res, creationFunction, model, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimizeModel_+3A_res">res</code></td>
<td>
<p>result state of the optimization process</p>
</td></tr>
<tr><td><code id="optimizeModel_+3A_creationfunction">creationFunction</code></td>
<td>
<p>Function to create individuals/solutions in search space.</p>
</td></tr>
<tr><td><code id="optimizeModel_+3A_model">model</code></td>
<td>
<p>result of the buildModel function</p>
</td></tr>
<tr><td><code id="optimizeModel_+3A_control">control</code></td>
<td>
<p>list of settings, from optimCEGO</p>
</td></tr>
</table>


<h3>Value</h3>

<p>result list of the optimizer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimCEGO">optimCEGO</a></code>
</p>

<hr>
<h2 id='optimMaxMinDist'>Max-Min-Distance Optimizer</h2><span id='topic+optimMaxMinDist'></span>

<h3>Description</h3>

<p>One-shot optimizer: Create a design with maximum sum of distances, and evaluate.
Best candidate is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimMaxMinDist(x = NULL, fun, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimMaxMinDist_+3A_x">x</code></td>
<td>
<p>Optional set of solution(s) as a list, which are added to the randomly generated solutions and are also evaluated with the target function.</p>
</td></tr>
<tr><td><code id="optimMaxMinDist_+3A_fun">fun</code></td>
<td>
<p>target function to be minimized</p>
</td></tr>
<tr><td><code id="optimMaxMinDist_+3A_control">control</code></td>
<td>
<p>(list), with the options:
</p>

<dl>
<dt><code>budget</code></dt><dd><p> The limit on number of target function evaluations (stopping criterion) (default: 100).</p>
</dd>
<dt><code>vectorized</code></dt><dd><p> Boolean. Defines whether target function is vectorized (takes a list of solutions as argument) or not (takes single solution as argument). Default: FALSE.</p>
</dd>
<dt><code>creationFunction</code></dt><dd><p> Function to create individuals/solutions in search space. Default is a function that creates random permutations of length 6.</p>
</dd>
<dt><code>designBudget</code></dt><dd><p> budget of the design function <code><a href="#topic+designMaxMinDist">designMaxMinDist</a></code>, which is the number of randomly created candidates in each iteration.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a list: 	
</p>

<dl>
<dt><code>xbest</code></dt><dd><p> best solution found</p>
</dd>
<dt><code>ybest</code></dt><dd><p> fitness of the best solution</p>
</dd>
<dt><code>x</code></dt><dd><p> history of all evaluated solutions</p>
</dd>
<dt><code>y</code></dt><dd><p> corresponding target function values f(x)</p>
</dd>
<dt><code>count</code></dt><dd><p> number of performed target function evaluations </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+optimCEGO">optimCEGO</a></code>, <code><a href="#topic+optimEA">optimEA</a></code>, <code><a href="#topic+optimRS">optimRS</a></code>, <code><a href="#topic+optim2Opt">optim2Opt</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seed=0
#distance
dF &lt;- distancePermutationHamming
#creation
cF &lt;- function()sample(5)
#objective function
lF &lt;- landscapeGeneratorUNI(1:5,dF)
#start optimization
set.seed(seed)
res &lt;- optimMaxMinDist(,lF,list(creationFunction=cF,budget=20,
	vectorized=TRUE)) ##target function is "vectorized", expects list as input
res$xbest 

</code></pre>

<hr>
<h2 id='optimMIES'>Mixed Integer Evolution Strategy (MIES)</h2><span id='topic+optimMIES'></span>

<h3>Description</h3>

<p>An optimization algorithm from the family of Evolution Strategies, designed to
optimize mixed-integer problems: The search space is composed of continuous (real-valued) parameters,
ordinal integers and categorical parameters.
Please note that the categorical parameters need to be coded as integers 
(type should not be a factor or character).
It is an implementation (with a slight modification) of MIES as described by Li et al. (2013).
Note, that this algorithm always has a step size for each solution parameter, unlike Li et al.,
we did not include the option to change to a single step-size for all parameters.
Dominant recombination is used for solution parameters (the search space parameters), 
intermediate recombination for strategy parameters (i.e., step sizes).
Mutation: Self-adaptive, step sizes sigma are optimized alongside the solution parameters. 
Real-valued parameters are subject to variation based on independent normal distributed random variables. 
Ordinal integers are subject to variation based on the difference of geometric distributions. 
Categorical parameters are changed at random, with a self-adapted probability.
Note, that a more simple bound constraint method is used. Instead of the Transformation Ta,b(x) 
described by Li et al., optimMIES simply replaces any value that exceeds the bounds by respective boundary value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimMIES(x = NULL, fun, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimMIES_+3A_x">x</code></td>
<td>
<p>Optional start individual(s) as a list. If NULL (default), <code>creationFunction</code> (in <code>control</code> list) is used to create initial design. 
If <code>x</code> has less individuals than the population size, creationFunction will fill up the rest.</p>
</td></tr>
<tr><td><code id="optimMIES_+3A_fun">fun</code></td>
<td>
<p>target function to be minimized.</p>
</td></tr>
<tr><td><code id="optimMIES_+3A_control">control</code></td>
<td>
<p>(list), with the options:
</p>

<dl>
<dt><code>budget</code></dt><dd><p>The limit on number of target function evaluations (stopping criterion) (default: 1000).</p>
</dd>
<dt><code>popsize</code></dt><dd><p>Population size (default: 100).</p>
</dd>
<dt><code>generations</code></dt><dd><p>Number of generations (stopping criterion) (default: Inf).</p>
</dd>
<dt><code>targetY</code></dt><dd><p>Target function value (stopping criterion) (default: -Inf).</p>
</dd>
<dt><code>vectorized</code></dt><dd><p>Boolean. Defines whether target function is vectorized (takes a list of solutions as argument) or not (takes single solution as argument). Default: FALSE.</p>
</dd>
<dt><code>verbosity</code></dt><dd><p>Level of text output during run. Defaults to 0, no output.</p>
</dd>
<dt><code>plotting</code></dt><dd><p>Plot optimization progress during run (TRUE) or not (FALSE). Default is FALSE.</p>
</dd>
<dt><code>archive</code></dt><dd><p>Whether to keep all candidate solutions and their fitness in an archive (TRUE) or not (FALSE). Default is TRUE.</p>
</dd>
<dt><code>stoppingCriterionFunction</code></dt><dd><p>Custom additional stopping criterion. Function evaluated on the population, receiving all individuals (list) and their fitness (vector). If the result is FALSE, the algorithm stops.</p>
</dd>
<dt><code>types</code></dt><dd><p>A vector that specifies the data type of each variable: &quot;numeric&quot;, &quot;integer&quot; or &quot;factor&quot;.</p>
</dd>
<dt><code>lower</code></dt><dd><p>Lower bound of each variable. Factor variables can have the lower bound set to NA.</p>
</dd>
<dt><code>upper</code></dt><dd><p>Upper bound of each variable. Factor variables can have the upper bound set to NA.</p>
</dd>
<dt><code>levels</code></dt><dd><p>List of levels for each variable (only relevant for categorical variables). 
Should be a vector of numerical values, usually integers, but not necessarily a sequence.
HAS to be given if any factors/categoricals are present. Else, set to NA.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Details</h3>

<p>The control variables types, lower, upper and levels are especially important.
</p>


<h3>Value</h3>

<p>a list:
</p>

<dl>
<dt><code>xbest</code></dt><dd><p>best solution found.</p>
</dd>
<dt><code>ybest</code></dt><dd><p>fitness of the best solution.</p>
</dd>
<dt><code>x</code></dt><dd><p>history of all evaluated solutions.</p>
</dd>
<dt><code>y</code></dt><dd><p>corresponding target function values f(x).</p>
</dd>
<dt><code>count</code></dt><dd><p>number of performed target function evaluations.</p>
</dd>
<dt><code>message</code></dt><dd><p>Termination message: Which stopping criterion was reached.</p>
</dd>
<dt><code>population</code></dt><dd><p>Last population.</p>
</dd>
<dt><code>fitness</code></dt><dd><p>Fitness of last population.</p>
</dd>
</dl>



<h3>References</h3>

<p>Rui Li, Michael T. M. Emmerich, Jeroen Eggermont, Thomas Baeck, Martin Schuetz, Jouke Dijkstra, and Johan H. C. Reiber. 2013. Mixed integer evolution strategies for parameter optimization. Evol. Comput. 21, 1 (March 2013), 29-64.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optimCEGO">optimCEGO</a></code>, <code><a href="#topic+optimRS">optimRS</a></code>, <code><a href="#topic+optimEA">optimEA</a></code>, <code><a href="#topic+optim2Opt">optim2Opt</a></code>, <code><a href="#topic+optimMaxMinDist">optimMaxMinDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
controlList &lt;- list(lower=c(-5,-5,1,1,NA,NA),upper=c(10,5,10,10,NA,NA),
		types=c("numeric","numeric","integer","integer","factor","factor"),
	levels=list(NA,NA,NA,NA,c(1,3,5),1:4),
		vectorized = FALSE)
objFun &lt;- function(x){		
		x[[3]] &lt;- round(x[[3]])
		x[[4]] &lt;- round(x[[4]])
		y &lt;- sum(as.numeric(x[1:4])^2) 
		if(x[[5]]==1 &amp; x[[6]]==4)
			y &lt;- exp(y)
		else
			y &lt;- y^2
		if(x[[5]]==3)
			y&lt;-y-1	
		if(x[[5]]==5)
			y&lt;-y-2	
		if(x[[6]]==1)
			y&lt;-y*2
		if(x[[6]]==2)
			y&lt;-y * 1.54
		if(x[[6]]==3)
			y&lt;- y +2
		if(x[[6]]==4)
			y&lt;- y * 0.5	
		if(x[[5]]==1)
			y&lt;- y * 9	
		y	
	}
res &lt;- optimMIES(,objFun,controlList)
res$xbest
res$ybest

</code></pre>

<hr>
<h2 id='optimRS'>Combinatorial Random Search</h2><span id='topic+optimRS'></span>

<h3>Description</h3>

<p>Random Search for mixed or combinatorial optimization. Solutions are generated completely at random.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optimRS(x = NULL, fun, control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="optimRS_+3A_x">x</code></td>
<td>
<p>Optional set of solution(s) as a list, which are added to the randomly generated solutions and are also evaluated with the target function.</p>
</td></tr>
<tr><td><code id="optimRS_+3A_fun">fun</code></td>
<td>
<p>target function to be minimized</p>
</td></tr>
<tr><td><code id="optimRS_+3A_control">control</code></td>
<td>
<p>(list), with the options:
</p>

<dl>
<dt><code>budget</code></dt><dd><p> The limit on number of target function evaluations (stopping criterion) (default: 100)</p>
</dd>
<dt><code>vectorized</code></dt><dd><p> Boolean. Defines whether target function is vectorized (takes a list of solutions as argument) or not (takes single solution as argument). Default: FALSE</p>
</dd>
<dt><code>creationFunction</code></dt><dd><p> Function to create individuals/solutions in search space. Default is a function that creates random permutations of length 6</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a list: 	
</p>

<dl>
<dt><code>xbest</code></dt><dd><p> best solution found</p>
</dd>
<dt><code>ybest</code></dt><dd><p> fitness of the best solution</p>
</dd>
<dt><code>x</code></dt><dd><p> history of all evaluated solutions</p>
</dd>
<dt><code>y</code></dt><dd><p> corresponding target function values f(x)</p>
</dd>
<dt><code>count</code></dt><dd><p> number of performed target function evaluations </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+optimCEGO">optimCEGO</a></code>, <code><a href="#topic+optimEA">optimEA</a></code>, <code><a href="#topic+optim2Opt">optim2Opt</a></code>, <code><a href="#topic+optimMaxMinDist">optimMaxMinDist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seed=0
#distance
dF &lt;- distancePermutationHamming
#creation
cF &lt;- function()sample(5)
#objective function
lF &lt;- landscapeGeneratorUNI(1:5,dF)
#start optimization
set.seed(seed)
res &lt;- optimRS(,lF,list(creationFunction=cF,budget=100,
	vectorized=TRUE)) ##target function is "vectorized", expects list as input
res$xbest 

</code></pre>

<hr>
<h2 id='predict.modelKriging'>Kriging Prediction</h2><span id='topic+predict.modelKriging'></span>

<h3>Description</h3>

<p>Predict with a model fit resulting from <code><a href="#topic+modelKriging">modelKriging</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modelKriging'
predict(object, x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.modelKriging_+3A_object">object</code></td>
<td>
<p>fit of the Kriging model (settings and parameters), of class <code>modelKriging</code>.</p>
</td></tr>
<tr><td><code id="predict.modelKriging_+3A_x">x</code></td>
<td>
<p>list of samples to be predicted</p>
</td></tr>
<tr><td><code id="predict.modelKriging_+3A_...">...</code></td>
<td>
<p>further arguments, not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returned value depends on the setting of <code>object$predAll</code><br />
TRUE: list with function value (mean) <code>object$y</code> and uncertainty estimate <code>object$s</code> (standard deviation)<br />
FALSE:<code>object$y</code>only
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelKriging">modelKriging</a></code>
</p>
<p><code><a href="#topic+simulate.modelKriging">simulate.modelKriging</a></code>
</p>

<hr>
<h2 id='predict.modelKrigingClust'>Clustered Kriging Prediction</h2><span id='topic+predict.modelKrigingClust'></span>

<h3>Description</h3>

<p>Predict with a model fit resulting from <code><a href="#topic+modelKrigingClust">modelKrigingClust</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modelKrigingClust'
predict(object, newdata, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.modelKrigingClust_+3A_object">object</code></td>
<td>
<p>fit of the clustered Kriging model ensemble (settings and parameters), of class <code>modelKrigingClust</code>.</p>
</td></tr>
<tr><td><code id="predict.modelKrigingClust_+3A_newdata">newdata</code></td>
<td>
<p>list of samples to be predicted</p>
</td></tr>
<tr><td><code id="predict.modelKrigingClust_+3A_...">...</code></td>
<td>
<p>further arguments, currently not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with function value (mean) <code>object$y</code> and uncertainty estimate <code>object$s</code> (standard deviation)<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+predict.modelKriging">predict.modelKriging</a></code>
</p>

<hr>
<h2 id='predict.modelLinear'>Predict: Combinatorial Kriging</h2><span id='topic+predict.modelLinear'></span>

<h3>Description</h3>

<p>Predict with amodelLinear fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modelLinear'
predict(object, x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.modelLinear_+3A_object">object</code></td>
<td>
<p>fit of the Kriging model (settings and parameters), of class <code>modelLinear</code>.</p>
</td></tr>
<tr><td><code id="predict.modelLinear_+3A_x">x</code></td>
<td>
<p>list of samples to be predicted</p>
</td></tr>
<tr><td><code id="predict.modelLinear_+3A_...">...</code></td>
<td>
<p>further arguments, not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of predictions
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelLinear">modelLinear</a></code>
</p>

<hr>
<h2 id='predict.modelRBFN'>Predict: Combinatorial RBFN</h2><span id='topic+predict.modelRBFN'></span>

<h3>Description</h3>

<p>Predict with a model fit resulting from <code><a href="#topic+modelRBFN">modelRBFN</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modelRBFN'
predict(object, x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.modelRBFN_+3A_object">object</code></td>
<td>
<p>fit of the RBFN model (settings and parameters), of class <code>modelRBFN</code>.</p>
</td></tr>
<tr><td><code id="predict.modelRBFN_+3A_x">x</code></td>
<td>
<p>list of samples to be predicted</p>
</td></tr>
<tr><td><code id="predict.modelRBFN_+3A_...">...</code></td>
<td>
<p>further arguments, not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returned value depends on the setting of <code>object$predAll</code><br />
TRUE: list with function value (mean) <code>$y</code> and uncertainty estimate <code>$s</code> (standard deviation)<br />
FALSE:<code>$y</code>only
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelRBFN">modelRBFN</a></code>
</p>

<hr>
<h2 id='print.modelKriging'>Print Function: modelKriging</h2><span id='topic+print.modelKriging'></span>

<h3>Description</h3>

<p>Print information about a Kriging fit, as produced by <code><a href="#topic+modelKriging">modelKriging</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modelKriging'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.modelKriging_+3A_x">x</code></td>
<td>
<p>fit returned by <code><a href="#topic+modelKriging">modelKriging</a></code>.</p>
</td></tr>
<tr><td><code id="print.modelKriging_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>

<hr>
<h2 id='recombinationBinary1Point'>Single Point Crossover for Bit Strings</h2><span id='topic+recombinationBinary1Point'></span>

<h3>Description</h3>

<p>Given a population of bit-strings, this function recombines each
individual with another individual by randomly specifying a single position.
Information before that position is taken from the first parent,
the rest from the second.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombinationBinary1Point(population, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recombinationBinary1Point_+3A_population">population</code></td>
<td>
<p>List of bit-strings</p>
</td></tr>
<tr><td><code id="recombinationBinary1Point_+3A_parameters">parameters</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>population of recombined offspring
</p>

<hr>
<h2 id='recombinationBinary2Point'>Two Point Crossover for Bit Strings</h2><span id='topic+recombinationBinary2Point'></span>

<h3>Description</h3>

<p>Given a population of bit-strings, this function recombines each
individual with another individual by randomly specifying 2 positions.
Information in-between is taken from one parent, the rest from the other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombinationBinary2Point(population, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recombinationBinary2Point_+3A_population">population</code></td>
<td>
<p>List of bit-strings</p>
</td></tr>
<tr><td><code id="recombinationBinary2Point_+3A_parameters">parameters</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>population of recombined offspring
</p>

<hr>
<h2 id='recombinationBinaryAnd'>Arithmetic (AND) Crossover for Bit Strings</h2><span id='topic+recombinationBinaryAnd'></span>

<h3>Description</h3>

<p>Given a population of bit-strings, this function recombines each
individual with another individual by computing <code>parent1 &amp; parent2</code> (logical AND).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombinationBinaryAnd(population, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recombinationBinaryAnd_+3A_population">population</code></td>
<td>
<p>List of bit-strings</p>
</td></tr>
<tr><td><code id="recombinationBinaryAnd_+3A_parameters">parameters</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>population of recombined offspring
</p>

<hr>
<h2 id='recombinationBinaryUniform'>Uniform Crossover for Bit Strings</h2><span id='topic+recombinationBinaryUniform'></span>

<h3>Description</h3>

<p>Given a population of bit-strings, this function recombines each
individual with another individual by randomly picking bits from each parent. 
Note, that <code><a href="#topic+optimEA">optimEA</a></code> will not pass the whole population
to recombination functions, but only the chosen parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombinationBinaryUniform(population, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recombinationBinaryUniform_+3A_population">population</code></td>
<td>
<p>List of bit-strings</p>
</td></tr>
<tr><td><code id="recombinationBinaryUniform_+3A_parameters">parameters</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>population of recombined offspring
</p>

<hr>
<h2 id='recombinationPermutationAlternatingPosition'>Alternating Position Crossover (AP) for Permutations</h2><span id='topic+recombinationPermutationAlternatingPosition'></span>

<h3>Description</h3>

<p>Given a population of permutations, this function recombines each
individual with another individual.
Note, that <code><a href="#topic+optimEA">optimEA</a></code> will not pass the whole population
to recombination functions, but only the chosen parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombinationPermutationAlternatingPosition(population, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recombinationPermutationAlternatingPosition_+3A_population">population</code></td>
<td>
<p>List of permutations</p>
</td></tr>
<tr><td><code id="recombinationPermutationAlternatingPosition_+3A_parameters">parameters</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>population of recombined offspring
</p>

<hr>
<h2 id='recombinationPermutationCycleCrossover'>Cycle Crossover (CX) for Permutations</h2><span id='topic+recombinationPermutationCycleCrossover'></span>

<h3>Description</h3>

<p>Given a population of permutations, this function recombines each
individual with another individual.
Note, that <code><a href="#topic+optimEA">optimEA</a></code> will not pass the whole population
to recombination functions, but only the chosen parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombinationPermutationCycleCrossover(population, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recombinationPermutationCycleCrossover_+3A_population">population</code></td>
<td>
<p>List of permutations</p>
</td></tr>
<tr><td><code id="recombinationPermutationCycleCrossover_+3A_parameters">parameters</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>population of recombined offspring
</p>

<hr>
<h2 id='recombinationPermutationOrderCrossover1'>Order Crossover 1 (OX1) for Permutations</h2><span id='topic+recombinationPermutationOrderCrossover1'></span>

<h3>Description</h3>

<p>Given a population of permutations, this function recombines each
individual with another individual.
Note, that <code><a href="#topic+optimEA">optimEA</a></code> will not pass the whole population
to recombination functions, but only the chosen parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombinationPermutationOrderCrossover1(population, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recombinationPermutationOrderCrossover1_+3A_population">population</code></td>
<td>
<p>List of permutations</p>
</td></tr>
<tr><td><code id="recombinationPermutationOrderCrossover1_+3A_parameters">parameters</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>population of recombined offspring
</p>

<hr>
<h2 id='recombinationPermutationPositionBased'>Position Based Crossover (POS) for Permutations</h2><span id='topic+recombinationPermutationPositionBased'></span>

<h3>Description</h3>

<p>Given a population of permutations, this function recombines each
individual with another individual.
Note, that <code><a href="#topic+optimEA">optimEA</a></code> will not pass the whole population
to recombination functions, but only the chosen parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombinationPermutationPositionBased(population, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recombinationPermutationPositionBased_+3A_population">population</code></td>
<td>
<p>List of permutations</p>
</td></tr>
<tr><td><code id="recombinationPermutationPositionBased_+3A_parameters">parameters</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>population of recombined offspring
</p>

<hr>
<h2 id='recombinationSelfAdapt'>Self-adaptive recombination operator</h2><span id='topic+recombinationSelfAdapt'></span>

<h3>Description</h3>

<p>This recombination function selects an operator (provided in parameters$recombinationFunctions)
based on self-adaptive parameters chosen for each individual separately.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombinationSelfAdapt(population, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recombinationSelfAdapt_+3A_population">population</code></td>
<td>
<p>List of permutations</p>
</td></tr>
<tr><td><code id="recombinationSelfAdapt_+3A_parameters">parameters</code></td>
<td>
<p>list, contains the available single mutation functions (<code>mutationFunctions</code>), 
and a data.frame that collects the chosen function and mutation rate for each individual (<code>selfAdapt</code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+optimEA">optimEA</a></code>, <code><a href="#topic+mutationSelfAdapt">mutationSelfAdapt</a></code>
</p>

<hr>
<h2 id='recombinationStringSinglePointCrossover'>Single Point Crossover for Strings</h2><span id='topic+recombinationStringSinglePointCrossover'></span>

<h3>Description</h3>

<p>Given a population of strings, this function recombines each
individual with another random individual.
Note, that <code><a href="#topic+optimEA">optimEA</a></code> will not pass the whole population
to recombination functions, but only the chosen parents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recombinationStringSinglePointCrossover(population, parameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="recombinationStringSinglePointCrossover_+3A_population">population</code></td>
<td>
<p>List of strings</p>
</td></tr>
<tr><td><code id="recombinationStringSinglePointCrossover_+3A_parameters">parameters</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>population of recombined offspring
</p>

<hr>
<h2 id='removeDuplicates'>Remove Duplicates</h2><span id='topic+removeDuplicates'></span>

<h3>Description</h3>

<p>Remove duplicates in <code>x</code>, replace with non-duplicated individuals according to <code>cf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeDuplicates(x, cf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removeDuplicates_+3A_x">x</code></td>
<td>
<p>List of individuals</p>
</td></tr>
<tr><td><code id="removeDuplicates_+3A_cf">cf</code></td>
<td>
<p>Creation function, creates random new individuals</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>x</code> without duplicates
</p>

<hr>
<h2 id='removeDuplicatesOffspring'>Remove Duplicates from Offsprings</h2><span id='topic+removeDuplicatesOffspring'></span>

<h3>Description</h3>

<p>Remove duplicates in <code>c(xhist,off)</code>, replace with non-duplicated individuals according to <code>cf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>removeDuplicatesOffspring(xhist, off, cf, df = duplicated)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="removeDuplicatesOffspring_+3A_xhist">xhist</code></td>
<td>
<p>List of previous individuals</p>
</td></tr>
<tr><td><code id="removeDuplicatesOffspring_+3A_off">off</code></td>
<td>
<p>List of offspring individuals</p>
</td></tr>
<tr><td><code id="removeDuplicatesOffspring_+3A_cf">cf</code></td>
<td>
<p>Creation function, creates random new individuals</p>
</td></tr>
<tr><td><code id="removeDuplicatesOffspring_+3A_df">df</code></td>
<td>
<p>Dupliate Function. This function determines which elements in a list/population are duplicates. By default, this is the duplicated function from R-base.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>off</code> without duplicates
</p>

<hr>
<h2 id='repairConditionsCorrelationMatrix'>Repair Conditions of a Correlation Matrix</h2><span id='topic+repairConditionsCorrelationMatrix'></span>

<h3>Description</h3>

<p>This function repairs correlation matrices, so that the following two properties are ensured:
The correlations values should be between -1 and 1, and the diagonal values should be one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repairConditionsCorrelationMatrix(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repairConditionsCorrelationMatrix_+3A_mat">mat</code></td>
<td>
<p>symmetric, PSD distance matrix. If your matrix is not CNSD, use <code><a href="#topic+correctionDefinite">correctionDefinite</a></code> first. Or use <code><a href="#topic+correctionKernelMatrix">correctionKernelMatrix</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>repaired correlation matrix
</p>


<h3>References</h3>

<p>Martin Zaefferer and Thomas Bartz-Beielstein. (2016). Efficient Global Optimization with Indefinite Kernels. Parallel Problem Solving from Nature-PPSN XIV. Accepted, in press. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+correctionDefinite">correctionDefinite</a></code>, <code><a href="#topic+correctionDistanceMatrix">correctionDistanceMatrix</a></code>, <code><a href="#topic+correctionKernelMatrix">correctionKernelMatrix</a></code>, <code><a href="#topic+correctionCNSD">correctionCNSD</a></code>, <code><a href="#topic+repairConditionsDistanceMatrix">repairConditionsDistanceMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(c(2,1,4,3),c(2,4,3,1),c(4,2,1,3),c(4,3,2,1),c(1,4,3,2))
D &lt;- distanceMatrix(x,distancePermutationInsert)
K &lt;- exp(-0.01*D)
K &lt;- correctionDefinite(K,type="PSD")$mat
K
K &lt;- repairConditionsCorrelationMatrix(K)
</code></pre>

<hr>
<h2 id='repairConditionsDistanceMatrix'>Repair Conditions of a Distance Matrix</h2><span id='topic+repairConditionsDistanceMatrix'></span>

<h3>Description</h3>

<p>This function repairs distance matrices, so that the following two properties are ensured:
The distance values should be non-zero and the diagonal should be zero.
Other properties (conditionally negative semi-definitene (CNSD), symmetric) are
assumed to be given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repairConditionsDistanceMatrix(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="repairConditionsDistanceMatrix_+3A_mat">mat</code></td>
<td>
<p>symmetric, CNSD distance matrix. If your matrix is not CNSD, use <code><a href="#topic+correctionCNSD">correctionCNSD</a></code> first. Or use <code><a href="#topic+correctionDistanceMatrix">correctionDistanceMatrix</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>repaired distance matrix
</p>


<h3>References</h3>

<p>Martin Zaefferer and Thomas Bartz-Beielstein. (2016). Efficient Global Optimization with Indefinite Kernels. Parallel Problem Solving from Nature-PPSN XIV. Accepted, in press. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+correctionDefinite">correctionDefinite</a></code>, <code><a href="#topic+correctionDistanceMatrix">correctionDistanceMatrix</a></code>, <code><a href="#topic+correctionKernelMatrix">correctionKernelMatrix</a></code>, <code><a href="#topic+correctionCNSD">correctionCNSD</a></code>, <code><a href="#topic+repairConditionsCorrelationMatrix">repairConditionsCorrelationMatrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- list(c(2,1,4,3),c(2,4,3,1),c(4,2,1,3),c(4,3,2,1),c(1,4,3,2))
D &lt;- distanceMatrix(x,distancePermutationInsert)
D &lt;- correctionCNSD(D)
D
D &lt;- repairConditionsDistanceMatrix(D)
D
</code></pre>

<hr>
<h2 id='selfAdapt'>Self-adaption of EA parameters.</h2><span id='topic+selfAdapt'></span>

<h3>Description</h3>

<p>Learning / self-adaption of parameters of the evolutionary algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selfAdapt(
  params,
  inum,
  icat,
  iint,
  nnum,
  ncat,
  nint,
  lower,
  upper,
  values,
  tau,
  p
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="selfAdapt_+3A_params">params</code></td>
<td>
<p>parameters to be self-adapted</p>
</td></tr>
<tr><td><code id="selfAdapt_+3A_inum">inum</code></td>
<td>
<p>boolean vector, which parameters are numeric</p>
</td></tr>
<tr><td><code id="selfAdapt_+3A_icat">icat</code></td>
<td>
<p>boolean vector, which parameters are discrete, factors</p>
</td></tr>
<tr><td><code id="selfAdapt_+3A_iint">iint</code></td>
<td>
<p>boolean vector, which parameters are integer</p>
</td></tr>
<tr><td><code id="selfAdapt_+3A_nnum">nnum</code></td>
<td>
<p>number of numerical parameters</p>
</td></tr>
<tr><td><code id="selfAdapt_+3A_ncat">ncat</code></td>
<td>
<p>number of discrete parameters</p>
</td></tr>
<tr><td><code id="selfAdapt_+3A_nint">nint</code></td>
<td>
<p>number of integer parameters</p>
</td></tr>
<tr><td><code id="selfAdapt_+3A_lower">lower</code></td>
<td>
<p>lower bounds (numeric, integer parameters only)</p>
</td></tr>
<tr><td><code id="selfAdapt_+3A_upper">upper</code></td>
<td>
<p>upper bounds (numeric, integer parameters only)</p>
</td></tr>
<tr><td><code id="selfAdapt_+3A_values">values</code></td>
<td>
<p>values or levels of the discrete parameters</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+optimEA">optimEA</a></code>
</p>

<hr>
<h2 id='simulate.modelKriging'>Kriging Simulation</h2><span id='topic+simulate.modelKriging'></span>

<h3>Description</h3>

<p>(Conditional) Simulate at given locations, with a model fit resulting from <code><a href="#topic+modelKriging">modelKriging</a></code>.
In contrast to prediction or estimation, the goal is to reproduce the covariance 
structure, rather than the data itself. Note, that the conditional simulation 
also reproduces the training data, but
has a two times larger error than the Kriging predictor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'modelKriging'
simulate(
  object,
  nsim = 1,
  seed = NA,
  xsim,
  conditionalSimulation = TRUE,
  returnAll = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simulate.modelKriging_+3A_object">object</code></td>
<td>
<p>fit of the Kriging model (settings and parameters), of class <code>modelKriging</code>.</p>
</td></tr>
<tr><td><code id="simulate.modelKriging_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="simulate.modelKriging_+3A_seed">seed</code></td>
<td>
<p>random number generator seed. Defaults to NA, in which case no seed is set</p>
</td></tr>
<tr><td><code id="simulate.modelKriging_+3A_xsim">xsim</code></td>
<td>
<p>list of samples in input space, to be simulated</p>
</td></tr>
<tr><td><code id="simulate.modelKriging_+3A_conditionalsimulation">conditionalSimulation</code></td>
<td>
<p>logical, if set to TRUE (default), the simulation is conditioned with the training data of the Kriging model.
Else, the simulation is non-conditional.</p>
</td></tr>
<tr><td><code id="simulate.modelKriging_+3A_returnall">returnAll</code></td>
<td>
<p>if set to TRUE, a list with the simulated values (y) and the corresponding covariance matrix (covar)
of the simulated samples is returned.</p>
</td></tr>
<tr><td><code id="simulate.modelKriging_+3A_...">...</code></td>
<td>
<p>further arguments, not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returned value depends on the setting of <code>object$simulationReturnAll</code>
</p>


<h3>References</h3>

<p>N. A. Cressie. Statistics for Spatial Data. JOHN WILEY &amp; SONS INC, 1993.
</p>
<p>C. Lantuejoul. Geostatistical Simulation - Models and Algorithms. Springer-Verlag Berlin Heidelberg, 2002.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelKriging">modelKriging</a></code>, <code><a href="#topic+predict.modelKriging">predict.modelKriging</a></code>
</p>

<hr>
<h2 id='solutionFunctionGeneratorBinary'>Binary String Generator Function</h2><span id='topic+solutionFunctionGeneratorBinary'></span>

<h3>Description</h3>

<p>Returns a function that generates random bit-strings of length N.
Can be used to create individuals of NK-Landscapes or other problems with binary representation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solutionFunctionGeneratorBinary(N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solutionFunctionGeneratorBinary_+3A_n">N</code></td>
<td>
<p>length of the bit-strings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a function, without any arguments
</p>

<hr>
<h2 id='solutionFunctionGeneratorPermutation'>Permutation Generator Function</h2><span id='topic+solutionFunctionGeneratorPermutation'></span>

<h3>Description</h3>

<p>Returns a function that generates random permutations of length N.
Can be used to generate individual solutions for permutation problems, e.g., Travelling Salesperson Problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solutionFunctionGeneratorPermutation(N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solutionFunctionGeneratorPermutation_+3A_n">N</code></td>
<td>
<p>length of the permutations returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a function, without any arguments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fun &lt;- solutionFunctionGeneratorPermutation(10)
fun()
fun()
fun()

</code></pre>

<hr>
<h2 id='solutionFunctionGeneratorString'>String Generator Function</h2><span id='topic+solutionFunctionGeneratorString'></span>

<h3>Description</h3>

<p>Returns a function that generates random strings of length N, with given letters.
Can be used to generate individual solutions for permutation problems, e.g., Travelling Salesperson Problem
</p>


<h3>Usage</h3>

<pre><code class='language-R'>solutionFunctionGeneratorString(N, lts = c("A", "C", "G", "T"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="solutionFunctionGeneratorString_+3A_n">N</code></td>
<td>
<p>length of the permutations returned</p>
</td></tr>
<tr><td><code id="solutionFunctionGeneratorString_+3A_lts">lts</code></td>
<td>
<p>letters allowed in the string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a function, without any arguments
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fun &lt;- solutionFunctionGeneratorString(10,c("A","C","G","T"))
fun()
fun()
fun()

</code></pre>

<hr>
<h2 id='step2Opt'>2-Opt Step</h2><span id='topic+step2Opt'></span>

<h3>Description</h3>

<p>Helper function: A single 2-opt step for <code><a href="#topic+optim2Opt">optim2Opt</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step2Opt(route, i, k)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="step2Opt_+3A_route">route</code></td>
<td>
<p>route to be partially reversed</p>
</td></tr>
<tr><td><code id="step2Opt_+3A_i">i</code></td>
<td>
<p>start of reversal</p>
</td></tr>
<tr><td><code id="step2Opt_+3A_k">k</code></td>
<td>
<p>end of reversal</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new route
</p>

<hr>
<h2 id='testFunctionGeneratorSim'>Simulation-based Test Function Generator, Data Interface</h2><span id='topic+testFunctionGeneratorSim'></span>

<h3>Description</h3>

<p>Generate test functions for assessment of optimization algorithms with
non-conditional or conditional simulation, based on real-world data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testFunctionGeneratorSim(
  x,
  y,
  xsim,
  distanceFunction,
  controlModel = list(),
  controlSimulation = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testFunctionGeneratorSim_+3A_x">x</code></td>
<td>
<p>list of samples in input space, training data</p>
</td></tr>
<tr><td><code id="testFunctionGeneratorSim_+3A_y">y</code></td>
<td>
<p>column vector of observations for each sample, training data</p>
</td></tr>
<tr><td><code id="testFunctionGeneratorSim_+3A_xsim">xsim</code></td>
<td>
<p>list of samples in input space, for simulation</p>
</td></tr>
<tr><td><code id="testFunctionGeneratorSim_+3A_distancefunction">distanceFunction</code></td>
<td>
<p>a suitable distance function of type f(x1,x2), returning a scalar distance value, preferably between 0 and 1.
Maximum distances larger 1 are no problem, but may yield scaling bias when different measures are compared.
Should be non-negative and symmetric.  It can also be a list of several distance functions. In this case, Maximum Likelihood Estimation (MLE) is used 
to determine the most suited distance measure.
The distance function may have additional parameters. For that case, see distanceParametersLower/Upper in the controls.
If distanceFunction is missing, it can also be provided in the control list.</p>
</td></tr>
<tr><td><code id="testFunctionGeneratorSim_+3A_controlmodel">controlModel</code></td>
<td>
<p>(list), with the options for the model building procedure,
it will be passed to the <code><a href="#topic+modelKriging">modelKriging</a></code> function.</p>
</td></tr>
<tr><td><code id="testFunctionGeneratorSim_+3A_controlsimulation">controlSimulation</code></td>
<td>
<p>(list), with the parameters of the simulation:
</p>

<dl>
<dt><code>nsim</code></dt><dd><p> the number of simulations, or test functions, to be created.</p>
</dd>
<dt><code>conditionalSimulation</code></dt><dd><p> whether (TRUE) or not (FALSE) to use conditional simulation.</p>
</dd>
<dt><code>simulationSeed</code></dt><dd><p> a random number generator seed. Defaults to NA; which means no seed is set. For sake of reproducibility, set this to some integer value.</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the following elements: <code>fun</code> is a list of functions, where each function is the interpolation of one simulation realization. The length of the list depends on the nsim parameter.
<code>fit</code> is the result of the modeling procedure, that is, the model fit of class <code>modelKriging</code>.
</p>


<h3>References</h3>

<p>N. A. Cressie. Statistics for Spatial Data. JOHN WILEY &amp; SONS INC, 1993.
</p>
<p>C. Lantuejoul. Geostatistical Simulation - Models and Algorithms. Springer-Verlag Berlin Heidelberg, 2002.
</p>
<p>Zaefferer, M.; Fischbach, A.; Naujoks, B. &amp; Bartz-Beielstein, T. Simulation Based Test Functions for Optimization Algorithms Proceedings of the Genetic and Evolutionary Computation Conference 2017, ACM, 2017, 8.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelKriging">modelKriging</a></code>, <code><a href="#topic+simulate.modelKriging">simulate.modelKriging</a></code>, <code><a href="#topic+createSimulatedTestFunction">createSimulatedTestFunction</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nsim &lt;- 10
seed &lt;- 12345
n &lt;- 6
set.seed(seed)
#target function:
fun &lt;- function(x){
  exp(-20* x) + sin(6*x^2) + x
}
# "vectorize" target
f &lt;- function(x){sapply(x,fun)}
dF &lt;- function(x,y)(sum((x-y)^2)) #sum of squares 
# plot params
par(mfrow=c(4,1),mar=c(2.3,2.5,0.2,0.2),mgp=c(1.4,0.5,0))
#test samples for plots
xtest &lt;- as.list(seq(from=-0,by=0.005,to=1))
plot(xtest,f(xtest),type="l",xlab="x",ylab="Obj. function")
#evaluation samples (training)
xb &lt;- as.list(runif(n))
yb &lt;- f(xb)
# support samples for simulation
x &lt;- as.list(sort(c(runif(100),unlist(xb))))
# fit the model	and simulate: 
res &lt;- testFunctionGeneratorSim(xb,yb,x,dF,
   list(algThetaControl=list(method="NLOPT_GN_DIRECT_L",funEvals=100),
     useLambda=FALSE),
   list(nsim=nsim,conditionalSimulation=FALSE))
fit &lt;- res$fit
fun &lt;- res$fun
#predicted obj. function values
ypred &lt;- predict(fit,as.list(xtest))$y
plot(unlist(xtest),ypred,type="l",xlab="x",ylab="Estimation")
points(unlist(xb),yb,pch=19)
##############################	
# plot non-conditional simulation
##############################
ynew &lt;- NULL
for(i in 1:nsim)
  ynew &lt;- cbind(ynew,fun[[i]](xtest))
rangeY &lt;- range(ynew)
plot(unlist(xtest),ynew[,1],type="l",ylim=rangeY,xlab="x",ylab="Simulation")
for(i in 2:nsim){
  lines(unlist(xtest),ynew[,i],col=i,type="l")
}
##############################	
# create and plot test function, conditional
##############################
fun &lt;- testFunctionGeneratorSim(xb,yb,x,dF,
   list(algThetaControl=
     list(method="NLOPT_GN_DIRECT_L",funEvals=100),
			useLambda=FALSE),
   list(nsim=nsim,conditionalSimulation=TRUE))$fun
ynew &lt;- NULL
for(i in 1:nsim)
  ynew &lt;- cbind(ynew,fun[[i]](xtest))
rangeY &lt;- range(ynew)
plot(unlist(xtest),ynew[,1],type="l",ylim=rangeY,xlab="x",ylab="Conditional sim.")
for(i in 2:nsim){
  lines(unlist(xtest),ynew[,i],col=i,type="l")
}
points(unlist(xb),yb,pch=19)

</code></pre>

<hr>
<h2 id='tournamentSelection'>Tournament Selection</h2><span id='topic+tournamentSelection'></span>

<h3>Description</h3>

<p>Simple Tournament Selection implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tournamentSelection(
  fitness,
  tournamentSize,
  tournamentProbability,
  selectFromN
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tournamentSelection_+3A_fitness">fitness</code></td>
<td>
<p>Fitness values of individuals</p>
</td></tr>
<tr><td><code id="tournamentSelection_+3A_tournamentsize">tournamentSize</code></td>
<td>
<p>Tournament Size</p>
</td></tr>
<tr><td><code id="tournamentSelection_+3A_tournamentprobability">tournamentProbability</code></td>
<td>
<p>Tournament Probability</p>
</td></tr>
<tr><td><code id="tournamentSelection_+3A_selectfromn">selectFromN</code></td>
<td>
<p>Number of tournament winners</p>
</td></tr>
</table>


<h3>Value</h3>

<p>index of tournament winners
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modelKriging">modelKriging</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
