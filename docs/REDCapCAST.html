<!DOCTYPE html><html><head><title>Help for package REDCapCAST</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {REDCapCAST}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#clean_redcap_name'><p>clean_redcap_name</p></a></li>
<li><a href='#d2w'><p>Convert single digits to words</p></a></li>
<li><a href='#deploy_shiny'><p>Deploy the Shiny app with rsconnect</p></a></li>
<li><a href='#ds2dd'><p>(DEPRECATED) Data set to data dictionary function</p></a></li>
<li><a href='#ds2dd_detailed'><p>Extract data from stata file for data dictionary</p></a></li>
<li><a href='#easy_redcap'><p>Secure API key storage and data acquisition in one</p></a></li>
<li><a href='#file_extension'><p>Helper to import files correctly</p></a></li>
<li><a href='#focused_metadata'><p>focused_metadata</p></a></li>
<li><a href='#get_api_key'><p>Retrieve project API key if stored, if not, set and retrieve</p></a></li>
<li><a href='#get_id_name'><p>Get the id name</p></a></li>
<li><a href='#guess_time_only_filter'><p>Try at determining which are true time only variables</p></a></li>
<li><a href='#hms2character'><p>Change &quot;hms&quot; to &quot;character&quot; for REDCap upload.</p></a></li>
<li><a href='#is_repeated_longitudinal'><p>Test if repeatable or longitudinal</p></a></li>
<li><a href='#mark_complete'><p>Completion marking based on completed upload</p></a></li>
<li><a href='#match_fields_to_form'><p>Match fields to forms</p></a></li>
<li><a href='#mtcars_redcap'><p>mtcars dataset slightly modified to use for Shiny app upload demonstration</p></a></li>
<li><a href='#read_input'><p>Flexible file import based on extension</p></a></li>
<li><a href='#read_redcap_instrument'><p>Convenience function to download complete instrument, using token storage</p>
in keyring.</a></li>
<li><a href='#read_redcap_tables'><p>Download REDCap data</p></a></li>
<li><a href='#REDCap_split'><p>Split REDCap repeating instruments table into multiple tables</p></a></li>
<li><a href='#redcap_wider'><p>Redcap Wider</p></a></li>
<li><a href='#redcapcast_data'><p>Data set for demonstration</p></a></li>
<li><a href='#redcapcast_meta'><p>REDCap metadata from data base</p></a></li>
<li><a href='#sanitize_split'><p>Sanitize list of data frames</p></a></li>
<li><a href='#server_factory'><p>Shiny server factory</p></a></li>
<li><a href='#shiny_cast'><p>Launch the included Shiny-app for database casting and upload</p></a></li>
<li><a href='#split_non_repeating_forms'><p>Split a data frame into separate tables for each form</p></a></li>
<li><a href='#strsplitx'><p>Extended string splitting</p></a></li>
<li><a href='#time_only_correction'><p>Correction based on time_only_filter function</p></a></li>
<li><a href='#ui_factory'><p>UI factory for shiny app</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>REDCap Castellated Data Handling</td>
</tr>
<tr>
<td>Version:</td>
<td>24.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Originally forked from the R part of 'REDCapRITS' by Paul Egeler. 
    See <a href="https://github.com/pegeler/REDCapRITS">https://github.com/pegeler/REDCapRITS</a>.
    'REDCap' database casting and handling of castellated data when using 
    repeated instruments and longitudinal projects. Keeps a focused data export 
    approach, by allowing to only export required data from the database.
    'REDCap' (Research Electronic Data Capture) is a secure, web-based software
    platform designed to support data capture for research studies, providing
    1) an intuitive interface for validated data capture; 2) audit trails for
    tracking data manipulation and export procedures; 3) automated export
    procedures for seamless data downloads to common statistical packages; and
    4) procedures for data integration and interoperability with external 
    sources (Harris et al (2009) &lt;<a href="https://doi.org/10.1016%2Fj.jbi.2008.08.010">doi:10.1016/j.jbi.2008.08.010</a>&gt;; 
    Harris et al (2019) &lt;<a href="https://doi.org/10.1016%2Fj.jbi.2019.103208">doi:10.1016/j.jbi.2019.103208</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>httr, jsonlite, testthat, Hmisc, knitr, rmarkdown, gt,
usethis, ggplot2, here, styler, devtools, roxygen2, spelling</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/agdamsbo/REDCapCAST">https://github.com/agdamsbo/REDCapCAST</a>,
<a href="https://agdamsbo.github.io/REDCapCAST/">https://agdamsbo.github.io/REDCapCAST/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/agdamsbo/REDCapCAST/issues">https://github.com/agdamsbo/REDCapCAST/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, REDCapR, tidyr, tidyselect, keyring, purrr, readr,
stats, shiny, openxlsx2, rsconnect, haven</td>
</tr>
<tr>
<td>Collate:</td>
<td>'utils.r' 'process_user_input.r' 'REDCap_split.r' 'ds2dd.R'
'ds2dd_detailed.R' 'easy_redcap.R' 'mtcars_redcap.R'
'read_redcap_instrument.R' 'read_redcap_tables.R'
'redcap_wider.R' 'redcapcast_data.R' 'redcapcast_meta.R'
'shiny_cast.R'</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-28 06:43:41 UTC; au301842</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Gammelgaard Damsbo
    <a href="https://orcid.org/0000-0002-7559-1154"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Paul Egeler <a href="https://orcid.org/0000-0001-6948-9498"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Gammelgaard Damsbo &lt;agdamsbo@clin.au.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-28 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='clean_redcap_name'>clean_redcap_name</h2><span id='topic+clean_redcap_name'></span>

<h3>Description</h3>

<p>Stepwise removal on non-alphanumeric characters, trailing white space,
substitutes spaces for underscores and converts to lower case.
Trying to make up for different naming conventions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_redcap_name(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_redcap_name_+3A_x">x</code></td>
<td>
<p>vector or data frame for cleaning</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector or data frame, same format as input
</p>

<hr>
<h2 id='d2w'>Convert single digits to words</h2><span id='topic+d2w'></span>

<h3>Description</h3>

<p>Convert single digits to words
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d2w(x, lang = "en", neutrum = FALSE, everything = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="d2w_+3A_x">x</code></td>
<td>
<p>data. Handle vectors, data.frames and lists</p>
</td></tr>
<tr><td><code id="d2w_+3A_lang">lang</code></td>
<td>
<p>language. Danish (da) and English (en), Default is &quot;en&quot;</p>
</td></tr>
<tr><td><code id="d2w_+3A_neutrum">neutrum</code></td>
<td>
<p>for numbers depending on counted word</p>
</td></tr>
<tr><td><code id="d2w_+3A_everything">everything</code></td>
<td>
<p>flag to also split numbers &gt;9 to single digits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns characters in same format as input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d2w(c(2:8, 21))
d2w(data.frame(2:7, 3:8, 1), lang = "da", neutrum = TRUE)

## If everything=T, also larger numbers are reduced.
## Elements in the list are same length as input
d2w(list(2:8, c(2, 6, 4, 23), 2), everything = TRUE)

</code></pre>

<hr>
<h2 id='deploy_shiny'>Deploy the Shiny app with rsconnect</h2><span id='topic+deploy_shiny'></span>

<h3>Description</h3>

<p>Deploy the Shiny app with rsconnect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deploy_shiny(path = here::here("app/"), name.app = "shiny_cast")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deploy_shiny_+3A_path">path</code></td>
<td>
<p>app folder path</p>
</td></tr>
<tr><td><code id="deploy_shiny_+3A_name.app">name.app</code></td>
<td>
<p>name of deployed app</p>
</td></tr>
</table>


<h3>Value</h3>

<p>deploy
</p>


<h3>Examples</h3>

<pre><code class='language-R'># deploy_shiny

</code></pre>

<hr>
<h2 id='ds2dd'>(DEPRECATED) Data set to data dictionary function</h2><span id='topic+ds2dd'></span>

<h3>Description</h3>

<p>Creates a very basic data dictionary skeleton. Please see 'ds2dd_detailed()'
for a more advanced function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds2dd(
  ds,
  record.id = "record_id",
  form.name = "basis",
  field.type = "text",
  field.label = NULL,
  include.column.names = FALSE,
  metadata = metadata_names
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ds2dd_+3A_ds">ds</code></td>
<td>
<p>data set</p>
</td></tr>
<tr><td><code id="ds2dd_+3A_record.id">record.id</code></td>
<td>
<p>name or column number of id variable, moved to first row of
data dictionary, character of integer. Default is &quot;record_id&quot;.</p>
</td></tr>
<tr><td><code id="ds2dd_+3A_form.name">form.name</code></td>
<td>
<p>vector of form names, character string, length 1 or length
equal to number of variables. Default is &quot;basis&quot;.</p>
</td></tr>
<tr><td><code id="ds2dd_+3A_field.type">field.type</code></td>
<td>
<p>vector of field types, character string, length 1 or length
equal to number of variables. Default is &quot;text.</p>
</td></tr>
<tr><td><code id="ds2dd_+3A_field.label">field.label</code></td>
<td>
<p>vector of form names, character string, length 1 or length
equal to number of variables. Default is NULL and is then identical to field
names.</p>
</td></tr>
<tr><td><code id="ds2dd_+3A_include.column.names">include.column.names</code></td>
<td>
<p>Flag to give detailed output including new
column names for original data set for upload.</p>
</td></tr>
<tr><td><code id="ds2dd_+3A_metadata">metadata</code></td>
<td>
<p>Metadata column names. Default is the included
REDCapCAST::metadata_names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Migrated from stRoke ds2dd(). Fits better with the functionality of
'REDCapCAST'.
</p>


<h3>Value</h3>

<p>data.frame or list of data.frame and vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>redcapcast_data$record_id &lt;- seq_len(nrow(redcapcast_data))
ds2dd(redcapcast_data, include.column.names=TRUE)
</code></pre>

<hr>
<h2 id='ds2dd_detailed'>Extract data from stata file for data dictionary</h2><span id='topic+ds2dd_detailed'></span>

<h3>Description</h3>

<p>Extract data from stata file for data dictionary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds2dd_detailed(
  data,
  add.auto.id = FALSE,
  date.format = "dmy",
  form.name = NULL,
  field.type = NULL,
  field.label = NULL,
  field.label.attr = "label",
  field.validation = NULL,
  metadata = metadata_names,
  validate.time = FALSE,
  time.var.sel.pos = "[Tt]i[d(me)]",
  time.var.sel.neg = "[Dd]at[eo]"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ds2dd_detailed_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_add.auto.id">add.auto.id</code></td>
<td>
<p>flag to add id column</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_date.format">date.format</code></td>
<td>
<p>date format, character string. ymd/dmy/mdy. dafault is
dmy.</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_form.name">form.name</code></td>
<td>
<p>manually specify form name(s). Vector of length 1 or
ncol(data). Default is NULL and &quot;data&quot; is used.</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_field.type">field.type</code></td>
<td>
<p>manually specify field type(s). Vector of length 1 or
ncol(data). Default is NULL and &quot;text&quot; is used for everything but factors,
which wil get &quot;radio&quot;.</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_field.label">field.label</code></td>
<td>
<p>manually specify field label(s). Vector of length 1 or
ncol(data). Default is NULL and colnames(data) is used or attribute
'field.label.attr' for haven_labelled data set (imported .dta file with
'haven::read_dta()').</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_field.label.attr">field.label.attr</code></td>
<td>
<p>attribute name for named labels for haven_labelled
data set (imported .dta file with 'haven::read_dta()'. Default is &quot;label&quot;</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_field.validation">field.validation</code></td>
<td>
<p>manually specify field validation(s). Vector of
length 1 or ncol(data). Default is NULL and 'levels()' are used for factors
or attribute 'factor.labels.attr' for haven_labelled data set (imported .dta
file with 'haven::read_dta()').</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_metadata">metadata</code></td>
<td>
<p>redcap metadata headings. Default is
REDCapCAST:::metadata_names.</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_validate.time">validate.time</code></td>
<td>
<p>Flag to validate guessed time columns</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_time.var.sel.pos">time.var.sel.pos</code></td>
<td>
<p>Positive selection regex string passed to
'gues_time_only_filter()' as sel.pos.</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_time.var.sel.neg">time.var.sel.neg</code></td>
<td>
<p>Negative selection regex string passed to
'gues_time_only_filter()' as sel.neg.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a natural development of the ds2dd() function. It assumes
that the first column is the ID-column. No checks.
Please, do always inspect the data dictionary before upload.
</p>
<p>Ensure, that the data set is formatted with as much information as possible.
</p>
<p>'field.type' can be supplied
</p>


<h3>Value</h3>

<p>list of length 2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- redcapcast_data
data |&gt; ds2dd_detailed(validate.time = TRUE)
data |&gt; ds2dd_detailed()
iris |&gt; ds2dd_detailed(add.auto.id = TRUE)
mtcars |&gt; ds2dd_detailed(add.auto.id = TRUE)
</code></pre>

<hr>
<h2 id='easy_redcap'>Secure API key storage and data acquisition in one</h2><span id='topic+easy_redcap'></span>

<h3>Description</h3>

<p>Secure API key storage and data acquisition in one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>easy_redcap(project.name, widen.data = TRUE, uri, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="easy_redcap_+3A_project.name">project.name</code></td>
<td>
<p>The name of the current project (for key storage with
'keyring::key_set()', using the default keyring)</p>
</td></tr>
<tr><td><code id="easy_redcap_+3A_widen.data">widen.data</code></td>
<td>
<p>argument to widen the exported data</p>
</td></tr>
<tr><td><code id="easy_redcap_+3A_uri">uri</code></td>
<td>
<p>REDCap database API uri</p>
</td></tr>
<tr><td><code id="easy_redcap_+3A_...">...</code></td>
<td>
<p>arguments passed on to 'REDCapCAST::read_redcap_tables()'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame or list depending on widen.data
</p>

<hr>
<h2 id='file_extension'>Helper to import files correctly</h2><span id='topic+file_extension'></span>

<h3>Description</h3>

<p>Helper to import files correctly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_extension(filenames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="file_extension_+3A_filenames">filenames</code></td>
<td>
<p>file names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file_extension(list.files(here::here(""))[[2]])[[1]]
</code></pre>

<hr>
<h2 id='focused_metadata'>focused_metadata</h2><span id='topic+focused_metadata'></span>

<h3>Description</h3>

<p>Extracts limited metadata for variables in a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focused_metadata(metadata, vars_in_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="focused_metadata_+3A_metadata">metadata</code></td>
<td>
<p>A dataframe containing metadata</p>
</td></tr>
<tr><td><code id="focused_metadata_+3A_vars_in_data">vars_in_data</code></td>
<td>
<p>Vector of variable names in the dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing metadata for the variables in the dataset
</p>

<hr>
<h2 id='get_api_key'>Retrieve project API key if stored, if not, set and retrieve</h2><span id='topic+get_api_key'></span>

<h3>Description</h3>

<p>Retrieve project API key if stored, if not, set and retrieve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_api_key(key.name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_api_key_+3A_key.name">key.name</code></td>
<td>
<p>character vector of key name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>

<hr>
<h2 id='get_id_name'>Get the id name</h2><span id='topic+get_id_name'></span>

<h3>Description</h3>

<p>Get the id name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_id_name(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_id_name_+3A_data">data</code></td>
<td>
<p>data frame or list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>

<hr>
<h2 id='guess_time_only_filter'>Try at determining which are true time only variables</h2><span id='topic+guess_time_only_filter'></span>

<h3>Description</h3>

<p>This is just a try at guessing data type based on data class and column names
hoping for a tiny bit of naming consistency. R does not include a time-only
data format natively, so the &quot;hms&quot; class from 'readr' is used. This
has to be converted to character class before REDCap upload.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_time_only_filter(
  data,
  validate = FALSE,
  sel.pos = "[Tt]i[d(me)]",
  sel.neg = "[Dd]at[eo]"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_time_only_filter_+3A_data">data</code></td>
<td>
<p>data set</p>
</td></tr>
<tr><td><code id="guess_time_only_filter_+3A_validate">validate</code></td>
<td>
<p>flag to output validation data. Will output list.</p>
</td></tr>
<tr><td><code id="guess_time_only_filter_+3A_sel.pos">sel.pos</code></td>
<td>
<p>Positive selection regex string</p>
</td></tr>
<tr><td><code id="guess_time_only_filter_+3A_sel.neg">sel.neg</code></td>
<td>
<p>Negative selection regex string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector or list depending on 'validate' flag.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- redcapcast_data
data |&gt; guess_time_only_filter()
data |&gt;
  guess_time_only_filter(validate = TRUE) |&gt;
  lapply(head)
</code></pre>

<hr>
<h2 id='hms2character'>Change &quot;hms&quot; to &quot;character&quot; for REDCap upload.</h2><span id='topic+hms2character'></span>

<h3>Description</h3>

<p>Change &quot;hms&quot; to &quot;character&quot; for REDCap upload.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hms2character(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hms2character_+3A_data">data</code></td>
<td>
<p>data set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame or tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- redcapcast_data
## data |&gt; time_only_correction() |&gt; hms2character()
</code></pre>

<hr>
<h2 id='is_repeated_longitudinal'>Test if repeatable or longitudinal</h2><span id='topic+is_repeated_longitudinal'></span>

<h3>Description</h3>

<p>Test if repeatable or longitudinal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_repeated_longitudinal(
  data,
  generics = c("redcap_event_name", "redcap_repeat_instrument", "redcap_repeat_instance")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_repeated_longitudinal_+3A_data">data</code></td>
<td>
<p>data set</p>
</td></tr>
<tr><td><code id="is_repeated_longitudinal_+3A_generics">generics</code></td>
<td>
<p>default is &quot;redcap_event_name&quot;, &quot;redcap_repeat_instrument&quot;
and &quot;redcap_repeat_instance&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_repeated_longitudinal(c("record_id", "age", "record_id", "gender"))
is_repeated_longitudinal(redcapcast_data)
is_repeated_longitudinal(list(redcapcast_data))
</code></pre>

<hr>
<h2 id='mark_complete'>Completion marking based on completed upload</h2><span id='topic+mark_complete'></span>

<h3>Description</h3>

<p>Completion marking based on completed upload
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mark_complete(upload, ls)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mark_complete_+3A_upload">upload</code></td>
<td>
<p>output list from 'REDCapR::redcap_write()'</p>
</td></tr>
<tr><td><code id="mark_complete_+3A_ls">ls</code></td>
<td>
<p>output list from 'ds2dd_detailed()'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with 'REDCapR::redcap_write()' results
</p>

<hr>
<h2 id='match_fields_to_form'>Match fields to forms</h2><span id='topic+match_fields_to_form'></span>

<h3>Description</h3>

<p>Match fields to forms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_fields_to_form(metadata, vars_in_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_fields_to_form_+3A_metadata">metadata</code></td>
<td>
<p>A data frame containing field names and form names</p>
</td></tr>
<tr><td><code id="match_fields_to_form_+3A_vars_in_data">vars_in_data</code></td>
<td>
<p>A character vector of variable names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing field names and form names
</p>

<hr>
<h2 id='mtcars_redcap'>mtcars dataset slightly modified to use for Shiny app upload demonstration</h2><span id='topic+mtcars_redcap'></span>

<h3>Description</h3>

<p>mtcars dataset slightly modified to use for Shiny app upload demonstration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mtcars_redcap)
</code></pre>


<h3>Format</h3>

<p>A data frame with 13 variables:
</p>

<dl>
<dt>record_id</dt><dd><p>ID, numeric</p>
</dd>
<dt>mpg</dt><dd><p>ID, numeric</p>
</dd>
<dt>cyl</dt><dd><p>ID, numeric</p>
</dd>
<dt>disp</dt><dd><p>ID, numeric</p>
</dd>
<dt>hp</dt><dd><p>ID, numeric</p>
</dd>
<dt>drat</dt><dd><p>ID, numeric</p>
</dd>
<dt>wt</dt><dd><p>ID, numeric</p>
</dd>
<dt>qsec</dt><dd><p>ID, numeric</p>
</dd>
<dt>vs</dt><dd><p>ID, numeric</p>
</dd>
<dt>am</dt><dd><p>ID, numeric</p>
</dd>
<dt>gear</dt><dd><p>ID, numeric</p>
</dd>
<dt>carb</dt><dd><p>ID, numeric</p>
</dd>
<dt>name</dt><dd><p>original rownames, charater</p>
</dd>
</dl>


<hr>
<h2 id='read_input'>Flexible file import based on extension</h2><span id='topic+read_input'></span>

<h3>Description</h3>

<p>Flexible file import based on extension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_input(file, consider.na = c("NA", "\"\"", ""))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_input_+3A_file">file</code></td>
<td>
<p>file name</p>
</td></tr>
<tr><td><code id="read_input_+3A_consider.na">consider.na</code></td>
<td>
<p>character vector of strings to consider as NAs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>read_input("https://raw.githubusercontent.com/agdamsbo/cognitive.index.lookup/main/data/sample.csv")
</code></pre>

<hr>
<h2 id='read_redcap_instrument'>Convenience function to download complete instrument, using token storage
in keyring.</h2><span id='topic+read_redcap_instrument'></span>

<h3>Description</h3>

<p>Convenience function to download complete instrument, using token storage
in keyring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_redcap_instrument(
  key,
  uri,
  instrument,
  raw_or_label = "raw",
  id_name = "record_id",
  records = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_redcap_instrument_+3A_key">key</code></td>
<td>
<p>key name in standard keyring for token retrieval.</p>
</td></tr>
<tr><td><code id="read_redcap_instrument_+3A_uri">uri</code></td>
<td>
<p>REDCap database API uri</p>
</td></tr>
<tr><td><code id="read_redcap_instrument_+3A_instrument">instrument</code></td>
<td>
<p>instrument name</p>
</td></tr>
<tr><td><code id="read_redcap_instrument_+3A_raw_or_label">raw_or_label</code></td>
<td>
<p>raw or label passed to 'REDCapR::redcap_read()'</p>
</td></tr>
<tr><td><code id="read_redcap_instrument_+3A_id_name">id_name</code></td>
<td>
<p>id variable name. Default is &quot;record_id&quot;.</p>
</td></tr>
<tr><td><code id="read_redcap_instrument_+3A_records">records</code></td>
<td>
<p>specify the records to download. Index numbers.
Numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='read_redcap_tables'>Download REDCap data</h2><span id='topic+read_redcap_tables'></span>

<h3>Description</h3>

<p>Implementation of REDCap_split with a focused data acquisition approach using
REDCapR::redcap_read and only downloading specified fields, forms and/or
events using the built-in focused_metadata including some clean-up.
Works with classical and longitudinal projects with or without repeating
instruments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_redcap_tables(
  uri,
  token,
  records = NULL,
  fields = NULL,
  events = NULL,
  forms = NULL,
  raw_or_label = "label",
  split_forms = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_redcap_tables_+3A_uri">uri</code></td>
<td>
<p>REDCap database API uri</p>
</td></tr>
<tr><td><code id="read_redcap_tables_+3A_token">token</code></td>
<td>
<p>API token</p>
</td></tr>
<tr><td><code id="read_redcap_tables_+3A_records">records</code></td>
<td>
<p>records to download</p>
</td></tr>
<tr><td><code id="read_redcap_tables_+3A_fields">fields</code></td>
<td>
<p>fields to download</p>
</td></tr>
<tr><td><code id="read_redcap_tables_+3A_events">events</code></td>
<td>
<p>events to download</p>
</td></tr>
<tr><td><code id="read_redcap_tables_+3A_forms">forms</code></td>
<td>
<p>forms to download</p>
</td></tr>
<tr><td><code id="read_redcap_tables_+3A_raw_or_label">raw_or_label</code></td>
<td>
<p>raw or label tags</p>
</td></tr>
<tr><td><code id="read_redcap_tables_+3A_split_forms">split_forms</code></td>
<td>
<p>Whether to split &quot;repeating&quot; or &quot;all&quot; forms, default is
all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of instruments
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples will be provided later
</code></pre>

<hr>
<h2 id='REDCap_split'>Split REDCap repeating instruments table into multiple tables</h2><span id='topic+REDCap_split'></span>

<h3>Description</h3>

<p>This will take output from a REDCap export and split it into a base table
and child tables for each repeating instrument. Metadata
is used to determine which fields should be included in each resultant table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>REDCap_split(
  records,
  metadata,
  primary_table_name = "",
  forms = c("repeating", "all")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="REDCap_split_+3A_records">records</code></td>
<td>
<p>Exported project records. May be a <code>data.frame</code>,
<code>response</code>, or <code>character</code> vector containing JSON from an API
call.</p>
</td></tr>
<tr><td><code id="REDCap_split_+3A_metadata">metadata</code></td>
<td>
<p>Project metadata (the data dictionary). May be a
<code>data.frame</code>, <code>response</code>, or <code>character</code> vector containing
JSON from an API call.</p>
</td></tr>
<tr><td><code id="REDCap_split_+3A_primary_table_name">primary_table_name</code></td>
<td>
<p>Name given to the list element for the primary
output table (as described in <em>README.md</em>). Ignored if
<code>forms = 'all'</code>.</p>
</td></tr>
<tr><td><code id="REDCap_split_+3A_forms">forms</code></td>
<td>
<p>Indicate whether to create separate tables for repeating
instruments only or for all forms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>"data.frame"</code>s. The number of tables will differ
depending on the <code>forms</code> option selected.
</p>

<ul>
<li> <p><code>'repeating'</code>: one base table and one or more
tables for each repeating instrument.
</p>
</li>
<li> <p><code>'all'</code>: a data.frame for each instrument, regardless of
whether it is a repeating instrument or not.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Paul W. Egeler, M.S., GStat
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Using an API call -------------------------------------------------------

library(RCurl)

# Get the records
records &lt;- postForm(
  uri = api_url, # Supply your site-specific URI
  token = api_token, # Supply your own API token
  content = "record",
  format = "json",
  returnFormat = "json"
)

# Get the metadata
metadata &lt;- postForm(
  uri = api_url, # Supply your site-specific URI
  token = api_token, # Supply your own API token
  content = "metadata",
  format = "json"
)

# Convert exported JSON strings into a list of data.frames
REDCapRITS::REDCap_split(records, metadata)

# Using a raw data export -------------------------------------------------

# Get the records
records &lt;- read.csv("/path/to/data/ExampleProject_DATA_2018-06-03_1700.csv")

# Get the metadata
metadata &lt;- read.csv(
  "/path/to/data/ExampleProject_DataDictionary_2018-06-03.csv"
)

# Split the tables
REDCapRITS::REDCap_split(records, metadata)

# In conjunction with the R export script ---------------------------------

# You must set the working directory first since the REDCap data export
# script contains relative file references.
old &lt;- getwd()
setwd("/path/to/data/")

# Run the data export script supplied by REDCap.
# This will create a data.frame of your records called 'data'
source("ExampleProject_R_2018-06-03_1700.r")

# Get the metadatan
metadata &lt;- read.csv("ExampleProject_DataDictionary_2018-06-03.csv")

# Split the tables
REDCapRITS::REDCap_split(data, metadata)
setwd(old)

## End(Not run)
</code></pre>

<hr>
<h2 id='redcap_wider'>Redcap Wider</h2><span id='topic+redcap_wider'></span>

<h3>Description</h3>

<p>Converts a list of REDCap data frames from long to wide format.
Handles longitudinal projects, but not yet repeated instruments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redcap_wider(
  data,
  event.glue = "{.value}_{redcap_event_name}",
  inst.glue = "{.value}_{redcap_repeat_instance}"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="redcap_wider_+3A_data">data</code></td>
<td>
<p>A list of data frames.</p>
</td></tr>
<tr><td><code id="redcap_wider_+3A_event.glue">event.glue</code></td>
<td>
<p>A dplyr::glue string for repeated events naming</p>
</td></tr>
<tr><td><code id="redcap_wider_+3A_inst.glue">inst.glue</code></td>
<td>
<p>A dplyr::glue string for repeated instruments naming</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list of data frames in wide format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Longitudinal
list1 &lt;- list(
  data.frame(
    record_id = c(1, 2, 1, 2),
    redcap_event_name = c("baseline", "baseline", "followup", "followup"),
    age = c(25, 26, 27, 28)
  ),
  data.frame(
    record_id = c(1, 2),
    redcap_event_name = c("baseline", "baseline"),
    gender = c("male", "female")
  )
)
redcap_wider(list1)
# Simpel with two instruments
list2 &lt;- list(
  data.frame(
    record_id = c(1, 2),
    age = c(25, 26)
  ),
  data.frame(
    record_id = c(1, 2),
    gender = c("male", "female")
  )
)
redcap_wider(list2)
# Simple with single instrument
list3 &lt;- list(data.frame(
  record_id = c(1, 2),
  age = c(25, 26)
))
redcap_wider(list3)
# Longitudinal with repeatable instruments
list4 &lt;- list(
  data.frame(
    record_id = c(1, 2, 1, 2),
    redcap_event_name = c("baseline", "baseline", "followup", "followup"),
    age = c(25, 26, 27, 28)
  ),
  data.frame(
    record_id = c(1, 1, 1, 1, 2, 2, 2, 2),
    redcap_event_name = c(
      "baseline", "baseline", "followup", "followup",
      "baseline", "baseline", "followup", "followup"
    ),
    redcap_repeat_instrument = "walk",
    redcap_repeat_instance = c(1, 2, 1, 2, 1, 2, 1, 2),
    dist = c(40, 32, 25, 33, 28, 24, 23, 36)
  ),
  data.frame(
    record_id = c(1, 2),
    redcap_event_name = c("baseline", "baseline"),
    gender = c("male", "female")
  )
)
redcap_wider(list4)
</code></pre>

<hr>
<h2 id='redcapcast_data'>Data set for demonstration</h2><span id='topic+redcapcast_data'></span>

<h3>Description</h3>

<p>This is a small dataset from a REDCap database for demonstrational purposes.
Contains only synthetic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(redcapcast_data)
</code></pre>


<h3>Format</h3>

<p>A data frame with 22 variables:
</p>

<dl>
<dt>record_id</dt><dd><p>ID, numeric</p>
</dd>
<dt>redcap_event_name</dt><dd><p>Event name, character</p>
</dd>
<dt>redcap_repeat_instrument</dt><dd><p>Repeat instrument, character</p>
</dd>
<dt>redcap_repeat_instance</dt><dd><p>Repeat instance, numeric</p>
</dd>
<dt>cpr</dt><dd><p>CPR number, character</p>
</dd>
<dt>inclusion</dt><dd><p>Inclusion date, Date</p>
</dd>
<dt>inclusion_time</dt><dd><p>Inclusion time, hms</p>
</dd>
<dt>dob</dt><dd><p>Date of birth, Date</p>
</dd>
<dt>age</dt><dd><p>Age decimal, numeric</p>
</dd>
<dt>age_integer</dt><dd><p>Age integer, numeric</p>
</dd>
<dt>sex</dt><dd><p>Legal sex, character</p>
</dd>
<dt>cohabitation</dt><dd><p>Cohabitation status, character</p>
</dd>
<dt>hypertension</dt><dd><p>Hypertension, character</p>
</dd>
<dt>diabetes</dt><dd><p>diabetes, character</p>
</dd>
<dt>region</dt><dd><p>region, character</p>
</dd>
<dt>baseline_data_start_complete</dt><dd><p>Completed, character</p>
</dd>
<dt>mrs_assessed</dt><dd><p>mRS Assessed, character</p>
</dd>
<dt>mrs_date</dt><dd><p>Assesment date, Date</p>
</dd>
<dt>mrs_score</dt><dd><p>Categorical score, numeric</p>
</dd>
<dt>mrs_complete</dt><dd><p>Complete, numeric</p>
</dd>
<dt>event_datetime</dt><dd><p>Event datetime, POSIXct</p>
</dd>
<dt>event_age</dt><dd><p>Age at time of event, numeric</p>
</dd>
<dt>event_type</dt><dd><p>Event type, character</p>
</dd>
<dt>new_event_complete</dt><dd><p>Completed, character</p>
</dd>
</dl>


<hr>
<h2 id='redcapcast_meta'>REDCap metadata from data base</h2><span id='topic+redcapcast_meta'></span>

<h3>Description</h3>

<p>This metadata dataset from a REDCap database is for demonstrational purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(redcapcast_meta)
</code></pre>


<h3>Format</h3>

<p>A data frame with 22 variables:
</p>

<dl>
<dt>field_name</dt><dd><p>field_name, character</p>
</dd>
<dt>form_name</dt><dd><p>form_name, character</p>
</dd>
<dt>section_header</dt><dd><p>section_header, character</p>
</dd>
<dt>field_type</dt><dd><p>field_type, character</p>
</dd>
<dt>field_label</dt><dd><p>field_label, character</p>
</dd>
<dt>select_choices_or_calculations</dt><dd><p>select_choices_or_calculations, character</p>
</dd>
<dt>field_note</dt><dd><p>field_note, character</p>
</dd>
<dt>text_validation_type_or_show_slider_number</dt><dd><p>text_validation_type_or_show_slider_number, character</p>
</dd>
<dt>text_validation_min</dt><dd><p>text_validation_min, character</p>
</dd>
<dt>text_validation_max</dt><dd><p>text_validation_max, character</p>
</dd>
<dt>identifier</dt><dd><p>identifier, character</p>
</dd>
<dt>branching_logic</dt><dd><p>branching_logic, character</p>
</dd>
<dt>required_field</dt><dd><p>required_field, character</p>
</dd>
<dt>custom_alignment</dt><dd><p>custom_alignment, character</p>
</dd>
<dt>question_number</dt><dd><p>question_number, character</p>
</dd>
<dt>matrix_group_name</dt><dd><p>matrix_group_name, character</p>
</dd>
<dt>matrix_ranking</dt><dd><p>matrix_ranking, character</p>
</dd>
<dt>field_annotation</dt><dd><p>field_annotation, character</p>
</dd>
</dl>


<hr>
<h2 id='sanitize_split'>Sanitize list of data frames</h2><span id='topic+sanitize_split'></span>

<h3>Description</h3>

<p>Removing empty rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sanitize_split(
  l,
  generic.names = c("redcap_event_name", "redcap_repeat_instrument",
    "redcap_repeat_instance")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sanitize_split_+3A_l">l</code></td>
<td>
<p>A list of data frames.</p>
</td></tr>
<tr><td><code id="sanitize_split_+3A_generic.names">generic.names</code></td>
<td>
<p>A vector of generic names to be excluded.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames with generic names excluded.
</p>

<hr>
<h2 id='server_factory'>Shiny server factory</h2><span id='topic+server_factory'></span>

<h3>Description</h3>

<p>Shiny server factory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>server_factory()
</code></pre>


<h3>Value</h3>

<p>shiny server
</p>

<hr>
<h2 id='shiny_cast'>Launch the included Shiny-app for database casting and upload</h2><span id='topic+shiny_cast'></span>

<h3>Description</h3>

<p>Launch the included Shiny-app for database casting and upload
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shiny_cast()
</code></pre>


<h3>Value</h3>

<p>shiny app
</p>


<h3>Examples</h3>

<pre><code class='language-R'># shiny_cast()

</code></pre>

<hr>
<h2 id='split_non_repeating_forms'>Split a data frame into separate tables for each form</h2><span id='topic+split_non_repeating_forms'></span>

<h3>Description</h3>

<p>Split a data frame into separate tables for each form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_non_repeating_forms(table, universal_fields, fields)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_non_repeating_forms_+3A_table">table</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="split_non_repeating_forms_+3A_universal_fields">universal_fields</code></td>
<td>
<p>A character vector of fields that should be included
in every table</p>
</td></tr>
<tr><td><code id="split_non_repeating_forms_+3A_fields">fields</code></td>
<td>
<p>A two-column matrix containing the names of fields that should
be included in each form</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames, one for each non-repeating form
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a table
table &lt;- data.frame(
  id = c(1, 2, 3, 4, 5),
  form_a_name = c("John", "Alice", "Bob", "Eve", "Mallory"),
  form_a_age = c(25, 30, 25, 15, 20),
  form_b_name = c("John", "Alice", "Bob", "Eve", "Mallory"),
  form_b_gender = c("M", "F", "M", "F", "F")
)

# Create the universal fields
universal_fields &lt;- c("id")

# Create the fields
fields &lt;- matrix(
  c(
    "form_a_name", "form_a",
    "form_a_age", "form_a",
    "form_b_name", "form_b",
    "form_b_gender", "form_b"
  ),
  ncol = 2, byrow = TRUE
)

# Split the table
split_non_repeating_forms(table, universal_fields, fields)
</code></pre>

<hr>
<h2 id='strsplitx'>Extended string splitting</h2><span id='topic+strsplitx'></span>

<h3>Description</h3>

<p>Can be used as a substitute of the base function. Main claim to fame is
easing the split around the defined delimiter, see example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strsplitx(x, split, type = "classic", perl = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="strsplitx_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="strsplitx_+3A_split">split</code></td>
<td>
<p>delimiter</p>
</td></tr>
<tr><td><code id="strsplitx_+3A_type">type</code></td>
<td>
<p>Split type. Can be c(&quot;classic&quot;, &quot;before&quot;, &quot;after&quot;, &quot;around&quot;)</p>
</td></tr>
<tr><td><code id="strsplitx_+3A_perl">perl</code></td>
<td>
<p>perl param from strsplit()</p>
</td></tr>
<tr><td><code id="strsplitx_+3A_...">...</code></td>
<td>
<p>additional parameters are passed to base strsplit handling splits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- c("12 months follow-up", "3 steps", "mRS 6 weeks",
"Counting to 231 now")
strsplitx(test, "[0-9]", type = "around")
</code></pre>

<hr>
<h2 id='time_only_correction'>Correction based on time_only_filter function</h2><span id='topic+time_only_correction'></span>

<h3>Description</h3>

<p>Correction based on time_only_filter function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_only_correction(data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_only_correction_+3A_data">data</code></td>
<td>
<p>data set</p>
</td></tr>
<tr><td><code id="time_only_correction_+3A_...">...</code></td>
<td>
<p>arguments passed on to 'guess_time_only_filter()'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- redcapcast_data
## data |&gt; time_only_correction()
</code></pre>

<hr>
<h2 id='ui_factory'>UI factory for shiny app</h2><span id='topic+ui_factory'></span>

<h3>Description</h3>

<p>UI factory for shiny app
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ui_factory()
</code></pre>


<h3>Value</h3>

<p>shiny ui
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
