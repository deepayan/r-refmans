<!DOCTYPE html><html lang="en-US"><head><title>Help for package REDCapCAST</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {REDCapCAST}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#REDCapCAST-package'><p>REDCapCAST: REDCap Metadata Casting and Castellated Data Handling</p></a></li>
<li><a href='#all_na'><p>Check if vector is all NA</p></a></li>
<li><a href='#apply_factor_labels'><p>Preserve all factor levels from REDCap data dictionary in data export</p></a></li>
<li><a href='#apply_field_label'><p>Apply REDCap filed labels to data frame</p></a></li>
<li><a href='#as_factor'><p>Convert labelled vectors to factors while preserving attributes</p></a></li>
<li><a href='#as_logical'><p>Interpret specific binary values as logicals</p></a></li>
<li><a href='#case_match_regex_list'><p>List-base regex case_when</p></a></li>
<li><a href='#cast_data_overview'><p>Overview of REDCapCAST data for shiny</p></a></li>
<li><a href='#cast_meta_overview'><p>Overview of REDCapCAST meta data for shiny</p></a></li>
<li><a href='#char2choice'><p>Simple function to generate REDCap choices from character vector</p></a></li>
<li><a href='#char2cond'><p>Simple function to generate REDCap branching logic from character vector</p></a></li>
<li><a href='#clean_field_label'><p>Very simple function to remove rich text formatting from field label</p>
and save the first paragraph ('&lt;p&gt;...&lt;/p&gt;').</a></li>
<li><a href='#clean_redcap_name'><p>clean_redcap_name</p></a></li>
<li><a href='#compact_vec'><p>Compacting a vector of any length with or without names</p></a></li>
<li><a href='#create_html_table'><p>Create two-column HTML table for data piping in REDCap instruments</p></a></li>
<li><a href='#create_instrument_meta'><p>DEPRICATED Create zips file with necessary content based on data set</p></a></li>
<li><a href='#cut_string_length'><p>Cut string to desired length</p></a></li>
<li><a href='#d2w'><p>Convert single digits to words</p></a></li>
<li><a href='#doc2dd'><p>Doc table to data dictionary - EARLY, DOCS MISSING</p></a></li>
<li><a href='#ds2dd'><p>(DEPRECATED) Data set to data dictionary function</p></a></li>
<li><a href='#ds2dd_detailed'><p>Extract data from stata file for data dictionary</p></a></li>
<li><a href='#easy_redcap'><p>Secure API key storage and data acquisition in one</p></a></li>
<li><a href='#export_redcap_instrument'><p>Creates zip-file with necessary content to manually add instrument to database</p></a></li>
<li><a href='#fct_drop'><p>Drop unused levels preserving label data</p></a></li>
<li><a href='#fct2num'><p>Allows conversion of factor to numeric values preserving original levels</p></a></li>
<li><a href='#file_extension'><p>DEPRECATED Helper to import files correctly</p></a></li>
<li><a href='#focused_metadata'><p>focused_metadata</p></a></li>
<li><a href='#format_redcap_factor'><p>Converts REDCap choices to factor levels and stores in labels attribute</p></a></li>
<li><a href='#format_subheader'><p>Sub-header formatting wrapper</p></a></li>
<li><a href='#get_api_key'><p>Retrieve project API key if stored, if not, set and retrieve</p></a></li>
<li><a href='#get_attr'><p>Extract attribute. Returns NA if none</p></a></li>
<li><a href='#get_id_name'><p>Get the id name</p></a></li>
<li><a href='#guess_time_only'><p>Guess time variables based on naming pattern</p></a></li>
<li><a href='#guess_time_only_filter'><p>Try at determining which are true time only variables</p></a></li>
<li><a href='#haven_all_levels'><p>Finish incomplete haven attributes substituting missings with values</p></a></li>
<li><a href='#hms2character'><p>Change &quot;hms&quot; to &quot;character&quot; for REDCap upload.</p></a></li>
<li><a href='#html_tag_wrap'><p>Simple html tag wrapping for REDCap text formatting</p></a></li>
<li><a href='#is_missing'><p>Multi missing check</p></a></li>
<li><a href='#is_repeated_longitudinal'><p>Test if repeatable or longitudinal</p></a></li>
<li><a href='#is.labelled'><p>Tests for multiple label classes</p></a></li>
<li><a href='#mark_complete'><p>Completion marking based on completed upload</p></a></li>
<li><a href='#match_fields_to_form'><p>Match fields to forms</p></a></li>
<li><a href='#mtcars_redcap'><p>mtcars dataset slightly modified to use for Shiny app upload demonstration</p></a></li>
<li><a href='#named_levels'><p>Get named vector of factor levels and values</p></a></li>
<li><a href='#nav_bar_page'><p>Nav_bar defining function for shiny ui</p></a></li>
<li><a href='#numchar2fct'><p>Applying var2fct across data set</p></a></li>
<li><a href='#parse_data'><p>Helper to auto-parse un-formatted data with haven and readr</p></a></li>
<li><a href='#possibly_numeric'><p>Tests if vector can be interpreted as numeric without introducing NAs by</p>
coercion</a></li>
<li><a href='#possibly_roman'><p>Test if vector can be interpreted as roman numerals</p></a></li>
<li><a href='#process_user_input'><p>User input processing</p></a></li>
<li><a href='#process_user_input.character'><p>User input processing character</p></a></li>
<li><a href='#process_user_input.data.frame'><p>User input processing data.frame</p></a></li>
<li><a href='#process_user_input.default'><p>User input processing default</p></a></li>
<li><a href='#process_user_input.response'><p>User input processing response</p></a></li>
<li><a href='#read_input'><p>Flexible file import based on extension</p></a></li>
<li><a href='#read_redcap_instrument'><p>Convenience function to download complete instrument, using token storage</p>
in keyring.</a></li>
<li><a href='#read_redcap_tables'><p>Download REDCap data</p></a></li>
<li><a href='#REDCap_split'><p>Split REDCap repeating instruments table into multiple tables</p></a></li>
<li><a href='#redcap_wider'><p>Transforms list of REDCap data.frames to a single wide data.frame</p></a></li>
<li><a href='#redcapcast_data'><p>Data set for demonstration</p></a></li>
<li><a href='#redcapcast_meta'><p>REDCap metadata from data base</p></a></li>
<li><a href='#replace_curly_quote'><p>Replace curly apostrophes and quotes from word</p></a></li>
<li><a href='#sanitize_split'><p>Sanitize list of data frames</p></a></li>
<li><a href='#set_attr'><p>Set attributes for named attribute. Appends if attr is NULL</p></a></li>
<li><a href='#shiny_cast'><p>Launch the included Shiny-app for database casting and upload</p></a></li>
<li><a href='#split_non_repeating_forms'><p>Split a data frame into separate tables for each form</p></a></li>
<li><a href='#strsplitx'><p>Extended string splitting</p></a></li>
<li><a href='#suffix2label'><p>Transfer variable name suffix to label in widened data</p></a></li>
<li><a href='#time_only_correction'><p>Correction based on time_only_filter function</p></a></li>
<li><a href='#var2fct'><p>Convert vector to factor based on threshold of number of unique levels</p></a></li>
<li><a href='#vec2choice'><p>Named vector to REDCap choices ('wrapping compact_vec()')</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>REDCap Metadata Casting and Castellated Data Handling</td>
</tr>
<tr>
<td>Version:</td>
<td>25.3.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Casting metadata for REDCap database creation and handling of 
    castellated data using repeated instruments and longitudinal projects in 
    'REDCap'. Keeps a focused data export approach, by allowing to only export 
    required data from the database. Also for casting new REDCap databases based 
    on datasets from other sources.
    Originally forked from the R part of 'REDCapRITS' by Paul Egeler. 
    See <a href="https://github.com/pegeler/REDCapRITS">https://github.com/pegeler/REDCapRITS</a>.
    'REDCap' (Research Electronic Data Capture) is a secure, web-based software
    platform designed to support data capture for research studies, providing
    1) an intuitive interface for validated data capture; 2) audit trails for
    tracking data manipulation and export procedures; 3) automated export
    procedures for seamless data downloads to common statistical packages; and
    4) procedures for data integration and interoperability with external 
    sources (Harris et al (2009) &lt;<a href="https://doi.org/10.1016%2Fj.jbi.2008.08.010">doi:10.1016/j.jbi.2008.08.010</a>&gt;; 
    Harris et al (2019) &lt;<a href="https://doi.org/10.1016%2Fj.jbi.2019.103208">doi:10.1016/j.jbi.2019.103208</a>&gt;).</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>httr, jsonlite, testthat, Hmisc, knitr, rmarkdown, styler,
devtools, roxygen2, spelling, rhub, rsconnect, pkgconfig</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/agdamsbo/REDCapCAST">https://github.com/agdamsbo/REDCapCAST</a>,
<a href="https://agdamsbo.github.io/REDCapCAST/">https://agdamsbo.github.io/REDCapCAST/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/agdamsbo/REDCapCAST/issues">https://github.com/agdamsbo/REDCapCAST/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, REDCapR, tidyr, tidyselect, keyring, purrr, readr,
stats, zip, assertthat, forcats, vctrs, gt, bslib, here, glue,
gtsummary, shiny, haven, openxlsx2, readODS</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Collate:</td>
<td>'REDCapCAST-package.R' 'utils.r' 'process_user_input.r'
'REDCap_split.r' 'as_factor.R' 'as_logical.R' 'doc2dd.R'
'ds2dd_detailed.R' 'easy_redcap.R' 'export_redcap_instrument.R'
'fct_drop.R' 'html_styling.R' 'mtcars_redcap.R'
'read_redcap_instrument.R' 'read_redcap_tables.R'
'redcap_wider.R' 'redcapcast_data.R' 'redcapcast_meta.R'
'shiny_cast.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-10 10:39:02 UTC; au301842</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Gammelgaard Damsbo
    <a href="https://orcid.org/0000-0002-7559-1154"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Paul Egeler <a href="https://orcid.org/0000-0001-6948-9498"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Gammelgaard Damsbo &lt;agdamsbo@clin.au.dk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-10 14:30:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='REDCapCAST-package'>REDCapCAST: REDCap Metadata Casting and Castellated Data Handling</h2><span id='topic+REDCapCAST'></span><span id='topic+REDCapCAST-package'></span>

<h3>Description</h3>

<p>Casting metadata for REDCap database creation and handling of castellated data using repeated instruments and longitudinal projects in 'REDCap'. Keeps a focused data export approach, by allowing to only export required data from the database. Also for casting new REDCap databases based on datasets from other sources. Originally forked from the R part of 'REDCapRITS' by Paul Egeler. See <a href="https://github.com/pegeler/REDCapRITS">https://github.com/pegeler/REDCapRITS</a>. 'REDCap' (Research Electronic Data Capture) is a secure, web-based software platform designed to support data capture for research studies, providing 1) an intuitive interface for validated data capture; 2) audit trails for tracking data manipulation and export procedures; 3) automated export procedures for seamless data downloads to common statistical packages; and 4) procedures for data integration and interoperability with external sources (Harris et al (2009) <a href="https://doi.org/10.1016/j.jbi.2008.08.010">doi:10.1016/j.jbi.2008.08.010</a>; Harris et al (2019) <a href="https://doi.org/10.1016/j.jbi.2019.103208">doi:10.1016/j.jbi.2019.103208</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Andreas Gammelgaard Damsbo <a href="mailto:agdamsbo@clin.au.dk">agdamsbo@clin.au.dk</a> (<a href="https://orcid.org/0000-0002-7559-1154">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Paul Egeler <a href="mailto:paulegeler@gmail.com">paulegeler@gmail.com</a> (<a href="https://orcid.org/0000-0001-6948-9498">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/agdamsbo/REDCapCAST">https://github.com/agdamsbo/REDCapCAST</a>
</p>
</li>
<li> <p><a href="https://agdamsbo.github.io/REDCapCAST/">https://agdamsbo.github.io/REDCapCAST/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/agdamsbo/REDCapCAST/issues">https://github.com/agdamsbo/REDCapCAST/issues</a>
</p>
</li></ul>


<hr>
<h2 id='all_na'>Check if vector is all NA</h2><span id='topic+all_na'></span>

<h3>Description</h3>

<p>Check if vector is all NA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_na(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="all_na_+3A_data">data</code></td>
<td>
<p>vector of data.frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rep(NA, 4) |&gt; all_na()
</code></pre>

<hr>
<h2 id='apply_factor_labels'>Preserve all factor levels from REDCap data dictionary in data export</h2><span id='topic+apply_factor_labels'></span>

<h3>Description</h3>

<p>Preserve all factor levels from REDCap data dictionary in data export
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_factor_labels(data, meta = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_factor_labels_+3A_data">data</code></td>
<td>
<p>REDCap exported data set</p>
</td></tr>
<tr><td><code id="apply_factor_labels_+3A_meta">meta</code></td>
<td>
<p>REDCap data dictionary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='apply_field_label'>Apply REDCap filed labels to data frame</h2><span id='topic+apply_field_label'></span>

<h3>Description</h3>

<p>Apply REDCap filed labels to data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_field_label(data, meta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_field_label_+3A_data">data</code></td>
<td>
<p>REDCap exported data set</p>
</td></tr>
<tr><td><code id="apply_field_label_+3A_meta">meta</code></td>
<td>
<p>REDCap data dictionary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='as_factor'>Convert labelled vectors to factors while preserving attributes</h2><span id='topic+as_factor'></span><span id='topic+as_factor.factor'></span><span id='topic+as_factor.logical'></span><span id='topic+as_factor.numeric'></span><span id='topic+as_factor.character'></span><span id='topic+as_factor.haven_labelled'></span><span id='topic+as_factor.labelled'></span><span id='topic+as_factor.data.frame'></span>

<h3>Description</h3>

<p>This extends <a href="forcats.html#topic+as_factor">as_factor</a> as well as <a href="haven.html#topic+as_factor">as_factor</a>, by appending
original attributes except for &quot;class&quot; after converting to factor to avoid
ta loss in case of rich formatted and labelled data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_factor(x, ...)

## S3 method for class 'factor'
as_factor(x, ...)

## S3 method for class 'logical'
as_factor(x, ...)

## S3 method for class 'numeric'
as_factor(x, ...)

## S3 method for class 'character'
as_factor(x, ...)

## S3 method for class 'haven_labelled'
as_factor(
  x,
  levels = c("default", "labels", "values", "both"),
  ordered = FALSE,
  ...
)

## S3 method for class 'labelled'
as_factor(
  x,
  levels = c("default", "labels", "values", "both"),
  ordered = FALSE,
  ...
)

## S3 method for class 'data.frame'
as_factor(x, ..., only_labelled = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_factor_+3A_x">x</code></td>
<td>
<p>Object to coerce to a factor.</p>
</td></tr>
<tr><td><code id="as_factor_+3A_...">...</code></td>
<td>
<p>Other arguments passed down to method.</p>
</td></tr>
<tr><td><code id="as_factor_+3A_levels">levels</code></td>
<td>
<p>How to create the levels of the generated factor:
</p>
<p>* &quot;default&quot;: uses labels where available, otherwise the values.
Labels are sorted by value.
* &quot;both&quot;: like &quot;default&quot;, but pastes together the level and value
* &quot;label&quot;: use only the labels; unlabelled values become 'NA'
* &quot;values&quot;: use only the values</p>
</td></tr>
<tr><td><code id="as_factor_+3A_ordered">ordered</code></td>
<td>
<p>If 'TRUE' create an ordered (ordinal) factor, if
'FALSE' (the default) create a regular (nominal) factor.</p>
</td></tr>
<tr><td><code id="as_factor_+3A_only_labelled">only_labelled</code></td>
<td>
<p>Only apply to labelled columns?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Please refer to parent functions for extended documentation.
To avoid redundancy calls and errors, functions are copy-pasted here
</p>
<p>Empty variables with empty levels attribute are interpreted as logicals
</p>


<h3>Examples</h3>

<pre><code class='language-R'># will preserve all attributes
c(1, 4, 3, "A", 7, 8, 1) |&gt; as_factor()
structure(c(1, 2, 3, 2, 10, 9),
  labels = c(Unknown = 9, Refused = 10)
) |&gt;
  as_factor() |&gt;
  dput()

structure(c(1, 2, 3, 2, 10, 9),
  labels = c(Unknown = 9, Refused = 10),
  class = "haven_labelled"
) |&gt;
  as_factor() |&gt; class()
structure(rep(NA,10),
  class = c("labelled")
) |&gt;
  as_factor() |&gt; summary()

rep(NA,10) |&gt; as_factor()

</code></pre>

<hr>
<h2 id='as_logical'>Interpret specific binary values as logicals</h2><span id='topic+as_logical'></span><span id='topic+as_logical.data.frame'></span><span id='topic+as_logical.default'></span>

<h3>Description</h3>

<p>Interpret specific binary values as logicals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_logical(
  x,
  values = list(c("TRUE", "FALSE"), c("Yes", "No"), c(1, 0), c(1, 2)),
  ...
)

## S3 method for class 'data.frame'
as_logical(
  x,
  values = list(c("TRUE", "FALSE"), c("Yes", "No"), c(1, 0), c(1, 2)),
  ...
)

## Default S3 method:
as_logical(
  x,
  values = list(c("TRUE", "FALSE"), c("Yes", "No"), c(1, 0), c(1, 2)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as_logical_+3A_x">x</code></td>
<td>
<p>vector or data.frame</p>
</td></tr>
<tr><td><code id="as_logical_+3A_values">values</code></td>
<td>
<p>list of values to interpret as logicals. First value is</p>
</td></tr>
<tr><td><code id="as_logical_+3A_...">...</code></td>
<td>
<p>ignored
interpreted as TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c(sample(c("TRUE", "FALSE"), 20, TRUE), NA) |&gt;
  as_logical() |&gt;
  class()
ds &lt;- dplyr::tibble(
  B = factor(sample(c(1, 2), 20, TRUE)),
  A = factor(sample(c("TRUE", "FALSE"), 20, TRUE)),
  C = sample(c(3, 4), 20, TRUE),
  D = factor(sample(c("In", "Out"), 20, TRUE))
)
ds |&gt;
  as_logical() |&gt;
  sapply(class)
ds$A |&gt; class()
sample(c("TRUE",NA), 20, TRUE) |&gt;
  as_logical()
as_logical(0)
</code></pre>

<hr>
<h2 id='case_match_regex_list'>List-base regex case_when</h2><span id='topic+case_match_regex_list'></span>

<h3>Description</h3>

<p>Mimics case_when for list of regex patterns and values. Used for date/time
validation generation from name vector. Like case_when, the matches are in
order of priority.
Primarily used in REDCapCAST to do data type coding from systematic variable
naming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>case_match_regex_list(data, match.list, .default = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="case_match_regex_list_+3A_data">data</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="case_match_regex_list_+3A_match.list">match.list</code></td>
<td>
<p>list of case matches</p>
</td></tr>
<tr><td><code id="case_match_regex_list_+3A_.default">.default</code></td>
<td>
<p>Default value for non-matches. Default is NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>case_match_regex_list(
  c("test_date", "test_time", "test_tida", "test_tid"),
  list(date_dmy = "_dat[eo]$", time_hh_mm_ss = "_ti[md]e?$")
)
</code></pre>

<hr>
<h2 id='cast_data_overview'>Overview of REDCapCAST data for shiny</h2><span id='topic+cast_data_overview'></span>

<h3>Description</h3>

<p>Overview of REDCapCAST data for shiny
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cast_data_overview(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cast_data_overview_+3A_data">data</code></td>
<td>
<p>list with class 'REDCapCAST'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gt object
</p>

<hr>
<h2 id='cast_meta_overview'>Overview of REDCapCAST meta data for shiny</h2><span id='topic+cast_meta_overview'></span>

<h3>Description</h3>

<p>Overview of REDCapCAST meta data for shiny
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cast_meta_overview(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cast_meta_overview_+3A_data">data</code></td>
<td>
<p>list with class 'REDCapCAST'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>gt object
</p>

<hr>
<h2 id='char2choice'>Simple function to generate REDCap choices from character vector</h2><span id='topic+char2choice'></span>

<h3>Description</h3>

<p>Simple function to generate REDCap choices from character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>char2choice(data, char.split = "/", raw = NULL, .default = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="char2choice_+3A_data">data</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="char2choice_+3A_char.split">char.split</code></td>
<td>
<p>splitting character(s)</p>
</td></tr>
<tr><td><code id="char2choice_+3A_raw">raw</code></td>
<td>
<p>specific values. Can be used for options of same length.</p>
</td></tr>
<tr><td><code id="char2choice_+3A_.default">.default</code></td>
<td>
<p>default value for missing. Default is NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>char2choice(c("yes/no","  yep. / nope  ","",NA,"what"),.default=NA)
</code></pre>

<hr>
<h2 id='char2cond'>Simple function to generate REDCap branching logic from character vector</h2><span id='topic+char2cond'></span>

<h3>Description</h3>

<p>Simple function to generate REDCap branching logic from character vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>char2cond(
  data,
  minor.split = ",",
  major.split = ";",
  major.sep = " or ",
  .default = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="char2cond_+3A_data">data</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="char2cond_+3A_minor.split">minor.split</code></td>
<td>
<p>minor split</p>
</td></tr>
<tr><td><code id="char2cond_+3A_major.split">major.split</code></td>
<td>
<p>major split</p>
</td></tr>
<tr><td><code id="char2cond_+3A_major.sep">major.sep</code></td>
<td>
<p>argument separation. Default is &quot; or &quot;.</p>
</td></tr>
<tr><td><code id="char2cond_+3A_.default">.default</code></td>
<td>
<p>default value for missing. Default is NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#data &lt;- dd_inst$betingelse
#c("Extubation_novent, 2; Pacu_delay, 1") |&gt; char2cond()
</code></pre>

<hr>
<h2 id='clean_field_label'>Very simple function to remove rich text formatting from field label
and save the first paragraph ('&lt;p&gt;...&lt;/p&gt;').</h2><span id='topic+clean_field_label'></span>

<h3>Description</h3>

<p>Very simple function to remove rich text formatting from field label
and save the first paragraph ('&lt;p&gt;...&lt;/p&gt;').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_field_label(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_field_label_+3A_data">data</code></td>
<td>
<p>field label</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>clean_field_label("&lt;div class=\"rich-text-field-label\"&gt;&lt;p&gt;Fazekas score&lt;/p&gt;&lt;/div&gt;")
</code></pre>

<hr>
<h2 id='clean_redcap_name'>clean_redcap_name</h2><span id='topic+clean_redcap_name'></span>

<h3>Description</h3>

<p>Stepwise removal on non-alphanumeric characters, trailing white space,
substitutes spaces for underscores and converts to lower case.
Trying to make up for different naming conventions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_redcap_name(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="clean_redcap_name_+3A_x">x</code></td>
<td>
<p>vector or data frame for cleaning</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector or data frame, same format as input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>"Research!, ne:ws? and c;l-.ls" |&gt; clean_redcap_name()
</code></pre>

<hr>
<h2 id='compact_vec'>Compacting a vector of any length with or without names</h2><span id='topic+compact_vec'></span>

<h3>Description</h3>

<p>Compacting a vector of any length with or without names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compact_vec(data, nm.sep = ": ", val.sep = "; ")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compact_vec_+3A_data">data</code></td>
<td>
<p>vector, optionally named</p>
</td></tr>
<tr><td><code id="compact_vec_+3A_nm.sep">nm.sep</code></td>
<td>
<p>string separating name from value if any</p>
</td></tr>
<tr><td><code id="compact_vec_+3A_val.sep">val.sep</code></td>
<td>
<p>string separating values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample(seq_len(4), 20, TRUE) |&gt;
  as_factor() |&gt;
  named_levels() |&gt;
  sort() |&gt;
  compact_vec()
1:6 |&gt; compact_vec()
"test" |&gt; compact_vec()
sample(letters[1:9], 20, TRUE) |&gt; compact_vec()
</code></pre>

<hr>
<h2 id='create_html_table'>Create two-column HTML table for data piping in REDCap instruments</h2><span id='topic+create_html_table'></span>

<h3>Description</h3>

<p>Create two-column HTML table for data piping in REDCap instruments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_html_table(text, variable)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_html_table_+3A_text">text</code></td>
<td>
<p>descriptive text</p>
</td></tr>
<tr><td><code id="create_html_table_+3A_variable">variable</code></td>
<td>
<p>variable to pipe</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>create_html_table(text = "Patient ID", variable = c("[cpr]"))
create_html_table(text = paste("assessor", 1:2, sep = "_"), variable = c("[cpr]"))
# create_html_table(text = c("CPR nummer","Word"), variable = c("[cpr][1]", "[cpr][2]", "[test]"))
</code></pre>

<hr>
<h2 id='create_instrument_meta'>DEPRICATED Create zips file with necessary content based on data set</h2><span id='topic+create_instrument_meta'></span>

<h3>Description</h3>

<p>Metadata can be added by editing the data dictionary of a project in the
initial design phase. If you want to later add new instruments, this
function can be used to create (an) instrument(s) to add to a project in
production.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_instrument_meta(data, dir = here::here(""), record.id = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_instrument_meta_+3A_data">data</code></td>
<td>
<p>metadata for the relevant instrument.
Could be from 'ds2dd_detailed()'</p>
</td></tr>
<tr><td><code id="create_instrument_meta_+3A_dir">dir</code></td>
<td>
<p>destination dir for the instrument zip. Default is the current WD.</p>
</td></tr>
<tr><td><code id="create_instrument_meta_+3A_record.id">record.id</code></td>
<td>
<p>flag to omit the first row of the data dictionary assuming
this is the record_id field which should not be included in the instrument.
Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data &lt;- iris |&gt;
  ds2dd_detailed(
    add.auto.id = TRUE,
    form.name = sample(c("b", "c"),
      size = 6,
      replace = TRUE, prob = rep(.5, 2)
    )
  ) |&gt;
  purrr::pluck("meta")
# data |&gt; create_instrument_meta()

data &lt;- iris |&gt;
  ds2dd_detailed(add.auto.id = FALSE) |&gt;
  purrr::pluck("data")
iris |&gt;
  setNames(glue::glue("{sample(x = c('a','b'),size = length(ncol(iris)),
replace=TRUE,prob = rep(x=.5,2))}__{names(iris)}")) |&gt;
  ds2dd_detailed(form.sep = "__")
data |&gt;
  purrr::pluck("meta") |&gt;
  create_instrument_meta(record.id = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='cut_string_length'>Cut string to desired length</h2><span id='topic+cut_string_length'></span>

<h3>Description</h3>

<p>Cut string to desired length
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cut_string_length(data, l = 100)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cut_string_length_+3A_data">data</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="cut_string_length_+3A_l">l</code></td>
<td>
<p>length</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string of length l
</p>


<h3>Examples</h3>

<pre><code class='language-R'>"length" |&gt; cut_string_length(l=3)
</code></pre>

<hr>
<h2 id='d2w'>Convert single digits to words</h2><span id='topic+d2w'></span>

<h3>Description</h3>

<p>Convert single digits to words
</p>


<h3>Usage</h3>

<pre><code class='language-R'>d2w(x, lang = "en", neutrum = FALSE, everything = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="d2w_+3A_x">x</code></td>
<td>
<p>data. Handle vectors, data.frames and lists</p>
</td></tr>
<tr><td><code id="d2w_+3A_lang">lang</code></td>
<td>
<p>language. Danish (da) and English (en), Default is &quot;en&quot;</p>
</td></tr>
<tr><td><code id="d2w_+3A_neutrum">neutrum</code></td>
<td>
<p>for numbers depending on counted word</p>
</td></tr>
<tr><td><code id="d2w_+3A_everything">everything</code></td>
<td>
<p>flag to also split numbers &gt;9 to single digits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns characters in same format as input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d2w(c(2:8, 21))
d2w(data.frame(2:7, 3:8, 1), lang = "da", neutrum = TRUE)

## If everything=T, also larger numbers are reduced.
## Elements in the list are same length as input
d2w(list(2:8, c(2, 6, 4, 23), 2), everything = TRUE)

</code></pre>

<hr>
<h2 id='doc2dd'>Doc table to data dictionary - EARLY, DOCS MISSING</h2><span id='topic+doc2dd'></span>

<h3>Description</h3>

<p>Works well with 'project.aid::docx2list()'.
Allows defining a database in a text document (see provided template) for
an easier to use data base creation. This approach allows easier
collaboration when defining the database. The generic case is a data frame
with variable names as values in a column. This is a format like the REDCap
data dictionary, but gives a few options for formatting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>doc2dd(
  data,
  instrument.name,
  col.variables = 1,
  list.datetime.format = list(date_dmy = "_dat[eo]$", time_hh_mm_ss = "_ti[md]e?$"),
  col.description = NULL,
  col.condition = NULL,
  col.subheader = NULL,
  subheader.tag = "h2",
  condition.minor.sep = ",",
  condition.major.sep = ";",
  col.calculation = NULL,
  col.choices = NULL,
  choices.char.sep = "/",
  missing.default = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="doc2dd_+3A_data">data</code></td>
<td>
<p>tibble or data.frame with all variable names in one column</p>
</td></tr>
<tr><td><code id="doc2dd_+3A_instrument.name">instrument.name</code></td>
<td>
<p>character vector length one. Instrument name.</p>
</td></tr>
<tr><td><code id="doc2dd_+3A_col.variables">col.variables</code></td>
<td>
<p>variable names column (default = 1), allows dplyr
subsetting</p>
</td></tr>
<tr><td><code id="doc2dd_+3A_list.datetime.format">list.datetime.format</code></td>
<td>
<p>formatting for date/time detection.
See 'case_match_regex_list()'</p>
</td></tr>
<tr><td><code id="doc2dd_+3A_col.description">col.description</code></td>
<td>
<p>descriptions column, allows dplyr
subsetting. If empty, variable names will be used.</p>
</td></tr>
<tr><td><code id="doc2dd_+3A_col.condition">col.condition</code></td>
<td>
<p>conditions for branching column, allows dplyr
subsetting. See 'char2cond()'.</p>
</td></tr>
<tr><td><code id="doc2dd_+3A_col.subheader">col.subheader</code></td>
<td>
<p>sub-header column, allows dplyr subsetting.
See 'format_subheader()'.</p>
</td></tr>
<tr><td><code id="doc2dd_+3A_subheader.tag">subheader.tag</code></td>
<td>
<p>formatting tag. Default is &quot;h2&quot;</p>
</td></tr>
<tr><td><code id="doc2dd_+3A_condition.minor.sep">condition.minor.sep</code></td>
<td>
<p>condition split minor. See 'char2cond()'.
Default is &quot;,&quot;.</p>
</td></tr>
<tr><td><code id="doc2dd_+3A_condition.major.sep">condition.major.sep</code></td>
<td>
<p>condition split major. See 'char2cond()'.
Default is &quot;;&quot;.</p>
</td></tr>
<tr><td><code id="doc2dd_+3A_col.calculation">col.calculation</code></td>
<td>
<p>calculations column. Has to be written exact.
Character vector.</p>
</td></tr>
<tr><td><code id="doc2dd_+3A_col.choices">col.choices</code></td>
<td>
<p>choices column. See 'char2choice()'.</p>
</td></tr>
<tr><td><code id="doc2dd_+3A_choices.char.sep">choices.char.sep</code></td>
<td>
<p>choices split. See 'char2choice()'. Default is &quot;/&quot;.</p>
</td></tr>
<tr><td><code id="doc2dd_+3A_missing.default">missing.default</code></td>
<td>
<p>value for missing fields. Default is NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble or data.frame (same as data)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data &lt;- dd_inst
# data |&gt; doc2dd(instrument.name = "evt",
# col.description = 3,
# col.condition = 4,
# col.subheader = 2,
# col.calculation = 5,
# col.choices = 6)
</code></pre>

<hr>
<h2 id='ds2dd'>(DEPRECATED) Data set to data dictionary function</h2><span id='topic+ds2dd'></span>

<h3>Description</h3>

<p>Creates a very basic data dictionary skeleton. Please see 'ds2dd_detailed()'
for a more advanced function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds2dd(
  ds,
  record.id = "record_id",
  form.name = "basis",
  field.type = "text",
  field.label = NULL,
  include.column.names = FALSE,
  metadata = names(REDCapCAST::redcapcast_meta)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds2dd_+3A_ds">ds</code></td>
<td>
<p>data set</p>
</td></tr>
<tr><td><code id="ds2dd_+3A_record.id">record.id</code></td>
<td>
<p>name or column number of id variable, moved to first row of
data dictionary, character of integer. Default is &quot;record_id&quot;.</p>
</td></tr>
<tr><td><code id="ds2dd_+3A_form.name">form.name</code></td>
<td>
<p>vector of form names, character string, length 1 or length
equal to number of variables. Default is &quot;basis&quot;.</p>
</td></tr>
<tr><td><code id="ds2dd_+3A_field.type">field.type</code></td>
<td>
<p>vector of field types, character string, length 1 or length
equal to number of variables. Default is &quot;text.</p>
</td></tr>
<tr><td><code id="ds2dd_+3A_field.label">field.label</code></td>
<td>
<p>vector of form names, character string, length 1 or length
equal to number of variables. Default is NULL and is then identical to field
names.</p>
</td></tr>
<tr><td><code id="ds2dd_+3A_include.column.names">include.column.names</code></td>
<td>
<p>Flag to give detailed output including new
column names for original data set for upload.</p>
</td></tr>
<tr><td><code id="ds2dd_+3A_metadata">metadata</code></td>
<td>
<p>Metadata column names. Default is the included
names(REDCapCAST::redcapcast_meta).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Migrated from stRoke ds2dd(). Fits better with the functionality of
'REDCapCAST'.
</p>


<h3>Value</h3>

<p>data.frame or list of data.frame and vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>redcapcast_data$record_id &lt;- seq_len(nrow(redcapcast_data))
ds2dd(redcapcast_data, include.column.names = TRUE)
</code></pre>

<hr>
<h2 id='ds2dd_detailed'>Extract data from stata file for data dictionary</h2><span id='topic+ds2dd_detailed'></span>

<h3>Description</h3>

<p>Extract data from stata file for data dictionary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ds2dd_detailed(
  data,
  add.auto.id = FALSE,
  date.format = "dmy",
  form.name = NULL,
  form.sep = NULL,
  form.prefix = TRUE,
  field.type = NULL,
  field.label = NULL,
  field.label.attr = "label",
  field.validation = NULL,
  metadata = names(REDCapCAST::redcapcast_meta),
  convert.logicals = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ds2dd_detailed_+3A_data">data</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_add.auto.id">add.auto.id</code></td>
<td>
<p>flag to add id column</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_date.format">date.format</code></td>
<td>
<p>date format, character string. ymd/dmy/mdy. dafault is
dmy.</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_form.name">form.name</code></td>
<td>
<p>manually specify form name(s). Vector of length 1 or
ncol(data). Default is NULL and &quot;data&quot; is used.</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_form.sep">form.sep</code></td>
<td>
<p>If supplied dataset has form names as suffix or prefix to the
column/variable names, the seperator can be specified. If supplied, the
form.name is ignored. Default is NULL.</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_form.prefix">form.prefix</code></td>
<td>
<p>Flag to set if form is prefix (TRUE) or suffix (FALSE) to
the column names. Assumes all columns have pre- or suffix if specified.</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_field.type">field.type</code></td>
<td>
<p>manually specify field type(s). Vector of length 1 or
ncol(data). Default is NULL and &quot;text&quot; is used for everything but factors,
which wil get &quot;radio&quot;.</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_field.label">field.label</code></td>
<td>
<p>manually specify field label(s). Vector of length 1 or
ncol(data). Default is NULL and colnames(data) is used or attribute
'field.label.attr' for haven_labelled data set (imported .dta file with
'haven::read_dta()').</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_field.label.attr">field.label.attr</code></td>
<td>
<p>attribute name for named labels for haven_labelled
data set (imported .dta file with 'haven::read_dta()'. Default is &quot;label&quot;</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_field.validation">field.validation</code></td>
<td>
<p>manually specify field validation(s). Vector of
length 1 or ncol(data). Default is NULL and 'levels()' are used for factors
or attribute 'factor.labels.attr' for haven_labelled data set (imported .dta
file with 'haven::read_dta()').</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_metadata">metadata</code></td>
<td>
<p>redcap metadata headings. Default is
names(REDCapCAST::redcapcast_meta).</p>
</td></tr>
<tr><td><code id="ds2dd_detailed_+3A_convert.logicals">convert.logicals</code></td>
<td>
<p>convert logicals to factor. Default is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a natural development of the ds2dd() function. It assumes
that the first column is the ID-column. No checks.
Please, do always inspect the data dictionary before upload.
</p>
<p>Ensure, that the data set is formatted with as much information as possible.
</p>
<p>'field.type' can be supplied
</p>


<h3>Value</h3>

<p>list of length 2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Basic parsing with default options
requireNamespace("REDCapCAST")
redcapcast_data |&gt;
  dplyr::select(-dplyr::starts_with("redcap_")) |&gt;
  ds2dd_detailed()

## Adding a record_id field
iris |&gt; ds2dd_detailed(add.auto.id = TRUE)

## Passing form name information to function
iris |&gt;
  ds2dd_detailed(
    add.auto.id = TRUE,
    form.name = sample(c("b", "c"), size = 6, replace = TRUE, prob = rep(.5, 2))
  ) |&gt;
  purrr::pluck("meta")
mtcars |&gt;
  dplyr::mutate(unknown = NA) |&gt;
  numchar2fct() |&gt;
  ds2dd_detailed(add.auto.id = TRUE)

## Using column name suffix to carry form name
data &lt;- iris |&gt;
  ds2dd_detailed(add.auto.id = TRUE) |&gt;
  purrr::pluck("data")
names(data) &lt;- glue::glue("{sample(x = c('a','b'),size = length(names(data)),
replace=TRUE,prob = rep(x=.5,2))}__{names(data)}")
data |&gt; ds2dd_detailed(form.sep = "__")
</code></pre>

<hr>
<h2 id='easy_redcap'>Secure API key storage and data acquisition in one</h2><span id='topic+easy_redcap'></span>

<h3>Description</h3>

<p>Secure API key storage and data acquisition in one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>easy_redcap(
  project.name,
  uri,
  raw_or_label = "both",
  data_format = c("wide", "list", "redcap", "long"),
  widen.data = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="easy_redcap_+3A_project.name">project.name</code></td>
<td>
<p>The name of the current project (for key storage with
<a href="keyring.html#topic+key_set">key_set</a>, using the default keyring)</p>
</td></tr>
<tr><td><code id="easy_redcap_+3A_uri">uri</code></td>
<td>
<p>REDCap database API uri</p>
</td></tr>
<tr><td><code id="easy_redcap_+3A_raw_or_label">raw_or_label</code></td>
<td>
<p>argument passed on to
<a href="#topic+read_redcap_tables">read_redcap_tables</a>. Default is &quot;both&quot; to get labelled
data.</p>
</td></tr>
<tr><td><code id="easy_redcap_+3A_data_format">data_format</code></td>
<td>
<p>Choose the data</p>
</td></tr>
<tr><td><code id="easy_redcap_+3A_widen.data">widen.data</code></td>
<td>
<p>argument to widen the exported data. [DEPRECATED], use
'data_format'instead</p>
</td></tr>
<tr><td><code id="easy_redcap_+3A_...">...</code></td>
<td>
<p>arguments passed on to <a href="#topic+read_redcap_tables">read_redcap_tables</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame or list depending on widen.data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
easy_redcap("My_new_project", fields = c("record_id", "age", "hypertension"))

## End(Not run)
</code></pre>

<hr>
<h2 id='export_redcap_instrument'>Creates zip-file with necessary content to manually add instrument to database</h2><span id='topic+export_redcap_instrument'></span>

<h3>Description</h3>

<p>Metadata can be added by editing the data dictionary of a project in the
initial design phase. If you want to later add new instruments, this
function can be used to create (an) instrument(s) to add to a project in
production.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_redcap_instrument(data, file, force = FALSE, record.id = "record_id")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_redcap_instrument_+3A_data">data</code></td>
<td>
<p>metadata for the relevant instrument.
Could be from 'ds2dd_detailed()'</p>
</td></tr>
<tr><td><code id="export_redcap_instrument_+3A_file">file</code></td>
<td>
<p>destination file name.</p>
</td></tr>
<tr><td><code id="export_redcap_instrument_+3A_force">force</code></td>
<td>
<p>force instrument creation and ignore different form names by
just using the first.</p>
</td></tr>
<tr><td><code id="export_redcap_instrument_+3A_record.id">record.id</code></td>
<td>
<p>record id variable name. Default is 'record_id'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>exports zip-file
</p>


<h3>Examples</h3>

<pre><code class='language-R'># iris |&gt;
#  ds2dd_detailed(
#    add.auto.id = TRUE,
#    form.name = sample(c("b", "c"), size = 6, replace = TRUE, prob = rep(.5, 2))
#  ) |&gt;
#  purrr::pluck("meta") |&gt;
#  (\(.x){
#  split(.x, .x$form_name)
#  })() |&gt;
#  purrr::imap(function(.x, .i){
#  export_redcap_instrument(.x,file=here::here(paste0(.i,Sys.Date(),".zip")))
#  })

# iris |&gt;
#  ds2dd_detailed(
#    add.auto.id = TRUE
#  ) |&gt;
#  purrr::pluck("meta") |&gt;
#  export_redcap_instrument(file=here::here(paste0("instrument",Sys.Date(),".zip")))
</code></pre>

<hr>
<h2 id='fct_drop'>Drop unused levels preserving label data</h2><span id='topic+fct_drop'></span><span id='topic+fct_drop.data.frame'></span><span id='topic+fct_drop.factor'></span>

<h3>Description</h3>

<p>This extends [forcats::fct_drop()] to natively work across a data.frame and
replaces [base::droplevels()].
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fct_drop(x, ...)

## S3 method for class 'data.frame'
fct_drop(x, ...)

## S3 method for class 'factor'
fct_drop(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fct_drop_+3A_x">x</code></td>
<td>
<p>Factor to drop unused levels</p>
</td></tr>
<tr><td><code id="fct_drop_+3A_...">...</code></td>
<td>
<p>Other arguments passed down to method.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars |&gt;
  numchar2fct() |&gt;
  fct_drop()
mtcars |&gt;
  numchar2fct() |&gt;
  dplyr::mutate(vs = fct_drop(vs))
</code></pre>

<hr>
<h2 id='fct2num'>Allows conversion of factor to numeric values preserving original levels</h2><span id='topic+fct2num'></span>

<h3>Description</h3>

<p>Allows conversion of factor to numeric values preserving original levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fct2num(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fct2num_+3A_data">data</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c(1, 4, 3, "A", 7, 8, 1) |&gt;
  as_factor() |&gt;
  fct2num()

structure(c(1, 2, 3, 2, 10, 9),
  labels = c(Unknown = 9, Refused = 10),
  class = "haven_labelled"
) |&gt;
  as_factor() |&gt;
  fct2num()

structure(c(1, 2, 3, 2, 10, 9),
  labels = c(Unknown = 9, Refused = 10),
  class = "labelled"
) |&gt;
  as_factor() |&gt;
  fct2num()

structure(c(1, 2, 3, 2, 10, 9),
  labels = c(Unknown = 9, Refused = 10)
) |&gt;
  as_factor() |&gt;
  fct2num()
</code></pre>

<hr>
<h2 id='file_extension'>DEPRECATED Helper to import files correctly</h2><span id='topic+file_extension'></span>

<h3>Description</h3>

<p>DEPRECATED Helper to import files correctly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>file_extension(filenames)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="file_extension_+3A_filenames">filenames</code></td>
<td>
<p>file names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file_extension(list.files(here::here(""))[[2]])[[1]]
file_extension(c("file.cd..ks", "file"))
</code></pre>

<hr>
<h2 id='focused_metadata'>focused_metadata</h2><span id='topic+focused_metadata'></span>

<h3>Description</h3>

<p>Extracts limited metadata for variables in a dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>focused_metadata(metadata, vars_in_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="focused_metadata_+3A_metadata">metadata</code></td>
<td>
<p>A dataframe containing metadata</p>
</td></tr>
<tr><td><code id="focused_metadata_+3A_vars_in_data">vars_in_data</code></td>
<td>
<p>Vector of variable names in the dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe containing metadata for the variables in the dataset
</p>

<hr>
<h2 id='format_redcap_factor'>Converts REDCap choices to factor levels and stores in labels attribute</h2><span id='topic+format_redcap_factor'></span>

<h3>Description</h3>

<p>Applying <a href="#topic+as_factor">as_factor</a> to the data.frame or variable, will
coerce to a factor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_redcap_factor(data, meta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_redcap_factor_+3A_data">data</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="format_redcap_factor_+3A_meta">meta</code></td>
<td>
<p>vector of REDCap choices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of class &quot;labelled&quot; with a &quot;labels&quot; attribute
</p>


<h3>Examples</h3>

<pre><code class='language-R'>format_redcap_factor(sample(1:3, 20, TRUE), "1, First. | 2, second | 3, THIRD")
</code></pre>

<hr>
<h2 id='format_subheader'>Sub-header formatting wrapper</h2><span id='topic+format_subheader'></span>

<h3>Description</h3>

<p>Sub-header formatting wrapper
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_subheader(data, tag = "h2")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format_subheader_+3A_data">data</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="format_subheader_+3A_tag">tag</code></td>
<td>
<p>character vector length 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>"Instrument header" |&gt; format_subheader()
</code></pre>

<hr>
<h2 id='get_api_key'>Retrieve project API key if stored, if not, set and retrieve</h2><span id='topic+get_api_key'></span>

<h3>Description</h3>

<p>Attempting to make secure API key storage so simple, that no other way makes
sense. Wrapping <a href="keyring.html#topic+key_get">key_get</a> and <a href="keyring.html#topic+key_set">key_set</a> using the
<a href="keyring.html#topic+key_list">key_list</a> to check if key is in storage already.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_api_key(key.name, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_api_key_+3A_key.name">key.name</code></td>
<td>
<p>character vector of key name</p>
</td></tr>
<tr><td><code id="get_api_key_+3A_...">...</code></td>
<td>
<p>passed to <a href="keyring.html#topic+key_set">key_set</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>

<hr>
<h2 id='get_attr'>Extract attribute. Returns NA if none</h2><span id='topic+get_attr'></span>

<h3>Description</h3>

<p>Extract attribute. Returns NA if none
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_attr(data, attr = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_attr_+3A_data">data</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="get_attr_+3A_attr">attr</code></td>
<td>
<p>attribute name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>attr(mtcars$mpg, "label") &lt;- "testing"
do.call(c, sapply(mtcars, get_attr))
## Not run: 
mtcars |&gt;
  numchar2fct(numeric.threshold = 6) |&gt;
  ds2dd_detailed()

## End(Not run)
</code></pre>

<hr>
<h2 id='get_id_name'>Get the id name</h2><span id='topic+get_id_name'></span>

<h3>Description</h3>

<p>Get the id name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_id_name(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_id_name_+3A_data">data</code></td>
<td>
<p>data frame or list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>

<hr>
<h2 id='guess_time_only'>Guess time variables based on naming pattern</h2><span id='topic+guess_time_only'></span>

<h3>Description</h3>

<p>This is for repairing data with time variables with appended &quot;1970-01-01&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_time_only(
  data,
  validate.time = FALSE,
  time.var.sel.pos = "[Tt]i[d(me)]",
  time.var.sel.neg = "[Dd]at[eo]"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="guess_time_only_+3A_data">data</code></td>
<td>
<p>data.frame or tibble</p>
</td></tr>
<tr><td><code id="guess_time_only_+3A_validate.time">validate.time</code></td>
<td>
<p>Flag to validate guessed time columns</p>
</td></tr>
<tr><td><code id="guess_time_only_+3A_time.var.sel.pos">time.var.sel.pos</code></td>
<td>
<p>Positive selection regex string passed to
'gues_time_only_filter()' as sel.pos.</p>
</td></tr>
<tr><td><code id="guess_time_only_+3A_time.var.sel.neg">time.var.sel.neg</code></td>
<td>
<p>Negative selection regex string passed to
'gues_time_only_filter()' as sel.neg.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame or tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>redcapcast_data |&gt; guess_time_only(validate.time = TRUE)
</code></pre>

<hr>
<h2 id='guess_time_only_filter'>Try at determining which are true time only variables</h2><span id='topic+guess_time_only_filter'></span>

<h3>Description</h3>

<p>This is just a try at guessing data type based on data class and column names
hoping for a tiny bit of naming consistency. R does not include a time-only
data format natively, so the &quot;hms&quot; class from 'readr' is used. This
has to be converted to character class before REDCap upload.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_time_only_filter(
  data,
  validate = FALSE,
  sel.pos = "[Tt]i[d(me)]",
  sel.neg = "[Dd]at[eo]"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="guess_time_only_filter_+3A_data">data</code></td>
<td>
<p>data set</p>
</td></tr>
<tr><td><code id="guess_time_only_filter_+3A_validate">validate</code></td>
<td>
<p>flag to output validation data. Will output list.</p>
</td></tr>
<tr><td><code id="guess_time_only_filter_+3A_sel.pos">sel.pos</code></td>
<td>
<p>Positive selection regex string</p>
</td></tr>
<tr><td><code id="guess_time_only_filter_+3A_sel.neg">sel.neg</code></td>
<td>
<p>Negative selection regex string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector or list depending on 'validate' flag.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- redcapcast_data
data |&gt; guess_time_only_filter()
data |&gt;
  guess_time_only_filter(validate = TRUE) |&gt;
  lapply(head)
</code></pre>

<hr>
<h2 id='haven_all_levels'>Finish incomplete haven attributes substituting missings with values</h2><span id='topic+haven_all_levels'></span>

<h3>Description</h3>

<p>Finish incomplete haven attributes substituting missings with values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haven_all_levels(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="haven_all_levels_+3A_data">data</code></td>
<td>
<p>haven labelled variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ds &lt;- structure(c(1, 2, 3, 2, 10, 9),
  labels = c(Unknown = 9, Refused = 10),
  class = "haven_labelled"
)
haven::is.labelled(ds)
attributes(ds)
ds |&gt; haven_all_levels()
</code></pre>

<hr>
<h2 id='hms2character'>Change &quot;hms&quot; to &quot;character&quot; for REDCap upload.</h2><span id='topic+hms2character'></span>

<h3>Description</h3>

<p>Change &quot;hms&quot; to &quot;character&quot; for REDCap upload.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hms2character(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hms2character_+3A_data">data</code></td>
<td>
<p>data set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame or tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- redcapcast_data
## data |&gt; time_only_correction() |&gt; hms2character()
</code></pre>

<hr>
<h2 id='html_tag_wrap'>Simple html tag wrapping for REDCap text formatting</h2><span id='topic+html_tag_wrap'></span>

<h3>Description</h3>

<p>Simple html tag wrapping for REDCap text formatting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_tag_wrap(data, tag = "h2", extra = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="html_tag_wrap_+3A_data">data</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="html_tag_wrap_+3A_tag">tag</code></td>
<td>
<p>character vector length 1</p>
</td></tr>
<tr><td><code id="html_tag_wrap_+3A_extra">extra</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>html_tag_wrap("Titel", tag = "div", extra = 'class="rich-text-field-label"')
html_tag_wrap("Titel", tag = "h2")
</code></pre>

<hr>
<h2 id='is_missing'>Multi missing check</h2><span id='topic+is_missing'></span>

<h3>Description</h3>

<p>Multi missing check
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_missing(data, nas = c("", "NA"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_missing_+3A_data">data</code></td>
<td>
<p>character vector</p>
</td></tr>
<tr><td><code id="is_missing_+3A_nas">nas</code></td>
<td>
<p>character vector of strings considered as NA</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector
</p>

<hr>
<h2 id='is_repeated_longitudinal'>Test if repeatable or longitudinal</h2><span id='topic+is_repeated_longitudinal'></span>

<h3>Description</h3>

<p>Test if repeatable or longitudinal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_repeated_longitudinal(
  data,
  generics = c("redcap_event_name", "redcap_repeat_instrument", "redcap_repeat_instance")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is_repeated_longitudinal_+3A_data">data</code></td>
<td>
<p>data set</p>
</td></tr>
<tr><td><code id="is_repeated_longitudinal_+3A_generics">generics</code></td>
<td>
<p>default is &quot;redcap_event_name&quot;, &quot;redcap_repeat_instrument&quot;
and &quot;redcap_repeat_instance&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is_repeated_longitudinal(c("record_id", "age", "record_id", "gender"))
is_repeated_longitudinal(redcapcast_data)
is_repeated_longitudinal(list(redcapcast_data))
</code></pre>

<hr>
<h2 id='is.labelled'>Tests for multiple label classes</h2><span id='topic+is.labelled'></span>

<h3>Description</h3>

<p>Tests for multiple label classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.labelled(x, classes = c("haven_labelled", "labelled"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.labelled_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="is.labelled_+3A_classes">classes</code></td>
<td>
<p>classes to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>structure(c(1, 2, 3, 2, 10, 9),
  labels = c(Unknown = 9, Refused = 10),
  class = "haven_labelled"
) |&gt; is.labelled()
</code></pre>

<hr>
<h2 id='mark_complete'>Completion marking based on completed upload</h2><span id='topic+mark_complete'></span>

<h3>Description</h3>

<p>Completion marking based on completed upload
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mark_complete(upload, ls)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mark_complete_+3A_upload">upload</code></td>
<td>
<p>output list from 'REDCapR::redcap_write()'</p>
</td></tr>
<tr><td><code id="mark_complete_+3A_ls">ls</code></td>
<td>
<p>output list from 'ds2dd_detailed()'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with 'REDCapR::redcap_write()' results
</p>

<hr>
<h2 id='match_fields_to_form'>Match fields to forms</h2><span id='topic+match_fields_to_form'></span>

<h3>Description</h3>

<p>Match fields to forms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_fields_to_form(metadata, vars_in_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="match_fields_to_form_+3A_metadata">metadata</code></td>
<td>
<p>A data frame containing field names and form names</p>
</td></tr>
<tr><td><code id="match_fields_to_form_+3A_vars_in_data">vars_in_data</code></td>
<td>
<p>A character vector of variable names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing field names and form names
</p>

<hr>
<h2 id='mtcars_redcap'>mtcars dataset slightly modified to use for Shiny app upload demonstration</h2><span id='topic+mtcars_redcap'></span>

<h3>Description</h3>

<p>mtcars dataset slightly modified to use for Shiny app upload demonstration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(mtcars_redcap)
</code></pre>


<h3>Format</h3>

<p>A data frame with 13 variables:
</p>

<dl>
<dt>record_id</dt><dd><p>ID, numeric</p>
</dd>
<dt>mpg</dt><dd><p>ID, numeric</p>
</dd>
<dt>cyl</dt><dd><p>ID, numeric</p>
</dd>
<dt>disp</dt><dd><p>ID, numeric</p>
</dd>
<dt>hp</dt><dd><p>ID, numeric</p>
</dd>
<dt>drat</dt><dd><p>ID, numeric</p>
</dd>
<dt>wt</dt><dd><p>ID, numeric</p>
</dd>
<dt>qsec</dt><dd><p>ID, numeric</p>
</dd>
<dt>vs</dt><dd><p>ID, numeric</p>
</dd>
<dt>am</dt><dd><p>ID, numeric</p>
</dd>
<dt>gear</dt><dd><p>ID, numeric</p>
</dd>
<dt>carb</dt><dd><p>ID, numeric</p>
</dd>
<dt>name</dt><dd><p>original rownames, charater</p>
</dd>
</dl>


<hr>
<h2 id='named_levels'>Get named vector of factor levels and values</h2><span id='topic+named_levels'></span>

<h3>Description</h3>

<p>Get named vector of factor levels and values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>named_levels(
  data,
  label = "labels",
  na.label = NULL,
  na.value = 99,
  sort.numeric = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="named_levels_+3A_data">data</code></td>
<td>
<p>factor</p>
</td></tr>
<tr><td><code id="named_levels_+3A_label">label</code></td>
<td>
<p>character string of attribute with named vector of factor labels</p>
</td></tr>
<tr><td><code id="named_levels_+3A_na.label">na.label</code></td>
<td>
<p>character string to refactor NA values. Default is NULL.</p>
</td></tr>
<tr><td><code id="named_levels_+3A_na.value">na.value</code></td>
<td>
<p>new value for NA strings. Ignored if na.label is NULL.
Default is 99.</p>
</td></tr>
<tr><td><code id="named_levels_+3A_sort.numeric">sort.numeric</code></td>
<td>
<p>sort factor levels if levels are numeric. Default is TRUE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>structure(c(1, 2, 3, 2, 10, 9),
  labels = c(Unknown = 9, Refused = 10),
  class = "haven_labelled"
) |&gt;
  as_factor() |&gt;
  named_levels()
structure(c(1, 2, 3, 2, 10, 9),
  labels = c(Unknown = 9, Refused = 10),
  class = "labelled"
) |&gt;
  as_factor() |&gt;
  named_levels()
</code></pre>

<hr>
<h2 id='nav_bar_page'>Nav_bar defining function for shiny ui</h2><span id='topic+nav_bar_page'></span>

<h3>Description</h3>

<p>Nav_bar defining function for shiny ui
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nav_bar_page()
</code></pre>


<h3>Value</h3>

<p>shiny object
</p>

<hr>
<h2 id='numchar2fct'>Applying var2fct across data set</h2><span id='topic+numchar2fct'></span>

<h3>Description</h3>

<p>Individual thresholds for character and numeric columns
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numchar2fct(data, numeric.threshold = 6, character.throshold = 6)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numchar2fct_+3A_data">data</code></td>
<td>
<p>dataset. data.frame or tibble</p>
</td></tr>
<tr><td><code id="numchar2fct_+3A_numeric.threshold">numeric.threshold</code></td>
<td>
<p>threshold for var2fct for numeric columns. Default
is 6.</p>
</td></tr>
<tr><td><code id="numchar2fct_+3A_character.throshold">character.throshold</code></td>
<td>
<p>threshold for var2fct for character columns.
Default is 6.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame or tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars |&gt; str()
## Not run: 
mtcars |&gt;
  numchar2fct(numeric.threshold = 6) |&gt;
  str()

## End(Not run)
</code></pre>

<hr>
<h2 id='parse_data'>Helper to auto-parse un-formatted data with haven and readr</h2><span id='topic+parse_data'></span>

<h3>Description</h3>

<p>Helper to auto-parse un-formatted data with haven and readr
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_data(
  data,
  guess_type = TRUE,
  col_types = NULL,
  locale = readr::default_locale(),
  ignore.vars = "cpr",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parse_data_+3A_data">data</code></td>
<td>
<p>data.frame or tibble</p>
</td></tr>
<tr><td><code id="parse_data_+3A_guess_type">guess_type</code></td>
<td>
<p>logical to guess type with readr</p>
</td></tr>
<tr><td><code id="parse_data_+3A_col_types">col_types</code></td>
<td>
<p>specify col_types using readr semantics. Ignored if guess_type is TRUE</p>
</td></tr>
<tr><td><code id="parse_data_+3A_locale">locale</code></td>
<td>
<p>option to specify locale. Defaults to readr::default_locale().</p>
</td></tr>
<tr><td><code id="parse_data_+3A_ignore.vars">ignore.vars</code></td>
<td>
<p>specify column names of columns to ignore when parsing</p>
</td></tr>
<tr><td><code id="parse_data_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame or tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars |&gt;
  parse_data() |&gt;
  str()
</code></pre>

<hr>
<h2 id='possibly_numeric'>Tests if vector can be interpreted as numeric without introducing NAs by
coercion</h2><span id='topic+possibly_numeric'></span>

<h3>Description</h3>

<p>Tests if vector can be interpreted as numeric without introducing NAs by
coercion
</p>


<h3>Usage</h3>

<pre><code class='language-R'>possibly_numeric(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="possibly_numeric_+3A_data">data</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c("1","5") |&gt; possibly_numeric()
c("1","5","e") |&gt; possibly_numeric()
</code></pre>

<hr>
<h2 id='possibly_roman'>Test if vector can be interpreted as roman numerals</h2><span id='topic+possibly_roman'></span>

<h3>Description</h3>

<p>Test if vector can be interpreted as roman numerals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>possibly_roman(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="possibly_roman_+3A_data">data</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample(1:100, 10) |&gt;
  as.roman() |&gt;
  possibly_roman()
sample(c(TRUE, FALSE), 10, TRUE) |&gt; possibly_roman()
rep(NA, 10) |&gt; possibly_roman()
</code></pre>

<hr>
<h2 id='process_user_input'>User input processing</h2><span id='topic+process_user_input'></span>

<h3>Description</h3>

<p>User input processing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_user_input(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_user_input_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
</table>


<h3>Value</h3>

<p>processed input
</p>

<hr>
<h2 id='process_user_input.character'>User input processing character</h2><span id='topic+process_user_input.character'></span>

<h3>Description</h3>

<p>User input processing character
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'character'
process_user_input(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_user_input.character_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="process_user_input.character_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>processed input
</p>

<hr>
<h2 id='process_user_input.data.frame'>User input processing data.frame</h2><span id='topic+process_user_input.data.frame'></span>

<h3>Description</h3>

<p>User input processing data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame'
process_user_input(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_user_input.data.frame_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="process_user_input.data.frame_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>processed input
</p>

<hr>
<h2 id='process_user_input.default'>User input processing default</h2><span id='topic+process_user_input.default'></span>

<h3>Description</h3>

<p>User input processing default
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
process_user_input(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_user_input.default_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="process_user_input.default_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>processed input
</p>

<hr>
<h2 id='process_user_input.response'>User input processing response</h2><span id='topic+process_user_input.response'></span>

<h3>Description</h3>

<p>User input processing response
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'response'
process_user_input(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_user_input.response_+3A_x">x</code></td>
<td>
<p>input</p>
</td></tr>
<tr><td><code id="process_user_input.response_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>processed input
</p>

<hr>
<h2 id='read_input'>Flexible file import based on extension</h2><span id='topic+read_input'></span>

<h3>Description</h3>

<p>Flexible file import based on extension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_input(file, consider.na = c("NA", "\"\"", ""))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_input_+3A_file">file</code></td>
<td>
<p>file name</p>
</td></tr>
<tr><td><code id="read_input_+3A_consider.na">consider.na</code></td>
<td>
<p>character vector of strings to consider as NAs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>read_input("https://raw.githubusercontent.com/agdamsbo/cognitive.index.lookup/main/data/sample.csv")
</code></pre>

<hr>
<h2 id='read_redcap_instrument'>Convenience function to download complete instrument, using token storage
in keyring.</h2><span id='topic+read_redcap_instrument'></span>

<h3>Description</h3>

<p>Convenience function to download complete instrument, using token storage
in keyring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_redcap_instrument(
  key,
  uri,
  instrument,
  raw_or_label = "raw",
  id_name = "record_id",
  records = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_redcap_instrument_+3A_key">key</code></td>
<td>
<p>key name in standard keyring for token retrieval.</p>
</td></tr>
<tr><td><code id="read_redcap_instrument_+3A_uri">uri</code></td>
<td>
<p>REDCap database API uri</p>
</td></tr>
<tr><td><code id="read_redcap_instrument_+3A_instrument">instrument</code></td>
<td>
<p>instrument name</p>
</td></tr>
<tr><td><code id="read_redcap_instrument_+3A_raw_or_label">raw_or_label</code></td>
<td>
<p>raw or label passed to 'REDCapR::redcap_read()'</p>
</td></tr>
<tr><td><code id="read_redcap_instrument_+3A_id_name">id_name</code></td>
<td>
<p>id variable name. Default is &quot;record_id&quot;.</p>
</td></tr>
<tr><td><code id="read_redcap_instrument_+3A_records">records</code></td>
<td>
<p>specify the records to download. Index numbers.
Numeric vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='read_redcap_tables'>Download REDCap data</h2><span id='topic+read_redcap_tables'></span>

<h3>Description</h3>

<p>Implementation of passed on to <a href="#topic+REDCap_split">REDCap_split</a> with a focused
data acquisition approach using passed on to <a href="REDCapR.html#topic+redcap_read">redcap_read</a> and
only downloading specified fields, forms and/or events using the built-in
focused_metadata including some clean-up.
Works with classical and longitudinal projects with or without repeating
instruments.
Will preserve metadata in the data.frames as labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_redcap_tables(
  uri,
  token,
  records = NULL,
  fields = NULL,
  events = NULL,
  forms = NULL,
  raw_or_label = c("raw", "label", "both"),
  split_forms = c("all", "repeating", "none"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_redcap_tables_+3A_uri">uri</code></td>
<td>
<p>REDCap database API uri</p>
</td></tr>
<tr><td><code id="read_redcap_tables_+3A_token">token</code></td>
<td>
<p>API token</p>
</td></tr>
<tr><td><code id="read_redcap_tables_+3A_records">records</code></td>
<td>
<p>records to download</p>
</td></tr>
<tr><td><code id="read_redcap_tables_+3A_fields">fields</code></td>
<td>
<p>fields to download</p>
</td></tr>
<tr><td><code id="read_redcap_tables_+3A_events">events</code></td>
<td>
<p>events to download</p>
</td></tr>
<tr><td><code id="read_redcap_tables_+3A_forms">forms</code></td>
<td>
<p>forms to download</p>
</td></tr>
<tr><td><code id="read_redcap_tables_+3A_raw_or_label">raw_or_label</code></td>
<td>
<p>raw or label tags. Can be &quot;raw&quot;, &quot;label&quot; or &quot;both&quot;.
</p>
<p>* &quot;raw&quot;: Standard <a href="REDCapR.html#topic+redcap_read">redcap_read</a> method to get raw values.
* &quot;label&quot;: Standard <a href="REDCapR.html#topic+redcap_read">redcap_read</a> method to get label values.
* &quot;both&quot;: Get raw values with REDCap labels applied as labels. Use
<a href="#topic+as_factor">as_factor</a> to format factors with original labels and use
the  'gtsummary' package functions like <a href="gtsummary.html#topic+tbl_summary">tbl_summary</a> to
easily get beautiful tables with original labels from REDCap. Use
<a href="#topic+fct_drop">fct_drop</a> to drop empty levels.</p>
</td></tr>
<tr><td><code id="read_redcap_tables_+3A_split_forms">split_forms</code></td>
<td>
<p>Whether to split &quot;repeating&quot; or &quot;all&quot; forms, default is
all. Give &quot;none&quot; to export native semi-long REDCap format</p>
</td></tr>
<tr><td><code id="read_redcap_tables_+3A_...">...</code></td>
<td>
<p>passed on to <a href="REDCapR.html#topic+redcap_read">redcap_read</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of instruments
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples will be provided later
</code></pre>

<hr>
<h2 id='REDCap_split'>Split REDCap repeating instruments table into multiple tables</h2><span id='topic+REDCap_split'></span>

<h3>Description</h3>

<p>This will take output from a REDCap export and split it into a base table
and child tables for each repeating instrument. Metadata
is used to determine which fields should be included in each resultant table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>REDCap_split(
  records,
  metadata,
  primary_table_name = "",
  forms = c("repeating", "all")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="REDCap_split_+3A_records">records</code></td>
<td>
<p>Exported project records. May be a <code>data.frame</code>,
<code>response</code>, or <code>character</code> vector containing JSON from an API
call.</p>
</td></tr>
<tr><td><code id="REDCap_split_+3A_metadata">metadata</code></td>
<td>
<p>Project metadata (the data dictionary). May be a
<code>data.frame</code>, <code>response</code>, or <code>character</code> vector containing
JSON from an API call.</p>
</td></tr>
<tr><td><code id="REDCap_split_+3A_primary_table_name">primary_table_name</code></td>
<td>
<p>Name given to the list element for the primary
output table. Ignored if <code>forms = 'all'</code>.</p>
</td></tr>
<tr><td><code id="REDCap_split_+3A_forms">forms</code></td>
<td>
<p>Indicate whether to create separate tables for repeating
instruments only or for all forms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>"data.frame"</code>s. The number of tables will differ
depending on the <code>forms</code> option selected.
</p>

<ul>
<li> <p><code>'repeating'</code>: one base table and one or more
tables for each repeating instrument.
</p>
</li>
<li> <p><code>'all'</code>: a data.frame for each instrument, regardless of
whether it is a repeating instrument or not.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Paul W. Egeler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Using an API call -------------------------------------------------------

library(RCurl)

# Get the records
records &lt;- postForm(
  uri = api_url, # Supply your site-specific URI
  token = api_token, # Supply your own API token
  content = "record",
  format = "json",
  returnFormat = "json"
)

# Get the metadata
metadata &lt;- postForm(
  uri = api_url, # Supply your site-specific URI
  token = api_token, # Supply your own API token
  content = "metadata",
  format = "json"
)

# Convert exported JSON strings into a list of data.frames
REDCapCAST::REDCap_split(records, metadata)

# Using a raw data export -------------------------------------------------

# Get the records
records &lt;- read.csv("/path/to/data/ExampleProject_DATA_2018-06-03_1700.csv")

# Get the metadata
metadata &lt;- read.csv(
  "/path/to/data/ExampleProject_DataDictionary_2018-06-03.csv"
)

# Split the tables
REDCapCAST::REDCap_split(records, metadata)

# In conjunction with the R export script ---------------------------------

# You must set the working directory first since the REDCap data export
# script contains relative file references.
old &lt;- getwd()
setwd("/path/to/data/")

# Run the data export script supplied by REDCap.
# This will create a data.frame of your records called 'data'
source("ExampleProject_R_2018-06-03_1700.r")

# Get the metadatan
metadata &lt;- read.csv("ExampleProject_DataDictionary_2018-06-03.csv")

# Split the tables
REDCapCAST::REDCap_split(data, metadata)
setwd(old)

## End(Not run)
</code></pre>

<hr>
<h2 id='redcap_wider'>Transforms list of REDCap data.frames to a single wide data.frame</h2><span id='topic+redcap_wider'></span>

<h3>Description</h3>

<p>Converts a list of REDCap data.frames from long to wide format.
In essence it is a wrapper for the <a href="tidyr.html#topic+pivot_wider">pivot_wider</a> function applied
on a REDCap output (from <a href="#topic+read_redcap_tables">read_redcap_tables</a>) or manually
split by <a href="#topic+REDCap_split">REDCap_split</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>redcap_wider(
  data,
  event.glue = "{.value}____{redcap_event_name}",
  inst.glue = "{.value}____{redcap_repeat_instance}"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="redcap_wider_+3A_data">data</code></td>
<td>
<p>A list of data frames</p>
</td></tr>
<tr><td><code id="redcap_wider_+3A_event.glue">event.glue</code></td>
<td>
<p>A <a href="glue.html#topic+glue">glue</a> string for repeated events naming</p>
</td></tr>
<tr><td><code id="redcap_wider_+3A_inst.glue">inst.glue</code></td>
<td>
<p>A <a href="glue.html#topic+glue">glue</a> string for repeated instruments naming</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame in wide format
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Longitudinal
list1 &lt;- list(
  data.frame(
    record_id = c(1, 2, 1, 2),
    redcap_event_name = c("baseline", "baseline", "followup", "followup"),
    age = c(25, 26, 27, 28)
  ),
  data.frame(
    record_id = c(1, 2),
    redcap_event_name = c("baseline", "baseline"),
    gender = c("male", "female")
  )
)
redcap_wider(list1)
# Simpel with two instruments
list2 &lt;- list(
  data.frame(
    record_id = c(1, 2),
    age = c(25, 26)
  ),
  data.frame(
    record_id = c(1, 2),
    gender = c("male", "female")
  )
)
redcap_wider(list2)
# Simple with single instrument
list3 &lt;- list(data.frame(
  record_id = c(1, 2),
  age = c(25, 26)
))
redcap_wider(list3)
# Longitudinal with repeatable instruments
list4 &lt;- list(
  data.frame(
    record_id = c(1, 2, 1, 2),
    redcap_event_name = c("baseline", "baseline", "followup", "followup"),
    age = c(25, 26, 27, 28)
  ),
  data.frame(
    record_id = c(1, 1, 1, 1, 2, 2, 2, 2),
    redcap_event_name = c(
      "baseline", "baseline", "followup", "followup",
      "baseline", "baseline", "followup", "followup"
    ),
    redcap_repeat_instrument = "walk",
    redcap_repeat_instance = c(1, 2, 1, 2, 1, 2, 1, 2),
    dist = c(40, 32, 25, 33, 28, 24, 23, 36)
  ),
  data.frame(
    record_id = c(1, 2),
    redcap_event_name = c("baseline", "baseline"),
    gender = c("male", "female")
  )
)
redcap_wider(list4)

list5 &lt;- list(
  data.frame(
    record_id = c(1, 2, 1, 2),
    redcap_event_name = c("baseline", "baseline", "followup", "followup")
  ),
  data.frame(
    record_id = c(1, 1, 1, 1, 2, 2, 2, 2),
    redcap_event_name = c(
      "baseline", "baseline", "followup", "followup",
      "baseline", "baseline", "followup", "followup"
    ),
    redcap_repeat_instrument = "walk",
    redcap_repeat_instance = c(1, 2, 1, 2, 1, 2, 1, 2),
    dist = c(40, 32, 25, 33, 28, 24, 23, 36)
  ),
  data.frame(
    record_id = c(1, 2),
    redcap_event_name = c("baseline", "baseline"),
    gender = c("male", "female")
  )
)
redcap_wider(list5)
</code></pre>

<hr>
<h2 id='redcapcast_data'>Data set for demonstration</h2><span id='topic+redcapcast_data'></span>

<h3>Description</h3>

<p>This is a small dataset from a REDCap database for demonstrational purposes.
Contains only synthetic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(redcapcast_data)
</code></pre>


<h3>Format</h3>

<p>A data frame with 22 variables:
</p>

<dl>
<dt>record_id</dt><dd><p>ID, numeric</p>
</dd>
<dt>redcap_event_name</dt><dd><p>Event name, character</p>
</dd>
<dt>redcap_repeat_instrument</dt><dd><p>Repeat instrument, character</p>
</dd>
<dt>redcap_repeat_instance</dt><dd><p>Repeat instance, numeric</p>
</dd>
<dt>cpr</dt><dd><p>CPR number, character</p>
</dd>
<dt>inclusion</dt><dd><p>Inclusion date, Date</p>
</dd>
<dt>inclusion_time</dt><dd><p>Inclusion time, hms</p>
</dd>
<dt>dob</dt><dd><p>Date of birth, Date</p>
</dd>
<dt>age</dt><dd><p>Age decimal, numeric</p>
</dd>
<dt>age_integer</dt><dd><p>Age integer, numeric</p>
</dd>
<dt>sex</dt><dd><p>Legal sex, character</p>
</dd>
<dt>cohabitation</dt><dd><p>Cohabitation status, character</p>
</dd>
<dt>con_calc</dt><dd><p>con_calc</p>
</dd>
<dt>con_mrs</dt><dd><p>con_mrs</p>
</dd>
<dt>consensus_complete</dt><dd><p>consensus_complete</p>
</dd>
<dt>hypertension</dt><dd><p>Hypertension, character</p>
</dd>
<dt>diabetes</dt><dd><p>diabetes, character</p>
</dd>
<dt>region</dt><dd><p>region, character</p>
</dd>
<dt>baseline_data_start_complete</dt><dd><p>Completed, character</p>
</dd>
<dt>mrs_assessed</dt><dd><p>mRS Assessed, character</p>
</dd>
<dt>mrs_date</dt><dd><p>Assesment date, Date</p>
</dd>
<dt>mrs_score</dt><dd><p>Categorical score, numeric</p>
</dd>
<dt>mrs_complete</dt><dd><p>Complete, numeric</p>
</dd>
<dt>event_datetime</dt><dd><p>Event datetime, POSIXct</p>
</dd>
<dt>event_age</dt><dd><p>Age at time of event, numeric</p>
</dd>
<dt>event_type</dt><dd><p>Event type, character</p>
</dd>
<dt>new_event_complete</dt><dd><p>Completed, character</p>
</dd>
</dl>


<hr>
<h2 id='redcapcast_meta'>REDCap metadata from data base</h2><span id='topic+redcapcast_meta'></span>

<h3>Description</h3>

<p>This metadata dataset from a REDCap database is for demonstration purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(redcapcast_meta)
</code></pre>


<h3>Format</h3>

<p>A data frame with 22 variables:
</p>

<dl>
<dt>field_name</dt><dd><p>field_name, character</p>
</dd>
<dt>form_name</dt><dd><p>form_name, character</p>
</dd>
<dt>section_header</dt><dd><p>section_header, character</p>
</dd>
<dt>field_type</dt><dd><p>field_type, character</p>
</dd>
<dt>field_label</dt><dd><p>field_label, character</p>
</dd>
<dt>select_choices_or_calculations</dt><dd><p>select_choices_or_calculations, character</p>
</dd>
<dt>field_note</dt><dd><p>field_note, character</p>
</dd>
<dt>text_validation_type_or_show_slider_number</dt><dd><p>text_validation_type_or_show_slider_number, character</p>
</dd>
<dt>text_validation_min</dt><dd><p>text_validation_min, character</p>
</dd>
<dt>text_validation_max</dt><dd><p>text_validation_max, character</p>
</dd>
<dt>identifier</dt><dd><p>identifier, character</p>
</dd>
<dt>branching_logic</dt><dd><p>branching_logic, character</p>
</dd>
<dt>required_field</dt><dd><p>required_field, character</p>
</dd>
<dt>custom_alignment</dt><dd><p>custom_alignment, character</p>
</dd>
<dt>question_number</dt><dd><p>question_number, character</p>
</dd>
<dt>matrix_group_name</dt><dd><p>matrix_group_name, character</p>
</dd>
<dt>matrix_ranking</dt><dd><p>matrix_ranking, character</p>
</dd>
<dt>field_annotation</dt><dd><p>field_annotation, character</p>
</dd>
</dl>


<hr>
<h2 id='replace_curly_quote'>Replace curly apostrophes and quotes from word</h2><span id='topic+replace_curly_quote'></span>

<h3>Description</h3>

<p>Copied from textclean, which has not been updated since 2018 and is not
on CRAN. Github:https://github.com/trinker/textclean
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_curly_quote(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="replace_curly_quote_+3A_x">x</code></td>
<td>
<p>character vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>

<hr>
<h2 id='sanitize_split'>Sanitize list of data frames</h2><span id='topic+sanitize_split'></span>

<h3>Description</h3>

<p>Removing empty rows
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sanitize_split(
  l,
  generic.names = c("redcap_event_name", "redcap_repeat_instrument",
    "redcap_repeat_instance"),
  drop.complete = TRUE,
  drop.empty = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sanitize_split_+3A_l">l</code></td>
<td>
<p>A list of data frames.</p>
</td></tr>
<tr><td><code id="sanitize_split_+3A_generic.names">generic.names</code></td>
<td>
<p>A vector of generic names to be excluded.</p>
</td></tr>
<tr><td><code id="sanitize_split_+3A_drop.complete">drop.complete</code></td>
<td>
<p>logical to remove generic REDCap variables indicating
instrument completion. Default is TRUE.</p>
</td></tr>
<tr><td><code id="sanitize_split_+3A_drop.empty">drop.empty</code></td>
<td>
<p>logical to remove variables with only NAs Default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames with generic names excluded.
</p>

<hr>
<h2 id='set_attr'>Set attributes for named attribute. Appends if attr is NULL</h2><span id='topic+set_attr'></span>

<h3>Description</h3>

<p>Set attributes for named attribute. Appends if attr is NULL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_attr(data, label, attr = NULL, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set_attr_+3A_data">data</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="set_attr_+3A_label">label</code></td>
<td>
<p>label</p>
</td></tr>
<tr><td><code id="set_attr_+3A_attr">attr</code></td>
<td>
<p>attribute name</p>
</td></tr>
<tr><td><code id="set_attr_+3A_overwrite">overwrite</code></td>
<td>
<p>overwrite existing attributes. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with attribute
</p>

<hr>
<h2 id='shiny_cast'>Launch the included Shiny-app for database casting and upload</h2><span id='topic+shiny_cast'></span>

<h3>Description</h3>

<p>Wraps shiny::runApp()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shiny_cast(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shiny_cast_+3A_...">...</code></td>
<td>
<p>Arguments passed to shiny::runApp()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>shiny app
</p>


<h3>Examples</h3>

<pre><code class='language-R'># shiny_cast()

</code></pre>

<hr>
<h2 id='split_non_repeating_forms'>Split a data frame into separate tables for each form</h2><span id='topic+split_non_repeating_forms'></span>

<h3>Description</h3>

<p>Split a data frame into separate tables for each form
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_non_repeating_forms(table, universal_fields, fields)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_non_repeating_forms_+3A_table">table</code></td>
<td>
<p>A data frame</p>
</td></tr>
<tr><td><code id="split_non_repeating_forms_+3A_universal_fields">universal_fields</code></td>
<td>
<p>A character vector of fields that should be included
in every table</p>
</td></tr>
<tr><td><code id="split_non_repeating_forms_+3A_fields">fields</code></td>
<td>
<p>A two-column matrix containing the names of fields that should
be included in each form</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data frames, one for each non-repeating form
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a table
table &lt;- data.frame(
  id = c(1, 2, 3, 4, 5),
  form_a_name = c("John", "Alice", "Bob", "Eve", "Mallory"),
  form_a_age = c(25, 30, 25, 15, 20),
  form_b_name = c("John", "Alice", "Bob", "Eve", "Mallory"),
  form_b_gender = c("M", "F", "M", "F", "F")
)

# Create the universal fields
universal_fields &lt;- c("id")

# Create the fields
fields &lt;- matrix(
  c(
    "form_a_name", "form_a",
    "form_a_age", "form_a",
    "form_b_name", "form_b",
    "form_b_gender", "form_b"
  ),
  ncol = 2, byrow = TRUE
)

# Split the table
split_non_repeating_forms(table, universal_fields, fields)
</code></pre>

<hr>
<h2 id='strsplitx'>Extended string splitting</h2><span id='topic+strsplitx'></span>

<h3>Description</h3>

<p>Can be used as a substitute of the base function. Main claim to fame is
easing the split around the defined delimiter, see example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>strsplitx(x, split, type = "classic", perl = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="strsplitx_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="strsplitx_+3A_split">split</code></td>
<td>
<p>delimiter</p>
</td></tr>
<tr><td><code id="strsplitx_+3A_type">type</code></td>
<td>
<p>Split type. Can be c(&quot;classic&quot;, &quot;before&quot;, &quot;after&quot;, &quot;around&quot;)</p>
</td></tr>
<tr><td><code id="strsplitx_+3A_perl">perl</code></td>
<td>
<p>perl param from strsplit()</p>
</td></tr>
<tr><td><code id="strsplitx_+3A_...">...</code></td>
<td>
<p>additional parameters are passed to base strsplit handling splits</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test &lt;- c("12 months follow-up", "3 steps", "mRS 6 weeks",
"Counting to 231 now")
strsplitx(test, "[0-9]", type = "around")
</code></pre>

<hr>
<h2 id='suffix2label'>Transfer variable name suffix to label in widened data</h2><span id='topic+suffix2label'></span>

<h3>Description</h3>

<p>Transfer variable name suffix to label in widened data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>suffix2label(
  data,
  suffix.sep = "____",
  attr = "label",
  glue.str = "{label} ({paste(suffixes,collapse=', ')})"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="suffix2label_+3A_data">data</code></td>
<td>
<p>data.frame</p>
</td></tr>
<tr><td><code id="suffix2label_+3A_suffix.sep">suffix.sep</code></td>
<td>
<p>string to split suffix(es). Passed to <a href="base.html#topic+strsplit">strsplit</a></p>
</td></tr>
<tr><td><code id="suffix2label_+3A_attr">attr</code></td>
<td>
<p>label attribute. Default is &quot;label&quot;</p>
</td></tr>
<tr><td><code id="suffix2label_+3A_glue.str">glue.str</code></td>
<td>
<p>glue string for new label. Available variables are &quot;label&quot;
and &quot;suffixes&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='time_only_correction'>Correction based on time_only_filter function</h2><span id='topic+time_only_correction'></span>

<h3>Description</h3>

<p>Correction based on time_only_filter function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_only_correction(data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="time_only_correction_+3A_data">data</code></td>
<td>
<p>data set</p>
</td></tr>
<tr><td><code id="time_only_correction_+3A_...">...</code></td>
<td>
<p>arguments passed on to 'guess_time_only_filter()'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- redcapcast_data
## data |&gt; time_only_correction()
</code></pre>

<hr>
<h2 id='var2fct'>Convert vector to factor based on threshold of number of unique levels</h2><span id='topic+var2fct'></span>

<h3>Description</h3>

<p>This is a wrapper of forcats::as_factor, which sorts numeric vectors before
factoring, but levels character vectors in order of appearance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var2fct(data, unique.n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var2fct_+3A_data">data</code></td>
<td>
<p>vector or data.frame column</p>
</td></tr>
<tr><td><code id="var2fct_+3A_unique.n">unique.n</code></td>
<td>
<p>threshold to convert class to factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample(seq_len(4), 20, TRUE) |&gt;
  var2fct(6) |&gt;
  summary()
sample(letters, 20) |&gt;
  var2fct(6) |&gt;
  summary()
sample(letters[1:4], 20, TRUE) |&gt; var2fct(6)
</code></pre>

<hr>
<h2 id='vec2choice'>Named vector to REDCap choices ('wrapping compact_vec()')</h2><span id='topic+vec2choice'></span>

<h3>Description</h3>

<p>Named vector to REDCap choices ('wrapping compact_vec()')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2choice(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="vec2choice_+3A_data">data</code></td>
<td>
<p>named vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample(seq_len(4), 20, TRUE) |&gt;
  as_factor() |&gt;
  named_levels() |&gt;
  sort() |&gt;
  vec2choice()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
