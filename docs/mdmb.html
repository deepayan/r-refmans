<!DOCTYPE html><html><head><title>Help for package mdmb</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mdmb}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mdmb-package'>
<p>Model Based Treatment of Missing Data</p></a></li>
<li><a href='#data.mb'>
<p>Example Datasets for <span class="pkg">mdmb</span> Package</p></a></li>
<li><a href='#eval_prior_list'>
<p>Evaluates Several Prior Distributions</p></a></li>
<li><a href='#frm'>
<p>Factored Regression Model: Generalized Linear Regression Model with Missing Covariates</p></a></li>
<li><a href='#mdmb_regression'>
<p>Several Regression Models with Prior Distributions and Sampling Weights</p></a></li>
<li><a href='#offset_values_extract'>
<p>Extracts Offset Values</p></a></li>
<li><a href='#oprobit_dist'>
<p>Ordinal Probit Models</p></a></li>
<li><a href='#remove_NA_data_frame'>
<p>Removes Rows with Some Missing Entries in a Data Frame</p></a></li>
<li><a href='#yjt_dist'>
<p>Scaled <code class="reqn">t</code> Distribution with Yeo-Johnson and Box-Cox Transformations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Model Based Treatment of Missing Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.8-7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-02-28 22:35:18</td>
</tr>
<tr>
<td>Author:</td>
<td>
    Alexander Robitzsch [aut, cre], Oliver Luedtke [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Robitzsch &lt;robitzsch@ipn.uni-kiel.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Contains model-based treatment of missing data for regression 
    models with missing values in covariates or the dependent 
    variable using maximum likelihood or Bayesian estimation 
    (Ibrahim et al., 2005; &lt;<a href="https://doi.org/10.1198%2F016214504000001844">doi:10.1198/016214504000001844</a>&gt;;
    Luedtke, Robitzsch, &amp; West, 2020a, 2020b;
    &lt;<a href="https://doi.org/10.1080%2F00273171.2019.1640104%26gt%3B%26lt%3Bdoi%3A10.1037%2Fmet0000233">doi:10.1080/00273171.2019.1640104&gt;&lt;doi:10.1037/met0000233</a>&gt;).
    The regression model can be nonlinear (e.g., interaction 
    effects, quadratic effects or B-spline functions). 
    Multilevel models with missing data in predictors are
    available for Bayesian estimation. Substantive-model compatible 
    multiple imputation can be also conducted.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>CDM, coda, graphics, miceadds (&ge; 3.2-23), Rcpp, sirt, stats,
utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>miceadds, Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Enhances:</td>
<td>JointAI, jomo, mice, smcfcs</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alexanderrobitzsch/mdmb">https://github.com/alexanderrobitzsch/mdmb</a>,
<a href="https://sites.google.com/site/alexanderrobitzsch2/software">https://sites.google.com/site/alexanderrobitzsch2/software</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-28 21:36:48 UTC; sunpn563</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-28 22:02:29 UTC</td>
</tr>
</table>
<hr>
<h2 id='mdmb-package'>
Model Based Treatment of Missing Data 
</h2><span id='topic+mdmb-package'></span><span id='topic+mdmb'></span>

<h3>Description</h3>


<p>    Contains model-based treatment of missing data for regression 
    models with missing values in covariates or the dependent 
    variable using maximum likelihood or Bayesian estimation 
    (Ibrahim et al., 2005; &lt;doi:10.1198/016214504000001844&gt;;
    Luedtke, Robitzsch, &amp; West, 2020a, 2020b;
    &lt;doi:10.1080/00273171.2019.1640104&gt;&lt;doi:10.1037/met0000233&gt;).
    The regression model can be nonlinear (e.g., interaction 
    effects, quadratic effects or B-spline functions). 
    Multilevel models with missing data in predictors are
    available for Bayesian estimation. Substantive-model compatible 
    multiple imputation can be also conducted.
</p>


<h3>Details</h3>


<ul>
<li><p> The maximum likelihood estimation of regression models with
missing values in covariates is implemented in <code><a href="#topic+frm_em">frm_em</a></code>.
Available regression models are linear regression, logistic regression,
ordinal probit regression and models with Box-Cox or Yeo-Johnson transformed 
normally distributed outcomes. The factorization based regression model
also allow the inclusion of latent variables and measurement error prone
covariates.  
</p>
</li>
<li><p> Bayesian estimation and multiple imputation of regression models with
missing values in covariates is implemented in <code><a href="#topic+frm_fb">frm_fb</a></code>. The same
regression models like in <code><a href="#topic+frm_em">frm_em</a></code> can be specified. Moreover,
multilevel models can also be specified with Bayesian estimation. 
The function <code><a href="#topic+frm_fb">frm_fb</a></code> allows substantive model compatible multiple imputation.
</p>
</li></ul>



<h3>Author(s)</h3>


<p>    Alexander Robitzsch [aut, cre], Oliver Luedtke [aut]
</p>
<p>Maintainer: Alexander Robitzsch &lt;robitzsch@ipn.uni-kiel.de&gt;
</p>


<h3>References</h3>

<p>Ibrahim, J. G., Chen, M. H., Lipsitz, S. R., &amp; Herring, A. H. (2005). 
Missing-data methods for generalized linear models: A comparative review. 
<em>Journal of the American Statistical Association, 100</em>, 332-346.
</p>
<p>Luedtke, O., Robitzsch, A., &amp; West, S. (2020a). Analysis of interactions and nonlinear 
effects with missing data: A factored regression modeling approach using maximum 
likelihood estimation. <em>Multivariate Behavioral Research, 55</em>(3), 361-381. 
doi: <a href="https://doi.org/10.1080/00273171.2019.1640104">10.1080/00273171.2019.1640104</a>
</p>
<p>Luedtke, O., Robitzsch, A., &amp; West, S. (2020b). Regression models involving nonlinear 
effects with missing data: A sequential modeling approach using Bayesian estimation. 
<em>Psychological Methods, 25</em>(2), 157-181. 
doi: <a href="https://doi.org/10.1037/met0000233">10.1037/met0000233</a>
</p>


<h3>See Also</h3>

<p>The EM algorithm for the multivariate normal model is implemented in 
<code>norm2::emNorm</code> in the <span class="pkg">norm2</span> package. 
A corresponding MCMC algorithm can be
found in the <code>norm2::mcmcNorm</code> function.
</p>
<p>See the <span class="pkg">lavaan</span>, <span class="pkg">OpenMx</span> or <span class="pkg">sem</span> packages for full information 
maximum likelihood approaches for handling missing data for multivariate
normal distributions, linear regression models, and, more generally, 
structural equation modeling with missing data.
</p>
<p>Structural equation models with missing data can be also estimated with a
two-stage procedure. In a first stage, a mean vector and a covariance matrix
is estimated (possibly with auxiliary variables) and in the second stage,
the structural equation model is estimated on the previously obtained
mean vector and covariance matrix. The procedure is implemented in the  
<code>semTools::twostage</code> function in the <span class="pkg">semTools</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  ##  
  ##  |\  /||~~\ |\  /||~~\
  ##  | \/ ||   || \/ ||--&lt;
  ##  |    ||__/ |    ||__/
  ##                       

  ##  
  ##  &gt; library(mdmb)
  ##  * mdmb 0.0-13 (2017-01-15)
  ##      
</code></pre>

<hr>
<h2 id='data.mb'>
Example Datasets for <span class="pkg">mdmb</span> Package
</h2><span id='topic+data.mb'></span><span id='topic+data.mb01'></span><span id='topic+data.mb02'></span><span id='topic+data.mb03'></span><span id='topic+data.mb04'></span><span id='topic+data.mb05'></span>

<h3>Description</h3>

<p>Example datasets for <span class="pkg">mdmb</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data.mb01)
data(data.mb02)
data(data.mb03)
data(data.mb04)
data(data.mb05)
</code></pre>


<h3>Format</h3>


<ul>
<li><p> Dataset <code>data.mb01</code>. Simulated dataset with missing values.
Variables <code>Y</code>, <code>X</code> and <code>Z</code> are continuous.
</p>
<p><code>List of 2</code> <br />
<code> $ complete:'data.frame':       4000 obs. of  3 variables:</code> <br />
<code>  ..$ X: num [1:4000] -1.08 0.57 -0.32 0.34 1.21 -0.44 -1.07 -0.29 0.76 -1.75 ...</code> <br />
<code>  ..$ Z: num [1:4000] -0.02 0.26 -1.45 1.24 0.98 -2.36 0.84 -1.08 -0.15 -1.36 ...</code> <br />
<code>  ..$ Y: num [1:4000] 0.88 1.75 -0.82 -1.81 -1.58 -3.34 -3.35 -0.29 1.47 0.23 ...</code> <br />
<code> $ missing :'data.frame':       4000 obs. of  3 variables:</code> <br />
<code>  ..$ X: num [1:4000] -1.08 0.57 NA NA 1.21 NA -1.07 -0.29 0.76 NA ...</code> <br />
<code>  ..$ Z: num [1:4000] -0.02 0.26 -1.45 1.24 0.98 -2.36 0.84 -1.08 -0.15 -1.36 ...</code> <br />
<code>  ..$ Y: num [1:4000] 0.88 1.75 -0.82 -1.81 -1.58 -3.34 -3.35 -0.29 1.47 0.23 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.mb02</code>. Simulated dataset with missing values. The
variables <code>Z</code> and <code>Y</code> are dichotomous.
</p>
<p><code>List of 2</code> <br />
<code> $ complete:'data.frame':       2000 obs. of  3 variables:</code> <br />
<code>  ..$ X: num [1:2000] -0.93 0.3 -0.93 0.7 0.52 -1.38 -0.14 0.09 0.23 -1.64 ...</code> <br />
<code>  ..$ Z: num [1:2000] 1 0 1 0 0 1 1 1 1 1 ...</code> <br />
<code>  ..$ Y: num [1:2000] 1 1 0 1 1 0 1 0 0 1 ...</code> <br />
<code> $ missing :'data.frame':       2000 obs. of  3 variables:</code> <br />
<code>  ..$ X: num [1:2000] -0.93 0.3 -0.93 0.7 0.52 NA -0.14 0.09 0.23 -1.64 ...</code> <br />
<code>  ..$ Z: num [1:2000] 1 0 1 NA NA 1 NA 1 1 1 ...</code> <br />
<code>  ..$ Y: num [1:2000] 1 1 0 1 1 0 1 0 0 1 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.mb03</code>. This dataset is from Enders, Baraldi &amp; Cham (2014)
and contains three
variables primary school reading (<code>x</code>), primary school learning problems (<code>z</code>)
and middle school reading (<code>y</code>) which all have missing values.
</p>
<p><code>'data.frame':   74 obs. of  3 variables:</code> <br />
<code> $ x: num  NA NA NA NA NA 8.34 NA 8.36 6.89 8.56 ...</code> <br />
<code> $ z: num  8.81 4.5 6.31 4.7 5.1 4 6.11 3.7 6.81 6.31 ...</code> <br />
<code> $ y: num  5 5.1 6.3 9 9 9.3 NA 10.7 6.2 NA ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.mb04</code>. This multilevel dataset contains three variables:
level-1 variables codey, <code>x</code> and the level-2 variable <code>w</code>.
</p>
<p><code>'data.frame':   500 obs. of  4 variables:</code> <br />
<code> $ idcluster: int  1 1 1 1 1 2 2 2 2 2 ...</code> <br />
<code> $ x        : num  NA NA -1.15 -1.65 0.25 ...</code> <br />
<code> $ w        : num  -0.552 -0.552 -0.552 -0.552 -0.552 ...</code> <br />
<code> $ y        : num  NA NA -0.0711 0.7165 -0.1917 ...</code> <br />
</p>
</li>
<li><p> Dataset <code>data.mb05</code>. This dataset contains selected (and transformed)
variables of the German PISA 2012 data.
</p>
<p><code>'data.frame':   5001 obs. of  13 variables:</code> <br />
<code> $ idschool : num  1001 1001 1001 1001 1001 ...</code> <br />
<code> $ idstud   : num  1e+05 1e+05 1e+05 1e+05 1e+05 ...</code> <br />
<code> $ female   : num  1 1 0 0 0 1 1 1 0 0 ...</code> <br />
<code> $ books    : num  NA 3 3 1 NA 2 NA 1 NA 2 ...</code> <br />
<code> $ hisced   : num  NA 6 6 2 NA 2 NA 2 NA 2 ...</code> <br />
<code> $ hisei    : num  NA 30.6 57.7 26.9 NA ...</code> <br />
<code> $ hisei10  : num  NA 0.257 0.596 0.211 NA ...</code> <br />
<code> $ native   : num  NA NA 1 0 NA 0 NA 1 NA 1 ...</code> <br />
<code> $ ANCINTMAT: num  NA 0.644 -0.096 1.057 NA ...</code> <br />
<code> $ MATHEFF  : num  NA 0.34 0.54 -0.18 NA 0.15 NA NA NA NA ...</code> <br />
<code> $ READ     : num  -0.25 -0.503 0.421 -1.664 -0.894 ...</code> <br />
<code> $ MATH     : num  -0.565 -0.854 0.384 -0.896 -0.534 ...</code> <br />
<code> $ W_FSTUWT : num  140 140 140 140 140 ...</code> <br />
</p>
</li></ul>



<h3>References</h3>

<p>Enders, C. K., Baraldi, A. N., &amp; Cham, H. (2014). Estimating interaction effects with
incomplete predictor variables. <em>Psychological Methods, 19</em>(1), 39-55.
doi: <a href="https://doi.org/10.1037/a0035314">10.1037/a0035314</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Linear interaction example from Enders et al. (2014)
#############################################################################

# load packages
library(mdmb)
library(mice)
library(mitools)
library(sandwich)

#--- attach example dataset (Enders et al., 2014) from mdmb package
data( data.mb03, package="mdmb")
dat &lt;- data.mb03

#--- center data which speeds convergence of Bayesian estimation
#--- of the imputation model
for (vv in 1:3){
    M_vv &lt;- mean( dat[,vv], na.rm=TRUE )
    dat[,vv] &lt;- dat[,vv] - M_vv
}

#--- generate initial imputed values withj mice package
imp &lt;- mice::mice( dat, m=, maxit=20 )
data_init &lt;- mice::complete(imp, action=1)

#--- define number of iterations and number of imputed datasets
iter &lt;- 50000; burnin &lt;- 5000
Nimp &lt;- 100

#******* imputation model M3 with quadratic effects

# model for dependent variable
dep &lt;- list("model"="linreg", "formula"=y ~ x*z + I(x^2) + I(z^2) )
# covariate models
ind_x &lt;- list( "model"="linreg", "formula"=x ~ z + I(z^2) )
ind_z &lt;- list( "model"="linreg", "formula"=z ~ 1 )
ind &lt;- list( x=ind_x, z=ind_z)

#generate imputations
imp &lt;- mdmb::frm_fb(dat=dat, dep=dep, ind=ind, burnin=burnin, iter=iter,
              data_init=data_init, Nimp=Nimp)

#--- create list of multiply imputed datasets
datlist &lt;- mdmb::frm2datlist(imp)

#-------------------------------
#--- analyze imputed datasets with mice package

# convert into object of class mids
imp2 &lt;- miceadds::datlist2mids(datlist)
# estimate linear model on multiply imputed datasets
mod1 &lt;- with(imp2, stats::lm( y ~ x*z ) )
summary( mice::pool(mod1) )

#-------------------------------
#--- analyze imputed datasets using sandwich standard errors

results &lt;- list()
variances &lt;- list()
Nimp &lt;- length(datlist)
for (ii in 1:Nimp){
    mod_ii &lt;- stats::lm( y ~ x*z, data=datlist[[ii]] )
    variances[[ii]] &lt;- sandwich::vcovHC(mod_ii)
    results[[ii]] &lt;- coef(mod_ii)
}

mod2 &lt;- mitools::MIcombine(results=results,variances=variances,df.complete=69)
summary(mod2)

## End(Not run)
</code></pre>

<hr>
<h2 id='eval_prior_list'>
Evaluates Several Prior Distributions
</h2><span id='topic+eval_prior_list'></span><span id='topic+eval_prior_list_sumlog'></span>

<h3>Description</h3>

<p>The function <code>eval_prior_list</code> evaluates several prior distributions
specified in a list. The function <code>eval_prior_list_sumlog</code>
computes the sum of the logarithms of all prior values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_prior_list(par, par_prior, log=FALSE, eps=1e-50)

eval_prior_list_sumlog(par, par_prior, use_grad=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval_prior_list_+3A_par">par</code></td>
<td>

<p>Parameter vector
</p>
</td></tr>
<tr><td><code id="eval_prior_list_+3A_par_prior">par_prior</code></td>
<td>

<p>List of prior distributions specified in a list (see Examples)
</p>
</td></tr>
<tr><td><code id="eval_prior_list_+3A_log">log</code></td>
<td>
<p>Logical indicating whether the logarithm of the prior should be
computed</p>
</td></tr>
<tr><td><code id="eval_prior_list_+3A_eps">eps</code></td>
<td>
<p>Decimal to be added to the prior to avoid computation of the logarithm
for values of zero</p>
</td></tr>
<tr><td><code id="eval_prior_list_+3A_use_grad">use_grad</code></td>
<td>
<p>Integer value for computation value for gradient</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector or a numeric value
</p>


<h3>See Also</h3>

<p><code><a href="sirt.html#topic+prior_model_parse">sirt::prior_model_parse</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Evaluation of prior values
#############################################################################

# normal distribution
b0 &lt;- list( "dnorm", list(mean=0,sd=100) )
# t distribution with one degree of freedom (Cauchy distribution)
b1 &lt;- list( "dt", list(df=1) )
# define list of priors
beta_prior &lt;- list( b0, b1 )
# parameter value
beta &lt;- c( 0.3, 1 )

#-- evaluate priors
mdmb::eval_prior_list(par=beta, par_prior=beta_prior)
mdmb::eval_prior_list_sumlog(par=beta, par_prior=beta_prior)
</code></pre>

<hr>
<h2 id='frm'>
Factored Regression Model: Generalized Linear Regression Model with Missing Covariates
</h2><span id='topic+frm'></span><span id='topic+frm_em'></span><span id='topic+coef.frm_em'></span><span id='topic+vcov.frm_em'></span><span id='topic+logLik.frm_em'></span><span id='topic+summary.frm_em'></span><span id='topic+frm_fb'></span><span id='topic+coef.frm_fb'></span><span id='topic+plot.frm_fb'></span><span id='topic+vcov.frm_fb'></span><span id='topic+summary.frm_fb'></span><span id='topic+frm2datlist'></span>

<h3>Description</h3>

<p>The factored regression model (FRM) allows the estimation of the linear regression model
(with normally distributed residuals) and the generalized logistic regression model
(logistic regression for dichotomous outcomes). Missing values in covariates are
handled by posing a conditional univariate distribution for each covariate. The
approach follows Ibrahim (1990), Ibrahim, Chen, Lipsitz and Herring (2005),
Lee and Mitra (2016), and Zhang and Wang (2017) and is applied in
Luedtke, Robitzsch, and West (2020a, 2020b). Latent variables
and covariates with measurement error or multiple indicators can also be handled
within this framework (see Examples 3, 4 and 5).
</p>
<p>Missing values are handled by numerical integration in <code>frm_em</code>
(see also Allison, 2012). The user has to specify an integration grid for each
variable (defined in argument <code>nodes</code> for each model).
</p>
<p>Standard error estimates in <code>frm_em</code> are obtained by a numerical differentiation of
the Fisher score function (see Jamshidian &amp; Jennrich, 2000).
</p>
<p>The function <code>frm_fb</code> employs a fully Bayesian approach with noninformative
prior distribution. This function imputes missing values in the models from
the posterior distributions. Imputed datasets can be extracted by the
function <code>frm2datlist</code>.
</p>
<p>The current functionality only support missing values on continuous covariates
(accommodating skewness and only positive values), dichotomous covariates and
ordinal covariates.
</p>
<p>Multilevel models (using <code>model="mlreg"</code>) for normally distributed
(<code>outcome="normal"</code>) and ordinal variables (<code>outcome="probit"</code>)
as well as variables at higher levels (using argument <code>variable_level</code>)
are accommodated.
</p>
<p>The handling of nominal covariates will be included in future
<span class="pkg">mdmb</span> package versions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Factored regression model: Numerical integration with EM algorithm
frm_em(dat, dep, ind, weights=NULL, verbose=TRUE, maxiter=500, conv_dev=1e-08,
         conv_parm=1e-05, nodes_control=c(11,5), h=1e-04, use_grad=2,
        update_model=NULL)

## S3 method for class 'frm_em'
coef(object, ...)
## S3 method for class 'frm_em'
logLik(object, ...)
## S3 method for class 'frm_em'
summary(object, digits=4, file=NULL, ...)
## S3 method for class 'frm_em'
vcov(object, ...)

# Factored regression model: Fully Bayesian estimation
frm_fb(dat, dep, ind, weights=NULL, verbose=TRUE, data_init=NULL, iter=500,
        burnin=100, Nimp=10, Nsave=3000, refresh=25, acc_bounds=c(.45,.50),
        print_iter=10, use_gibbs=TRUE, aggregation=TRUE)

## S3 method for class 'frm_fb'
coef(object, ...)
## S3 method for class 'frm_fb'
plot(x, idparm=NULL, ask=TRUE, ... )
## S3 method for class 'frm_fb'
summary(object, digits=4, file=NULL, ...)
## S3 method for class 'frm_fb'
vcov(object, ...)

frm2datlist(object, as_mids=FALSE)  # create list of imputed datasets
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frm_+3A_dat">dat</code></td>
<td>

<p>Data frame
</p>
</td></tr>
<tr><td><code id="frm_+3A_dep">dep</code></td>
<td>

<p>List containing model specification for dependent variable. The list
has arguments (see Examples)
</p>
<p><code>model</code>: String indicating the model type. Options are
<code>"linreg"</code> (wrapper to <code><a href="stats.html#topic+lm">stats::lm</a></code>
or <code><a href="stats.html#topic+lm.wfit">stats::lm.wfit</a></code>),
<code>"logistic"</code> for dichotomous variables (wrapper to
<code><a href="#topic+logistic_regression">logistic_regression</a></code>), <code>"oprobit"</code> for ordinal variables
(wrapper to <code><a href="#topic+oprobit_regression">oprobit_regression</a></code>),
<code>"yjtreg"</code> for continuous variables and bounded variables on <code class="reqn">(0,1)</code>
(wrapper to <code><a href="#topic+yjt_regression">yjt_regression</a></code>),
<code>"bctreg"</code> for positive continuous variables
(wrapper to <code><a href="#topic+bct_regression">bct_regression</a></code>),
<code>"mlreg"</code> for multilevel models with normally distributed and ordinal
data (wrapper to <code><a href="miceadds.html#topic+ml_mcmc">miceadds::ml_mcmc</a></code>)
<br />
<code>formula</code>: An <span class="rlang"><b>R</b></span> formula object. <br />
<code>nodes</code> (for <code>frm_em</code>): Vector containing the integration nodes <br />
<code>nodes_weights</code> (for <code>frm_em</code>):
Optional vector containing initial probabilities for each node <br />
<code>coef_inits</code>: Optional vector containing initial coefficient for the model <br />
<code>sigma_fixed</code>: Fixed standard deviations in case of <code>model="linreg"</code>.
Heterogeneous standard deviations are allowed. <br />
<code>R_args</code>: Arguments for estimation functions. <br />
<code>sampling_level</code>: Variable name for cluster identifiers for level for sampling values
for multilevel data. Sampling at level of clusters can be beneficials
if derived variables from cluster members (e.g., group means) occur
in multilevel models. The option is only applicable for <code>frm_fb</code>. <br />
<code>variable_level</code>: Cluster identifier indicating level of variable for imputations
of higher-level variables
</p>
</td></tr>
<tr><td><code id="frm_+3A_ind">ind</code></td>
<td>

<p>List containing a list of univariate conditional models for covariates.
See <code>dep</code> for more details on specification.
</p>
</td></tr>
<tr><td><code id="frm_+3A_weights">weights</code></td>
<td>

<p>Optional vector of sampling weights
</p>
</td></tr>
<tr><td><code id="frm_+3A_verbose">verbose</code></td>
<td>

<p>Logical indicating whether convergence progress should be displayed.
</p>
</td></tr>
<tr><td><code id="frm_+3A_maxiter">maxiter</code></td>
<td>

<p>Maximum number of iterations
</p>
</td></tr>
<tr><td><code id="frm_+3A_conv_dev">conv_dev</code></td>
<td>

<p>Convergence criterion for deviance
</p>
</td></tr>
<tr><td><code id="frm_+3A_conv_parm">conv_parm</code></td>
<td>

<p>Convergence criterion for regression coefficients
</p>
</td></tr>
<tr><td><code id="frm_+3A_nodes_control">nodes_control</code></td>
<td>
<p>Control arguments if nodes are not provided
by the user. The first value denote the number of nodes, while
the second value denotes the spread of the node distribution defined
as the factor of the standard deviation of the observed data.</p>
</td></tr>
<tr><td><code id="frm_+3A_h">h</code></td>
<td>
<p>Step width for numerical differentiation for calculating the
covariance matrix</p>
</td></tr>
<tr><td><code id="frm_+3A_use_grad">use_grad</code></td>
<td>
<p>Computation method for gradient in <code><a href="#topic+yjt_regression">yjt_regression</a></code>,
<code><a href="#topic+bct_regression">bct_regression</a></code> or <code><a href="#topic+logistic_regression">logistic_regression</a></code>.
It can be <code>0</code> (compatible with <span class="pkg">mdmb</span> <code class="reqn">\le</code>0.3),
<code>1</code> or <code>2</code> (most efficient one).</p>
</td></tr>
<tr><td><code id="frm_+3A_update_model">update_model</code></td>
<td>
<p>Optional proviously fitted model can be used as an input</p>
</td></tr>
<tr><td><code id="frm_+3A_data_init">data_init</code></td>
<td>
<p>Initial values for dataset</p>
</td></tr>
<tr><td><code id="frm_+3A_iter">iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code id="frm_+3A_burnin">burnin</code></td>
<td>
<p>Number of burnin iterations</p>
</td></tr>
<tr><td><code id="frm_+3A_nimp">Nimp</code></td>
<td>
<p>Number of imputed datasets</p>
</td></tr>
<tr><td><code id="frm_+3A_nsave">Nsave</code></td>
<td>
<p>(Maximum) Number of values to be saved for MCMC chain</p>
</td></tr>
<tr><td><code id="frm_+3A_refresh">refresh</code></td>
<td>
<p>Number of imputations after which proposal distribution
should be updated in Metropolis-Hastings step</p>
</td></tr>
<tr><td><code id="frm_+3A_acc_bounds">acc_bounds</code></td>
<td>
<p>Bounds for acceptance rates for parameters</p>
</td></tr>
<tr><td><code id="frm_+3A_print_iter">print_iter</code></td>
<td>
<p>Number of imputation after which iteration progress
should be displayed</p>
</td></tr>
<tr><td><code id="frm_+3A_use_gibbs">use_gibbs</code></td>
<td>
<p>Logical indicating whether Gibbs sampling instead of
Metropolis-Hastings sampling should be used. Can be only
applied for <code>linreg</code>.</p>
</td></tr>
<tr><td><code id="frm_+3A_aggregation">aggregation</code></td>
<td>
<p>Logical indicating whether complete dataset should be
used for computing the predictive distribution of missing values.
<code>argument=TRUE</code> is often needed for multilevel data in which cluster
means are included in regression models.
</p>
</td></tr>
<tr><td><code id="frm_+3A_object">object</code></td>
<td>
<p>Object of corresponding class</p>
</td></tr>
<tr><td><code id="frm_+3A_x">x</code></td>
<td>
<p>Object of corresponding class</p>
</td></tr>
<tr><td><code id="frm_+3A_digits">digits</code></td>
<td>
<p>Number of digits in <code>summary</code></p>
</td></tr>
<tr><td><code id="frm_+3A_file">file</code></td>
<td>
<p>File to which the <code>summary</code> should be linked</p>
</td></tr>
<tr><td><code id="frm_+3A_idparm">idparm</code></td>
<td>
<p>Indices for parameters to be plotted</p>
</td></tr>
<tr><td><code id="frm_+3A_ask">ask</code></td>
<td>
<p>Logical indicating whether the user is asked before new plot</p>
</td></tr>
<tr><td><code id="frm_+3A_as_mids">as_mids</code></td>
<td>
<p>Logical indicating whether multiply imputed datasets
should be converted into objects of class <code>mids</code></p>
</td></tr>
<tr><td><code id="frm_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function allows for fitting a factored regression model. Consider the case
of three variables <code class="reqn">Y</code>, <code class="reqn">X</code> and <code class="reqn">Z</code>. A factored regression model
consists of a sequence of univariate conditional models <code class="reqn">P(Y|X,Z)</code>,
<code class="reqn">P(X|Z)</code> and <code class="reqn">P(Z)</code> such that the joint distribution can be factorized as
</p>
<p style="text-align: center;"><code class="reqn"> P(Y,X,Z)=P( Y|X,Z) P(X|Z) P(Z) </code>
</p>

<p>Each of the three variables can contain missing values. Missing values are
integrated out by posing a distributional assumption for each variable with
missing values.
</p>


<h3>Value</h3>

<p>For <code>frm_em</code> it is a list containing the following values
</p>
<table>
<tr><td><code>coefs</code></td>
<td>
<p>Estimated coefficients</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>Covariance matrix</p>
</td></tr>
<tr><td><code>partable</code></td>
<td>
<p>Summary parameter table</p>
</td></tr>
<tr><td><code>all_coefs</code></td>
<td>
<p>List with all estimated coefficients</p>
</td></tr>
<tr><td><code>ll</code></td>
<td>
<p>Log likelihood value</p>
</td></tr>
<tr><td><code>like</code></td>
<td>
<p>Individual likelihood</p>
</td></tr>
<tr><td><code>dat</code></td>
<td>
<p>Data frame with included latent values for each variable with missing
values</p>
</td></tr>
<tr><td><code>se</code></td>
<td>
<p>Standard errors for coefficients</p>
</td></tr>
<tr><td><code>info</code></td>
<td>
<p>Information matrix</p>
</td></tr>
<tr><td><code>conv</code></td>
<td>
<p>Convergence indicator</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>Number of iterations</p>
</td></tr>
<tr><td><code>ic</code></td>
<td>
<p>Information criteria</p>
</td></tr>
<tr><td><code>ind0</code></td>
<td>
<p>List with model specifications including <code>dep</code> and <code>ind</code></p>
</td></tr>
<tr><td><code>predictorMatrix</code></td>
<td>
<p>Predictor matrix</p>
</td></tr>
<tr><td><code>variablesMatrix</code></td>
<td>
<p>Matrix containing all variables appearing in statistical
models</p>
</td></tr>
<tr><td><code>desc_vars</code></td>
<td>
<p>Descriptive statistics of variables</p>
</td></tr>
<tr><td><code>model_results</code></td>
<td>
<p>Results from fitted models</p>
</td></tr>
</table>
<p>The output for <code>frm_fb</code> contains particular additional values
</p>
<table>
<tr><td><code>tech_summary</code></td>
<td>
<p>Summary table with informations about MCMC algorithm</p>
</td></tr>
<tr><td><code>values_coda</code></td>
<td>
<p>Sampled parameter values saved as class <code>mcmc</code> for
analysis in <span class="pkg">coda</span> package</p>
</td></tr>
<tr><td><code>parms_mcmc</code></td>
<td>
<p>Object containing informations of sampled parameters</p>
</td></tr>
<tr><td><code>imputations_mcmc</code></td>
<td>
<p>Object containing informations of imputed datasets</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The <code>coef</code> and <code>vcov</code> methods can be used to extract coefficients and
the corresponding covariance matrix, respectively. Standard errors for a fitted
object <code>mod</code> can be extracted by making use of the <span class="pkg">survey</span>
package and the statement <code>survey::SE(mod)</code>.
</p>


<h3>Author(s)</h3>

<p>Alexander Robitzsch
</p>


<h3>References</h3>

<p>Allison, P. D. (2012). <em>Handling missing data by maximum likelihood</em>.
SAS Global Forum 2012.
</p>
<p>Bartlett, J. W., &amp; Morris, T. P. (2015) Multiple imputation of covariates by
substantive-model compatible fully conditional specification.
<em>Stata Journal, 15</em>(2), 437-456.
</p>
<p>Bartlett, J. W., Seaman, S. R., White, I. R., Carpenter, J. R., &amp; Alzheimer's Disease
Neuroimaging Initiative (2015). Multiple imputation of covariates by fully conditional
specification: Accommodating the substantive model.
<em>Statistical Methods in Medical Research, 24</em>(4), 462-487.
doi: <a href="https://doi.org/10.1177/0962280214521348">10.1177/0962280214521348</a>
</p>
<p>Erler, N. S., Rizopoulos, D., Rosmalen, J. V., Jaddoe, V. W., Franco, O. H., &amp;
Lesaffre, E. M. (2016). Dealing with missing covariates in epidemiologic studies:
A comparison between multiple
imputation and a full Bayesian approach. <em>Statistics in Medicine, 35</em>(17),
2955-2974. doi: <a href="https://doi.org/10.1002/sim.6944">10.1002/sim.6944</a>
</p>
<p>Ibrahim, J. G. (1990). Incomplete data in generalized linear models.
<em>Journal of the American Statistical Association, 85</em>(411), 765-769.
doi: <a href="https://doi.org/10.1080/01621459.1990.10474938">10.1080/01621459.1990.10474938</a>
</p>
<p>Ibrahim, J. G., Chen, M. H., Lipsitz, S. R., &amp; Herring, A. H. (2005).
Missing-data methods for generalized linear models: A comparative review.
<em>Journal of the American Statistical Association, 100</em>(469), 332-346.
doi: <a href="https://doi.org/10.1198/016214504000001844">10.1198/016214504000001844</a>
</p>
<p>Jamshidian, M., &amp; Jennrich, R. I. (2000). Standard errors for EM estimation.
<em>Journal of the Royal Statistical Society (Series B), 62</em>(2), 257-270.
doi: <a href="https://doi.org/10.1111/1467-9868.00230">10.1111/1467-9868.00230</a>
</p>
<p>Keller, B. T., &amp; Enders, C. K. (2018). <em>Blimp user's manual</em>. Los Angeles, CA. <br />
<em>http://www.appliedmissingdata.com/multilevel-imputation.html</em>
</p>
<p>Lee, M. C., &amp; Mitra, R. (2016). Multiply imputing missing values in data sets
with mixed measurement scales using a sequence of generalised linear models.
<em>Computational Statistics &amp; Data Analysis, 95</em>(24), 24-38.
doi: <a href="https://doi.org/10.1016/j.csda.2015.08.004">10.1016/j.csda.2015.08.004</a>
</p>
<p>Luedtke, O., Robitzsch, A., &amp; West, S. (2020a). Analysis of interactions and nonlinear
effects with missing data: A factored regression modeling approach using maximum
likelihood estimation. <em>Multivariate Behavioral Research, 55</em>(3), 361-381.
doi: <a href="https://doi.org/10.1080/00273171.2019.1640104">10.1080/00273171.2019.1640104</a>
</p>
<p>Luedtke, O., Robitzsch, A., &amp; West, S. (2020b). Regression models involving nonlinear
effects with missing data: A sequential modeling approach using Bayesian estimation.
<em>Psychological Methods, 25</em>(2), 157-181.
doi: <a href="https://doi.org/10.1037/met0000233">10.1037/met0000233</a>
</p>
<p>Zhang, Q., &amp; Wang, L. (2017). Moderation analysis with missing data in the predictors.
<em>Psychological Methods, 22</em>(4), 649-666.
doi: <a href="https://doi.org/10.1037/met0000104">10.1037/met0000104</a>
</p>


<h3>See Also</h3>

<p>See also the <span class="pkg">icdGLM</span> package for estimation of generalized
linear models with incomplete discrete covariates.
</p>
<p>The imputation of covariates in substantive models with interactions or nonlinear
terms can be also conducted with the <span class="pkg">JointAI</span> package which is a wrapper
to the JAGS software (see Erler et al., 2016). This package is also based on a sequential
modelling approach.
</p>
<p>The <span class="pkg">jomo</span> package also accommodates substantive models (<code>jomo::jomo.lm</code>)
based on a joint modeling framework.
</p>
<p>Substantive model compatible imputation based
on fully conditional specification can be found in the <span class="pkg">smcfcs</span> package
(see Bartlett et al., 2015; Bartlett &amp; Morris, 2015)
or the Blimp stand-alone software (Keller &amp; Enders, 2018).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#############################################################################
# EXAMPLE 1: Simulated example linear regression with interaction effects
#############################################################################

# The interaction model stats::lm( Y ~ X + Z + X:Z) is of substantive interest.
# There can be missing values in all variables.

data(data.mb01)
dat &lt;- data.mb01$missing

#******************************************
# Model 1: ML approach

#--- specify models

# define integration nodes
xnodes &lt;- seq(-4,4,len=11)        # nodes for X
ynodes &lt;- seq(-10,10,len=13)
  # nodes for Y. These ynodes are not really necessary for this dataset because
  # Y has no missing values.

# define model for dependent variable Y
dep &lt;- list("model"="linreg", "formula"=Y ~  X*Z, "nodes"=ynodes )

# model P(X|Z)
ind_X &lt;- list( "model"="linreg", "formula"=X ~ Z, "nodes"=xnodes )
# all models for covariates
ind &lt;- list( "X"=ind_X )

#--- estimate model with numerical integration
mod1 &lt;- mdmb::frm_em(dat=dat, dep=dep, ind=ind )
summary(mod1)

# extract some informations
coef(mod1)
vcov(mod1)
logLik(mod1)

#******************************************
# Model 2: Fully Bayesian approach / Multiple Imputation

#--- define models
dep &lt;- list("model"="linreg", "formula"=Y ~  X*Z )
ind_X &lt;- list( "model"="linreg", "formula"=X ~ Z  )
ind_Z &lt;- list( "model"="linreg", "formula"=Z ~ 1  )
ind &lt;- list( "X"=ind_X, Z=ind_Z)

#--- estimate model
mod2 &lt;- mdmb::frm_fb(dat, dep, ind, burnin=200, iter=1000)
summary(mod2)
#* plot parameters
plot(mod2)

#--- create list of multiply imputed datasets
datlist &lt;- mdmb::frm2datlist(mod2)
# convert into object of class mids
imp2 &lt;- miceadds::datlist2mids(datlist)
# estimate linear model on multiply imputed datasets
mod2c &lt;- with(imp2, stats::lm( Y ~ X*Z ) )
summary( mice::pool(mod2c) )

#******************************************
# Model 3: Multiple imputation in jomo package

library(jomo)

# impute with substantive model containing interaction effects
formula &lt;- Y ~ X*Z
imp &lt;- jomo::jomo.lm( formula=formula, data=dat, nburn=100, nbetween=100)

# convert to object of class mids
datlist &lt;- miceadds::jomo2mids( imp )
# estimate linear model
mod3 &lt;- with(datlist, lm( Y ~ X*Z ) )
summary( mice::pool(mod3) )

#############################################################################
# EXAMPLE 2: Simulated example logistic regression with interaction effects
#############################################################################

# Interaction model within a logistic regression Y ~ X + Z + X:Z
# Y and Z are dichotomous variables.

# attach data
data(data.mb02)
dat &lt;- data.mb02$missing

#******************************************
# Model 1: ML approach

#--- specify model

# define nodes
xnodes &lt;- seq(-5,5,len=15)  # X - normally distributed variable
ynodes &lt;- c(0,1)                # Y and Z dichotomous variable

# model P(Y|X,Z) for dependent variable
dep &lt;- list("model"="logistic", "formula"=Y ~  X*Z, "nodes"=ynodes )
# model P(X|Z)
ind_X &lt;- list( "model"="linreg", "formula"=X ~ Z, "nodes"=xnodes )
# model P(Z)
ind_Z &lt;- list( "model"="logistic", "formula"=Z ~ 1, "nodes"=ynodes )
ind &lt;- list(  "Z"=ind_Z, "X"=ind_X )

#--- estimate model with numerical integration
mod1 &lt;- mdmb::frm_em(dat=dat, dep=dep, ind=ind )
summary(mod1)

#******************************************
# Model 2: Fully Bayesian approach

#--- specify model
dep &lt;- list("model"="logistic", "formula"=Y ~  X*Z  )
ind_X &lt;- list( "model"="linreg", "formula"=X ~ Z )
ind_Z &lt;- list( "model"="logistic", "formula"=Z ~ 1 )
ind &lt;- list(  "Z"=ind_Z, "X"=ind_X )

#--- Bayesian estimation
mod2 &lt;- mdmb::frm_fb(dat=dat, dep=dep, ind=ind, burnin=500, iter=1000 )
summary(mod2)

#############################################################################
# EXAMPLE 3: Confirmatory factor analysis
#############################################################################

# A latent variable can be considered as missing data and the 'frm_em' function
# is used to estimate the latent variable model.

#--- simulate data
N &lt;- 1000
set.seed(91834)
# latent variable
theta &lt;- stats::rnorm(N)
# simulate items
y1 &lt;- 1.5 + 1*theta + stats::rnorm(N, sd=.7 )
y2 &lt;- 1.9 + .7*theta + stats::rnorm(N, sd=1 )
y3 &lt;- .9 + .7*theta + stats::rnorm(N, sd=.2 )
dat &lt;- data.frame(y1,y2,y3)
dat$theta &lt;- NA

#******************************************
# Model 1: ML approach

#--- define model
nodes &lt;- seq(-4,4,len=21)
ind_y1 &lt;- list("model"="linreg", "formula"=y1 ~  offset(1*theta),
                "nodes"=nodes )
ind_y2 &lt;- list( "model"="linreg", "formula"=y2 ~ theta, "nodes"=nodes,
                "coef_inits"=c(NA,1) )
ind_y3 &lt;- list( "model"="linreg", "formula"=y3 ~ theta, "nodes"=nodes,
                 "coef_inits"=c(1,1) )
dep &lt;- list( "model"="linreg", "formula"=theta ~ 0, "nodes"=nodes )
ind &lt;- list( "y1"=ind_y1,  "y2"=ind_y2, "y3"=ind_y3)

#*** estimate model with mdmb::frm_em
mod1 &lt;- mdmb::frm_em(dat, dep, ind)
summary(mod1)

#*** estimate model in lavaan
library(lavaan)
lavmodel &lt;- "
     theta=~ 1*y1 + y2 + y3
     theta ~~ theta
     "
mod1b &lt;- lavaan::cfa( model=lavmodel, data=dat )
summary(mod1b)

# compare likelihood
logLik(mod1)
logLik(mod1b)

#############################################################################
# EXAMPLE 4: Rasch model
#############################################################################

#--- simulate data
set.seed(91834)
N &lt;- 500
# latent variable
theta0 &lt;- theta &lt;- stats::rnorm(N)
# number of items
I &lt;- 7
dat &lt;- sirt::sim.raschtype( theta, b=seq(-1.5,1.5,len=I) )
colnames(dat) &lt;- paste0("I",1:I)
dat$theta &lt;- NA

#******************************************
# Model 1: ML approach

#--- define model
nodes &lt;- seq(-4,4,len=13)
dep &lt;- list("model"="linreg", "formula"=theta ~  0, "nodes"=nodes )
ind &lt;- list()
for (ii in 1:I){
    ind_ii &lt;- list( "model"="logistic", formula=
                 stats::as.formula( paste0("I",ii, " ~ offset(1*theta)") ) )
    ind[[ii]] &lt;- ind_ii
}
names(ind) &lt;- colnames(dat)[-(I+1)]

#--- estimate Rasch model with mdmb::frm_em
mod1 &lt;- mdmb::frm_em(dat, dep, ind )
summary(mod1)

#--- estmate Rasch model with sirt package
library(sirt)
mod2 &lt;- sirt::rasch.mml2( dat[,-(I+1)], theta.k=nodes, use.freqpatt=FALSE)
summary(mod2)

#** compare estimated parameters
round(cbind(coef(mod1), c( mod2$sd.trait, -mod2$item$thresh[ seq(I,1)] ) ), 3)

#############################################################################
# EXAMPLE 5: Regression model with measurement error in covariates
#############################################################################

#--- simulate data
set.seed(768)
N &lt;- 1000
# true score
theta &lt;- stats::rnorm(N)
# heterogeneous error variance
var_err &lt;- stats::runif(N, .5, 1)
# simulate observed score
x &lt;- theta + stats::rnorm(N, sd=sqrt(var_err) )
# simulate outcome
y &lt;- .3 + .7 * theta + stats::rnorm( N, sd=.8 )
dat0 &lt;- dat &lt;- data.frame( y=y, x=x, theta=theta )

#*** estimate model with true scores (which are unobserved in real datasets)
mod0 &lt;- stats::lm( y ~ theta, data=dat0 )
summary(mod0)

#******************************************
# Model 1: Model-based approach

#--- specify model
dat$theta &lt;- NA
nodes &lt;- seq(-4,4,len=15)
dep &lt;- list( "model"="linreg", "formula"=y ~ theta, "nodes"=nodes,
                "coef_inits"=c(NA, .4 ) )
ind &lt;- list()
ind[["theta"]] &lt;- list( "model"="linreg", "formula"=theta ~ 1,
                         "nodes"=nodes  )
ind[["x"]] &lt;- list( "model"="linreg", "formula"=x ~ 0 + offset(theta),
                        "nodes"=nodes )
# assumption of heterogeneous known error variance
ind[["x"]]$sigma_fixed &lt;- sqrt( var_err )

#--- estimate regression model
mod1 &lt;- mdmb::frm_em(dat, dep, ind )
summary(mod1)

#******************************************
# Model 2: Fully Bayesian estimation

#--- specify model
dep &lt;- list( "model"="linreg", "formula"=y ~ theta )
ind &lt;- list()
ind[["theta"]] &lt;- list( "model"="linreg", "formula"=theta ~ 1  )
ind[["x"]] &lt;- list( "model"="linreg", "formula"=x ~ 0 + offset(theta) )
# assumption of heterogeneous known error variance
ind[["x"]]$sigma_fixed &lt;- sqrt( var_err )
data_init &lt;- dat
data_init$theta &lt;- dat$x

# estimate model
mod2 &lt;- mdmb::frm_fb(dat, dep, ind, burnin=200, iter=1000, data_init=data_init)
summary(mod2)
plot(mod2)

#############################################################################
# EXAMPLE 6: Non-normally distributed covariates:
#            Positive values with Box-Cox transformation
#############################################################################

# simulate data with chi-squared distributed covariate from
# regression model Y ~ X
set.seed(876)
n &lt;- 1500
df &lt;- 2
x &lt;- stats::rchisq( n, df=df )
x &lt;- x / sqrt( 2*df)
y &lt;- 0 + 1*x
R2 &lt;- .25    # explained variance
y &lt;- y + stats::rnorm(n, sd=sqrt( (1-R2)/R2 * 1) )
dat0 &lt;- dat &lt;- data.frame( y=y, x=x )

# simulate missing responses
prop_miss &lt;- .5
cor_miss &lt;- .7
resp_tend &lt;- cor_miss*(dat$y-mean(y) )/ stats::sd(y) +
                 stats::rnorm(n, sd=sqrt( 1 - cor_miss^2) )
dat[ resp_tend &lt; stats::qnorm( prop_miss ), "x" ] &lt;- NA
summary(dat)

#-- complete data
mod0 &lt;- stats::lm( y ~ x, data=dat0 )
summary(mod0)
#-- listwise deletion
mod1 &lt;- stats::lm( y ~ x, data=dat )
summary(mod1)

# normal distribution assumption for frm

# define models
dep &lt;- list("model"="linreg", "formula"=y ~  x )
# normally distributed data
ind_x1 &lt;- list( "model"="linreg", "formula"=x ~ 1 )
# Box-Cox normal distribution
ind_x2 &lt;- list( "model"="bctreg", "formula"=x ~ 1,
              nodes=c( seq(0.05, 3, len=31), seq( 3.5, 9, by=.5 ) ) )
ind1 &lt;- list( "x"=ind_x1 )
ind2 &lt;- list( "x"=ind_x2 )

#--- incorrect normal distribution assumption
mod1 &lt;- mdmb::frm_em(dat=dat, dep=dep, ind=ind1 )
summary(mod1)

#--- model chi-square distribution of predictor with Box-Cox transformation
mod2 &lt;- mdmb::frm_em(dat=dat, dep=dep, ind=ind2 )
summary(mod2)

#############################################################################
# EXAMPLE 7: Latent interaction model
#############################################################################

# A latent interaction model Y ~ FX + FZ is of interest. Y is directly observed,
# FX and FZ are both indirectly observed by three items

#--- simulate data
N &lt;- 1000
set.seed(987)
# latent variable
FX &lt;- stats::rnorm(N)
FZ &lt;- stats::rnorm(N)
# simulate items
x1 &lt;- 1.5 + 1*FX + stats::rnorm(N, sd=.7 )
x2 &lt;- 1.9 + .7*FX + stats::rnorm(N, sd=1 )
x3 &lt;- .9 + .7*FX + stats::rnorm(N, sd=.2 )
z1 &lt;- 1.5 + 1*FZ + stats::rnorm(N, sd=.7 )
z2 &lt;- 1.9 + .7*FZ + stats::rnorm(N, sd=1 )
z3 &lt;- .9 + .7*FZ + stats::rnorm(N, sd=.2 )
dat &lt;- data.frame(x1,x2,x3,z1,z2,z3)
dat$FX &lt;- NA
dat$FZ &lt;- NA
dat$y &lt;- 2 + .5*FX + .3*FZ + .4*FX*FZ + rnorm( N, sd=1 )

# estimate interaction model with ML

#--- define model
nodes &lt;- seq(-4,4,len=11)
ind_x1 &lt;- list("model"="linreg", "formula"=x1 ~  offset(1*FX),
                "nodes"=nodes )
ind_x2 &lt;- list( "model"="linreg", "formula"=x2 ~ FX, "nodes"=nodes,
                "coef_inits"=c(NA,1) )
ind_x3 &lt;- list( "model"="linreg", "formula"=x3 ~ FX, "nodes"=nodes,
                 "coef_inits"=c(1,1) )
ind_FX &lt;- list( "model"="linreg", "formula"=FX ~ 0, "nodes"=nodes )
ind_z1 &lt;- list("model"="linreg", "formula"=z1 ~  offset(1*FZ),
                "nodes"=nodes )
ind_z2 &lt;- list( "model"="linreg", "formula"=z2 ~ FZ, "nodes"=nodes,
                "coef_inits"=c(NA,1) )
ind_z3 &lt;- list( "model"="linreg", "formula"=z3 ~ FZ, "nodes"=nodes,
                 "coef_inits"=c(1,1) )
ind_FZ &lt;- list( "model"="linreg", "formula"=FZ ~ 0 + FX, "nodes"=nodes )
ind &lt;- list( "x1"=ind_x1,  "x2"=ind_x2, "x3"=ind_x3, "FX"=ind_FX,
            "z1"=ind_z1,  "z2"=ind_z2, "z3"=ind_z3, "FX"=ind_FZ )
dep &lt;- list( "model"="linreg", formula=y ~ FX+FZ+FX*FZ, "coef_inits"=c(1,.2,.2,0) )

#*** estimate model with mdmb::frm_em
mod1 &lt;- mdmb::frm_em(dat, dep, ind)
summary(mod1)

#############################################################################
# EXAMPLE 8: Non-ignorable data in Y
#############################################################################

# regression Y ~ X in which Y is missing depending Y itself

library(mvtnorm)
cor_XY &lt;- .4        # correlation between X and Y
prop_miss &lt;- .5     # missing proportion
cor_missY &lt;- .7     # correlation with missing propensity
N &lt;- 3000           # sample size

#----- simulate data
set.seed(790)
Sigma &lt;- matrix( c(1, cor_XY, cor_XY, 1), 2, 2 )
mu &lt;- c(0,0)
dat &lt;- mvtnorm::rmvnorm( N, mean=mu, sigma=Sigma )
colnames(dat) &lt;- c("X","Y")
dat &lt;- as.data.frame(dat)

#-- generate missing responses on Y depending on Y itself
y1 &lt;- dat$Y
miss_tend &lt;- cor_missY * y1  + rnorm(N, sd=sqrt( 1 - cor_missY^2) )
dat$Y[ miss_tend &lt; quantile( miss_tend, prop_miss ) ] &lt;- NA

#--- ML estimation under assumption of ignorability
nodes &lt;- seq(-5,5,len=15)
dep &lt;- list("model"="linreg", "formula"=Y ~  X, "nodes"=nodes )
ind_X &lt;- list( "model"="linreg", "formula"=X ~ 1, "nodes"=nodes )
ind &lt;- list( "X"=ind_X )
mod1 &lt;- mdmb::frm_em(dat=dat, dep=dep, ind=ind)
summary(mod1)

#--- ML estimation under assumption with specifying a model for non-ignorability
#    for response indicator resp_Y
dat$resp_Y &lt;- 1* ( 1 - is.na(dat$Y) )
dep &lt;- list("model"="linreg", "formula"=Y ~  X, "nodes"=nodes )
ind_X &lt;- list( "model"="linreg", "formula"=X ~ 1, "nodes"=nodes )
ind_respY &lt;- list( "model"="logistic", "formula"=resp_Y ~ Y, "nodes"=nodes )
ind &lt;- list( "X"=ind_X, "resp_Y"=ind_respY )
mod2 &lt;- mdmb::frm_em(dat=dat, dep=dep, ind=ind)
summary(mod2)

#############################################################################
# EXAMPLE 9: Ordinal variables: Graded response model
#############################################################################

#--- simulate data
N &lt;- 2000
set.seed(91834)
# latent variable
theta &lt;- stats::rnorm(N)
# simulate items
y1 &lt;- 1*theta + stats::rnorm(N)
y2 &lt;- .7*theta + stats::rnorm(N)
y3 &lt;- .7*theta + stats::rnorm(N)
# discretize variables
y1 &lt;- as.numeric( cut( y1, breaks=c(-Inf, -.5, 0.4, 1, Inf ) ) ) - 1
y2 &lt;- as.numeric( cut( y2, breaks=c(-Inf, 0.3, 1, Inf ) ) ) - 1
y3 &lt;- as.numeric( cut( y3, breaks=c(-Inf, .2, Inf ) ) ) - 1
# define dataset
dat &lt;- data.frame(y1,y2,y3)
dat$theta &lt;- NA

#******************************************
# Model 1: Fully Bayesian estimation

#--- define model
ind_y1 &lt;- list( "model"="oprobit", "formula"=y1 ~  offset(1*theta) )
ind_y2 &lt;- list( "model"="oprobit", "formula"=y2 ~ theta )
ind_y3 &lt;- list( "model"="oprobit", "formula"=y3 ~ theta )
dep &lt;- list( "model"="linreg", "formula"=theta ~ 0  )
ind &lt;- list( "y1"=ind_y1,  "y2"=ind_y2, "y3"=ind_y3)
# initial data
data_init &lt;- dat
data_init$theta &lt;- as.numeric( scale(dat$y1) ) + stats::rnorm(N, sd=.4 )

#-- estimate model
iter &lt;- 3000; burnin &lt;- 1000
mod1 &lt;- mdmb::frm_fb(dat=dat, dep=dep, ind=ind, data_init=data_init,
                   iter=iter, burnin=burnin)
summary(mod1)
plot(mod1)

#############################################################################
# EXAMPLE 10: Imputation for missig predictors in models with interaction
#             effects in multilevel regression models
#############################################################################

library(miceadds)
data(data.mb04, package="mdmb")
dat &lt;- data.mb04

#*** model specification
mcmc_iter &lt;- 4   # number of MCMC iterations for model parameter sampling
model_formula &lt;- y ~ cwc(x, idcluster) + gm(x, idcluster) + w + w*cwc(x, idcluster) +
                   w*gm(x, idcluster) + ( 1 + cwc(x, idcluster) | idcluster)
dep &lt;- list("model"="mlreg", "formula"=model_formula,
               R_args=list(iter=mcmc_iter, outcome="normal") )
ind_x &lt;- list( "model"="mlreg", "formula"=x ~ w + (1|idcluster), R_args=list(iter=mcmc_iter),
                  sampling_level="idcluster" )
# group means of x are involved in the outcome model. Therefore, Metropolis-Hastings
# sampling of missing values in x should be conducted at the level of clusters,
# i.e. specifying sampling_level
ind &lt;- list("x"=ind_x)

# --- estimate model
mod1 &lt;- mdmb::frm_fb(dat, dep, ind, aggregation=TRUE)
# argument aggregation is necessary because group means are involved in regression formulas

#-------------
#*** imputation of a continuous level-2 variable w

#  create artificially some missings on w
dat[ dat$idcluster %%3==0, "w" ] &lt;- NA

# define level-2 model with argument variable_level
ind_w &lt;- list( "model"="linreg", "formula"=w ~ 1, "variable_level"="idcluster" )
ind &lt;- list( x=ind_x, w=ind_w)

#* conduct imputations
mod2 &lt;- mdmb::frm_fb(dat, dep, ind, aggregation=TRUE)
summary(mod2)

#--- Model 1 with user-defined prior distributions for covariance matrices
model_formula &lt;- y ~ cwc(x, idcluster) + gm(x, idcluster) + w + w*cwc(x, idcluster) +
                   w*gm(x, idcluster) + ( 1 + cwc(x, idcluster) | idcluster)

# define scale degrees of freedom (nu) and scale matrix (S) for inverse Wishart distribution
psi_nu0_list &lt;- list( -3 )
psi_S0_list &lt;- list( diag(0,2) )
dep &lt;- list("model"="mlreg", "formula"=model_formula,
               R_args=list(iter=mcmc_iter, outcome="normal",
               psi_nu0_list=psi_nu0_list, psi_S0_list=psi_S0_list ) )

# define nu and S parameters for covariate model
psi_nu0_list &lt;- list( .4 )
psi_S0_list &lt;- list( matrix(.2, nrow=1, ncol=1) )
ind_x &lt;- list( "model"="mlreg", "formula"=x ~ w + (1|idcluster),
                   R_args=list(iter=mcmc_iter, psi_nu0_list=psi_nu0_list,
                            psi_S0_list=psi_S0_list),
                  sampling_level="idcluster" )
ind &lt;- list("x"=ind_x)

# --- estimate model
mod3 &lt;- mdmb::frm_fb(dat, dep, ind, aggregation=TRUE)

#############################################################################
# EXAMPLE 11: Bounded variable combined with Yeo-Johnson transformation
#############################################################################

#*** simulate data
set.seed(876)
n &lt;- 1500
x &lt;- mdmb::ryjt_scaled( n, location=-.2, shape=.8, lambda=.9, probit=TRUE)
R2 &lt;- .25    # explained variance
y &lt;- 1*x + stats::rnorm(n, sd=sqrt( (1-R2)/R2 * stats::var(x)) )
dat0 &lt;- dat &lt;- data.frame( y=y, x=x )

# simulate missing responses
prop_miss &lt;- .5
cor_miss &lt;- .7
resp_tend &lt;- cor_miss*(dat$y-mean(y) )/ stats::sd(y) +
                 stats::rnorm(n, sd=sqrt( 1 - cor_miss^2) )
dat[ resp_tend &lt; stats::qnorm(prop_miss), "x" ] &lt;- NA
summary(dat)

#*** define models
dep &lt;- list("model"="linreg", "formula"=y ~  x )
# distribution according to Yeo-Johnson transformation
ind_x1 &lt;- list( "model"="yjtreg", "formula"=x ~ 1 )
# distribution according to Probit Yeo-Johnson transformation
ind_x2 &lt;- list( "model"="yjtreg", "formula"=x ~ 1, R_args=list("probit"=TRUE ) )
ind1 &lt;- list( "x"=ind_x1 )
ind2 &lt;- list( "x"=ind_x2 )

#--- complete data
mod0 &lt;- stats::lm( y~x, data=dat0)
summary(mod0)

#--- Yeo-Johnson normal distribution (for unbounded variables)
mod1 &lt;- mdmb::frm_em(dat=dat, dep=dep, ind=ind1 )
summary(mod1)

#--- Probit Yeo-Johnson normal distribution (for bounded variable on (0,1))
mod2 &lt;- mdmb::frm_em(dat=dat, dep=dep, ind=ind2)
summary(mod2)

#--- same model, but MCMC estimation
mod3 &lt;- mdmb::frm_fb(dat, dep, ind=ind2, burnin=2000, iter=5000)
summary(mod3)
plot(mod3)

#############################################################################
# EXAMPLE 12: Yeo-Johnson transformation with estimated degrees of freedom
#############################################################################

#*** simulate data
set.seed(876)
n &lt;- 1500
x &lt;- mdmb::ryjt_scaled( n, location=-.2, shape=.8, lambda=.9, df=10 )
R2 &lt;- .25    # explained variance
y &lt;- 1*x + stats::rnorm(n, sd=sqrt( (1-R2)/R2 * stats::var(x)) )
dat0 &lt;- dat &lt;- data.frame( y=y, x=x )

# simulate missing responses
prop_miss &lt;- .5
cor_miss &lt;- .7
resp_tend &lt;- cor_miss*(dat$y-mean(y) )/ stats::sd(y) +
                 stats::rnorm(n, sd=sqrt( 1-cor_miss^2) )
dat[ resp_tend &lt; stats::qnorm(prop_miss), "x" ] &lt;- NA
summary(dat)

#*** define models
dep &lt;- list("model"="linreg", "formula"=y ~  x )
# specify distribution with estimated degrees of freedom
ind_x &lt;- list( "model"="yjtreg", "formula"=x ~ 1, R_args=list(est_df=TRUE ) )
ind &lt;- list( "x"=ind_x )

#--- Yeo-Johnson t distribution
mod1 &lt;- mdmb::frm_fb(dat=dat, dep=dep, ind=ind, iter=3000, burnin=1000 )
summary(mod1)

## End(Not run)
</code></pre>

<hr>
<h2 id='mdmb_regression'>
Several Regression Models with Prior Distributions and Sampling Weights
</h2><span id='topic+logistic_regression'></span><span id='topic+coef.logistic_regression'></span><span id='topic+vcov.logistic_regression'></span><span id='topic+logLik.logistic_regression'></span><span id='topic+summary.logistic_regression'></span><span id='topic+predict.logistic_regression'></span><span id='topic+yjt_regression'></span><span id='topic+coef.yjt_regression'></span><span id='topic+vcov.yjt_regression'></span><span id='topic+logLik.yjt_regression'></span><span id='topic+summary.yjt_regression'></span><span id='topic+predict.yjt_regression'></span><span id='topic+bct_regression'></span><span id='topic+coef.bct_regression'></span><span id='topic+vcov.bct_regression'></span><span id='topic+logLik.bct_regression'></span><span id='topic+summary.bct_regression'></span><span id='topic+predict.bct_regression'></span><span id='topic+oprobit_regression'></span><span id='topic+coef.oprobit_regression'></span><span id='topic+vcov.oprobit_regression'></span><span id='topic+logLik.oprobit_regression'></span><span id='topic+summary.oprobit_regression'></span><span id='topic+predict.oprobit_regression'></span>

<h3>Description</h3>

<p>Several regression functions which allow for sampling weights and
prior distributions.
</p>
<p>The function <code>yjt_regression</code> performs a linear regression in which the
response variable is transformed according to the Yeo-Johnson transformation
(Yeo &amp; Johnson, 2000; see <code><a href="#topic+yjt_dist">yjt_dist</a></code>) and the residuals are
distributed following the scaled <code class="reqn">t</code> distribution. The degrees of freedom
of the <code class="reqn">t</code> distribution can be fixed or estimated (<code>est_df=TRUE</code>).
The function <code>bct_regression</code> has same functionality like the
Yeo-Johnson transformation but employs a Box-Cox transformation
of the outcome variable.
</p>
<p>The Yeo-Johnson transformation can be extended by a probit transformation
(<code>probit=TRUE</code>) to cover the case of bounded variables on <code class="reqn">[0,1]</code>.
</p>
<p>The function <code>logistic_regression</code> performs logistic regression
for dichotomous data.
</p>
<p>The function <code>oprobit_regression</code> performs ordinal probit regression
for ordinal polytomous data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>#---- linear regression with Yeo-Johnson transformed scaled t distribution
yjt_regression(formula, data, weights=NULL, beta_init=NULL, beta_prior=NULL,
        df=Inf, lambda_fixed=NULL, probit=FALSE, est_df=FALSE, df_min=0.5, df_max=100,
        use_grad=2, h=1e-5, optimizer="optim", maxiter=300, control=NULL)

## S3 method for class 'yjt_regression'
coef(object, ...)
## S3 method for class 'yjt_regression'
logLik(object, ...)
## S3 method for class 'yjt_regression'
predict(object, newdata=NULL, trafo=TRUE,  ...)
## S3 method for class 'yjt_regression'
summary(object, digits=4, file=NULL, ...)
## S3 method for class 'yjt_regression'
vcov(object, ...)

#---- linear regression with Box-Cox transformed scaled t distribution
bct_regression(formula, data, weights=NULL, beta_init=NULL, beta_prior=NULL,
        df=Inf, lambda_fixed=NULL, est_df=FALSE, use_grad=2, h=1e-5,
        optimizer="optim", maxiter=300, control=NULL)

## S3 method for class 'bct_regression'
coef(object, ...)
## S3 method for class 'bct_regression'
logLik(object, ...)
## S3 method for class 'bct_regression'
predict(object, newdata=NULL, trafo=TRUE, ...)
## S3 method for class 'bct_regression'
summary(object, digits=4, file=NULL, ...)
## S3 method for class 'bct_regression'
vcov(object, ...)

#---- logistic regression
logistic_regression(formula, data, weights=NULL, beta_init=NULL,
         beta_prior=NULL, use_grad=2, h=1e-5, optimizer="optim", maxiter=300,
         control=NULL)

## S3 method for class 'logistic_regression'
coef(object, ...)
## S3 method for class 'logistic_regression'
logLik(object, ...)
## S3 method for class 'logistic_regression'
predict(object, newdata=NULL, ...)
## S3 method for class 'logistic_regression'
summary(object, digits=4, file=NULL, ...)
## S3 method for class 'logistic_regression'
vcov(object, ...)

#---- ordinal probit regression
oprobit_regression(formula, data, weights=NULL, beta_init=NULL,
        use_grad=2, h=1e-5, optimizer="optim", maxiter=300,
        control=NULL, control_optim_fct=NULL)

## S3 method for class 'oprobit_regression'
coef(object, ...)
## S3 method for class 'oprobit_regression'
logLik(object, ...)
## S3 method for class 'oprobit_regression'
predict(object, newdata=NULL, ...)
## S3 method for class 'oprobit_regression'
summary(object, digits=4, file=NULL, ...)
## S3 method for class 'oprobit_regression'
vcov(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mdmb_regression_+3A_formula">formula</code></td>
<td>

<p>Formula
</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_data">data</code></td>
<td>

<p>Data frame. The dependent variable must be coded as 0 and 1.
</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_weights">weights</code></td>
<td>

<p>Optional vector of sampling weights
</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_beta_init">beta_init</code></td>
<td>

<p>Optional vector of initial regression coefficients
</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_beta_prior">beta_prior</code></td>
<td>
<p>Optional list containing priors of all parameters
(see Examples for definition of this list).</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_df">df</code></td>
<td>
<p>Fixed degrees of freedom for scaled <code class="reqn">t</code> distribution</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_lambda_fixed">lambda_fixed</code></td>
<td>
<p>Optional fixed value for <code class="reqn">\lambda</code> for scaled
<code class="reqn">t</code> distribution with Yeo-Johnson transformation</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_probit">probit</code></td>
<td>
<p>Logical whether probit transformation should be employed for
bounded outcome in <code>yjt_regression</code></p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_est_df">est_df</code></td>
<td>
<p>Logical indicating whether degrees of freedom in
<code class="reqn">t</code> distribution should be estimated.</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_df_min">df_min</code></td>
<td>
<p>Minimum value for estimated degrees of freedom</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_df_max">df_max</code></td>
<td>
<p>Maximum value for estimated degrees of freedom</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_use_grad">use_grad</code></td>
<td>
<p>Computation method for gradients in <code>stats::optim</code>.
The value <code>0</code> is the internal approximation of
<code>stats::optim</code> and applies the settings in <span class="pkg">mdmb</span> (<code class="reqn">\le</code>0.3).
The specification <code>use_grad=1</code> uses the calculation of
the gradient in <code>CDM::numerical_Hessian</code>. The value <code>2</code> is
usually the most efficient calculation of the gradient.</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_h">h</code></td>
<td>
<p>Numerical differentiation parameter.</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_optimizer">optimizer</code></td>
<td>
<p>Type of optimizer to be chosen. Options are
<code>"nlminb"</code> (<code><a href="stats.html#topic+nlminb">stats::nlminb</a></code>) and
the default <code>"optim"</code> (<code><a href="stats.html#topic+optim">stats::optim</a></code>)
</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_maxiter">maxiter</code></td>
<td>
<p>Maximum number of iterations</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_control">control</code></td>
<td>

<p>Optional arguments to be passed to optimization function
(<code><a href="stats.html#topic+nlminb">stats::nlminb</a></code>) or
<code><a href="stats.html#topic+optim">stats::optim</a></code>
</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_control_optim_fct">control_optim_fct</code></td>
<td>
<p>Optional control argument for gradient in
optimization</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_object">object</code></td>
<td>
<p>Object of class <code>logistic_regression</code></p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_newdata">newdata</code></td>
<td>
<p>Design matrix for <code>predict</code> function</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_trafo">trafo</code></td>
<td>
<p>Logical indicating whether fitted values should be on the
transformed metric (<code>trafo=TRUE</code>) or the original metric
(<code>trafo=FALSE</code>)</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_digits">digits</code></td>
<td>
<p>Number of digits for rounding</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_file">file</code></td>
<td>
<p>File name if the <code>summary</code> output should be sunk into a file.</p>
</td></tr>
<tr><td><code id="mdmb_regression_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List containing values
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>Estimated regression coefficients</p>
</td></tr>
<tr><td><code>vcov</code></td>
<td>
<p>Estimated covariance matrix</p>
</td></tr>
<tr><td><code>partable</code></td>
<td>
<p>Parameter table</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Vector of values of dependent variable</p>
</td></tr>
<tr><td><code>Xdes</code></td>
<td>
<p>Design matrix</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>Sampling weights</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>Fitted values in metric of probabilities</p>
</td></tr>
<tr><td><code>linear.predictor</code></td>
<td>
<p>Fitted values in metric of logits</p>
</td></tr>
<tr><td><code>loglike</code></td>
<td>
<p>Log likelihood value</p>
</td></tr>
<tr><td><code>logprior</code></td>
<td>
<p>Log prior value</p>
</td></tr>
<tr><td><code>logpost</code></td>
<td>
<p>Log posterior value</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>Deviance</p>
</td></tr>
<tr><td><code>loglike_case</code></td>
<td>
<p>Case-wise likelihood</p>
</td></tr>
<tr><td><code>ic</code></td>
<td>
<p>Information criteria</p>
</td></tr>
<tr><td><code>R2</code></td>
<td>
<p>Pseudo R-square value according to McKelvey and Zavoina</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Alexander Robitzsch
</p>


<h3>References</h3>

<p>McKelvey, R., &amp; Zavoina, W. (1975). A statistical model for the analysis of
ordinal level dependent variables.
<em>Journal of Mathematical Sociology, 4</em>(1), 103-120.
doi: <a href="https://doi.org/10.1080/0022250X.1975.9989847">10.1080/0022250X.1975.9989847</a>
</p>
<p>Yeo, I.-K., &amp; Johnson, R. (2000). A new family of power transformations to
improve normality or symmetry. <em>Biometrika, 87</em>(4), 954-959.
doi: <a href="https://doi.org/10.1093/biomet/87.4.954">10.1093/biomet/87.4.954</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+yjt_dist">yjt_dist</a></code> or <code>car::yjPower</code>
for functions for the Yeo-Johnson transformation.
</p>
<p>See <code><a href="stats.html#topic+lm">stats::lm</a></code> and
<code><a href="stats.html#topic+glm">stats::glm</a></code> for linear and logistic
regression models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Simulated example logistic regression
#############################################################################

#--- simulate dataset
set.seed(986)
N &lt;- 500
x &lt;- stats::rnorm(N)
y &lt;- 1*( stats::runif(N) &lt; stats::plogis( -0.8 + 1.2 * x ) )
data &lt;- data.frame( x=x, y=y )

#--- estimate logistic regression with mdmb::logistic_regression
mod1 &lt;- mdmb::logistic_regression( y ~ x, data=data )
summary(mod1)

## Not run: 
#--- estimate logistic regression with stats::glm
mod1b &lt;- stats::glm( y ~ x, data=data, family="binomial")
summary(mod1b)

#--- estimate logistic regression with prior distributions
b0 &lt;- list( "dnorm", list(mean=0, sd=100) )  # first parameter
b1 &lt;- list( "dcauchy", list(location=0, scale=2.5) )   # second parameter
beta_priors &lt;- list( b0, b1 )  # order in list defines priors for parameters
#* estimation
mod2 &lt;- mdmb::logistic_regression( y ~ x, data=data, beta_prior=beta_priors )
summary(mod2)

#############################################################################
# EXAMPLE 2: Yeo-Johnson transformed scaled t regression
#############################################################################

#*** create simulated data
set.seed(9865)
n &lt;- 1000
x &lt;- stats::rnorm(n)
y &lt;- .5 + 1*x + .7*stats::rt(n, df=8 )
y &lt;- mdmb::yj_antitrafo( y, lambda=.5 )
dat &lt;- data.frame( y=y, x=x )
# display data
graphics::hist(y)

#--- Model 1: fit regression model with transformed normal distribution (df=Inf)
mod1 &lt;- mdmb::yjt_regression( y ~ x, data=dat )
summary(mod1)

#--- Model 2: fit regression model with transformed scaled t distribution (df=10)
mod2 &lt;- mdmb::yjt_regression( y ~ x, data=dat, df=10)
summary(mod2)

#--- Model 3: fit regression model with transformed normal distribution (df=Inf)
#             and fixed transformation parameter lambda of .5
mod3 &lt;- mdmb::yjt_regression( y ~ x, data=dat, lambda_fixed=.5)
summary(mod3)

#--- Model 4: fit regression model with transformed normal distribution (df=Inf)
#             and fixed transformation parameter lambda of 1
#             -&gt; This model corresponds to least squares regression
mod4 &lt;- mdmb::yjt_regression( y ~ x, data=dat, lambda_fixed=1)
summary(mod4)

# fit with lm function
mod4b &lt;- stats::lm( y ~ x, data=dat )
summary(mod4b)

#--- Model 5: fit regression model with estimated degrees of freedom
mod5 &lt;- mdmb::yjt_regression( y ~ x, data=dat, est_df=TRUE)
summary(mod5)

#** compare log-likelihood values
logLik(mod1)
logLik(mod2)
logLik(mod3)
logLik(mod4)
logLik(mod4b)
logLik(mod5)

#############################################################################
# EXAMPLE 3: Regression with Box-Cox and Yeo-Johnson transformations
#############################################################################

#*** simulate data
set.seed(985)
n &lt;- 1000
x &lt;- stats::rnorm(n)
y &lt;- .5 + 1*x + stats::rnorm(n, sd=.7 )
y &lt;- mdmb::bc_antitrafo( y, lambda=.5 )
dat &lt;- data.frame( y=y, x=x )

#--- Model 1: fit regression model with Box-Cox transformation
mod1 &lt;- mdmb::bct_regression( y ~ x, data=dat )
summary(mod1)
#--- Model 2: fit regression model with Yeo-Johnson transformation
mod2 &lt;- mdmb::yjt_regression( y ~ x, data=dat )
summary(mod2)
#--- compare fit
logLik(mod1)
logLik(mod2)

#############################################################################
# EXAMPLE 4: Ordinal probit regression
#############################################################################

#--- simulate data
set.seed(987)
N &lt;- 1500
x &lt;- stats::rnorm(N)
z &lt;- stats::rnorm(N)
# regression coefficients
b0 &lt;- -.5 ; b1 &lt;- .6 ; b2 &lt;- .1
# vector of thresholds
thresh &lt;- c(-1, -.3, 1)
yast &lt;- b0 + b1 * x + b2*z + stats::rnorm(N)
y &lt;- as.numeric( cut( yast, c(-Inf,thresh,Inf) ) ) - 1
dat &lt;- data.frame( x=x, y=y, z=z )

#--- probit regression
mod &lt;- mdmb::oprobit_regression( formula=y ~ x + z + I(x*z), data=dat)
summary(mod)

## End(Not run)
</code></pre>

<hr>
<h2 id='offset_values_extract'>
Extracts Offset Values
</h2><span id='topic+offset_values_extract'></span>

<h3>Description</h3>

<p>Extracts offset values by applying a formula with an offset term
to a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>offset_values_extract(formula, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="offset_values_extract_+3A_formula">formula</code></td>
<td>

<p>An <span class="rlang"><b>R</b></span> Formula
</p>
</td></tr>
<tr><td><code id="offset_values_extract_+3A_data">data</code></td>
<td>

<p>Data frame
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector containing offset values
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+offset">stats::offset</a></code>,
<code><a href="stats.html#topic+model.offset">stats::model.offset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Toy example for extraction of offset values
#############################################################################

data(data.ma01, package="miceadds")
dat &lt;- data.ma01

dat1 &lt;- mdmb::offset_values_extract( formula=~ migrant + offset(books), data=dat )
dat1[1:5]
  ##  [1] 6 6 5 2 6
</code></pre>

<hr>
<h2 id='oprobit_dist'>
Ordinal Probit Models
</h2><span id='topic+oprobit_dist'></span><span id='topic+doprobit'></span><span id='topic+fit_oprobit'></span><span id='topic+coef.fit_oprobit'></span><span id='topic+logLik.fit_oprobit'></span><span id='topic+summary.fit_oprobit'></span><span id='topic+vcov.fit_oprobit'></span>

<h3>Description</h3>

<p>Fits and evaluates the ordinal probit model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>#---- ordinal probit model
doprobit(x, thresh, max_val=99)

fit_oprobit(x, par_init=NULL, weights=NULL)
## S3 method for class 'fit_oprobit'
coef(object, ...)
## S3 method for class 'fit_oprobit'
logLik(object, ...)
## S3 method for class 'fit_oprobit'
summary(object, digits=4, file=NULL, ...)
## S3 method for class 'fit_oprobit'
vcov(object, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oprobit_dist_+3A_x">x</code></td>
<td>

<p>Numeric vector
</p>
</td></tr>
<tr><td><code id="oprobit_dist_+3A_thresh">thresh</code></td>
<td>

<p>Vector of thresholds
</p>
</td></tr>
<tr><td><code id="oprobit_dist_+3A_max_val">max_val</code></td>
<td>
<p>Maximum value for computing thresholds</p>
</td></tr>
<tr><td><code id="oprobit_dist_+3A_par_init">par_init</code></td>
<td>
<p>Optional vector of initial parameters</p>
</td></tr>
<tr><td><code id="oprobit_dist_+3A_weights">weights</code></td>
<td>
<p>Optional vector of sampling weights</p>
</td></tr>
<tr><td><code id="oprobit_dist_+3A_object">object</code></td>
<td>
<p>Object of class <code>fit_yjt_scaled</code> or <code>fit_t_scaled</code></p>
</td></tr>
<tr><td><code id="oprobit_dist_+3A_digits">digits</code></td>
<td>
<p>Number of digits used for rounding in <code>summary</code></p>
</td></tr>
<tr><td><code id="oprobit_dist_+3A_file">file</code></td>
<td>
<p>File name for the <code>summary</code> to be sunk into</p>
</td></tr>
<tr><td><code id="oprobit_dist_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector or an object of fitted distribution depending on the called function
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+oprobit_regression">oprobit_regression</a></code> for fitting a regression model in which
the response variable follows an ordinal probit model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Fit an ordinal probit distribution
#############################################################################

#-- simulate data
set.seed(987)
N &lt;- 1500
# define thresholds
thresh &lt;- c(0,.3, .7, 1.6)
# latent continuous data
yast &lt;- stats::rnorm(N)
# discretized ordinal data
x &lt;- as.numeric( cut( yast, c(-Inf,thresh,Inf) ) ) - 1

#-- fit ordinal probit distribution
mod &lt;- mdmb::fit_oprobit(x=x)
summary(mod)
logLik(mod)
vcov(mod)
</code></pre>

<hr>
<h2 id='remove_NA_data_frame'>
Removes Rows with Some Missing Entries in a Data Frame
</h2><span id='topic+remove_NA_data_frame'></span>

<h3>Description</h3>

<p>Removes rows with some missing entries in a data frame for variables
appearing in the <span class="rlang"><b>R</b></span> formula <code>formula</code>. This operation is also
known as listwise deletion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_NA_data_frame(formula, data, weights=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_NA_data_frame_+3A_formula">formula</code></td>
<td>

<p>An <span class="rlang"><b>R</b></span> formula
</p>
</td></tr>
<tr><td><code id="remove_NA_data_frame_+3A_data">data</code></td>
<td>

<p>Data frame
</p>
</td></tr>
<tr><td><code id="remove_NA_data_frame_+3A_weights">weights</code></td>
<td>

<p>Optional vector of sample weights
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with some rows removed according to missing data
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.matrix">stats::model.matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Removing rows in a data frame (listwise deletion)
#############################################################################

data(data.ma01, package="miceadds")
dat &lt;- data.ma01

#*** remove rows with some missings according to a formula
dat1 &lt;- mdmb::remove_NA_data_frame( formula=read ~ migrant + books, data=dat)

#*** remove rows according to two formulas
formula1 &lt;- read ~ migrant + books
formula2 &lt;- paredu ~ migrant + female
# create formula consisting of formula1 and formula2
formula3 &lt;- paste( "~", deparse(formula1[[2]]), "+", deparse(formula1[[3]]),
             " + ", deparse(formula2[[2]]), "+", deparse(formula2[[3]])  )
dat2 &lt;- mdmb::remove_NA_data_frame( formula=as.formula(formula3), data=dat)

dim(dat)
dim(dat1$data)
dim(dat2$data)
  ##  &gt; dim(dat)
  ##  [1] 4073   11
  ##  &gt; dim(dat1$data)
  ##  [1] 3371   11
  ##  &gt; dim(dat2$data)
  ##  [1] 3090   11
</code></pre>

<hr>
<h2 id='yjt_dist'>
Scaled <code class="reqn">t</code> Distribution with Yeo-Johnson and Box-Cox Transformations
</h2><span id='topic+yjt_dist'></span><span id='topic+yj_trafo'></span><span id='topic+yj_antitrafo'></span><span id='topic+dt_scaled'></span><span id='topic+rt_scaled'></span><span id='topic+fit_t_scaled'></span><span id='topic+coef.fit_t_scaled'></span><span id='topic+logLik.fit_t_scaled'></span><span id='topic+summary.fit_t_scaled'></span><span id='topic+vcov.fit_t_scaled'></span><span id='topic+dyjt_scaled'></span><span id='topic+ryjt_scaled'></span><span id='topic+fit_yjt_scaled'></span><span id='topic+coef.fit_yjt_scaled'></span><span id='topic+logLik.fit_yjt_scaled'></span><span id='topic+summary.fit_yjt_scaled'></span><span id='topic+vcov.fit_yjt_scaled'></span><span id='topic+bc_trafo'></span><span id='topic+bc_antitrafo'></span><span id='topic+dbct_scaled'></span><span id='topic+rbct_scaled'></span><span id='topic+fit_bct_scaled'></span><span id='topic+coef.fit_bct_scaled'></span><span id='topic+logLik.fit_bct_scaled'></span><span id='topic+summary.fit_bct_scaled'></span><span id='topic+vcov.fit_bct_scaled'></span>

<h3>Description</h3>

<p>Collection of functions for the Yeo-Johnson transformation
(Yeo &amp; Johnson, 2000) and the corresponding distribution family of scaled
<code class="reqn">t</code> distribution with and without Yeo-Johnson transformation
(see Details). The Yeo-Johnson transformation can also be applied for bounded variables
on <code class="reqn">(0,1)</code> which uses a probit transformation (see Details; argument <code>probit</code>).
</p>
<p>The Box-Cox transformation (<code>bc</code>; Sakia, 1992)
can be applied for variables with positive values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># Yeo-Johnson transformation and its inverse transformation
yj_trafo(y, lambda, use_rcpp=TRUE, probit=FALSE)
yj_antitrafo(y, lambda, probit=FALSE)

#---- scaled t distribution with Yeo-Johnson transformation
dyjt_scaled(x, location=0, shape=1, lambda=1, df=Inf, log=FALSE, probit=FALSE)
ryjt_scaled(n, location=0, shape=1, lambda=1, df=Inf, probit=FALSE)

fit_yjt_scaled(x, df=Inf, par_init=NULL, lambda_fixed=NULL, weights=NULL, probit=FALSE)
## S3 method for class 'fit_yjt_scaled'
coef(object, ...)
## S3 method for class 'fit_yjt_scaled'
logLik(object, ...)
## S3 method for class 'fit_yjt_scaled'
summary(object, digits=4, file=NULL, ...)
## S3 method for class 'fit_yjt_scaled'
vcov(object, ...)

# Box-Cox transformation and its inverse transformation
bc_trafo(y, lambda)
bc_antitrafo(y, lambda)

#---- scaled t distribution with Box-Cox transformation
dbct_scaled(x, location=0, shape=1, lambda=1, df=Inf, log=FALSE, check_zero=TRUE)
rbct_scaled(n, location=0, shape=1, lambda=1, df=Inf)

fit_bct_scaled(x, df=Inf, par_init=NULL, lambda_fixed=NULL, weights=NULL)
## S3 method for class 'fit_bct_scaled'
coef(object, ...)
## S3 method for class 'fit_bct_scaled'
logLik(object, ...)
## S3 method for class 'fit_bct_scaled'
summary(object, digits=4, file=NULL, ...)
## S3 method for class 'fit_bct_scaled'
vcov(object, ...)

#---- scaled t distribution
dt_scaled(x, location=0, shape=1, df=Inf, log=FALSE)
rt_scaled(n, location=0, shape=1, df=Inf)

fit_t_scaled(x, df=Inf, par_init=NULL, weights=NULL)
## S3 method for class 'fit_t_scaled'
coef(object, ...)
## S3 method for class 'fit_t_scaled'
logLik(object, ...)
## S3 method for class 'fit_t_scaled'
summary(object, digits=4, file=NULL, ...)
## S3 method for class 'fit_t_scaled'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="yjt_dist_+3A_y">y</code></td>
<td>

<p>Numeric vector
</p>
</td></tr>
<tr><td><code id="yjt_dist_+3A_lambda">lambda</code></td>
<td>

<p>Transformation parameter <code class="reqn">\lambda</code> for Yeo-Johnson transformation
</p>
</td></tr>
<tr><td><code id="yjt_dist_+3A_use_rcpp">use_rcpp</code></td>
<td>
<p>Logical indicating whether <span class="pkg">Rcpp</span> package should be used</p>
</td></tr>
<tr><td><code id="yjt_dist_+3A_probit">probit</code></td>
<td>
<p>Logical indicating whether probit transformation should be
applied for bounded variables on <code class="reqn">(0,1)</code></p>
</td></tr>
<tr><td><code id="yjt_dist_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="yjt_dist_+3A_location">location</code></td>
<td>
<p>Location parameter of (transformed) scaled <code class="reqn">t</code> distribution</p>
</td></tr>
<tr><td><code id="yjt_dist_+3A_shape">shape</code></td>
<td>
<p>Shape parameter of (transformed) scaled <code class="reqn">t</code> distribution</p>
</td></tr>
<tr><td><code id="yjt_dist_+3A_df">df</code></td>
<td>
<p>Degrees of freedom of (transformed) scaled <code class="reqn">t</code> distribution</p>
</td></tr>
<tr><td><code id="yjt_dist_+3A_log">log</code></td>
<td>
<p>Logical indicating whether logarithm of the density should be
computed</p>
</td></tr>
<tr><td><code id="yjt_dist_+3A_check_zero">check_zero</code></td>
<td>
<p>Logical indicating whether check for inadmissible values
should be conducted</p>
</td></tr>
<tr><td><code id="yjt_dist_+3A_n">n</code></td>
<td>
<p>Number of observations to be simulated</p>
</td></tr>
<tr><td><code id="yjt_dist_+3A_par_init">par_init</code></td>
<td>
<p>Optional vector of initial parameters</p>
</td></tr>
<tr><td><code id="yjt_dist_+3A_lambda_fixed">lambda_fixed</code></td>
<td>
<p>Optional value for fixed <code class="reqn">\lambda</code> parameter</p>
</td></tr>
<tr><td><code id="yjt_dist_+3A_weights">weights</code></td>
<td>
<p>Optional vector of sampling weights</p>
</td></tr>
<tr><td><code id="yjt_dist_+3A_object">object</code></td>
<td>
<p>Object of class <code>fit_yjt_scaled</code> or <code>fit_t_scaled</code></p>
</td></tr>
<tr><td><code id="yjt_dist_+3A_digits">digits</code></td>
<td>
<p>Number of digits used for rounding in <code>summary</code></p>
</td></tr>
<tr><td><code id="yjt_dist_+3A_file">file</code></td>
<td>
<p>File name for the <code>summary</code> to be sunk into</p>
</td></tr>
<tr><td><code id="yjt_dist_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">g_\lambda</code> be the Yeo-Johnson transformation. A random variable <code class="reqn">X</code>
is distribution as Scaled <code class="reqn">t</code> with Yeo-Johnson transformation with location
<code class="reqn">\mu</code>, scale <code class="reqn">\sigma</code> and transformation parameter <code class="reqn">\lambda</code>
iff <code class="reqn">X=g_\lambda ( \mu + \sigma Z ) </code> and <code class="reqn">Z</code> is <code class="reqn">t</code> distributed
with <code>df</code> degrees of freedom.
</p>
<p>For a bounded variable <code class="reqn">X</code> on <code class="reqn">(0,1)</code>, the probit transformation <code class="reqn">\Phi</code>
is applied such that <code class="reqn">X=\Phi( g_\lambda ( \mu + \sigma Z ) ) </code> with a <code class="reqn">t</code>
distributed variable <code class="reqn">Z</code>.
</p>
<p>For a Yeo-Johnson normally distributed variable, a normally distributed variable results in
case of <code class="reqn">\lambda=1</code>. For a Box-Cox normally distributed variable, a normally
distributed variable results for <code class="reqn">\lambda=1</code>.
</p>


<h3>Value</h3>

<p>Vector or an object of fitted distribution depending on the called function
</p>


<h3>References</h3>

<p>Sakia, S. M. (1992). The Box-Cox transformation technique: A review.
<em>The Statistician, 41</em>(2), 169-178.
doi: <a href="https://doi.org/10.2307/2348250">10.2307/2348250</a>
</p>
<p>Yeo, I.-K., &amp; Johnson, R. (2000). A new family of power transformations to
improve normality or symmetry. <em>Biometrika, 87</em>(4), 954-959.
doi: <a href="https://doi.org/10.1093/biomet/87.4.954">10.1093/biomet/87.4.954</a>
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+yjt_regression">yjt_regression</a></code> for fitting a regression model in which
the response variable is distributed according to the scaled <code class="reqn">t</code>
distribution with Yeo-Johnson transformation.
</p>
<p>See <code>car::yjPower</code> for fitting the Yeo-Johnson
transformation in the <span class="pkg">car</span> package. See <code>car::bcPower</code> for the
Box-Cox transformation.
</p>
<p>The scaled <code class="reqn">t</code> distribution can be also found in
<code>metRology::dt.scaled</code> (<span class="pkg">metRology</span> package).
</p>
<p>See <code><a href="stats.html#topic+dt">stats::dt</a></code> for the <code class="reqn">t</code> distribution.
</p>
<p>See the <span class="pkg">fitdistrplus</span> package or the general
<code><a href="stats4.html#topic+mle">stats4::mle</a></code> function
for fitting several distributions in <span class="rlang"><b>R</b></span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################################
# EXAMPLE 1: Transforming values according to Yeo-Johnson transformation
#############################################################################

# vector of y values
y &lt;- seq(-3,3, len=100)

# non-negative lambda values
plot( y, mdmb::yj_trafo( y, lambda=1 ), type="l", ylim=8*c(-1,1),
           ylab=expression( g[lambda] (y) ) )
lines( y, mdmb::yj_trafo( y, lambda=2 ), lty=2 )
lines( y, mdmb::yj_trafo( y, lambda=.5 ), lty=3 )
lines( y, mdmb::yj_trafo( y, lambda=0 ), lty=4 )

# non-positive lambda values
plot( y, mdmb::yj_trafo( y, lambda=-1 ), type="l", ylim=8*c(-1,1),
           ylab=expression(g[lambda] (y) ) )
lines( y, mdmb::yj_trafo( y, lambda=-2 ), lty=2 )
lines( y, mdmb::yj_trafo( y, lambda=-.5 ), lty=3 )
lines( y, mdmb::yj_trafo( y, lambda=0 ), lty=4 )

## Not run: 
#############################################################################
# EXAMPLE 2: Density of scaled t distribution
#############################################################################

# define location and scale parameter
m0 &lt;- 0.3
sig &lt;- 1.5
#-- compare density of scaled t distribution with large degrees of freedom
#   with normal distribution
y1 &lt;- mdmb::dt_scaled( y, location=m0, shape=sig, df=100 )
y2 &lt;- stats::dnorm( y, mean=m0, sd=sig )
max(abs(y1-y2))

#############################################################################
# EXAMPLE 3: Simulating and fitting the scaled t distribution
#############################################################################

#-- simulate data with 10 degrees of freedom
set.seed(987)
df0 &lt;- 10    # define degrees of freedom
x &lt;- mdmb::rt_scaled( n=1E4, location=m0, shape=sig, df=df0 )
#** fit data with df=10 degrees of freedom
fit1 &lt;- mdmb::fit_t_scaled(x=x, df=df0 )
#** compare with fit from normal distribution
fit2 &lt;- mdmb::fit_t_scaled(x=x, df=Inf )  # df=Inf is the default

#-- some comparisons
coef(fit1)
summary(fit1)
logLik(fit1)
AIC(fit1)
AIC(fit2)

#############################################################################
# EXAMPLE 4: Simulation and fitting of scaled t distribution with
#            Yeo-Johnson transformation
#############################################################################

# define parameters of transformed scaled t distribution
m0 &lt;- .5
sig &lt;- 1.5
lam &lt;- .5

# evaluate density
x &lt;- seq( -5, 5, len=100 )
y &lt;- mdmb::dyjt_scaled( x, location=m0, shape=sig, lambda=lam )
graphics::plot( x, y, type="l")

# transform original values
mdmb::yj_trafo( y=x, lambda=lam )

#** simulate data
set.seed(987)
x &lt;- mdmb::ryjt_scaled(n=3000, location=m0, shape=sig, lambda=lam )
graphics::hist(x, breaks=30)

#*** Model 1: Fit data with lambda to be estimated
fit1 &lt;- mdmb::fit_yjt_scaled(x=x)
summary(fit1)
coef(fit1)

#*** Model 2: Fit data with lambda fixed to simulated lambda
fit2 &lt;- mdmb::fit_yjt_scaled(x=x, lambda_fixed=lam)
summary(fit2)
coef(fit2)

#*** Model 3: Fit data with lambda fixed to 1
fit3 &lt;- mdmb::fit_yjt_scaled(x=x, lambda_fixed=1)

#-- compare log-likelihood values
logLik(fit1)
logLik(fit2)
logLik(fit3)

#############################################################################
# EXAMPLE 5: Approximating the chi square distribution
#            with yjt and bct distribution
#############################################################################

#-- simulate data
set.seed(987)
n &lt;- 3000
df0 &lt;- 5
x &lt;- stats::rchisq( n=n, df=df0 )

#-- plot data
graphics::hist(x, breaks=30)

#-- fit data with yjt distribution
fit1 &lt;- mdmb::fit_yjt_scaled(x)
summary(fit1)
c1 &lt;- coef(fit1)

#-- fit data with bct distribution
fit2 &lt;- mdmb::fit_bct_scaled(x)
summary(fit2)
c2 &lt;- coef(fit2)
# compare log-likelihood values
logLik(fit1)
logLik(fit2)

#-- plot chi square distribution and approximating yjt distribution
y &lt;- seq( .01, 3*df0, len=100 )
dy &lt;- stats::dchisq( y, df=df0 )
graphics::plot( y, dy, type="l", ylim=c(0, max(dy) )*1.1 )
# approximation with scaled t distribution and Yeo-Johnson transformation
graphics::lines( y, mdmb::dyjt_scaled(y, location=c1[1], shape=c1[2], lambda=c1[3]),
                     lty=2)
# approximation with scaled t distribution and Box-Cox transformation
graphocs::lines( y, mdmb::dbct_scaled(y, location=c2[1], shape=c2[2], lambda=c2[3]),
                     lty=3)
# appoximating normal distribution
graphics::lines( y, stats::dnorm( y, mean=df0, sd=sqrt(2*df0) ), lty=4)
graphics::legend( .6*max(y), .9*max(dy), c("chi square", "yjt", "bct", "norm"),
                     lty=1:4)

#############################################################################
# EXAMPLE 6: Bounded variable on (0,1) with Probit Yeo-Johnson transformation
#############################################################################

set.seed(876)
n &lt;- 1000
x &lt;- stats::rnorm(n)
y &lt;- stats::pnorm( 1*x + stats::rnorm(n, sd=sqrt(.5) ) )
dat &lt;- data.frame( y=y, x=x )

#*** fit Probit Yeo-Johnson distribution
mod1 &lt;- mdmb::fit_yjt_scaled(x=y, probit=TRUE)
summary(mod1)

#*** estimation using regression model
mod2 &lt;- mdmb::yjt_regression( y ~ x, data=dat, probit=TRUE )
summary(mod2)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
