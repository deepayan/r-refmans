<!DOCTYPE html><html lang="en"><head><title>Help for package RgoogleMaps</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RgoogleMaps}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AddAlpha'><p>add alpha level to color that lacks one</p></a></li>
<li><a href='#ColorMap'><p>Plot Levels of a Variable in a Colour-Coded Map</p></a></li>
<li><a href='#columbus'><p>Columbus OH spatial analysis data set</p></a></li>
<li><a href='#degreeAxis'><p>axis with degrees</p></a></li>
<li><a href='#genStaticMap'><p>generates a &quot;static map&quot; from map tiles by &quot;stitching&quot; them together</p></a></li>
<li><a href='#geosphere_mercator'><p>Transform longitude/latiude points to the Mercator projection.</p></a></li>
<li><a href='#GetBingMap'><p>download a static map from the Microsoft map tile server</p></a></li>
<li><a href='#getGeoCode'><p>geocoding utility</p></a></li>
<li><a href='#GetMap'><p>download a static map from the Google server</p></a></li>
<li><a href='#GetMap.bbox'><p>GetMap bbox</p></a></li>
<li><a href='#GetMapTiles'><p>download map tiles from specified map tile servers such as openstreetmap or Google</p></a></li>
<li><a href='#GetOsmMap'><p>Query the Open Street Map server for map tiles instead of Google Maps</p></a></li>
<li><a href='#IdentifyPoints'><p>identify points by clicking on map</p></a></li>
<li><a href='#incidents'><p>San Francisco crime data</p></a></li>
<li><a href='#LatLon2XY'><p>computes the coordinate transformation from lat/lon to map tile coordinates</p></a></li>
<li><a href='#LatLon2XY.centered'><p>computes the centered coordinate transformation from lat/lon to map tile coordinates</p></a></li>
<li><a href='#MapBackground'><p>get static Map from the Google server</p></a></li>
<li><a href='#MaxZoom'><p>computes the maximum zoom level which will contain the given lat/lon range</p></a></li>
<li><a href='#mypolygon'><p>simple wrapper function to plot colored polygons</p></a></li>
<li><a href='#NumTiles'><p>computes the necessary number of tiles from a bounding box and a zoom level</p></a></li>
<li><a href='#NYleukemia'><p>Upstate New York Leukemia Data</p></a></li>
<li><a href='#osmtile_bbox'><p>compute the bounding box of an OpenStreetmap tile</p></a></li>
<li><a href='#pennLC'><p>Pennsylvania Lung Cancer</p></a></li>
<li><a href='#PlotArrowsOnStaticMap'><p>plots arrows or segments on map</p></a></li>
<li><a href='#plotmap'><p>easy to use wrapper function</p></a></li>
<li><a href='#PlotOnMapTiles'><p>plots on map tiles by &quot;stitching&quot; them together</p></a></li>
<li><a href='#PlotOnStaticMap'><p>overlays plot on background image of map tile</p></a></li>
<li><a href='#plotOSM'><p>plots OSM map tiles</p></a></li>
<li><a href='#plotOSMtile'><p>plots a single OSM tile</p></a></li>
<li><a href='#PlotPolysOnStaticMap'><p>plots polygons on map</p></a></li>
<li><a href='#qbbox'><p>computes bounding box</p></a></li>
<li><a href='#ReadMapTile'><p>Read a bitmap image stored in the PNG format</p></a></li>
<li><a href='#RGB2GRAY'><p>translates an RGB image matrix to gray scale</p></a></li>
<li><a href='#sp_bbox'><p>computes bounding box</p></a></li>
<li><a href='#SpatialToPBS'><p>converts spatial objects as defined in package sp to simpler PBSmapping type dataframes</p></a></li>
<li><a href='#TextOnStaticMap'><p>plots text on map</p></a></li>
<li><a href='#Tile2R'><p>simple utility to offset and scale XY coordinates with respect to the center</p></a></li>
<li><a href='#updateusr'><p>Updates the 'usr' coordinates in the current plot.</p></a></li>
<li><a href='#XY2LatLon'><p>computes the centered coordinate transformation from lat/lon to map tile coordinates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Overlays on Static Maps</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-31</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats, utils, grDevices, methods, png</td>
</tr>
<tr>
<td>Suggests:</td>
<td>PBSmapping, RColorBrewer, leaflet, jpeg, RCurl</td>
</tr>
<tr>
<td>Author:</td>
<td>Markus Loecher </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/markusloecher/rgooglemaps/blob/master/rgooglemaps/www/QuickTutorial.html">https://github.com/markusloecher/rgooglemaps/blob/master/rgooglemaps/www/QuickTutorial.html</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Markus Loecher &lt;markus.loecher@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Serves two purposes: (i) Provide a
        comfortable R interface to query the Google server for static
        maps, and (ii) Use the map as a background image to overlay
        plots within R. This requires proper coordinate scaling.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-06 10:07:34 UTC; loecherm</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-06 12:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AddAlpha'>add alpha level to color that lacks one</h2><span id='topic+AddAlpha'></span>

<h3>Description</h3>

<p>add alpha level to color that lacks one</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddAlpha(plotclr, alpha = 0.5, verbose = 0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AddAlpha_+3A_plotclr">plotclr</code></td>
<td>
<p>color to be modified</p>
</td></tr>
<tr><td><code id="AddAlpha_+3A_alpha">alpha</code></td>
<td>
<p>alpha level</p>
</td></tr>
<tr><td><code id="AddAlpha_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modified color with alpha value</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>




#example: 


#require(RColorBrewer)


if (requireNamespace("RColorBrewer", quietly = TRUE)) {


  plotclr &lt;- RColorBrewer::brewer.pal(8,"YlOrRd")


  plotclr = AddAlpha(plotclr,0.5)


} else {


  print("package RColorBrewer must be installed for this example")


}





</code></pre>

<hr>
<h2 id='ColorMap'>Plot Levels of a Variable in a Colour-Coded Map</h2><span id='topic+ColorMap'></span>

<h3>Description</h3>

<p>Plot Levels of a Variable in a Colour-Coded Map</p>


<h3>Usage</h3>

<pre><code class='language-R'>ColorMap(values, map = NULL, polys = NULL, log = FALSE, 


    nclr = 7, include.legend = list(TRUE), round = 3, 


    brks = NULL, legend = NULL, location = "topright", 


    rev = FALSE, alpha = 0.5, GRAY = FALSE, palette = c("YlOrRd", 


        "RdYlGn", "Spectral")[1], textInPolys = NULL, 


    ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ColorMap_+3A_values">values</code></td>
<td>
<p>variable to plot</p>
</td></tr>
<tr><td><code id="ColorMap_+3A_map">map</code></td>
<td>
<p>map object</p>
</td></tr>
<tr><td><code id="ColorMap_+3A_polys">polys</code></td>
<td>
<p>an object of class SpatialPolygons (See <a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a></p>
</td></tr>
<tr><td><code id="ColorMap_+3A_log">log</code></td>
<td>
<p>boolean of whether to plot values on log scale</p>
</td></tr>
<tr><td><code id="ColorMap_+3A_nclr">nclr</code></td>
<td>
<p>number of colour-levels to use</p>
</td></tr>
<tr><td><code id="ColorMap_+3A_include.legend">include.legend</code></td>
<td>
<p>boolean of whether to include legend</p>
</td></tr>
<tr><td><code id="ColorMap_+3A_round">round</code></td>
<td>
<p>number of digits to round to in legend</p>
</td></tr>
<tr><td><code id="ColorMap_+3A_brks">brks</code></td>
<td>
<p>if desired, pre-specified breaks for legend</p>
</td></tr>
<tr><td><code id="ColorMap_+3A_legend">legend</code></td>
<td>
<p>if desired, a pre-specified legend</p>
</td></tr>
<tr><td><code id="ColorMap_+3A_location">location</code></td>
<td>
<p>location of legend</p>
</td></tr>
<tr><td><code id="ColorMap_+3A_rev">rev</code></td>
<td>
<p>boolean of whether to reverse colour scheme (darker colours for smaller values)</p>
</td></tr>
<tr><td><code id="ColorMap_+3A_alpha">alpha</code></td>
<td>
<p>alpha value of colors</p>
</td></tr>
<tr><td><code id="ColorMap_+3A_gray">GRAY</code></td>
<td>
<p>boolean: if TRUE, use gray scale instead</p>
</td></tr>
<tr><td><code id="ColorMap_+3A_palette">palette</code></td>
<td>
<p>palette to choose from RColorBrewer</p>
</td></tr>
<tr><td><code id="ColorMap_+3A_textinpolys">textInPolys</code></td>
<td>
<p>text to be displayed inside polygons. This can be a column names for values</p>
</td></tr>
<tr><td><code id="ColorMap_+3A_...">...</code></td>
<td>
<p>extra args to pass to <code>PlotPolysOnStaticMap</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  if (0){


    data("NYleukemia", envir = environment())


    population &lt;- NYleukemia$data$population


    cases &lt;- NYleukemia$data$cases


    mapNY &lt;- GetMap(center=c(lat=42.67456,lon=-76.00365), destfile = "NYstate.png", 


                    maptype = "mobile", zoom=9)


    ColorMap(100*cases/population, mapNY, NYleukemia$spatial.polygon, add = FALSE,


             alpha = 0.35, log = TRUE, location = "topleft")


}


  #ColorMap(100*cases/population, map=NULL, NYleukemia$spatial.polygon)


  


</code></pre>

<hr>
<h2 id='columbus'>Columbus OH spatial analysis data set</h2><span id='topic+columbus'></span><span id='topic+col.gal.nb'></span><span id='topic+coords'></span><span id='topic+polys'></span><span id='topic+bbs'></span>

<h3>Description</h3>

<p>The <code>columbus</code> data frame has 49 rows and 22 columns.
Unit of analysis: 49 neighbourhoods in Columbus, OH, 1980 data.
In addition the data set includes a <code>polylist</code> object <code>polys</code>
with the boundaries of the neighbourhoods, a matrix of polygon centroids
<code>coords</code>, and <code>col.gal.nb</code>, the neighbours list
from an original GAL-format file. The matrix <code>bbs</code> is DEPRECATED, but retained for other packages using this data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(columbus)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>AREA</dt><dd><p>computed by ArcView</p>
</dd>
<dt>PERIMETER</dt><dd><p>computed by ArcView</p>
</dd>
<dt>COLUMBUS.</dt><dd><p>internal polygon ID (ignore)</p>
</dd>
<dt>COLUMBUS.I</dt><dd><p>another internal polygon ID (ignore)</p>
</dd>
<dt>POLYID</dt><dd><p>yet another polygon ID</p>
</dd>
<dt>NEIG</dt><dd><p>neighborhood id value (1-49);
conforms to id value used in Spatial Econometrics book.</p>
</dd>
<dt>HOVAL</dt><dd><p>housing value (in $1,000)</p>
</dd>
<dt>INC</dt><dd><p>household income (in $1,000)</p>
</dd>
<dt>CRIME</dt><dd><p>residential burglaries and vehicle thefts per thousand
households in the neighborhood</p>
</dd>
<dt>OPEN</dt><dd><p>open space in neighborhood</p>
</dd>
<dt>PLUMB</dt><dd><p>percentage housing units without plumbing</p>
</dd>
<dt>DISCBD</dt><dd><p>distance to CBD</p>
</dd>
<dt>X</dt><dd><p>x coordinate (in arbitrary digitizing units, not polygon coordinates)</p>
</dd>
<dt>Y</dt><dd><p>y coordinate (in arbitrary digitizing units, not polygon coordinates)</p>
</dd>
<dt>NSA</dt><dd><p>north-south dummy (North=1)</p>
</dd>
<dt>NSB</dt><dd><p>north-south dummy (North=1)</p>
</dd>
<dt>EW</dt><dd><p>east-west dummy (East=1)</p>
</dd>
<dt>CP</dt><dd><p>core-periphery dummy (Core=1)</p>
</dd>
<dt>THOUS</dt><dd><p>constant=1,000</p>
</dd>
<dt>NEIGNO</dt><dd><p>NEIG+1,000, alternative neighborhood id value</p>
</dd>
</dl>



<h3>Details</h3>

<p>The row names of <code>columbus</code> and the <code>region.id</code> attribute of
<code>polys</code> are set to <code>columbus$NEIGNO</code>.
</p>


<h3>Note</h3>

<p>All source data files prepared by
Luc Anselin, Spatial Analysis Laboratory, Department of Agricultural and Consumer Economics, University of Illinois, Urbana-Champaign.
</p>


<h3>Source</h3>

<p>Anselin, Luc.  1988.  Spatial econometrics: methods and
models.  Dordrecht: Kluwer Academic, Table 12.1 p. 189.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#library(maptools)
#columbus &lt;- readShapePoly(system.file("etc/shapes/columbus.shp",
# package="spdep")[1])
#col.gal.nb &lt;- read.gal(system.file("etc/weights/columbus.gal",
# package="spdep")[1])
</code></pre>

<hr>
<h2 id='degreeAxis'>axis with degrees</h2><span id='topic+degreeAxis'></span>

<h3>Description</h3>

<p>add an axis with degree labels</p>


<h3>Usage</h3>

<pre><code class='language-R'>degreeAxis(side, at = NULL, labels, MyMap, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="degreeAxis_+3A_side">side</code></td>
<td>
<p>integer; see <a href="graphics.html#topic+axis">axis</a></p>
</td></tr>
<tr><td><code id="degreeAxis_+3A_at">at</code></td>
<td>
<p>numeric; if missing, <a href="graphics.html#topic+axTicks">axTicks</a> is called for nice values; see <a href="graphics.html#topic+axis">axis</a></p>
</td></tr>
<tr><td><code id="degreeAxis_+3A_labels">labels</code></td>
<td>
<p>character; if omitted labels are constructed with degree symbols, ending in N/S/E/W; in case of negative degrees, sign is reversed and S or W is added; see <a href="graphics.html#topic+axis">axis</a></p>
</td></tr>
<tr><td><code id="degreeAxis_+3A_mymap">MyMap</code></td>
<td>
<p>optional map object to be passed</p>
</td></tr>
<tr><td><code id="degreeAxis_+3A_...">...</code></td>
<td>
<p>optional arguments to <a href="graphics.html#topic+axis">axis</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>axis is plotted on current graph</p>


<h3>Note</h3>

<p>decimal degrees are used if variation is small, instead of minutes and seconds</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>

xy = cbind(x = 2 * runif(100) - 1, y = 2 * runif(100) - 1)


plot(xy,xlim=c(-1,1),ylim=c(-1,1))


degreeAxis(1)


degreeAxis(2, at = c(-1,-0.5,0,0.5,1))


</code></pre>

<hr>
<h2 id='genStaticMap'>generates a &quot;static map&quot; from map tiles by &quot;stitching&quot; them together</h2><span id='topic+genStaticMap'></span>

<h3>Description</h3>

<p>necssary because the Google static maps API requires a key now</p>


<h3>Usage</h3>

<pre><code class='language-R'>genStaticMap(center, zoom = 15, size = c(640, 640), 


    destfile = tempfile("staticMap", fileext = ".png"), 


    type = c("google", "google-m", "google-s", "osm", 


        "osm-hot", "stamen-toner", "stamen-terrain", 


        "stamen-watercolor")[1], urlBase = "http://mt1.google.com/vt/lyrs=m", 


    tileDir = "/tmp/", tileExt = ".png", verbose = 0, 


    ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genStaticMap_+3A_center">center</code></td>
<td>
<p>optional center</p>
</td></tr>
<tr><td><code id="genStaticMap_+3A_zoom">zoom</code></td>
<td>
<p>zoom</p>
</td></tr>
<tr><td><code id="genStaticMap_+3A_size">size</code></td>
<td>
<p>size (in pixels) of &quot;stitched&quot; map</p>
</td></tr>
<tr><td><code id="genStaticMap_+3A_destfile">destfile</code></td>
<td>
<p>File to load the map image from or save to, depending on <code>NEWMAP</code>.</p>
</td></tr>
<tr><td><code id="genStaticMap_+3A_type">type</code></td>
<td>
<p>choice of tile server</p>
</td></tr>
<tr><td><code id="genStaticMap_+3A_urlbase">urlBase</code></td>
<td>
<p>tileserver URL, alternatives would be &quot;http://a.tile.openstreetmap.org/&quot;, &quot;http://tile.stamen.com/toner/&quot;,&quot;http://tile.stamen.com/watercolor/&quot;</p>
</td></tr>
<tr><td><code id="genStaticMap_+3A_tiledir">tileDir</code></td>
<td>
<p>map tiles can be stored in a local directory, e.g. &quot;~/mapTiles/Google/&quot;</p>
</td></tr>
<tr><td><code id="genStaticMap_+3A_tileext">tileExt</code></td>
<td>
<p>image type of tile</p>
</td></tr>
<tr><td><code id="genStaticMap_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
<tr><td><code id="genStaticMap_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with tiles</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>




if (0){


  lat = c(40.702147,40.718217,40.711614);


  lon = c(-74.012318,-74.015794,-73.998284);


  center = c(mean(lat), mean(lon));


  zoom &lt;- min(MaxZoom(range(lat), range(lon)));


  bb=qbbox(lat,lon)


  


  mt = GetMapTiles(latR =bb$latR , lonR=bb$lonR,zoom=zoom,verbose=1)


  PlotOnMapTiles(mt,lat=lat,lon=lon,pch=20,col=c('red', 'blue', 'green'),cex=2)


  


  mt = GetMapTiles(latR =bb$latR , lonR=bb$lonR,zoom=zoom,


                   tileDir= "~/mapTiles/Google/")


  PlotOnMapTiles(mt,lat=lat,lon=lon,pch=20,col=c('red', 'blue', 'green'),cex=2)


  


}


</code></pre>

<hr>
<h2 id='geosphere_mercator'>Transform longitude/latiude points to the Mercator projection. </h2><span id='topic+geosphere_mercator'></span>

<h3>Description</h3>

<p>From <code>geosphere::mercator</code></p>


<h3>Usage</h3>

<pre><code class='language-R'>geosphere_mercator(p, inverse = FALSE, r = 6378137)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geosphere_mercator_+3A_p">p</code></td>
<td>
<p>longitude/latitude of point(s). Can be a vector of two numbers, a matrix of 2 columns (first one is longitude, second is latitude)</p>
</td></tr>
<tr><td><code id="geosphere_mercator_+3A_inverse">inverse</code></td>
<td>
<p>Logical. If TRUE, do the inverse projection (from Mercator to longitude/latitude</p>
</td></tr>
<tr><td><code id="geosphere_mercator_+3A_r">r</code></td>
<td>
<p>Numeric. Radius of the earth; default = 6378137 m</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mercator projection of lon/lat points</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>

<hr>
<h2 id='GetBingMap'>download a static map from the Microsoft map tile server</h2><span id='topic+GetBingMap'></span>

<h3>Description</h3>

<p>Query the Google server for a static map tile, defined primarily by its 
</p>
<p>center and zoom. Many additional arguments allow the user to customize 
</p>
<p>the map tile.</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetBingMap(center = c(lat = 42, lon = -76), mapArea = c(45.219, 


    -122.325, 47.61, -122.107), size = c(640, 640), 


    destfile, zoom = 12, markers, path = "", maptype = c("Road", 


        "Aerial", "AerialWithLabels")[1], format = c("png", 


        "gif", "jpg", "jpg-baseline", "png8", "png32")[1], 


    extraURL = "", RETURNIMAGE = TRUE, GRAYSCALE = FALSE, 


    NEWMAP = TRUE, SCALE = 1, apiKey = NULL, verbose = 0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetBingMap_+3A_center">center</code></td>
<td>
<p>optional center (lat first,lon second  )</p>
</td></tr>
<tr><td><code id="GetBingMap_+3A_maparea">mapArea</code></td>
<td>
<p>A rectangular area specified as a bounding box (ll,ur). Required when a center point or set of route points are not specified</p>
</td></tr>
<tr><td><code id="GetBingMap_+3A_size">size</code></td>
<td>
<p>desired size of the map tile image. defaults to maximum size returned by the Gogle server, which is 640x640 pixels</p>
</td></tr>
<tr><td><code id="GetBingMap_+3A_destfile">destfile</code></td>
<td>
<p>File to load the map image from or save to, depending on <code>NEWMAP</code>.</p>
</td></tr>
<tr><td><code id="GetBingMap_+3A_zoom">zoom</code></td>
<td>
<p>Google maps zoom level.</p>
</td></tr>
<tr><td><code id="GetBingMap_+3A_markers">markers</code></td>
<td>
<p>(optional) defines one or more markers to attach to the image at specified locations. This parameter takes a string of marker definitions separated by the pipe character (|)</p>
</td></tr>
<tr><td><code id="GetBingMap_+3A_path">path</code></td>
<td>
<p>(optional) defines a single path of two or more connected points to overlay on the image at specified locations. This parameter takes a string of point definitions separated by the pipe character (|)</p>
</td></tr>
<tr><td><code id="GetBingMap_+3A_maptype">maptype</code></td>
<td>
<p>defines the type of map to construct. See https://msdn.microsoft.com/en-us/library/ff701724.aspx</p>
</td></tr>
<tr><td><code id="GetBingMap_+3A_format">format</code></td>
<td>
<p>(optional) defines the format of the resulting image. By default, the Static Maps API creates GIF images. There are several possible formats including GIF, JPEG and PNG types. Which format you use depends on how you intend to present the image. JPEG typically provides greater compression, while GIF and PNG provide greater detail. This version supports only PNG.</p>
</td></tr>
<tr><td><code id="GetBingMap_+3A_extraurl">extraURL</code></td>
<td>
<p>custom URL suffix</p>
</td></tr>
<tr><td><code id="GetBingMap_+3A_returnimage">RETURNIMAGE</code></td>
<td>
<p>return image yes/no default: TRUE</p>
</td></tr>
<tr><td><code id="GetBingMap_+3A_grayscale">GRAYSCALE</code></td>
<td>
<p>Boolean toggle; if TRUE the colored map tile is rendered into a black &amp; white image, see <a href="#topic+RGB2GRAY">RGB2GRAY</a></p>
</td></tr>
<tr><td><code id="GetBingMap_+3A_newmap">NEWMAP</code></td>
<td>
<p>if TRUE, query the Google server and save to <code>destfile</code>, if FALSE load from destfile.</p>
</td></tr>
<tr><td><code id="GetBingMap_+3A_scale">SCALE</code></td>
<td>
<p>use the API's scale parameter to return higher-resolution map images. The scale value is multiplied with the size to determine the actual output size of the image in pixels, without changing the coverage area of the map</p>
</td></tr>
<tr><td><code id="GetBingMap_+3A_apikey">apiKey</code></td>
<td>
<p>optional API key (allows for higher rate of downloads)</p>
</td></tr>
<tr><td><code id="GetBingMap_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>map structure or URL used to download the tile.</p>


<h3>Note</h3>

<p>Note that size is in order (lon, lat)</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>See Also</h3>

<p><a href="#topic+GetMap.bbox">GetMap.bbox</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>




if (0){


  #for bing maps you will need your own API key, 


  #sign up at https://msdn.microsoft.com/en-us/library/ff428642.aspx


  apiKey = scan("bingAPIkey.txt",what="")


  map1=GetBingMap(center=c(47.619048,-122.35384),zoom=15,apiKey=apiKey, 


                  verbose=1, destfile="Seattle.png") 


  PlotOnStaticMap(map1)


  m="&amp;pp=47.620495,-122.34931;21;AA&amp;pp=47.619385,-122.351485;;AB&amp;pp=47.616295,-122.3556;22"


  map2=GetBingMap(center=c(47.619048,-122.35384),zoom=15,markers=m,apiKey=apiKey, 


                  verbose=1, destfile="Seattle2.png")


  


  PlotOnStaticMap(map2,lat=c(47.620495,47.619385,47.616295),


                  lon=c(-122.34931,-122.351485,-122.3556))


  	


  m="&amp;pp=49.28273,-123.12074;22&amp;pp=44.05207,-123.08675;22"


  


  map3= GetBingMap(center=c(47.677006,-122.125526),zoom=6,markers=m,apiKey=apiKey,


                   verbose=1, destfile="Seattle2.png")


  #plotmap(map=map3)


  m=cbind.data.frame(lat=c(49.28273,44.05207),lon=c(-123.12074,-123.08675),col=c(3:4))


  PlotOnStaticMap(map3, lat =m$lat,lon=m$lon,col=m$col,pch=19)


  


  #overlay traffic:


  #Get a map with Road imagery and traffic flow based on a query.


  #This example gets a map with road imagery based on a query result Bellevue, Washington. 


  #Traffic flow is also included on the map.


  


  #http://dev.virtualearth.net/REST/V1/Imagery/Map/Road/Bellevue%20Washington


  #?mapLayer=TrafficFlow&amp;key=BingMapsKey


  #note that we are using the extraURL argument to pass any extra parameters:


  map4 = GetBingMap(center="Bellevue%20Washington", zoom=12, extraURL="&amp;mapLayer=TrafficFlow", 


                    apiKey=apiKey,verbose=1, destfile="BellevueTraffic.png")


  PlotOnStaticMap(map4)


  


  #Get a map with Road imagery that displays a route.


  #This example gets a map with road imagery that displays a driving 


  #route between the cities of Seattle and Redmond in Washington State. 


  


  #note that we are using the extraURL argument to pass any extra parameters:


  #http://dev.virtualearth.net/REST/v1/Imagery/Map/Road/Routes


  #?wp.0=Seattle,WA;64;1&amp;wp.1=Redmond,WA;66;2&amp;key=BingMapsKey 


  map5 = GetBingMap(center="Bellevue%20Washington", zoom=8, 


                    extraURL="&amp;Routes?wp.0=Seattle,WA;64;1&amp;wp.1=Redmond,WA;66;2", 


                  apiKey=apiKey,verbose=1, destfile="Seattle2Redmond.png")


  PlotOnStaticMap(map5)


}


</code></pre>

<hr>
<h2 id='getGeoCode'>geocoding utility</h2><span id='topic+getGeoCode'></span>

<h3>Description</h3>

<p>Geocode your data using, R, JSON and OSM or Google Maps' Geocoding APIs </p>


<h3>Usage</h3>

<pre><code class='language-R'>getGeoCode(gcStr, API = c("osm", "google")[1], JSON = FALSE, 


    verbose = 0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getGeoCode_+3A_gcstr">gcStr</code></td>
<td>
<p>adddress to geocode</p>
</td></tr>
<tr><td><code id="getGeoCode_+3A_api">API</code></td>
<td>
<p>which API to use. see https://nominatim.org/release-docs/develop/api/Search/ and http://allthingsr.blogspot.de/2012/01/geocode-your-data-using-r-json-and.html</p>
</td></tr>
<tr><td><code id="getGeoCode_+3A_json">JSON</code></td>
<td>
<p>use the JSON protocol. If FALSE, we do not have to load additional libraries</p>
</td></tr>
<tr><td><code id="getGeoCode_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns lat/lon for address</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (0){


  getGeoCode("1600 Amphitheatre Parkway, Mountain View, CA")


  getGeoCode("Brooklyn")


  #You can run this on the entire column of a data frame or a data table:


  DF = cbind.data.frame(address=c("Berlin,Germany", "Princeton,NJ", 


            "cadillac+mountain+acadia+national+park"), lat = NA, lon = NA)


  DF &lt;- with(DF, data.frame(address, t(sapply(DF$address, getGeoCode))))


}


</code></pre>

<hr>
<h2 id='GetMap'>download a static map from the Google server</h2><span id='topic+GetMap'></span>

<h3>Description</h3>

<p>Query the Google server for a static map tile, defined primarily by its 
</p>
<p>center and zoom. Many additional arguments allow the user to customize 
</p>
<p>the map tile.
</p>
<p>documentation at https://developers.google.com/maps/documentation/staticmaps/</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetMap(center = c(lat = 42, lon = -76), size = c(640, 


    640), destfile = tempfile("staticMap", fileext = ".png"), 


    zoom = 12, markers, path = "", span, frame, hl, 


    sensor = "true", maptype = c("roadmap", "mobile", 


        "satellite", "terrain", "hybrid", "mapmaker-roadmap", 


        "mapmaker-hybrid")[2], format = c("gif", "jpg", 


        "jpg-baseline", "png8", "png32")[5], extraURL = "", 


    RETURNIMAGE = TRUE, GRAYSCALE = FALSE, NEWMAP = TRUE, 


    SCALE = 1, API_console_key, type = c("google", 


        "google-m", "google-s", "osm", "osm-hot", "stamen-toner", 


        "stamen-terrain", "stamen-watercolor")[1], 


    urlBase = "http://mt1.google.com/vt/lyrs=m", tileDir = "/tmp/", 


    verbose = 0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetMap_+3A_center">center</code></td>
<td>
<p>optional center (lat first,lon second  )</p>
</td></tr>
<tr><td><code id="GetMap_+3A_size">size</code></td>
<td>
<p>desired size of the map tile image. defaults to maximum size returned by the Gogle server, which is 640x640 pixels</p>
</td></tr>
<tr><td><code id="GetMap_+3A_destfile">destfile</code></td>
<td>
<p>File to load the map image from or save to, depending on <code>NEWMAP</code>.</p>
</td></tr>
<tr><td><code id="GetMap_+3A_zoom">zoom</code></td>
<td>
<p>Google maps zoom level.</p>
</td></tr>
<tr><td><code id="GetMap_+3A_markers">markers</code></td>
<td>
<p>(optional) defines one or more markers to attach to the image at specified locations. This parameter takes a string of marker definitions separated by the pipe character (|)</p>
</td></tr>
<tr><td><code id="GetMap_+3A_path">path</code></td>
<td>
<p>(optional) defines a single path of two or more connected points to overlay on the image at specified locations. This parameter takes a string of point definitions separated by the pipe character (|)</p>
</td></tr>
<tr><td><code id="GetMap_+3A_span">span</code></td>
<td>
<p>(optional) defines a minimum viewport for the map image expressed as a latitude and longitude pair. The static map service takes this value and produces a map of the proper zoom level to include the entire provided span value from the map's center point. Note that the resulting map may include larger bounds for either latitude or longitude depending on the rectangular dimensions of the map. If zoom is specified, span is ignored</p>
</td></tr>
<tr><td><code id="GetMap_+3A_frame">frame</code></td>
<td>
<p>(optional) specifies that the resulting image should be framed with a colored blue border. The frame consists of a 5 pixel, 55 % opacity blue border.</p>
</td></tr>
<tr><td><code id="GetMap_+3A_hl">hl</code></td>
<td>
<p>(optional) defines the language to use for display of labels on map tiles. Note that this paramater is only supported for some country tiles; if the specific language requested is not supported for the tile set, then the default language for that tile set will be used.</p>
</td></tr>
<tr><td><code id="GetMap_+3A_sensor">sensor</code></td>
<td>
<p>specifies whether the application requesting the static map is using a sensor to determine the user's location. This parameter is now required for all static map requests.</p>
</td></tr>
<tr><td><code id="GetMap_+3A_maptype">maptype</code></td>
<td>
<p>defines the type of map to construct. There are several possible maptype values, including satellite, terrain, hybrid, and mobile.</p>
</td></tr>
<tr><td><code id="GetMap_+3A_format">format</code></td>
<td>
<p>(optional) defines the format of the resulting image. By default, the Static Maps API creates GIF images. There are several possible formats including GIF, JPEG and PNG types. Which format you use depends on how you intend to present the image. JPEG typically provides greater compression, while GIF and PNG provide greater detail. This version supports only PNG.</p>
</td></tr>
<tr><td><code id="GetMap_+3A_extraurl">extraURL</code></td>
<td>
<p>custom URL suffix</p>
</td></tr>
<tr><td><code id="GetMap_+3A_returnimage">RETURNIMAGE</code></td>
<td>
<p>return image yes/no default: TRUE</p>
</td></tr>
<tr><td><code id="GetMap_+3A_grayscale">GRAYSCALE</code></td>
<td>
<p>Boolean toggle; if TRUE the colored map tile is rendered into a black &amp; white image, see <a href="#topic+RGB2GRAY">RGB2GRAY</a></p>
</td></tr>
<tr><td><code id="GetMap_+3A_newmap">NEWMAP</code></td>
<td>
<p>if TRUE, query the Google server and save to <code>destfile</code>, if FALSE load from destfile.</p>
</td></tr>
<tr><td><code id="GetMap_+3A_scale">SCALE</code></td>
<td>
<p>use the API's scale parameter to return higher-resolution map images. The scale value is multiplied with the size to determine the actual output size of the image in pixels, without changing the coverage area of the map</p>
</td></tr>
<tr><td><code id="GetMap_+3A_api_console_key">API_console_key</code></td>
<td>
<p>API key (formerly optional, now mandatory). If missing, the function &quot;stitches&quot; a static map from map tiles</p>
</td></tr>
<tr><td><code id="GetMap_+3A_type">type</code></td>
<td>
<p>choice of tile server</p>
</td></tr>
<tr><td><code id="GetMap_+3A_urlbase">urlBase</code></td>
<td>
<p>tileserver URL, alternatives would be &quot;http://a.tile.openstreetmap.org/&quot;, &quot;http://tile.stamen.com/toner/&quot;,&quot;http://tile.stamen.com/watercolor/&quot;</p>
</td></tr>
<tr><td><code id="GetMap_+3A_tiledir">tileDir</code></td>
<td>
<p>map tiles can be stored in a local directory, e.g. &quot;~/mapTiles/Google/&quot;</p>
</td></tr>
<tr><td><code id="GetMap_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>map structure or URL used to download the tile.</p>


<h3>Note</h3>

<p>Note that size is in order (lon, lat)</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>See Also</h3>

<p><a href="#topic+GetMap.bbox">GetMap.bbox</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (0){#takes too long to run for CRAN check


  


  lat = c(40.702147,40.718217,40.711614);


  lon = c(-74.012318,-74.015794,-73.998284);


  center = c(mean(lat), mean(lon));


  zoom &lt;- min(MaxZoom(range(lat), range(lon)));


  #this overhead is taken care of implicitly by GetMap.bbox(); 


  markers = paste0("&amp;markers=color:blue|label:S|40.702147,-74.015794&amp;markers=color:",


                   "green|label:G|40.711614,-74.012318&amp;markers=color:red|color:red|",


                   "label:C|40.718217,-73.998284")


  myMap &lt;- GetMap(center=center, zoom=zoom,markers=markers);


  #Note that in the presence of markers one often needs to add some extra padding to the 


  #latitude range to accomodate the extent of the top most marker


  


  #add a path, i.e. polyline:


  myMap &lt;- GetMap(center=center, zoom=zoom,


                  path = paste0("&amp;path=color:0x0000ff|weight:5|40.737102,-73.990318|",


                  "40.749825,-73.987963|40.752946,-73.987384|40.755823,-73.986397"));


  #use implicit geo coding 


  BrooklynMap &lt;- GetMap(center="Brooklyn", zoom=13)


  PlotOnStaticMap(BrooklynMap)


  


  #use implicit geo coding and display labels in Korean:


  BrooklynMap &lt;- GetMap(center="Brooklyn", zoom=13, hl="ko")


  PlotOnStaticMap(BrooklynMap)


  


  #no highways


  ManHatMap &lt;- GetMap(center="Lower Manhattan", zoom=14, 


                      extraURL="&amp;style=feature:road.highway|visibility:off",


                      destfile = "LowerManhattan.png")


  PlotOnStaticMap(ManHatMap)


  


  #reload the map without a new download:


  ManHatMap &lt;- GetMap(destfile = "LowerManhattan.png",NEWMAP=FALSE)


  PlotOnStaticMap(ManHatMap)





  #The example below defines a polygonal area within Manhattan, passed a series of 


  #intersections as locations:


  #myMap &lt;- GetMap(path = paste0("&amp;path=color:0x00000000|weight:5|fillcolor:0xFFFF0033|",


  #          "8th+Avenue+%26+34th+St,New+York,NY|8th+Avenue+%26+42nd+St,New+York,NY|",


  #          "Park+Ave+%26+42nd+St,New+York,NY,NY|Park+Ave+%26+34th+St,New+York,NY,NY"),


  #            destfile = "MyTile3a.png");


  


  #note that since the path string is just appended to the URL you can "abuse" the path 


  #argument to pass anything to the query, e.g. the style parameter:


  #The following example displays a map of Brooklyn where local roads have been changed 


  #to bright green and the residential areas have been changed to black:


  # myMap &lt;- GetMap(center="Brooklyn", zoom=12, maptype = "roadmap", 


  #path = paste0("&amp;style=feature:road.local|element:geometry|hue:0x00ff00|",


  #        "saturation:100&amp;style=feature:landscape|element:geometry|lightness:-100"),


  #        sensor='false', destfile = "MyTile4.png",  RETURNIMAGE = FALSE);


  


  #In the last example we set RETURNIMAGE to FALSE which is a useful feature in general


  #if png is not installed. In that cases, the images can still be fetched 


  #and saved but not read into R.


  


  #In the following example we let the Static Maps API determine the correct center and 


  #zoom level implicitly, based on evaluation of the position of the markers. 


  #However, to be of use within R we do need to know the values for zoom and 


  #center explicitly, so it is better practice to compute them ourselves and 


  #pass them as arguments, in which case meta information on the map tile can be saved as well.


  


  #myMap &lt;- GetMap(markers = paste0("&amp;markers=color:blue|label:S|40.702147,-74.015794&amp;",


  #          "markers=color:green|label:G|40.711614,-74.012318&amp;markers=color:red|",


  #          "color:red|label:C|40.718217,-73.998284"), 


  #           destfile = "MyTile1.png",  RETURNIMAGE = FALSE);


}


</code></pre>

<hr>
<h2 id='GetMap.bbox'>GetMap bbox</h2><span id='topic+GetMap.bbox'></span>

<h3>Description</h3>

<p>Wrapper function for <a href="#topic+GetMap">GetMap</a>. Query the Google server for a static map tile, defined primarily by its lat/lon range and/or center and/or zoom. 
</p>
<p>Multiple additional arguments allow the user to customize the map tile.</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetMap.bbox(lonR, latR, center, size = c(640, 640), 


    destfile = "MyTile.png", MINIMUMSIZE = FALSE, RETURNIMAGE = TRUE, 


    GRAYSCALE = FALSE, NEWMAP = TRUE, zoom, verbose = 0, 


    SCALE = 1, type = c("google", "google-m", "google-s", 


        "osm", "osm-hot", "stamen-toner", "stamen-terrain", 


        "stamen-watercolor")[1], urlBase = "http://mt1.google.com/vt/lyrs=m", 


    tileDir = "/tmp/", ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetMap.bbox_+3A_lonr">lonR</code></td>
<td>
<p>longitude range</p>
</td></tr>
<tr><td><code id="GetMap.bbox_+3A_latr">latR</code></td>
<td>
<p>latitude range</p>
</td></tr>
<tr><td><code id="GetMap.bbox_+3A_center">center</code></td>
<td>
<p>optional center</p>
</td></tr>
<tr><td><code id="GetMap.bbox_+3A_size">size</code></td>
<td>
<p>desired size of the map tile image. defaults to maximum size returned by the Gogle server, which is 640x640 pixels</p>
</td></tr>
<tr><td><code id="GetMap.bbox_+3A_destfile">destfile</code></td>
<td>
<p>File to load the map image from or save to, depending on <code>NEWMAP</code>.</p>
</td></tr>
<tr><td><code id="GetMap.bbox_+3A_minimumsize">MINIMUMSIZE</code></td>
<td>
<p>reduce the size of the map to its minimum size that still fits the lat/lon ranges ?</p>
</td></tr>
<tr><td><code id="GetMap.bbox_+3A_returnimage">RETURNIMAGE</code></td>
<td>
<p>return image yes/no default: TRUE</p>
</td></tr>
<tr><td><code id="GetMap.bbox_+3A_grayscale">GRAYSCALE</code></td>
<td>
<p>Boolean toggle; if TRUE the colored map tile is rendered into a black &amp; white image, see <a href="#topic+RGB2GRAY">RGB2GRAY</a></p>
</td></tr>
<tr><td><code id="GetMap.bbox_+3A_newmap">NEWMAP</code></td>
<td>
<p>if TRUE, query the Google server and save to <code>destfile</code>, if FALSE load from destfile.</p>
</td></tr>
<tr><td><code id="GetMap.bbox_+3A_zoom">zoom</code></td>
<td>
<p>Google maps zoom level. optional</p>
</td></tr>
<tr><td><code id="GetMap.bbox_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
<tr><td><code id="GetMap.bbox_+3A_scale">SCALE</code></td>
<td>
<p>use the API's scale parameter to return higher-resolution map images. The scale value is multiplied with the size to determine the actual output size of the image in pixels, without changing the coverage area of the map</p>
</td></tr>
<tr><td><code id="GetMap.bbox_+3A_type">type</code></td>
<td>
<p>choice of tile server</p>
</td></tr>
<tr><td><code id="GetMap.bbox_+3A_urlbase">urlBase</code></td>
<td>
<p>tileserver URL, alternatives would be &quot;http://a.tile.openstreetmap.org/&quot;, &quot;http://tile.stamen.com/toner/&quot;,&quot;http://tile.stamen.com/watercolor/&quot;</p>
</td></tr>
<tr><td><code id="GetMap.bbox_+3A_tiledir">tileDir</code></td>
<td>
<p>map tiles can be stored in a local directory, e.g. &quot;~/mapTiles/Google/&quot;</p>
</td></tr>
<tr><td><code id="GetMap.bbox_+3A_...">...</code></td>
<td>
<p>extra arguments to <a href="#topic+GetMap">GetMap</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>map tile</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>

 if (0){


 	mymarkers &lt;- cbind.data.frame(lat = c(38.898648,38.889112, 38.880940), 


          lon = c(-77.037692, -77.050273, -77.03660), size =  c('tiny','tiny','tiny'), 


          col = c('blue', 'green', 'red'), char = c('','',''));





	##get the bounding box:


  	bb &lt;- qbbox(lat = mymarkers[,"lat"], lon = mymarkers[,"lon"]);


  


	##download the map:


  	MyMap &lt;- GetMap.bbox(bb$lonR, bb$latR, destfile = "DC.png", GRAYSCALE =TRUE,


                markers = mymarkers);


 	##The function qbbox() basically computes a bounding box for the given lat,lon 


   #points with a few additional options such as quantile boxes, additional buffers, etc.  


  	bb &lt;- qbbox(c(40.702147,40.711614,40.718217),c(-74.015794,-74.012318,-73.998284), 


            TYPE = "all", margin = list(m=rep(5,4), TYPE = c("perc", "abs")[1]));


 	##download the map:           


	MyMap &lt;- GetMap.bbox(bb$lonR, bb$latR,destfile = "MyTile3.png", maptype = "satellite") 





}


</code></pre>

<hr>
<h2 id='GetMapTiles'>download map tiles from specified map tile servers such as openstreetmap or Google</h2><span id='topic+GetMapTiles'></span>

<h3>Description</h3>

<p>Query the server for map tiles, defined uniquely by their 
</p>
<p>X and Y ID and zoom. For offline usage, these map tiles are stored in a local directory
</p>
<p>Example OSM:http://a.tile.openstreetmap.org/10/549/335.png
</p>
<p>Also see https://wiki.openstreetmap.org/wiki/Tile_servers
</p>
<p>Example Google mobile: http://mt1.google.com/vt/lyrs=m&amp;x=1325&amp;y=3143&amp;z=13
</p>
<p>Example Google satellite: http://mt1.google.com/vt/lyrs=s&amp;x=1325&amp;y=3143&amp;z=13</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetMapTiles(center = c(lat = 52.431635, lon = 13.194773), 


    lonR, latR, nTiles = c(3, 3), zoom = 13, type = c("google", 


        "google-m", "google-s", "osm", "osm-hot", "stamen-toner", 


        "stamen-terrain", "stamen-watercolor")[1], 


    urlBase = "http://mt1.google.com/vt/lyrs=m", tileDir = "/tmp/", 


    CheckExistingFiles = TRUE, TotalSleep = NULL, tileExt = ".png", 


    returnTiles = TRUE, verbose = 0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetMapTiles_+3A_center">center</code></td>
<td>
<p>optional center (lat first,lon second  )</p>
</td></tr>
<tr><td><code id="GetMapTiles_+3A_lonr">lonR</code></td>
<td>
<p>longitude range</p>
</td></tr>
<tr><td><code id="GetMapTiles_+3A_latr">latR</code></td>
<td>
<p>latitude range</p>
</td></tr>
<tr><td><code id="GetMapTiles_+3A_ntiles">nTiles</code></td>
<td>
<p>number of tiles in x and y direction</p>
</td></tr>
<tr><td><code id="GetMapTiles_+3A_zoom">zoom</code></td>
<td>
<p>Google maps zoom level.</p>
</td></tr>
<tr><td><code id="GetMapTiles_+3A_type">type</code></td>
<td>
<p>choice of tile server</p>
</td></tr>
<tr><td><code id="GetMapTiles_+3A_urlbase">urlBase</code></td>
<td>
<p>tileserver URL, alternatives would be &quot;http://a.tile.openstreetmap.org/&quot;, &quot;http://tile.stamen.com/toner/&quot;,&quot;http://tile.stamen.com/watercolor/&quot;</p>
</td></tr>
<tr><td><code id="GetMapTiles_+3A_tiledir">tileDir</code></td>
<td>
<p>map tiles can be stored in a local directory, e.g. &quot;~/mapTiles/Google/&quot;</p>
</td></tr>
<tr><td><code id="GetMapTiles_+3A_checkexistingfiles">CheckExistingFiles</code></td>
<td>
<p>logical, if TRUE check if files already exist and only download if not!</p>
</td></tr>
<tr><td><code id="GetMapTiles_+3A_totalsleep">TotalSleep</code></td>
<td>
<p>overall time (in seconds) that one is willing to add in between downloads. This is intended to lower the risk of a server denial. If NULL no call to <a href="base.html#topic+Sys.sleep">Sys.sleep</a> is executed</p>
</td></tr>
<tr><td><code id="GetMapTiles_+3A_tileext">tileExt</code></td>
<td>
<p>image type of tile</p>
</td></tr>
<tr><td><code id="GetMapTiles_+3A_returntiles">returnTiles</code></td>
<td>
<p>return tiles in a list?</p>
</td></tr>
<tr><td><code id="GetMapTiles_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with important information</p>


<h3>Note</h3>

<p>Note that size is in order (lon, lat)</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>See Also</h3>

<p><a href="#topic+GetMap.bbox">GetMap.bbox</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (0){


  


  #OSM, Ireland


  xlim = c(-7, -3.5) 


  ylim = c(51.35, 55.35)


  Dublin = c(lon=-6.266155,lat=53.350140)


  DublinMerc = geosphere_mercator(Dublin)


  


  ir.osm &lt;- GetMapTiles(lonR=xlim, latR=ylim, zoom=7, verbose=1,


                        type = "osm", tileDir= TRUE)


  map = plotOSM(ir.osm)


  par("usr")#A vector of the form c(x1, x2, y1, y2)


  points(map$bbox$upperLeft,col=2,pch=20)


  points(map$bbox$lowerRight,col=2,pch=20)


  


  points(DublinMerc, col =2, pch=1,cex=1.5)


  


  ir.stamenToner &lt;- GetMapTiles(lonR=xlim, latR=ylim, zoom=7,verbose=0,


                                type = "stamen", tileDir= TRUE)


  plotOSM(ir.stamenToner)


  


  ir.stamenWater &lt;- GetMapTiles(lonR=xlim, latR=ylim, zoom=7, verbose=1,


                                type = "stamen-watercolor", tileDir= TRUE)


  plotOSM(ir.stamenWater)


 


  


  #############################################


  zoom=5


  nTiles = prod(NumTiles(lonR=c(-135,-66), latR=c(25,54) , zoom=zoom))


  us_google_5 = GetMapTiles(lonR=c(-135,-66), latR=c(25,54) , zoom=zoom, TotalSleep = 2*nTiles,


              type = "google", tileDir= TRUE, verbose = TRUE)


  


  PlotOnMapTiles(us_google_5)


  wtc_ll = getGeoCode("World Trade Center, NY")


  wtc_google_15=GetMapTiles(wtc_ll, zoom=15,nTiles = c(3,3), type = "google", 


                            tileDir= TRUE, verbose = 1)


  PlotOnMapTiles(wtc_google_15)


  wtc_google_16 =GetMapTiles(wtc_ll, zoom=16,nTiles = c(4,4), type = "google", 


                             tileDir= TRUE, verbose=1)


  PlotOnMapTiles(wtc_google_16)








  wtc_stamen=GetMapTiles(wtc_ll, zoom=15,nTiles = c(3,3), verbose=1,


                  type = "stamen-toner", tileDir= TRUE)


  PlotOnMapTiles(wtc_stamen)











###combine with leaflet:


#From:http://stackoverflow.com/questions/5050851/


#     best-lightweight-web-server-only-static-content-for-windows


#To use Python as a simple web server just change your working 


#directory to the folder with your static content and type 


#python -m SimpleHTTPServer 8000, everything in the directory


#will be available at http:/localhost:8000/


  


library(leaflet)


m = leaflet::leaflet() %&gt;% 


  addTiles( urlTemplate = "http:/localhost:8000/mapTiles/OSM/{z}_{x}_{y}.png")


m = leaflet::leaflet() %&gt;% 


  addTiles( urlTemplate = "http:/localhost:8000/mapTiles/Google/{z}_{x}_{y}.png")


m = m %&gt;% leaflet::setView(-74.01312, 40.71180, zoom = 16)


m = m %&gt;% leaflet::addMarkers(-74.01312, 40.71180)





#Quadriga:


m = m %&gt;% leaflet::setView(13.39780, 52.51534, zoom = 16)


m = m %&gt;% leaflet::addMarkers(13.39780, 52.51534)


}





</code></pre>

<hr>
<h2 id='GetOsmMap'>Query the Open Street Map server for map tiles instead of Google Maps</h2><span id='topic+GetOsmMap'></span>

<h3>Description</h3>

<p>The querying parameters for Open Street Maps are somewhat different in this version. 
</p>
<p>Instead of a zoom, center and size, the user supplies a scale parameter and a lat/lon bounding box. 
</p>
<p>The scale determines the image size.</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetOsmMap(lonR = c(-74.02132, -73.98622), latR = c(40.69983, 


    40.72595), scale = 20000, destfile = "MyTile.png", 


    format = "png", RETURNIMAGE = TRUE, GRAYSCALE = FALSE, 


    NEWMAP = TRUE, verbose = 1, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetOsmMap_+3A_lonr">lonR</code></td>
<td>
<p>longitude range</p>
</td></tr>
<tr><td><code id="GetOsmMap_+3A_latr">latR</code></td>
<td>
<p>latitude range</p>
</td></tr>
<tr><td><code id="GetOsmMap_+3A_scale">scale</code></td>
<td>
<p>Open Street map scale parameter. The larger this value, the smaller the resulting map tile in memory. There is a balance to be struck between the lat/lon bounding box and the scale parameter.</p>
</td></tr>
<tr><td><code id="GetOsmMap_+3A_destfile">destfile</code></td>
<td>
<p>File to load the map image from or save to, depending on <code>NEWMAP</code>.</p>
</td></tr>
<tr><td><code id="GetOsmMap_+3A_format">format</code></td>
<td>
<p>(optional) defines the format of the resulting image.</p>
</td></tr>
<tr><td><code id="GetOsmMap_+3A_returnimage">RETURNIMAGE</code></td>
<td>
<p>return image yes/no default: TRUE</p>
</td></tr>
<tr><td><code id="GetOsmMap_+3A_grayscale">GRAYSCALE</code></td>
<td>
<p>Boolean toggle; if TRUE the colored map tile is rendered into a black &amp; white image, see <a href="#topic+RGB2GRAY">RGB2GRAY</a></p>
</td></tr>
<tr><td><code id="GetOsmMap_+3A_newmap">NEWMAP</code></td>
<td>
<p>if TRUE, query the Google server and save to <code>destfile</code>, if FALSE load from destfile.</p>
</td></tr>
<tr><td><code id="GetOsmMap_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity,</p>
</td></tr>
<tr><td><code id="GetOsmMap_+3A_...">...</code></td>
<td>
<p>extra arguments to be used in future versions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>map structure or URL used to download the tile.</p>


<h3>Note</h3>

<p>The OSM maptile server is frequently too busy to accomodate every request, so patience is warranted.</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (0) {


 	CologneMap &lt;- GetOsmMap(lonR= c(6.89, 7.09), latR = c(50.87, 51), scale = 150000, 


                            destfile = "Cologne.png");


	PlotOnStaticMap(CologneMap, mar=rep(4,4), NEWMAP = FALSE, TrueProj = FALSE, axes= TRUE);


		


	PrincetonMap &lt;- GetOsmMap(lonR= c(-74.67102, -74.63943), latR = c(40.33804,40.3556), 


                             scale = 12500, destfile = "Princeton.png");


	png("PrincetonWithAxes.png", 1004, 732)


      PlotOnStaticMap(PrincetonMap, axes = TRUE, mar = rep(4,4));


    dev.off()


 }


</code></pre>

<hr>
<h2 id='IdentifyPoints'>identify points by clicking on map</h2><span id='topic+IdentifyPoints'></span>

<h3>Description</h3>

<p>The user can try to identify lat/lon pairs on the map by clicking on them</p>


<h3>Usage</h3>

<pre><code class='language-R'>IdentifyPoints(MyMap, n = 1, verbose = 0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IdentifyPoints_+3A_mymap">MyMap</code></td>
<td>
<p>map object</p>
</td></tr>
<tr><td><code id="IdentifyPoints_+3A_n">n</code></td>
<td>
<p>the maximum number of points to locate.</p>
</td></tr>
<tr><td><code id="IdentifyPoints_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the lat/lon coordinates of the chosen points are returned </p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#The first step naturally will be to download a static map from the Google server. A simple example:





 #identifiy points:


 #IdentifyPoints(MyMap,5)





</code></pre>

<hr>
<h2 id='incidents'>San Francisco crime data</h2><span id='topic+incidents'></span>

<h3>Description</h3>

<p>The <code>incidents</code> data frame has 5000 rows and 16 columns.
These are 5000 random rows from the 2012 crime data recorded in San Francisco.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(incidents)</code></pre>


<h3>Format</h3>

<p>This data frame contains the following columns:
</p>

<dl>
<dt>IncidntNum</dt><dd><p>incident number assigned by the police</p>
</dd>
<dt>Category</dt><dd><p>Category of crime</p>
</dd>
<dt>Descript</dt><dd><p>longer description</p>
</dd>
<dt>DayOfWeek</dt><dd><p>day of week</p>
</dd>
<dt>Date</dt><dd><p>date</p>
</dd>
<dt>Time</dt><dd><p>time of day formatted as hh:mm </p>
</dd>
<dt>PdDistrict</dt><dd><p>police district</p>
</dd>
<dt>Resolution</dt><dd><p>was the crime resolved?</p>
</dd>
<dt>Location</dt><dd><p>location as address</p>
</dd>
<dt>lon</dt><dd><p>longitude</p>
</dd>
<dt>lat</dt><dd><p>latitude</p>
</dd>
<dt>violent</dt><dd><p>violent flag</p>
</dd>
<dt>HrOfDay</dt><dd><p>hour of day as 2-digit integer</p>
</dd>
<dt>TimeOfDay</dt><dd><p>hour of day as decimal number</p>
</dd>
<dt>HourOfWeek</dt><dd><p>hour of week as decimal number between 0-168</p>
</dd>
<dt>censusBlock</dt><dd><p>ID of census block</p>
</dd>
</dl>



<h3>Details</h3>

<p>crime data recorded in San Francisco
</p>


<h3>Source</h3>

<p>URL https://data.sfgov.org/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(incidents)
table(incidents$Category)

</code></pre>

<hr>
<h2 id='LatLon2XY'>computes the coordinate transformation from lat/lon to map tile coordinates </h2><span id='topic+LatLon2XY'></span>

<h3>Description</h3>

<p>The function LatLon2XY(lat,lon,zoom) computes the coordinate transformation from lat/lon to map tile coordinates given a zoom level. 
</p>
<p>It returns the tile coordinates as well as the pixel coordinates within the Tile itself. </p>


<h3>Usage</h3>

<pre><code class='language-R'>LatLon2XY(lat, lon, zoom)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LatLon2XY_+3A_lat">lat</code></td>
<td>
<p>latitude values to transform</p>
</td></tr>
<tr><td><code id="LatLon2XY_+3A_lon">lon</code></td>
<td>
<p>longitude values to transform</p>
</td></tr>
<tr><td><code id="LatLon2XY_+3A_zoom">zoom</code></td>
<td>
<p>zoom level.lat,lon,zoom</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with values
</p>
<table role = "presentation">
<tr><td><code>Tile</code></td>
<td>
<p>integer numbers specifying the tile</p>
</td></tr>
<tr><td><code>Coords</code></td>
<td>
<p>pixel coordinate within the Tile</p>
</td></tr></table>


<h3>Note</h3>

<p>The fractional part times 256 is the pixel coordinate within the Tile itself. </p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>

LatLon2XY(38.45, -122.375, 11)


</code></pre>

<hr>
<h2 id='LatLon2XY.centered'>computes the centered coordinate transformation from lat/lon to map tile coordinates </h2><span id='topic+LatLon2XY.centered'></span>

<h3>Description</h3>

<p>The function LatLon2XY.centered(MyMap, lat,lon,zoom) computes the coordinate transformation from lat/lon to map tile coordinates given a map object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>LatLon2XY.centered(MyMap, lat, lon, zoom)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LatLon2XY.centered_+3A_mymap">MyMap</code></td>
<td>
<p>map object</p>
</td></tr>
<tr><td><code id="LatLon2XY.centered_+3A_lat">lat</code></td>
<td>
<p>latitude values to transform</p>
</td></tr>
<tr><td><code id="LatLon2XY.centered_+3A_lon">lon</code></td>
<td>
<p>longitude values to transform</p>
</td></tr>
<tr><td><code id="LatLon2XY.centered_+3A_zoom">zoom</code></td>
<td>
<p>optional zoom level. If missing, taken from <code>MyMap</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>properly scaled and centered (with respect to the center of <code>MyMap</code> ) coordinates  
</p>
<table role = "presentation">
<tr><td><code>newX</code></td>
<td>
<p> transformed longitude</p>
</td></tr>
<tr><td><code>newY</code></td>
<td>
<p>transformed latitude</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>See Also</h3>

<p><a href="#topic+LatLon2XY">LatLon2XY</a> <a href="#topic+Tile2R">Tile2R</a> </p>

<hr>
<h2 id='MapBackground'>get static Map from the Google server</h2><span id='topic+MapBackground'></span>

<h3>Description</h3>

<p>get static Map from the Google server</p>


<h3>Usage</h3>

<pre><code class='language-R'>MapBackground(lat, lon, destfile, NEWMAP = TRUE, myTile, 

    zoom = NULL, size = c(640, 640), GRAYSCALE = FALSE, 

    mar = c(0, 0, 0, 0), PLOT = FALSE, verbose = 1, 

    ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MapBackground_+3A_lat">lat</code></td>
<td>
<p>center latitude</p>
</td></tr>
<tr><td><code id="MapBackground_+3A_lon">lon</code></td>
<td>
<p>center longitude</p>
</td></tr>
<tr><td><code id="MapBackground_+3A_destfile">destfile</code></td>
<td>
<p>File to load the map image from or save to, depending on <code>NEWMAP</code>.</p>
</td></tr>
<tr><td><code id="MapBackground_+3A_newmap">NEWMAP</code></td>
<td>
<p>if TRUE, query the Google server and save to <code>destfile</code>, if FALSE load from destfile.</p>
</td></tr>
<tr><td><code id="MapBackground_+3A_mytile">myTile</code></td>
<td>
<p>map tile from previous downloads</p>
</td></tr>
<tr><td><code id="MapBackground_+3A_zoom">zoom</code></td>
<td>
<p>Google maps zoom level.</p>
</td></tr>
<tr><td><code id="MapBackground_+3A_size">size</code></td>
<td>
<p>desired size of the map tile image. defaults to maximum size returned by the Gogle server, which is 640x640 pixels</p>
</td></tr>
<tr><td><code id="MapBackground_+3A_grayscale">GRAYSCALE</code></td>
<td>
<p>Boolean toggle; if TRUE the colored map tile is rendered into a black &amp; white image, see <a href="#topic+RGB2GRAY">RGB2GRAY</a></p>
</td></tr>
<tr><td><code id="MapBackground_+3A_mar">mar</code></td>
<td>
<p>outer margin in plot; if you want to see axes, change the default</p>
</td></tr>
<tr><td><code id="MapBackground_+3A_plot">PLOT</code></td>
<td>
<p>if TRUE, leave the plotting to <a href="#topic+PlotOnStaticMap">PlotOnStaticMap</a>, highly recommended</p>
</td></tr>
<tr><td><code id="MapBackground_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
<tr><td><code id="MapBackground_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <a href="#topic+GetMap.bbox">GetMap.bbox</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing the map tile</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>

<hr>
<h2 id='MaxZoom'>computes the maximum zoom level which will contain the given lat/lon range</h2><span id='topic+MaxZoom'></span>

<h3>Description</h3>

<p>computes the maximum zoom level which will contain the given lat/lon range</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxZoom(latrange, lonrange, size = c(640, 640))</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MaxZoom_+3A_latrange">latrange</code></td>
<td>
<p>range of latitude values</p>
</td></tr>
<tr><td><code id="MaxZoom_+3A_lonrange">lonrange</code></td>
<td>
<p>range of longitude values</p>
</td></tr>
<tr><td><code id="MaxZoom_+3A_size">size</code></td>
<td>
<p>desired size of the map tile image. defaults to maximum size returned by the Gogle server, which is 640x640 pixels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zoom level</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>

<hr>
<h2 id='mypolygon'>simple wrapper function to plot colored polygons</h2><span id='topic+mypolygon'></span>

<h3>Description</h3>

<p>same as <a href="graphics.html#topic+polygon">polygon</a>, execept the value for color is taken from the 1st element of the exra column 'col'</p>


<h3>Usage</h3>

<pre><code class='language-R'>mypolygon(x, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mypolygon_+3A_x">x</code></td>
<td>
<p>matrix containing columns X,Y,col</p>
</td></tr>
<tr><td><code id="mypolygon_+3A_...">...</code></td>
<td>
<p>extra arguments passed to  <a href="graphics.html#topic+polygon">polygon</a></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Loecher</p>

<hr>
<h2 id='NumTiles'>computes the necessary number of tiles from a bounding box and a zoom level</h2><span id='topic+NumTiles'></span>

<h3>Description</h3>

<p>computes the necessary number of tiles from a bounding box and a zoom level</p>


<h3>Usage</h3>

<pre><code class='language-R'>NumTiles(lonR, latR, zoom = 13, CheckExistingFiles = TRUE, 


    tileExt = ".png", tileDir = "~/mapTiles/OSM/", 


    verbose = 0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NumTiles_+3A_lonr">lonR</code></td>
<td>
<p>longitude range</p>
</td></tr>
<tr><td><code id="NumTiles_+3A_latr">latR</code></td>
<td>
<p>latitude range,</p>
</td></tr>
<tr><td><code id="NumTiles_+3A_zoom">zoom</code></td>
<td>
<p>zoom level</p>
</td></tr>
<tr><td><code id="NumTiles_+3A_checkexistingfiles">CheckExistingFiles</code></td>
<td>
<p>logical, if TRUE check if files already exist and only download if not!</p>
</td></tr>
<tr><td><code id="NumTiles_+3A_tileext">tileExt</code></td>
<td>
<p>image type of tile</p>
</td></tr>
<tr><td><code id="NumTiles_+3A_tiledir">tileDir</code></td>
<td>
<p>map tiles are stored in a local directory, e.g. &quot;~/mapTiles/Google/&quot;</p>
</td></tr>
<tr><td><code id="NumTiles_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tuple with number of tiles for lon and lat extent</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (0){


  #US bounding box:


  for (zoom in 4:15) {


    cat("OSM, zoom =", zoom, "\n")


    NumTiles(lonR=c(-135,-66), latR=c(25,54) , zoom=zoom)


  }


  for (zoom in 4:15) {


    cat("Google, zoom =", zoom, "\n")


    NumTiles(lonR=c(-135,-66), latR=c(25,54) , zoom=zoom, tileDir= "~/mapTiles/Google/")


  }


}


</code></pre>

<hr>
<h2 id='NYleukemia'>Upstate New York Leukemia Data</h2><span id='topic+NYleukemia'></span>

<h3>Description</h3>

<p>Census tract level (<code>n=281</code>) leukemia data for the 8 counties in upstate New York from 1978-1982, paired with population data from the 1980 census.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NYleukemia)</code></pre>


<h3>Format</h3>

<p>List with 5 items:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>geo</code> </td><td style="text-align: left;"> table of the FIPS code, longitude, and latitude of the geographic centroid of each census tract </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>data</code> </td><td style="text-align: left;"> table of the FIPS code, number of cases, and population of each census tract </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>spatial.polygon</code> </td><td style="text-align: left;"> object of class SpatialPolygons (See <a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a>) containing a map of the study region </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>surrounded</code> </td><td style="text-align: left;"> row IDs of the 4 census tracts that are completely surrounded by the <code>surrounding</code> census tracts </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>surrounding</code> </td><td style="text-align: left;"> row IDs of the 4 census tracts that completely surround the <code>surrounded</code> census tracts </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>http://www.sph.emory.edu/~lwaller/ch4index.htm</p>


<h3>References</h3>

<p>Turnbull, B. W. et al (1990)
Monitoring for clusters of disease: application to leukemia incidence in upstate New York <em>American Journal of Epidemiology</em>, <b>132</b>, 136&ndash;143
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (0) {
data(NYleukemia)
  population &lt;- NYleukemia$data$population
  cases &lt;- NYleukemia$data$cases
  mapNY &lt;- GetMap(center=c(lon=-76.00365, lat=42.67456), destfile = "NYstate.png",
  maptype = "mobile", zoom=9)
  ColorMap(100*cases/population, mapNY, NYleukemia$spatial.polygon, add = FALSE,
  alpha = 0.35, log = TRUE, location = "topleft")
 }
</code></pre>

<hr>
<h2 id='osmtile_bbox'>compute the bounding box of an OpenStreetmap tile</h2><span id='topic+osmtile_bbox'></span>

<h3>Description</h3>

<p>inspired by <code>osmtile</code> from the package <code>OpenStreetmap</code>
</p>
<p>returns the Mercator projection bounding box</p>


<h3>Usage</h3>

<pre><code class='language-R'>osmtile_bbox(x = 61, y = 41, zoom = 7, minim = -20037508)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="osmtile_bbox_+3A_x">x</code></td>
<td>
<p>x tile coordinate</p>
</td></tr>
<tr><td><code id="osmtile_bbox_+3A_y">y</code></td>
<td>
<p>x tile coordinate</p>
</td></tr>
<tr><td><code id="osmtile_bbox_+3A_zoom">zoom</code></td>
<td>
<p>zoom level</p>
</td></tr>
<tr><td><code id="osmtile_bbox_+3A_minim">minim</code></td>
<td>
<p>parameter for OSM projection</p>
</td></tr>
</table>


<h3>Value</h3>

<p>bounding box, Mercator projection </p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>

<hr>
<h2 id='pennLC'>Pennsylvania Lung Cancer</h2><span id='topic+pennLC'></span>

<h3>Description</h3>

<p>County-level (n=67) population/case data for lung cancer in Pennsylvania in 2002, stratified on race (white vs non-white), gender and age (Under 40, 40-59, 60-69 and 70+).  Additionally, county-specific smoking rates.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pennLC)</code></pre>


<h3>Format</h3>

<p>List of 3 items:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>geo</code> </td><td style="text-align: left;"> a table of county IDs, longitude/latitude of the geographic centroid of each county </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>data</code> </td><td style="text-align: left;"> a table of county IDs, number of cases, population and strata information </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>smoking</code> </td><td style="text-align: left;"> a table of county IDs and proportion of smokers</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>spatial.polygon</code> </td><td style="text-align: left;"> an object of class SpatialPolygons (See <a href="sp.html#topic+SpatialPolygons-class">SpatialPolygons-class</a>) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Source</h3>

<p>Population data was obtained from the 2000 decennial census, lung cancer 
and smoking data were obtained from the Pennsylvania Department of Health website:  http://www.dsf.health.state.pa.us/
</p>


<h3>See Also</h3>

 
<p><code><a href="#topic+NYleukemia">NYleukemia</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pennLC)
#pennLC$geo
#pennLC$data
#pennLC$smoking

# Map smoking rates in Pennsylvania
#mapvariable(pennLC$smoking[,2], pennLC$spatial.polygon)
</code></pre>

<hr>
<h2 id='PlotArrowsOnStaticMap'>plots arrows or segments on map </h2><span id='topic+PlotArrowsOnStaticMap'></span>

<h3>Description</h3>

<p>This function plots/overlays arrows or segments on a map.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotArrowsOnStaticMap(MyMap, lat0, lon0, lat1 = lat0, 


    lon1 = lon0, TrueProj = TRUE, FUN = arrows, add = FALSE, 


    verbose = 0, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotArrowsOnStaticMap_+3A_mymap">MyMap</code></td>
<td>
<p>map image returned from e.g. <code>GetMap()</code></p>
</td></tr>
<tr><td><code id="PlotArrowsOnStaticMap_+3A_lat0">lat0</code></td>
<td>
<p>latitude valuesof points FROM which to draw.</p>
</td></tr>
<tr><td><code id="PlotArrowsOnStaticMap_+3A_lon0">lon0</code></td>
<td>
<p>longitude values of points FROM which to draw.</p>
</td></tr>
<tr><td><code id="PlotArrowsOnStaticMap_+3A_lat1">lat1</code></td>
<td>
<p>latitude valuesof points TO which to draw.</p>
</td></tr>
<tr><td><code id="PlotArrowsOnStaticMap_+3A_lon1">lon1</code></td>
<td>
<p>longitude values of points TO which to draw.</p>
</td></tr>
<tr><td><code id="PlotArrowsOnStaticMap_+3A_trueproj">TrueProj</code></td>
<td>
<p>set to FALSE if you are willing to accept some degree of inaccuracy in the mapping. In that case, the coordinates of the image are in lat/lon and the user can simply overly points/lines/axis without worrying about projections</p>
</td></tr>
<tr><td><code id="PlotArrowsOnStaticMap_+3A_fun">FUN</code></td>
<td>
<p>, plotting function to use for overlay; typical choices would be <a href="graphics.html#topic+arrows">arrows</a> and <a href="graphics.html#topic+segments">segments</a></p>
</td></tr>
<tr><td><code id="PlotArrowsOnStaticMap_+3A_add">add</code></td>
<td>
<p>start a new plot or add to an existing</p>
</td></tr>
<tr><td><code id="PlotArrowsOnStaticMap_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
<tr><td><code id="PlotArrowsOnStaticMap_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>return value of <code>FUN</code></p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>See Also</h3>

<p><a href="#topic+PlotOnStaticMap">PlotOnStaticMap</a> <a href="graphics.html#topic+arrows">arrows</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (0){


  	MyMap &lt;- GetMap(center=c(lat=40.7,lon=-74), zoom=11)


	PlotArrowsOnStaticMap(MyMap, lat0=40.69, lon0=-73.9, lat1=40.71, lon1=-74.1, col = 'red')   


}


</code></pre>

<hr>
<h2 id='plotmap'>easy to use wrapper function</h2><span id='topic+plotmap'></span>

<h3>Description</h3>

<p>note the similarity in name to PBSmapping::plotMap
</p>
<p>This function is the workhorse of the package RgoogleMaps. It overlays plot on background image of map tile.</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotmap(lat, lon, map, zoom = NULL, API = c("google", 


    "OSM", "bing", "google2")[1], maptype = c("roadmap", 


    "mobile", "satellite", "terrain", "hybrid", "mapmaker-roadmap", 


    "mapmaker-hybrid")[2], destfile, data, alpha = 1, 


    col = 1, apiKey = NULL, verbose = 0, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotmap_+3A_lat">lat</code></td>
<td>
<p>latitude values to be overlaid OR string to be geocoded OR named vector (lat,lon)!</p>
</td></tr>
<tr><td><code id="plotmap_+3A_lon">lon</code></td>
<td>
<p>longitude values to be overlaid</p>
</td></tr>
<tr><td><code id="plotmap_+3A_map">map</code></td>
<td>
<p>optional map object</p>
</td></tr>
<tr><td><code id="plotmap_+3A_zoom">zoom</code></td>
<td>
<p>Google maps zoom level</p>
</td></tr>
<tr><td><code id="plotmap_+3A_api">API</code></td>
<td>
<p>choice  of map tile API</p>
</td></tr>
<tr><td><code id="plotmap_+3A_maptype">maptype</code></td>
<td>
<p>defines the type of map to construct. There are several possible maptype values, including satellite, terrain, hybrid, and mobile.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_destfile">destfile</code></td>
<td>
<p>File to save the map image to</p>
</td></tr>
<tr><td><code id="plotmap_+3A_data">data</code></td>
<td>
<p>data to look up variables in</p>
</td></tr>
<tr><td><code id="plotmap_+3A_alpha">alpha</code></td>
<td>
<p>opacity</p>
</td></tr>
<tr><td><code id="plotmap_+3A_col">col</code></td>
<td>
<p>plot color</p>
</td></tr>
<tr><td><code id="plotmap_+3A_apikey">apiKey</code></td>
<td>
<p>optional API key (allows for higher rate of downloads for Google); mandatory for Bing maps</p>
</td></tr>
<tr><td><code id="plotmap_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
<tr><td><code id="plotmap_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>PlotOnStaticMap</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (0){


  #####################Google maps#############################


  mapBG1 = plotmap("Brandenburg Gate, Berlin", zoom = 15)





  #####################bing maps#############################


  


  #for bing maps you will need your own API key, 


  #sign up at https://msdn.microsoft.com/en-us/library/ff428642.aspx


  apiKey = scan("bingAPIkey.txt",what="")


  mapBG2 = plotmap("Brandenburg Gate, Berlin", zoom = 15, API = "bing", apiKey=apiKey)


  


  latlon &lt;- cbind.data.frame(lat = c(38.898648,38.889112, 38.880940), 


                              lon = c(-77.037692, -77.050273, -77.03660));


  


  


  map3 = plotmap(lat = latlon$lat, lon = latlon$lon, API = "bing", apiKey=apiKey,


                 col = "purple", pch="X",cex=1.5)


  


  


  #####################OSM maps#############################


  map4 = plotmap(lat = latlon$lat, lon = latlon$lon, API = "OSM", zoom=15,


                 col = "purple", pch="X",cex=1.5)


}


</code></pre>

<hr>
<h2 id='PlotOnMapTiles'>plots on map tiles by &quot;stitching&quot; them together</h2><span id='topic+PlotOnMapTiles'></span>

<h3>Description</h3>

<p>Counterpart to <code>PlotOnStaticMap</code> for map tiles</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotOnMapTiles(mt, lat, lon, center, size = c(768, 


    768), add = FALSE, FUN = points, mar = c(0, 0, 


    0, 0), verbose = 0, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotOnMapTiles_+3A_mt">mt</code></td>
<td>
<p>list returned by <code>GetMapTiles</code></p>
</td></tr>
<tr><td><code id="PlotOnMapTiles_+3A_lat">lat</code></td>
<td>
<p>latitude values to be overlaid, if any</p>
</td></tr>
<tr><td><code id="PlotOnMapTiles_+3A_lon">lon</code></td>
<td>
<p>longitude values to be overlaid, if any</p>
</td></tr>
<tr><td><code id="PlotOnMapTiles_+3A_center">center</code></td>
<td>
<p>optional center</p>
</td></tr>
<tr><td><code id="PlotOnMapTiles_+3A_size">size</code></td>
<td>
<p>size (in pixels) of &quot;stitched&quot; map</p>
</td></tr>
<tr><td><code id="PlotOnMapTiles_+3A_add">add</code></td>
<td>
<p>start a new plot or add to an existing</p>
</td></tr>
<tr><td><code id="PlotOnMapTiles_+3A_fun">FUN</code></td>
<td>
<p>plotting function to use for overlay; typical choices would be <a href="graphics.html#topic+points">points</a> and <a href="graphics.html#topic+lines">lines</a></p>
</td></tr>
<tr><td><code id="PlotOnMapTiles_+3A_mar">mar</code></td>
<td>
<p>outer margin in plot; if you want to see axes, change the default</p>
</td></tr>
<tr><td><code id="PlotOnMapTiles_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
<tr><td><code id="PlotOnMapTiles_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing returned</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>




if (0){


  lat = c(40.702147,40.718217,40.711614);


  lon = c(-74.012318,-74.015794,-73.998284);


  center = c(mean(lat), mean(lon));


  zoom &lt;- min(MaxZoom(range(lat), range(lon)));


  bb=qbbox(lat,lon)


  


  manhattan_osm = GetMapTiles(latR =bb$latR , lonR=bb$lonR,zoom=zoom,verbose=1)


  PlotOnMapTiles(manhattan_osm,lat=lat,lon=lon,pch=20,col=c('red', 'blue', 'green'),cex=2)


  


  manhattan_goo = GetMapTiles(latR =bb$latR , lonR=bb$lonR,zoom=zoom,


                   tileDir= TRUE, type="google" )


  PlotOnMapTiles(manhattan_goo,lat=lat,lon=lon,pch=20,col=c('red', 'blue', 'green'),cex=2)


  


}


</code></pre>

<hr>
<h2 id='PlotOnStaticMap'>overlays plot on background image of map tile</h2><span id='topic+PlotOnStaticMap'></span>

<h3>Description</h3>

<p>This function is the workhorse of the package RgoogleMaps. It overlays plot on background image of map tile</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotOnStaticMap(MyMap, lat, lon, destfile, zoom = NULL, 


    size, GRAYSCALE = FALSE, add = FALSE, FUN = points, 


    mar = c(0, 0, 0, 0), NEWMAP = TRUE, TrueProj = TRUE, 


    axes = FALSE, atX = NULL, atY = NULL, verbose = 0, 


    ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotOnStaticMap_+3A_mymap">MyMap</code></td>
<td>
<p>optional map object</p>
</td></tr>
<tr><td><code id="PlotOnStaticMap_+3A_lat">lat</code></td>
<td>
<p>latitude values to be overlaid</p>
</td></tr>
<tr><td><code id="PlotOnStaticMap_+3A_lon">lon</code></td>
<td>
<p>longitude values to be overlaid</p>
</td></tr>
<tr><td><code id="PlotOnStaticMap_+3A_destfile">destfile</code></td>
<td>
<p>File to load the map image from or save to, depending on whether <code>MyMap</code> was passed.</p>
</td></tr>
<tr><td><code id="PlotOnStaticMap_+3A_zoom">zoom</code></td>
<td>
<p>Google maps zoom level. optional if <code>MyMap</code> is passed, required if not.</p>
</td></tr>
<tr><td><code id="PlotOnStaticMap_+3A_size">size</code></td>
<td>
<p>desired size of the map tile image. defaults to maximum size returned by the Gogle server, which is 640x640 pixels</p>
</td></tr>
<tr><td><code id="PlotOnStaticMap_+3A_grayscale">GRAYSCALE</code></td>
<td>
<p>Boolean toggle; if TRUE the colored map tile is rendered into a black &amp; white image, see <a href="#topic+RGB2GRAY">RGB2GRAY</a></p>
</td></tr>
<tr><td><code id="PlotOnStaticMap_+3A_add">add</code></td>
<td>
<p>start a new plot or add to an existing</p>
</td></tr>
<tr><td><code id="PlotOnStaticMap_+3A_fun">FUN</code></td>
<td>
<p>plotting function to use for overlay; typical choices would be <a href="graphics.html#topic+points">points</a> and <a href="graphics.html#topic+lines">lines</a></p>
</td></tr>
<tr><td><code id="PlotOnStaticMap_+3A_mar">mar</code></td>
<td>
<p>outer margin in plot; if you want to see axes, change the default</p>
</td></tr>
<tr><td><code id="PlotOnStaticMap_+3A_newmap">NEWMAP</code></td>
<td>
<p>load map from file or get it &quot;new&quot; from the static map server</p>
</td></tr>
<tr><td><code id="PlotOnStaticMap_+3A_trueproj">TrueProj</code></td>
<td>
<p>set to FALSE if you are willing to accept some degree of inaccuracy in the mapping. In that case, the coordinates of the image are in lat/lon and the user can simply overly points/lines/axis without worrying about projections</p>
</td></tr>
<tr><td><code id="PlotOnStaticMap_+3A_axes">axes</code></td>
<td>
<p>overlay axes ?</p>
</td></tr>
<tr><td><code id="PlotOnStaticMap_+3A_atx">atX</code></td>
<td>
<p>numeric; position of ticks on x-axis; if missing, <a href="graphics.html#topic+axTicks">axTicks</a> is called for nice values; see <a href="graphics.html#topic+axis">axis</a></p>
</td></tr>
<tr><td><code id="PlotOnStaticMap_+3A_aty">atY</code></td>
<td>
<p>numeric; position of ticks on y-axis; if missing, <a href="graphics.html#topic+axTicks">axTicks</a> is called for nice values; see <a href="graphics.html#topic+axis">axis</a></p>
</td></tr>
<tr><td><code id="PlotOnStaticMap_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
<tr><td><code id="PlotOnStaticMap_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>the map object is returned via <code>invisible(MyMap)</code></p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>

#The first step naturally will be to download a static map from the Google server. A simple example:





  if (0){


    lat = c(40.702147,40.711614,40.718217);


    lon = c(-74.015794,-74.012318,-73.998284);


    center = c(mean(lat), mean(lon));


    zoom &lt;- min(MaxZoom(range(lat), range(lon)));


    #this overhead is taken care of implicitly by GetMap.bbox();              


    MyMap &lt;- GetMap(center=center, zoom=zoom,markers = paste0("&amp;markers=color:blue|label:S|",


             "40.702147,-74.015794&amp;markers=color:green|label:G|40.711614,-74.012318&amp;markers=",


             "color:red|color:red|label:C|40.718217,-73.998284"), destfile = "MyTile1.png");


                   


     tmp &lt;- PlotOnStaticMap(MyMap, lat = lat, 


                            lon = lon, 


                            destfile = "MyTile1.png", cex=1.5,pch=20,


                            col=c('red', 'blue', 'green'), add=FALSE);


     #and add lines:


     PlotOnStaticMap(MyMap, lat = c(40.702147,40.711614,40.718217), 


                     lon = c(-74.015794,-74.012318,-73.998284), 


                     lwd=1.5,col=c('red', 'blue', 'green'), FUN = lines, add=TRUE)


     	


  }


</code></pre>

<hr>
<h2 id='plotOSM'>plots OSM map tiles</h2><span id='topic+plotOSM'></span>

<h3>Description</h3>

<p>places tiles on plot</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotOSM(mt, upperLeft, lowerRight, lat, lon, add = FALSE, 

    removeMargin = TRUE, verbose = 0, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotOSM_+3A_mt">mt</code></td>
<td>
<p>list returned by <code>GetMapTiles</code></p>
</td></tr>
<tr><td><code id="plotOSM_+3A_upperleft">upperLeft</code></td>
<td>
<p>upperLeft corner in lat/lon of the plot region</p>
</td></tr>
<tr><td><code id="plotOSM_+3A_lowerright">lowerRight</code></td>
<td>
<p>lowerRight corner in lat/lon of the plot region</p>
</td></tr>
<tr><td><code id="plotOSM_+3A_lat">lat</code></td>
<td>
<p>latitude values to be overlaid, if any</p>
</td></tr>
<tr><td><code id="plotOSM_+3A_lon">lon</code></td>
<td>
<p>longitude values to be overlaid, if any</p>
</td></tr>
<tr><td><code id="plotOSM_+3A_add">add</code></td>
<td>
<p>Boolean, whether to add to existing plot</p>
</td></tr>
<tr><td><code id="plotOSM_+3A_removemargin">removeMargin</code></td>
<td>
<p>Boolean, whether to strip margins of plot</p>
</td></tr>
<tr><td><code id="plotOSM_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
<tr><td><code id="plotOSM_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>rasterImage</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns map object invisibly </p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>

<hr>
<h2 id='plotOSMtile'>plots a single OSM tile</h2><span id='topic+plotOSMtile'></span>

<h3>Description</h3>

<p>Adds tile to plot</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotOSMtile(osmtile, zoom, add = TRUE, raster = TRUE, 

    verbose = 0, ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotOSMtile_+3A_osmtile">osmtile</code></td>
<td>
<p>tile object</p>
</td></tr>
<tr><td><code id="plotOSMtile_+3A_zoom">zoom</code></td>
<td>
<p>zoom level</p>
</td></tr>
<tr><td><code id="plotOSMtile_+3A_add">add</code></td>
<td>
<p>Boolean, whether to add to existing plot</p>
</td></tr>
<tr><td><code id="plotOSMtile_+3A_raster">raster</code></td>
<td>
<p>Boolean, whether to load rster image</p>
</td></tr>
<tr><td><code id="plotOSMtile_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
<tr><td><code id="plotOSMtile_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>rasterImage</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns nothing</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>

<hr>
<h2 id='PlotPolysOnStaticMap'>plots polygons on map</h2><span id='topic+PlotPolysOnStaticMap'></span>

<h3>Description</h3>

<p>This function plots/overlays polygons on a map. Typically, the polygons originate from a shapefile.</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotPolysOnStaticMap(MyMap, polys, col, border = NULL, 

    lwd = 0.25, verbose = 0, add = TRUE, textInPolys = NULL, 

    ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotPolysOnStaticMap_+3A_mymap">MyMap</code></td>
<td>
<p>map image returned from e.g. <code>GetMap()</code></p>
</td></tr>
<tr><td><code id="PlotPolysOnStaticMap_+3A_polys">polys</code></td>
<td>
<p>or of class <a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a> from the package sp
</p>
<p>polygons to overlay; these can be either of class <a href="PBSmapping.html#topic+PolySet">PolySet</a> from the package PBSmapping</p>
</td></tr>
<tr><td><code id="PlotPolysOnStaticMap_+3A_col">col</code></td>
<td>
<p>(optional) vector of colors, one for each polygon</p>
</td></tr>
<tr><td><code id="PlotPolysOnStaticMap_+3A_border">border</code></td>
<td>
<p>the color to draw the border. The default, NULL, means to use <a href="graphics.html#topic+par">par</a>(&quot;fg&quot;). Use border = NA to omit borders, see <a href="graphics.html#topic+polygon">polygon</a></p>
</td></tr>
<tr><td><code id="PlotPolysOnStaticMap_+3A_lwd">lwd</code></td>
<td>
<p>line width, see <a href="graphics.html#topic+par">par</a></p>
</td></tr>
<tr><td><code id="PlotPolysOnStaticMap_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
<tr><td><code id="PlotPolysOnStaticMap_+3A_add">add</code></td>
<td>
<p>start a new plot or add to an existing</p>
</td></tr>
<tr><td><code id="PlotPolysOnStaticMap_+3A_textinpolys">textInPolys</code></td>
<td>
<p>text to be displayed inside polygons.</p>
</td></tr>
<tr><td><code id="PlotPolysOnStaticMap_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>PlotOnStaticMap</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>See Also</h3>

<p><a href="#topic+PlotOnStaticMap">PlotOnStaticMap</a> <a href="#topic+mypolygon">mypolygon</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (0){

  #require(PBSmapping);
  shpFile &lt;- paste(system.file(package = "RgoogleMaps"), "/shapes/bg11_d00.shp", sep = "")
  #shpFile &lt;- system.file('bg11_d00.shp', package = "RgoogleMaps");
  
  shp=PBSmapping::importShapefile(shpFile,projection="LL");
  bb &lt;- qbbox(lat = shp[,"Y"], lon = shp[,"X"]);
  MyMap &lt;- GetMap.bbox(bb$lonR, bb$latR, destfile = "DC.png");
  PlotPolysOnStaticMap(MyMap, shp, lwd=.5, col = rgb(0.25,0.25,0.25,0.025), add = F);
  
  #Try an open street map:

  mapOSM &lt;- GetMap.bbox(bb$lonR, bb$latR, destfile = "DC.png", type="osm");
  PlotPolysOnStaticMap(mapOSM, shp, lwd=.5, col = rgb(0.75,0.25,0.25,0.15), add = F);

  #North Carolina SIDS data set:
  shpFile &lt;- system.file("shapes/sids.shp", package="rgooglemaps");
  shp=PBSmapping::importShapefile(shpFile,projection="LL");
  bb &lt;- qbbox(lat = shp[,"Y"], lon = shp[,"X"]);
  MyMap &lt;- GetMap.bbox(bb$lonR, bb$latR, destfile = "SIDS.png");
  #compute regularized SID rate
  sid &lt;- 100*attr(shp, "PolyData")$SID74/(attr(shp, "PolyData")$BIR74+500)
  b &lt;- as.integer(cut(sid, quantile(sid, seq(0,1,length=8)) ));
  b[is.na(b)] &lt;- 1;
  opal &lt;- col2rgb(grey.colors(7), alpha=TRUE)/255; opal["alpha",] &lt;- 0.2;
  shp[,"col"] &lt;- rgb(0.1,0.1,0.1,0.2);
  for (i in 1:length(b)) 
    shp[shp[,"PID"] == i,"col"] &lt;- rgb(opal[1,b[i]],opal[2,b[i]],opal[3,b[i]],opal[4,b[i]]);
  PlotPolysOnStaticMap(MyMap, shp, lwd=.5, col = shp[,"col"], add = F);
  
  
  #or choose an aspect ratio that corresponds better to North Carolina's elongated shape:
  MyMap &lt;- GetMap.bbox(bb$lonR, bb$latR, destfile = "SIDS.png", size = c(640, 320), zoom = 7);
  PlotPolysOnStaticMap(MyMap, shp, lwd=.5, col = shp[,"col"], add = F);
 }


</code></pre>

<hr>
<h2 id='qbbox'>computes bounding box</h2><span id='topic+qbbox'></span>

<h3>Description</h3>

<p>The function qbbox computes a bounding box for the given lat,lon 
</p>
<p>points with a few additional options such as quantile boxes, additional margins, etc.</p>


<h3>Usage</h3>

<pre><code class='language-R'>qbbox(lat, lon, TYPE = c("all", "quantile")[1], margin = list(m = c(1, 

    1, 1, 1), TYPE = c("perc", "abs")[1]), q.lat = c(0.1, 

    0.9), q.lon = c(0.1, 0.9), verbose = 0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qbbox_+3A_lat">lat</code></td>
<td>
<p>latitude values</p>
</td></tr>
<tr><td><code id="qbbox_+3A_lon">lon</code></td>
<td>
<p>longitude values</p>
</td></tr>
<tr><td><code id="qbbox_+3A_type">TYPE</code></td>
<td>
<p>absolute or percentage trimming?</p>
</td></tr>
<tr><td><code id="qbbox_+3A_margin">margin</code></td>
<td>
<p>relative or absolute margin around the data. Set to NULL if no margin desired.</p>
</td></tr>
<tr><td><code id="qbbox_+3A_q.lat">q.lat</code></td>
<td>
<p>latitude quantile trimming, the tails will be trimmed from the bounding box</p>
</td></tr>
<tr><td><code id="qbbox_+3A_q.lon">q.lon</code></td>
<td>
<p>longitude quantile trimming,</p>
</td></tr>
<tr><td><code id="qbbox_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>latR</code></td>
<td>
<p>latitude range</p>
</td></tr>
<tr><td><code>lonR</code></td>
<td>
<p>longitude range</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lat = 37.85 + rnorm(100, sd=0.001);

lon = -120.47 + rnorm(100, sd=0.001);

#add a few outliers:

lat[1:5] &lt;- lat[1:5] + rnorm(5, sd =.01);

lon[1:5] &lt;- lon[1:5] + rnorm(5, sd =.01);



#range, discarding the upper and lower 10% of the data

qbbox(lat, lon, TYPE = "quantile");

#full range:

qbbox(lat, lon, TYPE = "all");

#add a 10% extra margin on all four sides:

qbbox(lat, lon, margin = list(m = c(10, 10, 10, 10), TYPE = c("perc", "abs")[1]));

 

</code></pre>

<hr>
<h2 id='ReadMapTile'>Read a bitmap image stored in the PNG format</h2><span id='topic+ReadMapTile'></span>

<h3>Description</h3>

<p>Reads an image from a PNG file/content into a raster array.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadMapTile(destfile, METADATA = TRUE, native = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReadMapTile_+3A_destfile">destfile</code></td>
<td>
<p>png file to read</p>
</td></tr>
<tr><td><code id="ReadMapTile_+3A_metadata">METADATA</code></td>
<td>
<p>read MetaInfo as well ?</p>
</td></tr>
<tr><td><code id="ReadMapTile_+3A_native">native</code></td>
<td>
<p>determines the image representation - if FALSE then the result is an array, if TRUE then the result is a native raster representation, see <a href="png.html#topic+readPNG">readPNG</a> in package png.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>map or tile object</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>

<hr>
<h2 id='RGB2GRAY'>translates an RGB image matrix to gray scale</h2><span id='topic+RGB2GRAY'></span>

<h3>Description</h3>

<p>This function translates the rgb values of the array myTile into a scalar matrix with just one gray value per pixel.</p>


<h3>Usage</h3>

<pre><code class='language-R'>RGB2GRAY(myTile)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RGB2GRAY_+3A_mytile">myTile</code></td>
<td>
<p>rgb image matrix, usually array with 3 dimensions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Gray scale intensity defined as  0.30R + 0.59G + 0.11B</p>


<h3>Value</h3>

<p>image tile</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (0){


  BrooklynLatLon = getGeoCode("Brooklyn")


  mapBrooklyn &lt;- GetMap(center=BrooklynLatLon, destfile = file.path(tempdir(), "Brooklyn.png"), 


                 zoom=11, size = c(240,240))


  mapBrooklynBW$myTile = RGB2GRAY(mapBrooklyn$myTile)


  PlotOnStaticMap(mapBrooklynBW)


}


</code></pre>

<hr>
<h2 id='sp_bbox'>computes bounding box</h2><span id='topic+sp_bbox'></span>

<h3>Description</h3>

<p>The function sp_bbox computes a bounding box; it was copied from the sp package bbox function </p>


<h3>Usage</h3>

<pre><code class='language-R'>sp_bbox(obj)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sp_bbox_+3A_obj">obj</code></td>
<td>
<p>object deriving from class &quot;Spatial&quot;, or one of classes: &quot;Line&quot;, &quot;Lines&quot;, &quot;Polygon&quot; or &quot;Polygons&quot;, or ANY, which requires obj to be an array with at least two columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>two-column matrix; the first column has the minimum, the second the maximum values; rows represent the spatial dimensions</p>


<h3>Author(s)</h3>

<p>Roger Bivand</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# just 9 points on a grid:
x &lt;- c(1,1,1,2,2,2,3,3,3)
y &lt;- c(1,2,3,1,2,3,1,2,3)
xy &lt;- cbind(x,y)

sp_bbox(xy)

</code></pre>

<hr>
<h2 id='SpatialToPBS'>converts spatial objects as defined in package sp to simpler PBSmapping type dataframes </h2><span id='topic+SpatialToPBS'></span>

<h3>Description</h3>

<p>The PlotPolysOnStaticMap() function currently does not take sp objects directly but instead needs
</p>
<p>PBSmapping type data.frames. This function converts sp objects into such.                         
</p>
<p>THANKS TO Fabio Priuli for a major bug fix w.r.t. holes in spatial polygons!</p>


<h3>Usage</h3>

<pre><code class='language-R'>SpatialToPBS(xy, verbose = 0)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SpatialToPBS_+3A_xy">xy</code></td>
<td>
<p>spatial object, such as SpatialPoints, SpatialPolygons, etc..</p>
</td></tr>
<tr><td><code id="SpatialToPBS_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with elements xy = converted object, bb = bounding box, fun = plot function</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  if (0) {


    data("NYleukemia", envir = environment())


    population &lt;- NYleukemia$data$population


    cases &lt;- NYleukemia$data$cases


    mapNY &lt;- GetMap(center=c(lat=42.67456,lon=-76.00365), 


                    destfile = file.path(tempdir(),"NYstate.png"), 


                    maptype = "mobile", zoom=9)


    #mapNY=ReadMapTile("NYstate.png")


    clrStuff=ColorMap(100*cases/population, alpha = 0.35, log = TRUE)


    NYpolys = SpatialToPBS(NYleukemia$spatial.polygon)


    PlotPolysOnStaticMap(mapNY, NYpolys$xy, col = clrStuff$colcode, add = FALSE)


    legend("topleft", legend = clrStuff$legend, fill = clrStuff$fill, 


           bg = rgb(0.1,0.1,0.1,0.3))


}


  


</code></pre>

<hr>
<h2 id='TextOnStaticMap'>plots text on map</h2><span id='topic+TextOnStaticMap'></span>

<h3>Description</h3>

<p>TextOnStaticMap draws the strings given in the vector labels at the coordinates given by x and y on a map. y may be missing since xy.coords(x,y) is used for construction of the coordinates.</p>


<h3>Usage</h3>

<pre><code class='language-R'>TextOnStaticMap(MyMap, lat, lon, labels = seq_along(lat), 


    TrueProj = TRUE, FUN = text, add = FALSE, verbose = 0, 


    ...)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="TextOnStaticMap_+3A_mymap">MyMap</code></td>
<td>
<p>map image returned from e.g. <code>GetMap()</code></p>
</td></tr>
<tr><td><code id="TextOnStaticMap_+3A_lat">lat</code></td>
<td>
<p>latitude where to put text.</p>
</td></tr>
<tr><td><code id="TextOnStaticMap_+3A_lon">lon</code></td>
<td>
<p>longitude where to put text.</p>
</td></tr>
<tr><td><code id="TextOnStaticMap_+3A_labels">labels</code></td>
<td>
<p>a character vector or <a href="base.html#topic+expression">expression</a> specifying the text to be written. An attempt is made to coerce other language objects (names and calls) to expressions, and vectors and other classed objects to character vectors by <a href="base.html#topic+as.character">as.character</a>. If labels is longer than x and y, the coordinates are recycled to the length of labels.</p>
</td></tr>
<tr><td><code id="TextOnStaticMap_+3A_trueproj">TrueProj</code></td>
<td>
<p>set to FALSE if you are willing to accept some degree of inaccuracy in the mapping. In that case, the coordinates of the image are in lat/lon and the user can simply overly points/lines/axis without worrying about projections</p>
</td></tr>
<tr><td><code id="TextOnStaticMap_+3A_fun">FUN</code></td>
<td>
<p>overlay function, typical choice would be <a href="graphics.html#topic+text">text</a></p>
</td></tr>
<tr><td><code id="TextOnStaticMap_+3A_add">add</code></td>
<td>
<p>start a new plot or add to an existing</p>
</td></tr>
<tr><td><code id="TextOnStaticMap_+3A_verbose">verbose</code></td>
<td>
<p>level of verbosity</p>
</td></tr>
<tr><td><code id="TextOnStaticMap_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>FUN</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>return value of <code>FUN</code></p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>

  if (0) {


   lat = c(40.702147,40.718217,40.711614);


    lon = c(-74.012318,-74.015794,-73.998284);


    center = c(mean(lat), mean(lon));


    zoom &lt;- min(MaxZoom(range(lat), range(lon)));


    


   


   MyMap &lt;- GetMap(center=center, zoom=zoom,markers = paste0("&amp;markers=color:blue|label:S|",


            "40.702147,-74.015794&amp;markers=color:green|label:G|40.711614,-74.012318&amp;markers=",


             "color:red|color:red|label:C|40.718217,-73.998284"), destfile = "MyTile1.png");


    TextOnStaticMap(MyMap, lat=40.711614,lon=-74.012318, "Some Text", cex=2, col = 'red')


    


}


</code></pre>

<hr>
<h2 id='Tile2R'>simple utility to offset and scale XY coordinates with respect to the center</h2><span id='topic+Tile2R'></span>

<h3>Description</h3>

<p>simple utility to offset and scale XY coordinates with respect to the center</p>


<h3>Usage</h3>

<pre><code class='language-R'>Tile2R(points, center)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Tile2R_+3A_points">points</code></td>
<td>
<p>XY coordinates returned by e.g. <a href="#topic+LatLon2XY">LatLon2XY</a></p>
</td></tr>
<tr><td><code id="Tile2R_+3A_center">center</code></td>
<td>
<p>XY coordinates of center returned by e.g. <a href="#topic+LatLon2XY">LatLon2XY</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>mainly used for shrinking the size of a tile to the minimum size.</p>


<h3>Value</h3>

<p>list with X and Y pixel values</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>

latR &lt;- c(34.5,34.9);


 lonR &lt;- c(-100.3, -100);


 lat.center &lt;- 34.7;


 lon.center &lt;- -100.2;


 zoom = 10;


 ll &lt;- LatLon2XY(latR[1], lonR[1], zoom);#lower left corner


 ur &lt;- LatLon2XY(latR[2], lonR[2], zoom );#upper right corner


 cr &lt;- LatLon2XY(lat.center, lon.center, zoom );#center


 ll.Rcoords &lt;- Tile2R(ll, cr);


 ur.Rcoords &lt;- Tile2R(ur, cr);





</code></pre>

<hr>
<h2 id='updateusr'>Updates the 'usr' coordinates in the current plot.</h2><span id='topic+updateusr'></span>

<h3>Description</h3>

<p>For a traditional graphics plot this function will update the 'usr'
</p>
<p>coordinates by transforming a pair of points from the current usr
</p>
<p>coordinates to those specified.</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateusr(x1, y1 = NULL, x2, y2 = NULL)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="updateusr_+3A_x1">x1</code></td>
<td>
<p>The x-coords of 2 points in the current 'usr' coordinates, or anything that can be passed to <code>xy.coords</code>.</p>
</td></tr>
<tr><td><code id="updateusr_+3A_y1">y1</code></td>
<td>
<p>The y-coords of 2 points in the current 'usr' coordinates, or an object representing the points in the new 'usr' coordinates.</p>
</td></tr>
<tr><td><code id="updateusr_+3A_x2">x2</code></td>
<td>
<p>The x-coords for the 2 points in the new coordinates.</p>
</td></tr>
<tr><td><code id="updateusr_+3A_y2">y2</code></td>
<td>
<p>The y-coords for the 2 points in the new coordinates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Sometimes graphs (in the traditional graphing scheme) end up with usr
</p>
<p>coordinates different from expected for adding to the plot (for
</p>
<p>example <code>barplot</code> does not center the bars at integers).  This
</p>
<p>function will take 2 points in the current 'usr' coordinates and the
</p>
<p>desired 'usr' coordinates of the 2 points and transform the user
</p>
<p>coordinates to make this happen.  The updating only shifts and scales
</p>
<p>the coordinates, it does not do any rotation or warping transforms.
</p>
<p>If <code>x1</code> and <code>y1</code> are lists or matricies and <code>x2</code> and
</p>
<p><code>y2</code> are not specified, then <code>x1</code> is taken to be the
</p>
<p>coordinates in the current system and <code>y1</code> is the coordinates in
</p>
<p>the new system.
</p>
<p>Currently you need to give the function exactly 2 points in each
</p>
<p>system.  The 2 points cannot have the same x values or y values in
</p>
<p>either system.</p>


<h3>Value</h3>

<p>An invisible list with the previous 'usr' coordinates from <code>par</code>.</p>


<h3>Note</h3>

<p>Currently you need to give coordinates for exactly 2 points without
</p>
<p>missing values.  Future versions of the function will allow missing
</p>
<p>values or multiple points.
</p>
<p>Note by Markus Loecher: both the source and the documentations were copied from the package TeachingDemos version 2.3</p>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>Examples</h3>

<pre><code class='language-R'>

tmp &lt;- barplot(1:4)


updateusr(tmp[1:2], 0:1, 1:2, 0:1)


lines(1:4, c(1,3,2,2), lwd=3, type='b',col='red')





# update the y-axis to put a reference distribution line in the bottom


# quarter





tmp &lt;- rnorm(100)


hist(tmp)


tmp2 &lt;- par('usr')


xx &lt;- seq(min(tmp), max(tmp), length.out=250)


yy &lt;- dnorm(xx, mean(tmp), sd(tmp))


updateusr( tmp2[1:2], tmp2[3:4], tmp2[1:2], c(0, max(yy)*4) )


lines(xx,yy)





</code></pre>

<hr>
<h2 id='XY2LatLon'>computes the centered coordinate transformation from lat/lon to map tile coordinates </h2><span id='topic+XY2LatLon'></span>

<h3>Description</h3>

<p>The function XY2LatLon(MyMap, X,Y,zoom) computes the coordinate transformation from map tile coordinates to lat/lon given a map object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>XY2LatLon(MyMap, X, Y, zoom)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="XY2LatLon_+3A_mymap">MyMap</code></td>
<td>
<p>map object</p>
</td></tr>
<tr><td><code id="XY2LatLon_+3A_x">X</code></td>
<td>
<p>latitude values to transform</p>
</td></tr>
<tr><td><code id="XY2LatLon_+3A_y">Y</code></td>
<td>
<p>longitude values to transform</p>
</td></tr>
<tr><td><code id="XY2LatLon_+3A_zoom">zoom</code></td>
<td>
<p>optional zoom level. If missing, taken from <code>MyMap</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>properly scaled and centered (with respect to the center of <code>MyMap</code> ) coordinates  
</p>
<table role = "presentation">
<tr><td><code>lon</code></td>
<td>
<p>longitude</p>
</td></tr>
<tr><td><code>lat</code></td>
<td>
<p>latitude</p>
</td></tr></table>


<h3>Author(s)</h3>

<p>Markus Loecher</p>


<h3>See Also</h3>

<p><a href="#topic+LatLon2XY">LatLon2XY</a> <a href="#topic+Tile2R">Tile2R</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>

#quick test:





  zoom=12;MyMap &lt;- list(40,-120,zoom, url="google", BBOX = list(ll=c(35,-125), ur=c(45,-115)));


  LatLon &lt;- c(lat = 40.0123, lon = -120.0123);


  Rcoords &lt;- LatLon2XY.centered(MyMap,LatLon["lat"],LatLon["lon"])


  newLatLon &lt;- XY2LatLon(MyMap, Rcoords$newX, Rcoords$newY)


  max(abs(newLatLon - LatLon));





#more systematic:


 for (zoom in 2:10){


   cat("zoom: ", zoom, "\n");


   MyMap &lt;- list(40,-120,zoom, url="google", BBOX = list(ll=c(35,-125), ur=c(45,-115)));


   LatLon &lt;- c(lat = runif(1,-80,80), lon = runif(1,-170,170));


   Rcoords &lt;- LatLon2XY.centered(MyMap,LatLon["lat"],LatLon["lon"])


   newLatLon &lt;- XY2LatLon(MyMap, Rcoords$newX, Rcoords$newY)


   if(max(abs(newLatLon - LatLon)) &gt; 0.0001) print(rbind(LatLon, newLatLon));


 }





</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
