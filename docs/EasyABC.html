<!DOCTYPE html><html><head><title>Help for package EasyABC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EasyABC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ABC_emulation'>
<p>Rejection sampling scheme for ABC using an emulator</p></a></li>
<li><a href='#ABC_mcmc'>
<p>Coupled to MCMC schemes for ABC</p></a></li>
<li><a href='#ABC_rejection'>
<p>Rejection sampling scheme for ABC</p></a></li>
<li><a href='#ABC_sequential'>
<p>Sequential sampling schemes for ABC</p></a></li>
<li><a href='#binary_model'>
<p>Wrapper for a binary executable for non-parallel simulations</p></a></li>
<li><a href='#binary_model_cluster'>
<p>Wrapper for a binary executable for parallel simulations</p></a></li>
<li><a href='#EasyABC-internal'><p>Internal EasyABC objects</p></a></li>
<li><a href='#EasyABC-package'><p>EasyABC: performing efficient approximate Bayesian computation sampling schemes using R</p></a></li>
<li><a href='#SABC'><p>Simulated Annealing approach to Approximate Bayesian Computation (SABC)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Efficient Approximate Bayesian Computation Sampling Schemes</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-15</td>
</tr>
<tr>
<td>Author:</td>
<td>Franck Jabot, Thierry Faure, Nicolas Dumoulin, Carlo Albert.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicolas Dumoulin &lt;nicolas.dumoulin@inrae.fr&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://easyabc.r-forge.r-project.org/">http://easyabc.r-forge.r-project.org/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0), abc</td>
</tr>
<tr>
<td>Imports:</td>
<td>pls, mnormt, MASS, parallel, lhs, tensorA</td>
</tr>
<tr>
<td>Description:</td>
<td>Enables launching a series of simulations of a computer code from the R session, and to retrieve the simulation outputs in an appropriate format for post-processing treatments. Five sequential sampling schemes and three coupled-to-MCMC schemes are implemented.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-20 11:22:10 UTC; dumoulin</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-05 21:51:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='ABC_emulation'>
Rejection sampling scheme for ABC using an emulator</h2><span id='topic+ABC_emulation'></span>

<h3>Description</h3>

<p>This function launches a series of <code>nb_design_pts</code> model simulations with model parameters drawn in the prior distribution specified in <code>prior_matrix</code>, build an emulator with these computed design points and then launches a series of <code>nb_simul</code> emulator simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ABC_emulation(model, prior,  nb_design_pts, nb_simul, prior_test=NULL,
  summary_stat_target=NULL, emulator_span = 50, tol=NULL, use_seed=FALSE,
  seed_count=0, n_cluster=1, verbose=FALSE, progress_bar=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ABC_emulation_+3A_model">model</code></td>
<td>

<p>a <code>R</code> function implementing the model to be simulated. It must take as arguments a vector of model parameter values and it must return a vector of summary statistics. When using the option <code>use_seed=TRUE</code>, <code>model</code> must take as arguments a vector containing a seed value and the model parameter values.
A tutorial is provided in the package's vignette to dynamically link a binary code to a <code>R</code> function.  Users may alternatively wish to wrap their binary executables using the provided functions <code><a href="#topic+binary_model">binary_model</a></code> and <code><a href="#topic+binary_model_cluster">binary_model_cluster</a></code>. The use of these functions is associated with slightly different constraints on the design of the binary code (see <code><a href="#topic+binary_model">binary_model</a></code> and <code><a href="#topic+binary_model_cluster">binary_model_cluster</a></code>).</p>
</td></tr>
<tr><td><code id="ABC_emulation_+3A_prior">prior</code></td>
<td>

<p>a list of prior information. Each element of the list corresponds to a model parameter. The list element must be a vector whose first argument determines the type of prior distribution: possible values are <code>"unif"</code> for a uniform distribution on a segment, <code>"normal"</code> for a normal distribution, <code>"lognormal"</code> for a lognormal distribution or <code>"exponential"</code> for an exponential distribution.
The following arguments of the list elements contain the characteritiscs of the prior distribution chosen: for <code>"unif"</code>, two numbers must be given: the minimum and maximum values of the uniform distribution; for <code>"normal"</code>, two numbers must be given: the mean and standard deviation of the normal distribution; for <code>"lognormal"</code>, two numbers must be given: the mean and standard deviation on the log scale of the lognormal distribution; for <code>"exponential"</code>, one number must be given: the rate of the exponential distribution. User-defined prior distributions can also be provided. See the vignette for additional information on this topic.</p>
</td></tr>
<tr><td><code id="ABC_emulation_+3A_nb_design_pts">nb_design_pts</code></td>
<td>

<p>a positive integer equal to the desired number of simulations of the model used to build the emulator.</p>
</td></tr>
<tr><td><code id="ABC_emulation_+3A_nb_simul">nb_simul</code></td>
<td>

<p>a positive integer equal to the desired number of simulations of the emulator.</p>
</td></tr>
<tr><td><code id="ABC_emulation_+3A_prior_test">prior_test</code></td>
<td>

<p>a string expressing the constraints between model parameters.
This expression will be evaluated as a logical expression, you can use all the logical operators including <code>"&lt;"</code>, <code>"&gt;"</code>, ...
Each parameter should be designated with <code>"X1"</code>, <code>"X2"</code>, ... in the same order as in the prior definition.
If not provided, no constraint will be applied.</p>
</td></tr>
<tr><td><code id="ABC_emulation_+3A_summary_stat_target">summary_stat_target</code></td>
<td>

<p>a vector containing the targeted (observed) summary statistics.
If not provided, <code>ABC_rejection</code> only launches the simulations and outputs the simulation results.</p>
</td></tr>
<tr><td><code id="ABC_emulation_+3A_emulator_span">emulator_span</code></td>
<td>

<p>a positive number, the number of design points selected for the local regression.
<code>50</code> by default.</p>
</td></tr>
<tr><td><code id="ABC_emulation_+3A_tol">tol</code></td>
<td>

<p>tolerance, a strictly positive number (between 0 and 1) indicating the proportion of simulations retained nearest the targeted summary statistics.</p>
</td></tr>
<tr><td><code id="ABC_emulation_+3A_use_seed">use_seed</code></td>
<td>

<p>logical. If <code>FALSE</code> (default), <code>ABC_rejection</code> provides as input to the function <code>model</code> a vector containing the model parameters used for the simulation.
If <code>TRUE</code>, <code>ABC_rejection</code> provides as input to the function <code>model</code> a vector containing an integer seed value and the model parameters used for the simulation.
In this last case, the seed value should be used by <code>model</code> to initialize its pseudo-random number generators (if <code>model</code> is stochastic).</p>
</td></tr>
<tr><td><code id="ABC_emulation_+3A_seed_count">seed_count</code></td>
<td>

<p>a positive integer, the initial seed value provided to the function <code>model</code> (if <code>use_seed=TRUE</code>). This value is incremented by 1 at each call of the function <code>model</code>.</p>
</td></tr>
<tr><td><code id="ABC_emulation_+3A_n_cluster">n_cluster</code></td>
<td>

<p>a positive integer. If larger than 1 (the default value), <code>ABC_rejection</code> will launch <code>model</code> simulations in parallel on <code>n_cluster</code> cores of the computer.</p>
</td></tr>
<tr><td><code id="ABC_emulation_+3A_verbose">verbose</code></td>
<td>

<p>logical. <code>FALSE</code> by default. If <code>TRUE</code>, <code>ABC_rejection</code> writes in the current directory intermediary results at the end of each step of the algorithm in the file &quot;output&quot;.
These outputs have a matrix format, in wich each raw is a different simulation, the first columns are the parameters used for this simulation, and the last columns are the summary statistics of this simulation.</p>
</td></tr>
<tr><td><code id="ABC_emulation_+3A_progress_bar">progress_bar</code></td>
<td>

<p>logical, <code>FALSE</code> by default. If <code>TRUE</code>, <code>ABC_rejection</code> will output a bar of progression with the estimated remaining computing time. Option not available with multiple cores.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned value is a list containing the following components: 
</p>
<table>
<tr><td><code>param</code></td>
<td>

<p>The model parameters used in the <code>model</code> simulations.</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>

<p>The summary statistics obtained at the end of the <code>model</code> simulations.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>

<p>The weights of the different <code>model</code> simulations. In the standard rejection scheme, all <code>model</code> simulations have the same weights.</p>
</td></tr>
<tr><td><code>stats_normalization</code></td>
<td>

<p>The standard deviation of the summary statistics across the <code>model</code> simulations.</p>
</td></tr>
<tr><td><code>nsim</code></td>
<td>

<p>The number of <code>model</code> simulations performed.</p>
</td></tr>
<tr><td><code>nrec</code></td>
<td>

<p>The number of retained simulations (if targeted summary statistics are provided).</p>
</td></tr>
<tr><td><code>computime</code></td>
<td>

<p>The computing time to perform the simulations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Franck Jabot, Thierry Faure and Nicolas Dumoulin</p>


<h3>References</h3>

<p>Jabot, F., Lagarrigues G., Courbaud B., Dumoulin N. (2015). A comparison of emulation methods for Approximate Bayesian Computation. To be published.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binary_model">binary_model</a></code>, <code><a href="#topic+binary_model_cluster">binary_model_cluster</a></code>, <code><a href="#topic+ABC_sequential">ABC_sequential</a></code>, <code><a href="#topic+ABC_mcmc">ABC_mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run:  

    ##### EXAMPLE 1 #####
    #####################

    ## the model is a C++ function packed into a R function -- the option 'use_seed'
    ##  must be turned to TRUE.
    trait_prior=list(c("unif",3,5),c("unif",-2.3,1.6),c("unif",-25,125),c("unif",-0.7,3.2))
    trait_prior

    ## only launching simulations with parameters drawn in the prior distributions
    ABC_emul = ABC_emulation(model=trait_model, prior=trait_prior,
      nb_design_pts=10, nb_simul=300, use_seed=TRUE, progress=TRUE)
    ABC_emul

    ## launching simulations with parameters drawn in the prior distributions and performing
    # the rejection step
    sum_stat_obs=c(100,2.5,20,30000)
    ABC_emul = ABC_emulation(model=trait_model, prior=trait_prior, tol=0.2, nb_design_pts=10,
      nb_simul=100, summary_stat_target=sum_stat_obs, use_seed=TRUE, progress=TRUE)
    ABC_emul

 
## End(Not run)
</code></pre>

<hr>
<h2 id='ABC_mcmc'>
Coupled to MCMC schemes for ABC
</h2><span id='topic+ABC_mcmc'></span>

<h3>Description</h3>

<p>This function implements three different algorithms to perform coupled to MCMC ABC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	ABC_mcmc(method, model, prior, summary_stat_target, prior_test=NULL, n_rec=100,
	n_between_sampling=10,	n_cluster = 1, use_seed = FALSE, verbose = FALSE,
	dist_weights=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ABC_mcmc_+3A_method">method</code></td>
<td>

<p>a character string indicating the ABC-MCMC algorithm to be used. Possible values are <code>"Marjoram_original"</code>, <code>"Marjoram"</code> and <code>"Wegmann"</code>.
Note that the method <code>"Marjoram_original"</code> cannot be used with multiple cores.</p>
</td></tr>
<tr><td><code id="ABC_mcmc_+3A_model">model</code></td>
<td>

<p>a <code>R</code> function implementing the model to be simulated. It must take as arguments a vector of model parameter values and it must return a vector of summary statistics. When using the option <code>use_seed=TRUE</code>, <code>model</code> must take as arguments a vector containing a seed value and the model parameter values.
A tutorial is provided in the package's vignette to dynamically link a binary code to a <code>R</code> function.  Users may alternatively wish to wrap their binary executables using the provided functions <code><a href="#topic+binary_model">binary_model</a></code> and <code><a href="#topic+binary_model_cluster">binary_model_cluster</a></code>. The use of these functions is associated with slightly different constraints on the design of the binary code (see <code><a href="#topic+binary_model">binary_model</a></code> and <code><a href="#topic+binary_model_cluster">binary_model_cluster</a></code>).</p>
</td></tr>
<tr><td><code id="ABC_mcmc_+3A_prior">prior</code></td>
<td>

<p>a list of prior information. Each element of the list corresponds to a model parameter. The list element must be a vector whose first argument determines the type of prior distribution: possible values are <code>"unif"</code> for a uniform distribution on a segment, <code>"normal"</code> for a normal distribution, <code>"lognormal"</code> for a lognormal distribution or <code>"exponential"</code> for an exponential distribution.
The following arguments of the list elements contain the characteritiscs of the prior distribution chosen: for <code>"unif"</code>, two numbers must be given: the minimum and maximum values of the uniform distribution; for <code>"normal"</code>, two numbers must be given: the mean and standard deviation of the normal distribution; for <code>"lognormal"</code>, two numbers must be given: the mean and standard deviation on the log scale of the lognormal distribution; for <code>"exponential"</code>, one number must be given: the rate of the exponential distribution. User-defined prior distributions can also be provided. See the vignette for additional information on this topic.</p>
</td></tr>
<tr><td><code id="ABC_mcmc_+3A_summary_stat_target">summary_stat_target</code></td>
<td>

<p>a vector containing the targeted (observed) summary statistics.</p>
</td></tr>
<tr><td><code id="ABC_mcmc_+3A_prior_test">prior_test</code></td>
<td>

<p>a string expressing the constraints between model parameters.
This expression will be evaluated as a logical expression, you can use all the logical operators including <code>"&lt;"</code>, <code>"&gt;"</code>, ...
Each parameter should be designated with <code>"X1"</code>, <code>"X2"</code>, ... in the same order as in the prior definition.
If not provided, no constraint will be applied.</p>
</td></tr>
<tr><td><code id="ABC_mcmc_+3A_n_rec">n_rec</code></td>
<td>

<p>a positive integer equal to the desired number of sampled points along the MCMC.</p>
</td></tr>
<tr><td><code id="ABC_mcmc_+3A_n_between_sampling">n_between_sampling</code></td>
<td>

<p>a positive integer equal to the desired spacing between sampled points along the MCMC.</p>
</td></tr>
<tr><td><code id="ABC_mcmc_+3A_n_cluster">n_cluster</code></td>
<td>

<p>a positive integer. If larger than 1 (the default value), <code>ABC_mcmc</code> will launch <code>model</code> simulations in parallel on <code>n_cluster</code> cores of the computer.</p>
</td></tr>
<tr><td><code id="ABC_mcmc_+3A_use_seed">use_seed</code></td>
<td>

<p>logical. If <code>FALSE</code> (default), <code>ABC_mcmc</code> provides as input to the function <code>model</code> a vector containing the model parameters used for the simulation.
If <code>TRUE</code>, <code>ABC_mcmc</code> provides as input to the function <code>model</code> a vector containing an integer seed value and the model parameters used for the simulation.
In this last case, the seed value should be used by <code>model</code> to initialize its pseudo-random number generators (if <code>model</code> is stochastic).</p>
</td></tr>
<tr><td><code id="ABC_mcmc_+3A_verbose">verbose</code></td>
<td>

<p>logical. <code>FALSE</code> by default. If <code>TRUE</code>, <code>ABC_mcmc</code> writes in the current directory intermediary results at the end of each step of the algorithm in the file &quot;output_mcmc&quot;.
These outputs have a matrix format, in wich each raw is a different simulation, the first columns are the parameters used for this simulation, the following columns are the summary statistics of this simulation, and the last column is the distance between the simulation and the data.</p>
</td></tr>
<tr><td><code id="ABC_mcmc_+3A_dist_weights">dist_weights</code></td>
<td>

<p>a vector containing the weights to apply to the distance between the computed and the targeted statistics.
These weights can be used to give more importance to a summary statistisc for example. The weights will
be normalized before applying them. If not provided, no weights will be applied.
</p>
</td></tr>
<tr><td><code id="ABC_mcmc_+3A_...">...</code></td>
<td>
<p>Additional arguments can be passed depending on the choosen method (see below)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the package's vignette for details on ABC-MCMC.
</p>


<h3>Value</h3>

<p>The returned value is a list containing the following components: 
</p>
<table>
<tr><td><code>param</code></td>
<td>

<p>The model parameters used in the <code>model</code> simulations.</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>

<p>The summary statistics obtained at the end of the <code>model</code> simulations.</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>

<p>The distance of the simulations to the data.</p>
</td></tr>
<tr><td><code>stats_normalization</code></td>
<td>

<p>The standard deviation of the summary statistics across the <code>model</code> simulations of the initial step.
These values are used to normalize the summary statistics before the computation of the Euclidean distance between simulations and data.
If <code>method</code> is <code>"Marjoram_original"</code>, this is equal to <code>tab_normalization</code>.
If <code>method</code> is <code>"Wegmann"</code>, this is not provided.</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>

<p>The final maximal distance between simulations and data in the retained sample of particles.</p>
</td></tr>
<tr><td><code>nsim</code></td>
<td>

<p>The number of <code>model</code> simulations performed.</p>
</td></tr>
<tr><td><code>n_between_sampling</code></td>
<td>

<p>The spacing between two sampled points in the MCMC.</p>
</td></tr>
<tr><td><code>computime</code></td>
<td>

<p>The computing time to perform the simulations.</p>
</td></tr>
<tr><td><code>min_stats</code></td>
<td>

<p>The minimal values of each summary statistics during the calibration step, given when <code>method</code> is <code>"Wegmann"</code>.</p>
</td></tr>
<tr><td><code>max_stats</code></td>
<td>

<p>The maximal values of each summary statistics during the calibration step, given when <code>method</code> is <code>"Wegmann"</code>.</p>
</td></tr>
<tr><td><code>lambda</code></td>
<td>

<p>The lambda values of the Box-Cox transformation, given when <code>method</code> is <code>"Wegmann"</code>.</p>
</td></tr>
<tr><td><code>geometric_mean</code></td>
<td>

<p>The geometric means, given when <code>method</code> is <code>"Wegmann"</code>.</p>
</td></tr>
<tr><td><code>boxcox_mean</code></td>
<td>

<p>The means of Box-Cox transforms, given when <code>method</code> is <code>"Wegmann"</code>.</p>
</td></tr>
<tr><td><code>boxcox_sd</code></td>
<td>

<p>The standard deviations of Box-Cox transforms, given when <code>method</code> is <code>"Wegmann"</code>.</p>
</td></tr>
<tr><td><code>pls_transform</code></td>
<td>

<p>The matrix of PLS transformation, given when <code>method</code> is <code>"Wegmann"</code>.</p>
</td></tr>
<tr><td><code>numcomp</code></td>
<td>

<p>The number of used components for the PLS transformation, given when <code>method</code> is <code>"Wegmann"</code>.</p>
</td></tr>
</table>


<h3>Additional parameters</h3>

<p>Depending on the choosen method, you can specify the following arguments:
</p>

<dl>
<dt>dist_max</dt><dd>
<p>a positive number, used when <code>method</code> is <code>"Marjoram_original"</code>.
This is the tolerance threshold used during the MCMC.
If not provided by the user, it is automatically computed as half the distance between the first simulation and the target summary statistics and a warning is printed.</p>
</dd>
<dt>tab_normalization</dt><dd>
<p>a vector of the same length as <code>summary_stat_target</code>, used when <code>method</code> is <code>"Marjoram_original"</code>.
Each element contains a positive number by which each summary statistics must be divided before the computation of the Euclidean distance between simulations and data.
If not provided by the user, the simulated summary statistics are divided by the target summary statistics and a warning is printed.</p>
</dd>
<dt>proposal_range</dt><dd>
<p>a vector of the same length as the number of model parameters, used when <code>method</code> is <code>"Marjoram_original"</code>.
Each element contains a positive number defining the range of MCMC jumps for each model parameter.
If not provided by the user, a default value is used for each parameter and a warning is printed. The default value is 1/50 of the prior range for uniform distributions, 1/20 of the standard deviation of the prior distribution for normal distributions, 1/20 * exp ( sigma * sigma </p>
</dd></dl>
<p> for lognormal distributions where sigma is the standard deviation of the prior distribution in the log scale, and 1/20 of the inverse of the rate for exponential distributions.
</p>
<dl>
<dt>n_calibration</dt><dd>
<p>a positive integer, used when <code>method</code> is <code>"Marjoram"</code> or <code>"Wegmann"</code>.
This is the number of simulations performed during the calibration step.
Default value is 10000.</p>
</dd>
<dt>tolerance_quantile</dt><dd>
<p>a positive number between 0 and 1 (strictly), used when <code>method</code> is <code>"Marjoram"</code> or <code>"Wegmann"</code>.
This is the percentage of simulations retained during the calibration step to determine the tolerance threshold to be used during the MCMC.
Default value is 0.01.</p>
</dd>
<dt>proposal_phi</dt><dd>
<p>a positive number, used when <code>method</code> is <code>"Marjoram"</code> or <code>"Wegmann"</code>.
This is a scaling factor defining the range of MCMC jumps.
Default value is 1.</p>
</dd>
<dt>numcomp</dt><dd>
<p>a positive integer, used when <code>method</code> is <code>"Wegmann"</code>.
This is the number of components to be used for PLS transformations.
Default value is 0 which encodes that this number is equal to the number of summary statistics.</p>
</dd>
<dt>seed_count</dt><dd>
<p>a positive integer, the initial seed value provided to the function <code>model</code> (if <code>use_seed=TRUE</code>). This value is incremented by 1 at each call of the function <code>model</code>.</p>
</dd>
<dt>progress_bar</dt><dd>
<p>logical, <code>FALSE</code> by default. If <code>TRUE</code>, <code>ABC_mcmc</code> will output a bar of progression with the estimated remaining computing time. Option not available with multiple cores.
</p>
</dd>
<dt>max_pick</dt><dd>
<p>a positive number, the max number of fails when moving particle inside the prior. Enabled only if inside_prior is to <code>TRUE</code>.
<code>10000</code> by default.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Franck Jabot, Thierry Faure and Nicolas Dumoulin</p>


<h3>References</h3>

<p>Marjoram, P., Molitor, J., Plagnol, V. and Tavar\'e, S. (2003) Markov chain Monte Carlo without likelihoods. <em>PNAS</em>, <b>100</b>, 15324&ndash;15328.
</p>
<p>Wegmann, D., Leuenberger, C. and Excoffier, L. (2009) Efficient approximate Bayesian computation coupled with Markov chain Monte Carlo without likelihood. <em>Genetics</em>, <b>182</b>, 1207-1218.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binary_model">binary_model</a></code>, <code><a href="#topic+binary_model_cluster">binary_model_cluster</a></code>, <code><a href="#topic+ABC_rejection">ABC_rejection</a></code>, <code><a href="#topic+ABC_emulation">ABC_emulation</a></code>, <code><a href="#topic+ABC_sequential">ABC_sequential</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run:  
    ##### EXAMPLE 1 #####
    #####################

    ## the model has two parameters and outputs two summary statistics.
    ## defining a simple toy model:
    toy_model&lt;-function(x){ c( x[1] + x[2] + rnorm(1,0,0.1) , x[1] * x[2] + rnorm(1,0,0.1) ) }

    ## define prior information
    toy_prior=list(c("unif",0,1),c("normal",1,2))
    # a uniform prior distribution between 0 and 1 for parameter 1, and a normal distribution
    # of mean 1 and standard deviation of 2 for parameter 2.

    ## define the targeted summary statistics
    sum_stat_obs=c(1.5,0.5)

    ## to perform the Marjoram et al. (2003)'s method:
    ##
    ABC_Marjoram_original&lt;-ABC_mcmc(method="Marjoram_original", model=toy_model, prior=toy_prior,
      summary_stat_target=sum_stat_obs)
    ABC_Marjoram_original

    ## artificial example to perform the Marjoram et al. (2003)'s method, with modifications
    # drawn from Wegmann et al. (2009) without Box-Cox and PLS transformations.
    ##
    ABC_Marjoram&lt;-ABC_mcmc(method="Marjoram", model=toy_model, prior=toy_prior,
      summary_stat_target=sum_stat_obs)
    ABC_Marjoram


    ## artificial example to perform the Wegmann et al. (2009)'s method.
    ##
    ABC_Wegmann&lt;-ABC_mcmc(method="Wegmann", model=toy_model, prior=toy_prior,
      summary_stat_target=sum_stat_obs)
    ABC_Wegmann


    ##### EXAMPLE 2 #####
    #####################

    ## this time, the model is a C++ function packed into a R function -- this time,
    # the option 'use_seed' must be turned to TRUE.

    ## define prior information
    trait_prior=list(c("unif",3,5),c("unif",-2.3,1.6),c("unif",-25,125),c("unif",-0.7,3.2))
    trait_prior

    ## define the targeted summary statistics
    sum_stat_obs=c(100,2.5,20,30000)


    ## artificial example to perform the Marjoram et al. (2003)'s method.
    ##
    n=10
    ABC_Marjoram_original&lt;-ABC_mcmc(method="Marjoram_original", model=trait_model,
    prior=trait_prior, summary_stat_target=sum_stat_obs, n_rec=n, use_seed=TRUE)
    ABC_Marjoram_original

    ## artificial example to perform the Marjoram et al. (2003)'s method, with modifications
    # drawn from Wegmann et al. (2009) without Box-Cox and PLS transformations.
    ##
    n=10
    n_calib=10
    tol_quant=0.2 
    ABC_Marjoram&lt;-ABC_mcmc(method="Marjoram", model=trait_model, prior=trait_prior,
      summary_stat_target=sum_stat_obs, n_rec=n, n_calibration=n_calib,
      tolerance_quantile=tol_quant, use_seed=TRUE)
    ABC_Marjoram


    ## artificial example to perform the Wegmann et al. (2009)'s method.
    ##
    n=10
    n_calib=10
    tol_quant=0.2 
    ABC_Wegmann&lt;-ABC_mcmc(method="Wegmann", model=trait_model, prior=trait_prior,
        summary_stat_target=sum_stat_obs, n_rec=n, n_calibration=n_calib,
        tolerance_quantile=tol_quant, use_seed=TRUE)
    ABC_Wegmann
 
## End(Not run)
</code></pre>

<hr>
<h2 id='ABC_rejection'>
Rejection sampling scheme for ABC</h2><span id='topic+ABC_rejection'></span>

<h3>Description</h3>

<p>This function launches a series of <code>nb_simul</code> model simulations with model parameters drawn in the prior distribution specified in <code>prior_matrix</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ABC_rejection(model, prior, nb_simul, prior_test=NULL, summary_stat_target=NULL,
  tol=NULL, use_seed=FALSE, seed_count=0, n_cluster=1, verbose=FALSE, progress_bar=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ABC_rejection_+3A_model">model</code></td>
<td>

<p>a <code>R</code> function implementing the model to be simulated. It must take as arguments a vector of model parameter values and it must return a vector of summary statistics. When using the option <code>use_seed=TRUE</code>, <code>model</code> must take as arguments a vector containing a seed value and the model parameter values.
A tutorial is provided in the package's vignette to dynamically link a binary code to a <code>R</code> function.  Users may alternatively wish to wrap their binary executables using the provided functions <code><a href="#topic+binary_model">binary_model</a></code> and <code><a href="#topic+binary_model_cluster">binary_model_cluster</a></code>. The use of these functions is associated with slightly different constraints on the design of the binary code (see <code><a href="#topic+binary_model">binary_model</a></code> and <code><a href="#topic+binary_model_cluster">binary_model_cluster</a></code>).</p>
</td></tr>
<tr><td><code id="ABC_rejection_+3A_prior">prior</code></td>
<td>

<p>a list of prior information. Each element of the list corresponds to a model parameter. The list element must be a vector whose first argument determines the type of prior distribution: possible values are <code>"unif"</code> for a uniform distribution on a segment, <code>"normal"</code> for a normal distribution, <code>"lognormal"</code> for a lognormal distribution or <code>"exponential"</code> for an exponential distribution.
The following arguments of the list elements contain the characteritiscs of the prior distribution chosen: for <code>"unif"</code>, two numbers must be given: the minimum and maximum values of the uniform distribution; for <code>"normal"</code>, two numbers must be given: the mean and standard deviation of the normal distribution; for <code>"lognormal"</code>, two numbers must be given: the mean and standard deviation on the log scale of the lognormal distribution; for <code>"exponential"</code>, one number must be given: the rate of the exponential distribution. User-defined prior distributions can also be provided. See the vignette for additional information on this topic.</p>
</td></tr>
<tr><td><code id="ABC_rejection_+3A_nb_simul">nb_simul</code></td>
<td>

<p>a positive integer equal to the desired number of simulations of the model.</p>
</td></tr>
<tr><td><code id="ABC_rejection_+3A_prior_test">prior_test</code></td>
<td>

<p>a string expressing the constraints between model parameters.
This expression will be evaluated as a logical expression, you can use all the logical operators including <code>"&lt;"</code>, <code>"&gt;"</code>, ...
Each parameter should be designated with <code>"X1"</code>, <code>"X2"</code>, ... in the same order as in the prior definition.
If not provided, no constraint will be applied.</p>
</td></tr>
<tr><td><code id="ABC_rejection_+3A_summary_stat_target">summary_stat_target</code></td>
<td>

<p>a vector containing the targeted (observed) summary statistics.
If not provided, <code>ABC_rejection</code> only launches the simulations and outputs the simulation results.</p>
</td></tr>
<tr><td><code id="ABC_rejection_+3A_tol">tol</code></td>
<td>

<p>tolerance, a strictly positive number (between 0 and 1) indicating the proportion of simulations retained nearest the targeted summary statistics.</p>
</td></tr>
<tr><td><code id="ABC_rejection_+3A_use_seed">use_seed</code></td>
<td>

<p>logical. If <code>FALSE</code> (default), <code>ABC_rejection</code> provides as input to the function <code>model</code> a vector containing the model parameters used for the simulation.
If <code>TRUE</code>, <code>ABC_rejection</code> provides as input to the function <code>model</code> a vector containing an integer seed value and the model parameters used for the simulation.
In this last case, the seed value should be used by <code>model</code> to initialize its pseudo-random number generators (if <code>model</code> is stochastic).</p>
</td></tr>
<tr><td><code id="ABC_rejection_+3A_seed_count">seed_count</code></td>
<td>

<p>a positive integer, the initial seed value provided to the function <code>model</code> (if <code>use_seed=TRUE</code>). This value is incremented by 1 at each call of the function <code>model</code>.</p>
</td></tr>
<tr><td><code id="ABC_rejection_+3A_n_cluster">n_cluster</code></td>
<td>

<p>a positive integer. If larger than 1 (the default value), <code>ABC_rejection</code> will launch <code>model</code> simulations in parallel on <code>n_cluster</code> cores of the computer.</p>
</td></tr>
<tr><td><code id="ABC_rejection_+3A_verbose">verbose</code></td>
<td>

<p>logical. <code>FALSE</code> by default. If <code>TRUE</code>, <code>ABC_rejection</code> writes in the current directory intermediary results at the end of each step of the algorithm in the file &quot;output&quot;.
These outputs have a matrix format, in wich each raw is a different simulation, the first columns are the parameters used for this simulation, and the last columns are the summary statistics of this simulation.</p>
</td></tr>
<tr><td><code id="ABC_rejection_+3A_progress_bar">progress_bar</code></td>
<td>

<p>logical, <code>FALSE</code> by default. If <code>TRUE</code>, <code>ABC_rejection</code> will output a bar of progression with the estimated remaining computing time. Option not available with multiple cores.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned value is a list containing the following components: 
</p>
<table>
<tr><td><code>param</code></td>
<td>

<p>The model parameters used in the <code>model</code> simulations.</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>

<p>The summary statistics obtained at the end of the <code>model</code> simulations.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>

<p>The weights of the different <code>model</code> simulations. In the standard rejection scheme, all <code>model</code> simulations have the same weights.</p>
</td></tr>
<tr><td><code>stats_normalization</code></td>
<td>

<p>The standard deviation of the summary statistics across the <code>model</code> simulations.</p>
</td></tr>
<tr><td><code>nsim</code></td>
<td>

<p>The number of <code>model</code> simulations performed.</p>
</td></tr>
<tr><td><code>nrec</code></td>
<td>

<p>The number of retained simulations (if targeted summary statistics are provided).</p>
</td></tr>
<tr><td><code>computime</code></td>
<td>

<p>The computing time to perform the simulations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Franck Jabot, Thierry Faure and Nicolas Dumoulin</p>


<h3>References</h3>

<p>Pritchard, J.K., and M.T. Seielstad and A. Perez-Lezaun and
M.W. Feldman (1999) Population growth of human Y chromosomes: a study
of Y chromosome microsatellites. <em>Molecular Biology and
Evolution</em>, <b>16</b>, 1791&ndash;1798.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binary_model">binary_model</a></code>, <code><a href="#topic+binary_model_cluster">binary_model_cluster</a></code>, <code><a href="#topic+ABC_sequential">ABC_sequential</a></code>, <code><a href="#topic+ABC_mcmc">ABC_mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    ##### EXAMPLE 1 #####
    #####################
    set.seed(1)

    ## artificial example to show how to use the 'ABC_rejection' function.
    ## defining a simple toy model:
    toy_model&lt;-function(x){ 2 * x + 5 + rnorm(1,0,0.1) }

    ## define prior information
    toy_prior=list(c("unif",0,1)) # a uniform prior distribution between 0 and 1

    ## only launching simulations with parameters drawn in the prior distributions
    set.seed(1)
    n=10
    ABC_sim&lt;-ABC_rejection(model=toy_model, prior=toy_prior, nb_simul=n)
    ABC_sim

    ## launching simulations with parameters drawn in the prior distributions
    # and performing the rejection step
    sum_stat_obs=6.5
    tolerance=0.2
    ABC_rej&lt;-ABC_rejection(model=toy_model, prior=toy_prior, nb_simul=n,
      summary_stat_target=sum_stat_obs, tol=tolerance)

    ## NB: see the package's vignette to see how to pipeline 'ABC_rejection' with the function
    # 'abc' of the package 'abc' to perform other rejection schemes.
 ## Not run:  

    ##### EXAMPLE 2 #####
    #####################

    ## this time, the model has two parameters and outputs two summary statistics.
    ## defining a simple toy model:
    toy_model2&lt;-function(x){ c( x[1] + x[2] + rnorm(1,0,0.1) , x[1] * x[2] + rnorm(1,0,0.1) ) }

    ## define prior information
    toy_prior2=list(c("unif",0,1),c("normal",1,2))
    # a uniform prior distribution between 0 and 1 for parameter 1, and a normal distribution
    # of mean 1 and standard deviation of 2 for parameter 2.

    ## only launching simulations with parameters drawn in the prior distributions
    set.seed(1)
    n=10
    ABC_sim&lt;-ABC_rejection(model=toy_model2, prior=toy_prior2, nb_simul=n)
    ABC_sim

    ## launching simulations with parameters drawn in the prior distributions
    # and performing the rejection step
    sum_stat_obs2=c(1.5,0.5)
    tolerance=0.2
    ABC_rej&lt;-ABC_rejection(model=toy_model2, prior=toy_prior2, nb_simul=n,
      summary_stat_target=sum_stat_obs2, tol=tolerance)

    ## NB: see the package's vignette to see how to pipeline 'ABC_rejection' with the function
    # 'abc' of the package 'abc' to perform other rejection schemes.


    ##### EXAMPLE 3 #####
    #####################

    ## this time, the model is a C++ function packed into a R function -- this time, the option
    # 'use_seed' must be turned to TRUE.
    n=10
    trait_prior=list(c("unif",3,5),c("unif",-2.3,1.6),c("unif",-25,125),c("unif",-0.7,3.2))
    trait_prior

    ## only launching simulations with parameters drawn in the prior distributions
    ABC_sim&lt;-ABC_rejection(model=trait_model, prior=trait_prior, nb_simul=n, use_seed=TRUE)
    ABC_sim

    ## launching simulations with parameters drawn in the prior distributions and performing
    # the rejection step
    sum_stat_obs=c(100,2.5,20,30000)
    tolerance=0.2
    ABC_rej&lt;-ABC_rejection(model=trait_model, prior=trait_prior, nb_simul=n,
      summary_stat_target=sum_stat_obs, tol=tolerance, use_seed=TRUE)

    ## NB: see the package's vignette to see how to pipeline 'ABC_rejection' with the function
    # 'abc' of the package 'abc' to perform other rejection schemes.


    ##### EXAMPLE 4 - Parallel implementations #####
    ################################################

    ## NB: the option use_seed must be turned to TRUE.

    ## For models already running with the option use_seed=TRUE, simply change
    # the value of n_cluster:
    sum_stat_obs=c(100,2.5,20,30000)
    ABC_simb&lt;-ABC_rejection(model=trait_model, prior=trait_prior, nb_simul=n,
      use_seed=TRUE, n_cluster=2)

    ## For other models, change the value of n_cluster and modify the model so that the first
    # parameter becomes a seed information value:
    toy_model_parallel&lt;-function(x){ 
	set.seed(x[1])
	2 * x[2] + 5 + rnorm(1,0,0.1) }
    sum_stat_obs=6.5

    ABC_simb&lt;-ABC_rejection(model=toy_model_parallel, prior=toy_prior, nb_simul=n,
      use_seed=TRUE, n_cluster=2)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='ABC_sequential'>
Sequential sampling schemes for ABC</h2><span id='topic+ABC_sequential'></span>

<h3>Description</h3>

<p>This function implements four different algorithms to perform sequential sampling schemes for ABC.
Sequential sampling schemes consist in sampling initially model parameters in the prior distribution, just like in a standard rejection-based ABC, in order to obtain a rough posterior distribution of parameter values, and in subsequently sampling close to this rough posterior distribution to refine it.
Sequential sampling schemes have been shown to be more efficient than standard rejection-based procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	ABC_sequential(method, model, prior, nb_simul, summary_stat_target,
          prior_test=NULL, n_cluster = 1, use_seed = FALSE, verbose = FALSE,
          dist_weights=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ABC_sequential_+3A_method">method</code></td>
<td>

<p>a character string indicating the sequential algorithm to be used. Possible values are <code>"Beaumont"</code>, <code>"Drovandi"</code>, <code>"Delmoral"</code>, <code>"Lenormand"</code> and <code>"Emulation"</code>.</p>
</td></tr>
<tr><td><code id="ABC_sequential_+3A_model">model</code></td>
<td>

<p>a <code>R</code> function implementing the model to be simulated. It must take as arguments a vector of model parameter values and it must return a vector of summary statistics. When using the option <code>use_seed=TRUE</code>, <code>model</code> must take as arguments a vector containing a seed value and the model parameter values.
A tutorial is provided in the package's vignette to dynamically link a binary code to a <code>R</code> function.  Users may alternatively wish to wrap their binary executables using the provided functions <code><a href="#topic+binary_model">binary_model</a></code> and <code><a href="#topic+binary_model_cluster">binary_model_cluster</a></code>. The use of these functions is associated with slightly different constraints on the design of the binary code (see <code><a href="#topic+binary_model">binary_model</a></code> and <code><a href="#topic+binary_model_cluster">binary_model_cluster</a></code>).</p>
</td></tr>
<tr><td><code id="ABC_sequential_+3A_prior">prior</code></td>
<td>

<p>a list of prior information. Each element of the list corresponds to a model parameter. The list element must be a vector whose first argument determines the type of prior distribution: possible values are <code>"unif"</code> for a uniform distribution on a segment, <code>"normal"</code> for a normal distribution, <code>"lognormal"</code> for a lognormal distribution or <code>"exponential"</code> for an exponential distribution.
The following arguments of the list elements contain the characteritiscs of the prior distribution chosen: for <code>"unif"</code>, two numbers must be given: the minimum and maximum values of the uniform distribution; for <code>"normal"</code>, two numbers must be given: the mean and standard deviation of the normal distribution; for <code>"lognormal"</code>, two numbers must be given: the mean and standard deviation on the log scale of the lognormal distribution; for <code>"exponential"</code>, one number must be given: the rate of the exponential distribution.
Note that when using the method &quot;Lenormand&quot;, solely uniform prior distributions are supported. User-defined prior distributions can also be provided. See the vignette for additional information on this topic.</p>
</td></tr>
<tr><td><code id="ABC_sequential_+3A_nb_simul">nb_simul</code></td>
<td>

<p>a positive integer equal to the desired number of simulations of the model below the tolerance threshold when <code>method</code> is <code>"Beaumont"</code>, <code>"Drovandi"</code> and <code>"Delmoral"</code>.
When <code>method</code> is <code>"Lenormand"</code>, the number of simulations below the tolerance threshold is equal to <code>nb_simul * alpha</code>. See the package's vignette and Lenormand et al. (2012) for details.</p>
</td></tr>
<tr><td><code id="ABC_sequential_+3A_summary_stat_target">summary_stat_target</code></td>
<td>

<p>a vector containing the targeted (observed) summary statistics.</p>
</td></tr>
<tr><td><code id="ABC_sequential_+3A_prior_test">prior_test</code></td>
<td>

<p>a string expressing the constraints between model parameters.
This expression will be evaluated as a logical expression, you can use all the logical operators including <code>"&lt;"</code>, <code>"&gt;"</code>, ...
Each parameter should be designated with <code>"X1"</code>, <code>"X2"</code>, ... in the same order as in the prior definition.
If not provided, no constraint will be applied.</p>
</td></tr>
<tr><td><code id="ABC_sequential_+3A_n_cluster">n_cluster</code></td>
<td>

<p>a positive integer. If larger than 1 (the default value), <code>ABC_sequential</code> will launch <code>model</code> simulations in parallel on <code>n_cluster</code> cores of the computer.</p>
</td></tr>
<tr><td><code id="ABC_sequential_+3A_use_seed">use_seed</code></td>
<td>

<p>logical. If <code>FALSE</code> (default), <code>ABC_sequential</code> provides as input to the function <code>model</code> a vector containing the model parameters used for the simulation.
If <code>TRUE</code>, <code>ABC_sequential</code> provides as input to the function <code>model</code> a vector containing an integer seed value and the model parameters used for the simulation.
In this last case, the seed value should be used by <code>model</code> to initialize its pseudo-random number generators (if <code>model</code> is stochastic).</p>
</td></tr>
<tr><td><code id="ABC_sequential_+3A_verbose">verbose</code></td>
<td>

<p>logical. <code>FALSE</code> by default. If <code>TRUE</code>, <code>ABC_sequential</code> writes in the current directory intermediary results at the end of each step of the algorithm various files.
The file &quot;n_simul_tot_step_iteration&quot; (where iteration is the step number) contains the total number of simulations performed since the beginning of the algorithm at the end of the step &quot;iteration&quot;.
The file &quot;R_step_iteration&quot; (when using the method &quot;Drovandi&quot;) is the parameter R used during the step &quot;iteration&quot; (see Drovandi and Pettitt 2011 for details).
The file &quot;p_acc_iteration&quot; (when using the method &quot;Lenormand&quot;) is the parameter p_acc computed at the end of the step &quot;iteration&quot; (see Lenormand et al. 2012 for details).
The file &quot;tolerance_step_iteration&quot; (when using the method &quot;Drovandi&quot;, &quot;Delmoral&quot; or &quot;Lenormand&quot;) is the tolerance computed at the end of the step &quot;iteration&quot;.
The file &quot;output_step_iteration&quot; gives the simulations kept after each iteration and has a matrix format, in wich each row is a different simulation, the first column is the weight of the simulation, the following columns are the parameters used for this simulation, and the last columns are the summary statistics of this simulation.
The file &quot;model_step_iteration&quot; gives the simulations performed at each iteration and has a matrix format, in which each row is a different simulation, the first column is the weight of the simulation, the following columns are the parameters used for this simulation, and the last columns are the summary statistics of this simulation.
All these informations are further stored in a list (with the same formats) and are accessible from R - see <code>intermediary</code> in the value section below.</p>
</td></tr>
<tr><td><code id="ABC_sequential_+3A_dist_weights">dist_weights</code></td>
<td>

<p>a vector containing the weights to apply to the distance between the computed and the targeted statistics.
These weights can be used to give more importance to a summary statistisc for example. The weights will
be normalized before applying them. If not provided, no weights will be applied.
</p>
</td></tr>
<tr><td><code id="ABC_sequential_+3A_...">...</code></td>
<td>
<p>Additional arguments can be passed depending on the choosen method (see below)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the package's vignette for details on the four algorithms.
</p>


<h3>Value</h3>

<p>The returned value is a list containing the following components: 
</p>
<table>
<tr><td><code>param</code></td>
<td>

<p>The model parameters used in the <code>model</code> simulations.</p>
</td></tr>
<tr><td><code>stats</code></td>
<td>

<p>The summary statistics obtained at the end of the <code>model</code> simulations.</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>

<p>The weights of the different <code>model</code> simulations.</p>
</td></tr>
<tr><td><code>stats_normalization</code></td>
<td>

<p>The standard deviation of the summary statistics across the <code>model</code> simulations of the initial step.
These values are used to normalize the summary statistics before the computation of the Euclidean distance between simulations and data.</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>

<p>The final maximal distance between simulations and data in the retained sample of particles.</p>
</td></tr>
<tr><td><code>nsim</code></td>
<td>

<p>The number of <code>model</code> simulations performed.</p>
</td></tr>
<tr><td><code>computime</code></td>
<td>

<p>The computing time to perform the simulations.</p>
</td></tr>
<tr><td><code>intermediary</code></td>
<td>

<p>Intermediary results stored when the option <code>"verbose=TRUE"</code> is chosen. Each element of this list corresponds to a different step. See the argument <code>verbose</code> above for more details on the information stored.</p>
</td></tr>
</table>


<h3>Additional parameters</h3>

<p>Depending on the choosen method, you can specify the following arguments:
</p>

<dl>
<dt>seed_count</dt><dd>
<p>a positive integer, the initial seed value provided to the function <code>model</code> (if <code>use_seed=TRUE</code>). This value is incremented by 1 at each call of the function <code>model</code>.</p>
</dd>
<dt>inside_prior</dt><dd>
<p>logical used when <code>method</code> is <code>"Beaumont"</code>, <code>"Lenormand"</code> or <code>"Emulation"</code>. <code>TRUE</code> by default.
If <code>FALSE</code>, parameter sampling is not restricted to the initial ranges of the prior distribution during the subsequent algorithm steps.</p>
</dd>
<dt>tolerance_tab</dt><dd>
<p>a vector containing the sequence of tolerance thresholds when <code>method</code> is <code>"Beaumont"</code>, or the targeted final tolerance threshold when <code>method</code> is <code>"Drovandi"</code>.</p>
</dd>
<dt>alpha</dt><dd>
<p>a positive number between 0 and 1 (strictly) used when <code>method</code> is <code>"Drovandi"</code>, <code>"Delmoral"</code>, <code>"Lenormand"</code> or <code>"Emulation"</code>.
<code>alpha</code> is the proportion of particles rejected at each step in the algorithm <code>"Drovandi"</code>.
This is the proportion of particles kept at each step in the algorithms <code>"Delmoral"</code>, <code>"Lenormand"</code> and <code>"Emulation"</code>.
Default values are 0.5 when <code>method</code> is <code>"Drovandi"</code>, <code>"Lenormand"</code> or <code>"Emulation"</code> and 0.9 for <code>"Delmoral"</code>.
See the package's vignette for details.</p>
</dd>
<dt>c</dt><dd>
<p>a positive number between 0 and 1 (strictly) used when <code>method</code> is <code>"Drovandi"</code>.
This is the expected proportion of particles which are going to be duplicated at each step.
Default value is 0.01.
See the package's vignette and Drovandi and Pettitt (2011) for details.</p>
</dd>
<dt>first_tolerance_level_auto</dt><dd>
<p>logical used when <code>method</code> is <code>"Drovandi"</code>.
Default value is <code>TRUE</code>. In this case, the first tolerance threshold is determined by the algorithm, by taking the 1-<code>alpha</code> quantile of the distances between the simulated and targeted summary statistics.
If <code>FALSE</code>, the initial tolerance threshold for the first step has to be provided as the first element of the vector <code>tolerance_tab</code>. In this case, the targeted final tolerance threshold is the second element of <code>tolerance_tab</code>.</p>
</dd>
<dt>M</dt><dd>
<p>a positive integer used when <code>method</code> is <code>"Delmoral"</code>.
This is the number of <code>model</code> simulations performed for each parameter set.
Default value is 1. See the package's vignette and Del Moral et al. (2012) for details.</p>
</dd>
<dt>nb_threshold</dt><dd>
<p>a positive integer used when <code>method</code> is <code>"Delmoral"</code>. Default value is 0.5*<code>nb_simul</code>.
This is the minimal effective sample size below which a resampling step is launched. See the package's vignette and Del Moral et al. (2012) for details.</p>
</dd>
<dt>tolerance_target</dt><dd>
<p>a positive number used when <code>method</code> is <code>"Delmoral"</code>.
This is the targeted final tolerance threshold.</p>
</dd>
<dt>p_acc_min</dt><dd>
<p>a positive number between 0 and 1 (strictly) used when <code>method</code> is <code>"Lenormand"</code> or <code>"Emulation"</code>.
This is the stopping criterion of the algorithm: a small number ensures a better convergence of the algorithm, but at a cost in computing time.
Default value is 0.05. See the package's vignette and Lenormand et al. (2012) for details.</p>
</dd>
<dt>n_step_emulation</dt><dd>
<p>a positive integer, the number of times the emulation is repeated. <code>9</code> by default.
</p>
</dd>
<dt>emulator_span</dt><dd>
<p>a positive number, the number of design points selected for the local regression.
<code>50</code> by default.
</p>
</dd>
<dt>progress_bar</dt><dd>
<p>logical, <code>FALSE</code> by default. If <code>TRUE</code>, <code>ABC_sequential</code> will output a bar of progression with the estimated remaining computing time. Option not available with multiple cores.
</p>
</dd>
<dt>max_pick</dt><dd>
<p>a positive number, the max number of fails when moving particle inside the prior. Enabled only if inside_prior is to <code>TRUE</code>.
<code>10000</code> by default.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Franck Jabot, Thierry Faure and Nicolas Dumoulin</p>


<h3>References</h3>

<p>Beaumont, M. A., Cornuet, J., Marin, J., and Robert, C. P. (2009) Adaptive approximate Bayesian computation. <em>Biometrika</em>,<b>96</b>, 983&ndash;990.
</p>
<p>Del Moral, P., Doucet, A., and Jasra, A. (2012) An adaptive sequential Monte Carlo method for approximate Bayesian computation. <em>Statistics and Computing</em>, <b>22</b>, 1009&ndash;1020.
</p>
<p>Drovandi, C. C. and Pettitt, A. N. (2011) Estimation of parameters for macroparasite population evolution using approximate Bayesian computation. <em>Biometrics</em>, <b>67</b>, 225&ndash;233.
</p>
<p>Lenormand, M., Jabot, F., Deffuant G. (2012) Adaptive approximate Bayesian computation for complex models. http://arxiv.org/pdf/1111.1308.pdf
</p>
<p>Jabot, F., Lagarrigues G., Courbaud B., Dumoulin N. (2015). A comparison of emulation methods for Approximate Bayesian Computation. To be published.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binary_model">binary_model</a></code>, <code><a href="#topic+binary_model_cluster">binary_model_cluster</a></code>, <code><a href="#topic+ABC_rejection">ABC_rejection</a></code>, <code><a href="#topic+ABC_emulation">ABC_emulation</a></code>, <code><a href="#topic+ABC_mcmc">ABC_mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run:  
    ##### EXAMPLE 1 #####
    #####################
    set.seed(1)

    ## artificial example to show how to use the 'ABC_sequential' function.
    ## defining a simple toy model:
    toy_model&lt;-function(x){ 2 * x + 5 + rnorm(1,0,0.1) }

    ## define prior information
    toy_prior=list(c("unif",0,1)) # a uniform prior distribution between 0 and 1

    ## define the targeted summary statistics
    sum_stat_obs=6.5

    ## to perform the Beaumont et al. (2009)'s method:
    ##
    tolerance=c(1.5,0.5)
    ABC_Beaumont&lt;-ABC_sequential(method="Beaumont", model=toy_model, prior=toy_prior,
    nb_simul=20, summary_stat_target=sum_stat_obs, tolerance_tab=tolerance)
    ABC_Beaumont

    ## to perform the Drovandi and Pettitt (2011)'s method:
    ##
    tolerance=0.5
    c_drov=0.7
    ABC_Drovandi&lt;-ABC_sequential(method="Drovandi", model=toy_model, prior=toy_prior,
    nb_simul=20, summary_stat_target=sum_stat_obs, tolerance_tab=tolerance, c=c_drov)
    ABC_Drovandi

    ## to perform the Del Moral et al. (2012)'s method:
    ##
    alpha_delmo=0.5
    tolerance=0.5
    ABC_Delmoral&lt;-ABC_sequential(method="Delmoral", model=toy_model, prior=toy_prior,
    nb_simul=20, summary_stat_target=sum_stat_obs, alpha=alpha_delmo, tolerance_target=tolerance)
    ABC_Delmoral

    ## to perform the Lenormand et al. (2012)'s method:
    ##
    pacc=0.4
    ABC_Lenormand&lt;-ABC_sequential(method="Lenormand", model=toy_model, prior=toy_prior,
    nb_simul=20, summary_stat_target=sum_stat_obs, p_acc_min=pacc)
    ABC_Lenormand


    ##### EXAMPLE 2 #####
    #####################

    ## this time, the model has two parameters and outputs two summary statistics.
    ## defining a simple toy model:
    toy_model2&lt;-function(x){ c( x[1] + x[2] + rnorm(1,0,0.1) , x[1] * x[2] + rnorm(1,0,0.1) ) }

    ## define prior information
    toy_prior2=list(c("unif",0,1),c("normal",1,2))
    # a uniform prior distribution between 0 and 1 for parameter 1, and a normal distribution
    # of mean 1 and standard deviation of 2 for parameter 2.

    ## define the targeted summary statistics
    sum_stat_obs2=c(1.5,0.5)

    ## to perform the Beaumont et al. (2009)'s method:
    ##
    tolerance=c(1.5,0.5)
    ABC_Beaumont&lt;-ABC_sequential(method="Beaumont", model=toy_model2, prior=toy_prior2,
    nb_simul=20, summary_stat_target=sum_stat_obs2, tolerance_tab=tolerance)
    ABC_Beaumont

    ## to perform the Drovandi and Pettitt (2011)'s method:
    ##
    tolerance=0.5
    c_drov=0.7
    ABC_Drovandi&lt;-ABC_sequential(method="Drovandi", model=toy_model2, prior=toy_prior2,
    nb_simul=20, summary_stat_target=sum_stat_obs2, tolerance_tab=tolerance, c=c_drov)
    ABC_Drovandi

    ## to perform the Del Moral et al. (2012)'s method:
    ##
    alpha_delmo=0.5
    tolerance=0.5
    ABC_Delmoral&lt;-ABC_sequential(method="Delmoral", model=toy_model2, prior=toy_prior2,
    nb_simul=20, summary_stat_target=sum_stat_obs2, alpha=alpha_delmo, tolerance_target=tolerance)
    ABC_Delmoral

    ## to perform the Lenormand et al. (2012)'s method:
    ##
    pacc=0.4
    # Only uniform priors are supported for the method "Lenormand" (since it performs a Latin
    # Hypercube sampling at the beginning):
    toy_prior2=list(c("unif",0,1),c("unif",0.5,1.5))
    # a uniform prior distribution between 0 and 1 for parameter 1, and a normal distribution of
    # mean 1 and standard deviation of 1 for parameter 2.
    ABC_Lenormand&lt;-ABC_sequential(method="Lenormand", model=toy_model2, prior=toy_prior2,
    nb_simul=20, summary_stat_target=sum_stat_obs2, p_acc_min=pacc)
    ABC_Lenormand

    ##### EXAMPLE 3 #####
    #####################

    ## this time, the model is a C++ function packed into a R function -- this time, the option
    # 'use_seed' must be turned to TRUE.
    n=10
    ## define prior information
    trait_prior=list(c("unif",3,5),c("unif",-2.3,1.6),c("unif",-25,125),c("unif",-0.7,3.2))
    trait_prior

    ## define the targeted summary statistics
    sum_stat_obs=c(100,2.5,20,30000)

    ## to perform the Beaumont et al. (2009)'s method:
    ##
    tolerance=c(8,5)
    ABC_Beaumont&lt;-ABC_sequential(method="Beaumont", model=trait_model, prior=trait_prior,
    nb_simul=20, summary_stat_target=sum_stat_obs, tolerance_tab=tolerance, use_seed=TRUE)
    ABC_Beaumont

    ## to perform the Drovandi and Pettitt (2011)'s method:
    ##
    tolerance=3
    c_drov=0.7
    ABC_Drovandi&lt;-ABC_sequential(method="Drovandi", model=trait_model, prior=trait_prior,
      nb_simul=20, summary_stat_target=sum_stat_obs, tolerance_tab=tolerance, c=c_drov,
      use_seed=TRUE)
    ABC_Drovandi

    ## to perform the Del Moral et al. (2012)'s method:
    ##
    alpha_delmo=0.5
    tolerance=3
    ABC_Delmoral&lt;-ABC_sequential(method="Delmoral", model=trait_model, prior=trait_prior,
      nb_simul=20, summary_stat_target=sum_stat_obs, alpha=alpha_delmo,
      tolerance_target=tolerance, use_seed=TRUE)
    ABC_Delmoral

    ## to perform the Lenormand et al. (2012)'s method:
    ##
    pacc=0.4
    ABC_Lenormand&lt;-ABC_sequential(method="Lenormand", model=trait_model, prior=trait_prior,
      nb_simul=20, summary_stat_target=sum_stat_obs, p_acc_min=pacc, use_seed=TRUE)
    ABC_Lenormand


    ##### EXAMPLE 4 - Parallel implementations #####
    ################################################

    ## NB: the option use_seed must be turned to TRUE.

    ## For models already running with the option use_seed=TRUE, simply change
    # the value of n_cluster:
    sum_stat_obs=c(100,2.5,20,30000)
    ABC_Lenormand&lt;-ABC_sequential(method="Lenormand", model=trait_model, prior=trait_prior,
    nb_simul=20, summary_stat_target=sum_stat_obs, p_acc_min=pacc, use_seed=TRUE, n_cluster=2)
    ABC_Lenormand

    ## For other models, change the value of n_cluster and modify the model so that the
    # first parameter becomes a seed information value:
    toy_model_parallel&lt;-function(x){ 
	set.seed(x[1])
	2 * x[2] + 5 + rnorm(1,0,0.1) }
    sum_stat_obs=6.5

    ABC_Lenormand&lt;-ABC_sequential(method="Lenormand", model=toy_model_parallel, prior=toy_prior,
    nb_simul=20, summary_stat_target=sum_stat_obs, p_acc_min=pacc, use_seed=TRUE, n_cluster=2)
    ABC_Lenormand
 
## End(Not run)
</code></pre>

<hr>
<h2 id='binary_model'>
Wrapper for a binary executable for non-parallel simulations</h2><span id='topic+binary_model'></span>

<h3>Description</h3>

<p>This function enables to link a binary executable to a <code>R</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  binary_model(command)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binary_model_+3A_command">command</code></td>
<td>

<p>a character string indicating the command to launch the executable on your system.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A binary executable used with <code>binary_model</code> has to be placed in the current directory of the <code>R</code> session.
It further has to respect several constraints: it has to read the seed for its pseudo-random number generator and the model parameters in a file &quot;input&quot;, and it must write the summary statistic in a file &quot;output&quot;.
The file &quot;input&quot; will be generated by the wrapper <code>binary_model</code> in the current directory of the <code>R</code> session, and the wrapper will read the file &quot;output&quot; generated by the binary executable.
In the file &quot;input&quot;, the first line contains the seed, and each subsequent line contains one model parameter value.
In the file &quot;output&quot;, each summary statistic should be separated by a space or a tab separation.
This wrapper should be used for use with a single core of the computer. If the user wishes to use several cores of the computer, the wrapper <code><a href="#topic+binary_model_cluster">binary_model_cluster</a></code> should be used.
Note that the files &quot;input&quot; and &quot;output&quot; are deleted by the wrapper at the end of the function.
</p>


<h3>Value</h3>

<p>A <code>R</code> function wrapping the binary executable, to be used with the <code>EasyABC</code> functions.
</p>


<h3>Author(s)</h3>

<p>Franck Jabot, Thierry Faure and Nicolas Dumoulin</p>


<h3>See Also</h3>

<p><code><a href="#topic+binary_model_cluster">binary_model_cluster</a></code>, <code><a href="#topic+ABC_rejection">ABC_rejection</a></code>, <code><a href="#topic+ABC_sequential">ABC_sequential</a></code>, <code><a href="#topic+ABC_mcmc">ABC_mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
 ## Not run: 
    ## artificial example to show how to use the binary_model function with
    # an executable "My_Executable"
    ABC_rej&lt;-ABC_rejection(model=binary_model("./My_Executable"), prior=..., n_cluster=1,...)

    # NB: on windows, "My_Executable" should be of the form "My_Executable.exe" :
    ABC_rej&lt;-ABC_rejection(model=binary_model("./My_Executable.exe"), prior=..., n_cluster=1,...)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='binary_model_cluster'>
Wrapper for a binary executable for parallel simulations</h2><span id='topic+binary_model_cluster'></span>

<h3>Description</h3>

<p>This function enables to link a binary executable to a <code>R</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  binary_model_cluster(command)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binary_model_cluster_+3A_command">command</code></td>
<td>

<p>a character string indicating the command to launch the executable on your system.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A binary executable used with <code>binary_model_cluster</code> has to be placed in the current directory of the <code>R</code> session.
It further has to respect several constraints: 
1- it has to have a single argument: a number <code>k</code> used by the binary executable to know in which files read and write.
2- it has to read the seed for its pseudo-random number generator and the model parameters in a file &quot;inputk&quot; (where k is the argument passed to the executable: input1, input2,...).
3- it has to write the summary statistic in a file &quot;outputk&quot; (where k is the argument passed to the executable: output1, output2,...).
The file &quot;inputk&quot; will be generated by the wrapper <code>binary_model_cluster</code> in the current directory of the <code>R</code> session, and the wrapper will read the file &quot;outputk&quot; generated by the binary executable.
This construction ensures that each core reads and writes in different files.
In the file &quot;inputk&quot;, the first line contains the seed, and each subsequent line contains one model parameter value.
In the file &quot;outputk&quot;, each summary statistic should be separated by a space or a tab separation.
This wrapper should be used for use with multiple cores of the computer. If the user wishes to use a single core of the computer, the wrapper <code><a href="#topic+binary_model">binary_model</a></code> should be used.
Note that the files &quot;inputk&quot; and &quot;outputk&quot; are deleted by the wrapper at the end of the function.
</p>


<h3>Value</h3>

<p>A <code>R</code> function wrapping the binary executable, to be used with the <code>EasyABC</code> functions.
</p>


<h3>Author(s)</h3>

<p>Franck Jabot, Thierry Faure and Nicolas Dumoulin</p>


<h3>See Also</h3>

<p><code><a href="#topic+binary_model">binary_model</a></code>, <code><a href="#topic+ABC_rejection">ABC_rejection</a></code>, <code><a href="#topic+ABC_sequential">ABC_sequential</a></code>, <code><a href="#topic+ABC_mcmc">ABC_mcmc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
 ## Not run: 
    ## artificial example to show how to use the binary_model function with
    # an executable "My_Executable"
    ABC_rej&lt;-ABC_rejection(model=binary_model_cluster("./My_Executable"),
      prior=..., n_cluster=2,...)
    # NB: on windows, "My_Executable" should be of the form "My_Executable.exe" :
    ABC_rej&lt;-ABC_rejection(model=binary_model_cluster("./My_Executable.exe"),
      prior=..., n_cluster=2,...)
 
## End(Not run)
</code></pre>

<hr>
<h2 id='EasyABC-internal'>Internal EasyABC objects</h2><span id='topic+EasyABC-internal'></span>

<h3>Description</h3>

<p>Internal EasyABC objects.</p>


<h3>Details</h3>

<p>These are not to be called by the user.</p>

<hr>
<h2 id='EasyABC-package'>EasyABC: performing efficient approximate Bayesian computation sampling schemes using R</h2><span id='topic+EasyABC-package'></span><span id='topic+EasyABC'></span>

<h3>Description</h3>

<p>The package EasyABC enables to launch a series of simulations of a computer code from the R platform,
and to retrieve the simulation outputs in an appropriate format for post-processing treatments.
Four sequential sampling schemes, three coupled-to-MCMC schemes and a Simulated Annealing scheme are implemented.
EasyABC further enables to launch the simulations in parallel on multiple cores of a computer.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: EasyABC
Type: Package
Version: 1.5.1
Date: 2022-09-21
License: GPL-3
LazyLoad: yes
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Franck Jabot, Thierry Faure, Nicolas Dumoulin, Carlo Albert</p>


<h3>See Also</h3>

<p><code><a href="#topic+ABC_rejection">ABC_rejection</a></code>, <code><a href="#topic+ABC_sequential">ABC_sequential</a></code>, <code><a href="#topic+ABC_mcmc">ABC_mcmc</a></code>, <code><a href="#topic+SABC">SABC</a></code>, <code><a href="#topic+binary_model">binary_model</a></code>, <code><a href="#topic+binary_model_cluster">binary_model_cluster</a></code>
</p>

<hr>
<h2 id='SABC'>Simulated Annealing approach to Approximate Bayesian Computation (SABC)</h2><span id='topic+SABC'></span><span id='topic+SABC.noninf'></span><span id='topic+SABC.inf'></span>

<h3>Description</h3>

<p>Algorithms for the Simulated Annealing approach to Approximate Bayesian Computation (SABC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SABC(r.model, r.prior, d.prior, n.sample, eps.init, iter.max,
     v=ifelse(method=="informative",0.4,1.2), beta=0.8,
     delta=0.1, resample=5*n.sample, verbose=n.sample,
     method="noninformative", adaptjump=TRUE,
     summarystats=FALSE, y=NULL, f.summarystats=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SABC_+3A_r.model">r.model</code></td>
<td>
<p>Function that returns either a random sample from the likelihood or a scalar distance between such a sample and the data. The first argument must be the parameter vector.</p>
</td></tr>
<tr><td><code id="SABC_+3A_r.prior">r.prior</code></td>
<td>
<p>Function that returns a random sample from the prior.</p>
</td></tr>
<tr><td><code id="SABC_+3A_d.prior">d.prior</code></td>
<td>
<p>Function that returns the density of the prior distribution.</p>
</td></tr>
<tr><td><code id="SABC_+3A_n.sample">n.sample</code></td>
<td>
<p>Size of the ensemble.</p>
</td></tr>
<tr><td><code id="SABC_+3A_eps.init">eps.init</code></td>
<td>
<p>Initial tolerance or temperature.</p>
</td></tr>
<tr><td><code id="SABC_+3A_iter.max">iter.max</code></td>
<td>
<p>Total number of simulations from the likelihood.</p>
</td></tr>
<tr><td><code id="SABC_+3A_v">v</code></td>
<td>
<p>Tuning parameter that governs the annealing speed. Defaults to 1.2, for the <code>noninformative</code> algorithm and 0.4, for the <code>informative</code> algorithm.</p>
</td></tr>
<tr><td><code id="SABC_+3A_beta">beta</code></td>
<td>
<p>Tuning parameter that governs the mixing in parameter space. Defaults to 0.8.</p>
</td></tr>
<tr><td><code id="SABC_+3A_delta">delta</code></td>
<td>
<p>Tuning parameter for the resampling steps. Defaults to 0.1.</p>
</td></tr>
<tr><td><code id="SABC_+3A_resample">resample</code></td>
<td>
<p>Number of accepted particle updates after which a resampling step is performed. Defaults to 5*<code>n.sample</code>.</p>
</td></tr>
<tr><td><code id="SABC_+3A_verbose">verbose</code></td>
<td>
<p>Shows the iteration progress each <code>verbose</code> simulations from the likelihood. NULL for no output. Defaults to <code>verbose = n.sample</code>.</p>
</td></tr>
<tr><td><code id="SABC_+3A_adaptjump">adaptjump</code></td>
<td>
<p>Whether to adapt covariance of jump distribution. Default is TRUE.</p>
</td></tr>
<tr><td><code id="SABC_+3A_method">method</code></td>
<td>
<p>Argument to select algorithm. Accepts <code>noninformative</code> or <code>informative</code>.</p>
</td></tr>
<tr><td><code id="SABC_+3A_summarystats">summarystats</code></td>
<td>
<p>Whether summary statistics shall be calculated (semi-) automatically. Defaults to FALSE.</p>
</td></tr>
<tr><td><code id="SABC_+3A_y">y</code></td>
<td>
<p>Data vector. Needs to be provided if either <code>summarystats = TRUE</code> or if <code>r.model</code> returns a sample from the likelihood.</p>
</td></tr>
<tr><td><code id="SABC_+3A_f.summarystats">f.summarystats</code></td>
<td>
<p>If <code>summarystats = TRUE</code> this function is needed for the calculation of the summary statistics. Defaults to <code>f.summarystats(x)=(x,x^2,x^3)</code>, where the powers are to be understood element-wise.</p>
</td></tr>
<tr><td><code id="SABC_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>r.model</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>SABC defines a class of algorithms for particle ABC that are inspired by Simulated Annealing. Unlike other algorithms, this class is not based on importance sampling, and hence does not suffer from a loss of effective sample size due to re-sampling. The approach is presented in detail in Albert, Kuensch, and Scheidegger (2014; see references).
</p>
<p>This package implements two versions of SABC algorithms, for the cases of a non-informative or an informative prior. These are described in detail in the paper. The algorithms can be selected using the <code>method</code> argument: <code>method=noninformative</code> or <code>method=informative</code>.
In the informative case, the algorithm corrects for the bias caused by an over- or under-representation of the prior.
</p>
<p>The argument <code>adaptjump</code> allows a choice of whether to adapt the covariance of the jump distribution. Default is TRUE.
</p>
<p>Furthermore, the package allows for three different ways of using the data.
If <code>y</code> is not provided, the algorithm expects <code>r.model</code> to return a scalar measuring the distance between a random sample from the likelihood and the data.
If <code>y</code> is provided and <code>summarystats = FALSE</code>, the algorithm expects <code>r.model</code> to return a random sample from the likelihood and uses the relative sum of squares to measure the distances between <code>y</code> and random likelihood samples.
If <code>summarystats = TRUE</code> the algorithm calculates summary statistics semi-automatically, as described in detail in the paper by Fearnhead et al. (2012; see references).
The summary statistics are calculated by means of a linear regression applied to a sample from the prior and the image of <code>f.summarystats</code> of an associated sample from the likelihood.
</p>


<h3>Value</h3>

<p>Returns a list with the following components:
</p>
<table>
<tr><td><code>E</code></td>
<td>
<p>Matrix with ensemble of samples.</p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p>Matrix with prior ensemble of samples.</p>
</td></tr>
<tr><td><code>eps</code></td>
<td>
<p>Value of tolerance (temperature) at final iteration.</p>
</td></tr>
<tr><td><code>ESS</code></td>
<td>
<p>Effective sample size, due to final bias correction (<code>informative</code> algorithm only).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Carlo Albert &lt;carlo.albert@eawag.ch&gt;, Andreas Scheidegger, Tobia Fasciati. Package initially compiled by Lukas M. Weber.
</p>


<h3>References</h3>

<p>C. Albert, H. R. Kuensch and A. Scheidegger, Statistics and Computing 0960-3174 (2014),  arXiv:1208.2157, <em>A Simulated Annealing Approach to Approximate Bayes Computations</em>.
</p>
<p>P. Fearnhead and D. Prangle, J. R. Statist. Soc. B  74 (2012), <em>Constructing summary statistics for approximate Bayesian computation: semi-automatic approximate Bayesian computation</em>.</p>


<h3>Examples</h3>

<pre><code class='language-R'> ## Not run:  
## Example for "noninformative" case
# Prior is uniform on [-10,10]
d.prior &lt;- function(par)
    dunif(par,-10,10)
r.prior &lt;- function()
    runif(1,-10,10)

# Model is the sum of two normal distributions. Return distance to observation 0:
f.dist &lt;- function(par)
    return( abs(rnorm( 1 , par , ifelse(runif(1)&lt;0.5,1,0.1 ) )))

# Run algorithm ("noninformative" case)
res &lt;- SABC(f.dist,r.prior,d.prior,n.sample=500,eps.init=2,iter.max=50000)
 
## End(Not run)

 ## Not run: 
# Histogram of results
hist(res$E[,1],breaks=200)
 
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
