<!DOCTYPE html><html lang="en"><head><title>Help for package MCMCprecision</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MCMCprecision}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MCMCprecision-package'><p>MCMCprecision: Precision of discrete parameters in transdimensional MCMC</p></a></li>
<li><a href='#best_models'><p>Precision for the k Best-Performing Models</p></a></li>
<li><a href='#fit_dirichlet'><p>Estimate Parameters of Dirichlet Distribution</p></a></li>
<li><a href='#rdirichlet'><p>Random Sample from Dirichlet Distribution</p></a></li>
<li><a href='#rmarkov'><p>Generate a sample of a discrete-state Markov chain</p></a></li>
<li><a href='#stationary'><p>Precision of stationary distribution for discrete MCMC variables</p></a></li>
<li><a href='#stationary_mle'><p>MLE for stationary distribution of discrete MCMC variables</p></a></li>
<li><a href='#summary.stationary'><p>Summary for Posterior Model Probabilities</p></a></li>
<li><a href='#transitions'><p>Get matrix of observed transition frequencies</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Precision of Discrete Parameters in Transdimensional MCMC</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-12-04</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel W. Heck <a href="https://orcid.org/0000-0002-6302-9252"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel W. Heck &lt;dheck@uni-marburg.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimates the precision of transdimensional Markov chain Monte Carlo 
    (MCMC) output, which is often used for Bayesian analysis of models with different 
    dimensionality (e.g., model selection). Transdimensional MCMC (e.g., reversible 
    jump MCMC) relies on sampling a discrete model-indicator variable to estimate 
    the posterior model probabilities. If only few switches occur between the models, 
    precision may be low and assessment based on the assumption of independent 
    samples misleading. Based on the observed transition matrix of the indicator 
    variable, the method of Heck, Overstall, Gronau, &amp; Wagenmakers (2019, 
    Statistics &amp; Computing, 29, 631-643) &lt;<a href="https://doi.org/10.1007%2Fs11222-018-9828-0">doi:10.1007/s11222-018-9828-0</a>&gt; draws 
    posterior samples of the stationary distribution to (a) assess the uncertainty 
    in the estimated posterior model probabilities and (b) estimate the effective 
    sample size of the MCMC output.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, parallel, utils, stats, Matrix, combinat</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, R.rsp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppProgress, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/danheck/MCMCprecision">https://github.com/danheck/MCMCprecision</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-04 21:16:38 UTC; daniel</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-05 09:00:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='MCMCprecision-package'>MCMCprecision: Precision of discrete parameters in transdimensional MCMC</h2><span id='topic+MCMCprecision'></span><span id='topic+MCMCprecision-package'></span>

<h3>Description</h3>

<p>MCMCprecision estimates the precision of the posterior model probabilities in
transdimensional Markov chain Monte Carlo methods (e.g., reversible jump MCMC
or product-space MCMC). This is useful for applications of transdimensional
MCMC such as model selection, mixtures with varying numbers of components,
change-point detection, capture-recapture models, phylogenetic trees,
variable selection, and for discrete parameters in MCMC output in general.
</p>


<h3>Details</h3>

<p>The main function to assess the estimation uncertainty of discrete MCMC output is
is <code><a href="#topic+stationary">stationary</a></code>.
</p>
<p>The method is explained in detail in Heck et al. (2019, Statistics &amp; Computing),
available in the package by calling: <code>vignette("MCMCprecision")</code>
</p>


<h3>Author(s)</h3>

<p>Daniel W. Heck
</p>


<h3>References</h3>

<p>Heck, D. W., Overstall, A. M., Gronau, Q. F., &amp; Wagenmakers, E.-J. (2019).
Quantifying uncertainty in transdimensional Markov chain Monte Carlo
using discrete Markov models. Statistics &amp; Computing, 29, 631–643.
<a href="https://dx.doi.org/10.1007/s11222-018-9828-0">https://dx.doi.org/10.1007/s11222-018-9828-0</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/danheck/MCMCprecision">https://github.com/danheck/MCMCprecision</a>
</p>
</li></ul>


<hr>
<h2 id='best_models'>Precision for the k Best-Performing Models</h2><span id='topic+best_models'></span>

<h3>Description</h3>

<p>Assesses the precision in estimating the ranking of the <code class="reqn">k</code> best-performing models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>best_models(samples, k, ties.method = "min")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="best_models_+3A_samples">samples</code></td>
<td>
<p>a matrix with posterior samples (one per row) for the model posterior probabilities (one model per column). Can be estimated using <code><a href="#topic+stationary">stationary</a></code> with the argument <code>summary = FALSE</code>.</p>
</td></tr>
<tr><td><code id="best_models_+3A_k">k</code></td>
<td>
<p>number of best-performing models to be considered</p>
</td></tr>
<tr><td><code id="best_models_+3A_ties.method">ties.method</code></td>
<td>
<p>a character string specifying how ties are treated, see <code><a href="base.html#topic+rank">rank</a></code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># a sequence of uncorrelated model indices
mult &lt;- rmultinom(1000, 1, c(.05, .6, .15, .12, .08))
idx &lt;- apply(mult, 2, which.max)
z &lt;- letters[idx]
stat &lt;- stationary(z, summary = FALSE)
best_models(stat, 3)
</code></pre>

<hr>
<h2 id='fit_dirichlet'>Estimate Parameters of Dirichlet Distribution</h2><span id='topic+fit_dirichlet'></span>

<h3>Description</h3>

<p>C++ implementation of the fixed-point iteration algorithm by Minka (2000).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_dirichlet(x, const, maxit = 1e+05, abstol = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_dirichlet_+3A_x">x</code></td>
<td>
<p>a matrix of Dirichlet samples, one row per observation.</p>
</td></tr>
<tr><td><code id="fit_dirichlet_+3A_const">const</code></td>
<td>
<p>constant that is added to avoid problems with zeros in <code>log(x)</code>.
The default is <code>const = min(x[x&gt;0])*.01</code>.</p>
</td></tr>
<tr><td><code id="fit_dirichlet_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
<tr><td><code id="fit_dirichlet_+3A_abstol">abstol</code></td>
<td>
<p>The absolute convergence tolerance: maximum of absolute differences of Dirichlet parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is used to estimate the effective sample size based on samples
of posterior model probabilities (see <code><a href="#topic+stationary">stationary</a></code> and
<code><a href="#topic+summary.stationary">summary.stationary</a></code>).
</p>


<h3>References</h3>

<p>Minka, T. (2000). Estimating a Dirichlet distribution. Technical Report.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rdirichlet">rdirichlet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rdirichlet(100, c(8,1,3,9))
fit_dirichlet(x)

</code></pre>

<hr>
<h2 id='rdirichlet'>Random Sample from Dirichlet Distribution</h2><span id='topic+rdirichlet'></span>

<h3>Description</h3>

<p>Random generation from the Dirichlet distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdirichlet(n, a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rdirichlet_+3A_n">n</code></td>
<td>
<p>number of samples</p>
</td></tr>
<tr><td><code id="rdirichlet_+3A_a">a</code></td>
<td>
<p>vector or matrix of shape parameters</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+fit_dirichlet">fit_dirichlet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdirichlet(2, c(1,5,3,8))

</code></pre>

<hr>
<h2 id='rmarkov'>Generate a sample of a discrete-state Markov chain</h2><span id='topic+rmarkov'></span>

<h3>Description</h3>

<p>Generates a sequence of discrete states from a discrete-time Markov chain with transition matrix <code>P</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmarkov(n, P, start = rep(1, ncol(P)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rmarkov_+3A_n">n</code></td>
<td>
<p>length of the generated sequence.</p>
</td></tr>
<tr><td><code id="rmarkov_+3A_p">P</code></td>
<td>
<p>transition matrix (rows are normalized to sum to 1).</p>
</td></tr>
<tr><td><code id="rmarkov_+3A_start">start</code></td>
<td>
<p>vector with nonnegative values that defines the discrete starting
distribution at t=0 (<code>start</code> is normalized to sum to 1). The default is
a discrete uniform distribution.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- matrix(c(.30, .50, .20,
              .05, .25, .70,
              .00, .10, .90), 3, 3, byrow=TRUE)
rmarkov(50, P)
</code></pre>

<hr>
<h2 id='stationary'>Precision of stationary distribution for discrete MCMC variables</h2><span id='topic+stationary'></span>

<h3>Description</h3>

<p>Transdimensional MCMC methods include a discrete model-indicator variable <code class="reqn">z</code>
with a fixed but unknown stationary distribution with probabilities <code class="reqn">\pi</code>
(i.e., the model posterior probabiltiies). The function <code>stationary</code>
draws posterior samples to assess the estimation uncertainty of <code class="reqn">\pi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stationary(
  z,
  N,
  labels,
  sample = 1000,
  epsilon = "1/M",
  cpu = 1,
  method = "arma",
  digits = 6,
  progress = TRUE,
  summary = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stationary_+3A_z">z</code></td>
<td>
<p>MCMC output for the discrete indicator variable with numerical,
character, or factor labels (can also be a <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>
or a matrix with one MCMC chain per column).</p>
</td></tr>
<tr><td><code id="stationary_+3A_n">N</code></td>
<td>
<p>the observed <code><a href="#topic+transitions">transitions</a></code> matrix (if supplied, <code>z</code> is ignored).
A quadratic matrix with sampled transition frequencies
(<code>N[i,j]</code> = number of switches from <code>z[t]=i</code> to <code>z[t+1]=j</code>).</p>
</td></tr>
<tr><td><code id="stationary_+3A_labels">labels</code></td>
<td>
<p>optional: vector of labels for complete set of models
(e.g., models not sampled in the chain <code>z</code>). If <code>epsilon=0</code>,
this does not affect inferences due to the improper Dirichlet(0,..,0) prior.</p>
</td></tr>
<tr><td><code id="stationary_+3A_sample">sample</code></td>
<td>
<p>number of posterior samples to be drawn for the stationary distribution <code class="reqn">\pi</code>.</p>
</td></tr>
<tr><td><code id="stationary_+3A_epsilon">epsilon</code></td>
<td>
<p>prior parameter for the rows of the estimated transition matrix <code class="reqn">P</code>:
<code class="reqn">P[i,]</code> ~ Dirichlet<code class="reqn">(\epsilon, ..., \epsilon)</code>.
The default <code>epsilon="1/M"</code> (with M = number of sampled models) provides
estimates close to the i.i.d. estimates and is numerically stable.
The alternative <code>epsilon=0</code> minimizes the impact of the prior and
renders non-sampled models irrelevant.
If <code>method="iid"</code> (ignores dependencies), a Dirichlet prior is assumed on the stationary
distribution <code class="reqn">\pi</code> instead of the rows of the transition matrix <code class="reqn">P</code>.</p>
</td></tr>
<tr><td><code id="stationary_+3A_cpu">cpu</code></td>
<td>
<p>number of CPUs used for parallel sampling.
Will only speed up computations for large numbers of models
(i.e., for large transition matrices).</p>
</td></tr>
<tr><td><code id="stationary_+3A_method">method</code></td>
<td>
<p>how to compute eigenvectors:
</p>

<ul>
<li> <p><code>"arma"</code> (default): Uses <code>RcppArmadillo::eig_gen</code>.
</p>
</li>
<li> <p><code>"base"</code>: Uses <code>base::<a href="base.html#topic+eigen">eigen</a></code>, which might be more stable,
but also much slower than <code>"arma"</code> for small transition matrices.
</p>
</li>
<li> <p><code>"eigen"</code>: Uses package <code>RcppEigen::EigenSolver</code>
</p>
</li>
<li> <p><code>"armas"</code>: Uses sparse matrices with <code>RcppArmadillo::eigs_gen</code>,
which can be faster for very large number of models
if <code>epsilon=0</code> (might be numerically unstable).
</p>
</li>
<li> <p><code>"iid"</code>: Assumes i.i.d. sampling of the model indicator variable <code>z</code>.
This is only implemented as a benchmark, because results cannot
be trusted if the samples <code>z</code> are correlated (which is usually
the case for transdimensional MCMC output)
</p>
</li></ul>
</td></tr>
<tr><td><code id="stationary_+3A_digits">digits</code></td>
<td>
<p>number of digits that are used for checking whether the first
eigenvalue is equal to 1 (any difference must be due to low numerical precision)</p>
</td></tr>
<tr><td><code id="stationary_+3A_progress">progress</code></td>
<td>
<p>whether to show a progress bar (not functional for <code>cpu&gt;1</code>)</p>
</td></tr>
<tr><td><code id="stationary_+3A_summary">summary</code></td>
<td>
<p>whether the output should be summarized.
If <code>FALSE</code>, posterior samples of the stationary probabilities are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method draws independent posterior samples of the transition matrix <code class="reqn">P</code>
for the discrete-valued indicator variable <code>z</code> (usually, a sequence of sampled models).
For each row of the transition matrix, a Dirichlet<code class="reqn">(\epsilon,...,\epsilon)</code>
prior is assumed, resulting in a conjugate Dirichlet posterior.
For each sample, the eigenvector with eigenvalue 1 is computed and normalized.
These (independent) posterior samples can be used to assess the estimation
uncertainty in the stationary distribution <code class="reqn">pi</code> of interest
(e.g., the model posterior probabilities) and to estimate the effective sample size
(see <code><a href="#topic+summary.stationary">summary.stationary</a></code>).
</p>


<h3>Value</h3>

<p>default: a summary for the posterior distribution of the model
posterior probabilities (i.e., the fixed but unknown stationary distribution of <code>z</code>).
If <code>summary=FALSE</code>, posterior samples for <code class="reqn">pi</code> are returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+best_models">best_models</a></code>, <code><a href="#topic+summary.stationary">summary.stationary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data-generating transition matrix
P &lt;- matrix(c(.1,.5,.4,
              0, .5,.5,
              .9,.1,0), ncol = 3, byrow=TRUE)

# input: sequence of sampled models
z &lt;- rmarkov(500, P)
stationary(z)

# input: transition frequencies
N &lt;- transitions(z)
samples &lt;- stationary(N = N, summary = FALSE)

# summaries:
best_models(samples, k = 3)
summary(samples)
</code></pre>

<hr>
<h2 id='stationary_mle'>MLE for stationary distribution of discrete MCMC variables</h2><span id='topic+stationary_mle'></span>

<h3>Description</h3>

<p>Maximum-likelihood estimation of stationary distribution <code class="reqn">\pi</code> based on (a) a sampled trajectory <code class="reqn">z</code> of a model-indicator variable or (b) a sampled transition count matrix <code class="reqn">N</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stationary_mle(z, N, labels, method = "rev", abstol = 1e-05, maxit = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stationary_mle_+3A_z">z</code></td>
<td>
<p>MCMC output for the discrete indicator variable with numerical,
character, or factor labels (can also be a <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>
or a matrix with one MCMC chain per column).</p>
</td></tr>
<tr><td><code id="stationary_mle_+3A_n">N</code></td>
<td>
<p>the observed <code><a href="#topic+transitions">transitions</a></code> matrix (if supplied, <code>z</code> is ignored).
A quadratic matrix with sampled transition frequencies
(<code>N[i,j]</code> = number of switches from <code>z[t]=i</code> to <code>z[t+1]=j</code>).</p>
</td></tr>
<tr><td><code id="stationary_mle_+3A_labels">labels</code></td>
<td>
<p>optional: vector of labels for complete set of models
(e.g., models not sampled in the chain <code>z</code>). If <code>epsilon=0</code>,
this does not affect inferences due to the improper Dirichlet(0,..,0) prior.</p>
</td></tr>
<tr><td><code id="stationary_mle_+3A_method">method</code></td>
<td>
<p>Different types of MLEs:
</p>

<ul>
<li> <p><code>"iid"</code>: Assumes i.i.d. sampling of the model indicator variable <code>z</code> and estimates <code class="reqn">\pi</code> as the relative frequencies each model was sampled.
</p>
</li>
<li> <p><code>"rev"</code>: Estimate stationary distribution under the constraint that the transition matrix is reversible (i.e., fulfills detailed balance) based on the iterative fixed-point algorithm proposed by Trendelkamp-Schroer et al. (2015)
</p>
</li>
<li> <p><code>"eigen"</code>: Computes the first left-eigenvector (normalized to sum to 1) of the sampled transition matrix
</p>
</li></ul>
</td></tr>
<tr><td><code id="stationary_mle_+3A_abstol">abstol</code></td>
<td>
<p>absolute convergence tolerance (only for <code>method = "rev"</code>)</p>
</td></tr>
<tr><td><code id="stationary_mle_+3A_maxit">maxit</code></td>
<td>
<p>maximum number of iterations (only for <code>method = "rev"</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimates are implemented mainly for comparison with the Bayesian sampling approach implemented in <code><a href="#topic+stationary">stationary</a></code>, which quantify estimation uncertainty (i.e., posterior SD) of the posterior model probability estimates.
</p>


<h3>Value</h3>

<p>a vector with posterior model probability estimates
</p>


<h3>References</h3>

<p>Trendelkamp-Schroer, B., Wu, H., Paul, F., &amp; Noé, F. (2015). Estimation and uncertainty of reversible Markov models. The Journal of Chemical Physics, 143(17), 174101. <a href="https://doi.org/10.1063/1.4934536">https://doi.org/10.1063/1.4934536</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stationary">stationary</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- matrix(c(.1,.5,.4,
              0,.5,.5,
              .9,.1,0), ncol = 3, byrow=TRUE)
z &lt;- rmarkov(1000, P)
stationary_mle(z)

# input: transition frequency
tab &lt;- transitions(z)
stationary_mle(N = tab)
</code></pre>

<hr>
<h2 id='summary.stationary'>Summary for Posterior Model Probabilities</h2><span id='topic+summary.stationary'></span>

<h3>Description</h3>

<p>Summary for a sample of posterior model probabilities (<code><a href="#topic+stationary">stationary</a></code>).
Also provides the estimated effective sample size and summaries for all pairwise Bayes factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stationary'
summary(object, BF = FALSE, logBF = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.stationary_+3A_object">object</code></td>
<td>
<p>posterior samples of the stationary distribution (rows = samples; columns = models).</p>
</td></tr>
<tr><td><code id="summary.stationary_+3A_bf">BF</code></td>
<td>
<p>whether to compute summaries for all pairwise Bayes factors.</p>
</td></tr>
<tr><td><code id="summary.stationary_+3A_logbf">logBF</code></td>
<td>
<p>whether to summarize log Bayes factors instead of Bayes factors.</p>
</td></tr>
<tr><td><code id="summary.stationary_+3A_...">...</code></td>
<td>
<p>passed to <code><a href="#topic+fit_dirichlet">fit_dirichlet</a></code> to estimate effective sample size
(e.g., <code>maxit</code> and <code>abstol</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Effective sample is estimated by fitting a Dirichlet model to the
posterior model probabilities (thereby assuming that samples were drawn from
an equivalent multinomial distribution based on independent sampling).
More precisely, sample size is estimated by the sum of the Dirichlet parameters
<code class="reqn">\sum\alpha[i]</code> minus the prior sample size <code class="reqn">\epsilon*M^2</code>
(where <code class="reqn">M</code> is the number of sampled models and <code class="reqn">\epsilon</code> the
prior parameter for each transition frequency).
</p>


<h3>Value</h3>

<p>a list with estimates for
<code>"pp"</code> = posterior model probabilities,
<code>"n.eff"</code> = effective sample size, and
<code>"bf"</code> = pairwise Bayes factors (optional)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stationary">stationary</a></code>, <code><a href="#topic+fit_dirichlet">fit_dirichlet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- matrix(c(.1,.5,.4,
              0, .5,.5,
              .9,.1,0), ncol = 3, byrow=TRUE)
z &lt;- rmarkov(1000, P)
samples &lt;- stationary(z, summary = FALSE)
summary(samples)

</code></pre>

<hr>
<h2 id='transitions'>Get matrix of observed transition frequencies</h2><span id='topic+transitions'></span>

<h3>Description</h3>

<p>Summarizes a sequence of discrete values by the observed transition frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitions(z, labels, order = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transitions_+3A_z">z</code></td>
<td>
<p>vector of model indices (numerical or character)</p>
</td></tr>
<tr><td><code id="transitions_+3A_labels">labels</code></td>
<td>
<p>fixed labels for models that should be included in transition matrix, e.g., <code>labels=1:20</code> or <code>c("m1","m2",...)</code></p>
</td></tr>
<tr><td><code id="transitions_+3A_order">order</code></td>
<td>
<p>order of the transition table. If <code>order=1</code>, a matrix with transition frequencies from <code>z[t+1]</code> is returned. If <code>order=2</code>, a 3-dimensional array is returned with transition frequencies for <code>z[t]</code>, <code>z[t+1]</code>, and <code>z[t+2]</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a square matrix with transition frequencies
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P &lt;- matrix(c(.9,.1,0,
              .1,.6,.3,
              .2,.3,.5), 3, byrow=TRUE)
z &lt;- rmarkov(2000, P)
transitions(z)
transitions(z, order = 2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
