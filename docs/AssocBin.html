<!DOCTYPE html><html lang="en"><head><title>Help for package AssocBin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {AssocBin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binChi'><p>Statistics for bins</p></a></li>
<li><a href='#binner'><p>Many split recursive binning</p></a></li>
<li><a href='#catBinner'><p>Binning of categorical variable pairs</p></a></li>
<li><a href='#chiScores'><p>Scoring functions to choose splits</p></a></li>
<li><a href='#depthFill'><p>Generate fills encoding bin features</p></a></li>
<li><a href='#halfCutTie'><p>Halve continuously to break ties</p></a></li>
<li><a href='#halfSplit'><p>Halve at an observed point</p></a></li>
<li><a href='#heart'><p>Heart Disease Diagnosis Data</p></a></li>
<li><a href='#inDep'><p>Test pairwise variable independence</p></a></li>
<li><a href='#makeBin'><p>Make a bin</p></a></li>
<li><a href='#makeCriteria'><p>Make stop crteria</p></a></li>
<li><a href='#maxScoreSplit'><p>Size-restricted bivariate score maximizing splitting</p></a></li>
<li><a href='#plotBinning'><p>Plot a binning using shaded rectangles</p></a></li>
<li><a href='#rIntSplit'><p>Random integer splitting</p></a></li>
<li><a href='#rUnifSplit'><p>Random uniform splitting</p></a></li>
<li><a href='#sandboxMaxSplit'><p>Bivariate score maximizing splitting</p></a></li>
<li><a href='#singleBinner'><p>Single split recursive binning</p></a></li>
<li><a href='#sp500pseudo'><p>De-Garched S&amp;P 500 returns</p></a></li>
<li><a href='#splitX'><p>Helper functions for marginal splitting</p></a></li>
<li><a href='#stopper'><p>Check bins against stop criteria</p></a></li>
<li><a href='#summary.inDep'><p>S3 methods for 'inDep'</p></a></li>
<li><a href='#uniBinner'><p>Single margin binning</p></a></li>
<li><a href='#uniMaxScoreSplit'><p>Univariate score maximizing splitting</p></a></li>
<li><a href='#uniRIntSplit'><p>Univariate random integer splitting</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.0-2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Measuring Association with Recursive Binning</td>
</tr>
<tr>
<td>Description:</td>
<td>An iterative implementation of a recursive binary partitioning algorithm to measure pairwise dependence with a modular design that allows user specification of the splitting logic and stop criteria. Helper functions provide suggested versions of both and support visualization and the computation of summary statistics on final binnings. For a complete description of the functionality and algorithm, see Salahub and Oldford (2023) &lt;<a href="https://doi.org/10.48550%2FarXiv.2311.08561">doi:10.48550/arXiv.2311.08561</a>&gt;.</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chris Salahub &lt;chris.salahub@uwaterloo.ca&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-12-10 01:05:32 UTC; cdsal</td>
</tr>
<tr>
<td>Author:</td>
<td>Chris Salahub <a href="https://orcid.org/0000-0003-3770-6798"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-12-10 03:20:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='binChi'>Statistics for bins</h2><span id='topic+binChi'></span><span id='topic+binMI'></span><span id='topic+binAbsDif'></span>

<h3>Description</h3>

<p>These functions compute statistics based on observed
and expected counts for a list of bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binChi(bins, agg = sum)

binMI(bins, agg = sum)

binAbsDif(bins, agg = sum)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binChi_+3A_bins">bins</code></td>
<td>
<p>a list of bins, each a list with elements 'x', 'y',
'depth', 'bnds' (list with elements 'x' and 'y'), 'expn', 'n'</p>
</td></tr>
<tr><td><code id="binChi_+3A_agg">agg</code></td>
<td>
<p>function which is aggregates the individual statistics
computed over each bin</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Binstatistics
</p>
<p>Three functions are provided by default, 'binChi'
computes the chi-squared statistic by taking the squared
difference between observed and expected counts and dividing this
by the expected counts. 'binMi' computes the mutual information
for each bin using the observed and expected counts. Finally,
'binAbsDif' computes the absolute difference between observed
and expected counts. Each function first computes a value on
every bin independently and stores all these values in memory
before using the function provided in the optional argument 'agg'
to aggregate these values.
</p>


<h3>Value</h3>

<p>A list with elements 'residuals' and 'stat' reporting the
individual statistic values (possibly transformed) and the
aggegrated statistic value.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>binChi()</code>: Chi-squared statistic
</p>
</li>
<li> <p><code>binMI()</code>: Mutual information
</p>
</li>
<li> <p><code>binAbsDif()</code>: Absolute difference between observed
and expected
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>binList1 &lt;- list(list(x = c(1,2), y = c(3,1), depth = 1, n = 2,
                      expn = 2),
                list(x = c(3,4), y = c(2,4), depth = 1, n = 2,
                     expn = 2))
binList2 &lt;- list(list(x = c(1,2), y = c(3,1), depth = 6, n = 2,
                      expn = 4),
                list(x = c(), y = c(), depth = 1, n = 0, expn = 1))
binChi(binList1)
binChi(binList2)
binMI(binList1)
binMI(binList2)
binAbsDif(binList2)
</code></pre>

<hr>
<h2 id='binner'>Many split recursive binning</h2><span id='topic+binner'></span>

<h3>Description</h3>

<p>'binner' is an iterative implementation of a
recursive binary partitioning algorithm which accepts the
splitting and stopping functions that guide partitioning as
arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binner(x, y, stopper, splitter, init = halfSplit, dropPoints = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binner_+3A_x">x</code></td>
<td>
<p>numeric vector of the first variable to be binned</p>
</td></tr>
<tr><td><code id="binner_+3A_y">y</code></td>
<td>
<p>numeric vector of the second variable to be binned</p>
</td></tr>
<tr><td><code id="binner_+3A_stopper">stopper</code></td>
<td>
<p>function which accepts a list with elements
'x', 'y', 'bnds', 'expn', and 'n' and returns a logical indicating
whether a split should occur for the bin defined by that list</p>
</td></tr>
<tr><td><code id="binner_+3A_splitter">splitter</code></td>
<td>
<p>function which accepts a list of lists with
elements 'x', 'y', 'bnds', 'expn', and 'n' and returns a list
where each element is a list of two corresponding to a split of
the bin at that position in the original list</p>
</td></tr>
<tr><td><code id="binner_+3A_init">init</code></td>
<td>
<p>function like 'splitter' applied to the first bin</p>
</td></tr>
<tr><td><code id="binner_+3A_droppoints">dropPoints</code></td>
<td>
<p>logical; should points be dropped from final
bins?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'binner' creates a two-dimensional histogram of the
sample space of 'x' and 'y' by recursively splitting partitions of
the data using 'splitter' until 'stopper' indicates that all
partitions are not to be split. An optional argument 'init' gives
the function applied to the first bin containing all points to
initialize the binning algorithm.
</p>


<h3>Value</h3>

<p>A list of lists each with elements 'x', 'y', 'bnds',
'expn', 'n', and 'stopped'.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## necessary set up
crits &lt;- makeCriteria(depth &gt;= 4, n &lt; 10, expn &lt;= 5)
stopFn &lt;- function(bns) stopper(bns, crits)
spltFn &lt;- function(bn) maxScoreSplit(bn, chiScores)
## generate data
x &lt;- sample(1:100)
y &lt;- sample(1:100)
## run binner
bins &lt;- binner(x, y, stopper = stopFn, splitter = spltFn)
</code></pre>

<hr>
<h2 id='catBinner'>Binning of categorical variable pairs</h2><span id='topic+catBinner'></span>

<h3>Description</h3>

<p>'catBinner' converts the cross-tabulation of two
categorical variables into bins which work with all of the
functionality on bins built into 'AssocBin'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>catBinner(x, y, dropPoints = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="catBinner_+3A_x">x</code></td>
<td>
<p>factor vector for the first categorical variable</p>
</td></tr>
<tr><td><code id="catBinner_+3A_y">y</code></td>
<td>
<p>factor vector for the second categorical variable</p>
</td></tr>
<tr><td><code id="catBinner_+3A_droppoints">dropPoints</code></td>
<td>
<p>logical; should points be dropped from final
bins?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As both variables are already categorical, 'catBinner'
performs no splits and does not merge any categories by default.
</p>


<h3>Value</h3>

<p>A list of lists each with elements 'x', 'y', 'bnds',
'expn', 'n', and 'stopped'.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>

<hr>
<h2 id='chiScores'>Scoring functions to choose splits</h2><span id='topic+chiScores'></span><span id='topic+miScores'></span><span id='topic+randScores'></span>

<h3>Description</h3>

<p>These functions define scores to evaluate candidate
splits along a single margin within partition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chiScores(bounds, nbelow, n)

miScores(bounds, nbelow, n)

randScores(bounds, nbelow, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chiScores_+3A_bounds">bounds</code></td>
<td>
<p>numeric vector giving candidate split bounds in
increasing order</p>
</td></tr>
<tr><td><code id="chiScores_+3A_nbelow">nbelow</code></td>
<td>
<p>integer vector giving the number of points below
each candidate split</p>
</td></tr>
<tr><td><code id="chiScores_+3A_n">n</code></td>
<td>
<p>the total number of points in the bin to be split</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Scorings
</p>
<p>Each of these functions accepts 'boundss', an ordered
numeric vector containing the candidate splits within a bin and
the bin bounds all in increasing order, and 'nbelow' which gives
the count of points below each split. 'n' is used to determine the
number of points above the split.
</p>


<h3>Value</h3>

<p>A vector of scores.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>chiScores()</code>: A chi-squared statistic score
</p>
</li>
<li> <p><code>miScores()</code>: A mutual information score
</p>
</li>
<li> <p><code>randScores()</code>: A random score for random splitting
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vals &lt;- c(2, 5, 12, 16, 19)
chiScores(vals, 1:3, 3)
## same for the miScores
miScores(vals, 1:3, 3)
## random scoring produces different output every time
randScores(vals, 1:3, 3)
randScores(vals, 1:3, 3)
</code></pre>

<hr>
<h2 id='depthFill'>Generate fills encoding bin features</h2><span id='topic+depthFill'></span><span id='topic+residualFill'></span>

<h3>Description</h3>

<p>These functions all accept a list of bins and return
a vector of colours of the same length that encode some feature of
the bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depthFill(bins, colrng = c("white", "firebrick"))

residualFill(
  bins,
  resFun = binChi,
  maxRes,
  colrng = c("steelblue", "white", "firebrick"),
  breaks = NA,
  nbr = NA
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="depthFill_+3A_bins">bins</code></td>
<td>
<p>list of bins to be visualized</p>
</td></tr>
<tr><td><code id="depthFill_+3A_colrng">colrng</code></td>
<td>
<p>hue range to be passed to 'colorRampPalette' to
generate the final hue scale</p>
</td></tr>
<tr><td><code id="depthFill_+3A_resfun">resFun</code></td>
<td>
<p>function which returns a result with a name element
'residuals' that is a numeric vector of the same length as 'bins'</p>
</td></tr>
<tr><td><code id="depthFill_+3A_maxres">maxRes</code></td>
<td>
<p>numeric maximum value of the residuals to maintain
the correct origin, taken to be the maximum observed residual if
not provided</p>
</td></tr>
<tr><td><code id="depthFill_+3A_breaks">breaks</code></td>
<td>
<p>numeric vector of breakpoints to control hues,
defaults to breakpoints that indicate Pearson residuals outside
the asymptotic 95 percent confidence interval around zero under
the null</p>
</td></tr>
<tr><td><code id="depthFill_+3A_nbr">nbr</code></td>
<td>
<p>number of breakpoints for automatic breakpoint
generation if 'breaks' is not provided</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Shadings
</p>
<p>Two functions are provided by default: one which
generates a fill based on bin depth and the other based on a
residual function applied to each bin.
</p>


<h3>Value</h3>

<p>A vector of colours the same length as 'bins'.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>depthFill()</code>: Fill by depth
</p>
</li>
<li> <p><code>residualFill()</code>: Fill by residual values
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bin &lt;- makeBin(x = 1:10, y = sample(1:10))
bin2 &lt;- halfSplit(bin, "x")
bin3 &lt;- unlist(lapply(bin2, maxScoreSplit,
                      scorer = chiScores, minExp = 2),
               recursive = FALSE)
plotBinning(bin3, fill = depthFill(bin3)) # all the same depth
plotBinning(bin3, fill = residualFill(bin3)) # diff resids
</code></pre>

<hr>
<h2 id='halfCutTie'>Halve continuously to break ties</h2><span id='topic+halfCutTie'></span>

<h3>Description</h3>

<p>This function halves a bin based on the midpoint of
the bounds along whichever margin produces the larger score.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>halfCutTie(bin, xscore, yscore, wider, squarify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="halfCutTie_+3A_bin">bin</code></td>
<td>
<p>a bin to be split with elements 'x', 'y', 'depth',
'bnds' (list with elements 'x' and 'y'), 'expn', 'n'</p>
</td></tr>
<tr><td><code id="halfCutTie_+3A_xscore">xscore</code></td>
<td>
<p>numeric value giving the score for all splits along
x</p>
</td></tr>
<tr><td><code id="halfCutTie_+3A_yscore">yscore</code></td>
<td>
<p>numeric value giving the score for all splits along
y</p>
</td></tr>
<tr><td><code id="halfCutTie_+3A_wider">wider</code></td>
<td>
<p>logical; is the bin wider than it is tall?</p>
</td></tr>
<tr><td><code id="halfCutTie_+3A_squarify">squarify</code></td>
<td>
<p>logical value, should we force splitting on
the longer side regardless of scores?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal of this function is to break ties within bin
splitting in a way which prevents very small or lopsided bins from
forming, a common problem with the 'halfSplit' function
</p>


<h3>Value</h3>

<p>A list of two bins resulting from the split of 'bin' in
half along the margin corresponding to the larger score.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bin &lt;- makeBin(x = 1:10, y = sample(1:10))
halfCutTie(bin, 1, 2, wider = FALSE) # splits on y
halfCutTie(bin, 2, 1, wider = FALSE) # splits on x
halfCutTie(bin, 1, 1, wider = FALSE) # ties are random
</code></pre>

<hr>
<h2 id='halfSplit'>Halve at an observed point</h2><span id='topic+halfSplit'></span>

<h3>Description</h3>

<p>This function halves a bin under the restriction that
splits can only occur at observation coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>halfSplit(bin, margin = sample(c("x", "y"), 1))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="halfSplit_+3A_bin">bin</code></td>
<td>
<p>a bin to be split with elements 'x', 'y', 'depth',
'bnds' (list with elements 'x' and 'y'), 'expn', 'n'</p>
</td></tr>
<tr><td><code id="halfSplit_+3A_margin">margin</code></td>
<td>
<p>string, one of 'x' or 'y'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a bin and a margin, this function splits the bin so
half the points are above the new split point and half are below.
</p>


<h3>Value</h3>

<p>A list of two bins resulting from the split of 'bin' in
half along the specified margin
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bin &lt;- list(x = 1:10, y = sample(1:10),
            bnds = list(x = c(0, 10), y = c(0, 10)),
            expn = 10, n = 10, depth = 0)
halfSplit(bin)
halfSplit(bin, margin = "y")
</code></pre>

<hr>
<h2 id='heart'>Heart Disease Diagnosis Data</h2><span id='topic+heart'></span>

<h3>Description</h3>

<p>This data (adapted from the UCI Machine Learning Repository at
https://archive.ics.uci.edu/) presents a single data frame
reporting heart disease diagnosis results for patients from
studies carried out by Andras Janosi at the Hungarian
Institute of Cardiology; William Steinbrunn and Matthias
Pfisterer at the University Hospitals of Zurich and Basel;
and two separate studies by Robert Detrano carried out at the
Cleveland Clinic Foundation and Long Beach V.A. Medical Center.
The data contains measurements of 15 variables collected on 920
participants:
</p>

<dl>
<dt>age</dt><dd><p>Age in years</p>
</dd>
<dt>sex</dt><dd><p>Sex</p>
</dd>
<dt>cp</dt><dd><p>Reported chest pain type: typical angina, non-typical angina, non-angina, or no pain</p>
</dd>
<dt>trestbps</dt><dd><p>Resting blood pressure (mmHg on admission to hospital)</p>
</dd>
<dt>chol</dt><dd><p>Serum cholesterol in mg/dl</p>
</dd>
<dt>fbs</dt><dd><p>Indicator of fasting blood sugar &gt;120 mg/dl</p>
</dd>
<dt>restecg</dt><dd><p>Resting electrocardiographic results: normal, indicating ventricular hypertrophy, or displaying ST-T wave abnormality</p>
</dd>
<dt>thalach</dt><dd><p>Maximum measured heart rate</p>
</dd>
<dt>exang</dt><dd><p>Indicator of exercise induced angina</p>
</dd>
<dt>oldpeak</dt><dd><p>ST wave depression induced by exercise relative to rest</p>
</dd>
<dt>slope</dt><dd><p>The slope of the ST segment during peak exercise</p>
</dd>
<dt>ca</dt><dd><p>Number of major blood vessels coloured by fluoroscopy</p>
</dd>
<dt>thal</dt><dd><p>Type of heart defect</p>
</dd>
<dt>num</dt><dd><p>Diagnosis of heart disease. Values greater than one indicate heart disease of different sorts while a value of zero indicates no heart disease</p>
</dd>
<dt>study</dt><dd><p>The study where the participant's data was collected</p>
</dd>
</dl>



<h3>Usage</h3>

<pre><code class='language-R'>data(heart)
</code></pre>


<h3>Format</h3>

<p>A matrix with 920 rows and 15 columns, with each row reporting
measurements for a participant in one of the heart disease
studies.
</p>

<hr>
<h2 id='inDep'>Test pairwise variable independence</h2><span id='topic+inDep'></span>

<h3>Description</h3>

<p>This is a high-level function which accepts a data
set, stop criteria, and split functions for continuous variables
and then applies a chi-square test for independence to bins
generated by recursively binning the ranks of continuous variables
or implied by the combinations of levels of categorical variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inDep(
  data,
  stopCriteria,
  catCon = uniRIntSplit,
  conCon = rIntSplit,
  dropPoints = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="inDep_+3A_data">data</code></td>
<td>
<p>'data.frame' or object coercible to a 'data.frame'</p>
</td></tr>
<tr><td><code id="inDep_+3A_stopcriteria">stopCriteria</code></td>
<td>
<p>output of 'makeCriteria' providing criteria
used to stop binning to be passed to binning functions</p>
</td></tr>
<tr><td><code id="inDep_+3A_catcon">catCon</code></td>
<td>
<p>splitting function to apply to pairs of one
cateogorical and one continuous variable</p>
</td></tr>
<tr><td><code id="inDep_+3A_concon">conCon</code></td>
<td>
<p>splitting function to apply to pairs of continuous
variables</p>
</td></tr>
<tr><td><code id="inDep_+3A_droppoints">dropPoints</code></td>
<td>
<p>logical; should returned bins contain points?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of 'inDep' is a list, the first element of
which is a list of lists, each of which records the details of the
binning of a particular pair of variables
</p>


<h3>Value</h3>

<p>An 'inDep' object, with slots 'data', 'types', 'pairs',
'binnings', 'residuals', 'statistics', 'dfs', 'logps', and
'pvalues' that stores the results of using recursive binning with
the specified splitting logic to test independence on a data set.
'data' gives the name of the data object in the global environment
which was split, 'types' is a character vector giving the data
types of each pair, 'pairs' is a character vector of the variable
names of each pair, 'binnings' is a list of lists where each list
is the binning fir to the corresponding pair by the recursive
binning algorithm, 'residuals' is list of numeric vectors giving
the residual for each bin of each pairwise binning, 'statistics'
is a numeric vector giving the chi-squared statistic for each
binning, 'dfs' is a numeric vector giving the degrees of freedom
of each binning based on the variable type combination and the
final number of bins, 'logps' gives the natural logarithm of
the statistic's p-value, and finally 'pvalues' is a numeric
vector of p-values for 'statistics' assuming a chi-squared null
distribution with 'dfs' degrees of freedom.  Internally, the
p-values are computed on the log scale to better distinguish
between strongly dependent pairs and the 'pvalues' returned are
computed by calling 'exp(logps)'. The order of all returned values
is by increasing 'logps'.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>

<hr>
<h2 id='makeBin'>Make a bin</h2><span id='topic+makeBin'></span>

<h3>Description</h3>

<p>Creating a new bin object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBin(
  x,
  y,
  bnds = list(x = range(x) - c(1, 0), y = range(y) - c(1, 0)),
  expn = length(x),
  n = length(x),
  depth = 0,
  stopped = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeBin_+3A_x">x</code></td>
<td>
<p>numeric vector of observations on the first variable</p>
</td></tr>
<tr><td><code id="makeBin_+3A_y">y</code></td>
<td>
<p>numeric vector of observations on the second variable</p>
</td></tr>
<tr><td><code id="makeBin_+3A_bnds">bnds</code></td>
<td>
<p>list of length two with named elements 'x' and 'y'
each a vector of length two giving respective bin boundaries</p>
</td></tr>
<tr><td><code id="makeBin_+3A_expn">expn</code></td>
<td>
<p>expected number of points in the bin, can be
non-integer</p>
</td></tr>
<tr><td><code id="makeBin_+3A_n">n</code></td>
<td>
<p>observed count of points in the bin</p>
</td></tr>
<tr><td><code id="makeBin_+3A_depth">depth</code></td>
<td>
<p>number of splits from the initial bin to the bin</p>
</td></tr>
<tr><td><code id="makeBin_+3A_stopped">stopped</code></td>
<td>
<p>logical; should the bin be split further?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'makeBin' creates a bin list based on the arguments
provided to it. Should some be missing, basic defaults ensure
that the complete set of bin characteristics are created in
the resulting list representing the bin object.
</p>


<h3>Value</h3>

<p>A list with named elements matching these arguments
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>makeBin(x = 1:10, y = sample(1:10),
bnds = list(x = c(0,10), y = c(0, 10)), expn = 10, n = 10,
depth = 0, stopped = FALSE)
</code></pre>

<hr>
<h2 id='makeCriteria'>Make stop crteria</h2><span id='topic+makeCriteria'></span>

<h3>Description</h3>

<p>Capture a sequence of logical statements and append
them into a single expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeCriteria(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeCriteria_+3A_...">...</code></td>
<td>
<p>an arbitrary number of expressions which evaluate to
logicals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function, along with 'stopper' dictates the stop
behaviour of recursive binning. It accepts an arbitrary number
of arguments, each a logical statement, and appends them all into
a string separated by the pipe character.
</p>


<h3>Value</h3>

<p>A string which appends all expressions together.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>makeCriteria(depth &gt;= 5, n &lt; 1)
</code></pre>

<hr>
<h2 id='maxScoreSplit'>Size-restricted bivariate score maximizing splitting</h2><span id='topic+maxScoreSplit'></span>

<h3>Description</h3>

<p>Splits a bin based on the location maximizing a score
function with restrictions on minimum bin size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxScoreSplit(bin, scorer, minExp = 5, squarify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxScoreSplit_+3A_bin">bin</code></td>
<td>
<p>a bin to be split with elements 'x', 'y', 'depth',
'bnds' (list with elements 'x' and 'y'), 'expn', 'n'</p>
</td></tr>
<tr><td><code id="maxScoreSplit_+3A_scorer">scorer</code></td>
<td>
<p>function which accepts a numeric vector of potential
split coordinates and the bounds of 'bin' and returns a numeric
vector of scores for each</p>
</td></tr>
<tr><td><code id="maxScoreSplit_+3A_minexp">minExp</code></td>
<td>
<p>value giving the smallest expected count allowed for
bin splits</p>
</td></tr>
<tr><td><code id="maxScoreSplit_+3A_squarify">squarify</code></td>
<td>
<p>logical value, should we force splitting on
the longer side regardless of scores?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function serves as a wrapper which manages the
logic of splitting bins using a score function while maintaining
a minimum size and allowing forced splits along the wider edge.
</p>


<h3>Value</h3>

<p>A list of two bins resulting from the split of 'bin'
along the corresponding margin at the maximum location
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bin &lt;- makeBin(x = 1:10, y = sample(1:10))
maxScoreSplit(bin, chiScores)
maxScoreSplit(bin, miScores) # pretty similar for both
maxScoreSplit(bin, randScores)
maxScoreSplit(bin, randScores) # different every time
</code></pre>

<hr>
<h2 id='plotBinning'>Plot a binning using shaded rectangles</h2><span id='topic+plotBinning'></span>

<h3>Description</h3>

<p>Use a binning and vector of fill colours to
visualize the sample space of pairwise data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBinning(
  bins,
  fill,
  add = FALSE,
  factor = 0.5,
  xlab = "x",
  ylab = "y",
  suppressLabs = FALSE,
  border = "black",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotBinning_+3A_bins">bins</code></td>
<td>
<p>list of lists each with a named elements 'x', 'y', and
'bnds', the last of which is a list having named elements 'x' and
'y'</p>
</td></tr>
<tr><td><code id="plotBinning_+3A_fill">fill</code></td>
<td>
<p>vector of values which can be interpreted as colours
of the same length as 'bins'</p>
</td></tr>
<tr><td><code id="plotBinning_+3A_add">add</code></td>
<td>
<p>logical, should the plot of bins be added to the
current plot area?</p>
</td></tr>
<tr><td><code id="plotBinning_+3A_factor">factor</code></td>
<td>
<p>number between 0 and 1, what factor should be
applied to jittering of categorical variables?</p>
</td></tr>
<tr><td><code id="plotBinning_+3A_xlab">xlab</code></td>
<td>
<p>string, the label to be placed on the x axis</p>
</td></tr>
<tr><td><code id="plotBinning_+3A_ylab">ylab</code></td>
<td>
<p>string, the label to be placed on the y axis</p>
</td></tr>
<tr><td><code id="plotBinning_+3A_suppresslabs">suppressLabs</code></td>
<td>
<p>logical, should axis labels be suppressed or
displayed?</p>
</td></tr>
<tr><td><code id="plotBinning_+3A_border">border</code></td>
<td>
<p>argument to be passed to 'rect' internally giving
the border colour</p>
</td></tr>
<tr><td><code id="plotBinning_+3A_...">...</code></td>
<td>
<p>optional additional arguments to be passed to 'plot',
'points'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'plotBinning' plots each bin within a list of bins with
custom shading to communicate large residuals, the depth of bins,
or highlight particular bins. It automatically jitters points
within categorical levels to avoid overplotting.
</p>


<h3>Value</h3>

<p>A list of lists each with elements 'x', 'y', 'bnds',
'expn', and 'n'.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bin &lt;- list(x = 1:10, y = sample(1:10),
            bnds = list(x = c(0, 10), y = c(0, 10)),
            expn = 10, n = 10, depth = 0)
bin2 &lt;- halfSplit(bin, "x")
bin3 &lt;- unlist(lapply(bin2, maxScoreSplit, scorer = chiScores),
               recursive = FALSE)
plotBinning(bin3)
</code></pre>

<hr>
<h2 id='rIntSplit'>Random integer splitting</h2><span id='topic+rIntSplit'></span>

<h3>Description</h3>

<p>A function which splits a bin at a random integer
conforming to limits on minimum bin size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rIntSplit(bin, minExp = 5, squarify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rIntSplit_+3A_bin">bin</code></td>
<td>
<p>a bin to be split with elements 'x', 'y', 'depth',
'bnds' (list with elements 'x' and 'y'), 'expn', 'n'</p>
</td></tr>
<tr><td><code id="rIntSplit_+3A_minexp">minExp</code></td>
<td>
<p>numeric giving the minimum expected count allowed
in a bin</p>
</td></tr>
<tr><td><code id="rIntSplit_+3A_squarify">squarify</code></td>
<td>
<p>logical value, should we force splitting on
the longer side?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function serves as a wrapper which manages the
interaction of a score function, marginal splitting functions,
tie breaking function, and a maximum selection function to split
a bin at the observation coordinate which maximizes the score
function.
</p>


<h3>Value</h3>

<p>A list of two bins resulting from the split of 'bin'
along the corresponding margin at the maximum location
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bin &lt;- makeBin(x = 1:10, y = sample(1:10))
rIntSplit(bin, minExp = 2)
</code></pre>

<hr>
<h2 id='rUnifSplit'>Random uniform splitting</h2><span id='topic+rUnifSplit'></span>

<h3>Description</h3>

<p>Split bins randomly and uniformly
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rUnifSplit(bin, minExp = 0, squarify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rUnifSplit_+3A_bin">bin</code></td>
<td>
<p>a bin to be split with elements 'x', 'y', 'depth',
'bnds' (list with elements 'x' and 'y'), 'expn', 'n'</p>
</td></tr>
<tr><td><code id="rUnifSplit_+3A_minexp">minExp</code></td>
<td>
<p>numeric giving the minimum expected count allowed
in a bin</p>
</td></tr>
<tr><td><code id="rUnifSplit_+3A_squarify">squarify</code></td>
<td>
<p>logical value, should we force splitting on
the longer side?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function samples a coordinate uniformly along a
random margin and splits a bin at that coordinate. In contrast to
maxScoreSplit with randScores, this can introduce splits at
locations other than the points.
</p>


<h3>Value</h3>

<p>A list of two bins resulting from the split of 'bin'
at a random location on a random margin
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bin &lt;- makeBin(x = 1:10, y = sample(1:10))
rUnifSplit(bin, minExp = 2)
</code></pre>

<hr>
<h2 id='sandboxMaxSplit'>Bivariate score maximizing splitting</h2><span id='topic+sandboxMaxSplit'></span>

<h3>Description</h3>

<p>A function which splits a bin based on the location
maximizing a score function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sandboxMaxSplit(
  bin,
  scorer,
  ties = halfCutTie,
  minExp = 5,
  pickMax = which.max,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sandboxMaxSplit_+3A_bin">bin</code></td>
<td>
<p>a bin to be split with elements 'x', 'y', 'depth',
'bnds' (list with elements 'x' and 'y'), 'expn', 'n'</p>
</td></tr>
<tr><td><code id="sandboxMaxSplit_+3A_scorer">scorer</code></td>
<td>
<p>function which accepts a numeric vector of potential
split coordinates and the bounds of 'bin' and returns a numeric
vector of scores for each</p>
</td></tr>
<tr><td><code id="sandboxMaxSplit_+3A_ties">ties</code></td>
<td>
<p>function which is called to break ties when all splits
generate the same score</p>
</td></tr>
<tr><td><code id="sandboxMaxSplit_+3A_minexp">minExp</code></td>
<td>
<p>value giving the smallest expected count allowed for
bin splits</p>
</td></tr>
<tr><td><code id="sandboxMaxSplit_+3A_pickmax">pickMax</code></td>
<td>
<p>function which accepts a list of scores and returns
the element of the largest score according to some rule</p>
</td></tr>
<tr><td><code id="sandboxMaxSplit_+3A_...">...</code></td>
<td>
<p>optional additional arguments to 'scorer'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function serves as a wrapper which manages the
interaction of a score function, marginal splitting functions,
tie breaking function, and a maximum selection function to split
a bin at the observation coordinate which maximizes the score
function.
</p>


<h3>Value</h3>

<p>A list of two bins resulting from the split of 'bin'
along the corresponding margin at the maximum location
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>

<hr>
<h2 id='singleBinner'>Single split recursive binning</h2><span id='topic+singleBinner'></span>

<h3>Description</h3>

<p>'singleBinner' is an iterative implementation of a
recursive binary partitioning algorithm which accepts the
splitting and stopping functions that guide partitioning as
arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>singleBinner(
  x,
  y,
  stopper,
  splitter,
  init = halfSplit,
  maxK = 5,
  dropPoints = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="singleBinner_+3A_x">x</code></td>
<td>
<p>numeric vector of the first variable to be binned</p>
</td></tr>
<tr><td><code id="singleBinner_+3A_y">y</code></td>
<td>
<p>numeric vector of the second variable to be binned</p>
</td></tr>
<tr><td><code id="singleBinner_+3A_stopper">stopper</code></td>
<td>
<p>function which accepts a list with elements
'x', 'y', 'bnds', 'expn', and 'n' and returns a logical indicating
whether a split should occur for the bin defined by that list</p>
</td></tr>
<tr><td><code id="singleBinner_+3A_splitter">splitter</code></td>
<td>
<p>function which accepts a list of lists with
elements 'x', 'y', 'bnds', 'expn', and 'n' and returns a list
where each element is a list of two corresponding to a split of
the bin at that position in the original list</p>
</td></tr>
<tr><td><code id="singleBinner_+3A_init">init</code></td>
<td>
<p>function like 'splitter' applied to the first bin</p>
</td></tr>
<tr><td><code id="singleBinner_+3A_maxk">maxK</code></td>
<td>
<p>integer giving the number of bins where splitting
is stopped regardless of stop criteria</p>
</td></tr>
<tr><td><code id="singleBinner_+3A_droppoints">dropPoints</code></td>
<td>
<p>logical; should points be dropped from final
bins?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'singleBinner' creates a two-dimensional histogram of the
sample space of 'x' and 'y' by recursively splitting partitions of
the data using 'splitter' until 'stopper' indicates that all
partitions are not to be split. An optional argument 'init' gives
the function applied to the first bin containing all points to
initialize the binning algorithm. Unlike 'binner', it does this by
splitting one bin at a time, and so accepts an argument to specify
exactly how many bins to produce.
</p>


<h3>Value</h3>

<p>A list of lists each with elements 'x', 'y', 'bnds',
'expn', 'n', and 'stopped'.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## necessary set up
crits &lt;- makeCriteria(depth &gt;= 4, n &lt; 10, expn &lt;= 5)
stopFn &lt;- function(bns) stopper(bns, crits)
spltFn &lt;- function(bn) rIntSplit(bn, minExp = 5)
## generate data
x &lt;- sample(1:100)
y &lt;- sample(1:100)
## run binner
bins &lt;- singleBinner(x, y, stopper = stopFn, splitter = spltFn)
</code></pre>

<hr>
<h2 id='sp500pseudo'>De-Garched S&amp;P 500 returns</h2><span id='topic+sp500pseudo'></span>

<h3>Description</h3>

<p>This data is the result of code from the 'zenplots' package to
process S&amp;P 500 consituent stock returns into uniform
pseudo-observations for measuring association.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sp500pseudo)
</code></pre>


<h3>Format</h3>

<p>A matrix with 755 rows and 461 columns, the rows correspond to
dates between 2007 and 2009 and the columns correspond to the
different S&amp;P 500 constituent stocks.
</p>

<hr>
<h2 id='splitX'>Helper functions for marginal splitting</h2><span id='topic+splitX'></span><span id='topic+splitY'></span>

<h3>Description</h3>

<p>These functions are helpers to safely split bins
along X or Y.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitX(bin, bd, above, below)

splitY(bin, bd, above, below)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitX_+3A_bin">bin</code></td>
<td>
<p>a bin to be split with elements 'x', 'y', 'depth',
'bnds' (list with elements 'x' and 'y'), 'expn', 'n'</p>
</td></tr>
<tr><td><code id="splitX_+3A_bd">bd</code></td>
<td>
<p>numeric split point within the bin bounds</p>
</td></tr>
<tr><td><code id="splitX_+3A_above">above</code></td>
<td>
<p>indices of 'x' and 'y' points in the bin above 'bd'</p>
</td></tr>
<tr><td><code id="splitX_+3A_below">below</code></td>
<td>
<p>indices of 'x' and 'y' points in the bin below 'bd'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These unexported functions have been defined primarily
to clean up other code, but could be changed to obtain different
core functionality.
</p>


<h3>Value</h3>

<p>A list of two bins resulting from the split of 'bin' at
'bds'.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>splitX()</code>: Splitting on x
</p>
</li>
<li> <p><code>splitY()</code>: Splitting on y
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>

<hr>
<h2 id='stopper'>Check bins against stop criteria</h2><span id='topic+stopper'></span>

<h3>Description</h3>

<p>Evaluate the stop 'criteria' for each bin in
'binList'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopper(binList, criteria)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stopper_+3A_binlist">binList</code></td>
<td>
<p>a list of bins, each a list which can be cast as an
environment for evaluation</p>
</td></tr>
<tr><td><code id="stopper_+3A_criteria">criteria</code></td>
<td>
<p>string of logical expressions separated by pipes
to be evaluated within each bin of 'binList'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes use of R's lexical scoping to
evaluate 'criteria' (a string), within each bin of 'binList'.
</p>


<h3>Value</h3>

<p>A logical vector of the same length as 'binList'.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crits &lt;- makeCriteria(depth &gt;= 5, n &lt; 1)
binList1 &lt;- list(makeBin(x = c(1,2), y = c(3,1), depth = 1, n = 2),
                makeBin(x = c(3,4), y = c(2,4), depth = 1, n = 2))
binList2 &lt;- list(makeBin(x = c(1,2), y = c(3,1), depth = 6, n = 2),
                makeBin(x = c(), y = c(), depth = 1, n = 0))
stopper(binList1, crits)
stopper(binList2, crits)
</code></pre>

<hr>
<h2 id='summary.inDep'>S3 methods for 'inDep'</h2><span id='topic+summary.inDep'></span><span id='topic+plot.inDep'></span>

<h3>Description</h3>

<p>The 'summary' and 'plot' methods outlined here
support the quick description of an 'inDep' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'inDep'
summary(object, ...)

## S3 method for class 'inDep'
plot(x, ..., which = 1:5, border = "black", buffer = 0.01)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.inDep_+3A_object">object</code></td>
<td>
<p>'inDep' object to summarize</p>
</td></tr>
<tr><td><code id="summary.inDep_+3A_...">...</code></td>
<td>
<p>additional arguments to pass on to the method</p>
</td></tr>
<tr><td><code id="summary.inDep_+3A_x">x</code></td>
<td>
<p>object with class 'inDep'</p>
</td></tr>
<tr><td><code id="summary.inDep_+3A_which">which</code></td>
<td>
<p>indices of binnings to display from 'x', where
binnings are ordered by increasing p-value</p>
</td></tr>
<tr><td><code id="summary.inDep_+3A_border">border</code></td>
<td>
<p>colour of borders to be drawn on the binnings</p>
</td></tr>
<tr><td><code id="summary.inDep_+3A_buffer">buffer</code></td>
<td>
<p>relative width of empty space separating categories</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Methods
</p>
<p>For each index in 'which', this function produces a row
of three plots. The first plot is the raw data, the second plot
is the ranks of the data, and the final plot is the binning
contained in the 'inDep' object.
</p>


<h3>Value</h3>

<p>Nothing for the plot method, while summary quietly returns
a summary of 'inDep'
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>summary(inDep)</code>: Summary method for 'inDep'
</p>
</li>
<li> <p><code>plot(inDep)</code>: Plot method for 'inDep'
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>

<hr>
<h2 id='uniBinner'>Single margin binning</h2><span id='topic+uniBinner'></span>

<h3>Description</h3>

<p>'uniBinner' is an iterative implementation of a
recursive binary partitioning algorithm which accepts the
splitting and stopping functions that guide partitioning as
arguments and applies them to the margin 'y' alone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniBinner(x, y, stopper, splitter, dropPoints = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uniBinner_+3A_x">x</code></td>
<td>
<p>factor vector for the the first variable</p>
</td></tr>
<tr><td><code id="uniBinner_+3A_y">y</code></td>
<td>
<p>numeric vector of the second variable (to be split)</p>
</td></tr>
<tr><td><code id="uniBinner_+3A_stopper">stopper</code></td>
<td>
<p>function which accepts a list with elements
'x', 'y', 'bnds', 'expn', and 'n' and returns a logical indicating
whether a split should occur for the bin defined by that list</p>
</td></tr>
<tr><td><code id="uniBinner_+3A_splitter">splitter</code></td>
<td>
<p>function which accepts a list of lists with
elements 'x', 'y', 'bnds', 'expn', and 'n' and returns a list
where each element is a list of two corresponding to a split of
the bin at that position in the original list</p>
</td></tr>
<tr><td><code id="uniBinner_+3A_droppoints">dropPoints</code></td>
<td>
<p>logical; should points be dropped from final
bins?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'binner' creates a one-dimensional histogram of 'y' for
each categorical value of 'x' by recursively splitting partitions
of the data using 'splitter' until 'stopper' indicates that all
partitions are not to be split.
</p>


<h3>Value</h3>

<p>A list of lists each with elements 'x', 'y', 'bnds',
'expn', 'n', and 'stopped'.
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>

<hr>
<h2 id='uniMaxScoreSplit'>Univariate score maximizing splitting</h2><span id='topic+uniMaxScoreSplit'></span>

<h3>Description</h3>

<p>A function which splits a bin based on the location
maximizing a score function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniMaxScoreSplit(bin, scorer, minExp = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uniMaxScoreSplit_+3A_bin">bin</code></td>
<td>
<p>a bin to be split with elements 'x', 'y', 'depth',
'bnds' (list with elements 'x' and 'y'), 'expn', 'n'</p>
</td></tr>
<tr><td><code id="uniMaxScoreSplit_+3A_scorer">scorer</code></td>
<td>
<p>function which accepts a numeric vector of potential
split coordinates and the bounds of 'bin' and returns a numeric
vector of scores for each</p>
</td></tr>
<tr><td><code id="uniMaxScoreSplit_+3A_minexp">minExp</code></td>
<td>
<p>numeric giving the minimum expected count allowed
in a bin</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is the univariate version of
'maxScoreSplit' and so is considerably simpler. It assumes the
variable to be split is named 'x' in the bin, and the other
variable is to remain unsplit.
</p>


<h3>Value</h3>

<p>A list of two bins resulting from the split of 'bin' at
the maximum split location along y
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>

<hr>
<h2 id='uniRIntSplit'>Univariate random integer splitting</h2><span id='topic+uniRIntSplit'></span>

<h3>Description</h3>

<p>A function which splits a bin along x at a random
integer conforming to limits on minimum bin size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uniRIntSplit(bin, minExp = 5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uniRIntSplit_+3A_bin">bin</code></td>
<td>
<p>a bin to be split with elements 'x', 'y', 'depth',
'bnds' (list with elements 'x' and 'y'), 'expn', 'n'</p>
</td></tr>
<tr><td><code id="uniRIntSplit_+3A_minexp">minExp</code></td>
<td>
<p>numeric giving the minimum expected count allowed
in a bin</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function serves as a wrapper which manages the
interaction of a score function, marginal splitting functions,
tie breaking function, and a maximum selection function to split
a bin along a single margin at the observation coordinate which
maximizes the score function.
</p>


<h3>Value</h3>

<p>A list of two bins resulting from the split of 'bin'
along the corresponding margin at the maximum location
</p>


<h3>Author(s)</h3>

<p>Chris Salahub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bin &lt;- makeBin(x = 1:10, y = sample(1:10))
rIntSplit(bin, minExp = 2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
