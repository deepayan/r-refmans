<!DOCTYPE html><html><head><title>Help for package whoa</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {whoa}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bin_depths'><p>bin read depths of SNPs into categories having at least S observations</p></a></li>
<li><a href='#estimate_m_rd'><p>Estimate heterozygote miscall rate for different read depth categories (no nulls)</p></a></li>
<li><a href='#exp_and_obs_geno_freqs'><p>Computed expected and observed genotype frequencies from a &lsquo;vcfR&rsquo; object</p></a></li>
<li><a href='#geno_freq_boundaries'><p>function to return a tibble with the min/max values of genotype freqs possible</p></a></li>
<li><a href='#geno_freq_calc_single'><p>from on 012 file compute expected (assuming HW equilbrium) and observed genotype counts</p></a></li>
<li><a href='#geno_freqs_scatter'><p>return a &lsquo;ggplot2&rsquo; plot object of observed and expected genotype freqs</p></a></li>
<li><a href='#gibbsM'><p>simulate a new miscall rate for each read depth category given X and Y</p></a></li>
<li><a href='#gibbsP'><p>simulate new reference allele frequencies from their beta full conditional</p></a></li>
<li><a href='#gibbsX'><p>compute full conditional for each X given Y, p, R, and m, and then sample from it</p></a></li>
<li><a href='#infer_m'><p>get posterior estimates for m from different read depth categories</p></a></li>
<li><a href='#lobster_buz_2000'><p>Restriction-associated digest (RAD) sequence data from 36 lobsters at 2000 single nucleotide polymorphisms (SNPs)</p></a></li>
<li><a href='#lobster_buz_2000_as_012_matrix'><p>An 012 matrix from  (RAD) sequence data from 36 lobsters at 2000 single nucleotide polymorphisms (SNPs)</p></a></li>
<li><a href='#make_it_012'><p>just a quick function for making an 012 matrix from a character matrix</p></a></li>
<li><a href='#posteriors_plot'><p>return a &lsquo;ggplot2&rsquo; plot object of the posterior esimates for heterozyote miscall rates</p></a></li>
<li><a href='#prep_vcf_for_est_m_rd'><p>convert a VCF into an 012,-1 matrix and read_depth bin matrix for estimation</p></a></li>
<li><a href='#tidy_m_ests'><p>tidy up the estimate_m_rd output into something you can plot</p></a></li>
<li><a href='#whoa'><p>whoa: Evaluation of genotyping error in genotype by sequencing data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Evaluation of Genotyping Error in Genotype-by-Sequencing Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eric C. Anderson &lt;eric.anderson@noaa.gov&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>This is a small, lightweight package that lets users investigate the distribution of genotypes in genotype-by-sequencing (GBS) data where they expect (by and large) Hardy-Weinberg equilibrium, in order to assess rates of genotyping errors and the dependence of those rates on read depth.  It implements a Markov chain Monte Carlo (MCMC) sampler using 'Rcpp' to compute a Bayesian estimate of what we call the heterozygote miscall rate for restriction-associated digest (RAD) sequencing data and other types of reduced representation GBS data. It also provides functions to generate plots of expected and observed genotype frequencies. Some background on these topics can be found in a recent paper "Recent advances in conservation and population genomics data analysis" by Hendricks et al. (2018) &lt;<a href="https://doi.org/10.1111%2Feva.12659">doi:10.1111/eva.12659</a>&gt;, and another paper describing the MCMC approach is in preparation with Gordon Luikart and Thierry Gosselin.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/publicdomain/zero/1.0/legalcode">CC0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, magrittr, tibble, tidyr, Rcpp (&ge; 0.12.16), vcfR,
viridis, ggplot2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-09 22:58:14 UTC; eriq</td>
</tr>
<tr>
<td>Author:</td>
<td>Eric C. Anderson [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-11 06:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bin_depths'>bin read depths of SNPs into categories having at least S observations</h2><span id='topic+bin_depths'></span>

<h3>Description</h3>

<p>bin read depths of SNPs into categories having at least S observations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_depths(D, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin_depths_+3A_d">D</code></td>
<td>
<p>a matrix of read depths.  Rows are individuals, columns are SNPs.  Cells where data are missing
in the genotype matrix must be denoted as NA</p>
</td></tr>
<tr><td><code id="bin_depths_+3A_s">S</code></td>
<td>
<p>the min number of observations to have in each bin</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns a list with two components.  <code>dp_bins</code> is a matrix of the same
shape as D with the bin categories (as 1, 2, ...) and -1 for this cells
corresponding to missing genotypes.  <code>num_cats</code> is the number of depth bins.
<code>tidy_bins</code> is a long format description of the bins.
<code>bin_stats</code> is a tibble giving summary information about the read depth bins which
is useful for plotting things, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# get a matrix of read depths and make it an integer matrix
depths &lt;- vcfR::extract.gt(lobster_buz_2000, element = "DP")
storage.mode(depths) &lt;- "integer"

# get a character matrix of genotypes, so we can figure out which
# are missing and mask those from depths
genos &lt;- vcfR::extract.gt(lobster_buz_2000, element = "GT")

# make missing in depths if missing in genos
depths[is.na(genos)] &lt;- NA

# bin the read depths into bins with at least 1000 observations in each bin
bins &lt;- bin_depths(depths, 1000)
</code></pre>

<hr>
<h2 id='estimate_m_rd'>Estimate heterozygote miscall rate for different read depth categories (no nulls)</h2><span id='topic+estimate_m_rd'></span>

<h3>Description</h3>

<p>To see how this Rcpp function is applied, see the code in
<code><a href="#topic+infer_m">infer_m</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_m_rd(Y, R, init_m, num_cats, p_prior, m_prior, num_reps)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_m_rd_+3A_y">Y</code></td>
<td>
<p>the 012,-1 matrix that is N x L giving the observed genotypes of the N individuals
at L SNPs.</p>
</td></tr>
<tr><td><code id="estimate_m_rd_+3A_r">R</code></td>
<td>
<p>integer matrix that is N x L giving the read depth categories.  These must be indexed from
1 up to num_cats.  Missing data should be -1.</p>
</td></tr>
<tr><td><code id="estimate_m_rd_+3A_init_m">init_m</code></td>
<td>
<p>starting value for m.  Typically you might want to use the m estimated
from init_m</p>
</td></tr>
<tr><td><code id="estimate_m_rd_+3A_num_cats">num_cats</code></td>
<td>
<p>the number of read depth categories.</p>
</td></tr>
<tr><td><code id="estimate_m_rd_+3A_p_prior">p_prior</code></td>
<td>
<p>two-vector that holds the beta parameters for a prior on the
allele frequency for each locus.  Typical value is c(0.5, 0.5).</p>
</td></tr>
<tr><td><code id="estimate_m_rd_+3A_m_prior">m_prior</code></td>
<td>
<p>two-vector that holds the beta parameters for a prior on the
heterozygote miscall rate for each locus.  Typical value is c(0.5, 0.5).</p>
</td></tr>
<tr><td><code id="estimate_m_rd_+3A_num_reps">num_reps</code></td>
<td>
<p>the number of MCMC sweeps to do.</p>
</td></tr>
</table>

<hr>
<h2 id='exp_and_obs_geno_freqs'>Computed expected and observed genotype frequencies from a &lsquo;vcfR&rsquo; object</h2><span id='topic+exp_and_obs_geno_freqs'></span>

<h3>Description</h3>

<p>Under the assumption of Hardy-Weinberg equilibrium, this function uses the
estimated allele frequencies from the data set in v to compute expected genotype
frequencies, and then reports these along with the observed genotype frequencies.
Loci come out named as CHROM&ndash;POS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exp_and_obs_geno_freqs(
  v = NULL,
  d012 = NULL,
  prop_indv_required = 0.5,
  prop_loci_required = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exp_and_obs_geno_freqs_+3A_v">v</code></td>
<td>
<p>a &lsquo;vcfR&rsquo; object.  Exactly one of <code>v</code> or <code>d012</code> is required. But you
can't use both!</p>
</td></tr>
<tr><td><code id="exp_and_obs_geno_freqs_+3A_d012">d012</code></td>
<td>
<p>an integer matrix (or a numeric matrix, which will be coerced to
be of integer type) with individuals in columns, and markers in rows.
0 denotes a genotype homozygous for the reference allele, 1 is a heterozygote, 2 is a
homozygote for the alternate allele, and -1 denotes missing data.  This matrix is not
required to have column (sample) names.  They won't be used if they are present.  But,
the matrix must have rownames, which should be in the format of CHROM&ndash;POS (i.e. the &quot;chromosome&quot;
name (or the &quot;contig&quot; name) followed by a &quot;&ndash;&quot; followed by the position of the marker in the &quot;chromosome&quot;).
Exactly one of <code>v</code> or <code>d012</code> is required. But you
can't use both!</p>
</td></tr>
<tr><td><code id="exp_and_obs_geno_freqs_+3A_prop_indv_required">prop_indv_required</code></td>
<td>
<p>loci will be dropped if a proportion of
individuals less than prop_indv_required have non-missing data at that locus.
Default is 0.5</p>
</td></tr>
<tr><td><code id="exp_and_obs_geno_freqs_+3A_prop_loci_required">prop_loci_required</code></td>
<td>
<p>individual will be dropped if their proportion of
non-missing loci is less than prop_loci_required. Default is 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a tibble with the following columns: <code>snp</code> = the locus name
as CHROM&ndash;POS; <code>p</code> = The frequency of the alternate (ALT) allele; <code>ntot</code> = the total
number of individuals with no missing data at the locus; <code>geno</code> = column
telling which genotype (0, 1, or 2) is referred to; <code>p_exp</code> = expected
frequency of the genotype; <code>p_obs</code> = observed frequency of genotype;
<code>n_exp</code> = expected number of such genotypes; <code>n_obs</code> = observed
number of such genotypes; <code>z_score</code> = simple statistic giving how far
the observed genotype frequency is from that expected under Hardy-Weinberg
equilibrium.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eao &lt;- exp_and_obs_geno_freqs(v = lobster_buz_2000)

# if you wanted to run that on an 012 matrix,
# it would be like this:
eao012 &lt;- exp_and_obs_geno_freqs(d012 = lobster_buz_2000_as_012_matrix)
</code></pre>

<hr>
<h2 id='geno_freq_boundaries'>function to return a tibble with the min/max values of genotype freqs possible</h2><span id='topic+geno_freq_boundaries'></span>

<h3>Description</h3>

<p>These mins and maxes occur because the genotypes are used to estimate
the allele frequencies.  The output of this function is useful for
putting boundaries on plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno_freq_boundaries()
</code></pre>


<h3>Value</h3>

<p>a tibble
</p>


<h3>Examples</h3>

<pre><code class='language-R'>gfb &lt;- geno_freq_boundaries()
</code></pre>

<hr>
<h2 id='geno_freq_calc_single'>from on 012 file compute expected (assuming HW equilbrium) and observed genotype counts</h2><span id='topic+geno_freq_calc_single'></span>

<h3>Description</h3>

<p>This is an internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno_freq_calc_single(g012)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geno_freq_calc_single_+3A_g012">g012</code></td>
<td>
<p>an 012 matrix, with indivs in rows and loci in columns.
Missing data can be -1 or NA. The matrix must
have colnames which are the locus names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See information for return value of <code><a href="#topic+exp_and_obs_geno_freqs">exp_and_obs_geno_freqs</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get an 012 matrix from the lobster data
tmp &lt;- t(vcfR::extract.gt(lobster_buz_2000, element = "GT"))
locnames &lt;- colnames(tmp)
g &lt;- make_it_012(tmp)
colnames(g) &lt;- locnames # put these back on since make_it_012 removes them
gf &lt;- geno_freq_calc_single(g)
</code></pre>

<hr>
<h2 id='geno_freqs_scatter'>return a &lsquo;ggplot2&rsquo; plot object of observed and expected genotype freqs</h2><span id='topic+geno_freqs_scatter'></span>

<h3>Description</h3>

<p>return a &lsquo;ggplot2&rsquo; plot object of observed and expected genotype freqs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geno_freqs_scatter(gfc, alpha = 0.2, max_plot_loci = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geno_freqs_scatter_+3A_gfc">gfc</code></td>
<td>
<p>a tibble like that created by exp_and_obs_geno_freqs()</p>
</td></tr>
<tr><td><code id="geno_freqs_scatter_+3A_alpha">alpha</code></td>
<td>
<p>the transparency (alpha) parameter to apply to the points
in the scatterplot. Default is 0.2.</p>
</td></tr>
<tr><td><code id="geno_freqs_scatter_+3A_max_plot_loci">max_plot_loci</code></td>
<td>
<p>By default this plots only 500 loci, sampled
randomly, to keep &lsquo;ggplot2&rsquo; taking forever to plot, for example, 100K
points.  If you want to plot all the points, set this to a number
larger than the number of single nucleotide polymorphisms (SNPs) in the data set.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># get the expected and observed geno freqs
gfreqs &lt;- exp_and_obs_geno_freqs(lobster_buz_2000)
g &lt;- geno_freqs_scatter(gfreqs)

# now g is a 'ggplot2' object.
</code></pre>

<hr>
<h2 id='gibbsM'>simulate a new miscall rate for each read depth category given X and Y</h2><span id='topic+gibbsM'></span>

<h3>Description</h3>

<p>This just writes new values into M as if it were an output variable.
Internal function used within <code><a href="#topic+estimate_m_rd">estimate_m_rd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gibbsM(M, num_cats, X, Y, R, pri)
</code></pre>

<hr>
<h2 id='gibbsP'>simulate new reference allele frequencies from their beta full conditional</h2><span id='topic+gibbsP'></span>

<h3>Description</h3>

<p>This just writes new values into P as if it were an output variable.
Internal function used within <code><a href="#topic+estimate_m_rd">estimate_m_rd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gibbsP(p, X, pri)
</code></pre>

<hr>
<h2 id='gibbsX'>compute full conditional for each X given Y, p, R, and m, and then sample from it</h2><span id='topic+gibbsX'></span>

<h3>Description</h3>

<p>This just writes new values into X as if it were an output variable.
Internal function used within <code><a href="#topic+estimate_m_rd">estimate_m_rd</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gibbsX(X, Y, R, p, M)
</code></pre>

<hr>
<h2 id='infer_m'>get posterior estimates for m from different read depth categories</h2><span id='topic+infer_m'></span>

<h3>Description</h3>

<p>This function calls internal C++ routines that perform Markov
chain Monte Carlo (MCMC) to sample from the posterior distribution of the
heterozygote miscall rate for each read depth category.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infer_m(
  v,
  minBin,
  indivs = NULL,
  init_m = 0.1,
  num_sweeps = 500,
  burn_in = 100
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infer_m_+3A_v">v</code></td>
<td>
<p>a &lsquo;vcfR&rsquo; object holding the information from a variant call format (VCF) file with the genotype and depth data.
If you are going to be breaking the estimates down by read depth categories, the VCF file must have a DP field for
every genotype.</p>
</td></tr>
<tr><td><code id="infer_m_+3A_minbin">minBin</code></td>
<td>
<p>minimum number of observations for each read depth bin.  If you have 10K markers
and 50 individuals then you have about 500,000 genotypes to play with.  Requiring bins with at
least 5,000 genotypes in them will give you less than 100 bins.  You can play around with this
number to get the right number of bins.  The algorithm breaks the read depths up into bins that
have at least minBin genotypes in them.</p>
</td></tr>
<tr><td><code id="infer_m_+3A_indivs">indivs</code></td>
<td>
<p>a character vector holding
the names of the individuals from the VCF file to include in the analysis.  By default
this is NULL, in which case everyone from the file is included.</p>
</td></tr>
<tr><td><code id="infer_m_+3A_init_m">init_m</code></td>
<td>
<p>the initial value of the heterozygote miscall rate assumed for each read depth bin.
By default this is 0.1.</p>
</td></tr>
<tr><td><code id="infer_m_+3A_num_sweeps">num_sweeps</code></td>
<td>
<p>the number of sweeps of the MCMC algorithm to do.  Default is 500, which is a
little on the short side.  Run multiple times and make sure the values obtained are similar across
runs to assess convergence.</p>
</td></tr>
<tr><td><code id="infer_m_+3A_burn_in">burn_in</code></td>
<td>
<p>how many sweeps from the beginning of the chain to discard when computing the
posterior means and quantiles.  Default is 100.  Note that full traces of the visited m values
for every read depth bin are returned as well, so that the behavior of the chain in those early
steps can be investigated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The read depth bins are
determined by passing to the function <code>minBin</code>&mdash;the minimum number of observations desired for each read
depth bin.  The function then breaks the observations into bins so that each read depth bin
has at least minBin observations.
</p>
<p>Note that if you want to estimate the heterozygote miscall rate <b>overall</b> (i.e., not conditioning each
estimate on a read depth bin), then simply give a very large number (larger than the number of
markers times the number of individuals) for minBin.  For example, you could use a number like 1e15
for minBin. As a consequence, all the genotypes will be put into a single read depth bin.
</p>


<h3>Value</h3>

<p>A list with six components:
</p>

<dl>
<dt>m_posteriors</dt><dd><p>A tibble with 6 columns: bin = the index of the read depth bin;
mean = the posterior mean estimate of the the heterozygote miscall rate in that bin;
lo95 = the low endpoint of the 95
95
and mean_dp = the mean read depth in the bin. </p>
</dd>
<dt>m_traces</dt><dd><p>A tibble with all the values visited for m for every read depth bin.  This tibble
has three columns: bin = the index of the read depth bin; sweep = the sweep number, value = the value
of m for that read depth bin in that particular sweep. </p>
</dd>
<dt>dp_summary</dt><dd><p>A tibble summarizing how many genotypes of different read depths
appear in each bin.</p>
</dd>
<dt>bin_stats</dt><dd><p>A tibble with a different summary of the read-depth bins.</p>
</dd>
<dt>num_sweeps</dt><dd><p>Number of MCMC sweeps used.</p>
</dd>
<dt>burn_in</dt><dd><p>Number of sweeps discarded as burn in.</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'># Shorter run than recommended (for quick example...)
im &lt;- infer_m(lobster_buz_2000, minBin = 1000, num_sweeps = 100, burn_in = 20)
</code></pre>

<hr>
<h2 id='lobster_buz_2000'>Restriction-associated digest (RAD) sequence data from 36 lobsters at 2000 single nucleotide polymorphisms (SNPs)</h2><span id='topic+lobster_buz_2000'></span>

<h3>Description</h3>

<p>A data set from the study by Benestan et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lobster_buz_2000
</code></pre>


<h3>Format</h3>

<p>A &lsquo;vcfR&rsquo; object in which the original data set has
been reduced to just the 36 lobsters from the BUZ population
and a randomly sampled 2000 SNPs from the 10,156 originally
available.
</p>
<p>This is the sort of object obtained after calling <code>vcfR::read.vcfR()</code>
on a variant call format (VCF) file.
</p>


<h3>Source</h3>

<p><a href="https://datadryad.org/stash/dataset/doi:10.5061/dryad.q771r">https://datadryad.org/stash/dataset/doi:10.5061/dryad.q771r</a>
</p>

<hr>
<h2 id='lobster_buz_2000_as_012_matrix'>An 012 matrix from  (RAD) sequence data from 36 lobsters at 2000 single nucleotide polymorphisms (SNPs)</h2><span id='topic+lobster_buz_2000_as_012_matrix'></span>

<h3>Description</h3>

<p>A data set from the study by Benestan et al. (2016).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lobster_buz_2000_as_012_matrix
</code></pre>


<h3>Format</h3>

<p>This is an integer matrix with positions in rows and samples in columns.
It is an 012 matrix that corresponds to lobster_buz_2000.  It is useful as
an example of the necessary format for the d012 argument to <code><a href="#topic+exp_and_obs_geno_freqs">exp_and_obs_geno_freqs</a></code>.
</p>


<h3>Source</h3>

<p><a href="https://datadryad.org/stash/dataset/doi:10.5061/dryad.q771r">https://datadryad.org/stash/dataset/doi:10.5061/dryad.q771r</a>
</p>

<hr>
<h2 id='make_it_012'>just a quick function for making an 012 matrix from a character matrix</h2><span id='topic+make_it_012'></span>

<h3>Description</h3>

<p>The standard way within R of pulling values out of a named
vector really bogs down on large data sets.  So I will do this instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_it_012(M)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_it_012_+3A_m">M</code></td>
<td>
<p>a character matrix of variant call format (VCF) genotypes and no dimnames.  Allowable values are
&quot;0/0&quot;, and &quot;0|0&quot;, which get coverted to integer 0;  &quot;0/1&quot;, &quot;0|1&quot;, &quot;1/0&quot;, and &quot;1|0&quot;,
which get converted to integer 1; and
&quot;1/1&quot;, and &quot;1|1&quot;, which get converted to integer 2.  Everything else gets
converted to -1 to denote missing data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer matrix of values which are 0, 1, 2, or -1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get an 012 matrix from the lobster data
tmp &lt;- t(vcfR::extract.gt(lobster_buz_2000, element = "GT"))
dimnames(tmp) &lt;- NULL
g &lt;- make_it_012(tmp)
</code></pre>

<hr>
<h2 id='posteriors_plot'>return a &lsquo;ggplot2&rsquo; plot object of the posterior esimates for heterozyote miscall rates</h2><span id='topic+posteriors_plot'></span>

<h3>Description</h3>

<p>This just returns a &lsquo;ggplot2&rsquo; plot object that plots the read depth bins on the x-axis
and the posterior mean m estimates (and credible intervals) on the y-axis, and
depicts the number of genotypes in each read depth bin using color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>posteriors_plot(P)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="posteriors_plot_+3A_p">P</code></td>
<td>
<p>the tibble that is the m_posteriors component of <code><a href="#topic+infer_m">infer_m</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a &lsquo;ggplot2&rsquo; plot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># get something to plot (short run for example)
im &lt;- infer_m(lobster_buz_2000, minBin = 1000, num_sweeps = 100, burn_in = 20)

# then plot it
g &lt;- posteriors_plot(im$m_posteriors)

# now g is a 'ggplot2' object
</code></pre>

<hr>
<h2 id='prep_vcf_for_est_m_rd'>convert a VCF into an 012,-1 matrix and read_depth bin matrix for estimation</h2><span id='topic+prep_vcf_for_est_m_rd'></span>

<h3>Description</h3>

<p>convert a VCF into an 012,-1 matrix and read_depth bin matrix for estimation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prep_vcf_for_est_m_rd(v, DF = "DP", minBin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prep_vcf_for_est_m_rd_+3A_v">v</code></td>
<td>
<p>a vcfR object into which a VCF file has been read</p>
</td></tr>
<tr><td><code id="prep_vcf_for_est_m_rd_+3A_df">DF</code></td>
<td>
<p>Field to use for obtaining total read depth.  Currently
all that is available is DP.</p>
</td></tr>
<tr><td><code id="prep_vcf_for_est_m_rd_+3A_minbin">minBin</code></td>
<td>
<p>minimum number of observations for each read depth bin</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This sends back a list with <code>mat012</code>: the 012,-1 matrix of genotypes, and
<code>dp_bins_list</code>: the list returned by bin_depths().
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pv &lt;- prep_vcf_for_est_m_rd(lobster_buz_2000, minBin = 1000)
</code></pre>

<hr>
<h2 id='tidy_m_ests'>tidy up the estimate_m_rd output into something you can plot</h2><span id='topic+tidy_m_ests'></span>

<h3>Description</h3>

<p>Internal function. See use in <code><a href="#topic+infer_m">infer_m</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tidy_m_ests(E, S, TB, burn = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tidy_m_ests_+3A_e">E</code></td>
<td>
<p>the list returned by the estimation function</p>
</td></tr>
<tr><td><code id="tidy_m_ests_+3A_s">S</code></td>
<td>
<p>the bin stats</p>
</td></tr>
<tr><td><code id="tidy_m_ests_+3A_tb">TB</code></td>
<td>
<p>the tidy bins</p>
</td></tr>
<tr><td><code id="tidy_m_ests_+3A_burn">burn</code></td>
<td>
<p>how much for burn in?</p>
</td></tr>
</table>

<hr>
<h2 id='whoa'>whoa: Evaluation of genotyping error in genotype by sequencing data</h2><span id='topic+whoa'></span>

<h3>Description</h3>

<p>The name is found in the capitals here:  <code>W</code>here's my <code>H</code>eterozygotes?! <code>O</code>bservations
of genotyping <code>A</code>ccuracy.
</p>


<h3>the <code>whoa</code> main high-level functions</h3>

<p>The main function in the package whoa is <code><a href="#topic+infer_m">infer_m</a></code>.
This function infers the heterozygote miscall rate (the rate at
which true heterozygotes have been miscalled as homozygotes in
genotype-by-sequencing data) for calls made upon genotypes falling
within different read depth categories.
</p>
<p>The output from  <code><a href="#topic+infer_m">infer_m</a></code> is easily plotted by passing the
m_posteriors component of the output list from <code>infer_m</code> into
<code><a href="#topic+posteriors_plot">posteriors_plot</a></code>.
</p>


<h3>example data</h3>

<p>The package comes with a small data set, <code><a href="#topic+lobster_buz_2000">lobster_buz_2000</a></code>, which
was read in from a variant call format (VCF) file and is now stored in the package as a &lsquo;vcfR&rsquo; object.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
