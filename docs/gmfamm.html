<!DOCTYPE html><html lang="en"><head><title>Help for package gmfamm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gmfamm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#apply_respfun_outcome'><p>Apply link functions based on outcome information</p></a></li>
<li><a href='#compress_outcomes'><p>Compress the outcome list of predictions into single vectors</p></a></li>
<li><a href='#fam'><p>First draft of new family</p></a></li>
<li><a href='#fam2'><p>Next draft of new family</p></a></li>
<li><a href='#famg'><p>Draft of new family for gamlss2</p></a></li>
<li><a href='#gm'><p>Indicate Generalized Multivariate Model</p></a></li>
<li><a href='#gmfamm'><p>Family object for bamlss for Generalized Multivariate Functional Additive</p>
Mixed Models</a></li>
<li><a href='#gmfamm_predict'><p>Prediction of Generalized Multivariate Functional Additive Mixed model</p></a></li>
<li><a href='#incorporate_outcome'><p>Incorporate outcome information into</p></a></li>
<li><a href='#mface_cyc'><p>Multilevel functional principal components analysis with fast covariance estimation</p></a></li>
<li><a href='#pbc_gmfamm'><p>Subset of PBC data set for GMFAMM</p></a></li>
<li><a href='#simMuFu'><p>Simulate multivariate functional data</p></a></li>
<li><a href='#trafficfam'><p>Draft of family for traffic example</p></a></li>
<li><a href='#trafficfam2'><p>Draft 2 of family for traffic example</p></a></li>
<li><a href='#trafficfam3'><p>Draft of family for traffic example</p></a></li>
<li><a href='#trafficfam4'><p>Draft of family for traffic example</p></a></li>
<li><a href='#varbinq'><p>Generalized Multivariate Functional Additive Models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Generalized Multivariate Functional Additive Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Supply implementation to model generalized multivariate functional
 data using Bayesian additive mixed models of R package 'bamlss' via a latent
 Gaussian process (see Umlauf, Klein, Zeileis (2018) 
 &lt;<a href="https://doi.org/10.1080%2F10618600.2017.1407325">doi:10.1080/10618600.2017.1407325</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5), bamlss</td>
</tr>
<tr>
<td>Imports:</td>
<td>mgcv, stats, MASS, splines, Matrix</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), tidyverse, JMbayes2, registr, funData,
MFPCA, MJMbamlss, refund</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-17 20:10:54 UTC; alex</td>
</tr>
<tr>
<td>Author:</td>
<td>Nikolaus Umlauf <a href="https://orcid.org/0000-0003-2160-9803"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Alexander Volkmann [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Volkmann &lt;alexandervolkmann8@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-18 14:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='apply_respfun_outcome'>Apply link functions based on outcome information</h2><span id='topic+apply_respfun_outcome'></span>

<h3>Description</h3>

<p>This is an internal function for the extreme case that a vector is plugged
into a response function depending on outcome information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_respfun_outcome(x, outcome, links)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="apply_respfun_outcome_+3A_x">x</code></td>
<td>
<p>Vector of additive predictors.</p>
</td></tr>
<tr><td><code id="apply_respfun_outcome_+3A_outcome">outcome</code></td>
<td>
<p>Factor vector containing information on the outcome of
the corresponding element of vector x.</p>
</td></tr>
<tr><td><code id="apply_respfun_outcome_+3A_links">links</code></td>
<td>
<p>Vector containing the names of the respective links for the mu
outcomes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of lenght x where different response functions have been
applied.
</p>

<hr>
<h2 id='compress_outcomes'>Compress the outcome list of predictions into single vectors</h2><span id='topic+compress_outcomes'></span>

<h3>Description</h3>

<p>This is an internal function combining all mu and sigma outcomes,
respectively, taking into account the outcome information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compress_outcomes(pred_list, mus, sigmas, outcome)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compress_outcomes_+3A_pred_list">pred_list</code></td>
<td>
<p>List of predictions for each outcome.</p>
</td></tr>
<tr><td><code id="compress_outcomes_+3A_mus">mus</code></td>
<td>
<p>Character vector with names of included mu models.</p>
</td></tr>
<tr><td><code id="compress_outcomes_+3A_sigmas">sigmas</code></td>
<td>
<p>Character vector with names of included sigma models.</p>
</td></tr>
<tr><td><code id="compress_outcomes_+3A_outcome">outcome</code></td>
<td>
<p>Factor vector containing the information of which row
corresponds to which outcome.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with two elements containing predictions for mu and sigma model
terms. If a some model parameters are missing (such as sigma for binomial
distributional assumption) NA elements are contained.
</p>

<hr>
<h2 id='fam'>First draft of new family</h2><span id='topic+fam'></span>

<h3>Description</h3>

<p>Fix three distributional assumptions and do not supply any derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fam(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fam_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bamlss family object.
</p>

<hr>
<h2 id='fam2'>Next draft of new family</h2><span id='topic+fam2'></span>

<h3>Description</h3>

<p>Fix three distributional assumptions but supply derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fam2(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fam2_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bamlss family object.
</p>

<hr>
<h2 id='famg'>Draft of new family for gamlss2</h2><span id='topic+famg'></span>

<h3>Description</h3>

<p>Fix three distributional assumptions but supply derivatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>famg(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="famg_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A gamlss2 family object.
</p>

<hr>
<h2 id='gm'>Indicate Generalized Multivariate Model</h2><span id='topic+gm'></span>

<h3>Description</h3>

<p>This function is used in the formula call of a generalized multivariate
functional additive mixed model to supply the information of the outcome and
factor variables to bamlss.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gm(y, outcome, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gm_+3A_y">y</code></td>
<td>
<p>Name of variable in data set which contains the values of the
longitudinal outcome.</p>
</td></tr>
<tr><td><code id="gm_+3A_outcome">outcome</code></td>
<td>
<p>Name of variable in data set which is the factor variable
indicating which outcome the value is from. Note that only the ordering
not the factor levels are used in the estimation process.</p>
</td></tr>
<tr><td><code id="gm_+3A_...">...</code></td>
<td>
<p>Additional arguments not used at the moment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix combining y and outcomes of class 'matrix' and 'gm'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
# Number of subjects
n &lt;- 10

# Number of observations
ni &lt;- 3

# Covariate vector
x &lt;- rep(rnorm(n), each = ni)
t &lt;- rep(c(0, 0.5, 1), times = n)

# Additive predictor
eta_1 &lt;- t + 0.5*x
eta_2 &lt;- t + 0.5*x

# Outcomes
y1 &lt;- rnorm(n*ni, eta_1, 0.3)
y2 &lt;- rbinom(n*ni, 1, 1/(1 + exp(-eta_2)))

# Data format
dat &lt;- data.frame(
   id = factor(rep(seq_len(n), each = ni)),
   y = c(y1, y2),
   dim = factor(rep(c(1, 2), each = n*ni)),
   t = t,
   x = x,
   fpc = 1
)

# Specify formula
f &lt;- list(
  gm(y, dim) ~ t + x,
  sigma1 ~ 1,
  mu2 ~ t + x,
  Lambda ~ -1 + s(id, by = fpc, bs = "re")
)

</code></pre>

<hr>
<h2 id='gmfamm'>Family object for bamlss for Generalized Multivariate Functional Additive
Mixed Models</h2><span id='topic+gmfamm'></span>

<h3>Description</h3>

<p>Family object for bamlss for Generalized Multivariate Functional Additive
Mixed Models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmfamm(family, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gmfamm_+3A_family">family</code></td>
<td>
<p>Vector of bamlss family names to construct the full family.</p>
</td></tr>
<tr><td><code id="gmfamm_+3A_...">...</code></td>
<td>
<p>Not used at the moment.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>family.bamlss</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Short example to see how a family can be specified.
gmfamm(family = c("binomial", "poisson", "gaussian"))

# Long example to see how an analysis can be done.

library(tidyverse)
library(registr)
library(funData)
library(MFPCA)
library(MJMbamlss)
library(refund)

# Take only three outcomes (normal, binary, poisson)
# Log-transformation of serBilir to get normal distribution
pbc &lt;- pbc_gmfamm %&gt;%
  filter(outcome %in% c("serBilir", "hepatomegaly", "platelets")) %&gt;%
  droplevels() %&gt;%
  mutate(y = case_when(outcome == "serBilir" ~ log(y),
                       outcome != "serBilir" ~ y),
         year = ifelse(year &gt; 9.99, 9.99, year))

pbc_list &lt;- split(pbc, pbc$outcome) %&gt;%
  lapply(function (dat) {
    dat &lt;- dat %&gt;%
      mutate(value = y, index = year) %&gt;%
      select(id, value, index) %&gt;%
      arrange(id, index)
  })

# Fit separate univariate GPFCAs
# Two numbers (x, y) in npc criterion indicate x% total variance but each pc
# hast to contribute at least y%
gfpcs &lt;- mapply(function (data, fams) {
  gfpca_twoStep(Y = data, family = fams, npc_criterion = c(0.99, 0.001),
                verbose = FALSE)
}, data = pbc_list, fams = list("binomial", "poisson", "gaussian"),
SIMPLIFY = FALSE)

# Convert fitted values to funData
mfdata &lt;- multiFunData(lapply(gfpcs, function (x) {
  funData(argvals = x$t_vec,
          X = matrix(x$Yhat$value, ncol = length(x$t_vec), byrow = TRUE))
}))

# Convert estimated eigenfunctions to funData
uniexpansions &lt;- lapply(gfpcs, function (x) {
  list(type = "given",
       functions =  funData(argvals = x$t_vec, X = t(x$efunctions)))
})

# Calculate the maximal number of MFPCs
m &lt;- sum(sapply(gfpcs, "[[", "npc"))

# Estimate the MFPCs with weights 1
mfpca &lt;- MFPCA(mFData = mfdata, M = m, uniExpansions = uniexpansions)

# Choose number of MFPCs based on threshold
nfpc &lt;- min(which(cumsum(mfpca$values) / sum(mfpca$values) &gt; 0.95))

# Attach estimated MFPCs
pbc &lt;- attach_wfpc(mfpca, pbc, n = nfpc, marker = "outcome", obstime = "year")

# Specify formula
f &lt;- list(
  gm(y, outcome) ~ year + drug + sex, # hepatomegaly
  mu2 ~ year, # platelets
  mu3 ~ year + age, # serBilir
  sigma3 ~ 1, # serBilir sd
  Lambda ~ -1 + s(id, fpc.1, bs = "pcre") +
    s(id, fpc.2, bs = "pcre") + s(id, fpc.3, bs = "pcre") +
    s(id, fpc.4, bs = "pcre")
)

b &lt;- bamlss(f,
            family = gmfamm(c("binomial", "poisson", "gaussian")),
            data = pbc)


</code></pre>

<hr>
<h2 id='gmfamm_predict'>Prediction of Generalized Multivariate Functional Additive Mixed model</h2><span id='topic+gmfamm_predict'></span>

<h3>Description</h3>

<p>Note: FPC basis has to be evaluated for newdata before the predict function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmfamm_predict(
  object,
  newdata,
  model = NULL,
  term = NULL,
  match.names = TRUE,
  intercept = TRUE,
  type = c("link", "parameter"),
  compress = TRUE,
  FUN = function(x) {
     mean(x, na.rm = TRUE)
 },
  trans = NULL,
  what = c("samples", "parameters"),
  nsamps = NULL,
  verbose = FALSE,
  drop = TRUE,
  cores = NULL,
  chunks = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gmfamm_predict_+3A_object">object</code></td>
<td>
<p>bamlss-model object to be predicted.</p>
</td></tr>
<tr><td><code id="gmfamm_predict_+3A_newdata">newdata</code></td>
<td>
<p>Dataset for which to create predictions. Not needed for
conditional survival probabilities.</p>
</td></tr>
<tr><td><code id="gmfamm_predict_+3A_model">model</code></td>
<td>
<p>Character or integer, specifies the model for which predictions should be computed.</p>
</td></tr>
<tr><td><code id="gmfamm_predict_+3A_term">term</code></td>
<td>
<p>Character or integer, specifies the model terms for which predictions are required.
Note that, e.g., <code>term = c("s(x1)", "x2")</code> will compute the combined prediction
<code>s(x1) + x2</code>.</p>
</td></tr>
<tr><td><code id="gmfamm_predict_+3A_match.names">match.names</code></td>
<td>
<p>Should partial string matching be used to select the <code>term</code>s for
prediction. Note that, e.g., <code>term = "x1"</code> will select all terms including <code>"x1"</code> if
<code>match.names = TRUE</code>.</p>
</td></tr>
<tr><td><code id="gmfamm_predict_+3A_intercept">intercept</code></td>
<td>
<p>Should the intercept be included?</p>
</td></tr>
<tr><td><code id="gmfamm_predict_+3A_type">type</code></td>
<td>
<p>Character string indicating which type of predictions to compute.
<code>link</code> returns the predictors of the corresponding model., <code>"parameter"</code> returns the estimates for all
pedictors, <code>"probabilities"</code> returns the survival probabilities
conditional on the survival up to the last longitudinal measurement, and
<code>"cumhaz"</code> return the cumulative hazard up to the survival time or for
a time window after the last longitudinal measurement. If <code>type</code> is
set to <code>"loglik"</code>, the log-likelihood of the joint model is returned.
Note that types <code>"probabilities"</code> and <code>"cumhaz"</code> are not yet
implemented.</p>
</td></tr>
<tr><td><code id="gmfamm_predict_+3A_compress">compress</code></td>
<td>
<p>TRUE if the</p>
</td></tr>
<tr><td><code id="gmfamm_predict_+3A_fun">FUN</code></td>
<td>
<p>A function that should be applied on the samples of predictors or
parameters, depending on argument <code>type</code>.</p>
</td></tr>
<tr><td><code id="gmfamm_predict_+3A_trans">trans</code></td>
<td>
<p>A transformer function or named list of transformer functions that computes
transformed predictions. If <code>trans</code> is a list, the list names must match the names
of the parameters of the <code><a href="bamlss.html#topic+bamlss.family">bamlss.family</a></code>.</p>
</td></tr>
<tr><td><code id="gmfamm_predict_+3A_what">what</code></td>
<td>
<p>Predictions can be computed from samples or estimated parameters of optimizer
functions. If no samples are available the default is to use estimated parameters.</p>
</td></tr>
<tr><td><code id="gmfamm_predict_+3A_nsamps">nsamps</code></td>
<td>
<p>If the fitted <code><a href="bamlss.html#topic+bamlss">bamlss</a></code> object contains samples of parameters,
computing predictions may take quite some time. Therefore, to get a first feeling it can
be useful to compute predictions only based on <code>nsamps</code> samples, i.e., <code>nsamps</code>
specifies the number of samples which are extracted on equidistant intervals.</p>
</td></tr>
<tr><td><code id="gmfamm_predict_+3A_verbose">verbose</code></td>
<td>
<p>Print information during runtime of the algorithm.</p>
</td></tr>
<tr><td><code id="gmfamm_predict_+3A_drop">drop</code></td>
<td>
<p>If predictions for only one <code>model</code> are returned, the list structure is dropped.</p>
</td></tr>
<tr><td><code id="gmfamm_predict_+3A_cores">cores</code></td>
<td>
<p>Specifies the number of cores that should be used for
prediction. Note that this functionality is based on the
<code><a href="parallel.html#topic+parallel">parallel</a></code> package.</p>
</td></tr>
<tr><td><code id="gmfamm_predict_+3A_chunks">chunks</code></td>
<td>
<p>Should computations be split into <code>chunks</code>? Prediction is
then processed sequentially.</p>
</td></tr>
<tr><td><code id="gmfamm_predict_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Functionality of some arguments are restricted.
</p>

<hr>
<h2 id='incorporate_outcome'>Incorporate outcome information into</h2><span id='topic+incorporate_outcome'></span>

<h3>Description</h3>

<p>This is an internal function multiplying all outcome predictions with 0 if
the respective row is not part of the outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incorporate_outcome(pred_list, mus, sigmas, outcome_ids, outcome_levels)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="incorporate_outcome_+3A_pred_list">pred_list</code></td>
<td>
<p>List of predictions for each outcome.</p>
</td></tr>
<tr><td><code id="incorporate_outcome_+3A_mus">mus</code></td>
<td>
<p>Integer vector for numbering available mus. Can be NULL but
shouldn't.</p>
</td></tr>
<tr><td><code id="incorporate_outcome_+3A_sigmas">sigmas</code></td>
<td>
<p>Integer vector for numbering available sigmas. Can be NULL.</p>
</td></tr>
<tr><td><code id="incorporate_outcome_+3A_outcome_ids">outcome_ids</code></td>
<td>
<p>Numeric matrix resulting from model.matrix call containing
the info about the outcomes. Column names are hard coded.</p>
</td></tr>
<tr><td><code id="incorporate_outcome_+3A_outcome_levels">outcome_levels</code></td>
<td>
<p>Character string containing the outcome names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List but now with 0 elements where the rows are not corresponding to
outcomes.
</p>

<hr>
<h2 id='mface_cyc'>Multilevel functional principal components analysis with fast covariance estimation</h2><span id='topic+mface_cyc'></span>

<h3>Description</h3>

<p>Decompose dense or sparse multilevel functional observations using multilevel
functional principal component analysis with the fast covariance estimation
approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mface_cyc(
  Y,
  id,
  visit = NULL,
  twoway = TRUE,
  weight = "obs",
  argvals = NULL,
  pve = 0.99,
  npc = NULL,
  p = 3,
  m = 2,
  knots = 35,
  silent = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mface_cyc_+3A_y">Y</code></td>
<td>
<p>A multilevel functional dataset on a regular grid stored in a matrix.
Each row of the data is the functional observations at one visit for one subject.
Missingness is allowed and need to be labeled as NA. The data must be specified.</p>
</td></tr>
<tr><td><code id="mface_cyc_+3A_id">id</code></td>
<td>
<p>A vector containing the id information to identify the subjects. The
data must be specified.</p>
</td></tr>
<tr><td><code id="mface_cyc_+3A_visit">visit</code></td>
<td>
<p>A vector containing information used to identify the visits.
If not provided, assume the visit id are 1,2,... for each subject.</p>
</td></tr>
<tr><td><code id="mface_cyc_+3A_twoway">twoway</code></td>
<td>
<p>Logical, indicating whether to carry out twoway ANOVA and
calculate visit-specific means. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="mface_cyc_+3A_weight">weight</code></td>
<td>
<p>The way of calculating covariance. <code>weight = "obs"</code> indicates
that the sample covariance is weighted by observations. <code>weight = "subj"</code>
indicates that the sample covariance is weighted equally by subjects. Defaults to <code>"obs"</code>.</p>
</td></tr>
<tr><td><code id="mface_cyc_+3A_argvals">argvals</code></td>
<td>
<p>A vector containing observed locations on the functional domain.</p>
</td></tr>
<tr><td><code id="mface_cyc_+3A_pve">pve</code></td>
<td>
<p>Proportion of variance explained. This value is used to choose the
number of principal components for both levels.</p>
</td></tr>
<tr><td><code id="mface_cyc_+3A_npc">npc</code></td>
<td>
<p>Pre-specified value for the number of principal components.
If given, this overrides <code>pve</code>.</p>
</td></tr>
<tr><td><code id="mface_cyc_+3A_p">p</code></td>
<td>
<p>The degree of B-splines functions to use. Defaults to 3.</p>
</td></tr>
<tr><td><code id="mface_cyc_+3A_m">m</code></td>
<td>
<p>The order of difference penalty to use. Defaults to 2.</p>
</td></tr>
<tr><td><code id="mface_cyc_+3A_knots">knots</code></td>
<td>
<p>Number of knots to use or the vectors of knots. Defaults to 35.</p>
</td></tr>
<tr><td><code id="mface_cyc_+3A_silent">silent</code></td>
<td>
<p>Logical, indicating whether to not display the name of each step.
Defaults to <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fast MFPCA approach (Cui et al., 2023) uses FACE (Xiao et al., 2016) to estimate
covariance functions and mixed model equations (MME) to predict
scores for each level. As a result, it has lower computational complexity than
MFPCA (Di et al., 2009) implemented in the <code>mfpca.sc</code> function, and
can be applied to decompose data sets with over 10000 subjects and over 10000
dimensions.
</p>
<p>This code is a direct copy of the function <code>mfpca.face</code> in the
<code>refund</code> package (version 0.1-35) and slightly adapted to allow cyclical splines in the
estimation of the eigenfunctions.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>Yhat</code></td>
<td>
<p>FPC approximation (projection onto leading components)
of <code>Y</code>, estimated curves for all subjects and visits</p>
</td></tr>
<tr><td><code>Yhat.subject</code></td>
<td>
<p>Estimated subject specific curves for all subjects</p>
</td></tr>
<tr><td><code>Y.df</code></td>
<td>
<p>The observed data</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>estimated mean function (or a vector of zeroes if <code>center==FALSE</code>).</p>
</td></tr>
<tr><td><code>eta</code></td>
<td>
<p>The estimated visit specific shifts from overall mean.</p>
</td></tr>
<tr><td><code>scores</code></td>
<td>
<p>A matrix of estimated FPC scores for level1 and level2.</p>
</td></tr>
<tr><td><code>efunctions</code></td>
<td>
<p>A matrix of estimated eigenfunctions of the functional
covariance, i.e., the FPC basis functions for levels 1 and 2.</p>
</td></tr>
<tr><td><code>evalues</code></td>
<td>
<p>Estimated eigenvalues of the covariance operator, i.e., variances
of FPC scores for levels 1 and 2.</p>
</td></tr>
<tr><td><code>pve</code></td>
<td>
<p>The percent variance explained by the returned number of PCs.</p>
</td></tr>
<tr><td><code>npc</code></td>
<td>
<p>Number of FPCs: either the supplied <code>npc</code>, or the minimum
number of basis functions needed to explain proportion <code>pve</code> of the
variance in the observed curves for levels 1 and 2.</p>
</td></tr>
<tr><td><code>sigma2</code></td>
<td>
<p>Estimated measurement error variance.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ruonan Li <a href="mailto:rli20@ncsu.edu">rli20@ncsu.edu</a>, Erjia Cui <a href="mailto:ecui@umn.edu">ecui@umn.edu</a>,
adapted by Alexander Volkmann
</p>


<h3>References</h3>

<p>Cui, E., Li, R., Crainiceanu, C., and Xiao, L. (2023). Fast multilevel
functional principal component analysis. <em>Journal of Computational and
Graphical Statistics</em>, 32(3), 366-377.
</p>
<p>Di, C., Crainiceanu, C., Caffo, B., and Punjabi, N. (2009).
Multilevel functional principal component analysis. <em>Annals of Applied
Statistics</em>, 3, 458-488.
</p>
<p>Xiao, L., Ruppert, D., Zipunnikov, V., and Crainiceanu, C. (2016).
Fast covariance estimation for high-dimensional functional data.
<em>Statistics and Computing</em>, 26, 409-421.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(refund)
data(DTI)
mfpca.DTI &lt;- mfpca.face(Y = DTI$cca, id = DTI$ID, twoway = TRUE)
</code></pre>

<hr>
<h2 id='pbc_gmfamm'>Subset of PBC data set for GMFAMM</h2><span id='topic+pbc_gmfamm'></span>

<h3>Description</h3>

<p>A subset of data from the <a href="JMbayes2.html#topic+pbc2">pbc2</a> data set which is the Mayo
Clinic Primary Biliary Cirrhosis Data, where only patients who survived at
least 10 years since they entered the study and were alive and had not had a
transplant at the end of the 10th year.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pbc_gmfamm
</code></pre>


<h3>Format</h3>

<p>## 'pbc_gmfamm'
A data frame with 5,943 rows and 10 columns:
</p>

<dl>
<dt>id</dt><dd><p>patients identifier; in the subset, there are 50 patients
included.</p>
</dd>
<dt>years</dt><dd><p>number of years in the study without event</p>
</dd>
<dt>status</dt><dd><p>a factor with levels <code>alive</code>, <code>transplanted</code>, and
<code>dead</code>.</p>
</dd>
<dt>drug</dt><dd><p>a factor with levels <code>placebo</code> and <code>D-penicilin</code>.</p>
</dd>
<dt>age</dt><dd><p>at registration in years.</p>
</dd>
<dt>sex</dt><dd><p>a factor with levels <code>male</code> and <code>female</code>.</p>
</dd>
<dt>year</dt><dd><p>number of years between enrollment and this visit date.</p>
</dd>
<dt>status2</dt><dd><p>a numeric vector with value <code>1</code> denotign if the patient
was dead, and <code>0</code> if the patient was alive or transplanted.</p>
</dd>
<dt>outcome</dt><dd><p>a factor with levels <code>albumin</code>, <code>alkaline</code>,
<code>ascites</code>, <code>edema</code>, <code>hepatomegaly</code>, <code>histologic</code>,
<code>platelets</code>, <code>prothrombin</code>, <code>serBilir</code>, <code>serChol</code>,
<code>SGOT</code>, <code>spiders</code>.</p>
</dd>
<dt>y</dt><dd><p>value of the corresponding outcome at the visit date.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Additionally, subject 124 is excluded as it has only one longitudinal
measurement per outcome. Function <a href="registr.html#topic+gfpca_twoStep">gfpca_twoStep</a>, however,
assumes at least two longitudinal observations per subject.
</p>


<h3>Source</h3>

<p><a href="JMbayes2.html#topic+pbc2">pbc2</a>
</p>


<h3>References</h3>

<p>Hall et al. (2008): Modelling sparse generalized
longitudinal observations with latent gaussian processes. Journal of the
Royal Statistical Society Series B: Statistical Methodology, 70(4), 703-723.
</p>

<hr>
<h2 id='simMuFu'>Simulate multivariate functional data</h2><span id='topic+simMuFu'></span>

<h3>Description</h3>

<p>This function provides a unified simulation structure for multivariate
functional data <code class="reqn">f_1, \ldots, f_N</code> on one- or two-dimensional domains,
based on a truncated multivariate Karhunen-Loeve representation: </p>
<p style="text-align: center;"><code class="reqn">f_i(t)
= \sum_{m = 1}^M \rho_{i,m} \psi_m(t).</code>
</p>
<p> The multivariate eigenfunctions
(basis functions) <code class="reqn">\psi_m</code>  are constructed from univariate orthonormal
bases. There are two different concepts for the construction, that can be
chosen by the parameter <code>type</code>: A split orthonormal basis (<code>split</code>,
only one-dimensional domains) and weighted univariate orthonormal bases
(<code>weighted</code>, one- and two-dimensional domains). The scores
<code class="reqn">\rho_{i,m}</code> in the Karhunen-Loeve representation are simulated
independently from a normal distribution with zero mean and decreasing
variance. See Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simMuFu(
  type,
  argvals,
  M,
  eFunType,
  ignoreDeg = NULL,
  eValType,
  N,
  seed,
  seed_funs = 8
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simMuFu_+3A_type">type</code></td>
<td>
<p>A character string, specifying the construction method for the
multivariate eigenfunctions (either <code>"split"</code> or <code>"weighted"</code>).
See Details.</p>
</td></tr>
<tr><td><code id="simMuFu_+3A_argvals">argvals</code></td>
<td>
<p>A list, containing the observation points for each element of
the multivariate functional data that is to be simulated. The length of
<code>argvals</code> determines the number of elements in the resulting simulated
multivariate functional data. See Details.</p>
</td></tr>
<tr><td><code id="simMuFu_+3A_m">M</code></td>
<td>
<p>An integer (<code>type = "split"</code>) or a list of integers (<code>type
= "weighted"</code>), giving the number of univariate basis functions to use. See
Details.</p>
</td></tr>
<tr><td><code id="simMuFu_+3A_efuntype">eFunType</code></td>
<td>
<p>A character string (<code>type = "split"</code>)   or a list of
character strings (<code>type = "weighted"</code>), specifying the type of
univariate orthonormal basis functions to use. See Details.</p>
</td></tr>
<tr><td><code id="simMuFu_+3A_ignoredeg">ignoreDeg</code></td>
<td>
<p>A vector of integers (<code>type = "split"</code>)   or a list of
integer vectors (<code>type = "weighted"</code>), specifying the degrees to
ignore when generating the univariate orthonormal bases. Defaults to
<code>NULL</code>. See Details.</p>
</td></tr>
<tr><td><code id="simMuFu_+3A_evaltype">eValType</code></td>
<td>
<p>A character string, specifying the type of
eigenvalues/variances used for the simulation of the multivariate functions
based on the truncated Karhunen-Loeve representation. See
<code>eVal</code> for details.</p>
</td></tr>
<tr><td><code id="simMuFu_+3A_n">N</code></td>
<td>
<p>An integer, specifying the number of multivariate functions to be
generated.</p>
</td></tr>
<tr><td><code id="simMuFu_+3A_seed">seed</code></td>
<td>
<p>A random seed for the score generation.</p>
</td></tr>
<tr><td><code id="simMuFu_+3A_seed_funs">seed_funs</code></td>
<td>
<p>A random seed to make the eigenfunction creation
reproducible.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>type</code> defines how the eigenfunction basis for the
multivariate Karhunen-Loeve representation is constructed: </p>
 <ul>
<li>
<p><code>type = "split"</code>: The basis functions of an underlying 'big' orthonormal
basis are split in <code>M</code> parts, translated and possibly reflected. This
yields an orthonormal basis of multivariate functions with <code>M</code>
elements. This option is implemented only for one-dimensional domains. </p>
</li>
<li>
<p><code>type = "weighted":</code> The multivariate eigenfunction basis consists of
weighted univariate orthonormal bases.  This yields an orthonormal basis of
multivariate functions with <code>M</code> elements. For data on two-dimensional
domains (images), the univariate basis is constructed as a tensor product of
univariate bases in each direction (x- and y-direction). </p>
</li></ul>

<p>Depending on <code>type</code>, the other parameters have to be specified as
follows: </p>


<h4>Split 'big' orthonormal basis</h4>

<p> The parameters <code>M</code>
(integer), <code>eFunType</code> (character string) and <code>ignoreDeg</code> (integer
vector or <code>NULL</code>) are passed to the function <code>eFun</code> to
generate a univariate orthonormal basis on a 'big' interval. Subsequently,
the basis functions are split and translated, such that the <code class="reqn">j</code>-th part
of the split function is defined on the interval corresponding to
<code>argvals[[j]]</code>. The elements of the multivariate basis functions are
given by these split parts of the original basis functions multiplied by a
random sign <code class="reqn">\sigma_j \in \{-1,1\}, j = 1, \ldots, p</code>.</p>



<h4>Weighted orthonormal bases</h4>

<p> The parameters <code>argvals, M,
eFunType</code> and <code>ignoreDeg</code> are all lists of a similar structure. They are
passed element-wise to the function <code>eFun</code> to generate
orthonormal basis functions for each element of the multivariate functional
data to be simulated. In case of bivariate elements (images), the
corresponding basis functions are constructed as tensor products of
orthonormal basis functions in each direction (x- and y-direction).
</p>
<p>If the <code class="reqn">j</code>-th element of the simulated data should be defined on a
one-dimensional domain, then </p>
 <ul>
<li> <p><code>argvals[[j]]</code> is a list,
containing one vector of observation points. </p>
</li>
<li> <p><code>M[[j]]</code> is an
integer, specifying the number of basis functions to use for this entry.
</p>
</li>
<li>  <p><code>eFunType[[j]]</code> is a character string, specifying the type of
orthonormal basis functions to use for this entry (see <code>eFun</code> for
possible options). </p>
</li>
<li> <p><code>ignoreDeg[[j]]</code> is a vector of integers,
specifying the degrees to ignore when constructing the orthonormal basis
functions. The default value is <code>NULL</code>. </p>
</li></ul>

<p>If the <code class="reqn">j</code>-th element of the simulated data should be defined on a
two-dimensional domain, then </p>
 <ul>
<li> <p><code>argvals[[j]]</code> is a list,
containing two vectors of observation points, one for each direction
(observation points in x-direction and in y-direction). </p>
</li>
<li> <p><code>M[[j]]</code>
is a vector of two integers, giving the number of basis functions for each
direction (x- and y-direction). </p>
</li>
<li> <p><code>eFunType[[j]]</code> is a vector of two
character strings, giving the type of orthonormal basis functions for each
direction (x- and y-direction, see <code>eFun</code> for possible options).
The corresponding basis functions are constructed as tensor products of
orthonormal basis functions in each direction. </p>
</li>
<li> <p><code>ignoreDeg[[j]]</code> is
a list, containing two integer vectors that specify the degrees to ignore
when constructing the orthonormal basis functions in each direction. The
default value is <code>NULL</code>. </p>
</li></ul>
<p> The total number of basis functions (i.e. the
product of <code>M[[j]]</code> for all <code>j</code>) must be equal!</p>

<p>This code is a direct copy of the function <code>simMultiFunData</code> in the
<code>funData</code> package (version 1.3-9) and slightly adapted. It also returns
the simulated scores and needs the additional argument <code>seed</code> to
generate reproducible eigenvalues and eigenfunctions.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>simData</code></td>
<td>
<p>A <code>multiFunData</code> object with
<code>N</code> observations, representing the simulated multivariate functional
data.</p>
</td></tr> <tr><td><code>trueFuns</code></td>
<td>
<p>A <code>multiFunData</code> object with
<code>M</code> observations, representing the multivariate eigenfunction basis
used for simulating the data.</p>
</td></tr> <tr><td><code>trueVals</code></td>
<td>
<p>A vector of numerics,
representing the eigenvalues used for simulating the data.</p>
</td></tr> <tr><td><code>score</code></td>
<td>
<p>A
matrix containing the simulated scores.</p>
</td></tr>
</table>


<h3>References</h3>

<p>C. Happ, S. Greven (2018): Multivariate Functional Principal
Component Analysis for Data Observed on Different (Dimensional) Domains.
Journal of the American Statistical Association, 113(522): 649-659.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oldPar &lt;- par(no.readonly = TRUE)
library(funData)

# split
split &lt;- simMuFu(type = "split", argvals = list(seq(0,1,0.01),
                                                seq(-0.5,0.5,0.02)),
                 M = 5, eFunType = "Poly", eValType = "linear", N = 7,
                 seed = 2)

par(mfrow = c(1,2))
plot(split$trueFuns, main = "Split: True Eigenfunctions", ylim = c(-2,2))
plot(split$simData, main = "Split: Simulated Data")

# weighted (one-dimensional domains)

par(oldPar)

</code></pre>

<hr>
<h2 id='trafficfam'>Draft of family for traffic example</h2><span id='topic+trafficfam'></span>

<h3>Description</h3>

<p>Fix four distributional assumptions and supply derivatives. Use BCCGo for
speed data. Use negative binomial for count data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trafficfam(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trafficfam_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bamlss family object.
</p>

<hr>
<h2 id='trafficfam2'>Draft 2 of family for traffic example</h2><span id='topic+trafficfam2'></span>

<h3>Description</h3>

<p>Fix four distributional assumptions and supply derivatives. Use BCCGo for
speed data. Use zero-truncated negative binomial for count data (no second
derivatives available).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trafficfam2(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trafficfam2_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bamlss family object.
</p>

<hr>
<h2 id='trafficfam3'>Draft of family for traffic example</h2><span id='topic+trafficfam3'></span>

<h3>Description</h3>

<p>Fix four distributional assumptions and supply derivatives. Use gamma for
speed data. Use negative binomial for count data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trafficfam3(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trafficfam3_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bamlss family object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Construct data
set.seed(123)
# Number of subjects
n &lt;- 10

# Number of observations
ni &lt;- 3

# Covariate vector
x &lt;- rep(rnorm(n), each = ni)
t &lt;- rep(c(0, 0.5, 1), times = n)

# Additive predictor
eta_1 &lt;- eta_2 &lt;- eta_3 &lt;- eta_4 &lt;- t + 0.5*x

# Outcomes
y1 &lt;- rnbinom(n*ni, exp(eta_1), 0.3)
y2 &lt;- rnbinom(n*ni, exp(eta_2), 0.4)
y3 &lt;- rgamma(n*ni, shape = 0.3, scale = exp(eta_3) / 0.3)
y4 &lt;- rgamma(n*ni, shape = 0.4, scale = exp(eta_4) / 0.4)

# Data format
dat &lt;- data.frame(
   id = factor(rep(seq_len(n), each = ni)),
   y = c(y1, y2, y3, y4),
   dim = factor(rep(c(1:4), each = n*ni)),
   t = t,
   x = x,
   fpc = 1
)

# Specify formula
f &lt;- list(
  gm(y, dim) ~ t + x,
  sigma1 ~ 1,
  mu2 ~ t + x,
  sigma2 ~ 1,
  mu3 ~ t + x,
  sigma3 ~ 1,
  mu4 ~ t + x,
  sigma4 ~ 1,
  Lambda ~ -1 + s(id, by = fpc, bs = "re")
)

# Model
b &lt;- bamlss(f, family = trafficfam3, n.iter = 20, burnin = 10,
            data = dat)
</code></pre>

<hr>
<h2 id='trafficfam4'>Draft of family for traffic example</h2><span id='topic+trafficfam4'></span>

<h3>Description</h3>

<p>Fix four distributional assumptions and supply derivatives. Use lognormal for
speed data. Use Poisson for count data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trafficfam4(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trafficfam4_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bamlss family object.
</p>

<hr>
<h2 id='varbinq'>Generalized Multivariate Functional Additive Models</h2><span id='topic+varbinq'></span>

<h3>Description</h3>

<p>This package does things.
_PACKAGE
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
