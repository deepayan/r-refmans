<!DOCTYPE html><html><head><title>Help for package adnuts</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adnuts}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.check_ADMB_version'><p>Check that the  model is compiled with the right version</p>
of ADMB which is 12.0 or later</a></li>
<li><a href='#.check_console_printing'><p>Check if the session is interactive or Rstudio which has</p>
implications for parallel output</a></li>
<li><a href='#.check_model_path'><p>Check that the file can be found</p></a></li>
<li><a href='#.getADMBHessian'><p>Read in admodel.hes file</p></a></li>
<li><a href='#.sample_admb'><p>Hidden wrapper function for sampling from ADMB models</p></a></li>
<li><a href='#.update_model'><p>Convert model name depending on system</p></a></li>
<li><a href='#adfit'><p>Constructor for the &quot;adfit&quot; (A-D fit) class</p></a></li>
<li><a href='#adnuts'><p>adnuts: No-U-turn sampling for AD Model Builder (ADMB)</p></a></li>
<li><a href='#as.data.frame.adfit'><p>Convert object of class adfit to data.frame. Calls</p>
<code>extract_samples</code></a></li>
<li><a href='#check_identifiable'><p>Check identifiability from model Hessian</p></a></li>
<li><a href='#extract_sampler_params'><p>Extract sampler parameters from a fit.</p></a></li>
<li><a href='#extract_samples'><p>Extract posterior samples from a model fit.</p></a></li>
<li><a href='#is.adfit'><p>Check object of class adfit</p></a></li>
<li><a href='#launch_shinyadmb'><p>Launch shinystan for an ADMB fit.</p></a></li>
<li><a href='#launch_shinytmb'><p>Launch shinystan for a TMB fit.</p></a></li>
<li><a href='#pairs_admb'><p>Plot pairwise parameter posteriors and optionally the MLE points and</p>
confidence ellipses.</a></li>
<li><a href='#plot_marginals'><p>Plot marginal distributions for a fitted model</p></a></li>
<li><a href='#plot_sampler_params'><p>Plot adaptation metrics for a fitted model.</p></a></li>
<li><a href='#plot_uncertainties'><p>Plot MLE vs MCMC marginal standard deviations for each</p>
parameter</a></li>
<li><a href='#plot.adfit'><p>Plot object of class adfit</p></a></li>
<li><a href='#print.adfit'><p>Print summary of adfit object</p></a></li>
<li><a href='#sample_admb'><p>Deprecated version of wrapper function. Use sample_nuts or</p>
sample_rwm instead.</a></li>
<li><a href='#sample_inits'><p>Function to generate random initial values from a previous fit using</p>
adnuts</a></li>
<li><a href='#sample_nuts'><p>Bayesian inference of an ADMB model using the no-U-turn</p>
sampler (NUTS) or random walk Metropolis (RWM) algorithms.</a></li>
<li><a href='#sample_tmb'><p>Bayesian inference of a TMB model using the no-U-turn sampler.</p></a></li>
<li><a href='#sample_tmb_hmc'><p>Draw MCMC samples from a model posterior using a static HMC sampler.</p></a></li>
<li><a href='#sample_tmb_nuts'><p>Draw MCMC samples from a model posterior using the No-U-Turn (NUTS)</p>
sampler with dual averaging.</a></li>
<li><a href='#sample_tmb_rwm'><p>[Deprecated] Draw MCMC samples from a model posterior using a</p>
Random Walk Metropolis (RWM) sampler.</a></li>
<li><a href='#summary.adfit'><p>Print summary of object of class adfit</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>No-U-Turn MCMC Sampling for 'ADMB' Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Bayesian inference using the no-U-turn (NUTS) algorithm by 
 Hoffman and Gelman (2014) <a href="https://www.jmlr.org/papers/v15/hoffman14a.html">https://www.jmlr.org/papers/v15/hoffman14a.html</a>. 
 Designed for 'AD Model Builder' ('ADMB') models,
 or when R functions for log-density and log-density gradient
 are available, such as 'Template Model Builder'
 models and other special cases. Functionality is similar to 'Stan', 
 and the 'rstan' and 'shinystan' packages are used for diagnostics and 
 inference.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), snowfall (&ge; 1.84.6.1)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/Cole-Monnahan-NOAA/adnuts">https://github.com/Cole-Monnahan-NOAA/adnuts</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/Cole-Monnahan-NOAA/adnuts/issues">https://github.com/Cole-Monnahan-NOAA/adnuts/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>shinystan (&ge; 2.5.0), matrixcalc (&ge; 1.0.3), stats, knitr,
TMB, rmarkdown, withr, testthat (&ge; 2.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ellipse, rstan, R2admb, ggplot2, rlang</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-02 19:04:08 UTC; cole.monnahan</td>
</tr>
<tr>
<td>Author:</td>
<td>Cole Monnahan <a href="https://orcid.org/0000-0003-0871-6700"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cole Monnahan &lt;monnahc@uw.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-02 19:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='.check_ADMB_version'>Check that the  model is compiled with the right version
of ADMB which is 12.0 or later</h2><span id='topic+.check_ADMB_version'></span>

<h3>Description</h3>

<p>Check that the  model is compiled with the right version
of ADMB which is 12.0 or later
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_ADMB_version(model, path = getwd(), min.version = 12, warn = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".check_ADMB_version_+3A_model">model</code></td>
<td>
<p>Model name without file extension</p>
</td></tr>
<tr><td><code id=".check_ADMB_version_+3A_path">path</code></td>
<td>
<p>Path to model folder, defaults to working
directory. NULL value specifies working directory (default).</p>
</td></tr>
<tr><td><code id=".check_ADMB_version_+3A_min.version">min.version</code></td>
<td>
<p>Minimum valid version (numeric). Defaults
to 12.0.</p>
</td></tr>
<tr><td><code id=".check_ADMB_version_+3A_warn">warn</code></td>
<td>
<p>Boolean whether to throw warnings or not</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Some functionality of packages <span class="pkg">adnuts</span> is
imbedded in the ADMB source code so that when a model is
compiled it is contained in the model executable. If this
code does not exist adnuts will fail. The solution is to
update ADMB and recompile the model.
</p>


<h3>Value</h3>

<p>Nothing, errors out if either model could not be run
or the version is incompatible. If compatible nothing
happens.
</p>

<hr>
<h2 id='.check_console_printing'>Check if the session is interactive or Rstudio which has
implications for parallel output</h2><span id='topic+.check_console_printing'></span>

<h3>Description</h3>

<p>Check if the session is interactive or Rstudio which has
implications for parallel output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_console_printing(parallel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".check_console_printing_+3A_parallel">parallel</code></td>
<td>
<p>Boolean whether chain is executed in parallel
mode or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When using RStudio and RGui, the parallel output does
not show on the console. As a workaround it is captured in
each cluster into a file and then read in and printed.
</p>


<h3>Value</h3>

<p>Boolean whether output should be printed to console
progressively, or saved to file and printed at the end.
</p>

<hr>
<h2 id='.check_model_path'>Check that the file can be found</h2><span id='topic+.check_model_path'></span>

<h3>Description</h3>

<p>Check that the file can be found
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.check_model_path(model, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".check_model_path_+3A_model">model</code></td>
<td>
<p>Model name without file extension</p>
</td></tr>
<tr><td><code id=".check_model_path_+3A_path">path</code></td>
<td>
<p>Path to model folder, defaults to working</p>
</td></tr>
</table>

<hr>
<h2 id='.getADMBHessian'>Read in admodel.hes file</h2><span id='topic+.getADMBHessian'></span>

<h3>Description</h3>

<p>Read in admodel.hes file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getADMBHessian(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".getADMBHessian_+3A_path">path</code></td>
<td>
<p>Path to folder containing the admodel.hes file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Hessian matrix
</p>

<hr>
<h2 id='.sample_admb'>Hidden wrapper function for sampling from ADMB models</h2><span id='topic+.sample_admb'></span>

<h3>Description</h3>

<p>Hidden wrapper function for sampling from ADMB models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sample_admb(
  model,
  path = getwd(),
  iter = 2000,
  init = NULL,
  chains = 3,
  warmup = NULL,
  seeds = NULL,
  thin = 1,
  mceval = FALSE,
  duration = NULL,
  cores = NULL,
  control = NULL,
  verbose = TRUE,
  algorithm = "NUTS",
  skip_optimization = TRUE,
  skip_monitor = FALSE,
  skip_unbounded = TRUE,
  admb_args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sample_admb_+3A_model">model</code></td>
<td>
<p>Name of model (i.e., 'model' for model.tpl). For
non-Windows systems this will automatically be converted to
'./model' internally. For Windows, long file names are
sometimes shortened from e.g., 'long_model_filename' to
'LONG_~1'. This should work, but will throw warnings. Please
shorten the model name. See
https://en.wikipedia.org/wiki/8.3_filename.</p>
</td></tr>
<tr><td><code id=".sample_admb_+3A_path">path</code></td>
<td>
<p>Path to model executable. Defaults to working
directory. Often best to have model files in a separate
subdirectory, particularly for parallel.</p>
</td></tr>
<tr><td><code id=".sample_admb_+3A_iter">iter</code></td>
<td>
<p>The number of samples to draw.</p>
</td></tr>
<tr><td><code id=".sample_admb_+3A_init">init</code></td>
<td>
<p>A list of lists containing the initial parameter
vectors, one for each chain or a function. It is strongly
recommended to initialize multiple chains from dispersed
points. A of NULL signifies to use the starting values
present in the model (i.e., <code>obj$par</code>) for all chains.</p>
</td></tr>
<tr><td><code id=".sample_admb_+3A_chains">chains</code></td>
<td>
<p>The number of chains to run.</p>
</td></tr>
<tr><td><code id=".sample_admb_+3A_warmup">warmup</code></td>
<td>
<p>The number of warmup iterations.</p>
</td></tr>
<tr><td><code id=".sample_admb_+3A_seeds">seeds</code></td>
<td>
<p>A vector of seeds, one for each chain.</p>
</td></tr>
<tr><td><code id=".sample_admb_+3A_thin">thin</code></td>
<td>
<p>The thinning rate to apply to samples. Typically
not used with NUTS.</p>
</td></tr>
<tr><td><code id=".sample_admb_+3A_mceval">mceval</code></td>
<td>
<p>Whether to run the model with <code>-mceval</code> on
samples from merged chains.</p>
</td></tr>
<tr><td><code id=".sample_admb_+3A_duration">duration</code></td>
<td>
<p>The number of minutes after which the model
will quit running.</p>
</td></tr>
<tr><td><code id=".sample_admb_+3A_cores">cores</code></td>
<td>
<p>The number of cores to use for parallel
execution. Default is number available in the system minus
1. If <code>cores=1</code>, serial execution occurs (even if
<code>chains&gt;1</code>), otherwise parallel execution via package
snowfall is used. For slow analyses it is recommended to set
<code>chains</code>&lt;=<code>cores</code> so each core needs to run only a
single chain.</p>
</td></tr>
<tr><td><code id=".sample_admb_+3A_control">control</code></td>
<td>
<p>A list to control the sampler. See details for
further use.</p>
</td></tr>
<tr><td><code id=".sample_admb_+3A_verbose">verbose</code></td>
<td>
<p>Flag whether to show console output (default)
or suppress it completely except for warnings and
errors. Works for serial or parallel execution.</p>
</td></tr>
<tr><td><code id=".sample_admb_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm to use, one of &quot;NUTS&quot; or &quot;RWM&quot;</p>
</td></tr>
<tr><td><code id=".sample_admb_+3A_skip_optimization">skip_optimization</code></td>
<td>
<p>Whether to run the optimizer before
running MCMC. This is rarely need as it is better to run it
once before to get the covariance matrix, or the estimates
are not needed with adaptive NUTS.</p>
</td></tr>
<tr><td><code id=".sample_admb_+3A_skip_monitor">skip_monitor</code></td>
<td>
<p>Whether to skip calculating diagnostics
(effective sample size, Rhat) via the <code>rstan::monitor</code>
function. This can be slow for models with high dimension or
many iterations. The result is used in plots and summaries
so it is recommended to turn on. If model run with
<code>skip_monitor=FALSE</code> you can recreate it post-hoc by
setting <code>fit$monitor=rstan::monitor(fit$samples,
fit$warmup, print=FALSE)</code>.</p>
</td></tr>
<tr><td><code id=".sample_admb_+3A_skip_unbounded">skip_unbounded</code></td>
<td>
<p>Whether to skip returning the unbounded
version of the posterior samples in addition to the bounded
ones. It may be advisable to set to FALSE for very large
models to save space.</p>
</td></tr>
<tr><td><code id=".sample_admb_+3A_admb_args">admb_args</code></td>
<td>
<p>A character string which gets passed to the
command line, allowing finer control</p>
</td></tr>
</table>

<hr>
<h2 id='.update_model'>Convert model name depending on system</h2><span id='topic+.update_model'></span>

<h3>Description</h3>

<p>Convert model name depending on system
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.update_model(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".update_model_+3A_model">model</code></td>
<td>
<p>Model name without file extension</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated model name to use with system call
</p>

<hr>
<h2 id='adfit'>Constructor for the &quot;adfit&quot; (A-D fit) class</h2><span id='topic+adfit'></span>

<h3>Description</h3>

<p>Constructor for the &quot;adfit&quot; (A-D fit) class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adfit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adfit_+3A_x">x</code></td>
<td>
<p>Fitted object from <code><a href="#topic+sample_admb">sample_admb</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class &quot;adfit&quot;
</p>

<hr>
<h2 id='adnuts'>adnuts: No-U-turn sampling for AD Model Builder (ADMB)</h2><span id='topic+adnuts'></span>

<h3>Description</h3>

<p>Draw Bayesian posterior samples from an ADMB model using the
no-U-turn MCMC sampler. Adaptation schemes are used so specifying tuning
parameters is not necessary, and parallel execution reduces overall run
time.
</p>


<h3>Details</h3>

<p>The software package Stan pioneered the use of no-U-turn (NUTS) sampling
for Bayesian models (Hoffman and Gelman 2014, Carpenter et
al. 2017). This algorithm provides fast, efficient sampling across a
wide range of models, including hierarchical ones, and thus can be used
as a generic modeling tool (Monnahan et al. 2017). The functionality
provided by <span class="pkg">adnuts</span> is based loosely off Stan and <span class="rlang"><b>R</b></span> package
<span class="pkg">rstan</span>
</p>
<p>The <span class="pkg">adnuts</span> <span class="rlang"><b>R</b></span> package provides an <span class="rlang"><b>R</b></span> workflow for NUTS
sampling for ADMB models (Fournier et al. 2011), including
adaptation of step size and metric (mass matrix), parallel
execution, and links to diagnostic and inference tools
provided by <span class="pkg">rstan</span> and <span class="pkg">shinystan</span>.  The ADMB
implementation of NUTS code is bundled into the ADMB source
itself (as of version 12.0). Thus, when a user builds an
ADMB model the NUTS code is incorporated into the model
executable. Thus, <span class="pkg">adnuts</span> simply provides a convenient
set of wrappers to more easily execute, diagnose, and make
inference on a model. More details can be found in the
package vignette.
</p>
<p>Note that previous versions of <span class="pkg">adnuts</span> included
functionality for TMB models, but this has been replaced by
<span class="pkg">tmbstan</span> (Kristensen et al. 2016, Monnahan and
Kristensen 2018).
</p>


<h3>References</h3>

<p>Carpenter, B., Gelman, A., Hoffman, M.D., Lee, D., Goodrich, B.,
Betancourt, M., Riddell, A., Guo, J.Q., Li, P., Riddell, A.,
2017. Stan: A Probabilistic Programming Language.  J Stat
Softw. 76:1-29.
</p>
<p>Fournier, D.A., Skaug, H.J., Ancheta, J., Ianelli, J., Magnusson, A.,
Maunder, M.N., Nielsen, A., Sibert, J., 2012. AD Model Builder: using
automatic differentiation for statistical inference of highly
parameterized complex nonlinear models.  Optim Method
Softw. 27:233-249.
</p>
<p>Hoffman, M.D., Gelman, A., 2014. The no-U-turn sampler: adaptively
setting path lengths in Hamiltonian Monte Carlo.  J Mach Learn
Res. 15:1593-1623.
</p>
<p>Kristensen, K., Nielsen, A., Berg, C.W., Skaug, H., Bell, B.M.,
2016. TMB: Automatic differentiation and Laplace approximation.  J
Stat Softw. 70:21.
</p>
<p>Kristensen, K., 2017. TMB: General random effect model builder tool
inspired by ADMB. R package version 1.7.11.
</p>
<p>Monnahan, C.C., Thorson, J.T., Branch, T.A., 2017. Faster estimation of
Bayesian models in ecology using Hamiltonian Monte Carlo.  Methods in
Ecology and Evolution. 8:339-348.
</p>
<p>Monnahan C.C., Kristensen K. (2018). No-U-turn sampling for fast
Bayesian inference in ADMB and TMB: Introducing the adnuts and
tmbstan R packages PLoS ONE 13(5): e0197954.
https://doi.org/10.1371/journal.pone.0197954
</p>
<p>Stan Development Team, 2016. Stan modeling language users guide and
reference manual, version 2.11.0.
</p>
<p>Stan Development Team, 2016. RStan: The R interface to Stan. R package
version 2.14.1. http://mc-stan.org.
</p>

<hr>
<h2 id='as.data.frame.adfit'>Convert object of class adfit to data.frame. Calls
<code><a href="#topic+extract_samples">extract_samples</a></code></h2><span id='topic+as.data.frame.adfit'></span>

<h3>Description</h3>

<p>Convert object of class adfit to data.frame. Calls
<code><a href="#topic+extract_samples">extract_samples</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adfit'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.adfit_+3A_x">x</code></td>
<td>
<p>Fitted object from <code><a href="#topic+sample_rwm">sample_rwm</a></code></p>
</td></tr>
<tr><td><code id="as.data.frame.adfit_+3A_row.names">row.names</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="as.data.frame.adfit_+3A_optional">optional</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="as.data.frame.adfit_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This calls the default settings of
<code><a href="#topic+extract_samples">extract_samples</a></code>, no warmup samples and no
column for the log-posterior (lp__). Use this function
directly for finer control.
</p>


<h3>Value</h3>

<p>A data frame with parameters as columns and samples as
rows.
</p>

<hr>
<h2 id='check_identifiable'>Check identifiability from model Hessian</h2><span id='topic+check_identifiable'></span>

<h3>Description</h3>

<p>Check identifiability from model Hessian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_identifiable(model, path = getwd())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_identifiable_+3A_model">model</code></td>
<td>
<p>Model name without file extension</p>
</td></tr>
<tr><td><code id="check_identifiable_+3A_path">path</code></td>
<td>
<p>Path to model folder, defaults to working directory</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Read in the admodel.hes file and check the eigenvalues to
determine which parameters are not identifiable and thus cause the
Hessian to be non-invertible. Use this to identify which parameters
are problematic. This function was converted from a version in the
<code>FishStatsUtils</code> package.
</p>


<h3>Value</h3>

<p>Prints output of bad parameters and invisibly returns it.
</p>

<hr>
<h2 id='extract_sampler_params'>Extract sampler parameters from a fit.</h2><span id='topic+extract_sampler_params'></span>

<h3>Description</h3>

<p>Extract information about NUTS trajectories, such as acceptance ratio
and treedepth, from a fitted object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_sampler_params(fit, inc_warmup = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_sampler_params_+3A_fit">fit</code></td>
<td>
<p>A list returned by <code>sample_admb</code>.</p>
</td></tr>
<tr><td><code id="extract_sampler_params_+3A_inc_warmup">inc_warmup</code></td>
<td>
<p>Whether to extract the warmup samples or not
(default). Warmup samples should never be used for inference, but may
be useful for diagnostics.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each trajectory (iteration) in NUTS has associated information
about the trajectory: stepsize, acceptance ratio, treedepth, and number of
leapfrog steps. This function extracts these into a data.frame, which
may be useful for diagnosing issues in certain cases. In general, the
user should not need to examine them, or preferably should via
<code><a href="#topic+plot_sampler_params">plot_sampler_params</a></code> or  <code><a href="#topic+launch_shinyadmb">launch_shinyadmb</a></code>.
</p>


<h3>Value</h3>

<p>An invisible data.frame containing samples (rows) of each
parameter (columns). If multiple chains exist they will be rbinded
together.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+launch_shinyadmb">launch_shinyadmb</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- readRDS(system.file('examples', 'fit.RDS', package='adnuts'))
sp &lt;- extract_sampler_params(fit, inc_warmup=TRUE)
str(sp)

</code></pre>

<hr>
<h2 id='extract_samples'>Extract posterior samples from a model fit.</h2><span id='topic+extract_samples'></span>

<h3>Description</h3>

<p>A helper function to extract posterior samples across multiple chains
into a single data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_samples(
  fit,
  inc_warmup = FALSE,
  inc_lp = FALSE,
  as.list = FALSE,
  unbounded = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_samples_+3A_fit">fit</code></td>
<td>
<p>A list returned by <code>sample_admb</code>.</p>
</td></tr>
<tr><td><code id="extract_samples_+3A_inc_warmup">inc_warmup</code></td>
<td>
<p>Whether to extract the warmup samples or not
(default). Warmup samples should never be used for inference, but may
be useful for diagnostics.</p>
</td></tr>
<tr><td><code id="extract_samples_+3A_inc_lp">inc_lp</code></td>
<td>
<p>Whether to include a column for the log posterior density
(last column). For diagnostics it can be useful.</p>
</td></tr>
<tr><td><code id="extract_samples_+3A_as.list">as.list</code></td>
<td>
<p>Whether to return the samples as a list (one element per
chain). This could then be converted to a CODA mcmc object.</p>
</td></tr>
<tr><td><code id="extract_samples_+3A_unbounded">unbounded</code></td>
<td>
<p>Boolean flag whether to return samples in
unbounded (untransformed) space. Will only be differences
when init_bounded types are used in the ADMB template. This
can be useful for model debugging.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is loosely based on the <span class="pkg">rstan</span> function
<code>extract</code>. Merging samples across chains should only be used for
inference after appropriate diagnostic checks. Do not calculate
diagnostics like Rhat or effective sample size after using this
function, instead, use <code><a href="rstan.html#topic+monitor">monitor</a></code>. Likewise, warmup
samples are not valid and should never be used for inference, but may
be useful in some cases for diagnosing issues.
</p>


<h3>Value</h3>

<p>If as.list is FALSE, an invisible data.frame containing samples
(rows) of each parameter (columns). If multiple chains exist they will
be rbinded together, maintaining order within each chain. If as.list
is TRUE, samples are returned as a list of matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A previously run fitted ADMB model
fit &lt;- readRDS(system.file('examples', 'fit.RDS', package='adnuts'))
post &lt;- extract_samples(fit)
tail(apply(post, 2, median))
</code></pre>

<hr>
<h2 id='is.adfit'>Check object of class adfit</h2><span id='topic+is.adfit'></span>

<h3>Description</h3>

<p>Check object of class adfit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.adfit(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.adfit_+3A_x">x</code></td>
<td>
<p>Returned list from <code><a href="#topic+sample_admb">sample_admb</a></code></p>
</td></tr>
</table>

<hr>
<h2 id='launch_shinyadmb'>Launch shinystan for an ADMB fit.</h2><span id='topic+launch_shinyadmb'></span>

<h3>Description</h3>

<p>Launch shinystan for an ADMB fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>launch_shinyadmb(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="launch_shinyadmb_+3A_fit">fit</code></td>
<td>
<p>A named list returned by <code>sample_admb</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>launch_shinytmb</code>
</p>

<hr>
<h2 id='launch_shinytmb'>Launch shinystan for a TMB fit.</h2><span id='topic+launch_shinytmb'></span>

<h3>Description</h3>

<p>Launch shinystan for a TMB fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>launch_shinytmb(fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="launch_shinytmb_+3A_fit">fit</code></td>
<td>
<p>A named list returned by <code>sample_tmb</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>launch_shinyadmb</code>
</p>

<hr>
<h2 id='pairs_admb'>Plot pairwise parameter posteriors and optionally the MLE points and
confidence ellipses.</h2><span id='topic+pairs_admb'></span>

<h3>Description</h3>

<p>Plot pairwise parameter posteriors and optionally the MLE points and
confidence ellipses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pairs_admb(
  fit,
  order = NULL,
  diag = c("trace", "acf", "hist"),
  acf.ylim = c(-1, 1),
  ymult = NULL,
  axis.col = gray(0.5),
  pars = NULL,
  label.cex = 0.8,
  limits = NULL,
  add.mle = TRUE,
  add.monitor = TRUE,
  unbounded = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pairs_admb_+3A_fit">fit</code></td>
<td>
<p>A list as returned by <code>sample_admb</code>.</p>
</td></tr>
<tr><td><code id="pairs_admb_+3A_order">order</code></td>
<td>
<p>The order to consider the parameters. Options are
NULL (default) to use the order declared in the model, or
'slow' and 'fast' which are based on the effective sample
sizes ordered by slowest or fastest mixing respectively. See
example for usage.</p>
</td></tr>
<tr><td><code id="pairs_admb_+3A_diag">diag</code></td>
<td>
<p>What type of plot to include on the diagonal,
options are 'acf' which plots the autocorrelation function
<code>acf</code>, 'hist' shows marginal posterior histograms, and
'trace' the trace plot.</p>
</td></tr>
<tr><td><code id="pairs_admb_+3A_acf.ylim">acf.ylim</code></td>
<td>
<p>If using the acf function on the diagonal,
specify the y limit. The default is c(-1,1).</p>
</td></tr>
<tr><td><code id="pairs_admb_+3A_ymult">ymult</code></td>
<td>
<p>A vector of length ncol(posterior) specifying how
much room to give when using the hist option for the
diagonal. For use if the label is blocking part of the
plot. The default is 1.3 for all parameters.</p>
</td></tr>
<tr><td><code id="pairs_admb_+3A_axis.col">axis.col</code></td>
<td>
<p>Color of axes</p>
</td></tr>
<tr><td><code id="pairs_admb_+3A_pars">pars</code></td>
<td>
<p>A vector of parameter names or integers
representing which parameters to subset. Useful if the model
has a larger number of parameters and you just want to show
a few key ones.</p>
</td></tr>
<tr><td><code id="pairs_admb_+3A_label.cex">label.cex</code></td>
<td>
<p>Control size of outer and diagonal labels (default 1)</p>
</td></tr>
<tr><td><code id="pairs_admb_+3A_limits">limits</code></td>
<td>
<p>A list containing the ranges for each parameter
to use in plotting.</p>
</td></tr>
<tr><td><code id="pairs_admb_+3A_add.mle">add.mle</code></td>
<td>
<p>Boolean whether to add 95% confidence ellipses</p>
</td></tr>
<tr><td><code id="pairs_admb_+3A_add.monitor">add.monitor</code></td>
<td>
<p>Boolean whether to print effective sample</p>
</td></tr>
<tr><td><code id="pairs_admb_+3A_unbounded">unbounded</code></td>
<td>
<p>Whether to use the bounded or unbounded
version of the parameters.
size (ESS) and Rhat values on the diagonal.</p>
</td></tr>
<tr><td><code id="pairs_admb_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to plot call in lower
diagonal panels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is modified from the base <code>pairs</code>
code to work specifically with fits from the
'adnuts' package using either the NUTS or RWM MCMC
algorithms. If an invertible Hessian was found (in
<code>fit$mle</code>) then estimated covariances are available to
compare and added automatically (red ellipses). Likewise, a
&quot;monitor&quot; object from <code>rstan::monitor</code> is attached as
<code>fit$monitor</code> and provides effective sample sizes (ESS)
and Rhat values. The ESS are used to potentially order the
parameters via argument <code>order</code>, but also printed on
the diagonal.
</p>


<h3>Value</h3>

<p>Produces a plot, and returns nothing.
</p>


<h3>Author(s)</h3>

<p>Cole Monnahan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- readRDS(system.file('examples', 'fit.RDS', package='adnuts'))
pairs_admb(fit)
pairs_admb(fit, pars=1:2)
pairs_admb(fit, pars=c('b', 'a'))
pairs_admb(fit, pars=1:2, order='slow')
pairs_admb(fit, pars=1:2, order='fast')

</code></pre>

<hr>
<h2 id='plot_marginals'>Plot marginal distributions for a fitted model</h2><span id='topic+plot_marginals'></span>

<h3>Description</h3>

<p>Plot marginal distributions for a fitted model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_marginals(
  fit,
  pars = NULL,
  mfrow = NULL,
  add.mle = TRUE,
  add.monitor = TRUE,
  breaks = 30
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_marginals_+3A_fit">fit</code></td>
<td>
<p>A fitted object returned by
<code><a href="#topic+sample_admb">sample_admb</a></code>.</p>
</td></tr>
<tr><td><code id="plot_marginals_+3A_pars">pars</code></td>
<td>
<p>A numeric or character vector of parameters which
to plot, for plotting a subset of the total (defaults to all)</p>
</td></tr>
<tr><td><code id="plot_marginals_+3A_mfrow">mfrow</code></td>
<td>
<p>A custom grid size (vector of two) to be called
as <code>par(mfrow)</code>, overriding the defaults.</p>
</td></tr>
<tr><td><code id="plot_marginals_+3A_add.mle">add.mle</code></td>
<td>
<p>Whether to add marginal normal distributions
determined from the inverse Hessian file</p>
</td></tr>
<tr><td><code id="plot_marginals_+3A_add.monitor">add.monitor</code></td>
<td>
<p>Whether to add ESS and Rhat information</p>
</td></tr>
<tr><td><code id="plot_marginals_+3A_breaks">breaks</code></td>
<td>
<p>The number of breaks to use in <code>hist()</code>,
defaulting to 30</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots grid cells of all parameters
in a model, comparing the marginal posterior histogram vs
the asymptotic normal (red lines) from the inverse
Hessian. Its intended use is to quickly gauge differences
between frequentist and Bayesian inference on the same
model.
</p>
<p>If <code>fit$monitor</code> exists the effective sample size
(ESS) and R-hat estimates are printed in the top right
corner. See
<a href="https://mc-stan.org/rstan/reference/Rhat.html">https://mc-stan.org/rstan/reference/Rhat.html</a> for more
information. Generally Rhat&gt;1.05 or ESS&lt;100 (per chain)
suggest inference may be unreliable.
</p>
<p>This function is customized to work with multipage PDFs,
specifically:
<code>pdf('marginals.pdf', onefile=TRUE, width=7,height=5)</code>
produces a nice readable file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- readRDS(system.file('examples', 'fit.RDS', package='adnuts'))
plot_marginals(fit, pars=1:2)

</code></pre>

<hr>
<h2 id='plot_sampler_params'>Plot adaptation metrics for a fitted model.</h2><span id='topic+plot_sampler_params'></span>

<h3>Description</h3>

<p>Plot adaptation metrics for a fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sampler_params(fit, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_sampler_params_+3A_fit">fit</code></td>
<td>
<p>A fitted object returned by
<code><a href="#topic+sample_admb">sample_admb</a></code>.</p>
</td></tr>
<tr><td><code id="plot_sampler_params_+3A_plot">plot</code></td>
<td>
<p>Whether to plot the results</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This utility function quickly plots the adaptation output of NUTS
chains.
</p>


<h3>Value</h3>

<p>Prints and invisibly returns a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- readRDS(system.file('examples', 'fit.RDS', package='adnuts'))
plot_sampler_params(fit)
</code></pre>

<hr>
<h2 id='plot_uncertainties'>Plot MLE vs MCMC marginal standard deviations for each
parameter</h2><span id='topic+plot_uncertainties'></span>

<h3>Description</h3>

<p>Plot MLE vs MCMC marginal standard deviations for each
parameter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_uncertainties(fit, log = TRUE, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_uncertainties_+3A_fit">fit</code></td>
<td>
<p>A fitted object returned by
<code><a href="#topic+sample_admb">sample_admb</a></code></p>
</td></tr>
<tr><td><code id="plot_uncertainties_+3A_log">log</code></td>
<td>
<p>Whether to plot the logarithm or not.</p>
</td></tr>
<tr><td><code id="plot_uncertainties_+3A_plot">plot</code></td>
<td>
<p>Whether to plot it or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It can be helpful to compare uncertainty estimates
between the two paradigms. This plots the marginal posterior
standard deviation vs the frequentist standard error
estimated from the .cor file. Large differences often
indicate issues with one estimation method.
</p>


<h3>Value</h3>

<p>Invisibly returns data.frame with parameter name and
estimated uncertainties.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- readRDS(system.file('examples', 'fit.RDS', package='adnuts'))
x &lt;- plot_uncertainties(fit, plot=FALSE)
head(x)
</code></pre>

<hr>
<h2 id='plot.adfit'>Plot object of class adfit</h2><span id='topic+plot.adfit'></span>

<h3>Description</h3>

<p>Plot object of class adfit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adfit'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.adfit_+3A_x">x</code></td>
<td>
<p>Fitted object from <code><a href="#topic+sample_admb">sample_admb</a></code></p>
</td></tr>
<tr><td><code id="plot.adfit_+3A_y">y</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="plot.adfit_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot created
</p>

<hr>
<h2 id='print.adfit'>Print summary of adfit object</h2><span id='topic+print.adfit'></span>

<h3>Description</h3>

<p>Print summary of adfit object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adfit'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.adfit_+3A_x">x</code></td>
<td>
<p>Fitted object from <code><a href="#topic+sample_admb">sample_admb</a></code></p>
</td></tr>
<tr><td><code id="print.adfit_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary printed to console
</p>

<hr>
<h2 id='sample_admb'>Deprecated version of wrapper function. Use sample_nuts or
sample_rwm instead.</h2><span id='topic+sample_admb'></span>

<h3>Description</h3>

<p>Deprecated version of wrapper function. Use sample_nuts or
sample_rwm instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_admb(
  model,
  path = getwd(),
  iter = 2000,
  init = NULL,
  chains = 3,
  warmup = NULL,
  seeds = NULL,
  thin = 1,
  mceval = FALSE,
  duration = NULL,
  parallel = FALSE,
  cores = NULL,
  control = NULL,
  skip_optimization = TRUE,
  algorithm = "NUTS",
  skip_monitor = FALSE,
  skip_unbounded = TRUE,
  admb_args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_admb_+3A_model">model</code></td>
<td>
<p>Name of model (i.e., 'model' for model.tpl). For
non-Windows systems this will automatically be converted to
'./model' internally. For Windows, long file names are
sometimes shortened from e.g., 'long_model_filename' to
'LONG_~1'. This should work, but will throw warnings. Please
shorten the model name. See
https://en.wikipedia.org/wiki/8.3_filename.</p>
</td></tr>
<tr><td><code id="sample_admb_+3A_path">path</code></td>
<td>
<p>Path to model executable. Defaults to working
directory. Often best to have model files in a separate
subdirectory, particularly for parallel.</p>
</td></tr>
<tr><td><code id="sample_admb_+3A_iter">iter</code></td>
<td>
<p>The number of samples to draw.</p>
</td></tr>
<tr><td><code id="sample_admb_+3A_init">init</code></td>
<td>
<p>A list of lists containing the initial parameter
vectors, one for each chain or a function. It is strongly
recommended to initialize multiple chains from dispersed
points. A of NULL signifies to use the starting values
present in the model (i.e., <code>obj$par</code>) for all chains.</p>
</td></tr>
<tr><td><code id="sample_admb_+3A_chains">chains</code></td>
<td>
<p>The number of chains to run.</p>
</td></tr>
<tr><td><code id="sample_admb_+3A_warmup">warmup</code></td>
<td>
<p>The number of warmup iterations.</p>
</td></tr>
<tr><td><code id="sample_admb_+3A_seeds">seeds</code></td>
<td>
<p>A vector of seeds, one for each chain.</p>
</td></tr>
<tr><td><code id="sample_admb_+3A_thin">thin</code></td>
<td>
<p>The thinning rate to apply to samples. Typically
not used with NUTS.</p>
</td></tr>
<tr><td><code id="sample_admb_+3A_mceval">mceval</code></td>
<td>
<p>Whether to run the model with <code>-mceval</code> on
samples from merged chains.</p>
</td></tr>
<tr><td><code id="sample_admb_+3A_duration">duration</code></td>
<td>
<p>The number of minutes after which the model
will quit running.</p>
</td></tr>
<tr><td><code id="sample_admb_+3A_parallel">parallel</code></td>
<td>
<p>A deprecated argument, use cores=1 for serial
execution or cores&gt;1 for parallel (default is to parallel
with cores equal to the available-1)</p>
</td></tr>
<tr><td><code id="sample_admb_+3A_cores">cores</code></td>
<td>
<p>The number of cores to use for parallel
execution. Default is number available in the system minus
1. If <code>cores=1</code>, serial execution occurs (even if
<code>chains&gt;1</code>), otherwise parallel execution via package
snowfall is used. For slow analyses it is recommended to set
<code>chains</code>&lt;=<code>cores</code> so each core needs to run only a
single chain.</p>
</td></tr>
<tr><td><code id="sample_admb_+3A_control">control</code></td>
<td>
<p>A list to control the sampler. See details for
further use.</p>
</td></tr>
<tr><td><code id="sample_admb_+3A_skip_optimization">skip_optimization</code></td>
<td>
<p>Whether to run the optimizer before
running MCMC. This is rarely need as it is better to run it
once before to get the covariance matrix, or the estimates
are not needed with adaptive NUTS.</p>
</td></tr>
<tr><td><code id="sample_admb_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm to use, one of &quot;NUTS&quot; or &quot;RWM&quot;</p>
</td></tr>
<tr><td><code id="sample_admb_+3A_skip_monitor">skip_monitor</code></td>
<td>
<p>Whether to skip calculating diagnostics
(effective sample size, Rhat) via the <code>rstan::monitor</code>
function. This can be slow for models with high dimension or
many iterations. The result is used in plots and summaries
so it is recommended to turn on. If model run with
<code>skip_monitor=FALSE</code> you can recreate it post-hoc by
setting <code>fit$monitor=rstan::monitor(fit$samples,
fit$warmup, print=FALSE)</code>.</p>
</td></tr>
<tr><td><code id="sample_admb_+3A_skip_unbounded">skip_unbounded</code></td>
<td>
<p>Whether to skip returning the unbounded
version of the posterior samples in addition to the bounded
ones. It may be advisable to set to FALSE for very large
models to save space.</p>
</td></tr>
<tr><td><code id="sample_admb_+3A_admb_args">admb_args</code></td>
<td>
<p>A character string which gets passed to the
command line, allowing finer control</p>
</td></tr>
</table>


<h3>Warning</h3>

<p>This is deprecated and will cease to exist
in future releases
</p>

<hr>
<h2 id='sample_inits'>Function to generate random initial values from a previous fit using
adnuts</h2><span id='topic+sample_inits'></span>

<h3>Description</h3>

<p>Function to generate random initial values from a previous fit using
adnuts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_inits(fit, chains)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_inits_+3A_fit">fit</code></td>
<td>
<p>An outputted list from <code><a href="#topic+sample_admb">sample_admb</a></code></p>
</td></tr>
<tr><td><code id="sample_inits_+3A_chains">chains</code></td>
<td>
<p>The number of chains for the subsequent run, which
determines the number to return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of lists which can be passed back into
<code><a href="#topic+sample_admb">sample_admb</a></code>.
</p>

<hr>
<h2 id='sample_nuts'>Bayesian inference of an ADMB model using the no-U-turn
sampler (NUTS) or random walk Metropolis (RWM) algorithms.</h2><span id='topic+sample_nuts'></span><span id='topic+sample_rwm'></span><span id='topic+wrappers'></span>

<h3>Description</h3>

<p>Draw Bayesian posterior samples from an AD Model Builder
(ADMB) model using an MCMC algorithm. 'sample_nuts' and
'sample_rwm' generates posterior samples from which inference
can be made.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_nuts(
  model,
  path = getwd(),
  iter = 2000,
  init = NULL,
  chains = 3,
  warmup = NULL,
  seeds = NULL,
  thin = 1,
  mceval = FALSE,
  duration = NULL,
  parallel = FALSE,
  cores = NULL,
  control = NULL,
  skip_optimization = TRUE,
  verbose = TRUE,
  skip_monitor = FALSE,
  skip_unbounded = TRUE,
  admb_args = NULL,
  extra.args = NULL
)

sample_rwm(
  model,
  path = getwd(),
  iter = 2000,
  init = NULL,
  chains = 3,
  warmup = NULL,
  seeds = NULL,
  thin = 1,
  mceval = FALSE,
  duration = NULL,
  parallel = FALSE,
  cores = NULL,
  control = NULL,
  skip_optimization = TRUE,
  verbose = TRUE,
  skip_monitor = FALSE,
  skip_unbounded = TRUE,
  admb_args = NULL,
  extra.args = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_nuts_+3A_model">model</code></td>
<td>
<p>Name of model (i.e., 'model' for model.tpl). For
non-Windows systems this will automatically be converted to
'./model' internally. For Windows, long file names are
sometimes shortened from e.g., 'long_model_filename' to
'LONG_~1'. This should work, but will throw warnings. Please
shorten the model name. See
https://en.wikipedia.org/wiki/8.3_filename.</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_path">path</code></td>
<td>
<p>Path to model executable. Defaults to working
directory. Often best to have model files in a separate
subdirectory, particularly for parallel.</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_iter">iter</code></td>
<td>
<p>The number of samples to draw.</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_init">init</code></td>
<td>
<p>A list of lists containing the initial parameter
vectors, one for each chain or a function. It is strongly
recommended to initialize multiple chains from dispersed
points. A of NULL signifies to use the starting values
present in the model (i.e., <code>obj$par</code>) for all chains.</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_chains">chains</code></td>
<td>
<p>The number of chains to run.</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_warmup">warmup</code></td>
<td>
<p>The number of warmup iterations.</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_seeds">seeds</code></td>
<td>
<p>A vector of seeds, one for each chain.</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_thin">thin</code></td>
<td>
<p>The thinning rate to apply to samples. Typically
not used with NUTS.</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_mceval">mceval</code></td>
<td>
<p>Whether to run the model with <code>-mceval</code> on
samples from merged chains.</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_duration">duration</code></td>
<td>
<p>The number of minutes after which the model
will quit running.</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_parallel">parallel</code></td>
<td>
<p>A deprecated argument, use cores=1 for serial
execution or cores&gt;1 for parallel (default is to parallel
with cores equal to the available-1)</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_cores">cores</code></td>
<td>
<p>The number of cores to use for parallel
execution. Default is number available in the system minus
1. If <code>cores=1</code>, serial execution occurs (even if
<code>chains&gt;1</code>), otherwise parallel execution via package
snowfall is used. For slow analyses it is recommended to set
<code>chains</code>&lt;=<code>cores</code> so each core needs to run only a
single chain.</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_control">control</code></td>
<td>
<p>A list to control the sampler. See details for
further use.</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_skip_optimization">skip_optimization</code></td>
<td>
<p>Whether to run the optimizer before
running MCMC. This is rarely need as it is better to run it
once before to get the covariance matrix, or the estimates
are not needed with adaptive NUTS.</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_verbose">verbose</code></td>
<td>
<p>Flag whether to show console output (default)
or suppress it completely except for warnings and
errors. Works for serial or parallel execution.</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_skip_monitor">skip_monitor</code></td>
<td>
<p>Whether to skip calculating diagnostics
(effective sample size, Rhat) via the <code>rstan::monitor</code>
function. This can be slow for models with high dimension or
many iterations. The result is used in plots and summaries
so it is recommended to turn on. If model run with
<code>skip_monitor=FALSE</code> you can recreate it post-hoc by
setting <code>fit$monitor=rstan::monitor(fit$samples,
fit$warmup, print=FALSE)</code>.</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_skip_unbounded">skip_unbounded</code></td>
<td>
<p>Whether to skip returning the unbounded
version of the posterior samples in addition to the bounded
ones. It may be advisable to set to FALSE for very large
models to save space.</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_admb_args">admb_args</code></td>
<td>
<p>A character string which gets passed to the
command line, allowing finer control</p>
</td></tr>
<tr><td><code id="sample_nuts_+3A_extra.args">extra.args</code></td>
<td>
<p>Deprecated, use a <code>admb_args</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adaptation schemes are used with NUTS so specifying tuning
parameters is not necessary. See vignette for options for
adaptation of step size and mass matrix.  The RWM algorithm
provides no new functionality not available from previous
versions of ADMB. However, 'sample_rwm' has an improved
console output, is setup for parallel execution, and a smooth
workflow for diagnostics.
</p>
<p>Parallel chains will be run if argument 'cores' is greater
than one. This entails copying the folder, and starting a new
R session to run that chain, which are then merged back
together. Note that console output is inconsistent when using
parallel, and may not show. On Windows the R terminal shows
output live, but the GUI does not. RStudio is a special case
and will not show live, and instead is captured and returned
at the end. It is strongly recommended to start with serial
execution as debugging parallel chains is very difficult.
</p>
<p>Note that the algorithm code is in the ADMB source code, and
'adnuts' provides a wrapper for it. The command line arguments
are returned and can be examined by the user. See vignette for
more information.
</p>
<p>This function implements algorithm 6 of Hoffman and Gelman (2014),
and loosely follows package <code>rstan</code>. The step size can be
adapted or specified manually. The metric (i.e., mass matrix) can be
unit diagonal, adapted diagonal (default and recommended), a dense
matrix specified by the user, or an adapted dense matrix.
Further control of algorithms can be
specified with the <code>control</code> argument.  Elements are:
</p>

<dl>
<dt>adapt_delta</dt><dd><p>The target acceptance rate. D</p>
</dd>
<dt>metric</dt><dd><p>The mass metric to use. Options are: &quot;unit&quot; for a unit diagonal
matrix; <code>NULL</code> to estimate a diagonal matrix during warmup; a matrix
to be used directly (in untransformed space).</p>
</dd>
<dt>adapt_delta</dt><dd><p>Whether adaptation of step size is turned on.</p>
</dd>
<dt>adapt_mass</dt><dd><p>Whether adaptation of mass matrix is turned
on. Currently only allowed for diagonal metric.</p>
</dd>
<dt>adapt_mass_dense</dt><dd><p>Whether dense adaptation of mass
matrix is turned on.</p>
</dd>
<dt>max_treedepth</dt><dd><p>Maximum treedepth for the NUTS algorithm.</p>
</dd>
<dt>stepsize</dt><dd><p>The stepsize for the NUTS algorithm. If <code>NULL</code> it
will be adapted during warmup.</p>
</dd>
<dt>adapt_init_buffer</dt><dd><p>The initial buffer size during mass matrix
adaptation where sample information is not used (default
50)</p>
</dd>
<dt>adapt_term_buffer</dt><dd><p>The terminal buffer size (default 75)
during mass
matrix adaptation (final fast phase)</p>
</dd>
<dt>adapt_window</dt><dd><p>The initial size of the mass matrix
adaptation window, which gets doubled each time thereafter.</p>
</dd>
<dt>refresh</dt><dd><p>The rate at which to refresh progress to the
console. Defaults to even 10
progress updates.</p>
</dd>
</dl>

<p>The adaptation scheme (step size and mass matrix) is based heavily on those by the
software Stan, and more details can be found in that
documentation and this vignette.
</p>


<h3>Warning</h3>

<p>The user is responsible for specifying the
model properly (priors, starting values, desired parameters
fixed, etc.), as well as assessing the convergence and
validity of the resulting samples (e.g., through the
<code>coda</code> package), or with function
<code><a href="#topic+launch_shinytmb">launch_shinytmb</a></code> before making
inference. Specifically, priors must be specified in the
template file for each parameter. Unspecified priors will be
implicitly uniform.
</p>


<h3>Author(s)</h3>

<p>Cole Monnahan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This is the packaged simple regression model
path.simple &lt;- system.file('examples', 'simple', package='adnuts')
## It is best to have your ADMB files in a separate folder and provide that
## path, so make a copy of the model folder locally.
path &lt;- 'simple'
dir.create(path)
trash &lt;- file.copy(from=list.files(path.simple, full.names=TRUE), to=path)
## Compile and run model
oldwd &lt;- getwd()
setwd(path)
system('admb simple.tpl')
system('simple')
setwd('..')
init &lt;- function() rnorm(2)
## Run NUTS with defaults
fit &lt;- sample_nuts(model='simple', init=init, path=path)
unlink(path, TRUE) # cleanup folder
setwd(oldwd)

## End(Not run)

</code></pre>

<hr>
<h2 id='sample_tmb'>Bayesian inference of a TMB model using the no-U-turn sampler.</h2><span id='topic+sample_tmb'></span>

<h3>Description</h3>

<p>Draw Bayesian posterior samples from a Template Model Builder (TMB)
model using an MCMC algorithm. This function generates posterior samples
from which inference can be made. Adaptation schemes are used so
specification tuning parameters are not necessary, and parallel
execution reduces overall run time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_tmb(
  obj,
  iter = 2000,
  init,
  chains = 3,
  seeds = NULL,
  warmup = floor(iter/2),
  lower = NULL,
  upper = NULL,
  thin = 1,
  parallel = FALSE,
  cores = NULL,
  path = NULL,
  algorithm = "NUTS",
  laplace = FALSE,
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_tmb_+3A_obj">obj</code></td>
<td>
<p>A TMB model object.</p>
</td></tr>
<tr><td><code id="sample_tmb_+3A_iter">iter</code></td>
<td>
<p>The number of samples to draw.</p>
</td></tr>
<tr><td><code id="sample_tmb_+3A_init">init</code></td>
<td>
<p>A list of lists containing the initial parameter
vectors, one for each chain or a function. It is strongly
recommended to initialize multiple chains from dispersed
points. A of NULL signifies to use the starting values
present in the model (i.e., <code>obj$par</code>) for all chains.</p>
</td></tr>
<tr><td><code id="sample_tmb_+3A_chains">chains</code></td>
<td>
<p>The number of chains to run.</p>
</td></tr>
<tr><td><code id="sample_tmb_+3A_seeds">seeds</code></td>
<td>
<p>A vector of seeds, one for each chain.</p>
</td></tr>
<tr><td><code id="sample_tmb_+3A_warmup">warmup</code></td>
<td>
<p>The number of warmup iterations.</p>
</td></tr>
<tr><td><code id="sample_tmb_+3A_lower">lower</code></td>
<td>
<p>A vector of lower bounds for parameters. Allowed values are
-Inf and numeric.</p>
</td></tr>
<tr><td><code id="sample_tmb_+3A_upper">upper</code></td>
<td>
<p>A vector of upper bounds for parameters. Allowed values are
Inf and numeric.</p>
</td></tr>
<tr><td><code id="sample_tmb_+3A_thin">thin</code></td>
<td>
<p>The thinning rate to apply to samples. Typically
not used with NUTS.</p>
</td></tr>
<tr><td><code id="sample_tmb_+3A_parallel">parallel</code></td>
<td>
<p>A deprecated argument, use cores=1 for serial
execution or cores&gt;1 for parallel (default is to parallel
with cores equal to the available-1)</p>
</td></tr>
<tr><td><code id="sample_tmb_+3A_cores">cores</code></td>
<td>
<p>The number of cores to use for parallel
execution. Default is number available in the system minus
1. If <code>cores=1</code>, serial execution occurs (even if
<code>chains&gt;1</code>), otherwise parallel execution via package
snowfall is used. For slow analyses it is recommended to set
<code>chains</code>&lt;=<code>cores</code> so each core needs to run only a
single chain.</p>
</td></tr>
<tr><td><code id="sample_tmb_+3A_path">path</code></td>
<td>
<p>Path to model executable. Defaults to working
directory. Often best to have model files in a separate
subdirectory, particularly for parallel.</p>
</td></tr>
<tr><td><code id="sample_tmb_+3A_algorithm">algorithm</code></td>
<td>
<p>The algorithm to use. NUTS is the default and
recommended one, but &quot;RWM&quot; for the random walk Metropolis sampler and
&quot;HMC&quot; for the static HMC sampler are available. These last two are
deprecated but may be of use in some situations. These algorithms
require different arguments; see their help files for more
information.</p>
</td></tr>
<tr><td><code id="sample_tmb_+3A_laplace">laplace</code></td>
<td>
<p>Whether to use the Laplace approximation if some
parameters are declared as random. Default is to turn off this
functionality and integrate across all parameters with MCMC.</p>
</td></tr>
<tr><td><code id="sample_tmb_+3A_control">control</code></td>
<td>
<p>A list to control the sampler. See details for
further use.</p>
</td></tr>
<tr><td><code id="sample_tmb_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to samplers</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements algorithm 6 of Hoffman and Gelman (2014),
and loosely follows package <code>rstan</code>. The step size can be
adapted or specified manually. The metric (i.e., mass matrix) can be
unit diagonal, adapted diagonal (default and recommended), or a dense
matrix specified by the user. Further control of algorithms can be
specified with the <code>control</code> argument.  Elements are:
</p>

<dl>
<dt>adapt_delta</dt><dd><p>The target acceptance rate.</p>
</dd>
<dt>metric</dt><dd><p>The mass metric to use. Options are: &quot;unit&quot; for a unit diagonal
matrix; &quot;diag&quot; to estimate a diagonal matrix during warmup; a matrix
to be used directly (in untransformed space).</p>
</dd>
<dt>adapt_engaged</dt><dd><p>Whether adaptation of step size and metric is turned on.</p>
</dd>
<dt>max_treedepth</dt><dd><p>Maximum treedepth for the NUTS algorithm.</p>
</dd>
<dt>stepsize</dt><dd><p>The stepsize for the NUTS algorithm. If <code>NULL</code> it
will be adapted during warmup.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A list containing the samples, and properties of the sampler
useful for diagnosing behavior and efficiency.
</p>


<h3>Warning</h3>

<p>This is deprecated and will cease to exist
in future releases
</p>


<h3>Author(s)</h3>

<p>Cole Monnahan
</p>


<h3>See Also</h3>

<p><code><a href="#topic+extract_samples">extract_samples</a></code> to extract samples and
<code><a href="#topic+launch_shinytmb">launch_shinytmb</a></code> to explore the results graphically which
is a wrapper for the <code><a href="shinystan.html#topic+launch_shinystan">launch_shinystan</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Build a fake TMB object with objective &amp; gradient functions and some
## other flags
## Not run: 
f &lt;- function(x, order=0){
  if(order != 1) # negative log density
    -sum(dnorm(x=x, mean=0, sd=1, log=TRUE))
  else x # gradient of negative log density
}
init &lt;- function() rnorm(2)
obj &lt;- list(env=list(DLL='demo', last.par.best=c(x=init()), f=f,
  beSilent=function() NULL))
## Run NUTS for this object
fit &lt;- sample_tmb(obj, iter=1000, chains=3, init=init)
## Check basic diagnostics
mon &lt;- rstan::monitor(fit$samples, print=FALSE)
Rhat &lt;- mon[,"Rhat"]
max(Rhat)
ess &lt;- mon[, 'n_eff']
min(ess)
## Or do it interactively with ShinyStan
launch_shinytmb(fit)

## End(Not run)

</code></pre>

<hr>
<h2 id='sample_tmb_hmc'>Draw MCMC samples from a model posterior using a static HMC sampler.</h2><span id='topic+sample_tmb_hmc'></span>

<h3>Description</h3>

<p>Draw MCMC samples from a model posterior using a static HMC sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_tmb_hmc(
  iter,
  fn,
  gr,
  init,
  L,
  eps,
  warmup = floor(iter/2),
  seed = NULL,
  chain = 1,
  thin = 1,
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_tmb_hmc_+3A_iter">iter</code></td>
<td>
<p>The number of samples to draw.</p>
</td></tr>
<tr><td><code id="sample_tmb_hmc_+3A_fn">fn</code></td>
<td>
<p>A function that returns the log of the posterior density.</p>
</td></tr>
<tr><td><code id="sample_tmb_hmc_+3A_gr">gr</code></td>
<td>
<p>A function that returns a vector of gradients of the log of
the posterior density (same as <code>fn</code>).</p>
</td></tr>
<tr><td><code id="sample_tmb_hmc_+3A_init">init</code></td>
<td>
<p>A list of lists containing the initial parameter
vectors, one for each chain or a function. It is strongly
recommended to initialize multiple chains from dispersed
points. A of NULL signifies to use the starting values
present in the model (i.e., <code>obj$par</code>) for all chains.</p>
</td></tr>
<tr><td><code id="sample_tmb_hmc_+3A_l">L</code></td>
<td>
<p>The number of leapfrog steps to take. The NUTS algorithm does
not require this as an input. If <code>L=1</code> this function will perform
Langevin sampling. In some contexts <code>L</code> can roughly be thought of
as a thinning rate.</p>
</td></tr>
<tr><td><code id="sample_tmb_hmc_+3A_eps">eps</code></td>
<td>
<p>The step size. If a numeric value is passed, it will be used
throughout the entire chain. A <code>NULL</code> value will initiate
sampler_params of <code>eps</code> using the dual averaging algorithm during
the first <code>warmup</code> steps.</p>
</td></tr>
<tr><td><code id="sample_tmb_hmc_+3A_warmup">warmup</code></td>
<td>
<p>The number of warmup iterations.</p>
</td></tr>
<tr><td><code id="sample_tmb_hmc_+3A_seed">seed</code></td>
<td>
<p>The random seed to use.</p>
</td></tr>
<tr><td><code id="sample_tmb_hmc_+3A_chain">chain</code></td>
<td>
<p>The chain number, for printing only.</p>
</td></tr>
<tr><td><code id="sample_tmb_hmc_+3A_thin">thin</code></td>
<td>
<p>The thinning rate to apply to samples. Typically
not used with NUTS.</p>
</td></tr>
<tr><td><code id="sample_tmb_hmc_+3A_control">control</code></td>
<td>
<p>A list to control the sampler. See details for
further use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements algorithm 5 of Hoffman and Gelman
(2014), which includes adaptive step sizes (<code>eps</code>) via an
algorithm called dual averaging.
</p>


<h3>Value</h3>

<p>A list containing samples ('par') and algorithm details such as
step size adaptation and acceptance probabilities per iteration
('sampler_params').
</p>


<h3>References</h3>

 <ul>
<li><p>Neal, R. M. (2011). MCMC using Hamiltonian
dynamics. Handbook of Markov Chain Monte Carlo.  </p>
</li>
<li><p>Hoffman and
Gelman (2014). The No-U-Turn sampler: Adaptively setting path lengths
in Hamiltonian Monte Carlo. J. Mach. Learn. Res.  15:1593-1623.  </p>
</li></ul>

<p>Hoffman and Gelman (2014). The No-U-Turn sampler: Adaptively setting
path lengths in Hamiltonian Monte Carlo. J. Mach. Learn. Res.
15:1593-1623.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_tmb">sample_tmb</a></code>
</p>
<p><code><a href="#topic+sample_tmb">sample_tmb</a></code>
</p>

<hr>
<h2 id='sample_tmb_nuts'>Draw MCMC samples from a model posterior using the No-U-Turn (NUTS)
sampler with dual averaging.</h2><span id='topic+sample_tmb_nuts'></span>

<h3>Description</h3>

<p>Draw MCMC samples from a model posterior using the No-U-Turn (NUTS)
sampler with dual averaging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_tmb_nuts(
  iter,
  fn,
  gr,
  init,
  warmup = floor(iter/2),
  chain = 1,
  thin = 1,
  seed = NULL,
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_tmb_nuts_+3A_iter">iter</code></td>
<td>
<p>The number of samples to draw.</p>
</td></tr>
<tr><td><code id="sample_tmb_nuts_+3A_fn">fn</code></td>
<td>
<p>A function that returns the log of the posterior density.</p>
</td></tr>
<tr><td><code id="sample_tmb_nuts_+3A_gr">gr</code></td>
<td>
<p>A function that returns a vector of gradients of the log of
the posterior density (same as <code>fn</code>).</p>
</td></tr>
<tr><td><code id="sample_tmb_nuts_+3A_init">init</code></td>
<td>
<p>A list of lists containing the initial parameter
vectors, one for each chain or a function. It is strongly
recommended to initialize multiple chains from dispersed
points. A of NULL signifies to use the starting values
present in the model (i.e., <code>obj$par</code>) for all chains.</p>
</td></tr>
<tr><td><code id="sample_tmb_nuts_+3A_warmup">warmup</code></td>
<td>
<p>The number of warmup iterations.</p>
</td></tr>
<tr><td><code id="sample_tmb_nuts_+3A_chain">chain</code></td>
<td>
<p>The chain number, for printing only.</p>
</td></tr>
<tr><td><code id="sample_tmb_nuts_+3A_thin">thin</code></td>
<td>
<p>The thinning rate to apply to samples. Typically
not used with NUTS.</p>
</td></tr>
<tr><td><code id="sample_tmb_nuts_+3A_seed">seed</code></td>
<td>
<p>The random seed to use.</p>
</td></tr>
<tr><td><code id="sample_tmb_nuts_+3A_control">control</code></td>
<td>
<p>A list to control the sampler. See details for
further use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements algorithm 6 of Hoffman and Gelman
(2014), which includes adaptive step sizes (<code>eps</code>) via an
algorithm called dual averaging. It also includes an adaptation scheme
to tune a diagonal mass matrix (metric) during warmup.
</p>
<p>These <code>fn</code> and <code>gr</code> functions must have Jacobians already
applied if there are transformations used.
</p>


<h3>References</h3>

<p>Hoffman and Gelman (2014). The No-U-Turn sampler: Adaptively setting
path lengths in Hamiltonian Monte Carlo. J. Mach. Learn. Res.
15:1593-1623.
</p>


<h3>See Also</h3>

<p><code>sample_tmb</code>
</p>

<hr>
<h2 id='sample_tmb_rwm'>[Deprecated] Draw MCMC samples from a model posterior using a
Random Walk Metropolis (RWM) sampler.</h2><span id='topic+sample_tmb_rwm'></span>

<h3>Description</h3>

<p>[Deprecated] Draw MCMC samples from a model posterior using a
Random Walk Metropolis (RWM) sampler.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_tmb_rwm(
  iter,
  fn,
  init,
  alpha = 1,
  chain = 1,
  warmup = floor(iter/2),
  thin = 1,
  seed = NULL,
  control = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_tmb_rwm_+3A_iter">iter</code></td>
<td>
<p>The number of samples to draw.</p>
</td></tr>
<tr><td><code id="sample_tmb_rwm_+3A_fn">fn</code></td>
<td>
<p>A function that returns the log of the posterior density.</p>
</td></tr>
<tr><td><code id="sample_tmb_rwm_+3A_init">init</code></td>
<td>
<p>A list of lists containing the initial parameter
vectors, one for each chain or a function. It is strongly
recommended to initialize multiple chains from dispersed
points. A of NULL signifies to use the starting values
present in the model (i.e., <code>obj$par</code>) for all chains.</p>
</td></tr>
<tr><td><code id="sample_tmb_rwm_+3A_alpha">alpha</code></td>
<td>
<p>The amount to scale the proposal, i.e,
Xnew=Xcur+alpha*Xproposed where Xproposed is generated from a mean-zero
multivariate normal. Varying <code>alpha</code> varies the acceptance rate.</p>
</td></tr>
<tr><td><code id="sample_tmb_rwm_+3A_chain">chain</code></td>
<td>
<p>The chain number, for printing only.</p>
</td></tr>
<tr><td><code id="sample_tmb_rwm_+3A_warmup">warmup</code></td>
<td>
<p>The number of warmup iterations.</p>
</td></tr>
<tr><td><code id="sample_tmb_rwm_+3A_thin">thin</code></td>
<td>
<p>The thinning rate to apply to samples. Typically
not used with NUTS.</p>
</td></tr>
<tr><td><code id="sample_tmb_rwm_+3A_seed">seed</code></td>
<td>
<p>The random seed to use.</p>
</td></tr>
<tr><td><code id="sample_tmb_rwm_+3A_control">control</code></td>
<td>
<p>A list to control the sampler. See details for
further use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm does not yet contain adaptation of <code>alpha</code>
so some trial and error may be required for efficient sampling.
</p>


<h3>Value</h3>

<p>A list containing samples and other metadata.
</p>


<h3>References</h3>

<p>Metropolis, N., Rosenbluth, A.W., Rosenbluth, M.N., Teller, A.H.,
Teller, E., 1953. Equation of state calculations by fast computing
machines.  J Chem Phys. 21:1087-1092.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sample_tmb">sample_tmb</a></code>
</p>

<hr>
<h2 id='summary.adfit'>Print summary of object of class adfit</h2><span id='topic+summary.adfit'></span>

<h3>Description</h3>

<p>Print summary of object of class adfit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adfit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.adfit_+3A_object">object</code></td>
<td>
<p>Fitted object from <code><a href="#topic+sample_admb">sample_admb</a></code></p>
</td></tr>
<tr><td><code id="summary.adfit_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary printed to screen
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
