<!DOCTYPE html><html lang="en"><head><title>Help for package wflo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {wflo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#wflo'><p>Data set and functions for wind farm layout optimization.</p></a></li>
<li><a href='#AcquireData'><p>Downloads the larger data set for entire Germany.</p></a></li>
<li><a href='#AirDensity'><p>Provides convenient computations for air density.</p></a></li>
<li><a href='#Area'><p>Computes the overlap area for the partial Jensen wake.</p></a></li>
<li><a href='#Cost'><p>Stub for a turbine's cost function.</p></a></li>
<li><a href='#e'><p>Environment for data and variables.</p></a></li>
<li><a href='#FarmData'><p>Data set for wind farm layout optimization.</p></a></li>
<li><a href='#FarmVars'><p>Variables object for wind farm specifications.</p></a></li>
<li><a href='#GaussWS'><p>Convenience function to look-up values from a object returned by GenerateGauss.</p></a></li>
<li><a href='#GenerateGauss'><p>For an incoming wind speed at reference height, this function computes a 3D tensor object containing Gaussian model based wind speeds.</p></a></li>
<li><a href='#Geo2Ari'><p>Converts degrees between the arithmetic system and the azimuth system (and vice versa).</p></a></li>
<li><a href='#GetAngle'><p>Returns the angle between two turbines.</p></a></li>
<li><a href='#GetArrow'><p>Simple helper function for <code>PlotResult</code>.</p></a></li>
<li><a href='#GetDirInfo'><p>Returns average wind direction and direction standard deviation for a turbine's location.</p></a></li>
<li><a href='#GetFarmFromLonLat'><p>Accesses full FarmData set and returns a compatible list object for the requested location.</p></a></li>
<li><a href='#GK2Index'><p>Converts Gauss-Kruger coordinates to FarmData indices.</p></a></li>
<li><a href='#GK2LonLat'><p>Converts Gauss-Kruger coordinates to longitude/latitude coordinates.</p></a></li>
<li><a href='#Height'><p>Returns the elevation of a turbine's location.</p></a></li>
<li><a href='#ImposeVectorField'><p>Simple helper function for <code>PlotResult</code>.</p></a></li>
<li><a href='#Index2GK'><p>Converts FarmData indices to Gauss-Kruger coordinates.</p></a></li>
<li><a href='#JensenAngle'><p>For a given distance <code>x</code>, computes the wake cone generated by a turbine.</p></a></li>
<li><a href='#JensenFactor'><p>For a given distance <code>x</code>, computes the penalty factor for a turbine's wake.</p></a></li>
<li><a href='#JensenTrapezoid'><p>Computes the four corner points of a Jensen trapezoid (or cone).</p></a></li>
<li><a href='#LonLat2GK'><p>Converts longitude/latitude coordinates to Gauss-Kruger coordinates.</p></a></li>
<li><a href='#MosettiTurbineCost'><p>Returns Mosetti's cost model for a number of turbines.</p></a></li>
<li><a href='#PairPenalty'><p>Returns the Jensen wake penalty factor for a pair of turbines.</p></a></li>
<li><a href='#PartialJensen'><p>Computes the partial Jensen wake effect.</p></a></li>
<li><a href='#PlotResult'><p>Visualizes the wind farm layout optimization result.</p></a></li>
<li><a href='#PointInPolygon'><p>Checks whether a point is inside a polygon.</p></a></li>
<li><a href='#Profit'><p>Computes the economic profit for a given wind farm layout configuration</p></a></li>
<li><a href='#ProfitContributors'><p>Computes profit contributions for all points in a setup solution.</p></a></li>
<li><a href='#QuickGauss3D'><p>For an incoming wind speed at reference height, this function computes a 3D Gaussian model based wind speed.</p></a></li>
<li><a href='#ShowWakePenalizers'><p>Visualizes the points causing/'suffering' from wake effects.</p></a></li>
<li><a href='#SwitchProfile'><p>Helper function for ex-post wind direction dependence analysis</p></a></li>
<li><a href='#ValidSetup'><p>Checks whether all turbine locations provided satisfy the minimum distance criterion.</p></a></li>
<li><a href='#WindspeedHellmann'><p>Scales wind speeds to certain heights.</p></a></li>
<li><a href='#WindspeedLog'><p>Scales wind speeds to certain heights.</p></a></li>
<li><a href='#Yield'><p>Returns yearly yield for a turbine's location.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Data Set and Helper Functions for Wind Farm Layout Optimization
Problems</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-18</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a convenient data set, a set of helper functions, and a benchmark function for
    economically (profit) driven wind farm layout optimization. This enables researchers in the field
    of the NP-hard (non-deterministic polynomial-time hard) problem of wind farm layout optimization
    to focus on their optimization methodology contribution and also provides a realistic benchmark
    setting for comparability among contributions. See Croonenbroeck, Carsten &amp; Hennecke, David (2020)
    &lt;<a href="https://doi.org/10.1016%2Fj.energy.2020.119244">doi:10.1016/j.energy.2020.119244</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>plotrix, progress, emstreeR, terra, sf</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MASS, nloptr, pso, rgenoud, snow, doSNOW, foreach, parallel</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-18 16:27:19 UTC; ccroo</td>
</tr>
<tr>
<td>Author:</td>
<td>Carsten Croonenbroeck [aut, cre],
  David Hennecke [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carsten Croonenbroeck &lt;carsten.croonenbroeck@uni-rostock.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-18 20:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='wflo'>Data set and functions for wind farm layout optimization.</h2><span id='topic+wflo'></span><span id='topic+wflo-package'></span>

<h3>Description</h3>

<p>This package makes two contributions to the Wind Farm Layout Optimization (WFLO) research branch: First, it provides a convenient and realistic data set of high resolution and accuracy encompassing wind speeds, wind directions, standard deviations of wind directions, and (adjusted) yields for the entire area of Germany. Second, it supplies a set of helper functions and a benchmark function for economically (profit) driven wind farm layout optimization. This enables researchers in the field of the np-hard problem of wflo to focus on their optimization methodology contribution and also provides a realistic benchmark setting for comparability among contributions. 
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck<br />
David Hennecke
</p>

<hr>
<h2 id='AcquireData'>Downloads the larger data set for entire Germany.</h2><span id='topic+AcquireData'></span>

<h3>Description</h3>

<p>Convenience function that downloads the larger data set covering the entire area of Germany and saves it to the specified directory. This data set can replace the smaller sub sample data set that is part of this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AcquireData(Folder)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AcquireData_+3A_folder">Folder</code></td>
<td>

<p>must be a character string containing the folder location to where the file will be saved. For instance, use <code><a href="base.html#topic+getwd">getwd</a></code> to save to the current working directory.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will interactively lead the user through the downloading process and also gives advice on how to use the larger data set. Make sure that R can write to the specified directory.
</p>


<h3>Value</h3>

<p><code>AcquireData</code> returns nothing.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+FarmVars">FarmVars</a></code> for the settings object and <code><a href="#topic+FarmData">FarmData</a></code> for the smaller, built-in data set that is part of this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
AcquireData(tempdir())
# Will download the data file to the specified directory.

## End(Not run)
</code></pre>

<hr>
<h2 id='AirDensity'>Provides convenient computations for air density.</h2><span id='topic+AirDensity'></span>

<h3>Description</h3>

<p>Implements a set of computations and constants to compute air density as a function of altitude (a.s.l.), temperature and relative humidity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AirDensity(Altitude = 0, Temperature = 20, phi = 0.76)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="AirDensity_+3A_altitude">Altitude</code></td>
<td>

<p>altitude in meters above sea level.
</p>
</td></tr>
<tr><td><code id="AirDensity_+3A_temperature">Temperature</code></td>
<td>

<p>temperature in degrees Celsius.
</p>
</td></tr>
<tr><td><code id="AirDensity_+3A_phi">phi</code></td>
<td>

<p>relative humidity, must be within [0, 1].
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first computes air pressure at user provided target altitude based on the barometric formula. Then, saturation vapor pressure is computed using the Magnus formula. With both, the density of air is computed afterward.
</p>


<h3>Value</h3>

<p><code>AirDensity</code> returns a single value representing air density in kg per cubic meter.
</p>


<h3>Note</h3>

<p>This function returns valid values for negative altitudes, but only for temperature values between -45 and +60 degrees Celsius.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WindspeedLog">WindspeedLog</a></code> and <code><a href="#topic+WindspeedHellmann">WindspeedHellmann</a></code> to compute wind speed at target heights using two slightly different established models.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>AirDensity()
AirDensity(300, 25, 0.6)
AirDensity(0, 0, 0) # Standard conditions according to DIN 1343:1990,
                    # returns the expected value of 1.292.
</code></pre>

<hr>
<h2 id='Area'>Computes the overlap area for the partial Jensen wake.</h2><span id='topic+Area'></span>

<h3>Description</h3>

<p>The partial Jensen wake model requires the overlap area of the rotor disc at the downwind location with the wake disc. This function computes it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Area(a, b, d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Area_+3A_a">a</code></td>
<td>

<p>must be a single value. Provide the radius of the first circle in meters.
</p>
</td></tr>
<tr><td><code id="Area_+3A_b">b</code></td>
<td>

<p>must be a single value. Provide the radius of the second circle in meters.
</p>
</td></tr>
<tr><td><code id="Area_+3A_d">d</code></td>
<td>

<p>must be a single value. Provide the distance between the two circles' centers.
</p>
</td></tr>	
</table>


<h3>Details</h3>

<p>If a turbine is downwind another turbine, the wake cone of that upwind turbine may only partially cover the rotor disc of the second turbine. For the partial wake model it is necessary to compute the covered area.
</p>


<h3>Value</h3>

<p><code>Area</code> returns covered area in square meters.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JensenTrapezoid">JensenTrapezoid</a></code> to check whether there are wake effects present. <code><a href="#topic+FarmVars">FarmVars</a></code> for the data object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Area(60, 40, 50)
# Returns 2930.279.
</code></pre>

<hr>
<h2 id='Cost'>Stub for a turbine's cost function.</h2><span id='topic+Cost'></span>

<h3>Description</h3>

<p>A function that returns the yearly installation costs for a given set of turbines (provide x and y for the turbines' locations). In its present form it only returns the 'UnitCost' value from the <code><a href="#topic+FarmVars">FarmVars</a></code> settings object per turbine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cost(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Cost_+3A_x">x</code></td>
<td>

<p>can be a single value or a numeric vector of values, contains the 'x' location(s) of turbines.
</p>
</td></tr>
<tr><td><code id="Cost_+3A_y">y</code></td>
<td>

<p>can be a single value or a numeric vector of values, contains the 'y' location(s) of turbines.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that <code>x</code> and <code>y</code> should both be of length <code>n</code>, i.e. the numbers of values they contain should match the number of turbines in the current wind farm layout problem.<br />
This function is a stub and can and should be replaced by something reasonable in an actual wind farm layout problem.
</p>


<h3>Value</h3>

<p><code>Cost</code> returns a vector of values. The number of elements matches the length of <code>x</code> and <code>y</code>.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Profit">Profit</a></code> to see where to use <code>Cost</code>, <code><a href="#topic+Yield">Yield</a></code> for a similar function for yearly yield.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Returns a vector of two, c(100000, 100000).
Cost(c(0.5, 0.7), c(0.2, 0.3))

## Replace the function by another function
## also called 'Cost', embedded in environment e.
## Also, see the vignette.
## Not run: 
e$Cost &lt;- function(x, y) #x, y \in R^n
{
	retVal &lt;- rep(e$FarmVars$UnitCost, min(length(x), length(y)))
	retVal[x &gt; 0.5] &lt;- retVal[x &gt; 0.5] * 2
	return(retVal)
}
set.seed(1357)
NumTurbines &lt;- 4 # For example.
Result &lt;- pso::psoptim(par = runif(NumTurbines * 2), fn = Profit,
  lower = rep(0, NumTurbines * 2), upper = rep(1, NumTurbines * 2))
Result
rm(Cost, envir = e)

## End(Not run)
</code></pre>

<hr>
<h2 id='e'>Environment for data and variables.</h2><span id='topic+e'></span>

<h3>Description</h3>

<p>Environment that contains variables object <code>FarmVars</code> and, if downloaded, full data set <code>FarmData</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e
</code></pre>


<h3>Details</h3>

<p><code>e</code> contains data and variables, see <code><a href="#topic+FarmVars">FarmVars</a></code> and <code><a href="#topic+FarmData">FarmData</a></code>.
</p>


<h3>Value</h3>

<p><code>e</code> returns the environment for <code>FarmVars</code> and <code>FarmData</code>.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AcquireData">AcquireData</a></code> for downloading the full data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e
## Gives the environment object.
</code></pre>

<hr>
<h2 id='FarmData'>Data set for wind farm layout optimization.</h2><span id='topic+FarmData'></span>

<h3>Description</h3>

<p>This list object contains four matrices covering adjusted yield, wind speed, wind direction and standard deviations of wind directions in Germany.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FarmData
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> object containing seven matrices, each containing 25 x 25 values at a raster resolution of 200 x 200 m (note that for the larger data set downloadable using <code><a href="#topic+AcquireData">AcquireData</a></code>, each matrix contains 4400 x 3250 values):<br />
<br />
<code>$AdjustedYield</code>: Yield is average annual energy production (AEP). According to FGW technical guidelines, AEP is adjusted due to different location qualities to obtain a better guess at the marketable energy output. Interpret these values directly as 'megawatt hours per year'.<br />
<br />
<code>$WindSpeed</code>: Average wind speeds in meters per second.<br />
<br />
<code>$WindDirection</code>: Average wind directions in degrees (azimuth system).<br />
<br />
<code>$SDDirection</code>: Standard deviations of wind directions in degrees (azimuth system).<br />
<br />
<code>$Elevation</code>: Terrain relief (elevation in meters).<br />
<br />
<code>$Slope</code>: Terrain slope in degrees.<br />
<br />
<code>$SlopeDirection</code>: Direction of hillside in degrees.<br />
</p>


<h3>Note</h3>

<p>If the full mode data set is present, it is loaded into the environment <code>e</code>. The built-in data set <code>FarmData</code> contains matrices of dimension 25 x 25, while the full data set <code>e$FarmData</code> consists of 4400 x 3250 matrices.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck<br />
David Hennecke
</p>


<h3>Source</h3>

<p>DWD Climate Data Center (CDC): <a href="ftp://opendata.dwd.de/climate_environment/CDC/grids_germany/multi_annual/wind_parameters/resol_200x200/">ftp://opendata.dwd.de/climate_environment/CDC/grids_germany/multi_annual/wind_parameters/resol_200x200/</a><br />
<br />
FGW Technical Guidelines: <a href="https://wind-fgw.de/shop/technical-guidelines/?lang=en">https://wind-fgw.de/shop/technical-guidelines/?lang=en</a><br />
<br />
Croonenbroeck, C. &amp; Hennecke, D. Does the German renewable energy act provide a fair incentive system for onshore wind power? - A simulation analysis, Energy Policy, 2020, 114, 111663, 1-15, https://doi.org/10.1016/j.enpol.2020.111663
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 'Profit' uses this data set internally:
NumTurbines &lt;- 4
set.seed(1357)
Result &lt;- optim(par = runif(NumTurbines * 2), fn = Profit, method = "L-BFGS-B",
  lower = rep(0, NumTurbines * 2), upper = rep(1, NumTurbines * 2))
Result
PlotResult(Result)
</code></pre>

<hr>
<h2 id='FarmVars'>Variables object for wind farm specifications.</h2><span id='topic+FarmVars'></span>

<h3>Description</h3>

<p>This list object collects all necessary variables for wind farm layout optimizations within this package. The object is loaded upon loading the package, embedded into a user writeable environment <code>e</code> and provides a set of default values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FarmVars
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> object containing:<br />
<br />
<code>$UnitCost</code>: This contains yearly costs per turbine in actual currency. Mostly, this will be installation costs, maintenance cost and others. If, for example, total turbine installation costs are 2 mio. EUR and the projected life span of the turbine is 20 years, then the yearly cost is roughly 100,000 EUR, which is also the default value for this item. Refine the number at will to encompass annuity (taking interest effects into consideration), salvage, or the mentioned maintenance cost.<br />
<br />
<code>$Price</code>: This denotes the average sale price of electricity produced at the wind farm per megawatt hour. Defaults to 100, since 100 EUR per megawatt hour is a good (still rough) estimate in the European electricity market.<br />
<br />
<code>$StartPoint</code>: Denotes the point at which to start to 'cut out' a sample field from the data set. Since the full data set covers the entire region of Germany at a 200 x 200 meters resolution, the entire area is too big for a wind farm. For an actual wind farm layout optimization problem, a smaller region is indicated. This package will conveniently provide a square area of 5 km x 5 km in size. Note: Concerning the larger data set covering the entire area of Germany (conveniently downloadable using <code><a href="#topic+AcquireData">AcquireData</a></code>), this area con be found at point 2000:2000 (full data covering a range of 4400 x 3250 points) and from there, spans a five kilometers square, i.e. covers the raster at 2000:2024, 2000:2024. Change the default value of 1 to 2000 to find that area or to something else for cross checking your algorithm with data covering a different area. However, for comparability, evaluate your algorithm result at the default of 2000 or using the built-in data set.<br />
<br />
<code>$Width</code>: Denotes the width (and, since the test area is a square, also the height) of the test area. Defaults to 25, which leads to a 5 km x 5 km square as a sample wind field, as the raster resolution is 200 x 200 m.<br />
<br />
<code>$MeterMinDist</code>: Denotes the minimum distance from one turbine to another in meters. Defaults to 500 meters, which is a rather conservative value.<br />
<br />
<code>$EndPoint</code>: The complement to '$StartPoint'. Is computed based on '$StartPoint' and '$Width' as follows: FarmVars$StartPoint + FarmVars$Width - 1. By default, $StartPoint = 1 and $Width = 25, so $EndPoint = 1 + 25 - 1 = 25.<br />
<br />
<code>$MeterWidth</code>: Contains the width (and, since the test area is a square, also the height) of the test area in meters. Since by default, FarmVars$Width = 25 and the raster resolution is 200 x 200 m, this defaults to $MeterWidth = 200 * 25 = 5000 meters (5 km).<br />
<br />
<code>$MinDist</code>: Contains the minimum distance in problem space. Since the problem space in a convenient unit square, this defaults to $MinDist = MeterMinDist / MeterWidth = 500 / 5000 = 0.1.<br />
<br />
<code>$z</code>: Contains the hub height of the turbine type under investigation. Default value is 100 meters.<br />
<br />
<code>$z0</code>: Contains the terrain's roughness length required for Jensen's wake model. In most studies, a default value of 0.1 is agreed to be a good guess for onshore wind farms, so this is the default value here.<br />
<br />
<code>$r0</code>: Contains the rotor radius for the turbine type under investigation. For instance, a Vestas V90 turbine has a rotor diameter of 90 meters (hence the name), so the radius is 45 mesters, which is also the default value here.<br />
<br />
<code>Partial</code>:
Selects whether to incorporate partial Jensen wake or not. Defaults to TRUE.<br />
<br />
<code>$BenchmarkSolution</code>: Contains the best setup for the standard benchmark field at a task of placing 20 turbines. This result has been generated by optimizer <code>genoud()</code> from package <code>rgenoud</code>. It should serve as a benchmark or starting point for improved solutions. e$FarmVars$BenchmarkSolution is taken from Croonenbroeck &amp; Hennecke (2020). Note, however, that the computed profit is a little less than the 12,053,607 EUR reported there, since, starting from version 1.6, wflo by default takes partial Jensen wake effects into account. This does however in no way constrain the representativeness of e$FarmVars$BenchmarkSolution.
</p>


<h3>Source</h3>

<p>Carsten Croonenbroeck</p>


<h3>References</h3>

<p>Croonenbroeck, C. &amp; Hennecke, D. A Comparison of Optimizers in a Unified Standard for Optimization on Wind Farm Layout Optimization, Energy, 2020, 119244, 1-15, https://doi.org/10.1016/j.energy.2020.119244</p>


<h3>Examples</h3>

<pre><code class='language-R'># Inspect the benchmark solution by
Result &lt;- list(par = e$FarmVars$BenchmarkSolution)
Profit(Result$par)
PlotResult(Result)
ShowWakePenalizers(Result)
</code></pre>

<hr>
<h2 id='GaussWS'>Convenience function to look-up values from a object returned by GenerateGauss.</h2><span id='topic+GaussWS'></span>

<h3>Description</h3>

<p>Dependent on the resolution at which <code><a href="#topic+GenerateGauss">GenerateGauss</a></code> was set to use, the resolution coordinates (array indices) cannot immediately be interpreted as being measured in meters. This function returns wind speeds from the Gauss object accoring to x, y, z simply provided in meters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussWS(Gauss, x, y, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GaussWS_+3A_gauss">Gauss</code></td>
<td>

<p>must be an object returned by <code><a href="#topic+GenerateGauss">GenerateGauss</a></code>.
</p>
</td></tr>
<tr><td><code id="GaussWS_+3A_x">x</code></td>
<td>

<p>must be a single value. Provide desired distance in meters.
</p>
</td></tr>
<tr><td><code id="GaussWS_+3A_y">y</code></td>
<td>

<p>must be a single value. Provide desired distance in meters. May be negative.
</p>
</td></tr>
<tr><td><code id="GaussWS_+3A_z">z</code></td>
<td>

<p>must be a single value. Provide desired distance in meters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gaussian wake model is loosely based on the initial contribution by Bastankhah &amp; Porte-Agel (2014).
</p>


<h3>Value</h3>

<p><code>GaussWS</code> returns a single number which can be considered a wind speed in the wake of a turbine at location x, y, and z.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>References</h3>

<p>Bastankhah, M., &amp; Porte-Agel, F. (2014). A new analytical model for wind-turbine wakes. Renewable Energy, 70, 116-123.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+GenerateGauss">GenerateGauss</a></code> to compute the three-dimensional tensor array object containing the wind speed data. See <code><a href="#topic+QuickGauss3D">QuickGauss3D</a></code> for the same algorithm, immediately returning the wind speed at one single point only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
GaussWS(Gauss, 100, 1, 100)
GaussWS(Gauss, 80, -40, 90)
GaussWS(Gauss, 200, 40, 150)

## End(Not run)
</code></pre>

<hr>
<h2 id='GenerateGauss'>For an incoming wind speed at reference height, this function computes a 3D tensor object containing Gaussian model based wind speeds.</h2><span id='topic+GenerateGauss'></span>

<h3>Description</h3>

<p>This function pre-computes Gaussian wind speeds and stores them in a 3D array, similar to voxels. Using that 'table', wind speeds can be looked up very quickly, which makes Gaussian wake feasible during WFLO runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GenerateGauss(u = 8, refHeight = 10, maxX = 500, resY = 100,
resZ = 100, Verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GenerateGauss_+3A_u">u</code></td>
<td>

<p>measured wind speed at reference height. Will mostly be measured in meters per second.
</p>
</td></tr>
<tr><td><code id="GenerateGauss_+3A_refheight">refHeight</code></td>
<td>

<p>reference height in meters. This is the height at which the incoming wind speed u is measured.
</p>
</td></tr>
<tr><td><code id="GenerateGauss_+3A_maxx">maxX</code></td>
<td>

<p>the number of steps down the x axis for which to compute the model.
</p>
</td></tr>
<tr><td><code id="GenerateGauss_+3A_resy">resY</code></td>
<td>

<p>the number of steps along the y axis for which to compute the model. Note that as y may take negative values, the resolution space should be chosen not too small, here. If, e.g., resY = 100, this means that y may take values from -50 to 50, which may be too low a resolution in some cases.
</p>
</td></tr>
<tr><td><code id="GenerateGauss_+3A_resz">resZ</code></td>
<td>

<p>the number of steps up the z axis for which to compute the model.
</p>
</td></tr>
<tr><td><code id="GenerateGauss_+3A_verbose">Verbose</code></td>
<td>

<p>selectes whether the function displays status reports during computation, as it may take some time, dependent on the resolution setting.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users may choose to compute a rather fine resolution run over night and then save the returned object so it can be loaded in future sessions. The Gaussian wake model is loosely based on the initial contribution by Bastankhah &amp; Porte-Agel (2014).
</p>


<h3>Value</h3>

<p><code>GenerateGauss</code> returns the three-dimensional array containing wind speeds.
</p>


<h3>Note</h3>

<p>Note that the model assumes that along the x axis, x = 0 is the turbine location. x expands along the wind direction downwind. y denoted whether a point is 'left' or 'right' the x axis. Thus, the x-z plane is the plane along the x axis and perpendicular to the ground. The z axis is hight, starting at 0 = ground level.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>References</h3>

<p>Bastankhah, M., &amp; Porte-Agel, F. (2014). A new analytical model for wind-turbine wakes. Renewable Energy, 70, 116-123.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+GaussWS">GaussWS</a></code> for a convenience function to look-up the values from the returned array. See <code><a href="#topic+QuickGauss3D">QuickGauss3D</a></code> for the same algorithm, immediately returning the wind speed at one single point only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Gauss &lt;- GenerateGauss(maxX = 500, resY = 1000, resZ = 1000)

## End(Not run)
</code></pre>

<hr>
<h2 id='Geo2Ari'>Converts degrees between the arithmetic system and the azimuth system (and vice versa).</h2><span id='topic+Geo2Ari'></span>

<h3>Description</h3>

<p>Use this function to convert degrees from the arithmetic system (0° being east, ascending counterclockwise) into the azimuth system (0° being north, ascending clockwise) and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Geo2Ari(g)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Geo2Ari_+3A_g">g</code></td>
<td>

<p>contains a single value degree (usually between 0° and 360°, decimal fractions allowed).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>g</code> may contain degrees from both systems, the function turns the data into the respective other system.
</p>


<h3>Value</h3>

<p><code>Geo2Ari</code> returns a single value of degrees.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GetDirInfo">GetDirInfo</a></code> for further degree information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Geo2Ari(0)
## In an arithmetic system, 0° means 'east', while 'east' in
## azimuth notation is 90°. This call returns 90.
Geo2Ari(90)
## In an azimuth system, 90° means 'east', while 'east' in
## arithmetic notation is 0°. This call returns 0.
Geo2Ari(Geo2Ari(123))
## Returns 123.
</code></pre>

<hr>
<h2 id='GetAngle'>Returns the angle between two turbines.</h2><span id='topic+GetAngle'></span>

<h3>Description</h3>

<p>As seen from a point in the wind farm, computes the angle to another point in that farm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetAngle(x1, y1, x2, y2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetAngle_+3A_x1">x1</code></td>
<td>

<p>must be a single value. Provide the <code>x</code> location of the first turbine.
</p>
</td></tr>
<tr><td><code id="GetAngle_+3A_y1">y1</code></td>
<td>

<p>must be a single value. Provide the <code>y</code> location of the first turbine.
</p>
</td></tr>
<tr><td><code id="GetAngle_+3A_x2">x2</code></td>
<td>

<p>must be a single value. Provide the <code>x</code> location of the second turbine.
</p>
</td></tr>
<tr><td><code id="GetAngle_+3A_y2">y2</code></td>
<td>

<p>must be a single value. Provide the <code>y</code> location of the second turbine.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From point 2's point of view, computes the angle to point 1.
</p>


<h3>Value</h3>

<p><code>GetAngle</code> returns a single number between 0 and 360. If both points are identical, the return value is 0.
</p>


<h3>Note</h3>

<p>Note that this function returns an angle in arithmetic degrees notation. To convert to azimuth notation, use <code><a href="#topic+Geo2Ari">Geo2Ari</a></code>.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+JensenAngle">JensenAngle</a></code> to compute the wake cone and with it, use <code><a href="#topic+JensenTrapezoid">JensenTrapezoid</a></code> to see if another turbine B is in turbine A's wake.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GetAngle(0.2, 0.2, 0.1, 0.1)
## Looking from point (0.1, 0.1) at point (0.2, 0.2), the angle is 45° (arithmetic).
</code></pre>

<hr>
<h2 id='GetArrow'>Simple helper function for <code><a href="#topic+PlotResult">PlotResult</a></code>.</h2><span id='topic+GetArrow'></span>

<h3>Description</h3>

<p>Given a point, an angle information (in arithmetic degrees), and a length information, computes start and end points of an arrow usable via the <code><a href="graphics.html#topic+arrows">arrows</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetArrow(BaseX, BaseY, Degrees, Frac = 25)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetArrow_+3A_basex">BaseX</code></td>
<td>

<p>must be a single value containing the x value of a point which later will be the center of the arrow.
</p>
</td></tr>
<tr><td><code id="GetArrow_+3A_basey">BaseY</code></td>
<td>

<p>must be a single value containing the y value of a point which later will be the center of the arrow.
</p>
</td></tr>
<tr><td><code id="GetArrow_+3A_degrees">Degrees</code></td>
<td>

<p>must be a single value containing the desired rotation degree of the arrow.
</p>
</td></tr>
<tr><td><code id="GetArrow_+3A_frac">Frac</code></td>
<td>

<p>must be a single value containing the length of the arrow. Default is 25 and for convenience, this parameter should in most cases be identical to FarmVars$Width.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will be used internally by <code><a href="#topic+PlotResult">PlotResult</a></code>.
</p>


<h3>Value</h3>

<p><code>GetArrow</code> returns a vector of four values representing x and y for the start point and x and y for the end point of an arrow (in that order).
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+PlotResult">PlotResult</a></code> to visualize the optimization result. See <code><a href="#topic+FarmVars">FarmVars</a></code> for the data object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GetArrow(0.5, 0.5, 45)
#At c(0.5, 0.5), generates an arrow pointing in north-eastern direction.
</code></pre>

<hr>
<h2 id='GetDirInfo'>Returns average wind direction and direction standard deviation for a turbine's location.</h2><span id='topic+GetDirInfo'></span>

<h3>Description</h3>

<p>For a turbine's location represented by <code>x</code> and <code>y</code>, looks up the wind direction from the matrix <code>Dirs</code> and the corresponding standard deviation from matrix <code>SDs</code>. Internally transforms coordinates of <code>x</code> and <code>y</code> from problem space (usually unit square) to the matrix space of <code>Dirs</code> and <code>SDs</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetDirInfo(x, y, Dirs, SDs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetDirInfo_+3A_x">x</code></td>
<td>

<p>must be a single value containing the 'x' location of a turbine in problem space.
</p>
</td></tr>
<tr><td><code id="GetDirInfo_+3A_y">y</code></td>
<td>

<p>must be a single value containing the 'y' location of a turbine in problem space.
</p>
</td></tr>
<tr><td><code id="GetDirInfo_+3A_dirs">Dirs</code></td>
<td>

<p>a matrix containing average yearly wind directions. Usually, the third element of the list object <code><a href="#topic+FarmData">FarmData</a></code> will be used as this matrix.
</p>
</td></tr>
<tr><td><code id="GetDirInfo_+3A_sds">SDs</code></td>
<td>

<p>a matrix containing average yearly wind direction standard deviations. Usually, the fourth element of the list object <code><a href="#topic+FarmData">FarmData</a></code> will be used as this matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>GetDirInfo</code> returns a vector of two elements, the first being the average wind direction in degrees and the second being the corresponding standard deviation. Note that degrees are meant in the arithmetic degrees system (0° being east, ascending counterclockwise). To transform into an azimuth system (0° being north, ascending clockwise), use function <code><a href="#topic+Geo2Ari">Geo2Ari</a></code>. Also note that wind directions are meant to denote 'where the wind is going to' rather than 'where the wind is coming from'.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Profit">Profit</a></code> to see where to use <code>GetDirInfo</code>, <code><a href="#topic+Yield">Yield</a></code> for a similar function for adjusted yield. See <code><a href="#topic+FarmVars">FarmVars</a></code> for the data object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Dirs &lt;- FarmData[[3]][e$FarmVars$StartPoint:e$FarmVars$EndPoint,
e$FarmVars$StartPoint:e$FarmVars$EndPoint]
SDs &lt;- FarmData[[4]][e$FarmVars$StartPoint:e$FarmVars$EndPoint,
e$FarmVars$StartPoint:e$FarmVars$EndPoint]
GetDirInfo(0.5, 0.7, Dirs, SDs)
## Returns wind direction and standard deviation for the given location
## and provided the matrices given.
</code></pre>

<hr>
<h2 id='GetFarmFromLonLat'>Accesses full FarmData set and returns a compatible list object for the requested location.</h2><span id='topic+GetFarmFromLonLat'></span>

<h3>Description</h3>

<p>This function accepts a pair longitude (decimal system, east) and latitude (decimal system, north) coordinates as well a a desired edge length in m and if valid, returns a list object similar to <code><a href="#topic+FarmData">FarmData</a></code>, but at the specified location and with the specified size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetFarmFromLonLat(Top, Left, EdgeLen, DoPlot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GetFarmFromLonLat_+3A_top">Top</code></td>
<td>

<p>longitude value (decimal system, east).
</p>
</td></tr>
<tr><td><code id="GetFarmFromLonLat_+3A_left">Left</code></td>
<td>

<p>latitude value (decimal system, north).
</p>
</td></tr>
<tr><td><code id="GetFarmFromLonLat_+3A_edgelen">EdgeLen</code></td>
<td>

<p>edge length in meters. Note that the returned farm data object is always a square area and thus, contains square matrices.
</p>
</td></tr>
<tr><td><code id="GetFarmFromLonLat_+3A_doplot">DoPlot</code></td>
<td>

<p>optionally plots the annual energy production (AEP) 'landscape' in the returned object using a <code><a href="grDevices.html#topic+terrain.colors">terrain.colors</a></code> coloring scheme, together with a color key.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires that the full <code><a href="#topic+FarmData">FarmData</a></code> dataset is loaded. See <code><a href="#topic+AcquireData">AcquireData</a></code> on how to obtain it.
</p>


<h3>Value</h3>

<p>Returns a list object following the structure of <code><a href="#topic+FarmData">FarmData</a></code>, but only containing the farm area starting from the top-left point specified and as many 'tiles' required to meet the desired edge length at 200 m tiles resolution.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+Index2GK">Index2GK</a></code> to convert index coordinates to Gauss-Kruger coordinates, and <code><a href="#topic+GK2LonLat">GK2LonLat</a></code> to convert Gauss-Kruger coordinates to longitude/latitude coordinates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This will return a farm at the specified location, edge length 5,000 m (5 km).
# Requires full data set to be loaded.
## Not run: 
MyFarm &lt;- GetFarmFromLonLat(51.49594, 11.58818, 5000, DoPlot = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='GK2Index'>Converts Gauss-Kruger coordinates to FarmData indices.</h2><span id='topic+GK2Index'></span>

<h3>Description</h3>

<p>This function accepts Gauss-Kruger (GK) coordinates that are within the FarmData space and converts them to a pair of indices that point to locations within the FarmData matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GK2Index(X, Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GK2Index_+3A_x">X</code></td>
<td>

<p>a numeric value for the 'right' value in the GK coordinate system.
</p>
</td></tr>
<tr><td><code id="GK2Index_+3A_y">Y</code></td>
<td>

<p>a numeric value for the 'top' value in the GK coordinate system.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes that the GK zone is EPSG 31467. References to indices valid if the full data set is loaded, see <code><a href="#topic+FarmData">FarmData</a></code> and <code><a href="#topic+AcquireData">AcquireData</a></code>.
</p>


<h3>Value</h3>

<p>Returns index values between 1 and 3,250 for X and between 1 and 4,400 for Y.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Index2GK">Index2GK</a></code> for the inverse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>GK2Index(3280000, 5230000) # Will return c(1, 4400), the lower left point.
GK2Index(3929800, 6109800) # Will return c(3250, 1), the top right point.
</code></pre>

<hr>
<h2 id='GK2LonLat'>Converts Gauss-Kruger coordinates to longitude/latitude coordinates.</h2><span id='topic+GK2LonLat'></span>

<h3>Description</h3>

<p>This function accepts a pair of Gauss-Kruger (GK) coordinates and converts them to longitude (decimal system, east) and latitude (decimal system, north) coordinates by performing re-projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GK2LonLat(X, Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GK2LonLat_+3A_x">X</code></td>
<td>

<p>a numeric value for the 'right' value in the GK coordinate system.
</p>
</td></tr>
<tr><td><code id="GK2LonLat_+3A_y">Y</code></td>
<td>

<p>a numeric value for the 'top' value in the GK coordinate system.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes that the GK zone is EPSG 31467.
</p>


<h3>Value</h3>

<p>Returns a vector of two values where longitude is first, latitude second.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+LonLat2GK">LonLat2GK</a></code> for the inverse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LonLat &lt;- GK2LonLat(3702793, 5998319) # Will return c(12.09750, 54.07547).
</code></pre>

<hr>
<h2 id='Height'>Returns the elevation of a turbine's location.</h2><span id='topic+Height'></span>

<h3>Description</h3>

<p>For a turbine's location represented by <code>x</code> and <code>y</code>, looks up the elevation from the matrix <code>Elev</code>. Internally transforms coordinates of <code>x</code> and <code>y</code> from problem space (usually unit square) to the matrix space of <code>Elev</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Height(x, y, Elev)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Height_+3A_x">x</code></td>
<td>

<p>must be a single value containing the 'x' location of a turbine in problem space.
</p>
</td></tr>
<tr><td><code id="Height_+3A_y">y</code></td>
<td>

<p>must be a single value containing the 'y' location of a turbine in problem space.
</p>
</td></tr>
<tr><td><code id="Height_+3A_elev">Elev</code></td>
<td>

<p>a matrix containing heights. Usually, the fifth element of the list object <code><a href="#topic+FarmData">FarmData</a></code> will be used as this matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Height is a convenience function for looking up heights as required e.g. for a partial Jensen wake model, independent from the actual size of the area under investigation.
</p>


<h3>Value</h3>

<p><code>Height</code> returns a single value, the elevation in meters.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Profit">Profit</a></code> to see where to use <code>Height</code>. See <code><a href="#topic+FarmData">FarmData</a></code> for the data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Returns adjusted yield for the given location.
P &lt;- c(0.5868695, 0.9722714)
Height(P[1], P[2], FarmData[[5]][e$FarmVars$StartPoint:e$FarmVars$EndPoint,
    e$FarmVars$StartPoint:e$FarmVars$EndPoint])
</code></pre>

<hr>
<h2 id='ImposeVectorField'>Simple helper function for <code><a href="#topic+PlotResult">PlotResult</a></code>.</h2><span id='topic+ImposeVectorField'></span>

<h3>Description</h3>

<p>Draws a set of arrows over an existing plot. Will be used internally by <code><a href="#topic+PlotResult">PlotResult</a></code> to visualize the vector field of wind directions over a plot of the wind farm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ImposeVectorField(xNum = 5, yNum = 5, ColMain = "black",
  ColBand = "white", Frac = 25, DoSDs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ImposeVectorField_+3A_xnum">xNum</code></td>
<td>

<p>must be a single value containing the desired number of arrows horizontally.
</p>
</td></tr>
<tr><td><code id="ImposeVectorField_+3A_ynum">yNum</code></td>
<td>

<p>must be a single value containing the desired number of arrows vertically.
</p>
</td></tr>
<tr><td><code id="ImposeVectorField_+3A_colmain">ColMain</code></td>
<td>

<p>must be a single value containing the desired color for the main wind direction arrow.
</p>
</td></tr>
<tr><td><code id="ImposeVectorField_+3A_colband">ColBand</code></td>
<td>

<p>must be a single value containing the desired color for the secondary arrows representing the standard deviation arrows. Only used if <code>DoSDs = TRUE</code>.
</p>
</td></tr>
<tr><td><code id="ImposeVectorField_+3A_frac">Frac</code></td>
<td>

<p>must be a single value containing the desired length information for the arrows. Will be passed to <code><a href="#topic+GetArrow">GetArrow</a></code> internally.
</p>
</td></tr>
<tr><td><code id="ImposeVectorField_+3A_dosds">DoSDs</code></td>
<td>

<p>must be <code>TRUE</code> or <code>FALSE</code>. If <code>TRUE</code>, will not only draw one arrow for the main wind direction per point, but also two additional arrows (using color <code>ColBand</code>) representing the main wind direction plus/minus half the standard deviation.
</p>
</td></tr>	
</table>


<h3>Details</h3>

<p>This function will be used internally by <code><a href="#topic+PlotResult">PlotResult</a></code>.<br />
<code>ImposeVectorField</code> requires <code><a href="#topic+FarmData">FarmData</a></code> to be present and an existing plot to impose the vector field over.
</p>


<h3>Value</h3>

<p><code>ImposeVectorField</code> returns nothing.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+PlotResult">PlotResult</a></code> to visualize the optimization result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(c(0, 1), c(0, 1))
ImposeVectorField(ColBand = "red")
</code></pre>

<hr>
<h2 id='Index2GK'>Converts FarmData indices to Gauss-Kruger coordinates.</h2><span id='topic+Index2GK'></span>

<h3>Description</h3>

<p>This function accepts indices that are within the FarmData space and converts them to a pair of Gauss-Kruger (GK) coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Index2GK(X, Y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Index2GK_+3A_x">X</code></td>
<td>

<p>a numeric value for the 'X' value in the FarmData space.
</p>
</td></tr>
<tr><td><code id="Index2GK_+3A_y">Y</code></td>
<td>

<p>a numeric value for the 'Y' value in the FarmData space.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes that the GK zone is EPSG 31467. References to indices are valid if the full data set is loaded, see <code><a href="#topic+FarmData">FarmData</a></code> and <code><a href="#topic+AcquireData">AcquireData</a></code>.
</p>


<h3>Value</h3>

<p>For index values between 1 and 3,250 for X and between 1 and 4,400 for Y, returns Gauss-Kruger coordinates valid in the EPSG 31467 coordinate system.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GK2Index">GK2Index</a></code> for the inverse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Index2GK(1, 4400) # Will return c(3280000, 5230000), the lower left point.
Index2GK(3250, 1) # Will return c(3929800, 6109800), the top right point.
</code></pre>

<hr>
<h2 id='JensenAngle'>For a given distance <code>x</code>, computes the wake cone generated by a turbine.</h2><span id='topic+JensenAngle'></span>

<h3>Description</h3>

<p>In Jensen's wake model, a wake cone is generated by a turbine based on the turbine's hub height z, its rotor radius r_0, the terrain's roughness length z_0 and the distance x between the turbine under investigation and a certain second point. z, r_0 and z_0 are taken from the <code><a href="#topic+FarmVars">FarmVars</a></code> settings object, while x is to be provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JensenAngle(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JensenAngle_+3A_x">x</code></td>
<td>

<p>must be a single value. Provide distance in meters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a second turbine (B) is in a first turbine (A)'s wake, turbine B's power output must be penalized due to turbulence. This can be performed via Jensen's wake model, but first, it should be checked whether B is actually in A's wake. This function computes the angle of the wake cone generated by turbine A. This can be used together with function <code><a href="#topic+JensenTrapezoid">JensenTrapezoid</a></code> <code><a href="#topic+PointInPolygon">PointInPolygon</a></code> and  to see if B is in the wake of A.
</p>


<h3>Value</h3>

<p><code>JensenAngle</code> returns the (onesided) angle of the wake cone generated by a turbine for distance <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>References</h3>

<p>Jensen, N. O. (1983). A note on wind generator interaction. Roskilde: Risø National Laboratory. Risø-M, No. 2411
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JensenTrapezoid">JensenTrapezoid</a></code> to check whether there are wake effects present. <code><a href="#topic+FarmVars">FarmVars</a></code> for the data object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>JensenAngle(500)
## For a distance of 500 m, the function returns a wake cone angle of 9.2233 degrees
## (given standard values for z, z_0 and r_0 in the FarmVars settings object).
</code></pre>

<hr>
<h2 id='JensenFactor'>For a given distance <code>x</code>, computes the penalty factor for a turbine's wake.</h2><span id='topic+JensenFactor'></span>

<h3>Description</h3>

<p>In Jensen's wake model, a wake cone is generated by a turbine based on the turbine's hub height z, its rotor radius r_0, the terrain's roughness length z_0 and the distance x between the turbine under investigation and a certain second point. z, r_0 and z_0 are taken from the <code><a href="#topic+FarmVars">FarmVars</a></code> settings object, while x is to be provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JensenFactor(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JensenFactor_+3A_x">x</code></td>
<td>

<p>must be a single value. Provide distance in meters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a second turbine (B) is in a first turbine (A)'s wake, turbine B's power output must be penalized due to turbulence. This function computes the penalty factor for that wake.
</p>


<h3>Value</h3>

<p><code>JensenFactor</code> returns the a single number between 0 and 1, which can immediately be used a a penalty factor.
</p>


<h3>Note</h3>

<p>Note that for Jensen's multiple wake model, wake penalties from several potentially influencing upwind turbines must be computed. As the factors are between 0 and 1, they can conveniently multiplied by each other afterward. If there are four turbines (A, B, C, D) inside a wind farm, you are investigating turbine D and it turns out that D is in the wake of B and C, but not A, then compute penalty for B (assume 0.7) and C (assume 0.8). Now, the penalty factors for A, B and C are 1, 0.7 and 0.8, so 1 * 0.7 * 0.8 = 0.56 is the penalty for turbine D.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>References</h3>

<p>Jensen, N. O. (1983). A note on wind generator interaction. Roskilde: Risø National Laboratory. Risø-M, No. 2411
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+JensenAngle">JensenAngle</a></code> to compute the wake cone and with it, use <code><a href="#topic+JensenTrapezoid">JensenTrapezoid</a></code> to see if another turbine B is in turbine A's wake. Apply <code>JensenFactor</code> only if this is the case.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>JensenFactor(500)
## Provided that turbine B is in turbine A's wake and that the two turbines are 500 meters apart,
## turbine B must be penalized by a factor of 0.7952.
</code></pre>

<hr>
<h2 id='JensenTrapezoid'>Computes the four corner points of a Jensen trapezoid (or cone).</h2><span id='topic+JensenTrapezoid'></span>

<h3>Description</h3>

<p>Provided a wind direction, a point and a downwind length, computes the corner points of a Jensen trapezoid (in the literature oftentimes called a 'cone').
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JensenTrapezoid(WindDir, Point, x, Margin = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JensenTrapezoid_+3A_winddir">WindDir</code></td>
<td>

<p>unique value, a wind direction in degrees.
</p>
</td></tr>
<tr><td><code id="JensenTrapezoid_+3A_point">Point</code></td>
<td>

<p>a vector of two containing x and y coordinates of a point. Usually, both will be between 0 and 1.
</p>
</td></tr>
<tr><td><code id="JensenTrapezoid_+3A_x">x</code></td>
<td>

<p>downwind distance of the cone in meters.
</p>
</td></tr>
<tr><td><code id="JensenTrapezoid_+3A_margin">Margin</code></td>
<td>

<p>specified whether to add a small margin to the distance parameter (i.e. internally, compute x * 1.1). Defaults to TRUE.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>JensenTrapezoid</code> returns a matrix of four columns (the four corner points) and two rows (x and y coordinates).
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>References</h3>

<p>Jensen, N. O. (1983). A note on wind generator interaction. Roskilde: Riso National Laboratory. Riso-M, No. 2411
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JensenAngle">JensenAngle</a></code> to compute 'cone' angle information, <code><a href="#topic+PointInPolygon">PointInPolygon</a></code> for a test whether a point is inside a polygon.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MyTrapezoid &lt;- JensenTrapezoid(45, c(0.5, 0.5), 500)
</code></pre>

<hr>
<h2 id='LonLat2GK'>Converts longitude/latitude coordinates to Gauss-Kruger coordinates.</h2><span id='topic+LonLat2GK'></span>

<h3>Description</h3>

<p>This function accepts a pair longitude (decimal system, east) and latitude (decimal system, north) coordinates and converts them to Gauss-Kruger (GK) coordinates by performing re-projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LonLat2GK(Lon, Lat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LonLat2GK_+3A_lon">Lon</code></td>
<td>

<p>longitude value (decimal system, east).
</p>
</td></tr>
<tr><td><code id="LonLat2GK_+3A_lat">Lat</code></td>
<td>

<p>latitude value (decimal system, north).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting values are in GK zone EPSG 31467.
</p>


<h3>Value</h3>

<p>Returns a vector of two values where X is first, Y second.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GK2LonLat">GK2LonLat</a></code> for the inverse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LonLat2GK(12.09750, 54.07548) # Will return c(3702793, 5998320).
</code></pre>

<hr>
<h2 id='MosettiTurbineCost'>Returns Mosetti's cost model for a number of turbines.</h2><span id='topic+MosettiTurbineCost'></span>

<h3>Description</h3>

<p>This function returns the dimensionless cost based on Mosetti et al. (1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MosettiTurbineCost(N)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MosettiTurbineCost_+3A_n">N</code></td>
<td>

<p>number of turbines for which cost is to be computed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Wind farm cost does not increase linearly with the number of turbines. Economies of scale lead to disproportionate cost increases. This function returns the dimensionless cost based on Mosetti et al. (1994).
</p>


<h3>Value</h3>

<p><code>MosettiTurbineCost</code> returns a dimensionless cost factor.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>References</h3>

<p>G. Mosetti, C. Poloni, B. Diviacco (1994). Optimization of wind turbine positioning in large windfarms by means of a genetic algorithm, Journal of Wind Engineering and Industrial Aerodynamics, 51(1), 105-116.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Cost">Cost</a></code> for a plug-in cost function for profit.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>MosettiTurbineCost(1)
MosettiTurbineCost(20)
</code></pre>

<hr>
<h2 id='PairPenalty'>Returns the Jensen wake penalty factor for a pair of turbines.</h2><span id='topic+PairPenalty'></span>

<h3>Description</h3>

<p>As seen from a turbine in the wind farm, computes the wake penalty factor for another turbine in that farm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PairPenalty(x1, y1, x2, y2, Dirs, SDs)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PairPenalty_+3A_x1">x1</code></td>
<td>

<p>must be a single value. Provide the <code>x</code> location of the first turbine.
</p>
</td></tr>
<tr><td><code id="PairPenalty_+3A_y1">y1</code></td>
<td>

<p>must be a single value. Provide the <code>y</code> location of the first turbine.
</p>
</td></tr>
<tr><td><code id="PairPenalty_+3A_x2">x2</code></td>
<td>

<p>must be a single value. Provide the <code>x</code> location of the second turbine.
</p>
</td></tr>
<tr><td><code id="PairPenalty_+3A_y2">y2</code></td>
<td>

<p>must be a single value. Provide the <code>y</code> location of the second turbine.
</p>
</td></tr>
<tr><td><code id="PairPenalty_+3A_dirs">Dirs</code></td>
<td>

<p>a matrix containing average yearly wind directions. Usually, the third element of the list object <code><a href="#topic+FarmData">FarmData</a></code> will be used as this matrix.
</p>
</td></tr>
<tr><td><code id="PairPenalty_+3A_sds">SDs</code></td>
<td>

<p>a matrix containing average yearly wind direction standard deviations. Usually, the fourth element of the list object <code><a href="#topic+FarmData">FarmData</a></code> will be used as this matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>First, this function uses <code><a href="#topic+GetAngle">GetAngle</a></code> to compute the angle between the two points provided, as seen from point 2's point of view. It then obtains the wind direction at point 2 using <code><a href="#topic+GetDirInfo">GetDirInfo</a></code>. After that, the distance between the two points is computed. With it, the wake cone is computed using <code><a href="#topic+JensenAngle">JensenAngle</a></code> to check whether point 2 is in point 1's wake using <code><a href="#topic+JensenTrapezoid">JensenTrapezoid</a></code>. If that is the case, <code><a href="#topic+JensenFactor">JensenFactor</a></code> is used to compute the penalty factor.<br />
Note that the penalty is the deduction to wind speed. It applies to wind power by its third power, so the user is responsible to take it to its cube himself. <code><a href="#topic+Profit">Profit</a></code> does that automatically internally.
</p>


<h3>Value</h3>

<p><code>PairPenalty</code> returns a single number between 0 and 1. If point 2 is not in the wake of point 1, the function returns 1.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+JensenFactor">JensenFactor</a></code> to see how this function operates. See <code><a href="#topic+FarmVars">FarmVars</a></code> for the data object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Dirs &lt;- FarmData[[3]][e$FarmVars$StartPoint:e$FarmVars$EndPoint,
e$FarmVars$StartPoint:e$FarmVars$EndPoint]
SDs &lt;- FarmData[[4]][e$FarmVars$StartPoint:e$FarmVars$EndPoint,
e$FarmVars$StartPoint:e$FarmVars$EndPoint]
PairPenalty(0.9, 0.8, 0.6, 0.9, Dirs, SDs)
## Weak wake penalty
PairPenalty(0.1, 0.1, 0.6, 0.9, Dirs, SDs)
## No wake penalty
</code></pre>

<hr>
<h2 id='PartialJensen'>Computes the partial Jensen wake effect.</h2><span id='topic+PartialJensen'></span>

<h3>Description</h3>

<p>If a rotor disc of a first turbine is only partially covered by a wake cone of a second turbine, the penalty must be adjusted accordingly. This function returns partial penalties, if partial wake applies, or full penalty, if not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PartialJensen(x2, y2, x1, y1, Dirs, SDs, Elev, Z = NULL, DrawTop = FALSE,
DrawFront = FALSE, DrawSide = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PartialJensen_+3A_x1">x1</code></td>
<td>

<p>must be a single value. Provide the <code>x</code> location of the first turbine.
</p>
</td></tr>
<tr><td><code id="PartialJensen_+3A_y1">y1</code></td>
<td>

<p>must be a single value. Provide the <code>y</code> location of the first turbine.
</p>
</td></tr>
<tr><td><code id="PartialJensen_+3A_x2">x2</code></td>
<td>

<p>must be a single value. Provide the <code>x</code> location of the second turbine.
</p>
</td></tr>
<tr><td><code id="PartialJensen_+3A_y2">y2</code></td>
<td>

<p>must be a single value. Provide the <code>y</code> location of the second turbine.
</p>
</td></tr>
<tr><td><code id="PartialJensen_+3A_dirs">Dirs</code></td>
<td>

<p>a matrix containing average yearly wind directions. Usually, the third element of the list object <code><a href="#topic+FarmData">FarmData</a></code> will be used as this matrix.
</p>
</td></tr>
<tr><td><code id="PartialJensen_+3A_sds">SDs</code></td>
<td>

<p>a matrix containing average yearly wind direction standard deviations. Usually, the fourth element of the list object <code><a href="#topic+FarmData">FarmData</a></code> will be used as this matrix.
</p>
</td></tr>
<tr><td><code id="PartialJensen_+3A_elev">Elev</code></td>
<td>

<p>a matrix containing elevations. Usually, the fifth element of the list object <code><a href="#topic+FarmData">FarmData</a></code> will be used as this matrix.
</p>
</td></tr>
<tr><td><code id="PartialJensen_+3A_z">Z</code></td>
<td>

<p>accepts a vector of two representing the heights of the turbines at the two points in meters. If <code>NULL</code> (the default), <code>PartialJensen</code> uses <code>e$FarmVars$z</code> as the heights information for both points. In all cases, the heights are added to the terrain topography information from <code>Elev</code>.
</p>
</td></tr>
<tr><td><code id="PartialJensen_+3A_drawtop">DrawTop</code></td>
<td>

<p>If <code>TRUE</code>, draws a top view of the partial wake situation. Defaults to <code>FALSE</code>. Should not be <code>TRUE</code> at the same time as <code>DrawFront</code> or <code>DrawSide</code>.
</p>
</td></tr>
<tr><td><code id="PartialJensen_+3A_drawfront">DrawFront</code></td>
<td>

<p>If <code>TRUE</code>, draws a front view of the partial wake situation. Defaults to <code>FALSE</code>. Should not be <code>TRUE</code> at the same time as <code>DrawTop</code> or <code>DrawSide</code>.
</p>
</td></tr>
<tr><td><code id="PartialJensen_+3A_drawside">DrawSide</code></td>
<td>

<p>If <code>TRUE</code>, draws a side view of the partial wake situation. Defaults to <code>FALSE</code>. Should not be <code>TRUE</code> at the same time as <code>DrawTop</code> or <code>DrawFront</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first checks whether there is partial coverage. If so, it adjusts the penalty internally given by <code><a href="#topic+PairPenalty">PairPenalty</a></code> and if not, returns the full penalty. Therefore, the function is imposed over an existing Jensen model and refines it.<br />
Note that the penalty is the deduction to wind speed. It applies to wind power by its third power, so the user is responsible to take it to its cube himself. <code><a href="#topic+Profit">Profit</a></code> does that automatically internally.
</p>


<h3>Value</h3>

<p><code>PartialJensen</code> returns a penality between 0 and 1.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>References</h3>

<p>Frandsen, S. (1992). On the wind speed reduction in the center of large clusters of wind turbines. Journal of Wind Engineering and Industrial Aerodynamics, 39(1-3), pp. 251-265, https://doi.org/10.1016/0167-6105(92)90551-K.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JensenTrapezoid">JensenTrapezoid</a></code> to check whether there are wake effects present. <code><a href="#topic+FarmVars">FarmVars</a></code> for the data object. <code><a href="#topic+PairPenalty">PairPenalty</a></code> for the non-partial wake penalty.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>P1 &lt;- c(0.5868695, 0.9722714)
P2 &lt;- c(0.4827957, 0.9552658)

if (exists("FarmData", envir = e, inherits = FALSE))
{
  Dirs &lt;- e$FarmData[[3]][e$FarmVars$StartPoint:e$FarmVars$EndPoint,
    e$FarmVars$StartPoint:e$FarmVars$EndPoint]
  SDs &lt;- e$FarmData[[4]][e$FarmVars$StartPoint:e$FarmVars$EndPoint,
    e$FarmVars$StartPoint:e$FarmVars$EndPoint]
  Elev &lt;- e$FarmData[[5]][e$FarmVars$StartPoint:e$FarmVars$EndPoint,
    e$FarmVars$StartPoint:e$FarmVars$EndPoint]
} else
{
  Dirs &lt;- FarmData[[3]][e$FarmVars$StartPoint:e$FarmVars$EndPoint,
    e$FarmVars$StartPoint:e$FarmVars$EndPoint]
  SDs &lt;- FarmData[[4]][e$FarmVars$StartPoint:e$FarmVars$EndPoint,
    e$FarmVars$StartPoint:e$FarmVars$EndPoint]
  Elev &lt;- FarmData[[5]][e$FarmVars$StartPoint:e$FarmVars$EndPoint,
    e$FarmVars$StartPoint:e$FarmVars$EndPoint]
}

## First, compute the non-partial penalty:
Penal &lt;- PairPenalty(P2[1], P2[2], P1[1], P1[2], Dirs, SDs)

## Then, correct it for partial coverage:
Penal2 &lt;- PartialJensen(P2[1], P2[2], P1[1], P1[2], Dirs, SDs, Elev)

## Now draw a top view:
Penal2 &lt;- PartialJensen(P2[1], P2[2], P1[1], P1[2], Dirs, SDs, Elev, DrawTop = TRUE)

## Now draw a front view:
Penal2 &lt;- PartialJensen(P2[1], P2[2], P1[1], P1[2], Dirs, SDs, Elev, DrawFront = TRUE)
## Note that the downwind point is somewhat elevated, seems 'right'
## from the upwind point of view, and far away (rotor disc seems smaller).

## Now draw a side view:
Penal2 &lt;- PartialJensen(P2[1], P2[2], P1[1], P1[2], Dirs, SDs, Elev, DrawSide = TRUE)

## For elevation, see
Height(P1[1], P1[2], Elev) # (upwind point)
## and
Height(P2[1], P2[2], Elev) # (downwind point)

## Instead, for the next example, the downwind point is closer
## to the upwind point (larger impression of rotor disc), 'left'
## of it and lower in terms of elevation:
x1 &lt;- 0.5
y1 &lt;- 0.5
x2 &lt;- 0.45
y2 &lt;- 0.478
Penal &lt;- PairPenalty(x2, y2, x1, y1, Dirs, SDs)
Penal2 &lt;- PartialJensen(x2, y2, x1, y1, Dirs, SDs, Elev, DrawTop = TRUE)
Penal2 &lt;- PartialJensen(x2, y2, x1, y1, Dirs, SDs, Elev, DrawFront = TRUE)
## For elevation, see
Height(x1, y1, Elev) # (upwind point)
## and
Height(x2, y2, Elev) # (downwind point)
</code></pre>

<hr>
<h2 id='PlotResult'>Visualizes the wind farm layout optimization result.</h2><span id='topic+PlotResult'></span>

<h3>Description</h3>

<p>This function draws the adjusted yields of the wind farm under investigation using <code><a href="graphics.html#topic+image">image</a></code>, superimposes a contour plot using <code><a href="graphics.html#topic+contour">contour</a></code> and arrows for the wind directions using <code><a href="#topic+ImposeVectorField">ImposeVectorField</a></code> and then draws the points for the turbines' locations (aligned to their respective raster grid centers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PlotResult(Result, ImageData = NULL, DoLabels = FALSE, Labels = "IDs")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PlotResult_+3A_result">Result</code></td>
<td>

<p>must be an optimization result as returned by an optimizer such as <code><a href="stats.html#topic+optim">optim</a></code>. Usually, this will be a <code>list</code> at least containing '$par'. Most optimizers comply with this R standard. If your optimizer does not, wrap its result into a list containing an object '$par' containing the optimization result (i.e., a vector of points).
</p>
</td></tr>
<tr><td><code id="PlotResult_+3A_imagedata">ImageData</code></td>
<td>

<p>a matrix containing the data for the background, processed via <code><a href="graphics.html#topic+image">image</a></code>. If not provided (or NULL), uses the data in <code>FarmData[[1]]</code> or, if present, <code>e$FarmData[[1]]</code>. Defaults to NULL.
</p>
</td></tr>
<tr><td><code id="PlotResult_+3A_dolabels">DoLabels</code></td>
<td>

<p>a boolean that indicates whether labels should be plotted next to the points. Defaults to FALSE.
</p>
</td></tr>
<tr><td><code id="PlotResult_+3A_labels">Labels</code></td>
<td>

<p>a vector of length n = N / 2, can be numeric values or strings. Defines the labels to be shown if <code>DoLabels = TRUE</code>. Defaults to &quot;IDs&quot;, in which case the points are sequently numbered from 1:n. <code>Labels</code> is ignored if <code>DoLabels = FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For maximum convenience and compatibility with numeric optimizers of most kinds, this function expects nothing but the usual optimization result <code>list</code>. This, however, requires that the <code><a href="#topic+FarmData">FarmData</a></code> dataset as well as the <code><a href="#topic+FarmVars">FarmVars</a></code> object is present defining additional settings.
</p>


<h3>Value</h3>

<p><code>PlotResult</code> returns nothing.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+Profit">Profit</a></code> to obtain an optimization result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Will not provide a very good result
NumTurbines &lt;- 4
set.seed(1357)
Result &lt;- optim(par = runif(NumTurbines * 2), fn = Profit,
  method = "L-BFGS-B", lower = rep(0, NumTurbines * 2),
  upper = rep(1, NumTurbines * 2))
Result
PlotResult(Result)
</code></pre>

<hr>
<h2 id='PointInPolygon'>Checks whether a point is inside a polygon.</h2><span id='topic+PointInPolygon'></span>

<h3>Description</h3>

<p>Uses the famous Jensen test to check whether a provided point is inside a polygon, the latter defined by a set of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PointInPolygon(PointMat, TestPoint)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PointInPolygon_+3A_pointmat">PointMat</code></td>
<td>

<p>a 2 x 4 matrix, four corner points of each x and y coordinates.
</p>
</td></tr>
<tr><td><code id="PointInPolygon_+3A_testpoint">TestPoint</code></td>
<td>

<p>a vector of two containing x and y coordinates of a point to test.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>PointInPolygon</code> returns <code>TRUE</code> if the point is inside the polygon, or <code>FALSE</code>, else.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>References</h3>

<p>Jensen, N. O. (1983). A note on wind generator interaction. Roskilde: Risø National Laboratory. Risø-M, No. 2411
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JensenTrapezoid">JensenTrapezoid</a></code> to compute a Jensen trapezoid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1357)
Angle &lt;- runif(n = 1, min = 0, max = 360)
Point &lt;- runif(n = 2, min = 0, max = 1)
Dist &lt;- rnorm(n = 1, mean = 200, sd = 200)

MyTrapezoid &lt;- JensenTrapezoid(Angle, Point, Dist)

plot(x = MyTrapezoid[1, ], y = MyTrapezoid[2, ], xlab = "", ylab = "")
lines(x = c(MyTrapezoid[1, 1], MyTrapezoid[1, 2]), y = c(MyTrapezoid[2, 1], MyTrapezoid[2, 2]))
lines(x = c(MyTrapezoid[1, 2], MyTrapezoid[1, 3]), y = c(MyTrapezoid[2, 2], MyTrapezoid[2, 3]))
lines(x = c(MyTrapezoid[1, 3], MyTrapezoid[1, 4]), y = c(MyTrapezoid[2, 3], MyTrapezoid[2, 4]))
lines(x = c(MyTrapezoid[1, 4], MyTrapezoid[1, 1]), y = c(MyTrapezoid[2, 4], MyTrapezoid[2, 1]))

NumTest &lt;- 50

xTest &lt;- runif(n = NumTest, min = min(MyTrapezoid[1, ]), max = max(MyTrapezoid[1, ]))
yTest &lt;- runif(n = NumTest, min = min(MyTrapezoid[2, ]), max = max(MyTrapezoid[2, ]))

for (i in 1:NumTest)
{
	ThisPoint &lt;- c(xTest[i], yTest[i])
	if (PointInPolygon(MyTrapezoid, ThisPoint))
	{
		points(ThisPoint[1], ThisPoint[2], pch = 16, col = "green")
	} else
	{
		points(ThisPoint[1], ThisPoint[2], pch = 16, col = "red")
	}
}
</code></pre>

<hr>
<h2 id='Profit'>Computes the economic profit for a given wind farm layout configuration</h2><span id='topic+Profit'></span>

<h3>Description</h3>

<p>This is the bread-and-butter function to this package. It takes a set of points (turbine locations) and based on the adjusted yields in the field specified via the <code><a href="#topic+FarmVars">FarmVars</a></code> settings object, checks whether the layout is valid, computes the Jensen penalties, generates the total marketable power production of this layout, takes cost and sale price into consideration and finally computes the farm's economic profit. Note, however, that since most numeric optimizers by default operate as a minimizer, <code>Profit</code> returns the negative profit, i.e. a negative number for positive profit values and a positive number if cost is greater than revenue.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Profit(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Profit_+3A_x">X</code></td>
<td>

<p>must be a numeric vector containing an even number of values, at least two. If the length of the vector is N, then n = N / 2 is the number of points. The first values 1,...,n are interpreted as x coordinates and the subsequent n + 1,...,N values are the y coordinates.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For maximum convenience and compatibility with numeric optimizers of most kinds, this function expects nothing but the problem vector (the set of points) as a parameter. This, however, requires that the <code><a href="#topic+FarmData">FarmData</a></code> dataset as well as the <code><a href="#topic+FarmVars">FarmVars</a></code> object is present defining additional settings.<br />
As <code>Profit</code> returns the negative profit for compatibility with minimizers, reverse the sign for actual profit values.<br />
<code>Profit</code> requires the optimizer to accept box constraints, as <code>Profit</code> can not compute values outside the wind farm boundary (the function's domain). If your optimizer does not accept box constraints, embed <code>Profit</code> into a wrapper function that returns the sum of costs if it least one point is outside the boundary.
</p>


<h3>Value</h3>

<p><code>Profit</code> returns a single number. The result is the negative profit for any valid setting of points and consequently, the sum of all costs for invalid settings.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p>Calls <code><a href="#topic+Yield">Yield</a></code> and <code><a href="#topic+Cost">Cost</a></code> internally. Use <code><a href="#topic+PlotResult">PlotResult</a></code> to visualize the optimization result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Will not provide a very good result
NumTurbines &lt;- 4
set.seed(1357)
Result &lt;- optim(par = runif(NumTurbines * 2), fn = Profit,
  method = "L-BFGS-B", lower = rep(0, NumTurbines * 2),
  upper = rep(1, NumTurbines * 2))
Result
PlotResult(Result)
##########################################
#Will provide a somewhat better result
#Necessary to install pso
## Not run: 
NumTurbines &lt;- 4
Result &lt;- pso::psoptim(par = runif(NumTurbines * 2), fn = Profit,
  lower = rep(0, NumTurbines * 2), upper = rep(1, NumTurbines * 2))
Result
PlotResult(Result)

## End(Not run)
##########################################
#Simple wrapper function for optimizers not accepting box constraints
NumTurbines &lt;- 4
lower &lt;- rep(0, NumTurbines * 2)
upper &lt;- rep(1, NumTurbines * 2)
Wrapper &lt;- function(X)
{
	xSel &lt;- seq(from = 1, to = length(X) - 1, by = 2)
	x &lt;- X[xSel]
	y &lt;- X[xSel + 1]

	if (any(x &lt; lower) | any(x &gt; upper) | any(y &lt; lower) | any(y &gt; upper))
	{
		return(sum(rep(e$FarmVars$UnitCost, length(x))))
	}

	return(Profit(X))
}
## Not run: 
set.seed(1357)
Result &lt;- optim(par = runif(NumTurbines * 2), fn = Wrapper, method = "SANN")
Result
PlotResult(Result)
## End(Not run)
</code></pre>

<hr>
<h2 id='ProfitContributors'>Computes profit contributions for all points in a setup solution.</h2><span id='topic+ProfitContributors'></span>

<h3>Description</h3>

<p>This function takes an optimizer result (or simple vector object) and computes the profit contribution for each point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ProfitContributors(Result)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ProfitContributors_+3A_result">Result</code></td>
<td>

<p>must be an optimization result as returned by an optimizer such as <code><a href="stats.html#topic+optim">optim</a></code> or a vector. Usually, this will be a <code>list</code> at least containing '$par'.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Neglecting a possibly invalid setup (caused by at least one point), computes the profit contributions. If the setup provided is valid, the sum of contributions is identical to the (absulute value of the) returned value of <code><a href="#topic+Profit">Profit</a></code>.
</p>


<h3>Value</h3>

<p><code>ProfitContributors</code> returns a matrix of two columns and n rows, whith n being the number of turbines. The first column is a sequence of 1:n, representing the turbine IDs, while the second column contains the actual profit contributions.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+ValidSetup">ValidSetup</a></code> to see how a setup is categorized as valid or not. Use <code><a href="#topic+PlotResult">PlotResult</a></code> to visualize the optimization result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Prints a result and uses the profit contributions as labels.
NumTurbines &lt;- 4
set.seed(1235)
Result &lt;- optim(par = runif(NumTurbines * 2), fn = Profit,
  method = "L-BFGS-B", lower = rep(0, NumTurbines * 2),
  upper = rep(1, NumTurbines * 2))
MyLabels &lt;- ProfitContributors(Result)
MyLabels
#PlotResult(Result, DoLabels = TRUE, Labels = MyLabels[, 2])

# Given a valid setup, this should be TRUE.
#identical(abs(Profit(Result$par)), sum(MyLabels[, 2]))
</code></pre>

<hr>
<h2 id='QuickGauss3D'>For an incoming wind speed at reference height, this function computes a 3D Gaussian model based wind speed.</h2><span id='topic+QuickGauss3D'></span>

<h3>Description</h3>

<p>This function computes Gaussian wind speeds.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QuickGauss3D(x, y, z, u = 8, refHeight = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="QuickGauss3D_+3A_x">x</code></td>
<td>

<p>must be a single value. Provide distance in meters.
</p>
</td></tr>
<tr><td><code id="QuickGauss3D_+3A_y">y</code></td>
<td>

<p>must be a single value. Provide distance in meters.
</p>
</td></tr>
<tr><td><code id="QuickGauss3D_+3A_z">z</code></td>
<td>

<p>must be a single value. Provide distance in meters.
</p>
</td></tr>
<tr><td><code id="QuickGauss3D_+3A_u">u</code></td>
<td>

<p>must be a single value. Provide wind speed in meters per second.
</p>
</td></tr>
<tr><td><code id="QuickGauss3D_+3A_refheight">refHeight</code></td>
<td>

<p>must be a single value. Provide reference height (the height at which wind speed u was measured) in meters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gaussian wake model is loosely based on the initial contribution by Bastankhah &amp; Porte-Agel (2014).
</p>


<h3>Value</h3>

<p><code>QuickGauss3D</code> returns a single number which can be considered a wind speed in the wake of a turbine at location x, y, and z.
</p>


<h3>Note</h3>

<p>Note that the model assumes that along the x axis, x = 0 is the turbine location. x expands along the wind direction downwind. y denoted whether a point is 'left' or 'right' the x axis. Thus, the x-z plane is the plane along the x axis and perpendicular to the ground. The z axis is hight, starting at 0 = ground level.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>References</h3>

<p>Bastankhah, M., &amp; Porte-Agel, F. (2014). A new analytical model for wind-turbine wakes. Renewable Energy, 70, 116-123.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+GenerateGauss">GenerateGauss</a></code> to compute the three-dimensional tensor array object containing the wind speed data. Use <code><a href="#topic+GaussWS">GaussWS</a></code> for a convenience function to look-up the values from the returned array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>QuickGauss3D(100, 1, 100)
QuickGauss3D(200, -40, 120)
QuickGauss3D(50, 40, 70)
</code></pre>

<hr>
<h2 id='ShowWakePenalizers'>Visualizes the points causing/'suffering' from wake effects.</h2><span id='topic+ShowWakePenalizers'></span>

<h3>Description</h3>

<p>After optimization, this function draws a reduced 'field' and shows which points cause wake penalties on which points. 'Causers' are displayed in grey, 'sufferers', i.e. points that are in (possibly multiple) wakes of (several) causers are displayed in gold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ShowWakePenalizers(Result, Cones = TRUE, All = FALSE, VectorField = TRUE,
ImposeMST = FALSE, NS = FALSE, NSOnly = FALSE, Exaggerate = TRUE,
DoubleLine = TRUE, Frames = 100, Alpha = 0.5, MaxContrast = TRUE, Soften = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ShowWakePenalizers_+3A_result">Result</code></td>
<td>

<p>must be an optimization result as returned by an optimizer such as <code><a href="stats.html#topic+optim">optim</a></code>. Usually, this will be a <code>list</code> at least containing '$par'. Most optimizers comply with this R standard. If your optimizer does not, wrap its result into a list containing an object '$par' containing the optimization result (i.e., a vector of points).
</p>
</td></tr>
<tr><td><code id="ShowWakePenalizers_+3A_cones">Cones</code></td>
<td>

<p>triggers whether the Jensen cones are to be displayed as well. Defaults to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="ShowWakePenalizers_+3A_all">All</code></td>
<td>

<p>triggers whether all Jensen cones are to be displayed, instead of just causers and sufferers. Defaults to <code>FALSE</code>, as <code>TRUE</code> results in a mess most of the times.
</p>
</td></tr>
<tr><td><code id="ShowWakePenalizers_+3A_vectorfield">VectorField</code></td>
<td>

<p>controls whether or not to impose the wind directions vector field (arrows). Defaults to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="ShowWakePenalizers_+3A_imposemst">ImposeMST</code></td>
<td>

<p>if <code>TRUE</code>, computes and imposes a minimum spanning tree for the vertices, useful for cable installation purposes. Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="ShowWakePenalizers_+3A_ns">NS</code></td>
<td>

<p>if <code>TRUE</code>, imposes a computationally intensive Navier-Stokes based wake simulation image over the plot. Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="ShowWakePenalizers_+3A_nsonly">NSOnly</code></td>
<td>

<p>if <code>TRUE</code>, imposes just the Navier-Stokes wake simulation (no Jensen wakes). Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="ShowWakePenalizers_+3A_exaggerate">Exaggerate</code></td>
<td>

<p>if <code>TRUE</code>, displays turbines as squares in the Navier-Stokes visualization. The turbine is then still to scale, but in reality the rotor is a disc instead of a cube, of course. This overly emphasizes wakes, which may be desired in most cases. Thus, defaults to <code>TRUE</code>. Set to <code>FALSE</code> for a more realistic look of the rotor discs, but this will make the wakes appear less severe.
</p>
</td></tr>
<tr><td><code id="ShowWakePenalizers_+3A_doubleline">DoubleLine</code></td>
<td>

<p>applies only if <code>Exaggerate == TRUE</code>. The rotor disc is then a disc instead of a cube (or line instead of square), but the line will be two instead of one pixel wide. This option is a trade-off between <code>Exaggerate == TRUE</code> and <code>Exaggerate == FALSE</code>. Set to <code>TRUE</code> (the default) if <code>Exaggerate == FALSE</code> to apply. Note that only if <code>Exaggerate == FALSE</code> and <code>DoubleLine == FALSE</code>, the rotor disc is a one pixel wide line, the most realistic setting which however shows only weak wakes.
</p>
</td></tr>
<tr><td><code id="ShowWakePenalizers_+3A_frames">Frames</code></td>
<td>

<p>number of frames to pre-compute for the Navier-Stokes simulation. 100 is a good value. Less makes the computation faster, but more inaccurate. More than 100 in only necessary for very low wind speeds. Thus, defaults to <code>100</code>.
</p>
</td></tr>
<tr><td><code id="ShowWakePenalizers_+3A_alpha">Alpha</code></td>
<td>

<p>The Navier-Stokes wake simulation is imposed semi-transparent over the usual image. This controls the transparency. Alpha = 0 means transparent, Alpha = 1 means opaque. Defaults to <code>0.5</code>.
</p>
</td></tr>
<tr><td><code id="ShowWakePenalizers_+3A_maxcontrast">MaxContrast</code></td>
<td>

<p>increases the contrast to maximum (this is equivalent to histogram stretching). Defaults to <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="ShowWakePenalizers_+3A_soften">Soften</code></td>
<td>

<p>applies a Gaussian soften filter to the Navier-Stokes image to have a more homogeneous visualization. Defaults to <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Enables the researcher to inspect the optimization result in an a-posteriori analysis of Jensen's wake model. Parts of the Navier-Stokes code are inspired by Stam (2003).
</p>


<h3>Value</h3>

<p><code>ShowWakePenalizers</code> invisibly returns a square matrix (dimension: 'number of turbines') of wake penalty pairs: Columns are sufferers, rows are causers. For each row/column pair unequal to one, the turbine in row i sheds wake on the turbine in column j. The actual numbers are those returned by <code><a href="#topic+JensenFactor">JensenFactor</a></code>.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>References</h3>

<p>Stam, S. (2003). Real-Time Fluid Dynamics for Games. <a href="https://www.researchgate.net/publication/2560062_Real-Time_Fluid_Dynamics_for_Games">https://www.researchgate.net/publication/2560062_Real-Time_Fluid_Dynamics_for_Games</a>, 1-17
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+PlotResult">PlotResult</a></code> to visualize the optimization result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Will show that turbine 1 sheds wake on turbine 5.
NumTurbines &lt;- 8
set.seed(1357)
Result &lt;- optim(par = runif(NumTurbines * 2), fn = Profit,
  method = "L-BFGS-B", lower = rep(0, NumTurbines * 2),
  upper = rep(1, NumTurbines * 2))
ShowWakePenalizers(Result)

###############

#This may take some time. A progress bar is displayed.
Result = list(par = e$FarmVars$BenchmarkSolution)
ShowWakePenalizers(Result, All = TRUE, NS = TRUE, VectorField = FALSE, Alpha = 0.7)

###############

#Generates a few frames of an animation.
Result &lt;- list(par = e$FarmVars$BenchmarkSolution)
MakeFrames &lt;- function(Frames)
{
	for (i in 100:(100 + Frames - 1))
	{
		bmp(file = paste(i, ".bmp", sep = ""))
		ShowWakePenalizers(Result, All = TRUE, NS = TRUE, Frames = i)
		dev.off()
	}
}
system.time(MakeFrames(30)) #May take an hour.


## End(Not run)
</code></pre>

<hr>
<h2 id='SwitchProfile'>Helper function for ex-post wind direction dependence analysis</h2><span id='topic+SwitchProfile'></span>

<h3>Description</h3>

<p>This function helps with analzing an already computed turbine setup. As <code><a href="#topic+Profit">Profit</a></code> (together with an optimizer) finds an optimal setup given actual wind speeds in that area, the question arises whether that setup is 'robust' against changing wind directions. If for a given setup, there is no or only little wake dependence (analyze e.g. with <code><a href="#topic+ShowWakePenalizers">ShowWakePenalizers</a></code>), this may change if wind direction changes. Given a different wind direction, a situation may come up at which there is an upwind turbine and a local set of, say, two, three, or even more downwind turbines. As these downwind turbines are in the wake of the upwind turbines ('receiving' only reduced wind speeds), it may be beneficial to shut down the upwind turbine in order to have the downwind turbine receive full wind, thus possibly generating greater profit.<br />
<br />
<code>SwitchProfile</code> expects a 'bit' pattern of turbines (so-called 'profiles') at which '1' means that a turbine is to be used, while '0' means, the turbine is to be shut down. For a total of four tubines in a setup, profile <code>c(1, 1, 1, 1)</code> means that all turbines are used, while profile <code>c(1, 0, 0, 1)</code> means that turbines 1 and 4 are used, turbines 2 and 3 are to be shut down. If a wind farm is 'robust' against wind direction changes, it should return profiles of all ones for all wind directions.<br />
<br />
In the examples we show a short code sample that uses <code>SwitchProfile</code> to loop through 360 integer wind direction degrees and optimizes actual profiles. It is up to the researcher to use alternative optimizers in order to find (possibly) better profiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SwitchProfile(On, Result)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SwitchProfile_+3A_on">On</code></td>
<td>

<p>must be a numeric vector of length <code>n</code>, where <code>n</code> is the number of turbines in a setup.
</p>
</td></tr>
<tr><td><code id="SwitchProfile_+3A_result">Result</code></td>
<td>

<p>the actual setup as an optimizer result. Must be a list that contains the turbine locations is a slot &quot;$par&quot;. For example, use <code>Result = list(par = e$FarmVars$BenchmarkSolution)</code>, see <code><a href="#topic+FarmVars">FarmVars</a></code> for details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For compatibility with non-integer solution optimizers, <code>SwitchProfile</code> expects not only values equal to 0 or 1, but will assume that values below 0.5 are meant to be 0, and values &gt;= 0.5 are coerced to 1.
</p>


<h3>Value</h3>

<p><code>SwitchProfile</code> returns a single number. The result is the negative profit for the profile given. The result can be optimized in order to find the maximum profit profile, which should be identical to a profile of all ones if the setup is robust against wind direction changes.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+Profit">Profit</a></code> for the target function used internally.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Result &lt;- list(par = e$FarmVars$BenchmarkSolution)

Profile1 &lt;- rep(1, times = 20)

#Will be identical to Profit(Result$par):
SwitchProfile(Profile1, Result)

Profile2 &lt;- Profile1
Profile2[8] &lt;- 0 #Disable turbine 8.

#Returns farm profit if turbine 8 is off:
SwitchProfile(Profile2, Result)

##########################################

#Warning, this will overwrite e$FarmData. If not dispensable,
#backup before use.
#Computation may be slow.

## Not run: 
Result &lt;- list(par = e$FarmVars$BenchmarkSolution)
e$FarmData &lt;- FarmData

n &lt;- length(e$FarmVars$BenchmarkSolution) / 2

Profiles &lt;- matrix(ncol = n, nrow = 360)
Dom &lt;- cbind(rep(0, n), rep(1, n))

for (j in 1:360)
{
	e$FarmData$WindDirection &lt;- matrix(data = j, ncol = e$FarmVars$Width,
	  nrow = e$FarmVars$Width)
	message(paste("Processing wind direction: ", j, " degrees.", sep = ""))
	flush.console()

	Result &lt;- rgenoud::genoud(fn = SwitchProfile, nvars = n, starting.values = runif(n),
	  Domains = Dom, boundary.enforcement = 2, MemoryMatrix = FALSE, print.level = 0,
	  Result = Result)
	On &lt;- Result$par
	On[On &lt; 0.5] &lt;- 0
	On[On &gt;= 0.5] &lt;- 1
	Profiles[j, ] &lt;- On
}

#Now 'Profiles' is a matrix of 360 rows (degrees) and n columns.
#If the setup is robust against wind direction changes, all values
#in the columns should be ones. If there are zeros left, double
#check these profiles (compare to full turbines setup) manually,
#e.g. using

for (i in 1:nrow(Profiles))
{
	if (any(Profiles[i, ] == 0))
	{
		e$FarmData$WindDirection &lt;- matrix(data = i,
    ncol = e$FarmVars$Width, nrow = e$FarmVars$Width)

		print(paste("Is unrestricted profit (",
    abs(Profit(e$FarmVars$BenchmarkSolution)), ") still
    greater than 'profile profit' (",
    abs(SwitchProfile(Profiles[i, ], Result)), ")? ",
    abs(Profit(e$FarmVars$BenchmarkSolution)) &gt;=
    abs(SwitchProfile(Profiles[i, ], Result)), ".", sep = ""))
	}
}

#Is absolute profile profit actually greater than the absolute value
#function Profit() returns? If yes, then it is beneficial to turn off
#turbines (use profiles) if wind comes from the given angle.

## End(Not run)

##########################################

#As an alternative to using an optimizer to find the optimal profile,
#all possible profiles can be 'looped through' deterministically using
#the following few lines of code.

#Warning, this will overwrite e$FarmData. If not dispensable,
#backup before use.

#Be advised, computation may be very slow, even if run on modern
#machines and even though using parallelization.

## Not run: 
Result &lt;- list(par = e$FarmVars$BenchmarkSolution)
e$FarmData &lt;- FarmData

ComputeProfile &lt;- function(i)
{
	e$FarmData$WindDirection &lt;- matrix(data = i, ncol = e$FarmVars$Width,
	  nrow = e$FarmVars$Width)

	BestProfit &lt;- n * e$FarmVars$UnitCost
	BestProfile &lt;- rep(0, n)
	for (j in 0:MaxNum)
	{
		ThisProfile &lt;- as.numeric(rev(intToBits(j)))[(32 - (n - 1)):32]
		if (length(which(ThisProfile == 1)) &gt; 1)
		{
			ThisProfit &lt;- SwitchProfile(ThisProfile, Result)
		} else
		{
			ThisProfit &lt;- n * e$FarmVars$UnitCost
		}

		if (ThisProfit &lt; BestProfit)
		{
			BestProfit &lt;- ThisProfit
			BestProfile &lt;- ThisProfile
		}
	}
	return(BestProfile)
}

n &lt;- length(e$FarmVars$BenchmarkSolution) / 2
MaxNum &lt;- (2 ^ n) - 1

NumCores &lt;- parallel::detectCores() - 1
cl &lt;- snow::makeCluster(NumCores)

ParallelProfile &lt;- new.env()
ParallelProfile$FarmVars &lt;- e$FarmVars
ParallelProfile$FarmData &lt;- e$FarmData

snow::clusterExport(cl, list = ls())
snow::clusterExport(cl, list = ls(envir = as.environment("package:wflo")))

doSNOW::registerDoSNOW(cl)

iterations &lt;- 360
pb &lt;- txtProgressBar(max = iterations, style = 3)
progress &lt;- function(n) setTxtProgressBar(pb, n)
opts &lt;- list(progress = progress)
`%dopar%` &lt;- foreach::`%dopar%`
AllProfiles &lt;- foreach::foreach(i = 1:iterations,
  .options.snow = opts) %dopar% ComputeProfile(i)

close(pb)
snow::stopCluster(cl)

## End(Not run)

#Afterward, check the resulting list of profiles for remaining zeros as above.

##########################################

#Thinking the thought of wind direction dependent layouts further,
#Profit() can be used to optimize a farm setup that takes all wind
#direction wake patterns into account during the optimization
#stage already.

#Warning, this will overwrite \code{e$FarmData}. If not dispensable,
#backup before use.
#Computation may be slow.

## Not run: 
e$FarmData &lt;- FarmData

SumProfit &lt;- function(X)
{
	MySum &lt;- as.numeric()
	for (i in 1:360)
	{
		e$FarmData$WindDirection &lt;- matrix(data = i, ncol = e$FarmVars$Width,
		  nrow = e$FarmVars$Width)
		MySum[i] &lt;- Profit(X)
	}
	MySum &lt;- sum(MySum)
	return(MySum)
}

n &lt;- 20
Dom &lt;- cbind(rep(0, 2 * n), rep(1, 2 * n))
Result &lt;- rgenoud::genoud(fn = SumProfit, nvars = 2 * n, starting.values = runif(2 * n),
  Domains = Dom, boundary.enforcement = 2, MemoryMatrix = FALSE, print.level = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='ValidSetup'>Checks whether all turbine locations provided satisfy the minimum distance criterion.</h2><span id='topic+ValidSetup'></span>

<h3>Description</h3>

<p>For a set of turbine locations represented by <code>x</code> and <code>y</code>, checks whether all possible pairs satisfy the minimum distance criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ValidSetup(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ValidSetup_+3A_x">x</code></td>
<td>

<p>must be a numeric vector of at least two values, contains the 'x' location(s) of turbines.
</p>
</td></tr>
<tr><td><code id="ValidSetup_+3A_y">y</code></td>
<td>

<p>must be a numeric vector of at least two values, contains the 'y' location(s) of turbines.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ValidSetup</code> returns <code>TRUE</code> if all pairs of turbines are at least as far away from each other as 'MinDist' from the <code><a href="#topic+FarmVars">FarmVars</a></code> settings object requests, or <code>FALSE</code>, else.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ValidSetup(c(0.5, 0.7), c(0.7, 0.9))
## Returns TRUE if FarmVars$MinDist is at its standard value (0.1).
</code></pre>

<hr>
<h2 id='WindspeedHellmann'>Scales wind speeds to certain heights.</h2><span id='topic+WindspeedHellmann'></span>

<h3>Description</h3>

<p>For a wind speed at given height, returns a scaled wind speed at some different height. Often used to obtain wind speed at hub height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WindspeedHellmann(v0, HH = 100, refHeight = 10, alpha = 1 / 7)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WindspeedHellmann_+3A_v0">v0</code></td>
<td>

<p>wind speed (in meters per second) at reference height.
</p>
</td></tr>
<tr><td><code id="WindspeedHellmann_+3A_hh">HH</code></td>
<td>

<p>the height (in meters) at which wind speed is desired.
</p>
</td></tr>
<tr><td><code id="WindspeedHellmann_+3A_refheight">refHeight</code></td>
<td>

<p>reference height (in meters). The height at which the actual wind speed (v0) was measured.
</p>
</td></tr>
<tr><td><code id="WindspeedHellmann_+3A_alpha">alpha</code></td>
<td>

<p>power law parameter. Usually set to 1/7 for onshore sites.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply implements </p>
<p style="text-align: center;"><code class="reqn">v = v_0 (\frac{HH}{refHeight})^{\alpha}</code>
</p>



<h3>Value</h3>

<p><code>WindspeedHellmann</code> returns a wind speed (in meters per second) at the desired height.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WindspeedLog">WindspeedLog</a></code> for a different way to scale wind speeds to heights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>WindspeedLog(v0 = 6, HH = 80, z0 = 0.1, refHeight = 20)
WindspeedHellmann(v0 = 6, HH = 80, refHeight = 20)
</code></pre>

<hr>
<h2 id='WindspeedLog'>Scales wind speeds to certain heights.</h2><span id='topic+WindspeedLog'></span>

<h3>Description</h3>

<p>For a wind speed at given height, returns a scaled wind speed at some different height. Often used to obtain wind speed at hub height.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WindspeedLog(v0, HH = 100, z0 = 0.1, refHeight = 10)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="WindspeedLog_+3A_v0">v0</code></td>
<td>

<p>wind speed (in meters per second) at reference height.
</p>
</td></tr>
<tr><td><code id="WindspeedLog_+3A_hh">HH</code></td>
<td>

<p>the height (in meters) at which wind speed is desired.
</p>
</td></tr>
<tr><td><code id="WindspeedLog_+3A_z0">z0</code></td>
<td>

<p>roughness length (in meters). Usually set to 0.1 m for onshore sites.
</p>
</td></tr>
<tr><td><code id="WindspeedLog_+3A_refheight">refHeight</code></td>
<td>

<p>reference height (in meters). The height at which the actual wind speed (v0) was measured.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simply implements </p>
<p style="text-align: center;"><code class="reqn">v = v_0 (\frac{\log{\frac{HH}{z_0}}}{\log{\frac{refHeight}{z_0}}})</code>
</p>
<p><br />
Note that this way to scale wind speeds to certain heights is frequently considered deprecated in the literature. Use <code><a href="#topic+WindspeedHellmann">WindspeedHellmann</a></code> instead.
</p>


<h3>Value</h3>

<p><code>WindspeedLog</code> returns a wind speed (in meters per second) at the desired height.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+WindspeedHellmann">WindspeedHellmann</a></code> for a different way to scale wind speeds to heights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>WindspeedLog(v0 = 6, HH = 80, z0 = 0.1, refHeight = 20)
WindspeedHellmann(v0 = 6, HH = 80, refHeight = 20)
</code></pre>

<hr>
<h2 id='Yield'>Returns yearly yield for a turbine's location.</h2><span id='topic+Yield'></span>

<h3>Description</h3>

<p>For a turbine's location represented by <code>x</code> and <code>y</code>, looks up the (adjusted) yield from the matrix <code>Adj</code>. Internally transforms coordinates of <code>x</code> and <code>y</code> from problem space (usually unit square) to the matrix space of <code>Adj</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Yield(x, y, Adj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Yield_+3A_x">x</code></td>
<td>

<p>must be a single value containing the 'x' location of a turbine in problem space.
</p>
</td></tr>
<tr><td><code id="Yield_+3A_y">y</code></td>
<td>

<p>must be a single value containing the 'y' location of a turbine in problem space.
</p>
</td></tr>
<tr><td><code id="Yield_+3A_adj">Adj</code></td>
<td>

<p>a matrix containing adjusted yields. Usually, the first element of the list object <code><a href="#topic+FarmData">FarmData</a></code> will be used as this matrix.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adjusted yields are the projected yearly average yields dependent on wind speed, hub height and other settings at each point in the raster data. Annual Energy Production (AEP) at a specific location, weighted by a location quality correction factor, produces adjusted yields. This adjustment returns a better guess on the marketable yield at a specific point. For details on the data, see the data set description to this package.<br />
Note that <code><a href="#topic+Profit">Profit</a></code> internally multiplies the outcome of <code>Yield</code> by <code>e$FarmVars$Price</code> to obtain revenue. Users who replace the function by <code>e$Yield</code> need to provide that manually, if revenue is desired.
</p>


<h3>Value</h3>

<p><code>Yield</code> returns a single value.
</p>


<h3>Author(s)</h3>

<p>Carsten Croonenbroeck
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Profit">Profit</a></code> to see where to use <code>Yield</code>, <code><a href="#topic+Cost">Cost</a></code> for a similar function for yearly cost. <code><a href="#topic+FarmData">FarmData</a></code> for the data set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Returns adjusted yield for the given location.
Adj &lt;- FarmData[[1]][e$FarmVars$StartPoint:e$FarmVars$EndPoint,
e$FarmVars$StartPoint:e$FarmVars$EndPoint]
Yield(0.5, 0.7, Adj)

## Replace the function by another function
## also called 'Yield', embedded in environment e.
## Also, see the vignette.
## Not run: 
e$Yield &lt;- function(x, y, AEP) #x, y \in R
{
	return(x + y)
}
set.seed(1357)
NumTurbines &lt;- 4 # For example.
Result &lt;- pso::psoptim(par = runif(NumTurbines * 2), fn = Profit,
  lower = rep(0, NumTurbines * 2), upper = rep(1, NumTurbines * 2))
Result
rm(Yield, envir = e)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
