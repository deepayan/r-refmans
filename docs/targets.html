<!DOCTYPE html><html><head><title>Help for package targets</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {targets}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#targets-package'><p>targets: Dynamic Function-Oriented Make-Like Declarative Pipelines for R</p></a></li>
<li><a href='#callr_args_default'><p>Deprecated: <code>callr</code> arguments.</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rstudio_addin_tar_glimpse'><p>RStudio addin to call <code>tar_glimpse()</code>.</p></a></li>
<li><a href='#rstudio_addin_tar_load'><p>RStudio addin to call <code>tar_load()</code> on the symbol at the cursor.</p></a></li>
<li><a href='#rstudio_addin_tar_make_bg'><p>RStudio addin to run <code>tar_make()</code> in the background.</p></a></li>
<li><a href='#rstudio_addin_tar_outdated'><p>RStudio addin to call <code>tar_outdated()</code>.</p></a></li>
<li><a href='#rstudio_addin_tar_progress'><p>RStudio addin to print <code>tail(tar_progress())</code>.</p></a></li>
<li><a href='#rstudio_addin_tar_read'><p>RStudio addin to call <code>tar_read()</code> on the symbol at the cursor.</p></a></li>
<li><a href='#rstudio_addin_tar_target'><p>RStudio addin to insert <code>"tar_target()"</code> at the cursor.</p></a></li>
<li><a href='#rstudio_addin_tar_visnetwork'><p>RStudio addin to call <code>tar_visnetwork()</code>.</p></a></li>
<li><a href='#tar_active'><p>Show if the pipeline is running.</p></a></li>
<li><a href='#tar_assert'><p>Assertions</p></a></li>
<li><a href='#tar_backoff'><p>Superseded: exponential backoff</p></a></li>
<li><a href='#tar_bind'><p>Combine pipeline objects (deprecated).</p></a></li>
<li><a href='#tar_branch_index'><p>Integer branch indexes</p></a></li>
<li><a href='#tar_branch_names'><p>Branch names</p></a></li>
<li><a href='#tar_branch_names_raw'><p>Branch names (raw version)</p></a></li>
<li><a href='#tar_branches'><p>Reconstruct the branch names and the names of their dependencies.</p></a></li>
<li><a href='#tar_built'><p>Deprecated: list built targets.</p></a></li>
<li><a href='#tar_call'><p>Identify the called <code>targets</code> function.</p></a></li>
<li><a href='#tar_callr_args_default'><p>Default <code>callr</code> arguments.</p></a></li>
<li><a href='#tar_callr_inner_try'><p>Invoke a <code>targets</code> task from inside a <code>callr</code> function</p>
(without error handling).</a></li>
<li><a href='#tar_cancel'><p>Cancel a target mid-execution under a custom condition.</p></a></li>
<li><a href='#tar_canceled'><p>List canceled targets.</p></a></li>
<li><a href='#tar_completed'><p>List completed targets.</p></a></li>
<li><a href='#tar_condition'><p>Conditions</p></a></li>
<li><a href='#tar_condition_traced'><p>Contain an error condition and formatted traceback.</p></a></li>
<li><a href='#tar_config_get'><p>Get configuration settings.</p></a></li>
<li><a href='#tar_config_projects'><p>List projects.</p></a></li>
<li><a href='#tar_config_set'><p>Set configuration settings.</p></a></li>
<li><a href='#tar_config_unset'><p>Unset configuration settings.</p></a></li>
<li><a href='#tar_config_yaml'><p>Read <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>.</p></a></li>
<li><a href='#tar_counter'><p>Create a counter object.</p></a></li>
<li><a href='#tar_crew'><p>Get crew worker info.</p></a></li>
<li><a href='#tar_cue'><p>Declare the rules that cue a target.</p></a></li>
<li><a href='#tar_debug_instructions'><p>Print instructions for debugging a target.</p></a></li>
<li><a href='#tar_deduplicate'><p>Deduplicate meta and progress databases (deprecated).</p></a></li>
<li><a href='#tar_definition'><p>For developers only: get the definition of the current target.</p></a></li>
<li><a href='#tar_delete'><p>Delete target output values.</p></a></li>
<li><a href='#tar_deps'><p>Code dependencies</p></a></li>
<li><a href='#tar_deps_raw'><p>Code dependencies (raw version)</p></a></li>
<li><a href='#tar_described_as'><p>Select targets using their descriptions.</p></a></li>
<li><a href='#tar_destroy'><p>Destroy the data store.</p></a></li>
<li><a href='#tar_dir'><p>Execute code in a temporary directory.</p></a></li>
<li><a href='#tar_dispatched'><p>List dispatched targets.</p></a></li>
<li><a href='#tar_edit'><p>Open the target script file for editing.</p></a></li>
<li><a href='#tar_engine_knitr'><p>Target Markdown <code>knitr</code> engine</p></a></li>
<li><a href='#tar_envir'><p>For developers only: get the environment of the current target.</p></a></li>
<li><a href='#tar_envvars'><p>Show <code>targets</code> environment variables.</p></a></li>
<li><a href='#tar_errored'><p>List errored targets.</p></a></li>
<li><a href='#tar_exist_meta'><p>Check if target metadata exists.</p></a></li>
<li><a href='#tar_exist_objects'><p>Check if local output data exists for one or more targets.</p></a></li>
<li><a href='#tar_exist_process'><p>Check if process metadata exists.</p></a></li>
<li><a href='#tar_exist_progress'><p>Check if progress metadata exists.</p></a></li>
<li><a href='#tar_exist_script'><p>Check if the target script file exists.</p></a></li>
<li><a href='#tar_format'><p>Define a custom target storage format.</p></a></li>
<li><a href='#tar_github_actions'><p>Set up GitHub Actions to run a targets pipeline</p></a></li>
<li><a href='#tar_glimpse'><p>Visualize an abridged fast dependency graph.</p></a></li>
<li><a href='#tar_group'><p>Group a data frame to iterate over subsets of rows.</p></a></li>
<li><a href='#tar_helper'><p>Write a helper R script.</p></a></li>
<li><a href='#tar_helper_raw'><p>Write a helper R script (raw version).</p></a></li>
<li><a href='#tar_interactive'><p>Run if Target Markdown interactive mode is on.</p></a></li>
<li><a href='#tar_invalidate'><p>Delete one or more metadata records (e.g. to rerun a target).</p></a></li>
<li><a href='#tar_language'><p>Language</p></a></li>
<li><a href='#tar_load'><p>Load the values of targets.</p></a></li>
<li><a href='#tar_load_everything'><p>Load the values of all available targets.</p></a></li>
<li><a href='#tar_load_globals'><p>Load globals for debugging, testing, and prototyping</p></a></li>
<li><a href='#tar_load_raw'><p>Load the values of targets (raw version).</p></a></li>
<li><a href='#tar_make'><p>Run a pipeline of targets.</p></a></li>
<li><a href='#tar_make_clustermq'><p>Superseded. Run a pipeline with persistent <code>clustermq</code> workers.</p></a></li>
<li><a href='#tar_make_future'><p>Superseded. Run a pipeline of targets in parallel with transient</p>
<code>future</code> workers.</a></li>
<li><a href='#tar_make_interactive'><p>Interactive mode pipeline</p></a></li>
<li><a href='#tar_manifest'><p>Produce a data frame of information about your targets.</p></a></li>
<li><a href='#tar_mermaid'><p><code>mermaid.js</code> dependency graph.</p></a></li>
<li><a href='#tar_meta'><p>Read a project's metadata.</p></a></li>
<li><a href='#tar_meta_delete'><p>Delete metadata.</p></a></li>
<li><a href='#tar_meta_download'><p>download local metadata to the cloud.</p></a></li>
<li><a href='#tar_meta_sync'><p>Synchronize cloud metadata.</p></a></li>
<li><a href='#tar_meta_upload'><p>Upload local metadata to the cloud.</p></a></li>
<li><a href='#tar_name'><p>Get the name of the target currently running.</p></a></li>
<li><a href='#tar_network'><p>Return the vertices and edges of a pipeline dependency graph.</p></a></li>
<li><a href='#tar_newer'><p>List new targets</p></a></li>
<li><a href='#tar_noninteractive'><p>Run if Target Markdown interactive mode is not on.</p></a></li>
<li><a href='#tar_objects'><p>List saved targets</p></a></li>
<li><a href='#tar_older'><p>List old targets</p></a></li>
<li><a href='#tar_option_export'><p>Export options.</p></a></li>
<li><a href='#tar_option_get'><p>Get a target option.</p></a></li>
<li><a href='#tar_option_reset'><p>Reset all target options.</p></a></li>
<li><a href='#tar_option_set'><p>Set target options.</p></a></li>
<li><a href='#tar_outdated'><p>Check which targets are outdated.</p></a></li>
<li><a href='#tar_path'><p>Deprecated: identify the file path where a target will be stored.</p></a></li>
<li><a href='#tar_path_script'><p>Current target script path</p></a></li>
<li><a href='#tar_path_script_support'><p>Directory path to the support scripts</p>
of the current target script</a></li>
<li><a href='#tar_path_store'><p>Current data store path</p></a></li>
<li><a href='#tar_path_target'><p>Identify the file path where a target will be stored.</p></a></li>
<li><a href='#tar_pattern'><p>Emulate dynamic branching.</p></a></li>
<li><a href='#tar_pid'><p>Get main process ID.</p></a></li>
<li><a href='#tar_pipeline'><p>Declare a pipeline (deprecated).</p></a></li>
<li><a href='#tar_poll'><p>Repeatedly poll progress in the R console.</p></a></li>
<li><a href='#tar_process'><p>Get main process info.</p></a></li>
<li><a href='#tar_progress'><p>Read progress.</p></a></li>
<li><a href='#tar_progress_branches'><p>Tabulate the progress of dynamic branches.</p></a></li>
<li><a href='#tar_progress_summary'><p>Summarize target progress.</p></a></li>
<li><a href='#tar_prune'><p>Remove targets that are no longer part of the pipeline.</p></a></li>
<li><a href='#tar_prune_list'><p>List targets that <code>tar_prune()</code> will remove.</p></a></li>
<li><a href='#tar_random_port'><p>Random TCP port</p></a></li>
<li><a href='#tar_read'><p>Read a target's value from storage.</p></a></li>
<li><a href='#tar_read_raw'><p>Read a target's value from storage (raw version)</p></a></li>
<li><a href='#tar_renv'><p>Set up package dependencies for compatibility with <code>renv</code></p></a></li>
<li><a href='#tar_reprex'><p>Reproducible example of <code>targets</code> with <code>reprex</code></p></a></li>
<li><a href='#tar_resources'><p>Target resources</p></a></li>
<li><a href='#tar_resources_aws'><p>Target resources: Amazon Web Services (AWS) S3 storage</p></a></li>
<li><a href='#tar_resources_clustermq'><p>Target resources: <code>clustermq</code> high-performance computing</p></a></li>
<li><a href='#tar_resources_crew'><p>Target resources: <code>crew</code> high-performance computing</p></a></li>
<li><a href='#tar_resources_feather'><p>Target resources: feather storage formats</p></a></li>
<li><a href='#tar_resources_fst'><p>Target resources: <code>fst</code> storage formats</p></a></li>
<li><a href='#tar_resources_future'><p>Target resources: <code>future</code> high-performance computing</p></a></li>
<li><a href='#tar_resources_gcp'><p>Target resources: Google Cloud Platform (GCP)</p>
Google Cloud Storage (GCS)</a></li>
<li><a href='#tar_resources_network'><p>Target resources for network file systems.</p></a></li>
<li><a href='#tar_resources_parquet'><p>Target resources: parquet storage formats</p></a></li>
<li><a href='#tar_resources_qs'><p>Target resources: qs storage formats</p></a></li>
<li><a href='#tar_resources_url'><p>Target resources: URL storage formats</p></a></li>
<li><a href='#tar_runtime_object'><p>Get the <code>tar_runtime</code> object.</p></a></li>
<li><a href='#tar_script'><p>Write a target script file.</p></a></li>
<li><a href='#tar_seed'><p>Deprecated: get the seed of the current target.</p></a></li>
<li><a href='#tar_seed_create'><p>Create a seed for a target.</p></a></li>
<li><a href='#tar_seed_get'><p>Get the random number generator seed of the target currently running.</p></a></li>
<li><a href='#tar_seed_set'><p>Set a seed to run a target.</p></a></li>
<li><a href='#tar_sitrep'><p>Show the cue-by-cue status of each target.</p></a></li>
<li><a href='#tar_skipped'><p>List skipped targets.</p></a></li>
<li><a href='#tar_source'><p>Run R scripts.</p></a></li>
<li><a href='#tar_started'><p>Deprecated: list started targets.</p></a></li>
<li><a href='#tar_store'><p>Deprecated: current data store path</p></a></li>
<li><a href='#tar_target'><p>Declare a target.</p></a></li>
<li><a href='#tar_target_raw'><p>Define a target using unrefined names and language objects.</p></a></li>
<li><a href='#tar_test'><p>Test code in a temporary directory.</p></a></li>
<li><a href='#tar_timestamp'><p>Get the timestamp(s) of a target.</p></a></li>
<li><a href='#tar_timestamp_raw'><p>Get the timestamp(s) of a target (raw version).</p></a></li>
<li><a href='#tar_toggle'><p>Choose code to run based on Target Markdown mode.</p></a></li>
<li><a href='#tar_traceback'><p>Get a target's traceback</p></a></li>
<li><a href='#tar_unscript'><p>Remove target script helper files.</p></a></li>
<li><a href='#tar_unversion'><p>Delete cloud object version IDs from local metadata.</p></a></li>
<li><a href='#tar_validate'><p>Validate a pipeline of targets.</p></a></li>
<li><a href='#tar_visnetwork'><p>visNetwork dependency graph.</p></a></li>
<li><a href='#tar_watch'><p>Shiny app to watch the dependency graph.</p></a></li>
<li><a href='#tar_watch_app_ui'><p>Create the full <code>tar_watch()</code> app UI.</p></a></li>
<li><a href='#tar_watch_server'><p>Shiny module server for tar_watch()</p></a></li>
<li><a href='#tar_watch_ui'><p>Shiny module UI for tar_watch()</p></a></li>
<li><a href='#tar_workspace'><p>Load a saved workspace and seed for debugging.</p></a></li>
<li><a href='#tar_workspaces'><p>List saved target workspaces.</p></a></li>
<li><a href='#target_run_worker'><p>Internal function to run a target on a worker.</p></a></li>
<li><a href='#use_targets'><p>Use targets</p></a></li>
<li><a href='#use_targets_rmd'><p>Use targets with Target Markdown.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Dynamic Function-Oriented 'Make'-Like Declarative Pipelines</td>
</tr>
<tr>
<td>Description:</td>
<td>Pipeline tools coordinate the pieces of computationally
  demanding analysis projects.
  The 'targets' package is a 'Make'-like pipeline tool for statistics and
  data science in R. The package skips costly runtime for tasks
  that are already up to date,
  orchestrates the necessary computation with implicit parallel computing,
  and abstracts files as R objects. If all the current output matches
  the current upstream code and data, then the whole pipeline is up
  to date, and the results are more trustworthy than otherwise.
  The methodology in this package
  borrows from GNU 'Make' (2015, ISBN:978-9881443519)
  and 'drake' (2018, &lt;<a href="https://doi.org/10.21105%2Fjoss.00550">doi:10.21105/joss.00550</a>&gt;).</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.0</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://docs.ropensci.org/targets/">https://docs.ropensci.org/targets/</a>,
<a href="https://github.com/ropensci/targets">https://github.com/ropensci/targets</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ropensci/targets/issues">https://github.com/ropensci/targets/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>base64url (&ge; 1.4), callr (&ge; 3.7.0), cli (&ge; 2.0.2),
codetools (&ge; 0.2.16), data.table (&ge; 1.12.8), digest (&ge;
0.6.25), igraph (&ge; 2.0.0), knitr (&ge; 1.34), ps, R6 (&ge; 2.4.1),
rlang (&ge; 1.0.0), secretbase, stats, tibble (&ge; 3.0.1),
tidyselect (&ge; 1.1.0), tools, utils, vctrs (&ge; 0.2.4), yaml (&ge;
2.2.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bs4Dash (&ge; 2.0.0), clustermq (&ge; 0.9.2), crew (&ge; 0.9.0),
curl (&ge; 4.3), DT (&ge; 0.14), dplyr (&ge; 1.0.0), fst (&ge; 0.9.2),
future (&ge; 1.19.1), future.batchtools (&ge; 0.9.0), future.callr
(&ge; 0.6.0), gargle (&ge; 1.2.0), googleCloudStorageR (&ge; 0.7.0),
gt (&ge; 0.2.2), keras (&ge; 2.2.5.0), markdown (&ge; 1.1), nanonext
(&ge; 0.12.0), rmarkdown (&ge; 2.4), parallelly (&ge; 1.35.0),
paws.common (&ge; 0.6.4), paws.storage (&ge; 0.4.0), pingr (&ge;
2.0.1), pkgload (&ge; 1.1.0), processx (&ge; 3.4.3), qs (&ge;
0.24.1), reprex (&ge; 2.0.0), rstudioapi (&ge; 0.11), R.utils (&ge;
2.6.0), shiny (&ge; 1.5.0), shinybusy (&ge; 0.2.2), shinyWidgets
(&ge; 0.5.4), testthat (&ge; 3.0.0), torch (&ge; 0.1.0), usethis (&ge;
1.6.3), visNetwork (&ge; 2.1.2)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-13 15:19:37 UTC; C240390</td>
</tr>
<tr>
<td>Author:</td>
<td>William Michael Landau
    <a href="https://orcid.org/0000-0003-1878-3253"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Matthew T. Warkentin [ctb],
  Mark Edmondson <a href="https://orcid.org/0000-0002-8434-3881"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Samantha Oliver <a href="https://orcid.org/0000-0001-5668-1165"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  Tristan Mahr <a href="https://orcid.org/0000-0002-8890-5116"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [rev],
  Eli Lilly and Company [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>William Michael Landau &lt;will.landau.oss@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-13 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='targets-package'>targets: Dynamic Function-Oriented Make-Like Declarative Pipelines for R</h2><span id='topic+targets-package'></span>

<h3>Description</h3>

<p>A pipeline toolkit for Statistics and data science in R,
the <code>targets</code> package brings function-oriented programming to
Make-like declarative pipelines. <code>targets</code> orchestrates a pipeline
as a graph of dependencies,
skips steps that are already up to date, runs the necessary
computations with optional parallel workers, abstracts files as
R objects, and provides tangible evidence that the results are
reproducible given the underlying code and data.
The methodology in this package
borrows from GNU Make (2015, ISBN:978-9881443519)
and <code>drake</code> (2018, <a href="https://doi.org/10.21105/joss.00550">doi:10.21105/joss.00550</a>).
</p>


<h3>See Also</h3>

<p>Other help: 
<code><a href="#topic+tar_reprex">tar_reprex</a>()</code>,
<code><a href="#topic+use_targets">use_targets</a>()</code>,
<code><a href="#topic+use_targets_rmd">use_targets_rmd</a>()</code>
</p>

<hr>
<h2 id='callr_args_default'>Deprecated: <code>callr</code> arguments.</h2><span id='topic+callr_args_default'></span>

<h3>Description</h3>

<p>Deprecated on 2022-08-05 (version 0.13.1).
Please use <code><a href="#topic+tar_callr_args_default">tar_callr_args_default()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callr_args_default(callr_function, reporter = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callr_args_default_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from the <code>callr</code> package
that starts an external R process.</p>
</td></tr>
<tr><td><code id="callr_args_default_+3A_reporter">reporter</code></td>
<td>
<p>Character of length 1, choice of reporter
for <code><a href="#topic+tar_make">tar_make()</a></code> or a related function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not a user-side function. Do not invoke directly.
Exported for internal purposes only.
</p>


<h3>Value</h3>

<p>A list of arguments to <code>callr_function</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_callr_args_default(callr::r)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+all_of'></span><span id='topic+any_of'></span><span id='topic+contains'></span><span id='topic+ends_with'></span><span id='topic+everything'></span><span id='topic+last_col'></span><span id='topic+matches'></span><span id='topic+num_range'></span><span id='topic+one_of'></span><span id='topic+starts_with'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>tidyselect</dt><dd><p><code><a href="tidyselect.html#topic+all_of">all_of</a></code>, <code><a href="tidyselect.html#topic+all_of">any_of</a></code>, <code><a href="tidyselect.html#topic+starts_with">contains</a></code>, <code><a href="tidyselect.html#topic+starts_with">ends_with</a></code>, <code><a href="tidyselect.html#topic+everything">everything</a></code>, <code><a href="tidyselect.html#topic+everything">last_col</a></code>, <code><a href="tidyselect.html#topic+starts_with">matches</a></code>, <code><a href="tidyselect.html#topic+starts_with">num_range</a></code>, <code><a href="tidyselect.html#topic+one_of">one_of</a></code>, <code><a href="tidyselect.html#topic+starts_with">starts_with</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rstudio_addin_tar_glimpse'>RStudio addin to call <code><a href="#topic+tar_glimpse">tar_glimpse()</a></code>.</h2><span id='topic+rstudio_addin_tar_glimpse'></span>

<h3>Description</h3>

<p>For internal use only. Not a user-side function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstudio_addin_tar_glimpse()
</code></pre>

<hr>
<h2 id='rstudio_addin_tar_load'>RStudio addin to call <code><a href="#topic+tar_load">tar_load()</a></code> on the symbol at the cursor.</h2><span id='topic+rstudio_addin_tar_load'></span>

<h3>Description</h3>

<p>For internal use only. Not a user-side function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstudio_addin_tar_load(context = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstudio_addin_tar_load_+3A_context">context</code></td>
<td>
<p>RStudio API context from
<code>rstudioapi::getActiveDocumentContext()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='rstudio_addin_tar_make_bg'>RStudio addin to run <code><a href="#topic+tar_make">tar_make()</a></code> in the background.</h2><span id='topic+rstudio_addin_tar_make_bg'></span>

<h3>Description</h3>

<p>For internal use only. Not a user-side function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstudio_addin_tar_make_bg()
</code></pre>

<hr>
<h2 id='rstudio_addin_tar_outdated'>RStudio addin to call <code><a href="#topic+tar_outdated">tar_outdated()</a></code>.</h2><span id='topic+rstudio_addin_tar_outdated'></span>

<h3>Description</h3>

<p>For internal use only. Not a user-side function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstudio_addin_tar_outdated()
</code></pre>

<hr>
<h2 id='rstudio_addin_tar_progress'>RStudio addin to print <code>tail(tar_progress())</code>.</h2><span id='topic+rstudio_addin_tar_progress'></span>

<h3>Description</h3>

<p>For internal use only. Not a user-side function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstudio_addin_tar_progress()
</code></pre>

<hr>
<h2 id='rstudio_addin_tar_read'>RStudio addin to call <code><a href="#topic+tar_read">tar_read()</a></code> on the symbol at the cursor.</h2><span id='topic+rstudio_addin_tar_read'></span>

<h3>Description</h3>

<p>For internal use only. Not a user-side function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstudio_addin_tar_read(context = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstudio_addin_tar_read_+3A_context">context</code></td>
<td>
<p>RStudio API context from
<code>rstudioapi::getActiveDocumentContext()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='rstudio_addin_tar_target'>RStudio addin to insert <code>"tar_target()"</code> at the cursor.</h2><span id='topic+rstudio_addin_tar_target'></span>

<h3>Description</h3>

<p>For internal use only. Not a user-side function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstudio_addin_tar_target(context = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rstudio_addin_tar_target_+3A_context">context</code></td>
<td>
<p>RStudio API context from
<code>rstudioapi::getActiveDocumentContext()</code>.</p>
</td></tr>
</table>

<hr>
<h2 id='rstudio_addin_tar_visnetwork'>RStudio addin to call <code><a href="#topic+tar_visnetwork">tar_visnetwork()</a></code>.</h2><span id='topic+rstudio_addin_tar_visnetwork'></span>

<h3>Description</h3>

<p>For internal use only. Not a user-side function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstudio_addin_tar_visnetwork()
</code></pre>

<hr>
<h2 id='tar_active'>Show if the pipeline is running.</h2><span id='topic+tar_active'></span>

<h3>Description</h3>

<p>Return <code>TRUE</code> if called in a target or <code style="white-space: pre;">&#8288;_targets.R&#8288;</code> and
the pipeline is running.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_active()
</code></pre>


<h3>Value</h3>

<p>Logical of length 1, <code>TRUE</code> if called in a target or <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>
and the pipeline is running (<code>FALSE</code> otherwise).
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+tar_backoff">tar_backoff</a>()</code>,
<code><a href="#topic+tar_call">tar_call</a>()</code>,
<code><a href="#topic+tar_cancel">tar_cancel</a>()</code>,
<code><a href="#topic+tar_definition">tar_definition</a>()</code>,
<code><a href="#topic+tar_described_as">tar_described_as</a>()</code>,
<code><a href="#topic+tar_envir">tar_envir</a>()</code>,
<code><a href="#topic+tar_group">tar_group</a>()</code>,
<code><a href="#topic+tar_name">tar_name</a>()</code>,
<code><a href="#topic+tar_path">tar_path</a>()</code>,
<code><a href="#topic+tar_path_script">tar_path_script</a>()</code>,
<code><a href="#topic+tar_path_script_support">tar_path_script_support</a>()</code>,
<code><a href="#topic+tar_path_store">tar_path_store</a>()</code>,
<code><a href="#topic+tar_path_target">tar_path_target</a>()</code>,
<code><a href="#topic+tar_source">tar_source</a>()</code>,
<code><a href="#topic+tar_store">tar_store</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_active() # FALSE
tar_script({
  message("Pipeline running? ", tar_active())
  tar_target(x, tar_active())
})
tar_manifest() # prints "Pipeline running? FALSE"
tar_make() # prints "pipeline running? TRUE"
tar_read(x) # TRUE
})
}
</code></pre>

<hr>
<h2 id='tar_assert'>Assertions</h2><span id='topic+tar_assert'></span><span id='topic+tar_assert_chr'></span><span id='topic+tar_assert_dbl'></span><span id='topic+tar_assert_df'></span><span id='topic+tar_assert_equal_lengths'></span><span id='topic+tar_assert_envir'></span><span id='topic+tar_assert_expr'></span><span id='topic+tar_assert_flag'></span><span id='topic+tar_assert_file'></span><span id='topic+tar_assert_finite'></span><span id='topic+tar_assert_function'></span><span id='topic+tar_assert_function_arguments'></span><span id='topic+tar_assert_ge'></span><span id='topic+tar_assert_identical'></span><span id='topic+tar_assert_in'></span><span id='topic+tar_assert_not_dirs'></span><span id='topic+tar_assert_not_dir'></span><span id='topic+tar_assert_not_in'></span><span id='topic+tar_assert_inherits'></span><span id='topic+tar_assert_int'></span><span id='topic+tar_assert_internet'></span><span id='topic+tar_assert_lang'></span><span id='topic+tar_assert_le'></span><span id='topic+tar_assert_list'></span><span id='topic+tar_assert_lgl'></span><span id='topic+tar_assert_name'></span><span id='topic+tar_assert_named'></span><span id='topic+tar_assert_names'></span><span id='topic+tar_assert_nonempty'></span><span id='topic+tar_assert_null'></span><span id='topic+tar_assert_not_expr'></span><span id='topic+tar_assert_nzchar'></span><span id='topic+tar_assert_package'></span><span id='topic+tar_assert_path'></span><span id='topic+tar_assert_match'></span><span id='topic+tar_assert_nonmissing'></span><span id='topic+tar_assert_positive'></span><span id='topic+tar_assert_scalar'></span><span id='topic+tar_assert_store'></span><span id='topic+tar_assert_target'></span><span id='topic+tar_assert_target_list'></span><span id='topic+tar_assert_true'></span><span id='topic+tar_assert_unique'></span><span id='topic+tar_assert_unique_targets'></span>

<h3>Description</h3>

<p>These functions assert the correctness of user inputs
and generate custom error conditions as needed. Useful
for writing packages built on top of <code>targets</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_assert_chr(x, msg = NULL)

tar_assert_dbl(x, msg = NULL)

tar_assert_df(x, msg = NULL)

tar_assert_equal_lengths(x, msg = NULL)

tar_assert_envir(x, msg = NULL)

tar_assert_expr(x, msg = NULL)

tar_assert_flag(x, choices, msg = NULL)

tar_assert_file(x)

tar_assert_finite(x, msg = NULL)

tar_assert_function(x, msg = NULL)

tar_assert_function_arguments(x, args, msg = NULL)

tar_assert_ge(x, threshold, msg = NULL)

tar_assert_identical(x, y, msg = NULL)

tar_assert_in(x, choices, msg = NULL)

tar_assert_not_dirs(x, msg = NULL)

tar_assert_not_dir(x, msg = NULL)

tar_assert_not_in(x, choices, msg = NULL)

tar_assert_inherits(x, class, msg = NULL)

tar_assert_int(x, msg = NULL)

tar_assert_internet(msg = NULL)

tar_assert_lang(x, msg = NULL)

tar_assert_le(x, threshold, msg = NULL)

tar_assert_list(x, msg = NULL)

tar_assert_lgl(x, msg = NULL)

tar_assert_name(x)

tar_assert_named(x, msg = NULL)

tar_assert_names(x, msg = NULL)

tar_assert_nonempty(x, msg = NULL)

tar_assert_null(x, msg = NULL)

tar_assert_not_expr(x, msg = NULL)

tar_assert_nzchar(x, msg = NULL)

tar_assert_package(package, msg = NULL)

tar_assert_path(path, msg = NULL)

tar_assert_match(x, pattern, msg = NULL)

tar_assert_nonmissing(x, msg = NULL)

tar_assert_positive(x, msg = NULL)

tar_assert_scalar(x, msg = NULL)

tar_assert_store(store)

tar_assert_target(x, msg = NULL)

tar_assert_target_list(x)

tar_assert_true(x, msg = NULL)

tar_assert_unique(x, msg = NULL)

tar_assert_unique_targets(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_assert_+3A_x">x</code></td>
<td>
<p>R object, input to be validated. The kind of object depends on the
specific assertion function called.</p>
</td></tr>
<tr><td><code id="tar_assert_+3A_msg">msg</code></td>
<td>
<p>Character of length 1, a message to be printed to the console
if <code>x</code> is invalid.</p>
</td></tr>
<tr><td><code id="tar_assert_+3A_choices">choices</code></td>
<td>
<p>Character vector of choices of <code>x</code> for certain assertions.</p>
</td></tr>
<tr><td><code id="tar_assert_+3A_args">args</code></td>
<td>
<p>Character vector of expected function argument names.
Order matters.</p>
</td></tr>
<tr><td><code id="tar_assert_+3A_threshold">threshold</code></td>
<td>
<p>Numeric of length 1, lower/upper bound for
assertions like <code>tar_assert_le()</code>/<code>tar_assert_ge()</code>.</p>
</td></tr>
<tr><td><code id="tar_assert_+3A_y">y</code></td>
<td>
<p>R object, value to compare against <code>x</code>.</p>
</td></tr>
<tr><td><code id="tar_assert_+3A_class">class</code></td>
<td>
<p>Character vector of expected class names.</p>
</td></tr>
<tr><td><code id="tar_assert_+3A_package">package</code></td>
<td>
<p>Character of length 1, name of an R package.</p>
</td></tr>
<tr><td><code id="tar_assert_+3A_path">path</code></td>
<td>
<p>Character, file path.</p>
</td></tr>
<tr><td><code id="tar_assert_+3A_pattern">pattern</code></td>
<td>
<p>Character of length 1, a <code>grep</code> pattern for certain
assertions.</p>
</td></tr>
<tr><td><code id="tar_assert_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the data store of the pipeline.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other utilities to extend targets: 
<code><a href="#topic+tar_condition">tar_condition</a></code>,
<code><a href="#topic+tar_language">tar_language</a></code>,
<code><a href="#topic+tar_test">tar_test</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_assert_chr("123")
try(tar_assert_chr(123))
</code></pre>

<hr>
<h2 id='tar_backoff'>Superseded: exponential backoff</h2><span id='topic+tar_backoff'></span>

<h3>Description</h3>

<p>Superseded: configure exponential backoff
while polling for tasks during the pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_backoff(min = 0.001, max = 0.1, rate = 1.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_backoff_+3A_min">min</code></td>
<td>
<p>Positive numeric of length 1,
minimum polling interval in seconds.
Must be at least <code>sqrt(.Machine$double.eps)</code>.</p>
</td></tr>
<tr><td><code id="tar_backoff_+3A_max">max</code></td>
<td>
<p>Positive numeric of length 1,
maximum polling interval in seconds.
Must be at least <code>sqrt(.Machine$double.eps)</code>.</p>
</td></tr>
<tr><td><code id="tar_backoff_+3A_rate">rate</code></td>
<td>
<p>Positive numeric of length 1, greater than or equal to 1.
Multiplicative rate parameter that allows the exponential backoff
minimum polling interval to increase from <code>min</code> to <code>max</code>.
Actual polling intervals are sampled uniformly from the current
minimum to <code>max</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is superseded and is now only relevant to other
superseded functions <code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="#topic+tar_make_future">tar_make_future()</a></code>.
<code><a href="#topic+tar_make">tar_make()</a></code> uses <code>crew</code> in an efficient non-polling way, making
exponential backoff unnecessary.
</p>


<h3>Backoff</h3>

<p>In high-performance computing it can be expensive to repeatedly poll the
priority queue if no targets are ready to process. The number of seconds
between polls is <code>runif(1, min, max(max, min * rate ^ index))</code>,
where <code>index</code> is the number of consecutive polls so far that found
no targets ready to skip or run, and <code>min</code>, <code>max</code>, and <code>rate</code>
are arguments to <code><a href="#topic+tar_backoff">tar_backoff()</a></code>.
(If no target is ready, <code>index</code> goes up by 1. If a target is ready,
<code>index</code> resets to 0. For more information on exponential,
backoff, visit <a href="https://en.wikipedia.org/wiki/Exponential_backoff">https://en.wikipedia.org/wiki/Exponential_backoff</a>).
Raising <code>min</code> or <code>max</code> is kinder to the CPU etc. but may incur delays
in some instances.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+tar_active">tar_active</a>()</code>,
<code><a href="#topic+tar_call">tar_call</a>()</code>,
<code><a href="#topic+tar_cancel">tar_cancel</a>()</code>,
<code><a href="#topic+tar_definition">tar_definition</a>()</code>,
<code><a href="#topic+tar_described_as">tar_described_as</a>()</code>,
<code><a href="#topic+tar_envir">tar_envir</a>()</code>,
<code><a href="#topic+tar_group">tar_group</a>()</code>,
<code><a href="#topic+tar_name">tar_name</a>()</code>,
<code><a href="#topic+tar_path">tar_path</a>()</code>,
<code><a href="#topic+tar_path_script">tar_path_script</a>()</code>,
<code><a href="#topic+tar_path_script_support">tar_path_script_support</a>()</code>,
<code><a href="#topic+tar_path_store">tar_path_store</a>()</code>,
<code><a href="#topic+tar_path_target">tar_path_target</a>()</code>,
<code><a href="#topic+tar_source">tar_source</a>()</code>,
<code><a href="#topic+tar_store">tar_store</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_option_set(backoff = tar_backoff(min = 0.001, max = 0.1, rate = 1.5))
})
}
</code></pre>

<hr>
<h2 id='tar_bind'>Combine pipeline objects (deprecated).</h2><span id='topic+tar_bind'></span>

<h3>Description</h3>

<p>Functions <code>tar_pipeline()</code> and <code><a href="#topic+tar_bind">tar_bind()</a></code> are deprecated.
Instead, simply end your target script file
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) file with a list of target objects.
You can nest these objects however you like.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_bind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_bind_+3A_...">...</code></td>
<td>
<p>Pipeline objects or nested lists of pipeline objects.
You can generate a pipeline object with <code><a href="#topic+tar_pipeline">tar_pipeline()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Deprecated on 2021-01-03.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In your target script file (default: _targets.R):
library(targets)
list( # You no longer need tar_pipeline() here.
  tar_target(data_file, "data.csv", format = "file"),
  list( # Target lists can be arbitrarily nested.
    tar_target(data_object, read.csv(data_file)),
    tar_target(analysis, analyze(data_object))
  )
)
</code></pre>

<hr>
<h2 id='tar_branch_index'>Integer branch indexes</h2><span id='topic+tar_branch_index'></span>

<h3>Description</h3>

<p>Get the integer indexes of individual branch names
within their corresponding dynamic branching targets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_branch_index(names, store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_branch_index_+3A_names">names</code></td>
<td>
<p>Character vector of branch names.</p>
</td></tr>
<tr><td><code id="tar_branch_index_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named integer vector of branch indexes.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_branch_names">tar_branch_names</a>()</code>,
<code><a href="#topic+tar_branch_names_raw">tar_branch_names_raw</a>()</code>,
<code><a href="#topic+tar_branches">tar_branches</a>()</code>,
<code><a href="#topic+tar_pattern">tar_pattern</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(4)),
    tar_target(y, 2 * x, pattern = map(x)),
    tar_target(z, y, pattern = map(y))
  )
}, ask = FALSE)
tar_make()
names &lt;- c(
  tar_meta(y, children)$children[[1]][c(2, 3)],
  tar_meta(z, children)$children[[1]][2]
)
names
tar_branch_index(names) # c(2, 3, 2)
})
}
</code></pre>

<hr>
<h2 id='tar_branch_names'>Branch names</h2><span id='topic+tar_branch_names'></span>

<h3>Description</h3>

<p>Get the branch names of a dynamic branching target
using numeric indexes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_branch_names(name, index, store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_branch_names_+3A_name">name</code></td>
<td>
<p>Symbol, name of the dynamic branching target (pattern).</p>
</td></tr>
<tr><td><code id="tar_branch_names_+3A_index">index</code></td>
<td>
<p>Integer vector of branch indexes.</p>
</td></tr>
<tr><td><code id="tar_branch_names_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of branch names.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_branch_index">tar_branch_index</a>()</code>,
<code><a href="#topic+tar_branch_names_raw">tar_branch_names_raw</a>()</code>,
<code><a href="#topic+tar_branches">tar_branches</a>()</code>,
<code><a href="#topic+tar_pattern">tar_pattern</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(4)),
    tar_target(y, 2 * x, pattern = map(x)),
    tar_target(z, y, pattern = map(y))
  )
}, ask = FALSE)
tar_make()
tar_branch_names(z, c(2, 3))
})
}
</code></pre>

<hr>
<h2 id='tar_branch_names_raw'>Branch names (raw version)</h2><span id='topic+tar_branch_names_raw'></span>

<h3>Description</h3>

<p>Get the branch names of a dynamic branching target
using numeric indexes. Same as <code><a href="#topic+tar_branch_names">tar_branch_names()</a></code> except
<code>name</code> is a character of length 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_branch_names_raw(name, index, store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_branch_names_raw_+3A_name">name</code></td>
<td>
<p>Character of length 1,
name of the dynamic branching target (pattern).</p>
</td></tr>
<tr><td><code id="tar_branch_names_raw_+3A_index">index</code></td>
<td>
<p>Integer vector of branch indexes.</p>
</td></tr>
<tr><td><code id="tar_branch_names_raw_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of branch names.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_branch_index">tar_branch_index</a>()</code>,
<code><a href="#topic+tar_branch_names">tar_branch_names</a>()</code>,
<code><a href="#topic+tar_branches">tar_branches</a>()</code>,
<code><a href="#topic+tar_pattern">tar_pattern</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(w, 1),
    tar_target(x, seq_len(4)),
    tar_target(y, 2 * x, pattern = map(x)),
    tar_target(z, y, pattern = map(y))
  )
}, ask = FALSE)
tar_make()
tar_branch_names_raw("z", c(2, 3))
})
}
</code></pre>

<hr>
<h2 id='tar_branches'>Reconstruct the branch names and the names of their dependencies.</h2><span id='topic+tar_branches'></span>

<h3>Description</h3>

<p>Given a branching pattern, use available metadata
to reconstruct branch names and the names of each
branch's dependencies. The metadata of each target
must already exist and be consistent with the metadata
of the other targets involved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_branches(name, pattern, store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_branches_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target.</p>
</td></tr>
<tr><td><code id="tar_branches_+3A_pattern">pattern</code></td>
<td>
<p>Language to define branching for a target.
For example, in a pipeline with numeric vector targets <code>x</code> and <code>y</code>,
<code>tar_target(z, x + y, pattern = map(x, y))</code> implicitly defines
branches of <code>z</code> that each compute <code>x[1] + y[1]</code>, <code>x[2] + y[2]</code>,
and so on. See the user manual for details.</p>
</td></tr>
<tr><td><code id="tar_branches_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The results from this function can help you retroactively
figure out correspondences between upstream branches and downstream
branches. However, it does not always correctly predict what the
names of the branches will be after the next run of the pipeline.
Dynamic branching happens while the pipeline is running,
so we cannot always know what the names of the branches will be
in advance (or even how many there will be).
</p>


<h3>Value</h3>

<p>A <code>tibble</code> with one row per branch and one column for each target
(including the branched-over targets and the target with the pattern.)
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_branch_index">tar_branch_index</a>()</code>,
<code><a href="#topic+tar_branch_names">tar_branch_names</a>()</code>,
<code><a href="#topic+tar_branch_names_raw">tar_branch_names_raw</a>()</code>,
<code><a href="#topic+tar_pattern">tar_pattern</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(2)),
    tar_target(y, head(letters, 2)),
    tar_target(z, head(LETTERS, 2)),
    tar_target(dynamic, c(x, y, z), pattern = cross(z, map(x, y)))
  )
}, ask = FALSE)
tar_make()
tar_branches(dynamic, pattern = cross(z, map(x, y)))
})
}
</code></pre>

<hr>
<h2 id='tar_built'>Deprecated: list built targets.</h2><span id='topic+tar_built'></span>

<h3>Description</h3>

<p>Deprecated in favor of <code><a href="#topic+tar_completed">tar_completed()</a></code> on 2023-12-04
(version 1.3.2.9004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_built(names = NULL, store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_built_+3A_names">names</code></td>
<td>
<p>Optional, names of the targets. If supplied, the
output is restricted to the selected targets.
The object supplied to <code>names</code> should be <code>NULL</code> or a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_built_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of completed targets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(2)),
    tar_target(y, 2 * x, pattern = map(x))
  )
}, ask = FALSE)
tar_make()
tar_completed()
tar_completed(starts_with("y_")) # see also any_of()
})
}
</code></pre>

<hr>
<h2 id='tar_call'>Identify the called <code>targets</code> function.</h2><span id='topic+tar_call'></span>

<h3>Description</h3>

<p>Get the name of the currently running <code>targets</code>
interface function. Returns <code>NULL</code> if not invoked inside
a target or <code style="white-space: pre;">&#8288;_targets.R&#8288;</code> (i.e. if not directly invoked
by <code><a href="#topic+tar_make">tar_make()</a></code>, <code><a href="#topic+tar_visnetwork">tar_visnetwork()</a></code>, etc.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_call()
</code></pre>


<h3>Value</h3>

<p>Character of length 1, name of the currently running <code>targets</code>
interface function. For example, suppose you have a call to
<code>tar_call()</code> inside a target or <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. Then if you run
<code>tar_make()</code>, <code>tar_call()</code> will return <code>"tar_make"</code>.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+tar_active">tar_active</a>()</code>,
<code><a href="#topic+tar_backoff">tar_backoff</a>()</code>,
<code><a href="#topic+tar_cancel">tar_cancel</a>()</code>,
<code><a href="#topic+tar_definition">tar_definition</a>()</code>,
<code><a href="#topic+tar_described_as">tar_described_as</a>()</code>,
<code><a href="#topic+tar_envir">tar_envir</a>()</code>,
<code><a href="#topic+tar_group">tar_group</a>()</code>,
<code><a href="#topic+tar_name">tar_name</a>()</code>,
<code><a href="#topic+tar_path">tar_path</a>()</code>,
<code><a href="#topic+tar_path_script">tar_path_script</a>()</code>,
<code><a href="#topic+tar_path_script_support">tar_path_script_support</a>()</code>,
<code><a href="#topic+tar_path_store">tar_path_store</a>()</code>,
<code><a href="#topic+tar_path_target">tar_path_target</a>()</code>,
<code><a href="#topic+tar_source">tar_source</a>()</code>,
<code><a href="#topic+tar_store">tar_store</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_call() # NULL
tar_script({
  message("called function: ", tar_call())
  tar_target(x, tar_call())
})
tar_manifest() # prints "called function: tar_manifest"
tar_make() # prints "called function: tar_make"
tar_read(x) # "tar_make"
})
}
</code></pre>

<hr>
<h2 id='tar_callr_args_default'>Default <code>callr</code> arguments.</h2><span id='topic+tar_callr_args_default'></span>

<h3>Description</h3>

<p>Default <code>callr</code> arguments for the <code>callr_arguments</code>
argument of <code><a href="#topic+tar_make">tar_make()</a></code> and related functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_callr_args_default(callr_function, reporter = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_callr_args_default_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from the <code>callr</code> package
that starts an external R process.</p>
</td></tr>
<tr><td><code id="tar_callr_args_default_+3A_reporter">reporter</code></td>
<td>
<p>Character of length 1, choice of reporter
for <code><a href="#topic+tar_make">tar_make()</a></code> or a related function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not a user-side function. Do not invoke directly.
Exported for internal purposes only.
</p>


<h3>Value</h3>

<p>A list of arguments to <code>callr_function</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_callr_args_default(callr::r)
</code></pre>

<hr>
<h2 id='tar_callr_inner_try'>Invoke a <code>targets</code> task from inside a <code>callr</code> function
(without error handling).</h2><span id='topic+tar_callr_inner_try'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not invoke directly.
Exported for internal purposes only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_callr_inner_try(
  targets_function,
  targets_arguments,
  options,
  envir = NULL,
  parent,
  script,
  store,
  fun,
  pid_parent
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_callr_inner_try_+3A_targets_function">targets_function</code></td>
<td>
<p>A function from <code>targets</code> to call.</p>
</td></tr>
<tr><td><code id="tar_callr_inner_try_+3A_targets_arguments">targets_arguments</code></td>
<td>
<p>Named list of arguments of targets_function.</p>
</td></tr>
<tr><td><code id="tar_callr_inner_try_+3A_options">options</code></td>
<td>
<p>Names of global options to temporarily set
in the <code>callr</code> process.</p>
</td></tr>
<tr><td><code id="tar_callr_inner_try_+3A_envir">envir</code></td>
<td>
<p>Name of the environment to run in. If <code>NULL</code>,
the environment defaults to <code>tar_option_get("envir")</code>.</p>
</td></tr>
<tr><td><code id="tar_callr_inner_try_+3A_parent">parent</code></td>
<td>
<p>Parent environment of the call to
<code>tar_call_inner()</code>.</p>
</td></tr>
<tr><td><code id="tar_callr_inner_try_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_callr_inner_try_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
<tr><td><code id="tar_callr_inner_try_+3A_fun">fun</code></td>
<td>
<p>Character of length 1, name of the <code>targets</code>
function being called.</p>
</td></tr>
<tr><td><code id="tar_callr_inner_try_+3A_pid_parent">pid_parent</code></td>
<td>
<p>Integer of length 1, process ID of the calling process,
e.g. the one that called <code><a href="#topic+tar_make">tar_make()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output of a call to a <code>targets</code> function that uses
<code>callr</code> for reproducibility.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the examples of tar_make().
</code></pre>

<hr>
<h2 id='tar_cancel'>Cancel a target mid-execution under a custom condition.</h2><span id='topic+tar_cancel'></span>

<h3>Description</h3>

<p>Cancel a target while its command is running
if a condition is met.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_cancel(condition = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_cancel_+3A_condition">condition</code></td>
<td>
<p>Logical of length 1, whether to cancel the target.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Must be invoked by the target itself. <code>tar_cancel()</code>
cannot interrupt a target from another process.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+tar_active">tar_active</a>()</code>,
<code><a href="#topic+tar_backoff">tar_backoff</a>()</code>,
<code><a href="#topic+tar_call">tar_call</a>()</code>,
<code><a href="#topic+tar_definition">tar_definition</a>()</code>,
<code><a href="#topic+tar_described_as">tar_described_as</a>()</code>,
<code><a href="#topic+tar_envir">tar_envir</a>()</code>,
<code><a href="#topic+tar_group">tar_group</a>()</code>,
<code><a href="#topic+tar_name">tar_name</a>()</code>,
<code><a href="#topic+tar_path">tar_path</a>()</code>,
<code><a href="#topic+tar_path_script">tar_path_script</a>()</code>,
<code><a href="#topic+tar_path_script_support">tar_path_script_support</a>()</code>,
<code><a href="#topic+tar_path_store">tar_path_store</a>()</code>,
<code><a href="#topic+tar_path_target">tar_path_target</a>()</code>,
<code><a href="#topic+tar_source">tar_source</a>()</code>,
<code><a href="#topic+tar_store">tar_store</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(tar_target(x, tar_cancel(1 &gt; 0)))
tar_make() # Should cancel target x.
})
}
</code></pre>

<hr>
<h2 id='tar_canceled'>List canceled targets.</h2><span id='topic+tar_canceled'></span>

<h3>Description</h3>

<p>List targets whose progress is <code>"canceled"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_canceled(names = NULL, store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_canceled_+3A_names">names</code></td>
<td>
<p>Optional, names of the targets. If supplied, the
output is restricted to the selected targets.
The object supplied to <code>names</code> should be <code>NULL</code> or a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_canceled_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of canceled targets.
</p>


<h3>See Also</h3>

<p>Other progress: 
<code><a href="#topic+tar_completed">tar_completed</a>()</code>,
<code><a href="#topic+tar_dispatched">tar_dispatched</a>()</code>,
<code><a href="#topic+tar_errored">tar_errored</a>()</code>,
<code><a href="#topic+tar_poll">tar_poll</a>()</code>,
<code><a href="#topic+tar_progress">tar_progress</a>()</code>,
<code><a href="#topic+tar_progress_branches">tar_progress_branches</a>()</code>,
<code><a href="#topic+tar_progress_summary">tar_progress_summary</a>()</code>,
<code><a href="#topic+tar_skipped">tar_skipped</a>()</code>,
<code><a href="#topic+tar_watch">tar_watch</a>()</code>,
<code><a href="#topic+tar_watch_server">tar_watch_server</a>()</code>,
<code><a href="#topic+tar_watch_ui">tar_watch_ui</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(2)),
    tar_target(y, 2 * x, pattern = map(x))
  )
}, ask = FALSE)
tar_make()
tar_canceled()
tar_canceled(starts_with("y_")) # see also any_of()
})
}
</code></pre>

<hr>
<h2 id='tar_completed'>List completed targets.</h2><span id='topic+tar_completed'></span>

<h3>Description</h3>

<p>List targets whose progress is <code>"completed"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_completed(names = NULL, store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_completed_+3A_names">names</code></td>
<td>
<p>Optional, names of the targets. If supplied, the
output is restricted to the selected targets.
The object supplied to <code>names</code> should be <code>NULL</code> or a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_completed_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of completed targets.
</p>


<h3>See Also</h3>

<p>Other progress: 
<code><a href="#topic+tar_canceled">tar_canceled</a>()</code>,
<code><a href="#topic+tar_dispatched">tar_dispatched</a>()</code>,
<code><a href="#topic+tar_errored">tar_errored</a>()</code>,
<code><a href="#topic+tar_poll">tar_poll</a>()</code>,
<code><a href="#topic+tar_progress">tar_progress</a>()</code>,
<code><a href="#topic+tar_progress_branches">tar_progress_branches</a>()</code>,
<code><a href="#topic+tar_progress_summary">tar_progress_summary</a>()</code>,
<code><a href="#topic+tar_skipped">tar_skipped</a>()</code>,
<code><a href="#topic+tar_watch">tar_watch</a>()</code>,
<code><a href="#topic+tar_watch_server">tar_watch_server</a>()</code>,
<code><a href="#topic+tar_watch_ui">tar_watch_ui</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(2)),
    tar_target(y, 2 * x, pattern = map(x))
  )
}, ask = FALSE)
tar_make()
tar_completed()
tar_completed(starts_with("y_")) # see also any_of()
})
}
</code></pre>

<hr>
<h2 id='tar_condition'>Conditions</h2><span id='topic+tar_condition'></span><span id='topic+tar_message_run'></span><span id='topic+tar_throw_file'></span><span id='topic+tar_throw_run'></span><span id='topic+tar_throw_validate'></span><span id='topic+tar_warn_deprecate'></span><span id='topic+tar_warn_run'></span><span id='topic+tar_warn_validate'></span><span id='topic+tar_message_validate'></span><span id='topic+tar_print'></span><span id='topic+tar_error'></span><span id='topic+tar_warning'></span><span id='topic+tar_message'></span>

<h3>Description</h3>

<p>These functions throw custom
<code>targets</code>-specific error conditions.
Useful for error handling in packages built on top of <code>targets</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_message_run(...)

tar_throw_file(...)

tar_throw_run(..., class = character(0))

tar_throw_validate(...)

tar_warn_deprecate(...)

tar_warn_run(...)

tar_warn_validate(...)

tar_message_validate(...)

tar_print(...)

tar_error(message, class)

tar_warning(message, class)

tar_message(message, class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_condition_+3A_...">...</code></td>
<td>
<p>zero or more objects which can be coerced to character
(and which are pasted together with no separator) or a single
condition object.</p>
</td></tr>
<tr><td><code id="tar_condition_+3A_class">class</code></td>
<td>
<p>Character vector of S3 classes of the message.</p>
</td></tr>
<tr><td><code id="tar_condition_+3A_message">message</code></td>
<td>
<p>Character of length 1, text of the message.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other utilities to extend targets: 
<code><a href="#topic+tar_assert">tar_assert</a></code>,
<code><a href="#topic+tar_language">tar_language</a></code>,
<code><a href="#topic+tar_test">tar_test</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>try(tar_throw_validate("something is not valid"))
</code></pre>

<hr>
<h2 id='tar_condition_traced'>Contain an error condition and formatted traceback.</h2><span id='topic+tar_condition_traced'></span>

<h3>Description</h3>

<p>Not a user-side function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_condition_traced(condition, trace)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_condition_traced_+3A_condition">condition</code></td>
<td>
<p>An error condition object thrown by <code>stop()</code> or
<code>rlang::abort()</code>.</p>
</td></tr>
<tr><td><code id="tar_condition_traced_+3A_trace">trace</code></td>
<td>
<p>A raw return value from <code>.traceback()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Contain an error condition and formatted traceback.
</p>

<hr>
<h2 id='tar_config_get'>Get configuration settings.</h2><span id='topic+tar_config_get'></span>

<h3>Description</h3>

<p>Read the custom settings for the current project
in the optional YAML configuration file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_config_get(
  name,
  config = Sys.getenv("TAR_CONFIG", "_targets.yaml"),
  project = Sys.getenv("TAR_PROJECT", "main")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_config_get_+3A_name">name</code></td>
<td>
<p>Character of length 1, name of the specific
configuration setting to retrieve.</p>
</td></tr>
<tr><td><code id="tar_config_get_+3A_config">config</code></td>
<td>
<p>Character of length 1, file path of the YAML
configuration file with <code>targets</code> project settings.
The <code>config</code> argument specifies which YAML configuration
file that <code>tar_config_get()</code> reads from or <code>tar_config_set()</code>
writes to in a single function call.
It does not globally change which configuration file is used
in subsequent function calls. The default file path of the YAML
file is always <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code> unless you set another
default path using the <code>TAR_CONFIG</code> environment variable,
e.g. <code>Sys.setenv(TAR_CONFIG = "custom.yaml")</code>. This also has the
effect of temporarily modifying the default arguments to other functions
such as <code><a href="#topic+tar_make">tar_make()</a></code> because the default arguments
to those functions are controlled by <code>tar_config_get()</code>.</p>
</td></tr>
<tr><td><code id="tar_config_get_+3A_project">project</code></td>
<td>
<p>Character of length 1, name of the current
<code>targets</code> project. Thanks to the <code>config</code> R package,
<code>targets</code> YAML configuration files can store multiple
sets of configuration settings, with each set corresponding
to its own project. The <code>project</code> argument allows you to
set or get a configuration setting for a specific project
for a given call to <code>tar_config_set()</code> or <code>tar_config_get()</code>.
The default project is always called <code>"main"</code>
unless you set another
default project using the <code>TAR_PROJECT</code> environment variable,
e.g. <code>Sys.setenv(tar_project = "custom")</code>. This also has the
effect of temporarily modifying the default arguments to other functions
such as <code><a href="#topic+tar_make">tar_make()</a></code> because the default arguments
to those functions are controlled by <code>tar_config_get()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the configuration setting from
the YAML configuration file (default: <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>)
or the default value if the setting is not available.
The data type of the return value depends on your choice
of <code>name</code>.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>Configuration</h3>

<p>For several key functions like <code><a href="#topic+tar_make">tar_make()</a></code>, the
default values of arguments are controlled though
<code>tar_config_get()</code>. <code>tar_config_get()</code> retrieves data
from an optional YAML configuration file.
You can control the settings in the YAML
file programmatically with <code>tar_config_set()</code>.
The default file path of this YAML file is <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>, and you can
set another path globally using the <code>TAR_CONFIG</code>
environment variable. The YAML file can store configuration
settings for multiple projects, and you can globally
set the default project with the <code>TAR_PROJECT</code> environment
variable.
The structure of the YAML file
follows rules similar to the <code>config</code> R package, e.g.
projects can inherit settings from one another using the <code>inherits</code> field.
Exceptions include:
</p>

<ol>
<li><p> There is no requirement to have a configuration named <code>"default"</code>.
</p>
</li>
<li><p> Other projects do not inherit from the default project' automatically.
</p>
</li>
<li><p> Not all fields need values because <code>targets</code> already has defaults.
</p>
</li></ol>

<p><code>targets</code> does not actually invoke
the <code>config</code> package. The implementation in <code>targets</code>
was written from scratch without viewing or copying any
part of the source code of <code>config</code>.
</p>


<h3>See Also</h3>

<p>Other configuration: 
<code><a href="#topic+tar_config_projects">tar_config_projects</a>()</code>,
<code><a href="#topic+tar_config_set">tar_config_set</a>()</code>,
<code><a href="#topic+tar_config_unset">tar_config_unset</a>()</code>,
<code><a href="#topic+tar_config_yaml">tar_config_yaml</a>()</code>,
<code><a href="#topic+tar_envvars">tar_envvars</a>()</code>,
<code><a href="#topic+tar_option_get">tar_option_get</a>()</code>,
<code><a href="#topic+tar_option_reset">tar_option_reset</a>()</code>,
<code><a href="#topic+tar_option_set">tar_option_set</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(list(tar_target(x, 1 + 1)))
tar_config_get("store") # "_targets"
store_path &lt;- tempfile()
tar_config_set(store = store_path)
tar_config_get("store") # Shows a temp file.
tar_make() # Writes to the custom data store identified in _targets.yaml.
tar_read(x) # tar_read() knows about _targets.yaml too.
file.exists("_targets") # FALSE
file.exists(store_path) # TRUE
})
}
</code></pre>

<hr>
<h2 id='tar_config_projects'>List projects.</h2><span id='topic+tar_config_projects'></span>

<h3>Description</h3>

<p>List the names of projects defined in <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_config_projects(config = Sys.getenv("TAR_CONFIG", "_targets.yaml"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_config_projects_+3A_config">config</code></td>
<td>
<p>Character of length 1, file path of the YAML
configuration file with <code>targets</code> project settings.
The <code>config</code> argument specifies which YAML configuration
file that <code>tar_config_get()</code> reads from or <code>tar_config_set()</code>
writes to in a single function call.
It does not globally change which configuration file is used
in subsequent function calls. The default file path of the YAML
file is always <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code> unless you set another
default path using the <code>TAR_CONFIG</code> environment variable,
e.g. <code>Sys.setenv(TAR_CONFIG = "custom.yaml")</code>. This also has the
effect of temporarily modifying the default arguments to other functions
such as <code><a href="#topic+tar_make">tar_make()</a></code> because the default arguments
to those functions are controlled by <code>tar_config_get()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of names of projects defined in <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>Configuration</h3>

<p>For several key functions like <code><a href="#topic+tar_make">tar_make()</a></code>, the
default values of arguments are controlled though
<code>tar_config_get()</code>. <code>tar_config_get()</code> retrieves data
from an optional YAML configuration file.
You can control the settings in the YAML
file programmatically with <code>tar_config_set()</code>.
The default file path of this YAML file is <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>, and you can
set another path globally using the <code>TAR_CONFIG</code>
environment variable. The YAML file can store configuration
settings for multiple projects, and you can globally
set the default project with the <code>TAR_PROJECT</code> environment
variable.
The structure of the YAML file
follows rules similar to the <code>config</code> R package, e.g.
projects can inherit settings from one another using the <code>inherits</code> field.
Exceptions include:
</p>

<ol>
<li><p> There is no requirement to have a configuration named <code>"default"</code>.
</p>
</li>
<li><p> Other projects do not inherit from the default project' automatically.
</p>
</li>
<li><p> Not all fields need values because <code>targets</code> already has defaults.
</p>
</li></ol>

<p><code>targets</code> does not actually invoke
the <code>config</code> package. The implementation in <code>targets</code>
was written from scratch without viewing or copying any
part of the source code of <code>config</code>.
</p>


<h3>See Also</h3>

<p>Other configuration: 
<code><a href="#topic+tar_config_get">tar_config_get</a>()</code>,
<code><a href="#topic+tar_config_set">tar_config_set</a>()</code>,
<code><a href="#topic+tar_config_unset">tar_config_unset</a>()</code>,
<code><a href="#topic+tar_config_yaml">tar_config_yaml</a>()</code>,
<code><a href="#topic+tar_envvars">tar_envvars</a>()</code>,
<code><a href="#topic+tar_option_get">tar_option_get</a>()</code>,
<code><a href="#topic+tar_option_reset">tar_option_reset</a>()</code>,
<code><a href="#topic+tar_option_set">tar_option_set</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>yaml &lt;- tempfile()
tar_config_set(store = "my_store_a", config = yaml, project = "project_a")
tar_config_set(store = "my_store_b", config = yaml, project = "project_b")
tar_config_projects(config = yaml)
</code></pre>

<hr>
<h2 id='tar_config_set'>Set configuration settings.</h2><span id='topic+tar_config_set'></span>

<h3>Description</h3>

<p><code>tar_config_set()</code> writes special custom settings
for the current project to an optional YAML configuration file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_config_set(
  inherits = NULL,
  as_job = NULL,
  garbage_collection = NULL,
  label = NULL,
  label_width = NULL,
  level_separation = NULL,
  reporter_make = NULL,
  reporter_outdated = NULL,
  script = NULL,
  seconds_meta_append = NULL,
  seconds_meta_upload = NULL,
  seconds_reporter = NULL,
  seconds_interval = NULL,
  store = NULL,
  shortcut = NULL,
  use_crew = NULL,
  workers = NULL,
  config = Sys.getenv("TAR_CONFIG", "_targets.yaml"),
  project = Sys.getenv("TAR_PROJECT", "main")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_config_set_+3A_inherits">inherits</code></td>
<td>
<p>Character of length 1, name of the project from which
the current project should inherit configuration settings.
The current project is the <code>project</code> argument, which
defaults to <code>Sys.getenv("TAR_PROJECT", "main")</code>.
If the <code>inherits</code> argument <code>NULL</code>, the <code>inherits</code> setting is not modified.
Use <code><a href="#topic+tar_config_unset">tar_config_unset()</a></code> to delete a setting.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_as_job">as_job</code></td>
<td>
<p>Logical of length 1, <code>as_job</code> argument of <code><a href="#topic+tar_make">tar_make()</a></code>.
<code>TRUE</code> to run as an RStudio IDE / Posit Workbench job,
<code>FALSE</code> to run as a <code>callr</code> process in the main R session
(depending on the <code>callr_function</code> argument).
If <code>as_job_</code> is <code>TRUE</code>, then the <code>rstudioapi</code> package must be installed.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical of length 1, <code>garbage_collection</code>
argument of <code><a href="#topic+tar_make">tar_make()</a></code> (if <code>crew</code> is enabled),
<code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code>, and <code><a href="#topic+tar_make_future">tar_make_future()</a></code>.
Whether to run garbage collection on the main process
before sending a target
to a worker. For <code><a href="#topic+tar_make">tar_make()</a></code>, this argument is
ignored if <code>tar_option_get("controller")</code> is <code>NULL</code>.
Independent from the <code>garbage_collection</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code>,
which controls garbage collection on the worker.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_label">label</code></td>
<td>
<p>Argument of <code><a href="#topic+tar_glimpse">tar_glimpse()</a></code> and <code><a href="#topic+tar_visnetwork">tar_visnetwork()</a></code>
to control node labels.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_label_width">label_width</code></td>
<td>
<p>Argument of <code><a href="#topic+tar_glimpse">tar_glimpse()</a></code> and <code><a href="#topic+tar_visnetwork">tar_visnetwork()</a></code>
to control the maximum width (number of characters wide)
of the node labels.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_level_separation">level_separation</code></td>
<td>
<p>Argument of <code><a href="#topic+tar_visnetwork">tar_visnetwork()</a></code> and <code><a href="#topic+tar_glimpse">tar_glimpse()</a></code>
to control the space between hierarchical levels.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_reporter_make">reporter_make</code></td>
<td>
<p>Character of length 1, <code>reporter</code> argument to
<code><a href="#topic+tar_make">tar_make()</a></code> and related functions that run the pipeline.
If the argument <code>NULL</code>, the setting is not modified.
Use <code><a href="#topic+tar_config_unset">tar_config_unset()</a></code> to delete a setting.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_reporter_outdated">reporter_outdated</code></td>
<td>
<p>Character of length 1, <code>reporter</code> argument to
<code><a href="#topic+tar_outdated">tar_outdated()</a></code> and related functions that do not run the pipeline.
If the argument <code>NULL</code>, the setting is not modified.
Use <code><a href="#topic+tar_config_unset">tar_config_unset()</a></code> to delete a setting.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the target script file
that defines the pipeline (<code style="white-space: pre;">&#8288;_targets.R&#8288;</code> by default).
This path should be either
an absolute path or a path relative to the project root where you will
call <code><a href="#topic+tar_make">tar_make()</a></code> and other functions. When <code><a href="#topic+tar_make">tar_make()</a></code> and friends
run the script from the current working directory.
If the argument <code>NULL</code>, the setting is not modified.
Use <code><a href="#topic+tar_config_unset">tar_config_unset()</a></code> to delete a setting.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_seconds_meta_append">seconds_meta_append</code></td>
<td>
<p>Argument of <code><a href="#topic+tar_make">tar_make()</a></code>, <code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code>,
and <code><a href="#topic+tar_make_future">tar_make_future()</a></code>.
Positive numeric of length 1 with the minimum
number of seconds between saves to the local metadata and progress files
in the data store.
Higher values generally make the pipeline run faster, but unsaved
work (in the event of a crash) is not up to date.
When the pipeline ends,
all the metadata and progress data is saved immediately,
regardless of <code>seconds_meta_append</code>.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_seconds_meta_upload">seconds_meta_upload</code></td>
<td>
<p>Argument of <code><a href="#topic+tar_make">tar_make()</a></code>, <code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code>,
and <code><a href="#topic+tar_make_future">tar_make_future()</a></code>.
Positive numeric of length 1 with the minimum
number of seconds between uploads of the metadata and progress data
to the cloud
(see <a href="https://books.ropensci.org/targets/cloud-storage.html">https://books.ropensci.org/targets/cloud-storage.html</a>).
Higher values generally make the pipeline run faster, but unsaved
work (in the event of a crash) may not be backed up to the cloud.
When the pipeline ends,
all the metadata and progress data is uploaded immediately,
regardless of <code>seconds_meta_upload</code>.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_seconds_reporter">seconds_reporter</code></td>
<td>
<p>Argument of <code><a href="#topic+tar_make">tar_make()</a></code>, <code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code>,
and <code><a href="#topic+tar_make_future">tar_make_future()</a></code>. Positive numeric of length 1 with the minimum
number of seconds between times when the reporter prints progress
messages to the R console.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_seconds_interval">seconds_interval</code></td>
<td>
<p>Deprecated on 2023-08-24 (version 1.2.2.9001).
Use <code>seconds_meta_append</code>, <code>seconds_meta_upload</code>,
and <code>seconds_reporter</code> instead.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the data store of the pipeline.
If <code>NULL</code>, the <code>store</code> setting is left unchanged in the
YAML configuration file (default: <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>).
Usually, the data store lives at <code style="white-space: pre;">&#8288;_targets&#8288;</code>.
Set <code>store</code> to a custom directory
to specify a path other than <code style="white-space: pre;">&#8288;_targets/&#8288;</code>. The path need not exist
before the pipeline begins, and it need not end with &quot;_targets&quot;,
but it must be writeable.
For optimal performance, choose a storage location
with fast read/write access.
If the argument <code>NULL</code>, the setting is not modified.
Use <code><a href="#topic+tar_config_unset">tar_config_unset()</a></code> to delete a setting.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_shortcut">shortcut</code></td>
<td>
<p>logical of length 1, default <code>shortcut</code> argument
to <code><a href="#topic+tar_make">tar_make()</a></code> and related functions.
If the argument <code>NULL</code>, the setting is not modified.
Use <code><a href="#topic+tar_config_unset">tar_config_unset()</a></code> to delete a setting.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_use_crew">use_crew</code></td>
<td>
<p>Logical of length 1, whether to use <code>crew</code> in <code><a href="#topic+tar_make">tar_make()</a></code>
if the <code>controller</code> option is set in <code>tar_option_set()</code> in the target
script (<code style="white-space: pre;">&#8288;_targets.R&#8288;</code>). See <a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>
for details.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_workers">workers</code></td>
<td>
<p>Positive numeric of length 1, <code>workers</code> argument of
<code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and related functions that run the pipeline
with parallel computing among targets.
If the argument <code>NULL</code>, the setting is not modified.
Use <code><a href="#topic+tar_config_unset">tar_config_unset()</a></code> to delete a setting.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_config">config</code></td>
<td>
<p>Character of length 1, file path of the YAML
configuration file with <code>targets</code> project settings.
The <code>config</code> argument specifies which YAML configuration
file that <code>tar_config_get()</code> reads from or <code>tar_config_set()</code>
writes to in a single function call.
It does not globally change which configuration file is used
in subsequent function calls. The default file path of the YAML
file is always <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code> unless you set another
default path using the <code>TAR_CONFIG</code> environment variable,
e.g. <code>Sys.setenv(TAR_CONFIG = "custom.yaml")</code>. This also has the
effect of temporarily modifying the default arguments to other functions
such as <code><a href="#topic+tar_make">tar_make()</a></code> because the default arguments
to those functions are controlled by <code>tar_config_get()</code>.</p>
</td></tr>
<tr><td><code id="tar_config_set_+3A_project">project</code></td>
<td>
<p>Character of length 1, name of the current
<code>targets</code> project. Thanks to the <code>config</code> R package,
<code>targets</code> YAML configuration files can store multiple
sets of configuration settings, with each set corresponding
to its own project. The <code>project</code> argument allows you to
set or get a configuration setting for a specific project
for a given call to <code>tar_config_set()</code> or <code>tar_config_get()</code>.
The default project is always called <code>"main"</code>
unless you set another
default project using the <code>TAR_PROJECT</code> environment variable,
e.g. <code>Sys.setenv(tar_project = "custom")</code>. This also has the
effect of temporarily modifying the default arguments to other functions
such as <code><a href="#topic+tar_make">tar_make()</a></code> because the default arguments
to those functions are controlled by <code>tar_config_get()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly)
</p>


<h3>Configuration</h3>

<p>For several key functions like <code><a href="#topic+tar_make">tar_make()</a></code>, the
default values of arguments are controlled though
<code>tar_config_get()</code>. <code>tar_config_get()</code> retrieves data
from an optional YAML configuration file.
You can control the settings in the YAML
file programmatically with <code>tar_config_set()</code>.
The default file path of this YAML file is <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>, and you can
set another path globally using the <code>TAR_CONFIG</code>
environment variable. The YAML file can store configuration
settings for multiple projects, and you can globally
set the default project with the <code>TAR_PROJECT</code> environment
variable.
The structure of the YAML file
follows rules similar to the <code>config</code> R package, e.g.
projects can inherit settings from one another using the <code>inherits</code> field.
Exceptions include:
</p>

<ol>
<li><p> There is no requirement to have a configuration named <code>"default"</code>.
</p>
</li>
<li><p> Other projects do not inherit from the default project' automatically.
</p>
</li>
<li><p> Not all fields need values because <code>targets</code> already has defaults.
</p>
</li></ol>

<p><code>targets</code> does not actually invoke
the <code>config</code> package. The implementation in <code>targets</code>
was written from scratch without viewing or copying any
part of the source code of <code>config</code>.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other configuration: 
<code><a href="#topic+tar_config_get">tar_config_get</a>()</code>,
<code><a href="#topic+tar_config_projects">tar_config_projects</a>()</code>,
<code><a href="#topic+tar_config_unset">tar_config_unset</a>()</code>,
<code><a href="#topic+tar_config_yaml">tar_config_yaml</a>()</code>,
<code><a href="#topic+tar_envvars">tar_envvars</a>()</code>,
<code><a href="#topic+tar_option_get">tar_option_get</a>()</code>,
<code><a href="#topic+tar_option_reset">tar_option_reset</a>()</code>,
<code><a href="#topic+tar_option_set">tar_option_set</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(list(tar_target(x, 1 + 1)))
tar_config_get("store") # NULL (data store defaults to "_targets/")
store_path &lt;- tempfile()
tar_config_set(store = store_path)
tar_config_get("store") # Shows a temp file.
tar_make() # Writes to the custom data store identified in _targets.yaml.
tar_read(x) # tar_read() knows about _targets.yaml too.
file.exists("_targets") # FALSE
file.exists(store_path) # TRUE
})
}
</code></pre>

<hr>
<h2 id='tar_config_unset'>Unset configuration settings.</h2><span id='topic+tar_config_unset'></span>

<h3>Description</h3>

<p>Unset (i.e. delete) one or more
custom settings for the current project
from the optional YAML configuration file.
After that, <code><a href="#topic+tar_option_get">tar_option_get()</a></code> will return the original
default values for those settings for the project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_config_unset(
  names = character(0),
  config = Sys.getenv("TAR_CONFIG", "_targets.yaml"),
  project = Sys.getenv("TAR_PROJECT", "main")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_config_unset_+3A_names">names</code></td>
<td>
<p>Character vector of configuration settings
to delete from the current project.</p>
</td></tr>
<tr><td><code id="tar_config_unset_+3A_config">config</code></td>
<td>
<p>Character of length 1, file path of the YAML
configuration file with <code>targets</code> project settings.
The <code>config</code> argument specifies which YAML configuration
file that <code>tar_config_get()</code> reads from or <code>tar_config_set()</code>
writes to in a single function call.
It does not globally change which configuration file is used
in subsequent function calls. The default file path of the YAML
file is always <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code> unless you set another
default path using the <code>TAR_CONFIG</code> environment variable,
e.g. <code>Sys.setenv(TAR_CONFIG = "custom.yaml")</code>. This also has the
effect of temporarily modifying the default arguments to other functions
such as <code><a href="#topic+tar_make">tar_make()</a></code> because the default arguments
to those functions are controlled by <code>tar_config_get()</code>.</p>
</td></tr>
<tr><td><code id="tar_config_unset_+3A_project">project</code></td>
<td>
<p>Character of length 1, name of the current
<code>targets</code> project. Thanks to the <code>config</code> R package,
<code>targets</code> YAML configuration files can store multiple
sets of configuration settings, with each set corresponding
to its own project. The <code>project</code> argument allows you to
set or get a configuration setting for a specific project
for a given call to <code>tar_config_set()</code> or <code>tar_config_get()</code>.
The default project is always called <code>"main"</code>
unless you set another
default project using the <code>TAR_PROJECT</code> environment variable,
e.g. <code>Sys.setenv(tar_project = "custom")</code>. This also has the
effect of temporarily modifying the default arguments to other functions
such as <code><a href="#topic+tar_make">tar_make()</a></code> because the default arguments
to those functions are controlled by <code>tar_config_get()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly)
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>Configuration</h3>

<p>For several key functions like <code><a href="#topic+tar_make">tar_make()</a></code>, the
default values of arguments are controlled though
<code>tar_config_get()</code>. <code>tar_config_get()</code> retrieves data
from an optional YAML configuration file.
You can control the settings in the YAML
file programmatically with <code>tar_config_set()</code>.
The default file path of this YAML file is <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>, and you can
set another path globally using the <code>TAR_CONFIG</code>
environment variable. The YAML file can store configuration
settings for multiple projects, and you can globally
set the default project with the <code>TAR_PROJECT</code> environment
variable.
The structure of the YAML file
follows rules similar to the <code>config</code> R package, e.g.
projects can inherit settings from one another using the <code>inherits</code> field.
Exceptions include:
</p>

<ol>
<li><p> There is no requirement to have a configuration named <code>"default"</code>.
</p>
</li>
<li><p> Other projects do not inherit from the default project' automatically.
</p>
</li>
<li><p> Not all fields need values because <code>targets</code> already has defaults.
</p>
</li></ol>

<p><code>targets</code> does not actually invoke
the <code>config</code> package. The implementation in <code>targets</code>
was written from scratch without viewing or copying any
part of the source code of <code>config</code>.
</p>


<h3>See Also</h3>

<p>Other configuration: 
<code><a href="#topic+tar_config_get">tar_config_get</a>()</code>,
<code><a href="#topic+tar_config_projects">tar_config_projects</a>()</code>,
<code><a href="#topic+tar_config_set">tar_config_set</a>()</code>,
<code><a href="#topic+tar_config_yaml">tar_config_yaml</a>()</code>,
<code><a href="#topic+tar_envvars">tar_envvars</a>()</code>,
<code><a href="#topic+tar_option_get">tar_option_get</a>()</code>,
<code><a href="#topic+tar_option_reset">tar_option_reset</a>()</code>,
<code><a href="#topic+tar_option_set">tar_option_set</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(list(tar_target(x, 1 + 1)))
tar_config_get("store") # "_targets"
store_path &lt;- tempfile()
tar_config_set(store = store_path)
tar_config_get("store") # Shows a temp file.
tar_config_unset("store")
tar_config_get("store") # _targets
})
}
</code></pre>

<hr>
<h2 id='tar_config_yaml'>Read <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>.</h2><span id='topic+tar_config_yaml'></span>

<h3>Description</h3>

<p>Read the YAML content of <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_config_yaml(config = Sys.getenv("TAR_CONFIG", "_targets.yaml"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_config_yaml_+3A_config">config</code></td>
<td>
<p>Character of length 1, file path of the YAML
configuration file with <code>targets</code> project settings.
The <code>config</code> argument specifies which YAML configuration
file that <code>tar_config_get()</code> reads from or <code>tar_config_set()</code>
writes to in a single function call.
It does not globally change which configuration file is used
in subsequent function calls. The default file path of the YAML
file is always <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code> unless you set another
default path using the <code>TAR_CONFIG</code> environment variable,
e.g. <code>Sys.setenv(TAR_CONFIG = "custom.yaml")</code>. This also has the
effect of temporarily modifying the default arguments to other functions
such as <code><a href="#topic+tar_make">tar_make()</a></code> because the default arguments
to those functions are controlled by <code>tar_config_get()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nested list of fields defined in <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>Configuration</h3>

<p>For several key functions like <code><a href="#topic+tar_make">tar_make()</a></code>, the
default values of arguments are controlled though
<code>tar_config_get()</code>. <code>tar_config_get()</code> retrieves data
from an optional YAML configuration file.
You can control the settings in the YAML
file programmatically with <code>tar_config_set()</code>.
The default file path of this YAML file is <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code>, and you can
set another path globally using the <code>TAR_CONFIG</code>
environment variable. The YAML file can store configuration
settings for multiple projects, and you can globally
set the default project with the <code>TAR_PROJECT</code> environment
variable.
The structure of the YAML file
follows rules similar to the <code>config</code> R package, e.g.
projects can inherit settings from one another using the <code>inherits</code> field.
Exceptions include:
</p>

<ol>
<li><p> There is no requirement to have a configuration named <code>"default"</code>.
</p>
</li>
<li><p> Other projects do not inherit from the default project' automatically.
</p>
</li>
<li><p> Not all fields need values because <code>targets</code> already has defaults.
</p>
</li></ol>

<p><code>targets</code> does not actually invoke
the <code>config</code> package. The implementation in <code>targets</code>
was written from scratch without viewing or copying any
part of the source code of <code>config</code>.
</p>


<h3>See Also</h3>

<p>Other configuration: 
<code><a href="#topic+tar_config_get">tar_config_get</a>()</code>,
<code><a href="#topic+tar_config_projects">tar_config_projects</a>()</code>,
<code><a href="#topic+tar_config_set">tar_config_set</a>()</code>,
<code><a href="#topic+tar_config_unset">tar_config_unset</a>()</code>,
<code><a href="#topic+tar_envvars">tar_envvars</a>()</code>,
<code><a href="#topic+tar_option_get">tar_option_get</a>()</code>,
<code><a href="#topic+tar_option_reset">tar_option_reset</a>()</code>,
<code><a href="#topic+tar_option_set">tar_option_set</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>yaml &lt;- tempfile()
tar_config_set(store = "my_store_a", config = yaml, project = "project_a")
tar_config_set(store = "my_store_b", config = yaml, project = "project_b")
str(tar_config_yaml(config = yaml))
</code></pre>

<hr>
<h2 id='tar_counter'>Create a counter object.</h2><span id='topic+tar_counter'></span>

<h3>Description</h3>

<p>Internal function. Not for users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_counter(names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_counter_+3A_names">names</code></td>
<td>
<p>Character vector of names to set in the counter.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>tar_counter(names = "x")
</code></pre>

<hr>
<h2 id='tar_crew'>Get crew worker info.</h2><span id='topic+tar_crew'></span>

<h3>Description</h3>

<p>For the most recent run of the pipeline with <code><a href="#topic+tar_make">tar_make()</a></code>
where a <code>crew</code> controller was started, get summary-level information
of the workers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_crew(store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_crew_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame one row per <code>crew</code> worker and the following columns:
</p>

<ul>
<li> <p><code>controller</code>: name of the <code>crew</code> controller.
</p>
</li>
<li> <p><code>launches</code>: number of times the worker was launched.
</p>
</li>
<li> <p><code>seconds</code>: number of seconds the worker spent running tasks.
</p>
</li>
<li> <p><code>targets</code>: number of targets the worker completed and delivered.
</p>
</li></ul>



<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+tar_load">tar_load</a>()</code>,
<code><a href="#topic+tar_load_everything">tar_load_everything</a>()</code>,
<code><a href="#topic+tar_load_raw">tar_load_raw</a>()</code>,
<code><a href="#topic+tar_objects">tar_objects</a>()</code>,
<code><a href="#topic+tar_pid">tar_pid</a>()</code>,
<code><a href="#topic+tar_process">tar_process</a>()</code>,
<code><a href="#topic+tar_read">tar_read</a>()</code>,
<code><a href="#topic+tar_read_raw">tar_read_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
if (requireNamespace("crew", quietly = TRUE)) {
tar_script({
  tar_option_set(controller = crew::crew_controller_local())
  list(
    tar_target(x, seq_len(2)),
    tar_target(y, 2 * x, pattern = map(x))
  )
}, ask = FALSE)
tar_make()
tar_process()
tar_process(pid)
}
})
}
</code></pre>

<hr>
<h2 id='tar_cue'>Declare the rules that cue a target.</h2><span id='topic+tar_cue'></span>

<h3>Description</h3>

<p>Declare the rules that mark a target as outdated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_cue(
  mode = c("thorough", "always", "never"),
  command = TRUE,
  depend = TRUE,
  format = TRUE,
  repository = TRUE,
  iteration = TRUE,
  file = TRUE,
  seed = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_cue_+3A_mode">mode</code></td>
<td>
<p>Cue mode. If <code>"thorough"</code>, all the cues apply unless
individually suppressed. If <code>"always"</code>, then the target always
runs. If <code>"never"</code>, then the target does not run unless the
metadata does not exist or the last run errored.</p>
</td></tr>
<tr><td><code id="tar_cue_+3A_command">command</code></td>
<td>
<p>Logical, whether to rerun the target if command changed
since last time.</p>
</td></tr>
<tr><td><code id="tar_cue_+3A_depend">depend</code></td>
<td>
<p>Logical, whether to rerun the target if the value of one
of the dependencies changed.</p>
</td></tr>
<tr><td><code id="tar_cue_+3A_format">format</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
storage format changed. The storage format is user-specified through
<code><a href="#topic+tar_target">tar_target()</a></code> or <code><a href="#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_cue_+3A_repository">repository</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
storage repository changed. The storage repository is user-specified
through <code><a href="#topic+tar_target">tar_target()</a></code> or <code><a href="#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_cue_+3A_iteration">iteration</code></td>
<td>
<p>Logical, whether to rerun the target if the user-specified
iteration method changed. The iteration method is user-specified through
<code><a href="#topic+tar_target">tar_target()</a></code> or <code><a href="#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_cue_+3A_file">file</code></td>
<td>
<p>Logical, whether to rerun the target if the file(s) with the
return value changed or at least one is missing.</p>
</td></tr>
<tr><td><code id="tar_cue_+3A_seed">seed</code></td>
<td>
<p>Logical, whether to rerun the target if pseudo-random
number generator seed either changed or is <code>NA</code>.
The reproducible deterministic target-specific
seeds are controlled by <code>tar_option_get("seed")</code> and the target names.
See <code><a href="#topic+tar_option_set">tar_option_set()</a></code> for details.</p>
</td></tr>
</table>


<h3>Target invalidation rules</h3>

<p><code>targets</code> uses internal metadata and special cues
to decide whether a target is up to date (can skip)
or is outdated/invalidated (needs to rerun). By default,
<code>targets</code> moves through the following list of cues
and declares a target outdated if at least one is cue activated.
</p>

<ol>
<li><p> There is no metadata record of the target.
</p>
</li>
<li><p> The target errored last run.
</p>
</li>
<li><p> The target has a different class than it did before.
</p>
</li>
<li><p> The cue mode equals <code>"always"</code>.
</p>
</li>
<li><p> The cue mode does not equal <code>"never"</code>.
</p>
</li>
<li><p> The <code>command</code> metadata field (the hash of the R command)
is different from last time.
</p>
</li>
<li><p> The <code>depend</code> metadata field (the hash of the immediate upstream
dependency targets and global objects) is different from last time.
</p>
</li>
<li><p> The storage format is different from last time.
</p>
</li>
<li><p> The iteration mode is different from last time.
</p>
</li>
<li><p> A target's file (either the one in <code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code>
or a dynamic file) does not exist or changed since last time.
</p>
</li></ol>

<p>The user can suppress many of the above cues using the <code>tar_cue()</code>
function, which creates the <code>cue</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code>.
Cues objects also constitute more nuanced target invalidation rules.
The <code>tarchetypes</code> package has many such examples, including
<code>tar_age()</code>, <code>tar_download()</code>, <code>tar_cue_age()</code>, <code>tar_cue_force()</code>,
and <code>tar_cue_skip()</code>.
</p>


<h3>Dependency-based invalidation and user-defined functions</h3>

<p>If the cue of a target has <code>depend = TRUE</code> (default) then the target
is marked invalidated/outdated when its upstream dependencies change.
A target's dependencies include upstream targets,
user-defined functions, and other global objects populated
in the target script file (default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>).
To determine if a given dependency changed
since the last run of the pipeline, <code>targets</code> computes hashes.
The hash of a target is computed on its files in storage
(usually a file in <code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code>). The hash of a
non-function global object dependency is computed directly on its
in-memory data. User-defined functions are hashed in the following way:
</p>

<ol>
<li><p> Deparse the function with <code>targets:::tar_deparse_safe()</code>. This
function computes a string representation of the function
body and arguments. This string representation is invariant to
changes in comments and whitespace, which means
trivial changes to formatting do not cue targets to rerun.
</p>
</li>
<li><p> Manually remove any literal pointers from the function string
using <code>targets:::mask_pointers()</code>. Such pointers arise from
inline compiled C/C++ functions.
</p>
</li>
<li><p> Using static code analysis (i.e. <code><a href="#topic+tar_deps">tar_deps()</a></code>, which is based on
<code>codetools::findGlobals()</code>) identify any user-defined functions
and global objects that the current function depends on.
Append the hashes of those dependencies to the string representation
of the current function.
</p>
</li>
<li><p> Compute the hash of the final string representation using
<code>targets:::digest_chr64()</code>.
</p>
</li></ol>

<p>Above, (3) is important because user-defined functions
have dependencies of their own, such as other user-defined
functions and other global objects. (3) ensures that a change to
a function's dependencies invalidates the function itself, which
in turn invalidates any calling functions and any targets downstream
with the <code>depend</code> cue turned on.
</p>


<h3>See Also</h3>

<p>Other targets: 
<code><a href="#topic+tar_format">tar_format</a>()</code>,
<code><a href="#topic+tar_target">tar_target</a>()</code>,
<code><a href="#topic+tar_target_raw">tar_target_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following target will always run when the pipeline runs.
x &lt;- tar_target(x, download_data(), cue = tar_cue(mode = "always"))
</code></pre>

<hr>
<h2 id='tar_debug_instructions'>Print instructions for debugging a target.</h2><span id='topic+tar_debug_instructions'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not call directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_debug_instructions()
</code></pre>


<h3>Value</h3>

<p><code>NULL</code> (invisibly). Messages are printed out.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_debug_instructions()
</code></pre>

<hr>
<h2 id='tar_deduplicate'>Deduplicate meta and progress databases (deprecated).</h2><span id='topic+tar_deduplicate'></span>

<h3>Description</h3>

<p>Deprecated in version 0.3.0 (2020-03-06).
Deduplication happens automatically before and after the pipeline runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_deduplicate(
  meta = TRUE,
  progress = TRUE,
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_deduplicate_+3A_meta">meta</code></td>
<td>
<p>Logical, whether to deduplicate the meta database file
at <code style="white-space: pre;">&#8288;_targets/meta/meta&#8288;</code>.</p>
</td></tr>
<tr><td><code id="tar_deduplicate_+3A_progress">progress</code></td>
<td>
<p>Logical, whether to deduplicate the progress database file
at <code style="white-space: pre;">&#8288;_targets/meta/progress&#8288;</code>.</p>
</td></tr>
<tr><td><code id="tar_deduplicate_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Removes duplicated entries in the meta and progress
databases in order to lighten storage. These databases are located
in the <code style="white-space: pre;">&#8288;_targets/meta/meta&#8288;</code> and <code style="white-space: pre;">&#8288;_targets/meta/progress&#8288;</code> files,
where <code style="white-space: pre;">&#8288;_targets&#8288;</code> is the a folder at the project root.
No essential data is removed, so
this is simply a form of garbage collection.
</p>


<h3>Value</h3>

<p>Nothing.
</p>

<hr>
<h2 id='tar_definition'>For developers only: get the definition of the current target.</h2><span id='topic+tar_definition'></span>

<h3>Description</h3>

<p>For developers only: get the full definition of the
target currently running. This target definition is the same kind
of object produced by <code><a href="#topic+tar_target">tar_target()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_definition(
  default = targets::tar_target_raw("target_name", quote(identity()))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_definition_+3A_default">default</code></td>
<td>
<p>Environment, value to return if <code>tar_definition()</code>
is called on its own outside a <code>targets</code> pipeline.
Having a default lets users run things without <code><a href="#topic+tar_make">tar_make()</a></code>,
which helps peel back layers of code and troubleshoot bugs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most users should not use <code>tar_definition()</code>  because accidental
modifications could break the pipeline.
<code>tar_definition()</code> only exists in order to support third-party interface
packages, and even then the returned target definition is not modified..
</p>


<h3>Value</h3>

<p>If called from a running target, <code>tar_definition()</code> returns
the target object of the currently running target.
See the &quot;Target objects&quot; section for details.
</p>


<h3>Target objects</h3>

<p>Functions like <code>tar_target()</code> produce target objects,
special objects with specialized sets of S3 classes.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+tar_active">tar_active</a>()</code>,
<code><a href="#topic+tar_backoff">tar_backoff</a>()</code>,
<code><a href="#topic+tar_call">tar_call</a>()</code>,
<code><a href="#topic+tar_cancel">tar_cancel</a>()</code>,
<code><a href="#topic+tar_described_as">tar_described_as</a>()</code>,
<code><a href="#topic+tar_envir">tar_envir</a>()</code>,
<code><a href="#topic+tar_group">tar_group</a>()</code>,
<code><a href="#topic+tar_name">tar_name</a>()</code>,
<code><a href="#topic+tar_path">tar_path</a>()</code>,
<code><a href="#topic+tar_path_script">tar_path_script</a>()</code>,
<code><a href="#topic+tar_path_script_support">tar_path_script_support</a>()</code>,
<code><a href="#topic+tar_path_store">tar_path_store</a>()</code>,
<code><a href="#topic+tar_path_target">tar_path_target</a>()</code>,
<code><a href="#topic+tar_source">tar_source</a>()</code>,
<code><a href="#topic+tar_store">tar_store</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>class(tar_definition())
tar_definition()$settings$name
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(
  tar_target(x, tar_definition()$settings$memory, memory = "transient")
)
tar_make(x)
tar_read(x)
})
}
</code></pre>

<hr>
<h2 id='tar_delete'>Delete target output values.</h2><span id='topic+tar_delete'></span>

<h3>Description</h3>

<p>Delete the output values of targets in <code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code>
(or the cloud if applicable)
but keep the records in the metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_delete(
  names,
  cloud = TRUE,
  batch_size = 1000L,
  verbose = TRUE,
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_delete_+3A_names">names</code></td>
<td>
<p>Optional, names of the targets to delete. If supplied, the
<code>names</code> argument restricts the targets which are deleted.
The value is a <code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_delete_+3A_cloud">cloud</code></td>
<td>
<p>Logical of length 1, whether to delete objects
from the cloud if applicable (e.g. AWS, GCP). If <code>FALSE</code>,
files are not deleted from the cloud.</p>
</td></tr>
<tr><td><code id="tar_delete_+3A_batch_size">batch_size</code></td>
<td>
<p>Positive integer between 1 and 1000,
number of target objects to delete
from the cloud with each HTTP API request.
Currently only supported for AWS.
Cannot be more than 1000.</p>
</td></tr>
<tr><td><code id="tar_delete_+3A_verbose">verbose</code></td>
<td>
<p>Logical of length 1, whether to print console messages
to show progress when deleting each batch of targets from each
cloud bucket. Batched deletion with verbosity is currently only supported
for AWS.</p>
</td></tr>
<tr><td><code id="tar_delete_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you have a small number of data-heavy targets you
need to discard to conserve storage, this function can help.
Local external files files (i.e. <code>format = "file"</code>
and <code>repository = "local"</code>) are not deleted.
For targets with <code>repository</code> not equal <code>"local"</code>, <code>tar_delete()</code> attempts
to delete the file and errors out if the deletion is unsuccessful.
If deletion fails, either log into the cloud platform
and manually delete the file (e.g. the AWS web console
in the case of <code>repository = "aws"</code>) or call
<code><a href="#topic+tar_invalidate">tar_invalidate()</a></code> on that target so that <code>targets</code>
does not try to delete the object.
For patterns recorded in the metadata, all the branches
will be deleted. For patterns no longer in the metadata,
branches are left alone.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>Cloud target data versioning</h3>

<p>Some buckets in Amazon S3 or Google Cloud Storage are &quot;versioned&quot;,
which means they track historical versions of each data object.
If you use <code>targets</code> with cloud storage
(<a href="https://books.ropensci.org/targets/cloud-storage.html">https://books.ropensci.org/targets/cloud-storage.html</a>)
and versioning is turned on, then <code>targets</code> will record each
version of each target in its metadata.
</p>
<p>Functions like <code><a href="#topic+tar_read">tar_read()</a></code>
and <code><a href="#topic+tar_load">tar_load()</a></code> load the version recorded in the local metadata,
which may not be the same as the &quot;current&quot; version of the
object in the bucket. Likewise, functions <code><a href="#topic+tar_delete">tar_delete()</a></code>
and <code><a href="#topic+tar_destroy">tar_destroy()</a></code> only remove
the version ID of each target as recorded in the local
metadata.
</p>
<p>If you want to interact with the <em>latest</em> version of an object
instead of the version ID recorded in the local metadata,
then you will need to delete the object from the metadata.
</p>

<ol>
<li><p> Make sure your local copy of the metadata is current and
up to date. You may need to run <code><a href="#topic+tar_meta_download">tar_meta_download()</a></code> or
<code><a href="#topic+tar_meta_sync">tar_meta_sync()</a></code> first.
</p>
</li>
<li><p> Run <code><a href="#topic+tar_unversion">tar_unversion()</a></code> to remove the recorded version IDs of
your targets in the local metadata.
</p>
</li>
<li><p> With the version IDs gone from the local metadata,
functions like <code><a href="#topic+tar_read">tar_read()</a></code> and <code><a href="#topic+tar_destroy">tar_destroy()</a></code> will use the
<em>latest</em> version of each target data object.
</p>
</li>
<li><p> Optional: to back up the local metadata file with the version IDs
deleted, use <code><a href="#topic+tar_meta_upload">tar_meta_upload()</a></code>.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other clean: 
<code><a href="#topic+tar_destroy">tar_destroy</a>()</code>,
<code><a href="#topic+tar_invalidate">tar_invalidate</a>()</code>,
<code><a href="#topic+tar_prune">tar_prune</a>()</code>,
<code><a href="#topic+tar_prune_list">tar_prune_list</a>()</code>,
<code><a href="#topic+tar_unversion">tar_unversion</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(y1, 1 + 1),
    tar_target(y2, 1 + 1),
    tar_target(z, y1 + y2)
  )
}, ask = FALSE)
tar_make()
tar_delete(starts_with("y")) # Only deletes y1 and y2.
tar_make() # y1 and y2 rerun but return the same values, so z is up to date.
})
}
</code></pre>

<hr>
<h2 id='tar_deps'>Code dependencies</h2><span id='topic+tar_deps'></span>

<h3>Description</h3>

<p>List the dependencies of a function or expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_deps(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_deps_+3A_expr">expr</code></td>
<td>
<p>A quoted R expression or function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>targets</code> detects the dependencies of commands using
static code analysis. Use <code>tar_deps()</code> to run the
code analysis and see the dependencies for yourself.
</p>


<h3>Value</h3>

<p>Character vector of the dependencies of a function or expression.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tar_branches">tar_branches()</a></code>, <code><a href="#topic+tar_network">tar_network()</a></code>
</p>
<p>Other inspect: 
<code><a href="#topic+tar_deps_raw">tar_deps_raw</a>()</code>,
<code><a href="#topic+tar_manifest">tar_manifest</a>()</code>,
<code><a href="#topic+tar_network">tar_network</a>()</code>,
<code><a href="#topic+tar_outdated">tar_outdated</a>()</code>,
<code><a href="#topic+tar_sitrep">tar_sitrep</a>()</code>,
<code><a href="#topic+tar_validate">tar_validate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_deps(x &lt;- y + z)
tar_deps({
  x &lt;- 1
  x + a
})
tar_deps(function(a = b) map_dfr(data, ~do_row(.x)))
</code></pre>

<hr>
<h2 id='tar_deps_raw'>Code dependencies (raw version)</h2><span id='topic+tar_deps_raw'></span>

<h3>Description</h3>

<p>Same as <code><a href="#topic+tar_deps">tar_deps()</a></code> except <code>expr</code> must already be an
unquoted function or expression object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_deps_raw(expr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_deps_raw_+3A_expr">expr</code></td>
<td>
<p>An R expression object or function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of the dependencies of a function or expression.
</p>


<h3>See Also</h3>

<p>Other inspect: 
<code><a href="#topic+tar_deps">tar_deps</a>()</code>,
<code><a href="#topic+tar_manifest">tar_manifest</a>()</code>,
<code><a href="#topic+tar_network">tar_network</a>()</code>,
<code><a href="#topic+tar_outdated">tar_outdated</a>()</code>,
<code><a href="#topic+tar_sitrep">tar_sitrep</a>()</code>,
<code><a href="#topic+tar_validate">tar_validate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_deps_raw(quote(x &lt;- y + z))
tar_deps_raw(
  quote({
    x &lt;- 1
    x + a
  })
)
tar_deps_raw(function(a = b) map_dfr(data, ~do_row(.x)))
</code></pre>

<hr>
<h2 id='tar_described_as'>Select targets using their descriptions.</h2><span id='topic+tar_described_as'></span>

<h3>Description</h3>

<p>Select a subset of targets in the <code style="white-space: pre;">&#8288;_targets.R&#8288;</code> file
based on their custom descriptions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_described_as(
  described_as = NULL,
  tidyselect = TRUE,
  callr_function = callr::r,
  callr_arguments = targets::tar_callr_args_default(callr_function),
  envir = parent.frame(),
  script = targets::tar_config_get("script")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_described_as_+3A_described_as">described_as</code></td>
<td>
<p>A <code>tidyselect</code> expression to select targets
based on their descriptions. For example,
<code>described_as = starts_with("survival model")</code> matches all
targets in the pipeline whose <code>description</code> arguments
of <code><a href="#topic+tar_target">tar_target()</a></code> start with the text string <code>"survival model"</code>.</p>
</td></tr>
<tr><td><code id="tar_described_as_+3A_tidyselect">tidyselect</code></td>
<td>
<p>If <code>TRUE</code>, return a call to <code>tidyselect::all_of()</code>
identifying the selected targets, which can then be supplied to any
<code>tidyselect</code>-compatible names<code style="white-space: pre;">&#8288;argument of downstream functions like [tar_make()] and [tar_manifest()]. If&#8288;</code>FALSE', return a simple character vector of target names.</p>
</td></tr>
<tr><td><code id="tar_described_as_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_described_as_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
<tr><td><code id="tar_described_as_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_described_as_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Targets with empty descriptions are ignored.
</p>


<h3>Value</h3>

<p>If <code>tidyselect</code> is <code>TRUE</code>, then <code><a href="#topic+tar_described_as">tar_described_as()</a></code> returns
a call to <code>tidyselect::all_of()</code> which can be supplied to the <code>names</code>
argument of functions like <code><a href="#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="#topic+tar_make">tar_make()</a></code>.
This allows functions like <code><a href="#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="#topic+tar_make">tar_make()</a></code>
to focus on only the targets with the matching descriptions.
If <code>tidyselect</code> is <code>FALSE</code>, then <code><a href="#topic+tar_described_as">tar_described_as()</a></code> returns
a simple character vector of the names of all the targets in the
pipeline with matching descriptions.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+tar_active">tar_active</a>()</code>,
<code><a href="#topic+tar_backoff">tar_backoff</a>()</code>,
<code><a href="#topic+tar_call">tar_call</a>()</code>,
<code><a href="#topic+tar_cancel">tar_cancel</a>()</code>,
<code><a href="#topic+tar_definition">tar_definition</a>()</code>,
<code><a href="#topic+tar_envir">tar_envir</a>()</code>,
<code><a href="#topic+tar_group">tar_group</a>()</code>,
<code><a href="#topic+tar_name">tar_name</a>()</code>,
<code><a href="#topic+tar_path">tar_path</a>()</code>,
<code><a href="#topic+tar_path_script">tar_path_script</a>()</code>,
<code><a href="#topic+tar_path_script_support">tar_path_script_support</a>()</code>,
<code><a href="#topic+tar_path_store">tar_path_store</a>()</code>,
<code><a href="#topic+tar_path_target">tar_path_target</a>()</code>,
<code><a href="#topic+tar_source">tar_source</a>()</code>,
<code><a href="#topic+tar_store">tar_store</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(b2, TRUE, description = "blue two"),
    tar_target(b3, TRUE, description = "blue three"),
    tar_target(g2, TRUE, description = "green two"),
    tar_target(g3, TRUE, description = "green three"),
    tar_target(g4, TRUE, description = "green three")
  )
}, ask = FALSE)
tar_described_as(starts_with("green"), tidyselect = FALSE)
tar_make(names = tar_described_as(starts_with("green")))
tar_progress() # Only `g2`, `g3`, and `g4` ran.
})
}
</code></pre>

<hr>
<h2 id='tar_destroy'>Destroy the data store.</h2><span id='topic+tar_destroy'></span>

<h3>Description</h3>

<p>Destroy the data store written by the pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_destroy(
  destroy = c("all", "cloud", "local", "meta", "process", "progress", "objects",
    "scratch", "workspaces", "user"),
  batch_size = 1000L,
  verbose = TRUE,
  ask = NULL,
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_destroy_+3A_destroy">destroy</code></td>
<td>
<p>Character of length 1, what to destroy. Choices:
</p>

<ul>
<li> <p><code>"all"</code>: entire data store (default: <code style="white-space: pre;">&#8288;_targets/&#8288;</code>)
including cloud data, as well as download/upload scratch files.
</p>
</li>
<li> <p><code>"cloud"</code>: cloud data, including metadata as well as target object data
from targets with <code>tar_target(..., repository = "aws")</code>.
Also deletes temporary staging files in
<code>file.path(tempdir(), "targets")</code>
that may have been accidentally left over from incomplete
uploads or downloads.
</p>
</li>
<li> <p><code>"local"</code>: all the local files in the data store but nothing
on the cloud.
</p>
</li>
<li> <p><code>"meta"</code>: metadata file at <code>meta/meta</code> in the
data store, which invalidates all the targets but keeps the data.
</p>
</li>
<li> <p><code>"process"</code>: progress data file at
<code>meta/process</code> in the data store, which resets the metadata
of the main process.
</p>
</li>
<li> <p><code>"progress"</code>: progress data file at
<code>meta/progress</code> in the data store,
which resets the progress tracking info.
</p>
</li>
<li> <p><code>"objects"</code>: all the target
return values in <code style="white-space: pre;">&#8288;objects/&#8288;</code> in the data
store but keep progress and metadata.
Dynamic files are not deleted this way.
</p>
</li>
<li> <p><code>"scratch"</code>: temporary files in saved during <code><a href="#topic+tar_make">tar_make()</a></code> that should
automatically get deleted except if R crashed.
</p>
</li>
<li> <p><code>"workspaces"</code>: compressed lightweight files in <code style="white-space: pre;">&#8288;workspaces/&#8288;</code>
in the data store with the saved workspaces of targets.
See <code><a href="#topic+tar_workspace">tar_workspace()</a></code> for details.
</p>
</li>
<li> <p><code>"user"</code>: custom user-supplied files in the <code style="white-space: pre;">&#8288;user/&#8288;</code> folder in the
data store.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_destroy_+3A_batch_size">batch_size</code></td>
<td>
<p>Positive integer between 1 and 1000,
number of target objects to delete
from the cloud with each HTTP API request.
Currently only supported for AWS.
Cannot be more than 1000.</p>
</td></tr>
<tr><td><code id="tar_destroy_+3A_verbose">verbose</code></td>
<td>
<p>Logical of length 1, whether to print console messages
to show progress when deleting each batch of targets from each
cloud bucket. Batched deletion with verbosity is currently only supported
for AWS.</p>
</td></tr>
<tr><td><code id="tar_destroy_+3A_ask">ask</code></td>
<td>
<p>Logical of length 1, whether to pause with a menu prompt
before deleting files. To disable this menu, set the <code>TAR_ASK</code>
environment variable to <code>"false"</code>. <code>usethis::edit_r_environ()</code>
can help set environment variables.</p>
</td></tr>
<tr><td><code id="tar_destroy_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. If the script does not exist,
then cloud metadata will not be deleted.</p>
</td></tr>
<tr><td><code id="tar_destroy_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data store is a folder created by <code><a href="#topic+tar_make">tar_make()</a></code>
(or <code><a href="#topic+tar_make_future">tar_make_future()</a></code> or <code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code>).
The details of the data store are explained at
<a href="https://books.ropensci.org/targets/data.html#local-data-store">https://books.ropensci.org/targets/data.html#local-data-store</a>.
The data store folder contains the output data
and metadata of the targets in the pipeline. Usually,
the data store is a folder called <code style="white-space: pre;">&#8288;_targets/&#8288;</code>
(see <code><a href="#topic+tar_config_set">tar_config_set()</a></code> to customize), and it may
link to data on the cloud if you used AWS or GCP
buckets. By default, <code>tar_destroy()</code> deletes the entire
<code style="white-space: pre;">&#8288;_targets/&#8288;</code> folder (or wherever the data store is located),
including custom user-supplied files in <code style="white-space: pre;">&#8288;_targets/user/&#8288;</code>,
as well as any cloud data that the pipeline uploaded.
See the <code>destroy</code> argument to customize this behavior
and only delete part of the data store, and see functions like
<code><a href="#topic+tar_invalidate">tar_invalidate()</a></code>, <code><a href="#topic+tar_delete">tar_delete()</a></code>, and <code><a href="#topic+tar_prune">tar_prune()</a></code> to remove
information pertaining to some but not all targets in the pipeline.
After calling <code>tar_destroy()</code> with default arguments,
the entire data store is gone, which means all the output data from
previous runs of the pipeline is gone (except for
input/output files tracked with <code>tar_target(..., format = "file")</code>).
The next run of the pipeline will start from scratch,
and it will not skip any targets.
</p>


<h3>Value</h3>

<p><code>NULL</code> (invisibly).
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>Cloud target data versioning</h3>

<p>Some buckets in Amazon S3 or Google Cloud Storage are &quot;versioned&quot;,
which means they track historical versions of each data object.
If you use <code>targets</code> with cloud storage
(<a href="https://books.ropensci.org/targets/cloud-storage.html">https://books.ropensci.org/targets/cloud-storage.html</a>)
and versioning is turned on, then <code>targets</code> will record each
version of each target in its metadata.
</p>
<p>Functions like <code><a href="#topic+tar_read">tar_read()</a></code>
and <code><a href="#topic+tar_load">tar_load()</a></code> load the version recorded in the local metadata,
which may not be the same as the &quot;current&quot; version of the
object in the bucket. Likewise, functions <code><a href="#topic+tar_delete">tar_delete()</a></code>
and <code><a href="#topic+tar_destroy">tar_destroy()</a></code> only remove
the version ID of each target as recorded in the local
metadata.
</p>
<p>If you want to interact with the <em>latest</em> version of an object
instead of the version ID recorded in the local metadata,
then you will need to delete the object from the metadata.
</p>

<ol>
<li><p> Make sure your local copy of the metadata is current and
up to date. You may need to run <code><a href="#topic+tar_meta_download">tar_meta_download()</a></code> or
<code><a href="#topic+tar_meta_sync">tar_meta_sync()</a></code> first.
</p>
</li>
<li><p> Run <code><a href="#topic+tar_unversion">tar_unversion()</a></code> to remove the recorded version IDs of
your targets in the local metadata.
</p>
</li>
<li><p> With the version IDs gone from the local metadata,
functions like <code><a href="#topic+tar_read">tar_read()</a></code> and <code><a href="#topic+tar_destroy">tar_destroy()</a></code> will use the
<em>latest</em> version of each target data object.
</p>
</li>
<li><p> Optional: to back up the local metadata file with the version IDs
deleted, use <code><a href="#topic+tar_meta_upload">tar_meta_upload()</a></code>.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other clean: 
<code><a href="#topic+tar_delete">tar_delete</a>()</code>,
<code><a href="#topic+tar_invalidate">tar_invalidate</a>()</code>,
<code><a href="#topic+tar_prune">tar_prune</a>()</code>,
<code><a href="#topic+tar_prune_list">tar_prune_list</a>()</code>,
<code><a href="#topic+tar_unversion">tar_unversion</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(list(tar_target(x, 1 + 1)), ask = FALSE)
tar_make() # Creates the _targets/ data store.
tar_destroy()
print(file.exists("_targets")) # Should be FALSE.
})
}
</code></pre>

<hr>
<h2 id='tar_dir'>Execute code in a temporary directory.</h2><span id='topic+tar_dir'></span>

<h3>Description</h3>

<p>Not a user-side function. Just for CRAN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_dir(code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_dir_+3A_code">code</code></td>
<td>
<p>User-defined code.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Runs code inside a new <code>tempfile()</code> directory
in order to avoid writing to the user's file space.
Used in examples and tests in order to comply with CRAN policies.
</p>


<h3>Value</h3>

<p>Return value of the user-defined code.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_dir(file.create("only_exists_in_tar_dir"))
file.exists("only_exists_in_tar_dir")
</code></pre>

<hr>
<h2 id='tar_dispatched'>List dispatched targets.</h2><span id='topic+tar_dispatched'></span>

<h3>Description</h3>

<p>List the targets with progress status <code>"dispatched"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_dispatched(names = NULL, store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_dispatched_+3A_names">names</code></td>
<td>
<p>Optional, names of the targets. If supplied, the
function restricts its output to these targets.
You can supply symbols
or <code>tidyselect</code> helpers like <code><a href="#topic+any_of">any_of()</a></code> and <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_dispatched_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A target is <code>"dispatched"</code> if it is sent off to be run. Depending
on your high-performance computing configuration via the <code>crew</code> package,
the may not actually start right away. This may happen if the target
is ready to start but all available parallel workers are busy.
</p>


<h3>Value</h3>

<p>A character vector of dispatched targets.
</p>


<h3>See Also</h3>

<p>Other progress: 
<code><a href="#topic+tar_canceled">tar_canceled</a>()</code>,
<code><a href="#topic+tar_completed">tar_completed</a>()</code>,
<code><a href="#topic+tar_errored">tar_errored</a>()</code>,
<code><a href="#topic+tar_poll">tar_poll</a>()</code>,
<code><a href="#topic+tar_progress">tar_progress</a>()</code>,
<code><a href="#topic+tar_progress_branches">tar_progress_branches</a>()</code>,
<code><a href="#topic+tar_progress_summary">tar_progress_summary</a>()</code>,
<code><a href="#topic+tar_skipped">tar_skipped</a>()</code>,
<code><a href="#topic+tar_watch">tar_watch</a>()</code>,
<code><a href="#topic+tar_watch_server">tar_watch_server</a>()</code>,
<code><a href="#topic+tar_watch_ui">tar_watch_ui</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(2)),
    tar_target(y, 2 * x, pattern = map(x))
  )
}, ask = FALSE)
tar_make()
tar_dispatched()
tar_dispatched(starts_with("y_")) # see also any_of()
})
}
</code></pre>

<hr>
<h2 id='tar_edit'>Open the target script file for editing.</h2><span id='topic+tar_edit'></span>

<h3>Description</h3>

<p>Open the target script file for editing.
Requires the <code>usethis</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_edit(script = targets::tar_config_get("script"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_edit_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The target script file is an R code file
that defines the pipeline. The default path is <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>,
but the default for the current project
can be configured with <code><a href="#topic+tar_config_set">tar_config_set()</a></code>
</p>


<h3>See Also</h3>

<p>Other scripts: 
<code><a href="#topic+tar_github_actions">tar_github_actions</a>()</code>,
<code><a href="#topic+tar_helper">tar_helper</a>()</code>,
<code><a href="#topic+tar_helper_raw">tar_helper_raw</a>()</code>,
<code><a href="#topic+tar_renv">tar_renv</a>()</code>,
<code><a href="#topic+tar_script">tar_script</a>()</code>
</p>

<hr>
<h2 id='tar_engine_knitr'>Target Markdown <code>knitr</code> engine</h2><span id='topic+tar_engine_knitr'></span>

<h3>Description</h3>

<p><code>knitr</code> language engine that runs <code>targets</code>
code chunks in Target Markdown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_engine_knitr(options)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_engine_knitr_+3A_options">options</code></td>
<td>
<p>A named list of <code>knitr</code> chunk options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character, output generated from <code>knitr::engine_output()</code>.
</p>


<h3>Target Markdown interactive mode</h3>

<p>Target Markdown has two modes:
</p>

<ol>
<li><p> Non-interactive mode. This is the default when you
run <code>knitr::knit()</code> or <code>rmarkdown::render()</code>.
Here, the code in <code>targets</code> code chunks gets written
to special script files in order to set up a <code>targets</code>
pipeline to run later.
</p>
</li>
<li><p> Interactive mode: here, no scripts are written to set up
a pipeline. Rather, the globals or targets in question
are run in the current environment and the values
are assigned to that environment.
</p>
</li></ol>

<p>The mode is interactive if <code>!isTRUE(getOption("knitr.in.progress"))</code>,
is <code>TRUE</code>. The <code>knitr.in.progress</code> option is <code>TRUE</code>
when you run <code>knitr::knit()</code> or <code>rmarkdown::render()</code>
and <code>NULL</code> if you are running one chunk at a time interactively
in an integrated development environment, e.g. the
notebook interface in RStudio:
<a href="https://bookdown.org/yihui/rmarkdown/notebook.html">https://bookdown.org/yihui/rmarkdown/notebook.html</a>.
You can choose the mode with the <code>tar_interactive</code>
chunk option.
(In <code>targets</code> 0.6.0, <code>tar_interactive</code> defaults to <code>interactive()</code>
instead of <code>!isTRUE(getOption("knitr.in.progress"))</code>.)
</p>


<h3>Target Markdown chunk options</h3>

<p>Target Markdown introduces the following <code>knitr</code> code chunk options.
Most other standard <code>knitr</code> code chunk options should just work
in non-interactive mode. In interactive mode, not all
</p>

<ul>
<li> <p><code>tar_globals</code>: Logical of length 1,
whether to define globals or targets.
If <code>TRUE</code>, the chunk code defines functions, objects, and options
common to all the targets. If <code>FALSE</code> or <code>NULL</code> (default),
then the chunk returns formal targets for the pipeline.
</p>
</li>
<li> <p><code>tar_interactive</code>: Logical of length 1, whether to run in
interactive mode or non-interactive mode.
See the &quot;Target Markdown interactive mode&quot; section of this
help file for details.
</p>
</li>
<li> <p><code>tar_name</code>: name to use for writing helper script files
(e.g. <code style="white-space: pre;">&#8288;_targets_r/targets/target_script.R&#8288;</code>)
and specifying target names if the <code>tar_simple</code> chunk option
is <code>TRUE</code>. All helper scripts and target names must have
unique names, so please do not set this option globally
with <code>knitr::opts_chunk$set()</code>.
</p>
</li>
<li> <p><code>tar_script</code>: Character of length 1, where to write the
target script file in non-interactive mode. Most users can
skip this option and stick with the default <code style="white-space: pre;">&#8288;_targets.R&#8288;</code> script path.
Helper script files are always written next to the target script in
a folder with an <code>"_r"</code> suffix. The <code>tar_script</code> path must either be
absolute or be relative to the project root
(where you call <code>tar_make()</code> or similar).
If not specified, the target script path defaults to
<code>tar_config_get("script")</code> (default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>;
helpers default: <code style="white-space: pre;">&#8288;_targets_r/&#8288;</code>). When you run <code>tar_make()</code> etc.
with a non-default target script, you must select the correct target
script file either with the <code>script</code> argument or with
<code>tar_config_set(script = ...)</code>. The function will <code>source()</code>
the script file from the current working directory
(i.e. with <code>chdir = FALSE</code> in <code>source()</code>).
</p>
</li>
<li> <p><code>tar_simple</code>: Logical of length 1.
Set to <code>TRUE</code> to define a single target with a simplified interface.
In code chunks with <code>tar_simple</code> equal to <code>TRUE</code>, the chunk label
(or the <code>tar_name</code> chunk option if you set it)
becomes the name, and the chunk code becomes the command.
In other words, a code chunk with label <code>targetname</code> and
command <code>mycommand()</code> automatically gets converted to
<code>tar_target(name = targetname, command = mycommand())</code>.
All other arguments of <code>tar_target()</code> remain at their default
values (configurable with <code>tar_option_set()</code> in a
<code>tar_globals = TRUE</code> chunk).
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="https://books.ropensci.org/targets/literate-programming.html">https://books.ropensci.org/targets/literate-programming.html</a>
</p>
<p>Other Target Markdown: 
<code><a href="#topic+tar_interactive">tar_interactive</a>()</code>,
<code><a href="#topic+tar_noninteractive">tar_noninteractive</a>()</code>,
<code><a href="#topic+tar_toggle">tar_toggle</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
# Register the engine.
if (requireNamespace("knitr", quietly = TRUE)) {
  knitr::knit_engines$set(targets = targets::tar_engine_knitr)
}
# Then, `targets` code chunks in a knitr report will run
# as described at
# &lt;https://books.ropensci.org/targets/literate-programming.html&gt;.
}
</code></pre>

<hr>
<h2 id='tar_envir'>For developers only: get the environment of the current target.</h2><span id='topic+tar_envir'></span>

<h3>Description</h3>

<p>For developers only: get the environment where a
target runs its command. Designed to be called
while the target is running. The environment
inherits from <code>tar_option_get("envir")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_envir(default = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_envir_+3A_default">default</code></td>
<td>
<p>Environment, value to return if <code>tar_envir()</code>
is called on its own outside a <code>targets</code> pipeline.
Having a default lets users run things without <code><a href="#topic+tar_make">tar_make()</a></code>,
which helps peel back layers of code and troubleshoot bugs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most users should not use <code>tar_envir()</code> because accidental
modifications to <code>parent.env(tar_envir())</code> could break the pipeline.
<code>tar_envir()</code> only exists in order to support third-party interface
packages, and even then the returned environment is not modified.
</p>


<h3>Value</h3>

<p>If called from a running target, <code>tar_envir()</code> returns
the environment where the target runs its command.
If called outside a pipeline, the return value is
whatever the user supplies to <code>default</code>
(which defaults to <code>parent.frame()</code>).
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+tar_active">tar_active</a>()</code>,
<code><a href="#topic+tar_backoff">tar_backoff</a>()</code>,
<code><a href="#topic+tar_call">tar_call</a>()</code>,
<code><a href="#topic+tar_cancel">tar_cancel</a>()</code>,
<code><a href="#topic+tar_definition">tar_definition</a>()</code>,
<code><a href="#topic+tar_described_as">tar_described_as</a>()</code>,
<code><a href="#topic+tar_group">tar_group</a>()</code>,
<code><a href="#topic+tar_name">tar_name</a>()</code>,
<code><a href="#topic+tar_path">tar_path</a>()</code>,
<code><a href="#topic+tar_path_script">tar_path_script</a>()</code>,
<code><a href="#topic+tar_path_script_support">tar_path_script_support</a>()</code>,
<code><a href="#topic+tar_path_store">tar_path_store</a>()</code>,
<code><a href="#topic+tar_path_target">tar_path_target</a>()</code>,
<code><a href="#topic+tar_source">tar_source</a>()</code>,
<code><a href="#topic+tar_store">tar_store</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_envir()
tar_envir(default = new.env(parent = emptyenv()))
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(tar_target(x, tar_envir(default = parent.frame())))
tar_make(x)
tar_read(x)
})
}
</code></pre>

<hr>
<h2 id='tar_envvars'>Show <code>targets</code> environment variables.</h2><span id='topic+tar_envvars'></span>

<h3>Description</h3>

<p>Show all the special environment variables
available for customizing <code>targets</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_envvars(unset = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_envvars_+3A_unset">unset</code></td>
<td>
<p>Character of length 1, value to return
for any environment variable that is not set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You can customize the behavior of <code>targets</code>
with special environment variables. The sections in this help file
describe each environment variable, and the <code>tar_envvars()</code> function
lists their current values.
</p>
<p>If you modify environment variables, please set them
in project-level <code>.Renviron</code> file so you do not lose your
configuration when you restart your R session.
Modify the project-level <code>.Renviron</code> file with
<code>usethis::edit_r_environ(scope = "project")</code>. Restart
your R session after you are done editing.
</p>
<p>For targets that run on parallel workers
created by <code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code> or <code><a href="#topic+tar_make_future">tar_make_future()</a></code>,
only the environment variables listed by <code><a href="#topic+tar_envvars">tar_envvars()</a></code>
are specifically exported to the targets.
For all other environment variables, you will have to set
the values manually, e.g. a project-level <code>.Renviron</code> file
(for workers that have access to the local file system).
</p>


<h3>Value</h3>

<p>A data frame with one row per environment variable
and columns with the name and current value of each.
An unset environment variable will have a value of <code>""</code>
by default. (Customize with the <code>unset</code> argument).
</p>


<h3>TAR_ASK</h3>

<p>The <code>TAR_ASK</code> environment variable accepts values <code>"true"</code> and <code>"false"</code>.
If <code>TAR_ASK</code> is not set, or if it is set to <code>"true"</code>,
then <code>targets</code> asks permission in a menu
before overwriting certain files, such as the target script file
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) in <code><a href="#topic+tar_script">tar_script()</a></code>.
If <code>TAR_ASK</code> is <code>"false"</code>, then <code>targets</code> overwrites the old files
with the new ones without asking. Once you are comfortable with
<code><a href="#topic+tar_script">tar_script()</a></code>, <code><a href="#topic+tar_github_actions">tar_github_actions()</a></code>, and similar functions,
you can safely set <code>TAR_ASK</code> to <code>"false"</code> in either a project-level
or user-level <code>.Renviron</code> file.
</p>


<h3>TAR_CONFIG</h3>

<p>The <code>TAR_CONFIG</code> environment variable controls the file path to the
optional YAML configuration file with project settings.
See the help file of <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details.
</p>


<h3>TAR_PROJECT</h3>

<p>The <code>TAR_PROJECT</code> environment variable sets the name of project
to set and get settings when working with the YAML configuration file.
See the help file of <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details.
</p>


<h3>TAR_WARN</h3>

<p>The <code>TAR_WARN</code> environment variable accepts values <code>"true"</code> and <code>"false"</code>.
If <code>TAR_WARN</code> is not set, or if it is set to <code>"true"</code>,
then <code>targets</code> throws warnings in certain edge cases,
such as target/global name conflicts and dangerous use of
<code>devtools::load_all()</code>. If <code>TAR_WARN</code> is <code>"false"</code>, then <code>targets</code>
does not throw warnings in these cases.
These warnings can detect potentially serious
issues with your pipeline, so please do not set <code>TAR_WARN</code>
unless your use case absolutely requires it.
</p>


<h3>See Also</h3>

<p>Other configuration: 
<code><a href="#topic+tar_config_get">tar_config_get</a>()</code>,
<code><a href="#topic+tar_config_projects">tar_config_projects</a>()</code>,
<code><a href="#topic+tar_config_set">tar_config_set</a>()</code>,
<code><a href="#topic+tar_config_unset">tar_config_unset</a>()</code>,
<code><a href="#topic+tar_config_yaml">tar_config_yaml</a>()</code>,
<code><a href="#topic+tar_option_get">tar_option_get</a>()</code>,
<code><a href="#topic+tar_option_reset">tar_option_reset</a>()</code>,
<code><a href="#topic+tar_option_set">tar_option_set</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_envvars()
</code></pre>

<hr>
<h2 id='tar_errored'>List errored targets.</h2><span id='topic+tar_errored'></span>

<h3>Description</h3>

<p>List targets whose progress is <code>"errored"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_errored(names = NULL, store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_errored_+3A_names">names</code></td>
<td>
<p>Optional, names of the targets. If supplied, the
output is restricted to the selected targets.
The object supplied to <code>names</code> should be <code>NULL</code> or a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_errored_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of errored targets.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other progress: 
<code><a href="#topic+tar_canceled">tar_canceled</a>()</code>,
<code><a href="#topic+tar_completed">tar_completed</a>()</code>,
<code><a href="#topic+tar_dispatched">tar_dispatched</a>()</code>,
<code><a href="#topic+tar_poll">tar_poll</a>()</code>,
<code><a href="#topic+tar_progress">tar_progress</a>()</code>,
<code><a href="#topic+tar_progress_branches">tar_progress_branches</a>()</code>,
<code><a href="#topic+tar_progress_summary">tar_progress_summary</a>()</code>,
<code><a href="#topic+tar_skipped">tar_skipped</a>()</code>,
<code><a href="#topic+tar_watch">tar_watch</a>()</code>,
<code><a href="#topic+tar_watch_server">tar_watch_server</a>()</code>,
<code><a href="#topic+tar_watch_ui">tar_watch_ui</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(2)),
    tar_target(y, 2 * x, pattern = map(x))
  )
}, ask = FALSE)
tar_make()
tar_errored()
tar_errored(starts_with("y_")) # see also any_of()
})
}
</code></pre>

<hr>
<h2 id='tar_exist_meta'>Check if target metadata exists.</h2><span id='topic+tar_exist_meta'></span>

<h3>Description</h3>

<p>Check if the target metadata file <code style="white-space: pre;">&#8288;_targets/meta/meta&#8288;</code>
exists for the current project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_exist_meta(store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_exist_meta_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To learn more about data storage in <code>targets</code>, visit
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>.
</p>


<h3>Value</h3>

<p>Logical of length 1, whether the current project's metadata exists.
</p>


<h3>See Also</h3>

<p>Other existence: 
<code><a href="#topic+tar_exist_objects">tar_exist_objects</a>()</code>,
<code><a href="#topic+tar_exist_process">tar_exist_process</a>()</code>,
<code><a href="#topic+tar_exist_progress">tar_exist_progress</a>()</code>,
<code><a href="#topic+tar_exist_script">tar_exist_script</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_exist_meta()
</code></pre>

<hr>
<h2 id='tar_exist_objects'>Check if local output data exists for one or more targets.</h2><span id='topic+tar_exist_objects'></span>

<h3>Description</h3>

<p>Check if output target data exists in either
<code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code> or the cloud for one or more targets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_exist_objects(
  names,
  cloud = TRUE,
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_exist_objects_+3A_names">names</code></td>
<td>
<p>Character vector of target names.
Not <code>tidyselect</code>-compatible.</p>
</td></tr>
<tr><td><code id="tar_exist_objects_+3A_cloud">cloud</code></td>
<td>
<p>Logical of length 1, whether to include
cloud targets in the output
(e.g. <code>tar_target(..., repository = "aws")</code>).</p>
</td></tr>
<tr><td><code id="tar_exist_objects_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If a target has no metadata or if the <code>repository</code>
argument of <code><a href="#topic+tar_target">tar_target()</a></code> was set to <code>"local"</code>,
then the <code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code> folder is checked. Otherwise,
if there is metadata and <code>repsitory</code> is not <code>"local"</code>,
then <code>tar_exist_objects()</code> checks the cloud repository
selected.
</p>


<h3>Value</h3>

<p>Logical of length <code>length(names)</code>, whether
each given target has an existing file in either
<code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code> or the cloud.
</p>


<h3>See Also</h3>

<p>Other existence: 
<code><a href="#topic+tar_exist_meta">tar_exist_meta</a>()</code>,
<code><a href="#topic+tar_exist_process">tar_exist_process</a>()</code>,
<code><a href="#topic+tar_exist_progress">tar_exist_progress</a>()</code>,
<code><a href="#topic+tar_exist_script">tar_exist_script</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_exist_objects(c("target1", "target2"))
</code></pre>

<hr>
<h2 id='tar_exist_process'>Check if process metadata exists.</h2><span id='topic+tar_exist_process'></span>

<h3>Description</h3>

<p>Check if the process metadata file <code style="white-space: pre;">&#8288;_targets/meta/process&#8288;</code>
exists for the current project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_exist_process(store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_exist_process_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To learn more about data storage in <code>targets</code>, visit
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>.
</p>


<h3>Value</h3>

<p>Logical of length 1, whether the current project's metadata exists.
</p>


<h3>See Also</h3>

<p>Other existence: 
<code><a href="#topic+tar_exist_meta">tar_exist_meta</a>()</code>,
<code><a href="#topic+tar_exist_objects">tar_exist_objects</a>()</code>,
<code><a href="#topic+tar_exist_progress">tar_exist_progress</a>()</code>,
<code><a href="#topic+tar_exist_script">tar_exist_script</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_exist_process()
</code></pre>

<hr>
<h2 id='tar_exist_progress'>Check if progress metadata exists.</h2><span id='topic+tar_exist_progress'></span>

<h3>Description</h3>

<p>Check if the progress metadata file <code style="white-space: pre;">&#8288;_targets/meta/progress&#8288;</code>
exists for the current project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_exist_progress(store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_exist_progress_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To learn more about data storage in <code>targets</code>, visit
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>.
</p>


<h3>Value</h3>

<p>Logical of length 1, whether the current project's metadata exists.
</p>


<h3>See Also</h3>

<p>Other existence: 
<code><a href="#topic+tar_exist_meta">tar_exist_meta</a>()</code>,
<code><a href="#topic+tar_exist_objects">tar_exist_objects</a>()</code>,
<code><a href="#topic+tar_exist_process">tar_exist_process</a>()</code>,
<code><a href="#topic+tar_exist_script">tar_exist_script</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_exist_progress()
</code></pre>

<hr>
<h2 id='tar_exist_script'>Check if the target script file exists.</h2><span id='topic+tar_exist_script'></span>

<h3>Description</h3>

<p>Check if the target script file exists for the
current project. The target script is <code style="white-space: pre;">&#8288;_targets.R&#8288;</code> by default,
but the path can be configured for the current project
using <code><a href="#topic+tar_config_set">tar_config_set()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_exist_script(script = targets::tar_config_get("script"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_exist_script_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical of length 1, whether the current project's metadata exists.
</p>


<h3>See Also</h3>

<p>Other existence: 
<code><a href="#topic+tar_exist_meta">tar_exist_meta</a>()</code>,
<code><a href="#topic+tar_exist_objects">tar_exist_objects</a>()</code>,
<code><a href="#topic+tar_exist_process">tar_exist_process</a>()</code>,
<code><a href="#topic+tar_exist_progress">tar_exist_progress</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_exist_script()
</code></pre>

<hr>
<h2 id='tar_format'>Define a custom target storage format.</h2><span id='topic+tar_format'></span>

<h3>Description</h3>

<p>Define a custom target storage format for the
<code>format</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code> or <code><a href="#topic+tar_option_set">tar_option_set()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_format(
  read = NULL,
  write = NULL,
  marshal = NULL,
  unmarshal = NULL,
  convert = NULL,
  copy = NULL,
  repository = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_format_+3A_read">read</code></td>
<td>
<p>A function with a single argument named <code>path</code>.
This function should read and return the target stored
at the file in the argument. It should have no side effects.
See the &quot;Format functions&quot; section for specific requirements.
If <code>NULL</code>, the <code>read</code> argument defaults to <code>readRDS()</code>.</p>
</td></tr>
<tr><td><code id="tar_format_+3A_write">write</code></td>
<td>
<p>A function with two arguments: <code>object</code> and <code>path</code>,
in that order. This function should save the R object <code>object</code>
to the file path at <code>path</code> and have no other side effects.
The function need not return a value, but the file written to <code>path</code>
must be a single file, and it cannot be a directory.
See the &quot;Format functions&quot; section for specific requirements.
If <code>NULL</code>, the <code>write</code> argument defaults to <code>saveRDS()</code>
with <code>version = 3</code>.</p>
</td></tr>
<tr><td><code id="tar_format_+3A_marshal">marshal</code></td>
<td>
<p>A function with a single argument named <code>object</code>.
This function should marshal the R object and return
an in-memory object that can be exported to remote parallel workers.
It should not read or write any persistent files.
See the Marshalling section for details.
See the &quot;Format functions&quot; section for specific requirements.
If <code>NULL</code>, the <code>marshal</code> argument defaults to just
returning the original object without any modifications.</p>
</td></tr>
<tr><td><code id="tar_format_+3A_unmarshal">unmarshal</code></td>
<td>
<p>A function with a single argument named <code>object</code>.
This function should unmarshal the (marshalled) R object and return
an in-memory object that is appropriate and valid for use
on a parallel worker. It should not read or write any persistent files.
See the Marshalling section for details.
See the &quot;Format functions&quot; section for specific requirements.
If <code>NULL</code>, the <code>unmarshal</code> argument defaults to just
returning the original object without any modifications.</p>
</td></tr>
<tr><td><code id="tar_format_+3A_convert">convert</code></td>
<td>
<p>The <code>convert</code> argument is a function
that accepts the object returned by the command of the target
and changes it into an acceptable format (e.g. can be
saved with the <code>read</code> function). The <code>convert</code>
ensures the in-memory copy
of an object during the running pipeline session
is the same as the copy of the object that is saved
to disk. The function should be idempotent, and it should
handle edge cases like <code>NULL</code> values (especially for
<code>error = "null"</code> in <code><a href="#topic+tar_target">tar_target()</a></code> or <code><a href="#topic+tar_option_set">tar_option_set()</a></code>).
If <code>NULL</code>, the <code>convert</code> argument defaults to just
returning the original object without any modifications.</p>
</td></tr>
<tr><td><code id="tar_format_+3A_copy">copy</code></td>
<td>
<p>The <code>copy</code> argument is a function
that accepts the object returned by the command of the target
and makes a deep copy in memory. This method does is relevant
to objects like <code>data.table</code>s that support in-place modification
which could cause unpredictable side effects from target
to target. In cases like these, the target should be deep-copied
before a downstream target attempts to use it (in the case of
<code>data.table</code> objects, using <code>data.table::copy()</code>).
If <code>NULL</code>, the <code>copy</code> argument defaults to just
returning the original object without any modifications.</p>
</td></tr>
<tr><td><code id="tar_format_+3A_repository">repository</code></td>
<td>
<p>Deprecated. Use the <code>repository</code> argument of
<code><a href="#topic+tar_target">tar_target()</a></code> or <code><a href="#topic+tar_option_set">tar_option_set()</a></code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is good practice to write formats that correctly handle
<code>NULL</code> objects if you are planning to set <code>error = "null"</code>
in <code><a href="#topic+tar_option_set">tar_option_set()</a></code>.
</p>


<h3>Value</h3>

<p>A character string of length 1 encoding the custom format.
You can supply this string directly to the <code>format</code>
argument of <code><a href="#topic+tar_target">tar_target()</a></code> or <code><a href="#topic+tar_option_set">tar_option_set()</a></code>.
</p>


<h3>Marshalling</h3>

<p>If an object can only be used in the R session
where it was created, it is called &quot;non-exportable&quot;.
Examples of non-exportable R objects are Keras models,
Torch objects, <code>xgboost</code> matrices, <code>xml2</code> documents,
<code>rstan</code> model objects, <code>sparklyr</code> data objects, and
database connection objects. These objects cannot be
exported to parallel workers (e.g. for <code><a href="#topic+tar_make_future">tar_make_future()</a></code>)
without special treatment. To send an non-exportable
object to a parallel worker, the object must be marshalled:
converted into a form that can be exported safely
(similar to serialization but not always the same).
Then, the worker must unmarshal the object: convert it
into a form that is usable and valid in the current R session.
Arguments <code>marshal</code> and <code>unmarshal</code> of <code>tar_format()</code>
let you control how marshalling and unmarshalling happens.
</p>


<h3>Format functions</h3>

<p>In <code>tar_format()</code>, functions like <code>read</code>, <code>write</code>,
<code>marshal</code>, and <code>unmarshal</code> must be perfectly pure
and perfectly self-sufficient.
They must load or namespace all their own packages,
and they must not depend on any custom user-defined
functions or objects in the global environment of your pipeline.
<code>targets</code> converts each function to and from text,
so it must not rely on any data in the closure.
This disqualifies functions produced by <code>Vectorize()</code>,
for example.
</p>
<p>The <code>write</code> function must write only a single file,
and the file it writes must not be a directory.
</p>
<p>The functions to read and write the object
should not do any conversions on the object. That is the job
of the <code>convert</code> argument. The <code>convert</code> argument is a function
that accepts the object returned by the command of the target
and changes it into an acceptable format (e.g. can be
saved with the <code>read</code> function). Working with the <code>convert</code>
function is best because it ensures the in-memory copy
of an object during the running pipeline session
is the same as the copy of the object that is saved
to disk.
</p>


<h3>See Also</h3>

<p>Other targets: 
<code><a href="#topic+tar_cue">tar_cue</a>()</code>,
<code><a href="#topic+tar_target">tar_target</a>()</code>,
<code><a href="#topic+tar_target_raw">tar_target_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following target is equivalent to the current superseded
# tar_target(name, command(), format = "keras").
# An improved version of this would supply a `convert` argument
# to handle NULL objects, which are returned by the target if it
# errors and the error argument of tar_target() is "null".
tar_target(
  name = keras_target,
  command = your_function(),
  format = tar_format(
    read = function(path) {
      keras::load_model_hdf5(path)
    },
    write = function(object, path) {
      keras::save_model_hdf5(object = object, filepath = path)
    },
    marshal = function(object) {
      keras::serialize_model(object)
    },
    unmarshal = function(object) {
      keras::unserialize_model(object)
    }
  )
)
# And the following is equivalent to the current superseded
# tar_target(name, torch::torch_tensor(seq_len(4)), format = "torch"),
# except this version has a `convert` argument to handle
# cases when `NULL` is returned (e.g. if the target errors out
# and the `error` argument is "null" in tar_target()
# or tar_option_set())
tar_target(
  name = torch_target,
  command = torch::torch_tensor(),
  format = tar_format(
    read = function(path) {
      torch::torch_load(path)
    },
    write = function(object, path) {
      torch::torch_save(obj = object, path = path)
    },
    marshal = function(object) {
      con &lt;- rawConnection(raw(), open = "wr")
      on.exit(close(con))
      torch::torch_save(object, con)
      rawConnectionValue(con)
    },
    unmarshal = function(object) {
      con &lt;- rawConnection(object, open = "r")
      on.exit(close(con))
      torch::torch_load(con)
    }
  )
)
</code></pre>

<hr>
<h2 id='tar_github_actions'>Set up GitHub Actions to run a targets pipeline</h2><span id='topic+tar_github_actions'></span>

<h3>Description</h3>

<p>Writes a GitHub Actions workflow file so the pipeline
runs on every push to GitHub. Historical runs accumulate in the
<code>targets-runs</code> branch, and the latest output is restored before
<code><a href="#topic+tar_make">tar_make()</a></code> so up-to-date targets do not rerun.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_github_actions(
  path = file.path(".github", "workflows", "targets.yaml"),
  ask = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_github_actions_+3A_path">path</code></td>
<td>
<p>Character of length 1, file path to write the GitHub Actions
workflow file.</p>
</td></tr>
<tr><td><code id="tar_github_actions_+3A_ask">ask</code></td>
<td>
<p>Logical, whether to ask before writing if the workflow file
already exists. If <code>NULL</code>, defaults to <code>Sys.getenv("TAR_ASK")</code>.
(Set to <code>"true"</code> or <code>"false"</code> with <code>Sys.setenv()</code>).
If <code>ask</code> and the <code>TAR_ASK</code> environment variable are both
indeterminate, defaults to <code>interactive()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Steps to set up continuous deployment:
</p>

<ol>
<li><p> Ensure your pipeline stays within the resource limitations of
GitHub Actions and repositories, both for storage and compute.
For storage, you may wish to reduce the burden with
an alternative repository (e.g. <code>tar_target(..., repository = "aws")</code>).
</p>
</li>
<li><p> Ensure Actions are enabled in your GitHub repository.
You may have to visit the Settings tab.
</p>
</li>
<li><p> Call <code>targets::tar_renv(extras = character(0))</code>
to expose hidden package dependencies.
</p>
</li>
<li><p> Set up <code>renv</code> for your project (with <code>renv::init()</code>
or <code>renv::snapshot()</code>). Details at
<a href="https://rstudio.github.io/renv/articles/ci.html">https://rstudio.github.io/renv/articles/ci.html</a>.
</p>
</li>
<li><p> Commit the <code>renv.lock</code> file to the <code>main</code> (recommended)
or <code>master</code> Git branch.
</p>
</li>
<li><p> Run <code>tar_github_actions()</code> to create the workflow file.
Commit this file to <code>main</code> (recommended) or <code>master</code> in Git.
</p>
</li>
<li><p> Push your project to GitHub. Verify that a GitHub Actions
workflow runs and pushes results to <code>targets-runs</code>.
Subsequent runs will only recompute the outdated targets.
</p>
</li></ol>



<h3>Value</h3>

<p>Nothing (invisibly). This function writes a GitHub Actions
workflow file as a side effect.
</p>


<h3>See Also</h3>

<p>Other scripts: 
<code><a href="#topic+tar_edit">tar_edit</a>()</code>,
<code><a href="#topic+tar_helper">tar_helper</a>()</code>,
<code><a href="#topic+tar_helper_raw">tar_helper_raw</a>()</code>,
<code><a href="#topic+tar_renv">tar_renv</a>()</code>,
<code><a href="#topic+tar_script">tar_script</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_github_actions(tempfile())
</code></pre>

<hr>
<h2 id='tar_glimpse'>Visualize an abridged fast dependency graph.</h2><span id='topic+tar_glimpse'></span>

<h3>Description</h3>

<p>Analyze the pipeline defined in the target script file
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>)
and visualize the directed acyclic graph of targets.
Unlike <code><a href="#topic+tar_visnetwork">tar_visnetwork()</a></code>, <code>tar_glimpse()</code> does not account for
metadata or progress information, which means the graph
renders faster. Also, <code>tar_glimpse()</code> omits functions and other global
objects by default (but you can include them with <code>targets_only = FALSE</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_glimpse(
  targets_only = TRUE,
  names = NULL,
  shortcut = FALSE,
  allow = NULL,
  exclude = ".Random.seed",
  label = targets::tar_config_get("label"),
  label_width = targets::tar_config_get("label_width"),
  level_separation = targets::tar_config_get("level_separation"),
  degree_from = 1L,
  degree_to = 1L,
  zoom_speed = 1,
  physics = FALSE,
  callr_function = callr::r,
  callr_arguments = targets::tar_callr_args_default(callr_function),
  envir = parent.frame(),
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_glimpse_+3A_targets_only">targets_only</code></td>
<td>
<p>Logical, whether to restrict the output to just targets
(<code>FALSE</code>) or to also include global functions and objects.</p>
</td></tr>
<tr><td><code id="tar_glimpse_+3A_names">names</code></td>
<td>
<p>Names of targets. The graph visualization will operate
only on these targets (and unless <code>shortcut</code> is <code>TRUE</code>,
all the targets upstream as well). Selecting a small subgraph
using <code>names</code> could speed up the load time of the visualization.
Unlike <code>allow</code>, <code>names</code> is invoked before the graph is generated.
Set to NULL to check/run all the targets (default).
Otherwise, the object supplied to <code>names</code> should be a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_glimpse_+3A_shortcut">shortcut</code></td>
<td>
<p>Logical of length 1, how to interpret the <code>names</code> argument.
If <code>shortcut</code> is <code>FALSE</code> (default) then the function checks
all targets upstream of <code>names</code> as far back as the dependency graph goes.
If <code>TRUE</code>, then the function only checks the targets in <code>names</code>
and uses stored metadata for information about upstream dependencies
as needed. <code>shortcut = TRUE</code> increases speed if there are a lot of
up-to-date targets, but it assumes all the dependencies
are up to date, so please use with caution.
Also, <code>shortcut = TRUE</code> only works if you set <code>names</code>.</p>
</td></tr>
<tr><td><code id="tar_glimpse_+3A_allow">allow</code></td>
<td>
<p>Optional, define the set of allowable vertices in the graph.
Unlike <code>names</code>, <code>allow</code> is invoked only after the graph is mostly
resolved, so it will not speed up execution.
Set to <code>NULL</code> to allow all vertices in the pipeline and environment
(default). Otherwise, you can supply symbols or
<code>tidyselect</code> helpers like <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_glimpse_+3A_exclude">exclude</code></td>
<td>
<p>Optional, define the set of exclude vertices from the graph.
Unlike <code>names</code>, <code>exclude</code> is invoked only after the graph is mostly
resolved, so it will not speed up execution.
Set to <code>NULL</code> to exclude no vertices.
Otherwise, you can supply symbols or <code>tidyselect</code>
helpers like <code><a href="#topic+any_of">any_of()</a></code> and <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_glimpse_+3A_label">label</code></td>
<td>
<p>Character vector of one or more aesthetics to add to the
vertex labels. Currently, the only option is  <code>"description"</code> to show each
target's custom description, or <code>character(0)</code> to suppress it.</p>
</td></tr>
<tr><td><code id="tar_glimpse_+3A_label_width">label_width</code></td>
<td>
<p>Positive numeric of length 1, maximum width
(in number of characters) of the node labels.</p>
</td></tr>
<tr><td><code id="tar_glimpse_+3A_level_separation">level_separation</code></td>
<td>
<p>Numeric of length 1,
<code>levelSeparation</code> argument of <code>visNetwork::visHierarchicalLayout()</code>.
Controls the distance between hierarchical levels.
Consider changing the value if the aspect ratio of the graph
is far from 1. If <code>level_separation</code> is <code>NULL</code>,
the <code>levelSeparation</code> argument of <code>visHierarchicalLayout()</code>
defaults to <code>150</code>.</p>
</td></tr>
<tr><td><code id="tar_glimpse_+3A_degree_from">degree_from</code></td>
<td>
<p>Integer of length 1. When you click on a node,
the graph highlights a neighborhood of that node. <code>degree_from</code>
controls the number of edges the neighborhood extends upstream.</p>
</td></tr>
<tr><td><code id="tar_glimpse_+3A_degree_to">degree_to</code></td>
<td>
<p>Integer of length 1. When you click on a node,
the graph highlights a neighborhood of that node. <code>degree_to</code>
controls the number of edges the neighborhood extends downstream.</p>
</td></tr>
<tr><td><code id="tar_glimpse_+3A_zoom_speed">zoom_speed</code></td>
<td>
<p>Positive numeric of length 1, scaling factor on the
zoom speed. Above 1 zooms faster than default, below 1 zooms
lower than default.</p>
</td></tr>
<tr><td><code id="tar_glimpse_+3A_physics">physics</code></td>
<td>
<p>Logical of length 1, whether to implement interactive
physics in the graph, e.g. edge elasticity.</p>
</td></tr>
<tr><td><code id="tar_glimpse_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_glimpse_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
<tr><td><code id="tar_glimpse_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_glimpse_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_glimpse_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>visNetwork</code> HTML widget object.
</p>


<h3>Dependency graph</h3>

<p>The dependency graph of a pipeline is a directed acyclic graph (DAG)
where each node indicates a target or global object and each directed
edge indicates where a downstream node depends on an upstream node.
The DAG is not always a tree, but it never contains a cycle because
no target is allowed to directly or indirectly depend on itself.
The dependency graph should show a natural progression of work from
left to right. <code>targets</code> uses static code analysis to create the graph,
so the order of <code>tar_target()</code> calls in the <code style="white-space: pre;">&#8288;_targets.R&#8288;</code> file
does not matter. However, targets does not support self-referential
loops or other cycles. For more information on the dependency graph,
please read
<a href="https://books.ropensci.org/targets/targets.html#dependencies">https://books.ropensci.org/targets/targets.html#dependencies</a>.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other visualize: 
<code><a href="#topic+tar_mermaid">tar_mermaid</a>()</code>,
<code><a href="#topic+tar_visnetwork">tar_visnetwork</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_INTERACTIVE_EXAMPLES"), "true")) {
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  tar_option_set()
  list(
    tar_target(y1, 1 + 1),
    tar_target(y2, 1 + 1),
    tar_target(z, y1 + y2)
  )
}, ask = FALSE)
tar_glimpse()
tar_glimpse(allow = starts_with("y")) # see also any_of()
})
}
</code></pre>

<hr>
<h2 id='tar_group'>Group a data frame to iterate over subsets of rows.</h2><span id='topic+tar_group'></span>

<h3>Description</h3>

<p>Like <code>dplyr::group_by()</code>, but for patterns.
<code>tar_group()</code> allows you to map or cross over subsets of data frames.
Requires <code>iteration = "group"</code> on the target. See the example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_group(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_group_+3A_x">x</code></td>
<td>
<p>Grouped data frame from <code>dplyr::group_by()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal of <code>tar_group()</code> is to post-process the return value
of a data frame target to allow downstream targets to branch over
subsets of rows. It takes the groups defined by <code>dplyr::group_by()</code>
and translates that information into a special <code>tar_group</code> is a column.
<code>tar_group</code> is a vector of positive integers
from 1 to the number of groups. Rows with the same integer in <code>tar_group</code>
belong to the same group, and branches are arranged in increasing order
with respect to the integers in <code>tar_group</code>.
The assignment of <code>tar_group</code> integers to group levels
depends on the orderings inside the grouping variables and not the order
of rows in the dataset. <code>dplyr::group_keys()</code> on the grouped data frame
shows how the grouping variables correspond to the integers in the
<code>tar_group</code> column.
</p>


<h3>Value</h3>

<p>A data frame with a special <code>tar_group</code> column that
<code>targets</code> will use to find subsets of your data frame.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+tar_active">tar_active</a>()</code>,
<code><a href="#topic+tar_backoff">tar_backoff</a>()</code>,
<code><a href="#topic+tar_call">tar_call</a>()</code>,
<code><a href="#topic+tar_cancel">tar_cancel</a>()</code>,
<code><a href="#topic+tar_definition">tar_definition</a>()</code>,
<code><a href="#topic+tar_described_as">tar_described_as</a>()</code>,
<code><a href="#topic+tar_envir">tar_envir</a>()</code>,
<code><a href="#topic+tar_name">tar_name</a>()</code>,
<code><a href="#topic+tar_path">tar_path</a>()</code>,
<code><a href="#topic+tar_path_script">tar_path_script</a>()</code>,
<code><a href="#topic+tar_path_script_support">tar_path_script_support</a>()</code>,
<code><a href="#topic+tar_path_store">tar_path_store</a>()</code>,
<code><a href="#topic+tar_path_target">tar_path_target</a>()</code>,
<code><a href="#topic+tar_source">tar_source</a>()</code>,
<code><a href="#topic+tar_store">tar_store</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
# The tar_group() function simply creates
# a tar_group column to partition the rows
# of a data frame.
data.frame(
  x = seq_len(6),
  id = rep(letters[seq_len(3)], each = 2)
) %&gt;%
  dplyr::group_by(id) %&gt;%
  tar_group()
# We use tar_group() below to branch over
# subsets of a data frame defined with dplyr::group_by().
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
library(dplyr)
list(
  tar_target(
    data,
    data.frame(
      x = seq_len(6),
      id = rep(letters[seq_len(3)], each = 2)
    ) %&gt;%
      group_by(id) %&gt;%
      tar_group(),
    iteration = "group"
  ),
  tar_target(
    sums,
    sum(data$x),
    pattern = map(data),
    iteration = "vector"
  )
)
})
tar_make()
tar_read(sums) # Should be c(3, 7, 11).
})
}
</code></pre>

<hr>
<h2 id='tar_helper'>Write a helper R script.</h2><span id='topic+tar_helper'></span>

<h3>Description</h3>

<p>Write a helper R script for a <code>targets</code> pipeline.
Could be supporting functions or the target script file
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_helper(path = NULL, code = NULL, tidy_eval = TRUE, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_helper_+3A_path">path</code></td>
<td>
<p>Character of length 1, path to write (or overwrite) <code>code</code>.
If the parent directory does not exist, <code>tar_helper_raw()</code> creates it.</p>
</td></tr>
<tr><td><code id="tar_helper_+3A_code">code</code></td>
<td>
<p>Quoted code to write to <code>path</code>.
<code>tar_helper()</code> overwrites the file if it already exists.</p>
</td></tr>
<tr><td><code id="tar_helper_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to use tidy evaluation on <code>code</code>. If
turned on, you can substitute expressions and symbols using <code style="white-space: pre;">&#8288;!!&#8288;</code> and <code style="white-space: pre;">&#8288;!!!&#8288;</code>.
See examples below.</p>
</td></tr>
<tr><td><code id="tar_helper_+3A_envir">envir</code></td>
<td>
<p>Environment for tidy evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_helper()</code> is a specialized version of <code><a href="#topic+tar_script">tar_script()</a></code>
with flexible paths and tidy evaluation.
</p>


<h3>Value</h3>

<p><code>NULL</code> (invisibly)
</p>


<h3>See Also</h3>

<p>Other scripts: 
<code><a href="#topic+tar_edit">tar_edit</a>()</code>,
<code><a href="#topic+tar_github_actions">tar_github_actions</a>()</code>,
<code><a href="#topic+tar_helper_raw">tar_helper_raw</a>()</code>,
<code><a href="#topic+tar_renv">tar_renv</a>()</code>,
<code><a href="#topic+tar_script">tar_script</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Without tidy evaluation:
path &lt;- tempfile()
tar_helper(path, x &lt;- 1)
writeLines(readLines(path))
# With tidy evaluation:
y &lt;- 123
tar_helper(path, x &lt;- !!y)
writeLines(readLines(path))
</code></pre>

<hr>
<h2 id='tar_helper_raw'>Write a helper R script (raw version).</h2><span id='topic+tar_helper_raw'></span>

<h3>Description</h3>

<p>Write a helper R script for a <code>targets</code> pipeline.
Could be supporting functions or the target script file
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_helper_raw(path = NULL, code = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_helper_raw_+3A_path">path</code></td>
<td>
<p>Character of length 1, path to write (or overwrite) <code>code</code>.
If the parent directory does not exist, <code>tar_helper_raw()</code> creates it.</p>
</td></tr>
<tr><td><code id="tar_helper_raw_+3A_code">code</code></td>
<td>
<p>Expression object. <code>tar_helper_raw()</code> deparses and writes
this code to a file at <code>path</code>, overwriting it if the file already exists.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_helper_raw()</code> is a specialized version of <code><a href="#topic+tar_script">tar_script()</a></code>
with flexible paths and tidy evaluation. It is like <code><a href="#topic+tar_helper">tar_helper()</a></code>
except that <code>code</code> is an &quot;evaluated&quot; argument rather than a quoted one.
</p>


<h3>Value</h3>

<p><code>NULL</code> (invisibly)
</p>


<h3>See Also</h3>

<p>Other scripts: 
<code><a href="#topic+tar_edit">tar_edit</a>()</code>,
<code><a href="#topic+tar_github_actions">tar_github_actions</a>()</code>,
<code><a href="#topic+tar_helper">tar_helper</a>()</code>,
<code><a href="#topic+tar_renv">tar_renv</a>()</code>,
<code><a href="#topic+tar_script">tar_script</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>path &lt;- tempfile()
tar_helper_raw(path, quote(x &lt;- 1))
writeLines(readLines(path))
</code></pre>

<hr>
<h2 id='tar_interactive'>Run if Target Markdown interactive mode is on.</h2><span id='topic+tar_interactive'></span>

<h3>Description</h3>

<p>In Target Markdown, run the enclosed code
only if interactive mode is activated. Otherwise,
do not run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_interactive(code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_interactive_+3A_code">code</code></td>
<td>
<p>R code to run if Target Markdown interactive mode
is turned on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Visit &lt;books.ropensci.org/targets/literate-programming.html&gt;
to learn about Target Markdown and interactive mode.
</p>


<h3>Value</h3>

<p>If Target Markdown interactive mode is turned on,
the function returns the result of running the code.
Otherwise, the function invisibly returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p>Other Target Markdown: 
<code><a href="#topic+tar_engine_knitr">tar_engine_knitr</a>()</code>,
<code><a href="#topic+tar_noninteractive">tar_noninteractive</a>()</code>,
<code><a href="#topic+tar_toggle">tar_toggle</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_interactive(message("In interactive mode."))
</code></pre>

<hr>
<h2 id='tar_invalidate'>Delete one or more metadata records (e.g. to rerun a target).</h2><span id='topic+tar_invalidate'></span>

<h3>Description</h3>

<p>Delete the metadata of records in <code style="white-space: pre;">&#8288;_targets/meta/meta&#8288;</code>
but keep the return values of targets in <code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_invalidate(names, store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_invalidate_+3A_names">names</code></td>
<td>
<p>Names of the targets to remove from the metadata list.
The object supplied to <code>names</code> should be a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_invalidate_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function forces one or more targets to rerun
on the next <code><a href="#topic+tar_make">tar_make()</a></code>, regardless of the cues and regardless
of how those targets are stored. After <code>tar_invalidate()</code>,
you will still be able to locate the data files with <code><a href="#topic+tar_path_target">tar_path_target()</a></code>
and manually salvage them in an emergency.
However, <code><a href="#topic+tar_load">tar_load()</a></code> and <code><a href="#topic+tar_read">tar_read()</a></code> will not be able to
read the data into R, and subsequent calls to <code><a href="#topic+tar_make">tar_make()</a></code>
will attempt to rerun those targets.
For patterns recorded in the metadata, all the branches
will be invalidated. For patterns no longer in the metadata,
branches are left alone.
</p>


<h3>Value</h3>

<p><code>NULL</code> (invisibly).
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other clean: 
<code><a href="#topic+tar_delete">tar_delete</a>()</code>,
<code><a href="#topic+tar_destroy">tar_destroy</a>()</code>,
<code><a href="#topic+tar_prune">tar_prune</a>()</code>,
<code><a href="#topic+tar_prune_list">tar_prune_list</a>()</code>,
<code><a href="#topic+tar_unversion">tar_unversion</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(y1, 1 + 1),
    tar_target(y2, 1 + 1),
    tar_target(z, y1 + y2)
  )
}, ask = FALSE)
tar_make()
tar_invalidate(starts_with("y")) # Only invalidates y1 and y2.
tar_make() # y1 and y2 rerun but return same values, so z is up to date.
})
}
</code></pre>

<hr>
<h2 id='tar_language'>Language</h2><span id='topic+tar_language'></span><span id='topic+tar_deparse_language'></span><span id='topic+tar_deparse_safe'></span><span id='topic+tar_tidy_eval'></span><span id='topic+tar_tidyselect_eval'></span>

<h3>Description</h3>

<p>These functions help with metaprogramming in
packages built on top of <code>targets</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_deparse_language(expr)

tar_deparse_safe(expr, collapse = "\n", backtick = TRUE)

tar_tidy_eval(expr, envir, tidy_eval)

tar_tidyselect_eval(names_quosure, choices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_language_+3A_expr">expr</code></td>
<td>
<p>A language object to modify or deparse.</p>
</td></tr>
<tr><td><code id="tar_language_+3A_collapse">collapse</code></td>
<td>
<p>Character of length 1, delimiter in deparsing.</p>
</td></tr>
<tr><td><code id="tar_language_+3A_backtick">backtick</code></td>
<td>
<p>logical indicating whether symbolic names should be
enclosed in backticks if they do not follow the standard syntax.</p>
</td></tr>
<tr><td><code id="tar_language_+3A_envir">envir</code></td>
<td>
<p>An environment to find objects for tidy evaluation.</p>
</td></tr>
<tr><td><code id="tar_language_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical of length 1, whether to apply tidy evaluation.</p>
</td></tr>
<tr><td><code id="tar_language_+3A_names_quosure">names_quosure</code></td>
<td>
<p>An <code>rlang</code> quosure with <code>tidyselect</code> expressions.</p>
</td></tr>
<tr><td><code id="tar_language_+3A_choices">choices</code></td>
<td>
<p>A character vector of choices for character elements
returned by tidy evaluation.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>tar_deparse_language()</code> is a wrapper around <code>tar_deparse_safe()</code>
which leaves character vectors and <code>NULL</code> objects alone,
which helps with subsequent user input validation.
</p>
</li>
<li> <p><code>tar_deparse_safe()</code> is a wrapper around <code>base::deparse()</code>
with a custom set of fast default settings and guardrails
to ensure the output always has length 1.
</p>
</li>
<li> <p><code>tar_tidy_eval()</code> applies tidy evaluation to a language object
and returns another language object.
</p>
</li>
<li> <p><code>tar_tidyselect_eval()</code> applies <code>tidyselect</code> selection with
some special guardrails around <code>NULL</code> inputs.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other utilities to extend targets: 
<code><a href="#topic+tar_assert">tar_assert</a></code>,
<code><a href="#topic+tar_condition">tar_condition</a></code>,
<code><a href="#topic+tar_test">tar_test</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_deparse_language(quote(run_model()))
</code></pre>

<hr>
<h2 id='tar_load'>Load the values of targets.</h2><span id='topic+tar_load'></span>

<h3>Description</h3>

<p>Load the return values of targets into the current environment
(or the environment of your choosing). For a typical target, the return
value lives in a file in <code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code>. For dynamic files (i.e.
<code>format = "file"</code>) the paths loaded in place of the values.
<code><a href="#topic+tar_load_everything">tar_load_everything()</a></code> is shorthand for <code>tar_load(everything())</code>
to load all targets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_load(
  names,
  branches = NULL,
  meta = tar_meta(targets_only = TRUE, store = store),
  strict = TRUE,
  silent = FALSE,
  envir = parent.frame(),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_load_+3A_names">names</code></td>
<td>
<p>Names of the targets to load.
The object supplied to <code>names</code> should be a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_load_+3A_branches">branches</code></td>
<td>
<p>Integer of indices of the branches to load
for any targets that are patterns.</p>
</td></tr>
<tr><td><code id="tar_load_+3A_meta">meta</code></td>
<td>
<p>Data frame of metadata from <code><a href="#topic+tar_meta">tar_meta()</a></code>.
<code>tar_read()</code> with the default arguments can be inefficient for large
pipelines because all the metadata is stored in a single file.
However, if you call <code><a href="#topic+tar_meta">tar_meta()</a></code> beforehand and supply it to the <code>meta</code>
argument, then successive calls to <code>tar_read()</code> may run much faster.</p>
</td></tr>
<tr><td><code id="tar_load_+3A_strict">strict</code></td>
<td>
<p>Logical of length 1, whether to error out
if one of the selected targets is in the metadata
but cannot be loaded.
Set to <code>FALSE</code> to just load the targets in the metadata
that can be loaded and skip the others.</p>
</td></tr>
<tr><td><code id="tar_load_+3A_silent">silent</code></td>
<td>
<p>Logical of length 1. Only relevant when
<code>strict</code> is <code>FALSE</code>. If <code>silent</code> is <code>FALSE</code>
and <code>strict</code> is <code>FALSE</code>, then a message will be printed
if a target is in the metadata but cannot be loaded.
However, load failures
will not stop other targets from being loaded.</p>
</td></tr>
<tr><td><code id="tar_load_+3A_envir">envir</code></td>
<td>
<p>Environment to put the loaded targets.</p>
</td></tr>
<tr><td><code id="tar_load_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>Cloud target data versioning</h3>

<p>Some buckets in Amazon S3 or Google Cloud Storage are &quot;versioned&quot;,
which means they track historical versions of each data object.
If you use <code>targets</code> with cloud storage
(<a href="https://books.ropensci.org/targets/cloud-storage.html">https://books.ropensci.org/targets/cloud-storage.html</a>)
and versioning is turned on, then <code>targets</code> will record each
version of each target in its metadata.
</p>
<p>Functions like <code><a href="#topic+tar_read">tar_read()</a></code>
and <code><a href="#topic+tar_load">tar_load()</a></code> load the version recorded in the local metadata,
which may not be the same as the &quot;current&quot; version of the
object in the bucket. Likewise, functions <code><a href="#topic+tar_delete">tar_delete()</a></code>
and <code><a href="#topic+tar_destroy">tar_destroy()</a></code> only remove
the version ID of each target as recorded in the local
metadata.
</p>
<p>If you want to interact with the <em>latest</em> version of an object
instead of the version ID recorded in the local metadata,
then you will need to delete the object from the metadata.
</p>

<ol>
<li><p> Make sure your local copy of the metadata is current and
up to date. You may need to run <code><a href="#topic+tar_meta_download">tar_meta_download()</a></code> or
<code><a href="#topic+tar_meta_sync">tar_meta_sync()</a></code> first.
</p>
</li>
<li><p> Run <code><a href="#topic+tar_unversion">tar_unversion()</a></code> to remove the recorded version IDs of
your targets in the local metadata.
</p>
</li>
<li><p> With the version IDs gone from the local metadata,
functions like <code><a href="#topic+tar_read">tar_read()</a></code> and <code><a href="#topic+tar_destroy">tar_destroy()</a></code> will use the
<em>latest</em> version of each target data object.
</p>
</li>
<li><p> Optional: to back up the local metadata file with the version IDs
deleted, use <code><a href="#topic+tar_meta_upload">tar_meta_upload()</a></code>.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+tar_crew">tar_crew</a>()</code>,
<code><a href="#topic+tar_load_everything">tar_load_everything</a>()</code>,
<code><a href="#topic+tar_load_raw">tar_load_raw</a>()</code>,
<code><a href="#topic+tar_objects">tar_objects</a>()</code>,
<code><a href="#topic+tar_pid">tar_pid</a>()</code>,
<code><a href="#topic+tar_process">tar_process</a>()</code>,
<code><a href="#topic+tar_read">tar_read</a>()</code>,
<code><a href="#topic+tar_read_raw">tar_read_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(y1, 1 + 1),
    tar_target(y2, 1 + 1),
    tar_target(z, y1 + y2)
  )
}, ask = FALSE)
tar_make()
ls() # Does not have "y1", "y2", or "z".
tar_load(starts_with("y"))
ls() # Has "y1" and "y2" but not "z".
tar_load(any_of("z"))
ls() # Has "y1", "y2", and "z".
})
}
</code></pre>

<hr>
<h2 id='tar_load_everything'>Load the values of all available targets.</h2><span id='topic+tar_load_everything'></span>

<h3>Description</h3>

<p>Shorthand for <code>tar_load(everything())</code> to load all
targets with entries in the metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_load_everything(
  branches = NULL,
  meta = tar_meta(targets_only = TRUE, store = store),
  strict = TRUE,
  silent = FALSE,
  envir = parent.frame(),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_load_everything_+3A_branches">branches</code></td>
<td>
<p>Integer of indices of the branches to load
for any targets that are patterns.</p>
</td></tr>
<tr><td><code id="tar_load_everything_+3A_meta">meta</code></td>
<td>
<p>Data frame of metadata from <code><a href="#topic+tar_meta">tar_meta()</a></code>.
<code>tar_read()</code> with the default arguments can be inefficient for large
pipelines because all the metadata is stored in a single file.
However, if you call <code><a href="#topic+tar_meta">tar_meta()</a></code> beforehand and supply it to the <code>meta</code>
argument, then successive calls to <code>tar_read()</code> may run much faster.</p>
</td></tr>
<tr><td><code id="tar_load_everything_+3A_strict">strict</code></td>
<td>
<p>Logical of length 1, whether to error out
if one of the selected targets is in the metadata
but cannot be loaded.
Set to <code>FALSE</code> to just load the targets in the metadata
that can be loaded and skip the others.</p>
</td></tr>
<tr><td><code id="tar_load_everything_+3A_silent">silent</code></td>
<td>
<p>Logical of length 1. Only relevant when
<code>strict</code> is <code>FALSE</code>. If <code>silent</code> is <code>FALSE</code>
and <code>strict</code> is <code>FALSE</code>, then a message will be printed
if a target is in the metadata but cannot be loaded.
However, load failures
will not stop other targets from being loaded.</p>
</td></tr>
<tr><td><code id="tar_load_everything_+3A_envir">envir</code></td>
<td>
<p>Environment to put the loaded targets.</p>
</td></tr>
<tr><td><code id="tar_load_everything_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+tar_crew">tar_crew</a>()</code>,
<code><a href="#topic+tar_load">tar_load</a>()</code>,
<code><a href="#topic+tar_load_raw">tar_load_raw</a>()</code>,
<code><a href="#topic+tar_objects">tar_objects</a>()</code>,
<code><a href="#topic+tar_pid">tar_pid</a>()</code>,
<code><a href="#topic+tar_process">tar_process</a>()</code>,
<code><a href="#topic+tar_read">tar_read</a>()</code>,
<code><a href="#topic+tar_read_raw">tar_read_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(y1, 1 + 1),
    tar_target(y2, 1 + 1),
    tar_target(z, y1 + y2)
  )
}, ask = FALSE)
tar_make()
ls() # Does not have "y1", "y2", or "z".
tar_load_everything()
ls() # Has "y1", "y2", and "z".
})
}
</code></pre>

<hr>
<h2 id='tar_load_globals'>Load globals for debugging, testing, and prototyping</h2><span id='topic+tar_load_globals'></span>

<h3>Description</h3>

<p>Load user-defined packages, functions, global objects, and
settings defined in the target script file (default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>).
This function is for debugging, testing, and prototyping only.
It is not recommended for use inside a serious pipeline
or to report the results of a serious pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_load_globals(
  envir = parent.frame(),
  script = targets::tar_config_get("script")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_load_globals_+3A_envir">envir</code></td>
<td>
<p>Environment to source the target script (default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>).
Defaults to the calling environment.</p>
</td></tr>
<tr><td><code id="tar_load_globals_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the target script file
that defines the pipeline (<code style="white-space: pre;">&#8288;_targets.R&#8288;</code> by default).
This path should be either
an absolute path or a path relative to the project root where you will
call <code><a href="#topic+tar_make">tar_make()</a></code> and other functions. When <code><a href="#topic+tar_make">tar_make()</a></code> and friends
run the script from the current working directory.
If the argument <code>NULL</code>, the setting is not modified.
Use <code><a href="#topic+tar_config_unset">tar_config_unset()</a></code> to delete a setting.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function first sources the target script file
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>)
to loads all user-defined functions, global objects, and settings
into the current R process. Then, it loads all the packages defined
in <code>tar_option_get("packages")</code> (default: <code>(.packages())</code>)
using <code>library()</code> with <code>lib.loc</code> defined in <code>tar_option_get("library")</code>
(default: <code>NULL</code>).
</p>


<h3>Value</h3>

<p><code>NULL</code> (invisibly).
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other debug: 
<code><a href="#topic+tar_traceback">tar_traceback</a>()</code>,
<code><a href="#topic+tar_workspace">tar_workspace</a>()</code>,
<code><a href="#topic+tar_workspaces">tar_workspaces</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  tar_option_set(packages = "callr")
  analyze_data &lt;- function(data) {
    summary(data)
  }
  list(
    tar_target(x, 1 + 1),
    tar_target(y, 1 + 1)
  )
}, ask = FALSE)
tar_load_globals()
print(analyze_data)
print("callr" %in% (.packages()))
})
}
</code></pre>

<hr>
<h2 id='tar_load_raw'>Load the values of targets (raw version).</h2><span id='topic+tar_load_raw'></span>

<h3>Description</h3>

<p>Same as <code><a href="#topic+tar_load">tar_load()</a></code> except <code>names</code> is a character vector.
Do not use in <code>knitr</code> or R Markdown reports with <code>tarchetypes::tar_knit()</code>
or <code>tarchetypes::tar_render()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_load_raw(
  names,
  branches = NULL,
  meta = tar_meta(store = store),
  strict = TRUE,
  silent = FALSE,
  envir = parent.frame(),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_load_raw_+3A_names">names</code></td>
<td>
<p>Character vector, names of the targets to load.
Not <code>tidyselect</code>-compatible.
Names are expected to be in the metadata in <code style="white-space: pre;">&#8288;_targets/meta&#8288;</code>.
Any target names not in the metadata are ignored.</p>
</td></tr>
<tr><td><code id="tar_load_raw_+3A_branches">branches</code></td>
<td>
<p>Integer of indices of the branches to load
for any targets that are patterns.</p>
</td></tr>
<tr><td><code id="tar_load_raw_+3A_meta">meta</code></td>
<td>
<p>Data frame of metadata from <code><a href="#topic+tar_meta">tar_meta()</a></code>.
<code>tar_read()</code> with the default arguments can be inefficient for large
pipelines because all the metadata is stored in a single file.
However, if you call <code><a href="#topic+tar_meta">tar_meta()</a></code> beforehand and supply it to the <code>meta</code>
argument, then successive calls to <code>tar_read()</code> may run much faster.</p>
</td></tr>
<tr><td><code id="tar_load_raw_+3A_strict">strict</code></td>
<td>
<p>Logical of length 1, whether to error out
if one of the selected targets is in the metadata
but cannot be loaded.
Set to <code>FALSE</code> to just load the targets in the metadata
that can be loaded and skip the others.</p>
</td></tr>
<tr><td><code id="tar_load_raw_+3A_silent">silent</code></td>
<td>
<p>Logical of length 1. Only relevant when
<code>strict</code> is <code>FALSE</code>. If <code>silent</code> is <code>FALSE</code>
and <code>strict</code> is <code>FALSE</code>, then a message will be printed
if a target is in the metadata but cannot be loaded.
However, load failures
will not stop other targets from being loaded.</p>
</td></tr>
<tr><td><code id="tar_load_raw_+3A_envir">envir</code></td>
<td>
<p>Environment to put the loaded targets.</p>
</td></tr>
<tr><td><code id="tar_load_raw_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>Cloud target data versioning</h3>

<p>Some buckets in Amazon S3 or Google Cloud Storage are &quot;versioned&quot;,
which means they track historical versions of each data object.
If you use <code>targets</code> with cloud storage
(<a href="https://books.ropensci.org/targets/cloud-storage.html">https://books.ropensci.org/targets/cloud-storage.html</a>)
and versioning is turned on, then <code>targets</code> will record each
version of each target in its metadata.
</p>
<p>Functions like <code><a href="#topic+tar_read">tar_read()</a></code>
and <code><a href="#topic+tar_load">tar_load()</a></code> load the version recorded in the local metadata,
which may not be the same as the &quot;current&quot; version of the
object in the bucket. Likewise, functions <code><a href="#topic+tar_delete">tar_delete()</a></code>
and <code><a href="#topic+tar_destroy">tar_destroy()</a></code> only remove
the version ID of each target as recorded in the local
metadata.
</p>
<p>If you want to interact with the <em>latest</em> version of an object
instead of the version ID recorded in the local metadata,
then you will need to delete the object from the metadata.
</p>

<ol>
<li><p> Make sure your local copy of the metadata is current and
up to date. You may need to run <code><a href="#topic+tar_meta_download">tar_meta_download()</a></code> or
<code><a href="#topic+tar_meta_sync">tar_meta_sync()</a></code> first.
</p>
</li>
<li><p> Run <code><a href="#topic+tar_unversion">tar_unversion()</a></code> to remove the recorded version IDs of
your targets in the local metadata.
</p>
</li>
<li><p> With the version IDs gone from the local metadata,
functions like <code><a href="#topic+tar_read">tar_read()</a></code> and <code><a href="#topic+tar_destroy">tar_destroy()</a></code> will use the
<em>latest</em> version of each target data object.
</p>
</li>
<li><p> Optional: to back up the local metadata file with the version IDs
deleted, use <code><a href="#topic+tar_meta_upload">tar_meta_upload()</a></code>.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+tar_crew">tar_crew</a>()</code>,
<code><a href="#topic+tar_load">tar_load</a>()</code>,
<code><a href="#topic+tar_load_everything">tar_load_everything</a>()</code>,
<code><a href="#topic+tar_objects">tar_objects</a>()</code>,
<code><a href="#topic+tar_pid">tar_pid</a>()</code>,
<code><a href="#topic+tar_process">tar_process</a>()</code>,
<code><a href="#topic+tar_read">tar_read</a>()</code>,
<code><a href="#topic+tar_read_raw">tar_read_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(y1, 1 + 1),
    tar_target(y2, 1 + 1),
    tar_target(z, y1 + y2)
  )
}, ask = FALSE)
tar_make()
tar_load_raw(any_of(c("y1", "y2")))
y1
y2
})
}
</code></pre>

<hr>
<h2 id='tar_make'>Run a pipeline of targets.</h2><span id='topic+tar_make'></span>

<h3>Description</h3>

<p>Run the pipeline you defined in the targets
script file (default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>). <code>tar_make()</code>
runs the correct targets in the correct order and stores the return
values in <code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code>. Use <code><a href="#topic+tar_read">tar_read()</a></code> to read a target
back into R, and see
<a href="https://docs.ropensci.org/targets/reference/index.html#clean">https://docs.ropensci.org/targets/reference/index.html#clean</a>
to manage output files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_make(
  names = NULL,
  shortcut = targets::tar_config_get("shortcut"),
  reporter = targets::tar_config_get("reporter_make"),
  seconds_meta_append = targets::tar_config_get("seconds_meta_append"),
  seconds_meta_upload = targets::tar_config_get("seconds_meta_upload"),
  seconds_reporter = targets::tar_config_get("seconds_reporter"),
  seconds_interval = targets::tar_config_get("seconds_interval"),
  callr_function = callr::r,
  callr_arguments = targets::tar_callr_args_default(callr_function, reporter),
  envir = parent.frame(),
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store"),
  garbage_collection = targets::tar_config_get("garbage_collection"),
  use_crew = targets::tar_config_get("use_crew"),
  terminate_controller = TRUE,
  as_job = targets::tar_config_get("as_job")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_make_+3A_names">names</code></td>
<td>
<p>Names of the targets to run or check. Set to <code>NULL</code> to
check/run all the targets (default).
The object supplied to <code>names</code> should be a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_make_+3A_shortcut">shortcut</code></td>
<td>
<p>Logical of length 1, how to interpret the <code>names</code> argument.
If <code>shortcut</code> is <code>FALSE</code> (default) then the function checks
all targets upstream of <code>names</code> as far back as the dependency graph goes.
<code>shortcut = TRUE</code> increases speed if there are a lot of
up-to-date targets, but it assumes all the dependencies
are up to date, so please use with caution.
It relies on stored metadata for information about upstream dependencies.
<code>shortcut = TRUE</code> only works if you set <code>names</code>.</p>
</td></tr>
<tr><td><code id="tar_make_+3A_reporter">reporter</code></td>
<td>
<p>Character of length 1, name of the reporter to user.
Controls how messages are printed as targets run in the pipeline.
Defaults to <code>tar_config_get("reporter_make")</code>. Choices:
</p>

<ul>
<li> <p><code>"silent"</code>: print nothing.
</p>
</li>
<li> <p><code>"summary"</code>: print a running total of the number of each targets in
each status category (queued, dispatched, skipped, completed, canceled,
or errored). Also show a timestamp (<code>"%H:%M %OS2"</code> <code>strptime()</code> format)
of the last time the progress changed and printed to the screen.
</p>
</li>
<li> <p><code>"timestamp"</code>: same as the <code>"verbose"</code> reporter except that each
.message begins with a time stamp.
</p>
</li>
<li> <p><code>"timestamp_positives"</code>: same as the <code>"timestamp"</code> reporter
except without messages for skipped targets.
</p>
</li>
<li> <p><code>"verbose"</code>: print messages for individual targets
as they start, finish, or are skipped. Each individual
target-specific time (e.g. &quot;3.487 seconds&quot;) is strictly the
elapsed runtime of the target and does not include
steps like data retrieval and output storage.
</p>
</li>
<li> <p><code>"verbose_positives"</code>: same as the <code>"verbose"</code> reporter
except without messages for skipped targets.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_make_+3A_seconds_meta_append">seconds_meta_append</code></td>
<td>
<p>Positive numeric of length 1 with the minimum
number of seconds between saves to the local metadata and progress files
in the data store.
Higher values generally make the pipeline run faster, but unsaved
work (in the event of a crash) is not up to date.
When the pipeline ends,
all the metadata and progress data is saved immediately,
regardless of <code>seconds_meta_append</code>.</p>
</td></tr>
<tr><td><code id="tar_make_+3A_seconds_meta_upload">seconds_meta_upload</code></td>
<td>
<p>Positive numeric of length 1 with the minimum
number of seconds between uploads of the metadata and progress data
to the cloud
(see <a href="https://books.ropensci.org/targets/cloud-storage.html">https://books.ropensci.org/targets/cloud-storage.html</a>).
Higher values generally make the pipeline run faster, but unsaved
work (in the event of a crash) may not be backed up to the cloud.
When the pipeline ends,
all the metadata and progress data is uploaded immediately,
regardless of <code>seconds_meta_upload</code>.</p>
</td></tr>
<tr><td><code id="tar_make_+3A_seconds_reporter">seconds_reporter</code></td>
<td>
<p>Positive numeric of length 1 with the minimum
number of seconds between times when the reporter prints progress
messages to the R console.</p>
</td></tr>
<tr><td><code id="tar_make_+3A_seconds_interval">seconds_interval</code></td>
<td>
<p>Deprecated on 2023-08-24 (version 1.2.2.9001).
Use <code>seconds_meta_append</code>, <code>seconds_meta_upload</code>,
and <code>seconds_reporter</code> instead.</p>
</td></tr>
<tr><td><code id="tar_make_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_make_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
<tr><td><code id="tar_make_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_make_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_make_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
<tr><td><code id="tar_make_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical of length 1. For a <code>crew</code>-integrated
pipeline, whether to run garbage collection on the main process
before sending a target
to a worker. Ignored if <code>tar_option_get("controller")</code> is <code>NULL</code>.
Independent from the <code>garbage_collection</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code>,
which controls garbage collection on the worker.</p>
</td></tr>
<tr><td><code id="tar_make_+3A_use_crew">use_crew</code></td>
<td>
<p>Logical of length 1, whether to use <code>crew</code> if the
<code>controller</code> option is set in <code>tar_option_set()</code> in the target script
(<code style="white-space: pre;">&#8288;_targets.R&#8288;</code>). See <a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>
for details.</p>
</td></tr>
<tr><td><code id="tar_make_+3A_terminate_controller">terminate_controller</code></td>
<td>
<p>Logical of length 1. For a <code>crew</code>-integrated
pipeline, whether to terminate the controller after stopping
or finishing the pipeline. This should almost always be set to <code>TRUE</code>,
but <code>FALSE</code> combined with <code>callr_function = NULL</code>
will allow you to get the running controller using
<code>tar_option_get("controller")</code> for debugging purposes.
For example, <code>tar_option_get("controller")$summary()</code> produces a
worker-by-worker summary of the work assigned and completed,
<code>tar_option_get("controller")$queue</code> is the list of unresolved tasks,
and <code>tar_option_get("controller")$results</code> is the list of
tasks that completed but were not collected with <code>pop()</code>.
You can manually terminate the controller with
<code>tar_option_get("controller")$summary()</code> to close down the dispatcher
and worker processes.</p>
</td></tr>
<tr><td><code id="tar_make_+3A_as_job">as_job</code></td>
<td>
<p><code>TRUE</code> to run as an RStudio IDE / Posit Workbench job,
<code>FALSE</code> to run as a <code>callr</code> process in the main R session
(depending on the <code>callr_function</code> argument).
If <code>as_job</code> is <code>TRUE</code>, then the <code>rstudioapi</code> package must be installed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> except if <code>callr_function = callr::r_bg()</code>, in which case
a handle to the <code>callr</code> background process is returned. Either way,
the value is invisibly returned.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other pipeline: 
<code><a href="#topic+tar_make_clustermq">tar_make_clustermq</a>()</code>,
<code><a href="#topic+tar_make_future">tar_make_future</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(y1, 1 + 1),
    tar_target(y2, 1 + 1),
    tar_target(z, y1 + y2)
  )
}, ask = FALSE)
tar_make(starts_with("y")) # Only processes y1 and y2.
# Distributed computing with crew:
if (requireNamespace("crew", quietly = TRUE)) {
tar_script({
  tar_option_set(controller = crew::controller_local())
  list(
    tar_target(y1, 1 + 1),
    tar_target(y2, 1 + 1),
    tar_target(z, y1 + y2)
  )
}, ask = FALSE)
tar_make()
}
})
}
</code></pre>

<hr>
<h2 id='tar_make_clustermq'>Superseded. Run a pipeline with persistent <code>clustermq</code> workers.</h2><span id='topic+tar_make_clustermq'></span>

<h3>Description</h3>

<p>Superseded. Use <code><a href="#topic+tar_make">tar_make()</a></code> with <code>crew</code>:
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_make_clustermq(
  names = NULL,
  shortcut = targets::tar_config_get("shortcut"),
  reporter = targets::tar_config_get("reporter_make"),
  seconds_meta_append = targets::tar_config_get("seconds_meta_append"),
  seconds_meta_upload = targets::tar_config_get("seconds_meta_upload"),
  seconds_reporter = targets::tar_config_get("seconds_reporter"),
  seconds_interval = targets::tar_config_get("seconds_interval"),
  workers = targets::tar_config_get("workers"),
  log_worker = FALSE,
  callr_function = callr::r,
  callr_arguments = targets::tar_callr_args_default(callr_function, reporter),
  envir = parent.frame(),
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store"),
  garbage_collection = targets::tar_config_get("garbage_collection")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_make_clustermq_+3A_names">names</code></td>
<td>
<p>Names of the targets to run or check. Set to <code>NULL</code> to
check/run all the targets (default).
The object supplied to <code>names</code> should be a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_make_clustermq_+3A_shortcut">shortcut</code></td>
<td>
<p>Logical of length 1, how to interpret the <code>names</code> argument.
If <code>shortcut</code> is <code>FALSE</code> (default) then the function checks
all targets upstream of <code>names</code> as far back as the dependency graph goes.
<code>shortcut = TRUE</code> increases speed if there are a lot of
up-to-date targets, but it assumes all the dependencies
are up to date, so please use with caution.
It relies on stored metadata for information about upstream dependencies.
<code>shortcut = TRUE</code> only works if you set <code>names</code>.</p>
</td></tr>
<tr><td><code id="tar_make_clustermq_+3A_reporter">reporter</code></td>
<td>
<p>Character of length 1, name of the reporter to user.
Controls how messages are printed as targets run in the pipeline.
Defaults to <code>tar_config_get("reporter_make")</code>. Choices:
</p>

<ul>
<li> <p><code>"silent"</code>: print nothing.
</p>
</li>
<li> <p><code>"summary"</code>: print a running total of the number of each targets in
each status category (queued, dispatched, skipped, completed, canceled,
or errored). Also show a timestamp (<code>"%H:%M %OS2"</code> <code>strptime()</code> format)
of the last time the progress changed and printed to the screen.
</p>
</li>
<li> <p><code>"timestamp"</code>: same as the <code>"verbose"</code> reporter except that each
.message begins with a time stamp.
</p>
</li>
<li> <p><code>"timestamp_positives"</code>: same as the <code>"timestamp"</code> reporter
except without messages for skipped targets.
</p>
</li>
<li> <p><code>"verbose"</code>: print messages for individual targets
as they start, finish, or are skipped. Each individual
target-specific time (e.g. &quot;3.487 seconds&quot;) is strictly the
elapsed runtime of the target and does not include
steps like data retrieval and output storage.
</p>
</li>
<li> <p><code>"verbose_positives"</code>: same as the <code>"verbose"</code> reporter
except without messages for skipped targets.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_make_clustermq_+3A_seconds_meta_append">seconds_meta_append</code></td>
<td>
<p>Positive numeric of length 1 with the minimum
number of seconds between saves to the local metadata and progress files
in the data store.
Higher values generally make the pipeline run faster, but unsaved
work (in the event of a crash) is not up to date.
When the pipeline ends,
all the metadata and progress data is saved immediately,
regardless of <code>seconds_meta_append</code>.</p>
</td></tr>
<tr><td><code id="tar_make_clustermq_+3A_seconds_meta_upload">seconds_meta_upload</code></td>
<td>
<p>Positive numeric of length 1 with the minimum
number of seconds between uploads of the metadata and progress data
to the cloud
(see <a href="https://books.ropensci.org/targets/cloud-storage.html">https://books.ropensci.org/targets/cloud-storage.html</a>).
Higher values generally make the pipeline run faster, but unsaved
work (in the event of a crash) may not be backed up to the cloud.
When the pipeline ends,
all the metadata and progress data is uploaded immediately,
regardless of <code>seconds_meta_upload</code>.</p>
</td></tr>
<tr><td><code id="tar_make_clustermq_+3A_seconds_reporter">seconds_reporter</code></td>
<td>
<p>Positive numeric of length 1 with the minimum
number of seconds between times when the reporter prints progress
messages to the R console.</p>
</td></tr>
<tr><td><code id="tar_make_clustermq_+3A_seconds_interval">seconds_interval</code></td>
<td>
<p>Deprecated on 2023-08-24 (version 1.2.2.9001).
Use <code>seconds_meta_append</code>, <code>seconds_meta_upload</code>,
and <code>seconds_reporter</code> instead.</p>
</td></tr>
<tr><td><code id="tar_make_clustermq_+3A_workers">workers</code></td>
<td>
<p>Positive integer, number of persistent <code>clustermq</code> workers
to create.</p>
</td></tr>
<tr><td><code id="tar_make_clustermq_+3A_log_worker">log_worker</code></td>
<td>
<p>Logical, whether to write a log file for each worker.
Same as the <code>log_worker</code> argument of <code>clustermq::Q()</code>
and <code>clustermq::workers()</code>.</p>
</td></tr>
<tr><td><code id="tar_make_clustermq_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_make_clustermq_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
<tr><td><code id="tar_make_clustermq_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_make_clustermq_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_make_clustermq_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
<tr><td><code id="tar_make_clustermq_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical of length 1, whether to run garbage
collection on the main process before sending a target to a worker.
Independent from the <code>garbage_collection</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code>,
which controls garbage collection on the worker.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_make_clustermq()</code> is like <code><a href="#topic+tar_make">tar_make()</a></code> except that targets
run in parallel on persistent workers. A persistent worker is an
R process that runs for a long time and runs multiple
targets during its lifecycle. Persistent
workers launch as soon as the pipeline reaches an outdated
target with <code>deployment = "worker"</code>, and they keep running
until the pipeline starts to wind down.
</p>
<p>To configure <code>tar_make_clustermq()</code>, you must configure
the <code>clustermq</code> package. To do this, set global options
<code>clustermq.scheduler</code> and <code>clustermq.template</code>
inside the target script file (default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>).
To read more about configuring <code>clustermq</code> for your scheduler, visit
<a href="https://mschubert.github.io/clustermq/articles/userguide.html#configuration">https://mschubert.github.io/clustermq/articles/userguide.html#configuration</a> # nolint
or <a href="https://books.ropensci.org/targets/hpc.html">https://books.ropensci.org/targets/hpc.html</a>.
<code>clustermq</code> is not a strict dependency of <code>targets</code>,
so you must install <code>clustermq</code> yourself.
</p>


<h3>Value</h3>

<p><code>NULL</code> except if <code>callr_function = callr::r_bg()</code>, in which case
a handle to the <code>callr</code> background process is returned. Either way,
the value is invisibly returned.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other pipeline: 
<code><a href="#topic+tar_make">tar_make</a>()</code>,
<code><a href="#topic+tar_make_future">tar_make_future</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (!identical(tolower(Sys.info()[["sysname"]]), "windows")) {
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  options(clustermq.scheduler = "multiprocess") # Does not work on Windows.
  tar_option_set()
  list(tar_target(x, 1 + 1))
}, ask = FALSE)
tar_make_clustermq()
})
}
}
</code></pre>

<hr>
<h2 id='tar_make_future'>Superseded. Run a pipeline of targets in parallel with transient
<code>future</code> workers.</h2><span id='topic+tar_make_future'></span>

<h3>Description</h3>

<p>Superseded. Use <code><a href="#topic+tar_make">tar_make()</a></code> with <code>crew</code>:
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_make_future(
  names = NULL,
  shortcut = targets::tar_config_get("shortcut"),
  reporter = targets::tar_config_get("reporter_make"),
  seconds_meta_append = targets::tar_config_get("seconds_meta_append"),
  seconds_meta_upload = targets::tar_config_get("seconds_meta_upload"),
  seconds_reporter = targets::tar_config_get("seconds_reporter"),
  seconds_interval = targets::tar_config_get("seconds_interval"),
  workers = targets::tar_config_get("workers"),
  callr_function = callr::r,
  callr_arguments = targets::tar_callr_args_default(callr_function, reporter),
  envir = parent.frame(),
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store"),
  garbage_collection = targets::tar_config_get("garbage_collection")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_make_future_+3A_names">names</code></td>
<td>
<p>Names of the targets to run or check. Set to <code>NULL</code> to
check/run all the targets (default).
The object supplied to <code>names</code> should be a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_make_future_+3A_shortcut">shortcut</code></td>
<td>
<p>Logical of length 1, how to interpret the <code>names</code> argument.
If <code>shortcut</code> is <code>FALSE</code> (default) then the function checks
all targets upstream of <code>names</code> as far back as the dependency graph goes.
<code>shortcut = TRUE</code> increases speed if there are a lot of
up-to-date targets, but it assumes all the dependencies
are up to date, so please use with caution.
It relies on stored metadata for information about upstream dependencies.
<code>shortcut = TRUE</code> only works if you set <code>names</code>.</p>
</td></tr>
<tr><td><code id="tar_make_future_+3A_reporter">reporter</code></td>
<td>
<p>Character of length 1, name of the reporter to user.
Controls how messages are printed as targets run in the pipeline.
Defaults to <code>tar_config_get("reporter_make")</code>. Choices:
</p>

<ul>
<li> <p><code>"silent"</code>: print nothing.
</p>
</li>
<li> <p><code>"summary"</code>: print a running total of the number of each targets in
each status category (queued, dispatched, skipped, completed, canceled,
or errored). Also show a timestamp (<code>"%H:%M %OS2"</code> <code>strptime()</code> format)
of the last time the progress changed and printed to the screen.
</p>
</li>
<li> <p><code>"timestamp"</code>: same as the <code>"verbose"</code> reporter except that each
.message begins with a time stamp.
</p>
</li>
<li> <p><code>"timestamp_positives"</code>: same as the <code>"timestamp"</code> reporter
except without messages for skipped targets.
</p>
</li>
<li> <p><code>"verbose"</code>: print messages for individual targets
as they start, finish, or are skipped. Each individual
target-specific time (e.g. &quot;3.487 seconds&quot;) is strictly the
elapsed runtime of the target and does not include
steps like data retrieval and output storage.
</p>
</li>
<li> <p><code>"verbose_positives"</code>: same as the <code>"verbose"</code> reporter
except without messages for skipped targets.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_make_future_+3A_seconds_meta_append">seconds_meta_append</code></td>
<td>
<p>Positive numeric of length 1 with the minimum
number of seconds between saves to the local metadata and progress files
in the data store.
Higher values generally make the pipeline run faster, but unsaved
work (in the event of a crash) is not up to date.
When the pipeline ends,
all the metadata and progress data is saved immediately,
regardless of <code>seconds_meta_append</code>.</p>
</td></tr>
<tr><td><code id="tar_make_future_+3A_seconds_meta_upload">seconds_meta_upload</code></td>
<td>
<p>Positive numeric of length 1 with the minimum
number of seconds between uploads of the metadata and progress data
to the cloud
(see <a href="https://books.ropensci.org/targets/cloud-storage.html">https://books.ropensci.org/targets/cloud-storage.html</a>).
Higher values generally make the pipeline run faster, but unsaved
work (in the event of a crash) may not be backed up to the cloud.
When the pipeline ends,
all the metadata and progress data is uploaded immediately,
regardless of <code>seconds_meta_upload</code>.</p>
</td></tr>
<tr><td><code id="tar_make_future_+3A_seconds_reporter">seconds_reporter</code></td>
<td>
<p>Positive numeric of length 1 with the minimum
number of seconds between times when the reporter prints progress
messages to the R console.</p>
</td></tr>
<tr><td><code id="tar_make_future_+3A_seconds_interval">seconds_interval</code></td>
<td>
<p>Deprecated on 2023-08-24 (version 1.2.2.9001).
Use <code>seconds_meta_append</code>, <code>seconds_meta_upload</code>,
and <code>seconds_reporter</code> instead.</p>
</td></tr>
<tr><td><code id="tar_make_future_+3A_workers">workers</code></td>
<td>
<p>Positive integer, maximum number of transient
<code>future</code> workers allowed to run at any given time.</p>
</td></tr>
<tr><td><code id="tar_make_future_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_make_future_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
<tr><td><code id="tar_make_future_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_make_future_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_make_future_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
<tr><td><code id="tar_make_future_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical of length 1, whether to run garbage
collection on the main process before sending a target to a worker.
Independent from the <code>garbage_collection</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code>,
which controls garbage collection on the worker.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is like <code><a href="#topic+tar_make">tar_make()</a></code> except that targets
run in parallel with transient <code>future</code> workers. It requires
that you declare your <code>future::plan()</code> inside the
target script file (default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>).
<code>future</code> is not a strict dependency of <code>targets</code>,
so you must install <code>future</code> yourself.
</p>
<p>To configure <code>tar_make_future()</code> with a computing cluster,
see the <code>future.batchtools</code> package documentation.
</p>


<h3>Value</h3>

<p><code>NULL</code> except if <code>callr_function = callr::r_bg()</code>, in which case
a handle to the <code>callr</code> background process is returned. Either way,
the value is invisibly returned.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other pipeline: 
<code><a href="#topic+tar_make">tar_make</a>()</code>,
<code><a href="#topic+tar_make_clustermq">tar_make_clustermq</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  future::plan(future::multisession, workers = 2)
  list(
    tar_target(x, 1 + 1),
    tar_target(y, 1 + 1)
  )
}, ask = FALSE)
tar_make_future()
})
}
</code></pre>

<hr>
<h2 id='tar_make_interactive'>Interactive mode pipeline</h2><span id='topic+tar_make_interactive'></span>

<h3>Description</h3>

<p>Not a user-side function. Do not invoke directly.
Only exported to on a technicality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_make_interactive(code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_make_interactive_+3A_code">code</code></td>
<td>
<p>Character vector of lines of a <code style="white-space: pre;">&#8288;_targets.R&#8288;</code> file
to define a pipeline.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_INTERACTIVE_EXAMPLES"), "true")) {
tar_make_interactive("library(targets); tar_target(x, 123)")
message(x)
}
</code></pre>

<hr>
<h2 id='tar_manifest'>Produce a data frame of information about your targets.</h2><span id='topic+tar_manifest'></span>

<h3>Description</h3>

<p>Along with <code><a href="#topic+tar_visnetwork">tar_visnetwork()</a></code> and <code><a href="#topic+tar_glimpse">tar_glimpse()</a></code>,
<code>tar_manifest()</code> helps check that you constructed your pipeline correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_manifest(
  names = NULL,
  fields = tidyselect::any_of(c("name", "command", "pattern", "description")),
  drop_missing = TRUE,
  callr_function = callr::r,
  callr_arguments = targets::tar_callr_args_default(callr_function),
  envir = parent.frame(),
  script = targets::tar_config_get("script")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_manifest_+3A_names">names</code></td>
<td>
<p>Names of the targets to show. Set to <code>NULL</code> to
show all the targets (default). Otherwise,
the object supplied to <code>names</code> should be a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_manifest_+3A_fields">fields</code></td>
<td>
<p>Names of the fields, or columns, to show. Set to <code>NULL</code> to
show all the fields (default). Otherwise, the value of <code>fields</code> should be
a <code>tidyselect</code> expression like <code><a href="#topic+starts_with">starts_with()</a></code> to select the columns
to show in the output.
Possible fields are below. All of them can be set in <code><a href="#topic+tar_target">tar_target()</a></code>,
<code><a href="#topic+tar_target_raw">tar_target_raw()</a></code>, or <code><a href="#topic+tar_option_set">tar_option_set()</a></code>.
</p>

<ul>
<li> <p><code>name</code>: Name of the target.
</p>
</li>
<li> <p><code>command</code>: the R command that runs when the target runs.
</p>
</li>
<li> <p><code>description</code>: custom free-form text description of the target,
if available.
</p>
</li>
<li> <p><code>pattern</code>: branching pattern of the target, if applicable.
</p>
</li>
<li> <p><code>format</code>: Storage format.
</p>
</li>
<li> <p><code>repository</code>: Storage repository.
</p>
</li>
<li> <p><code>iteration</code>: Iteration mode for branching.
</p>
</li>
<li> <p><code>error</code>: Error mode, what to do when the target fails.
</p>
</li>
<li> <p><code>memory</code>: Memory mode, when to keep targets in memory.
</p>
</li>
<li> <p><code>storage</code>: Storage mode for high-performance computing scenarios.
</p>
</li>
<li> <p><code>retrieval</code>: Retrieval mode for high-performance computing scenarios.
</p>
</li>
<li> <p><code>deployment</code>: Where/whether to deploy the target in high-performance
computing scenarios.
</p>
</li>
<li> <p><code>priority</code>: Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched
earlier (and polled earlier in <code><a href="#topic+tar_make_future">tar_make_future()</a></code>).
</p>
</li>
<li> <p><code>resources</code>: A list of target-specific resource requirements for
<code><a href="#topic+tar_make_future">tar_make_future()</a></code>.
</p>
</li>
<li> <p><code>cue_mode</code>: Cue mode from <code><a href="#topic+tar_cue">tar_cue()</a></code>.
</p>
</li>
<li> <p><code>cue_depend</code>: Depend cue from <code><a href="#topic+tar_cue">tar_cue()</a></code>.
</p>
</li>
<li> <p><code>cue_expr</code>: Command cue from <code><a href="#topic+tar_cue">tar_cue()</a></code>.
</p>
</li>
<li> <p><code>cue_file</code>: File cue from <code><a href="#topic+tar_cue">tar_cue()</a></code>.
</p>
</li>
<li> <p><code>cue_format</code>: Format cue from <code><a href="#topic+tar_cue">tar_cue()</a></code>.
</p>
</li>
<li> <p><code>cue_repository</code>: Repository cue from <code><a href="#topic+tar_cue">tar_cue()</a></code>.
</p>
</li>
<li> <p><code>cue_iteration</code>: Iteration cue from <code><a href="#topic+tar_cue">tar_cue()</a></code>.
</p>
</li>
<li> <p><code>packages</code>: List columns of packages loaded before running the target.
</p>
</li>
<li> <p><code>library</code>: List column of library paths to load the packages.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_manifest_+3A_drop_missing">drop_missing</code></td>
<td>
<p>Logical of length 1, whether to automatically omit
empty columns and columns with all missing values.</p>
</td></tr>
<tr><td><code id="tar_manifest_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_manifest_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
<tr><td><code id="tar_manifest_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_manifest_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of information about the targets in the pipeline.
Rows appear in topological order (the order they will run
without any influence from parallel computing or priorities).
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other inspect: 
<code><a href="#topic+tar_deps">tar_deps</a>()</code>,
<code><a href="#topic+tar_deps_raw">tar_deps_raw</a>()</code>,
<code><a href="#topic+tar_network">tar_network</a>()</code>,
<code><a href="#topic+tar_outdated">tar_outdated</a>()</code>,
<code><a href="#topic+tar_sitrep">tar_sitrep</a>()</code>,
<code><a href="#topic+tar_validate">tar_validate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  tar_option_set()
  list(
    tar_target(y1, 1 + 1),
    tar_target(y2, 1 + 1),
    tar_target(z, y1 + y2),
    tar_target(m, z, pattern = map(z), description = "branching over z"),
    tar_target(c, z, pattern = cross(z))
  )
}, ask = FALSE)
tar_manifest()
tar_manifest(fields = any_of(c("name", "command")))
tar_manifest(fields = any_of("command"))
tar_manifest(fields = starts_with("cue"))
})
}
</code></pre>

<hr>
<h2 id='tar_mermaid'><code>mermaid.js</code> dependency graph.</h2><span id='topic+tar_mermaid'></span>

<h3>Description</h3>

<p>Visualize the dependency graph with a static <code>mermaid.js</code> graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_mermaid(
  targets_only = FALSE,
  names = NULL,
  shortcut = FALSE,
  allow = NULL,
  exclude = ".Random.seed",
  outdated = TRUE,
  label = targets::tar_config_get("label"),
  label_width = targets::tar_config_get("label_width"),
  legend = TRUE,
  color = TRUE,
  reporter = targets::tar_config_get("reporter_outdated"),
  seconds_reporter = targets::tar_config_get("seconds_reporter"),
  callr_function = callr::r,
  callr_arguments = targets::tar_callr_args_default(callr_function),
  envir = parent.frame(),
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_mermaid_+3A_targets_only">targets_only</code></td>
<td>
<p>Logical, whether to restrict the output to just targets
(<code>FALSE</code>) or to also include global functions and objects.</p>
</td></tr>
<tr><td><code id="tar_mermaid_+3A_names">names</code></td>
<td>
<p>Names of targets. The graph visualization will operate
only on these targets (and unless <code>shortcut</code> is <code>TRUE</code>,
all the targets upstream as well). Selecting a small subgraph
using <code>names</code> could speed up the load time of the visualization.
Unlike <code>allow</code>, <code>names</code> is invoked before the graph is generated.
Set to NULL to check/run all the targets (default).
Otherwise, the object supplied to <code>names</code> should be a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_mermaid_+3A_shortcut">shortcut</code></td>
<td>
<p>Logical of length 1, how to interpret the <code>names</code> argument.
If <code>shortcut</code> is <code>FALSE</code> (default) then the function checks
all targets upstream of <code>names</code> as far back as the dependency graph goes.
If <code>TRUE</code>, then the function only checks the targets in <code>names</code>
and uses stored metadata for information about upstream dependencies
as needed. <code>shortcut = TRUE</code> increases speed if there are a lot of
up-to-date targets, but it assumes all the dependencies
are up to date, so please use with caution.
Also, <code>shortcut = TRUE</code> only works if you set <code>names</code>.</p>
</td></tr>
<tr><td><code id="tar_mermaid_+3A_allow">allow</code></td>
<td>
<p>Optional, define the set of allowable vertices in the graph.
Unlike <code>names</code>, <code>allow</code> is invoked only after the graph is mostly
resolved, so it will not speed up execution.
Set to <code>NULL</code> to allow all vertices in the pipeline and environment
(default). Otherwise, you can supply symbols or
<code>tidyselect</code> helpers like <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_mermaid_+3A_exclude">exclude</code></td>
<td>
<p>Optional, define the set of exclude vertices from the graph.
Unlike <code>names</code>, <code>exclude</code> is invoked only after the graph is mostly
resolved, so it will not speed up execution.
Set to <code>NULL</code> to exclude no vertices.
Otherwise, you can supply symbols or <code>tidyselect</code>
helpers like <code><a href="#topic+any_of">any_of()</a></code> and <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_mermaid_+3A_outdated">outdated</code></td>
<td>
<p>Logical, whether to show colors to distinguish outdated
targets from up-to-date targets. (Global functions and objects
still show these colors.) Looking for outdated targets
takes a lot of time for large pipelines with lots of branches,
and setting <code>outdated</code> to <code>FALSE</code> is a nice way to speed up the graph
if you only want to see dependency relationships and pipeline progress.</p>
</td></tr>
<tr><td><code id="tar_mermaid_+3A_label">label</code></td>
<td>
<p>Character vector of one or more aesthetics to add to the
vertex labels. Can contain <code>"description"</code> to show each
target's custom description, <code>"time"</code> to show total runtime, <code>"size"</code>
to show total storage size, or <code>"branches"</code> to show the number of
branches in each pattern. You can choose multiple aesthetics
at once, e.g. <code>label = c("description", "time")</code>.
Only the description is enabled by default.</p>
</td></tr>
<tr><td><code id="tar_mermaid_+3A_label_width">label_width</code></td>
<td>
<p>Positive numeric of length 1, maximum width
(in number of characters) of the node labels.</p>
</td></tr>
<tr><td><code id="tar_mermaid_+3A_legend">legend</code></td>
<td>
<p>Logical of length 1, whether to display the legend.</p>
</td></tr>
<tr><td><code id="tar_mermaid_+3A_color">color</code></td>
<td>
<p>Logical of length 1, whether to color the graph vertices
by status.</p>
</td></tr>
<tr><td><code id="tar_mermaid_+3A_reporter">reporter</code></td>
<td>
<p>Character of length 1, name of the reporter to user.
Controls how messages are printed as targets are checked. Choices:
</p>

<ul>
<li> <p><code>"silent"</code>: print nothing.
</p>
</li>
<li> <p><code>"forecast"</code>: print running totals of the checked and outdated
targets found so far.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_mermaid_+3A_seconds_reporter">seconds_reporter</code></td>
<td>
<p>Positive numeric of length 1 with the minimum
number of seconds between times when the reporter prints progress
messages to the R console.</p>
</td></tr>
<tr><td><code id="tar_mermaid_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_mermaid_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
<tr><td><code id="tar_mermaid_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_mermaid_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_mermaid_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mermaid.js</code> is a JavaScript library for constructing
static visualizations of graphs.
</p>


<h3>Value</h3>

<p>A character vector of lines of code of the <code>mermaid.js</code> graph.
You can visualize the graph by copying the text
into a public online <code>mermaid.js</code> editor or a <code>mermaid</code> GitHub code chunk
(<code style="white-space: pre;">&#8288;https://github.blog/2022-02-14-include-diagrams-markdown-files-mermaid/&#8288;</code>).
Alternatively, you can render it inline in an R Markdown or Quarto
document using a <code>results = "asis"</code> code chunk like so:
</p>
<div class="sourceCode"><pre>  ```{r, results = "asis", echo = FALSE}
  cat(c("```{mermaid}", targets::tar_mermaid(), "```"), sep = "\n")
  ```
</pre></div>


<h3>Dependency graph</h3>

<p>The dependency graph of a pipeline is a directed acyclic graph (DAG)
where each node indicates a target or global object and each directed
edge indicates where a downstream node depends on an upstream node.
The DAG is not always a tree, but it never contains a cycle because
no target is allowed to directly or indirectly depend on itself.
The dependency graph should show a natural progression of work from
left to right. <code>targets</code> uses static code analysis to create the graph,
so the order of <code>tar_target()</code> calls in the <code style="white-space: pre;">&#8288;_targets.R&#8288;</code> file
does not matter. However, targets does not support self-referential
loops or other cycles. For more information on the dependency graph,
please read
<a href="https://books.ropensci.org/targets/targets.html#dependencies">https://books.ropensci.org/targets/targets.html#dependencies</a>.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other visualize: 
<code><a href="#topic+tar_glimpse">tar_glimpse</a>()</code>,
<code><a href="#topic+tar_visnetwork">tar_visnetwork</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_INTERACTIVE_EXAMPLES"), "true")) {
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  tar_option_set()
  list(
    tar_target(y1, 1 + 1),
    tar_target(y2, 1 + 1),
    tar_target(z, y1 + y2, description = "sum of two other sums")
  )
})
# Copy the text into a mermaid.js online editor
# or a mermaid GitHub code chunk:
tar_mermaid()
})
}
</code></pre>

<hr>
<h2 id='tar_meta'>Read a project's metadata.</h2><span id='topic+tar_meta'></span>

<h3>Description</h3>

<p>Read the metadata of all recorded targets and global objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_meta(
  names = NULL,
  fields = NULL,
  targets_only = FALSE,
  complete_only = FALSE,
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_meta_+3A_names">names</code></td>
<td>
<p>Optional, names of the targets. If supplied, <code>tar_meta()</code>
only returns metadata on these targets.
You can supply symbols
or <code>tidyselect</code> helpers like <code><a href="#topic+any_of">any_of()</a></code> and <code><a href="#topic+starts_with">starts_with()</a></code>.
If <code>NULL</code>, all names are selected.</p>
</td></tr>
<tr><td><code id="tar_meta_+3A_fields">fields</code></td>
<td>
<p>Optional, names of columns/fields to select. If supplied,
<code>tar_meta()</code> only returns the selected metadata columns.
If <code>NULL</code>, all fields are selected.
You can supply symbols or <code>tidyselect</code> helpers
like <code><a href="#topic+any_of">any_of()</a></code> and <code><a href="#topic+starts_with">starts_with()</a></code>.
The <code>name</code> column is always included first
no matter what you select. Choices:
</p>

<ul>
<li> <p><code>name</code>: name of the target or global object.
</p>
</li>
<li> <p><code>type</code>: type of the object: either <code>"function"</code> or <code>"object"</code>
for global objects, and <code>"stem"</code>, <code>"branch"</code>,
<code>"map"</code>, or <code>"cross"</code> for targets.
</p>
</li>
<li> <p><code>data</code>: hash of the output data.
</p>
</li>
<li> <p><code>command</code>: hash of the target's deparsed command.
</p>
</li>
<li> <p><code>depend</code>: hash of the immediate upstream dependencies of the target.
</p>
</li>
<li> <p><code>seed</code>: random number generator seed with which the target ran.
A target's random number generator seed
is a deterministic function of its name. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.
</p>
</li>
<li> <p><code>path</code>: A list column of paths to target data. Usually, each element
is a single path, but there could be multiple paths per target
for dynamic files (i.e. <code>tar_target(format = "file")</code>).
</p>
</li>
<li> <p><code>time</code>: <code>POSIXct</code> object with the time the target's data in storage
was last modified. If the target stores no local file,
then the time stamp corresponds to the time the target last
ran successfully. Only targets that run commands have time stamps:
just non-branching targets and individual dynamic branches.
Displayed in the current time zone of the system.
If there are multiple outputs for that target, as with file targets,
then the maximum time is shown.
</p>
</li>
<li> <p><code>size</code>: hash of the sum of all the bytes of the files at <code>path</code>.
</p>
</li>
<li> <p><code>bytes</code>: total file size in bytes of all files in <code>path</code>.
</p>
</li>
<li> <p><code>format</code>: character, one of the admissible data storage formats.
See the <code>format</code> argument in the <code><a href="#topic+tar_target">tar_target()</a></code> help file for details.
</p>
</li>
<li> <p><code>iteration</code>: character, either <code>"list"</code> or <code>"vector"</code>
to describe the iteration and aggregation mode of the target. See the
<code>iteration</code> argument in the <code><a href="#topic+tar_target">tar_target()</a></code> help file for details.
</p>
</li>
<li> <p><code>parent</code>: for branches, name of the parent pattern.
</p>
</li>
<li> <p><code>children</code>: list column, names of the children of targets that
have them. These include buds of stems and branches of patterns.
</p>
</li>
<li> <p><code>seconds</code>: number of seconds it took to run the target.
</p>
</li>
<li> <p><code>warnings</code>: character string of warning messages
from the last run of the target.
Only the first 50 warnings are available,
and only the first 2048 characters of the concatenated warning messages.
</p>
</li>
<li> <p><code>error</code>: character string of the error message if the target errored.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_meta_+3A_targets_only">targets_only</code></td>
<td>
<p>Logical, whether to just show information about targets
or also return metadata on functions and other global objects.</p>
</td></tr>
<tr><td><code id="tar_meta_+3A_complete_only">complete_only</code></td>
<td>
<p>Logical, whether to return only complete rows
(no <code>NA</code> values).</p>
</td></tr>
<tr><td><code id="tar_meta_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A metadata row only updates when the target completes.
<code><a href="#topic+tar_progress">tar_progress()</a></code> shows information on targets that are running.
That is why the number of branches may disagree between <code><a href="#topic+tar_meta">tar_meta()</a></code>
and <code><a href="#topic+tar_progress">tar_progress()</a></code> for actively running pipelines.
</p>


<h3>Value</h3>

<p>A data frame with one row per target/object and the selected fields.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>Cloud metadata</h3>

<p>Metadata files help <code>targets</code>
read data objects and decide if the pipeline is up to date.
Usually, these metadata files live in files in the local
<code style="white-space: pre;">&#8288;_targets/meta/&#8288;</code> folder in your project, e.g. <code style="white-space: pre;">&#8288;_targets/meta/meta&#8288;</code>.
But in addition, if you set <code>repository</code> to anything other than
<code>"local"</code> in <code><a href="#topic+tar_option_set">tar_option_set()</a></code> in <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>, then <code><a href="#topic+tar_make">tar_make()</a></code>
continuously uploads the metadata files to the bucket you specify
in <code>resources</code>. <code><a href="#topic+tar_meta_delete">tar_meta_delete()</a></code> will delete those files from the
cloud, and so will <code><a href="#topic+tar_destroy">tar_destroy()</a></code> if <code>destroy</code> is
set to either <code>"all"</code> or <code>"cloud"</code>.
</p>
<p>Other functions in <code>targets</code>, such as <code><a href="#topic+tar_meta">tar_meta()</a></code>,
<code><a href="#topic+tar_visnetwork">tar_visnetwork()</a></code>, <code><a href="#topic+tar_outdated">tar_outdated()</a></code>, and <code><a href="#topic+tar_invalidate">tar_invalidate()</a></code>,
use the local metadata only and ignore the copies on the cloud.
So if you are working on a different computer than the
one running the pipeline, you will need to download the cloud metadata
to your current machine using <code><a href="#topic+tar_meta_download">tar_meta_download()</a></code>. Other functions
<code><a href="#topic+tar_meta_upload">tar_meta_upload()</a></code>, <code><a href="#topic+tar_meta_sync">tar_meta_sync()</a></code>, and <code><a href="#topic+tar_meta_delete">tar_meta_delete()</a></code>
also manage metadata across the cloud and the local file system.
</p>
<p>Remarks:
</p>

<ul>
<li><p> The <code>repository_meta</code> option in <code><a href="#topic+tar_option_set">tar_option_set()</a></code> is actually
what controls where the metadata lives in the cloud, but it defaults
to <code>repository</code>.
</p>
</li>
<li><p> Like <code><a href="#topic+tar_make">tar_make()</a></code>, <code><a href="#topic+tar_make_future">tar_make_future()</a></code> and <code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code>
also continuously upload metadata files to the cloud bucket
specified in <code>resources</code>.
</p>
</li>
<li> <p><code><a href="#topic+tar_meta_download">tar_meta_download()</a></code> and related functions need to run <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>
to detect <code><a href="#topic+tar_option_set">tar_option_set()</a></code> options <code>repository_meta</code> and <code>resources</code>,
so please be aware of side effects that may happen running your
custom <code style="white-space: pre;">&#8288;_targets.R&#8288;</code> file.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other metadata: 
<code><a href="#topic+tar_meta_delete">tar_meta_delete</a>()</code>,
<code><a href="#topic+tar_meta_download">tar_meta_download</a>()</code>,
<code><a href="#topic+tar_meta_sync">tar_meta_sync</a>()</code>,
<code><a href="#topic+tar_meta_upload">tar_meta_upload</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(2)),
    tar_target(y, 2 * x, pattern = map(x))
  )
}, ask = FALSE)
tar_make()
tar_meta()
tar_meta(starts_with("y_")) # see also any_of()
})
}
</code></pre>

<hr>
<h2 id='tar_meta_delete'>Delete metadata.</h2><span id='topic+tar_meta_delete'></span>

<h3>Description</h3>

<p>Delete the project metadata files from the local file system,
the cloud, or both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_meta_delete(
  meta = TRUE,
  progress = TRUE,
  process = TRUE,
  crew = TRUE,
  verbose = TRUE,
  delete = "all",
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_meta_delete_+3A_meta">meta</code></td>
<td>
<p>Logical of length 1, whether to process the main metadata file
at <code style="white-space: pre;">&#8288;_targets/meta/meta&#8288;</code>.</p>
</td></tr>
<tr><td><code id="tar_meta_delete_+3A_progress">progress</code></td>
<td>
<p>Logical of length 1, whether to process the progress file at
<code style="white-space: pre;">&#8288;_targets/meta/progress&#8288;</code>.</p>
</td></tr>
<tr><td><code id="tar_meta_delete_+3A_process">process</code></td>
<td>
<p>Logical of length 1, whether to process the process file at
<code style="white-space: pre;">&#8288;_targets/meta/process&#8288;</code>.</p>
</td></tr>
<tr><td><code id="tar_meta_delete_+3A_crew">crew</code></td>
<td>
<p>Logical of length 1, whether to process the <code>crew</code> file at
<code style="white-space: pre;">&#8288;_targets/meta/crew&#8288;</code>. Only exists if running <code>targets</code> with <code>crew</code>.</p>
</td></tr>
<tr><td><code id="tar_meta_delete_+3A_verbose">verbose</code></td>
<td>
<p>Logical of length 1, whether to print informative
console messages.</p>
</td></tr>
<tr><td><code id="tar_meta_delete_+3A_delete">delete</code></td>
<td>
<p>Character of length 1, which location to delete the files.
Choose <code>"local"</code> for local files, <code>"cloud"</code> for files on the cloud,
or <code>"all"</code> to delete metadata files from both the local file system
and the cloud.</p>
</td></tr>
<tr><td><code id="tar_meta_delete_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_meta_delete_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metadata: 
<code><a href="#topic+tar_meta">tar_meta</a>()</code>,
<code><a href="#topic+tar_meta_download">tar_meta_download</a>()</code>,
<code><a href="#topic+tar_meta_sync">tar_meta_sync</a>()</code>,
<code><a href="#topic+tar_meta_upload">tar_meta_upload</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
}, ask = FALSE)
tar_make()
tar_meta_delete()
})
}
</code></pre>

<hr>
<h2 id='tar_meta_download'>download local metadata to the cloud.</h2><span id='topic+tar_meta_download'></span>

<h3>Description</h3>

<p>download local metadata files to the cloud location
(repository, bucket, and prefix) you set in
<code><a href="#topic+tar_option_set">tar_option_set()</a></code> in <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_meta_download(
  meta = TRUE,
  progress = TRUE,
  process = TRUE,
  crew = TRUE,
  verbose = TRUE,
  strict = FALSE,
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_meta_download_+3A_meta">meta</code></td>
<td>
<p>Logical of length 1, whether to process the main metadata file
at <code style="white-space: pre;">&#8288;_targets/meta/meta&#8288;</code>.</p>
</td></tr>
<tr><td><code id="tar_meta_download_+3A_progress">progress</code></td>
<td>
<p>Logical of length 1, whether to process the progress file at
<code style="white-space: pre;">&#8288;_targets/meta/progress&#8288;</code>.</p>
</td></tr>
<tr><td><code id="tar_meta_download_+3A_process">process</code></td>
<td>
<p>Logical of length 1, whether to process the process file at
<code style="white-space: pre;">&#8288;_targets/meta/process&#8288;</code>.</p>
</td></tr>
<tr><td><code id="tar_meta_download_+3A_crew">crew</code></td>
<td>
<p>Logical of length 1, whether to process the <code>crew</code> file at
<code style="white-space: pre;">&#8288;_targets/meta/crew&#8288;</code>. Only exists if running <code>targets</code> with <code>crew</code>.</p>
</td></tr>
<tr><td><code id="tar_meta_download_+3A_verbose">verbose</code></td>
<td>
<p>Logical of length 1, whether to print informative
console messages.</p>
</td></tr>
<tr><td><code id="tar_meta_download_+3A_strict">strict</code></td>
<td>
<p>Logical of length 1. <code>TRUE</code> to error out if the file
does not exist in the bucket, <code>FALSE</code> to proceed without an error or
warning. If <code>strict</code> is <code>FALSE</code> and <code>verbose</code> is <code>TRUE</code>,
then an informative message will print to the R console.</p>
</td></tr>
<tr><td><code id="tar_meta_download_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_meta_download_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metadata: 
<code><a href="#topic+tar_meta">tar_meta</a>()</code>,
<code><a href="#topic+tar_meta_delete">tar_meta_delete</a>()</code>,
<code><a href="#topic+tar_meta_sync">tar_meta_sync</a>()</code>,
<code><a href="#topic+tar_meta_upload">tar_meta_upload</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
}, ask = FALSE)
tar_make()
tar_meta_download()
})
}
</code></pre>

<hr>
<h2 id='tar_meta_sync'>Synchronize cloud metadata.</h2><span id='topic+tar_meta_sync'></span>

<h3>Description</h3>

<p>Synchronize metadata in a cloud bucket with metadata in the
local data store.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_meta_sync(
  meta = TRUE,
  progress = TRUE,
  process = TRUE,
  crew = TRUE,
  verbose = TRUE,
  prefer_local = TRUE,
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_meta_sync_+3A_meta">meta</code></td>
<td>
<p>Logical of length 1, whether to process the main metadata file
at <code style="white-space: pre;">&#8288;_targets/meta/meta&#8288;</code>.</p>
</td></tr>
<tr><td><code id="tar_meta_sync_+3A_progress">progress</code></td>
<td>
<p>Logical of length 1, whether to process the progress file at
<code style="white-space: pre;">&#8288;_targets/meta/progress&#8288;</code>.</p>
</td></tr>
<tr><td><code id="tar_meta_sync_+3A_process">process</code></td>
<td>
<p>Logical of length 1, whether to process the process file at
<code style="white-space: pre;">&#8288;_targets/meta/process&#8288;</code>.</p>
</td></tr>
<tr><td><code id="tar_meta_sync_+3A_crew">crew</code></td>
<td>
<p>Logical of length 1, whether to process the <code>crew</code> file at
<code style="white-space: pre;">&#8288;_targets/meta/crew&#8288;</code>. Only exists if running <code>targets</code> with <code>crew</code>.</p>
</td></tr>
<tr><td><code id="tar_meta_sync_+3A_verbose">verbose</code></td>
<td>
<p>Logical of length 1, whether to print informative
console messages.</p>
</td></tr>
<tr><td><code id="tar_meta_sync_+3A_prefer_local">prefer_local</code></td>
<td>
<p>Logical of length 1 to control which copy of each
metadata file takes precedence if the local hash and cloud hash
are different but the time stamps are the same. Set to <code>TRUE</code>
to upload the local data file in that scenario, <code>FALSE</code> to download
the cloud file.</p>
</td></tr>
<tr><td><code id="tar_meta_sync_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_meta_sync_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+tar_meta_sync">tar_meta_sync()</a></code> synchronizes the local and cloud copies
of all the metadata files of the pipeline so that both have the
most recent copy. For each metadata file,
if the local file does not exist or is older than the cloud file,
then the cloud file is downloaded to the local file path.
Conversely, if the cloud file is older or does not exist, then the local
file is uploaded to the cloud. If the time stamps of these files are
equal, use the <code>prefer_local</code> argument to determine
which copy takes precedence.
</p>


<h3>See Also</h3>

<p>Other metadata: 
<code><a href="#topic+tar_meta">tar_meta</a>()</code>,
<code><a href="#topic+tar_meta_delete">tar_meta_delete</a>()</code>,
<code><a href="#topic+tar_meta_download">tar_meta_download</a>()</code>,
<code><a href="#topic+tar_meta_upload">tar_meta_upload</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
}, ask = FALSE)
tar_make()
tar_meta_sync()
})
}
</code></pre>

<hr>
<h2 id='tar_meta_upload'>Upload local metadata to the cloud.</h2><span id='topic+tar_meta_upload'></span>

<h3>Description</h3>

<p>Upload local metadata files to the cloud location
(repository, bucket, and prefix) you set in
<code><a href="#topic+tar_option_set">tar_option_set()</a></code> in <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_meta_upload(
  meta = TRUE,
  progress = TRUE,
  process = TRUE,
  crew = TRUE,
  verbose = TRUE,
  strict = FALSE,
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_meta_upload_+3A_meta">meta</code></td>
<td>
<p>Logical of length 1, whether to process the main metadata file
at <code style="white-space: pre;">&#8288;_targets/meta/meta&#8288;</code>.</p>
</td></tr>
<tr><td><code id="tar_meta_upload_+3A_progress">progress</code></td>
<td>
<p>Logical of length 1, whether to process the progress file at
<code style="white-space: pre;">&#8288;_targets/meta/progress&#8288;</code>.</p>
</td></tr>
<tr><td><code id="tar_meta_upload_+3A_process">process</code></td>
<td>
<p>Logical of length 1, whether to process the process file at
<code style="white-space: pre;">&#8288;_targets/meta/process&#8288;</code>.</p>
</td></tr>
<tr><td><code id="tar_meta_upload_+3A_crew">crew</code></td>
<td>
<p>Logical of length 1, whether to process the <code>crew</code> file at
<code style="white-space: pre;">&#8288;_targets/meta/crew&#8288;</code>. Only exists if running <code>targets</code> with <code>crew</code>.</p>
</td></tr>
<tr><td><code id="tar_meta_upload_+3A_verbose">verbose</code></td>
<td>
<p>Logical of length 1, whether to print informative
console messages.</p>
</td></tr>
<tr><td><code id="tar_meta_upload_+3A_strict">strict</code></td>
<td>
<p>Logical of length 1. <code>TRUE</code> to error out if the file
does not exist locally, <code>FALSE</code> to proceed without an error or
warning. If <code>strict</code> is <code>FALSE</code> and <code>verbose</code> is <code>TRUE</code>,
then an informative message will print to the R console.</p>
</td></tr>
<tr><td><code id="tar_meta_upload_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_meta_upload_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other metadata: 
<code><a href="#topic+tar_meta">tar_meta</a>()</code>,
<code><a href="#topic+tar_meta_delete">tar_meta_delete</a>()</code>,
<code><a href="#topic+tar_meta_download">tar_meta_download</a>()</code>,
<code><a href="#topic+tar_meta_sync">tar_meta_sync</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
}, ask = FALSE)
tar_make()
tar_meta_upload()
})
}
</code></pre>

<hr>
<h2 id='tar_name'>Get the name of the target currently running.</h2><span id='topic+tar_name'></span>

<h3>Description</h3>

<p>Get the name of the target currently running.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_name(default = "target")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_name_+3A_default">default</code></td>
<td>
<p>Character, value to return if <code>tar_name()</code>
is called on its own outside a <code>targets</code> pipeline.
Having a default lets users run things without <code><a href="#topic+tar_make">tar_make()</a></code>,
which helps peel back layers of code and troubleshoot bugs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character of length 1. If called inside a pipeline,
<code>tar_name()</code> returns name of the target currently running.
Otherwise, the return value is <code>default</code>.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+tar_active">tar_active</a>()</code>,
<code><a href="#topic+tar_backoff">tar_backoff</a>()</code>,
<code><a href="#topic+tar_call">tar_call</a>()</code>,
<code><a href="#topic+tar_cancel">tar_cancel</a>()</code>,
<code><a href="#topic+tar_definition">tar_definition</a>()</code>,
<code><a href="#topic+tar_described_as">tar_described_as</a>()</code>,
<code><a href="#topic+tar_envir">tar_envir</a>()</code>,
<code><a href="#topic+tar_group">tar_group</a>()</code>,
<code><a href="#topic+tar_path">tar_path</a>()</code>,
<code><a href="#topic+tar_path_script">tar_path_script</a>()</code>,
<code><a href="#topic+tar_path_script_support">tar_path_script_support</a>()</code>,
<code><a href="#topic+tar_path_store">tar_path_store</a>()</code>,
<code><a href="#topic+tar_path_target">tar_path_target</a>()</code>,
<code><a href="#topic+tar_source">tar_source</a>()</code>,
<code><a href="#topic+tar_store">tar_store</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_name()
tar_name(default = "custom_target_name")
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(tar_target(x, tar_name()), ask = FALSE)
tar_make()
tar_read(x)
})
}
</code></pre>

<hr>
<h2 id='tar_network'>Return the vertices and edges of a pipeline dependency graph.</h2><span id='topic+tar_network'></span>

<h3>Description</h3>

<p>Analyze the pipeline defined in the target script file
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>)
and return the vertices and edges of the directed acyclic graph
of dependency relationships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_network(
  targets_only = FALSE,
  names = NULL,
  shortcut = FALSE,
  allow = NULL,
  exclude = NULL,
  outdated = TRUE,
  reporter = targets::tar_config_get("reporter_outdated"),
  seconds_reporter = targets::tar_config_get("seconds_reporter"),
  callr_function = callr::r,
  callr_arguments = targets::tar_callr_args_default(callr_function, reporter),
  envir = parent.frame(),
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_network_+3A_targets_only">targets_only</code></td>
<td>
<p>Logical, whether to restrict the output to just targets
(<code>FALSE</code>) or to also include imported global functions and objects.</p>
</td></tr>
<tr><td><code id="tar_network_+3A_names">names</code></td>
<td>
<p>Names of targets. The graph visualization will operate
only on these targets (and unless <code>shortcut</code> is <code>TRUE</code>,
all the targets upstream as well). Selecting a small subgraph
using <code>names</code> could speed up the load time of the visualization.
Unlike <code>allow</code>, <code>names</code> is invoked before the graph is generated.
Set to NULL to check/run all the targets (default).
Otherwise, the object supplied to <code>names</code> should be a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_network_+3A_shortcut">shortcut</code></td>
<td>
<p>Logical of length 1, how to interpret the <code>names</code> argument.
If <code>shortcut</code> is <code>FALSE</code> (default) then the function checks
all targets upstream of <code>names</code> as far back as the dependency graph goes.
If <code>TRUE</code>, then the function only checks the targets in <code>names</code>
and uses stored metadata for information about upstream dependencies
as needed. <code>shortcut = TRUE</code> increases speed if there are a lot of
up-to-date targets, but it assumes all the dependencies
are up to date, so please use with caution.
Also, <code>shortcut = TRUE</code> only works if you set <code>names</code>.</p>
</td></tr>
<tr><td><code id="tar_network_+3A_allow">allow</code></td>
<td>
<p>Optional, define the set of allowable vertices in the graph.
Unlike <code>names</code>, <code>allow</code> is invoked only after the graph is mostly
resolved, so it will not speed up execution.
Set to <code>NULL</code> to allow all vertices in the pipeline and environment
(default). Otherwise, you can supply symbols or
<code>tidyselect</code> helpers like <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_network_+3A_exclude">exclude</code></td>
<td>
<p>Optional, define the set of exclude vertices from the graph.
Unlike <code>names</code>, <code>exclude</code> is invoked only after the graph is mostly
resolved, so it will not speed up execution.
Set to <code>NULL</code> to exclude no vertices.
Otherwise, you can supply symbols or <code>tidyselect</code>
helpers like <code><a href="#topic+any_of">any_of()</a></code> and <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_network_+3A_outdated">outdated</code></td>
<td>
<p>Logical, whether to show colors to distinguish outdated
targets from up-to-date targets. (Global functions and objects
still show these colors.) Looking for outdated targets
takes a lot of time for large pipelines with lots of branches,
and setting <code>outdated</code> to <code>FALSE</code> is a nice way to speed up the graph
if you only want to see dependency relationships and pipeline progress.</p>
</td></tr>
<tr><td><code id="tar_network_+3A_reporter">reporter</code></td>
<td>
<p>Character of length 1, name of the reporter to user.
Controls how messages are printed as targets are checked. Choices:
</p>

<ul>
<li> <p><code>"silent"</code>: print nothing.
</p>
</li>
<li> <p><code>"forecast"</code>: print running totals of the checked and outdated
targets found so far.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_network_+3A_seconds_reporter">seconds_reporter</code></td>
<td>
<p>Positive numeric of length 1 with the minimum
number of seconds between times when the reporter prints progress
messages to the R console.</p>
</td></tr>
<tr><td><code id="tar_network_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_network_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
<tr><td><code id="tar_network_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_network_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_network_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two data frames: <code>vertices</code> and <code>edges</code>. The
vertices data frame has one row per target and columns with the
the type of the target or object (stem, branch, map, cross, function,
or object), each target's description, and each target's status
(up to date, outdated, dispatched, completed, canceled, or errored),
as well as metadata if available (seconds of runtime, bytes of
storage, and number of dynamic branches).
The edges data frame has one row for every edge and columns <code>to</code> and
<code>from</code> to mark the starting and terminating vertices.
</p>


<h3>Dependency graph</h3>

<p>The dependency graph of a pipeline is a directed acyclic graph (DAG)
where each node indicates a target or global object and each directed
edge indicates where a downstream node depends on an upstream node.
The DAG is not always a tree, but it never contains a cycle because
no target is allowed to directly or indirectly depend on itself.
The dependency graph should show a natural progression of work from
left to right. <code>targets</code> uses static code analysis to create the graph,
so the order of <code>tar_target()</code> calls in the <code style="white-space: pre;">&#8288;_targets.R&#8288;</code> file
does not matter. However, targets does not support self-referential
loops or other cycles. For more information on the dependency graph,
please read
<a href="https://books.ropensci.org/targets/targets.html#dependencies">https://books.ropensci.org/targets/targets.html#dependencies</a>.
</p>


<h3>See Also</h3>

<p>Other inspect: 
<code><a href="#topic+tar_deps">tar_deps</a>()</code>,
<code><a href="#topic+tar_deps_raw">tar_deps_raw</a>()</code>,
<code><a href="#topic+tar_manifest">tar_manifest</a>()</code>,
<code><a href="#topic+tar_outdated">tar_outdated</a>()</code>,
<code><a href="#topic+tar_sitrep">tar_sitrep</a>()</code>,
<code><a href="#topic+tar_validate">tar_validate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  tar_option_set()
  list(
    tar_target(y1, 1 + 1),
    tar_target(y2, 1 + 1, description = "y2 info"),
    tar_target(z, y1 + y2, description = "z info")
  )
}, ask = FALSE)
tar_network(targets_only = TRUE)
})
}
</code></pre>

<hr>
<h2 id='tar_newer'>List new targets</h2><span id='topic+tar_newer'></span>

<h3>Description</h3>

<p>List all the targets whose last successful run occurred
after a certain point in time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_newer(
  time,
  names = NULL,
  inclusive = FALSE,
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_newer_+3A_time">time</code></td>
<td>
<p>A <code>POSIXct</code> object of length 1, time threshold.
Targets newer than this time stamp are returned.
For example, if <code>time = Sys.time - as.difftime(1, units = "weeks")</code>
then <code>tar_newer()</code> returns targets newer than one week ago.</p>
</td></tr>
<tr><td><code id="tar_newer_+3A_names">names</code></td>
<td>
<p>Names of eligible targets. Targets excluded from <code>names</code>
will not be returned even if they are newer than the given <code>time</code>.
The object supplied to <code>names</code> should be <code>NULL</code> or a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_newer_+3A_inclusive">inclusive</code></td>
<td>
<p>Logical of length 1, whether to include targets
completed at exactly the <code>time</code> given.</p>
</td></tr>
<tr><td><code id="tar_newer_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only applies to targets with recorded time stamps:
just non-branching targets and individual dynamic branches.
As of <code>targets</code> version 0.6.0, these time
stamps are available for these targets regardless of
storage format. Earlier versions of <code>targets</code> do not record
time stamps for remote storage such as <code>format = "url"</code>
or <code>repository = "aws"</code> in <code><a href="#topic+tar_target">tar_target()</a></code>.
</p>


<h3>Value</h3>

<p>A character vector of names of old targets with recorded
timestamp metadata.
</p>


<h3>See Also</h3>

<p>Other time: 
<code><a href="#topic+tar_older">tar_older</a>()</code>,
<code><a href="#topic+tar_timestamp">tar_timestamp</a>()</code>,
<code><a href="#topic+tar_timestamp_raw">tar_timestamp_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(tar_target(x, seq_len(2)))
}, ask = FALSE)
tar_make()
# targets newer than 1 week ago
tar_newer(Sys.time() - as.difftime(1, units = "weeks"))
# targets newer than 1 week from now
tar_newer(Sys.time() + as.difftime(1, units = "weeks"))
# Everything is still up to date.
tar_make()
# Invalidate all targets targets newer than 1 week ago
# so they run on the next tar_make().
invalidate_these &lt;- tar_newer(Sys.time() - as.difftime(1, units = "weeks"))
tar_invalidate(any_of(invalidate_these))
tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_noninteractive'>Run if Target Markdown interactive mode is not on.</h2><span id='topic+tar_noninteractive'></span>

<h3>Description</h3>

<p>In Target Markdown, run the enclosed code
only if interactive mode is not activated. Otherwise,
do not run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_noninteractive(code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_noninteractive_+3A_code">code</code></td>
<td>
<p>R code to run if Target Markdown interactive mode
is not turned on.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Visit &lt;books.ropensci.org/targets/literate-programming.html&gt;
to learn about Target Markdown and interactive mode.
</p>


<h3>Value</h3>

<p>If Target Markdown interactive mode is not turned on,
the function returns the result of running the code.
Otherwise, the function invisibly returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p>Other Target Markdown: 
<code><a href="#topic+tar_engine_knitr">tar_engine_knitr</a>()</code>,
<code><a href="#topic+tar_interactive">tar_interactive</a>()</code>,
<code><a href="#topic+tar_toggle">tar_toggle</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_noninteractive(message("Not in interactive mode."))
</code></pre>

<hr>
<h2 id='tar_objects'>List saved targets</h2><span id='topic+tar_objects'></span>

<h3>Description</h3>

<p>List targets currently saved to <code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code>
or the cloud. Does not include local files
with <code>tar_target(..., format = "file", repository = "local")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_objects(
  names = NULL,
  cloud = TRUE,
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_objects_+3A_names">names</code></td>
<td>
<p>Names of targets to select.
The object supplied to <code>names</code> should be <code>NULL</code> or a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_objects_+3A_cloud">cloud</code></td>
<td>
<p>Logical of length 1, whether to include
cloud targets in the output
(e.g. <code>tar_target(..., repository = "aws")</code>).</p>
</td></tr>
<tr><td><code id="tar_objects_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of targets saved to <code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code>.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+tar_crew">tar_crew</a>()</code>,
<code><a href="#topic+tar_load">tar_load</a>()</code>,
<code><a href="#topic+tar_load_everything">tar_load_everything</a>()</code>,
<code><a href="#topic+tar_load_raw">tar_load_raw</a>()</code>,
<code><a href="#topic+tar_pid">tar_pid</a>()</code>,
<code><a href="#topic+tar_process">tar_process</a>()</code>,
<code><a href="#topic+tar_read">tar_read</a>()</code>,
<code><a href="#topic+tar_read_raw">tar_read_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(tar_target(x, "value"))
}, ask = FALSE)
tar_make()
tar_objects()
tar_objects(starts_with("x")) # see also any_of()
})
}
</code></pre>

<hr>
<h2 id='tar_older'>List old targets</h2><span id='topic+tar_older'></span>

<h3>Description</h3>

<p>List all the targets whose last successful run occurred
before a certain point in time. Combine with <code><a href="#topic+tar_invalidate">tar_invalidate()</a></code>,
you can use <code>tar_older()</code> to automatically rerun targets at
regular intervals. See the examples for a demonstration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_older(
  time,
  names = NULL,
  inclusive = FALSE,
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_older_+3A_time">time</code></td>
<td>
<p>A <code>POSIXct</code> object of length 1, time threshold.
Targets older than this time stamp are returned.
For example, if <code>time = Sys.time() - as.difftime(1, units = "weeks")</code>
then <code>tar_older()</code> returns targets older than one week ago.</p>
</td></tr>
<tr><td><code id="tar_older_+3A_names">names</code></td>
<td>
<p>Names of eligible targets. Targets excluded from <code>names</code>
will not be returned even if they are old.
The object supplied to <code>names</code> should be <code>NULL</code> or a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_older_+3A_inclusive">inclusive</code></td>
<td>
<p>Logical of length 1, whether to include targets
completed at exactly the <code>time</code> given.</p>
</td></tr>
<tr><td><code id="tar_older_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only applies to targets with recorded time stamps:
just non-branching targets and individual dynamic branches.
As of <code>targets</code> version 0.6.0, these time
stamps are available for these targets regardless of
storage format. Earlier versions of <code>targets</code> do not record
time stamps for remote storage such as <code>format = "url"</code>
or <code>repository = "aws"</code> in <code><a href="#topic+tar_target">tar_target()</a></code>.
</p>


<h3>Value</h3>

<p>A character vector of names of old targets with recorded
timestamp metadata.
</p>


<h3>See Also</h3>

<p>Other time: 
<code><a href="#topic+tar_newer">tar_newer</a>()</code>,
<code><a href="#topic+tar_timestamp">tar_timestamp</a>()</code>,
<code><a href="#topic+tar_timestamp_raw">tar_timestamp_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(tar_target(x, seq_len(2)))
}, ask = FALSE)
tar_make()
# targets older than 1 week ago
tar_older(Sys.time() - as.difftime(1, units = "weeks"))
# targets older than 1 week from now
tar_older(Sys.time() + as.difftime(1, units = "weeks"))
# Everything is still up to date.
tar_make()
# Invalidate all targets targets older than 1 week from now
# so they run on the next tar_make().
invalidate_these &lt;- tar_older(Sys.time() + as.difftime(1, units = "weeks"))
tar_invalidate(any_of(invalidate_these))
tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_option_export'>Export options.</h2><span id='topic+tar_option_export'></span>

<h3>Description</h3>

<p>Internal function. Not for users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_option_export()
</code></pre>


<h3>Value</h3>

<p>A list of options from tar_option_set().
</p>

<hr>
<h2 id='tar_option_get'>Get a target option.</h2><span id='topic+tar_option_get'></span>

<h3>Description</h3>

<p>Get a target option. These options include default arguments to
<code><a href="#topic+tar_target">tar_target()</a></code> such as packages, storage format,
iteration type, and cue.
Needs to be called before any calls to <code><a href="#topic+tar_target">tar_target()</a></code>
in order to take effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_option_get(name = NULL, option = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_option_get_+3A_name">name</code></td>
<td>
<p>Character of length 1, name of an option to get.
Must be one of the argument names of <code><a href="#topic+tar_option_set">tar_option_set()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_option_get_+3A_option">option</code></td>
<td>
<p>Deprecated, use the <code>name</code> argument instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function goes well with <code><a href="#topic+tar_target_raw">tar_target_raw()</a></code> when it comes
to defining external interfaces on top of the <code>targets</code> package to create
pipelines.
</p>


<h3>Value</h3>

<p>Value of a target option.
</p>


<h3>See Also</h3>

<p>Other configuration: 
<code><a href="#topic+tar_config_get">tar_config_get</a>()</code>,
<code><a href="#topic+tar_config_projects">tar_config_projects</a>()</code>,
<code><a href="#topic+tar_config_set">tar_config_set</a>()</code>,
<code><a href="#topic+tar_config_unset">tar_config_unset</a>()</code>,
<code><a href="#topic+tar_config_yaml">tar_config_yaml</a>()</code>,
<code><a href="#topic+tar_envvars">tar_envvars</a>()</code>,
<code><a href="#topic+tar_option_reset">tar_option_reset</a>()</code>,
<code><a href="#topic+tar_option_set">tar_option_set</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_option_get("format") # default format before we set anything
tar_target(x, 1)$settings$format
tar_option_set(format = "fst_tbl") # new default format
tar_option_get("format")
tar_target(x, 1)$settings$format
tar_option_reset() # reset the format
tar_target(x, 1)$settings$format
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  tar_option_set(cue = tar_cue(mode = "always")) # All targets always run.
  list(tar_target(x, 1), tar_target(y, 2))
})
tar_make()
tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_option_reset'>Reset all target options.</h2><span id='topic+tar_option_reset'></span>

<h3>Description</h3>

<p>Reset all target options you previously chose with
<code><a href="#topic+tar_option_set">tar_option_set()</a></code>. These options are mostly configurable default
arguments to <code><a href="#topic+tar_target">tar_target()</a></code> and <code><a href="#topic+tar_target_raw">tar_target_raw()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_option_reset()
</code></pre>


<h3>Value</h3>

<p><code>NULL</code> (invisibly).
</p>


<h3>See Also</h3>

<p>Other configuration: 
<code><a href="#topic+tar_config_get">tar_config_get</a>()</code>,
<code><a href="#topic+tar_config_projects">tar_config_projects</a>()</code>,
<code><a href="#topic+tar_config_set">tar_config_set</a>()</code>,
<code><a href="#topic+tar_config_unset">tar_config_unset</a>()</code>,
<code><a href="#topic+tar_config_yaml">tar_config_yaml</a>()</code>,
<code><a href="#topic+tar_envvars">tar_envvars</a>()</code>,
<code><a href="#topic+tar_option_get">tar_option_get</a>()</code>,
<code><a href="#topic+tar_option_set">tar_option_set</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_option_get("format") # default format before we set anything
tar_target(x, 1)$settings$format
tar_option_set(format = "fst_tbl") # new default format
tar_option_get("format")
tar_target(x, 1)$settings$format
tar_option_reset() # reset all options
tar_target(x, 1)$settings$format
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  tar_option_set(cue = tar_cue(mode = "always"))
  tar_option_reset() # Undo option above.
  list(tar_target(x, 1), tar_target(y, 2))
})
tar_make()
tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_option_set'>Set target options.</h2><span id='topic+tar_option_set'></span>

<h3>Description</h3>

<p>Set target options, including default arguments to
<code><a href="#topic+tar_target">tar_target()</a></code> such as packages, storage format,
iteration type, and cue. Only the non-null arguments are actually
set as options. See currently set options with <code><a href="#topic+tar_option_get">tar_option_get()</a></code>.
To use <code>tar_option_set()</code> effectively, put it in your workflow's
target script file (default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>)
before calls to <code><a href="#topic+tar_target">tar_target()</a></code> or <code><a href="#topic+tar_target_raw">tar_target_raw()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_option_set(
  tidy_eval = NULL,
  packages = NULL,
  imports = NULL,
  library = NULL,
  envir = NULL,
  format = NULL,
  repository = NULL,
  repository_meta = NULL,
  iteration = NULL,
  error = NULL,
  memory = NULL,
  garbage_collection = NULL,
  deployment = NULL,
  priority = NULL,
  backoff = NULL,
  resources = NULL,
  storage = NULL,
  retrieval = NULL,
  cue = NULL,
  description = NULL,
  debug = NULL,
  workspaces = NULL,
  workspace_on_error = NULL,
  seed = NULL,
  controller = NULL,
  trust_object_timestamps = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_option_set_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to enable tidy evaluation
when interpreting <code>command</code> and <code>pattern</code>. If <code>TRUE</code>, you can use the
&quot;bang-bang&quot; operator <code style="white-space: pre;">&#8288;!!&#8288;</code> to programmatically insert
the values of global objects.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_imports">imports</code></td>
<td>
<p>Character vector of package names.
For every package listed, <code>targets</code> tracks every
dataset and every object in the package namespace
as if it were part of the global namespace.
As an example, say you have a package called <code>customAnalysisPackage</code>
which contains an object called <code>analysis_function()</code>.
If you write <code>tar_option_set(imports = "yourAnalysisPackage")</code> in your
target script file (default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>),
then a function called <code>"analysis_function"</code> will show up in the
<code><a href="#topic+tar_visnetwork">tar_visnetwork()</a></code> graph, and any targets or functions
referring to the symbol <code>"analysis_function"</code> will depend on the
function <code>analysis_function()</code> from package <code>yourAnalysisPackage</code>.
This is best combined with
<code>tar_option_set(packages = "yourAnalysisPackage")</code> so
that <code>analysis_function()</code> can actually be called in your code.
</p>
<p>There are several important limitations:
1. Namespaced calls, e.g. <code>yourAnalysisPackage::analysis_function()</code>,
are ignored because of the limitations in <code>codetools::findGlobals()</code>
which powers the static code analysis capabilities of <code>targets</code>.
2. The <code>imports</code> option only looks at R objects and R code.
It not account for low-level compiled code
such as C/C++ or Fortran.
3. If you supply multiple packages,
e.g. <code>tar_option_set(imports = c("p1", "p2"))</code>, then the objects in
<code>p1</code> override the objects in <code>p2</code> if there are name conflicts.
4. Similarly, objects in <code>tar_option_get("envir")</code> override
everything in <code>tar_option_get("imports")</code>.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_envir">envir</code></td>
<td>
<p>Environment containing functions and global objects
common to all targets in the pipeline.
The <code>envir</code> argument of <code><a href="#topic+tar_make">tar_make()</a></code> and related functions
always overrides the current value of <code>tar_option_get("envir")</code>
in the current R session just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.
</p>
<p>If <code>envir</code> is the global environment, all the promise objects
are diffused before sending the data to parallel workers
in <code><a href="#topic+tar_make_future">tar_make_future()</a></code> and <code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code>,
but otherwise the environment is unmodified.
This behavior improves performance by decreasing
the size of data sent to workers.
</p>
<p>If <code>envir</code> is not the global environment, then it should at least inherit
from the global environment or base environment
so <code>targets</code> can access attached packages.
In the case of a non-global <code>envir</code>, <code>targets</code> attempts to remove
potentially high memory objects that come directly from <code>targets</code>.
That includes <code>tar_target()</code> objects of class <code>"tar_target"</code>,
as well as objects of class <code>"tar_pipeline"</code> or <code>"tar_algorithm"</code>.
This behavior improves performance by decreasing
the size of data sent to workers.
</p>
<p>Package environments should not be assigned to <code>envir</code>.
To include package objects as upstream dependencies in the pipeline,
assign the package to the <code>packages</code> and <code>imports</code> arguments
of <code>tar_option_set()</code>.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_repository_meta">repository_meta</code></td>
<td>
<p>Character of length 1 with the same values as
<code>repository</code> (<code>"aws"</code>, <code>"gcp"</code>, <code>"local"</code>). Cloud repository
for the metadata text files in <code style="white-space: pre;">&#8288;_targets/meta/&#8288;</code>, including target
metadata and progress data. Defaults to <code>tar_option_get("repository")</code>.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vctrs::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a non-dynamic data frame.
For <code>iteration = "group"</code>, the target must not by dynamic
(the <code>pattern</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code> must be left <code>NULL</code>).
The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code><a href="#topic+tar_group">tar_group()</a></code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_option_set_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_option_set_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_backoff">backoff</code></td>
<td>
<p>An object from <code><a href="#topic+tar_backoff">tar_backoff()</a></code> configuring the exponential
backoff algorithm of the pipeline. See <code><a href="#topic+tar_backoff">tar_backoff()</a></code> for details.
A numeric argument for <code>backoff</code> is still allowed, but deprecated.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_option_set_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_option_set_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_debug">debug</code></td>
<td>
<p>Character vector of names of targets to run in debug mode.
To use effectively, you must set <code>callr_function = NULL</code> and
restart your R session just before running. You should also
<code><a href="#topic+tar_make">tar_make()</a></code>, <code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code>, or <code><a href="#topic+tar_make_future">tar_make_future()</a></code>.
For any target mentioned in <code>debug</code>, <code>targets</code> will force the target to
run locally (with <code>tar_cue(mode = "always")</code> and <code>deployment = "main"</code>
in the settings) and pause in an interactive debugger to help you diagnose
problems. This is like inserting a <code>browser()</code> statement at the
beginning of the target's expression, but without invalidating any
targets.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_workspaces">workspaces</code></td>
<td>
<p>Character vector of target names.
Could be non-branching targets, whole dynamic branching targets,
or individual branch names. <code><a href="#topic+tar_make">tar_make()</a></code> and friends
will save workspace files for these targets even if
the targets are skipped. Workspace files help with debugging.
See <code><a href="#topic+tar_workspace">tar_workspace()</a></code> for details about workspaces.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_workspace_on_error">workspace_on_error</code></td>
<td>
<p>Logical of length 1, whether to save
a workspace file for each target that throws an error.
Workspace files help with debugging.
See <code><a href="#topic+tar_workspace">tar_workspace()</a></code> for details about workspaces.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_seed">seed</code></td>
<td>
<p>Integer of length 1, seed for generating
target-specific pseudo-random number generator seeds.
These target-specific seeds are deterministic and depend on
<code>tar_option_get("seed")</code> and the target name. Target-specific seeds
are safely and reproducibly applied to each target's command,
and they are stored in the metadata and retrievable with
<code><a href="#topic+tar_meta">tar_meta()</a></code> or <code><a href="#topic+tar_seed">tar_seed()</a></code>.
</p>
<p>Either the user or third-party packages built on top of <code>targets</code>
may still set seeds inside the command of a target.
For example, some target factories in the
<code>tarchetypes</code> package assigns replicate-specific
seeds for the purposes of reproducible within-target batched replication.
In cases like these, the effect of the target-specific seed saved
in the metadata becomes irrelevant and the seed defined in the command
applies.
</p>
<p>The <code>seed</code> option can also be <code>NA</code> to disable
automatic seed-setting. Any targets defined while
<code>tar_option_get("seed")</code> is <code>NA</code> will not set a seed.
In this case, those targets will never be up to date
unless they have <code>cue = tar_cue(seed = FALSE)</code>.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_controller">controller</code></td>
<td>
<p>A controller or controller group object
produced by the <code>crew</code> R package. <code>crew</code> brings auto-scaled
distributed computing to <code><a href="#topic+tar_make">tar_make()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_option_set_+3A_trust_object_timestamps">trust_object_timestamps</code></td>
<td>
<p>Logical of length 1, whether to use
file system modification timestamps to check whether the target output
data files in <code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code> are up to date. This is an advanced
setting and usually does not need to be set by the user
except on old or difficult platforms.
</p>
<p>If <code>trust_object_timestamps</code>
is <code>TRUE</code> (default), then <code>targets</code> looks at the timestamp first.
If it agrees with the timestamp recorded in the metadata, then <code>targets</code>
considers the file unchanged. If the timestamps disagree, then <code>targets</code>
recomputes the hash to make a final determination.
This practice reduces the number of hash computations
and thus saves time.
</p>
<p>However, timestamp precision varies from a few
nanoseconds at best to 2 entire seconds at worst, and timestamps
with poor precision should not be fully trusted if there is any
possibility that you will manually change the file within 2 seconds
after the pipeline finishes.
If the data store is on a file system with low-precision timestamps,
then you may
consider setting <code>trust_object_timestamps</code> to <code>FALSE</code> so <code>targets</code>
errs on the safe side and always recomputes the hashes of files in
<code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code>.
</p>
<p>To check if your
file system has low-precision timestamps, you can run
<code style="white-space: pre;">&#8288;file.create("x"); nanonext::msleep(1); file.create("y");&#8288;</code>
from within the directory containing the <code style="white-space: pre;">&#8288;_targets&#8288;</code> data store
and then check
<code>difftime(file.mtime("y"), file.mtime("x"), units = "secs")</code>.
If the value from <code>difftime()</code> is around 0.001 seconds
(must be strictly above 0 and below 1) then you do not need to set
<code>trust_object_timestamps = FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly).
</p>


<h3>Storage formats</h3>


<ul>
<li> <p><code>"rds"</code>: Default, uses <code>saveRDS()</code> and <code>readRDS()</code>. Should work for
most objects, but slow.
</p>
</li>
<li> <p><code>"qs"</code>: Uses <code>qs::qsave()</code> and <code>qs::qread()</code>. Should work for
most objects, much faster than <code>"rds"</code>. Optionally set the
preset for <code>qsave()</code> through <code>tar_resources()</code> and <code>tar_resources_qs()</code>.
</p>
</li>
<li> <p><code>"feather"</code>: Uses <code>arrow::write_feather()</code> and
<code>arrow::read_feather()</code> (version 2.0). Much faster than <code>"rds"</code>,
but the value must be a data frame. Optionally set
<code>compression</code> and <code>compression_level</code> in <code>arrow::write_feather()</code>
through <code>tar_resources()</code> and <code>tar_resources_feather()</code>.
Requires the <code>arrow</code> package (not installed by default).
</p>
</li>
<li> <p><code>"parquet"</code>: Uses <code>arrow::write_parquet()</code> and
<code>arrow::read_parquet()</code> (version 2.0). Much faster than <code>"rds"</code>,
but the value must be a data frame. Optionally set
<code>compression</code> and <code>compression_level</code> in <code>arrow::write_parquet()</code>
through <code>tar_resources()</code> and <code>tar_resources_parquet()</code>.
Requires the <code>arrow</code> package (not installed by default).
</p>
</li>
<li> <p><code>"fst"</code>: Uses <code>fst::write_fst()</code> and <code>fst::read_fst()</code>.
Much faster than <code>"rds"</code>, but the value must be
a data frame. Optionally set the compression level for
<code>fst::write_fst()</code> through <code>tar_resources()</code> and <code>tar_resources_fst()</code>.
Requires the <code>fst</code> package (not installed by default).
</p>
</li>
<li> <p><code>"fst_dt"</code>: Same as <code>"fst"</code>, but the value is a <code>data.table</code>.
Deep copies are made as appropriate in order to protect
against the global effects of in-place modification.
Optionally set the compression level the same way as for <code>"fst"</code>.
</p>
</li>
<li> <p><code>"fst_tbl"</code>: Same as <code>"fst"</code>, but the value is a <code>tibble</code>.
Optionally set the compression level the same way as for <code>"fst"</code>.
</p>
</li>
<li> <p><code>"keras"</code>: superseded by <code><a href="#topic+tar_format">tar_format()</a></code> and incompatible
with <code>error = "null"</code> (in <code><a href="#topic+tar_target">tar_target()</a></code> or <code><a href="#topic+tar_option_set">tar_option_set()</a></code>).
Uses <code>keras::save_model_hdf5()</code> and
<code>keras::load_model_hdf5()</code>. The value must be a Keras model.
Requires the <code>keras</code> package (not installed by default).
</p>
</li>
<li> <p><code>"torch"</code>: superseded by <code><a href="#topic+tar_format">tar_format()</a></code> and incompatible
with <code>error = "null"</code> (in <code><a href="#topic+tar_target">tar_target()</a></code> or <code><a href="#topic+tar_option_set">tar_option_set()</a></code>).
Uses <code>torch::torch_save()</code> and <code>torch::torch_load()</code>.
The value must be an object from the <code>torch</code> package
such as a tensor or neural network module.
Requires the <code>torch</code> package (not installed by default).
</p>
</li>
<li> <p><code>"file"</code>: A dynamic file. To use this format,
the target needs to manually identify or save some data
and return a character vector of paths
to the data (must be a single file path if <code>repository</code>
is not <code>"local"</code>). (These paths must be existing files
and nonempty directories.)
Then, <code>targets</code> automatically checks those files and cues
the appropriate run/skip decisions if those files are out of date.
Those paths must point to files or directories,
and they must not contain characters <code>|</code> or <code>*</code>.
All the files and directories you return must actually exist,
or else <code>targets</code> will throw an error. (And if <code>storage</code> is <code>"worker"</code>,
<code>targets</code> will first stall out trying to wait for the file
to arrive over a network file system.)
If the target does not create any files, the return value should be
<code>character(0)</code>.
</p>
<p>If <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>,
then the character vector returned by the target must be of length 1
and point to a single file. (Directories and vectors of multiple
file paths are not supported for dynamic files on the cloud.)
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.
</p>
<p>To check if the file is up to date, <code>targets</code> avoids timestamps
and always recomputes the hash. If you find this to be too slow,
and if you trust the time stamps on your file system
(see the <code>trust_object_timestamps</code> argument of <code><a href="#topic+tar_option_set">tar_option_set()</a></code>),
then consider <code>format = "file_fast"</code> instead.
</p>
</li>
<li> <p><code>"file_fast"</code>: same as <code>format = "file"</code>, except that <code>targets</code>
uses time stamps to check if a file is up to date. If the time stamp
of the file agrees with the time stamp in the metadata, the
file is considered up to date. Otherwise, <code>targets</code> recomputes the
hash of the file to make a final determination. Low-precision
timestamps are not reliable for this, and some file systems
have timestamp precision as poor as 2 seconds. See the
<code>trust_object_timestamps</code> argument of <code><a href="#topic+tar_option_set">tar_option_set()</a></code>
for advice on this.
</p>
</li>
<li> <p><code>"url"</code>: A dynamic input URL. For this storage format,
<code>repository</code> is implicitly <code>"local"</code>,
URL format is like <code>format = "file"</code>
except the return value of the target is a URL that already exists
and serves as input data for downstream targets. Optionally
supply a custom <code>curl</code> handle through
<code>tar_resources()</code> and <code>tar_resources_url()</code>.
in <code>new_handle()</code>, <code>nobody = TRUE</code> is important because it
ensures <code>targets</code> just downloads the metadata instead of
the entire data file when it checks time stamps and hashes.
The data file at the URL needs to have an ETag or a Last-Modified
time stamp, or else the target will throw an error because
it cannot track the data. Also, use extreme caution when
trying to use <code>format = "url"</code> to track uploads. You must be absolutely
certain the ETag and Last-Modified time stamp are fully updated
and available by the time the target's command finishes running.
<code>targets</code> makes no attempt to wait for the web server.
</p>
</li>
<li><p> A custom format can be supplied with <code>tar_format()</code>. For this choice,
it is the user's responsibility to provide methods for (un)serialization
and (un)marshaling the return value of the target.
</p>
</li>
<li><p> The formats starting with <code>"aws_"</code> are deprecated as of 2022-03-13
(<code>targets</code> version &gt; 0.10.0). For cloud storage integration, use the
<code>repository</code> argument instead.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other configuration: 
<code><a href="#topic+tar_config_get">tar_config_get</a>()</code>,
<code><a href="#topic+tar_config_projects">tar_config_projects</a>()</code>,
<code><a href="#topic+tar_config_set">tar_config_set</a>()</code>,
<code><a href="#topic+tar_config_unset">tar_config_unset</a>()</code>,
<code><a href="#topic+tar_config_yaml">tar_config_yaml</a>()</code>,
<code><a href="#topic+tar_envvars">tar_envvars</a>()</code>,
<code><a href="#topic+tar_option_get">tar_option_get</a>()</code>,
<code><a href="#topic+tar_option_reset">tar_option_reset</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_option_get("format") # default format before we set anything
tar_target(x, 1)$settings$format
tar_option_set(format = "fst_tbl") # new default format
tar_option_get("format")
tar_target(x, 1)$settings$format
tar_option_reset() # reset the format
tar_target(x, 1)$settings$format
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  tar_option_set(cue = tar_cue(mode = "always")) # All targets always run.
  list(tar_target(x, 1), tar_target(y, 2))
})
tar_make()
tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_outdated'>Check which targets are outdated.</h2><span id='topic+tar_outdated'></span>

<h3>Description</h3>

<p>Checks for outdated targets in the pipeline,
targets that will be rerun automatically if you call
<code><a href="#topic+tar_make">tar_make()</a></code> or similar. See <code><a href="#topic+tar_cue">tar_cue()</a></code> for the rules
that decide whether a target needs to rerun.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_outdated(
  names = NULL,
  shortcut = targets::tar_config_get("shortcut"),
  branches = FALSE,
  targets_only = TRUE,
  reporter = targets::tar_config_get("reporter_outdated"),
  seconds_reporter = targets::tar_config_get("seconds_reporter"),
  seconds_interval = targets::tar_config_get("seconds_interval"),
  callr_function = callr::r,
  callr_arguments = targets::tar_callr_args_default(callr_function, reporter),
  envir = parent.frame(),
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_outdated_+3A_names">names</code></td>
<td>
<p>Names of the targets. <code>tar_outdated()</code> will check
these targets and all upstream ancestors in the dependency graph.
Set <code>names</code> to <code>NULL</code> to check/build all the targets (default).
The object supplied to <code>names</code> should be <code>NULL</code> or a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_outdated_+3A_shortcut">shortcut</code></td>
<td>
<p>Logical of length 1, how to interpret the <code>names</code> argument.
If <code>shortcut</code> is <code>FALSE</code> (default) then the function checks
all targets upstream of <code>names</code> as far back as the dependency graph goes.
If <code>TRUE</code>, then the function only checks the targets in <code>names</code>
and uses stored metadata for information about upstream dependencies
as needed. <code>shortcut = TRUE</code> increases speed if there are a lot of
up-to-date targets, but it assumes all the dependencies
are up to date, so please use with caution.
Also, <code>shortcut = TRUE</code> only works if you set <code>names</code>.</p>
</td></tr>
<tr><td><code id="tar_outdated_+3A_branches">branches</code></td>
<td>
<p>Logical of length 1, whether to include branch names.
Including branches could get cumbersome for large pipelines.
Individual branch names are still omitted when branch-specific information
is not reliable: for example, when a pattern branches over
an outdated target.</p>
</td></tr>
<tr><td><code id="tar_outdated_+3A_targets_only">targets_only</code></td>
<td>
<p>Logical of length 1, whether to just restrict to targets
or to include functions and other global objects from the environment
created by running the target script file (default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>).</p>
</td></tr>
<tr><td><code id="tar_outdated_+3A_reporter">reporter</code></td>
<td>
<p>Character of length 1, name of the reporter to user.
Controls how messages are printed as targets are checked. Choices:
</p>

<ul>
<li> <p><code>"silent"</code>: print nothing.
</p>
</li>
<li> <p><code>"forecast"</code>: print running totals of the checked and outdated
targets found so far.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_outdated_+3A_seconds_reporter">seconds_reporter</code></td>
<td>
<p>Positive numeric of length 1 with the minimum
number of seconds between times when the reporter prints progress
messages to the R console.</p>
</td></tr>
<tr><td><code id="tar_outdated_+3A_seconds_interval">seconds_interval</code></td>
<td>
<p>Deprecated on 2023-08-24 (version 1.2.2.9001).
Use <code>seconds_meta_append</code>, <code>seconds_meta_upload</code>,
and <code>seconds_reporter</code> instead.</p>
</td></tr>
<tr><td><code id="tar_outdated_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_outdated_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
<tr><td><code id="tar_outdated_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_outdated_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_outdated_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires that you define a pipeline
with a target script file (default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>).
(See <code><a href="#topic+tar_script">tar_script()</a></code> for details.)
</p>


<h3>Value</h3>

<p>Names of the outdated targets.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other inspect: 
<code><a href="#topic+tar_deps">tar_deps</a>()</code>,
<code><a href="#topic+tar_deps_raw">tar_deps_raw</a>()</code>,
<code><a href="#topic+tar_manifest">tar_manifest</a>()</code>,
<code><a href="#topic+tar_network">tar_network</a>()</code>,
<code><a href="#topic+tar_sitrep">tar_sitrep</a>()</code>,
<code><a href="#topic+tar_validate">tar_validate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(list(tar_target(x, 1 + 1)))
tar_outdated()
tar_script({
  list(
    tar_target(y1, 1 + 1),
    tar_target(y2, 1 + 1),
    tar_target(z, y1 + y2)
  )
}, ask = FALSE)
tar_outdated()
})
}
</code></pre>

<hr>
<h2 id='tar_path'>Deprecated: identify the file path where a target will be stored.</h2><span id='topic+tar_path'></span>

<h3>Description</h3>

<p>Deprecated: identify the file path where a target will be
stored after the target finishes running in the pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_path(
  name = NULL,
  default = NA_character_,
  create_dir = FALSE,
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_path_+3A_name">name</code></td>
<td>
<p>Symbol, name of a target.
If <code>NULL</code>, <code>tar_path()</code> returns the path of the target currently running
in a pipeline.</p>
</td></tr>
<tr><td><code id="tar_path_+3A_default">default</code></td>
<td>
<p>Character, value to return if <code>tar_path()</code>
is called on its own outside a <code>targets</code> pipeline.
Having a default lets users run things without <code><a href="#topic+tar_make">tar_make()</a></code>,
which helps peel back layers of code and troubleshoot bugs.</p>
</td></tr>
<tr><td><code id="tar_path_+3A_create_dir">create_dir</code></td>
<td>
<p>Logical of length 1,
whether to create <code>dirname(tar_path())</code> in <code>tar_path()</code> itself.
This is useful if you are writing to <code>tar_path()</code> from inside a
<code>storage = "none"</code> target and need the parent directory of the file
to exist.</p>
</td></tr>
<tr><td><code id="tar_path_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the data store if <code>tar_path()</code>
is called outside a running pipeline. If <code>tar_path()</code> is called
inside a running pipeline, this argument is ignored
and actual the path to the running pipeline's data store
is used instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_path()</code> was deprecated on 2022-10-11 (version 0.13.5.9000).
Use <code><a href="#topic+tar_path_target">tar_path_target()</a></code> instead.
</p>


<h3>Value</h3>

<p>Character, file path of the return value of the target.
If not called from inside a running target,
<code>tar_path(name = your_target)</code> just returns
<code style="white-space: pre;">&#8288;_targets/objects/your_target&#8288;</code>, the file path where <code>your_target</code>
will be saved unless <code>format</code> is equal to <code>"file"</code> or any of the
supported cloud-based storage formats.
</p>
<p>For non-cloud storage formats, if you call <code>tar_path()</code>
with no arguments while target <code>x</code> is running, the <code>name</code>
argument defaults to the name of the running target,
so <code>tar_path()</code> returns <code style="white-space: pre;">&#8288;_targets/objects/x&#8288;</code>.
</p>
<p>For cloud-backed formats, <code>tar_path()</code> returns the
path to the staging file in <code style="white-space: pre;">&#8288;_targets/scratch/&#8288;</code>.
That way, even if you select a cloud repository
(e.g. <code>tar_target(..., repository = "aws", storage = "none")</code>)
then you can still manually write to <code>tar_path(create_dir = TRUE)</code>
and the <code>targets</code> package will automatically hash it and
upload it to the AWS S3 bucket. This does not apply to
<code>format = "file"</code>, where you would never need <code>storage = "none"</code>
anyway.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+tar_active">tar_active</a>()</code>,
<code><a href="#topic+tar_backoff">tar_backoff</a>()</code>,
<code><a href="#topic+tar_call">tar_call</a>()</code>,
<code><a href="#topic+tar_cancel">tar_cancel</a>()</code>,
<code><a href="#topic+tar_definition">tar_definition</a>()</code>,
<code><a href="#topic+tar_described_as">tar_described_as</a>()</code>,
<code><a href="#topic+tar_envir">tar_envir</a>()</code>,
<code><a href="#topic+tar_group">tar_group</a>()</code>,
<code><a href="#topic+tar_name">tar_name</a>()</code>,
<code><a href="#topic+tar_path_script">tar_path_script</a>()</code>,
<code><a href="#topic+tar_path_script_support">tar_path_script_support</a>()</code>,
<code><a href="#topic+tar_path_store">tar_path_store</a>()</code>,
<code><a href="#topic+tar_path_target">tar_path_target</a>()</code>,
<code><a href="#topic+tar_source">tar_source</a>()</code>,
<code><a href="#topic+tar_store">tar_store</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_path_target()
tar_path_target(your_target)
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(tar_target(returns_path, tar_path_target()), ask = FALSE)
tar_make()
tar_read(returns_path)
})
}
</code></pre>

<hr>
<h2 id='tar_path_script'>Current target script path</h2><span id='topic+tar_path_script'></span>

<h3>Description</h3>

<p>Identify the file path to the target script
of the pipeline currently running.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_path_script()
</code></pre>


<h3>Value</h3>

<p>Character, file path to the target script
of the pipeline currently running.
If called outside of the pipeline currently running,
<code>tar_path_script()</code> returns <code>tar_config_get("script")</code>.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+tar_active">tar_active</a>()</code>,
<code><a href="#topic+tar_backoff">tar_backoff</a>()</code>,
<code><a href="#topic+tar_call">tar_call</a>()</code>,
<code><a href="#topic+tar_cancel">tar_cancel</a>()</code>,
<code><a href="#topic+tar_definition">tar_definition</a>()</code>,
<code><a href="#topic+tar_described_as">tar_described_as</a>()</code>,
<code><a href="#topic+tar_envir">tar_envir</a>()</code>,
<code><a href="#topic+tar_group">tar_group</a>()</code>,
<code><a href="#topic+tar_name">tar_name</a>()</code>,
<code><a href="#topic+tar_path">tar_path</a>()</code>,
<code><a href="#topic+tar_path_script_support">tar_path_script_support</a>()</code>,
<code><a href="#topic+tar_path_store">tar_path_store</a>()</code>,
<code><a href="#topic+tar_path_target">tar_path_target</a>()</code>,
<code><a href="#topic+tar_source">tar_source</a>()</code>,
<code><a href="#topic+tar_store">tar_store</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_path_script()
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
script &lt;- tempfile()
tar_script(tar_target(x, tar_path_script()), script = script, ask = FALSE)
tar_make(script = script)
tar_read(x)
})
}
</code></pre>

<hr>
<h2 id='tar_path_script_support'>Directory path to the support scripts
of the current target script</h2><span id='topic+tar_path_script_support'></span>

<h3>Description</h3>

<p>Identify the directory path to the
support scripts
of the current target script
of the pipeline currently running.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_path_script_support()
</code></pre>


<h3>Details</h3>

<p>A target script (default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) comes with
support scripts if it is written by Target Markdown.
These support scripts usually live in a folder called <code style="white-space: pre;">&#8288;_targets_r/&#8288;</code>,
but the path may vary from case to case. The
<code>tar_path_scipt_support()</code> returns the path to
the folder with the support scripts.
</p>


<h3>Value</h3>

<p>Character, directory path to the target script
of the pipeline currently running.
If called outside of the pipeline currently running,
<code>tar_path_script()</code> returns <code>tar_config_get("script")</code>.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+tar_active">tar_active</a>()</code>,
<code><a href="#topic+tar_backoff">tar_backoff</a>()</code>,
<code><a href="#topic+tar_call">tar_call</a>()</code>,
<code><a href="#topic+tar_cancel">tar_cancel</a>()</code>,
<code><a href="#topic+tar_definition">tar_definition</a>()</code>,
<code><a href="#topic+tar_described_as">tar_described_as</a>()</code>,
<code><a href="#topic+tar_envir">tar_envir</a>()</code>,
<code><a href="#topic+tar_group">tar_group</a>()</code>,
<code><a href="#topic+tar_name">tar_name</a>()</code>,
<code><a href="#topic+tar_path">tar_path</a>()</code>,
<code><a href="#topic+tar_path_script">tar_path_script</a>()</code>,
<code><a href="#topic+tar_path_store">tar_path_store</a>()</code>,
<code><a href="#topic+tar_path_target">tar_path_target</a>()</code>,
<code><a href="#topic+tar_source">tar_source</a>()</code>,
<code><a href="#topic+tar_store">tar_store</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_path_script_support()
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
script &lt;- tempfile()
tar_script(
  tar_target(x, tar_path_script_support()),
  script = script,
  ask = FALSE
)
tar_make(script = script)
tar_read(x)
})
}
</code></pre>

<hr>
<h2 id='tar_path_store'>Current data store path</h2><span id='topic+tar_path_store'></span>

<h3>Description</h3>

<p>Identify the file path to the data store
of the pipeline currently running.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_path_store()
</code></pre>


<h3>Value</h3>

<p>Character, file path to the data store
of the pipeline currently running.
If called outside of the pipeline currently running,
<code>tar_path_store()</code> returns <code>tar_config_get("store")</code>.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+tar_active">tar_active</a>()</code>,
<code><a href="#topic+tar_backoff">tar_backoff</a>()</code>,
<code><a href="#topic+tar_call">tar_call</a>()</code>,
<code><a href="#topic+tar_cancel">tar_cancel</a>()</code>,
<code><a href="#topic+tar_definition">tar_definition</a>()</code>,
<code><a href="#topic+tar_described_as">tar_described_as</a>()</code>,
<code><a href="#topic+tar_envir">tar_envir</a>()</code>,
<code><a href="#topic+tar_group">tar_group</a>()</code>,
<code><a href="#topic+tar_name">tar_name</a>()</code>,
<code><a href="#topic+tar_path">tar_path</a>()</code>,
<code><a href="#topic+tar_path_script">tar_path_script</a>()</code>,
<code><a href="#topic+tar_path_script_support">tar_path_script_support</a>()</code>,
<code><a href="#topic+tar_path_target">tar_path_target</a>()</code>,
<code><a href="#topic+tar_source">tar_source</a>()</code>,
<code><a href="#topic+tar_store">tar_store</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_path_store()
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(tar_target(x, tar_path_store()), ask = FALSE)
store &lt;- tempfile()
tar_make(store = store)
tar_read(x, store = store)
})
}
</code></pre>

<hr>
<h2 id='tar_path_target'>Identify the file path where a target will be stored.</h2><span id='topic+tar_path_target'></span>

<h3>Description</h3>

<p>Identify the file path where a target will be stored
after the target finishes running in the pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_path_target(
  name = NULL,
  default = NA_character_,
  create_dir = FALSE,
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_path_target_+3A_name">name</code></td>
<td>
<p>Symbol, name of a target.
If <code>NULL</code>, <code>tar_path_target()</code> returns the path of the target currently
running in a pipeline.</p>
</td></tr>
<tr><td><code id="tar_path_target_+3A_default">default</code></td>
<td>
<p>Character, value to return if <code>tar_path_target()</code>
is called on its own outside a <code>targets</code> pipeline.
Having a default lets users run things without <code><a href="#topic+tar_make">tar_make()</a></code>,
which helps peel back layers of code and troubleshoot bugs.</p>
</td></tr>
<tr><td><code id="tar_path_target_+3A_create_dir">create_dir</code></td>
<td>
<p>Logical of length 1,
whether to create <code>dirname(tar_path_target())</code> in
<code>tar_path_target()</code> itself.
This is useful if you are writing to <code>tar_path_target()</code> from inside a
<code>storage = "none"</code> target and need the parent directory of the file
to exist.</p>
</td></tr>
<tr><td><code id="tar_path_target_+3A_store">store</code></td>
<td>
<p>Character of length 1,
path to the data store if <code>tar_path_target()</code>
is called outside a running pipeline. If <code>tar_path_target()</code> is called
inside a running pipeline, this argument is ignored
and actual the path to the running pipeline's data store
is used instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character, file path of the return value of the target.
If not called from inside a running target,
<code>tar_path_target(name = your_target)</code> just returns
<code style="white-space: pre;">&#8288;_targets/objects/your_target&#8288;</code>, the file path where <code>your_target</code>
will be saved unless <code>format</code> is equal to <code>"file"</code> or any of the
supported cloud-based storage formats.
</p>
<p>For non-cloud storage formats, if you call <code>tar_path_target()</code>
with no arguments while target <code>x</code> is running, the <code>name</code>
argument defaults to the name of the running target,
so <code>tar_path_target()</code> returns <code style="white-space: pre;">&#8288;_targets/objects/x&#8288;</code>.
</p>
<p>For cloud-backed formats, <code>tar_path_target()</code> returns the
path to the staging file in <code style="white-space: pre;">&#8288;_targets/scratch/&#8288;</code>.
That way, even if you select a cloud repository
(e.g. <code>tar_target(..., repository = "aws", storage = "none")</code>)
then you can still manually write to
<code>tar_path_target(create_dir = TRUE)</code>
and the <code>targets</code> package will automatically hash it and
upload it to the AWS S3 bucket. This does not apply to
<code>format = "file"</code>, where you would never need <code>storage = "none"</code>
anyway.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+tar_active">tar_active</a>()</code>,
<code><a href="#topic+tar_backoff">tar_backoff</a>()</code>,
<code><a href="#topic+tar_call">tar_call</a>()</code>,
<code><a href="#topic+tar_cancel">tar_cancel</a>()</code>,
<code><a href="#topic+tar_definition">tar_definition</a>()</code>,
<code><a href="#topic+tar_described_as">tar_described_as</a>()</code>,
<code><a href="#topic+tar_envir">tar_envir</a>()</code>,
<code><a href="#topic+tar_group">tar_group</a>()</code>,
<code><a href="#topic+tar_name">tar_name</a>()</code>,
<code><a href="#topic+tar_path">tar_path</a>()</code>,
<code><a href="#topic+tar_path_script">tar_path_script</a>()</code>,
<code><a href="#topic+tar_path_script_support">tar_path_script_support</a>()</code>,
<code><a href="#topic+tar_path_store">tar_path_store</a>()</code>,
<code><a href="#topic+tar_source">tar_source</a>()</code>,
<code><a href="#topic+tar_store">tar_store</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_path_target()
tar_path_target(your_target)
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(tar_target(returns_path, tar_path_target()), ask = FALSE)
tar_make()
tar_read(returns_path)
})
}
</code></pre>

<hr>
<h2 id='tar_pattern'>Emulate dynamic branching.</h2><span id='topic+tar_pattern'></span><span id='topic+map'></span><span id='topic+cross'></span><span id='topic+head'></span><span id='topic+tail'></span><span id='topic+sample'></span>

<h3>Description</h3>

<p>Emulate the dynamic branching process outside a pipeline.
<code>tar_pattern()</code> can help you understand the overall branching structure
that comes from the <code>pattern</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_pattern(pattern, ..., seed = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_pattern_+3A_pattern">pattern</code></td>
<td>
<p>Function call with the pattern specification.</p>
</td></tr>
<tr><td><code id="tar_pattern_+3A_...">...</code></td>
<td>
<p>Named integers, each of length 1.
Each name is the name of a dependency target,
and each integer is the length of the target
(number of branches or slices). Names must be unique.</p>
</td></tr>
<tr><td><code id="tar_pattern_+3A_seed">seed</code></td>
<td>
<p>Integer of length 1, random number generator seed to
emulate the pattern reproducibly. (The <code>sample()</code> pattern is random).
In a real pipeline, the seed is automatically generated
from the target name in deterministic fashion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dynamic branching is a way to programmatically
create multiple new targets based on the values of other targets,
all while the pipeline is running. Use the <code>pattern</code> argument of
<code><a href="#topic+tar_target">tar_target()</a></code> to get started. <code>pattern</code> accepts a function call
composed of target names and any of the following patterns:
</p>

<ul>
<li> <p><code>map()</code>: iterate over one or more targets in sequence.
</p>
</li>
<li> <p><code>cross()</code>: iterate over combinations of slices of targets.
</p>
</li>
<li> <p><code>slice()</code>: select one or more slices by index, e.g.
<code>slice(x, index = c(3, 4))</code> selects the third and fourth
slice or branch of <code>x</code>.
</p>
</li>
<li> <p><code>head()</code>: restrict branching to the first few elements.
</p>
</li>
<li> <p><code>tail()</code>: restrict branching to the last few elements.
</p>
</li>
<li> <p><code>sample()</code>: restrict branching to a random subset of elements.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>tibble</code> showing the kinds of dynamic branches that
<code><a href="#topic+tar_target">tar_target()</a></code> would create in a real pipeline with the given <code>pattern</code>.
Each row is a dynamic branch, each column is a dependency target,
and each element is the name of an upstream bud or branch that the
downstream branch depends on. Buds are pieces of non-branching targets
(&quot;stems&quot;) and branches are pieces of patterns. The returned bud and branch
names are not the actual ones you will see when you run the pipeline,
but they do communicate the branching structure of the pattern.
</p>


<h3>See Also</h3>

<p>Other branching: 
<code><a href="#topic+tar_branch_index">tar_branch_index</a>()</code>,
<code><a href="#topic+tar_branch_names">tar_branch_names</a>()</code>,
<code><a href="#topic+tar_branch_names_raw">tar_branch_names_raw</a>()</code>,
<code><a href="#topic+tar_branches">tar_branches</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># To use dynamic map for real in a pipeline,
# call map() in a target's pattern.
# The following code goes at the bottom of
# your target script file (default: `_targets.R`).
list(
  tar_target(x, seq_len(2)),
  tar_target(y, head(letters, 2)),
  tar_target(dynamic, c(x, y), pattern = map(x, y)) # 2 branches
)
# Likewise for more complicated patterns.
list(
  tar_target(x, seq_len(2)),
  tar_target(y, head(letters, 2)),
  tar_target(z, head(LETTERS, 2)),
  tar_target(dynamic, c(x, y, z), pattern = cross(z, map(x, y))) #4 branches
)
# But you can emulate dynamic branching without running a pipeline
# in order to understand the patterns you are creating. Simply supply
# the pattern and the length of each dependency target.
# The returned data frame represents the branching structure of the pattern:
# One row per new branch, one column per dependency target, and
# one element per bud/branch in each dependency target.
tar_pattern(
  cross(x, map(y, z)),
  x = 2,
  y = 3,
  z = 3
)
tar_pattern(
  head(cross(x, map(y, z)), n = 2),
  x = 2,
  y = 3,
  z = 3
)
</code></pre>

<hr>
<h2 id='tar_pid'>Get main process ID.</h2><span id='topic+tar_pid'></span>

<h3>Description</h3>

<p>Get the process ID (PID) of the most recent main R process
to orchestrate the targets of the current project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_pid(store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_pid_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main process is the R process invoked
by <code><a href="#topic+tar_make">tar_make()</a></code> or similar. If <code>callr_function</code> is not <code>NULL</code>,
this is an external process, and the <code>pid</code> in the return value
will not agree with <code>Sys.getpid()</code> in your current interactive session.
The process may or may not be alive. You may want to
check it with <code>ps::ps_is_running(ps::ps_handle(targets::tar_pid()))</code>
before running another call to <code><a href="#topic+tar_make">tar_make()</a></code>
for the same project.
</p>


<h3>Value</h3>

<p>Integer with the process ID (PID) of the most recent
main R process to orchestrate the targets of the current project.
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+tar_crew">tar_crew</a>()</code>,
<code><a href="#topic+tar_load">tar_load</a>()</code>,
<code><a href="#topic+tar_load_everything">tar_load_everything</a>()</code>,
<code><a href="#topic+tar_load_raw">tar_load_raw</a>()</code>,
<code><a href="#topic+tar_objects">tar_objects</a>()</code>,
<code><a href="#topic+tar_process">tar_process</a>()</code>,
<code><a href="#topic+tar_read">tar_read</a>()</code>,
<code><a href="#topic+tar_read_raw">tar_read_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(2)),
    tar_target(y, 2 * x, pattern = map(x))
  )
}, ask = FALSE)
tar_make()
Sys.getpid()
tar_pid() # Different from the current PID.
})
}
</code></pre>

<hr>
<h2 id='tar_pipeline'>Declare a pipeline (deprecated).</h2><span id='topic+tar_pipeline'></span>

<h3>Description</h3>

<p>Functions <code>tar_pipeline()</code> and <code><a href="#topic+tar_bind">tar_bind()</a></code> are deprecated.
Instead, simply end your target script file (default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>)
with a list of target objects.
You can nest these objects however you like.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_pipeline(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_pipeline_+3A_...">...</code></td>
<td>
<p>Targets or lists of targets defined with <code><a href="#topic+tar_target">tar_target()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Deprecated on 2021-01-03.
</p>


<h3>Value</h3>

<p>A pipeline object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># In _targets.R:
library(targets)
list( # You no longer need tar_pipeline() here.
  tar_target(data_file, "data.csv", format = "file"),
  list( # Target lists can be arbitrarily nested.
    tar_target(data_object, read.csv(data_file)),
    tar_target(analysis, analyze(data_object))
  )
)
</code></pre>

<hr>
<h2 id='tar_poll'>Repeatedly poll progress in the R console.</h2><span id='topic+tar_poll'></span>

<h3>Description</h3>

<p>Print the information in <code><a href="#topic+tar_progress_summary">tar_progress_summary()</a></code>
at regular intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_poll(
  interval = 1,
  timeout = Inf,
  fields = c("skipped", "dispatched", "completed", "errored", "canceled", "since"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_poll_+3A_interval">interval</code></td>
<td>
<p>Number of seconds to wait between iterations
of polling progress.</p>
</td></tr>
<tr><td><code id="tar_poll_+3A_timeout">timeout</code></td>
<td>
<p>How many seconds to run before exiting.</p>
</td></tr>
<tr><td><code id="tar_poll_+3A_fields">fields</code></td>
<td>
<p>Optional character vector of names of progress data
columns to read. Set to <code>NULL</code> to read all fields.</p>
</td></tr>
<tr><td><code id="tar_poll_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly). Called for its side effects.
</p>


<h3>See Also</h3>

<p>Other progress: 
<code><a href="#topic+tar_canceled">tar_canceled</a>()</code>,
<code><a href="#topic+tar_completed">tar_completed</a>()</code>,
<code><a href="#topic+tar_dispatched">tar_dispatched</a>()</code>,
<code><a href="#topic+tar_errored">tar_errored</a>()</code>,
<code><a href="#topic+tar_progress">tar_progress</a>()</code>,
<code><a href="#topic+tar_progress_branches">tar_progress_branches</a>()</code>,
<code><a href="#topic+tar_progress_summary">tar_progress_summary</a>()</code>,
<code><a href="#topic+tar_skipped">tar_skipped</a>()</code>,
<code><a href="#topic+tar_watch">tar_watch</a>()</code>,
<code><a href="#topic+tar_watch_server">tar_watch_server</a>()</code>,
<code><a href="#topic+tar_watch_ui">tar_watch_ui</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_INTERACTIVE_EXAMPLES"), "true")) {
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(100)),
    tar_target(y, Sys.sleep(0.1), pattern = map(x))
  )
}, ask = FALSE)
px &lt;- tar_make(callr_function = callr::r_bg, reporter = "silent")
tar_poll()
})
}
</code></pre>

<hr>
<h2 id='tar_process'>Get main process info.</h2><span id='topic+tar_process'></span>

<h3>Description</h3>

<p>Get info on the most recent main R process
to orchestrate the targets of the current project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_process(names = NULL, store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_process_+3A_names">names</code></td>
<td>
<p>Optional, names of the data points to return.
If supplied, <code>tar_process()</code>
returns only the rows of the names you select.
The object supplied to <code>names</code> should be <code>NULL</code> or a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_process_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main process is the R process invoked
by <code><a href="#topic+tar_make">tar_make()</a></code> or similar. If <code>callr_function</code> is not <code>NULL</code>,
this is an external process, and the <code>pid</code> in the return value
will not agree with <code>Sys.getpid()</code> in your current interactive session.
The process may or may not be alive. You may want to
check the status with <code>tar_pid() %in% ps::ps_pids()</code>
before running another call to <code><a href="#topic+tar_make">tar_make()</a></code>
for the same project.
</p>


<h3>Value</h3>

<p>A data frame with metadata on the most recent main R process
to orchestrate the targets of the current project.
The output includes the <code>pid</code> of the main process.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+tar_crew">tar_crew</a>()</code>,
<code><a href="#topic+tar_load">tar_load</a>()</code>,
<code><a href="#topic+tar_load_everything">tar_load_everything</a>()</code>,
<code><a href="#topic+tar_load_raw">tar_load_raw</a>()</code>,
<code><a href="#topic+tar_objects">tar_objects</a>()</code>,
<code><a href="#topic+tar_pid">tar_pid</a>()</code>,
<code><a href="#topic+tar_read">tar_read</a>()</code>,
<code><a href="#topic+tar_read_raw">tar_read_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(2)),
    tar_target(y, 2 * x, pattern = map(x))
  )
}, ask = FALSE)
tar_make()
tar_process()
tar_process(pid)
})
}
</code></pre>

<hr>
<h2 id='tar_progress'>Read progress.</h2><span id='topic+tar_progress'></span>

<h3>Description</h3>

<p>Read a project's target progress data for the most recent
run of <code><a href="#topic+tar_make">tar_make()</a></code> or similar. Only the most recent record is shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_progress(
  names = NULL,
  fields = "progress",
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_progress_+3A_names">names</code></td>
<td>
<p>Optional, names of the targets. If supplied, the
output is restricted to the selected targets.
The object supplied to <code>names</code> should be <code>NULL</code> or a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_progress_+3A_fields">fields</code></td>
<td>
<p>Optional, names of progress data columns to read.
Set to <code>NULL</code> to read all fields.</p>
</td></tr>
<tr><td><code id="tar_progress_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row per target and the following columns:
</p>

<ul>
<li> <p><code>name</code>: name of the target.
</p>
</li>
<li> <p><code>type</code>: type of target: <code>"stem"</code> for non-branching targets,
<code>"pattern"</code> for dynamically branching targets, and <code>"branch"</code>
for dynamic branches.
</p>
</li>
<li> <p><code>parent</code>: name of the target's parent. For branches, this is the
name of the associated pattern. For other targets, the pattern
is just itself.
</p>
</li>
<li> <p><code>branches</code>: number of dynamic branches of a pattern. 0 for non-patterns.
</p>
</li>
<li> <p><code>progress</code>: the most recent progress update of that target.
Could be <code>"dispatched"</code>, <code>"completed"</code>, &quot;<code>skipped</code>&quot;, <code>"canceled"</code>,
or <code>"errored"</code>. <code>"dispatched"</code> means the target was sent off
to be run, but in the case of <code>tar_make()</code> with a <code>crew</code> controller,
the target might not actually start running right away if the <code>crew</code>
workers are all busy.
</p>
</li></ul>



<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other progress: 
<code><a href="#topic+tar_canceled">tar_canceled</a>()</code>,
<code><a href="#topic+tar_completed">tar_completed</a>()</code>,
<code><a href="#topic+tar_dispatched">tar_dispatched</a>()</code>,
<code><a href="#topic+tar_errored">tar_errored</a>()</code>,
<code><a href="#topic+tar_poll">tar_poll</a>()</code>,
<code><a href="#topic+tar_progress_branches">tar_progress_branches</a>()</code>,
<code><a href="#topic+tar_progress_summary">tar_progress_summary</a>()</code>,
<code><a href="#topic+tar_skipped">tar_skipped</a>()</code>,
<code><a href="#topic+tar_watch">tar_watch</a>()</code>,
<code><a href="#topic+tar_watch_server">tar_watch_server</a>()</code>,
<code><a href="#topic+tar_watch_ui">tar_watch_ui</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(2)),
    tar_target(y, 2 * x, pattern = map(x))
  )
}, ask = FALSE)
tar_make()
tar_progress()
tar_progress(starts_with("y_")) # see also any_of()
})
}
</code></pre>

<hr>
<h2 id='tar_progress_branches'>Tabulate the progress of dynamic branches.</h2><span id='topic+tar_progress_branches'></span>

<h3>Description</h3>

<p>Read a project's target progress data for the most recent
run of the pipeline and display the tabulated status
of dynamic branches. Only the most recent record is shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_progress_branches(
  names = NULL,
  fields = NULL,
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_progress_branches_+3A_names">names</code></td>
<td>
<p>Optional, names of the targets. If supplied, <code>tar_progress()</code>
only returns progress information on these targets.
The object supplied to <code>names</code> should be <code>NULL</code> or a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_progress_branches_+3A_fields">fields</code></td>
<td>
<p>Optional, names of progress data columns to read.
Set to <code>NULL</code> to read all fields.</p>
</td></tr>
<tr><td><code id="tar_progress_branches_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row per target per progress status
and the following columns.
</p>

<ul>
<li> <p><code>name</code>: name of the pattern.
</p>
</li>
<li> <p><code>progress</code>: progress status: <code>"dispatched"</code>, <code>"completed"</code>,
<code>"cancelled"</code>, or <code>"errored"</code>.
</p>
</li>
<li> <p><code>branches</code>: number of branches in the progress category.
</p>
</li>
<li> <p><code>total</code>: total number of branches planned for the whole pattern.
Values within the same pattern should all be equal.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other progress: 
<code><a href="#topic+tar_canceled">tar_canceled</a>()</code>,
<code><a href="#topic+tar_completed">tar_completed</a>()</code>,
<code><a href="#topic+tar_dispatched">tar_dispatched</a>()</code>,
<code><a href="#topic+tar_errored">tar_errored</a>()</code>,
<code><a href="#topic+tar_poll">tar_poll</a>()</code>,
<code><a href="#topic+tar_progress">tar_progress</a>()</code>,
<code><a href="#topic+tar_progress_summary">tar_progress_summary</a>()</code>,
<code><a href="#topic+tar_skipped">tar_skipped</a>()</code>,
<code><a href="#topic+tar_watch">tar_watch</a>()</code>,
<code><a href="#topic+tar_watch_server">tar_watch_server</a>()</code>,
<code><a href="#topic+tar_watch_ui">tar_watch_ui</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(2)),
    tar_target(y, x, pattern = map(x)),
    tar_target(z, stopifnot(y &lt; 1.5), pattern = map(y))
  )
}, ask = FALSE)
try(tar_make())
tar_progress_branches()
})
}
</code></pre>

<hr>
<h2 id='tar_progress_summary'>Summarize target progress.</h2><span id='topic+tar_progress_summary'></span>

<h3>Description</h3>

<p>Summarize the progress of a run of the pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_progress_summary(
  fields = c("skipped", "dispatched", "completed", "errored", "canceled", "since"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_progress_summary_+3A_fields">fields</code></td>
<td>
<p>Optional character vector of names of progress data
columns to read. Set to <code>NULL</code> to read all fields.</p>
</td></tr>
<tr><td><code id="tar_progress_summary_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row and the following
optional columns that can be selected with <code>fields</code>.
(<code>time</code> is omitted by default.)
</p>

<ul>
<li> <p><code>dispatched</code>: number of targets that were sent off to run and
did not (yet) finish. These targets may not actually be running,
depending on the status and workload of parallel workers.
</p>
</li>
<li> <p><code>completed</code>: number of targets that completed without
error or cancellation.
</p>
</li>
<li> <p><code>errored</code>: number of targets that threw an error.
</p>
</li>
<li> <p><code>canceled</code>: number of canceled targets (see <code><a href="#topic+tar_cancel">tar_cancel()</a></code>).
</p>
</li>
<li> <p><code>since</code>: how long ago progress last changed (<code>Sys.time() - time</code>).
</p>
</li>
<li> <p><code>time</code>: the time when the progress last changed
(modification timestamp of the <code style="white-space: pre;">&#8288;_targets/meta/progress&#8288;</code> file).
</p>
</li></ul>



<h3>See Also</h3>

<p>Other progress: 
<code><a href="#topic+tar_canceled">tar_canceled</a>()</code>,
<code><a href="#topic+tar_completed">tar_completed</a>()</code>,
<code><a href="#topic+tar_dispatched">tar_dispatched</a>()</code>,
<code><a href="#topic+tar_errored">tar_errored</a>()</code>,
<code><a href="#topic+tar_poll">tar_poll</a>()</code>,
<code><a href="#topic+tar_progress">tar_progress</a>()</code>,
<code><a href="#topic+tar_progress_branches">tar_progress_branches</a>()</code>,
<code><a href="#topic+tar_skipped">tar_skipped</a>()</code>,
<code><a href="#topic+tar_watch">tar_watch</a>()</code>,
<code><a href="#topic+tar_watch_server">tar_watch_server</a>()</code>,
<code><a href="#topic+tar_watch_ui">tar_watch_ui</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(2)),
    tar_target(y, x, pattern = map(x)),
    tar_target(z, stopifnot(y &lt; 1.5), pattern = map(y), error = "continue")
  )
}, ask = FALSE)
try(tar_make())
tar_progress_summary()
})
}
</code></pre>

<hr>
<h2 id='tar_prune'>Remove targets that are no longer part of the pipeline.</h2><span id='topic+tar_prune'></span>

<h3>Description</h3>

<p>Remove target values from <code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code> and the cloud
and remove target metadata from <code style="white-space: pre;">&#8288;_targets/meta/meta&#8288;</code>
for targets that are no longer part of the pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_prune(
  cloud = TRUE,
  batch_size = 1000L,
  verbose = TRUE,
  callr_function = callr::r,
  callr_arguments = targets::tar_callr_args_default(callr_function),
  envir = parent.frame(),
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_prune_+3A_cloud">cloud</code></td>
<td>
<p>Logical of length 1, whether to delete objects
from the cloud if applicable (e.g. AWS, GCP). If <code>FALSE</code>,
files are not deleted from the cloud.</p>
</td></tr>
<tr><td><code id="tar_prune_+3A_batch_size">batch_size</code></td>
<td>
<p>Positive integer between 1 and 1000,
number of target objects to delete
from the cloud with each HTTP API request.
Currently only supported for AWS.
Cannot be more than 1000.</p>
</td></tr>
<tr><td><code id="tar_prune_+3A_verbose">verbose</code></td>
<td>
<p>Logical of length 1, whether to print console messages
to show progress when deleting each batch of targets from each
cloud bucket. Batched deletion with verbosity is currently only supported
for AWS.</p>
</td></tr>
<tr><td><code id="tar_prune_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_prune_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
<tr><td><code id="tar_prune_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_prune_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_prune_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_prune()</code> is useful if you recently worked through
multiple changes to your project and are now trying to
discard irrelevant data while keeping the results that still matter.
Global objects and local files with <code>format = "file"</code> outside the
data store are unaffected. Also removes <code style="white-space: pre;">&#8288;_targets/scratch/&#8288;</code>,
which is only needed while <code><a href="#topic+tar_make">tar_make()</a></code>, <code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code>,
or <code><a href="#topic+tar_make_future">tar_make_future()</a></code> is running. To list the targets that will be
pruned without actually removing anything, use <code><a href="#topic+tar_prune_list">tar_prune_list()</a></code>.
</p>


<h3>Value</h3>

<p><code>NULL</code> except if <code>callr_function</code> is <code>callr::r_bg</code>, in which case
a handle to the <code>callr</code> background process is returned. Either way,
the value is invisibly returned.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>Cloud target data versioning</h3>

<p>Some buckets in Amazon S3 or Google Cloud Storage are &quot;versioned&quot;,
which means they track historical versions of each data object.
If you use <code>targets</code> with cloud storage
(<a href="https://books.ropensci.org/targets/cloud-storage.html">https://books.ropensci.org/targets/cloud-storage.html</a>)
and versioning is turned on, then <code>targets</code> will record each
version of each target in its metadata.
</p>
<p>Functions like <code><a href="#topic+tar_read">tar_read()</a></code>
and <code><a href="#topic+tar_load">tar_load()</a></code> load the version recorded in the local metadata,
which may not be the same as the &quot;current&quot; version of the
object in the bucket. Likewise, functions <code><a href="#topic+tar_delete">tar_delete()</a></code>
and <code><a href="#topic+tar_destroy">tar_destroy()</a></code> only remove
the version ID of each target as recorded in the local
metadata.
</p>
<p>If you want to interact with the <em>latest</em> version of an object
instead of the version ID recorded in the local metadata,
then you will need to delete the object from the metadata.
</p>

<ol>
<li><p> Make sure your local copy of the metadata is current and
up to date. You may need to run <code><a href="#topic+tar_meta_download">tar_meta_download()</a></code> or
<code><a href="#topic+tar_meta_sync">tar_meta_sync()</a></code> first.
</p>
</li>
<li><p> Run <code><a href="#topic+tar_unversion">tar_unversion()</a></code> to remove the recorded version IDs of
your targets in the local metadata.
</p>
</li>
<li><p> With the version IDs gone from the local metadata,
functions like <code><a href="#topic+tar_read">tar_read()</a></code> and <code><a href="#topic+tar_destroy">tar_destroy()</a></code> will use the
<em>latest</em> version of each target data object.
</p>
</li>
<li><p> Optional: to back up the local metadata file with the version IDs
deleted, use <code><a href="#topic+tar_meta_upload">tar_meta_upload()</a></code>.
</p>
</li></ol>



<h3>See Also</h3>

<p>tar_prune_inspect
</p>
<p>Other clean: 
<code><a href="#topic+tar_delete">tar_delete</a>()</code>,
<code><a href="#topic+tar_destroy">tar_destroy</a>()</code>,
<code><a href="#topic+tar_invalidate">tar_invalidate</a>()</code>,
<code><a href="#topic+tar_prune_list">tar_prune_list</a>()</code>,
<code><a href="#topic+tar_unversion">tar_unversion</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(y1, 1 + 1),
    tar_target(y2, 1 + 1),
    tar_target(z, y1 + y2)
  )
}, ask = FALSE)
tar_make()
# Remove some targets from the pipeline.
tar_script(list(tar_target(y1, 1 + 1)), ask = FALSE)
# Keep only the remaining targets in the data store.
tar_prune()
})
}
</code></pre>

<hr>
<h2 id='tar_prune_list'>List targets that <code>tar_prune()</code> will remove.</h2><span id='topic+tar_prune_list'></span>

<h3>Description</h3>

<p>List the targets that <code><a href="#topic+tar_prune">tar_prune()</a></code> will remove. Does not
actually remove any targets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_prune_list(
  callr_function = callr::r,
  callr_arguments = targets::tar_callr_args_default(callr_function),
  envir = parent.frame(),
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_prune_list_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_prune_list_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
<tr><td><code id="tar_prune_list_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_prune_list_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_prune_list_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+tar_prune">tar_prune()</a></code> for details.
</p>


<h3>Value</h3>

<p>If <code>callr_function</code> is <code>callr::r_bg</code>, the return value is
a handle to the <code>callr</code> background process is returned.
Otherwise, the return value is a character vector of target names
identifying targets that <code><a href="#topic+tar_prune">tar_prune()</a></code> will remove.
</p>


<h3>See Also</h3>

<p>tar_prune
</p>
<p>Other clean: 
<code><a href="#topic+tar_delete">tar_delete</a>()</code>,
<code><a href="#topic+tar_destroy">tar_destroy</a>()</code>,
<code><a href="#topic+tar_invalidate">tar_invalidate</a>()</code>,
<code><a href="#topic+tar_prune">tar_prune</a>()</code>,
<code><a href="#topic+tar_unversion">tar_unversion</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(y1, 1 + 1),
    tar_target(y2, 1 + 1),
    tar_target(z, y1 + y2)
  )
}, ask = FALSE)
tar_make()
# Remove some targets from the pipeline.
tar_script(list(tar_target(y1, 1 + 1)), ask = FALSE)
# List targets that tar_prune() will remove.
tar_prune_list()
})
}
</code></pre>

<hr>
<h2 id='tar_random_port'>Random TCP port</h2><span id='topic+tar_random_port'></span>

<h3>Description</h3>

<p>Not a user-side function. Exported for infrastructure
purposes only.
</p>
<p>Not a user-side function. Exported for infrastructure
purposes only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_random_port(lower = 49152L, upper = 65355L)

tar_random_port(lower = 49152L, upper = 65355L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_random_port_+3A_lower">lower</code></td>
<td>
<p>Integer of length 1, lowest possible port.</p>
</td></tr>
<tr><td><code id="tar_random_port_+3A_upper">upper</code></td>
<td>
<p>Integer of length 1, highest possible port.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A random port not likely to be used by another process.
</p>
<p>A random port not likely to be used by another process.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("parallelly", quietly = TRUE)) {
tar_random_port()
}
if (requireNamespace("parallelly", quietly = TRUE)) {
tar_random_port()
}
</code></pre>

<hr>
<h2 id='tar_read'>Read a target's value from storage.</h2><span id='topic+tar_read'></span>

<h3>Description</h3>

<p>Read a target's return value from its file in
<code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code>. For dynamic files (i.e. <code>format = "file"</code>)
the paths are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_read(
  name,
  branches = NULL,
  meta = tar_meta(store = store),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_read_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target to read.</p>
</td></tr>
<tr><td><code id="tar_read_+3A_branches">branches</code></td>
<td>
<p>Integer of indices of the branches to load
if the target is a pattern.</p>
</td></tr>
<tr><td><code id="tar_read_+3A_meta">meta</code></td>
<td>
<p>Data frame of metadata from <code><a href="#topic+tar_meta">tar_meta()</a></code>.
<code>tar_read()</code> with the default arguments can be inefficient for large
pipelines because all the metadata is stored in a single file.
However, if you call <code><a href="#topic+tar_meta">tar_meta()</a></code> beforehand and supply it to the <code>meta</code>
argument, then successive calls to <code>tar_read()</code> may run much faster.</p>
</td></tr>
<tr><td><code id="tar_read_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The target's return value from its file in
<code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code>, or the paths to the custom files and directories
if <code>format = "file"</code> was set.
</p>


<h3>Cloud target data versioning</h3>

<p>Some buckets in Amazon S3 or Google Cloud Storage are &quot;versioned&quot;,
which means they track historical versions of each data object.
If you use <code>targets</code> with cloud storage
(<a href="https://books.ropensci.org/targets/cloud-storage.html">https://books.ropensci.org/targets/cloud-storage.html</a>)
and versioning is turned on, then <code>targets</code> will record each
version of each target in its metadata.
</p>
<p>Functions like <code><a href="#topic+tar_read">tar_read()</a></code>
and <code><a href="#topic+tar_load">tar_load()</a></code> load the version recorded in the local metadata,
which may not be the same as the &quot;current&quot; version of the
object in the bucket. Likewise, functions <code><a href="#topic+tar_delete">tar_delete()</a></code>
and <code><a href="#topic+tar_destroy">tar_destroy()</a></code> only remove
the version ID of each target as recorded in the local
metadata.
</p>
<p>If you want to interact with the <em>latest</em> version of an object
instead of the version ID recorded in the local metadata,
then you will need to delete the object from the metadata.
</p>

<ol>
<li><p> Make sure your local copy of the metadata is current and
up to date. You may need to run <code><a href="#topic+tar_meta_download">tar_meta_download()</a></code> or
<code><a href="#topic+tar_meta_sync">tar_meta_sync()</a></code> first.
</p>
</li>
<li><p> Run <code><a href="#topic+tar_unversion">tar_unversion()</a></code> to remove the recorded version IDs of
your targets in the local metadata.
</p>
</li>
<li><p> With the version IDs gone from the local metadata,
functions like <code><a href="#topic+tar_read">tar_read()</a></code> and <code><a href="#topic+tar_destroy">tar_destroy()</a></code> will use the
<em>latest</em> version of each target data object.
</p>
</li>
<li><p> Optional: to back up the local metadata file with the version IDs
deleted, use <code><a href="#topic+tar_meta_upload">tar_meta_upload()</a></code>.
</p>
</li></ol>



<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+tar_crew">tar_crew</a>()</code>,
<code><a href="#topic+tar_load">tar_load</a>()</code>,
<code><a href="#topic+tar_load_everything">tar_load_everything</a>()</code>,
<code><a href="#topic+tar_load_raw">tar_load_raw</a>()</code>,
<code><a href="#topic+tar_objects">tar_objects</a>()</code>,
<code><a href="#topic+tar_pid">tar_pid</a>()</code>,
<code><a href="#topic+tar_process">tar_process</a>()</code>,
<code><a href="#topic+tar_read_raw">tar_read_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(list(tar_target(x, 1 + 1)), ask = FALSE)
tar_make()
tar_read(x)
})
}
</code></pre>

<hr>
<h2 id='tar_read_raw'>Read a target's value from storage (raw version)</h2><span id='topic+tar_read_raw'></span>

<h3>Description</h3>

<p>Like <code><a href="#topic+tar_read">tar_read()</a></code> except <code>name</code> is a character string.
Do not use in <code>knitr</code> or R Markdown reports with <code>tarchetypes::tar_knit()</code>
or <code>tarchetypes::tar_render()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_read_raw(
  name,
  branches = NULL,
  meta = tar_meta(store = store),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_read_raw_+3A_name">name</code></td>
<td>
<p>Character, name of the target to read.</p>
</td></tr>
<tr><td><code id="tar_read_raw_+3A_branches">branches</code></td>
<td>
<p>Integer of indices of the branches to load
if the target is a pattern.</p>
</td></tr>
<tr><td><code id="tar_read_raw_+3A_meta">meta</code></td>
<td>
<p>Data frame of metadata from <code><a href="#topic+tar_meta">tar_meta()</a></code>.
<code>tar_read()</code> with the default arguments can be inefficient for large
pipelines because all the metadata is stored in a single file.
However, if you call <code><a href="#topic+tar_meta">tar_meta()</a></code> beforehand and supply it to the <code>meta</code>
argument, then successive calls to <code>tar_read()</code> may run much faster.</p>
</td></tr>
<tr><td><code id="tar_read_raw_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The target's return value from its file in
<code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code>, or the paths to the custom files and directories
if <code>format = "file"</code> was set.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>Cloud target data versioning</h3>

<p>Some buckets in Amazon S3 or Google Cloud Storage are &quot;versioned&quot;,
which means they track historical versions of each data object.
If you use <code>targets</code> with cloud storage
(<a href="https://books.ropensci.org/targets/cloud-storage.html">https://books.ropensci.org/targets/cloud-storage.html</a>)
and versioning is turned on, then <code>targets</code> will record each
version of each target in its metadata.
</p>
<p>Functions like <code><a href="#topic+tar_read">tar_read()</a></code>
and <code><a href="#topic+tar_load">tar_load()</a></code> load the version recorded in the local metadata,
which may not be the same as the &quot;current&quot; version of the
object in the bucket. Likewise, functions <code><a href="#topic+tar_delete">tar_delete()</a></code>
and <code><a href="#topic+tar_destroy">tar_destroy()</a></code> only remove
the version ID of each target as recorded in the local
metadata.
</p>
<p>If you want to interact with the <em>latest</em> version of an object
instead of the version ID recorded in the local metadata,
then you will need to delete the object from the metadata.
</p>

<ol>
<li><p> Make sure your local copy of the metadata is current and
up to date. You may need to run <code><a href="#topic+tar_meta_download">tar_meta_download()</a></code> or
<code><a href="#topic+tar_meta_sync">tar_meta_sync()</a></code> first.
</p>
</li>
<li><p> Run <code><a href="#topic+tar_unversion">tar_unversion()</a></code> to remove the recorded version IDs of
your targets in the local metadata.
</p>
</li>
<li><p> With the version IDs gone from the local metadata,
functions like <code><a href="#topic+tar_read">tar_read()</a></code> and <code><a href="#topic+tar_destroy">tar_destroy()</a></code> will use the
<em>latest</em> version of each target data object.
</p>
</li>
<li><p> Optional: to back up the local metadata file with the version IDs
deleted, use <code><a href="#topic+tar_meta_upload">tar_meta_upload()</a></code>.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other data: 
<code><a href="#topic+tar_crew">tar_crew</a>()</code>,
<code><a href="#topic+tar_load">tar_load</a>()</code>,
<code><a href="#topic+tar_load_everything">tar_load_everything</a>()</code>,
<code><a href="#topic+tar_load_raw">tar_load_raw</a>()</code>,
<code><a href="#topic+tar_objects">tar_objects</a>()</code>,
<code><a href="#topic+tar_pid">tar_pid</a>()</code>,
<code><a href="#topic+tar_process">tar_process</a>()</code>,
<code><a href="#topic+tar_read">tar_read</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(list(tar_target(x, 1 + 1)), ask = FALSE)
tar_make()
tar_read_raw("x")
})
}
</code></pre>

<hr>
<h2 id='tar_renv'>Set up package dependencies for compatibility with <code>renv</code></h2><span id='topic+tar_renv'></span>

<h3>Description</h3>

<p>Write package dependencies to a script file
(by default, named <code style="white-space: pre;">&#8288;_targets_packages.R&#8288;</code> in the root project directory).
Each package is written to a separate line
as a standard <code><a href="base.html#topic+library">library()</a></code> call (e.g. <code>library(package)</code>) so
<code>renv</code> can identify them automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_renv(
  extras = c("bs4Dash", "crew", "gt", "markdown", "pingr", "rstudioapi", "shiny",
    "shinybusy", "shinyWidgets", "visNetwork"),
  path = "_targets_packages.R",
  callr_function = callr::r,
  callr_arguments = targets::tar_callr_args_default(callr_function),
  envir = parent.frame(),
  script = targets::tar_config_get("script")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_renv_+3A_extras">extras</code></td>
<td>
<p>Character vector of additional packages to declare as
project dependencies.</p>
</td></tr>
<tr><td><code id="tar_renv_+3A_path">path</code></td>
<td>
<p>Character of length 1, path to the script file to
populate with <code>library()</code> calls.</p>
</td></tr>
<tr><td><code id="tar_renv_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_renv_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
<tr><td><code id="tar_renv_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_renv_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gets called for its side-effect, which writes
package dependencies to a script for compatibility with <code>renv</code>.
The generated file should <strong>not</strong> be edited by hand and will be
overwritten each time <code>tar_renv()</code> is called.
</p>
<p>The behavior of <code>renv</code> is to create and manage a project-local <code>R</code> library
and keep a record of project dependencies in a file called <code>renv.lock</code>.
To identify dependencies, <code>renv</code> crawls through code to find packages
explicitly mentioned using <code>library()</code>, <code>require()</code>, or <code>::</code>.
However, <code>targets</code> manages packages in a way that hides dependencies
from <code>renv.</code> <code>tar_renv()</code> finds package dependencies that would be
otherwise hidden to <code>renv</code> because they are declared using the <code>targets</code>
API. Thus, calling <code>tar_renv</code> this is only necessary if using
<code><a href="#topic+tar_option_set">tar_option_set()</a></code> or <code><a href="#topic+tar_target">tar_target()</a></code> to use specialized storage
formats or manage packages.
</p>
<p>With the script written by <code>tar_renv()</code>, <code>renv</code> is able to crawl the
file to identify package dependencies (with <code>renv::dependencies()</code>).
<code>tar_renv()</code> only serves to make your <code>targets</code> project compatible with
<code>renv</code>, it is still the users responsibility to call <code>renv::init()</code> and
<code>renv::snapshot()</code> directly to initialize and manage a
project-local <code>R</code> library. This allows your <code>targets</code> pipeline to have
its own self-contained <code>R</code> library separate from your standard <code>R</code>
library. See <a href="https://rstudio.github.io/renv/index.html">https://rstudio.github.io/renv/index.html</a> for
more information.
</p>


<h3>Value</h3>

<p>Nothing, invisibly.
</p>


<h3>Performance</h3>

<p>If you use <code>renv</code>, then overhead from project initialization
could slow down <code><a href="#topic+tar_make">tar_make()</a></code> and friends.
If you experience slowness, please make sure your <code>renv</code> library
is on a fast file system.
(For example, slow network drives can severely reduce performance.)
In addition, you can disable the slowest <code>renv</code> initialization checks.
After confirming at
<a href="https://rstudio.github.io/renv/reference/config.html">https://rstudio.github.io/renv/reference/config.html</a>
that you can safely disable these checks,
you can write lines <code>RENV_CONFIG_RSPM_ENABLED=false</code>,
<code>RENV_CONFIG_SANDBOX_ENABLED=false</code>,
and <code>RENV_CONFIG_SYNCHRONIZED_CHECK=false</code>
in your user-level <code>.Renviron</code> file. If you disable the synchronization
check, remember to call <code>renv::status()</code> periodically
to check the health of your <code>renv</code> project library.
</p>


<h3>See Also</h3>

<p><a href="https://rstudio.github.io/renv/articles/renv.html">https://rstudio.github.io/renv/articles/renv.html</a>
</p>
<p>Other scripts: 
<code><a href="#topic+tar_edit">tar_edit</a>()</code>,
<code><a href="#topic+tar_github_actions">tar_github_actions</a>()</code>,
<code><a href="#topic+tar_helper">tar_helper</a>()</code>,
<code><a href="#topic+tar_helper_raw">tar_helper_raw</a>()</code>,
<code><a href="#topic+tar_script">tar_script</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
  tar_script({
    tar_option_set(packages = c("tibble", "qs"))
    list()
  }, ask = FALSE)
  tar_renv()
  writeLines(readLines("_targets_packages.R"))
})
tar_option_reset()
</code></pre>

<hr>
<h2 id='tar_reprex'>Reproducible example of <code>targets</code> with <code>reprex</code></h2><span id='topic+tar_reprex'></span>

<h3>Description</h3>

<p>Create a reproducible example of a <code>targets</code>
pipeline with the <code>reprex</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_reprex(pipeline = tar_target(example_target, 1), run = tar_make(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_reprex_+3A_pipeline">pipeline</code></td>
<td>
<p>R code for the target script file <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>.
<code>library(targets)</code> is automatically written at the top.</p>
</td></tr>
<tr><td><code id="tar_reprex_+3A_run">run</code></td>
<td>
<p>R code to inspect and run the pipeline.</p>
</td></tr>
<tr><td><code id="tar_reprex_+3A_...">...</code></td>
<td>
<p>Named arguments passed to <code>reprex::reprex()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The best way to get help with an issue is to
create a reproducible example of the problem
and post it to <a href="https://github.com/ropensci/targets/discussions">https://github.com/ropensci/targets/discussions</a>
<code>tar_reprex()</code> facilitates this process. It is like
<code>reprex::reprex({targets::tar_script(...); tar_make()})</code>,
but more convenient.
</p>


<h3>Value</h3>

<p>A character vector of rendered the reprex, invisibly.
</p>


<h3>See Also</h3>

<p>Other help: 
<code><a href="#topic+targets-package">targets-package</a></code>,
<code><a href="#topic+use_targets">use_targets</a>()</code>,
<code><a href="#topic+use_targets_rmd">use_targets_rmd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_INTERACTIVE_EXAMPLES"), "true")) {
tar_reprex(
  pipeline = {
    list(
      tar_target(data, data.frame(x = sample.int(1e3))),
      tar_target(summary, mean(data$x, na.rm = TRUE))
    )
  },
  run = {
    tar_visnetwork()
    tar_make()
  }
)
}
</code></pre>

<hr>
<h2 id='tar_resources'>Target resources</h2><span id='topic+tar_resources'></span>

<h3>Description</h3>

<p>Create a <code>resources</code> argument for <code><a href="#topic+tar_target">tar_target()</a></code>
or <code><a href="#topic+tar_option_set">tar_option_set()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_resources(
  aws = tar_option_get("resources")$aws,
  clustermq = tar_option_get("resources")$clustermq,
  crew = tar_option_get("resources")$crew,
  feather = tar_option_get("resources")$feather,
  fst = tar_option_get("resources")$fst,
  future = tar_option_get("resources")$future,
  gcp = tar_option_get("resources")$gcp,
  network = tar_option_get("resources")$network,
  parquet = tar_option_get("resources")$parquet,
  qs = tar_option_get("resources")$qs,
  url = tar_option_get("resources")$url
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_resources_+3A_aws">aws</code></td>
<td>
<p>Output of function <code>tar_resources_aws()</code>.
Amazon Web Services (AWS) S3 storage settings for
<code>tar_target(..., repository = "aws")</code>.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.</p>
</td></tr>
<tr><td><code id="tar_resources_+3A_clustermq">clustermq</code></td>
<td>
<p>Output of function <code>tar_resources_clustermq()</code>.
Optional <code>clustermq</code> settings for <code>tar_make_clustermq()</code>,
including the <code>log_worker</code> and <code>template</code> arguments of
<code>clustermq::workers()</code>. <code>clustermq</code> workers are <em>persistent</em>,
so there is not a one-to-one correspondence between workers and targets.
The <code>clustermq</code> resources apply to the workers, not the targets.
So the correct way to assign <code>clustermq</code> resources is through
<code><a href="#topic+tar_option_set">tar_option_set()</a></code>, not <code><a href="#topic+tar_target">tar_target()</a></code>. <code>clustermq</code> resources
in individual <code><a href="#topic+tar_target">tar_target()</a></code> calls will be ignored.</p>
</td></tr>
<tr><td><code id="tar_resources_+3A_crew">crew</code></td>
<td>
<p>Output of function <code>tar_resources_crew()</code>
with target-specific settings for integration with the
<code>crew</code> R package. These settings are arguments to the <code>push()</code>
method of the controller or controller group
object which control things like
auto-scaling behavior and the controller to use in the case
of a controller group.</p>
</td></tr>
<tr><td><code id="tar_resources_+3A_feather">feather</code></td>
<td>
<p>Output of function <code>tar_resources_feather()</code>.
Non-default arguments to <code>arrow::read_feather()</code> and
<code>arrow::write_feather()</code> for <code>arrow</code>/feather-based storage formats.
Applies to all formats ending with the <code>"_feather"</code> suffix.
For details on formats, see the <code>format</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_resources_+3A_fst">fst</code></td>
<td>
<p>Output of function <code>tar_resources_fst()</code>.
Non-default arguments to <code>fst::read_fst()</code> and
<code>fst::write_fst()</code> for <code>fst</code>-based storage formats.
Applies to all formats ending with <code>"fst"</code> in the name.
For details on formats, see the <code>format</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_resources_+3A_future">future</code></td>
<td>
<p>Output of function <code>tar_resources_future()</code>.
Optional <code>future</code> settings for <code>tar_make_future()</code>,
including the <code>resources</code> argument of
<code>future::future()</code>, which can include values to insert in
template placeholders in <code>future.batchtools</code> template files.
This is how to supply the <code>resources</code>
argument of <code>future::future()</code> for <code>targets</code>.
Resources supplied through
<code>future::plan()</code> and <code>future::tweak()</code> are completely ignored.</p>
</td></tr>
<tr><td><code id="tar_resources_+3A_gcp">gcp</code></td>
<td>
<p>Output of function <code>tar_resources_gcp()</code>.
Google Cloud Storage bucket settings for
<code>tar_target(..., repository = "gcp")</code>.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.</p>
</td></tr>
<tr><td><code id="tar_resources_+3A_network">network</code></td>
<td>
<p>Output of function <code>tar_resources_network()</code>.
Settings to configure how to handle unreliable network connections
in the case of uploading, downloading, and checking data
in situations that rely on network file systems or HTTP/HTTPS requests.
Examples include retries and timeouts for internal storage management
operations for <code>storage = "worker"</code> or <code>format = "file"</code>
(on network file systems),
<code>format = "url"</code>, <code>repository = "aws"</code>, and
<code>repository = "gcp"</code>. These settings do not
apply to actions you take in the custom R command of the target.</p>
</td></tr>
<tr><td><code id="tar_resources_+3A_parquet">parquet</code></td>
<td>
<p>Output of function <code>tar_resources_parquet()</code>.
Non-default arguments to <code>arrow::read_parquet()</code> and
<code>arrow::write_parquet()</code> for <code>arrow</code>/parquet-based storage formats.
Applies to all formats ending with the <code>"_parquet"</code> suffix.
For details on formats, see the <code>format</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_resources_+3A_qs">qs</code></td>
<td>
<p>Output of function <code>tar_resources_qs()</code>.
Non-default arguments to <code>qs::qread()</code> and
<code>qs::qsave()</code> for <code>qs</code>-based storage formats.
Applies to all formats ending with the <code>"_qs"</code> suffix.
For details on formats, see the <code>format</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_resources_+3A_url">url</code></td>
<td>
<p>Output of function <code>tar_resources_url()</code>.
Non-default settings for storage formats ending with the <code>"_url"</code> suffix.
These settings include the <code>curl</code> handle for extra control over HTTP
requests. For details on formats, see the <code>format</code> argument of
<code><a href="#topic+tar_target">tar_target()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of objects of class <code>"tar_resources"</code> with
non-default settings of various optional backends for data storage
and high-performance computing.
</p>


<h3>Resources</h3>

<p>Functions <code><a href="#topic+tar_target">tar_target()</a></code> and <code><a href="#topic+tar_option_set">tar_option_set()</a></code>
each takes an optional <code>resources</code> argument to supply
non-default settings of various optional backends for data storage
and high-performance computing. The <code>tar_resources()</code> function
is a helper to supply those settings in the correct manner.
</p>
<p>In <code>targets</code> version 0.12.2 and above, resources are inherited one-by-one
in nested fashion from <code>tar_option_get("resources")</code>.
For example, suppose you set
<code>tar_option_set(resources = tar_resources(aws = my_aws))</code>,
where <code>my_aws</code> equals <code>tar_resources_aws(bucket = "x", prefix = "y")</code>.
Then, <code style="white-space: pre;">&#8288;tar_target(data, get_data()&#8288;</code> will have bucket <code>"x"</code> and
prefix <code>"y"</code>. In addition, if <code>new_resources</code> equals
<code style="white-space: pre;">&#8288;tar_resources(aws = tar_resources_aws(bucket = "z")))&#8288;</code>, then
<code>tar_target(data, get_data(), resources = new_resources)</code>
will use the new bucket <code>"z"</code>, but it will still use the prefix <code>"y"</code>
supplied through <code>tar_option_set()</code>. (In <code>targets</code> 0.12.1 and below,
options like <code>prefix</code> do not carry over from <code>tar_option_set()</code> if you
supply non-default resources to <code>tar_target()</code>.)
</p>


<h3>See Also</h3>

<p>Other resources: 
<code><a href="#topic+tar_resources_aws">tar_resources_aws</a>()</code>,
<code><a href="#topic+tar_resources_clustermq">tar_resources_clustermq</a>()</code>,
<code><a href="#topic+tar_resources_crew">tar_resources_crew</a>()</code>,
<code><a href="#topic+tar_resources_feather">tar_resources_feather</a>()</code>,
<code><a href="#topic+tar_resources_fst">tar_resources_fst</a>()</code>,
<code><a href="#topic+tar_resources_future">tar_resources_future</a>()</code>,
<code><a href="#topic+tar_resources_gcp">tar_resources_gcp</a>()</code>,
<code><a href="#topic+tar_resources_network">tar_resources_network</a>()</code>,
<code><a href="#topic+tar_resources_parquet">tar_resources_parquet</a>()</code>,
<code><a href="#topic+tar_resources_qs">tar_resources_qs</a>()</code>,
<code><a href="#topic+tar_resources_url">tar_resources_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Somewhere in you target script file (usually _targets.R):
tar_target(
  name,
  command(),
  format = "qs",
  resources = tar_resources(
    qs = tar_resources_qs(preset = "fast"),
    future = tar_resources_future(resources = list(n_cores = 1))
  )
)
</code></pre>

<hr>
<h2 id='tar_resources_aws'>Target resources: Amazon Web Services (AWS) S3 storage</h2><span id='topic+tar_resources_aws'></span>

<h3>Description</h3>

<p>Create the <code>aws</code> argument of <code>tar_resources()</code>
to specify optional settings to AWS for
<code>tar_target(..., repository = "aws")</code>.
See the <code>format</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_resources_aws(
  bucket = targets::tar_option_get("resources")$aws$bucket,
  prefix = targets::tar_option_get("resources")$aws$prefix,
  region = targets::tar_option_get("resources")$aws$region,
  endpoint = targets::tar_option_get("resources")$aws$endpoint,
  s3_force_path_style = targets::tar_option_get("resources")$aws$s3_force_path_style,
  part_size = targets::tar_option_get("resources")$aws$part_size,
  page_size = targets::tar_option_get("resources")$aws$page_size,
  max_tries = targets::tar_option_get("resources")$aws$max_tries,
  seconds_timeout = targets::tar_option_get("resources")$aws$seconds_timeout,
  close_connection = targets::tar_option_get("resources")$aws$close_connection,
  verbose = targets::tar_option_get("resources")$aws$verbose,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_resources_aws_+3A_bucket">bucket</code></td>
<td>
<p>Character of length 1, name of an existing
bucket to upload and download the return values
of the affected targets during the pipeline.</p>
</td></tr>
<tr><td><code id="tar_resources_aws_+3A_prefix">prefix</code></td>
<td>
<p>Character of length 1, &quot;directory path&quot;
in the bucket where your target object and metadata will go.
Please supply an explicit prefix
unique to your <code>targets</code> project.
In the future, <code>targets</code> will begin requiring
explicitly user-supplied prefixes. (This last note
was added on 2023-08-24: <code>targets</code> version 1.2.2.9000.)</p>
</td></tr>
<tr><td><code id="tar_resources_aws_+3A_region">region</code></td>
<td>
<p>Character of length 1, AWS region containing the S3 bucket.
Set to <code>NULL</code> to use the default region.</p>
</td></tr>
<tr><td><code id="tar_resources_aws_+3A_endpoint">endpoint</code></td>
<td>
<p>Character of length 1, URL endpoint for S3 storage.
Defaults to the Amazon AWS endpoint if <code>NULL</code>. Example:
To use the S3 protocol with Google Cloud Storage,
set <code>endpoint = "https://storage.googleapis.com"</code>
and <code>region = "auto"</code>. (A custom endpoint may require that you
explicitly set a custom region directly in <code>tar_resources_aws()</code>.
<code>region = "auto"</code> happens to work with Google Cloud.)
Also make sure to create
HMAC access keys in the Google Cloud Storage console
(under Settings =&gt; Interoperability) and set the
<code>AWS_ACCESS_KEY_ID</code> and <code>AWS_SECRET_ACCESS_KEY</code> environment
variables accordingly. After that, you should be able to use
S3 storage formats with Google Cloud storage buckets.
There is one limitation, however: even if your bucket has
object versioning turned on, <code>targets</code> may fail to record object
versions. Google Cloud Storage in particular has this
incompatibility.</p>
</td></tr>
<tr><td><code id="tar_resources_aws_+3A_s3_force_path_style">s3_force_path_style</code></td>
<td>
<p>Logical of length 1, whether to use path-style
addressing for S3 requests.</p>
</td></tr>
<tr><td><code id="tar_resources_aws_+3A_part_size">part_size</code></td>
<td>
<p>Positive numeric of length 1, number of bytes
for each part of a multipart upload. (Except the last part,
which is the remainder.) In a multipart upload, each part
must be at least 5 MB. The default value of the <code>part_size</code>
argument is <code>5 * (2 ^ 20)</code>.</p>
</td></tr>
<tr><td><code id="tar_resources_aws_+3A_page_size">page_size</code></td>
<td>
<p>Positive integer of length 1, number of items in each
page for paginated HTTP requests such as listing objects.</p>
</td></tr>
<tr><td><code id="tar_resources_aws_+3A_max_tries">max_tries</code></td>
<td>
<p>Positive integer of length 1, maximum number of attempts
to access a network resource on AWS.</p>
</td></tr>
<tr><td><code id="tar_resources_aws_+3A_seconds_timeout">seconds_timeout</code></td>
<td>
<p>Positive numeric of length 1,
number of seconds until an HTTP connection times out.</p>
</td></tr>
<tr><td><code id="tar_resources_aws_+3A_close_connection">close_connection</code></td>
<td>
<p>Logical of length 1, whether to close HTTP
connections immediately.</p>
</td></tr>
<tr><td><code id="tar_resources_aws_+3A_verbose">verbose</code></td>
<td>
<p>Logical of length 1, whether to print console messages
when running computationally expensive operations such as listing
objects in a large bucket.</p>
</td></tr>
<tr><td><code id="tar_resources_aws_+3A_...">...</code></td>
<td>
<p>Named arguments to functions in <code>paws.storage::s3()</code> to manage
S3 storage. The documentation of these specific functions
is linked from <code style="white-space: pre;">&#8288;https://www.paws-r-sdk.com/docs/s3/&#8288;</code>.
The configurable functions themselves are:
</p>

<ul>
<li> <p><code>paws.storage::s3()$head_object()</code>
</p>
</li>
<li> <p><code>paws.storage::s3()$get_object()</code>
</p>
</li>
<li> <p><code>paws.storage::s3()$delete_object()</code>
</p>
</li>
<li> <p><code>paws.storage::s3()$put_object()</code>
</p>
</li>
<li> <p><code>paws.storage::s3()$create_multipart_upload()</code>
</p>
</li>
<li> <p><code>paws.storage::s3()$abort_multipart_upload()</code>
</p>
</li>
<li> <p><code>paws.storage::s3()$complete_multipart_upload()</code>
</p>
</li>
<li> <p><code>paws.storage::s3()$upload_part()</code>
The named arguments in <code>...</code> must not be any of
<code>"bucket"</code>, <code>"Bucket"</code>, <code>"key"</code>, <code>"Key"</code>,
<code>"prefix"</code>, <code>"region"</code>, <code>"part_size"</code>, <code>"endpoint"</code>,
<code>"version"</code>, <code>"VersionId"</code>, <code>"body"</code>, <code>"Body"</code>,
<code>"metadata"</code>, <code>"Metadata"</code>, <code>"UploadId"</code>, <code>"MultipartUpload"</code>,
or <code>"PartNumber"</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>


<h3>Value</h3>

<p>Object of class <code>"tar_resources_aws"</code>, to be supplied
to the <code>aws</code> argument of <code>tar_resources()</code>.
</p>


<h3>Resources</h3>

<p>Functions <code><a href="#topic+tar_target">tar_target()</a></code> and <code><a href="#topic+tar_option_set">tar_option_set()</a></code>
each takes an optional <code>resources</code> argument to supply
non-default settings of various optional backends for data storage
and high-performance computing. The <code>tar_resources()</code> function
is a helper to supply those settings in the correct manner.
</p>
<p>In <code>targets</code> version 0.12.2 and above, resources are inherited one-by-one
in nested fashion from <code>tar_option_get("resources")</code>.
For example, suppose you set
<code>tar_option_set(resources = tar_resources(aws = my_aws))</code>,
where <code>my_aws</code> equals <code>tar_resources_aws(bucket = "x", prefix = "y")</code>.
Then, <code style="white-space: pre;">&#8288;tar_target(data, get_data()&#8288;</code> will have bucket <code>"x"</code> and
prefix <code>"y"</code>. In addition, if <code>new_resources</code> equals
<code style="white-space: pre;">&#8288;tar_resources(aws = tar_resources_aws(bucket = "z")))&#8288;</code>, then
<code>tar_target(data, get_data(), resources = new_resources)</code>
will use the new bucket <code>"z"</code>, but it will still use the prefix <code>"y"</code>
supplied through <code>tar_option_set()</code>. (In <code>targets</code> 0.12.1 and below,
options like <code>prefix</code> do not carry over from <code>tar_option_set()</code> if you
supply non-default resources to <code>tar_target()</code>.)
</p>


<h3>See Also</h3>

<p>Other resources: 
<code><a href="#topic+tar_resources">tar_resources</a>()</code>,
<code><a href="#topic+tar_resources_clustermq">tar_resources_clustermq</a>()</code>,
<code><a href="#topic+tar_resources_crew">tar_resources_crew</a>()</code>,
<code><a href="#topic+tar_resources_feather">tar_resources_feather</a>()</code>,
<code><a href="#topic+tar_resources_fst">tar_resources_fst</a>()</code>,
<code><a href="#topic+tar_resources_future">tar_resources_future</a>()</code>,
<code><a href="#topic+tar_resources_gcp">tar_resources_gcp</a>()</code>,
<code><a href="#topic+tar_resources_network">tar_resources_network</a>()</code>,
<code><a href="#topic+tar_resources_parquet">tar_resources_parquet</a>()</code>,
<code><a href="#topic+tar_resources_qs">tar_resources_qs</a>()</code>,
<code><a href="#topic+tar_resources_url">tar_resources_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Somewhere in you target script file (usually _targets.R):
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_target(
  name,
  command(),
  format = "qs",
  repository = "aws",
  resources = tar_resources(
    aws = tar_resources_aws(bucket = "yourbucketname"),
    qs = tar_resources_qs(preset = "fast")
  )
)
}
</code></pre>

<hr>
<h2 id='tar_resources_clustermq'>Target resources: <code>clustermq</code> high-performance computing</h2><span id='topic+tar_resources_clustermq'></span>

<h3>Description</h3>

<p>Create the <code>clustermq</code> argument of <code>tar_resources()</code>
to specify optional high-performance computing settings
for <code>tar_make_clustermq()</code>.
For details, see the documentation of the <code>clustermq</code> R package
and the corresponding argument names in this help file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_resources_clustermq(
  template = targets::tar_option_get("resources")$clustermq$template
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_resources_clustermq_+3A_template">template</code></td>
<td>
<p>Named list, <code>template</code> argument to
<code>clustermq::workers()</code>. Defaults to an empty list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>clustermq</code> workers are <em>persistent</em>,
so there is not a one-to-one correspondence between workers and targets.
The <code>clustermq</code> resources apply to the workers, not the targets.
So the correct way to assign <code>clustermq</code> resources is through
<code><a href="#topic+tar_option_set">tar_option_set()</a></code>, not <code><a href="#topic+tar_target">tar_target()</a></code>. <code>clustermq</code> resources
in individual <code><a href="#topic+tar_target">tar_target()</a></code> calls will be ignored.
</p>


<h3>Value</h3>

<p>Object of class <code>"tar_resources_clustermq"</code>, to be supplied
to the <code>clustermq</code> argument of <code>tar_resources()</code>.
</p>


<h3>Resources</h3>

<p>Functions <code><a href="#topic+tar_target">tar_target()</a></code> and <code><a href="#topic+tar_option_set">tar_option_set()</a></code>
each takes an optional <code>resources</code> argument to supply
non-default settings of various optional backends for data storage
and high-performance computing. The <code>tar_resources()</code> function
is a helper to supply those settings in the correct manner.
</p>
<p>In <code>targets</code> version 0.12.2 and above, resources are inherited one-by-one
in nested fashion from <code>tar_option_get("resources")</code>.
For example, suppose you set
<code>tar_option_set(resources = tar_resources(aws = my_aws))</code>,
where <code>my_aws</code> equals <code>tar_resources_aws(bucket = "x", prefix = "y")</code>.
Then, <code style="white-space: pre;">&#8288;tar_target(data, get_data()&#8288;</code> will have bucket <code>"x"</code> and
prefix <code>"y"</code>. In addition, if <code>new_resources</code> equals
<code style="white-space: pre;">&#8288;tar_resources(aws = tar_resources_aws(bucket = "z")))&#8288;</code>, then
<code>tar_target(data, get_data(), resources = new_resources)</code>
will use the new bucket <code>"z"</code>, but it will still use the prefix <code>"y"</code>
supplied through <code>tar_option_set()</code>. (In <code>targets</code> 0.12.1 and below,
options like <code>prefix</code> do not carry over from <code>tar_option_set()</code> if you
supply non-default resources to <code>tar_target()</code>.)
</p>


<h3>See Also</h3>

<p>Other resources: 
<code><a href="#topic+tar_resources">tar_resources</a>()</code>,
<code><a href="#topic+tar_resources_aws">tar_resources_aws</a>()</code>,
<code><a href="#topic+tar_resources_crew">tar_resources_crew</a>()</code>,
<code><a href="#topic+tar_resources_feather">tar_resources_feather</a>()</code>,
<code><a href="#topic+tar_resources_fst">tar_resources_fst</a>()</code>,
<code><a href="#topic+tar_resources_future">tar_resources_future</a>()</code>,
<code><a href="#topic+tar_resources_gcp">tar_resources_gcp</a>()</code>,
<code><a href="#topic+tar_resources_network">tar_resources_network</a>()</code>,
<code><a href="#topic+tar_resources_parquet">tar_resources_parquet</a>()</code>,
<code><a href="#topic+tar_resources_qs">tar_resources_qs</a>()</code>,
<code><a href="#topic+tar_resources_url">tar_resources_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Somewhere in you target script file (usually _targets.R):
tar_target(
  name,
  command(),
  resources = tar_resources(
    clustermq = tar_resources_clustermq(template = list(n_cores = 2))
  )
)
</code></pre>

<hr>
<h2 id='tar_resources_crew'>Target resources: <code>crew</code> high-performance computing</h2><span id='topic+tar_resources_crew'></span>

<h3>Description</h3>

<p>Create the <code>crew</code> argument of <code>tar_resources()</code>
to specify optional target settings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_resources_crew(
  controller = targets::tar_option_get("resources")$crew$controller,
  scale = NULL,
  seconds_timeout = targets::tar_option_get("resources")$crew$seconds_timeout
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_resources_crew_+3A_controller">controller</code></td>
<td>
<p>Character of length 1.
If <code>tar_option_get("controller")</code> is a
<code>crew</code> controller group, the <code>controller</code> argument of
<code>tar_resources_crew()</code> indicates which controller in the controller
group to use. If you need heterogeneous workers,
you can leverage this argument to send different
targets to different worker groups.</p>
</td></tr>
<tr><td><code id="tar_resources_crew_+3A_scale">scale</code></td>
<td>
<p>Deprecated in version 1.3.0.9002 (2023-10-02). No longer
necessary.</p>
</td></tr>
<tr><td><code id="tar_resources_crew_+3A_seconds_timeout">seconds_timeout</code></td>
<td>
<p>Positive numeric of length 1,
optional task timeout passed to the <code>.timeout</code>
argument of <code>mirai::mirai()</code> (after converting to milliseconds).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_resources_crew()</code> accepts
target-specific settings for integration with the
<code>crew</code> R package. These settings are arguments to the <code>push()</code>
method of the controller or controller group
object which control things like
auto-scaling behavior and the controller to use in the case
of a controller group.
</p>


<h3>Value</h3>

<p>Object of class <code>"tar_resources_crew"</code>, to be supplied
to the <code>crew</code> argument of <code>tar_resources()</code>.
</p>


<h3>Resources</h3>

<p>Functions <code><a href="#topic+tar_target">tar_target()</a></code> and <code><a href="#topic+tar_option_set">tar_option_set()</a></code>
each takes an optional <code>resources</code> argument to supply
non-default settings of various optional backends for data storage
and high-performance computing. The <code>tar_resources()</code> function
is a helper to supply those settings in the correct manner.
</p>
<p>In <code>targets</code> version 0.12.2 and above, resources are inherited one-by-one
in nested fashion from <code>tar_option_get("resources")</code>.
For example, suppose you set
<code>tar_option_set(resources = tar_resources(aws = my_aws))</code>,
where <code>my_aws</code> equals <code>tar_resources_aws(bucket = "x", prefix = "y")</code>.
Then, <code style="white-space: pre;">&#8288;tar_target(data, get_data()&#8288;</code> will have bucket <code>"x"</code> and
prefix <code>"y"</code>. In addition, if <code>new_resources</code> equals
<code style="white-space: pre;">&#8288;tar_resources(aws = tar_resources_aws(bucket = "z")))&#8288;</code>, then
<code>tar_target(data, get_data(), resources = new_resources)</code>
will use the new bucket <code>"z"</code>, but it will still use the prefix <code>"y"</code>
supplied through <code>tar_option_set()</code>. (In <code>targets</code> 0.12.1 and below,
options like <code>prefix</code> do not carry over from <code>tar_option_set()</code> if you
supply non-default resources to <code>tar_target()</code>.)
</p>


<h3>See Also</h3>

<p>Other resources: 
<code><a href="#topic+tar_resources">tar_resources</a>()</code>,
<code><a href="#topic+tar_resources_aws">tar_resources_aws</a>()</code>,
<code><a href="#topic+tar_resources_clustermq">tar_resources_clustermq</a>()</code>,
<code><a href="#topic+tar_resources_feather">tar_resources_feather</a>()</code>,
<code><a href="#topic+tar_resources_fst">tar_resources_fst</a>()</code>,
<code><a href="#topic+tar_resources_future">tar_resources_future</a>()</code>,
<code><a href="#topic+tar_resources_gcp">tar_resources_gcp</a>()</code>,
<code><a href="#topic+tar_resources_network">tar_resources_network</a>()</code>,
<code><a href="#topic+tar_resources_parquet">tar_resources_parquet</a>()</code>,
<code><a href="#topic+tar_resources_qs">tar_resources_qs</a>()</code>,
<code><a href="#topic+tar_resources_url">tar_resources_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Somewhere in you target script file (usually _targets.R):
tar_target(
  name,
  command(),
  resources = tar_resources(
    crew = tar_resources_crew(seconds_timeout = 5)
  )
)
</code></pre>

<hr>
<h2 id='tar_resources_feather'>Target resources: feather storage formats</h2><span id='topic+tar_resources_feather'></span>

<h3>Description</h3>

<p>Create the feather argument of <code>tar_resources()</code>
to specify optional settings for feather data frame storage formats
powered by the <code>arrow</code> R package.
See the <code>format</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_resources_feather(
  compression = targets::tar_option_get("resources")$feather$compression,
  compression_level = targets::tar_option_get("resources")$feather$compression_level
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_resources_feather_+3A_compression">compression</code></td>
<td>
<p>Character of length 1, <code>compression</code>
argument of <code>arrow::write_feather()</code>. Defaults to <code>"default"</code>.</p>
</td></tr>
<tr><td><code id="tar_resources_feather_+3A_compression_level">compression_level</code></td>
<td>
<p>Numeric of length 1, <code>compression_level</code>
argument of <code>arrow::write_feather()</code>.
Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"tar_resources_feather"</code>, to be supplied
to the feather argument of <code>tar_resources()</code>.
</p>


<h3>Resources</h3>

<p>Functions <code><a href="#topic+tar_target">tar_target()</a></code> and <code><a href="#topic+tar_option_set">tar_option_set()</a></code>
each takes an optional <code>resources</code> argument to supply
non-default settings of various optional backends for data storage
and high-performance computing. The <code>tar_resources()</code> function
is a helper to supply those settings in the correct manner.
</p>
<p>In <code>targets</code> version 0.12.2 and above, resources are inherited one-by-one
in nested fashion from <code>tar_option_get("resources")</code>.
For example, suppose you set
<code>tar_option_set(resources = tar_resources(aws = my_aws))</code>,
where <code>my_aws</code> equals <code>tar_resources_aws(bucket = "x", prefix = "y")</code>.
Then, <code style="white-space: pre;">&#8288;tar_target(data, get_data()&#8288;</code> will have bucket <code>"x"</code> and
prefix <code>"y"</code>. In addition, if <code>new_resources</code> equals
<code style="white-space: pre;">&#8288;tar_resources(aws = tar_resources_aws(bucket = "z")))&#8288;</code>, then
<code>tar_target(data, get_data(), resources = new_resources)</code>
will use the new bucket <code>"z"</code>, but it will still use the prefix <code>"y"</code>
supplied through <code>tar_option_set()</code>. (In <code>targets</code> 0.12.1 and below,
options like <code>prefix</code> do not carry over from <code>tar_option_set()</code> if you
supply non-default resources to <code>tar_target()</code>.)
</p>


<h3>See Also</h3>

<p>Other resources: 
<code><a href="#topic+tar_resources">tar_resources</a>()</code>,
<code><a href="#topic+tar_resources_aws">tar_resources_aws</a>()</code>,
<code><a href="#topic+tar_resources_clustermq">tar_resources_clustermq</a>()</code>,
<code><a href="#topic+tar_resources_crew">tar_resources_crew</a>()</code>,
<code><a href="#topic+tar_resources_fst">tar_resources_fst</a>()</code>,
<code><a href="#topic+tar_resources_future">tar_resources_future</a>()</code>,
<code><a href="#topic+tar_resources_gcp">tar_resources_gcp</a>()</code>,
<code><a href="#topic+tar_resources_network">tar_resources_network</a>()</code>,
<code><a href="#topic+tar_resources_parquet">tar_resources_parquet</a>()</code>,
<code><a href="#topic+tar_resources_qs">tar_resources_qs</a>()</code>,
<code><a href="#topic+tar_resources_url">tar_resources_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Somewhere in you target script file (usually _targets.R):
tar_target(
  name,
  command(),
  format = "feather",
  resources = tar_resources(
    feather = tar_resources_feather(compression = "lz4")
  )
)
</code></pre>

<hr>
<h2 id='tar_resources_fst'>Target resources: <code>fst</code> storage formats</h2><span id='topic+tar_resources_fst'></span>

<h3>Description</h3>

<p>Create the <code>fst</code> argument of <code>tar_resources()</code>
to specify optional settings for big data frame storage formats
powered by the <code>fst</code> R package.
See the <code>format</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_resources_fst(compress = targets::tar_option_get("resources")$fst$compress)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_resources_fst_+3A_compress">compress</code></td>
<td>
<p>Numeric of length 1, <code>compress</code>
argument of <code>fst::write_fst()</code>. Defaults to <code>50</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"tar_resources_fst"</code>, to be supplied
to the <code>fst</code> argument of <code>tar_resources()</code>.
</p>


<h3>Resources</h3>

<p>Functions <code><a href="#topic+tar_target">tar_target()</a></code> and <code><a href="#topic+tar_option_set">tar_option_set()</a></code>
each takes an optional <code>resources</code> argument to supply
non-default settings of various optional backends for data storage
and high-performance computing. The <code>tar_resources()</code> function
is a helper to supply those settings in the correct manner.
</p>
<p>In <code>targets</code> version 0.12.2 and above, resources are inherited one-by-one
in nested fashion from <code>tar_option_get("resources")</code>.
For example, suppose you set
<code>tar_option_set(resources = tar_resources(aws = my_aws))</code>,
where <code>my_aws</code> equals <code>tar_resources_aws(bucket = "x", prefix = "y")</code>.
Then, <code style="white-space: pre;">&#8288;tar_target(data, get_data()&#8288;</code> will have bucket <code>"x"</code> and
prefix <code>"y"</code>. In addition, if <code>new_resources</code> equals
<code style="white-space: pre;">&#8288;tar_resources(aws = tar_resources_aws(bucket = "z")))&#8288;</code>, then
<code>tar_target(data, get_data(), resources = new_resources)</code>
will use the new bucket <code>"z"</code>, but it will still use the prefix <code>"y"</code>
supplied through <code>tar_option_set()</code>. (In <code>targets</code> 0.12.1 and below,
options like <code>prefix</code> do not carry over from <code>tar_option_set()</code> if you
supply non-default resources to <code>tar_target()</code>.)
</p>


<h3>See Also</h3>

<p>Other resources: 
<code><a href="#topic+tar_resources">tar_resources</a>()</code>,
<code><a href="#topic+tar_resources_aws">tar_resources_aws</a>()</code>,
<code><a href="#topic+tar_resources_clustermq">tar_resources_clustermq</a>()</code>,
<code><a href="#topic+tar_resources_crew">tar_resources_crew</a>()</code>,
<code><a href="#topic+tar_resources_feather">tar_resources_feather</a>()</code>,
<code><a href="#topic+tar_resources_future">tar_resources_future</a>()</code>,
<code><a href="#topic+tar_resources_gcp">tar_resources_gcp</a>()</code>,
<code><a href="#topic+tar_resources_network">tar_resources_network</a>()</code>,
<code><a href="#topic+tar_resources_parquet">tar_resources_parquet</a>()</code>,
<code><a href="#topic+tar_resources_qs">tar_resources_qs</a>()</code>,
<code><a href="#topic+tar_resources_url">tar_resources_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Somewhere in you target script file (usually _targets.R):
tar_target(
  name,
  command(),
  format = "fst_tbl",
  resources = tar_resources(
    fst = tar_resources_fst(compress = 100)
  )
)
</code></pre>

<hr>
<h2 id='tar_resources_future'>Target resources: <code>future</code> high-performance computing</h2><span id='topic+tar_resources_future'></span>

<h3>Description</h3>

<p>Create the <code>future</code> argument of <code>tar_resources()</code>
to specify optional high-performance computing settings
for <code>tar_make_future()</code>.
This is how to supply the <code>resources</code>
argument of <code>future::future()</code> for <code>targets</code>.
Resources supplied through
<code>future::plan()</code> and <code>future::tweak()</code> are completely ignored.
For details, see the documentation of the <code>future</code> R package
and the corresponding argument names in this help file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_resources_future(
  plan = NULL,
  resources = targets::tar_option_get("resources")$future$resources
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_resources_future_+3A_plan">plan</code></td>
<td>
<p>A <code>future::plan()</code> object or <code>NULL</code>,
a <code>target</code>-specific <code>future</code> plan. Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="tar_resources_future_+3A_resources">resources</code></td>
<td>
<p>Named list, <code>resources</code> argument to
<code>future::future()</code>. This argument is not supported in
some versions of <code>future</code>. For versions of <code>future</code>
where <code>resources</code> is not supported, instead supply <code>resources</code>
to <code>future::tweak()</code> and assign the returned plan to the <code>plan</code> argument
of <code>tar_resources_future()</code>.
The default value of <code>resources</code> in <code>tar_resources_future()</code>
is an empty list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"tar_resources_future"</code>, to be supplied
to the <code>future</code> argument of <code>tar_resources()</code>.
</p>


<h3>Resources</h3>

<p>Functions <code><a href="#topic+tar_target">tar_target()</a></code> and <code><a href="#topic+tar_option_set">tar_option_set()</a></code>
each takes an optional <code>resources</code> argument to supply
non-default settings of various optional backends for data storage
and high-performance computing. The <code>tar_resources()</code> function
is a helper to supply those settings in the correct manner.
</p>
<p>In <code>targets</code> version 0.12.2 and above, resources are inherited one-by-one
in nested fashion from <code>tar_option_get("resources")</code>.
For example, suppose you set
<code>tar_option_set(resources = tar_resources(aws = my_aws))</code>,
where <code>my_aws</code> equals <code>tar_resources_aws(bucket = "x", prefix = "y")</code>.
Then, <code style="white-space: pre;">&#8288;tar_target(data, get_data()&#8288;</code> will have bucket <code>"x"</code> and
prefix <code>"y"</code>. In addition, if <code>new_resources</code> equals
<code style="white-space: pre;">&#8288;tar_resources(aws = tar_resources_aws(bucket = "z")))&#8288;</code>, then
<code>tar_target(data, get_data(), resources = new_resources)</code>
will use the new bucket <code>"z"</code>, but it will still use the prefix <code>"y"</code>
supplied through <code>tar_option_set()</code>. (In <code>targets</code> 0.12.1 and below,
options like <code>prefix</code> do not carry over from <code>tar_option_set()</code> if you
supply non-default resources to <code>tar_target()</code>.)
</p>


<h3>See Also</h3>

<p>Other resources: 
<code><a href="#topic+tar_resources">tar_resources</a>()</code>,
<code><a href="#topic+tar_resources_aws">tar_resources_aws</a>()</code>,
<code><a href="#topic+tar_resources_clustermq">tar_resources_clustermq</a>()</code>,
<code><a href="#topic+tar_resources_crew">tar_resources_crew</a>()</code>,
<code><a href="#topic+tar_resources_feather">tar_resources_feather</a>()</code>,
<code><a href="#topic+tar_resources_fst">tar_resources_fst</a>()</code>,
<code><a href="#topic+tar_resources_gcp">tar_resources_gcp</a>()</code>,
<code><a href="#topic+tar_resources_network">tar_resources_network</a>()</code>,
<code><a href="#topic+tar_resources_parquet">tar_resources_parquet</a>()</code>,
<code><a href="#topic+tar_resources_qs">tar_resources_qs</a>()</code>,
<code><a href="#topic+tar_resources_url">tar_resources_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Somewhere in you target script file (usually _targets.R):
tar_target(
  name,
  command(),
  resources = tar_resources(
    future = tar_resources_future(resources = list(n_cores = 2))
  )
)
</code></pre>

<hr>
<h2 id='tar_resources_gcp'>Target resources: Google Cloud Platform (GCP)
Google Cloud Storage (GCS)</h2><span id='topic+tar_resources_gcp'></span>

<h3>Description</h3>

<p>Create the <code>gcp</code> argument of <code>tar_resources()</code>
to specify optional settings for Google Cloud Storage for
targets with <code>tar_target(..., repository = "gcp")</code>.
See the <code>format</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_resources_gcp(
  bucket = targets::tar_option_get("resources")$gcp$bucket,
  prefix = targets::tar_option_get("resources")$gcp$prefix,
  predefined_acl = targets::tar_option_get("resources")$gcp$predefined_acl,
  max_tries = targets::tar_option_get("resources")$gcp$max_tries,
  verbose = targets::tar_option_get("resources")$gcp$verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_resources_gcp_+3A_bucket">bucket</code></td>
<td>
<p>Character of length 1, name of an existing
bucket to upload and download the return values
of the affected targets during the pipeline.</p>
</td></tr>
<tr><td><code id="tar_resources_gcp_+3A_prefix">prefix</code></td>
<td>
<p>Character of length 1, &quot;directory path&quot;
in the bucket where your target object and metadata will go.
Please supply an explicit prefix
unique to your <code>targets</code> project.
In the future, <code>targets</code> will begin requiring
explicitly user-supplied prefixes. (This last note
was added on 2023-08-24: <code>targets</code> version 1.2.2.9000.)</p>
</td></tr>
<tr><td><code id="tar_resources_gcp_+3A_predefined_acl">predefined_acl</code></td>
<td>
<p>Character of length 1, user access
to the object. See <code>?googleCloudStorageR::gcs_upload</code>
for possible values. Defaults to <code>"private"</code>.</p>
</td></tr>
<tr><td><code id="tar_resources_gcp_+3A_max_tries">max_tries</code></td>
<td>
<p>Positive integer of length 1,
number of tries accessing a network resource on GCP.</p>
</td></tr>
<tr><td><code id="tar_resources_gcp_+3A_verbose">verbose</code></td>
<td>
<p>Logical of length 1, whether to print
extra messages like progress bars during uploads
and downloads. Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>


<h3>Value</h3>

<p>Object of class <code>"tar_resources_gcp"</code>, to be supplied
to the <code>gcp</code> argument of <code>tar_resources()</code>.
</p>


<h3>Resources</h3>

<p>Functions <code><a href="#topic+tar_target">tar_target()</a></code> and <code><a href="#topic+tar_option_set">tar_option_set()</a></code>
each takes an optional <code>resources</code> argument to supply
non-default settings of various optional backends for data storage
and high-performance computing. The <code>tar_resources()</code> function
is a helper to supply those settings in the correct manner.
</p>
<p>In <code>targets</code> version 0.12.2 and above, resources are inherited one-by-one
in nested fashion from <code>tar_option_get("resources")</code>.
For example, suppose you set
<code>tar_option_set(resources = tar_resources(aws = my_aws))</code>,
where <code>my_aws</code> equals <code>tar_resources_aws(bucket = "x", prefix = "y")</code>.
Then, <code style="white-space: pre;">&#8288;tar_target(data, get_data()&#8288;</code> will have bucket <code>"x"</code> and
prefix <code>"y"</code>. In addition, if <code>new_resources</code> equals
<code style="white-space: pre;">&#8288;tar_resources(aws = tar_resources_aws(bucket = "z")))&#8288;</code>, then
<code>tar_target(data, get_data(), resources = new_resources)</code>
will use the new bucket <code>"z"</code>, but it will still use the prefix <code>"y"</code>
supplied through <code>tar_option_set()</code>. (In <code>targets</code> 0.12.1 and below,
options like <code>prefix</code> do not carry over from <code>tar_option_set()</code> if you
supply non-default resources to <code>tar_target()</code>.)
</p>


<h3>See Also</h3>

<p>Other resources: 
<code><a href="#topic+tar_resources">tar_resources</a>()</code>,
<code><a href="#topic+tar_resources_aws">tar_resources_aws</a>()</code>,
<code><a href="#topic+tar_resources_clustermq">tar_resources_clustermq</a>()</code>,
<code><a href="#topic+tar_resources_crew">tar_resources_crew</a>()</code>,
<code><a href="#topic+tar_resources_feather">tar_resources_feather</a>()</code>,
<code><a href="#topic+tar_resources_fst">tar_resources_fst</a>()</code>,
<code><a href="#topic+tar_resources_future">tar_resources_future</a>()</code>,
<code><a href="#topic+tar_resources_network">tar_resources_network</a>()</code>,
<code><a href="#topic+tar_resources_parquet">tar_resources_parquet</a>()</code>,
<code><a href="#topic+tar_resources_qs">tar_resources_qs</a>()</code>,
<code><a href="#topic+tar_resources_url">tar_resources_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Somewhere in you target script file (usually _targets.R):
tar_target(
  name,
  command(),
  format = "qs",
  repository = "gcp",
  resources = tar_resources(
    gcp = tar_resources_gcp(bucket = "yourbucketname"),
    qs = tar_resources_qs(preset = "fast")
  )
)
</code></pre>

<hr>
<h2 id='tar_resources_network'>Target resources for network file systems.</h2><span id='topic+tar_resources_network'></span>

<h3>Description</h3>

<p>In high-performance computing on network file systems,
if <code>storage = "worker"</code> in <code><a href="#topic+tar_target">tar_target()</a></code> or <code><a href="#topic+tar_option_set">tar_option_set()</a></code>, then
<code>targets</code> waits for hashes to synchronize before continuing the pipeline.
These resources control the retry mechanism.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_resources_network(
  max_tries = targets::tar_option_get("resources")$network$max_tries,
  seconds_interval = targets::tar_option_get("resources")$network$seconds_interval,
  seconds_timeout = targets::tar_option_get("resources")$network$seconds_timeout,
  verbose = targets::tar_option_get("resources")$network$verbose
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_resources_network_+3A_max_tries">max_tries</code></td>
<td>
<p>Positive integer of length 1. Max number of tries.</p>
</td></tr>
<tr><td><code id="tar_resources_network_+3A_seconds_interval">seconds_interval</code></td>
<td>
<p>Positive numeric of length 1.
Multiplier for the exponential backoff algorithm, and width
of the jitter. Units of seconds.</p>
</td></tr>
<tr><td><code id="tar_resources_network_+3A_seconds_timeout">seconds_timeout</code></td>
<td>
<p>Positive numeric of length 1. Timeout length in
seconds.</p>
</td></tr>
<tr><td><code id="tar_resources_network_+3A_verbose">verbose</code></td>
<td>
<p>Logical of length 1, whether to print informative
console messages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"tar_resources_network"</code>, to be supplied
to the network argument of <code>tar_resources()</code>.
</p>


<h3>Resources</h3>

<p>Functions <code><a href="#topic+tar_target">tar_target()</a></code> and <code><a href="#topic+tar_option_set">tar_option_set()</a></code>
each takes an optional <code>resources</code> argument to supply
non-default settings of various optional backends for data storage
and high-performance computing. The <code>tar_resources()</code> function
is a helper to supply those settings in the correct manner.
</p>
<p>In <code>targets</code> version 0.12.2 and above, resources are inherited one-by-one
in nested fashion from <code>tar_option_get("resources")</code>.
For example, suppose you set
<code>tar_option_set(resources = tar_resources(aws = my_aws))</code>,
where <code>my_aws</code> equals <code>tar_resources_aws(bucket = "x", prefix = "y")</code>.
Then, <code style="white-space: pre;">&#8288;tar_target(data, get_data()&#8288;</code> will have bucket <code>"x"</code> and
prefix <code>"y"</code>. In addition, if <code>new_resources</code> equals
<code style="white-space: pre;">&#8288;tar_resources(aws = tar_resources_aws(bucket = "z")))&#8288;</code>, then
<code>tar_target(data, get_data(), resources = new_resources)</code>
will use the new bucket <code>"z"</code>, but it will still use the prefix <code>"y"</code>
supplied through <code>tar_option_set()</code>. (In <code>targets</code> 0.12.1 and below,
options like <code>prefix</code> do not carry over from <code>tar_option_set()</code> if you
supply non-default resources to <code>tar_target()</code>.)
</p>


<h3>See Also</h3>

<p>Other resources: 
<code><a href="#topic+tar_resources">tar_resources</a>()</code>,
<code><a href="#topic+tar_resources_aws">tar_resources_aws</a>()</code>,
<code><a href="#topic+tar_resources_clustermq">tar_resources_clustermq</a>()</code>,
<code><a href="#topic+tar_resources_crew">tar_resources_crew</a>()</code>,
<code><a href="#topic+tar_resources_feather">tar_resources_feather</a>()</code>,
<code><a href="#topic+tar_resources_fst">tar_resources_fst</a>()</code>,
<code><a href="#topic+tar_resources_future">tar_resources_future</a>()</code>,
<code><a href="#topic+tar_resources_gcp">tar_resources_gcp</a>()</code>,
<code><a href="#topic+tar_resources_parquet">tar_resources_parquet</a>()</code>,
<code><a href="#topic+tar_resources_qs">tar_resources_qs</a>()</code>,
<code><a href="#topic+tar_resources_url">tar_resources_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
# Somewhere in you target script file (usually _targets.R):
tar_target(
  name = your_name,
  command = your_command(),
  storage = "worker",
  resources = tar_resources(
    network = tar_resources_network(max_tries = 3)
  )
)
}
</code></pre>

<hr>
<h2 id='tar_resources_parquet'>Target resources: parquet storage formats</h2><span id='topic+tar_resources_parquet'></span>

<h3>Description</h3>

<p>Create the <code>parquet</code> argument of <code>tar_resources()</code>
to specify optional settings for parquet data frame storage formats
powered by the <code>arrow</code> R package.
See the <code>format</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_resources_parquet(
  compression = targets::tar_option_get("resources")$parquet$compression,
  compression_level = targets::tar_option_get("resources")$parquet$compression_level
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_resources_parquet_+3A_compression">compression</code></td>
<td>
<p>Character of length 1, <code>compression</code>
argument of <code>arrow::write_parquet()</code>. Defaults to <code>"snappy"</code>.</p>
</td></tr>
<tr><td><code id="tar_resources_parquet_+3A_compression_level">compression_level</code></td>
<td>
<p>Numeric of length 1, <code>compression_level</code>
argument of <code>arrow::write_parquet()</code>. Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"tar_resources_parquet"</code>, to be supplied
to the parquet argument of <code>tar_resources()</code>.
</p>


<h3>Resources</h3>

<p>Functions <code><a href="#topic+tar_target">tar_target()</a></code> and <code><a href="#topic+tar_option_set">tar_option_set()</a></code>
each takes an optional <code>resources</code> argument to supply
non-default settings of various optional backends for data storage
and high-performance computing. The <code>tar_resources()</code> function
is a helper to supply those settings in the correct manner.
</p>
<p>In <code>targets</code> version 0.12.2 and above, resources are inherited one-by-one
in nested fashion from <code>tar_option_get("resources")</code>.
For example, suppose you set
<code>tar_option_set(resources = tar_resources(aws = my_aws))</code>,
where <code>my_aws</code> equals <code>tar_resources_aws(bucket = "x", prefix = "y")</code>.
Then, <code style="white-space: pre;">&#8288;tar_target(data, get_data()&#8288;</code> will have bucket <code>"x"</code> and
prefix <code>"y"</code>. In addition, if <code>new_resources</code> equals
<code style="white-space: pre;">&#8288;tar_resources(aws = tar_resources_aws(bucket = "z")))&#8288;</code>, then
<code>tar_target(data, get_data(), resources = new_resources)</code>
will use the new bucket <code>"z"</code>, but it will still use the prefix <code>"y"</code>
supplied through <code>tar_option_set()</code>. (In <code>targets</code> 0.12.1 and below,
options like <code>prefix</code> do not carry over from <code>tar_option_set()</code> if you
supply non-default resources to <code>tar_target()</code>.)
</p>


<h3>See Also</h3>

<p>Other resources: 
<code><a href="#topic+tar_resources">tar_resources</a>()</code>,
<code><a href="#topic+tar_resources_aws">tar_resources_aws</a>()</code>,
<code><a href="#topic+tar_resources_clustermq">tar_resources_clustermq</a>()</code>,
<code><a href="#topic+tar_resources_crew">tar_resources_crew</a>()</code>,
<code><a href="#topic+tar_resources_feather">tar_resources_feather</a>()</code>,
<code><a href="#topic+tar_resources_fst">tar_resources_fst</a>()</code>,
<code><a href="#topic+tar_resources_future">tar_resources_future</a>()</code>,
<code><a href="#topic+tar_resources_gcp">tar_resources_gcp</a>()</code>,
<code><a href="#topic+tar_resources_network">tar_resources_network</a>()</code>,
<code><a href="#topic+tar_resources_qs">tar_resources_qs</a>()</code>,
<code><a href="#topic+tar_resources_url">tar_resources_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Somewhere in you target script file (usually _targets.R):
tar_target(
  name,
  command(),
  format = "parquet",
  resources = tar_resources(
    parquet = tar_resources_parquet(compression = "lz4")
  )
)
</code></pre>

<hr>
<h2 id='tar_resources_qs'>Target resources: qs storage formats</h2><span id='topic+tar_resources_qs'></span>

<h3>Description</h3>

<p>Create the <code>qs</code> argument of <code>tar_resources()</code>
to specify optional settings for big data storage formats
powered by the <code>qs</code> R package.
See the <code>format</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_resources_qs(preset = targets::tar_option_get("resources")$qs$preset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_resources_qs_+3A_preset">preset</code></td>
<td>
<p>Character of length 1, <code>preset</code>
argument of <code>qs::qsave()</code>. Defaults to <code>"high"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"tar_resources_qs"</code>, to be supplied
to the qs argument of <code>tar_resources()</code>.
</p>


<h3>Resources</h3>

<p>Functions <code><a href="#topic+tar_target">tar_target()</a></code> and <code><a href="#topic+tar_option_set">tar_option_set()</a></code>
each takes an optional <code>resources</code> argument to supply
non-default settings of various optional backends for data storage
and high-performance computing. The <code>tar_resources()</code> function
is a helper to supply those settings in the correct manner.
</p>
<p>In <code>targets</code> version 0.12.2 and above, resources are inherited one-by-one
in nested fashion from <code>tar_option_get("resources")</code>.
For example, suppose you set
<code>tar_option_set(resources = tar_resources(aws = my_aws))</code>,
where <code>my_aws</code> equals <code>tar_resources_aws(bucket = "x", prefix = "y")</code>.
Then, <code style="white-space: pre;">&#8288;tar_target(data, get_data()&#8288;</code> will have bucket <code>"x"</code> and
prefix <code>"y"</code>. In addition, if <code>new_resources</code> equals
<code style="white-space: pre;">&#8288;tar_resources(aws = tar_resources_aws(bucket = "z")))&#8288;</code>, then
<code>tar_target(data, get_data(), resources = new_resources)</code>
will use the new bucket <code>"z"</code>, but it will still use the prefix <code>"y"</code>
supplied through <code>tar_option_set()</code>. (In <code>targets</code> 0.12.1 and below,
options like <code>prefix</code> do not carry over from <code>tar_option_set()</code> if you
supply non-default resources to <code>tar_target()</code>.)
</p>


<h3>See Also</h3>

<p>Other resources: 
<code><a href="#topic+tar_resources">tar_resources</a>()</code>,
<code><a href="#topic+tar_resources_aws">tar_resources_aws</a>()</code>,
<code><a href="#topic+tar_resources_clustermq">tar_resources_clustermq</a>()</code>,
<code><a href="#topic+tar_resources_crew">tar_resources_crew</a>()</code>,
<code><a href="#topic+tar_resources_feather">tar_resources_feather</a>()</code>,
<code><a href="#topic+tar_resources_fst">tar_resources_fst</a>()</code>,
<code><a href="#topic+tar_resources_future">tar_resources_future</a>()</code>,
<code><a href="#topic+tar_resources_gcp">tar_resources_gcp</a>()</code>,
<code><a href="#topic+tar_resources_network">tar_resources_network</a>()</code>,
<code><a href="#topic+tar_resources_parquet">tar_resources_parquet</a>()</code>,
<code><a href="#topic+tar_resources_url">tar_resources_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Somewhere in you target script file (usually _targets.R):
tar_target(
  name,
  command(),
  format = "qs",
  resources = tar_resources(
    qs = tar_resources_qs(preset = "fast")
  )
)
</code></pre>

<hr>
<h2 id='tar_resources_url'>Target resources: URL storage formats</h2><span id='topic+tar_resources_url'></span>

<h3>Description</h3>

<p>Create the <code>url</code> argument of <code>tar_resources()</code>
to specify optional settings for URL storage formats.
See the <code>format</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_resources_url(
  handle = targets::tar_option_get("resources")$url$handle,
  max_tries = targets::tar_option_get("resources")$url$max_tries,
  seconds_interval = targets::tar_option_get("resources")$url$seconds_interval,
  seconds_timeout = targets::tar_option_get("resources")$url$seconds_interval
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_resources_url_+3A_handle">handle</code></td>
<td>
<p>Object returned by <code>curl::new_handle</code> or <code>NULL</code>.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="tar_resources_url_+3A_max_tries">max_tries</code></td>
<td>
<p>Positive integer of length 1, maximum number of tries
to access a URL.</p>
</td></tr>
<tr><td><code id="tar_resources_url_+3A_seconds_interval">seconds_interval</code></td>
<td>
<p>Nonnegative numeric of length 1,
number of seconds to wait between individual retries
while attempting to connect to the URL.
Use <code><a href="#topic+tar_resources_network">tar_resources_network()</a></code> instead.</p>
</td></tr>
<tr><td><code id="tar_resources_url_+3A_seconds_timeout">seconds_timeout</code></td>
<td>
<p>Nonnegative numeric of length 1,
number of seconds to wait before timing out while trying to
connect to the URL.
Use <code><a href="#topic+tar_resources_network">tar_resources_network()</a></code> instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"tar_resources_url"</code>, to be supplied
to the url argument of <code>tar_resources()</code>.
</p>


<h3>Resources</h3>

<p>Functions <code><a href="#topic+tar_target">tar_target()</a></code> and <code><a href="#topic+tar_option_set">tar_option_set()</a></code>
each takes an optional <code>resources</code> argument to supply
non-default settings of various optional backends for data storage
and high-performance computing. The <code>tar_resources()</code> function
is a helper to supply those settings in the correct manner.
</p>
<p>In <code>targets</code> version 0.12.2 and above, resources are inherited one-by-one
in nested fashion from <code>tar_option_get("resources")</code>.
For example, suppose you set
<code>tar_option_set(resources = tar_resources(aws = my_aws))</code>,
where <code>my_aws</code> equals <code>tar_resources_aws(bucket = "x", prefix = "y")</code>.
Then, <code style="white-space: pre;">&#8288;tar_target(data, get_data()&#8288;</code> will have bucket <code>"x"</code> and
prefix <code>"y"</code>. In addition, if <code>new_resources</code> equals
<code style="white-space: pre;">&#8288;tar_resources(aws = tar_resources_aws(bucket = "z")))&#8288;</code>, then
<code>tar_target(data, get_data(), resources = new_resources)</code>
will use the new bucket <code>"z"</code>, but it will still use the prefix <code>"y"</code>
supplied through <code>tar_option_set()</code>. (In <code>targets</code> 0.12.1 and below,
options like <code>prefix</code> do not carry over from <code>tar_option_set()</code> if you
supply non-default resources to <code>tar_target()</code>.)
</p>


<h3>See Also</h3>

<p>Other resources: 
<code><a href="#topic+tar_resources">tar_resources</a>()</code>,
<code><a href="#topic+tar_resources_aws">tar_resources_aws</a>()</code>,
<code><a href="#topic+tar_resources_clustermq">tar_resources_clustermq</a>()</code>,
<code><a href="#topic+tar_resources_crew">tar_resources_crew</a>()</code>,
<code><a href="#topic+tar_resources_feather">tar_resources_feather</a>()</code>,
<code><a href="#topic+tar_resources_fst">tar_resources_fst</a>()</code>,
<code><a href="#topic+tar_resources_future">tar_resources_future</a>()</code>,
<code><a href="#topic+tar_resources_gcp">tar_resources_gcp</a>()</code>,
<code><a href="#topic+tar_resources_network">tar_resources_network</a>()</code>,
<code><a href="#topic+tar_resources_parquet">tar_resources_parquet</a>()</code>,
<code><a href="#topic+tar_resources_qs">tar_resources_qs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
# Somewhere in you target script file (usually _targets.R):
tar_target(
  name,
  command(),
  format = "url",
  resources = tar_resources(
    url = tar_resources_url(handle = curl::new_handle())
  )
)
}
</code></pre>

<hr>
<h2 id='tar_runtime_object'>Get the <code>tar_runtime</code> object.</h2><span id='topic+tar_runtime_object'></span>

<h3>Description</h3>

<p>For internal purposes only. Not a user-side function.
Do not invoke directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_runtime_object()
</code></pre>


<h3>Details</h3>

<p>Manages internal settings
that targets need while they run.
</p>


<h3>Value</h3>

<p>The internal <code>tar_runtime</code> object of class <code>"tar_runtime"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_runtime_object()
</code></pre>

<hr>
<h2 id='tar_script'>Write a target script file.</h2><span id='topic+tar_script'></span>

<h3>Description</h3>

<p>The <code>tar_script()</code> function is a convenient
way to create the required target script file (default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>)
in the current working directory.
It always overwrites the existing target script,
and it requires you to be in the working directory
where you intend to write the file, so be careful.
See the &quot;Target script&quot; section for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_script(
  code = NULL,
  library_targets = TRUE,
  ask = NULL,
  script = targets::tar_config_get("script")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_script_+3A_code">code</code></td>
<td>
<p>R code to write to the target script file.
If <code>NULL</code>, an example target script file is written instead.</p>
</td></tr>
<tr><td><code id="tar_script_+3A_library_targets">library_targets</code></td>
<td>
<p>logical, whether to write a <code>library(targets)</code>
line at the top of the target script file automatically (recommended).
If <code>TRUE</code>, you do not need to explicitly put <code>library(targets)</code>
in <code>code</code>.</p>
</td></tr>
<tr><td><code id="tar_script_+3A_ask">ask</code></td>
<td>
<p>Logical, whether to ask before writing if the
target script file
already exists. If <code>NULL</code>, defaults to <code>Sys.getenv("TAR_ASK")</code>.
(Set to <code>"true"</code> or <code>"false"</code> with <code>Sys.setenv()</code>).
If <code>ask</code> and the <code>TAR_ASK</code> environment variable are both
indeterminate, defaults to <code>interactive()</code>.</p>
</td></tr>
<tr><td><code id="tar_script_+3A_script">script</code></td>
<td>
<p>Character of length 1, where to write
the target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly).
</p>


<h3>Target script file</h3>

<p>Every <code>targets</code> project requires a target script file.
The target script file is usually a file called <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>
Functions <code><a href="#topic+tar_make">tar_make()</a></code> and friends look for the target script
and run it to set up the pipeline just prior to the main task.
Every target script file should run the following
steps in the order below:
</p>

<ol>
<li><p> Package: load the <code>targets</code> package. This step is automatically
inserted at the top of the target script file produced by
<code>tar_script()</code> if <code>library_targets</code> is <code>TRUE</code>,
so you do not need to explicitly include it in <code>code</code>.
</p>
</li>
<li><p> Globals: load custom functions and global objects into memory.
Usually, this section is a bunch of calls to <code>source()</code> that run
scripts defining user-defined functions. These functions support
the R commands of the targets.
</p>
</li>
<li><p> Options: call <code><a href="#topic+tar_option_set">tar_option_set()</a></code> to set defaults for targets-specific
settings such as the names of required packages. Even if you have no
specific options to set, it is still recommended to call
<code><a href="#topic+tar_option_set">tar_option_set()</a></code> in order to register the proper environment.
</p>
</li>
<li><p> Targets: define one or more target objects using <code><a href="#topic+tar_target">tar_target()</a></code>.
</p>
</li>
<li><p> Pipeline: call <code><a href="base.html#topic+list">list()</a></code> to bring the targets from (3)
together in a pipeline object. Every target script file must return
a pipeline object, which usually means ending with a call to
<code><a href="base.html#topic+list">list()</a></code>. In practice, (3) and (4) can be combined together
in the same function call.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other scripts: 
<code><a href="#topic+tar_edit">tar_edit</a>()</code>,
<code><a href="#topic+tar_github_actions">tar_github_actions</a>()</code>,
<code><a href="#topic+tar_helper">tar_helper</a>()</code>,
<code><a href="#topic+tar_helper_raw">tar_helper_raw</a>()</code>,
<code><a href="#topic+tar_renv">tar_renv</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script() # Writes an example target script file.
# Writes a user-defined target script:
tar_script({
  x &lt;- tar_target(x, 1 + 1)
  tar_option_set()
  list(x)
}, ask = FALSE)
writeLines(readLines("_targets.R"))
})
</code></pre>

<hr>
<h2 id='tar_seed'>Deprecated: get the seed of the current target.</h2><span id='topic+tar_seed'></span>

<h3>Description</h3>

<p>Deprecated on 2023-10-12 (version 1.3.2.9001).
Use <code><a href="#topic+tar_seed_get">tar_seed_get()</a></code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_seed(default = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_seed_+3A_default">default</code></td>
<td>
<p>Integer, value to return if <code>tar_seed_get()</code>
is called on its own outside a <code>targets</code> pipeline.
Having a default lets users run things without <code><a href="#topic+tar_make">tar_make()</a></code>,
which helps peel back layers of code and troubleshoot bugs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer of length 1. If invoked inside a <code>targets</code> pipeline,
the return value is the seed of the target currently running,
which is a deterministic function of the target name. Otherwise,
the return value is <code>default</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_seed()
tar_seed(default = 123L)
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(tar_target(returns_seed, tar_seed()), ask = FALSE)
tar_make()
tar_read(returns_seed)
})
}
</code></pre>

<hr>
<h2 id='tar_seed_create'>Create a seed for a target.</h2><span id='topic+tar_seed_create'></span>

<h3>Description</h3>

<p>Create a seed for a target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_seed_create(name, global_seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_seed_create_+3A_name">name</code></td>
<td>
<p>Character of length 1, target name.</p>
</td></tr>
<tr><td><code id="tar_seed_create_+3A_global_seed">global_seed</code></td>
<td>
<p>Integer of length 1, the overarching global
pipeline seed which governs the seeds of all the targets.
Set to <code>NULL</code> to default to <code>tar_option_get("seed")</code>.
Set to <code>NA</code> to disable seed setting in <code>targets</code> and make
<code><a href="#topic+tar_seed_create">tar_seed_create()</a></code> return <code>NA_integer_</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer of length 1, the target seed.
</p>


<h3>Seeds</h3>

<p>A target's random number generator seed
is a deterministic function of its name and the global pipeline seed
from <code>tar_option_get("seed")</code>. Consequently,
</p>
<div class="sourceCode"><pre>1. Each target runs with a reproducible seed so that
   different runs of the same pipeline in the same computing
   environment produce identical results.
2. No two targets in the same pipeline share the same seed.
   Even dynamic branches have different names and thus different seeds.
</pre></div>
<p>You can retrieve the seed of a completed target
with <code>tar_meta(your_target, seed)</code>
and run <code><a href="#topic+tar_seed_set">tar_seed_set()</a></code> on the result to locally
recreate the target's initial RNG state. <code><a href="#topic+tar_workspace">tar_workspace()</a></code>
does this automatically as part of recovering a workspace.
</p>


<h3>RNG overlap</h3>

<p>In theory, there is a risk that the pseudo-random number generator
streams of different targets will overlap and produce statistically
correlated results. (For a discussion of the motivating problem,
see the Section 6: &quot;Random-number generation&quot; in the <code>parallel</code>
package vignette: <code>vignette(topic = "parallel", package = "parallel")</code>.)
However, this risk is extremely small in practice, as shown by
L'Ecuyer et al. (2017) <a href="https://doi.org/10.1016/j.matcom.2016.05.005">doi:10.1016/j.matcom.2016.05.005</a>
under &quot;A single RNG with a 'random' seed for each stream&quot; (Section 4:
under &quot;How to produce parallel streams and substreams&quot;).
<code>targets</code> and <code>tarchetypes</code> take the approach discussed in the
aforementioned section of the paper using the
<code>secretbase</code> package by Charlie Gao (2024) <a href="https://doi.org/10.5281/zenodo.10553140">doi:10.5281/zenodo.10553140</a>.
To generate the 32-bit integer <code>seed</code> argument of <code>set.seed()</code>
for each target, <code>secretbase</code> generates a cryptographic SHA3 hash
and robustly converts it to 32-bit output using the SHAKE256
extendable output function (XOF). <code>secretbase</code> uses algorithms from
the <code style="white-space: pre;">&#8288;Mbed TLS&#8288;</code> C library.
</p>


<h3>References</h3>


<ul>
<li><p> Gao C (2024). <code>secretbase</code>: Cryptographic Hash and
Extendable-Output Functions. R package version 0.1.0,
<a href="https://doi.org/10.5281/zenodo.10553140">doi:10.5281/zenodo.10553140</a>.
</p>
</li>
<li><p> Pierre L'Ecuyer, David Munger, Boris Oreshkin, and Richard Simard
(2017). Random numbers for parallel computers: Requirements and methods,
with emphasis on GPUs. Mathematics and Computers in Simulation,
135, 3-17. <a href="https://doi.org/10.1016/j.matcom.2016.05.005">doi:10.1016/j.matcom.2016.05.005</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other pseudo-random number generation: 
<code><a href="#topic+tar_seed_get">tar_seed_get</a>()</code>,
<code><a href="#topic+tar_seed_set">tar_seed_set</a>()</code>
</p>

<hr>
<h2 id='tar_seed_get'>Get the random number generator seed of the target currently running.</h2><span id='topic+tar_seed_get'></span>

<h3>Description</h3>

<p>Get the random number generator seed
of the target currently running.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_seed_get(default = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_seed_get_+3A_default">default</code></td>
<td>
<p>Integer, value to return if <code>tar_seed_get()</code>
is called on its own outside a <code>targets</code> pipeline.
Having a default lets users run things without <code><a href="#topic+tar_make">tar_make()</a></code>,
which helps peel back layers of code and troubleshoot bugs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer of length 1. If invoked inside a <code>targets</code> pipeline,
the return value is the seed of the target currently running,
which is a deterministic function of the target name. Otherwise,
the return value is <code>default</code>.
</p>


<h3>Seeds</h3>

<p>A target's random number generator seed
is a deterministic function of its name and the global pipeline seed
from <code>tar_option_get("seed")</code>. Consequently,
</p>
<div class="sourceCode"><pre>1. Each target runs with a reproducible seed so that
   different runs of the same pipeline in the same computing
   environment produce identical results.
2. No two targets in the same pipeline share the same seed.
   Even dynamic branches have different names and thus different seeds.
</pre></div>
<p>You can retrieve the seed of a completed target
with <code>tar_meta(your_target, seed)</code>
and run <code><a href="#topic+tar_seed_set">tar_seed_set()</a></code> on the result to locally
recreate the target's initial RNG state. <code><a href="#topic+tar_workspace">tar_workspace()</a></code>
does this automatically as part of recovering a workspace.
</p>


<h3>RNG overlap</h3>

<p>In theory, there is a risk that the pseudo-random number generator
streams of different targets will overlap and produce statistically
correlated results. (For a discussion of the motivating problem,
see the Section 6: &quot;Random-number generation&quot; in the <code>parallel</code>
package vignette: <code>vignette(topic = "parallel", package = "parallel")</code>.)
However, this risk is extremely small in practice, as shown by
L'Ecuyer et al. (2017) <a href="https://doi.org/10.1016/j.matcom.2016.05.005">doi:10.1016/j.matcom.2016.05.005</a>
under &quot;A single RNG with a 'random' seed for each stream&quot; (Section 4:
under &quot;How to produce parallel streams and substreams&quot;).
<code>targets</code> and <code>tarchetypes</code> take the approach discussed in the
aforementioned section of the paper using the
<code>secretbase</code> package by Charlie Gao (2024) <a href="https://doi.org/10.5281/zenodo.10553140">doi:10.5281/zenodo.10553140</a>.
To generate the 32-bit integer <code>seed</code> argument of <code>set.seed()</code>
for each target, <code>secretbase</code> generates a cryptographic SHA3 hash
and robustly converts it to 32-bit output using the SHAKE256
extendable output function (XOF). <code>secretbase</code> uses algorithms from
the <code style="white-space: pre;">&#8288;Mbed TLS&#8288;</code> C library.
</p>


<h3>References</h3>


<ul>
<li><p> Gao C (2024). <code>secretbase</code>: Cryptographic Hash and
Extendable-Output Functions. R package version 0.1.0,
<a href="https://doi.org/10.5281/zenodo.10553140">doi:10.5281/zenodo.10553140</a>.
</p>
</li>
<li><p> Pierre L'Ecuyer, David Munger, Boris Oreshkin, and Richard Simard
(2017). Random numbers for parallel computers: Requirements and methods,
with emphasis on GPUs. Mathematics and Computers in Simulation,
135, 3-17. <a href="https://doi.org/10.1016/j.matcom.2016.05.005">doi:10.1016/j.matcom.2016.05.005</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other pseudo-random number generation: 
<code><a href="#topic+tar_seed_create">tar_seed_create</a>()</code>,
<code><a href="#topic+tar_seed_set">tar_seed_set</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_seed_get()
tar_seed_get(default = 123L)
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(tar_target(returns_seed, tar_seed_get()), ask = FALSE)
tar_make()
tar_read(returns_seed)
})
}
</code></pre>

<hr>
<h2 id='tar_seed_set'>Set a seed to run a target.</h2><span id='topic+tar_seed_set'></span>

<h3>Description</h3>

<p><code>targets</code> generates its own target-specific seeds
using <code><a href="#topic+tar_seed_create">tar_seed_create()</a></code>. Use <code><a href="#topic+tar_seed_set">tar_seed_set()</a></code> to set one of
these seeds in R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_seed_set(seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_seed_set_+3A_seed">seed</code></td>
<td>
<p>Integer of length 1, value of the seed to set
with <code>set.seed()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+tar_seed_set">tar_seed_set()</a></code> gives the user-supplied <code>seed</code> to
<code>set.seed()</code> and sets arguments <code>kind = "default"</code>,
<code>normal.kind = "default"</code>, and <code>sample.kind = "default"</code>.
</p>


<h3>Value</h3>

<p><code>NULL</code> (invisibly).
</p>


<h3>Seeds</h3>

<p>A target's random number generator seed
is a deterministic function of its name and the global pipeline seed
from <code>tar_option_get("seed")</code>. Consequently,
</p>
<div class="sourceCode"><pre>1. Each target runs with a reproducible seed so that
   different runs of the same pipeline in the same computing
   environment produce identical results.
2. No two targets in the same pipeline share the same seed.
   Even dynamic branches have different names and thus different seeds.
</pre></div>
<p>You can retrieve the seed of a completed target
with <code>tar_meta(your_target, seed)</code>
and run <code><a href="#topic+tar_seed_set">tar_seed_set()</a></code> on the result to locally
recreate the target's initial RNG state. <code><a href="#topic+tar_workspace">tar_workspace()</a></code>
does this automatically as part of recovering a workspace.
</p>


<h3>RNG overlap</h3>

<p>In theory, there is a risk that the pseudo-random number generator
streams of different targets will overlap and produce statistically
correlated results. (For a discussion of the motivating problem,
see the Section 6: &quot;Random-number generation&quot; in the <code>parallel</code>
package vignette: <code>vignette(topic = "parallel", package = "parallel")</code>.)
However, this risk is extremely small in practice, as shown by
L'Ecuyer et al. (2017) <a href="https://doi.org/10.1016/j.matcom.2016.05.005">doi:10.1016/j.matcom.2016.05.005</a>
under &quot;A single RNG with a 'random' seed for each stream&quot; (Section 4:
under &quot;How to produce parallel streams and substreams&quot;).
<code>targets</code> and <code>tarchetypes</code> take the approach discussed in the
aforementioned section of the paper using the
<code>secretbase</code> package by Charlie Gao (2024) <a href="https://doi.org/10.5281/zenodo.10553140">doi:10.5281/zenodo.10553140</a>.
To generate the 32-bit integer <code>seed</code> argument of <code>set.seed()</code>
for each target, <code>secretbase</code> generates a cryptographic SHA3 hash
and robustly converts it to 32-bit output using the SHAKE256
extendable output function (XOF). <code>secretbase</code> uses algorithms from
the <code style="white-space: pre;">&#8288;Mbed TLS&#8288;</code> C library.
</p>


<h3>References</h3>


<ul>
<li><p> Gao C (2024). <code>secretbase</code>: Cryptographic Hash and
Extendable-Output Functions. R package version 0.1.0,
<a href="https://doi.org/10.5281/zenodo.10553140">doi:10.5281/zenodo.10553140</a>.
</p>
</li>
<li><p> Pierre L'Ecuyer, David Munger, Boris Oreshkin, and Richard Simard
(2017). Random numbers for parallel computers: Requirements and methods,
with emphasis on GPUs. Mathematics and Computers in Simulation,
135, 3-17. <a href="https://doi.org/10.1016/j.matcom.2016.05.005">doi:10.1016/j.matcom.2016.05.005</a>.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other pseudo-random number generation: 
<code><a href="#topic+tar_seed_create">tar_seed_create</a>()</code>,
<code><a href="#topic+tar_seed_get">tar_seed_get</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seed &lt;- tar_seed_create("target_name")
seed
sample(10)
tar_seed_set(seed)
sample(10)
tar_seed_set(seed)
sample(10)
</code></pre>

<hr>
<h2 id='tar_sitrep'>Show the cue-by-cue status of each target.</h2><span id='topic+tar_sitrep'></span>

<h3>Description</h3>

<p>For each target, report which cues are activated.
Except for the <code>never</code> cue, the target will rerun in <code><a href="#topic+tar_make">tar_make()</a></code>
if any cue is activated. The target is suppressed if the <code>never</code>
cue is <code>TRUE</code>. See <code><a href="#topic+tar_cue">tar_cue()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_sitrep(
  names = NULL,
  fields = NULL,
  shortcut = targets::tar_config_get("shortcut"),
  reporter = targets::tar_config_get("reporter_outdated"),
  callr_function = callr::r,
  callr_arguments = targets::tar_callr_args_default(callr_function, reporter),
  envir = parent.frame(),
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_sitrep_+3A_names">names</code></td>
<td>
<p>Optional, names of the targets. If supplied, <code>tar_sitrep()</code>
only returns metadata on these targets.
The object supplied to <code>names</code> should be <code>NULL</code> or a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_sitrep_+3A_fields">fields</code></td>
<td>
<p>Optional, names of columns/fields to select. If supplied,
<code>tar_sitrep()</code> only returns the selected metadata columns.
You can supply symbols or <code>tidyselect</code> helpers
like <code><a href="#topic+any_of">any_of()</a></code> and <code><a href="#topic+starts_with">starts_with()</a></code>.
The <code>name</code> column is always included first
no matter what you select. Choices:
</p>

<ul>
<li> <p><code>name</code>: name of the target or global object.
</p>
</li>
<li> <p><code>record</code>: Whether the <code>record</code> cue is activated:
<code>TRUE</code> if the target is not in the metadata (<code><a href="#topic+tar_meta">tar_meta()</a></code>),
or if the target errored during the last <code><a href="#topic+tar_make">tar_make()</a></code>,
or if the class of the target changed.
</p>
</li>
<li> <p><code>always</code>: Whether <code>mode</code> in <code><a href="#topic+tar_cue">tar_cue()</a></code> is <code>"always"</code>.
If <code>TRUE</code>, <code><a href="#topic+tar_make">tar_make()</a></code> always runs the target.
</p>
</li>
<li> <p><code>never</code>: Whether <code>mode</code> in <code><a href="#topic+tar_cue">tar_cue()</a></code> is <code>"never"</code>.
If <code>TRUE</code>, <code><a href="#topic+tar_make">tar_make()</a></code> will only run if the
<code>record</code> cue activates.
</p>
</li>
<li> <p><code>command</code>: Whether the target's command changed since last time.
Always <code>TRUE</code> if the <code>record</code> cue is activated.
Otherwise, always <code>FALSE</code> if the <code>command</code> cue is suppressed.
</p>
</li>
<li> <p><code>depend</code>: Whether the data/output of at least one of the target's
dependencies changed since last time.
Dependencies are targets, functions,
and global objects directly upstream.
Call <code>tar_outdated(targets_only = FALSE)</code> or
<code>tar_visnetwork(targets_only = FALSE)</code> to see exactly which
dependencies are outdated.
Always <code>NA</code> if the <code>record</code> cue is activated.
Otherwise, always <code>FALSE</code> if the <code>depend</code> cue is suppressed.
</p>
</li>
<li> <p><code>format</code>: Whether the storage format of the target
is different from last time.
Always <code>NA</code> if the <code>record</code> cue is activated.
Otherwise, always <code>FALSE</code> if the <code>format</code> cue is suppressed.
</p>
</li>
<li> <p><code>repository</code>: Whether the storage repository of the target
is different from last time.
Always <code>NA</code> if the <code>record</code> cue is activated.
Otherwise, always <code>FALSE</code> if the <code>format</code> cue is suppressed.
</p>
</li>
<li> <p><code>iteration</code>: Whether the iteration mode of the target
is different from last time.
Always <code>NA</code> if the <code>record</code> cue is activated.
Otherwise, always <code>FALSE</code> if the <code>iteration</code> cue is suppressed.
</p>
</li>
<li> <p><code>file</code>: Whether the file(s) with the target's return value
are missing or different from last time.
Always <code>NA</code> if the <code>record</code> cue is activated.
Otherwise, always <code>FALSE</code> if the <code>file</code> cue is suppressed.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_sitrep_+3A_shortcut">shortcut</code></td>
<td>
<p>Logical of length 1, how to interpret the <code>names</code> argument.
If <code>shortcut</code> is <code>FALSE</code> (default) then the function checks
all targets upstream of <code>names</code> as far back as the dependency graph goes.
If <code>TRUE</code>, then the function only checks the targets in <code>names</code>
and uses stored metadata for information about upstream dependencies
as needed. <code>shortcut = TRUE</code> increases speed if there are a lot of
up-to-date targets, but it assumes all the dependencies
are up to date, so please use with caution.
Use with caution. <code>shortcut = TRUE</code> only works if you set <code>names</code>.</p>
</td></tr>
<tr><td><code id="tar_sitrep_+3A_reporter">reporter</code></td>
<td>
<p>Character of length 1, name of the reporter to user.
Controls how messages are printed as targets are checked. Choices:
</p>

<ul>
<li> <p><code>"silent"</code>: print nothing.
</p>
</li>
<li> <p><code>"forecast"</code>: print running totals of the checked and outdated
targets found so far.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_sitrep_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_sitrep_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
<tr><td><code id="tar_sitrep_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_sitrep_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_sitrep_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Caveats:
</p>

<ul>
<li> <p><code><a href="#topic+tar_cue">tar_cue()</a></code> allows you to change/suppress cues, so the return
value will depend on the settings you supply to <code><a href="#topic+tar_cue">tar_cue()</a></code>.
</p>
</li>
<li><p> If a pattern tries to branches over a target that does not exist
in storage, then the branches are omitted from the output.
</p>
</li>
<li> <p><code>tar_sitrep()</code> is myopic. It only considers what happens to the
immediate target and its immediate upstream dependencies,
and it makes no attempt to propagate invalidation downstream.
</p>
</li></ul>



<h3>Value</h3>

<p>A data frame with one row per target/object and one column
per cue. Each element is a logical to indicate whether the cue
is activated for the target.
See the <code>field</code> argument in this help file for details.
</p>


<h3>See Also</h3>

<p>Other inspect: 
<code><a href="#topic+tar_deps">tar_deps</a>()</code>,
<code><a href="#topic+tar_deps_raw">tar_deps_raw</a>()</code>,
<code><a href="#topic+tar_manifest">tar_manifest</a>()</code>,
<code><a href="#topic+tar_network">tar_network</a>()</code>,
<code><a href="#topic+tar_outdated">tar_outdated</a>()</code>,
<code><a href="#topic+tar_validate">tar_validate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(2)),
    tar_target(y, 2 * x, pattern = map(x))
  )
}, ask = FALSE)
tar_make()
tar_sitrep()
tar_meta(starts_with("y_")) # see also any_of()
})
}
</code></pre>

<hr>
<h2 id='tar_skipped'>List skipped targets.</h2><span id='topic+tar_skipped'></span>

<h3>Description</h3>

<p>List targets whose progress is <code>"skipped"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_skipped(names = NULL, store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_skipped_+3A_names">names</code></td>
<td>
<p>Optional, names of the targets. If supplied, the
output is restricted to the selected targets.
The object supplied to <code>names</code> should be <code>NULL</code> or a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_skipped_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of skipped targets.
</p>


<h3>See Also</h3>

<p>Other progress: 
<code><a href="#topic+tar_canceled">tar_canceled</a>()</code>,
<code><a href="#topic+tar_completed">tar_completed</a>()</code>,
<code><a href="#topic+tar_dispatched">tar_dispatched</a>()</code>,
<code><a href="#topic+tar_errored">tar_errored</a>()</code>,
<code><a href="#topic+tar_poll">tar_poll</a>()</code>,
<code><a href="#topic+tar_progress">tar_progress</a>()</code>,
<code><a href="#topic+tar_progress_branches">tar_progress_branches</a>()</code>,
<code><a href="#topic+tar_progress_summary">tar_progress_summary</a>()</code>,
<code><a href="#topic+tar_watch">tar_watch</a>()</code>,
<code><a href="#topic+tar_watch_server">tar_watch_server</a>()</code>,
<code><a href="#topic+tar_watch_ui">tar_watch_ui</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(2)),
    tar_target(y, 2 * x, pattern = map(x))
  )
}, ask = FALSE)
tar_make()
tar_skipped()
tar_skipped(starts_with("y_")) # see also any_of()
})
}
</code></pre>

<hr>
<h2 id='tar_source'>Run R scripts.</h2><span id='topic+tar_source'></span>

<h3>Description</h3>

<p>Run all the R scripts in a directory
in the environment specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_source(
  files = "R",
  envir = targets::tar_option_get("envir"),
  change_directory = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_source_+3A_files">files</code></td>
<td>
<p>Character vector of file and directory paths
to look for R scripts to run. Paths must either be absolute
paths or must be relative to the current working directory
just before the function call.</p>
</td></tr>
<tr><td><code id="tar_source_+3A_envir">envir</code></td>
<td>
<p>Environment to run the scripts. Defaults to
<code>tar_option_get("envir")</code>, the environment of the pipeline.</p>
</td></tr>
<tr><td><code id="tar_source_+3A_change_directory">change_directory</code></td>
<td>
<p>Logical, whether to temporarily change
the working directory to the directory of each R script
before running it.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_source()</code> is a convenient way to load R scripts
in <code style="white-space: pre;">&#8288;_targets.R&#8288;</code> to make custom functions available to the pipeline.
<code>tar_source()</code> recursively looks for files ending
in <code>.R</code> or <code>.r</code>, and it runs each with
<code>eval(parse(text = readLines(script_file, warn = FALSE)), envir)</code>.
</p>


<h3>Value</h3>

<p><code>NULL</code> (invisibly)
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+tar_active">tar_active</a>()</code>,
<code><a href="#topic+tar_backoff">tar_backoff</a>()</code>,
<code><a href="#topic+tar_call">tar_call</a>()</code>,
<code><a href="#topic+tar_cancel">tar_cancel</a>()</code>,
<code><a href="#topic+tar_definition">tar_definition</a>()</code>,
<code><a href="#topic+tar_described_as">tar_described_as</a>()</code>,
<code><a href="#topic+tar_envir">tar_envir</a>()</code>,
<code><a href="#topic+tar_group">tar_group</a>()</code>,
<code><a href="#topic+tar_name">tar_name</a>()</code>,
<code><a href="#topic+tar_path">tar_path</a>()</code>,
<code><a href="#topic+tar_path_script">tar_path_script</a>()</code>,
<code><a href="#topic+tar_path_script_support">tar_path_script_support</a>()</code>,
<code><a href="#topic+tar_path_store">tar_path_store</a>()</code>,
<code><a href="#topic+tar_path_target">tar_path_target</a>()</code>,
<code><a href="#topic+tar_store">tar_store</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
# Running in tar_dir(), these files are written in tempdir().
dir.create("R")
writeLines("f &lt;- function(x) x + 1", file.path("R", "functions.R"))
tar_script({
  tar_source()
  list(tar_target(x, f(1)))
})
tar_make()
tar_read(x) # 2
})
}
</code></pre>

<hr>
<h2 id='tar_started'>Deprecated: list started targets.</h2><span id='topic+tar_started'></span>

<h3>Description</h3>

<p>Deprecated in favor of <code><a href="#topic+tar_dispatched">tar_dispatched()</a></code> on 2023-12-04
(version 1.3.2.9004).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_started(names = NULL, store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_started_+3A_names">names</code></td>
<td>
<p>Optional, names of the targets. If supplied, the
output is restricted to the selected targets.
The object supplied to <code>names</code> should be <code>NULL</code> or a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_started_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of dispatched targets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(
    tar_target(x, seq_len(2)),
    tar_target(y, 2 * x, pattern = map(x))
  )
}, ask = FALSE)
tar_make()
tar_dispatched()
tar_dispatched(starts_with("y_")) # see also any_of()
})
}
</code></pre>

<hr>
<h2 id='tar_store'>Deprecated: current data store path</h2><span id='topic+tar_store'></span>

<h3>Description</h3>

<p>Deprecated: identify the file path to the data store
of the pipeline currently running.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_store()
</code></pre>


<h3>Details</h3>

<p><code>tar_store()</code> was deprecated on 2022-10-11 (version 0.13.5.9000).
Use <code><a href="#topic+tar_path_store">tar_path_store()</a></code> instead.
</p>


<h3>Value</h3>

<p>Character, file path to the data store
of the pipeline currently running.
If called outside of the pipeline currently running,
<code>tar_store()</code> returns <code>tar_config_get("store")</code>.
</p>


<h3>See Also</h3>

<p>Other utilities: 
<code><a href="#topic+tar_active">tar_active</a>()</code>,
<code><a href="#topic+tar_backoff">tar_backoff</a>()</code>,
<code><a href="#topic+tar_call">tar_call</a>()</code>,
<code><a href="#topic+tar_cancel">tar_cancel</a>()</code>,
<code><a href="#topic+tar_definition">tar_definition</a>()</code>,
<code><a href="#topic+tar_described_as">tar_described_as</a>()</code>,
<code><a href="#topic+tar_envir">tar_envir</a>()</code>,
<code><a href="#topic+tar_group">tar_group</a>()</code>,
<code><a href="#topic+tar_name">tar_name</a>()</code>,
<code><a href="#topic+tar_path">tar_path</a>()</code>,
<code><a href="#topic+tar_path_script">tar_path_script</a>()</code>,
<code><a href="#topic+tar_path_script_support">tar_path_script_support</a>()</code>,
<code><a href="#topic+tar_path_store">tar_path_store</a>()</code>,
<code><a href="#topic+tar_path_target">tar_path_target</a>()</code>,
<code><a href="#topic+tar_source">tar_source</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_path_store()
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(tar_target(x, tar_path_store()), ask = FALSE)
store &lt;- tempfile()
tar_make(store = store)
tar_read(x, store = store)
})
}
</code></pre>

<hr>
<h2 id='tar_target'>Declare a target.</h2><span id='topic+tar_target'></span>

<h3>Description</h3>

<p>A target is a single step of computation in a pipeline.
It runs an R command and returns a value.
This value gets treated as an R object that can be used
by the commands of targets downstream. Targets that
are already up to date are skipped. See the user manual
for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_target(
  name,
  command,
  pattern = NULL,
  tidy_eval = targets::tar_option_get("tidy_eval"),
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_target_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_target_+3A_command">command</code></td>
<td>
<p>R code to run the target.</p>
</td></tr>
<tr><td><code id="tar_target_+3A_pattern">pattern</code></td>
<td>
<p>Language to define branching for a target.
For example, in a pipeline with numeric vector targets <code>x</code> and <code>y</code>,
<code>tar_target(z, x + y, pattern = map(x, y))</code> implicitly defines
branches of <code>z</code> that each compute <code>x[1] + y[1]</code>, <code>x[2] + y[2]</code>,
and so on. See the user manual for details.</p>
</td></tr>
<tr><td><code id="tar_target_+3A_tidy_eval">tidy_eval</code></td>
<td>
<p>Logical, whether to enable tidy evaluation
when interpreting <code>command</code> and <code>pattern</code>. If <code>TRUE</code>, you can use the
&quot;bang-bang&quot; operator <code style="white-space: pre;">&#8288;!!&#8288;</code> to programmatically insert
the values of global objects.</p>
</td></tr>
<tr><td><code id="tar_target_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_target_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_target_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_target_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_target_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vctrs::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a non-dynamic data frame.
For <code>iteration = "group"</code>, the target must not by dynamic
(the <code>pattern</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code> must be left <code>NULL</code>).
The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code><a href="#topic+tar_group">tar_group()</a></code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_target_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_target_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_target_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_target_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_target_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_target_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_target_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_target_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_target_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_target_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A target object. Users should not modify these directly,
just feed them to <code><a href="base.html#topic+list">list()</a></code> in your target script file
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>).
</p>


<h3>Target objects</h3>

<p>Functions like <code>tar_target()</code> produce target objects,
special objects with specialized sets of S3 classes.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>Storage formats</h3>


<ul>
<li> <p><code>"rds"</code>: Default, uses <code>saveRDS()</code> and <code>readRDS()</code>. Should work for
most objects, but slow.
</p>
</li>
<li> <p><code>"qs"</code>: Uses <code>qs::qsave()</code> and <code>qs::qread()</code>. Should work for
most objects, much faster than <code>"rds"</code>. Optionally set the
preset for <code>qsave()</code> through <code>tar_resources()</code> and <code>tar_resources_qs()</code>.
</p>
</li>
<li> <p><code>"feather"</code>: Uses <code>arrow::write_feather()</code> and
<code>arrow::read_feather()</code> (version 2.0). Much faster than <code>"rds"</code>,
but the value must be a data frame. Optionally set
<code>compression</code> and <code>compression_level</code> in <code>arrow::write_feather()</code>
through <code>tar_resources()</code> and <code>tar_resources_feather()</code>.
Requires the <code>arrow</code> package (not installed by default).
</p>
</li>
<li> <p><code>"parquet"</code>: Uses <code>arrow::write_parquet()</code> and
<code>arrow::read_parquet()</code> (version 2.0). Much faster than <code>"rds"</code>,
but the value must be a data frame. Optionally set
<code>compression</code> and <code>compression_level</code> in <code>arrow::write_parquet()</code>
through <code>tar_resources()</code> and <code>tar_resources_parquet()</code>.
Requires the <code>arrow</code> package (not installed by default).
</p>
</li>
<li> <p><code>"fst"</code>: Uses <code>fst::write_fst()</code> and <code>fst::read_fst()</code>.
Much faster than <code>"rds"</code>, but the value must be
a data frame. Optionally set the compression level for
<code>fst::write_fst()</code> through <code>tar_resources()</code> and <code>tar_resources_fst()</code>.
Requires the <code>fst</code> package (not installed by default).
</p>
</li>
<li> <p><code>"fst_dt"</code>: Same as <code>"fst"</code>, but the value is a <code>data.table</code>.
Deep copies are made as appropriate in order to protect
against the global effects of in-place modification.
Optionally set the compression level the same way as for <code>"fst"</code>.
</p>
</li>
<li> <p><code>"fst_tbl"</code>: Same as <code>"fst"</code>, but the value is a <code>tibble</code>.
Optionally set the compression level the same way as for <code>"fst"</code>.
</p>
</li>
<li> <p><code>"keras"</code>: superseded by <code><a href="#topic+tar_format">tar_format()</a></code> and incompatible
with <code>error = "null"</code> (in <code><a href="#topic+tar_target">tar_target()</a></code> or <code><a href="#topic+tar_option_set">tar_option_set()</a></code>).
Uses <code>keras::save_model_hdf5()</code> and
<code>keras::load_model_hdf5()</code>. The value must be a Keras model.
Requires the <code>keras</code> package (not installed by default).
</p>
</li>
<li> <p><code>"torch"</code>: superseded by <code><a href="#topic+tar_format">tar_format()</a></code> and incompatible
with <code>error = "null"</code> (in <code><a href="#topic+tar_target">tar_target()</a></code> or <code><a href="#topic+tar_option_set">tar_option_set()</a></code>).
Uses <code>torch::torch_save()</code> and <code>torch::torch_load()</code>.
The value must be an object from the <code>torch</code> package
such as a tensor or neural network module.
Requires the <code>torch</code> package (not installed by default).
</p>
</li>
<li> <p><code>"file"</code>: A dynamic file. To use this format,
the target needs to manually identify or save some data
and return a character vector of paths
to the data (must be a single file path if <code>repository</code>
is not <code>"local"</code>). (These paths must be existing files
and nonempty directories.)
Then, <code>targets</code> automatically checks those files and cues
the appropriate run/skip decisions if those files are out of date.
Those paths must point to files or directories,
and they must not contain characters <code>|</code> or <code>*</code>.
All the files and directories you return must actually exist,
or else <code>targets</code> will throw an error. (And if <code>storage</code> is <code>"worker"</code>,
<code>targets</code> will first stall out trying to wait for the file
to arrive over a network file system.)
If the target does not create any files, the return value should be
<code>character(0)</code>.
</p>
<p>If <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>,
then the character vector returned by the target must be of length 1
and point to a single file. (Directories and vectors of multiple
file paths are not supported for dynamic files on the cloud.)
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.
</p>
<p>To check if the file is up to date, <code>targets</code> avoids timestamps
and always recomputes the hash. If you find this to be too slow,
and if you trust the time stamps on your file system
(see the <code>trust_object_timestamps</code> argument of <code><a href="#topic+tar_option_set">tar_option_set()</a></code>),
then consider <code>format = "file_fast"</code> instead.
</p>
</li>
<li> <p><code>"file_fast"</code>: same as <code>format = "file"</code>, except that <code>targets</code>
uses time stamps to check if a file is up to date. If the time stamp
of the file agrees with the time stamp in the metadata, the
file is considered up to date. Otherwise, <code>targets</code> recomputes the
hash of the file to make a final determination. Low-precision
timestamps are not reliable for this, and some file systems
have timestamp precision as poor as 2 seconds. See the
<code>trust_object_timestamps</code> argument of <code><a href="#topic+tar_option_set">tar_option_set()</a></code>
for advice on this.
</p>
</li>
<li> <p><code>"url"</code>: A dynamic input URL. For this storage format,
<code>repository</code> is implicitly <code>"local"</code>,
URL format is like <code>format = "file"</code>
except the return value of the target is a URL that already exists
and serves as input data for downstream targets. Optionally
supply a custom <code>curl</code> handle through
<code>tar_resources()</code> and <code>tar_resources_url()</code>.
in <code>new_handle()</code>, <code>nobody = TRUE</code> is important because it
ensures <code>targets</code> just downloads the metadata instead of
the entire data file when it checks time stamps and hashes.
The data file at the URL needs to have an ETag or a Last-Modified
time stamp, or else the target will throw an error because
it cannot track the data. Also, use extreme caution when
trying to use <code>format = "url"</code> to track uploads. You must be absolutely
certain the ETag and Last-Modified time stamp are fully updated
and available by the time the target's command finishes running.
<code>targets</code> makes no attempt to wait for the web server.
</p>
</li>
<li><p> A custom format can be supplied with <code>tar_format()</code>. For this choice,
it is the user's responsibility to provide methods for (un)serialization
and (un)marshaling the return value of the target.
</p>
</li>
<li><p> The formats starting with <code>"aws_"</code> are deprecated as of 2022-03-13
(<code>targets</code> version &gt; 0.10.0). For cloud storage integration, use the
<code>repository</code> argument instead.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other targets: 
<code><a href="#topic+tar_cue">tar_cue</a>()</code>,
<code><a href="#topic+tar_format">tar_format</a>()</code>,
<code><a href="#topic+tar_target_raw">tar_target_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Defining targets does not run them.
data &lt;- tar_target(target_name, get_data(), packages = "tidyverse")
analysis &lt;- tar_target(analysis, analyze(x), pattern = map(x))
# Pipelines accept targets.
pipeline &lt;- list(data, analysis)
# Tidy evaluation
tar_option_set(envir = environment())
n_rows &lt;- 30L
data &lt;- tar_target(target_name, get_data(!!n_rows))
print(data)
# Disable tidy evaluation:
data &lt;- tar_target(target_name, get_data(!!n_rows), tidy_eval = FALSE)
print(data)
tar_option_reset()
# In a pipeline:
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(tar_target(x, 1 + 1), ask = FALSE)
tar_make()
tar_read(x)
})
}
</code></pre>

<hr>
<h2 id='tar_target_raw'>Define a target using unrefined names and language objects.</h2><span id='topic+tar_target_raw'></span>

<h3>Description</h3>

<p><code>tar_target_raw()</code> is just like <code><a href="#topic+tar_target">tar_target()</a></code> except
it avoids non-standard evaluation for the arguments: <code>name</code>
is a character string, <code>command</code> and <code>pattern</code> are language objects,
and there is no <code>tidy_eval</code> argument. Use <code>tar_target_raw()</code>
instead of <code><a href="#topic+tar_target">tar_target()</a></code> if you are creating entire batches
of targets programmatically (metaprogramming, static branching).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_target_raw(
  name,
  command,
  pattern = NULL,
  packages = targets::tar_option_get("packages"),
  library = targets::tar_option_get("library"),
  deps = NULL,
  string = NULL,
  format = targets::tar_option_get("format"),
  repository = targets::tar_option_get("repository"),
  iteration = targets::tar_option_get("iteration"),
  error = targets::tar_option_get("error"),
  memory = targets::tar_option_get("memory"),
  garbage_collection = targets::tar_option_get("garbage_collection"),
  deployment = targets::tar_option_get("deployment"),
  priority = targets::tar_option_get("priority"),
  resources = targets::tar_option_get("resources"),
  storage = targets::tar_option_get("storage"),
  retrieval = targets::tar_option_get("retrieval"),
  cue = targets::tar_option_get("cue"),
  description = targets::tar_option_get("description")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_target_raw_+3A_name">name</code></td>
<td>
<p>Character of length 1, name of the target. A target
name must be a valid name for a symbol in R, and it
must not start with a dot. Subsequent targets
can refer to this name symbolically to induce a dependency relationship:
e.g. <code>tar_target(downstream_target, f(upstream_target))</code> is a
target named <code>downstream_target</code> which depends on a target
<code>upstream_target</code> and a function <code>f()</code>. In addition, a target's
name determines its random number generator seed. In this way,
each target runs with a reproducible seed so someone else
running the same pipeline should get the same results,
and no two targets in the same pipeline share the same seed.
(Even dynamic branches have different names and thus different seeds.)
You can recover the seed of a completed target
with <code>tar_meta(your_target, seed)</code> and run <code><a href="#topic+tar_seed_set">tar_seed_set()</a></code>
on the result to locally recreate the target's initial RNG state.</p>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_command">command</code></td>
<td>
<p>Similar to the <code>command</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code> except
the object must already be an expression instead of
informally quoted code.
<code>base::expression()</code> and <code>base::quote()</code> can produce such objects.</p>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_pattern">pattern</code></td>
<td>
<p>Similar to the <code>pattern</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code>
except the object must already be an expression instead of
informally quoted code.
<code>base::expression()</code> and <code>base::quote()</code> can produce such objects.</p>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_packages">packages</code></td>
<td>
<p>Character vector of packages to load right before
the target runs or the output data is reloaded for
downstream targets. Use <code>tar_option_set()</code> to set packages
globally for all subsequent targets you define.</p>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_library">library</code></td>
<td>
<p>Character vector of library paths to try
when loading <code>packages</code>.</p>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_deps">deps</code></td>
<td>
<p>Optional character vector of the adjacent upstream
dependencies of the target, including targets and global objects.
If <code>NULL</code>, dependencies are resolved automatically as usual.
The <code>deps</code> argument is only for developers of extension
packages such as <code>tarchetypes</code>,
not for end users, and it should almost never be used at all.
In scenarios that at first appear to requires <code>deps</code>,
there is almost always a simpler and more robust workaround
that avoids setting <code>deps</code>.</p>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_string">string</code></td>
<td>
<p>Optional string representation of the command.
Internally, the string gets hashed to check if the command changed
since last run, which helps <code>targets</code> decide whether the
target is up to date. External interfaces can take control of
<code>string</code> to ignore changes in certain parts of the command.
If <code>NULL</code>, the strings is just deparsed from <code>command</code> (default).</p>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_format">format</code></td>
<td>
<p>Optional storage format for the target's return value.
With the exception of <code>format = "file"</code>, each target
gets a file in <code style="white-space: pre;">&#8288;_targets/objects&#8288;</code>, and each format is a different
way to save and load this file. See the &quot;Storage formats&quot; section
for a detailed list of possible data storage formats.</p>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_repository">repository</code></td>
<td>
<p>Character of length 1, remote repository for target
storage. Choices:
</p>

<ul>
<li> <p><code>"local"</code>: file system of the local machine.
</p>
</li>
<li> <p><code>"aws"</code>: Amazon Web Services (AWS) S3 bucket. Can be configured
with a non-AWS S3 bucket using the <code>endpoint</code> argument of
<code><a href="#topic+tar_resources_aws">tar_resources_aws()</a></code>, but versioning capabilities may be lost
in doing so.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li>
<li> <p><code>"gcp"</code>: Google Cloud Platform storage bucket.
See the cloud storage section of
<a href="https://books.ropensci.org/targets/data.html">https://books.ropensci.org/targets/data.html</a>
for details for instructions.
</p>
</li></ul>

<p>Note: if <code>repository</code> is not <code>"local"</code> and <code>format</code> is <code>"file"</code>
then the target should create a single output file.
That output file is uploaded to the cloud and tracked for changes
where it exists in the cloud. The local file is deleted after
the target runs.</p>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_iteration">iteration</code></td>
<td>
<p>Character of length 1, name of the iteration mode
of the target. Choices:
</p>

<ul>
<li> <p><code>"vector"</code>: branching happens with <code>vctrs::vec_slice()</code> and
aggregation happens with <code>vctrs::vec_c()</code>.
</p>
</li>
<li> <p><code>"list"</code>, branching happens with <code style="white-space: pre;">&#8288;[[]]&#8288;</code> and aggregation happens with
<code>list()</code>.
</p>
</li>
<li> <p><code>"group"</code>: <code>dplyr::group_by()</code>-like functionality to branch over
subsets of a non-dynamic data frame.
For <code>iteration = "group"</code>, the target must not by dynamic
(the <code>pattern</code> argument of <code><a href="#topic+tar_target">tar_target()</a></code> must be left <code>NULL</code>).
The target's return value must be a data
frame with a special <code>tar_group</code> column of consecutive integers
from 1 through the number of groups. Each integer designates a group,
and a branch is created for each collection of rows in a group.
See the <code><a href="#topic+tar_group">tar_group()</a></code> function to see how you can
create the special <code>tar_group</code> column with <code>dplyr::group_by()</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_error">error</code></td>
<td>
<p>Character of length 1, what to do if the target
stops and throws an error. Options:
</p>

<ul>
<li> <p><code>"stop"</code>: the whole pipeline stops and throws an error.
</p>
</li>
<li> <p><code>"continue"</code>: the whole pipeline keeps going.
</p>
</li>
<li> <p><code>"abridge"</code>: any currently running targets keep running,
but no new targets launch after that.
(Visit <a href="https://books.ropensci.org/targets/debugging.html">https://books.ropensci.org/targets/debugging.html</a>
to learn how to debug targets using saved workspaces.)
</p>
</li>
<li> <p><code>"null"</code>: The errored target continues and returns <code>NULL</code>.
The data hash is deliberately wrong so the target is not
up to date for the next run of the pipeline.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_memory">memory</code></td>
<td>
<p>Character of length 1, memory strategy.
If <code>"persistent"</code>, the target stays in memory
until the end of the pipeline (unless <code>storage</code> is <code>"worker"</code>,
in which case <code>targets</code> unloads the value from memory
right after storing it in order to avoid sending
copious data over a network).
If <code>"transient"</code>, the target gets unloaded
after every new target completes.
Either way, the target gets automatically loaded into memory
whenever another target needs the value.
For cloud-based dynamic files
(e.g. <code>format = "file"</code> with <code>repository = "aws"</code>),
this memory strategy applies to the
temporary local copy of the file:
<code>"persistent"</code> means it remains until the end of the pipeline
and is then deleted,
and <code>"transient"</code> means it gets deleted as soon as possible.
The former conserves bandwidth,
and the latter conserves local storage.</p>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_garbage_collection">garbage_collection</code></td>
<td>
<p>Logical, whether to run <code>base::gc()</code>
just before the target runs.</p>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_deployment">deployment</code></td>
<td>
<p>Character of length 1. If <code>deployment</code> is
<code>"main"</code>, then the target will run on the central controlling R process.
Otherwise, if <code>deployment</code> is <code>"worker"</code> and you set up the pipeline
with distributed/parallel computing, then
the target runs on a parallel worker. For more on distributed/parallel
computing in <code>targets</code>, please visit
<a href="https://books.ropensci.org/targets/crew.html">https://books.ropensci.org/targets/crew.html</a>.</p>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_priority">priority</code></td>
<td>
<p>Numeric of length 1 between 0 and 1. Controls which
targets get deployed first when multiple competing targets are ready
simultaneously. Targets with priorities closer to 1 get dispatched earlier
(and polled earlier in <code><a href="#topic+tar_make_future">tar_make_future()</a></code>).</p>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_resources">resources</code></td>
<td>
<p>Object returned by <code>tar_resources()</code>
with optional settings for high-performance computing
functionality, alternative data storage formats,
and other optional capabilities of <code>targets</code>.
See <code>tar_resources()</code> for details.</p>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_storage">storage</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's return value is sent back to the
host machine and saved/uploaded locally.
</p>
</li>
<li> <p><code>"worker"</code>: the worker saves/uploads the value.
</p>
</li>
<li> <p><code>"none"</code>: almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language. If you do use it,
then the return value of the target is totally ignored
when the target ends, but
each downstream target still attempts to load the data file
(except when <code>retrieval = "none"</code>).
</p>
<p>If you select <code>storage = "none"</code>, then
the return value of the target's command is ignored,
and the data is not saved automatically.
As with dynamic files (<code>format = "file"</code>) it is the
responsibility of the user to write to
the data store from inside the target.
</p>
<p>The distinguishing feature of <code>storage = "none"</code>
(as opposed to <code>format = "file"</code>)
is that in the general case,
downstream targets will automatically try to load the data
from the data store as a dependency. As a corollary, <code>storage = "none"</code>
is completely unnecessary if <code>format</code> is <code>"file"</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_retrieval">retrieval</code></td>
<td>
<p>Character of length 1, only relevant to
<code><a href="#topic+tar_make_clustermq">tar_make_clustermq()</a></code> and <code><a href="#topic+tar_make_future">tar_make_future()</a></code>.
Must be one of the following values:
</p>

<ul>
<li> <p><code>"main"</code>: the target's dependencies are loaded on the host machine
and sent to the worker before the target runs.
</p>
</li>
<li> <p><code>"worker"</code>: the worker loads the targets dependencies.
</p>
</li>
<li> <p><code>"none"</code>: the dependencies are not loaded at all.
This choice is almost never recommended. It is only for
niche situations, e.g. the data needs to be loaded
explicitly from another language.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_cue">cue</code></td>
<td>
<p>An optional object from <code>tar_cue()</code> to customize the
rules that decide whether the target is up to date.</p>
</td></tr>
<tr><td><code id="tar_target_raw_+3A_description">description</code></td>
<td>
<p>Character of length 1, a custom free-form human-readable
text description of the target. Descriptions appear as target labels
in functions like <code><a href="#topic+tar_manifest">tar_manifest()</a></code> and <code><a href="#topic+tar_visnetwork">tar_visnetwork()</a></code>,
and they let you select subsets of targets for the <code>names</code> argument of
functions like <code><a href="#topic+tar_make">tar_make()</a></code>. For example,
<code>tar_manifest(names = tar_described_as(starts_with("survival model")))</code>
lists all the targets whose descriptions start with the character
string <code>"survival model"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A target object. Users should not modify these directly,
just feed them to <code><a href="base.html#topic+list">list()</a></code> in your target script file
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>).
See the &quot;Target objects&quot; section for details.
</p>


<h3>Target objects</h3>

<p>Functions like <code>tar_target()</code> produce target objects,
special objects with specialized sets of S3 classes.
Target objects represent skippable steps of the analysis pipeline
as described at <a href="https://books.ropensci.org/targets/">https://books.ropensci.org/targets/</a>.
Please read the walkthrough at
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>
to understand the role of target objects in analysis pipelines.
</p>
<p>For developers,
<a href="https://wlandau.github.io/targetopia/contributing.html#target-factories">https://wlandau.github.io/targetopia/contributing.html#target-factories</a>
explains target factories (functions like this one which generate targets)
and the design specification at
<a href="https://books.ropensci.org/targets-design/">https://books.ropensci.org/targets-design/</a>
details the structure and composition of target objects.
</p>


<h3>See Also</h3>

<p>Other targets: 
<code><a href="#topic+tar_cue">tar_cue</a>()</code>,
<code><a href="#topic+tar_format">tar_format</a>()</code>,
<code><a href="#topic+tar_target">tar_target</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following are equivalent.
y &lt;- tar_target(y, sqrt(x), pattern = map(x))
y &lt;- tar_target_raw("y", expression(sqrt(x)), expression(map(x)))
# Programmatically create a chain of interdependent targets
target_list &lt;- lapply(seq_len(4), function(i) {
  tar_target_raw(
    letters[i + 1],
    substitute(do_something(x), env = list(x = as.symbol(letters[i])))
  )
})
print(target_list[[1]])
print(target_list[[2]])
if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(tar_target_raw("x", quote(1 + 1)), ask = FALSE)
tar_make()
tar_read(x)
})
}
</code></pre>

<hr>
<h2 id='tar_test'>Test code in a temporary directory.</h2><span id='topic+tar_test'></span>

<h3>Description</h3>

<p>Runs a <code>test_that()</code> unit test inside a temporary
directory to avoid writing to the user's file space.
This helps ensure compliance with CRAN policies.
Also isolates <code>tar_option_set()</code>
options and environment variables specific to <code>targets</code>
and skips the test on Solaris.
Useful for writing tests for
<a href="https://wlandau.github.io/targetopia/">targetopia</a> packages
(extensions to <code>targets</code> tailored to specific use cases).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_test(label, code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_test_+3A_label">label</code></td>
<td>
<p>Character of length 1, label for the test.</p>
</td></tr>
<tr><td><code id="tar_test_+3A_code">code</code></td>
<td>
<p>User-defined code for the test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly).
</p>


<h3>See Also</h3>

<p>Other utilities to extend targets: 
<code><a href="#topic+tar_assert">tar_assert</a></code>,
<code><a href="#topic+tar_condition">tar_condition</a></code>,
<code><a href="#topic+tar_language">tar_language</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_test("example test", {
  testing_variable_cafecfcb &lt;- "only defined inside tar_test()"
  file.create("only_exists_in_tar_test")
})
exists("testing_variable_cafecfcb")
file.exists("only_exists_in_tar_test")
</code></pre>

<hr>
<h2 id='tar_timestamp'>Get the timestamp(s) of a target.</h2><span id='topic+tar_timestamp'></span>

<h3>Description</h3>

<p>Get the timestamp associated with a target's
last successful run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_timestamp(
  name = NULL,
  format = NULL,
  tz = NULL,
  parse = NULL,
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_timestamp_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target. If <code>NULL</code> (default)
then <code>tar_timestamp()</code> will attempt to return the timestamp
of the target currently running. Must be called inside a target's
command or a supporting function in order to work.</p>
</td></tr>
<tr><td><code id="tar_timestamp_+3A_format">format</code></td>
<td>
<p>Deprecated in <code>targets</code> version 0.6.0 (2021-07-21).</p>
</td></tr>
<tr><td><code id="tar_timestamp_+3A_tz">tz</code></td>
<td>
<p>Deprecated in <code>targets</code> version 0.6.0 (2021-07-21).</p>
</td></tr>
<tr><td><code id="tar_timestamp_+3A_parse">parse</code></td>
<td>
<p>Deprecated in <code>targets</code> version 0.6.0 (2021-07-21).</p>
</td></tr>
<tr><td><code id="tar_timestamp_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_timestamp()</code> checks the metadata in <code style="white-space: pre;">&#8288;_targets/meta/meta&#8288;</code>,
not the actual returned data of the target.
The timestamp depends on the storage format of the target.
If storage is local, e.g. formats like <code>"rds"</code> and <code>"file"</code>,
then the time stamp is the latest modification time
of the target data files at the time the target
last successfully ran. For non-local storage as with
<code>repository = "aws"</code> and <code>format = "url"</code>, <code>targets</code> chooses instead
to simply record the time the target last successfully ran.
</p>


<h3>Value</h3>

<p>If the target is not recorded in the metadata
or cannot be parsed correctly, then
<code>tar_timestamp()</code> returns a <code>POSIXct</code> object at <code style="white-space: pre;">&#8288;1970-01-01 UTC&#8288;</code>.
</p>


<h3>See Also</h3>

<p>Other time: 
<code><a href="#topic+tar_newer">tar_newer</a>()</code>,
<code><a href="#topic+tar_older">tar_older</a>()</code>,
<code><a href="#topic+tar_timestamp_raw">tar_timestamp_raw</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(tar_target(x, 1))
}, ask = FALSE)
tar_make()
# Get the timestamp.
tar_timestamp(x)
# We can use the timestamp to cancel the target
# if it already ran within the last hour.
# Be sure to set `cue = tar_cue(mode = "always")`
# if you want the target to always check the timestamp.
tar_script({
  list(
  tar_target(
    x,
    tar_cancel((Sys.time() - tar_timestamp()) &lt; 3600),
    cue = tar_cue(mode = "always")
  )
)}, ask = FALSE)
tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_timestamp_raw'>Get the timestamp(s) of a target (raw version).</h2><span id='topic+tar_timestamp_raw'></span>

<h3>Description</h3>

<p>Get the time that a target last ran successfully.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_timestamp_raw(
  name = NULL,
  format = NULL,
  tz = NULL,
  parse = NULL,
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_timestamp_raw_+3A_name">name</code></td>
<td>
<p>Character of length 1, name of the target.</p>
</td></tr>
<tr><td><code id="tar_timestamp_raw_+3A_format">format</code></td>
<td>
<p>Deprecated in <code>targets</code> version 0.6.0 (2021-07-21).</p>
</td></tr>
<tr><td><code id="tar_timestamp_raw_+3A_tz">tz</code></td>
<td>
<p>Deprecated in <code>targets</code> version 0.6.0 (2021-07-21).</p>
</td></tr>
<tr><td><code id="tar_timestamp_raw_+3A_parse">parse</code></td>
<td>
<p>Deprecated in <code>targets</code> version 0.6.0 (2021-07-21).</p>
</td></tr>
<tr><td><code id="tar_timestamp_raw_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tar_timestamp_raw()</code> is like <code>tar_timestamp()</code> except
it accepts a character string for <code>name</code> instead of a symbol.
<code>tar_timestamp_raw()</code> checks the metadata in <code style="white-space: pre;">&#8288;_targets/meta/meta&#8288;</code>,
not the actual data. Time stamps are recorded only for targets that
run commands: just non-branching targets and individual dynamic
branches.
</p>


<h3>Value</h3>

<p>If the target is not recorded in the metadata
or cannot be parsed correctly, then
<code>tar_timestamp_raw()</code> returns a <code>POSIXct</code> object at <code style="white-space: pre;">&#8288;1970-01-01 UTC&#8288;</code>.
</p>


<h3>See Also</h3>

<p>Other time: 
<code><a href="#topic+tar_newer">tar_newer</a>()</code>,
<code><a href="#topic+tar_older">tar_older</a>()</code>,
<code><a href="#topic+tar_timestamp">tar_timestamp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  list(tar_target(x, 1))
}, ask = FALSE)
tar_make()
# Get the timestamp.
tar_timestamp_raw("x")
# We can use the timestamp to cancel the target
# if it already ran within the last hour.
# Be sure to set `cue = tar_cue(mode = "always")`
# if you want the target to always check the timestamp.
tar_script({
  list(
  tar_target(
    x,
    tar_cancel((Sys.time() - tar_timestamp_raw()) &lt; 3600),
    cue = tar_cue(mode = "always")
  )
)}, ask = FALSE)
tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_toggle'>Choose code to run based on Target Markdown mode.</h2><span id='topic+tar_toggle'></span>

<h3>Description</h3>

<p>Run one piece of code if Target Markdown mode
interactive mode is turned on and another piece of code otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_toggle(interactive, noninteractive)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_toggle_+3A_interactive">interactive</code></td>
<td>
<p>R code to run if Target Markdown interactive mode is
activated.</p>
</td></tr>
<tr><td><code id="tar_toggle_+3A_noninteractive">noninteractive</code></td>
<td>
<p>R code to run if Target Markdown interactive mode is
not activated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Visit &lt;books.ropensci.org/targets/literate-programming.html&gt;
to learn about Target Markdown and interactive mode.
</p>


<h3>Value</h3>

<p>If Target Markdown interactive mode is not turned on,
the function returns the result of running the code.
Otherwise, the function invisibly returns <code>NULL</code>.
</p>


<h3>See Also</h3>

<p>Other Target Markdown: 
<code><a href="#topic+tar_engine_knitr">tar_engine_knitr</a>()</code>,
<code><a href="#topic+tar_interactive">tar_interactive</a>()</code>,
<code><a href="#topic+tar_noninteractive">tar_noninteractive</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_toggle(
  message("In interactive mode."),
  message("Not in interactive mode.")
)
</code></pre>

<hr>
<h2 id='tar_traceback'>Get a target's traceback</h2><span id='topic+tar_traceback'></span>

<h3>Description</h3>

<p>Return the saved traceback of a target.
Assumes the target errored out in a previous run of the pipeline
with workspaces enabled for that target.
See <code><a href="#topic+tar_workspace">tar_workspace()</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_traceback(
  name,
  envir = NULL,
  packages = NULL,
  source = NULL,
  characters = NULL,
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_traceback_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target whose workspace to read.</p>
</td></tr>
<tr><td><code id="tar_traceback_+3A_envir">envir</code></td>
<td>
<p>Deprecated in <code>targets</code> &gt; 0.3.1 (2021-03-28).</p>
</td></tr>
<tr><td><code id="tar_traceback_+3A_packages">packages</code></td>
<td>
<p>Logical, whether to load the required packages
of the target.</p>
</td></tr>
<tr><td><code id="tar_traceback_+3A_source">source</code></td>
<td>
<p>Logical, whether to run the target script file
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) to load user-defined
global object dependencies into <code>envir</code>. If <code>TRUE</code>, then <code>envir</code>
should either be the global environment or inherit from the
global environment.</p>
</td></tr>
<tr><td><code id="tar_traceback_+3A_characters">characters</code></td>
<td>
<p>Deprecated in <code>targets</code> 1.4.0 (2023-12-06).</p>
</td></tr>
<tr><td><code id="tar_traceback_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector, the traceback of a failed target
if it exists.
</p>


<h3>See Also</h3>

<p>Other debug: 
<code><a href="#topic+tar_load_globals">tar_load_globals</a>()</code>,
<code><a href="#topic+tar_workspace">tar_workspace</a>()</code>,
<code><a href="#topic+tar_workspaces">tar_workspaces</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tmp &lt;- sample(1)
tar_script({
  tar_option_set(workspace_on_error = TRUE)
  list(
    tar_target(x, "loaded"),
    tar_target(y, stop(x))
  )
}, ask = FALSE)
try(tar_make())
tar_traceback(y, characters = 60)
})
}
</code></pre>

<hr>
<h2 id='tar_unscript'>Remove target script helper files.</h2><span id='topic+tar_unscript'></span>

<h3>Description</h3>

<p>Remove target script helper files (default: <code style="white-space: pre;">&#8288;_targets_r/&#8288;</code>)
that were created by Target Markdown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_unscript(script = targets::tar_config_get("script"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_unscript_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Target Markdown code chunks create R scripts in a folder
called <code style="white-space: pre;">&#8288;_targets_r/&#8288;</code> in order to aid the automatically supplied
<code style="white-space: pre;">&#8288;_targets.R&#8288;</code> file. Over time, the number of script files
starts to build up, and <code>targets</code> has no way of automatically
removing helper script files that are no longer necessary.
To keep your pipeline up to date
with the code chunks in the Target Markdown document(s),
it is good practice to call <code>tar_unscript()</code> at the beginning
of your first Target Markdown document. That way,
extraneous/discarded targets are automatically
removed from the pipeline when the document starts render.
</p>
<p>If the target script is at some alternative path,
e.g. <code>custom/script.R</code>, the helper scripts are in <code style="white-space: pre;">&#8288;custom/script_r/&#8288;</code>.
<code><a href="#topic+tar_unscript">tar_unscript()</a></code> works on the helper scripts as long as your
project configuration settings correctly identify the correct
target script.
</p>


<h3>Value</h3>

<p><code>NULL</code> (invisibly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_unscript()
})
</code></pre>

<hr>
<h2 id='tar_unversion'>Delete cloud object version IDs from local metadata.</h2><span id='topic+tar_unversion'></span>

<h3>Description</h3>

<p>Delete version IDs from local metadata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_unversion(
  names = tidyselect::everything(),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_unversion_+3A_names">names</code></td>
<td>
<p>Tidyselect expression to identify the targets to drop
version IDs.
The object supplied to <code>names</code> should be <code>NULL</code> or a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_unversion_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly).
</p>


<h3>Cloud target data versioning</h3>

<p>Some buckets in Amazon S3 or Google Cloud Storage are &quot;versioned&quot;,
which means they track historical versions of each data object.
If you use <code>targets</code> with cloud storage
(<a href="https://books.ropensci.org/targets/cloud-storage.html">https://books.ropensci.org/targets/cloud-storage.html</a>)
and versioning is turned on, then <code>targets</code> will record each
version of each target in its metadata.
</p>
<p>Functions like <code><a href="#topic+tar_read">tar_read()</a></code>
and <code><a href="#topic+tar_load">tar_load()</a></code> load the version recorded in the local metadata,
which may not be the same as the &quot;current&quot; version of the
object in the bucket. Likewise, functions <code><a href="#topic+tar_delete">tar_delete()</a></code>
and <code><a href="#topic+tar_destroy">tar_destroy()</a></code> only remove
the version ID of each target as recorded in the local
metadata.
</p>
<p>If you want to interact with the <em>latest</em> version of an object
instead of the version ID recorded in the local metadata,
then you will need to delete the object from the metadata.
</p>

<ol>
<li><p> Make sure your local copy of the metadata is current and
up to date. You may need to run <code><a href="#topic+tar_meta_download">tar_meta_download()</a></code> or
<code><a href="#topic+tar_meta_sync">tar_meta_sync()</a></code> first.
</p>
</li>
<li><p> Run <code><a href="#topic+tar_unversion">tar_unversion()</a></code> to remove the recorded version IDs of
your targets in the local metadata.
</p>
</li>
<li><p> With the version IDs gone from the local metadata,
functions like <code><a href="#topic+tar_read">tar_read()</a></code> and <code><a href="#topic+tar_destroy">tar_destroy()</a></code> will use the
<em>latest</em> version of each target data object.
</p>
</li>
<li><p> Optional: to back up the local metadata file with the version IDs
deleted, use <code><a href="#topic+tar_meta_upload">tar_meta_upload()</a></code>.
</p>
</li></ol>



<h3>See Also</h3>

<p>Other clean: 
<code><a href="#topic+tar_delete">tar_delete</a>()</code>,
<code><a href="#topic+tar_destroy">tar_destroy</a>()</code>,
<code><a href="#topic+tar_invalidate">tar_invalidate</a>()</code>,
<code><a href="#topic+tar_prune">tar_prune</a>()</code>,
<code><a href="#topic+tar_prune_list">tar_prune_list</a>()</code>
</p>

<hr>
<h2 id='tar_validate'>Validate a pipeline of targets.</h2><span id='topic+tar_validate'></span>

<h3>Description</h3>

<p>Inspect the pipeline for issues and throw an error or
warning if a problem is detected.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_validate(
  callr_function = callr::r,
  callr_arguments = targets::tar_callr_args_default(callr_function),
  envir = parent.frame(),
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_validate_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_validate_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
<tr><td><code id="tar_validate_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_validate_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_validate_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> except if <code>callr_function = callr::r_bg()</code>, in which case
a handle to the <code>callr</code> background process is returned. Either way,
the value is invisibly returned.
</p>


<h3>See Also</h3>

<p>Other inspect: 
<code><a href="#topic+tar_deps">tar_deps</a>()</code>,
<code><a href="#topic+tar_deps_raw">tar_deps_raw</a>()</code>,
<code><a href="#topic+tar_manifest">tar_manifest</a>()</code>,
<code><a href="#topic+tar_network">tar_network</a>()</code>,
<code><a href="#topic+tar_outdated">tar_outdated</a>()</code>,
<code><a href="#topic+tar_sitrep">tar_sitrep</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script(list(tar_target(x, 1 + 1)), ask = FALSE)
tar_validate()
})
}
</code></pre>

<hr>
<h2 id='tar_visnetwork'>visNetwork dependency graph.</h2><span id='topic+tar_visnetwork'></span>

<h3>Description</h3>

<p>Visualize the pipeline dependency graph with a <code>visNetwork</code>
HTML widget.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_visnetwork(
  targets_only = FALSE,
  names = NULL,
  shortcut = FALSE,
  allow = NULL,
  exclude = ".Random.seed",
  outdated = TRUE,
  label = targets::tar_config_get("label"),
  label_width = targets::tar_config_get("label_width"),
  level_separation = targets::tar_config_get("level_separation"),
  degree_from = 1L,
  degree_to = 1L,
  zoom_speed = 1,
  physics = FALSE,
  reporter = targets::tar_config_get("reporter_outdated"),
  seconds_reporter = targets::tar_config_get("seconds_reporter"),
  callr_function = callr::r,
  callr_arguments = targets::tar_callr_args_default(callr_function),
  envir = parent.frame(),
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_visnetwork_+3A_targets_only">targets_only</code></td>
<td>
<p>Logical, whether to restrict the output to just targets
(<code>FALSE</code>) or to also include global functions and objects.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_names">names</code></td>
<td>
<p>Names of targets. The graph visualization will operate
only on these targets (and unless <code>shortcut</code> is <code>TRUE</code>,
all the targets upstream as well). Selecting a small subgraph
using <code>names</code> could speed up the load time of the visualization.
Unlike <code>allow</code>, <code>names</code> is invoked before the graph is generated.
Set to NULL to check/run all the targets (default).
Otherwise, the object supplied to <code>names</code> should be a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_shortcut">shortcut</code></td>
<td>
<p>Logical of length 1, how to interpret the <code>names</code> argument.
If <code>shortcut</code> is <code>FALSE</code> (default) then the function checks
all targets upstream of <code>names</code> as far back as the dependency graph goes.
If <code>TRUE</code>, then the function only checks the targets in <code>names</code>
and uses stored metadata for information about upstream dependencies
as needed. <code>shortcut = TRUE</code> increases speed if there are a lot of
up-to-date targets, but it assumes all the dependencies
are up to date, so please use with caution.
Also, <code>shortcut = TRUE</code> only works if you set <code>names</code>.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_allow">allow</code></td>
<td>
<p>Optional, define the set of allowable vertices in the graph.
Unlike <code>names</code>, <code>allow</code> is invoked only after the graph is mostly
resolved, so it will not speed up execution.
Set to <code>NULL</code> to allow all vertices in the pipeline and environment
(default). Otherwise, you can supply symbols or
<code>tidyselect</code> helpers like <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_exclude">exclude</code></td>
<td>
<p>Optional, define the set of exclude vertices from the graph.
Unlike <code>names</code>, <code>exclude</code> is invoked only after the graph is mostly
resolved, so it will not speed up execution.
Set to <code>NULL</code> to exclude no vertices.
Otherwise, you can supply symbols or <code>tidyselect</code>
helpers like <code><a href="#topic+any_of">any_of()</a></code> and <code><a href="#topic+starts_with">starts_with()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_outdated">outdated</code></td>
<td>
<p>Logical, whether to show colors to distinguish outdated
targets from up-to-date targets. (Global functions and objects
still show these colors.) Looking for outdated targets
takes a lot of time for large pipelines with lots of branches,
and setting <code>outdated</code> to <code>FALSE</code> is a nice way to speed up the graph
if you only want to see dependency relationships and pipeline progress.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_label">label</code></td>
<td>
<p>Character vector of one or more aesthetics to add to the
vertex labels. Can contain <code>"description"</code> to show each
target's custom description, <code>"time"</code> to show total runtime, <code>"size"</code>
to show total storage size, or <code>"branches"</code> to show the number of
branches in each pattern. You can choose multiple aesthetics
at once, e.g. <code>label = c("description", "time")</code>.
Only the description is enabled by default.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_label_width">label_width</code></td>
<td>
<p>Positive numeric of length 1, maximum width
(in number of characters) of the node labels.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_level_separation">level_separation</code></td>
<td>
<p>Numeric of length 1,
<code>levelSeparation</code> argument of <code>visNetwork::visHierarchicalLayout()</code>.
Controls the distance between hierarchical levels.
Consider changing the value if the aspect ratio of the graph
is far from 1. If <code>level_separation</code> is <code>NULL</code>,
the <code>levelSeparation</code> argument of <code>visHierarchicalLayout()</code>
defaults to <code>150</code>.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_degree_from">degree_from</code></td>
<td>
<p>Integer of length 1. When you click on a node,
the graph highlights a neighborhood of that node. <code>degree_from</code>
controls the number of edges the neighborhood extends upstream.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_degree_to">degree_to</code></td>
<td>
<p>Integer of length 1. When you click on a node,
the graph highlights a neighborhood of that node. <code>degree_to</code>
controls the number of edges the neighborhood extends downstream.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_zoom_speed">zoom_speed</code></td>
<td>
<p>Positive numeric of length 1, scaling factor on the
zoom speed. Above 1 zooms faster than default, below 1 zooms
lower than default.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_physics">physics</code></td>
<td>
<p>Logical of length 1, whether to implement interactive
physics in the graph, e.g. edge elasticity.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_reporter">reporter</code></td>
<td>
<p>Character of length 1, name of the reporter to user.
Controls how messages are printed as targets are checked. Choices:
</p>

<ul>
<li> <p><code>"silent"</code>: print nothing.
</p>
</li>
<li> <p><code>"forecast"</code>: print running totals of the checked and outdated
targets found so far.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_seconds_reporter">seconds_reporter</code></td>
<td>
<p>Positive numeric of length 1 with the minimum
number of seconds between times when the reporter prints progress
messages to the R console.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_callr_function">callr_function</code></td>
<td>
<p>A function from <code>callr</code> to start a fresh clean R
process to do the work. Set to <code>NULL</code> to run in the current session
instead of an external process (but restart your R session just before
you do in order to clear debris out of the global environment).
<code>callr_function</code> needs to be <code>NULL</code> for interactive debugging,
e.g. <code>tar_option_set(debug = "your_target")</code>.
However, <code>callr_function</code> should not be <code>NULL</code> for serious
reproducible work.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_callr_arguments">callr_arguments</code></td>
<td>
<p>A list of arguments to <code>callr_function</code>.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_envir">envir</code></td>
<td>
<p>An environment, where to run the target R script
(default: <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>) if <code>callr_function</code> is <code>NULL</code>.
Ignored if <code>callr_function</code> is anything other than <code>NULL</code>.
<code>callr_function</code> should only be <code>NULL</code> for debugging and
testing purposes, not for serious runs of a pipeline, etc.
</p>
<p>The <code>envir</code> argument of <code><a href="#topic+tar_make">tar_make()</a></code> and related
functions always overrides
the current value of <code>tar_option_get("envir")</code> in the current R session
just before running the target script file,
so whenever you need to set an alternative <code>envir</code>, you should always set
it with <code>tar_option_set()</code> from within the target script file.
In other words, if you call <code>tar_option_set(envir = envir1)</code> in an
interactive session and then
<code>tar_make(envir = envir2, callr_function = NULL)</code>,
then <code>envir2</code> will be used.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_visnetwork_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>visNetwork</code> HTML widget object.
</p>


<h3>Dependency graph</h3>

<p>The dependency graph of a pipeline is a directed acyclic graph (DAG)
where each node indicates a target or global object and each directed
edge indicates where a downstream node depends on an upstream node.
The DAG is not always a tree, but it never contains a cycle because
no target is allowed to directly or indirectly depend on itself.
The dependency graph should show a natural progression of work from
left to right. <code>targets</code> uses static code analysis to create the graph,
so the order of <code>tar_target()</code> calls in the <code style="white-space: pre;">&#8288;_targets.R&#8288;</code> file
does not matter. However, targets does not support self-referential
loops or other cycles. For more information on the dependency graph,
please read
<a href="https://books.ropensci.org/targets/targets.html#dependencies">https://books.ropensci.org/targets/targets.html#dependencies</a>.
</p>


<h3>Storage access</h3>

<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>
<p>Several functions like <code>tar_make()</code>, <code>tar_read()</code>, <code>tar_load()</code>,
<code>tar_meta()</code>, and <code>tar_progress()</code> read or modify
the local data store of the pipeline.
The local data store is in flux while a pipeline is running,
and depending on how distributed computing or cloud computing is set up,
not all targets can even reach it. So please do not call these
functions from inside a target as part of a running
pipeline. The only exception is literate programming
target factories in the <code>tarchetypes</code> package such as <code>tar_render()</code>
and <code>tar_quarto()</code>.
</p>


<h3>See Also</h3>

<p>Other visualize: 
<code><a href="#topic+tar_glimpse">tar_glimpse</a>()</code>,
<code><a href="#topic+tar_mermaid">tar_mermaid</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_INTERACTIVE_EXAMPLES"), "true")) {
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  tar_option_set()
  list(
    tar_target(y1, 1 + 1),
    tar_target(y2, 1 + 1),
    tar_target(z, y1 + y2, description = "sum of two other sums")
  )
})
tar_visnetwork()
tar_visnetwork(allow = starts_with("y")) # see also any_of()
})
}
</code></pre>

<hr>
<h2 id='tar_watch'>Shiny app to watch the dependency graph.</h2><span id='topic+tar_watch'></span>

<h3>Description</h3>

<p>Launches a background process with a Shiny app
that calls <code><a href="#topic+tar_visnetwork">tar_visnetwork()</a></code> every few seconds.
To embed this app in other apps, use the Shiny module
in <code><a href="#topic+tar_watch_ui">tar_watch_ui()</a></code> and <code><a href="#topic+tar_watch_server">tar_watch_server()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_watch(
  seconds = 10,
  seconds_min = 1,
  seconds_max = 60,
  seconds_step = 1,
  targets_only = FALSE,
  exclude = ".Random.seed",
  outdated = FALSE,
  label = NULL,
  level_separation = 150,
  degree_from = 1L,
  degree_to = 1L,
  config = Sys.getenv("TAR_CONFIG", "_targets.yaml"),
  project = Sys.getenv("TAR_PROJECT", "main"),
  height = "650px",
  display = "summary",
  displays = c("summary", "branches", "progress", "graph", "about"),
  background = TRUE,
  browse = TRUE,
  host = getOption("shiny.host", "127.0.0.1"),
  port = getOption("shiny.port", targets::tar_random_port()),
  verbose = TRUE,
  supervise = TRUE,
  poll_connection = TRUE,
  stdout = "|",
  stderr = "|"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_watch_+3A_seconds">seconds</code></td>
<td>
<p>Numeric of length 1,
default number of seconds between refreshes of the graph.
Can be changed in the app controls.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_seconds_min">seconds_min</code></td>
<td>
<p>Numeric of length 1, lower bound of <code>seconds</code>
in the app controls.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_seconds_max">seconds_max</code></td>
<td>
<p>Numeric of length 1, upper bound of <code>seconds</code>
in the app controls.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_seconds_step">seconds_step</code></td>
<td>
<p>Numeric of length 1, step size of <code>seconds</code>
in the app controls.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_targets_only">targets_only</code></td>
<td>
<p>Logical, whether to restrict the output to just targets
(<code>FALSE</code>) or to also include global functions and objects.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_exclude">exclude</code></td>
<td>
<p>Character vector of nodes to omit from the graph.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_outdated">outdated</code></td>
<td>
<p>Logical, whether to show colors to distinguish outdated
targets from up-to-date targets. (Global functions and objects
still show these colors.) Looking for outdated targets
takes a lot of time for large pipelines with lots of branches,
and setting <code>outdated</code> to <code>FALSE</code> is a nice way to speed up the graph
if you only want to see dependency relationships and pipeline progress.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_label">label</code></td>
<td>
<p>Label argument to <code><a href="#topic+tar_visnetwork">tar_visnetwork()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_level_separation">level_separation</code></td>
<td>
<p>Numeric of length 1,
<code>levelSeparation</code> argument of <code>visNetwork::visHierarchicalLayout()</code>.
Controls the distance between hierarchical levels.
Consider changing the value if the aspect ratio of the graph
is far from 1. If <code>level_separation</code> is <code>NULL</code>,
the <code>levelSeparation</code> argument of <code>visHierarchicalLayout()</code>
defaults to <code>150</code>.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_degree_from">degree_from</code></td>
<td>
<p>Integer of length 1. When you click on a node,
the graph highlights a neighborhood of that node. <code>degree_from</code>
controls the number of edges the neighborhood extends upstream.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_degree_to">degree_to</code></td>
<td>
<p>Integer of length 1. When you click on a node,
the graph highlights a neighborhood of that node. <code>degree_to</code>
controls the number of edges the neighborhood extends downstream.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_config">config</code></td>
<td>
<p>Character of length 1, file path of the YAML
configuration file with <code>targets</code> project settings.
The <code>config</code> argument specifies which YAML configuration
file that <code>tar_config_get()</code> reads from or <code>tar_config_set()</code>
writes to in a single function call.
It does not globally change which configuration file is used
in subsequent function calls. The default file path of the YAML
file is always <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code> unless you set another
default path using the <code>TAR_CONFIG</code> environment variable,
e.g. <code>Sys.setenv(TAR_CONFIG = "custom.yaml")</code>. This also has the
effect of temporarily modifying the default arguments to other functions
such as <code><a href="#topic+tar_make">tar_make()</a></code> because the default arguments
to those functions are controlled by <code>tar_config_get()</code>.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_project">project</code></td>
<td>
<p>Character of length 1, name of the current
<code>targets</code> project. Thanks to the <code>config</code> R package,
<code>targets</code> YAML configuration files can store multiple
sets of configuration settings, with each set corresponding
to its own project. The <code>project</code> argument allows you to
set or get a configuration setting for a specific project
for a given call to <code>tar_config_set()</code> or <code>tar_config_get()</code>.
The default project is always called <code>"main"</code>
unless you set another
default project using the <code>TAR_PROJECT</code> environment variable,
e.g. <code>Sys.setenv(tar_project = "custom")</code>. This also has the
effect of temporarily modifying the default arguments to other functions
such as <code><a href="#topic+tar_make">tar_make()</a></code> because the default arguments
to those functions are controlled by <code>tar_config_get()</code>.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_height">height</code></td>
<td>
<p>Character of length 1,
height of the <code>visNetwork</code> widget and branches table.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_display">display</code></td>
<td>
<p>Character of length 1, which display to show first.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_displays">displays</code></td>
<td>
<p>Character vector of choices for the display.
Elements can be any of
<code>"graph"</code>, <code>"summary"</code>, <code>"branches"</code>, or <code>"about"</code>.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_background">background</code></td>
<td>
<p>Logical, whether to run the app in a background process
so you can still use the R console while the app is running.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_browse">browse</code></td>
<td>
<p>Whether to open the app in a browser when the app is ready.
Only relevant if <code>background</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_host">host</code></td>
<td>
<p>Character of length 1, IPv4 address to listen on.
Only relevant if <code>background</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_port">port</code></td>
<td>
<p>Positive integer of length 1, TCP port to listen on.
Only relevant if <code>background</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_verbose">verbose</code></td>
<td>
<p>whether to print a spinner and informative messages.
Only relevant if <code>background</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_supervise">supervise</code></td>
<td>
<p>Whether to register the process with a supervisor. If <code>TRUE</code>,
the supervisor will ensure that the process is killed when the R process
exits.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_poll_connection">poll_connection</code></td>
<td>
<p>Whether to have a control connection to
the process. This is used to transmit messages from the subprocess
to the main process.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_stdout">stdout</code></td>
<td>
<p>The name of the file the standard output of
the child R process will be written to.
If the child process runs with the <code>--slave</code> option (the default),
then the commands are not echoed and will not be shown
in the standard output. Also note that you need to call <code>print()</code>
explicitly to show the output of the command(s).
IF <code>NULL</code> (the default), then standard output is not returned, but
it is recorded and included in the error object if an error happens.</p>
</td></tr>
<tr><td><code id="tar_watch_+3A_stderr">stderr</code></td>
<td>
<p>The name of the file the standard error of
the child R process will be written to.
In particular <code>message()</code> sends output to the standard
error. If nothing was sent to the standard error, then this file
will be empty. This argument can be the same file as <code>stdout</code>,
in which case they will be correctly interleaved. If this is the
string <code>"2&gt;&amp;1"</code>, then standard error is redirected to standard output.
IF <code>NULL</code> (the default), then standard output is not returned, but
it is recorded and included in the error object if an error happens.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The controls of the app are in the left panel.
The <code>seconds</code> control is the number of seconds between
refreshes of the graph, and the other settings match
the arguments of <code><a href="#topic+tar_visnetwork">tar_visnetwork()</a></code>.
</p>


<h3>Value</h3>

<p>A handle to <code>callr::r_bg()</code> background process running the app.
</p>


<h3>See Also</h3>

<p>Other progress: 
<code><a href="#topic+tar_canceled">tar_canceled</a>()</code>,
<code><a href="#topic+tar_completed">tar_completed</a>()</code>,
<code><a href="#topic+tar_dispatched">tar_dispatched</a>()</code>,
<code><a href="#topic+tar_errored">tar_errored</a>()</code>,
<code><a href="#topic+tar_poll">tar_poll</a>()</code>,
<code><a href="#topic+tar_progress">tar_progress</a>()</code>,
<code><a href="#topic+tar_progress_branches">tar_progress_branches</a>()</code>,
<code><a href="#topic+tar_progress_summary">tar_progress_summary</a>()</code>,
<code><a href="#topic+tar_skipped">tar_skipped</a>()</code>,
<code><a href="#topic+tar_watch_server">tar_watch_server</a>()</code>,
<code><a href="#topic+tar_watch_ui">tar_watch_ui</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_INTERACTIVE_EXAMPLES"), "true")) {
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  sleep_run &lt;- function(...) {
    Sys.sleep(10)
  }
  list(
    tar_target(settings, sleep_run()),
    tar_target(data1, sleep_run(settings)),
    tar_target(data2, sleep_run(settings))
  )
}, ask = FALSE)
# Launch the app in a background process.
tar_watch(seconds = 10, outdated = FALSE, targets_only = TRUE)
# Run the pipeline.
tar_make()
})
}
</code></pre>

<hr>
<h2 id='tar_watch_app_ui'>Create the full <code><a href="#topic+tar_watch">tar_watch()</a></code> app UI.</h2><span id='topic+tar_watch_app_ui'></span>

<h3>Description</h3>

<p>Only exported for infrastructure purposes.
Not a user-side function. Users should instead
call <code><a href="#topic+tar_watch">tar_watch()</a></code> directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_watch_app_ui(
  seconds,
  seconds_min,
  seconds_max,
  seconds_step,
  targets_only,
  outdated,
  label,
  level_separation,
  degree_from,
  degree_to,
  height,
  display,
  displays
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_watch_app_ui_+3A_seconds">seconds</code></td>
<td>
<p>Numeric of length 1,
default number of seconds between refreshes of the graph.
Can be changed in the app controls.</p>
</td></tr>
<tr><td><code id="tar_watch_app_ui_+3A_seconds_min">seconds_min</code></td>
<td>
<p>Numeric of length 1, lower bound of <code>seconds</code>
in the app controls.</p>
</td></tr>
<tr><td><code id="tar_watch_app_ui_+3A_seconds_max">seconds_max</code></td>
<td>
<p>Numeric of length 1, upper bound of <code>seconds</code>
in the app controls.</p>
</td></tr>
<tr><td><code id="tar_watch_app_ui_+3A_seconds_step">seconds_step</code></td>
<td>
<p>Numeric of length 1, step size of <code>seconds</code>
in the app controls.</p>
</td></tr>
<tr><td><code id="tar_watch_app_ui_+3A_targets_only">targets_only</code></td>
<td>
<p>Logical, whether to restrict the output to just targets
(<code>FALSE</code>) or to also include global functions and objects.</p>
</td></tr>
<tr><td><code id="tar_watch_app_ui_+3A_outdated">outdated</code></td>
<td>
<p>Logical, whether to show colors to distinguish outdated
targets from up-to-date targets. (Global functions and objects
still show these colors.) Looking for outdated targets
takes a lot of time for large pipelines with lots of branches,
and setting <code>outdated</code> to <code>FALSE</code> is a nice way to speed up the graph
if you only want to see dependency relationships and pipeline progress.</p>
</td></tr>
<tr><td><code id="tar_watch_app_ui_+3A_label">label</code></td>
<td>
<p>Label argument to <code><a href="#topic+tar_visnetwork">tar_visnetwork()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_watch_app_ui_+3A_level_separation">level_separation</code></td>
<td>
<p>Numeric of length 1,
<code>levelSeparation</code> argument of <code>visNetwork::visHierarchicalLayout()</code>.
Controls the distance between hierarchical levels.
Consider changing the value if the aspect ratio of the graph
is far from 1. If <code>level_separation</code> is <code>NULL</code>,
the <code>levelSeparation</code> argument of <code>visHierarchicalLayout()</code>
defaults to <code>150</code>.</p>
</td></tr>
<tr><td><code id="tar_watch_app_ui_+3A_degree_from">degree_from</code></td>
<td>
<p>Integer of length 1. When you click on a node,
the graph highlights a neighborhood of that node. <code>degree_from</code>
controls the number of edges the neighborhood extends upstream.</p>
</td></tr>
<tr><td><code id="tar_watch_app_ui_+3A_degree_to">degree_to</code></td>
<td>
<p>Integer of length 1. When you click on a node,
the graph highlights a neighborhood of that node. <code>degree_to</code>
controls the number of edges the neighborhood extends downstream.</p>
</td></tr>
<tr><td><code id="tar_watch_app_ui_+3A_height">height</code></td>
<td>
<p>Character of length 1,
height of the <code>visNetwork</code> widget and branches table.</p>
</td></tr>
<tr><td><code id="tar_watch_app_ui_+3A_display">display</code></td>
<td>
<p>Character of length 1, which display to show first.</p>
</td></tr>
<tr><td><code id="tar_watch_app_ui_+3A_displays">displays</code></td>
<td>
<p>Character vector of choices for the display.
Elements can be any of
<code>"graph"</code>, <code>"summary"</code>, <code>"branches"</code>, or <code>"about"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Shiny UI.
</p>

<hr>
<h2 id='tar_watch_server'>Shiny module server for tar_watch()</h2><span id='topic+tar_watch_server'></span>

<h3>Description</h3>

<p>Use <code><a href="#topic+tar_watch_ui">tar_watch_ui()</a></code> and <code>tar_watch_server()</code>
to include <code><a href="#topic+tar_watch">tar_watch()</a></code> as a Shiny module in an app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_watch_server(
  id,
  height = "650px",
  exclude = ".Random.seed",
  config = Sys.getenv("TAR_CONFIG", "_targets.yaml"),
  project = Sys.getenv("TAR_PROJECT", "main")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_watch_server_+3A_id">id</code></td>
<td>
<p>Character of length 1, ID corresponding to the UI function
of the module.</p>
</td></tr>
<tr><td><code id="tar_watch_server_+3A_height">height</code></td>
<td>
<p>Character of length 1,
height of the <code>visNetwork</code> widget and branches table.</p>
</td></tr>
<tr><td><code id="tar_watch_server_+3A_exclude">exclude</code></td>
<td>
<p>Character vector of nodes to omit from the graph.</p>
</td></tr>
<tr><td><code id="tar_watch_server_+3A_config">config</code></td>
<td>
<p>Character of length 1, file path of the YAML
configuration file with <code>targets</code> project settings.
The <code>config</code> argument specifies which YAML configuration
file that <code>tar_config_get()</code> reads from or <code>tar_config_set()</code>
writes to in a single function call.
It does not globally change which configuration file is used
in subsequent function calls. The default file path of the YAML
file is always <code style="white-space: pre;">&#8288;_targets.yaml&#8288;</code> unless you set another
default path using the <code>TAR_CONFIG</code> environment variable,
e.g. <code>Sys.setenv(TAR_CONFIG = "custom.yaml")</code>. This also has the
effect of temporarily modifying the default arguments to other functions
such as <code><a href="#topic+tar_make">tar_make()</a></code> because the default arguments
to those functions are controlled by <code>tar_config_get()</code>.</p>
</td></tr>
<tr><td><code id="tar_watch_server_+3A_project">project</code></td>
<td>
<p>Character of length 1, name of the current
<code>targets</code> project. Thanks to the <code>config</code> R package,
<code>targets</code> YAML configuration files can store multiple
sets of configuration settings, with each set corresponding
to its own project. The <code>project</code> argument allows you to
set or get a configuration setting for a specific project
for a given call to <code>tar_config_set()</code> or <code>tar_config_get()</code>.
The default project is always called <code>"main"</code>
unless you set another
default project using the <code>TAR_PROJECT</code> environment variable,
e.g. <code>Sys.setenv(tar_project = "custom")</code>. This also has the
effect of temporarily modifying the default arguments to other functions
such as <code><a href="#topic+tar_make">tar_make()</a></code> because the default arguments
to those functions are controlled by <code>tar_config_get()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Shiny module server.
</p>


<h3>See Also</h3>

<p>Other progress: 
<code><a href="#topic+tar_canceled">tar_canceled</a>()</code>,
<code><a href="#topic+tar_completed">tar_completed</a>()</code>,
<code><a href="#topic+tar_dispatched">tar_dispatched</a>()</code>,
<code><a href="#topic+tar_errored">tar_errored</a>()</code>,
<code><a href="#topic+tar_poll">tar_poll</a>()</code>,
<code><a href="#topic+tar_progress">tar_progress</a>()</code>,
<code><a href="#topic+tar_progress_branches">tar_progress_branches</a>()</code>,
<code><a href="#topic+tar_progress_summary">tar_progress_summary</a>()</code>,
<code><a href="#topic+tar_skipped">tar_skipped</a>()</code>,
<code><a href="#topic+tar_watch">tar_watch</a>()</code>,
<code><a href="#topic+tar_watch_ui">tar_watch_ui</a>()</code>
</p>

<hr>
<h2 id='tar_watch_ui'>Shiny module UI for tar_watch()</h2><span id='topic+tar_watch_ui'></span>

<h3>Description</h3>

<p>Use <code>tar_watch_ui()</code> and <code><a href="#topic+tar_watch_server">tar_watch_server()</a></code>
to include <code><a href="#topic+tar_watch">tar_watch()</a></code> as a Shiny module in an app.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_watch_ui(
  id,
  label = "tar_watch_label",
  seconds = 10,
  seconds_min = 1,
  seconds_max = 60,
  seconds_step = 1,
  targets_only = FALSE,
  outdated = FALSE,
  label_tar_visnetwork = NULL,
  level_separation = 150,
  degree_from = 1L,
  degree_to = 1L,
  height = "650px",
  display = "summary",
  displays = c("summary", "branches", "progress", "graph", "about")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_watch_ui_+3A_id">id</code></td>
<td>
<p>Character of length 1, ID corresponding to the UI function
of the module.</p>
</td></tr>
<tr><td><code id="tar_watch_ui_+3A_label">label</code></td>
<td>
<p>Label for the module.</p>
</td></tr>
<tr><td><code id="tar_watch_ui_+3A_seconds">seconds</code></td>
<td>
<p>Numeric of length 1,
default number of seconds between refreshes of the graph.
Can be changed in the app controls.</p>
</td></tr>
<tr><td><code id="tar_watch_ui_+3A_seconds_min">seconds_min</code></td>
<td>
<p>Numeric of length 1, lower bound of <code>seconds</code>
in the app controls.</p>
</td></tr>
<tr><td><code id="tar_watch_ui_+3A_seconds_max">seconds_max</code></td>
<td>
<p>Numeric of length 1, upper bound of <code>seconds</code>
in the app controls.</p>
</td></tr>
<tr><td><code id="tar_watch_ui_+3A_seconds_step">seconds_step</code></td>
<td>
<p>Numeric of length 1, step size of <code>seconds</code>
in the app controls.</p>
</td></tr>
<tr><td><code id="tar_watch_ui_+3A_targets_only">targets_only</code></td>
<td>
<p>Logical, whether to restrict the output to just targets
(<code>FALSE</code>) or to also include global functions and objects.</p>
</td></tr>
<tr><td><code id="tar_watch_ui_+3A_outdated">outdated</code></td>
<td>
<p>Logical, whether to show colors to distinguish outdated
targets from up-to-date targets. (Global functions and objects
still show these colors.) Looking for outdated targets
takes a lot of time for large pipelines with lots of branches,
and setting <code>outdated</code> to <code>FALSE</code> is a nice way to speed up the graph
if you only want to see dependency relationships and pipeline progress.</p>
</td></tr>
<tr><td><code id="tar_watch_ui_+3A_label_tar_visnetwork">label_tar_visnetwork</code></td>
<td>
<p>Character vector, <code>label</code> argument to
<code><a href="#topic+tar_visnetwork">tar_visnetwork()</a></code>.</p>
</td></tr>
<tr><td><code id="tar_watch_ui_+3A_level_separation">level_separation</code></td>
<td>
<p>Numeric of length 1,
<code>levelSeparation</code> argument of <code>visNetwork::visHierarchicalLayout()</code>.
Controls the distance between hierarchical levels.
Consider changing the value if the aspect ratio of the graph
is far from 1. If <code>level_separation</code> is <code>NULL</code>,
the <code>levelSeparation</code> argument of <code>visHierarchicalLayout()</code>
defaults to <code>150</code>.</p>
</td></tr>
<tr><td><code id="tar_watch_ui_+3A_degree_from">degree_from</code></td>
<td>
<p>Integer of length 1. When you click on a node,
the graph highlights a neighborhood of that node. <code>degree_from</code>
controls the number of edges the neighborhood extends upstream.</p>
</td></tr>
<tr><td><code id="tar_watch_ui_+3A_degree_to">degree_to</code></td>
<td>
<p>Integer of length 1. When you click on a node,
the graph highlights a neighborhood of that node. <code>degree_to</code>
controls the number of edges the neighborhood extends downstream.</p>
</td></tr>
<tr><td><code id="tar_watch_ui_+3A_height">height</code></td>
<td>
<p>Character of length 1,
height of the <code>visNetwork</code> widget and branches table.</p>
</td></tr>
<tr><td><code id="tar_watch_ui_+3A_display">display</code></td>
<td>
<p>Character of length 1, which display to show first.</p>
</td></tr>
<tr><td><code id="tar_watch_ui_+3A_displays">displays</code></td>
<td>
<p>Character vector of choices for the display.
Elements can be any of
<code>"graph"</code>, <code>"summary"</code>, <code>"branches"</code>, or <code>"about"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Shiny module UI.
</p>


<h3>See Also</h3>

<p>Other progress: 
<code><a href="#topic+tar_canceled">tar_canceled</a>()</code>,
<code><a href="#topic+tar_completed">tar_completed</a>()</code>,
<code><a href="#topic+tar_dispatched">tar_dispatched</a>()</code>,
<code><a href="#topic+tar_errored">tar_errored</a>()</code>,
<code><a href="#topic+tar_poll">tar_poll</a>()</code>,
<code><a href="#topic+tar_progress">tar_progress</a>()</code>,
<code><a href="#topic+tar_progress_branches">tar_progress_branches</a>()</code>,
<code><a href="#topic+tar_progress_summary">tar_progress_summary</a>()</code>,
<code><a href="#topic+tar_skipped">tar_skipped</a>()</code>,
<code><a href="#topic+tar_watch">tar_watch</a>()</code>,
<code><a href="#topic+tar_watch_server">tar_watch_server</a>()</code>
</p>

<hr>
<h2 id='tar_workspace'>Load a saved workspace and seed for debugging.</h2><span id='topic+tar_workspace'></span>

<h3>Description</h3>

<p>Load the packages, workspace, and random number generator seed
of target attempted with a workspace file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_workspace(
  name,
  envir = parent.frame(),
  packages = TRUE,
  source = TRUE,
  script = targets::tar_config_get("script"),
  store = targets::tar_config_get("store")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_workspace_+3A_name">name</code></td>
<td>
<p>Symbol, name of the target whose workspace to read.</p>
</td></tr>
<tr><td><code id="tar_workspace_+3A_envir">envir</code></td>
<td>
<p>Environment in which to put the objects.</p>
</td></tr>
<tr><td><code id="tar_workspace_+3A_packages">packages</code></td>
<td>
<p>Logical, whether to load the required packages
of the target.</p>
</td></tr>
<tr><td><code id="tar_workspace_+3A_source">source</code></td>
<td>
<p>Logical, whether to run <code style="white-space: pre;">&#8288;_targets.R&#8288;</code> to load user-defined
global object dependencies into <code>envir</code>. If <code>TRUE</code>, then <code>envir</code>
should either be the global environment or inherit from the
global environment.</p>
</td></tr>
<tr><td><code id="tar_workspace_+3A_script">script</code></td>
<td>
<p>Character of length 1, path to the
target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>. When you set
this argument, the value of <code>tar_config_get("script")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_script">tar_script()</a></code>,
<code><a href="#topic+tar_config_get">tar_config_get()</a></code>, and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about the target script file and how to set it
persistently for a project.</p>
</td></tr>
<tr><td><code id="tar_workspace_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you activate workspaces through the <code>workspaces</code> argument
of <code><a href="#topic+tar_option_set">tar_option_set()</a></code>, then under the circumstances you specify,
<code>targets</code> will save a special workspace file to a location in
in <code style="white-space: pre;">&#8288;_targets/workspaces/&#8288;</code>. The workspace file is a compact reference
that allows <code>tar_workspace()</code> to load the target's dependencies
and random number generator seed as long as the data objects
are still in the data store (usually files in <code style="white-space: pre;">&#8288;_targets/objects/&#8288;</code>).
When you are done debugging, you can remove the workspace files
using <code>tar_destroy(destroy = "workspaces")</code>.
</p>


<h3>Value</h3>

<p>This function returns <code>NULL</code>, but it does load
the target's required packages, as well as multiple objects
into the environment (<code>envir</code> argument) in order to replicate the
workspace where the error happened. These objects include
the global objects at the time <code><a href="#topic+tar_make">tar_make()</a></code> was called and the
dependency targets. The random number generator seed for the
target is also assigned with <code><a href="#topic+tar_seed_set">tar_seed_set()</a></code>.
</p>


<h3>See Also</h3>

<p>Other debug: 
<code><a href="#topic+tar_load_globals">tar_load_globals</a>()</code>,
<code><a href="#topic+tar_traceback">tar_traceback</a>()</code>,
<code><a href="#topic+tar_workspaces">tar_workspaces</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tmp &lt;- sample(1)
tar_script({
  tar_option_set(workspace_on_error = TRUE)
  list(
    tar_target(x, "loaded"),
    tar_target(y, stop(x))
  )
}, ask = FALSE)
# The following code throws an error for demonstration purposes.
try(tar_make())
exists("x") # Should be FALSE.
tail(.Random.seed) # for comparison to the RNG state after tar_workspace(y)
tar_workspace(y)
exists("x") # Should be TRUE.
print(x) # "loaded"
# Should be different: tar_workspace() runs
# tar_seed_set(tar_meta(y, seed)$seed)
tail(.Random.seed)
})
}
</code></pre>

<hr>
<h2 id='tar_workspaces'>List saved target workspaces.</h2><span id='topic+tar_workspaces'></span>

<h3>Description</h3>

<p>List target workspaces currently saved to
<code style="white-space: pre;">&#8288;_targets/workspaces/&#8288;</code>. See <code><a href="#topic+tar_workspace">tar_workspace()</a></code> for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tar_workspaces(names = NULL, store = targets::tar_config_get("store"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tar_workspaces_+3A_names">names</code></td>
<td>
<p>Optional <code>tidyselect</code> selector to return
a tactical subset of workspace names.
If <code>NULL</code>, all names are selected.
The object supplied to <code>names</code> should be <code>NULL</code> or a
<code>tidyselect</code> expression like <code><a href="#topic+any_of">any_of()</a></code> or <code><a href="#topic+starts_with">starts_with()</a></code>
from <code>tidyselect</code> itself, or <code><a href="#topic+tar_described_as">tar_described_as()</a></code> to select target names
based on their descriptions.</p>
</td></tr>
<tr><td><code id="tar_workspaces_+3A_store">store</code></td>
<td>
<p>Character of length 1, path to the
<code>targets</code> data store. Defaults to <code>tar_config_get("store")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets/&#8288;</code>.
When you set this argument, the value of <code>tar_config_get("store")</code>
is temporarily changed for the current function call.
See <code><a href="#topic+tar_config_get">tar_config_get()</a></code> and <code><a href="#topic+tar_config_set">tar_config_set()</a></code> for details
about how to set the data store path persistently
for a project.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of available workspaces to load with
<code><a href="#topic+tar_workspace">tar_workspace()</a></code>.
</p>


<h3>See Also</h3>

<p>Other debug: 
<code><a href="#topic+tar_load_globals">tar_load_globals</a>()</code>,
<code><a href="#topic+tar_traceback">tar_traceback</a>()</code>,
<code><a href="#topic+tar_workspace">tar_workspace</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_EXAMPLES"), "true")) { # for CRAN
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
tar_script({
  tar_option_set(workspace_on_error = TRUE)
  list(
    tar_target(x, "value"),
    tar_target(y, x)
  )
}, ask = FALSE)
tar_make()
tar_workspaces()
tar_workspaces(contains("x"))
})
}
</code></pre>

<hr>
<h2 id='target_run_worker'>Internal function to run a target on a worker.</h2><span id='topic+target_run_worker'></span>

<h3>Description</h3>

<p>For internal purposes only. Not a user-side function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>target_run_worker(target, envir, path_store, fun, options, envvars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="target_run_worker_+3A_target">target</code></td>
<td>
<p>A target object.</p>
</td></tr>
<tr><td><code id="target_run_worker_+3A_envir">envir</code></td>
<td>
<p>An environment or the string <code>"globalenv"</code>.</p>
</td></tr>
<tr><td><code id="target_run_worker_+3A_path_store">path_store</code></td>
<td>
<p>Character of length 1, path to the data store.</p>
</td></tr>
<tr><td><code id="target_run_worker_+3A_fun">fun</code></td>
<td>
<p>Character of length 1, name of the user-side function called
to run the pipeline.</p>
</td></tr>
<tr><td><code id="target_run_worker_+3A_options">options</code></td>
<td>
<p>List, exported from an object of class <code>"tar_options"</code>.</p>
</td></tr>
<tr><td><code id="target_run_worker_+3A_envvars">envvars</code></td>
<td>
<p>Data frame of <code>targets</code>-specific environment variables
from <code><a href="#topic+tar_envvars">tar_envvars()</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='use_targets'>Use targets</h2><span id='topic+use_targets'></span>

<h3>Description</h3>

<p>Set up <code>targets</code> for an existing project.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_targets(
  script = targets::tar_config_get("script"),
  open = interactive(),
  overwrite = FALSE,
  scheduler = NULL,
  job_name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_targets_+3A_script">script</code></td>
<td>
<p>Character of length 1, where to write
the target script file. Defaults to <code>tar_config_get("script")</code>,
which in turn defaults to <code style="white-space: pre;">&#8288;_targets.R&#8288;</code>.</p>
</td></tr>
<tr><td><code id="use_targets_+3A_open">open</code></td>
<td>
<p>Logical of length 1, whether to open the file for editing
in the RStudio IDE.</p>
</td></tr>
<tr><td><code id="use_targets_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical of length 1, <code>TRUE</code> to overwrite the the target
script file, <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="use_targets_+3A_scheduler">scheduler</code></td>
<td>
<p>Deprecated in version 1.5.0.9001 (2024-02-12).</p>
</td></tr>
<tr><td><code id="use_targets_+3A_job_name">job_name</code></td>
<td>
<p>Deprecated in version 1.5.0.9001 (2024-02-12).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>use_targets()</code> writes an example <code style="white-space: pre;">&#8288;_targets.R&#8288;</code> script to
get started with a <code>targets</code> pipeline for the current project.
Follow the comments in this script to adapt it as needed.
For more information, please visit
<a href="https://books.ropensci.org/targets/walkthrough.html">https://books.ropensci.org/targets/walkthrough.html</a>.
</p>


<h3>Value</h3>

<p><code>NULL</code> (invisibly).
</p>


<h3>See Also</h3>

<p>Other help: 
<code><a href="#topic+tar_reprex">tar_reprex</a>()</code>,
<code><a href="#topic+targets-package">targets-package</a></code>,
<code><a href="#topic+use_targets_rmd">use_targets_rmd</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_INTERACTIVE_EXAMPLES"), "true")) {
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
use_targets(open = FALSE)
})
}
</code></pre>

<hr>
<h2 id='use_targets_rmd'>Use targets with Target Markdown.</h2><span id='topic+use_targets_rmd'></span>

<h3>Description</h3>

<p>Create an example Target Markdown report
to get started with <code>targets</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_targets_rmd(path = "_targets.Rmd", open = interactive())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_targets_rmd_+3A_path">path</code></td>
<td>
<p>Character of length 1, output path of the
Target Markdown report relative to the current active
project.</p>
</td></tr>
<tr><td><code id="use_targets_rmd_+3A_open">open</code></td>
<td>
<p>Logical, whether to open the file for editing
in the RStudio IDE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> (invisibly).
</p>


<h3>See Also</h3>

<p>Other help: 
<code><a href="#topic+tar_reprex">tar_reprex</a>()</code>,
<code><a href="#topic+targets-package">targets-package</a></code>,
<code><a href="#topic+use_targets">use_targets</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (identical(Sys.getenv("TAR_INTERACTIVE_EXAMPLES"), "true")) {
tar_dir({ # tar_dir() runs code from a temp dir for CRAN.
use_targets(open = FALSE)
})
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
