<!DOCTYPE html><html lang="en"><head><title>Help for package lorentz</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {lorentz}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#lorentz-package'>
<p>The Lorentz Transform in Relativistic Physics</p></a></li>
<li><a href='#as.matrix.3vel'><p>Coerce 3-vectors and 4-vectors to a matrix</p></a></li>
<li><a href='#boost'><p>Lorentz transformations</p></a></li>
<li><a href='#c.3vel'><p>Combine vectors of three-velocities and four-velocities into a single vector</p></a></li>
<li><a href='#celerity'><p>Celerity and rapidity</p></a></li>
<li><a href='#comm_fail'>
<p>Failure of commutativity and associativity using visual plots</p></a></li>
<li><a href='#coordnames'><p>Coordinate names for relativity</p></a></li>
<li><a href='#cosines'><p>Direction cosines</p></a></li>
<li><a href='#Extract.3vel'><p>Extract or replace parts of three-velocity</p></a></li>
<li><a href='#fourmom'><p>Four momentum</p></a></li>
<li><a href='#fourvel'><p>Four velocities</p></a></li>
<li><a href='#galileo'><p>Classical mechanics; Newtonian approximation; infinite speed of light</p></a></li>
<li><a href='#gam'><p>Gamma correction</p></a></li>
<li><a href='#gyr'><p>Gyr function</p></a></li>
<li><a href='#Ops.3vel'><p>Arithmetic Ops Group Methods for 3vel objects</p></a></li>
<li><a href='#photon'><p>Photons</p></a></li>
<li><a href='#print.3vel'><p>Print methods for three-velocities and four-velocities</p></a></li>
<li><a href='#r3vel'><p>Random relativistic velocities</p></a></li>
<li><a href='#reflect'><p>Mirrors</p></a></li>
<li><a href='#seq.3vel'><p>seq method for three velocities</p></a></li>
<li><a href='#sol'><p>Speed of light and Minkowski metric</p></a></li>
<li><a href='#threevel'><p>Three velocities</p></a></li>
<li><a href='#transform'><p>The energy-momentum tensor</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>The Lorentz Transform in Relativistic Physics</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr,testthat,rmarkdown,covr</td>
</tr>
<tr>
<td>Imports:</td>
<td>quadform,tensor,magic,magrittr</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>The Lorentz transform in special relativity; also the
    gyrogroup structure of three-velocities.  Performs active and
    passive transforms and has the ability to use units in which the
    speed of light is not unity.  Includes some experimental
    functionality for celerity and rapidity.  For general relativity,
    see the 'schwarzschild' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/RobinHankin/lorentz">https://github.com/RobinHankin/lorentz</a>,
<a href="https://robinhankin.github.io/lorentz/">https://robinhankin.github.io/lorentz/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/RobinHankin/lorentz/issues">https://github.com/RobinHankin/lorentz/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-22 11:42:42 UTC; rhankin</td>
</tr>
<tr>
<td>Author:</td>
<td>Robin K. S. Hankin
    <a href="https://orcid.org/0000-0001-5982-0415"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-23 16:20:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='lorentz-package'>
The Lorentz Transform in Relativistic Physics
</h2><span id='topic+lorentz-package'></span><span id='topic+lorentz'></span><span id='topic+Lorentz'></span><span id='topic+gyrogroup'></span>

<h3>Description</h3>

<p>The Lorentz transform in special relativity; also the
    gyrogroup structure of three-velocities.  Performs active and
    passive transforms and has the ability to use units in which the
    speed of light is not unity.  Includes some experimental
    functionality for celerity and rapidity.  For general relativity,
    see the 'schwarzschild' package.
</p>


<h3>Details</h3>

<p>The DESCRIPTION file:
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> lorentz</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Title: </td><td style="text-align: left;"> The Lorentz Transform in Relativistic Physics</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.1-2</td>
</tr>
<tr>
 <td style="text-align: left;">
Authors@R: </td><td style="text-align: left;"> person(given=c("Robin", "K. S."), family="Hankin", role = c("aut","cre"), email="hankin.robin@gmail.com", comment = c(ORCID = "0000-0001-5982-0415"))</td>
</tr>
<tr>
 <td style="text-align: left;">
Suggests: </td><td style="text-align: left;"> knitr,testthat,rmarkdown,covr</td>
</tr>
<tr>
 <td style="text-align: left;">
Imports: </td><td style="text-align: left;"> quadform,tensor,magic,magrittr</td>
</tr>
<tr>
 <td style="text-align: left;">
Maintainer: </td><td style="text-align: left;"> Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> R (&gt;= 4.1.0)</td>
</tr>
<tr>
 <td style="text-align: left;">
Description: </td><td style="text-align: left;"> The Lorentz transform in special relativity; also the
    gyrogroup structure of three-velocities.  Performs active and
    passive transforms and has the ability to use units in which the
    speed of light is not unity.  Includes some experimental
    functionality for celerity and rapidity.  For general relativity,
    see the 'schwarzschild' package.</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
Encoding: </td><td style="text-align: left;"> UTF-8</td>
</tr>
<tr>
 <td style="text-align: left;">
VignetteBuilder: </td><td style="text-align: left;"> knitr</td>
</tr>
<tr>
 <td style="text-align: left;">
URL: </td><td style="text-align: left;"> https://github.com/RobinHankin/lorentz, https://robinhankin.github.io/lorentz/</td>
</tr>
<tr>
 <td style="text-align: left;">
BugReports: </td><td style="text-align: left;"> https://github.com/RobinHankin/lorentz/issues</td>
</tr>
<tr>
 <td style="text-align: left;">
RoxygenNote: </td><td style="text-align: left;"> 7.2.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Author: </td><td style="text-align: left;"> Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>


<p>Index of help topics:
</p>
<pre>
Extract.3vel            Extract or replace parts of three-velocity
Ops.3vel                Arithmetic Ops Group Methods for 3vel objects
as.matrix.3vel          Coerce 3-vectors and 4-vectors to a matrix
boost                   Lorentz transformations
c.3vel                  Combine vectors of three-velocities and
                        four-velocities into a single vector
celerity                Celerity and rapidity
comm_fail               Failure of commutativity and associativity
                        using visual plots
coordnames              Coordinate names for relativity
cosines                 Direction cosines
fourmom                 Four momentum
fourvel                 Four velocities
galileo                 Classical mechanics; Newtonian approximation;
                        infinite speed of light
gam                     Gamma correction
gyr                     Gyr function
lorentz-package         The Lorentz Transform in Relativistic Physics
photon                  Photons
print.3vel              Print methods for three-velocities and
                        four-velocities
r3vel                   Random relativistic velocities
reflect                 Mirrors
seq.3vel                seq method for three velocities
sol                     Speed of light and Minkowski metric
threevel                Three velocities
transform               The energy-momentum tensor
</pre>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin [aut, cre] (&lt;https://orcid.org/0000-0001-5982-0415&gt;)
</p>
<p>Maintainer: Robin K. S. Hankin &lt;hankin.robin@gmail.com&gt;
</p>


<h3>References</h3>


<ul>
<li><p> Ungar 2006. &ldquo;Thomas precession: a kinematic
effect...&rdquo;. <em>European Journal of Physics</em>, 27:L17-L20.
</p>
</li>
<li>
<p><a href="https://www.youtube.com/watch?v=9Y9CxiukURw&amp;index=68&amp;list=PL9_n3Tqzq9iWtgD8POJFdnVUCZ_zw6OiB">https://www.youtube.com/watch?v=9Y9CxiukURw&amp;index=68&amp;list=PL9_n3Tqzq9iWtgD8POJFdnVUCZ_zw6OiB</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
u &lt;- as.3vel(c(0.3,0.6,-0.1))  # u is a three-velocity
gam(u)                         # relativistic gamma term for u
U &lt;- as.4vel(u)                # U is a four-velocity
B1 &lt;- boost(u)                 # B1 is the Lorentz transform matrix for u
B1 %*% c(1,0,0,0)              # Lorentz transform of zero 4-velocity (=-u)

B2 &lt;- boost(as.3vel(c(-0.1,0.8,0.3)))  
B3 &lt;- boost(as.3vel(c(-0.1,0.1,0.9)))  # more boosts

Bi &lt;- B1 %*% B2  # Bi is the boost for successive Lorentz transforms


pureboost(Bi)      # Decompose Bi into a pure boost...
orthog(Bi)         # and an orthogonal matrix

Bj &lt;- B2 %*% B1    # B1 and B2 do not commute...

(B1 %*% B2) %*% B3 
B1 %*% (B2 %*% B3)    # ...but composition *is* associative



## Three velocities and the gyrogroup

## Create some random three-velocities:

u &lt;- r3vel(10)
v &lt;- r3vel(10)
w &lt;- r3vel(10)

u+v
v+u        # Three-velocity addition is not commutative...

u+(v+w)   # ... nor associative
(u+v)+w 

</code></pre>

<hr>
<h2 id='as.matrix.3vel'>Coerce 3-vectors and 4-vectors to a matrix</h2><span id='topic+as.matrix.3vel'></span><span id='topic+as.matrix.4vel'></span>

<h3>Description</h3>

<p>Coerce 3-vectors and 4-vectors to a matrix.  A convenience wrapper for
<code>unclass()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '3vel'
as.matrix(x, ...)
## S3 method for class '4vel'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.matrix.3vel_+3A_x">x</code></td>
<td>
<p>Object of class <code>3vel</code> or <code>4vel</code></p>
</td></tr>
<tr><td><code id="as.matrix.3vel_+3A_...">...</code></td>
<td>
<p>Further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.matrix(r3vel(5))
as.matrix(r4vel(5))
</code></pre>

<hr>
<h2 id='boost'>Lorentz transformations</h2><span id='topic+boost'></span><span id='topic+rot'></span><span id='topic+thomas'></span><span id='topic+Thomas'></span><span id='topic+Thomas+20rotation'></span><span id='topic+wigner'></span><span id='topic+Wigner'></span><span id='topic+Wigner+20rotation'></span><span id='topic+precession'></span><span id='topic+boostfun'></span><span id='topic+decompose'></span><span id='topic+pureboost'></span><span id='topic+orthog'></span><span id='topic+pureboost.galilean'></span><span id='topic+orthog.galilean'></span><span id='topic+is.consistent.boost'></span><span id='topic+is.consistent.boost.galilean'></span><span id='topic+is.consistent.galilean.boost'></span>

<h3>Description</h3>

<p>Lorentz transformations: boosts and rotations</p>


<h3>Usage</h3>

<pre><code class='language-R'>boost(u=0)
rot(u,v,space=TRUE)
is.consistent.boost(L, give=FALSE, TOL=1e-10)
is.consistent.boost.galilean(L, give=FALSE, TOL=1e-10)
pureboost(L,include_sol=TRUE)
orthog(L)
pureboost.galilean(L, tidy=TRUE)
orthog.galilean(L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boost_+3A_u">u</code>, <code id="boost_+3A_v">v</code></td>
<td>
<p>Three-velocities, coerced to  class <code>3vel</code>.  In
function <code>boost()</code>, if <code>u</code> takes the special default value
<code>0</code>, this is interpreted as zero three velocity</p>
</td></tr>
<tr><td><code id="boost_+3A_l">L</code></td>
<td>
<p>Lorentz transform expressed as a <code class="reqn">4\times 4</code> matrix</p>
</td></tr>
<tr><td><code id="boost_+3A_tol">TOL</code></td>
<td>
<p>Numerical tolerance</p>
</td></tr>
<tr><td><code id="boost_+3A_give">give</code></td>
<td>
<p>Boolean with <code>TRUE</code> meaning to return the transformed
metric tensor (which should be the flat-space <code>eta()</code>; qv) and
default <code>FALSE</code> meaning to return whether the matrix is a
consistent boost or not</p>
</td></tr>
<tr><td><code id="boost_+3A_space">space</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return just
the spatial component of the rotation matrix and <code>FALSE</code>
meaning to return the full <code class="reqn">4\times 4</code> matrix
transformation</p>
</td></tr>
<tr><td><code id="boost_+3A_tidy">tidy</code></td>
<td>
<p>In <code>pureboost.galilean()</code>, Boolean with default
<code>TRUE</code> meaning to return a &ldquo;tidy&rdquo; boost matrix with
spatial components forced to be a <code class="reqn">3\times 3</code> identity
matrix</p>
</td></tr>
<tr><td><code id="boost_+3A_include_sol">include_sol</code></td>
<td>
<p>In function <code>pureboost()</code>, Boolean with
default <code>TRUE</code> meaning to correctly account for the speed of
light, and <code>FALSE</code> meaning to assume <code class="reqn">c=1</code>. See details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Arguments <code>u,v</code> are coerced to three-velocities.
</p>
<p>A rotation-free Lorentz transformation is known as a <dfn>boost</dfn>
(sometimes a <dfn>pure boost</dfn>), here expressed in matrix form.  Pure
boost matrices are symmetric if <code class="reqn">c=1</code>.  Function <code>boost(u)</code>
returns a <code class="reqn">4\times 4</code> matrix giving the Lorentz transform of
an arbitrary three-velocity <code>u</code>.
</p>
<p>Boosts can be successively applied with regular matrix multiplication.
However, composing two successive pure boosts does not in general
return a pure boost matrix: the product is not symmetric in general.
Also note that boost matrices do not commute.  The resulting matrix
product represents a <dfn>Lorentz transform</dfn>.
</p>
<p>It is possible to decompose a Lorentz transform <code class="reqn">L</code> into a pure
boost and a spatial rotation.  Thus <code class="reqn">L=OP</code> where <code class="reqn">O</code> is an
orthogonal matrix and <code class="reqn">P</code> a pure boost matrix; these are returned by
functions <code>orthog()</code> and <code>pureboost()</code> respectively.  If the 
speed of light is not equal to 1, the functions still work but can be
confusing.
</p>
<p>Functions <code>pureboost.galilean()</code> and <code>orthog.galilean()</code> are
the Newtonian equivalents of <code>pureboost()</code> and <code>orthog()</code>,
intended to be used when the speed of light is infinite (which causes
problems for the relativistic functions).
</p>
<p>As noted above, the composition of two pure Lorentz boosts is not
necessarily pure.  If we have two successive boosts corresponding to
<code class="reqn">u</code> and <code class="reqn">v</code>, then the composed boost may be decomposed into a
pure boost of <code>boost(u+v)</code> and a rotation of <code>rot(u,v)</code>.
</p>
<p>The reason argument <code>include_sol</code> exists is that function
<code>orthog()</code> needs to call <code>pureboost()</code> in an environment
where we pretend that <code class="reqn">c=1</code>.
</p>


<h3>Value</h3>

<p>Function <code>boost()</code> returns a <code class="reqn">4\times 4</code>
matrix; function <code>rot()</code> returns an orthogonal matrix.
</p>


<h3>Note</h3>

<p>Function <code>rot()</code> uses <code>crossprod()</code> for efficiency reasons
but is algebraically equivalent to
</p>
<p><code>boost(-u-v) %*% boost(u) %*% boost(v)</code>. 
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li>
<p>Ungar 2006. &ldquo;Thomas precession: a kinematic
effect...&rdquo;. European Journal of Physics, 27:L17-L20
</p>
</li>
<li>
<p>Sbitneva 2001. &ldquo;Nonassociative geometry of special relativity&rdquo;.
International Journal of Theoretical Physics, volume 40, number 1,
pages 359&ndash;362
</p>
</li>
<li><p> Wikipedia contributors 2018.  &ldquo;Wigner rotation&rdquo;,
Wikipedia, The Free Encyclopedia.
<a href="https://en.wikipedia.org/w/index.php?title=Wigner_rotation&amp;oldid=838661305">https://en.wikipedia.org/w/index.php?title=Wigner_rotation&amp;oldid=838661305</a>.  Online; accessed 23 August 2018
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>boost(as.3vel(c(0.4,-0.2,0.1)))

u &lt;- r3vel(1)
v &lt;- r3vel(1)
w &lt;- r3vel(1)

boost(u) - solve(boost(-u))  # should be zero

boost(u) %*% boost(v)   # not a pure boost (not symmetrical)
boost(u+v)  # not the same!
boost(v+u)  # also not the same!

u+v  # returns a three-velocity


boost(u) %*% boost(v) %*% boost(w)  # associative, no brackets needed
boost(u+(v+w))  # not the same!
boost((u+v)+w)  # also not the same!


rot(u,v)
rot(v,u)    # transpose (=inverse) of rot(u,v)


rot(u,v,FALSE) %*% boost(v) %*% boost(u)
boost(u+v)     # should be the same.


orthog(boost(u) %*% boost(v)) - rot(u,v,FALSE)  # zero to numerical precision
pureboost(boost(v) %*% boost(u)) - boost(u+v)   # ditto


## Define a random-ish Lorentz transform
L &lt;- boost(r3vel(1)) %*% boost(r3vel(1)) %*% boost(r3vel(1))

## check it:


## Not run:    # needs emulator package
quad.form(eta(),L)  # should be eta()

## End(Not run)

## More concisely:
is.consistent.boost(L)     # should be TRUE

## Decompose L into a rotation and a pure boost:
U &lt;- orthog(L)
P &lt;- pureboost(L)

L - U %*% P              # should be zero (L = UP)
crossprod(U)               # should be identity (U is orthogonal)
P - t(P)                   # should be zero (P is symmetric)

## First row of P should be a consistent 4-velocity:
is.consistent.4vel(P[1,,drop=FALSE],give=TRUE)
</code></pre>

<hr>
<h2 id='c.3vel'>Combine vectors of three-velocities and four-velocities into a single vector</h2><span id='topic+c.3vel'></span><span id='topic+c.3cel'></span><span id='topic+c.4vel'></span>

<h3>Description</h3>

<p>Combines its arguments recursively to form a vector of three velocities
or four velocities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '3vel'
c(...)
## S3 method for class '3cel'
c(...)
## S3 method for class '4vel'
c(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="c.3vel_+3A_...">...</code></td>
<td>
<p>Vectors of three-velocities</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a vector of three-velocities or four-velocities.  These are
stored as three- or four- column matrices; each row is a velocity.
</p>
<p>Names are inherited from the behaviour of <code>cbind()</code>, not
<code>c()</code>.
</p>


<h3>Note</h3>

<p>This function is used extensively in
<code>inst/distributive_search.R</code>.
</p>
<p>For &ldquo;c&rdquo; as in celerity or speed of light, see <code>sol()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+sol">sol</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
c(r3vel(3),r3vel(6,0.99))


</code></pre>

<hr>
<h2 id='celerity'>Celerity and rapidity</h2><span id='topic+celerity'></span><span id='topic+threecel'></span><span id='topic+rapidity'></span><span id='topic+celerity.3vel'></span><span id='topic+celerity.4vel'></span><span id='topic+celerity.default'></span><span id='topic+celerity_ur'></span><span id='topic+rapidity.3vel'></span><span id='topic+rapidity.4vel'></span><span id='topic+rapidity.default'></span><span id='topic+rapidity_ur'></span><span id='topic+as.3cel'></span><span id='topic+cel_to_vel'></span><span id='topic+vel_to_cel'></span><span id='topic+is.3cel'></span>

<h3>Description</h3>

<p>The celerity and rapidity of an object (experimental functionality)</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '3vel'
celerity(u)
## S3 method for class '4vel'
celerity(u)
celerity_ur(d)
## S3 method for class '3vel'
rapidity(u)
## S3 method for class '4vel'
rapidity(u)
rapidity_ur(d)
as.3cel(x)
cel_to_vel(x)
vel_to_cel(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="celerity_+3A_u">u</code>, <code id="celerity_+3A_x">x</code></td>
<td>
<p>Speed: either a vector of speeds or a vector of
three-velocities or four-velocities</p>
</td></tr>
<tr><td><code id="celerity_+3A_d">d</code></td>
<td>
<p>In functions <code>celerity_ur()</code> and <code>rapidity_ur()</code>,
deficit of speed; speed of light minus speed of object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <dfn>celerity</dfn> corresponding to speed <code class="reqn">u</code> is defined as
<code class="reqn">u\gamma</code> and the <dfn>rapidity</dfn> is
<code class="reqn">c\cdot\mathrm{atanh}(u/c)</code>.
</p>
<p>Functions <code>celerity_ur()</code> and <code>rapidity_ur()</code> are used for
the ultrarelativistic case where speeds are very close to the speed of
light.  Its argument <code>d</code> is the deficit, that is, <code class="reqn">d=c-v</code>
where <code class="reqn">v</code> is the speed of the transformation.  Algebraically,
<code>celerity_ur(c-v) == celerity(v)</code>, but if <code class="reqn">d=1-v/c</code> is small
the result of <code>celerity_ur()</code> is more accurate than that of
<code>celerity()</code>.
</p>
<p>Things get a bit sticky for celerity and rapidity if <code class="reqn">c\neq
  1</code>.  The guiding principle in the package is to give the
celerity and rapidity the same units as <code class="reqn">c</code>, so if <code class="reqn">u\ll
  c</code> we have that all three of <code>celerity(u)</code>,
<code>rapidity(u)</code> and <code>u</code> are approximately equal.  Note
carefully that, in contrast, <code class="reqn">\gamma</code> is dimensionless.  Also
observe that <code>d</code> in functions <code>celerity_ur()</code> and
<code>rapidity_ur()</code> has the same units as <code class="reqn">c</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+gam">gam</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
u &lt;- 0.1  # c=1
c(u,celerity(u),rapidity(u))

omgp &lt;- 4.9e-24  # speed deficit of the Oh-My-God particle
c(celerity_ur(omgp),rapidity_ur(omgp))


sol(299792458)                 # use SI units
u &lt;- 3e7  # ~0.1c
c(u,celerity(u),rapidity(u))


snail &lt;- 0.00275
c(snail,celerity(snail),rapidity(snail))


omgp &lt;- omgp*sol() 
c(celerity_ur(omgp),rapidity_ur(omgp))


sol(1)

</code></pre>

<hr>
<h2 id='comm_fail'>
Failure of commutativity and associativity using visual plots
</h2><span id='topic+comm_fail'></span><span id='topic+comm_fail1'></span><span id='topic+comm_fail2'></span><span id='topic+ass_fail'></span><span id='topic+my_seg'></span>

<h3>Description</h3>

<p>Relativistic addition of three-velocities is neither commutative nor
associative, and the functions documented here show this visually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comm_fail1(u, v, bold=5, r=1)
comm_fail2(u, v, bold=5, r=1)
ass_fail(u, v, w, bold=5,r=1)
my_seg(u,start=as.3vel(0), bold=5, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="comm_fail_+3A_u">u</code>, <code id="comm_fail_+3A_v">v</code>, <code id="comm_fail_+3A_w">w</code>, <code id="comm_fail_+3A_start">start</code></td>
<td>
<p>Three velocities.  Arguments <code>u</code> and <code>w</code> are
single-element three velocities, argument <code>v</code> is a vector.  See
the examples</p>
</td></tr>
<tr><td><code id="comm_fail_+3A_bold">bold</code></td>
<td>
<p>Integer specifying which vector element to be drawn in
bold</p>
</td></tr>
<tr><td><code id="comm_fail_+3A_r">r</code></td>
<td>
<p>Radius of dotted green circle, defaulting to 1 (corresponding
to <code class="reqn">c=1</code>).  Use <code>NA</code> to suppress plotting of circle</p>
</td></tr>
<tr><td><code id="comm_fail_+3A_...">...</code></td>
<td>
<p>Further arguments, passed to <code>arrows()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>These functions are called for their side-effect of plotting a diagram.
</p>


<h3>Note</h3>

<p>The vignette <code>lorentz</code> gives more details and
interpretation of the diagrams.
</p>
<p>Function <code>my_seg()</code> is an internal helper function.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
u &lt;- as.3vel(c(0.4,0,0))
v &lt;- seq(as.3vel(c(0.4,-0.2,0)), as.3vel(c(-0.3,0.9,0)),len=20)
w &lt;- as.3vel(c(0.8,-0.4,0))

comm_fail1(u=u, v=v)
comm_fail2(u=u, v=v)
  ass_fail(u=u, v=v, w=w, bold=10)

</code></pre>

<hr>
<h2 id='coordnames'>Coordinate names for relativity</h2><span id='topic+coordnames'></span><span id='topic+flob'></span>

<h3>Description</h3>

<p>Trivial function to set coordinate names to &ldquo;<code>t</code>&rdquo;,
&ldquo;<code>x</code>&rdquo;, &ldquo;<code>y</code>&rdquo;, &ldquo;<code>z</code>&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordnames(...)
flob(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coordnames_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
<tr><td><code id="coordnames_+3A_x">x</code></td>
<td>
<p>A matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>coordnames()</code> simply returns the character string
<code>c("t","x","y","z")</code>.  It may be overwritten.
Function <code>flob()</code> sets the row and columnnames of a <code class="reqn">4\times
    4</code> matrix to <code>coordnames()</code>.
</p>


<h3>Note</h3>

<p>If anyone can think of a better name than <code>flob()</code> let me know.</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
coordnames()

flob(diag(3))
flob(matrix(1,4,4))

## You can change the names if you wish:
coordnames &lt;- function(x){letters[1:4]}
flob(outer(1:4,1:4))

</code></pre>

<hr>
<h2 id='cosines'>Direction cosines</h2><span id='topic+cosines'></span><span id='topic+cosine'></span><span id='topic+dcosines'></span><span id='topic+direction.cosines'></span>

<h3>Description</h3>

<p>Given a vector of three-velocities, returns their direction cosines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cosines(u, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cosines_+3A_u">u</code></td>
<td>
<p>A vector of three-velocities</p>
</td></tr>
<tr><td><code id="cosines_+3A_drop">drop</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to coerce return
value from a one-row matrix to a vector, and <code>FALSE</code> meaning
to consistently return a matrix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
cosines(r3vel(7))


cosines(r3vel(1),drop=TRUE)
cosines(r3vel(1),drop=FALSE)
</code></pre>

<hr>
<h2 id='Extract.3vel'>Extract or replace parts of three-velocity</h2><span id='topic+Extract.3vel'></span><span id='topic+extract.3vel'></span><span id='topic++5B.vel'></span><span id='topic++5B+3C-.vel'></span><span id='topic++5B.3vel'></span><span id='topic++5B+3C-.3vel'></span><span id='topic++5B.4vel'></span><span id='topic++5B+3C-.4vel'></span>

<h3>Description</h3>

<p>Extract or replace subsets of three-velocities
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Extract.3vel_+3A_x">x</code></td>
<td>
<p>A three-vector</p>
</td></tr>
<tr><td><code id="Extract.3vel_+3A_index">index</code></td>
<td>
<p>elements to extract or replace</p>
</td></tr>
<tr><td><code id="Extract.3vel_+3A_value">value</code></td>
<td>
<p>replacement value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods (should) work as expected: an object of class
<code>3vel</code> is a three-column matrix with rows corresponding to
three-velocities; a single argument is interpreted as a row number.
Salient use-cases are <code>u[1:5] &lt;- u[1]</code> and <code>u[1] &lt;- 0</code>.
</p>
<p>To extract a single component, pass a second index: <code>u[,1]</code>
returns the x- component of the three-velocity.
</p>
<p>Extraction functions take a <code>drop</code> argument, except for <code>x[i]</code>
which returns a <code>vec</code> object.
</p>
<p>Currently, <code>u[]</code> returns <code>u</code> but I am not sure this is
desirable.  Maybe it should return <code>unclass(u)</code> or perhaps
<code>c(unclass(u))</code>.
</p>
<p>Use idiom <code>u[] &lt;- x</code> to replace entries of <code>u</code> elementwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
u &lt;- r3vel(10)
u[1:4]
u[5:6] &lt;- 0

u[7:8] &lt;- u[1]

u[,1] &lt;- 0.1

</code></pre>

<hr>
<h2 id='fourmom'>Four momentum</h2><span id='topic+Ops.4mom'></span><span id='topic+4mom'></span><span id='topic+fourmom'></span><span id='topic+as.4mom'></span><span id='topic+sum.4mom'></span><span id='topic+fourmomentum'></span><span id='topic+four-momentum'></span><span id='topic+4momentum'></span><span id='topic+4-momentum'></span><span id='topic+vel_to_4mom'></span><span id='topic+p_to_4mom'></span><span id='topic+is.4mom'></span><span id='topic+fourmom_mult'></span><span id='topic+fourmom_add'></span>

<h3>Description</h3>

<p>Create and test for four-momentum</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '4mom'
Ops(e1, e2)
## S3 method for class '4mom'
sum(..., na.rm=FALSE)
vel_to_4mom(U,m=1)
p_to_4mom(p,E=1)
as.4mom(x)
is.4mom(x)
fourmom_mult(P,n)
fourmom_add(e1,e2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fourmom_+3A_x">x</code>, <code id="fourmom_+3A_p">P</code>, <code id="fourmom_+3A_e1">e1</code>, <code id="fourmom_+3A_e2">e2</code></td>
<td>
<p>Four-momentum</p>
</td></tr>
<tr><td><code id="fourmom_+3A_p">p</code></td>
<td>
<p>Three-momentum</p>
</td></tr>
<tr><td><code id="fourmom_+3A_e">E</code></td>
<td>
<p>Scalar; energy</p>
</td></tr>
<tr><td><code id="fourmom_+3A_u">U</code></td>
<td>
<p>Object coerced to four-velocity</p>
</td></tr>
<tr><td><code id="fourmom_+3A_m">m</code></td>
<td>
<p>Scalar; rest mass</p>
</td></tr>
<tr><td><code id="fourmom_+3A_n">n</code></td>
<td>
<p>Multiplying factor</p>
</td></tr>
<tr><td><code id="fourmom_+3A_...">...</code>, <code id="fourmom_+3A_na.rm">na.rm</code></td>
<td>
<p>Arguments sent to <code>sum()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Four-momentum is a relativistic generalization of three-momentum, with
the object's energy as the first element.  It can be defined as
<code class="reqn">mU</code>, where <code class="reqn">m</code> is the rest mass and <code class="reqn">U</code> the four-velocity.
Equivalently, one can define four-momentum as
<code class="reqn">(E/c,p_x,p_y,p_z)</code> where <code class="reqn">E</code> is the energy and
<code class="reqn">(p_x,p_y,p_z)</code> the three-momentum.
</p>
<p>Function <code>vel_to_4mom()</code> converts three-velocity to four-momentum,
and function <code>p_to_4mom()</code>) converts a three-momentum to a
four-momentum.
</p>
<p>The function <code>Ops.4mom()</code> passes unary and binary arithmetic
operators &ldquo;<code>+</code>&rdquo;, &ldquo;<code>-</code>&rdquo; and &ldquo;<code>*</code>&rdquo; to
the appropriate specialist function.
</p>
<p>The package is designed so that natural <span class="rlang"><b>R</b></span> idiom may be used for
physically meaningful operations such as combining momenta of different
objects, using the conservation of four-momentum.
</p>
<p>For the four-momentum of a photon, use <code>as.photon()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+boost">boost</a></code>,<code><a href="#topic+as.photon">as.photon</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Define 5 random three velocities:
v &lt;- r3vel(5)

# convert to four-velocity:
as.4vel(v)

# Now convert 'v' to four-momentum, specifying rest mass:
vel_to_4mom(v)         # 4mom of five objects with 3vel v, all unit mass
vel_to_4mom(v,   1:5)  # 4mom of five objects with 3vel v, masses 1-5
vel_to_4mom(v[1],1:5)  # 4mom of five objects with same 3vel, masses 1..5

# Now convert 'v' to four-momentum, specifying energy E:
p_to_4mom(v,E=1)
p_to_4mom(v,E=10)   # slower
p_to_4mom(v,E=100)  # even slower

# Four-momentum of objects moving closely parallel to the x-axis:
P &lt;- vel_to_4mom(as.3vel(c(0.8,0,0)) + r3vel(7,0.01))

reflect(P)
reflect(P,c(1,1,1))

sum(P)

</code></pre>

<hr>
<h2 id='fourvel'>Four velocities</h2><span id='topic+4vel'></span><span id='topic+fourvel'></span><span id='topic+as.4vel'></span><span id='topic+is.consistent.4vel'></span><span id='topic+fourvelocity'></span><span id='topic+four-velocity'></span><span id='topic+4velocity'></span><span id='topic+4-velocity'></span><span id='topic+is.4vel'></span><span id='topic+to3'></span><span id='topic+inner4'></span><span id='topic+inner+20product'></span>

<h3>Description</h3>

<p>Create and test for four-velocities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.4vel(u)
is.consistent.4vel(U, give=FALSE, TOL=1e-10)
inner4(U,V=U)
to3(U)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fourvel_+3A_u">u</code></td>
<td>
<p>A vector of three-velocities</p>
</td></tr>
<tr><td><code id="fourvel_+3A_u">U</code>, <code id="fourvel_+3A_v">V</code></td>
<td>
<p>A vector of four-velocities</p>
</td></tr>
<tr><td><code id="fourvel_+3A_give">give</code></td>
<td>
<p>In function <code>is.consistent.4vel()</code>, Boolean with
<code>TRUE</code> meaning to return <code class="reqn">U\cdot U+c^2</code>, which is
zero for a four-velocity, and default <code>FALSE</code> meaning to return
whether the four-velocity is consistent to numerical precision</p>
</td></tr>
<tr><td><code id="fourvel_+3A_tol">TOL</code></td>
<td>
<p>Small positive value used for tolerance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>as.4vel()</code> takes a three-velocity and returns a
four-velocity.
</p>
<p>Given a four-vector <code class="reqn">V</code>, function <code>inner4()</code> returns the
Lorentz invariant <code class="reqn">V^iV_i=\eta_{ij}V^iV^j</code>.  This
quantity is unchanged under Lorentz transforms.  Note that function
<code>inner4()</code> works for any four-vector, not just four-velocities.
It will work for (eg) a four-displacement, a four-momentum vector or a
four-frequency.  In electromagnetism, we could have a four-current or
a four-potential.  If <code class="reqn">U</code> is a four-velocity, then
<code class="reqn">U^iU_i=-c^2</code>; if <code class="reqn">U</code> is a 4-displacement, then <code class="reqn">U^iU_i</code> is
the squared interval.  If <code class="reqn">P</code> is the four-momentum of a photon
then <code class="reqn">P^iP_i=0</code>.
</p>
<p>Function <code>to3()</code> is a low-level helper function used when
<code>as.3vel()</code> is given a four-velocity.
</p>
<p>Function <code>is.consistent.4vel()</code> checks for four-velocities being
consistent in the sense that <code class="reqn">U^iU_i=-c^2</code>.  Giving this
function a vector, for example, <code>is.consistent.4vel(1:5)</code>, will
return an error.
</p>
<p>Compare the functions documented here with <code>boost()</code>, which
returns a <code class="reqn">4\times 4</code> transformation matrix (which also
includes rotation information).
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+boost">boost</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- r3vel(10)
as.4vel(a)     # a four-velocity

as.3vel(as.4vel(a))-a   # zero to numerical precision

inner4(as.4vel(a))   #  -1 to numerical precision

stopifnot(all(is.consistent.4vel(as.4vel(a))))


## check Lorentz invariance of dot product:
U &lt;- as.4vel(r3vel(10))
V &lt;- as.4vel(r3vel(10))
B &lt;- boost(as.3vel(1:3/10))

frame1dotprod &lt;- inner4(U, V)
frame2dotprod &lt;- inner4(U %*% B, V %*% B)
max(abs(frame1dotprod-frame2dotprod))  # zero to numerical precision

</code></pre>

<hr>
<h2 id='galileo'>Classical mechanics; Newtonian approximation; infinite speed of light</h2><span id='topic+galileo'></span><span id='topic+galilean'></span><span id='topic+Galileo'></span><span id='topic+Galilean'></span><span id='topic+classical'></span><span id='topic+newton'></span><span id='topic+Newton'></span><span id='topic+newtonian'></span><span id='topic+Newtonian'></span>

<h3>Description</h3>

<p>The Lorentz transforms reduce to their classical limit, the Galilean
transforms, if speeds are low compared with <code class="reqn">c</code>.  Package idiom for
working in a classical framework is to use an infinite speed of light:
<code>sol(Inf)</code>.  Here I show examples of this.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+boost">boost</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>sol(Inf)
boost(as.3vel(1:3))
as.3vel(1:3) + as.3vel(c(-1,4,5))     # classical velocity addition
rot(as.3vel(1:3),as.3vel(c(-4,5,2)))  # identity matrix


B &lt;- boost(as.3vel(1:3))
orthog(B) %*% pureboost(B)  # should be B

sol(1)
</code></pre>

<hr>
<h2 id='gam'>Gamma correction</h2><span id='topic+speed'></span><span id='topic+speed.3vel'></span><span id='topic+speed.4vel'></span><span id='topic+speedsquared'></span><span id='topic+gam'></span><span id='topic+gam.3vel'></span><span id='topic+gam.3cel'></span><span id='topic+gam.4vel'></span><span id='topic+gam.default'></span><span id='topic+gamm1'></span><span id='topic+gamm1.3vel'></span><span id='topic+gamm1.4vel'></span><span id='topic+gamm1.default'></span><span id='topic+gam_ur'></span>

<h3>Description</h3>

<p>Lorentz gamma correction term in special relativity</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '3vel'
speed(u)
## S3 method for class '4vel'
speed(u)
speedsquared(u)
gam(u)
gamm1(u)
## S3 method for class '3vel'
gam(u)
## S3 method for class '3cel'
gam(u)
## S3 method for class '4vel'
gam(u)
## S3 method for class '3vel'
gamm1(u)
## S3 method for class '4vel'
gamm1(u)
gam_ur(d)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gam_+3A_u">u</code></td>
<td>
<p>Speed: either a vector of speeds or a vector of
three-velocities or four-velocities</p>
</td></tr>
<tr><td><code id="gam_+3A_d">d</code></td>
<td>
<p>In function <code>gam_ur()</code>, deficit of speed; speed of light
minus speed of object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>speed(u)</code> returns the speed of a <code>3vel</code> object or
<code>4vel</code> object.
</p>
<p>Function <code>gam(u)</code> returns the Lorentz factor
</p>
<p style="text-align: center;"><code class="reqn">\frac{1}{\sqrt{1-\mathbf{u}\cdot\mathbf{u}/c^2}}</code>
</p>

<p>Function <code>gamm1(u)</code> returns the Lorentz factor minus 1, useful
for slow speeds when larger accuracy is needed (much like
<code>expm1()</code>); to see the <span class="rlang"><b>R</b></span> idiom, type &ldquo;<code>gamm1.3vel</code>&rdquo;
at the commandline.  Function <code>gamm1()</code> is intended to work with
<code>3vel</code> objects or speeds.  The function will take a 4-velocity,
but this is not recommended as accuracy is lost (all it does is return
the time component of the 4-velocity minus 1).
</p>
<p>Function <code>gam_ur()</code> is used for the ultrarelativistic case where
speeds are very close to the speed of light (the function is named for
&ldquo;gamma, ultrarelativistic&rdquo;).  Its argument <code>d</code> is the
deficit, that is, <code class="reqn">c-v</code> where <code class="reqn">v</code> is the speed of the
transformation.  Algebraically, <code>gam_ur(c-v) == gam(v)</code>, but if
<code>d</code> is small compared to <code>c</code> the result is more accurate.
</p>
<p>Function <code>speedsquared(u)</code> returns the square of the speed of a
<code>3vel</code> object.  Use this to avoid taking a needless square root.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gam(seq(from=0,by=0.1,len=10))
gam(r3vel(6,0.7))


x &lt;- as.3vel(c(0.1,0.4,0.5))
speed(x)

gam(speed(x))  # works, but slow and inaccurate
gam(x)         # recommended: avoids needless coercion



## Use SI units and deal with terrestrial speeds.  Use gamm1() for this.
sol(299792458)
sound &lt;- 343 # speed of sound in SI
gam(sound)
gam(sound)-1  
gamm1(sound)   # gamm1() gives much higher precision

snail &lt;- as.3vel(c(0.00275,0,0)) # even the world's fastest snail...
gamm1(snail)                     # ...has only a small relativistic correction


## For the ultrarelativistic case of speeds very close to the speed of
## light, use gam_ur():

sol(1)           # revert to relativistic units

gam(0.99) - gam_ur(0.01) # zero to numerical accuracy

omgp &lt;- 4.9e-24  # speed deficit of the Oh-My-God particle
gam(1-omgp)      # numeric overflow
gam_ur(omgp)     # large but finite

</code></pre>

<hr>
<h2 id='gyr'>Gyr function</h2><span id='topic+gyr'></span><span id='topic+gyr.a'></span><span id='topic+gyrfun'></span>

<h3>Description</h3>

<p>Relativistic addition of three velocities</p>


<h3>Usage</h3>

<pre><code class='language-R'>gyr(u, v, x)
gyr.a(u, v, x)
gyrfun(u, v)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gyr_+3A_u">u</code>, <code id="gyr_+3A_v">v</code>, <code id="gyr_+3A_x">x</code></td>
<td>
<p>Three-velocities, objects of class <code>3vel</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function  <code>gyr(u,v,x)</code> returns the three-vector
<code class="reqn">\mathrm{gyr}[u,v]x</code>.
</p>
<p>Function <code>gyrfun(u,v)</code> returns a function that returns a
three-vector; see examples.
</p>
<p>The speed of light (1 by default) is not used directly by these
functions; set it with <code>sol()</code>.
</p>


<h3>Note</h3>

<p>Function <code>gyr()</code> is slightly faster than <code>gyr.a()</code>, which is
included for pedagogical reasons.
</p>
<p>Function <code>gyr()</code> is simply
</p>
<p><code>add3(neg3(add3(u,v)),add3(u,add3(v,x)))</code>
</p>
<p>while function <code>gyr.a()</code> uses the slower but more transparent
idiom
</p>
<p><code> -(u+v) + (u+(v+x)) </code>
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>References</h3>


<ul>
<li>
<p>Ungar 2006. &ldquo;Thomas precession: a kinematic
effect of the algebra of Einstein's velocity addition law.  Comments
on &lsquo;Deriving relativistic momentum and energy: I.
Three-dimensional case&rsquo;&rdquo;. European Journal of Physics,
27:L17-L20.
</p>
</li>
<li>
<p>Sbitneva 2001. &ldquo;Nonassociative geometry of special relativity&rdquo;.
International Journal of Theoretical Physics, volume 40, number 1,
pages 359&ndash;362</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

u &lt;- r3vel(10)
v &lt;- r3vel(10)
w &lt;- r3vel(10)

x &lt;- as.3vel(c(0.4,0.1,-0.5))
y &lt;- as.3vel(c(0.1,0.2,-0.7))
z &lt;- as.3vel(c(0.2,0.3,-0.1))


gyr(u,v,x)  # gyr[u,v]x

f &lt;- gyrfun(u,v)
g &lt;- gyrfun(v,u)

f(x)
f(r3vel(10))

f(g(x)) - x              # zero, by eqn 9
g(f(x)) - x              # zero, by eqn 9
(x+y) - f(y+x)           # zero by eqn 10
(u+(v+w)) - ((u+v)+f(w)) # zero by eqn 11


# Following taken from Sbitneva 2001:

rbind(x+(y+(x+z))  ,   (x+(y+x))+z)   # left Bol property
rbind((x+y)+(x+y)  ,   x+(y+(y+x)))   # left Bruck property


sol(299792458)   # speed of light in SI
as.3vel(c(1000,3000,1000)) + as.3vel(c(1000,3000,1000))
## should be close to Galilean result

sol(1)   # revert to default c=1

</code></pre>

<hr>
<h2 id='Ops.3vel'>Arithmetic Ops Group Methods for 3vel objects</h2><span id='topic+Ops.3vel'></span><span id='topic+Ops.4vel'></span><span id='topic+Ops.gyr'></span><span id='topic+Ops'></span><span id='topic+massage3'></span><span id='topic+neg3'></span><span id='topic+prod3'></span><span id='topic+add3'></span><span id='topic+dot3'></span><span id='topic+equal3'></span>

<h3>Description</h3>

<p>Arithmetic operations for three-velocities</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '3vel'
Ops(e1, e2)
## S3 method for class '4vel'
Ops(e1, e2)
massage3(u,v)
neg3(u)
prod3(u,v=u)
add3(u,v)
dot3(v,r)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Ops.3vel_+3A_e1">e1</code>, <code id="Ops.3vel_+3A_e2">e2</code>, <code id="Ops.3vel_+3A_u">u</code>, <code id="Ops.3vel_+3A_v">v</code></td>
<td>
<p>Objects of class &ldquo;<code>3vel</code>&rdquo;,
three-velocities</p>
</td></tr>
<tr><td><code id="Ops.3vel_+3A_r">r</code></td>
<td>
<p>Scalar value for circle-dot multiplication</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>Ops.3vel()</code> passes unary and binary arithmetic
operators &ldquo;<code>+</code>&rdquo;, &ldquo;<code>-</code>&rdquo; and &ldquo;<code>*</code>&rdquo;
to the appropriate specialist function.
</p>
<p>The most interesting operators are &ldquo;<code>+</code>&rdquo; and
&ldquo;<code>*</code>&rdquo;, which are passed to <code>add3()</code> and <code>dot3()</code>
respectively.  These are defined, following Ungar, as:
</p>
<p style="text-align: center;"><code class="reqn">
    \mathbf{u}+\mathbf{v} = \frac{1}{1+\mathbf{u}\cdot\mathbf{b}/c^2}
    \left\{
    \mathbf{u} +
    \frac{1}{\gamma_\mathbf{u}}\mathbf{v} +
    \frac{1}{c^2}\frac{\gamma_\mathbf{u}}{1+\gamma_\mathbf{u}}
    \left(\mathbf{u}\cdot\mathbf{v}\right)\mathbf{u}
    \right\}
  </code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
    r\odot\mathbf{v} =
    c\tanh\left(
    r\tanh^{-1}\frac{\left|\left|\mathbf{v}\right|\right|}{c}
    \right)\frac{\mathbf{v}}{\left|\left|\mathbf{v}\right|\right|}
  </code>
</p>
 
<p>where <code class="reqn">\mathbf{u}</code> and <code class="reqn">\mathbf{v}</code> are three-vectors
and <code class="reqn">r</code> a scalar.  Function <code>dot3()</code> has special dispensation
for zero velocity and does not treat <code>NA</code> entries entirely
consistently.
</p>
<p>Arithmetic operations, executed via <code>Ops.4vel()</code>, are not defined
on four-velocities.
</p>
<p>The package is designed so that natural <span class="rlang"><b>R</b></span> idiom may be used for three
velocity addition, see the examples section.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>3vel</code>, except for <code>prod3()</code>
which returns a numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>u &lt;- as.3vel(c(-0.7, 0.1,-0.1))
v &lt;- as.3vel(c( 0.1, 0.2, 0.3))
w &lt;- as.3vel(c( 0.5, 0.2,-0.3))

x &lt;- r3vel(10)   # random three velocities
y &lt;- r3vel(10)   # random three velocities


u+v   # add3(u,v)
u-v   # add3(u,neg3(v))

-v    # neg3(v)

gyr(u,v,w)

## package is vectorized:


u+x
x+y

f &lt;- gyrfun(u,v)
g &lt;- gyrfun(v,u)

f(g(x)) - x    # should be zero by eqn10
g(f(x)) - x


(u+v) - f(v+u)                     # zero by eqn 10
(u+(v+w)) - ((u+v)+f(w))           # zero by eqn 11
((u+v)+w) - (u+(v+g(w)))           # zero by eqn 11


## NB, R idiom is unambiguous.  But always always ALWAYS use brackets.

## Ice report in lat 42.n to 41.25n Long 49w to long 50.30w saw much
## heavy pack ice and great number large icebergs also field
## ice.  Weather good clear

## -u+v == (-u) + v == neg3(u) + v == add3(neg3(u),v)

## u+v+w == (u+v)+w == add3(add3(u,v),w)

</code></pre>

<hr>
<h2 id='photon'>Photons</h2><span id='topic+photon'></span><span id='topic+as.photon'></span><span id='topic+light'></span><span id='topic+nullvec'></span><span id='topic+nullvector'></span><span id='topic+null+20vector'></span><span id='topic+is.consistent.nullvec'></span>

<h3>Description</h3>

<p>Various functionality to deal with the 4-momentum of a photon</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.consistent.nullvec(N,TOL=1e-10)
as.photon(x,E=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="photon_+3A_n">N</code></td>
<td>
<p>Four-momentum to be tested for nullness</p>
</td></tr>
<tr><td><code id="photon_+3A_tol">TOL</code></td>
<td>
<p>tolerance</p>
</td></tr>
<tr><td><code id="photon_+3A_x">x</code></td>
<td>
<p>Vector of three-velocities</p>
</td></tr>
<tr><td><code id="photon_+3A_e">E</code></td>
<td>
<p>Energy, a scalar</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the four-momentum of a photon.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+4mom">4mom</a></code>,<code><a href="#topic+reflect">reflect</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
## A bunch of photons all approximately parallel to the x-axis:
as.photon(as.3vel(cbind(0.9,runif(10)/1000,runif(10)/1000)))


## mirror ball:
jj &lt;- matrix(rnorm(30),10,3)
disco &lt;- sweep(matrix(rnorm(30),10,3),1,sqrt(rowSums(jj^2)),`/`)
p &lt;- as.photon(c(1,0,0))
reflect(p,disco)

table(reflect(p,disco)[,2]&gt;0) # should be TRUE with probability sqrt(0.5)

## relativistic  disco; mirror ball moves at 0.5c:

B &lt;- boost(as.3vel(c(0.5,0,0)))
p |&gt; tcrossprod(B) |&gt; reflect(disco) |&gt; tcrossprod(solve(B))


</code></pre>

<hr>
<h2 id='print.3vel'>Print methods for three-velocities and four-velocities</h2><span id='topic+print.3vel'></span><span id='topic+print.3cel'></span><span id='topic+print.4vel'></span><span id='topic+print.4mom'></span>

<h3>Description</h3>

<p>Print methods for three-velocities</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '3vel'
print(x, ...)
## S3 method for class '3cel'
print(x, ...)
## S3 method for class '4vel'
print(x, ...)
## S3 method for class '4mom'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.3vel_+3A_x">x</code></td>
<td>
<p>Vector of three-velocities</p>
</td></tr>
<tr><td><code id="print.3vel_+3A_...">...</code></td>
<td>
<p>Further arguments, currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a vector of three-velocities</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>r3vel(10)
</code></pre>

<hr>
<h2 id='r3vel'>Random relativistic velocities</h2><span id='topic+r3vel'></span><span id='topic+r4vel'></span><span id='topic+rboost'></span>

<h3>Description</h3>

<p>Generates random three-velocities or four-velocities, optionally specifiying a magnitude
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r3vel(n=7, r = NA)
r4vel(...)
rboost(r = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="r3vel_+3A_n">n</code></td>
<td>
<p>Number of three- or four- velocities to generate</p>
</td></tr>
<tr><td><code id="r3vel_+3A_r">r</code></td>
<td>
<p>Absolute value of the three-velocities, with default
<code>NA</code> meaning to sample uniformly from the unit ball</p>
</td></tr>
<tr><td><code id="r3vel_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>r3vel()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>r3vel()</code> returns a random three-velocity.  Function
<code>r4vel()</code> is a convenience wrapper for <code>as.4vel(r3vel())</code>.
</p>
<p>Function <code>rboost()</code> returns a random <code class="reqn">4\times 4</code> Lorentz
boost matrix, drawn from the connected component.  If given
<code>r=0</code>, then a transform corresponding to a random rotation will
be returned.
</p>


<h3>Value</h3>

<p>Returns a vector of three- or four- velocities.
</p>


<h3>Note</h3>

<p>If the speed of light is infinite, these functions require a specified
argument for <code>r</code>.
</p>
<p>It is not entirely trivial to sample <em>uniformly</em> from the unit ball
or unit sphere, but it is not hard either.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
r3vel()

a &lt;- r3vel(10000)
b &lt;- r3vel(1000,0.8)
u &lt;- as.3vel(c(0,0,0.9))

pairs(unclass(u+a),asp=1)
pairs(unclass(a+u),asp=1)

is.consistent.boost(rboost())

sol(299792458)    # switch to SI units
sound &lt;- 343      # speed of sound in metres per second
r3vel(100,343)    # random 3-velocities with speed = 343 m/s

sol(1)   # return to default c=1

</code></pre>

<hr>
<h2 id='reflect'>Mirrors</h2><span id='topic+reflect'></span><span id='topic+mirror'></span><span id='topic+mirrors'></span><span id='topic+reflection'></span>

<h3>Description</h3>

<p>Plane mirrors in special relativity</p>


<h3>Usage</h3>

<pre><code class='language-R'>reflect(P,m,ref=1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reflect_+3A_p">P</code></td>
<td>
<p>Vector of four-momenta</p>
</td></tr>
<tr><td><code id="reflect_+3A_m">m</code></td>
<td>
<p>Orientation of mirror, expressed as a three-vector</p>
</td></tr>
<tr><td><code id="reflect_+3A_ref">ref</code></td>
<td>
<p>Coefficient of reflectivity of the mirror</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Takes a four-momentum and returns the four-momentum after reflection.
Will handle objects or photons.
</p>


<h3>Note</h3>

<p>All four-momenta are measured in the rest frame of the mirror, but it
is easy to reflect from moving mirrors; see examples.
</p>
<p>However, note that the <code>ref</code> argument is designed to work with
photons only, where it is conceptually the percentage of photons
reflected and not absorbed by the mirror.  If <code>ref</code> is less than
unity, odd results are given for four momenta of nonzero restmass
objects.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>See Also</h3>

<p><code><a href="#topic+photon">photon</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## We will reflect some photons from an oblique mirror moving at half
## the speed of light.

## First create 'A', a bunch of photons all moving roughly along the x-axis:
A &lt;- as.photon(as.3vel(cbind(0.9,runif(10)/1000,runif(10)/1000)))

## Now create 'm', a mirror oriented perpendicular to c(1,1,1):
m &lt;- c(1,1,1)

## Reflect the photons in the mirror:
reflect(A,m)

## Reflect the photons in a series of mirrors:
A |&gt; reflect(m) |&gt; reflect(1:3) |&gt; reflect(3:1) 


## To reflect from a moving mirror we need to transform to a frame in
## which the mirror is at rest, then transform back to the original
## frame.  First create B, a boost representing the mirror's movement
## along the x-axis at speed c/2:

B &lt;- boost(as.3vel(c(0.5,0,0)))


## Transform to the mirror's rest frame:
A %*% t(B)    

## NB: in the above, take a transpose because the *rows* of A are 4-vectors.

## Then reflect the photons in the mirror:
reflect(A %*% t(B),m)


## Now transform back to the original rest frame (NB: active transform):
A |&gt; tcrossprod(B) |&gt; reflect(m) |&gt; tcrossprod(solve(B))


</code></pre>

<hr>
<h2 id='seq.3vel'>seq method for three velocities</h2><span id='topic+seq.3vel'></span>

<h3>Description</h3>

<p>Simplified version of <code>seq()</code> for three-velocities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class '3vel'
seq(from, to, len, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seq.3vel_+3A_from">from</code>, <code id="seq.3vel_+3A_to">to</code></td>
<td>
<p>Start and end of sequence</p>
</td></tr>
<tr><td><code id="seq.3vel_+3A_len">len</code></td>
<td>
<p>Length of vector returned</p>
</td></tr>
<tr><td><code id="seq.3vel_+3A_...">...</code></td>
<td>
<p>Further arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>seq(a,b,n)</code> returns <code>a + t*(-b+a)</code> where <code>t</code> is
numeric vector <code>seq(from=0,to=1,len=n)</code>.
</p>
<p>This definition is one of several plausible alternatives, but has the
nice property that the first and last elements are exactly equal to
<code>a</code> and <code>b</code> respectively.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- as.3vel(c(4,5,6)/9)
b &lt;- as.3vel(c(-5,6,8)/14)
x &lt;- seq(a,b,len=9)

x[1]-a # should be zero
x[9]-b # should be zero


jj &lt;- a + seq(0,1,len=9)*(b-a)

jj-x   # decidedly non-zero


</code></pre>

<hr>
<h2 id='sol'>Speed of light and Minkowski metric</h2><span id='topic+sol'></span><span id='topic+eta'></span><span id='topic+minkowski'></span><span id='topic+lightspeed'></span><span id='topic+ptm'></span>

<h3>Description</h3>

<p>Getting and setting the speed of light</p>


<h3>Usage</h3>

<pre><code class='language-R'>sol(c)
eta(downstairs=TRUE)
ptm(to_natural=TRUE, change_time=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sol_+3A_c">c</code></td>
<td>
<p>Scalar, speed of light.  If missing, return the speed of
light</p>
</td></tr>
<tr><td><code id="sol_+3A_downstairs">downstairs</code></td>
<td>
<p>Boolean, with default <code>TRUE</code> meaning to return
the covariant metric tensor <code class="reqn">g_{ij}</code> with two downstairs
indices, and <code>FALSE</code> meaning to return the contravariant
version <code class="reqn">g^{ij}</code> with two upstairs indices</p>
</td></tr>
<tr><td><code id="sol_+3A_to_natural">to_natural</code>, <code id="sol_+3A_change_time">change_time</code></td>
<td>
<p>Boolean, specifying the
nature of the passive transform matrix</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the context of an <span class="rlang"><b>R</b></span> package, the symbol &ldquo;c&rdquo; presents
particular problems.  In the <span class="pkg">lorentz</span> package, the speed of light
is denoted &ldquo;sol&rdquo;, for &lsquo;speed of light&rsquo;.  You can set the
speed of light with <code>sol(x)</code>, and query it with <code>sol()</code>; see
the examples.  An infinite speed of light is sometimes useful for
Galilean transforms.
</p>
<p>The speed of light is a global variable, governed by
<code>options("c")</code>.  If <code>NULL</code>, define <code>c=1</code>.  Setting
<code>showSOL</code> to <code>TRUE</code> makes <code>sol()</code> change the prompt to
display the speed of light which might be useful.
</p>
<p>Function <code>eta()</code> returns the Minkowski flat-space metric
</p>
<p style="text-align: center;"><code class="reqn">\mathrm{diag}\left(-c^2,1,1,1\right).</code>
</p>

<p>Note that the top-left element of <code>eta()</code> is <code class="reqn">-c^2</code>, not
<code class="reqn">-1</code>.
</p>
<p>Function <code>ptm()</code> returns a passive transformation matrix that
converts displacement vectors to natural units
(<code>to_natural=TRUE</code>) or from natural units
(<code>to_natural=FALSE</code>).  Argument <code>change_time</code> specifies
whether to change the unit of time (if <code>TRUE</code>) or the unit of
length (if <code>FALSE</code>).
</p>


<h3>Note</h3>

<p>Typing &ldquo;<code>sol(299792458)</code>&rdquo; is a lot easier than typing
&ldquo;<code>options("c"=299792458)</code>&rdquo;, which is why the package uses
the idiom that it does.
</p>
<p>In a R-devel discussion about options for printing, Martin Maechler
makes the following observation: &ldquo;Good programming style
for functions according to my book is to have them depend only on
their arguments, and if a global option really (really? think twice!)
should influence behavior, there should be arguments of the function
which have a default determined by the global option&rdquo;
</p>
<p>I think he is right in general, but offer the observation that the
speed of light depends on the units chosen, and typically one fixes
one's units once and for all, and does not subsequently change them.
This would indicate (to me at least) that a global option would be
appropriate.  Further, there <em>is</em> a default, <code class="reqn">c=1</code>, which is
returned by <code>sol()</code> if the option is unset.  This is not just a
&ldquo;default&rdquo;, though: it is used in the overwhelming majority of
cases.  Indeed, pedagogically speaking, one learning objective from
the package is that units in which <code class="reqn">c\neq 1</code> are difficult,
awkward, and unnatural.  In the package R code, the
<em>only</em> place the speed of light option is accessed is via
<code>sol()</code>.  Similar arguments are presented in the <span class="pkg">clifford</span>
package at <code>signature.Rd</code>.
</p>
<p>Looking again at Martin's observation he seems to be suggesting that
something along the lines of
</p>
<pre>
    gam &lt;- function(u, c=1){1/sqrt(1-u^2/c^2)}
  </pre>
<p>But this is asking for trouble:
</p>
<pre>
    c(gam(0.4,c=1),gam(0.4,c=10))
  </pre>
<p>which is meaningless at best and misleading at worst.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sol()                          # returns current speed of light
sol(299792458)                 # use SI units
sol()                          # speed of light now SI value

eta()                          # note [t,t] term
u &lt;- as.3vel(c(100,200,300))   # fast terrestrial speed, but not relativistic
boost(u)                       # boost matrix practically Galilean
is.consistent.boost(boost(u))  # should be TRUE
sol(1)                         # revert to relativistic units

</code></pre>

<hr>
<h2 id='threevel'>Three velocities</h2><span id='topic+3vel'></span><span id='topic+as.3vel'></span><span id='topic+is.3vel'></span><span id='topic+length.vec'></span><span id='topic+names.vec'></span><span id='topic+names+3C-.vec'></span><span id='topic+threevel'></span><span id='topic+3velocity'></span><span id='topic+3-velocity'></span><span id='topic+threevelocity'></span><span id='topic+three-velocity'></span>

<h3>Description</h3>

<p>Create and test for three-velocities, <code>3vel</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>`3vel`(n)
threevel(n)
as.3vel(x)
is.3vel(x)
## S3 method for class 'vec'
length(x)
## S3 method for class 'vec'
names(x)
## S3 replacement method for class 'vec'
names(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threevel_+3A_n">n</code></td>
<td>
<p>In function <code>3vel()</code>, number of three velocities to
create</p>
</td></tr>
<tr><td><code id="threevel_+3A_x">x</code>, <code id="threevel_+3A_value">value</code></td>
<td>
<p>Vectors of three-velocities</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Class <code>vel</code> is a virtual class containing classes <code>3vel</code> and
<code>4vel</code>. 
</p>
<p>Function <code>threevel()</code> is a convenience wrapper for <code>3vel()</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
U &lt;- r4vel(7)
as.4vel(as.3vel(U)) # equal to U, to numerical precision

x &lt;- as.3vel(1:3/4)
u &lt;- as.3vel(matrix(runif(30)/10,ncol=3))

names(u) &lt;- letters[1:10]

x+u
u+x  # not equal



</code></pre>

<hr>
<h2 id='transform'>The energy-momentum tensor</h2><span id='topic+transform'></span><span id='topic+transform_dd'></span><span id='topic+transform_ud'></span><span id='topic+transform_uu'></span><span id='topic+raise'></span><span id='topic+lower'></span><span id='topic+perfectfluid'></span><span id='topic+dust'></span><span id='topic+photongas'></span><span id='topic+SET'></span><span id='topic+stress'></span><span id='topic+stress-energy'></span><span id='topic+stress-energy-tensor'></span><span id='topic+energy-momentum'></span><span id='topic+energy-momentum-tensor'></span>

<h3>Description</h3>

<p>Various functionality to deal with the stress-energy tensor
in special relativity.</p>


<h3>Usage</h3>

<pre><code class='language-R'>perfectfluid(rho,p,u=0)
dust(rho,u=0)
photongas(rho,u=0)
transform_dd(TT, B)
transform_ud(TT, B)
transform_uu(TT, B)
raise(TT)
lower(TT)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_+3A_tt">TT</code></td>
<td>
<p>A second-rank tensor with indices either
downstairs-downstairs, downstairs-upstairs, or upstairs-upstairs</p>
</td></tr>
<tr><td><code id="transform_+3A_b">B</code></td>
<td>
<p>A boost matrix</p>
</td></tr>
<tr><td><code id="transform_+3A_rho">rho</code>, <code id="transform_+3A_p">p</code>, <code id="transform_+3A_u">u</code></td>
<td>
<p>Density, pressure, and four-velocity of the dust</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>perfectfluid()</code> returns the stress-energy tensor, with
two upstairs indices, for a perfect fluid with the conditions
specified.  No checking for physical reasonableness (eg the weak
energy condition) is performed: caveat emptor!
</p>
<p>Function <code>dust()</code> is a (trivial) function that returns the
stress-energy tensor of a zero-pressure perfect fluid (that is, dust).
Function <code>photongas()</code> returns the stress-energy tensor of a
photon gas.  They are here for discoverability reasons; both are
special cases of a perfect fluid.
</p>
<p>Functions <code>transform_dd()</code> et seq transform a second-rank tensor
using the Lorentz transform.  The letters &ldquo;u&rdquo; or &ldquo;d&rdquo;
denote the indices of the tensor being upstairs (contravariant) or
downstairs (covariant).  The stress-energy tensor is usually written
with two upstairs indices, so use <code>transform_uu()</code> to transform
it.
</p>
<p>Function <code>lower()</code> lowers both indices of a tensor with two
upstairs indices.  Function <code>raise()</code> raises two downstairs
indices.  These two functions have identical <span class="rlang"><b>R</b></span> idiom but do not return
identical values if <code class="reqn">c\neq 1</code>.
</p>


<h3>Author(s)</h3>

<p>Robin K. S. Hankin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
perfectfluid(10,1)

u &lt;- as.3vel(c(0.4,0.4,0.2))

## In the following, LHS is stationary dust and RHS is dust moving at
## velocity 'u', but transformed to a frame also moving at velocity 'u':

LHS &lt;- dust(1)
RHS &lt;- transform_uu(dust(1,u),boost(u))
max(abs(LHS-RHS))  # should be small


## In the following, negative sign needed because active/passive
## difference:

LHS &lt;- dust(1,u)
RHS &lt;- transform_uu(dust(1),boost(-u))
max(abs(LHS-RHS))  # should be small

## Now test behaviour when  c!=1:


sol(299792458)
perfectfluid(1.225,101325) # air at STP

LHS &lt;- transform_uu(perfectfluid(1.225,101325),boost(as.3vel(c(1000,0,0))))
RHS &lt;- perfectfluid(1.225,101325) 
LHS-RHS  # should be small

sol(10)
u &lt;- as.3vel(4:6)
LHS &lt;- photongas(1,u)
RHS &lt;- transform_uu(photongas(1),boost(-u))
LHS-RHS # should be small



B1 &lt;- boost(r3vel(1)) %*% boost(r3vel(1))
B2 &lt;- boost(r3vel(1)) %*% boost(r3vel(1))
LHS &lt;- transform_uu(transform_uu(dust(1),B1),B2)
RHS &lt;- transform_uu(dust(1),B2 %*% B1)   # note order
LHS-RHS  # should be small


## remember to re-set c:
sol(1)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
