<!DOCTYPE html><html><head><title>Help for package NMdata</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NMdata}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addTAPD'><p>Add time since previous dose to data, time of previous dose, most</p>
recent dose amount, cumulative number of doses, and cumulative
dose amount.</a></li>
<li><a href='#cc'><p>Create character vectors without quotation marks</p></a></li>
<li><a href='#checkColRow'><p>check that col.row is not edited in Nonmem control stream</p></a></li>
<li><a href='#cl'><p>Define a vector with factor levels in the same order as occurring in the vector.</p></a></li>
<li><a href='#colLabels'><p>Extract column labels as defined in SAS</p></a></li>
<li><a href='#compareCols'><p>Compare elements in lists with aim of combining</p></a></li>
<li><a href='#deprecatedArg'><p>Report if an argument is deprecated.</p></a></li>
<li><a href='#dims'><p>Get dimensions of multiple objects</p></a></li>
<li><a href='#editCharCols'><p>Replace strings in character character columns of a data set</p></a></li>
<li><a href='#egdt'><p>Expand grid of data.tables</p></a></li>
<li><a href='#filePathSimple'><p>Clean and standardize file system paths</p></a></li>
<li><a href='#findCovs'><p>Extract columns that vary within values of other columns</p></a></li>
<li><a href='#findVars'><p>Extract columns that vary within values of other columns in a data.frame</p></a></li>
<li><a href='#flagsAssign'><p>Assign exclusion flags to a dataset based on specified table</p></a></li>
<li><a href='#flagsCount'><p>Create an overview of number of retained and discarded datapoints.</p></a></li>
<li><a href='#fnAppend'><p>paste something before file name extension.</p></a></li>
<li><a href='#fnExtension'><p>Change file name extension</p></a></li>
<li><a href='#getArgs'><p>Get provided arguments as a named list</p></a></li>
<li><a href='#getFilePaths'><p>Internal interpretation of file specification options</p></a></li>
<li><a href='#is.NMdata'><p>Check if an object is 'NMdata'</p></a></li>
<li><a href='#listMissings'><p>List rows with missing values across multiple columns</p></a></li>
<li><a href='#lstExtractTime'><p>Extract run time from output control stream</p></a></li>
<li><a href='#mergeCheck'><p>Merge, order, and check resulting rows and columns.</p></a></li>
<li><a href='#messageWrap'><p>Pretty wrapping of lines in NMdata vignettes</p></a></li>
<li><a href='#NMapplyFilters'><p>Translate filters in Nonmem and apply to data</p></a></li>
<li><a href='#NMcheckColnames'><p>Compare $INPUT in control stream to column names in input data</p></a></li>
<li><a href='#NMcheckData'><p>Check data for Nonmem compatibility or check control stream for</p>
data compatibility</a></li>
<li><a href='#NMcheckDataFile'><p>check input data based on control stream</p></a></li>
<li><a href='#NMcode2R'><p>Translate Nonmem $PK, $PRED sections or other Nonmem code to R code</p></a></li>
<li><a href='#NMdataConf'><p>Configure default behavior of NMdata functions</p></a></li>
<li><a href='#NMdataConfOptions'><p>Get NMdataConf parameter properties</p></a></li>
<li><a href='#NMdataDecideOption'><p>Determine active parameter value based on argument and NMdataConf setting</p></a></li>
<li><a href='#NMdataGetOption'><p>Look up default configuration of an argument</p></a></li>
<li><a href='#NMdataOperations'><p>Basic arithmetic on NMdata objects</p></a></li>
<li><a href='#NMexpandDoses'><p>Transform repeated dosing events (ADDL/II) to individual dosing events</p></a></li>
<li><a href='#NMextractDataFile'><p>Extract the data file used in a control stream</p></a></li>
<li><a href='#NMextractText'><p>Versatile text extractor from Nonmem (input or output) control streams</p></a></li>
<li><a href='#NMgenText'><p>Generate text for INPUT and possibly DATA sections of NONMEM</p>
control streams.</a></li>
<li><a href='#NMinfo'><p>Get metadata from an NMdata object</p></a></li>
<li><a href='#NMisNumeric'><p>Test if a variable can be interpreted by Nonmem</p></a></li>
<li><a href='#NMorderColumns'><p>Standardize column order in Nonmem input data</p></a></li>
<li><a href='#NMreadCov'><p>Read in data file</p></a></li>
<li><a href='#NMreadCsv'><p>Read input data formatted for Nonmem</p></a></li>
<li><a href='#NMreadExt'><p>Read information from Nonmem ext files</p></a></li>
<li><a href='#NMreadParsText'><p>Read comments to parameter definitions in Nonmem control streams</p></a></li>
<li><a href='#NMreadPhi'><p>Read information from Nonmem phi files</p></a></li>
<li><a href='#NMreadSection'><p>Extract sections of Nonmem control streams</p></a></li>
<li><a href='#NMreadTab'><p>Read an output table file from Nonmem</p></a></li>
<li><a href='#NMreplaceDataFile'><p>Replace data file used in Nonmem control stream</p></a></li>
<li><a href='#NMscanData'><p>Automatically find Nonmem input and output tables and organize data</p></a></li>
<li><a href='#NMscanInput'><p>Find and read input data and optionally translate column names</p>
according to the $INPUT section</a></li>
<li><a href='#NMscanMultiple'><p>Run NMscanData on multiple models and stack results</p></a></li>
<li><a href='#NMscanTables'><p>Find and read all output data tables in Nonmem run</p></a></li>
<li><a href='#NMstamp'><p>stamp a dataset or any other object</p></a></li>
<li><a href='#NMtransInp'><p>translate the column names according to the $INPUT section of a control stream</p></a></li>
<li><a href='#NMwriteData'><p>Write dataset for use in Nonmem (and R)</p></a></li>
<li><a href='#NMwriteSection'><p>Replace ($)sections of a Nonmem control stream</p></a></li>
<li><a href='#print.summary_NMdata'><p>print method for NMdata summaries</p></a></li>
<li><a href='#reduceTables'><p>reduce tables from NMscanTables to fewer objects</p></a></li>
<li><a href='#renameByContents'><p>Rename columns matching properties of data contents</p></a></li>
<li><a href='#searchColRow'><p>Check row identifier in a model for necessary properties.</p></a></li>
<li><a href='#summary.NMdata'><p>summary method for NMdata objects</p></a></li>
<li><a href='#tmpcol'><p>generate a name for a new data column that is not already in use.</p></a></li>
<li><a href='#unNMdata'><p>Remove NMdata class and discard NMdata meta data</p></a></li>
<li><a href='#writeNMinfo'><p>Do the actual writing of meta data</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Preparation, Checking and Post-Processing Data for PK/PD
Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philip Delff &lt;philip@delff.dk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient tools for preparation, checking and post-processing of data in PK/PD (pharmacokinetics/pharmacodynamics) modeling, with focus on use of Nonmem. Attention is paid to ensure consistency, traceability, and Nonmem compatibility of Data. Rigorously checks final Nonmem datasets. Implemented in 'data.table', but easily integrated with 'base' and 'tidyverse'.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, fst</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, formatR, mime, rmarkdown, ggplot2, tibble,
covr, htmltools, spelling</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://philipdelff.github.io/NMdata/">https://philipdelff.github.io/NMdata/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/philipdelff/NMdata/issues">https://github.com/philipdelff/NMdata/issues</a></td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-21 02:27:56 UTC; philipde</td>
</tr>
<tr>
<td>Author:</td>
<td>Philip Delff [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-21 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='addTAPD'>Add time since previous dose to data, time of previous dose, most
recent dose amount, cumulative number of doses, and cumulative
dose amount.</h2><span id='topic+addTAPD'></span>

<h3>Description</h3>

<p>For now, doses have to be in data as EVID=1 and/or EVID=4
records. They can be in the format of one row per dose or repeated
dosing notation using ADDL and II.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addTAPD(
  data,
  col.time = "TIME",
  col.evid = "EVID",
  col.amt = "AMT",
  col.tpdos = "TPDOS",
  col.tapd = "TAPD",
  col.pdosamt = "PDOSAMT",
  col.doscuma = "DOSCUMA",
  col.doscumn = "DOSCUMN",
  prefix.cols,
  suffix.cols,
  subset.dos,
  subset.is.complete,
  order.evid = c(3, 0, 2, 4, 1),
  by = "ID",
  SDOS = 1,
  as.fun,
  col.ndoses
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addTAPD_+3A_data">data</code></td>
<td>
<p>The data set to add the variables to.</p>
</td></tr>
<tr><td><code id="addTAPD_+3A_col.time">col.time</code></td>
<td>
<p>Name of time column (created by addTAPD). Default
it TIME.</p>
</td></tr>
<tr><td><code id="addTAPD_+3A_col.evid">col.evid</code></td>
<td>
<p>The name of the event ID column. This must exist
in data. Default is EVID.</p>
</td></tr>
<tr><td><code id="addTAPD_+3A_col.amt">col.amt</code></td>
<td>
<p>col.evid The name of the dose amount column. This
must exist in data. Default is AMT.</p>
</td></tr>
<tr><td><code id="addTAPD_+3A_col.tpdos">col.tpdos</code></td>
<td>
<p>Name of the time of previous dose column (created
by addTAPD). Default is TPDOS. Set to NULL to not create this
column.</p>
</td></tr>
<tr><td><code id="addTAPD_+3A_col.tapd">col.tapd</code></td>
<td>
<p>Name of the time of previous dose column (created
by addTAPD). Default is TAPD. Set to NULL to not create this
column.</p>
</td></tr>
<tr><td><code id="addTAPD_+3A_col.pdosamt">col.pdosamt</code></td>
<td>
<p>The name of the column to be created holding
the previous dose amount. Set to NULL to not create this
column.</p>
</td></tr>
<tr><td><code id="addTAPD_+3A_col.doscuma">col.doscuma</code></td>
<td>
<p>The name of the column to be created holding
the cumulative dose amount. Set to NULL to not create this
column.</p>
</td></tr>
<tr><td><code id="addTAPD_+3A_col.doscumn">col.doscumn</code></td>
<td>
<p>The name of the column (created by addTAPD) that
holds the cumulative number of doses administered to the
subject. Set to NULL to not create this column.</p>
</td></tr>
<tr><td><code id="addTAPD_+3A_prefix.cols">prefix.cols</code></td>
<td>
<p>String to be prepended to all generated column
names, that is each of col.tpdos, col.tapd, col.ndoses,
col.pdosamt, col.doscuma that are not NULL.</p>
</td></tr>
<tr><td><code id="addTAPD_+3A_suffix.cols">suffix.cols</code></td>
<td>
<p>String to be appended to all generated column
names, that is each of col.tpdos, col.tapd, col.ndoses,
col.pdosamt, col.doscuma that are not NULL.</p>
</td></tr>
<tr><td><code id="addTAPD_+3A_subset.dos">subset.dos</code></td>
<td>
<p>A string that will be evaluated as a custom
expression to identify relevant events. See subset.is.complete
as well.</p>
</td></tr>
<tr><td><code id="addTAPD_+3A_subset.is.complete">subset.is.complete</code></td>
<td>
<p>Only used in combination with
non-missing subset.dos. By default, subset.dos is used in
addition to the impact of col.evid (must be 1 or 4) and col.amt (greater than zero). If
subset.is.complete=TRUE, subset.dos is used alone, and
col.evid and col.amt are completely ignored. This is typically
useful if the events are not doses but other events that are
not expressed as a typical dose combination of EVID and AMT
columns.</p>
</td></tr>
<tr><td><code id="addTAPD_+3A_order.evid">order.evid</code></td>
<td>
<p>Order of events. This will only matter if there
are simultaneous events of different event types within
subjects. Typically if using nominal time, it may be important
to specify whether samples at dosing times are pre-dose
samples. The default is c(3,0,4,1,2) - i.e. samples and
simulations are pre-dose. See details.</p>
</td></tr>
<tr><td><code id="addTAPD_+3A_by">by</code></td>
<td>
<p>Columns to do calculations within. Default is ID.</p>
</td></tr>
<tr><td><code id="addTAPD_+3A_sdos">SDOS</code></td>
<td>
<p>Scaling value for columns related to dose amount,
relative to AMT values. col.pdosamt and col.doscuma are
affected and will be derived as AMT/SDOSE.</p>
</td></tr>
<tr><td><code id="addTAPD_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say tibble::as_tibble) in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="addTAPD_+3A_col.ndoses">col.ndoses</code></td>
<td>
<p>Deprecated. Use col.doscumn instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>addTAPD does not require the data to be ordered, and it
will not order it. This means you can run addTAPD before
ordering data (which may be one of the final steps) in data
set preparation. The argument called order.evid is important
because of this. If a dosing event and a sample occur at the
same time, when which dose was the previous for that sample?
Default is to assume the sample is a pre-dose sample, and
hence output will be calculated in relation to the dose
before. If no dose event is found before, NA's will be
assigned.
</p>


<h3>Value</h3>

<p>A data.frame with additional columns
</p>


<h3>See Also</h3>

<p>Other DataCreate: 
<code><a href="#topic+NMorderColumns">NMorderColumns</a>()</code>,
<code><a href="#topic+NMstamp">NMstamp</a>()</code>,
<code><a href="#topic+NMwriteData">NMwriteData</a>()</code>,
<code><a href="#topic+findCovs">findCovs</a>()</code>,
<code><a href="#topic+findVars">findVars</a>()</code>,
<code><a href="#topic+flagsAssign">flagsAssign</a>()</code>,
<code><a href="#topic+flagsCount">flagsCount</a>()</code>,
<code><a href="#topic+mergeCheck">mergeCheck</a>()</code>,
<code><a href="#topic+tmpcol">tmpcol</a>()</code>
</p>

<hr>
<h2 id='cc'>Create character vectors without quotation marks</h2><span id='topic+cc'></span>

<h3>Description</h3>

<p>When creating character vectors with several elements, it becomes
a lot of quotes to type. cc provides a simple way to skip the
quotes - but only for simple strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc_+3A_...">...</code></td>
<td>
<p>The unquoted names that will become character values in
the returned vector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Don't use cc with any special characters - only
alphanumerics and no spaces supported. Also, remember that
numerics are converted using as.character. Eg, this means that
leading zeros are dropped.
</p>


<h3>Value</h3>

<p>A character vector
</p>


<h3>See Also</h3>

<p>cl
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cc(a,b,`a b`)
cc(a,b,"a b")
## be careful with spaces and special characters
cc( d)
cc(" d")
cc()
## Numerics are converted using as.character
cc(001,1,13e3)
</code></pre>

<hr>
<h2 id='checkColRow'>check that col.row is not edited in Nonmem control stream</h2><span id='topic+checkColRow'></span>

<h3>Description</h3>

<p>In order to safely merge by a unique row identifier,
that row identifier must not be edited from input to
output. checkColRow helps checking that based on the control
stream.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkColRow(col.row, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkColRow_+3A_col.row">col.row</code></td>
<td>
<p>The name of the unique row identifier (say &quot;ROW&quot;).</p>
</td></tr>
<tr><td><code id="checkColRow_+3A_file">file</code></td>
<td>
<p>a list file or input control stream file path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if no issues found
</p>

<hr>
<h2 id='cl'>Define a vector with factor levels in the same order as occurring in the vector.</h2><span id='topic+cl'></span>

<h3>Description</h3>

<p>This is a shortcut for creating factors with levels as the order
of appearance of the specified levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cl(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cl_+3A_...">...</code></td>
<td>
<p>unique elements or vectors with unique elements</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor (vector)
</p>


<h3>See Also</h3>

<p>cc
</p>


<h3>Examples</h3>

<pre><code class='language-R'>factor("b","a")
cl("b","a")
x &lt;- c("b","a")
factor(x)
cl(x)
</code></pre>

<hr>
<h2 id='colLabels'>Extract column labels as defined in SAS</h2><span id='topic+colLabels'></span>

<h3>Description</h3>

<p>Extract column labels as defined in SAS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colLabels(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colLabels_+3A_...">...</code></td>
<td>
<p>See '?compareCols'</p>
</td></tr>
</table>

<hr>
<h2 id='compareCols'>Compare elements in lists with aim of combining</h2><span id='topic+compareCols'></span>

<h3>Description</h3>

<p>Useful interactive tool when merging or binding objects
together. It lists the names of elements that differ in presence
or class across multiple datasets. Before running rbind, you may want
to check the compatibility of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareCols(
  ...,
  list.data,
  keep.names = TRUE,
  test.equal = FALSE,
  diff.only = TRUE,
  cols.wanted,
  fun.class = base::class,
  quiet,
  as.fun,
  keepNames,
  testEqual
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareCols_+3A_...">...</code></td>
<td>
<p>objects which element names to compare</p>
</td></tr>
<tr><td><code id="compareCols_+3A_list.data">list.data</code></td>
<td>
<p>As alternative to ..., you can supply the data
sets in a list here.</p>
</td></tr>
<tr><td><code id="compareCols_+3A_keep.names">keep.names</code></td>
<td>
<p>If TRUE, the original dataset names are used in
reported table. If not, generic x1, x2,... are used. The
latter may be preferred for readability.</p>
</td></tr>
<tr><td><code id="compareCols_+3A_test.equal">test.equal</code></td>
<td>
<p>Do you just want a TRUE/FALSE to whether the
names of the two objects are the same? Default is FALSE which
means to return an overview for interactive use. You might
want to use TRUE in programming. However, notice that this
check may be overly rigorous. Many classes are compatible
enough (say numeric and integer), and compareCols doesn't take
this into account.</p>
</td></tr>
<tr><td><code id="compareCols_+3A_diff.only">diff.only</code></td>
<td>
<p>If TRUE, don't report columns where no difference
found. Default is TRUE if number of data sets supplied is
greater than one. If only one data set is supplied, the full
list of columns is shown by default.</p>
</td></tr>
<tr><td><code id="compareCols_+3A_cols.wanted">cols.wanted</code></td>
<td>
<p>Columns of special interest. These will always
be included in overview and indicated by a prepended * to the
column names. This argument is often useful when you start by
defining a set of columns that you want to end up with by
combining a number of data sets.</p>
</td></tr>
<tr><td><code id="compareCols_+3A_fun.class">fun.class</code></td>
<td>
<p>the function that will be run on each column to
check for differences. base::class is default. Notice that the
alternative base::typeof is different in certain ways. For
instance, typeof will not report a difference on numeric vs
difftime. You could basically submit any function that takes a
vector and returns a single value.</p>
</td></tr>
<tr><td><code id="compareCols_+3A_quiet">quiet</code></td>
<td>
<p>The default is to give some information along the way
on what data is found. But consider setting this to TRUE for
non-interactive use. Default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="compareCols_+3A_as.fun">as.fun</code></td>
<td>
<p>A function that will be run on the result before
returning. If first input data set is a data.table, the
default is to return a data.table, if not the default is to
return a data.frame. Use whatever to get what fits in with
your workflow. Default can be configured with NMdataConf.</p>
</td></tr>
<tr><td><code id="compareCols_+3A_keepnames">keepNames</code></td>
<td>
<p>Deprecated. Use keep.names instead.</p>
</td></tr>
<tr><td><code id="compareCols_+3A_testequal">testEqual</code></td>
<td>
<p>Deprecated. Use test.equal instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>technically, this function compares classes of elements
in lists. However, in relation to NMdata, this will most of
the time be columns in data.frames.
</p>
<p>Despite the name of the argument fun.class, it can be any function
to be evaluated on each element in '...'. See examples for how to
extract SAS labels on an object read with 'read_sas' from the
'haven' package.
</p>


<h3>Value</h3>

<p>A data.frame with an overview of elements and their
classes of objects in ... Class as defined by as.fun.
</p>


<h3>See Also</h3>

<p>Other DataWrangling: 
<code><a href="#topic+dims">dims</a>()</code>,
<code><a href="#topic+listMissings">listMissings</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## get SAS labels from objects read with haven::read_sas
## Not run: 
compareCols(...,fun.class=function(x)attributes(x)$label)

## End(Not run)


</code></pre>

<hr>
<h2 id='deprecatedArg'>Report if an argument is deprecated.</h2><span id='topic+deprecatedArg'></span>

<h3>Description</h3>

<p>Only supposed to be called from within a function. For now only
works for arguments that have been replaced by others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deprecatedArg(oldarg, newarg, args, msg = NULL, which = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deprecatedArg_+3A_oldarg">oldarg</code></td>
<td>
<p>The deprecated argument name (a character string).</p>
</td></tr>
<tr><td><code id="deprecatedArg_+3A_newarg">newarg</code></td>
<td>
<p>The non-deprecated argument name (a character
string).</p>
</td></tr>
<tr><td><code id="deprecatedArg_+3A_args">args</code></td>
<td>
<p>List of arguments in the function call to look for
oldarg and newarg. See '?getArgs'. If missing, 'getArgs()'
will be called from within 'deprecatedArg'. See 'which' too.</p>
</td></tr>
<tr><td><code id="deprecatedArg_+3A_which">which</code></td>
<td>
<p>If calling 'getArgs' this is passed along, referring
to how many environments to jump to look at arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The coalesced value of arguments
</p>


<h3>See Also</h3>

<p>Other arguments: 
<code><a href="#topic+getArgs">getArgs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   fun1 &lt;- function(a=1,b=2){
       ## b is deprecated
       a &lt;- deprecatedArg("b","a")
       a
   }

   expect_error(
       fun1(a=1,b=2)
   )
   expect_message(
       fun1(b=2)
   )

## End(Not run)
</code></pre>

<hr>
<h2 id='dims'>Get dimensions of multiple objects</h2><span id='topic+dims'></span>

<h3>Description</h3>

<p>Get dimensions of multiple objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dims(..., list.data, keep.names = TRUE, as.fun = NULL, keepNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dims_+3A_...">...</code></td>
<td>
<p>data sets</p>
</td></tr>
<tr><td><code id="dims_+3A_list.data">list.data</code></td>
<td>
<p>As alternative to ..., you can supply the data
sets in a list here.</p>
</td></tr>
<tr><td><code id="dims_+3A_keep.names">keep.names</code></td>
<td>
<p>If TRUE, the original dataset names are used in
reported table. If not, generic x1, x2,... are used. The
latter may be preferred for readability in some cases.</p>
</td></tr>
<tr><td><code id="dims_+3A_as.fun">as.fun</code></td>
<td>
<p>A function that will be run on the result before
returning. If first input data set is a data.table, the
default is to return a data.table, if not the default is to
return a data.frame. Use whatever to get what fits in with
your workflow. Default can be configured with NMdataConf.</p>
</td></tr>
<tr><td><code id="dims_+3A_keepnames">keepNames</code></td>
<td>
<p>Deprecated. Use keep.names instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with dimensions of objects in ... Actual
class defined by as.fun.
</p>


<h3>See Also</h3>

<p>Other DataWrangling: 
<code><a href="#topic+compareCols">compareCols</a>()</code>,
<code><a href="#topic+listMissings">listMissings</a>()</code>
</p>

<hr>
<h2 id='editCharCols'>Replace strings in character character columns of a data set</h2><span id='topic+editCharCols'></span>

<h3>Description</h3>

<p>Replace strings in character character columns of a data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>editCharCols(data, pattern, replacement, as.fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="editCharCols_+3A_data">data</code></td>
<td>
<p>The data set to edit.</p>
</td></tr>
<tr><td><code id="editCharCols_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to search for in character columns. Passed
to 'gsub()'. By default, 'gsub()' works with regular
expressions. See ... for how to disable this if you want to
replace a specific string.</p>
</td></tr>
<tr><td><code id="editCharCols_+3A_replacement">replacement</code></td>
<td>
<p>pattern or string to replace with. Passed to
'gsub()'.</p>
</td></tr>
<tr><td><code id="editCharCols_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say tibble::as_tibble) in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="editCharCols_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to 'gsub()'. Especially,
notice fixed=TRUE will disable interpretation of 'pattern' and
'replace' as regular expressions.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>### remove commas from character columns 
dat &lt;- data.frame(A=1:3,text=cc(a,"a,d","g"))
editCharCols(dat,pattern=",","")
### factors are not edited but result in an error
## Not run: 
dat &lt;- data.frame(A=1:3,text=cc(a,"a,d",g),fac=cl("a","a,d","g"))
editCharCols(dat,pattern=",","")

## End(Not run)

</code></pre>

<hr>
<h2 id='egdt'>Expand grid of data.tables</h2><span id='topic+egdt'></span>

<h3>Description</h3>

<p>Expand grid of data.tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>egdt(dt1, dt2, quiet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="egdt_+3A_dt1">dt1</code></td>
<td>
<p>a data.table.</p>
</td></tr>
<tr><td><code id="egdt_+3A_dt2">dt2</code></td>
<td>
<p>another data.table.</p>
</td></tr>
<tr><td><code id="egdt_+3A_quiet">quiet</code></td>
<td>
<p>The default is to give some information along the way
on what data is found. But consider setting this to TRUE for
non-interactive use. Default can be configured using
NMdataConf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Merging works mostly similarly for data.table and
data.table. However, for data.table the merge must be done by
one or more columns. This means that the convenient way to
expand all combinations of all rows in two data.frames is not
available for data.tables. This functions provides that
functionality. It always returns data.tables.
</p>


<h3>Value</h3>

<p>a data.table that expands combinations of rows in dt1 and
dt2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df1 &lt;- data.frame(a=1:2,b=3:4)
df2 &lt;- data.frame(c=5:6,d=7:8)
merge(df1,df2)
library(data.table)
## This is not possible
## Not run: 
merge(as.data.table(df1),as.data.table(df2),allow.cartesian=TRUE)

## End(Not run)
## Use egdt instead
egdt(as.data.table(df1),as.data.table(df2),quiet=TRUE)
## Dimensions are conveniently listed for interactive use
res &lt;- egdt(as.data.table(df1),as.data.table(df2))
</code></pre>

<hr>
<h2 id='filePathSimple'>Clean and standardize file system paths</h2><span id='topic+filePathSimple'></span>

<h3>Description</h3>

<p>Use this to tidy up paths. Combines pieces of a path like
file.path(). The function is intended to return a canonical
path format, i.e. paths that can be compared by simple string
comparison. Redundant /'s removed. normalizePath is used to
possibly shorten path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filePathSimple(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filePathSimple_+3A_...">...</code></td>
<td>
<p>additional arguments passed to file.path().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A (character) file path
</p>

<hr>
<h2 id='findCovs'>Extract columns that vary within values of other columns</h2><span id='topic+findCovs'></span>

<h3>Description</h3>

<p>This function provides an automated method to extract covariate-like
columns. The user decides which columns these variables cannot vary
within. So if you have repeated measures for each ID, this function can find
the columns that are constant within ID and their unique values for each
ID. Or, you can provide a combination of id.cols, say ID and STUDY, and get
variables that do not vary within unique combinations of these.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findCovs(data, by = NULL, cols.id, as.fun = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findCovs_+3A_data">data</code></td>
<td>
<p>data.frame in which to look for covariates</p>
</td></tr>
<tr><td><code id="findCovs_+3A_by">by</code></td>
<td>
<p>covariates will be searched for in combinations of values in
these columns. Often by will be either empty or ID. But it can also
be both say c(&quot;ID&quot;,&quot;DRUG&quot;) or c(&quot;ID&quot;,&quot;TRT&quot;).</p>
</td></tr>
<tr><td><code id="findCovs_+3A_cols.id">cols.id</code></td>
<td>
<p>Deprecated. Use by instead.</p>
</td></tr>
<tr><td><code id="findCovs_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return a data.table if data is a data.table
and return a data.frame in all other cases. Pass a function in as.fun to
convert to something else. If data is not a data.table, the default can
be configured using NMdataConf.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data set with one observation per combination of values of
variables listed in by.
</p>


<h3>See Also</h3>

<p>Other DataCreate: 
<code><a href="#topic+NMorderColumns">NMorderColumns</a>()</code>,
<code><a href="#topic+NMstamp">NMstamp</a>()</code>,
<code><a href="#topic+NMwriteData">NMwriteData</a>()</code>,
<code><a href="#topic+addTAPD">addTAPD</a>()</code>,
<code><a href="#topic+findVars">findVars</a>()</code>,
<code><a href="#topic+flagsAssign">flagsAssign</a>()</code>,
<code><a href="#topic+flagsCount">flagsCount</a>()</code>,
<code><a href="#topic+mergeCheck">mergeCheck</a>()</code>,
<code><a href="#topic+tmpcol">tmpcol</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt1=data.frame(ID=c(1,1,2,2),
               OCC=c(1,2,1,2),
               ## ID level
               eta1=c(1,1,3,3),
               ## occasion level
               eta2=c(1,3,1,5),
               ## not used
               eta3=0
               )
## model level
findCovs(dt1)
## ID level
findCovs(dt1,"ID")
## acual ID level
findVars(findCovs(dt1,"ID"))
## occasion level
findCovs(findVars(dt1,"ID"),c("ID","OCC"))
## Based on a "real data example"
## Not run: 
dat &lt;- NMscanData(system.file("examples/nonmem/xgxr001.lst", package = "NMdata"))
findCovs(dat,by="ID")
### Without an ID column we get non-varying columns
findCovs(dat)

## End(Not run)
</code></pre>

<hr>
<h2 id='findVars'>Extract columns that vary within values of other columns in a data.frame</h2><span id='topic+findVars'></span>

<h3>Description</h3>

<p>If you want to look at the variability of a number of columns and you want
to disregard those that are constant. Like for findCovs, by can be of
arbitrary length.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findVars(data, by = NULL, cols.id, as.fun = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findVars_+3A_data">data</code></td>
<td>
<p>data.frame in which to look for covariates</p>
</td></tr>
<tr><td><code id="findVars_+3A_by">by</code></td>
<td>
<p>optional covariates will be searched for in combinations of
values in these columns. Often by will be either empty or ID. But
it can also be both say c(&quot;ID&quot;,&quot;DRUG&quot;) or c(&quot;ID&quot;,&quot;TRT&quot;).</p>
</td></tr>
<tr><td><code id="findVars_+3A_cols.id">cols.id</code></td>
<td>
<p>Deprecated. Use by instead.</p>
</td></tr>
<tr><td><code id="findVars_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return a data.table if data is a data.table
and return a data.frame in all other cases. Pass a function in as.fun to
convert to something else. If data is not a data.table, the default can
be configured using NMdataConf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this to exclude columns that are constant within by. If
by=ID, this could be to get only time-varying covariates.
</p>


<h3>Value</h3>

<p>a data set with as many rows as in data.
</p>


<h3>See Also</h3>

<p>Other DataCreate: 
<code><a href="#topic+NMorderColumns">NMorderColumns</a>()</code>,
<code><a href="#topic+NMstamp">NMstamp</a>()</code>,
<code><a href="#topic+NMwriteData">NMwriteData</a>()</code>,
<code><a href="#topic+addTAPD">addTAPD</a>()</code>,
<code><a href="#topic+findCovs">findCovs</a>()</code>,
<code><a href="#topic+flagsAssign">flagsAssign</a>()</code>,
<code><a href="#topic+flagsCount">flagsCount</a>()</code>,
<code><a href="#topic+mergeCheck">mergeCheck</a>()</code>,
<code><a href="#topic+tmpcol">tmpcol</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dt1 &lt;- data.frame(ID=c(1,1,2,2),
                  OCC=c(1,2,1,2),
               ## ID level
                  eta1=c(1,1,3,3),
               ## occasion level
                  eta2=c(1,3,1,5),
               ## not used
                  eta3=0
               )
## model level
findCovs(dt1)
## ID level
findCovs(dt1,"ID")
## acual ID level
findVars(findCovs(dt1,"ID"))
## occasion level
findCovs(findVars(dt1,"ID"),c("ID","OCC"))
</code></pre>

<hr>
<h2 id='flagsAssign'>Assign exclusion flags to a dataset based on specified table</h2><span id='topic+flagsAssign'></span>

<h3>Description</h3>

<p>The aim with this function is to take a (say PK) dataset and a
pre-specified table of flags, assign the flags automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flagsAssign(
  data,
  tab.flags,
  subset.data,
  col.flagn,
  col.flagc,
  flags.increasing = FALSE,
  grp.incomp = "EVID",
  flagc.0 = "Analysis set",
  as.fun = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flagsAssign_+3A_data">data</code></td>
<td>
<p>The dataset to assign flags to.</p>
</td></tr>
<tr><td><code id="flagsAssign_+3A_tab.flags">tab.flags</code></td>
<td>
<p>A data.frame containing at least these named
columns: FLAG, flag, condition. Condition is disregarded for
FLAG==0. FLAG must be numeric and non-negative, flag and
condition are characters.</p>
</td></tr>
<tr><td><code id="flagsAssign_+3A_subset.data">subset.data</code></td>
<td>
<p>An optional string that provides a subset of
data to assign flags to. A common example is
subset=\&quot;EVID==0\&quot; to only assign to observations. Numerical
and character flags will be missing in rows that are not
matched by this subset.</p>
</td></tr>
<tr><td><code id="flagsAssign_+3A_col.flagn">col.flagn</code></td>
<td>
<p>The name of the column containing the numerical
flag values in tab.flags. This will be added to data. Default
value is FLAG and can be configured using NMdataConf.</p>
</td></tr>
<tr><td><code id="flagsAssign_+3A_col.flagc">col.flagc</code></td>
<td>
<p>The name of the column containing the character
flag values in tab.flags. This will be added to data. Default
value is flag and can be configured using NMdataConf.</p>
</td></tr>
<tr><td><code id="flagsAssign_+3A_flags.increasing">flags.increasing</code></td>
<td>
<p>The flags are applied by either decreasing
(default) or increasing value of col.flagn. Decreasing order
means that conditions associated with higher values of
col.flagn will be evaluated first. By using decreasing order,
you can easily adjust the Nonmem IGNORE statement from
IGNORE(FLAG.NE.0) to say IGNORE(FLAG.GT.10) if BLQ's have
FLAG=10, and you decide to include these in the analysis.</p>
</td></tr>
<tr><td><code id="flagsAssign_+3A_grp.incomp">grp.incomp</code></td>
<td>
<p>Column(s) that distinct incompatible subsets of
data. Default is &quot;EVID&quot; meaning that if different values of
EVID are found in data, the function will return an
error. This is a safeguard not to mix data unintentionally
when counting flags.</p>
</td></tr>
<tr><td><code id="flagsAssign_+3A_flagc.0">flagc.0</code></td>
<td>
<p>The character flag to assign to rows that are not
matched by exclusion conditions (numerical flag 0).</p>
</td></tr>
<tr><td><code id="flagsAssign_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data.tables if input data
is a data.table, and return a data.frame for all other input
classes. Pass a function in as.fun to convert to something
else. If return.all=FALSE, this is applied to data and
tab.flags independently.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>dt.flags must contain a column with numerical exclusion
flags, one with character exclusion flags, and one with a
expressions to evaluate for whether to apply the exclusion
flag. The flags are applied sequentially, by increasing value
of the numerical exclusion flag.
</p>


<h3>Value</h3>

<p>The dataset with flags added. Class as defined by
as.fun. See parameter flags.return as well.
</p>


<h3>See Also</h3>

<p>Other DataCreate: 
<code><a href="#topic+NMorderColumns">NMorderColumns</a>()</code>,
<code><a href="#topic+NMstamp">NMstamp</a>()</code>,
<code><a href="#topic+NMwriteData">NMwriteData</a>()</code>,
<code><a href="#topic+addTAPD">addTAPD</a>()</code>,
<code><a href="#topic+findCovs">findCovs</a>()</code>,
<code><a href="#topic+findVars">findVars</a>()</code>,
<code><a href="#topic+flagsCount">flagsCount</a>()</code>,
<code><a href="#topic+mergeCheck">mergeCheck</a>()</code>,
<code><a href="#topic+tmpcol">tmpcol</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pk &lt;- readRDS(file=system.file("examples/data/xgxr2.rds",package="NMdata"))
dt.flags &lt;- data.frame(
       flagn=10,
       flagc="Below LLOQ",
       condition=c("BLQ==1")
)
pk &lt;- flagsAssign(pk,dt.flags,subset.data="EVID==0",col.flagn="flagn",col.flagc="flagc")
pk &lt;- flagsAssign(pk,subset.data="EVID==1",flagc.0="Dosing",
        col.flagn="flagn",col.flagc="flagc")
unique(pk[,c("EVID","flagn","flagc","BLQ")])
flagsCount(pk[EVID==0],dt.flags,col.flagn="flagn",col.flagc="flagc")

## End(Not run)
</code></pre>

<hr>
<h2 id='flagsCount'>Create an overview of number of retained and discarded datapoints.</h2><span id='topic+flagsCount'></span>

<h3>Description</h3>

<p>Generate an overview of number of observations disregarded due to
different reasons. And how many are left after each exclusion
flag.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flagsCount(
  data,
  tab.flags,
  file,
  col.id = "ID",
  col.flagn,
  col.flagc,
  by = NULL,
  flags.increasing = FALSE,
  flagc.0 = "Analysis set",
  name.all.data = "All available data",
  grp.incomp = "EVID",
  save = TRUE,
  as.fun = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flagsCount_+3A_data">data</code></td>
<td>
<p>The dataset including both FLAG and flag columns.</p>
</td></tr>
<tr><td><code id="flagsCount_+3A_tab.flags">tab.flags</code></td>
<td>
<p>A data.frame containing at least these named
columns: FLAG, flag, condition. Condition is disregarded for
FLAG==0.</p>
</td></tr>
<tr><td><code id="flagsCount_+3A_file">file</code></td>
<td>
<p>A file to write the table of flag counts to. Will
probably be removed and put in a separate function.</p>
</td></tr>
<tr><td><code id="flagsCount_+3A_col.id">col.id</code></td>
<td>
<p>The name of the subject ID column. Default is &quot;ID&quot;.</p>
</td></tr>
<tr><td><code id="flagsCount_+3A_col.flagn">col.flagn</code></td>
<td>
<p>The name of the column containing the numerical
flag values in tab.flags. This will be added to data. Use the
same as when flagsAssign was called (if that was
used). Default value is FLAG and can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="flagsCount_+3A_col.flagc">col.flagc</code></td>
<td>
<p>The name of the column containing the character
flag values in data and tab.flags. Use the same as when
flagsAssign was called (if that was used). Default value is
flag and can be configured using NMdataConf.</p>
</td></tr>
<tr><td><code id="flagsCount_+3A_by">by</code></td>
<td>
<p>An optional column to group the counting by. This could
be &quot;STUDY&quot;, &quot;DRUG&quot;, &quot;EVID&quot;, or a combination of multiple
columns.</p>
</td></tr>
<tr><td><code id="flagsCount_+3A_flags.increasing">flags.increasing</code></td>
<td>
<p>The flags are applied by either decreasing
(default) or increasing value of col.flagn. By using
decreasing order, you can easily adjust the Nonmem IGNORE
statement from IGNORE(FLAG.NE.0) to say IGNORE(FLAG.GT.10) if
BLQ's have FLAG=10, and you decide to include these in the
analysis.</p>
</td></tr>
<tr><td><code id="flagsCount_+3A_flagc.0">flagc.0</code></td>
<td>
<p>The character flag to assign to rows that are not
matched by exclusion conditions (numerical flag 0).</p>
</td></tr>
<tr><td><code id="flagsCount_+3A_name.all.data">name.all.data</code></td>
<td>
<p>What to call the total set of data before
applying exclusion flags. Default is &quot;All available data&quot;.</p>
</td></tr>
<tr><td><code id="flagsCount_+3A_grp.incomp">grp.incomp</code></td>
<td>
<p>Column(s) that distinct incompatible subsets of
data. Default is &quot;EVID&quot; meaning that if different values of
EVID are found in data, the function will return an
error. This is a safeguard not to mix data unintentionally
when counting flags.</p>
</td></tr>
<tr><td><code id="flagsCount_+3A_save">save</code></td>
<td>
<p>Save file? Default is TRUE, meaning that a file will
be written if file argument is supplied.</p>
</td></tr>
<tr><td><code id="flagsCount_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return a data.table if input data
is a data.table, and return a data.frame for all other input
classes. Pass a function in as.fun to convert to something
else. If data is not a data.table, default can be configured
using NMdataConf.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to count flags as assigned by the
flagsAssign function.
</p>
<p>Notice that the character flags reported in the output table are
taken from tab.flags. The data column named by the value of
col.flagc (default is flag) is not used.
</p>
<p>In the returned table, N.discarded is the difference in number of
subjects since previous step. If two is reported, it can mean
that the remaining one observation of these two subjects are
discarded due to this flag. The majority of the samples can
have been discarded by earlier flags.
</p>


<h3>Value</h3>

<p>A summary table with number of discarded and retained
subjects and observations when applying each condition in the
flag table. &quot;discarded&quot; means that the reduction of number of
observations and subjects resulting from the flag, &quot;retained&quot;
means the numbers that are left after application of the
flag. The default is &quot;both&quot; which will report both. Class as
defined by as.fun.
</p>


<h3>See Also</h3>

<p>Other DataCreate: 
<code><a href="#topic+NMorderColumns">NMorderColumns</a>()</code>,
<code><a href="#topic+NMstamp">NMstamp</a>()</code>,
<code><a href="#topic+NMwriteData">NMwriteData</a>()</code>,
<code><a href="#topic+addTAPD">addTAPD</a>()</code>,
<code><a href="#topic+findCovs">findCovs</a>()</code>,
<code><a href="#topic+findVars">findVars</a>()</code>,
<code><a href="#topic+flagsAssign">flagsAssign</a>()</code>,
<code><a href="#topic+mergeCheck">mergeCheck</a>()</code>,
<code><a href="#topic+tmpcol">tmpcol</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
pk &lt;- readRDS(file=system.file("examples/data/xgxr2.rds",package="NMdata"))
dt.flags &lt;- data.frame(
       flagn=10,
       flagc="Below LLOQ",
       condition=c("BLQ==1")
)
pk &lt;- flagsAssign(pk,dt.flags,subset.data="EVID==0",col.flagn="flagn",col.flagc="flagc")
pk &lt;- flagsAssign(pk,subset.data="EVID==1",flagc.0="Dosing",
        col.flagn="flagn",col.flagc="flagc")
unique(pk[,c("EVID","flagn","flagc","BLQ")])
flagsCount(pk[EVID==0],dt.flags,col.flagn="flagn",col.flagc="flagc")

## End(Not run)
</code></pre>

<hr>
<h2 id='fnAppend'>paste something before file name extension.</h2><span id='topic+fnAppend'></span>

<h3>Description</h3>

<p>Append a file name like file.mod to file_1.mod or file_pk.mod. If
it's a number, we can pad some zeros if wanted. The separator
(default is underscore) can be modified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fnAppend(fn, x, pad0 = 0, sep = "_")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fnAppend_+3A_fn">fn</code></td>
<td>
<p>The file name to modify</p>
</td></tr>
<tr><td><code id="fnAppend_+3A_x">x</code></td>
<td>
<p>A character string or a numeric to add to the file name</p>
</td></tr>
<tr><td><code id="fnAppend_+3A_pad0">pad0</code></td>
<td>
<p>In case x is numeric, a number of zeros to pad before
the appended number. This is useful if you are generating say
more than 10 files, and your counter will be 01, 02,..,
10,... and not 1, 2,...,10,...</p>
</td></tr>
<tr><td><code id="fnAppend_+3A_sep">sep</code></td>
<td>
<p>The separator between the existing file name (until
extension) and the addition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character (vector)
</p>

<hr>
<h2 id='fnExtension'>Change file name extension</h2><span id='topic+fnExtension'></span>

<h3>Description</h3>

<p>Very simple but often applicable function to retrieve or change
the file name extension (from say file.lst to file.mod)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fnExtension(fn, ext)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fnExtension_+3A_fn">fn</code></td>
<td>
<p>file name. Often ending in an extension after a period
but the extension is not needed.</p>
</td></tr>
<tr><td><code id="fnExtension_+3A_ext">ext</code></td>
<td>
<p>new file name extension. If omitted or NULL, the
extension of fn is returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A text string
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fnExtension("file.lst",".mod")
fnExtension("file.lst","mod")
fnExtension("file.lst","..mod")
fnExtension("file.lst",cc(.mod,xml))
fnExtension(cc(file1.lst,file2.lst),cc(.xml))
fnExtension(cc(file1.lst,file2.lst),cc(.xml,.cov))
fnExtension("file.lst","")
fnExtension("file.lst")
</code></pre>

<hr>
<h2 id='getArgs'>Get provided arguments as a named list</h2><span id='topic+getArgs'></span>

<h3>Description</h3>

<p>Get provided arguments as a named list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getArgs(which = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getArgs_+3A_which">which</code></td>
<td>
<p>How many environment levels to go up to look for
arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list
</p>


<h3>See Also</h3>

<p>Other arguments: 
<code><a href="#topic+deprecatedArg">deprecatedArg</a>()</code>
</p>

<hr>
<h2 id='getFilePaths'>Internal interpretation of file specification options</h2><span id='topic+getFilePaths'></span>

<h3>Description</h3>

<p>Internal interpretation of file specification options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getFilePaths(files = NULL, file.pattern = NULL, dir = NULL, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getFilePaths_+3A_files">files</code></td>
<td>
<p>character vector of full file paths. Specify either
files or both file.pattern and dir.</p>
</td></tr>
<tr><td><code id="getFilePaths_+3A_file.pattern">file.pattern</code></td>
<td>
<p>A regular expression to look for in dir. If used, dir must also be supplied.</p>
</td></tr>
<tr><td><code id="getFilePaths_+3A_dir">dir</code></td>
<td>
<p>The directory i which to look for file.pattern. dir is
passed to list.files as pattern. If supplied, file.pattern must also be supplied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of full paths to files
</p>

<hr>
<h2 id='is.NMdata'>Check if an object is 'NMdata'</h2><span id='topic+is.NMdata'></span>

<h3>Description</h3>

<p>Check if an object is 'NMdata'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.NMdata(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.NMdata_+3A_x">x</code></td>
<td>
<p>Any object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical if x is an 'NMdata' object
</p>

<hr>
<h2 id='listMissings'>List rows with missing values across multiple columns</h2><span id='topic+listMissings'></span>

<h3>Description</h3>

<p>Missing can be NA and for character variables it can be certain
strings too. This function is experimental and design may change
in future releases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listMissings(data, cols, by, na.strings = c("", "."), quiet = FALSE, as.fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listMissings_+3A_data">data</code></td>
<td>
<p>The data to look into.</p>
</td></tr>
<tr><td><code id="listMissings_+3A_cols">cols</code></td>
<td>
<p>The columns to look for missings in.</p>
</td></tr>
<tr><td><code id="listMissings_+3A_by">by</code></td>
<td>
<p>If supplied, we are keeping track of the missings within
the values of the by columns. In summary, by is included too.</p>
</td></tr>
<tr><td><code id="listMissings_+3A_na.strings">na.strings</code></td>
<td>
<p>Strings that should be interpreted as
missing. All spaces will be removed before we compare to
na.strings. The default is c(&quot;&quot;,&quot;.&quot;) so say &quot; .  &quot; is a
missing by default.</p>
</td></tr>
<tr><td><code id="listMissings_+3A_quiet">quiet</code></td>
<td>
<p>Keep quiet? Default is not to.</p>
</td></tr>
<tr><td><code id="listMissings_+3A_as.fun">as.fun</code></td>
<td>
<p>A function that will be run on the result before
returning. If first input data set is a data.table, the
default is to return a data.table, if not the default is to
return a data.frame. Use whatever to get what fits in with
your workflow. Default can be configured with NMdataConf.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly, a data.frame including all findings
</p>


<h3>See Also</h3>

<p>Other DataWrangling: 
<code><a href="#topic+compareCols">compareCols</a>()</code>,
<code><a href="#topic+dims">dims</a>()</code>
</p>

<hr>
<h2 id='lstExtractTime'>Extract run time from output control stream</h2><span id='topic+lstExtractTime'></span>

<h3>Description</h3>

<p>Extract run time from output control stream
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lstExtractTime(file, tz.lst = "as.is")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lstExtractTime_+3A_file">file</code></td>
<td>
<p>path to output control stream</p>
</td></tr>
<tr><td><code id="lstExtractTime_+3A_tz.lst">tz.lst</code></td>
<td>
<p>The time zone of the time stamp from Nonmem. The
default (&quot;as.is&quot;) is to try to extract it or take it from the
system on which this function is run. See details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Time zones are system specific. See <code>OlsonNames()</code>
for a list of what time zones are available on the system.
</p>


<h3>Value</h3>

<p>A POSIXct date-time object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>file &lt;- system.file("examples/nonmem/xgxr003.lst",package="NMdata")
NMdata:::lstExtractTime(file)
file &lt;- system.file("examples/nonmem/xgxr003.mod",package="NMdata")
NMdata:::lstExtractTime(file)

## Not run: 
all.lsts &lt;- list.files(
  system.file("examples/nonmem",package="NMdata"),
  pattern="\\.lst",full.names=TRUE)
lapply(all.lsts,NMdata:::lstExtractTime)

## End(Not run)
</code></pre>

<hr>
<h2 id='mergeCheck'>Merge, order, and check resulting rows and columns.</h2><span id='topic+mergeCheck'></span>

<h3>Description</h3>

<p>Stop checking that the number of rows is unchanged after a merge -
mergeCheck checks what you really want - i.e. x is extended with
columns from y while all rows in x are retained, and no new rows
are created (plus some more checks). mergeCheck is not a merge implementation - it is a
useful merge wrapper. The advantage over using much more flexible
merge or join function lies in the fully automated checking that
the results are consistent with the simple merge described above.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeCheck(
  x,
  y,
  by,
  by.x,
  by.y,
  fun.commoncols = base::warning,
  ncols.expect,
  track.msg = FALSE,
  quiet,
  df1,
  df2,
  fun.na.by = base::stop,
  as.fun,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeCheck_+3A_x">x</code></td>
<td>
<p>A data.frame with the number of rows must should be
obtained from the merge. The resulting data.frame will be
ordered like x.</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_y">y</code></td>
<td>
<p>A data.frame that will be merged onto x.</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_by">by</code></td>
<td>
<p>The column(s) to merge by. Character string (vector). by
or by.x and by.y must be supplied.</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_by.x">by.x</code></td>
<td>
<p>If the columns to merge by in x and y are named
differently. by or by.x and by.y must be supplied.</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_by.y">by.y</code></td>
<td>
<p>If the columns to merge by in x and y are named
differently. by or by.x and by.y must be supplied.</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_fun.commoncols">fun.commoncols</code></td>
<td>
<p>If common columns are found in x and y, and
they are not used in by, this will create columns named like
col.x and col.y in result (see ?merge). Often, this is a
mistake, and the default is to throw a warning if this
happens. If using mergeCheck in a function, you may want to
make sure this is not happening and use
fun.commoncols=stop. If you want nothing to happen, you can do
fun.commoncols=NULL.</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_ncols.expect">ncols.expect</code></td>
<td>
<p>If you want to include a check of the number
of columns being added to the dimensions of x. So if
ncols.expect=1, the resulting data must have exactly one
column more than x - if not, an error will be returned.</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_track.msg">track.msg</code></td>
<td>
<p>If using mergeCheck inside other functions, it
can be useful to use track.msg=TRUE. This will add information
to messages/warnings/errors that they came from mergCheck.</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_quiet">quiet</code></td>
<td>
<p>If FALSE, the names of the added columns are
reported. Default value controlled by NMdataConf.</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_df1">df1</code></td>
<td>
<p>Deprecated. Use x.</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_df2">df2</code></td>
<td>
<p>Deprecated. Use y.</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_fun.na.by">fun.na.by</code></td>
<td>
<p>If NA's are found in (matched) by columns in both
x and why, what should we do? This could be OK, but in many
cases, it's because something unexpected is happening. Use
fun.na.by=NULL if you don't want to be notified and want to go
ahead regardless.</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return a data.table if x is a
data.table and return a data.frame in all other cases. Pass a
function in as.fun to convert to something else.</p>
</td></tr>
<tr><td><code id="mergeCheck_+3A_...">...</code></td>
<td>
<p>additional arguments passed to data.table::merge. If
all is among them, an error will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Besides merging and checking rows, mergeCheck makes sure
the order in x is retained in the resulting data (both rows
and column order). Also, a warning is given if column names
are overlapping, making merge create new column names like
col.x and col.y. Merges and other operations are done using
data.table. If x is a data.frame (and not a data.table), it
will internally be converted to a data.table, and the
resulting data.table will be converted back to a data.frame
before returning.
</p>
<p>mergeCheck is for the kind of merges where we think of x
as the data to be enriched with columns from y - rows
unchanged. This is even further limited than a left join where
you can match rows multiple times. A common example of the use
of mergeCheck is for adding covariates to a pk/pd data set. We
do not want that to remove or duplicate doses, observations,
or simulation records. In those cases, mergeCheck does all
needed checks, and you can run full speed without checking
dimensions (which is anyway not exactly the right thing to do
in the general case) or worry that something might go wrong.
</p>
<p>Checks performed:
</p>

<ul>
<li><p> x has &gt;0 rows
</p>
</li>
<li><p> by columns are present in x an y
</p>
</li>
<li><p> Merge is not performed on NA values. If by=ID and both x$ID and
y$ID contain NA's, an error is thrown (see argument fun.na.by).
</p>
</li>
<li><p> Merge is done by all common column names in x and y. A
warning is thrown if there are column names that are not being
used to merge by. This will result in two columns named like BW.x
and BW.y and is often unintended.
</p>
</li>
<li><p> Before merging a row counter is added to x. After the merge, the
result is assured to have exactly one occurrence of each of the
values of the row counter in x.
</p>
</li></ul>

<p>Moreover, row and column order from x is retained in the result.
</p>


<h3>Value</h3>

<p>a data.frame resulting from merging x and y. Class as
defined by as.fun.
</p>


<h3>See Also</h3>

<p>Other DataCreate: 
<code><a href="#topic+NMorderColumns">NMorderColumns</a>()</code>,
<code><a href="#topic+NMstamp">NMstamp</a>()</code>,
<code><a href="#topic+NMwriteData">NMwriteData</a>()</code>,
<code><a href="#topic+addTAPD">addTAPD</a>()</code>,
<code><a href="#topic+findCovs">findCovs</a>()</code>,
<code><a href="#topic+findVars">findVars</a>()</code>,
<code><a href="#topic+flagsAssign">flagsAssign</a>()</code>,
<code><a href="#topic+flagsCount">flagsCount</a>()</code>,
<code><a href="#topic+tmpcol">tmpcol</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> df1 &lt;- data.frame(x = 1:10,
                   y=letters[1:10],
                   stringsAsFactors=FALSE)
 df2 &lt;- data.frame(y=letters[1:11],
                   x2 = 1:11,
                   stringsAsFactors=FALSE)

 mc1 &lt;- mergeCheck(x=df1,y=df2,by="y")

## Notice as opposed to most merge/join algorithms, mergeCheck by
#default retains both row and column order from x
library(data.table)
merge(as.data.table(df1),as.data.table(df2))
## Here we get a duplicate of a df1 row in the result. If we only
## check dimensions, we make a mistake. mergeCheck captures the
## error - and tell us where to find the problem (ID 31 and 180):
## Not run: 
pk &lt;- readRDS(file=system.file("examples/data/xgxr2.rds",package="NMdata"))
dt.cov &lt;- pk[,.(ID=unique(ID))]
dt.cov[,COV:=sample(1:5,size=.N,replace=TRUE)]
dt.cov &lt;- dt.cov[c(1,1:(.N-1))]
dim(pk)
res.merge &lt;- merge(pk,dt.cov,by="ID")
dim(res.merge)
mergeCheck(pk,dt.cov,by="ID")

## End(Not run)
</code></pre>

<hr>
<h2 id='messageWrap'>Pretty wrapping of lines in NMdata vignettes</h2><span id='topic+messageWrap'></span>

<h3>Description</h3>

<p>Pretty wrapping of lines in NMdata vignettes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>messageWrap(
  ...,
  fun.msg = message,
  prefix = "\n",
  initial = "",
  width,
  track.msg = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="messageWrap_+3A_...">...</code></td>
<td>
<p>parameters to pass to strwrap</p>
</td></tr>
<tr><td><code id="messageWrap_+3A_fun.msg">fun.msg</code></td>
<td>
<p>The function to pass the text through. Typically,
message, warning, or stop. If NULL, nothing will happen, and
NULL is invisibly returned.</p>
</td></tr>
<tr><td><code id="messageWrap_+3A_prefix">prefix</code></td>
<td>
<p>Passed to strwrap. Default is &quot;\n&quot;.</p>
</td></tr>
<tr><td><code id="messageWrap_+3A_initial">initial</code></td>
<td>
<p>Passed to strwrap. Default is an empty string.</p>
</td></tr>
<tr><td><code id="messageWrap_+3A_width">width</code></td>
<td>
<p>Passed to strwrap. Default is 80.</p>
</td></tr>
<tr><td><code id="messageWrap_+3A_track.msg">track.msg</code></td>
<td>
<p>If TRUE, the name of the function throwing the
message/warning/error is mentioned. This is not default but
useful when using function inside other functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>

<hr>
<h2 id='NMapplyFilters'>Translate filters in Nonmem and apply to data</h2><span id='topic+NMapplyFilters'></span>

<h3>Description</h3>

<p>Translate filters in Nonmem and apply to data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMapplyFilters(data, file, text, lines, invert = FALSE, as.fun, quiet)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMapplyFilters_+3A_data">data</code></td>
<td>
<p>An input data object. Could be read with NMreadCsv or
NMscanInput.</p>
</td></tr>
<tr><td><code id="NMapplyFilters_+3A_file">file</code></td>
<td>
<p>Path to mod/lst file. Only one of file, text, or lines to be
given. See ?NMreadSection for understanding when to use, file, text, or
lines.</p>
</td></tr>
<tr><td><code id="NMapplyFilters_+3A_text">text</code></td>
<td>
<p>The mod/lst as characters.</p>
</td></tr>
<tr><td><code id="NMapplyFilters_+3A_lines">lines</code></td>
<td>
<p>The mod/lst as character, line by line.</p>
</td></tr>
<tr><td><code id="NMapplyFilters_+3A_invert">invert</code></td>
<td>
<p>Invert the filters? This means read what Nonmem would
disregard, and disregard what Nonmem would read.</p>
</td></tr>
<tr><td><code id="NMapplyFilters_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass a function
(say tibble::as_tibble) in as.fun to convert to something else. If
data.tables are wanted, use as.fun=&quot;data.table&quot;. The default can be
configured using NMdataConf.</p>
</td></tr>
<tr><td><code id="NMapplyFilters_+3A_quiet">quiet</code></td>
<td>
<p>Don't report information along the way if no warnings or
errors. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is not bulletproof. Nested conditions are not supported altogether.
</p>


<h3>Value</h3>

<p>data with filters applied
</p>


<h3>See Also</h3>

<p>Other Nonmem: 
<code><a href="#topic+NMextractText">NMextractText</a>()</code>,
<code><a href="#topic+NMgenText">NMgenText</a>()</code>,
<code><a href="#topic+NMreadSection">NMreadSection</a>()</code>,
<code><a href="#topic+NMreplaceDataFile">NMreplaceDataFile</a>()</code>,
<code><a href="#topic+NMwriteSection">NMwriteSection</a>()</code>
</p>

<hr>
<h2 id='NMcheckColnames'>Compare $INPUT in control stream to column names in input data</h2><span id='topic+NMcheckColnames'></span>

<h3>Description</h3>

<p>Mis-specification of column names in $DATA is a common source of
problems with Nonmem models, and should be one of the first things
to check for when seemingly inexplicable things happen. This
function lines up input data column names with $DATA and how
NMscanData will interpret $DATA so you can easily spot if
something is off.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMcheckColnames(file, as.fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMcheckColnames_+3A_file">file</code></td>
<td>
<p>A Nonmem control stream or list file</p>
</td></tr>
<tr><td><code id="NMcheckColnames_+3A_as.fun">as.fun</code></td>
<td>
<p>See ?NMdataConf</p>
</td></tr>
<tr><td><code id="NMcheckColnames_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An overview of input column names and how they are translated
</p>

<hr>
<h2 id='NMcheckData'>Check data for Nonmem compatibility or check control stream for
data compatibility</h2><span id='topic+NMcheckData'></span>

<h3>Description</h3>

<p>Check data in various ways for compatibility with Nonmem. Some
findings will be reported even if they will not make Nonmem fail
but because they are typical dataset issues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMcheckData(
  data,
  file,
  covs,
  covs.occ,
  cols.num,
  col.id = "ID",
  col.time = "TIME",
  col.dv = "DV",
  col.mdv = "MDV",
  col.cmt = "CMT",
  col.amt = "AMT",
  col.flagn,
  col.row,
  col.usubjid,
  cols.dup,
  type.data = "est",
  na.strings,
  return.summary = FALSE,
  quiet = FALSE,
  as.fun
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMcheckData_+3A_data">data</code></td>
<td>
<p>The data to check. data.frame, data.table, tibble,
anything that can be converted to data.table.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_file">file</code></td>
<td>
<p>Alternatively to checking a data object, you can use
file to specify a control stream to check. This can either be
a (working or non-working) input control stream or an output
control stream. In this case, <code>NMdataCheck</code> checks column
names in data against control stream (see
<code>NMcheckColnames</code>), reads the data as Nonmem would do,
and do the same checks on the data as NMdataCheck would do
using the data argument. <code>col.flagn</code> is ignored in this
case - instead, ACCEPT/IGNORE statements in control stream are
applied. The file argument is useful for debugging a Nonmem
model.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_covs">covs</code></td>
<td>
<p>columns that contain subject-level covariates. They
are expected to be non-missing, numeric and not varying within
subjects.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_covs.occ">covs.occ</code></td>
<td>
<p>A list specifying columns that contain
subject:occasion-level covariates. They are expected to be
non-missing, numeric and not varying within combinations of
subject and occasion. <code>covs.occ=list(PERIOD=c("FED"))</code>
means that <code>FED</code> is the covariate, while <code>PERIOD</code>
indicates the occasion.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_cols.num">cols.num</code></td>
<td>
<p>Columns that are expected to be present, numeric
and non-NA. If a character vector is given, the columns are
expected to be used in all rows. If a column is only used for
a subset of rows, use a list and name the elements by
subsetting strings. See examples.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_col.id">col.id</code></td>
<td>
<p>The name of the column that holds the subject
identifier. Default is &quot;ID&quot;.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_col.time">col.time</code></td>
<td>
<p>The name of the column holding actual time.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_col.dv">col.dv</code></td>
<td>
<p>The name of the column holding the dependent
variable. For now, only one column can be specified, and
<code>MDV</code> is assumed to match this column. Default is
<code>DV</code>.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_col.mdv">col.mdv</code></td>
<td>
<p>The name of the column holding the binary indicator
of the dependent variable missing. Default is <code>MDV</code>.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_col.cmt">col.cmt</code></td>
<td>
<p>The name(s) of the compartment column(s). These
will be checked to be positive integers for all rows. They are
also used in checks for row duplicates.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_col.amt">col.amt</code></td>
<td>
<p>The name of the dose amount column.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_col.flagn">col.flagn</code></td>
<td>
<p>Optionally, the name of the column holding
numeric exclusion flags. Default value is <code>FLAG</code> and can
be configured using <code>NMdataConf</code>. Even though <code>FLAG</code>
is the default value, no finding will be returned if the
column is missing unless explicitly defined as
<code>col.flagn="FLAG"</code>. This is because this way of using
exclusion flags is only one of many ways you could choose to
handle exclusions. Disable completely by using
<code>col.flagn=FALSE</code>.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_col.row">col.row</code></td>
<td>
<p>A column with a unique value for each row. Such a
column is recommended to use if possible. Default
(<code>"ROW"</code>) can be modified using <code>NMdataConf</code>.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_col.usubjid">col.usubjid</code></td>
<td>
<p>Optional unique subject identifier. It is
recommended to keep a unique subject identifier (typically a
character string including an abbreviated study name and the
subject id) from the clinical datasets in the analysis set. If
you supply the name of the column holding this identifier,
NMcheckData will check that it is non-missing, that it is
unique within values of col.id (i.e. that the analysis subject
ID's are unique across actual subjects), and that col.id is
unique within the unique subject ID (a violation of the latter
is less likely).</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_cols.dup">cols.dup</code></td>
<td>
<p>Additional column names to consider in search of
duplicate events. col.id, col.cmt, col.evid, and col.time are
always considered if found in data, and cols.dup is added to
this list if provided.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_type.data">type.data</code></td>
<td>
<p>&quot;est&quot; for estimation data (default), and &quot;sim&quot;
for simulation data. Differences are that <code>col.row</code> is
not expected for simulation data, and subjects will be checked
to have <code>EVID==0</code> rows for estimation data and
<code>EVID==2</code> rows for simulation data.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_na.strings">na.strings</code></td>
<td>
<p>Strings to be accepted when trying to convert
characters to numerics. This will typically be a string that
represents missing values. Default is &quot;.&quot;. Notice, actual NA,
i.e. not a string, is allowed independently of na.strings. See
<code>?NMisNumeric</code>.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_return.summary">return.summary</code></td>
<td>
<p>If TRUE (not default), the table summary
that is printed if <code>quiet=FALSE</code> is returned as well. In
that case, a list is returned, and the findings are in an
element called findings.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_quiet">quiet</code></td>
<td>
<p>Keep quiet? Default is not to.</p>
</td></tr>
<tr><td><code id="NMcheckData_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a
<code>data.frame</code>. Pass a function (say
<code>tibble::as_tibble</code>) in as.fun to convert to something
else. If <code>data.tables</code> are wanted, use
<code>as.fun="data.table"</code>. The default can be configured
using <code>NMdataConf</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following checks are performed. The term &quot;numeric&quot;
does not refer to a numeric representation in R, but
compatibility with Nonmem. The character string &quot;2&quot; is in this
sense a valid numeric, &quot;id2&quot; is not.  </p>

<ul>
<li><p> Column
names must be unique and not contain special characters
</p>
</li>
<li><p> If an exclusion flag is used (for ACCEPT/IGNORE in Nonmem),
elements must be non-missing and integers. Notice, if an exclusion
flag is found, the rest of the checks are performed on rows
where that flag equals 0 (zero) only.
</p>
</li>
<li><p> If a unique row identifier is found, it has to be
non-missing, increasing integers. 
</p>
</li>
<li><p> col.time (TIME),
EVID, col.id (ID), col.cmt (CMT), and col.mdv (MDV): If present, elements must be non-missing
and numeric.
</p>
</li>
<li><p> col.time (TIME) must be non-negative
</p>
</li>
<li><p> EVID must be in {0,1,2,3,4}.
</p>
</li>
<li><p> CMT must be positive integers. However, can be missing or zero for EVID==3.
</p>
</li>
<li><p> MDV must be the binary (1/0) representation of is.na(DV) for
dosing records (EVID==0).
</p>
</li>
<li><p> AMT must be 0 or NA for EVID 0 and 2
</p>
</li>
<li><p> AMT must be positive for EVID 1 and 4
</p>
</li>
<li><p> DV must be numeric
</p>
</li>
<li><p> DV must be missing for EVID in {1,4}.
</p>
</li>
<li><p> If found, RATE must be a numeric, equaling -2 or non-negative for dosing events.
</p>
</li>
<li><p> If found, SS must be a numeric, equaling 0 or 1 for dosing records.
</p>
</li>
<li><p> If found, <code>ADDL</code> must be a non-negative integer for dosing
records. II must be present.
</p>
</li>
<li><p> If found, II must be a non-negative integer for dosing
records. <code>ADDL</code> must be present.
</p>
</li>
<li><p> ID must be positive and values cannot be disjoint (all
records for each ID must be following each other. This is
technically not a requirement in Nonmem but most often an
error. Use a second ID column if you deliberately want to
soften this check)
</p>
</li>
<li><p> TIME cannot be decreasing within ID, unless EVID in {3,4}.
</p>
</li>
<li><p> all ID's must have doses (EVID in {1,4})
</p>
</li>
<li><p> all ID's must have observations (EVID==0)
</p>
</li>
<li><p> ID's should not have leading zeros since these will be lost
when Nonmem read, then write the data.
</p>
</li>
<li><p> If a unique row identifier is used, this must be
non-missing, increasing, integer
</p>
</li>
<li><p> Character values must not contain commas (they will mess up
writing/reading csv)
</p>
</li>
<li><p> Columns specified in covs argument must be non-missing,
numeric and not varying within subjects.
</p>
</li>
<li><p> Columns specified in covs.occ must be
non-missing, numeric and not varying within combinations of
subject and occasion.
</p>
</li>
<li><p> Columns specified in cols.num must be present, numeric
and non-NA.
</p>
</li>
<li><p> If a unique subject identifier column (col.usubjid) is
provided, col.id must be unique within values of col.usubjid and
vice versa.
</p>
</li>
<li><p> Events should not be duplicated. For all rows, the
combination of col.id, col.cmt ,col.evid, col.time plus the
optional columns specified in cols.dup must be unique. In other
words, if a subject (col.id) that has say observations (col.evid)
at the same time (col.time), this is considered a duplicate. The
exception is if there is a reset event (col.evid is 3 or 4) in
between the two rows. cols.dup can be used to add columns to this
analysis. This is useful for different assays run on the same
compartment (say a DVID column) or maybe stacked datasets. If
col.cmt is of length&gt;1, this search is repeated for each cmt
column.
</p>
</li></ul>



<h3>Value</h3>

<p>A table with findings
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dat &lt;- readRDS(system.file("examples/data/xgxr2.rds", package="NMdata"))
NMcheckData(dat)
dat[EVID==0,LLOQ:=3.5]
## expecting LLOQ only for samples
NMcheckData(dat,cols.num=list(c("STUDY"),"EVID==0"=c("LLOQ")))

## End(Not run)
</code></pre>

<hr>
<h2 id='NMcheckDataFile'>check input data based on control stream</h2><span id='topic+NMcheckDataFile'></span>

<h3>Description</h3>

<p>Finds input data and checks compatibility with Nonmem control
stream and runs NMcheckData. Don't call this function directly -
use the file argument in NMcheckData instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMcheckDataFile(
  file,
  col.row,
  col.id = "ID",
  formats.read = "csv",
  quiet = FALSE,
  file.mod,
  dir.data,
  as.fun,
  use.rds,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMcheckDataFile_+3A_file">file</code></td>
<td>
<p>a model file (input or output control stream)</p>
</td></tr>
<tr><td><code id="NMcheckDataFile_+3A_col.row">col.row</code></td>
<td>
<p>row identifier</p>
</td></tr>
<tr><td><code id="NMcheckDataFile_+3A_col.id">col.id</code></td>
<td>
<p>subject identifier</p>
</td></tr>
<tr><td><code id="NMcheckDataFile_+3A_formats.read">formats.read</code></td>
<td>
<p>Prioritized input data file formats to look
for and use if found. Default is c(&quot;csv&quot;) which means
<code>rds</code> and <code>fst</code> will _not_ be used. Typically only
the csv file is wanted because we want to test the input data
as read by Nonmem.</p>
</td></tr>
<tr><td><code id="NMcheckDataFile_+3A_quiet">quiet</code></td>
<td>
<p>Keep quiet? Default is FALSE.</p>
</td></tr>
<tr><td><code id="NMcheckDataFile_+3A_file.mod">file.mod</code></td>
<td>
<p>How to find the input control stream if you are
using the output control stream.</p>
</td></tr>
<tr><td><code id="NMcheckDataFile_+3A_dir.data">dir.data</code></td>
<td>
<p>The data directory can only be read from the
control stream (.mod) and not from the output file (.lst). So
if you only have the output control stream, use dir.data to
tell in which directory to find the data file. If dir.data is
provided, the .mod file is not used at all.</p>
</td></tr>
<tr><td><code id="NMcheckDataFile_+3A_as.fun">as.fun</code></td>
<td>
<p>The function to run results through before returning
them.</p>
</td></tr>
<tr><td><code id="NMcheckDataFile_+3A_use.rds">use.rds</code></td>
<td>
<p>Deprecated. Use formats.read instead.</p>
</td></tr>
<tr><td><code id="NMcheckDataFile_+3A_...">...</code></td>
<td>
<p>passed to NMcheckData</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of diagnostics
</p>

<hr>
<h2 id='NMcode2R'>Translate Nonmem $PK, $PRED sections or other Nonmem code to R code</h2><span id='topic+NMcode2R'></span>

<h3>Description</h3>

<p>Translate Nonmem $PK, $PRED sections or other Nonmem code to R code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMcode2R(text)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMcode2R_+3A_text">text</code></td>
<td>
<p>the Nonmem code.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You probably want to run this on text obtained by using
the NMreadSection function.
</p>


<h3>Value</h3>

<p>R code as text
</p>

<hr>
<h2 id='NMdataConf'>Configure default behavior of NMdata functions</h2><span id='topic+NMdataConf'></span>

<h3>Description</h3>

<p>Configure default behavior across the functions in NMdata rather
than typing the arguments in all function calls. Configure for
your file organization, data set column names, and other NMdata
behavior. Also, you can control what data class NMdata functions
return (say data.tables or tibbles if you prefer one of those over
data.frames).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMdataConf(..., allow.unknown = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMdataConf_+3A_...">...</code></td>
<td>
<p>NMdata options to modify. These are named arguments,
like for base::options. Normally, multiple arguments can be
used. The exception is if reset=TRUE is used which means all
options are restored to default values. If NULL is passed to
an argument, the argument is reset to default.  is See
examples for how to use.</p>
</td></tr>
<tr><td><code id="NMdataConf_+3A_allow.unknown">allow.unknown</code></td>
<td>
<p>Allow to store configuration of variables
that are not pre-defined in NMdata. This should only be needed
in cases where say another package wants to use the NMdata
configuration system for variables unknown to NMdata.
</p>
<p>Parameters that can be controlled are:
</p>

<ul>
<li><p>args.fread Arguments passed to fread when reading _input_
data files (fread options for reading Nonmem output tables cannot
be configured at this point). If you change this, you are starting
from scratch, except from file. This means that existing default
argument values are all disregarded.
</p>
</li>
<li><p>args.fwrite Arguments passed to fwrite when writing csv
files (NMwriteData). If you use this, you have to supply all
arguments you want to use with fwrite, except for x (the data) and
file.
</p>
</li>
<li><p>as.fun A function that will be applied to data returned by various
data reading functions (NMscanData, NMreadTab, NMreadCsv, NMscanInput,
NMscanTables). Also, data processing functions like mergeCheck, findCovs,
findVars, flagsAssign, flagsCount take this into account, but slightly
differently. For these functions that take data as arguments, the as.fun
configuration is only taken into account if a the data passed to the
functions are not of class data.table. The argument as.fun to these
functions is always adhered to. Pass an actual function, say
as.fun=tibble::as_tibble. If you want data.table, use as.fun=&quot;data.table&quot;
(not a function).
</p>
</li>
<li><p>check.time Logical, applies to NMscanData only. NMscanData by
defaults checks if output control stream is newer than input control stream
and input data. Set this to FALSE if you are in an environment where time
stamps cannot be relied on.
</p>
</li>
<li><p>col.flagc The name of the column containing the character
flag values for data row omission. Default value is flag. Used
by flagsAssign, flagsCount.
</p>
</li>
<li><p>col.flagn The name of the column containing numerical flag
values for data row omission. Default value is FLAG. Used by
flagsAssign, flagsCount, NMcheckData. 
</p>
</li>
<li><p>col.model The name of the column that will hold the name of
the model. See modelname too (which defines the values that the
column will hold).
</p>
</li>
<li><p>col.nmout A column of this name will be a logical
representing whether row was in output table or not.
</p>
</li>
<li><p>col.nomtime The name of the column holding nominal
time. This is only used for sorting columns by NMorderColumns.
</p>
</li>
<li><p>col.row The name of the column containing a unique row
identifier. This is used by NMscanData when merge.by.row=TRUE, and
by NMorderColumns (row counter will be first column in data).
</p>
</li>
<li><p>col.id The name of the column holding the numeric subject
ID. As of 'NMdata' 0.1.5 this is only used for sorting columns by
NMorderColumns.
</p>
</li>
<li><p>col.time The name of the column holding actual time. As of
'NMdata' 0.1.5 this is only used for sorting columns by
NMorderColumns.
</p>
</li>
<li><p>dir.psn The directory in which to find psn executables like
'execute' and 'update_inits'. Default is &quot;&quot; meaning that
executables must be in the system search path. Not used by NMdata.
</p>
</li>
<li><p>dir.res Directory in which 'NMsim' will store simulation
results files. Not used by NMdata. See dir.sims too.
</p>
</li>
<li><p>dir.sims Directory in which 'NMsim' will store Nonmem
simulations. Not used by NMdata. See dir.res too.
</p>
</li>
<li><p>file.cov A function that will derive the path to the
covariance (.cov) output file stream based on the path to the
output control stream. Technically, it can be a string too, but
when using NMdataConf, this would make little sense because it
would direct all output control streams to the same input control
streams.
</p>
</li>
<li><p>file.ext A function that will derive the path to the
parameter (.ext) output file stream based on the path to the
output control stream. Technically, it can be a string too, but
when using NMdataConf, this would make little sense because it
would direct all output control streams to the same input control
streams.
</p>
</li>
<li><p>file.mod A function that will derive the path to the input
control stream based on the path to the output control
stream. Technically, it can be a string too, but when using
NMdataConf, this would make little sense because it would direct
all output control streams to the same input control streams.
</p>
</li>
<li><p>file.phi A function that will derive the path to the Nonmem
output (.phi) file containing individual ETA, ETC, and/or PHI
values stream based on the path to the output control
stream. Technically, it can be a string too, but when using
NMdataConf, this would make little sense because it would direct
all output control streams to the same input control streams.
</p>
</li>
<li><p>file.data A function that will derive the path to the input
data based on the path to the output control stream. Technically,
it can be a string too, but when using NMdataConf, this would make
little sense because it would direct all output control streams to
the same input control streams.
</p>
</li>
<li><p>formats.read Prioritized input data file formats to look
for and use if found. Default is c(&quot;rds&quot;,&quot;csv&quot;) which means
<code>rds</code> will be used if found, and <code>csv</code> if
not. <code>fst</code> is possible too.
</p>
</li>
<li><p>formats.write character vector of formats.write. Default is
c(&quot;csv&quot;,&quot;rds&quot;). &quot;fst&quot; is possible too.
</p>
</li>
<li><p>merge.by.row Adjust the default combine method in
NMscanData.
</p>
</li>
<li><p>modelname A function that will translate the output control stream
path to a model name. Default is to strip .lst, so /path/to/run1.lst will
become run1. Technically, it can be a string too, but when using NMdataConf,
this would make little sense because it would translate all output control
streams model name.
</p>
</li>
<li><p>path.nonmem Path (a character string) to a nonmem
executable. Not used by NMdata. Default is NULL.
</p>
</li>
<li><p>quiet For non-interactive scripts, you can switch off the
chatty behavior once and for all using this setting.
</p>
</li>
<li><p>recover.rows In NMscanData, Include rows from input data
files that do not exist in output tables? This will be added
to the $row dataset only, and $run, $id, and $occ datasets are
created before this is taken into account. A column called
nmout will be TRUE when the row was found in output tables,
and FALSE when not. Default is FALSE.
</p>
</li>
<li><p>use.input In NMscanData, merge with columns in input data?
Using this, you don't have to worry about remembering including
all relevant variables in the output tables. Default is TRUE.
</p>
</li>
<li><p>use.rds Deprecated, use <code>formats.read</code> and
<code>formats.write</code> instead. Affects <code>NMscanData()</code>, 
<code>NMscanInput()</code>, <code>NMwriteData()</code>.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Recommendation: Use
this function transparently in the code and not in a configuration file
hidden from other users.
</p>


<h3>Value</h3>

<p>If no arguments given, a list of active settings. If
arguments given and no issues found, TRUE invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## get current defaults
NMdataConf()
## change a parameter
NMdataConf(check.time=FALSE)
## reset one parameter to default value
NMdataConf(modelname=NULL)
## reset all parameters to defaults
NMdataConf(reset=TRUE)
</code></pre>

<hr>
<h2 id='NMdataConfOptions'>Get NMdataConf parameter properties</h2><span id='topic+NMdataConfOptions'></span>

<h3>Description</h3>

<p>Get NMdataConf parameter properties
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMdataConfOptions(name, allow.unknown = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMdataConfOptions_+3A_name">name</code></td>
<td>
<p>Optionally, a single parameter name (say &quot;as.fun&quot;).</p>
</td></tr>
<tr><td><code id="NMdataConfOptions_+3A_allow.unknown">allow.unknown</code></td>
<td>
<p>Allow access to configuration of variables
that are not pre-defined in NMdata. This should only be needed
in cases where say another package wants to use the NMdata
configuration system for variables unknown to NMdata.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If name is provided, a list representing one argument,
otherwise a list with an element for each argument that can be
customized using NMdataConf.
</p>

<hr>
<h2 id='NMdataDecideOption'>Determine active parameter value based on argument and NMdataConf setting</h2><span id='topic+NMdataDecideOption'></span>

<h3>Description</h3>

<p>Determine active parameter value based on argument and NMdataConf setting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMdataDecideOption(name, argument, allow.unknown = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMdataDecideOption_+3A_name">name</code></td>
<td>
<p>The name of the parameter, say &quot;as.fun&quot;</p>
</td></tr>
<tr><td><code id="NMdataDecideOption_+3A_argument">argument</code></td>
<td>
<p>The value to pass. If missing or NULL, the value returned by NMdataConf/NMdataGetOption will typically be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Active argument value.
</p>

<hr>
<h2 id='NMdataGetOption'>Look up default configuration of an argument</h2><span id='topic+NMdataGetOption'></span>

<h3>Description</h3>

<p>Look up default configuration of an argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMdataGetOption(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMdataGetOption_+3A_...">...</code></td>
<td>
<p>argument to look up. Only one argument can be looked up.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value active in configuration
</p>

<hr>
<h2 id='NMdataOperations'>Basic arithmetic on NMdata objects</h2><span id='topic+NMdataOperations'></span><span id='topic+merge.NMdata'></span><span id='topic+t.NMdata'></span><span id='topic+dimnames.NMdata'></span><span id='topic+rbind.NMdata'></span><span id='topic+cbind.NMdata'></span>

<h3>Description</h3>

<p>Basic arithmetic on NMdata objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NMdata'
merge(x, ...)

## S3 method for class 'NMdata'
t(x, ...)

## S3 method for class 'NMdata'
dimnames(x, ...)

## S3 method for class 'NMdata'
rbind(x, ...)

## S3 method for class 'NMdata'
cbind(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMdataOperations_+3A_x">x</code></td>
<td>
<p>an NMdata object</p>
</td></tr>
<tr><td><code id="NMdataOperations_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When 'dimnames', 'merge', 'cbind', 'rbind', or 't' is
called on an 'NMdata' object, the 'NMdata' class is dropped,
and then the operation is performed. So if and 'NMdata' object
inherits from 'data.frame' and no other classes (which is
default), these operations will be performed using the
'data.frame' methods. But for example, if you use 'as.fun' to
get a 'data.table' or 'tbl', their respective methods are used
instead.
</p>


<h3>Value</h3>

<p>An object that is not of class 'NMdata'.
</p>

<hr>
<h2 id='NMexpandDoses'>Transform repeated dosing events (ADDL/II) to individual dosing events</h2><span id='topic+NMexpandDoses'></span>

<h3>Description</h3>

<p>Replaces single row repeated dosing events by multiple lines, then
reorders rows with respect to ID and TIME. If the row order is
different, you have to reorder the output manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMexpandDoses(
  data,
  col.time = "TIME",
  col.id = "ID",
  col.evid = "EVID",
  track.expand = FALSE,
  subset.dos,
  quiet = FALSE,
  as.fun
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMexpandDoses_+3A_data">data</code></td>
<td>
<p>The data set to expand</p>
</td></tr>
<tr><td><code id="NMexpandDoses_+3A_col.time">col.time</code></td>
<td>
<p>The name of the column holding the time on which
time since previous dose will be based. This is typically
actual or nominal time since first dose.</p>
</td></tr>
<tr><td><code id="NMexpandDoses_+3A_col.id">col.id</code></td>
<td>
<p>The subject identifier. All new columns will be
derived within unique values of this column.</p>
</td></tr>
<tr><td><code id="NMexpandDoses_+3A_col.evid">col.evid</code></td>
<td>
<p>The name of the event ID column. This must exist
in data. Default is EVID.</p>
</td></tr>
<tr><td><code id="NMexpandDoses_+3A_track.expand">track.expand</code></td>
<td>
<p>Keep track of what rows were in data
originally and which ones are added by NMexpandDoses by
including a column called nmexpand? nmexpand will be TRUE if
the row is &quot;generated&quot; by NMexpandDoses.</p>
</td></tr>
<tr><td><code id="NMexpandDoses_+3A_subset.dos">subset.dos</code></td>
<td>
<p>A string that will be evaluated as a custom
expression to identify relevant events.</p>
</td></tr>
<tr><td><code id="NMexpandDoses_+3A_quiet">quiet</code></td>
<td>
<p>Suppress messages back to user (default is FALSE)</p>
</td></tr>
<tr><td><code id="NMexpandDoses_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say tibble::as_tibble) in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data set with at least as many rows as data. If doses
are found to expand, these will be added.
</p>

<hr>
<h2 id='NMextractDataFile'>Extract the data file used in a control stream</h2><span id='topic+NMextractDataFile'></span>

<h3>Description</h3>

<p>A function that identifies the input data file based on a control
stream. The default is to look at the $DATA section of of the
output control stream (or input control stream if file.mod
argument is used). This can be partly or fully overruled by using
the dir.data or file.data arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMextractDataFile(file, dir.data = NULL, file.mod, file.data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMextractDataFile_+3A_file">file</code></td>
<td>
<p>The input control stream or the list file.</p>
</td></tr>
<tr><td><code id="NMextractDataFile_+3A_dir.data">dir.data</code></td>
<td>
<p>See NMscanInput. If used, only the file name
mentioned in $DATA is used. dir.data will be used as the path,
and the existence of the file in that directory is not
checked.</p>
</td></tr>
<tr><td><code id="NMextractDataFile_+3A_file.mod">file.mod</code></td>
<td>
<p>The input control stream. Default is to look for
\&quot;file\&quot; with extension changed to .mod (PSN style). You can
also supply the path to the file, or you can provide a
function that translates the output file path to the input
file path. The default behavior can be configured using
NMdataConf. See dir.data too.</p>
</td></tr>
<tr><td><code id="NMextractDataFile_+3A_file.data">file.data</code></td>
<td>
<p>Specification of the data file path. When this is
used, the control streams are not used at all.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The path to the input data file.
</p>

<hr>
<h2 id='NMextractText'>Versatile text extractor from Nonmem (input or output) control streams</h2><span id='topic+NMextractText'></span>

<h3>Description</h3>

<p>If you want to extract input sections like $PROBLEM, $DATA etc,
see NMreadSection. This function is more general and can be used to
extract eg result sections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMextractText(
  file,
  lines,
  text,
  section,
  char.section,
  char.end = char.section,
  return = "text",
  keep.empty = FALSE,
  keep.name = TRUE,
  keep.comments = TRUE,
  as.one = TRUE,
  clean.spaces = FALSE,
  simplify = TRUE,
  match.exactly = TRUE,
  type = "mod",
  linesep = "\n",
  keepEmpty,
  keepName,
  keepComments,
  asOne,
  cleanSpaces
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMextractText_+3A_file">file</code></td>
<td>
<p>A file path to read from. Normally a .mod or .lst. See
lines and text as well.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_lines">lines</code></td>
<td>
<p>Text lines to process. This is an alternative to
using the file and text arguments.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_text">text</code></td>
<td>
<p>Use this argument if the text to process is one long
character string, and indicate the line separator with the
linesep argument. Use only one of file, lines, and text.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_section">section</code></td>
<td>
<p>The name of section to extract. Examples: &quot;INPUT&quot;,
&quot;PK&quot;, &quot;TABLE&quot;, etc. It can also be result sections like
&quot;MINIMIZATION&quot;.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_char.section">char.section</code></td>
<td>
<p>The section denoted as a string compatible
with regular expressions. &quot;$&quot; (remember to escape properly)
for sections in .mod files, &quot;0&quot; for results in .lst files.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_char.end">char.end</code></td>
<td>
<p>A regular expression to capture the end of the
section. The default is to look for the next occurrence of
char.section.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_return">return</code></td>
<td>
<p>If &quot;text&quot;, plain text lines are returned. If &quot;idx&quot;,
matching line numbers are returned. &quot;text&quot; is default.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_keep.empty">keep.empty</code></td>
<td>
<p>Keep empty lines in output? Default is
FALSE. Notice, comments are removed before empty lines are
handled if 'keep.comments=TRUE'.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_keep.name">keep.name</code></td>
<td>
<p>Keep the section name in output (say, &quot;$PROBLEM&quot;)
Default is TRUE. It can only be FALSE, if return=&quot;text&quot;.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_keep.comments">keep.comments</code></td>
<td>
<p>Default is to keep comments. If FALSE, the
will be removed.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_as.one">as.one</code></td>
<td>
<p>If multiple hits, concatenate into one. This will
most often be relevant with name=&quot;TABLE&quot;. If FALSE, a list
will be returned, each element representing a table. Default
is TRUE. So if you want to process the tables separately, you
probably want FALSE here.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_clean.spaces">clean.spaces</code></td>
<td>
<p>If TRUE, leading and trailing are removed, and
multiplied succeeding white spaces are reduced to single white
spaces.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_simplify">simplify</code></td>
<td>
<p>If asOne=FALSE, do you want the result to be
simplified if only one table is found? Default is TRUE which
is desirable for interactive analysis. For programming, you
probably want FALSE.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_match.exactly">match.exactly</code></td>
<td>
<p>Default is to search for exact matches of
'section'. If FALSE, only the first three characters are
macthed. E.G., this allows &quot;ESTIMATION&quot; to match &quot;ESTIMATION&quot;
or &quot;EST&quot;.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_type">type</code></td>
<td>
<p>Either mod, res or NULL. mod is for information that
is given in .mod (.lst file can be used but results section is
disregarded). If NULL, NA or empty string, everything is
considered.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_linesep">linesep</code></td>
<td>
<p>If using the text argument, use linesep to indicate
how lines should be separated.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_keepempty">keepEmpty</code></td>
<td>
<p>Deprecated. See keep.empty.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_keepname">keepName</code></td>
<td>
<p>Deprecated. See keep.name.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_keepcomments">keepComments</code></td>
<td>
<p>Deprecated. See keep.comments.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_asone">asOne</code></td>
<td>
<p>Deprecated. See as.one.</p>
</td></tr>
<tr><td><code id="NMextractText_+3A_cleanspaces">cleanSpaces</code></td>
<td>
<p>Deprecated. See clean.spaces.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is planned to get a more general name and
then be called by NMreadSection.
</p>


<h3>Value</h3>

<p>character vector with extracted lines.
</p>


<h3>See Also</h3>

<p>Other Nonmem: 
<code><a href="#topic+NMapplyFilters">NMapplyFilters</a>()</code>,
<code><a href="#topic+NMgenText">NMgenText</a>()</code>,
<code><a href="#topic+NMreadSection">NMreadSection</a>()</code>,
<code><a href="#topic+NMreplaceDataFile">NMreplaceDataFile</a>()</code>,
<code><a href="#topic+NMwriteSection">NMwriteSection</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NMreadSection(system.file("examples/nonmem/xgxr001.lst", package = "NMdata"),section="DATA")
</code></pre>

<hr>
<h2 id='NMgenText'>Generate text for INPUT and possibly DATA sections of NONMEM
control streams.</h2><span id='topic+NMgenText'></span>

<h3>Description</h3>

<p>The user is provided with text to use in Nonmem. NMwriteSection
can use the results to update the control streams. INPUT lists
names of the data columns while DATA provides a path to data and
ACCEPT/IGNORE statements. Once a column is reached that Nonmem
will not be able to read as a numeric and column is not in
nm.drop, the list is stopped. Only exception is TIME which is not
tested for whether character or not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMgenText(
  data,
  drop,
  col.flagn = "FLAG",
  rename,
  copy,
  file,
  dir.data,
  capitalize = FALSE,
  until,
  allow.char.TIME = TRUE,
  width,
  quiet
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMgenText_+3A_data">data</code></td>
<td>
<p>The data that NONMEM will read.</p>
</td></tr>
<tr><td><code id="NMgenText_+3A_drop">drop</code></td>
<td>
<p>Only used for generation of proposed text for INPUT
section. Columns to drop in Nonmem $INPUT. This has two
implications. One is that the proposed $INPUT indicates =DROP
after the given column names. The other that in case it is a
non-numeric column, succeeding columns will still be included
in $INPUT and can be read by NONMEM.</p>
</td></tr>
<tr><td><code id="NMgenText_+3A_col.flagn">col.flagn</code></td>
<td>
<p>Name of a numeric column with zero value for rows
to include in Nonmem run, non-zero for rows to skip. The
argument is only used for generating the proposed $DATA text
to paste into the Nonmem control stream. To skip this feature,
use col.flagn=NULL. Default is defined by NMdataConf.</p>
</td></tr>
<tr><td><code id="NMgenText_+3A_rename">rename</code></td>
<td>
<p>For the $INPUT text proposal only. If you want to
rename columns in NONMEM $DATA, NMwriteData can adjust the
suggested $DATA text. If you plan to use BBW instead of BWBASE
in Nonmem, consider rename=c(BBW=&quot;BWBASE&quot;). The result will
include BBW and not BWBASE.</p>
</td></tr>
<tr><td><code id="NMgenText_+3A_copy">copy</code></td>
<td>
<p>For the $INPUT text proposal only. If you plan to use
additional names for columns in Nonmem $INPUT, NMwriteData can
adjust the suggested $INPUT text. Say you plan to use CONC as
DV in Nonmem, use copy=c(DV=&quot;CONC&quot;),
i.e. copy=c(newname=&quot;existing&quot;). INPUT suggestion will in this
case contain DV=CONC.</p>
</td></tr>
<tr><td><code id="NMgenText_+3A_file">file</code></td>
<td>
<p>The file name NONMEM will read the data from (for the
$DATA section). It can be a full path.</p>
</td></tr>
<tr><td><code id="NMgenText_+3A_dir.data">dir.data</code></td>
<td>
<p>For the $DATA text proposal only. The path to the
input datafile to be used in the Nonmem $DATA section. Often,
a relative path to the actual Nonmem run is wanted here. If
this is used, only the file name and not the path from the
file argument is used.</p>
</td></tr>
<tr><td><code id="NMgenText_+3A_capitalize">capitalize</code></td>
<td>
<p>For the $INPUT text proposal only. If TRUE, all
column names in $INPUT text will be converted to capital
letters.</p>
</td></tr>
<tr><td><code id="NMgenText_+3A_until">until</code></td>
<td>
<p>Use this to truncate the columns in $INPUT. until can
either be a character (column name) or a numeric (column
number). If a character is given, it is matched against the
resulting column name representation in $INPUT, i.e. this
could be &quot;DV=CONC&quot; if you are using in this case the copy
argument. In case until is of length&gt;1, the maximum will be
used (probably only interesting if character values are
supplied).</p>
</td></tr>
<tr><td><code id="NMgenText_+3A_allow.char.time">allow.char.TIME</code></td>
<td>
<p>For the $INPUT text proposal only. Assume
Nonmem can read TIME even if it can't be translated to
numeric. This is necessary if using the 00:00 format. Default
is TRUE.</p>
</td></tr>
<tr><td><code id="NMgenText_+3A_width">width</code></td>
<td>
<p>If positive, will be passed to strwrap for the $INPUT
text. If missing or NULL, strwrap will be called with default
value. If negative or zero, strwrap will not be called.</p>
</td></tr>
<tr><td><code id="NMgenText_+3A_quiet">quiet</code></td>
<td>
<p>Hold messages back? Default is defined by NMdataConf.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Text for inclusion in Nonmem control stream, invisibly. A
list with elements 'DATA' and 'INPUT'.
</p>


<h3>See Also</h3>

<p>Other Nonmem: 
<code><a href="#topic+NMapplyFilters">NMapplyFilters</a>()</code>,
<code><a href="#topic+NMextractText">NMextractText</a>()</code>,
<code><a href="#topic+NMreadSection">NMreadSection</a>()</code>,
<code><a href="#topic+NMreplaceDataFile">NMreplaceDataFile</a>()</code>,
<code><a href="#topic+NMwriteSection">NMwriteSection</a>()</code>
</p>

<hr>
<h2 id='NMinfo'>Get metadata from an NMdata object</h2><span id='topic+NMinfo'></span>

<h3>Description</h3>

<p>Extract metadata such as info on tables, columns and further
details in your favorite class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMinfo(data, info, as.fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMinfo_+3A_data">data</code></td>
<td>
<p>An object of class NMdata (a result of NMscanData)</p>
</td></tr>
<tr><td><code id="NMinfo_+3A_info">info</code></td>
<td>
<p>If not passed, all the metadata is returned. You can
use &quot;details&quot;, &quot;tables&quot;, or &quot;columns&quot; to get only these
subsets. If info is &quot;tables&quot; or &quot;columns&quot;</p>
</td></tr>
<tr><td><code id="NMinfo_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say tibble::as_tibble) in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of class as defined by as.fun in case info is
&quot;columns&quot; or &quot;tables&quot;. A list if info missing or equal to
&quot;details&quot;.
</p>

<hr>
<h2 id='NMisNumeric'>Test if a variable can be interpreted by Nonmem</h2><span id='topic+NMisNumeric'></span>

<h3>Description</h3>

<p>Nonmem can only interpret numeric data. However, a
factor or a character variable may very well be interpretable
by Nonmem (e.g. &quot;33&quot;). This function tells whether Nonmem will
be able to read it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMisNumeric(x, na.strings = ".", each = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMisNumeric_+3A_x">x</code></td>
<td>
<p>The vector to check Don't export</p>
</td></tr>
<tr><td><code id="NMisNumeric_+3A_na.strings">na.strings</code></td>
<td>
<p>Tolerated strings that do not translate to
numerics. Default is to accept &quot;.&quot; because it's common to
write missing values that way to Nonmem (even if Nonmem will
handle them as zeros rather than missing). Notice actual NA's
are accepted so you may want to use na.strings=NULL if you
don't code missings as &quot;.&quot; and just do this when writing the
data set to a delimited file (like NMwriteData will do for
you).</p>
</td></tr>
<tr><td><code id="NMisNumeric_+3A_each">each</code></td>
<td>
<p>Use each=TRUE to evaluate each element in a vector
individually. The default (each=FALSE) is to return a
single-length logical for a vector x summarizing whether all
the elements are numeric-compatible.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE or FALSE
</p>

<hr>
<h2 id='NMorderColumns'>Standardize column order in Nonmem input data</h2><span id='topic+NMorderColumns'></span>

<h3>Description</h3>

<p>Order data columns for easy export to Nonmem. No data values are
edited. The order is configurable through multiple arguments. See
details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMorderColumns(
  data,
  first,
  last,
  lower.last = FALSE,
  chars.last = TRUE,
  alpha = TRUE,
  col.id,
  col.nomtime,
  col.time,
  col.row,
  col.flagn,
  col.dv = "DV",
  as.fun = NULL,
  quiet
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMorderColumns_+3A_data">data</code></td>
<td>
<p>The dataset which columns to reorder.</p>
</td></tr>
<tr><td><code id="NMorderColumns_+3A_first">first</code></td>
<td>
<p>Columns that should come almost first. See details.</p>
</td></tr>
<tr><td><code id="NMorderColumns_+3A_last">last</code></td>
<td>
<p>Columns to move to back of dataset. If you work with a
large dataset, and some columns are irrelevant for the Nonmem
runs, you can use this argument.</p>
</td></tr>
<tr><td><code id="NMorderColumns_+3A_lower.last">lower.last</code></td>
<td>
<p>Should columns which names contain lowercase
characters be moved towards the back? Some people use a
standard of lowercase variables (say &quot;race&quot;) being character
representations (&quot;Asian&quot;, &quot;Caucasian&quot;, etc.) variables and the
uppercase (1,2,...) being the numeric representation for
Nonmem.</p>
</td></tr>
<tr><td><code id="NMorderColumns_+3A_chars.last">chars.last</code></td>
<td>
<p>Should columns which cannot be converted to
numeric be put towards the end? A column can be a character or
a factor in R, but still be valid in Nonmem (often the case
for ID which can only contain numeric digits but really is a
character or factor). So rather than only looking at the
column class, the columns are attempted converted to
numeric. Notice, it will attempted to be converted to numeric
to test whether Nonmem will be able to make sense of it, but
the values in the resulting dataset will be untouched. No
values will be edited. If TRUE, logicals will always be put
last. NA's must be NA or &quot;.&quot;.</p>
</td></tr>
<tr><td><code id="NMorderColumns_+3A_alpha">alpha</code></td>
<td>
<p>Sort columns alphabetically. Notice, this is the last
order priority applied.</p>
</td></tr>
<tr><td><code id="NMorderColumns_+3A_col.id">col.id</code></td>
<td>
<p>Name of the (numeric) unique subject ID. Can be
controlled with 'NMdataConf()'.</p>
</td></tr>
<tr><td><code id="NMorderColumns_+3A_col.nomtime">col.nomtime</code></td>
<td>
<p>The name of the column containing nominal
time. If given, it will put the column quite far left, just
after row counter and 'col.id'. Default value is NOMTIME and can be
configured with 'NMdataConf()'.</p>
</td></tr>
<tr><td><code id="NMorderColumns_+3A_col.time">col.time</code></td>
<td>
<p>The name of the column containing actual time. If
given, it will put the column quite far left, just after row
counter, subject ID, and nominal time. Default value is 'TIME'. Can be
controlled with 'NMdataConf()'.</p>
</td></tr>
<tr><td><code id="NMorderColumns_+3A_col.row">col.row</code></td>
<td>
<p>A row counter column. This will be the first column
in the dataset. Technically, you can use it for whatever
column you want first. Default value is 'ROW' and can be
configured with 'NMdataConf()'.</p>
</td></tr>
<tr><td><code id="NMorderColumns_+3A_col.flagn">col.flagn</code></td>
<td>
<p>The name of the column containing numerical flag
values for data row omission. Default value is FLAG and can be
configured with 'NMdataConf()'.</p>
</td></tr>
<tr><td><code id="NMorderColumns_+3A_col.dv">col.dv</code></td>
<td>
<p>a vector of column names to put early to represent
dependent variable(s). Default is DV.</p>
</td></tr>
<tr><td><code id="NMorderColumns_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return a data.table if data is a
data.table and return a data.frame in all other cases. Pass a
function in as.fun to convert to something else. The default
can be configured using 'NMdataConf()'. However, if data is a
data.table, settings via 'NMdataConf()' are ignored.</p>
</td></tr>
<tr><td><code id="NMorderColumns_+3A_quiet">quiet</code></td>
<td>
<p>If true, no warning will be given about missing
standard Nonmem columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will change the order of columns but it
will never edit values in any columns. The ordering is by the
following steps, each step depending on corresponding
argument.
</p>

<dl>
<dt>&quot;col.row - &quot;</dt><dd><p>Row id if argument row is non-NULL</p>
</dd>
<dt>&quot;not editable - &quot;</dt><dd><p>ID (if a column is called ID)</p>
</dd>
<dt>&quot;col.nomtime - &quot;</dt><dd><p>Nominal time.</p>
</dd>
<dt>&quot;col.time - &quot;</dt><dd><p>Actual time.</p>
</dd>
<dt>&quot;first - &quot;</dt><dd><p>user-specified first columns</p>
</dd>
<dt>&quot;Only col.dv editable - &quot;</dt><dd><p>Standard Nonmem columns: EVID, CMT, AMT, RATE, col.dv, MDV</p>
</dd>
<dt>&quot;last - &quot;</dt><dd><p>user-specified last columns</p>
</dd>
<dt>&quot;chars.last - &quot;</dt><dd><p>numeric, or interpretable as numeric</p>
</dd>
<dt>&quot;not editable - &quot;</dt><dd><p>less often used Nonmem names: col.flagn, OCC, ROUTE, GRP, TRIAL, DRUG, STUDY</p>
</dd>
<dt>&quot;lower.last - &quot;</dt><dd><p>lower case in name</p>
</dd>
<dt>&quot;alpha - &quot;</dt><dd><p>Alphabetic/numeric sorting</p>
</dd>
</dl>



<h3>Value</h3>

<p>data with modified column order.
</p>


<h3>See Also</h3>

<p>Other DataCreate: 
<code><a href="#topic+NMstamp">NMstamp</a>()</code>,
<code><a href="#topic+NMwriteData">NMwriteData</a>()</code>,
<code><a href="#topic+addTAPD">addTAPD</a>()</code>,
<code><a href="#topic+findCovs">findCovs</a>()</code>,
<code><a href="#topic+findVars">findVars</a>()</code>,
<code><a href="#topic+flagsAssign">flagsAssign</a>()</code>,
<code><a href="#topic+flagsCount">flagsCount</a>()</code>,
<code><a href="#topic+mergeCheck">mergeCheck</a>()</code>,
<code><a href="#topic+tmpcol">tmpcol</a>()</code>
</p>

<hr>
<h2 id='NMreadCov'>Read in data file</h2><span id='topic+NMreadCov'></span>

<h3>Description</h3>

<p>Read in data file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadCov(file, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMreadCov_+3A_file">file</code></td>
<td>
<p>The .cov covariance Nonmem matrix file to read</p>
</td></tr>
<tr><td><code id="NMreadCov_+3A_...">...</code></td>
<td>
<p>Passed to fread</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is taken from nonmem2rx::nmcov which was
based on NMdata::NMreadTab.
</p>


<h3>Value</h3>

<p>A matrix with covariance step from NONMEM
</p>


<h3>Author(s)</h3>

<p>Philip Delff and Matthew L. Fidler
</p>

<hr>
<h2 id='NMreadCsv'>Read input data formatted for Nonmem</h2><span id='topic+NMreadCsv'></span>

<h3>Description</h3>

<p>This function is especially useful if the csv file was written
using NMwriteData.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadCsv(
  file,
  args.fread,
  as.fun = NULL,
  format = fnExtension(file),
  args.fst
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMreadCsv_+3A_file">file</code></td>
<td>
<p>The file to read. Must be pure text.</p>
</td></tr>
<tr><td><code id="NMreadCsv_+3A_args.fread">args.fread</code></td>
<td>
<p>List of arguments passed to fread. Notice that
except for &quot;file&quot;, you need to supply all arguments to fread
if you use this argument. Default values can be configured
using NMdataConf.</p>
</td></tr>
<tr><td><code id="NMreadCsv_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say tibble::as_tibble) in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="NMreadCsv_+3A_format">format</code></td>
<td>
<p>Format of file to read. Can be of length&gt;1 in which
case the first format found will be used (i.e. format is a
prioritized vector). If not one of &quot;rds&quot; or &quot;fst&quot;, it is
assumed to be a delimited text file. Default is to determine
this from the file name extension. Notice, if a delimited
format is used, the extension can very well be different from
&quot;csv&quot; (say file name is
&quot;input.tab&quot;)&quot;. This will work for any delimited format supported by fread.</p>
</td></tr>
<tr><td><code id="NMreadCsv_+3A_args.fst">args.fst</code></td>
<td>
<p>Optional arguments to pass to <code>read_fst</code> if <code>format="fst"</code> is used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is almost just a shortcut to fread so you don't have to remember how to read the data that was exported for Nonmem. The only added feature is that meta data as written by NMwriteData is read and attached as NMdata metadata before data is returned.
</p>


<h3>Value</h3>

<p>A data set of class as defined by as.fun.
</p>


<h3>See Also</h3>

<p>NMwriteData
</p>
<p>Other DataRead: 
<code><a href="#topic+NMreadTab">NMreadTab</a>()</code>,
<code><a href="#topic+NMscanData">NMscanData</a>()</code>,
<code><a href="#topic+NMscanInput">NMscanInput</a>()</code>,
<code><a href="#topic+NMscanTables">NMscanTables</a>()</code>
</p>

<hr>
<h2 id='NMreadExt'>Read information from Nonmem ext files</h2><span id='topic+NMreadExt'></span>

<h3>Description</h3>

<p>Read information from Nonmem ext files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadExt(
  file,
  return,
  as.fun,
  modelname,
  col.model,
  auto.ext,
  tableno = "max",
  file.ext
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMreadExt_+3A_file">file</code></td>
<td>
<p>Path to the ext file</p>
</td></tr>
<tr><td><code id="NMreadExt_+3A_return">return</code></td>
<td>
<p>The .ext file contains both final parameter
estimates and iterations of the estimates. If
<code>return="pars"</code> (default) the final estimates are
returned in addition to what other parameter-level information
is found, like FIX, sd etc. as columns. If
<code>return="iterations"</code>, the iterations are returned. If
<code>return="both"</code>, both er returned, though in separate
data.frames compiled in a list.</p>
</td></tr>
<tr><td><code id="NMreadExt_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say tibble::as_tibble) in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="NMreadExt_+3A_modelname">modelname</code></td>
<td>
<p>See ?NMscanData</p>
</td></tr>
<tr><td><code id="NMreadExt_+3A_col.model">col.model</code></td>
<td>
<p>See ?NMscanData</p>
</td></tr>
<tr><td><code id="NMreadExt_+3A_auto.ext">auto.ext</code></td>
<td>
<p>If TRUE (default) the extension will automatically
be modified using 'NMdataConf()$file.ext'. This means 'file'
can be the path to an input or output control stream, and
'NMreadExt' will still read the '.ext' file.</p>
</td></tr>
<tr><td><code id="NMreadExt_+3A_tableno">tableno</code></td>
<td>
<p>In case the ext file contains multiple tables, this
argument controls which one to choose. The options are
</p>

<ul>
<li><p> &quot;max&quot; (default) Pick the table with the highest table
number. This typically means the results from the last
'$ESTIMATION' step are used.
</p>
</li>
<li><p> &quot;min&quot; Pick results from the first table available.
</p>
</li>
<li><p> &quot;all&quot; Keep all results. The tables can be distinguished by
the 'tableno' column.
</p>
</li>
<li><p> an integer greater than 0, in which case the table with this
table number will be picked.
</p>
</li></ul>
</td></tr>
<tr><td><code id="NMreadExt_+3A_file.ext">file.ext</code></td>
<td>
<p>Deprecated. Please use <code>file</code> instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter table returned if <code>return="pars"</code> or <code>return="all"</code> will contain columns based on the Nonmem 7.5 manual. It defines codes for different parameter-level values. They are:
</p>
<p>-1e+09: se
-1000000002: eigCor
-1000000003: cond
-1000000004: stdDevCor
-1000000005: seStdDevCor
-1000000006: FIX
-1000000007: termStat
-1000000008: partLik
</p>
<p>The parameter name is in the <code>parameter</code> column. The
&quot;parameter type&quot;, like &quot;THETA&quot;, &quot;OMEGA&quot;, &quot;SIGMA&quot; are available in
the <code>par.type</code> column. Counters are available in <code>i</code> and
<code>j</code> columns. <code>j</code> will be <code>NA</code> for
<code>par.type=="THETA"</code>
</p>
<p>The objective function value is included as a parameter.
</p>
<p>Notice that in case multiple tables are available in the 'ext'
file, the column names are taken from the first table. E.g., in
case of SAEM/IMP estimation, the objective function values will be
in the 'SAEMOBJ' column, even for the IMP step. This may change in
the future.
</p>


<h3>Value</h3>

<p>If <code>return="all"</code>, a list with a final parameter
table and a table of the iterations. If <code>return="pars"</code>,
only the parameter table, and if <code>return="iterations"</code>
only the iterations table. If you need both, it may be more
efficient to only read the file once and use
<code>return="all"</code>. Often, only one of the two are needed,
and it more convenient to just extract one.
</p>

<hr>
<h2 id='NMreadParsText'>Read comments to parameter definitions in Nonmem control streams</h2><span id='topic+NMreadParsText'></span>

<h3>Description</h3>

<p>When interpreting parameter estimates, it is often needed to
recover information about the meaning of the different parameters
from control stream. 'NMreadParsText' provides a flexible way to
organize the comments in the parameter sections into a
'data.frame'. This can subsequently easily be merged with parameter
values as obtained with 'NMreadExt'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadParsText(
  file,
  fields,
  fields.omega = fields,
  fields.sigma = fields.omega,
  use.theta.nums = FALSE,
  spaces.split = FALSE,
  modelname,
  col.model,
  as.fun
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMreadParsText_+3A_file">file</code></td>
<td>
<p>Path to the control stream to read.</p>
</td></tr>
<tr><td><code id="NMreadParsText_+3A_fields">fields</code></td>
<td>
<p>Defines naming and splitting of contents of lines in
parameter sections. Default is
<code>"%init;%symbol;%num;%label;%unit"</code>.</p>
</td></tr>
<tr><td><code id="NMreadParsText_+3A_fields.omega">fields.omega</code></td>
<td>
<p>Like 'fields', applied to '$OMEGA'
section. Default is to reuse 'fields'.</p>
</td></tr>
<tr><td><code id="NMreadParsText_+3A_fields.sigma">fields.sigma</code></td>
<td>
<p>Like 'fields', applied to '$SIGMA'
section. Default is to reuse 'fields.omega'.</p>
</td></tr>
<tr><td><code id="NMreadParsText_+3A_use.theta.nums">use.theta.nums</code></td>
<td>
<p>If the num field should be used to number
thetas. I do not see where this is advantageous to do.</p>
</td></tr>
<tr><td><code id="NMreadParsText_+3A_spaces.split">spaces.split</code></td>
<td>
<p>Is a blank in 'fields' to be treated as a
field seperator? Default is not to (i.e. neglect spaces in
'fields').</p>
</td></tr>
<tr><td><code id="NMreadParsText_+3A_modelname">modelname</code></td>
<td>
<p>See ?NMscanData</p>
</td></tr>
<tr><td><code id="NMreadParsText_+3A_col.model">col.model</code></td>
<td>
<p>See ?NMscanData</p>
</td></tr>
<tr><td><code id="NMreadParsText_+3A_as.fun">as.fun</code></td>
<td>
<p>See ?NMscanData</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Off-diagonal omega and sigma elements will only be
correctly treated if their num field specifies say 1-2 to
specify it is covariance between 1 and 2.
</p>

<hr>
<h2 id='NMreadPhi'>Read information from Nonmem phi files</h2><span id='topic+NMreadPhi'></span>

<h3>Description</h3>

<p>Read information from Nonmem phi files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadPhi(file, as.fun, modelname, col.model, auto.ext, file.phi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMreadPhi_+3A_file">file</code></td>
<td>
<p>Path to the phi file. If 'auto.ext=TRUE', the
extension will automatically be changed using the setting in
'NMdataConf()$file.fir' - this by default means that the
'.phi' extension will be used no matter what extension the
provided file name has.</p>
</td></tr>
<tr><td><code id="NMreadPhi_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say tibble::as_tibble) in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="NMreadPhi_+3A_modelname">modelname</code></td>
<td>
<p>See ?NMscanData</p>
</td></tr>
<tr><td><code id="NMreadPhi_+3A_col.model">col.model</code></td>
<td>
<p>See ?NMscanData</p>
</td></tr>
<tr><td><code id="NMreadPhi_+3A_auto.ext">auto.ext</code></td>
<td>
<p>If TRUE (default) the extension will automatically
be modified using 'NMdataConf()$file.phi'. This means 'file'
can be the path to an input or output control stream, and
'NMreadPhi' will still read the '.phi' file.</p>
</td></tr>
<tr><td><code id="NMreadPhi_+3A_file.phi">file.phi</code></td>
<td>
<p>Deprecated. Use 'file'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a final parameter table and a table of the iterations
</p>

<hr>
<h2 id='NMreadSection'>Extract sections of Nonmem control streams</h2><span id='topic+NMreadSection'></span><span id='topic+NMgetSection'></span>

<h3>Description</h3>

<p>This is a very commonly used wrapper for the input part of the
model file. Look NMextractText for more general functionality
suitable for the results part too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadSection(
  file = NULL,
  lines = NULL,
  text = NULL,
  section,
  return = "text",
  keep.empty = FALSE,
  keep.name = TRUE,
  keep.comments = TRUE,
  as.one = TRUE,
  clean.spaces = FALSE,
  simplify = TRUE,
  keepEmpty,
  keepName,
  keepComments,
  asOne,
  cleanSpaces,
  ...
)

NMgetSection(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMreadSection_+3A_file">file</code></td>
<td>
<p>A file path to read from. Normally a .mod or .lst. See
lines also.</p>
</td></tr>
<tr><td><code id="NMreadSection_+3A_lines">lines</code></td>
<td>
<p>Text lines to process. This is an alternative to
using the file argument.</p>
</td></tr>
<tr><td><code id="NMreadSection_+3A_text">text</code></td>
<td>
<p>Use this argument if the text to process is one long
character string, and indicate the line separator with the
linesep argument (handled by NMextractText). Use only one of
file, lines, and text.</p>
</td></tr>
<tr><td><code id="NMreadSection_+3A_section">section</code></td>
<td>
<p>The name of section to extract without
&quot;$&quot;. Examples: &quot;INPUT&quot;, &quot;PK&quot;, &quot;TABLE&quot;, etc. Not case
sensitive.</p>
</td></tr>
<tr><td><code id="NMreadSection_+3A_return">return</code></td>
<td>
<p>If &quot;text&quot;, plain text lines are returned. If &quot;idx&quot;,
matching line numbers are returned. &quot;text&quot; is default.</p>
</td></tr>
<tr><td><code id="NMreadSection_+3A_keep.empty">keep.empty</code></td>
<td>
<p>Keep empty lines in output? Default is
FALSE. Notice, comments are removed before empty lines are
handled if 'keep.comments=TRUE'.</p>
</td></tr>
<tr><td><code id="NMreadSection_+3A_keep.name">keep.name</code></td>
<td>
<p>Keep the section name in output (say, &quot;$PROBLEM&quot;)
Default is FALSE. It can only be FALSE, if return=&quot;text&quot;.</p>
</td></tr>
<tr><td><code id="NMreadSection_+3A_keep.comments">keep.comments</code></td>
<td>
<p>Default is to keep comments. If FALSE, the
will be removed.</p>
</td></tr>
<tr><td><code id="NMreadSection_+3A_as.one">as.one</code></td>
<td>
<p>If multiple hits, concatenate into one. This will
most often be relevant with name=&quot;TABLE&quot;. If FALSE, a list
will be returned, each element representing a table. Default
is TRUE. So if you want to process the tables separately, you
probably want FALSE here.</p>
</td></tr>
<tr><td><code id="NMreadSection_+3A_clean.spaces">clean.spaces</code></td>
<td>
<p>If TRUE, leading and trailing are removed, and
multiplied succeeding white spaces are reduced to single white
spaces.</p>
</td></tr>
<tr><td><code id="NMreadSection_+3A_simplify">simplify</code></td>
<td>
<p>If asOne=FALSE, do you want the result to be
simplified if only one section is found? Default is TRUE which
is desirable for interactive analysis. For programming, you
probably want FALSE.</p>
</td></tr>
<tr><td><code id="NMreadSection_+3A_keepempty">keepEmpty</code></td>
<td>
<p>Deprecated. See keep.empty.</p>
</td></tr>
<tr><td><code id="NMreadSection_+3A_keepname">keepName</code></td>
<td>
<p>Deprecated. See keep.name.</p>
</td></tr>
<tr><td><code id="NMreadSection_+3A_keepcomments">keepComments</code></td>
<td>
<p>Deprecated. See keep.comments.</p>
</td></tr>
<tr><td><code id="NMreadSection_+3A_asone">asOne</code></td>
<td>
<p>Deprecated. See as.one.</p>
</td></tr>
<tr><td><code id="NMreadSection_+3A_cleanspaces">cleanSpaces</code></td>
<td>
<p>Deprecated. See clean.spaces.</p>
</td></tr>
<tr><td><code id="NMreadSection_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to NMextractText</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector with extracted lines.
</p>
<p>character vector with extracted lines.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>NMgetSection</code>: Deprecated function name. Use NMreadSection.
</p>
</li></ul>


<h3>See Also</h3>

<p>Other Nonmem: 
<code><a href="#topic+NMapplyFilters">NMapplyFilters</a>()</code>,
<code><a href="#topic+NMextractText">NMextractText</a>()</code>,
<code><a href="#topic+NMgenText">NMgenText</a>()</code>,
<code><a href="#topic+NMreplaceDataFile">NMreplaceDataFile</a>()</code>,
<code><a href="#topic+NMwriteSection">NMwriteSection</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NMreadSection(system.file("examples/nonmem/xgxr001.lst", package="NMdata"),section="DATA")

</code></pre>

<hr>
<h2 id='NMreadTab'>Read an output table file from Nonmem</h2><span id='topic+NMreadTab'></span>

<h3>Description</h3>

<p>Read a table generated by a $TABLE statement in Nonmem. Generally,
these files cannot be read by read.table or similar because
formatting depends on options in the $TABLE statement, and because
Nonmem sometimes includes extra lines in the output that have to
be filtered out. NMreadTab can do this automatically based on the
table file alone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreadTab(
  file,
  col.tableno,
  col.nmrep,
  col.table.name,
  header = TRUE,
  skip,
  quiet = TRUE,
  as.fun,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMreadTab_+3A_file">file</code></td>
<td>
<p>path to Nonmem table file</p>
</td></tr>
<tr><td><code id="NMreadTab_+3A_col.tableno">col.tableno</code></td>
<td>
<p>In case of simulations where tables are being
repeated, a counter of the repetition number can be useful to
include in the output. For now, this will only work if the
NOHEADER option is not used. This is because NMreadTab
searches for the &quot;TABLE NO...&quot; strings in Nonmem output
tables. If col.tableno is TRUE (default), a counter of tables
is included as a column called NMREP. Notice, the table
numbers in NMREP are cumulatively counting the number of
tables reported in the file. NMREP is not the actual table
number as given by Nonmem.</p>
</td></tr>
<tr><td><code id="NMreadTab_+3A_col.nmrep">col.nmrep</code></td>
<td>
<p>col.nmrep If tables are repeated, include a
counter? It does not relate to the order of the $TABLE
statements but to cases where a $TABLE statement is run
repeatedly. E.g., in combination with the SUBPROBLEMS feature
in Nonmem, it is useful to keep track of the table
(repetition) number. If col.nmrep is TRUE, this will be
carried forward and added as a column called NMREP. This is
default behavior when more than one $TABLE repetition is found
in data. Set it to a different string to request the column
with a different name. The argument is passed to NMscanTables.</p>
</td></tr>
<tr><td><code id="NMreadTab_+3A_col.table.name">col.table.name</code></td>
<td>
<p>The name of a column containing the name or
description of the table (generated by Nonmem). The default is
&quot;table.name&quot;. Use FALSE not to include this column.</p>
</td></tr>
<tr><td><code id="NMreadTab_+3A_header">header</code></td>
<td>
<p>Use header=FALSE if table was created with NOHEADER
option in $TABLE.</p>
</td></tr>
<tr><td><code id="NMreadTab_+3A_skip">skip</code></td>
<td>
<p>The number of rows to skip. The default is skip=1 if
header==TRUE and skip=0 if header==FALSE.</p>
</td></tr>
<tr><td><code id="NMreadTab_+3A_quiet">quiet</code></td>
<td>
<p>logical stating whether or not information is printed
about what is being done. Default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="NMreadTab_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say tibble::as_tibble) in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="NMreadTab_+3A_...">...</code></td>
<td>
<p>Arguments passed to fread.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The actual reading of data is based on
data.table::fread. Generally, the function is fast thanks to
data.table.
</p>


<h3>Value</h3>

<p>The Nonmem table data.
</p>


<h3>See Also</h3>

<p>Other DataRead: 
<code><a href="#topic+NMreadCsv">NMreadCsv</a>()</code>,
<code><a href="#topic+NMscanData">NMscanData</a>()</code>,
<code><a href="#topic+NMscanInput">NMscanInput</a>()</code>,
<code><a href="#topic+NMscanTables">NMscanTables</a>()</code>
</p>

<hr>
<h2 id='NMreplaceDataFile'>Replace data file used in Nonmem control stream</h2><span id='topic+NMreplaceDataFile'></span>

<h3>Description</h3>

<p>Replace data file used in Nonmem control stream
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMreplaceDataFile(files, file.pattern, dir, path.data, newfile = file.mod, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMreplaceDataFile_+3A_files">files</code></td>
<td>
<p>Paths to input control streams to modify. See
file.pattern and dir too.</p>
</td></tr>
<tr><td><code id="NMreplaceDataFile_+3A_file.pattern">file.pattern</code></td>
<td>
<p>A pattern to look for if 'dir' is supplied too
(and not 'file.mod'). This is used to modify multiple input
control streams at once.</p>
</td></tr>
<tr><td><code id="NMreplaceDataFile_+3A_dir">dir</code></td>
<td>
<p>Directory in which to look for 'file.pattern'. Notice,
use either just 'file.mod' or both 'dir' and 'file.pattern'.</p>
</td></tr>
<tr><td><code id="NMreplaceDataFile_+3A_path.data">path.data</code></td>
<td>
<p>Path to input control stream to use in newfile</p>
</td></tr>
<tr><td><code id="NMreplaceDataFile_+3A_newfile">newfile</code></td>
<td>
<p>A path to a new control stream to write to (and
don't edit contents of 'file.mod'). Default is to overwrite 'file.mod'.</p>
</td></tr>
<tr><td><code id="NMreplaceDataFile_+3A_...">...</code></td>
<td>
<p>Additional arguments to pass to NMwriteSection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lines for a new control stream (invisibly)
</p>


<h3>See Also</h3>

<p>Other Nonmem: 
<code><a href="#topic+NMapplyFilters">NMapplyFilters</a>()</code>,
<code><a href="#topic+NMextractText">NMextractText</a>()</code>,
<code><a href="#topic+NMgenText">NMgenText</a>()</code>,
<code><a href="#topic+NMreadSection">NMreadSection</a>()</code>,
<code><a href="#topic+NMwriteSection">NMwriteSection</a>()</code>
</p>

<hr>
<h2 id='NMscanData'>Automatically find Nonmem input and output tables and organize data</h2><span id='topic+NMscanData'></span>

<h3>Description</h3>

<p>This is a very general solution to automatically identifying, reading, and  merging all output and input data in a Nonmem model. The most important
steps are
</p>

<ul>
<li><p>Read and combine output tables,
</p>
</li>
<li><p>If wanted, read input data and restore variables that were not output from the Nonmem model
</p>
</li>
<li><p>If wanted, also restore rows from input data that were disregarded in
Nonmem (e.g. observations or subjects that are not part of the analysis)

</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>NMscanData(
  file,
  col.row,
  use.input,
  merge.by.row,
  recover.rows,
  file.mod,
  dir.data,
  file.data,
  translate.input = TRUE,
  quiet,
  formats.read,
  args.fread,
  as.fun,
  col.id = "ID",
  modelname,
  col.model,
  col.nmout,
  col.nmrep,
  order.columns = TRUE,
  check.time,
  tz.lst,
  skip.absent = FALSE,
  tab.count,
  use.rds
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMscanData_+3A_file">file</code></td>
<td>
<p>Path to a Nonmem control stream or output file from
Nonmem (.mod or .lst)</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_col.row">col.row</code></td>
<td>
<p>A column with a unique value for each row. Such a
column is recommended to use if possible. See merge.by.row and
details as well. Default (&quot;ROW&quot;) can be modified using
NMdataConf.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_use.input">use.input</code></td>
<td>
<p>Should the input data be added to the output
data. Only column names that are not found in output data will
be retrieved from the input data. Default is TRUE which can be
modified using NMdataConf. See merge.by.row too.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_merge.by.row">merge.by.row</code></td>
<td>
<p>If use.input=TRUE, this argument determines
the method by which the input data is added to output
data. The default method (merge.by.row=FALSE) is to interpret
the Nonmem code to imitate the data filtering (IGNORE and
ACCEPT statements), but the recommended method is
merge.by.row=TRUE which means that data will be merged by a
unique row identifier. The row identifier must be present in
input and at least one full length output data table. See
argument col.row too.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_recover.rows">recover.rows</code></td>
<td>
<p>Include rows from input data files that do not
exist in output tables? This will be added to the $row dataset
only, and $run, $id, and $occ datasets are created before this
is taken into account. A column called nmout will be TRUE when
the row was found in output tables, and FALSE when
not. Default is FALSE and can be configured using NMdataConf.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_file.mod">file.mod</code></td>
<td>
<p>The input control stream file path. Default is to
look for \&quot;file\&quot; with extension changed to .mod (PSN
style). You can also supply the path to the file, or you can
provide a function that translates the output file path to the
input file path. The default behavior can be configured using
NMdataConf. See dir.data too.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_dir.data">dir.data</code></td>
<td>
<p>The data directory can only be read from the
control stream (.mod) and not from the output file (.lst). So
if you only have the output control stream, use dir.data to
tell in which directory to find the data file. If dir.data is
provided, the .mod file is not used at all.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_file.data">file.data</code></td>
<td>
<p>Specification of the data file path. When this is
used, the control streams are not used at all.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_translate.input">translate.input</code></td>
<td>
<p>Default is TRUE, meaning that input data
column names are translated according to $INPUT section in
Nonmem listing file.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_quiet">quiet</code></td>
<td>
<p>The default is to give some information along the way
on what data is found. But consider setting this to TRUE for
non-interactive use. Default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_formats.read">formats.read</code></td>
<td>
<p>Prioritized input data file formats to look
for and use if found. Default is c(&quot;rds&quot;,&quot;csv&quot;) which means
<code>rds</code> will be used if found, and <code>csv</code> if
not. <code>fst</code> is possible too. Default can be modified using
<code>NMdataConf()</code>.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_args.fread">args.fread</code></td>
<td>
<p>List of arguments passed to when reading _input_
data. Notice that except for &quot;input&quot; and &quot;file&quot;, you need to
supply all arguments to fread if you use this
argument. Default values can be configured using NMdataConf.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say tibble::as_tibble) in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_col.id">col.id</code></td>
<td>
<p>The name of the subject ID variable, default is
&quot;ID&quot;.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_modelname">modelname</code></td>
<td>
<p>The model name to be stored if col.model is not
NULL. If not supplied, the name will be taken from the control
stream file name by omitting the directory/path and deleting
the .lst extension (path/run001.lst becomes run001). This can
be a character string or a function which is called on the
value of file (file is another argument to NMscanData). The
function must take one character argument and return another
character string. As example, see NMdataConf()$modelname. The
default can be configured using NMdataConf.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_col.model">col.model</code></td>
<td>
<p>A column of this name containing the model name
will be included in the returned data. The default is to store
this in a column called &quot;model&quot;. See argument &quot;modelname&quot; as
well. Set to NULL if not wanted. Default can be configured
using NMdataConf.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_col.nmout">col.nmout</code></td>
<td>
<p>A column of this name will be a logical
representing whether row was in output table or not. Default
can be modified using NMdataConf.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_col.nmrep">col.nmrep</code></td>
<td>
<p>If tables are repeated, include a counter? It
does not relate to the order of the $TABLE statements but to
cases where a $TABLE statement is run repeatedly. E.g., in
combination with the SUBPROBLEMS feature in Nonmem, it is
useful to keep track of the table (repetition) number. If
col.nmrep is TRUE, this will be carried forward and added as a
column called NMREP. This is default behavior when more than
one $TABLE repetition is found in data. Set it to a different
string to request the column with a different name. The
argument is passed to NMscanTables.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_order.columns">order.columns</code></td>
<td>
<p>If TRUE (default), NMorderColumns is used to
reorder the columns before returning the data. NMorderColumns
will be called with alpha=FALSE, so columns are not sorted
alphabetically. But standard Nonmem columns like ID, TIME, and
other will be first. If col.row is used, this will be passed
to NMorderColumns too.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_check.time">check.time</code></td>
<td>
<p>If TRUE (default) and if input data is used,
input control stream and input data are checked to be newer
than output control stream and output tables. These are
important assumptions for the way information is merged by
NMscanData. However, if data has been transferred from another
system where Nonmem was run, these checks may not make sense,
and you may not want to see these warnings. The default can be
configured using NMdataConf. For the output control stream,
the time stamp recorded by Nonmem is used if possible, and if
the input data is created with NMwriteData, the recorded
creation time is used if possible. If not, and for all other
files, the file modification times are used.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_tz.lst">tz.lst</code></td>
<td>
<p>If supplied, the timezone to be used when reading
the time stamp in the output control stream. Please supply
something listed in OlsonNames(). Can be configured using
NMdataConf() too.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_skip.absent">skip.absent</code></td>
<td>
<p>Skip missing output table files with a warning?
Default is FALSE in which case an error is thrown.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_tab.count">tab.count</code></td>
<td>
<p>Deprecated. Use <code>col.tableno</code>.</p>
</td></tr>
<tr><td><code id="NMscanData_+3A_use.rds">use.rds</code></td>
<td>
<p>Deprecated - use <code>formats.read</code> instead. If
provided (though not recommended), this will overwrite
<code>formats.read</code>, and only formats <code>rds</code> and
<code>csv</code> can be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function makes it very easy to collect the data from
a Nonmem run.
</p>
<p>A useful feature of this function is that it can automatically
combine &quot;input&quot; data (the data read by Nonmem in $INPUT or
$INFILE) with &quot;output&quot; data (tables written by Nonmem in
$TABLE). There are two implemented methods for doing so. One (the
default but not recommended) relies on interpretation of filter
(IGNORE and ACCEPT) statements in $INPUT. This will work in most
cases, and checks for consistency with Nonmem results. However,
the recommended method is using a unique row identifier in both
input data and at least one output data file (not a FIRSTONLY or
LASTONLY table). Supply the name of this column using the col.row
argument.
</p>
<p>Limitations. A number of Nonmem features are not supported. Most
of this can be overcome by using merge.by.row=TRUE. Incomplete
list of known limitations:
</p>

<dl>
<dt>character TIME</dt><dd><p>If Nonmem is used to translate DAY and a character TIME column, TIME has to be available in an output table. NMscanData does not do the translation to numeric.</p>
</dd>
<dt>RECORDS</dt><dd><p>The RECORDS option to limit the part of the input data being used is not searched for. Using merge.by.row=TRUE will work unaffectedly.</p>
</dd>
<dt>NULL</dt><dd><p>The NULL argument to specify missing value string in input data is not respected. If delimited input data is read (as opposed to rds files), missing values are assumed to be represented by dots (.).</p>
</dd>
</dl>



<h3>Value</h3>

<p>A data set of class 'NMdata'.
</p>


<h3>See Also</h3>

<p>Other DataRead: 
<code><a href="#topic+NMreadCsv">NMreadCsv</a>()</code>,
<code><a href="#topic+NMreadTab">NMreadTab</a>()</code>,
<code><a href="#topic+NMscanInput">NMscanInput</a>()</code>,
<code><a href="#topic+NMscanTables">NMscanTables</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
res1 &lt;- NMscanData(system.file("examples/nonmem/xgxr001.lst", package="NMdata"))

## End(Not run)
</code></pre>

<hr>
<h2 id='NMscanInput'>Find and read input data and optionally translate column names
according to the $INPUT section</h2><span id='topic+NMscanInput'></span>

<h3>Description</h3>

<p>This function finds and reads the input data based on a control
stream file path. It can align the column names to the definitions
in $INPUT in the control stream, and it can subset the data based
on ACCEPT/IGNORE statements in $DATA. It supports a few other ways
to identify the input data file than reading the control stream,
and it can also read an rds or fst file instead of the delimited
text file used by Nonmem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMscanInput(
  file,
  formats.read,
  file.mod,
  dir.data = NULL,
  file.data = NULL,
  apply.filters = FALSE,
  translate = TRUE,
  recover.cols = TRUE,
  details = TRUE,
  col.id = "ID",
  col.row,
  quiet,
  args.fread,
  invert = FALSE,
  as.fun,
  applyFilters,
  use.rds
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMscanInput_+3A_file">file</code></td>
<td>
<p>a .lst (output) or a .mod (input) control stream
file. The filename does not need to end in .lst. It is
recommended to use the output control stream because it
reflects the model as it was run rather than how it is planned
for next run. However, see file.mod and dir.data.</p>
</td></tr>
<tr><td><code id="NMscanInput_+3A_formats.read">formats.read</code></td>
<td>
<p>Prioritized input data file formats to look
for and use if found. Default is c(&quot;rds&quot;,&quot;csv&quot;) which means
<code>rds</code> will be used if found, and <code>csv</code> if
not. <code>fst</code> is possible too. Default can be modified using
<code>NMdataConf()</code>.</p>
</td></tr>
<tr><td><code id="NMscanInput_+3A_file.mod">file.mod</code></td>
<td>
<p>The input control stream file path. Default is to
look for \&quot;file\&quot; with extension changed to .mod (PSN
style). You can also supply the path to the file, or you can
provide a function that translates the output file path to the
input file path. If dir.data is missing, the input control
stream is needed. This is because the .lst does not contain
the path to the data file. The .mod file is only used for
finding the data file. How to interpret the datafile is read
from the .lst file. The default can be configured using
NMdataConf. See dir.data too.</p>
</td></tr>
<tr><td><code id="NMscanInput_+3A_dir.data">dir.data</code></td>
<td>
<p>The data directory can only be read from the
control stream (.mod) and not from the output file (.lst). So
if you only have the output file, use dir.data to tell in
which directory to find the data file. If dir.data is
provided, the .mod file is not used at all.</p>
</td></tr>
<tr><td><code id="NMscanInput_+3A_file.data">file.data</code></td>
<td>
<p>Specification of the data file path. When this is
used, the control streams are not used at all.</p>
</td></tr>
<tr><td><code id="NMscanInput_+3A_apply.filters">apply.filters</code></td>
<td>
<p>If TRUE (default), IGNORE and ACCEPT
statements in the Nonmem control streams are applied before
returning the data.</p>
</td></tr>
<tr><td><code id="NMscanInput_+3A_translate">translate</code></td>
<td>
<p>If TRUE (default), data columns are named as
interpreted by Nonmem (in $INPUT). If data file contains more
columns than mentioned in $INPUT, these will be named as in
data file (if data file contains named variables).</p>
</td></tr>
<tr><td><code id="NMscanInput_+3A_recover.cols">recover.cols</code></td>
<td>
<p>recover columns that were not used in the
Nonmem control stream? Default is TRUE. Can only be negative
when translate=FALSE.</p>
</td></tr>
<tr><td><code id="NMscanInput_+3A_details">details</code></td>
<td>
<p>If TRUE, metadata is added to output. In this case,
you get a list. Typically, this is mostly useful if
programming up functions which behavior must depend on
properties of the output. See details.</p>
</td></tr>
<tr><td><code id="NMscanInput_+3A_col.id">col.id</code></td>
<td>
<p>The name of the subject ID column. Optional and only
used to calculate number of subjects in data. Default is
modified by NMdataConf.</p>
</td></tr>
<tr><td><code id="NMscanInput_+3A_col.row">col.row</code></td>
<td>
<p>The name of the row counter column. Optional and only
used to check whether the row counter is in the data.</p>
</td></tr>
<tr><td><code id="NMscanInput_+3A_quiet">quiet</code></td>
<td>
<p>Default is to inform a little, but TRUE is useful for
non-interactive stuff.</p>
</td></tr>
<tr><td><code id="NMscanInput_+3A_args.fread">args.fread</code></td>
<td>
<p>List of arguments passed to fread. Notice that
except for &quot;input&quot; and &quot;file&quot;, you need to supply all
arguments to fread if you use this argument. Default values
can be configured using NMdataConf.</p>
</td></tr>
<tr><td><code id="NMscanInput_+3A_invert">invert</code></td>
<td>
<p>If TRUE, the data rows that are dismissed by the
Nonmem data filters (ACCEPT and IGNORE) and only this will be
returned. Only used if apply.filters is TRUE.</p>
</td></tr>
<tr><td><code id="NMscanInput_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say tibble::as_tibble) in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="NMscanInput_+3A_applyfilters">applyFilters</code></td>
<td>
<p>Deprecated - use apply.filters.</p>
</td></tr>
<tr><td><code id="NMscanInput_+3A_use.rds">use.rds</code></td>
<td>
<p>Deprecated - use <code>formats.read</code> instead. If
provided (though not recommended), this will overwrite
<code>formats.read</code>, and only formats <code>rds</code> and
<code>csv</code> can be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Columns that are dropped (using DROP or SKIP in $INPUT)
in the model will be included in the output.
</p>
<p>It may not work if a column is dropped, and a new column is
renamed to the same name. Say you have DV and CONC as the only two
columns (not possible but illustrative), and in Nonmem you do
DV=DROP DV. Not sure it will work in Nonmem, and it probably won't
work in NMscanInput.
</p>


<h3>Value</h3>

<p>A data set, class defined by 'as.fun'
</p>


<h3>See Also</h3>

<p>Other DataRead: 
<code><a href="#topic+NMreadCsv">NMreadCsv</a>()</code>,
<code><a href="#topic+NMreadTab">NMreadTab</a>()</code>,
<code><a href="#topic+NMscanData">NMscanData</a>()</code>,
<code><a href="#topic+NMscanTables">NMscanTables</a>()</code>
</p>

<hr>
<h2 id='NMscanMultiple'>Run NMscanData on multiple models and stack results</h2><span id='topic+NMscanMultiple'></span>

<h3>Description</h3>

<p>Useful function for meta analyses when multiple models are stored
in one folder and can be read with NMscanData using the same
arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMscanMultiple(files, dir, file.pattern, as.fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMscanMultiple_+3A_files">files</code></td>
<td>
<p>File paths to the models (control stream) to
edit. See file.pattern too.</p>
</td></tr>
<tr><td><code id="NMscanMultiple_+3A_dir">dir</code></td>
<td>
<p>The directory in which to find the models. Passed to
list.files(). See file.pattern argument too.</p>
</td></tr>
<tr><td><code id="NMscanMultiple_+3A_file.pattern">file.pattern</code></td>
<td>
<p>The pattern used to match the filenames to
read with NMscanData. Passed to list.files(). If <code>dir</code> is
supplied and <code>files</code> is not (or is <code>NULL</code>), the
default is <code>".*\.lst"</code> which means all files ending in
'<code>.lst</code>'. See <code>dir</code> argument too.</p>
</td></tr>
<tr><td><code id="NMscanMultiple_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say tibble::as_tibble) in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="NMscanMultiple_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to NMscanData.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All results stacked, class as defined by as.fun
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
res &lt;- NMscanMultiple(dir=system.file("examples/nonmem", package="NMdata"),
file.pattern="xgxr01.*\\.lst",as.fun="data.table")
res.mean &lt;- res[,.(meanPRED=exp(mean(log(PRED)))),by=.(model,NOMTIME)]
library(ggplot2)
ggplot(res.mean,aes(NOMTIME,meanPRED,colour=model))+geom_line()

## End(Not run)
</code></pre>

<hr>
<h2 id='NMscanTables'>Find and read all output data tables in Nonmem run</h2><span id='topic+NMscanTables'></span>

<h3>Description</h3>

<p>Find and read all output data tables in Nonmem run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMscanTables(
  file,
  as.fun,
  quiet,
  col.nmrep = TRUE,
  col.tableno = FALSE,
  col.id = "ID",
  col.row,
  details,
  skip.absent = FALSE,
  meta.only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMscanTables_+3A_file">file</code></td>
<td>
<p>the Nonmem file to read (normally .mod or .lst)</p>
</td></tr>
<tr><td><code id="NMscanTables_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say tibble::as_tibble) in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="NMscanTables_+3A_quiet">quiet</code></td>
<td>
<p>The default is to give some information along the way
on what data is found. But consider setting this to TRUE for
non-interactive use. Default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="NMscanTables_+3A_col.nmrep">col.nmrep</code></td>
<td>
<p>col.nmrep If tables are repeated, include a
counter? It does not relate to the order of the $TABLE
statements but to cases where a $TABLE statement is run
repeatedly. E.g., in combination with the SUBPROBLEMS feature
in Nonmem, it is useful to keep track of the table
(repetition) number. If col.nmrep is TRUE, this will be
carried forward and added as a column called NMREP. This is
default behavior when more than one $TABLE repetition is found
in data. Set it to a different string to request the column
with a different name. The argument is passed to NMscanTables.</p>
</td></tr>
<tr><td><code id="NMscanTables_+3A_col.tableno">col.tableno</code></td>
<td>
<p>Nonmem includes a counter of tables in the
written data files. These are often not useful. However, if
col.tableno is TRUE (not default), this will be carried forward
and added as a column called NMREP. Even if NMREP is generated
by NMscanTables, it is treated like any other table column in
meta (?NMinfo) data.</p>
</td></tr>
<tr><td><code id="NMscanTables_+3A_col.id">col.id</code></td>
<td>
<p>name of the subject ID column. Used for calculation
of the number of subjects in each table.</p>
</td></tr>
<tr><td><code id="NMscanTables_+3A_col.row">col.row</code></td>
<td>
<p>The name of the row counter column. Optional and
only used to check whether the row counter is in the data.</p>
</td></tr>
<tr><td><code id="NMscanTables_+3A_details">details</code></td>
<td>
<p>If TRUE, metadata is added to output. In this case,
you get a list. Typically, this is mostly useful if
programming up functions which behavior must depend on
properties of the output.</p>
</td></tr>
<tr><td><code id="NMscanTables_+3A_skip.absent">skip.absent</code></td>
<td>
<p>Skip missing output table files with a warning?
Default is FALSE in which case an error is thrown.</p>
</td></tr>
<tr><td><code id="NMscanTables_+3A_meta.only">meta.only</code></td>
<td>
<p>If TRUE, tables are not read, only a table is
returned showing what tables were found and some available
meta information. Notice, not all meta information (e.g.,
dimensions) are available because the tables need to be read
to derive that.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of all the tables as data.frames. If details=TRUE,
this is in one element, called data, and meta is another
element. If not, only the data is returned.
</p>


<h3>See Also</h3>

<p>Other DataRead: 
<code><a href="#topic+NMreadCsv">NMreadCsv</a>()</code>,
<code><a href="#topic+NMreadTab">NMreadTab</a>()</code>,
<code><a href="#topic+NMscanData">NMscanData</a>()</code>,
<code><a href="#topic+NMscanInput">NMscanInput</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tabs1 &lt;- NMscanTables(system.file("examples/nonmem/xgxr001.lst", package="NMdata"))
</code></pre>

<hr>
<h2 id='NMstamp'>stamp a dataset or any other object</h2><span id='topic+NMstamp'></span>

<h3>Description</h3>

<p>Dataset metadata can be valuable, eg. by tracing an archived dataset
back to the code that generated it. The metadata added by
NMstamp can be accessed using the function NMinfo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMstamp(data, script, time = Sys.time(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMstamp_+3A_data">data</code></td>
<td>
<p>The dataset to stamp.</p>
</td></tr>
<tr><td><code id="NMstamp_+3A_script">script</code></td>
<td>
<p>path to the script where the dataset was generated.</p>
</td></tr>
<tr><td><code id="NMstamp_+3A_time">time</code></td>
<td>
<p>the time stamp to attach. Default is to use cpu clock.</p>
</td></tr>
<tr><td><code id="NMstamp_+3A_...">...</code></td>
<td>
<p>other named metadata elements to add to the dataset. Example:
Description=&quot;PK data for phase 1 trials in project&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NMstamp modifies the meta data by reference. See example.
</p>


<h3>Value</h3>

<p>data with meta data attached. Class unchanged.
</p>


<h3>See Also</h3>

<p>NMinfo
</p>
<p>Other DataCreate: 
<code><a href="#topic+NMorderColumns">NMorderColumns</a>()</code>,
<code><a href="#topic+NMwriteData">NMwriteData</a>()</code>,
<code><a href="#topic+addTAPD">addTAPD</a>()</code>,
<code><a href="#topic+findCovs">findCovs</a>()</code>,
<code><a href="#topic+findVars">findVars</a>()</code>,
<code><a href="#topic+flagsAssign">flagsAssign</a>()</code>,
<code><a href="#topic+flagsCount">flagsCount</a>()</code>,
<code><a href="#topic+mergeCheck">mergeCheck</a>()</code>,
<code><a href="#topic+tmpcol">tmpcol</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x=1
NMstamp(x,script="example.R",description="Example data")
NMinfo(x)
</code></pre>

<hr>
<h2 id='NMtransInp'>translate the column names according to the $INPUT section of a control stream</h2><span id='topic+NMtransInp'></span>

<h3>Description</h3>

<p>translate the column names according to the $INPUT section of a control stream
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMtransInp(data, file, translate = TRUE, recover.cols = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMtransInp_+3A_data">data</code></td>
<td>
<p>the data to translate</p>
</td></tr>
<tr><td><code id="NMtransInp_+3A_file">file</code></td>
<td>
<p>the list file or control stream</p>
</td></tr>
<tr><td><code id="NMtransInp_+3A_translate">translate</code></td>
<td>
<p>logical. Do translation according to Nonmem code
or not? If not, an overview of column names in data and in
Nonmem code is still returned with the data.</p>
</td></tr>
<tr><td><code id="NMtransInp_+3A_recover.cols">recover.cols</code></td>
<td>
<p>recover columns that were not used in the
NONMEM control stream? Default is TRUE. Can only be negative
when translate=FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data with column names translated as specified by nonmem
control stream. Class same as for 'data' argument. Class
data.table.
</p>

<hr>
<h2 id='NMwriteData'>Write dataset for use in Nonmem (and R)</h2><span id='topic+NMwriteData'></span>

<h3>Description</h3>

<p>Instead of trying to remember the arguments to pass to write.csv,
use this wrapper. It tells you what to write in $DATA and $INPUT
in Nonmem, and it (additionally) exports an rds file as
well which is highly preferable for use in R. It never edits the
data before writing the datafile. The filenames for csv, rds
etc. are derived by replacing the extension to the filename given
in the file argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMwriteData(
  data,
  file,
  formats.write = c("csv", "rds"),
  script,
  args.stamp,
  args.fwrite,
  args.rds,
  args.RData,
  args.write_fst,
  quiet,
  args.NMgenText,
  csv.trunc.as.nm = FALSE,
  genText = TRUE,
  save = TRUE,
  write.csv,
  write.rds,
  write.RData,
  nm.drop,
  nmdir.data,
  col.flagn,
  nm.rename,
  nm.copy,
  nm.capitalize,
  allow.char.TIME
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMwriteData_+3A_data">data</code></td>
<td>
<p>The dataset to write to file for use in Nonmem.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_file">file</code></td>
<td>
<p>The file to write to. The extension (everything after
and including last &quot;.&quot;) is dropped. csv, rds and other
standard file name extensions are added.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_formats.write">formats.write</code></td>
<td>
<p>character vector of formats.write. Default is
c(&quot;csv&quot;,&quot;rds&quot;). &quot;fst&quot; is possible too. Default can be modified
with <code>NMdataConf()</code>.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_script">script</code></td>
<td>
<p>If provided, the object will be stamped with this
script name before saved to rds or RData. See ?NMstamp.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_args.stamp">args.stamp</code></td>
<td>
<p>A list of arguments to be passed to NMstamp.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_args.fwrite">args.fwrite</code></td>
<td>
<p>List of arguments passed to fwrite. Notice that
except for &quot;x&quot; and &quot;file&quot;, you need to supply all arguments to
fwrite if you use this argument. Default values can be
configured using NMdataConf.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_args.rds">args.rds</code></td>
<td>
<p>A list of arguments to be passed to saveRDS.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_args.rdata">args.RData</code></td>
<td>
<p>A list of arguments to be passed to save. Please
note that writing RData is deprecated.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_args.write_fst">args.write_fst</code></td>
<td>
<p>An optional list of arguments to be passed
to write_fst.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_quiet">quiet</code></td>
<td>
<p>The default is to give some information along the way
on what data is found. But consider setting this to TRUE for
non-interactive use. Default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_args.nmgentext">args.NMgenText</code></td>
<td>
<p>List of arguments to pass to NMgenText - the
function that generates text suggestion for INPUT and DATA
sections in the Nonmem control stream. You can use these
arguments to get a text suggestion you an use directly in
Nonmem - and <code>NMwriteSection</code> can even update multiple
Nonmem control streams based on the result. This will update
your control streams to match your new data file with just one
command.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_csv.trunc.as.nm">csv.trunc.as.nm</code></td>
<td>
<p>If TRUE, csv file will be truncated
horizontally (columns will be dropped) to match the $INPUT
text generated for Nonmem (genText must be TRUE for this
option to be allowed). This can be a great advantage when
dealing with large datasets that can create problems in
parallellization. Combined with write.rds=TRUE, the full data
set will still be written to an rds file, so this can be used
when combining output and input data when reading model
results. This is done by default by NMscanData. This means
writing a lean (narrow) csv file for Nonmem while keeping
columns of non-numeric class like character and factor for
post-processing.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_gentext">genText</code></td>
<td>
<p>Run and report results of NMgenText? Default is
TRUE. You may want to disable this if data set is not for
Nonmem.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_save">save</code></td>
<td>
<p>Save defined files? Default is TRUE. If a variable is
used to control whether a script generates outputs (say
<code>writeOutputs=TRUE/FALSE)</code>, if you use
<code>save=writeOutputs</code> to comply with this.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_write.csv">write.csv</code></td>
<td>
<p>Write to csv file? Deprecated, use
'formats.write' instead.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_write.rds">write.rds</code></td>
<td>
<p>write an rds file? Deprecated, use
'formats.write' instead.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_write.rdata">write.RData</code></td>
<td>
<p>Deprecated and not recommended - will be
removed. RData is not a adequate format for a dataset (but is
for environments). Please use write.rds instead.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_nm.drop">nm.drop</code></td>
<td>
<p>Deprecated, use
args.NMgenText=list(drop=c(&quot;column&quot;)) instead.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_nmdir.data">nmdir.data</code></td>
<td>
<p>Deprecated, use
args.NMgenText=list(dir.data=&quot;your/path&quot;) instead.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_col.flagn">col.flagn</code></td>
<td>
<p>Name of a numeric column with zero value for rows
to include in Nonmem run, non-zero for rows to skip. The
argument is only used for generating the proposed $DATA text
to paste into the Nonmem control stream. To skip this feature,
use col.flagn=NULL.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_nm.rename">nm.rename</code></td>
<td>
<p>Deprecated, use
args.NMgenText=list(rename=c(newname=&quot;existing&quot;)) instead.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_nm.copy">nm.copy</code></td>
<td>
<p>Deprecated, use
args.NMgenText=list(copy=c(newname=&quot;existing&quot;)) instead.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_nm.capitalize">nm.capitalize</code></td>
<td>
<p>Deprecated, use
args.NMgenText=list(capitalize=TRUE) instead.</p>
</td></tr>
<tr><td><code id="NMwriteData_+3A_allow.char.time">allow.char.TIME</code></td>
<td>
<p>Deprecated, use
args.NMgenText=list(allow.char.TIME=TRUE) instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When writing csv files, the file will be
comma-separated. Because Nonmem does not support quoted
fields, you must avoid commas in character fields. An error is
returned if commas are found in strings.
</p>
<p>The user is provided with text to use in Nonmem. This lists names
of the data columns. Once a column is reached that Nonmem will not
be able to read as a numeric and column is not in nm.drop, the list
is stopped. Only exception is TIME which is not tested for whether
character or not.
</p>


<h3>Value</h3>

<p>Text for inclusion in Nonmem control stream, invisibly.
</p>


<h3>See Also</h3>

<p>Other DataCreate: 
<code><a href="#topic+NMorderColumns">NMorderColumns</a>()</code>,
<code><a href="#topic+NMstamp">NMstamp</a>()</code>,
<code><a href="#topic+addTAPD">addTAPD</a>()</code>,
<code><a href="#topic+findCovs">findCovs</a>()</code>,
<code><a href="#topic+findVars">findVars</a>()</code>,
<code><a href="#topic+flagsAssign">flagsAssign</a>()</code>,
<code><a href="#topic+flagsCount">flagsCount</a>()</code>,
<code><a href="#topic+mergeCheck">mergeCheck</a>()</code>,
<code><a href="#topic+tmpcol">tmpcol</a>()</code>
</p>

<hr>
<h2 id='NMwriteSection'>Replace ($)sections of a Nonmem control stream</h2><span id='topic+NMwriteSection'></span>

<h3>Description</h3>

<p>Just give the section name, the new lines and the file path, and the
&quot;$section&quot;, and the input to Nonmem will be updated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NMwriteSection(
  files,
  file.pattern,
  dir,
  section,
  newlines,
  list.sections,
  location = "replace",
  newfile,
  backup = TRUE,
  blank.append = TRUE,
  data.file,
  write = TRUE,
  quiet,
  simplify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NMwriteSection_+3A_files">files</code></td>
<td>
<p>File paths to the models (control stream) to
edit. See file.pattern too.</p>
</td></tr>
<tr><td><code id="NMwriteSection_+3A_file.pattern">file.pattern</code></td>
<td>
<p>Alternatively to files, you can supply a
regular expression which will be passed to list.files as the
pattern argument. If this is used, use dir argument as
well. Also see data.file to only process models that use a
specific data file.</p>
</td></tr>
<tr><td><code id="NMwriteSection_+3A_dir">dir</code></td>
<td>
<p>If file.pattern is used, dir is the directory to search
in.</p>
</td></tr>
<tr><td><code id="NMwriteSection_+3A_section">section</code></td>
<td>
<p>The name of the section to update with or without
&quot;$&quot;. Example: section=&quot;EST&quot; or section=&quot;$EST&quot; to edit the
sections starting by $EST. Section specification is not
case-sensitive. See ?NMreadSection too.</p>
</td></tr>
<tr><td><code id="NMwriteSection_+3A_newlines">newlines</code></td>
<td>
<p>The new text (including &quot;$SECTION&quot;). Better be
broken into lines in a character vector since this is simply
past to writeLines.</p>
</td></tr>
<tr><td><code id="NMwriteSection_+3A_list.sections">list.sections</code></td>
<td>
<p>Named list of new sections, each element
containing a section. Names must be section names, contents of
each element are the new section lines for each section.</p>
</td></tr>
<tr><td><code id="NMwriteSection_+3A_location">location</code></td>
<td>
<p>In combination with 'section', this determines
where the new section is inserter. Possible values are
&quot;replace&quot; (default), &quot;before&quot;, &quot;after&quot;, &quot;first&quot;, &quot;last&quot;.</p>
</td></tr>
<tr><td><code id="NMwriteSection_+3A_newfile">newfile</code></td>
<td>
<p>path and filename to new run. If missing, the
original file (from <code>files</code> or <code>file.pattern</code>) is
overwritten (see the <code>backup</code> option below). If NULL,
output is returned as a character vector rather than written.</p>
</td></tr>
<tr><td><code id="NMwriteSection_+3A_backup">backup</code></td>
<td>
<p>In case you are overwriting the old file, do you
want to backup the file (to say, backup_run001.mod)?</p>
</td></tr>
<tr><td><code id="NMwriteSection_+3A_blank.append">blank.append</code></td>
<td>
<p>Append a blank line to output?</p>
</td></tr>
<tr><td><code id="NMwriteSection_+3A_data.file">data.file</code></td>
<td>
<p>Use this to limit the scope of models to those
that use a specific input data data file. The string has to
exactly match the one in $DATA or $INFILE in Nonmem.</p>
</td></tr>
<tr><td><code id="NMwriteSection_+3A_write">write</code></td>
<td>
<p>Default is to write to file. If write=FALSE,
NMwriteSection returns the resulting input.txt without writing
it.  to disk?  Default is FALSE.</p>
</td></tr>
<tr><td><code id="NMwriteSection_+3A_quiet">quiet</code></td>
<td>
<p>The default is to give some information along the way
on what data is found. But consider setting this to TRUE for
non-interactive use. Default can be configured using
NMdataConf.</p>
</td></tr>
<tr><td><code id="NMwriteSection_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE (default) and only one file is edited, the
resulting rows are returned directly. If more than one file is
edited, the result will always be a list with one element per
file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The new file will be written with unix-style line
endings.
</p>


<h3>Value</h3>

<p>The new section text is returned. If write=TRUE, this is
done invisibly.
</p>


<h3>See Also</h3>

<p>Other Nonmem: 
<code><a href="#topic+NMapplyFilters">NMapplyFilters</a>()</code>,
<code><a href="#topic+NMextractText">NMextractText</a>()</code>,
<code><a href="#topic+NMgenText">NMgenText</a>()</code>,
<code><a href="#topic+NMreadSection">NMreadSection</a>()</code>,
<code><a href="#topic+NMreplaceDataFile">NMreplaceDataFile</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>newlines &lt;- "$EST POSTHOC INTERACTION METHOD=1 NOABORT PRINT=5 MAXEVAL=9999 SIG=3"
NMwriteSection(files=system.file("examples/nonmem/xgxr001.mod", package = "NMdata"),
section="EST", newlines=newlines,newfile=NULL)
## Not run: 
text.nm &lt;- NMwriteData(data)
NMwriteSection(dir="nonmem",
              file.pattern="^run.*\\.mod",
              list.sections=text.nm["INPUT"])

## End(Not run)
</code></pre>

<hr>
<h2 id='print.summary_NMdata'>print method for NMdata summaries</h2><span id='topic+print.summary_NMdata'></span>

<h3>Description</h3>

<p>print method for NMdata summaries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary_NMdata'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary_NMdata_+3A_x">x</code></td>
<td>
<p>The summary object to be printed. See ?summary.NMdata</p>
</td></tr>
<tr><td><code id="print.summary_NMdata_+3A_...">...</code></td>
<td>
<p>Arguments passed to other print methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NULL (invisibly)
</p>

<hr>
<h2 id='reduceTables'>reduce tables from NMscanTables to fewer objects</h2><span id='topic+reduceTables'></span>

<h3>Description</h3>

<p>reduce tables from NMscanTables to fewer objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reduceTables(tables, col.nmout)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reduceTables_+3A_tables">tables</code></td>
<td>
<p>Object from NMtables</p>
</td></tr>
<tr><td><code id="reduceTables_+3A_col.nmout">col.nmout</code></td>
<td>
<p>The name of the column holding logical of whether
row was found in output tables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is under development. It is not polished
for other than internal use by NMscanData. It will likely
return a different format in the future.
</p>


<h3>Value</h3>

<p>A list of data.tables: One row-level, one id-level data
set and their column specifications.
</p>

<hr>
<h2 id='renameByContents'>Rename columns matching properties of data contents</h2><span id='topic+renameByContents'></span>

<h3>Description</h3>

<p>For instance, lowercase all columns that Nonmem
cannot interpret (as numeric).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>renameByContents(data, fun.test, fun.rename, invert.test = FALSE, as.fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="renameByContents_+3A_data">data</code></td>
<td>
<p>data.frame in which to rename columns</p>
</td></tr>
<tr><td><code id="renameByContents_+3A_fun.test">fun.test</code></td>
<td>
<p>Function that returns TRUE for columns to be
renamed.</p>
</td></tr>
<tr><td><code id="renameByContents_+3A_fun.rename">fun.rename</code></td>
<td>
<p>Function that takes the existing column name and
returns the new one.</p>
</td></tr>
<tr><td><code id="renameByContents_+3A_invert.test">invert.test</code></td>
<td>
<p>Rename those where FALSE is returned from
fun.test.</p>
</td></tr>
<tr><td><code id="renameByContents_+3A_as.fun">as.fun</code></td>
<td>
<p>The default is to return data as a data.frame. Pass
a function (say tibble::as_tibble) in as.fun to convert to
something else. If data.tables are wanted, use
as.fun=&quot;data.table&quot;. The default can be configured using
NMdataConf.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data with (some) new column names. Class as defined by
as.fun.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pk &lt;- readRDS(file=system.file("examples/data/xgxr2.rds",package="NMdata"))
pk[,trtact:=NULL]
pk &lt;- renameByContents(data=pk,
                       fun.test = NMisNumeric,
                       fun.rename = tolower,
                       invert.test = TRUE)
## Or append a "C" to the same column names
pk &lt;- readRDS(file=system.file("examples/data/xgxr2.rds",package="NMdata"))
pk[,trtact:=NULL]
pk &lt;- renameByContents(data=pk,
                       fun.test = NMisNumeric,
                       fun.rename = function(x)paste0(x,"C"),
                       invert.test = TRUE)
</code></pre>

<hr>
<h2 id='searchColRow'>Check row identifier in a model for necessary properties.</h2><span id='topic+searchColRow'></span>

<h3>Description</h3>

<p>This function is only meant for internal use by NMscanData.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchColRow(
  file,
  file.mod = file.mod,
  dir.data,
  file.data,
  translate.input,
  formats.read,
  args.fread,
  col.id,
  tab.row
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchColRow_+3A_file">file</code></td>
<td>
<p>a .lst (output) or a .mod (input) control stream
file. The filename does not need to end in .lst. It is
recommended to use the output control stream because it
reflects the model as it was run rather than how it is planned
for next run. However, see file.mod and dir.data.</p>
</td></tr>
<tr><td><code id="searchColRow_+3A_file.mod">file.mod</code></td>
<td>
<p>The input control stream file path. Default is to
look for \&quot;file\&quot; with extension changed to .mod (PSN
style). You can also supply the path to the file, or you can
provide a function that translates the output file path to the
input file path. If dir.data is missing, the input control
stream is needed. This is because the .lst does not contain
the path to the data file. The .mod file is only used for
finding the data file. How to interpret the datafile is read
from the .lst file. The default can be configured using
NMdataConf. See dir.data too.</p>
</td></tr>
<tr><td><code id="searchColRow_+3A_dir.data">dir.data</code></td>
<td>
<p>The data directory can only be read from the
control stream (.mod) and not from the output file (.lst). So
if you only have the output file, use dir.data to tell in
which directory to find the data file. If dir.data is
provided, the .mod file is not used at all.</p>
</td></tr>
<tr><td><code id="searchColRow_+3A_file.data">file.data</code></td>
<td>
<p>Specification of the data file path. When this is
used, the control streams are not used at all.</p>
</td></tr>
<tr><td><code id="searchColRow_+3A_translate.input">translate.input</code></td>
<td>
<p>If TRUE (default), data columns are named
as interpreted by Nonmem (in $INPUT). If data file contains
more columns than mentioned in $INPUT, these will be named as
in data file (if data file contains named variables).</p>
</td></tr>
<tr><td><code id="searchColRow_+3A_args.fread">args.fread</code></td>
<td>
<p>List of arguments passed to fread. Notice that
except for &quot;input&quot; and &quot;file&quot;, you need to supply all
arguments to fread if you use this argument. Default values
can be configured using NMdataConf.</p>
</td></tr>
<tr><td><code id="searchColRow_+3A_col.id">col.id</code></td>
<td>
<p>The name of the subject ID column. Optional and only
used to calculate number of subjects in data. Default is
modified by NMdataConf.</p>
</td></tr>
<tr><td><code id="searchColRow_+3A_tab.row">tab.row</code></td>
<td>
<p>row-level data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character message about the findings if any
</p>

<hr>
<h2 id='summary.NMdata'>summary method for NMdata objects</h2><span id='topic+summary.NMdata'></span>

<h3>Description</h3>

<p>summary method for NMdata objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'NMdata'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.NMdata_+3A_object">object</code></td>
<td>
<p>An NMdata object (from NMscanData).</p>
</td></tr>
<tr><td><code id="summary.NMdata_+3A_...">...</code></td>
<td>
<p>Only passed to the summary generic if object is missing NMdata
meta data (this should not happen anyway).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The subjects are counted conditioned on the nmout column. If only
id-level output tables are present, there are no nmout=TRUE rows. This
means that in this case it will report that no IDs are found in
output. The correct statement is that records are found for zero
subjects in output tables.
</p>


<h3>Value</h3>

<p>A list with summary information on the NMdata object.
</p>

<hr>
<h2 id='tmpcol'>generate a name for a new data column that is not already in use.</h2><span id='topic+tmpcol'></span>

<h3>Description</h3>

<p>generate a name for a new data column that is not already in use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tmpcol(data, names = NULL, base = "tmpcol", max.it = 100, prefer.plain = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tmpcol_+3A_data">data</code></td>
<td>
<p>The dataset to find a new element name for</p>
</td></tr>
<tr><td><code id="tmpcol_+3A_names">names</code></td>
<td>
<p>Character vector of names that must not be
matched. Only one of data and names can be supplied.</p>
</td></tr>
<tr><td><code id="tmpcol_+3A_base">base</code></td>
<td>
<p>The base name of the new element. A number will
appended to this string that will ensure that the new element
name is not already in use.</p>
</td></tr>
<tr><td><code id="tmpcol_+3A_max.it">max.it</code></td>
<td>
<p>Maximum number of iterations on element name.</p>
</td></tr>
<tr><td><code id="tmpcol_+3A_prefer.plain">prefer.plain</code></td>
<td>
<p>If base isn't in use already, use it without a
digit appended?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string
</p>


<h3>See Also</h3>

<p>make.names
</p>
<p>Other DataCreate: 
<code><a href="#topic+NMorderColumns">NMorderColumns</a>()</code>,
<code><a href="#topic+NMstamp">NMstamp</a>()</code>,
<code><a href="#topic+NMwriteData">NMwriteData</a>()</code>,
<code><a href="#topic+addTAPD">addTAPD</a>()</code>,
<code><a href="#topic+findCovs">findCovs</a>()</code>,
<code><a href="#topic+findVars">findVars</a>()</code>,
<code><a href="#topic+flagsAssign">flagsAssign</a>()</code>,
<code><a href="#topic+flagsCount">flagsCount</a>()</code>,
<code><a href="#topic+mergeCheck">mergeCheck</a>()</code>
</p>

<hr>
<h2 id='unNMdata'>Remove NMdata class and discard NMdata meta data</h2><span id='topic+unNMdata'></span>

<h3>Description</h3>

<p>Remove NMdata class and discard NMdata meta data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unNMdata(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unNMdata_+3A_x">x</code></td>
<td>
<p>An 'NMdata' object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>x stripped from the 'NMdata' class
</p>

<hr>
<h2 id='writeNMinfo'>Do the actual writing of meta data</h2><span id='topic+writeNMinfo'></span>

<h3>Description</h3>

<p>Do the actual writing of meta data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeNMinfo(data, meta, append = FALSE, byRef = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeNMinfo_+3A_data">data</code></td>
<td>
<p>A data set</p>
</td></tr>
<tr><td><code id="writeNMinfo_+3A_meta">meta</code></td>
<td>
<p>The meta data to attach</p>
</td></tr>
<tr><td><code id="writeNMinfo_+3A_append">append</code></td>
<td>
<p>If FALSE, the existing meta data will be removed. If
TRUE, metadata will be appended to existing metadata. However,
this will not work recursively.</p>
</td></tr>
<tr><td><code id="writeNMinfo_+3A_byref">byRef</code></td>
<td>
<p>Should always be TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The data with meta data attached
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
