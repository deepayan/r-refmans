<!DOCTYPE html><html><head><title>Help for package cata</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cata}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ARI'><p>Adjusted Rand index</p></a></li>
<li><a href='#barray'><p>Convert 3d array of CATA data to 4d array of CATA differences</p></a></li>
<li><a href='#bcluster'><p>Wrapper function for b-cluster analysis</p></a></li>
<li><a href='#bcluster.h'><p>b-cluster analysis by hierarchical agglomerative strategy</p></a></li>
<li><a href='#bcluster.n'><p>b-cluster analysis by non-hierarchical iterative ascent clustering</p>
strategy</a></li>
<li><a href='#cochranQ'><p>Cochran's Q test</p></a></li>
<li><a href='#code.topk'><p>Apply top-k box coding to scale data</p></a></li>
<li><a href='#Consumer CATA data set: bread'><p>Consumer CATA data set: bread</p></a></li>
<li><a href='#evaluateClusterQuality'><p>Evaluate Quality of Cluster Analysis Solution</p></a></li>
<li><a href='#getb'><p>Calculate the b-measure</p></a></li>
<li><a href='#homogeneity'><p>Calculate within-cluster homogeneity</p></a></li>
<li><a href='#inspect'><p>Inspect/summarize many b-cluster analysis runs</p></a></li>
<li><a href='#mcnemarQ'><p>McNemar's test</p></a></li>
<li><a href='#pLift'><p>Penalty-Lift Analysis</p></a></li>
<li><a href='#rv.coef'><p>Calculate RV Coefficient</p></a></li>
<li><a href='#salton'><p>Salton's cosine measure</p></a></li>
<li><a href='#selectionPlot'><p>Plot variation in retained sensory differentiation</p></a></li>
<li><a href='#toMatrix'><p>Converts 3d array of CATA data to a tall 2d matrix format</p></a></li>
<li><a href='#topc'><p>Apply top-c choices coding to a vector of scale data from a respondent</p></a></li>
<li><a href='#toWideMatrix'><p>Converts 3d array of CATA data to a wide 2d matrix format</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Check-All-that-Apply (CATA) Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-04</td>
</tr>
<tr>
<td>Author:</td>
<td>J.C. Castura <a href="https://orcid.org/0000-0002-1640-833X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>J.C. Castura &lt;jcastura@compusense.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for analyzing check-all-that-apply (CATA) data from consumer and sensory tests. Cochran's Q test, McNemar's test, and Penalty-Lift analysis provided, as described in for CATA data analysis by Meyners, Castura &amp; Carr (2013) &lt;<a href="https://doi.org/10.1016%2Fj.foodqual.2013.06.010">doi:10.1016/j.foodqual.2013.06.010</a>&gt;. Cluster analysis can be performed using b-cluster analysis. The quality of cluster analysis solutions can be evaluated using various measures. The methods related to b-cluster analysis are described in a manuscript by Castura, Meyners, Varela &amp; Næs (2022) &lt;<a href="https://doi.org/10.1016%2Fj.foodqual.2022.104564">doi:10.1016/j.foodqual.2022.104564</a>&gt;. Methods are adapted to product-related hedonic responses by Castura, Meyners, Pohjanheimo, Varela &amp; Næs (2023) &lt;<a href="https://doi.org/10.1111%2Fjoss.12860">doi:10.1111/joss.12860</a>&gt;. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, graphics</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-04 17:41:20 UTC; jcastura</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-04 18:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='ARI'>Adjusted Rand index</h2><span id='topic+ARI'></span>

<h3>Description</h3>

<p>Calculate the adjusted Rand index between two sets of cluster memberships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARI(x, y, signif = FALSE, n = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ARI_+3A_x">x</code></td>
<td>
<p>vector of cluster memberships (integers)</p>
</td></tr>
<tr><td><code id="ARI_+3A_y">y</code></td>
<td>
<p>vector of cluster memberships (integers)</p>
</td></tr>
<tr><td><code id="ARI_+3A_signif">signif</code></td>
<td>
<p>conduct significance test; default is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="ARI_+3A_n">n</code></td>
<td>
<p>number of replicates in Monte Carlo significance test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ari adjusted Rand index
</p>
<p>nari normalized adjusted Rand index
</p>
<p>sim.mean average value of null distribution (should be closed to zero)
</p>
<p>sim.var variance of null distribution
</p>
<p>pvalue P value of observed ARI (or NARI) value
</p>


<h3>References</h3>

<p>Hubert, L., &amp; Arabie, P. (1985). Comparing partitions. 
<em>Journal of Classification</em>, 2, 193–218.
<a href="https://doi.org/10.1007/BF01908075">doi:10.1007/BF01908075</a>.
</p>
<p>Qannari, E.M., Courcoux, P., &amp; Faye, P. (2014). 
Significance test of the adjusted Rand index. Application to the free sorting 
task. <em>Food Quality and Preference</em>, 32, 93-97. 
<a href="https://doi.org/10.1016/j.foodqual.2013.05.005">doi:10.1016/j.foodqual.2013.05.005</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sample(1:3, 20, replace = TRUE)
y &lt;- sample(1:3, 20, replace = TRUE)

ARI(x, y, signif = FALSE)
</code></pre>

<hr>
<h2 id='barray'>Convert 3d array of CATA data to 4d array of CATA differences</h2><span id='topic+barray'></span>

<h3>Description</h3>

<p>Converts a three-dimensional array (<code>I</code> assessors, <code>J</code>
products, <code>M</code> attributes) to a four-dimensional array of product
comparisons (<code>I</code> assessors, <code>J(J-1)/2</code>
product comparisons, two outcomes (of type <code>b</code> or <code>c</code>), <code>M</code> 
attributes)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barray(X, values = "bc", type.in = "binary", type.out = "binary")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="barray_+3A_x">X</code></td>
<td>
<p>three-dimensional array (<code>I</code> assessors, <code>J</code>
products, <code>M</code> attributes) where values are <code>0</code> (not checked) 
or <code>1</code> (checked)</p>
</td></tr>
<tr><td><code id="barray_+3A_values">values</code></td>
<td>
<p><code>"bc"</code> (default) returns two outcomes: <code>b</code> and 
<code>c</code>; otherwise <code>"abcd"</code> returns four outcomes: <code>a</code>, <code>b</code>, 
<code>c</code>, <code>d</code>.</p>
</td></tr>
<tr><td><code id="barray_+3A_type.in">type.in</code></td>
<td>
<p>type of data submitted; default (<code>binary</code>) may be set to
<code>ordinal</code> or <code>scale</code>.</p>
</td></tr>
<tr><td><code id="barray_+3A_type.out">type.out</code></td>
<td>
<p>currently only <code>binary</code> is implemented</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A four-dimensional array of product comparisons having <code>I</code> 
assessors, <code>J(J-1)/2</code> product comparisons, outcomes (see <code>values</code>
parameter), <code>M</code> attributes
</p>


<h3>References</h3>

<p>Castura, J.C., Meyners, M., Varela, P., &amp; Næs, T. (2022). 
Clustering consumers based on product discrimination in check-all-that-apply 
(CATA) data. <em>Food Quality and Preference</em>, 104564. 
<a href="https://doi.org/10.1016/j.foodqual.2022.104564">doi:10.1016/j.foodqual.2022.104564</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bread)

# Get the 4d array of CATA differences for the first 8 consumers
b &lt;- barray(bread$cata[1:8,,])
</code></pre>

<hr>
<h2 id='bcluster'>Wrapper function for b-cluster analysis</h2><span id='topic+bcluster'></span>

<h3>Description</h3>

<p>By default, <code>bcluster</code> calls a function to perform b-cluster analysis 
by a non-hierarchical iterative ascent algorithm, then inspects results if 
there are multiple runs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcluster(X, inspect = TRUE, inspect.plot = TRUE, algorithm = "n", 
measure = "b", G = NULL, M = NULL, max.iter = 500, X.input = "data", 
tol = exp(-32), runs = 1, seed = 2021)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcluster_+3A_x">X</code></td>
<td>
<p>three-way array with <code>I</code> assessors, <code>J</code> products, 
<code>M</code> attributes where CATA data have values <code>0</code> (not checked) and 
<code>1</code> (checked)</p>
</td></tr>
<tr><td><code id="bcluster_+3A_inspect">inspect</code></td>
<td>
<p>default (<code>TRUE</code>) calls the <code><a href="#topic+inspect">inspect</a></code>
function to evaluate all solutions (when <code>runs&gt;1</code>)</p>
</td></tr>
<tr><td><code id="bcluster_+3A_inspect.plot">inspect.plot</code></td>
<td>
<p>default (<code>TRUE</code>) plots results from the 
<code><a href="#topic+inspect">inspect</a></code> function</p>
</td></tr>
<tr><td><code id="bcluster_+3A_algorithm">algorithm</code></td>
<td>
<p>default is <code>n</code> for non-hierarchical; <code>h</code> for 
hierarchical</p>
</td></tr>
<tr><td><code id="bcluster_+3A_measure">measure</code></td>
<td>
<p>default is <code>b</code> for the <code>b</code>-measure; <code>Q</code> for 
Cochran's Q test</p>
</td></tr>
<tr><td><code id="bcluster_+3A_g">G</code></td>
<td>
<p>number of clusters (required for non-hierarchical algorithm)</p>
</td></tr>
<tr><td><code id="bcluster_+3A_m">M</code></td>
<td>
<p>initial cluster memberships</p>
</td></tr>
<tr><td><code id="bcluster_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iteration allowed (default <code>500</code>)</p>
</td></tr>
<tr><td><code id="bcluster_+3A_x.input">X.input</code></td>
<td>
<p>available only for non-hierarchical algorithm; its value is
either <code>"data"</code> (default) or <code>"bc"</code> if <code>X</code> is
obtained from the function <code><a href="#topic+barray">barray</a></code></p>
</td></tr>
<tr><td><code id="bcluster_+3A_tol">tol</code></td>
<td>
<p>non-hierarchical algorithm stops if variance over 5 iterations is
less than <code>tol</code> (default: <code>exp(-32)</code>)</p>
</td></tr>
<tr><td><code id="bcluster_+3A_runs">runs</code></td>
<td>
<p>number of runs (defaults to <code>1</code>)</p>
</td></tr>
<tr><td><code id="bcluster_+3A_seed">seed</code></td>
<td>
<p>for reproducibility (default is <code>2021</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with elements:
</p>

<ul>
<li><p><code>runs</code> : b-cluster analysis results from 
<code><a href="#topic+bcluster.n">bcluster.n</a></code> or <code><a href="#topic+bcluster.h">bcluster.h</a></code> 
(in a list if <code>runs&gt;1</code>)
</p>
</li>
<li><p><code>inspect</code> : result from <code><a href="#topic+inspect">inspect</a></code> (the plot from 
this function is rendered if <code>inspect.plot</code> is <code>TRUE</code>)</p>
</li></ul>



<h3>References</h3>

<p>Castura, J.C., Meyners, M., Varela, P., &amp; Næs, T. (2022). 
Clustering consumers based on product discrimination in check-all-that-apply 
(CATA) data. <em>Food Quality and Preference</em>, 104564. 
<a href="https://doi.org/10.1016/j.foodqual.2022.104564">doi:10.1016/j.foodqual.2022.104564</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bread)

# b-cluster analysis on the first 8 consumers and the first 5 attributes
(b1 &lt;- bcluster(bread$cata[1:8,,1:5], G=2, seed = 123))
# Since the seed is the same, the result will be identical to
# (b2 &lt;- bcluster.n(bread$cata[1:8,,1:5], G=2, seed = 123))
</code></pre>

<hr>
<h2 id='bcluster.h'>b-cluster analysis by hierarchical agglomerative strategy</h2><span id='topic+bcluster.h'></span>

<h3>Description</h3>

<p>Perform b-clustering using the hierarchical agglomerative clustering 
strategy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcluster.h(X, measure = "b", runs = 1, seed = 2021)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcluster.h_+3A_x">X</code></td>
<td>
<p>three-way array; the <code>I, J, M</code> array has <code>I</code>
assessors, <code>J</code> products, <code>M</code> attributes where CATA data have values 
<code>0</code> (not checked) and <code>1</code> (checked)</p>
</td></tr>
<tr><td><code id="bcluster.h_+3A_measure">measure</code></td>
<td>
<p>currently only <code>b</code> (the <code>b</code>-measure) is implemented</p>
</td></tr>
<tr><td><code id="bcluster.h_+3A_runs">runs</code></td>
<td>
<p>number of runs (defaults to <code>1</code>; use a higher number of
runs for a real application)</p>
</td></tr>
<tr><td><code id="bcluster.h_+3A_seed">seed</code></td>
<td>
<p>for reproducibility (default is <code>2021</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>hclust</code> from hierarchical b-cluster 
analysis results (a list of such objects if <code>runs&gt;1</code>), where each <code>hclust</code> 
object has the structure described in <code><a href="stats.html#topic+hclust">hclust</a></code> as well as 
the item <code>retainedB</code> (a vector indicating the retained sensory 
differentiation at each iteration (merger)).
</p>


<h3>References</h3>

<p>Castura, J.C., Meyners, M., Varela, P., &amp; Næs, T. (2022). 
Clustering consumers based on product discrimination in check-all-that-apply 
(CATA) data. <em>Food Quality and Preference</em>, 104564. 
<a href="https://doi.org/10.1016/j.foodqual.2022.104564">doi:10.1016/j.foodqual.2022.104564</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bread)

# hierarchical b-cluster analysis on first 8 consumers and first 5 attributes
b &lt;- bcluster.h(bread$cata[1:8,,1:5])

plot(as.dendrogram(b), 
  main = "Hierarchical b-cluster analysis", 
  sub = "8 bread consumers on 5 attributes")
</code></pre>

<hr>
<h2 id='bcluster.n'>b-cluster analysis by non-hierarchical iterative ascent clustering
strategy</h2><span id='topic+bcluster.n'></span>

<h3>Description</h3>

<p>Non-hierarchical b-cluster analysis transfers assessors iteratively to
reach a local maximum in sensory differentiation retained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcluster.n(X, G, M = NULL, measure = "b", max.iter = 500, runs = 1,
X.input = "data", tol = exp(-32), seed = 2021)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcluster.n_+3A_x">X</code></td>
<td>
<p>CATA data organized in a three-way array (assessors, products, 
attributes)</p>
</td></tr>
<tr><td><code id="bcluster.n_+3A_g">G</code></td>
<td>
<p>number of clusters (required for non-hierarchical algorithm)</p>
</td></tr>
<tr><td><code id="bcluster.n_+3A_m">M</code></td>
<td>
<p>initial cluster memberships</p>
</td></tr>
<tr><td><code id="bcluster.n_+3A_measure">measure</code></td>
<td>
<p><code>b</code> (default) for the <code>b</code>-measure is implemented</p>
</td></tr>
<tr><td><code id="bcluster.n_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iteration allowed (default <code>500</code>)</p>
</td></tr>
<tr><td><code id="bcluster.n_+3A_runs">runs</code></td>
<td>
<p>number of runs (defaults to <code>1</code>)</p>
</td></tr>
<tr><td><code id="bcluster.n_+3A_x.input">X.input</code></td>
<td>
<p>either <code>"data"</code> (default) or <code>"bc"</code> if <code>X</code> is
obtained from the function <code><a href="#topic+barray">barray</a></code></p>
</td></tr>
<tr><td><code id="bcluster.n_+3A_tol">tol</code></td>
<td>
<p>algorithm stops if variance over 5 iterations is less than 
<code>tol</code> (default: <code>exp(-32)</code>)</p>
</td></tr>
<tr><td><code id="bcluster.n_+3A_seed">seed</code></td>
<td>
<p>for reproducibility (default is <code>2021</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bclust.n</code> (or a list of such objects 
if <code>runs&gt;1</code>), where each such object has the following components: 
</p>

<ul>
<li><p><code>cluster</code> : vector of the final cluster memberships
</p>
</li>
<li><p><code>totalB</code> : value of the total sensory differentiation in data set
</p>
</li>
<li><p><code>retainedB</code> : value of sensory differentiation retained in b-cluster
analysis solution
</p>
</li>
<li><p><code>progression</code> : vector of sensory differentiation retained in each 
iteration
</p>
</li>
<li><p><code>iter</code> : number of iterations completed
</p>
</li>
<li><p><code>finished</code> : boolean indicates whether the algorithm converged 
before <code>max.iter</code></p>
</li></ul>



<h3>References</h3>

<p>Castura, J.C., Meyners, M., Varela, P., &amp; Næs, T. (2022). 
Clustering consumers based on product discrimination in check-all-that-apply 
(CATA) data. <em>Food Quality and Preference</em>, 104564. 
<a href="https://doi.org/10.1016/j.foodqual.2022.104564">doi:10.1016/j.foodqual.2022.104564</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bread)

# b-cluster analysis on the first 8 consumers and the first 5 attributes
(b &lt;- bcluster.n(bread$cata[1:8, , 1:5], G=2))
</code></pre>

<hr>
<h2 id='cochranQ'>Cochran's Q test</h2><span id='topic+cochranQ'></span>

<h3>Description</h3>

<p>Calculate Cochran's Q test statistic. The null hypothesis that is assumed is 
that product proportions are all equal. The alternative hypothesis is that 
product proportions are not all equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cochranQ(X, na.rm = TRUE, quiet = FALSE, digits = getOption("digits"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cochranQ_+3A_x">X</code></td>
<td>
<p>matrix of <code>I</code> assessors (rows) and <code>J</code> products (columns)
where values are <code>0</code> (not checked) or <code>1</code> (checked)</p>
</td></tr>
<tr><td><code id="cochranQ_+3A_na.rm">na.rm</code></td>
<td>
<p>should <code>NA</code> values be removed?</p>
</td></tr>
<tr><td><code id="cochranQ_+3A_quiet">quiet</code></td>
<td>
<p>if <code>FALSE</code> (default) then it prints information related to 
the test; if <code>TRUE</code> it returns only the test statistic (<code>Q</code>)</p>
</td></tr>
<tr><td><code id="cochranQ_+3A_digits">digits</code></td>
<td>
<p>significant digits (to display)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Q test statistic
</p>


<h3>References</h3>

<p>Cochran, W. G. (1950). The comparison of percentages in matched samples. 
<em>Biometrika</em>, 37, 256-266.
</p>
<p>Meyners, M., Castura, J.C., &amp; Carr, B.T. (2013). Existing and  
new approaches for the analysis of CATA data. <em>Food Quality and Preference</em>, 
30, 309-319, <a href="https://doi.org/10.1016/j.foodqual.2013.06.010">doi:10.1016/j.foodqual.2013.06.010</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcnemarQ">mcnemarQ</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bread)

# Cochran's Q test on the first 25 consumers on the first attribute ("Fresh")
cochranQ(bread$cata[1:25,,1])
</code></pre>

<hr>
<h2 id='code.topk'>Apply top-k box coding to scale data</h2><span id='topic+code.topk'></span>

<h3>Description</h3>

<p>Apply top-k box coding to scale data. Using defaults give top-2 box (T2B) coding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>code.topk(X, zero.below = 8, one.above = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="code.topk_+3A_x">X</code></td>
<td>
<p>input matrix</p>
</td></tr>
<tr><td><code id="code.topk_+3A_zero.below">zero.below</code></td>
<td>
<p>default is <code>8</code>; values below this numeric threshold will be coded <code>0</code>; use <code>NULL</code> if there is no such threshold</p>
</td></tr>
<tr><td><code id="code.topk_+3A_one.above">one.above</code></td>
<td>
<p>default is <code>7</code>; values above this numeric threshold will be coded <code>1</code>; use <code>NULL</code> if there is no such threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix <code>X</code> with top-k coding applied
</p>


<h3>References</h3>

<p>Castura, J.C., Meyners, M., Pohjanheimo, T., Varela, P., &amp; Næs, T. (2023). 
An approach for clustering consumers by their top-box and top-choice responses. 
<em>Journal of Sensory Studies</em>, e12860. <a href="https://doi.org/10.1111/joss.12860">doi:10.1111/joss.12860</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some data
set.seed(123)
X &lt;- matrix(sample(1:9, 100, replace = TRUE), nrow = 5)

# apply top-2 box (T2B) coding
code.topk(X, zero.below = 8, one.above = 7)
</code></pre>

<hr>
<h2 id='Consumer+20CATA+20data+20set+3A+20bread'>Consumer CATA data set: bread</h2><span id='topic+bread'></span>

<h3>Description</h3>

<p>Raw results from CATA and Liking evaluations of six bread products samples by 161 consumers.</p>


<h3>Format</h3>

<p>A list with 4 items: 
</p>

<ul>
<li><p><code>$cata</code> :  check-all-that-apply (CATA) data (array, 161 consumers x 6 breads x 31 sensory attributes)
</p>
</li>
<li><p><code>$liking</code> :  9-point hedonic scale data (matrix, 161 consumers x 6 breads)
</p>
</li>
<li><p><code>$ideal.cata</code> :  check-all-that-apply (CATA) data for ideal bread (matrix, 161 consumers x 31 sensory attributes)
</p>
</li>
<li><p><code>$liking</code> :  9-point hedonic scale data for ideal bread(vector, 161 consumers)
</p>
</li></ul>

<p>CATA data is coded <code>1</code> if the attribute is checked; otherwise it is coded <code>0</code>
</p>


<h3>References</h3>

<p>Meyners, M., Castura, J.C., &amp; Carr, B.T. (2013). Existing and new approaches for the analysis of CATA data. <em>Food Quality and Preference</em>, 30, 309-319, <a href="https://doi.org/10.1016/j.foodqual.2013.06.010">doi:10.1016/j.foodqual.2013.06.010</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bread)
head(bread$cata)
</code></pre>

<hr>
<h2 id='evaluateClusterQuality'>Evaluate Quality of Cluster Analysis Solution</h2><span id='topic+evaluateClusterQuality'></span>

<h3>Description</h3>

<p>Evaluate the quality of cluster analysis solutions using measures related to
within-cluster product discrimination, between-cluster non-redundancy,
overall diversity (coverage), average RV, sensory differentiation retained,
and within-cluster homogeneity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluateClusterQuality(X, M, alpha = .05, M.order = NULL, 
quiet = FALSE, digits = getOption("digits"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluateClusterQuality_+3A_x">X</code></td>
<td>
<p>three-way array; the <code>I, J, M</code> array has <code>I</code>
assessors, <code>J</code> products, <code>M</code> attributes where CATA data have values 
<code>0</code> (not checked) and <code>1</code> (checked)</p>
</td></tr>
<tr><td><code id="evaluateClusterQuality_+3A_m">M</code></td>
<td>
<p>cluster memberships</p>
</td></tr>
<tr><td><code id="evaluateClusterQuality_+3A_alpha">alpha</code></td>
<td>
<p>significance level to be used for two-tailed tests</p>
</td></tr>
<tr><td><code id="evaluateClusterQuality_+3A_m.order">M.order</code></td>
<td>
<p>can be used to change the cluster numbers (e.g. to label 
cluster 1 as cluster 2 and vice versa); defaults to <code>NULL</code></p>
</td></tr>
<tr><td><code id="evaluateClusterQuality_+3A_quiet">quiet</code></td>
<td>
<p>if <code>FALSE</code> (default) then it prints information quality
measures; if <code>TRUE</code> then returns results without printing</p>
</td></tr>
<tr><td><code id="evaluateClusterQuality_+3A_digits">digits</code></td>
<td>
<p>significant digits (to display)</p>
</td></tr>
<tr><td><code id="evaluateClusterQuality_+3A_...">...</code></td>
<td>
<p>other parameters for <code><a href="base.html#topic+print.default">print.default</a></code> (if 
<code>quiet = TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing cluster analysis quality measures: 
</p>

<ul>
<li><p><code>$solution</code> : 
</p>

<ul>
<li><p><code>Pct.b</code> = percentage of the total sensory differentiation 
retained in the solution
</p>
</li>
<li><p><code>min(NR)</code> = smallest observed between-cluster non-redundancy
</p>
</li>
<li><p><code>Div_G</code> = overall diversity (coverage)
</p>
</li>
<li><p><code>H_G</code> = overall homogeneity (weighted average of within-cluster
homogeneity indices)
</p>
</li>
<li><p><code>avRV</code> = average RV coefficient for all between-cluster 
comparisons</p>
</li></ul>

</li>
<li><p><code>$clusters</code> : 
</p>

<ul>
<li><p><code>ng</code> = number of cluster members
</p>
</li>
<li><p><code>bg</code> = sensory differentiation retained in cluster
</p>
</li>
<li><p><code>xbarg</code> = average citation rate in cluster
</p>
</li>
<li><p><code>Hg</code> = homogeneity index within cluster (see 
<code><a href="#topic+homogeneity">homogeneity</a></code>)
</p>
</li>
<li><p><code>Dg</code> = within-cluster product discrimination</p>
</li></ul>

</li>
<li><p><code>$nonredundancy.clusterpairs</code> : 
</p>

<ul>
<li><p>square data frame showing non-redundancy for each pair of clusters
(low values indicate high redundancy)</p>
</li></ul>

</li>
<li><p><code>$rv.clusterpairs</code> : 
</p>

<ul>
<li><p>square data frame with RV coefficient for each pair of clusters
(high values indicate higher similarity in product configurations)</p>
</li></ul>
</li></ul>



<h3>References</h3>

<p>Castura, J.C., Meyners, M., Varela, P., &amp; Næs, T. (2022). 
Clustering consumers based on product discrimination in check-all-that-apply 
(CATA) data. <em>Food Quality and Preference</em>, 104564. 
<a href="https://doi.org/10.1016/j.foodqual.2022.104564">doi:10.1016/j.foodqual.2022.104564</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+homogeneity">homogeneity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bread)
evaluateClusterQuality(bread$cata[1:8,,1:5], M = rep(1:2, each = 4))
</code></pre>

<hr>
<h2 id='getb'>Calculate the b-measure</h2><span id='topic+getb'></span>

<h3>Description</h3>

<p>Function to calculate the b-measure, which quantifies the sensory 
differentiation retained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getb(X.b, X.c, oneI = FALSE, oneM = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getb_+3A_x.b">X.b</code></td>
<td>
<p>three-way (<code>I, J(J-1)/2, M</code>) array with 
<code>I</code> assessors, <code>J(J-1)/2</code> product comparisons, <code>M</code> CATA 
attributes, where values are counts of type <code>b</code> from the function 
<code><a href="#topic+barray">barray</a></code>)</p>
</td></tr>
<tr><td><code id="getb_+3A_x.c">X.c</code></td>
<td>
<p>array of same dimension as <code>X.b</code>, where values are counts of 
type <code>b</code> from the function <code><a href="#topic+barray">barray</a></code>)</p>
</td></tr>
<tr><td><code id="getb_+3A_onei">oneI</code></td>
<td>
<p>indicates whether calculation is for one assessor (default: 
<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="getb_+3A_onem">oneM</code></td>
<td>
<p>indicates whether calculation is for one attribute (default: 
<code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>b-measure
</p>


<h3>References</h3>

<p>Castura, J.C., Meyners, M., Varela, P., &amp; Næs, T. (2022). 
Clustering consumers based on product discrimination in check-all-that-apply 
(CATA) data. <em>Food Quality and Preference</em>, 104564. 
<a href="https://doi.org/10.1016/j.foodqual.2022.104564">doi:10.1016/j.foodqual.2022.104564</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bread)

bread.bc &lt;- barray(bread$cata[1:8,,1:5])
getb(bread.bc[,,1,], bread.bc[,,2,])
</code></pre>

<hr>
<h2 id='homogeneity'>Calculate within-cluster homogeneity</h2><span id='topic+homogeneity'></span>

<h3>Description</h3>

<p>Within a group of <code>N</code> consumers, the Homogeneity index lies between
<code>1/N</code> (no homogeneity) to <code>1</code> (perfect homogeneity).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homogeneity(X, oneI = FALSE, oneM = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homogeneity_+3A_x">X</code></td>
<td>
<p>three-way array; the <code>I, J, M</code> array has <code>I</code>
assessors, <code>J</code> products, <code>M</code> attributes where CATA data have values 
<code>0</code> (not checked) and <code>1</code> (checked)</p>
</td></tr>
<tr><td><code id="homogeneity_+3A_onei">oneI</code></td>
<td>
<p>indicates whether calculation is for one assessor (default: 
<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="homogeneity_+3A_onem">oneM</code></td>
<td>
<p>indicates whether calculation is for one attribute (default: 
<code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>homogeneity index
</p>


<h3>References</h3>

<p>Llobell, F., Cariou, V., Vigneau, E., Labenne, A., &amp; Qannari, 
E. M. (2019). A new approach for the analysis of data and the clustering of  
subjects in a CATA experiment. <em>Food Quality and Preference</em>, 72, 31-39, 
<a href="https://doi.org/10.1016/j.foodqual.2018.09.006">doi:10.1016/j.foodqual.2018.09.006</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bread)

# homogeneity index for the first 7 consumers on the first 6 attributes
homogeneity(bread$cata[1:7,,1:6])
</code></pre>

<hr>
<h2 id='inspect'>Inspect/summarize many b-cluster analysis runs</h2><span id='topic+inspect'></span>

<h3>Description</h3>

<p>Inspect many runs of b-cluster analysis. Calculate sensory differentiation 
retained and recurrence rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inspect(X, G = 2, bestB = NULL, bestM = NULL, inspect.plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inspect_+3A_x">X</code></td>
<td>
<p>list of multiple runs of b-cluster analysis results from 
<code><a href="#topic+bcluster.n">bcluster.n</a></code> or <code><a href="#topic+bcluster.h">bcluster.h</a></code></p>
</td></tr>
<tr><td><code id="inspect_+3A_g">G</code></td>
<td>
<p>number of clusters (required for non-hierarchical algorithm)</p>
</td></tr>
<tr><td><code id="inspect_+3A_bestb">bestB</code></td>
<td>
<p>total sensory differentiation retained in the best solution. If
not provided, then <code>bestB</code> is determined from best solution in the runs
provided (in <code>X</code>).</p>
</td></tr>
<tr><td><code id="inspect_+3A_bestm">bestM</code></td>
<td>
<p>cluster memberships for best solution. If not provided, then 
the best solution is determined from the runs provided (in <code>X</code>).</p>
</td></tr>
<tr><td><code id="inspect_+3A_inspect.plot">inspect.plot</code></td>
<td>
<p>default (<code>TRUE</code>) plots results from the 
<code><a href="#topic+inspect">inspect</a></code> function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with unique solutions in rows and the following
columns:
</p>

<ul>
<li><p><code>B</code> : Sensory differentiation retained
</p>
</li>
<li><p><code>PctB</code> : Percentage of the total sensory differentiation retained
</p>
</li>
<li><p><code>B.prop</code> : Proportion of sensory differentiation retained compared
to best solution
</p>
</li>
<li><p><code>Raw.agree</code> : raw agreement with best solution
</p>
</li>
<li><p><code>Count</code> : number of runs for which this solution was observed 
</p>
</li>
<li><p><code>Index</code> : list index (i.e., run number) of first solution  
solution in <code>X</code> corresponding to this row
</p>
</li>
<li><p><code>c.1, c.2, ...</code> : remaining columns gives index of the cluster 
to which the consumers (columns) are allocated</p>
</li></ul>



<h3>References</h3>

<p>Castura, J.C., Meyners, M., Varela, P., &amp; Næs, T. (2022). 
Clustering consumers based on product discrimination in check-all-that-apply 
(CATA) data. <em>Food Quality and Preference</em>, 104564. 
<a href="https://doi.org/10.1016/j.foodqual.2022.104564">doi:10.1016/j.foodqual.2022.104564</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bread)

res &lt;- bcluster.n(bread$cata[1:8, , 1:5], G = 2, runs = 3)
inspect(res)
</code></pre>

<hr>
<h2 id='mcnemarQ'>McNemar's test</h2><span id='topic+mcnemarQ'></span>

<h3>Description</h3>

<p>Pairwise tests are conducted using the two-tailed binomial test. These tests
can be conducted after Cochran's Q test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcnemarQ(X, na.rm = TRUE, quiet = FALSE, digits = getOption("digits"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcnemarQ_+3A_x">X</code></td>
<td>
<p>matrix of <code>I</code> assessors (rows) and <code>J</code> products (columns)
where values are <code>0</code> (not checked) or <code>1</code> (checked)</p>
</td></tr>
<tr><td><code id="mcnemarQ_+3A_na.rm">na.rm</code></td>
<td>
<p>should <code>NA</code> values be removed?</p>
</td></tr>
<tr><td><code id="mcnemarQ_+3A_quiet">quiet</code></td>
<td>
<p>if <code>FALSE</code> (default) then it prints information related to 
the test; if <code>TRUE</code> it returns only the test statistic (<code>Q</code>)</p>
</td></tr>
<tr><td><code id="mcnemarQ_+3A_digits">digits</code></td>
<td>
<p>significant digits (to display)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Test results for all McNemar pairwise tests conducted via the 
binomial test
</p>


<h3>References</h3>

<p>Cochran, W. G. (1950). The comparison of percentages in matched samples. 
<em>Biometrika</em>, 37, 256-266. 
</p>
<p>McNemar, Q. (1947). Note on the sampling error of the difference between 
correlated proportions or percentages. <em>Psychometrika</em>, 12(2), 153-157.
</p>
<p>Meyners, M., Castura, J.C., &amp; Carr, B.T. (2013). Existing and  
new approaches for the analysis of CATA data. <em>Food Quality and 
Preference</em>, 30, 309-319, <a href="https://doi.org/10.1016/j.foodqual.2013.06.010">doi:10.1016/j.foodqual.2013.06.010</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cochranQ">cochranQ</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bread)

# McNemar's exact pairwise test for all product pairs
# on the first 25 consumers and the first attribute ("Fresh")
mcnemarQ(bread$cata[1:25,,1])
</code></pre>

<hr>
<h2 id='pLift'>Penalty-Lift Analysis</h2><span id='topic+pLift'></span>

<h3>Description</h3>

<p>Penalty-Lift analysis for CATA variables, which is the difference between
the average hedonic response when CATA attribute is checked vs. the average
hedonic response when CATA attribute is not checked.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pLift(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pLift_+3A_x">X</code></td>
<td>
<p><em>either</em> a matrix of CATA data with <code>I</code> consumers (rows)
and <code>J</code> products (columns) <em>or</em> an array of CATA data with 
<code>I</code> consumers, <code>J</code> products, and <code>M</code> attributes.</p>
</td></tr>
<tr><td><code id="pLift_+3A_y">Y</code></td>
<td>
<p>matrix of hedonic data with <code>I</code> consumers (rows)
and <code>J</code> products (columns)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Penalty lift for the attribute if <code>X</code> is a matrix; otherwise,
penalty-lift for each attribute if <code>X</code> is a 3d array. If an attributes 
is only checked or not check then <code>NA</code> is returned.
</p>


<h3>References</h3>

<p>Meyners, M., Castura, J.C., &amp; Carr, B.T. (2013). Existing and new 
approaches for the analysis of CATA data. <em>Food Quality and Preference</em>, 
30, 309-319, <a href="https://doi.org/10.1016/j.foodqual.2013.06.010">doi:10.1016/j.foodqual.2013.06.010</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bread)

# penalty lift, based only on the first 12 consumers

# for the first attribute ("Fresh")
pLift(bread$cata[1:12,,1], bread$liking[1:12, ]) 

# for the first 3  attributes
pLift(bread$cata[1:12,,1:3], bread$liking[1:12, ]) 
</code></pre>

<hr>
<h2 id='rv.coef'>Calculate RV Coefficient</h2><span id='topic+rv.coef'></span>

<h3>Description</h3>

<p>Calculate RV coefficient
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rv.coef(X, Y, method = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rv.coef_+3A_x">X</code></td>
<td>
<p>input matrix (same dimensions as <code>Y</code>)</p>
</td></tr>
<tr><td><code id="rv.coef_+3A_y">Y</code></td>
<td>
<p>input matrix (same dimensions as <code>X</code>)</p>
</td></tr>
<tr><td><code id="rv.coef_+3A_method">method</code></td>
<td>
<p><code>1</code> (default) and <code>2</code> give identical RV coefficients</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RV coefficient
</p>


<h3>References</h3>

<p>Robert, P., &amp; Escoufier, Y. (1976). A unifying tool for linear 
multivariate statistical methods: the RV-coefficient. <em>Journal of the Royal 
Statistical Society: Series C (Applied Statistics)</em>, 25, 257-265.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some data
set.seed(123)
X &lt;- matrix(rnorm(8), nrow = 4)
Y &lt;- matrix(rnorm(8), nrow = 4)

# get the RV coefficient
rv.coef(X, Y)
</code></pre>

<hr>
<h2 id='salton'>Salton's cosine measure</h2><span id='topic+salton'></span>

<h3>Description</h3>

<p>Calculate Salton's cosine measure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>salton(X, Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="salton_+3A_x">X</code></td>
<td>
<p>input matrix (same dimensions as <code>Y</code>)</p>
</td></tr>
<tr><td><code id="salton_+3A_y">Y</code></td>
<td>
<p>input matrix (same dimensions as <code>X</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Salton's cosine measure
</p>


<h3>References</h3>

<p>Salton, G., &amp; McGill, M.J. (1983). <em>Introduction to Modern 
Information Retrieval</em>. Toronto: McGraw-Hill.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some data
set.seed(123)
X &lt;- matrix(rnorm(8), nrow = 4)
Y &lt;- matrix(rnorm(8), nrow = 4)

# get Salton's cosine measure
salton(X, Y)
</code></pre>

<hr>
<h2 id='selectionPlot'>Plot variation in retained sensory differentiation</h2><span id='topic+selectionPlot'></span>

<h3>Description</h3>

<p>Plot variation in retained sensory differentiation of cluster memberships
obtained from b-cluster analysis. This plot can be used to help the decision
of how many clusters to retain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>selectionPlot(x, pctB = NULL, x.input = "deltaB", indx = NULL, 
ylab = "change in B (K to G)", xlab = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="selectionPlot_+3A_x">x</code></td>
<td>
<p>input vector which is either deltaB (default; change 
in sensory differentiation retained) or B (sensory differentiation 
retained) if <code>x.input</code> is <code>"B"</code></p>
</td></tr>
<tr><td><code id="selectionPlot_+3A_pctb">pctB</code></td>
<td>
<p>vector of percentage of the total sensory differentiation retained</p>
</td></tr>
<tr><td><code id="selectionPlot_+3A_x.input">x.input</code></td>
<td>
<p>indicates what <code>x</code> is; either <code>"deltaB"</code> (default) 
or <code>B</code>.</p>
</td></tr>
<tr><td><code id="selectionPlot_+3A_indx">indx</code></td>
<td>
<p>numeric value indicating which point(s) to emphasize</p>
</td></tr>
<tr><td><code id="selectionPlot_+3A_ylab">ylab</code></td>
<td>
<p>label shown on y axis and at selection point</p>
</td></tr>
<tr><td><code id="selectionPlot_+3A_xlab">xlab</code></td>
<td>
<p>label for points along x axis</p>
</td></tr>
</table>


<h3>References</h3>

<p>Castura, J.C., Meyners, M., Varela, P., &amp; Næs, T. (2022). 
Clustering consumers based on product discrimination in check-all-that-apply 
(CATA) data. <em>Food Quality and Preference</em>, 104564. 
<a href="https://doi.org/10.1016/j.foodqual.2022.104564">doi:10.1016/j.foodqual.2022.104564</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
G2 &lt;- bcluster.n(bread$cata[1:8, , 1:5], G = 2, runs = 3)
G3 &lt;- bcluster.n(bread$cata[1:8, , 1:5], G = 3, runs = 3)
G4 &lt;- bcluster.n(bread$cata[1:8, , 1:5], G = 4, runs = 3)

best.indx &lt;- c(which.max(unlist(lapply(G2, function(x) x$retainedB))),
               which.max(unlist(lapply(G3, function(x) x$retainedB))),
               which.max(unlist(lapply(G4, function(x) x$retainedB))))
               
G1.bc &lt;- barray(bread$cata[1:8, , 1:5])
G1.B &lt;- getb(G1.bc[,,1,], G1.bc[,,2,])
BpctB &lt;- data.frame(retainedB = c(G1.B, 
                                  G2[[best.indx[1]]]$retainedB, 
                                  G3[[best.indx[2]]]$retainedB,
                                  G4[[best.indx[3]]]$retainedB))
BpctB$pctB &lt;- 100*BpctB$retainedB / G2[[1]]$totalB
BpctB$deltaB &lt;- 
           c(100*(1-BpctB$retainedB[-nrow(BpctB)] / BpctB$retainedB[-1]), NA)
BpctB &lt;- BpctB[-nrow(BpctB),]

opar &lt;- par(no.readonly=TRUE)
par(mar = rep(5,4))
selectionPlot(BpctB$deltaB, BpctB$pctB, indx = 2)
par(opar)
</code></pre>

<hr>
<h2 id='toMatrix'>Converts 3d array of CATA data to a tall 2d matrix format</h2><span id='topic+toMatrix'></span>

<h3>Description</h3>

<p>Converts a three-dimensional array (<code>I</code> assessors, <code>J</code>
products, <code>M</code> attributes) to a two-dimensional matrix with
(<code>I</code> assessors, <code>J</code> products) rows and (<code>M</code> 
attributes) columns, optionally preceded by two columns of row headers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toMatrix(X, header.rows = TRUE, oneI = FALSE, oneM = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toMatrix_+3A_x">X</code></td>
<td>
<p>three-dimensional array (<code>I</code> assessors, <code>J</code>
products, <code>M</code> attributes) where values are <code>0</code> (not checked) 
or <code>1</code> (checked)</p>
</td></tr>
<tr><td><code id="toMatrix_+3A_header.rows">header.rows</code></td>
<td>
<p><code>TRUE</code> (default) includes row headers; set to
<code>FALSE</code> to exclude these headers</p>
</td></tr>
<tr><td><code id="toMatrix_+3A_onei">oneI</code></td>
<td>
<p>indicates whether calculation is for one assessor (default: 
<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="toMatrix_+3A_onem">oneM</code></td>
<td>
<p>indicates whether calculation is for one attribute (default: 
<code>FALSE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>I</code> assessors * <code>J</code> products in rows
and <code>M</code> attributes in columns (preceded by 2 columns)
of headers if <code>header.rows = TRUE</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bread)

# convert CATA results from the first 8 consumers and the first 4 attributes
# to a tall matrix
toMatrix(bread$cata[1:8,,1:4])
</code></pre>

<hr>
<h2 id='topc'>Apply top-c choices coding to a vector of scale data from a respondent</h2><span id='topic+topc'></span>

<h3>Description</h3>

<p>Apply top-c choices coding to a vector of scale data from a respondent
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topc(x, c = 2, coding = "B")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topc_+3A_x">x</code></td>
<td>
<p>input matrix</p>
</td></tr>
<tr><td><code id="topc_+3A_c">c</code></td>
<td>
<p>number of top choices considered to be 'success'; other choices are 
considered to be 'failure' and are coded <code>0</code></p>
</td></tr>
<tr><td><code id="topc_+3A_coding">coding</code></td>
<td>
<p><code>"B"</code> (default) codes all successes as <code>1</code>; 
<code>"N"</code> codes all successes with their numeric coding</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix <code>X</code> with top-k coding applied
</p>


<h3>References</h3>

<p>Castura, J.C., Meyners, M., Pohjanheimo, T., Varela, P., &amp; Næs, T. (2023). 
An approach for clustering consumers by their top-box and top-choice responses. 
<em>Journal of Sensory Studies</em>, e12860. <a href="https://doi.org/10.1111/joss.12860">doi:10.1111/joss.12860</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some data
set.seed(123)
X &lt;- matrix(sample(1:9, 100, replace = TRUE), nrow = 5)

# apply top-2 choice (T2C) coding
apply(X, 1, topc)
</code></pre>

<hr>
<h2 id='toWideMatrix'>Converts 3d array of CATA data to a wide 2d matrix format</h2><span id='topic+toWideMatrix'></span>

<h3>Description</h3>

<p>Converts a three-dimensional array (<code>I</code> assessors, <code>J</code>
products, <code>M</code> attributes) to a two-dimensional matrix
(<code>J</code> products, (<code>I</code> assessors, <code>M</code> attributes))
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toWideMatrix(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toWideMatrix_+3A_x">X</code></td>
<td>
<p>three-dimensional array (<code>I</code> assessors, <code>J</code>
products, <code>M</code> attributes) where values are <code>0</code> (not checked) 
or <code>1</code> (checked)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with <code>J</code> products in rows and <code>I</code> 
assessors * <code>M</code> attributes in columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(bread)

# convert CATA results from the first 8 consumers and the first 4 attributes
# to a wide matrix
toWideMatrix(bread$cata[1:8,,1:4])
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
