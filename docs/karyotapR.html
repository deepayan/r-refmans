<!DOCTYPE html><html><head><title>Help for package karyotapR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {karyotapR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#karyotapR-package'><p>karyotapR: DNA Copy Number Analysis for Genome-Wide Tapestri Panels</p></a></li>
<li><a href='#assayBoxPlot'><p>Generate a box plot from assay data</p></a></li>
<li><a href='#assayHeatmap'><p>Generate heatmap of assay data</p></a></li>
<li><a href='#calcCopyNumber'><p>Calculate relative copy number value for each cell-probe unit using reference sample</p></a></li>
<li><a href='#calcGMMCopyNumber'><p>Call copy number for each cell-chromosome using Gaussian mixture models</p></a></li>
<li><a href='#calcNormCounts'><p>Normalize raw counts</p></a></li>
<li><a href='#calcSmoothCopyNumber'><p>Smooth copy number values across chromosomes and chromosome arms</p></a></li>
<li><a href='#callSampleLables'><p>Call sample labels based on feature counts</p></a></li>
<li><a href='#corner'><p>Print the top-left corner of a matrix</p></a></li>
<li><a href='#countBarcodedReads'><p>Get read counts from barcoded reads</p></a></li>
<li><a href='#createTapestriExperiment'><p>Create <code>TapestriExperiment</code> object from Tapestri Pipeline output</p></a></li>
<li><a href='#Custom Slot Getters and Setters'><p>Getter and Setter functions for <code>TapestriExperiment</code> slots</p></a></li>
<li><a href='#getChrOrder'><p>Get chromosome order from a string of chromosome/contig names</p></a></li>
<li><a href='#getCytobands'><p>Add chromosome cytobands and chromosome arms to <code>TapestriExperiment</code></p></a></li>
<li><a href='#getGMMBoundaries'><p>Calculate decision boundaries between components of copy number GMMs</p></a></li>
<li><a href='#getTidyData'><p>Get tidy-style data from <code>TapestriExperiment</code> objects</p></a></li>
<li><a href='#moveNonGenomeProbes'><p>Move non-genome probes counts and metadata to altExp slots</p></a></li>
<li><a href='#newTapestriExperimentExample'><p>Create Example <code>TapestriExperiment</code></p></a></li>
<li><a href='#PCAKneePlot'><p>Plot of PCA proportion of variance explained</p></a></li>
<li><a href='#plotCopyNumberGMM'><p>Plot copy number GMM components</p></a></li>
<li><a href='#reducedDimPlot'><p>Scatter plot for dimensional reduction results</p></a></li>
<li><a href='#runClustering'><p>Cluster 2D data</p></a></li>
<li><a href='#runPCA'><p>Cluster assay data by Principal Components Analysis</p></a></li>
<li><a href='#runUMAP'><p>Cluster matrix data by UMAP</p></a></li>
<li><a href='#TapestriExperiment-class'><p>TapestriExperiment Class Definition</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>DNA Copy Number Analysis for Genome-Wide Tapestri Panels</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Analysis of DNA copy number in single cells using 
    custom genome-wide targeted DNA sequencing panels for the Mission Bio 
    Tapestri platform. Users can easily parse, manipulate, and visualize 
    datasets produced from the automated 'Tapestri Pipeline', with support for 
    normalization, clustering, and copy number calling. Functions are also 
    available to deconvolute multiplexed samples by genotype and parsing 
    barcoded reads from exogenous lentiviral constructs.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/joeymays/karyotapR">https://github.com/joeymays/karyotapR</a>,
<a href="http://joeymays.xyz/karyotapR/">http://joeymays.xyz/karyotapR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/joeymays/karyotapR/issues">https://github.com/joeymays/karyotapR/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>circlize, cli, ComplexHeatmap, dbscan, dplyr, fitdistrplus,
GenomicRanges, ggplot2, gtools, IRanges, magrittr, methods,
purrr, rhdf5, rlang, S4Vectors, stats, SummarizedExperiment,
tibble, tidyr, umap, viridisLite</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6), SingleCellExperiment</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Biostrings, knitr, rmarkdown, Rsamtools, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-07 00:46:54 UTC; jcm844</td>
</tr>
<tr>
<td>Author:</td>
<td>Joseph Mays <a href="https://orcid.org/0000-0003-4903-938X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Joseph Mays &lt;josephcmays@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-07 08:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='karyotapR-package'>karyotapR: DNA Copy Number Analysis for Genome-Wide Tapestri Panels</h2><span id='topic+karyotapR'></span><span id='topic+karyotapR-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Analysis of DNA copy number in single cells using custom genome-wide targeted DNA sequencing panels for the Mission Bio Tapestri platform. Users can easily parse, manipulate, and visualize datasets produced from the automated 'Tapestri Pipeline', with support for normalization, clustering, and copy number calling. Functions are also available to deconvolute multiplexed samples by genotype and parsing barcoded reads from exogenous lentiviral constructs.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Joseph Mays <a href="mailto:josephcmays@gmail.com">josephcmays@gmail.com</a> (<a href="https://orcid.org/0000-0003-4903-938X">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/joeymays/karyotapR">https://github.com/joeymays/karyotapR</a>
</p>
</li>
<li> <p><a href="http://joeymays.xyz/karyotapR/">http://joeymays.xyz/karyotapR/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/joeymays/karyotapR/issues">https://github.com/joeymays/karyotapR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='assayBoxPlot'>Generate a box plot from assay data</h2><span id='topic+assayBoxPlot'></span>

<h3>Description</h3>

<p>Draws box plot of data from indicated <code>TapestriExperiment</code> <code>assay</code> slot.
This is especially useful for visualizing <code>altExp</code> count data, such as counts from
probes on chrY or barcode probe counts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assayBoxPlot(
  TapestriExperiment,
  alt.exp = NULL,
  assay = NULL,
  log.y = TRUE,
  split.features = FALSE,
  split.x.by = NULL,
  split.y.by = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assayBoxPlot_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p><code>TapestriExperiment</code> object</p>
</td></tr>
<tr><td><code id="assayBoxPlot_+3A_alt.exp">alt.exp</code></td>
<td>
<p>Character, <code>altExp</code> to plot. <code>NULL</code> (default) uses the top-level experiment in <code>TapestriExperiment</code>.</p>
</td></tr>
<tr><td><code id="assayBoxPlot_+3A_assay">assay</code></td>
<td>
<p>Character, assay to plot. <code>NULL</code> (default) selects first assay listed <code>TapestriExperiment</code>.</p>
</td></tr>
<tr><td><code id="assayBoxPlot_+3A_log.y">log.y</code></td>
<td>
<p>Logical, if <code>TRUE</code>, scales data using <code>log1p()</code>. Default <code>TRUE.</code></p>
</td></tr>
<tr><td><code id="assayBoxPlot_+3A_split.features">split.features</code></td>
<td>
<p>Logical, if <code>TRUE</code>, splits plot by <code>rowData</code> features if slot has more than one row feature/probe. Default <code>FALSE.</code></p>
</td></tr>
<tr><td><code id="assayBoxPlot_+3A_split.x.by">split.x.by</code></td>
<td>
<p>Character, <code>colData</code> column to use for X-axis categories. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="assayBoxPlot_+3A_split.y.by">split.y.by</code></td>
<td>
<p>Character, <code>colData</code> column to use for Y-axis splitting/faceting. Default <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot object, box plot
</p>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+geom_boxplot">ggplot2::geom_boxplot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
assayBoxPlot(tap.object, alt.exp = "chrYCounts", split.features = TRUE, split.x.by = "test.cluster")
</code></pre>

<hr>
<h2 id='assayHeatmap'>Generate heatmap of assay data</h2><span id='topic+assayHeatmap'></span>

<h3>Description</h3>

<p>Creates a heatmap of data from the indicated <code>TapestriObject</code> <code>assay</code> slot using the <code>ComplexHeatmap</code> package.
Heatmaps are generated as transposed (i.e. x-y flipped) representations of the <code>assay</code> matrix.
Additional <code><a href="ComplexHeatmap.html#topic+Heatmap">ComplexHeatmap::Heatmap()</a></code> parameters can be passed in to overwrite defaults.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assayHeatmap(
  TapestriExperiment,
  alt.exp = NULL,
  assay = NULL,
  split.col.by = NULL,
  split.row.by = NULL,
  annotate.row.by = NULL,
  color.preset = NULL,
  color.custom = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assayHeatmap_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p><code>TapestriExperiment</code> object</p>
</td></tr>
<tr><td><code id="assayHeatmap_+3A_alt.exp">alt.exp</code></td>
<td>
<p>Character, <code>altExp</code> slot to use. <code>NULL</code> (default) uses top-level/main experiment.</p>
</td></tr>
<tr><td><code id="assayHeatmap_+3A_assay">assay</code></td>
<td>
<p>Character, <code>assay</code> slot to use. <code>NULL</code> (default) uses first-indexed assay (usually &quot;counts&quot;).</p>
</td></tr>
<tr><td><code id="assayHeatmap_+3A_split.col.by">split.col.by</code></td>
<td>
<p>Character, <code>rowData</code> column to split columns by, i.e. &quot;chr&quot; or &quot;arm&quot;. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="assayHeatmap_+3A_split.row.by">split.row.by</code></td>
<td>
<p>Character, <code>colData</code> column to split rows by, i.e. &quot;cluster&quot;. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="assayHeatmap_+3A_annotate.row.by">annotate.row.by</code></td>
<td>
<p>Character, <code>colData</code> column to use for block annotation. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="assayHeatmap_+3A_color.preset">color.preset</code></td>
<td>
<p>Character, color preset to use for heatmap color, either &quot;copy.number&quot; or &quot;copy.number.denoise&quot; (see <code>Details</code>). Overrides <code>color.custom</code>. <code>NULL</code> (default) uses default <code>ComplexHeatmap</code> coloring.</p>
</td></tr>
<tr><td><code id="assayHeatmap_+3A_color.custom">color.custom</code></td>
<td>
<p>Color mapping function given by <code><a href="circlize.html#topic+colorRamp2">circlize::colorRamp2()</a></code>. <code>color.preset</code> must be <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="assayHeatmap_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code><a href="ComplexHeatmap.html#topic+Heatmap">ComplexHeatmap::Heatmap()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ComplexHeatmap</code> object
</p>


<h3>Options for <code>color.preset</code></h3>



<h4>&quot;copy.number&quot;</h4>

<p>Blue-white-red gradient from 0-2-4. 4 to 8+ is red-black gradient.
</p>
<div class="sourceCode"><pre>circlize::colorRamp2(c(0,1,2,3,4,8),
c('#2c7bb6','#abd9e9','#ffffff','#fdae61','#d7191c', "black"))
</pre></div>



<h4>&quot;copy.number.denoise&quot;</h4>

<p>Similar to 'copy.number' present, but white range is from 1.5-2.5 to reduce the appearance of noise around diploid cells.
</p>
<div class="sourceCode"><pre>circlize::colorRamp2(c(0,1,1.5,2,2.5,3,4,8),
c('#2c7bb6','#abd9e9','#ffffff','#ffffff','#ffffff','#fdae61','#d7191c', "black"))
</pre></div>



<h3>See Also</h3>

<p><a href="ComplexHeatmap.html#topic+Heatmap">Heatmap</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
assayHeatmap(tap.object,
  assay = "counts", split.row.by = "test.cluster",
  annotate.row.by = "test.cluster", split.col.by = "chr"
)
</code></pre>

<hr>
<h2 id='calcCopyNumber'>Calculate relative copy number value for each cell-probe unit using reference sample</h2><span id='topic+calcCopyNumber'></span><span id='topic+generateControlCopyNumberTemplate'></span>

<h3>Description</h3>

<p><code>calcCopyNumber()</code> transforms the normalized count matrix <code>normcounts</code> of a <code>TapestriExperiment</code> object
into copy number values based on a set of reference cell barcodes and given copy number value (e.g. 2 for diploid).
This is practically used to set the median copy number of a usually diploid reference
cell population to a known copy number value, e.g. 2, and then calculate the copy number for all the
cells relative to that reference population. This occurs individually for each probe,
such that the result is one copy number value per cell barcode per probe (cell-probe unit).
<code>control.copy.number</code> is a <code>data.frame</code> lookup table used to indicate the copy number value and cell barcodes
to use as the reference. A template for <code>control.copy.number</code> can be generated using <code><a href="#topic+generateControlCopyNumberTemplate">generateControlCopyNumberTemplate()</a></code>,
which will have a row for each chromosome arm represented in <code>TapestriExperiment</code>.
</p>
<p>The <code>control.copy.number</code> data.frame should include 3 columns named <code>arm</code>, <code>copy.number</code>, and <code>sample.label</code>.
<code>arm</code> is chromosome arm names from chr1p through chrXq, <code>copy.number</code> is the reference copy number value (2 = diploid), and <code>sample.label</code> is the
value corresponding to the <code>colData</code> column given in <code>sample.feature</code> to indicate the set of reference cell barcodes to use to set the copy number.
This is best used in a workflow where the cells are clustered first into their respective samples, and then one cluster is used as the reference population
the other clusters. This also allows for the baseline copy number to be set for each chromosome arm individually in the case where the
reference population is not completely diploid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcCopyNumber(
  TapestriExperiment,
  control.copy.number,
  sample.feature = "cluster",
  remove.bad.probes = FALSE
)

generateControlCopyNumberTemplate(
  TapestriExperiment,
  copy.number = 2,
  sample.feature.label = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcCopyNumber_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p><code>TapestriExperiment</code> object.</p>
</td></tr>
<tr><td><code id="calcCopyNumber_+3A_control.copy.number">control.copy.number</code></td>
<td>
<p><code>data.frame</code> with columns <code>arm</code>, <code>copy.number</code>, and <code>sample.label</code>. See details.</p>
</td></tr>
<tr><td><code id="calcCopyNumber_+3A_sample.feature">sample.feature</code></td>
<td>
<p>Character, <code>colData</code> column to use for subsetting cell.barcodes. Default &quot;cluster&quot;.</p>
</td></tr>
<tr><td><code id="calcCopyNumber_+3A_remove.bad.probes">remove.bad.probes</code></td>
<td>
<p>Logical, if <code>TRUE</code>, probes with median normalized counts = 0 are removed from the returned <code>TapestriExperiment</code>. If FALSE (default), probes with median normalized counts = 0 throw error and stop function.</p>
</td></tr>
<tr><td><code id="calcCopyNumber_+3A_copy.number">copy.number</code></td>
<td>
<p>Numeric, sets all entries of <code>copy.number</code> column in output. Default 2 (diploid).</p>
</td></tr>
<tr><td><code id="calcCopyNumber_+3A_sample.feature.label">sample.feature.label</code></td>
<td>
<p>Character, sets all entries of <code>sample.label</code> column in output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TapestriExperiment</code> object with cell-probe copy number values in <code>copyNumber</code> assay slot.
</p>
<p><code>data.frame</code> with 3 columns named <code>arm</code>, <code>copy.number</code>, and <code>sample.label</code>
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>generateControlCopyNumberTemplate()</code>: generates a <code>data.frame</code> template for <code>control.copy.number</code> in <code>calcCopyNumber()</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
tap.object &lt;- calcNormCounts(tap.object)
control.copy.number &lt;- generateControlCopyNumberTemplate(tap.object,
  copy.number = 2,
  sample.feature.label = "cellline1"
)
tap.object &lt;- calcCopyNumber(tap.object,
  control.copy.number,
  sample.feature = "test.cluster"
)
tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
control.copy.number &lt;- generateControlCopyNumberTemplate(tap.object,
  copy.number = 2,
  sample.feature.label = "cellline1"
)
</code></pre>

<hr>
<h2 id='calcGMMCopyNumber'>Call copy number for each cell-chromosome using Gaussian mixture models</h2><span id='topic+calcGMMCopyNumber'></span>

<h3>Description</h3>

<p>Uses control cells to simulate expected smoothed copy number distributions for all chromosomes across each of <code>model.components</code> (copy number level).
Then uses the distributions to calculate posterior probabilities for each cell-chromosome belonging to each of copy number level.
Each cell-chromosome is assigned the copy number value for which its posterior probability is highest.
This is done for both whole chromosomes and chromosome arms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcGMMCopyNumber(
  TapestriExperiment,
  cell.barcodes,
  control.copy.number,
  model.components = 1:5,
  model.priors = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcGMMCopyNumber_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p><code>TapestriExperiment</code> object.</p>
</td></tr>
<tr><td><code id="calcGMMCopyNumber_+3A_cell.barcodes">cell.barcodes</code></td>
<td>
<p>character, vector of cell barcodes to fit GMM. Usually corresponds to diploid control.</p>
</td></tr>
<tr><td><code id="calcGMMCopyNumber_+3A_control.copy.number">control.copy.number</code></td>
<td>
<p><code>data.frame</code> with columns <code>arm</code> and <code>copy.number</code>, indicating of known copy number of cells in <code>cell.barcodes</code>.</p>
</td></tr>
<tr><td><code id="calcGMMCopyNumber_+3A_model.components">model.components</code></td>
<td>
<p>numeric, vector of copy number GMM components to calculate, default <code>1:5</code> (for copy number = 1, 2, 3, 4, 5).</p>
</td></tr>
<tr><td><code id="calcGMMCopyNumber_+3A_model.priors">model.priors</code></td>
<td>
<p>numeric, relative prior probabilities for each GMM component. If <code>NULL</code> (default), assumes equal priors.</p>
</td></tr>
<tr><td><code id="calcGMMCopyNumber_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to internal functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TapestriExperiment</code> object with copy number calls based on the calculated GMMs, saved to <code>gmmCopyNumber</code> slot of <code>smoothedCopyNumberByChr</code> and <code>smoothedCopyNumberByArm</code> altExps.
GMM parameters for each <code>feature.id</code> are saved to the <code>metadata</code> slot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
tap.object &lt;- calcNormCounts(tap.object)
control.copy.number &lt;- generateControlCopyNumberTemplate(tap.object,
  copy.number = 2,
  sample.feature.label = "cellline1"
)
tap.object &lt;- calcCopyNumber(tap.object,
  control.copy.number,
  sample.feature = "test.cluster"
)
tap.object &lt;- calcSmoothCopyNumber(tap.object)
tap.object &lt;- calcGMMCopyNumber(tap.object,
  cell.barcodes = colnames(tap.object),
  control.copy.number = control.copy.number,
  model.components = 1:5
)

</code></pre>

<hr>
<h2 id='calcNormCounts'>Normalize raw counts</h2><span id='topic+calcNormCounts'></span>

<h3>Description</h3>

<p>Normalizes raw counts from <code>counts</code> slot in <code>TapestriExperiment</code> and returns the object with normalized counts in the <code>normcounts</code> slot.
Also calculates the standard deviation for each probe using normalized counts and adds it to <code>rowData</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcNormCounts(TapestriExperiment, method = "mb", scaling.factor = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcNormCounts_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p><code>TapestriExperiment</code> object.</p>
</td></tr>
<tr><td><code id="calcNormCounts_+3A_method">method</code></td>
<td>
<p>Character, normalization method. Default &quot;mb&quot;.</p>
</td></tr>
<tr><td><code id="calcNormCounts_+3A_scaling.factor">scaling.factor</code></td>
<td>
<p>Numeric, optional number to scale normalized counts if <code>method == "libNorm"</code>. Default <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;mb&quot; method performs the same normalization scheme as in Mission Bio's mosaic package for python:
Counts for each barcode are normalized relative to their barcode's mean and probe counts are normalized relative to their probe's median.
&quot;libNorm&quot; method preforms library size normalization, returning the proportion of counts of each probe within a cell.
The proportion is multiplied by <code>scaling.factor</code> if provided.
</p>


<h3>Value</h3>

<p><code>TapestriExperiment</code> object with normalized counts added to <code>normcounts</code> slot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
tap.object &lt;- calcNormCounts(tap.object)
</code></pre>

<hr>
<h2 id='calcSmoothCopyNumber'>Smooth copy number values across chromosomes and chromosome arms</h2><span id='topic+calcSmoothCopyNumber'></span>

<h3>Description</h3>

<p><code>calcSmoothCopyNumber()</code> takes <code>copyNumber</code> slot values for probes on a chromosome and smooths them by median (default) for each chromosome
and chromosome arm, resulting in one copy number value per chromosome and chromosome arm for each cell barcode.
Cell-chromosome values are then discretized into integers by conventional rounding (1.5 &lt;= x &lt; 2.5 rounds to 2).
Smoothed copy number and discretized smoothed copy number values are stored as <code>smoothedCopyNumber</code> and <code>discreteCopyNumber</code> assays,
in <code>altExp</code> slots <code>smoothedCopyNumberByChr</code> for chromosome-level smoothing, and <code>smoothedCopyNumberByArm</code> for chromosome arm-level smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcSmoothCopyNumber(TapestriExperiment, method = "median")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcSmoothCopyNumber_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p><code>TapestriExperiment</code> object.</p>
</td></tr>
<tr><td><code id="calcSmoothCopyNumber_+3A_method">method</code></td>
<td>
<p>Character, smoothing method: median (default) or mean.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TapestriExperiment</code> with <code>smoothedCopyNumber</code> and <code>discreteCopyNumber</code> assays in <code>altExp</code> slots <code>smoothedCopyNumberByChr</code> and <code>smoothedCopyNumberByArm</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
tap.object &lt;- calcNormCounts(tap.object)
control.copy.number &lt;- generateControlCopyNumberTemplate(tap.object,
  copy.number = 2,
  sample.feature.label = "cellline1"
)
tap.object &lt;- calcCopyNumber(tap.object,
  control.copy.number,
  sample.feature = "test.cluster"
)
tap.object &lt;- calcSmoothCopyNumber(tap.object)
</code></pre>

<hr>
<h2 id='callSampleLables'>Call sample labels based on feature counts</h2><span id='topic+callSampleLables'></span>

<h3>Description</h3>

<p><code>callSampleLables()</code> assigns labels (stored as <code>colData</code> column) to cells using feature count data in <code>colData</code>.
This is most useful for assigning barcode labels based on barcoded reads (see <a href="#topic+countBarcodedReads">countBarcodedReads</a>).
For <code>method = max</code>, labels are dictated by whichever <code>input.features</code> column has the highest number of counts.
By default, ties are broken by choosing whichever label has the lowest index position (<code>ties.method = "first"</code>).
Samples with 0 counts for all <code>input.features</code> columns are labeled according to <code>neg.label</code>.
If only one feature column is used, labels are assigned to cells with counts &gt; <code>min.count.threshold</code>, and <code>neg.label</code> otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>callSampleLables(
  TapestriExperiment,
  input.features,
  output.feature = "sample.call",
  return.table = FALSE,
  neg.label = NA,
  method = "max",
  ties.method = "first",
  min.count.threshold = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="callSampleLables_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p>A <code>TapestriExperiment</code> object.</p>
</td></tr>
<tr><td><code id="callSampleLables_+3A_input.features">input.features</code></td>
<td>
<p>Character vector, column names in <code>colData</code> to evaluate.</p>
</td></tr>
<tr><td><code id="callSampleLables_+3A_output.feature">output.feature</code></td>
<td>
<p>Character, column name to use for the call output. Default &quot;sample.call&quot;.</p>
</td></tr>
<tr><td><code id="callSampleLables_+3A_return.table">return.table</code></td>
<td>
<p>Logical, if <code>TRUE</code>, returns a data.frame of the sample.calls. If <code>FALSE</code> (default), returns updated <code>TapestriExperiment</code> object.</p>
</td></tr>
<tr><td><code id="callSampleLables_+3A_neg.label">neg.label</code></td>
<td>
<p>Character, label for samples with no counts. Default <code>NA</code>.</p>
</td></tr>
<tr><td><code id="callSampleLables_+3A_method">method</code></td>
<td>
<p>Character, call method. Only &quot;max&quot; currently supported, calls based on whichever <code>input.features</code> column has the most counts.</p>
</td></tr>
<tr><td><code id="callSampleLables_+3A_ties.method">ties.method</code></td>
<td>
<p>Character, passed to <code>max.col()</code> indicating how to break ties. Default &quot;first&quot;.</p>
</td></tr>
<tr><td><code id="callSampleLables_+3A_min.count.threshold">min.count.threshold</code></td>
<td>
<p>Numeric, minimum number of counts per cell to use for call. Default 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>TapestriExperiment</code> object with sample calls added to <code>colData</code> column <code>sample.name</code>. If <code>return.table == TRUE</code>, a <code>data.frame</code> of sample calls.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
colData(tap.object)$gRNA1 &lt;- 2 # example barcode counts
colData(tap.object)$gRNA2 &lt;- 10 # example barcode counts
tap.object &lt;- callSampleLables(tap.object,
  input.features = c("gRNA1", "gRNA2"),
  output.feature = "sample.grna"
)
</code></pre>

<hr>
<h2 id='corner'>Print the top-left corner of a matrix</h2><span id='topic+corner'></span>

<h3>Description</h3>

<p>Outputs up to 5 rows and columns of the input matrix object (with <code>rownames</code> and <code>colnames</code>) to get a quick look without filling the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corner(input.mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corner_+3A_input.mat">input.mat</code></td>
<td>
<p>A matrix-like object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix-like object matching input class, subset to a maximum of 5 rows and columns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
corner(assay(tap.object, "counts"))
</code></pre>

<hr>
<h2 id='countBarcodedReads'>Get read counts from barcoded reads</h2><span id='topic+countBarcodedReads'></span><span id='topic+countBarcodedReadsFromContig'></span>

<h3>Description</h3>

<p><code>countBarcodedReads()</code> and <code>countBarcodedReadsFromContig()</code> match exogenous DNA barcode sequences to their associated
cell barcodes and saves them to the <code>colData</code> (cell barcode metadata) of <code>TapestriExperiment</code>.
<code>countBarcodedReads()</code> is a shortcut for <code>countBarcodedReadsFromContig()</code>, allowing the user to specify 'gRNA' or 'barcode'
to use the <code>grnaCounts</code> or <code>barcodeCounts</code> <code>altExp</code> slots.
The entries in the <code>barcode.lookup</code> table do not have to be present in the sample,
allowing users to keep one master table/file of available barcode sequences for use in all experiments.
The <code>Rsamtools</code> and <code>Biostrings</code> packages must be installed to use these functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>countBarcodedReads(
  TapestriExperiment,
  bam.file,
  barcode.lookup,
  probe,
  return.table = FALSE,
  max.mismatch = 2,
  with.indels = FALSE,
  ...
)

countBarcodedReadsFromContig(
  bam.file,
  barcode.lookup,
  contig,
  cell.barcode.tag = "RG",
  max.mismatch = 2,
  with.indels = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="countBarcodedReads_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p><code>TapestriExperiment</code> object</p>
</td></tr>
<tr><td><code id="countBarcodedReads_+3A_bam.file">bam.file</code></td>
<td>
<p>File path of BAM file. <code>.bai</code> BAM index file must be in the same location (can be generated using <code><a href="Rsamtools.html#topic+scanBam">Rsamtools::indexBam()</a></code>).</p>
</td></tr>
<tr><td><code id="countBarcodedReads_+3A_barcode.lookup">barcode.lookup</code></td>
<td>
<p><code>data.frame</code> where the first column is the barcode identifier/name and the second column is the DNA sequence. Headers are ignored.</p>
</td></tr>
<tr><td><code id="countBarcodedReads_+3A_probe">probe</code></td>
<td>
<p>Character, either &quot;gRNA&quot; or &quot;barcode&quot; to parse counts from <code>grnaCounts</code> or <code>barcodeCounts</code> <code>altExp</code> slots, respectively.</p>
</td></tr>
<tr><td><code id="countBarcodedReads_+3A_return.table">return.table</code></td>
<td>
<p>Logical, if <code>TRUE</code>, returns table of read counts per barcode. If <code>FALSE</code>, returns <code>TapestriExperiment.</code> Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="countBarcodedReads_+3A_max.mismatch">max.mismatch</code></td>
<td>
<p>Numeric, the maximum and minimum number of mismatching letters allowed. Default 2.</p>
</td></tr>
<tr><td><code id="countBarcodedReads_+3A_with.indels">with.indels</code></td>
<td>
<p>If <code>TRUE</code>, then indels are allowed. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="countBarcodedReads_+3A_...">...</code></td>
<td>
<p>Arguments to pass on to <code>countBarcodedReadsFromContig()</code>.</p>
</td></tr>
<tr><td><code id="countBarcodedReads_+3A_contig">contig</code></td>
<td>
<p>Character, contig or chromosome name to search for barcodes in. Can be a vector of more than one contig to expand search space.</p>
</td></tr>
<tr><td><code id="countBarcodedReads_+3A_cell.barcode.tag">cell.barcode.tag</code></td>
<td>
<p>Character of length 2, indicates cell barcode field in BAM, specified by Tapestri pipeline (currently &quot;RG&quot;). Default &quot;RG&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TapestriExperiment</code> with barcoded read counts added to <code>colData</code>.
</p>
<p>A data.frame of read counts for each specified barcode.
</p>


<h3>See Also</h3>

<p><code><a href="Rsamtools.html#topic+scanBam">Rsamtools::indexBam()</a></code>
</p>
<p><code><a href="Biostrings.html#topic+matchPattern">Biostrings::matchPattern()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
counts &lt;- countBarcodedReads(
  TapestriExperiment,
  bam.file, barcode.lookup, "gRNA"
)

## End(Not run)
## Not run: 
counts &lt;- countBarcodedReadsFromContig(bam.file, barcode.lookup, "virus_ref2")

## End(Not run)
</code></pre>

<hr>
<h2 id='createTapestriExperiment'>Create <code>TapestriExperiment</code> object from Tapestri Pipeline output</h2><span id='topic+createTapestriExperiment'></span>

<h3>Description</h3>

<p><code>createTapestriExperiment()</code> constructs a <code>TapestriExperiment</code> container object from data stored in the <code>.h5</code> file output by the Tapestri Pipeline.
Read count matrix (probe x cell barcode) is stored in the &quot;counts&quot; <code>assay</code> slot of the top-level experiment.
Allele frequency matrix (variant x cell barcode) is stored in the &quot;alleleFrequency&quot; <code>assay</code> slot of the &quot;alleleFrequency&quot; <code>altExp</code> (alternative experiment) slot.
<code>panel.id</code> is an optional shortcut to set special probe identities for specific custom panels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createTapestriExperiment(
  h5.filename,
  panel.id = NULL,
  get.cytobands = TRUE,
  genome = "hg19",
  move.non.genome.probes = TRUE,
  filter.variants = TRUE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createTapestriExperiment_+3A_h5.filename">h5.filename</code></td>
<td>
<p>File path for <code>.h5</code> file from Tapestri Pipeline output.</p>
</td></tr>
<tr><td><code id="createTapestriExperiment_+3A_panel.id">panel.id</code></td>
<td>
<p>Character, Tapestri panel ID, either CO261, CO293, CO610, or <code>NULL</code>. Initializes <code>barcodeProbe</code> and <code>grnaProbe</code> slots. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="createTapestriExperiment_+3A_get.cytobands">get.cytobands</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), retrieve and add chromosome cytobands and chromosome arms to <code>rowData</code> (probe metadata).</p>
</td></tr>
<tr><td><code id="createTapestriExperiment_+3A_genome">genome</code></td>
<td>
<p>Character, reference genome for pulling cytoband coordinates and chromosome arm labels (see <code><a href="#topic+getCytobands">getCytobands()</a></code>). Only &quot;hg19&quot; (default) is currently supported.</p>
</td></tr>
<tr><td><code id="createTapestriExperiment_+3A_move.non.genome.probes">move.non.genome.probes</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), move counts and metadata from non-genomic probes to <code>altExp</code> slots (see <code><a href="#topic+moveNonGenomeProbes">moveNonGenomeProbes()</a></code>).</p>
</td></tr>
<tr><td><code id="createTapestriExperiment_+3A_filter.variants">filter.variants</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), only stores variants that have passed Tapestri Pipeline filters.</p>
</td></tr>
<tr><td><code id="createTapestriExperiment_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), metadata is output in message text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TapestriExperiment</code> object containing data from Tapestri Pipeline output.
</p>


<h3>Panel ID Shortcuts</h3>

<p><code>panel.id</code> is an optional shortcut to set the <code>barcodeProbe</code> and <code>grnaProbe</code> slots in <code>TapestriExperiment</code> for specific custom Tapestri panels.
</p>


<h4>CO261</h4>


<ul>
<li> <p><code>barcodeProbe</code> = &quot;not specified&quot;
</p>
</li>
<li> <p><code>grnaProbe</code> = &quot;not specified&quot;
</p>
</li></ul>




<h4>CO293</h4>


<ul>
<li> <p><code>barcodeProbe</code> = &quot;AMPL205334&quot;
</p>
</li>
<li> <p><code>grnaProbe</code> = &quot;AMPL205666&quot;
</p>
</li></ul>




<h4>CO610</h4>


<ul>
<li> <p><code>barcodeProbe</code> = &quot;CO610_AMP351&quot;
</p>
</li>
<li> <p><code>grnaProbe</code> = &quot;CO610_AMP350&quot;
</p>
</li></ul>




<h3>Automatic Operations</h3>



<h4>Raw Data</h4>

<p>Read count and allele frequency matrices are imported to their appropriate slots as described above.
<code>filter.variants == TRUE</code> (default) only loads allele frequency variants that have passed internal filters in the Tapestri Pipeline.
This greatly reduces the number of variants from tens of thousands to hundreds of likely more consequential variants,
saving RAM and reducing operation time.
</p>



<h4>Metadata</h4>

<p>Several metadata sets are copied or generated and then stored in the appropriate <code>TapestriExperiment</code> slot during construction.
</p>

<ul>
<li><p> Probe panel metadata stored in the <code>.h5</code> file are copied to <code>rowData</code>.
</p>
</li>
<li><p> Basic QC stats (e.g. total number of reads per probe) are added to <code>rowData.</code>
</p>
</li>
<li><p> Basic QC stats (e.g. total number of reads per cell barcode) are added to <code>colData.</code>
</p>
</li>
<li><p> Experiment-level metadata is stored in <code>metadata</code>.
</p>
</li></ul>




<h3>Optional Operations</h3>

<p>Two additional major operations are called by default during <code>TapestriExperiment</code> construction for convenience.
<code>get.cytobands == TRUE</code> (default) calls <code><a href="#topic+getCytobands">getCytobands()</a></code>, which retrieves the chromosome arm and cytoband for each probe based on stored positional data and saves them in <code>rowData</code>.
Some downstream smoothing and plotting functions may fail if chromosome arms are not present in <code>rowData</code>, so this generally should always be run.
<code>move.non.genome.probes</code> calls <code><a href="#topic+moveNonGenomeProbes">moveNonGenomeProbes()</a></code>, which moves probes corresponding to the specified tags to <code>altExp</code> (alternative experiment) slots in the <code>TapestriExperiment</code> object.
The exception is probes on chromosome Y; CNVs of chrY are more rare, so we move it to an <code>altExp</code> for separate analysis.
Probes corresponding to the <code>barcodeProbe</code> and <code>grnaProbe</code> slots, which are specified by the <code>panel.id</code> shortcut or manually (see <a href="#topic+Custom+20Slot+20Getters+20and+20Setters">Custom Slot Getters and Setters</a>),
are automatically moved to <code>altExp</code> by this operation as well.
If such probes are not present, the function will only generate a warning message, so it is always safe (and recommended) to run by default.
Any remaining probes that are not targeting a human chromosome and are not specified by the shortcut tags are moved to the <code>otherProbeCounts</code> slot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+moveNonGenomeProbes">moveNonGenomeProbes()</a></code>, <code><a href="#topic+getCytobands">getCytobands()</a></code>, which are run as part of this function by default.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
tapExperiment &lt;- createTapestriExperiment("myh5file.h5", "CO293")

## End(Not run)
</code></pre>

<hr>
<h2 id='Custom+20Slot+20Getters+20and+20Setters'>Getter and Setter functions for <code>TapestriExperiment</code> slots</h2><span id='topic+Custom+20Slot+20Getters+20and+20Setters'></span><span id='topic+barcodeProbe'></span><span id='topic+barcodeProbe+2CTapestriExperiment-method'></span><span id='topic+barcodeProbe+3C-'></span><span id='topic+barcodeProbe+3C-+2CTapestriExperiment-method'></span><span id='topic+grnaProbe'></span><span id='topic+grnaProbe+2CTapestriExperiment-method'></span><span id='topic+grnaProbe+3C-'></span><span id='topic+grnaProbe+3C-+2CTapestriExperiment-method'></span><span id='topic+gmmParams'></span><span id='topic+gmmParams+2CTapestriExperiment-method'></span>

<h3>Description</h3>

<p>Get and set custom slots in <code>TapestriExperiment</code>. Slots include
<code>barcodeProbe</code> for a sample barcode probe ID
and <code>grnaProbe</code> for a gRNA-associated probe ID. These are used as shortcuts for
<code><a href="#topic+moveNonGenomeProbes">moveNonGenomeProbes()</a></code> and <code><a href="#topic+countBarcodedReads">countBarcodedReads()</a></code>.
<code>gmmParams</code> holds parameters and metadata for GMM copy number calling models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>barcodeProbe(x)

## S4 method for signature 'TapestriExperiment'
barcodeProbe(x)

barcodeProbe(x) &lt;- value

## S4 replacement method for signature 'TapestriExperiment'
barcodeProbe(x) &lt;- value

grnaProbe(x)

## S4 method for signature 'TapestriExperiment'
grnaProbe(x)

grnaProbe(x) &lt;- value

## S4 replacement method for signature 'TapestriExperiment'
grnaProbe(x) &lt;- value

gmmParams(x)

## S4 method for signature 'TapestriExperiment'
gmmParams(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Custom+2B20Slot+2B20Getters+2B20and+2B20Setters_+3A_x">x</code></td>
<td>
<p>A <code>TapestriExperiment</code> object</p>
</td></tr>
<tr><td><code id="Custom+2B20Slot+2B20Getters+2B20and+2B20Setters_+3A_value">value</code></td>
<td>
<p>Character, probe ID to assign to slot</p>
</td></tr>
<tr><td><code id="Custom+2B20Slot+2B20Getters+2B20and+2B20Setters_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p>A <code>TapestriExperiment</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For the getter methods <code>barcodeProbe</code>, <code>grnaProbe</code>, and <code>gmmParams</code>, the value
of the given slot is returned. For the setter methods <code>barcodeProbe</code> and <code>grnaProbe</code>,
a <code>TapestriExperiment</code> object is returned with modifications made to the given slot.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>barcodeProbe(TapestriExperiment)</code>: barcodeProbe getter
</p>
</li>
<li> <p><code>barcodeProbe(TapestriExperiment) &lt;- value</code>: barcodeProbe setter
</p>
</li>
<li> <p><code>grnaProbe(TapestriExperiment)</code>: grnaProbe getter
</p>
</li>
<li> <p><code>grnaProbe(TapestriExperiment) &lt;- value</code>: grnaProbe setter
</p>
</li>
<li> <p><code>gmmParams(TapestriExperiment)</code>: gmmParams getter
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
barcodeProbe(tap.object) &lt;- "Probe01"
barcodeProbe(tap.object)

grnaProbe(tap.object) &lt;- "Probe02"
grnaProbe(tap.object)

gmmParams(tap.object)
</code></pre>

<hr>
<h2 id='getChrOrder'>Get chromosome order from a string of chromosome/contig names</h2><span id='topic+getChrOrder'></span>

<h3>Description</h3>

<p><code>getChrOrder()</code> takes a string of chromosome or contig names and returns the indices of the string in typical chromosome order, i.e. 1 through 22, X, Y.
Contig names that do not match 1:22, X, or Y are sorted numerically and alphabetically (with numbers coming first), and added to the end of the order.
The output string can then be used to sort the input string into typical chromosome order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getChrOrder(chr.vector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getChrOrder_+3A_chr.vector">chr.vector</code></td>
<td>
<p>Character vector of chromosome or contig names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numerical vector of the input vectors indices in chromosome order.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>chr.order &lt;- getChrOrder(c(1, "virus", 5, "X", 22, "plasmid", "Y"))
ordered.vector &lt;- c(1, "virus", 5, "X", 22, "plasmid", "Y")[chr.order]
</code></pre>

<hr>
<h2 id='getCytobands'>Add chromosome cytobands and chromosome arms to <code>TapestriExperiment</code></h2><span id='topic+getCytobands'></span>

<h3>Description</h3>

<p><code>getCytobands()</code> retrieves the chromosome arm and cytoband for each probe based on stored positional data and saves them in <code>rowData</code>.
This is run automatically as part of <code><a href="#topic+createTapestriExperiment">createTapestriExperiment()</a></code>.
Note: Some downstream smoothing and plotting functions may fail if chromosome arms are not present in <code>rowData</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCytobands(TapestriExperiment, genome = "hg19", verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCytobands_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p><code>TapestriExperiment</code> object.</p>
</td></tr>
<tr><td><code id="getCytobands_+3A_genome">genome</code></td>
<td>
<p>Character, reference genome to use. Only hg19 is currently supported.</p>
</td></tr>
<tr><td><code id="getCytobands_+3A_verbose">verbose</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), progress is output as message text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TapestriExperiment</code> object with <code>rowData</code> updated to include chromosome arms and cytobands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
tap.object &lt;- getCytobands(tap.object, genome = "hg19")
</code></pre>

<hr>
<h2 id='getGMMBoundaries'>Calculate decision boundaries between components of copy number GMMs</h2><span id='topic+getGMMBoundaries'></span>

<h3>Description</h3>

<p>Calculate decision boundaries between components of copy number GMMs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGMMBoundaries(TapestriExperiment, chromosome.scope = "chr")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGMMBoundaries_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p><code>TapestriExperiment</code> object.</p>
</td></tr>
<tr><td><code id="getGMMBoundaries_+3A_chromosome.scope">chromosome.scope</code></td>
<td>
<p>&quot;chr&quot; or &quot;arm&quot;, for using models for either whole chromosomes or chromosome arms. Default &quot;chr&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble containing boundary values of GMMs for each <code>feature.id</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
tap.object &lt;- calcNormCounts(tap.object)
control.copy.number &lt;- generateControlCopyNumberTemplate(tap.object,
  copy.number = 2,
  sample.feature.label = "cellline1"
)
tap.object &lt;- calcCopyNumber(tap.object,
  control.copy.number,
  sample.feature = "test.cluster"
)
tap.object &lt;- calcSmoothCopyNumber(tap.object)
tap.object &lt;- calcGMMCopyNumber(tap.object,
  cell.barcodes = colnames(tap.object),
  control.copy.number = control.copy.number,
  model.components = 1:5
)

boundaries &lt;- getGMMBoundaries(tap.object,
  chromosome.scope = "chr"
)

</code></pre>

<hr>
<h2 id='getTidyData'>Get tidy-style data from <code>TapestriExperiment</code> objects</h2><span id='topic+getTidyData'></span>

<h3>Description</h3>

<p><code>getTidyData()</code> pulls data from the indicated <code>assay</code> and/or <code>altExp</code> slot(s), and rearranges it into tidy format.
<code>colData</code> (cell metadata) from the top-level/main experiment is included.
<code>rowData</code> (probe metadata) from the indicated <code>assay</code> and/or <code>altExp</code> slot(s) is included.
Attempts are made to sort by &quot;chr&quot; and &quot;start.pos&quot; columns if they are present to simplify plotting and other downstream operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTidyData(
  TapestriExperiment,
  alt.exp = NULL,
  assay = NULL,
  feature.id.as.factor = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTidyData_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p><code>TapestriExperiment</code> object.</p>
</td></tr>
<tr><td><code id="getTidyData_+3A_alt.exp">alt.exp</code></td>
<td>
<p>Character, <code>altExp</code> slot to use. <code>NULL</code> (default) uses top-level/main experiment.</p>
</td></tr>
<tr><td><code id="getTidyData_+3A_assay">assay</code></td>
<td>
<p>Character, <code>assay</code> slot to use. <code>NULL</code> (default) uses first-indexed assay (often &quot;counts&quot;).</p>
</td></tr>
<tr><td><code id="getTidyData_+3A_feature.id.as.factor">feature.id.as.factor</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), the feature.id column is returned as a factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> of tidy data with corresponding metadata from <code>colData</code> and <code>rowData</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
tidy.data &lt;- getTidyData(tap.object, alt.exp = "alleleFrequency")
</code></pre>

<hr>
<h2 id='moveNonGenomeProbes'>Move non-genome probes counts and metadata to altExp slots</h2><span id='topic+moveNonGenomeProbes'></span>

<h3>Description</h3>

<p><code>moveNonGenomeProbes()</code> takes the probe IDs corresponding to <code>grnaProbe</code> and <code>barcodeProbe</code> slots of the <code>TapestriExperiment</code> object,
as well as probes on chrY, and moves them to their own <code>altExp</code> slots in the object.
This allows those counts and associated metadata to be manipulated separately without interfering with the probes used for CNV measurements which target the endogenous genome.
<code><a href="SingleCellExperiment.html#topic+splitAltExps">SingleCellExperiment::splitAltExps()</a></code> can be used for manual specification of probes to move to <code>altExp</code> slots if the shortcut slots are not used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>moveNonGenomeProbes(TapestriExperiment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="moveNonGenomeProbes_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p><code>TapestriExperiment</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>moveNonGenomeProbes()</code> moves probes corresponding to the specified tags to <code>altExp</code> (alternative experiment) slots in the <code>TapestriExperiment</code> object.
These probes should be those which do not correspond to a chromosome and therefore would not be used to call copy number variants.
The exception is probes on chromosome Y; CNVs of chrY are more rare, so we move it to an <code>altExp</code> for separate analysis.
Probes corresponding to the <code>barcodeProbe</code> and <code>grnaProbe</code> slots, which are specified by the <code>panel.id</code> shortcut or manually (see <a href="#topic+Custom+20Slot+20Getters+20and+20Setters">Custom Slot Getters and Setters</a>),
are automatically moved to <code>altExp</code> by this operation as well.
If such probes are not present, the function will only generate a warning message, so it is always safe (and recommended) to run by default.
Any remaining probes that are not targeting a human chromosome and are not specified by the shortcut tags are moved to the <code>otherProbeCounts</code> slot.
This function is run automatically by default and with default behavior as part of <code><a href="#topic+createTapestriExperiment">createTapestriExperiment()</a></code>.
</p>


<h3>Value</h3>

<p><code>TapestriExperiment</code> with <code>altExp</code> slots filled with counts and metadata for non-genomic probes.
</p>


<h3>See Also</h3>

<p><code><a href="SingleCellExperiment.html#topic+splitAltExps">SingleCellExperiment::splitAltExps()</a></code> for manual specification of probes to move to <code>altExp</code> slots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment
tap.object &lt;- moveNonGenomeProbes(tap.object)
</code></pre>

<hr>
<h2 id='newTapestriExperimentExample'>Create Example <code>TapestriExperiment</code></h2><span id='topic+newTapestriExperimentExample'></span>

<h3>Description</h3>

<p>Creates a <code>TapestriExperiment</code> object for demonstration purposes,
which includes 240 probes across the genome, and 300 cells of 3 types.
Raw counts are generated randomly.
Type 1 has 75 cells, all XY, all diploid.
Type 2 has 100 cells, all XX, with 3 copies of chr 7, otherwise diploid.
Type 3 has 125 cells, all XY, with 1 copy of chr 1p, otherwise diploid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newTapestriExperimentExample()
</code></pre>


<h3>Value</h3>

<p><code>TapestriExperiment</code> object with demo data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tapExperiment &lt;- newTapestriExperimentExample()
</code></pre>

<hr>
<h2 id='PCAKneePlot'>Plot of PCA proportion of variance explained</h2><span id='topic+PCAKneePlot'></span>

<h3>Description</h3>

<p>Draws &quot;knee plot&quot; of PCA proportion of variance explained to determine which principal components (PCs) to include for downstream applications e.g. clustering.
Variance explained for each PC is indicated by the line.
Cumulative variance explained is indicated by the bars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCAKneePlot(TapestriExperiment, alt.exp = "alleleFrequency", n.pcs = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCAKneePlot_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p><code>TapestriExperiment</code> object</p>
</td></tr>
<tr><td><code id="PCAKneePlot_+3A_alt.exp">alt.exp</code></td>
<td>
<p>Character, <code>altExp</code> to use, <code>NULL</code> uses top-level/main experiment. Default &quot;alleleFrequency&quot;.</p>
</td></tr>
<tr><td><code id="PCAKneePlot_+3A_n.pcs">n.pcs</code></td>
<td>
<p>Numeric, number of PCs to plot, starting at 1. Default 10.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object, combined line plot and bar graph
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
tap.object &lt;- runPCA(tap.object, alt.exp = "alleleFrequency")
PCAKneePlot(tap.object, n.pcs = 5)
</code></pre>

<hr>
<h2 id='plotCopyNumberGMM'>Plot copy number GMM components</h2><span id='topic+plotCopyNumberGMM'></span>

<h3>Description</h3>

<p>Plots the probability densities of GMM components for given chromosome or chromosome arm, store in a <code>TapestriExperiment</code>.
<code><a href="#topic+calcGMMCopyNumber">calcGMMCopyNumber()</a></code> must be run first.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCopyNumberGMM(
  TapestriExperiment,
  feature.id = 1,
  chromosome.scope = "chr",
  draw.boundaries = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCopyNumberGMM_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p><code>TapestriExperiment</code> object.</p>
</td></tr>
<tr><td><code id="plotCopyNumberGMM_+3A_feature.id">feature.id</code></td>
<td>
<p>chromosome or chromosome arm to plot.</p>
</td></tr>
<tr><td><code id="plotCopyNumberGMM_+3A_chromosome.scope">chromosome.scope</code></td>
<td>
<p>&quot;chr&quot; or &quot;arm&quot;, for plotting models for either whole chromosomes or chromosome arms.</p>
</td></tr>
<tr><td><code id="plotCopyNumberGMM_+3A_draw.boundaries">draw.boundaries</code></td>
<td>
<p>logical, if <code>TRUE</code>, draw decision boundaries between each Gaussian component.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>ggplot</code> object, density plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
tap.object &lt;- calcNormCounts(tap.object)
control.copy.number &lt;- generateControlCopyNumberTemplate(tap.object,
  copy.number = 2,
  sample.feature.label = "cellline1"
)
tap.object &lt;- calcCopyNumber(tap.object,
  control.copy.number,
  sample.feature = "test.cluster"
)
tap.object &lt;- calcSmoothCopyNumber(tap.object)
tap.object &lt;- calcGMMCopyNumber(tap.object,
  cell.barcodes = colnames(tap.object),
  control.copy.number = control.copy.number,
  model.components = 1:5
)

tap.object &lt;- plotCopyNumberGMM(tap.object,
  feature.id = 7,
  chromosome.scope = "chr",
  draw.boundaries = TRUE
)

</code></pre>

<hr>
<h2 id='reducedDimPlot'>Scatter plot for dimensional reduction results</h2><span id='topic+reducedDimPlot'></span>

<h3>Description</h3>

<p>Plots a scatter plot of the indicated dimensional reduction results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reducedDimPlot(
  TapestriExperiment,
  alt.exp = "alleleFrequency",
  dim.reduction,
  dim.x = 1,
  dim.y = 2,
  group.label = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reducedDimPlot_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p><code>TapestriExperiment</code> object</p>
</td></tr>
<tr><td><code id="reducedDimPlot_+3A_alt.exp">alt.exp</code></td>
<td>
<p>Character, <code>altExp</code> to use, <code>NULL</code> uses top-level/main experiment. Default &quot;alleleFrequency&quot;.</p>
</td></tr>
<tr><td><code id="reducedDimPlot_+3A_dim.reduction">dim.reduction</code></td>
<td>
<p>Character, dimension reduction to plot, either &quot;PCA&quot; or &quot;UMAP&quot;.</p>
</td></tr>
<tr><td><code id="reducedDimPlot_+3A_dim.x">dim.x</code></td>
<td>
<p>Numeric, index of dimensional reduction data to plot on X axis. Default 1.</p>
</td></tr>
<tr><td><code id="reducedDimPlot_+3A_dim.y">dim.y</code></td>
<td>
<p>Numeric, index of dimensional reduction data to plot on Y axis. Default 2.</p>
</td></tr>
<tr><td><code id="reducedDimPlot_+3A_group.label">group.label</code></td>
<td>
<p>Character, <code>colData</code> column for grouping samples by color. Default <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 object, scatter plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
tap.object &lt;- runPCA(tap.object, alt.exp = "alleleFrequency")
reducedDimPlot(tap.object, dim.reduction = "pca")
</code></pre>

<hr>
<h2 id='runClustering'>Cluster 2D data</h2><span id='topic+runClustering'></span>

<h3>Description</h3>

<p>Clusters data using dbscan method and saves cluster assignments for each cell barcode to <code>colData</code>.
Generally used to assign clusters to UMAP projection after PCA and UMAP dimensional reduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runClustering(
  TapestriExperiment,
  alt.exp = "alleleFrequency",
  dim.reduction = "UMAP",
  eps = 0.8,
  dim.1 = 1,
  dim.2 = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runClustering_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p><code>TapestriExperiment</code> object</p>
</td></tr>
<tr><td><code id="runClustering_+3A_alt.exp">alt.exp</code></td>
<td>
<p>Character, <code>altExp</code> slot to use. <code>NULL</code> uses top-level/main experiment. Default &quot;alleleFrequency&quot;.</p>
</td></tr>
<tr><td><code id="runClustering_+3A_dim.reduction">dim.reduction</code></td>
<td>
<p>Character, reduced dimension data to use. Default &quot;UMAP&quot;.</p>
</td></tr>
<tr><td><code id="runClustering_+3A_eps">eps</code></td>
<td>
<p>Numeric, <code>dbscan</code> <code>eps</code> parameter. Lower to increase cluster granularity. See <code><a href="dbscan.html#topic+dbscan">dbscan::dbscan()</a></code>. Default 0.8.</p>
</td></tr>
<tr><td><code id="runClustering_+3A_dim.1">dim.1</code></td>
<td>
<p>Numeric, index of data dimension to use. Default 1.</p>
</td></tr>
<tr><td><code id="runClustering_+3A_dim.2">dim.2</code></td>
<td>
<p>Numeric, index of data dimension to use. Default 2.</p>
</td></tr>
<tr><td><code id="runClustering_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code><a href="dbscan.html#topic+dbscan">dbscan::dbscan()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TapestriExperiment</code> object with updated <code>colData</code> containing cluster assignments.
</p>


<h3>See Also</h3>

<p><code><a href="dbscan.html#topic+dbscan">dbscan::dbscan()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
tap.object &lt;- runPCA(tap.object, alt.exp = "alleleFrequency")
tap.object &lt;- runUMAP(tap.object, pca.dims = 1:3)
tap.object &lt;- runClustering(tap.object, dim.reduction = "UMAP", eps = 0.8)
</code></pre>

<hr>
<h2 id='runPCA'>Cluster assay data by Principal Components Analysis</h2><span id='topic+runPCA'></span>

<h3>Description</h3>

<p>Analyzes assay data by Principal Components Analysis (PCA) and saves results
to <code>reducedDims</code> slot of <code>TapestriObject</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runPCA(
  TapestriExperiment,
  alt.exp = "alleleFrequency",
  assay = NULL,
  sd.min.threshold = NULL,
  center = TRUE,
  scale. = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runPCA_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p><code>TapestriExperiment</code> object</p>
</td></tr>
<tr><td><code id="runPCA_+3A_alt.exp">alt.exp</code></td>
<td>
<p>Character, <code>altExp</code> to use, <code>NULL</code> uses top-level/main experiment. Default &quot;alleleFrequency&quot;.</p>
</td></tr>
<tr><td><code id="runPCA_+3A_assay">assay</code></td>
<td>
<p>Character, <code>assay</code> to use. <code>NULL</code> (default) uses first-indexed assay.</p>
</td></tr>
<tr><td><code id="runPCA_+3A_sd.min.threshold">sd.min.threshold</code></td>
<td>
<p>Numeric, minimum threshold for allelefreq.sd. Increase to run PCA on fewer, more variable dimensions. Set to <code>NULL</code> if not using for alleleFrequency slot. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="runPCA_+3A_center">center</code></td>
<td>
<p>Logical, if <code>TRUE</code> (default), variables are shifted to be zero centered. See <code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code>.</p>
</td></tr>
<tr><td><code id="runPCA_+3A_scale.">scale.</code></td>
<td>
<p>Logical,if <code>TRUE</code> (default), variables are scaled to have unit variance prior to PCA. See <code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TapestriExperiment</code> with PCA results saved to <code>reducedDims</code> slot of <code>altExp</code>, and proportion of variance explained by each PC saved to <code>metadata</code> slot of <code>altExp.</code>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+prcomp">stats::prcomp()</a></code> for PCA method details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment
tap.object &lt;- runPCA(tap.object, alt.exp = "alleleFrequency")
</code></pre>

<hr>
<h2 id='runUMAP'>Cluster matrix data by UMAP</h2><span id='topic+runUMAP'></span>

<h3>Description</h3>

<p>Analyzes matrix data by UMAP and saves results to <code>reducedDims</code> slot of <code>TapestriObject</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runUMAP(
  TapestriExperiment,
  alt.exp = "alleleFrequency",
  assay = NULL,
  use.pca.dims = TRUE,
  pca.dims = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runUMAP_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p><code>TapestriExperiment</code> object</p>
</td></tr>
<tr><td><code id="runUMAP_+3A_alt.exp">alt.exp</code></td>
<td>
<p>Character, <code>altExp</code> to use, <code>NULL</code> uses top-level/main experiment. Default &quot;alleleFrequency&quot;.</p>
</td></tr>
<tr><td><code id="runUMAP_+3A_assay">assay</code></td>
<td>
<p>Character, <code>assay</code> to use. <code>NULL</code> (default) uses first-indexed assay. Not used when <code>use.pca.dims = TRUE</code>.</p>
</td></tr>
<tr><td><code id="runUMAP_+3A_use.pca.dims">use.pca.dims</code></td>
<td>
<p>Logical, if <code>TRUE</code>, uses experiment PCA, otherwise uses <code>assay</code> data. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="runUMAP_+3A_pca.dims">pca.dims</code></td>
<td>
<p>Numeric, indices of PCs to use in UMAP. Default <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="runUMAP_+3A_...">...</code></td>
<td>
<p>Additional parameters to pass to <code><a href="umap.html#topic+umap">umap::umap()</a></code>, e.g. for configuration (see <code><a href="umap.html#topic+umap.defaults">umap::umap.defaults()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TapestriExperiment</code> with UMAP embeddings saved to <code>reducedDims</code> slot of <code>altExp.</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tap.object &lt;- newTapestriExperimentExample() # example TapestriExperiment object
tap.object &lt;- runPCA(tap.object, alt.exp = "alleleFrequency")
tap.object &lt;- runUMAP(tap.object, pca.dims = 1:3)
</code></pre>

<hr>
<h2 id='TapestriExperiment-class'>TapestriExperiment Class Definition</h2><span id='topic+TapestriExperiment-class'></span><span id='topic+.TapestriExperiment'></span><span id='topic+show+2CTapestriExperiment-method'></span>

<h3>Description</h3>

<p>TapestriExperiment Class Definition
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'TapestriExperiment'
show(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TapestriExperiment-class_+3A_object">object</code></td>
<td>
<p>An R object</p>
</td></tr>
<tr><td><code id="TapestriExperiment-class_+3A_tapestriexperiment">TapestriExperiment</code></td>
<td>
<p>A <code>TapestriExperiment</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TapestriExperiment object
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>show(TapestriExperiment)</code>: Show method for <code>TapestriExperiment</code>
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>barcodeProbe</code></dt><dd><p>character.</p>
</dd>
<dt><code>grnaProbe</code></dt><dd><p>character.</p>
</dd>
<dt><code>gmmParams</code></dt><dd><p>list.</p>
</dd>
</dl>


<h3>Examples</h3>

<pre><code class='language-R'>tapExpObject &lt;- new("TapestriExperiment")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
