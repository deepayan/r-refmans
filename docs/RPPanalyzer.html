<!DOCTYPE html><html><head><title>Help for package RPPanalyzer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RPPanalyzer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#averageData'>

<p>Average biological replicates over different slides.</p></a></li>
<li><a href='#calcLinear'>
<p>Calculates sample concentrations using linear model fit</p></a></li>
<li><a href='#calcLogistic'>
<p>Calculates sample concentrations using sigmoid model fit</p></a></li>
<li><a href='#calcSdc'><p> Calculates the concentration of serial diluted samples</p></a></li>
<li><a href='#correctBG'>
<p>Corrects for background in an RPPA data set</p></a></li>
<li><a href='#correctDilinterc'>
<p>Dilution series intersect correction</p></a></li>
<li><a href='#curvePredictSigmoid'>
<p>Sigmoidal curve prediction.</p></a></li>
<li><a href='#dataI'><p> Reverse phase protein array rawdata, samples serially diluted</p></a></li>
<li><a href='#dataII'><p> Reverse phase protein array data, samples from a stimulation time course</p></a></li>
<li><a href='#dataIII'><p> Reverse phase protein array data from original cancer specimen</p></a></li>
<li><a href='#dataPreproc'>
<p>Data preprocessing</p></a></li>
<li><a href='#getErrorModel'>

<p>Estimates error model parameters var0 (basal variance) and varR (relative variance) and produces a new data.frame with the signals and error model parameters.</p></a></li>
<li><a href='#HKdata'><p> Reverse phase protein array data of siRNA transfected cell line</p></a></li>
<li><a href='#logList'>
<p>Logarithmize (log2) the first two RPPA list elements, i.e. foreground and background signal intensities</p></a></li>
<li><a href='#normalizeRPPA'><p> Normalizes data in an RPPA data list</p></a></li>
<li><a href='#pick.high.conc'>
<p>Select the highest concentration from serialy diluted samples</p></a></li>
<li><a href='#plotMeasurementsQC'><p> Scatter Plots from an RPPA data</p></a></li>
<li><a href='#plotQC'><p> Plot target and blank signal from RPPA control samples</p></a></li>
<li><a href='#plotqq'><p> qq-plot and qq-line of an RPPA data set</p></a></li>
<li><a href='#plotTimeCourse'><p> Draw time course from RPPA data</p></a></li>
<li><a href='#plotTimeCourseII'>
<p>Multiplot function for RPPA time course datasets</p></a></li>
<li><a href='#read.Data'>
<p>Read and Annotate RPPA rawdata</p></a></li>
<li><a href='#remove.arrays'>
<p>Remove arrays from a RPPA data list</p></a></li>
<li><a href='#rppa2boxplot'><p>Draws boxplots of groups of an RPPA data set including wilcox or kruskal test.</p></a></li>
<li><a href='#rppaList2ExpressionSet'>
<p>Convert RPPA data into Expression Set</p></a></li>
<li><a href='#rppaList2Heatmap'>
<p>Draw a heatmap with column side colors from a RPPA data</p></a></li>
<li><a href='#RPPanalyzer-package'>
<p>Read, annotate and normalize reverse phase protein array data and get a brief overview on the biological impact.</p></a></li>
<li><a href='#S1.gpr'><p> GenePix result files</p></a></li>
<li><a href='#sample.median'>
<p>Aggregate the replicates in an RPPA data set</p></a></li>
<li><a href='#sampledescription.old'><p> sample description file</p></a></li>
<li><a href='#sampledescription.txt'><p> sample description file</p></a></li>
<li><a href='#select.measurements'>
<p>Selects the measurement samples from an RPPA data list</p></a></li>
<li><a href='#select.sample.group'>
<p>Selects samples from RPPA data</p></a></li>
<li><a href='#ser.dil.samples'><p> Reverse phase protein array rawdata, samples serially diluted</p></a></li>
<li><a href='#simpleBoxplot'><p>Draws boxplots of groups of an RPPA data set.</p></a></li>
<li><a href='#slidedescription.old'><p> slide description file</p></a></li>
<li><a href='#slidedescription.txt'><p> slide description file</p></a></li>
<li><a href='#test.correlation'>
<p>Tests for correlations in RPPA data</p></a></li>
<li><a href='#write.Data'>
<p>writes an RPPA data list into csv file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Reads, Annotates, and Normalizes Reverse Phase Protein Array
Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-01-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Heiko Mannsperger with contributions of Stephan Gade</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Torsten Schoeps &lt;torsten.schoeps@bioinf.med.uni-goettingen.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14)</td>
</tr>
<tr>
<td>Imports:</td>
<td>quantreg, limma, lattice, stats4, gam, gplots, grid, ggplot2,
Hmisc, Biobase, methods, utils, graphics</td>
</tr>
<tr>
<td>ZipData:</td>
<td>no</td>
</tr>
<tr>
<td>Description:</td>
<td>Reads in sample description and slide description files and
        annotates the expression values taken from GenePix results files
	(text file format used by many microarray scanner and software providers). 
	After normalization data can be visualized as boxplot, heatmap or dotplot.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-25 09:21:58 UTC; root</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-25 11:00:02 UTC</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
</table>
<hr>
<h2 id='averageData'>

Average biological replicates over different slides.
</h2><span id='topic+averageData'></span>

<h3>Description</h3>


<p>The function assumes that each signal originates from an underlying true value which is scaled by a scaling factor depending on the slide and replicate. The method optimizes the scaling and truth parameters such that the distance between predicted and actual signals is minimized. There are aguments to specify what factors the scaling factors and truth parameters depend on.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>averageData(subsample, scaling = c("slide", "replicate"), 
	distinguish = c("cellline", "treatment"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="averageData_+3A_subsample">subsample</code></td>
<td>

<p>data.frame with columns &quot;slide&quot; (factor, the slide names), &quot;ab&quot; (factor, the antibody/target names), &quot;time&quot; (numeric, the time points), &quot;signal&quot; (numeric, signal values), &quot;var0&quot; (numeric, error parameter for the constant error), &quot;varR&quot; (numeric, error parameter for the relative error). The data.frame may contain further columns that can then be used in the <code>scaling</code> and <code>distinguish</code> arguments. The data.frame is a standard output of <code><a href="#topic+getErrorModel">getErrorModel</a></code>.
</p>
</td></tr>
<tr><td><code id="averageData_+3A_scaling">scaling</code></td>
<td>

<p>character. One scaling parameter ist estimated for each occurring combination of the corresponding factors.
</p>
</td></tr>
<tr><td><code id="averageData_+3A_distinguish">distinguish</code></td>
<td>

<p>character. One truth parameter ist estimaed for each occuring combination of the factors &quot;time&quot;, &quot;ab&quot; (antibody/target) and the factors in <code>distinguish</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>


<p>Averaging is based on the assumption that for each level of <code>scaling</code> there is an underlying &quot;true&quot; antibody time-course for each level of <code>distinguish</code>. The signals of different scaling levels are assumed to differ by a scaling factor. Both, antibody time-course values and scaling parameters are estimated simulatenously by generalized least squares estimation:
</p>
<p style="text-align: center;"><code class="reqn">GRSS = \sum_{i,j}(s_i S_{ij}- y_j/s_i)^2/(\sigma_{ij,0}^2 + (y_j/s_i)^2 \sigma_{ij,R}^2)</code>
</p>

<p>where <code class="reqn">i, j</code> correspond to the levels of <code>c("time", "ab", distinguish)</code> and the levels of <code>scaling</code>.
</p>


<h3>Value</h3>






<table>
<tr><td><code>data.frame</code></td>
<td>

<p>with columns &quot;time&quot;, &quot;ab&quot;, &quot;signal&quot; (the truth parameters returned by <code>nls</code>), &quot;sigma&quot; (the standard error of the truth parameter returned by <code>nls</code>), &quot;connection&quot; (integer, signals can only be compared on the same scale if they agree in &quot;ab&quot;, and &quot;connection&quot;) and one column for each entry of <code>distinguish</code>.
</p>
</td></tr> 
</table>


<h3>Author(s)</h3>


<p>Daniel Kaschek, Physikalisches Institut, Uni Freiburg. Email: <code>daniel.kaschek@physik.uni-freiburg.de</code>
</p>

<hr>
<h2 id='calcLinear'>
Calculates sample concentrations using linear model fit
</h2><span id='topic+calcLinear'></span>

<h3>Description</h3>

<p>calculates sample concentrations of a RPPA data set, using parameter of a linear
model fitted to the dilution series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcLinear(x, sample.id = c("sample", "sample.n"), dilution = "dilution"
, method = "quantreg", plot = F, detectionLimit = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcLinear_+3A_x">x</code></td>
<td>
<p>List containing background corrected RPPA data set
</p>
</td></tr>
<tr><td><code id="calcLinear_+3A_sample.id">sample.id</code></td>
<td>

<p>character vector refering to column names from which samples can be separated
</p>
</td></tr>
<tr><td><code id="calcLinear_+3A_dilution">dilution</code></td>
<td>

<p>column name from the column in feature data that describes the dilution steps
of each sample
</p>
</td></tr>
<tr><td><code id="calcLinear_+3A_method">method</code></td>
<td>

<p>character string describing the method used for the linear fit
</p>
</td></tr>
<tr><td><code id="calcLinear_+3A_plot">plot</code></td>
<td>

<p>logical. If true dilution curves are plotted
</p>
</td></tr>
<tr><td><code id="calcLinear_+3A_detectionlimit">detectionLimit</code></td>
<td>

<p>logical. If true model is fitted on dilution steps above the detection limit.
If false, all data points are used to fit the model
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>expression</code></td>
<td>
<p>matrix with protein expression data</p>
</td></tr>
<tr><td><code>dummy</code></td>
<td>
<p>matrix with protein expression data</p>
</td></tr>
<tr><td><code>arraydescription</code></td>
<td>
<p>data frame with feature data</p>
</td></tr>
<tr><td><code>sampledescription</code></td>
<td>
<p>data frame with pheno data</p>
</td></tr>
</table>


<h3>Note</h3>

<p>for calculation of serial diluted samples only
</p>


<h3>Author(s)</h3>

<p>Heiko Mannsperger &lt;h.mannsperger@dkfz.de&gt;,Stephan Gade &lt;s.gade@dkfz.de&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(RPPanalyzer)
data(ser.dil.samples)

predicted.data &lt;- calcLinear(ser.dil.samples,sample.id=c("sample","sample.n"),
dilution="dilution")

## End(Not run)
</code></pre>

<hr>
<h2 id='calcLogistic'>
Calculates sample concentrations using sigmoid model fit
</h2><span id='topic+calcLogistic'></span>

<h3>Description</h3>

<p>Calculates sample concentrations of a RPPA data set, as wrapper for
curveFitSigmoid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcLogistic(x, sample.id = c("sample", "sample.n"), dilution = "dilution",
xVal = NULL, plot = F, detectionLimit = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcLogistic_+3A_x">x</code></td>
<td>

<p><code>x</code> List containing RPPA data set
</p>
</td></tr>
<tr><td><code id="calcLogistic_+3A_sample.id">sample.id</code></td>
<td>

<p>character vector refering to column names from which samples can be separated
</p>
</td></tr>
<tr><td><code id="calcLogistic_+3A_dilution">dilution</code></td>
<td>

<p>column name from the column in feature data that describes the dilution steps
of each sample
</p>
</td></tr>
<tr><td><code id="calcLogistic_+3A_xval">xVal</code></td>
<td>

<p>defines the dilution value for which the concentration is calulated. If null
the highest dilution value is used
</p>
</td></tr>
<tr><td><code id="calcLogistic_+3A_plot">plot</code></td>
<td>

<p>logical. If true dilution curves are plotted
</p>
</td></tr>
<tr><td><code id="calcLogistic_+3A_detectionlimit">detectionLimit</code></td>
<td>

<p>logical. If true model is fitted on dilution steps above the detection limit.
If false, all data points are used to fit the model
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>expression</code></td>
<td>
<p>matrix with protein expression data</p>
</td></tr>
<tr><td><code>dummy</code></td>
<td>
<p>matrix with protein expression data</p>
</td></tr>
<tr><td><code>arraydescription</code></td>
<td>
<p>data frame with feature data</p>
</td></tr>
<tr><td><code>sampledescription</code></td>
<td>
<p>data frame with pheno data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heiko Mannsperger &lt;h.mannsperger@dkfz.de&gt;, Stephan Gade &lt;s.gade@dkfz.de&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(RPPanalyzer)
data(ser.dil.samples)

predicted.data &lt;- calcLogistic(ser.dil.samples, sample.id=c("sample","sample.n"),
dilution="dilution")

## End(Not run)
</code></pre>

<hr>
<h2 id='calcSdc'> Calculates the concentration of serial diluted samples</h2><span id='topic+calcSdc'></span>

<h3>Description</h3>

<p>Calculates the protein concentration of a serial diluted sample stored in an
RPPA data list using the serial dilution curve algorithm
published by Zhang et.al, Bioinformatics 2009.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    calcSdc(x,sample.id=c("sample","sample.n"),
		sel=c("measurement","control"), dilution="dilution",
		D0=2,sensible.min=5, sensible.max=1.e9,minimal.err=5,
		plot=T, r=1.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcSdc_+3A_x">x</code></td>
<td>
<p>RPPA data list with replicates aggregated with median </p>
</td></tr>
<tr><td><code id="calcSdc_+3A_sample.id">sample.id</code></td>
<td>
<p>Attributes to identify the samples</p>
</td></tr>
<tr><td><code id="calcSdc_+3A_sel">sel</code></td>
<td>
<p>The sample type that should be calculated. Has to be &quot;measurements&quot;,&quot;control&quot;, &quot;neg_control&quot;,or &quot;blank&quot;.</p>
</td></tr>
<tr><td><code id="calcSdc_+3A_dilution">dilution</code></td>
<td>
<p>Name of the column in the feature data matrix describing the dilution steps of the samples.</p>
</td></tr>
<tr><td><code id="calcSdc_+3A_d0">D0</code></td>
<td>
<p>Dilution factor.</p>
</td></tr>
<tr><td><code id="calcSdc_+3A_sensible.min">sensible.min</code></td>
<td>
<p>Signals below this value are marked as undetected</p>
</td></tr>
<tr><td><code id="calcSdc_+3A_sensible.max">sensible.max</code></td>
<td>
<p>Signals above the value are marked as saturated</p>
</td></tr>
<tr><td><code id="calcSdc_+3A_minimal.err">minimal.err</code></td>
<td>
<p>Minimal valid estimate for the background noise</p>
</td></tr>
<tr><td><code id="calcSdc_+3A_plot">plot</code></td>
<td>
<p>Logical. If true, model fits are plotted </p>
</td></tr>
<tr><td><code id="calcSdc_+3A_r">r</code></td>
<td>
<p>Constant factor used to determine the confidence interval for the saturation limit $M$ and the background noise $a$, shoul be $&gt;1$. Can be lower if accuracy of signals is improved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method of Zhang et. al doesn't fit the dose response curve but a derive model describing the functional relationship between the signals of two consecutive dilution steps. Since this new model does not contain the protein concentration anymore all spots of one array can be used for the fit, allowing a much more robust estimation of the underlying paramters.
</p>


<h3>Value</h3>

<table>
<tr><td><code>expression</code></td>
<td>
<p>matrix with expression values</p>
</td></tr>
<tr><td><code>error</code></td>
<td>
<p>matrix with error values</p>
</td></tr>
<tr><td><code>arraydescription</code></td>
<td>
<p>data frame with feature data</p>
</td></tr>
<tr><td><code>sampledescription</code></td>
<td>
<p>data frame with pheno data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heiko Mannsperger &lt;h.mannsperger@dkfz.de&gt;, Stephan Gade &lt;s.gade@dkfz.de&gt; </p>


<h3>References</h3>

<p>Zhang et. al, Bioinformatics 2009,Serial dilution curve:
a new method for analysis of reverse phase protein array data </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
    library(RPPanalyzer)
    data(ser.dil.samples)

    ser.dil_median &lt;- sample.median(ser.dil.samples)
    predicted.data &lt;- calcSdc(ser.dil_median,D0=2,sel=c("measurement"), dilution="dilution")

## End(Not run)
</code></pre>

<hr>
<h2 id='correctBG'>
Corrects for background in an RPPA data set
</h2><span id='topic+correctBG'></span>

<h3>Description</h3>

<p>Corrects for background in an RPPA data set using different algorithms
(e.g. from the limma package) avoiding negative values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correctBG(x, method = "normexp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correctBG_+3A_x">x</code></td>
<td>

<p>List with RPPA data set
</p>
</td></tr>
<tr><td><code id="correctBG_+3A_method">method</code></td>
<td>

<p>any method from the function <code><a href="limma.html#topic+backgroundCorrect">backgroundCorrect</a></code> and <code>addmin</code> which adds
a fix number to each value to avoid negative values
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for the <code><a href="limma.html#topic+backgroundCorrect">backgroundCorrect</a></code>
function of the limma package. As additional method &quot;addmin&quot; is implemented. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>expression</code></td>
<td>
<p>matrix with background corrected expression data</p>
</td></tr>
<tr><td><code>background</code></td>
<td>
<p>matrix with background data</p>
</td></tr>
<tr><td><code>arraydescription</code></td>
<td>
<p>data frame with feature data</p>
</td></tr>
<tr><td><code>sampledescription</code></td>
<td>
<p>data frame with pheno data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heiko Mannsperger &lt;h.mannsperger@dkfz.de&gt;, Stephan Gade &lt;s.gade@dkfz.de&gt;
</p>


<h3>References</h3>

<p>Ritchie, ME, Silver, J, Oshlack, A, Holmes, M, Diyagama, D, Holloway, A,
and Smyth, GK (2007). A comparison of background correction methods for
two-colour microarrays. Bioinformatics 23, 2700-2707.
</p>


<h3>See Also</h3>

<p>For detailed information about the background correction methods see: <code><a href="limma.html#topic+backgroundCorrect">backgroundCorrect</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(RPPanalyzer)
data(dataI)

dataBGcorrected &lt;- correctBG(dataI,method="normexp")

## End(Not run)
</code></pre>

<hr>
<h2 id='correctDilinterc'>
Dilution series intersect correction
</h2><span id='topic+correctDilinterc'></span><span id='topic+analyzeIntercepts'></span><span id='topic+getIntercepts'></span><span id='topic+getSignals'></span><span id='topic+as.my'></span>

<h3>Description</h3>

<p>Consists of 3 functions: <code>getIntercepts()</code>, <code>analyzeIntercepts()</code> and <code>getSignals()</code>.
The first one derives intercepts of dilution series in dependence of dilSeriesID (column in sampledescription.txt) and slide/pad/incubationRun/spottingRun number (colnames of arraydescription). A smoothing spline is used to extrapolate to 0. Nonparametric bootstrap is used to estimate uncertainty of the intercept estimate.
The second function is used in the last one and does Analysis of Variances for nested models.
The last one updates the original timeseries signal to (foreground expression - intercept).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	correctDilinterc(dilseries, arraydesc, timeseries, exportNo) 
    getIntercepts(dilseries, arraydesc)
    analyzeIntercepts(intercepts, test="F", export)
    getSignals(timeseries, intercepts, arraydesc, exportNo)
	as.my(v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correctDilinterc_+3A_dilseries">dilseries</code></td>
<td>
<p>foreground signal matrix as result of <code><a href="#topic+write.Data">write.Data</a></code> and import of resulting txt file, but just sample_type &quot;control&quot;, i.e. dilution series</p>
</td></tr>
<tr><td><code id="correctDilinterc_+3A_arraydesc">arraydesc</code></td>
<td>
<p>&quot;arraydescription&quot; matrix of the RPPA data set list</p>
</td></tr>
<tr><td><code id="correctDilinterc_+3A_timeseries">timeseries</code></td>
<td>
<p>foreground signal matrix as result of <code><a href="#topic+write.Data">write.Data</a></code> and import of resulting txt file, but just sample_type &quot;measurement&quot;</p>
</td></tr>
<tr><td><code id="correctDilinterc_+3A_exportno">exportNo</code></td>
<td>
<p>integer of 1-4 which of the linear fits should be exported to the attribute of the result, variable for <code>analyzeIntercepts()</code>, 1: constant, 2: antibody, 3: antibody + slide (default) or antibody + slide + sample (<code>dilSeriesID</code>)</p>
</td></tr>
<tr><td><code id="correctDilinterc_+3A_intercepts">intercepts</code></td>
<td>
<p>output of <code>getIntercepts()</code>, data frame with columns for dilSeriesID and slide/pad/incubationRun/spottingRun number as well as antibody, estimated intercept and estimated error of intercept</p>
</td></tr>
<tr><td><code id="correctDilinterc_+3A_test">test</code></td>
<td>
<p>test parameter for ANOVA (see documentation of <code><a href="stats.html#topic+anova">anova</a></code>), default is &quot;F&quot;</p>
</td></tr>
<tr><td><code id="correctDilinterc_+3A_export">export</code></td>
<td>
<p>see <code>exportNo</code></p>
</td></tr>
<tr><td><code id="correctDilinterc_+3A_v">v</code></td>
<td>
<p>some variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with adapted signal intensities via subtraction of dilution intercept at concentration 0
</p>


<h3>Author(s)</h3>

<p>Daniel Kaschek, Silvia von der Heyde
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(RPPanalyzer)


# read data
dataDir &lt;- system.file("extdata", package="RPPanalyzer")
setwd(dataDir)
rawdata &lt;- read.Data(blocksperarray=12, spotter="aushon", printFlags=FALSE)
# write data
write.Data(rawdata,FileNameExtension="test_data")
# import raw data
fgRaw.tmp &lt;- read.delim("test_dataexpression.txt",
stringsAsFactors=FALSE, row.names=NULL, header=TRUE)
fgRaw &lt;- read.delim("test_dataexpression.txt", skip=max(which(fgRaw.tmp[,1]==""))+1,
stringsAsFactors=FALSE, row.names=NULL, header=TRUE)
# remove NAs
fgNAVec &lt;- which(is.na(fgRaw[,"ID"]))
if(length(fgNAVec) &gt; 0){
fgRaw &lt;- fgRaw[-fgNAVec,]
}
colnames(fgRaw) &lt;- sub("X","", gsub("\\.","-", colnames(fgRaw)))
# correct data for BG noise
correctedData &lt;- correctDilinterc(dilseries=fgRaw[which(fgRaw$sample_type=="control" &amp;
!is.na(fgRaw$dilSeriesID)),], arraydesc=rawdata$arraydescription,
timeseries=fgRaw[which(fgRaw$sample_type=="measurement"),], exportNo=2)

## End(Not run)

</code></pre>

<hr>
<h2 id='curvePredictSigmoid'>
Sigmoidal curve prediction.
</h2><span id='topic+curvePredictSigmoid'></span>

<h3>Description</h3>

<p>3-parameter sigmoidal curve.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>curvePredictSigmoid(x, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="curvePredictSigmoid_+3A_x">x</code></td>
<td>

<p>Input value(s).
</p>
</td></tr>
<tr><td><code id="curvePredictSigmoid_+3A_params">params</code></td>
<td>

<p>Parameter vector containing three parameters alpha, beta and gamma.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The model is defined as <code>alpha + beta*(2^(x*gamma))/(1+2^(x*gamma)))</code>.
</p>


<h3>Value</h3>

<p>The prediction f(x) of the input value(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- seq(-5, 5, by=0.1)
y &lt;- curvePredictSigmoid(x, c(alpha=2, beta=1, gamma=1.5))
plot(x, y)

## End(Not run)
</code></pre>

<hr>
<h2 id='dataI'> Reverse phase protein array rawdata, samples serially diluted</h2><span id='topic+dataI'></span>

<h3>Description</h3>

<p>The data Set is a list of four elements. Expression and background are matrices
containing signal intensities, the data frames arraydescription and sampledescription
comprising feature and phenodata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataI)</code></pre>


<h3>Format</h3>

<p>list
</p>


<h3>Details</h3>

<p>The data set is a list of four elements with data of a original reverse phase
array experiment. The elements expression and background are 2304 times 26 matrices
containing integers describing the signal intensities and local background for every spot of the
experiment as generated with image analysis software.
Arraydescription is a data frame, describing the incubation of every array
refering the column of the expression and background matrix. Required rows are target
and AB_ID with characters and array.id (four integers linked with &quot;-&quot;).
Sampledescription is a data frame according to the rows of expression and
background matrix and annotates the samples. Sampledescription requires the
columns &quot;ID&quot;, &quot;sample_type&quot;, &quot;sample&quot;, &quot;concentration&quot;, and &quot;dilution&quot;
as minimal information and &quot;sample.n&quot; to separate different sample groups.
</p>


<h3>Source</h3>

<p>The data set contains original reverse phase protein array signals
with randomized pheno and feature data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dataI)
str(dataI)

</code></pre>

<hr>
<h2 id='dataII'> Reverse phase protein array data, samples from a stimulation time course</h2><span id='topic+dataII'></span>

<h3>Description</h3>

<p>The data Set is a list of four elements. <code>Sample.median</code> and <code>sample.mads</code> are matrices
containing logged signal intensities and errors, the data frames arraydescription and sampledescription
comprising feature and phenodata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataII)</code></pre>


<h3>Format</h3>

<p>List
</p>


<h3>Details</h3>

<p>The data set is a list of four elements with data of a original reverse phase
array experiment. The elements <code>Sample.median</code> and <code>sample.mads</code> are 624 times 12 matrices
containing logged signal intensities and errors for every sample of the
experiment. The values are background corrected and normalized against total protein content.
Arraydescription is a data frame, describing the incubation of every array
refering the column of the matrices. Required rows are target
and AB_ID with characters and array.id (four integers linked with &quot;-&quot;).
Sampledescription is a data frame according to the rows of the
matrices annotating the samples. The columns &quot;sample&quot;, &quot;stimulation&quot;,
&quot;inhibition&quot;, &quot;stim_concentration&quot;, and &quot;time&quot;
are describing the time course experiment.
</p>


<h3>Source</h3>

<p>The data set contains original reverse phase protein array signals
from a stimulation time course experiment with randomized pheno and feature data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dataII)
str(dataII)

</code></pre>

<hr>
<h2 id='dataIII'> Reverse phase protein array data from original cancer specimen</h2><span id='topic+dataIII'></span>

<h3>Description</h3>

<p>The data Set is a list of four elements. Expression and background are matrices
containing signal intensities, the data frames arraydescription and sampledescription
comprising feature and phenodata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataIII)</code></pre>


<h3>Format</h3>

<p>List
</p>


<h3>Details</h3>

<p>The data set is a list of four elements with data of a original reverse phase
array experiment. The elements expression and background are 384 times 75 matrices
containing integers describing the signal intensities and local background for every spot of the
experiment as generated with image analysis software.
Arraydescription is a data frame, describing the incubation of every array
refering the column of the expression and background matrix. Required rows are target
and AB_ID with characters and array.id (four integers linked with &quot;-&quot;).
Sampledescription is a data frame according to the rows of expression and
background matrix and annotates the samples.
</p>


<h3>Source</h3>

<p>The data set contains original reverse phase protein array signals
from cancer specimen with randomized pheno and feature data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(dataIII)
str(dataIII)

</code></pre>

<hr>
<h2 id='dataPreproc'>
Data preprocessing
</h2><span id='topic+dataPreproc'></span>

<h3>Description</h3>

<p>Function for import, normalization and quality checks of data prior to the actual analysis.
The preprocessing steps include subtraction of dilution series intercepts and FCF normalization.
Additionally plots for quality checks are generated including dilutions and BLANK measurements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dataPreproc(dataDir=getwd(), blocks=12, spot="aushon",
  exportNo=3, correct="both", remove_flagged=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dataPreproc_+3A_datadir">dataDir</code></td>
<td>
<p>directory of gpr files, slidedescription.txt and sampledescription.txt, default is the current working directory</p>
</td></tr>
<tr><td><code id="dataPreproc_+3A_blocks">blocks</code></td>
<td>
<p>see <code>blocksperarray</code> in <code><a href="#topic+read.Data">read.Data</a></code>, default is 12</p>
</td></tr>
<tr><td><code id="dataPreproc_+3A_spot">spot</code></td>
<td>
<p>see <code>spotter</code> in <code><a href="#topic+read.Data">read.Data</a></code>, default is &quot;aushon&quot;</p>
</td></tr>
<tr><td><code id="dataPreproc_+3A_exportno">exportNo</code></td>
<td>
<p>see <code>exportNo</code> in <code><a href="#topic+correctDilinterc">correctDilinterc</a></code>, integer of 1-4 defining the linear fit to be used (1: constant, 2: antibody, 3: antibody + slide, 4: antibody + slide + sample), default is 3</p>
</td></tr>
<tr><td><code id="dataPreproc_+3A_correct">correct</code></td>
<td>
<p>&quot;both&quot; applies <code><a href="#topic+correctDilinterc">correctDilinterc</a></code> to all measurements, including FCF. &quot;none&quot; does not use this BG correction at all. &quot;noFCF&quot; applies <code><a href="#topic+correctDilinterc">correctDilinterc</a></code> to all but not FCF measurements. The default is &quot;both&quot;.</p>
</td></tr>
<tr><td><code id="dataPreproc_+3A_remove_flagged">remove_flagged</code></td>
<td>
<p>Either NULL or an integer. If an integer, looks into column <code>Flags</code> of the gpr file and removes samples with flag value less than or equal <code>-remove_flagged</code> from the data tables.</p>
</td></tr>  
</table>


<h3>Value</h3>

<p>A list of 4 elements is returned.
</p>
<table>
<tr><td><code>rawdat</code></td>
<td>
<p>list of 4 raw data elements (<code>expression</code> and <code>background</code> matrices, <code>arraydescription</code> and <code>sampledescription</code> data frames) according to <code><a href="#topic+read.Data">read.Data</a></code></p>
</td></tr>
<tr><td><code>cordat</code></td>
<td>
<p>list of 4 elements like <code>rawdat</code> with <code>expression</code> data corrected to dilution intercepts, in case of resulting negative values the absoulte minimum + 1 is added, <code>expression</code> data is without NAs and is reduced to the <code>measurement</code> sample type, <code>background</code> is not corrected to intercepts, as it is not used here. If <code>correct</code> is &quot;noFCF&quot;, the FCF measurements stay as in rawdat. If <code>correct</code> is &quot;none&quot;, the measurements stay as in rawdat.</p>
</td></tr>
<tr><td><code>normdat</code></td>
<td>
<p>list of 4 elements like <code>cordat</code> with <code>expression</code> as dilution intercept (<code>correct</code> &quot;both&quot; or &quot;noFCF&quot;) and FCF normalized foreground data, the neglected background data are renamed here to <code>dummy</code> and should not be used</p>
</td></tr>
<tr><td><code>DIR</code></td>
<td>
<p>directory for storing the generated outputs</p>
</td></tr>
</table>
<p>All output files are stored in an analysis folder labeled by the date of analysis.
The txt files <code>Dataexpression</code> and <code>Databackground</code> result from <code><a href="#topic+write.Data">write.Data</a></code> and store the raw data.
The pdf files <code>getIntercepts_Output</code> and <code>anovaIntercepts_Output</code> result from <code><a href="#topic+correctDilinterc">correctDilinterc</a></code>.  
<code>getIntercepts_Output</code> shows the derived intercepts and smoothing splines of dilution series in dependence of the <code>dilSeriesID</code> column in sampledescription.txt and the slide/pad/incubationRun/spottingRun columns of the <code>arraydescription</code> matrix.
<code>anovaIntercepts_Output.pdf</code> results from the ANOVA in <code><a href="#topic+correctDilinterc">correctDilinterc</a></code>, comparing different linear models of the dilution series intercepts. The barplot displays the residual sum of squares (RSS) of the individual model fits. It helps to choose the appropriate <code>exportNo</code> parameter. As RSS decreases, the model fits better.
Finally, three pdf files for quality checking are returned. 
<code>QC_dilutioncurve_raw.pdf</code> plots target and blank (2nd antibody only) signals from serially diluted control samples of the raw RPPA data set, see <code><a href="#topic+plotQC">plotQC</a></code>.
<code>QC_targetVSblank_normed.pdf</code> plots blank signals vs. target specific signals of dilution intercept corrected and FCF normalized RPPA data, see <code><a href="#topic+plotMeasurementsQC">plotMeasurementsQC</a></code>.
<code>QC_qqPlot_normed.pdf</code> contains qq-plots of dilution intercept corrected and FCF normalized RPPA data, see <code><a href="#topic+plotqq">plotqq</a></code>.
</p>


<h3>Author(s)</h3>

<p>Silvia von der Heyde
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(RPPanalyzer)



# get output list 
dataDir&lt;-system.file("extdata",package="RPPanalyzer")
res&lt;-dataPreproc(dataDir=dataDir,blocks=12,spot="aushon",exportNo=4,correct="both")

# get individual elements
# raw data
rawdat&lt;-res$rawdat
# dilution intercept corrected data
cordat&lt;-res$cordat
# dilution intercept corrected and FCF normalized data
normdat&lt;-res$normdat
# output directory
DIR&lt;-res$DIR


## End(Not run)
</code></pre>

<hr>
<h2 id='getErrorModel'>

Estimates error model parameters var0 (basal variance) and varR (relative variance) and produces a new data.frame with the signals and error model parameters.
</h2><span id='topic+getErrorModel'></span>

<h3>Description</h3>


<p>The method is based on a maximum-likelihood estimation. The model prediction is the expected variance given the signal, depending on var0 and varR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getErrorModel(dataexpression, verbose=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getErrorModel_+3A_dataexpression">dataexpression</code></td>
<td>
<p>data.frame, standard output from RPPanalyzer's <code><a href="#topic+write.Data">write.Data</a></code>.</p>
</td></tr>
<tr><td><code id="getErrorModel_+3A_verbose">verbose</code></td>
<td>
<p>logical, if TRUE, the function prints out additional information and produces a PDF file in the working directory with the signal vs. variance plots.</p>
</td></tr>
</table>


<h3>Details</h3>


<p>The empirical variance estimator is <code class="reqn">\chi^2</code> distributed with <code class="reqn">n-2</code> degrees of freedom, where <code class="reqn">n</code> is the number of technical replicates. The estimated error parameters maximize the corresponding log-likelihood function. At the moment, the code assumes <code class="reqn">n=3</code>. For cases <code class="reqn">n&gt;3</code>, the error parameters are slightly overestimated, thus, providing a conservative result. The explicit error model is
</p>
<p style="text-align: center;"><code class="reqn">\sigma^2(S) = \sigma_0^2 + S^2\sigma_R^2 = var0 + varR S^2</code>
</p>

<p>where <code class="reqn">S</code> is the signal strength.
</p>


<h3>Value</h3>






<table>
<tr><td><code>data.frame</code></td>
<td>
<p>with columns &quot;slide&quot; (factor, the slide names), &quot;ab&quot; (factor, the antibody/target names), &quot;time&quot; (numeric, the time points), &quot;signal&quot; (numeric, signal values), &quot;var0&quot; (numeric, error parameter for the constant error, equivalent to sigma0^2), &quot;varR&quot; (numeric, error parameter for the relative error, equivalent to sigmaR^2) and other columns depending on the input data.frame</p>
</td></tr>
</table>


<h3>Author(s)</h3>


<p>Daniel Kaschek, Physikalisches Institut, Uni Freiburg. Email: <code>daniel.kaschek@physik.uni-freiburg.de</code>
</p>

<hr>
<h2 id='HKdata'> Reverse phase protein array data of siRNA transfected cell line</h2><span id='topic+HKdata'></span>

<h3>Description</h3>

<p>The data Set is a list of four elements. Expression and background are matrices
containing signal intensities, the data frames arraydescription and sampledescription
comprising feature and phenodata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(HKdata)</code></pre>


<h3>Format</h3>

<p>List
</p>


<h3>Details</h3>

<p>The data set is a list of four elements with data of a original reverse phase
array experiment. The elements expression and background are 768 times 21 matrices
containing integers describing the signal intensities and local background for every spot of the
experiment as generated with image analysis software.
Arraydescription is a data frame, describing the incubation of every array
refering the column of the expression and background matrix. Required rows are target
and AB_ID with characters and array.id (four integers linked with &quot;-&quot;).
Sampledescription is a data frame according to the rows of expression and
background matrix and annotates the samples.
</p>


<h3>Source</h3>

<p>The data set contains original reverse phase protein array of siRNA transfected cell line
with randomized pheno and feature data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(HKdata)
str(HKdata)

</code></pre>

<hr>
<h2 id='logList'>
Logarithmize (log2) the first two RPPA list elements, i.e. foreground and background signal intensities
</h2><span id='topic+logList'></span>

<h3>Description</h3>

<p>Function to logarithmize (log2) the first two RPPA list elements, i.e. foreground and background signal intensities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  logList(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logList_+3A_x">x</code></td>
<td>
<p>list of 4 elements (<code>expression</code> and <code>background</code> data matrices, <code>arraydescription</code> and <code>sampledescription</code> data frames) according to <code><a href="#topic+read.Data">read.Data</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>x.log</code></td>
<td>
<p>list of 4 elements like the input but with log2 values of <code>expression</code> and <code>background</code> matrices</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Silvia von der Heyde
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(RPPanalyzer)

  
  
# input data
dataDir&lt;-system.file("extdata",package="RPPanalyzer")
x&lt;-dataPreproc(dataDir=dataDir, blocks=12, spot="aushon", exportNo=4)
x.norm&lt;-x$normdat

# get log2 list 
x.log&lt;-logList(x.norm)


## End(Not run)
</code></pre>

<hr>
<h2 id='normalizeRPPA'> Normalizes data in an RPPA data list </h2><span id='topic+normalizeRPPA'></span>

<h3>Description</h3>

<p>Normalizes data in an RPPA data list. Four different normalization methods
are provided: using externally measured protein concentration, signals from
housekeeping proteins or protein dyes and row normalization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalizeRPPA(x, method = "row", normalizer = "housekeeping", useCol = "BCA",
writetable = F,vals="logged")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalizeRPPA_+3A_x">x</code></td>
<td>
<p> List containing RPPA data set </p>
</td></tr>
<tr><td><code id="normalizeRPPA_+3A_method">method</code></td>
<td>
<p> character string: one of <code>proteinDye</code>,<code>row</code>,
<code>housekeeping</code>,<code>extValue</code>   </p>
</td></tr>
<tr><td><code id="normalizeRPPA_+3A_normalizer">normalizer</code></td>
<td>
<p> character string describing the target in slidedescription
that should be used for normalization using <code>housekeeping</code> </p>
</td></tr>
<tr><td><code id="normalizeRPPA_+3A_usecol">useCol</code></td>
<td>
<p> character string describing the column in sampledescription
that should be used for normalization using the method <code>extValue</code>. </p>
</td></tr>
<tr><td><code id="normalizeRPPA_+3A_writetable">writetable</code></td>
<td>
<p> logical. If true data are exported as tab delimited text
files to current working directory </p>
</td></tr>
<tr><td><code id="normalizeRPPA_+3A_vals">vals</code></td>
<td>
<p> the data is returned at log2 scale with substracted normalizer
value per default. If argument is set to <code>native</code> the median of the normalizer
values is added after normalization and the data is returned at native scale.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provides four different methods to normalize RPPA data to ensure
that an optimal data quality. The default method <code>row</code> uses the expression
matrix: after taking the logarithm the row median is substracted from each
value of one row assuming that the median expression over all targets of one
sample is representing total protein amount of the spots. For the method
<code>proteinDye</code> arrays with the pattern <code>protein</code> in the target
description are used for normalization. For every spotting run a separate
protein slide is required. If the slides containing more than one array, the
arrays will be normalized by the corresponding <code>protein</code> array. To use
external protein assay data for normalization, a column containing the protein
concentration has to be added to the sampledescription file. The name of this
column is addressed via the <code>useCol</code> argument. To use any other target
for normalization the method <code>housekeeping</code> can be used. The target
for this method has to be addressed via the <code>normalizer</code> argument.
</p>


<h3>Value</h3>

<table>
<tr><td><code>expression</code></td>
<td>
<p>matrix with protein expression data</p>
</td></tr>
<tr><td><code>dummy</code></td>
<td>
<p>matrix with protein expression data</p>
</td></tr>
<tr><td><code>arraydescription</code></td>
<td>
<p>data frame with feature data</p>
</td></tr>
<tr><td><code>sampledescription</code></td>
<td>
<p>data frame with pheno data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heiko Mannsperger &lt;h.mannsperger@dkfz-heidelberg.de&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	library(RPPanalyzer)
	data(dataI)
	dataI_bgcorr &lt;- correctBG(dataI,method="normexp")
	dataIb &lt;- pick.high.conc(dataI_bgcorr,highest="dilution")
	normRow &lt;- normalizeRPPA(dataIb,method="row")
	normDye &lt;- normalizeRPPA(dataIb,method="proteinDye")
	normPassay &lt;- normalizeRPPA(dataIb,method="extValue",useCol="concentration")
	normHK &lt;-  normalizeRPPA(dataIb,method="housekeeping",normalizer="housekeeping")

## End(Not run)
</code></pre>

<hr>
<h2 id='pick.high.conc'>
Select the highest concentration from serialy diluted samples
</h2><span id='topic+pick.high.conc'></span>

<h3>Description</h3>

<p>Picks the dilution step with the value 1 from serialy diluted samples in an
RPPA data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   pick.high.conc(x, highest = ("dilution"), sample.id=c("sample","sample.n"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pick.high.conc_+3A_x">x</code></td>
<td>
<p>Any RPPA data list with 4 elements</p>
</td></tr>
<tr><td><code id="pick.high.conc_+3A_highest">highest</code></td>
<td>
<p>Character string describing the column that contains the dilution steps</p>
</td></tr>  
<tr><td><code id="pick.high.conc_+3A_sample.id">sample.id</code></td>
<td>
<p>Attributes to identify the samples</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function selects all spots or samples from a RPPA data set with the value
1 in the column of the sampledescription denoted in argument <code>highest</code>.
</p>


<h3>Value</h3>

<p>An RPPA data list containing only the samples with the highest concentration of each dilution series.
</p>


<h3>Author(s)</h3>

<p>Heiko Mannsperger &lt;h.mannsperger@dkfz.de&gt;, Stephan Gade &lt;s.gade@dkfz.de&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
   library(RPPanalyzer)
   data(ser.dil.samples)

   dataHighcon &lt;- pick.high.conc(ser.dil.samples,highest="dilution")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotMeasurementsQC'> Scatter Plots from an RPPA data </h2><span id='topic+plotMeasurementsQC'></span>

<h3>Description</h3>

<p>Plots the blank signals and the target specific signals of an RPPA data list
in a PDF file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   plotMeasurementsQC(x, file = "QC_plots.pdf", arrays2rm = c("protein"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMeasurementsQC_+3A_x">x</code></td>
<td>
<p> RPPA data list as output from <code>read.Data</code> </p>
</td></tr>
<tr><td><code id="plotMeasurementsQC_+3A_file">file</code></td>
<td>
<p> name of the PDF file that will be exported </p>
</td></tr>
<tr><td><code id="plotMeasurementsQC_+3A_arrays2rm">arrays2rm</code></td>
<td>
<p> character describing the arrays that dont have be plotted </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function genrates scatter plots in a pdf file from not yet normalized samples
(annotated as <code>measurement</code> in the <code>sample_type</code> column
of the sampledescription file) of RPPA data to get an impression of the distance
from the blank signal to the target specific signal.
An array with blank as target description is needed.
</p>


<h3>Value</h3>

<p>Genrates a PDF file
</p>


<h3>Author(s)</h3>

<p> Heiko Mannsperger &lt;h.mannsperger@dkfz.de&gt; </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	library(RPPanalyzer)
	data(dataIII)
   plotMeasurementsQC(dataIII,file="control_plot.pdf")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotQC'> Plot target and blank signal from RPPA control samples</h2><span id='topic+plotQC'></span>

<h3>Description</h3>

<p>Plots target and blank signal from control samples of an RPPA data set in one plot.
Exports pdf file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotQC(x, file = "target_vs_blank.pdf", arrays2rm = c("protein"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotQC_+3A_x">x</code></td>
<td>
<p> RPPA data list as output from <code>read.Data</code> </p>
</td></tr>
<tr><td><code id="plotQC_+3A_file">file</code></td>
<td>
<p> name of the PDF file </p>
</td></tr>
<tr><td><code id="plotQC_+3A_arrays2rm">arrays2rm</code></td>
<td>
<p> character describing the arrays that dont have be plotted </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function genrates scatter plots in a pdf file from not yet normalized, serially diluted
control samples (annotated as <code>control</code> in the <code>sample_type</code> column
of the sampledescription file) of RPPA data to get an impression of the antibody dynamic. An
array with blank as target description is needed.
</p>


<h3>Value</h3>

<p>generates a PDF file
</p>


<h3>Author(s)</h3>

<p> Heiko Mannsperger &lt;h.mannsperger@dkfz.de&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(RPPanalyzer)
data(dataIII)

plotQC(dataIII,file="plotQC.pdf")

## End(Not run)
</code></pre>

<hr>
<h2 id='plotqq'> qq-plot and qq-line of an RPPA data set </h2><span id='topic+plotqq'></span>

<h3>Description</h3>

<p>Draws a qq-plot and qq-line from measurements samples of a RPPA data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   plotqq(x, fileName = "qqplot_and_line.pdf")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotqq_+3A_x">x</code></td>
<td>
<p> RPPA data list as output from <code>read.Data</code> </p>
</td></tr>
<tr><td><code id="plotqq_+3A_filename">fileName</code></td>
<td>
<p> name of the PDF file </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function implements the functions <code>qqnorm</code> and <code>qqline</code> from
stats package to get an impression of the data distribution in an RPPA data set.
</p>


<h3>Value</h3>

<p>generates a PDF file.
</p>


<h3>Author(s)</h3>

<p> Heiko Mannsperger &lt;h.mannsperger@dkfz.de&gt; </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	library(RPPanalyzer)
	data(dataIII)
	plotqq(dataIII,file="dataIII_qqplot.pdf")
    
## End(Not run)
</code></pre>

<hr>
<h2 id='plotTimeCourse'> Draw time course from RPPA data </h2><span id='topic+plotTimeCourse'></span>

<h3>Description</h3>

<p>Draws time course data from a RPPA data list and calculates a mathematical
model on the time course data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotTimeCourse(x, tc.identifier = 
			c("sample", "stimulation", "inhibition", "stim_concentration"),
		tc.reference=NULL, plot.split = "experiment", file = NULL,
		arrays2rm = c("protein", "Blank"), plotformat = "stderr",
		log=TRUE, color=NULL, xlim = NULL, ylim = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTimeCourse_+3A_x">x</code></td>
<td>
<p> List containing RPPA data set </p>
</td></tr>
<tr><td><code id="plotTimeCourse_+3A_tc.identifier">tc.identifier</code></td>
<td>
<p> character string describing the column names in the
sampledescription that identifies the individual time course experiments</p>
</td></tr>
<tr><td><code id="plotTimeCourse_+3A_tc.reference">tc.reference</code></td>
<td>
<p> character string describing the sample that will be used
as reference for the time course plots.</p>
</td></tr>
<tr><td><code id="plotTimeCourse_+3A_plot.split">plot.split</code></td>
<td>
<p> character string describing the column names in
sampledescription that defines the argument that devides between different plots </p>
</td></tr>
<tr><td><code id="plotTimeCourse_+3A_file">file</code></td>
<td>
<p> character string for the name of the exported file </p>
</td></tr>
<tr><td><code id="plotTimeCourse_+3A_arrays2rm">arrays2rm</code></td>
<td>
<p> character strings identifying the targets that should be
from the time course plots </p>
</td></tr>
<tr><td><code id="plotTimeCourse_+3A_plotformat">plotformat</code></td>
<td>
<p> character string defining the plot type: <code>rawdata</code> for 
plotting the connected medians plus standard deviation of the data, 
<code>spline</code> and <code>both</code> for plotting the a spline fit through the data
or both raw data and spline, as well as a confidence band showing the standard
error of the spline fit; <code>spline_noconf</code> only plots the spline without
confidence band. <code>errbar</code> will show the spline fit plus raw data
without connecting the medians by a line, <code>stderr</code> will show 
a less crowded version of the spline plus standard error represented 
as simple error bars (which is the default). </p>
</td></tr>
<tr><td><code id="plotTimeCourse_+3A_log">log</code></td>
<td>
<p>logical, if true time courses signal intensities will be plotted
at log2 scale</p>
</td></tr>
<tr><td><code id="plotTimeCourse_+3A_color">color</code></td>
<td>
<p> Vector holding the colors for the samples to be plot. If NULL, colors will be generated. </p>
</td></tr>
<tr><td><code id="plotTimeCourse_+3A_xlim">xlim</code></td>
<td>
<p> Limits for x-axis. If NULL (default) limits are generated for each timeseries plot. 
If a range (numeric vector of length 2) is given, this is used for all plots. </p>
</td></tr>
<tr><td><code id="plotTimeCourse_+3A_ylim">ylim</code></td>
<td>
<p> Analogous to <code>xlim</code> for y-axis limits. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots RPPA time course experiments from data sets with aggregated
replicate spots. A column <code>time</code> containing numeric values is required in the sampledescription file.
One or several column in the sampledescription file should be
able to indentify the individual experiments described in argument <code>tc.identifier</code>.
One column should provide a parameter <code>plot.split</code> to split the whole data set into different
comparable time courses that have to be plotted together.<br />
</p>
<p>Different plotting options can be specified with the argument <code>plotformat</code>. Option <code>both</code> is 
most informative, since it shows the original data plus standard deviations
at each time point, combined with a spline fit and the standard error
of the fit.
</p>


<h3>Value</h3>

<p>generates a PDF file</p>


<h3>Author(s)</h3>

<p>Heiko Mannsperger &lt;h.mannsperger@dkfz.de </p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	library(RPPanalyzer)
	data(dataII)
	plotTimeCourse(dataII,
		tc.identifier=c("sample","stimulation","stim_concentration","inhibition")
        ,plot.split="experiment",plotformat="stderr")
    plotTimeCourse(dataII,
		tc.identifier=c("sample","stimulation","stim_concentration","inhibition")
        ,plot.split="experiment",plotformat="errbar")
    plotTimeCourse(dataII,
		tc.identifier=c("sample","stimulation","stim_concentration","inhibition")
        ,plot.split="experiment",plotformat="both")
    plotTimeCourse(dataII,
		tc.identifier=c("sample","stimulation","stim_concentration","inhibition")
        ,plot.split="experiment",plotformat="rawdata")
    plotTimeCourse(dataII,
		tc.identifier=c("sample","stimulation","stim_concentration","inhibition")
        ,plot.split="experiment",plotformat="spline")
    plotTimeCourse(dataII,
		tc.identifier=c("sample","stimulation","stim_concentration","inhibition")
        ,plot.split="experiment",plotformat="spline_noconf")
               

## End(Not run)
</code></pre>

<hr>
<h2 id='plotTimeCourseII'>
Multiplot function for RPPA time course datasets
</h2><span id='topic+plotTimeCourseII'></span>

<h3>Description</h3>

<p>plotTimeCourseII creates multiplot rectangular PDF files for time course datasets. Page layout (number of plots per page, arrangement of plots) and plot layout can be customized within the function.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    plotTimeCourseII(x,plotgroup="",filename="timeseries_multiplot.pdf",numpage=4,
	cols=2,xname="time",yname="signal",legpos="top",legrow=2,legtitle="treatment",
	legtitlepos="top",legtextsize=10,legtextcolor="black",legtitlesize=10,
	legtitlecolor="black",legtitleface="bold",legitemsize=1,plottitlesize=12,
	plottitleface="bold",xaxissize=10,yaxissize=10,xaxisface="bold",
	yaxisface="bold",xaxistextsize=8,xaxistextangle=0,yaxistextsize=8,
	linecolor="Set1")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotTimeCourseII_+3A_x">x</code></td>
<td>

<p>RPPA time course dataset preprocessed with the getErrorModel and averageData function
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_plotgroup">plotgroup</code></td>
<td>

<p>select the feature (eg. treatment) which should be plotted in one plot
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_filename">filename</code></td>
<td>

<p>enter filename, DIR needs to be defined as your working directory, add .pdf to filename
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_numpage">numpage</code></td>
<td>

<p>number of plots per page
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_cols">cols</code></td>
<td>

<p>number of plot columns per page
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_xname">xname</code></td>
<td>

<p>title of the x axis
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_yname">yname</code></td>
<td>

<p>title of the y axis
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_legpos">legpos</code></td>
<td>

<p>postion of the legend in context of the plot (&quot;top&quot;,&quot;bottom&quot;,&quot;right&quot;,&quot;left&quot;), &quot;none&quot; removes legend from plot
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_legrow">legrow</code></td>
<td>

<p>number of item rows within the legend
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_legtitle">legtitle</code></td>
<td>

<p>title of the legend
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_legtitlepos">legtitlepos</code></td>
<td>

<p>position of the legend title
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_legtextsize">legtextsize</code></td>
<td>

<p>font size of the legend text
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_legtextcolor">legtextcolor</code></td>
<td>

<p>color of the legend text
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_legtitlesize">legtitlesize</code></td>
<td>

<p>font size of the legend title
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_legtitlecolor">legtitlecolor</code></td>
<td>

<p>color of the legend title
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_legtitleface">legtitleface</code></td>
<td>

<p>font face of the legend title (eg. &quot;bold&quot;)
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_legitemsize">legitemsize</code></td>
<td>

<p>size of the legend item pictures
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_plottitlesize">plottitlesize</code></td>
<td>

<p>size of the plot title
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_plottitleface">plottitleface</code></td>
<td>

<p>font face of the plot title
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_xaxissize">xaxissize</code></td>
<td>

<p>font size of the x axis title
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_yaxissize">yaxissize</code></td>
<td>

<p>font size of the y axis title
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_xaxisface">xaxisface</code></td>
<td>

<p>font face of the x axis title
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_yaxisface">yaxisface</code></td>
<td>

<p>font face of the y axis title
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_xaxistextsize">xaxistextsize</code></td>
<td>

<p>font size of the x axis text
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_xaxistextangle">xaxistextangle</code></td>
<td>

<p>angle of the x axis text
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_yaxistextsize">yaxistextsize</code></td>
<td>

<p>font size of the y axis text
</p>
</td></tr>
<tr><td><code id="plotTimeCourseII_+3A_linecolor">linecolor</code></td>
<td>

<p>color of the plot lines: either chose a scheme (&quot;Set1&quot;,&quot;Dark2&quot;,&quot;Paired&quot;) or hand a vector of color names
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plotTimeCourseII function plots RPPA timecourse datasets in multiple line charts. For each cell line
and target protein a separate plot is created. The average foldchange values of different replicates and the
error bars are visualized. In order to be visualized by the plotTimeCourseII function, the dataset needs
to be preprocessed by the getErrorModel and averageData function from the RPPanalyzer package.  
Additionally the plotgroup needs to be defined if it is not named ?treatment?. The remaining arguments
are optional. 
</p>


<h3>Value</h3>

<p>Generates a PDF file.
</p>


<h3>Author(s)</h3>

<p>Johannes Bues (j.bues@dkfz-heidelberg.de)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# pre-process the data
dataDir &lt;- system.file("extdata", package="RPPanalyzer")
res &lt;- dataPreproc(dataDir=dataDir, blocks=12, spot="aushon", exportNo=2)
# remove arrays
normdat_rm &lt;- remove.arrays(res$normdat, param="target", arrays2rm=c("protein","blank"))
# select samples and export data
sel_sampels_A549 &lt;- select.sample.group(normdat_rm, params=list("cell_line"="A549"), combine= FALSE)
write.Data(sel_sampels_A549, FileNameExtension="HGF_sample_data_A549")
# read selected data
dataexpression_1 &lt;- read.table("HGF_sample_data_A549expression.txt")
# use getErrorModel function
dataexpression_2 &lt;- getErrorModel(dataexpression_1, verbose=FALSE)
# use averageData function
dataexpression_3 &lt;- averageData(dataexpression_2, scaling=c("slide","replicate"), 
distinguish=c("cell_line","treatment"))
# plot time course data
plotTimeCourseII(dataexpression_3, filename="timecourse_HGF_sample_data_A549.pdf", 
legpos="top", xname="time [min]",
yname="signal [a.u.]", linecolor=c("red","green","blue","black","orange","grey"))


## End(Not run)
</code></pre>

<hr>
<h2 id='read.Data'>
Read and Annotate RPPA rawdata
</h2><span id='topic+read.Data'></span>

<h3>Description</h3>

<p>reads sampledescription and slidedescription txt files
and annotates the median expression value in GenePix 	result files stored
in current working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   read.Data(blocksperarray = 4, spotter = "arrayjet", writetable = FALSE,
   printFlags=FALSE,fileName="Flagged_spots.csv", remove_flagged=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.Data_+3A_blocksperarray">blocksperarray</code></td>
<td>

<p>Integer describing the number of blocks in one array.
</p>
</td></tr>
<tr><td><code id="read.Data_+3A_spotter">spotter</code></td>
<td>

<p>character strings: default <code>arrayjet</code> or <code>aushon</code>.
</p>
</td></tr>
<tr><td><code id="read.Data_+3A_writetable">writetable</code></td>
<td>
<p> logical. If true data are exported as tab delimited text
files to current working directory
</p>
</td></tr>
<tr><td><code id="read.Data_+3A_printflags">printFlags</code></td>
<td>
<p>logical. If true flagged spots will exported as csv file</p>
</td></tr>
<tr><td><code id="read.Data_+3A_filename">fileName</code></td>
<td>
<p>character string naming the csv file for the flagged spots</p>
</td></tr>
<tr><td><code id="read.Data_+3A_remove_flagged">remove_flagged</code></td>
<td>
<p>Either NULL or an integer. If an integer, looks into column <code>Flags</code> of the gpr file and removes samples with flag value less than or equal <code>-remove_flagged</code> from the data tables.</p>
</td></tr>
<tr><td><code id="read.Data_+3A_...">...</code></td>
<td>
<p>any other arguments passed to read.gpr</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reads and annotates RPPA rawdata provided in three different
kind of files.
It is very important that these data files are in a correct format and stored
in the same folder.
</p>
<p>The file sampledescription.txt has to be a tab delimited
text file with at least 6 columns named plate, column, row, sample_type, sample,
concentration and in case of serially diluted samples a column dilution is required.
The first 3 columns are describing the location of the sample in the source well plate.
The 4th column describes the for different types of samples: measurement, control,
neg_control or blank. In the column sample any character string describing the sample is possible.
The column concentration has to contain only numerical values. Columns
with further phenodata can be added.
</p>
<p>The slidedescription.txt describes the array properties. Required columns are:
gpr (describing the name of the corresponding gpr file), the columns
pad, slide, incubation_run, spotting_run containing integers are generating a unique array identifier.
The column target describes the analyzed target and AB_ID the used antibody.
Column with further feature data can be added.
</p>
<p>The third kind of files are the gpr files as results from image analysis
software GenePix using the galfile from a aushon or arrayjet spotter.
</p>


<h3>Value</h3>

<table>
<tr><td><code>expression</code></td>
<td>
<p>matrix with protein expression data</p>
</td></tr>
<tr><td><code>background</code></td>
<td>
<p>matrix with background data</p>
</td></tr>
<tr><td><code>arraydescription</code></td>
<td>
<p>data frame with feature data</p>
</td></tr>
<tr><td><code>sampledescription</code></td>
<td>
<p>data frame with pheno data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heiko Mannsperger &lt;h.mannsperger@dkfz-heidelberg.de&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  library(RPPanalyzer)
  
  
  dataDir &lt;- system.file("extdata", package="RPPanalyzer")
  setwd(dataDir)
  rawdata &lt;- read.Data(blocksperarray=12, spotter="aushon", printFlags=FALSE, remove_flagged=NULL)
  print(dim(rawdata$expression))
  
  rawdata &lt;- read.Data(blocksperarray=12, spotter="aushon", printFlags=FALSE, remove_flagged=50)
  print(dim(rawdata$expression))
  
## End(Not run)
  
  </code></pre>

<hr>
<h2 id='remove.arrays'>
Remove arrays from a RPPA data list
</h2><span id='topic+remove.arrays'></span>

<h3>Description</h3>

<p>Removes arrays from the RPPA data set which are not used in following calculations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove.arrays(x, param = "target", arrays2rm = c("protein", "blank", "housekeeping"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove.arrays_+3A_x">x</code></td>
<td>

<p>List with RPPA data set
</p>
</td></tr>
<tr><td><code id="remove.arrays_+3A_param">param</code></td>
<td>

<p>charater describing a row in the arraydescription (column in slidedescription file) 
</p>
</td></tr>
<tr><td><code id="remove.arrays_+3A_arrays2rm">arrays2rm</code></td>
<td>

<p>character defining the arrays to remove
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The RPPA data list without the arrays specified by <code>arrays2rm</code>.
</p>


<h3>Author(s)</h3>

<p>Heiko Mannsperger &lt;h.mannsperger@dkfz.de&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
        library(RPPanalyzer)
        data(dataIII)
            
        DT &lt;- remove.arrays(dataIII, param = "target", arrays2rm = c("protein"))

## End(Not run)
</code></pre>

<hr>
<h2 id='rppa2boxplot'>Draws boxplots of groups of an RPPA data set including wilcox or kruskal test.</h2><span id='topic+rppa2boxplot'></span>

<h3>Description</h3>

<p>Draws boxplots of groups of an RPPA data set and compares the expression values to a reference group (control) if provided (wilcox.test). Otherwise a test on general differences is performed (kruskal.test). Additionally a grouping order for plotting can be provided here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rppa2boxplot(x, param, control=NULL, orderGrp=NULL, file = "boxplot_groups.pdf")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rppa2boxplot_+3A_x">x</code></td>
<td>
<p> List with RPPA data with aggregated replicate spots </p>
</td></tr>
<tr><td><code id="rppa2boxplot_+3A_param">param</code></td>
<td>
<p> Character value of one of the columns of the sampledescription matrix, i.e. x[[4]], describing the phenodata that should be analyzed </p>
</td></tr>
<tr><td><code id="rppa2boxplot_+3A_control">control</code></td>
<td>
<p>Character value of one of the columns of the sampledescription matrix, i.e. x[[4]], describing the sample group of <code>param</code> that serves as reference in the wilcoxon test. In case of NULL (default) the general kruskal.test is performed instead. </p>
</td></tr>
<tr><td><code id="rppa2boxplot_+3A_ordergrp">orderGrp</code></td>
<td>
<p> defines the ordering of the subgroups in <code>param</code>, i.e. vector of specifically ordered values of <code>param</code> </p>
</td></tr>
<tr><td><code id="rppa2boxplot_+3A_file">file</code></td>
<td>
<p> Title of the file that will be exported.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates a PDF file
</p>


<h3>Author(s)</h3>

<p>Silvia von der Heyde, Heiko Mannsperger</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(RPPanalyzer)
	
data(dataIII)
dataIII_median &lt;- sample.median(dataIII)
rppa2boxplot(x=dataIII_median, param="rank", control="vx",
	orderGrp=c("vx","zx","yzr","rxi"), file="wilcoxonBoxplot.pdf")
rppa2boxplot(x=dataIII_median, param="rank", control=NULL,
	orderGrp=c("vx","zx","yzr","rxi"), file="kruskalBoxplot.pdf")

## End(Not run)
</code></pre>

<hr>
<h2 id='rppaList2ExpressionSet'>
Convert RPPA data into Expression Set
</h2><span id='topic+rppaList2ExpressionSet'></span>

<h3>Description</h3>

<p>Converts a RPPA data list into an Expression Set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   rppaList2ExpressionSet(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rppaList2ExpressionSet_+3A_x">x</code></td>
<td>

<p>List with RPPA data set</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function builds an Expression Set from RPPA data. Due to the design of
RPPA experiments, pheno and feature data are inverted compared to DNA/RNA array
data sets.
</p>


<h3>Value</h3>

<p>object of class Expressionset
</p>


<h3>Author(s)</h3>

<p>Heiko Mannsperger &lt;h.mannsperger@dkfz.de&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	library(RPPanalyzer)
	data(dataI)
   dataI_bgcorr &lt;- correctBG(dataI,method="normexp")
	dataI_median &lt;- sample.median(dataI_bgcorr)
	expr.set &lt;- rppaList2ExpressionSet(dataI_median)
    
## End(Not run)
</code></pre>

<hr>
<h2 id='rppaList2Heatmap'>
Draw a heatmap with column side colors from a RPPA data
</h2><span id='topic+rppaList2Heatmap'></span>

<h3>Description</h3>

<p>Draws a heatmap from an RPPA data set and adds column side colors
visualizing groups of selected phenodata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   rppaList2Heatmap(x, sampledescription = "sample", side.color = "tissue",
   remove = c("blank", "protein", "Abmix"), distance = "eucsq",
   dendros = "both", cutoff = 0.005, fileName = NULL,
   cols = colorpanel(100, low = "blue", mid = "yellow", high = "red"),
   hclust.method="ward", scale = "row")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rppaList2Heatmap_+3A_x">x</code></td>
<td>

<p>List with RPPA data set, aggregatedreplicates 
</p>
</td></tr>
<tr><td><code id="rppaList2Heatmap_+3A_sampledescription">sampledescription</code></td>
<td>

<p>character describing the sample identifier
</p>
</td></tr>
<tr><td><code id="rppaList2Heatmap_+3A_side.color">side.color</code></td>
<td>

<p>character describing the parameter for the side colors of the heatmap
</p>
</td></tr>
<tr><td><code id="rppaList2Heatmap_+3A_remove">remove</code></td>
<td>

<p>character describing the arrays that should removed from the heatmap data
</p>
</td></tr>
<tr><td><code id="rppaList2Heatmap_+3A_distance">distance</code></td>
<td>

<p>character describing the method for the dendrogram
</p>
</td></tr>
<tr><td><code id="rppaList2Heatmap_+3A_dendros">dendros</code></td>
<td>

<p>character: &quot;both&quot; for row and column dendrogram
</p>
</td></tr>
<tr><td><code id="rppaList2Heatmap_+3A_cutoff">cutoff</code></td>
<td>

<p>numeric describing the percentage that are identified as outliers for the
heatmap color distribution
</p>
</td></tr>
<tr><td><code id="rppaList2Heatmap_+3A_filename">fileName</code></td>
<td>

<p>character for the file where the pdf file will be stored. If NULL,
plot to standard plotting device.
</p>
</td></tr>
<tr><td><code id="rppaList2Heatmap_+3A_cols">cols</code></td>
<td>

<p>color key for the heatmap	
</p>
</td></tr>
<tr><td><code id="rppaList2Heatmap_+3A_hclust.method">hclust.method</code></td>
<td>

<p>The method to be used for cluster agglomeration. Defaults to <code>ward</code>.
See help of <code>hclust</code> for options.
</p>
</td></tr>
<tr><td><code id="rppaList2Heatmap_+3A_scale">scale</code></td>
<td>

<p>String. Either <code>row, column, both or none</code> for row or column, both or no scaling, respectively.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generates a PDF file
</p>


<h3>Author(s)</h3>

<p>Heiko Mannsperger &lt;h.mannsperger@dkfz.de&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	library(RPPanalyzer)
	data(dataIII)
	dataIII_median &lt;- sample.median(dataIII)
	
	rppaList2Heatmap(dataIII_median)

## End(Not run)
</code></pre>

<hr>
<h2 id='RPPanalyzer-package'>
Read, annotate and normalize reverse phase protein array data and get a brief overview on the biological impact.
</h2><span id='topic+RPPanalyzer-package'></span><span id='topic+RPPanalyzer'></span>

<h3>Description</h3>

<p>The package reads pheno and feature data of an RPPA experiment from textfiles and annotates the expression values in genepix result files (gpr files). For background correction the <code>backgroundcorrect</code> funktion from the limma package is used. After normalization data can be plotted to check quality control or to get a first impression on the biological relevance of the data set.
</p>


<h3>Author(s)</h3>

<p>Maintainer: Heiko Mannsperger &lt;h.mannsperger@dkfz.de&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	data(dataI)
	
	bgcorrected &lt;- correctBG(dataI)
	normalized &lt;- normalizeRPPA(bgcorrected,method="proteinDye")
	aggregated &lt;- sample.median(normalized)

## End(Not run)
</code></pre>

<hr>
<h2 id='S1.gpr'> GenePix result files</h2><span id='topic+S1.gpr+2C+20S2.gpr+2C+20S4.gpr'></span>

<h3>Description</h3>

<p>GenePix result files are tab delimited text files exported from the commonly
used microarray image analysis tool GenePix.
</p>


<h3>Format</h3>

<p>tab delimeted text file
</p>


<h3>Source</h3>

<p>The GenePix result files are files from original reverse phase protein arrays
</p>

<hr>
<h2 id='sample.median'>
Aggregate the replicates in an RPPA data set
</h2><span id='topic+sample.median'></span>

<h3>Description</h3>

<p>Aggregates the replicates in an RPPA data list using
the median function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   sample.median(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample.median_+3A_x">x</code></td>
<td>

<p>List with RPPA data set
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>expression</code></td>
<td>
<p>matrix with protein expression data</p>
</td></tr>
<tr><td><code>error_mad</code></td>
<td>
<p>matrix with error values</p>
</td></tr>
<tr><td><code>arraydescription</code></td>
<td>
<p>data frame with feature data</p>
</td></tr>
<tr><td><code>sampledescription</code></td>
<td>
<p>data frame with pheno data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heiko Mannsperger &lt;h.mannsperger@dkfz.de&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	library(RPPanalyzer)
	
   data(dataI)
   dataI_bgcorr &lt;- correctBG(dataI,method="normexp")
	
	data.median &lt;- sample.median(dataI_bgcorr)

## End(Not run)
</code></pre>

<hr>
<h2 id='sampledescription.old'> sample description file</h2><span id='topic+sampledescription.old'></span>

<h3>Description</h3>

<p>The sample description file contains all information concerning the samples
of a reverse phase protein experiment.
</p>


<h3>Format</h3>

<p>tab delimeted text file
</p>


<h3>Details</h3>

<p>The sample description file contains information for sample annotation and data analysis.
To identify the sample in the source well plate the columns <code>plate</code>, <code>row</code>, <code>column</code>
are obligatory. It is neccessary that every well that is spottet is described.
The columns <code>sample_type</code> and <code>sample</code> as well as <code>concentration</code> and
for serially diluted samples <code>dilution</code> are required for data analysis.
To fit a model to serial dilution e.g. using the <code>calcSdc</code> function, it
is neccessary to indicate the highest concentration in the <code>dilution</code> column
with the value 1.
Any additionally column can be added to describe further phenodata of interest.
</p>


<h3>Source</h3>

<p>The data set contains original reverse phase protein array signals
with randomized pheno and feature data.
</p>

<hr>
<h2 id='sampledescription.txt'> sample description file</h2><span id='topic+sampledescription.txt'></span>

<h3>Description</h3>

<p>The sample description file contains all information concerning the samples
of a reverse phase protein experiment.
</p>


<h3>Format</h3>

<p>tab delimeted text file
</p>


<h3>Details</h3>

<p>The sample description file contains information for sample annotation and data analysis.
To identify the sample in the source well plate the columns <code>plate</code>, <code>row</code>, <code>column</code>
are obligatory. It is neccessary that every well that is spottet is described.
The columns <code>sample_type</code> and <code>sample</code> as well as <code>concentration</code> and
for serially diluted samples <code>dilution</code> are required for data analysis.
The column <code>dilSeriesID</code> is required for background correction based on serial dilutions.
Any additionally column can be added to describe further phenodata of interest.
</p>


<h3>Source</h3>

<p>The data set contains original reverse phase protein array signals.
A549 cells were starved for 24 h and subsequently stimulated with six different HGF concentrations 
ranging from 0 - 100 ng/ml. 
Samples were obtained at six different time points ranging from 0 - 120 min. 
The experiment was done in triplicates, and the samples were analysed by RPPA using antibodies 
directed against proteins and phosphoproteins of MET receptor signalling.
</p>

<hr>
<h2 id='select.measurements'>
Selects the measurement samples from an RPPA data list
</h2><span id='topic+select.measurements'></span>

<h3>Description</h3>

<p>Selects the measurement samples defined as &quot;measurement&quot; in sample_type from
an RPPA data list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   select.measurements(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.measurements_+3A_x">x</code></td>
<td>

<p>List with RPPA data set
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>expression</code></td>
<td>
<p>matrix with protein expression data</p>
</td></tr>
<tr><td><code>background</code></td>
<td>
<p>matrix with protein background data or error values
dependend on the input files</p>
</td></tr>
<tr><td><code>arraydescription</code></td>
<td>
<p>data frame with feature data</p>
</td></tr>
<tr><td><code>sampledescription</code></td>
<td>
<p>data frame with pheno data</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Heiko Mannsperger &lt;h.mannsperger@dkfz.de&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	library(RPPanalyzer)
	data(dataIII)
	dataIII_median &lt;- sample.median(dataIII)
	measures &lt;- select.measurements(dataIII_median)
	
## End(Not run)
</code></pre>

<hr>
<h2 id='select.sample.group'>
Selects samples from RPPA data
</h2><span id='topic+select.sample.group'></span>

<h3>Description</h3>

<p>Selects samples from an RPPA data list according to the selected parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
	select.sample.group(x, params=list("tissue" = c("T", "N")), combine = F )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select.sample.group_+3A_x">x</code></td>
<td>
<p>List with RPPA data set</p>
</td></tr>
<tr><td><code id="select.sample.group_+3A_params">params</code></td>
<td>
<p>List of parameters the selection of samples is bases on. The names of the list describes the columns of the sampledescription matrix. The according values corresponds to the values in these columns that will be selected.
</p>
</td></tr>
<tr><td><code id="select.sample.group_+3A_combine">combine</code></td>
<td>
<p>Logical value. Indicates wheter the samples should match at least one criterion given in the params list (<code>combine=TRUE</code>) or if all criteria should be met (<code>combine=FALSE</code>). Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An RPPA data list containing only these samples that match the criteria given in the <code>params</code> list.
</p>


<h3>Author(s)</h3>

<p>Heiko Mannsperger &lt;h.mannsperger@dkfz.de&gt;, Stephan Gade &lt;s.gade@dkfz.de&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	library(RPPanalyzer)
	data(dataII)

	selectedData &lt;- select.sample.group(dataII,params=list("stimulation"=c("A","B")))

## End(Not run)
</code></pre>

<hr>
<h2 id='ser.dil.samples'> Reverse phase protein array rawdata, samples serially diluted</h2><span id='topic+ser.dil.samples'></span>

<h3>Description</h3>

<p>The data Set is a list of four elements. Expression and background are matrices
containing signal intensities, the data frames arraydescription and sampledescription
comprising feature and phenodata.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(ser.dil.samples)</code></pre>


<h3>Format</h3>

<p>list
</p>


<h3>Details</h3>

<p>The data set is a subset of the data set dataI to shorten the running time during
the R CMD check process. The data set contains information about the localization of
the samples.
</p>


<h3>Source</h3>

<p>The data set contains original reverse phase protein array signals
with randomized pheno and feature data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(ser.dil.samples)
str(ser.dil.samples)

## End(Not run)
</code></pre>

<hr>
<h2 id='simpleBoxplot'>Draws boxplots of groups of an RPPA data set.</h2><span id='topic+simpleBoxplot'></span>

<h3>Description</h3>

<p>Draws boxplots of groups of an RPPA data set. Additionally a grouping order for plotting can be provided here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleBoxplot(x, param, orderGrp=NULL, file = "boxplot_groups.pdf")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpleBoxplot_+3A_x">x</code></td>
<td>
<p> List with RPPA data with aggregated replicate spots </p>
</td></tr>
<tr><td><code id="simpleBoxplot_+3A_param">param</code></td>
<td>
<p> Character value of one of the columns of the sampledescription matrix, i.e. x[[4]], describing the phenodata that should be analyzed </p>
</td></tr>
<tr><td><code id="simpleBoxplot_+3A_ordergrp">orderGrp</code></td>
<td>
<p> defines the ordering of the subgroups in <code>param</code>, i.e. vector of specifically ordered values of <code>param</code> </p>
</td></tr>
<tr><td><code id="simpleBoxplot_+3A_file">file</code></td>
<td>
<p> Title of the file that will be exported.  </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates a PDF file
</p>


<h3>Author(s)</h3>

<p>Silvia von der Heyde, Heiko Mannsperger</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(RPPanalyzer)
	
data(dataIII)
dataIII_median &lt;- sample.median(dataIII)
simpleBoxplot(x=dataIII_median, param="rank", 
	orderGrp=c("vx","zx","yzr","rxi"), file="simpleBoxplot.pdf")
    
## End(Not run)
</code></pre>

<hr>
<h2 id='slidedescription.old'> slide description file</h2><span id='topic+slidedescription.old'></span>

<h3>Description</h3>

<p>The slide description file contains all information concerning the arrays
of a reverse phase protein experiment.
</p>


<h3>Format</h3>

<p>tab delimeted text file
</p>


<h3>Details</h3>

<p>The slide description file contains information for array annotation and data analysis.
To find the GenePix result files (gpr files) in current working directory it
is neccesssary that the names of the gpr files are matching with the <code>gpr</code> column.
To identify the array on the slides the columns <code>pad</code>, <code>slide</code>, <code>spotting_run</code>, <code>incubation_run</code>
are obligatory. It is neccessary that every well that is spottet is described.
The columns <code>sample_type</code> and <code>sample</code> as well as <code>concentration</code> and
(for serially diluted samples) <code>dilution</code> are required for data analysis.
The columns <code>target</code> describes the analyzed proteins and <code>AB_ID</code>
contains a indentifier for the antibody used for the detection.
Any additionally column can be added to describe further phenodata of interest.
</p>


<h3>Source</h3>

<p>The data set contains the incubation data from reverse phase protein arrays
with randomized feature data.
</p>

<hr>
<h2 id='slidedescription.txt'> slide description file</h2><span id='topic+slidedescription.txt'></span>

<h3>Description</h3>

<p>The slide description file contains all information concerning the arrays
of a reverse phase protein experiment.
</p>


<h3>Format</h3>

<p>tab delimeted text file
</p>


<h3>Details</h3>

<p>The slide description file contains information for array annotation and data analysis.
To find the GenePix result files (gpr files) in current working directory it
is neccesssary that the names of the gpr files are matching with the <code>gpr</code> column.
To identify the array on the slides the columns <code>pad</code>, <code>slide</code>, <code>spotting_run</code>, <code>incubation_run</code>
are obligatory. It is neccessary that every well that is spottet is described.
The columns <code>sample_type</code> and <code>sample</code> as well as <code>concentration</code> and
(for serially diluted samples) <code>dilution</code> are required for data analysis.
The columns <code>target</code> describes the analyzed proteins and <code>AB_ID</code>
contains a indentifier for the antibody used for the detection.
Any additionally column can be added to describe further phenodata of interest.
</p>


<h3>Source</h3>

<p>The data set contains the incubation data from reverse phase protein arrays for 
the HGF data set. These are 3 sample slides plus one slide for FCF normalization.
</p>

<hr>
<h2 id='test.correlation'>
Tests for correlations in RPPA data
</h2><span id='topic+test.correlation'></span>

<h3>Description</h3>

<p>Tests for correlation between protein expression value and any continuous
data using cor.test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.correlation(x, param, method.cor = "kendall", 
	method.padj = "BH", file = "correlation_plot.pdf") 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.correlation_+3A_x">x</code></td>
<td>

<p>List containing RPPa data set
</p>
</td></tr>
<tr><td><code id="test.correlation_+3A_param">param</code></td>
<td>

<p>character describing the parameter	
</p>
</td></tr>
<tr><td><code id="test.correlation_+3A_method.cor">method.cor</code></td>
<td>

<p>character string describing the correlation
</p>
</td></tr>
<tr><td><code id="test.correlation_+3A_method.padj">method.padj</code></td>
<td>

<p>character string describing the method for the p-value correction for
multiple testing.
</p>
</td></tr>
<tr><td><code id="test.correlation_+3A_file">file</code></td>
<td>

<p>character string
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>generates a pdf file
</p>


<h3>Author(s)</h3>

<p>Heiko Mannsperger &lt;h.mannsperger@dkfz.de&gt;
</p>


<h3>See Also</h3>

<p>For information about the argument method.cor see <code><a href="stats.html#topic+cor.test">cor.test</a></code>,
informations about methods.padj can be found under <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(RPPanalyzer)
data(dataIII)
dataIII_median &lt;- sample.median(dataIII)
test.correlation(dataIII_median,param="staging")


## End(Not run)
</code></pre>

<hr>
<h2 id='write.Data'>
writes an RPPA data list into csv file
</h2><span id='topic+write.Data'></span>

<h3>Description</h3>

<p>Writes the 3 or 4 elements of an RPPA data list into one or two csv files
which can easily imported into spreadsheet software
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write.Data(x,FileNameExtension="Data")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.Data_+3A_x">x</code></td>
<td>
<p>List with RPPA data set</p>
</td></tr>
<tr><td><code id="write.Data_+3A_filenameextension">FileNameExtension</code></td>
<td>
<p>character string which will be added to the name of the
exported file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>one or two csv files dependend from the length of the RPPA data list
</p>


<h3>Author(s)</h3>

<p>Heiko Mannsperger &lt;h.mannsperger@dkfz.de&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
	library(RPPanalyzer)
	data(dataII)
	
	write.Data(dataII)
    
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
