<!DOCTYPE html><html><head><title>Help for package SoundexBR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SoundexBR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#accent'><p>Get rid of Accent Marks</p></a></li>
<li><a href='#ascii.table'><p>ASCII Characters Table</p></a></li>
<li><a href='#char2int'><p>Character to Integer</p></a></li>
<li><a href='#int2char'><p>Interger to Character</p></a></li>
<li><a href='#soundexBR'><p> Phonetic-Coding For Portuguese</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Phonetic-Coding for Portuguese</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2015-07-14 20:24:20</td>
</tr>
<tr>
<td>Author:</td>
<td>Daniel Marcelino</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Daniel Marcelino &lt;dmarcelino@live.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>The SoundexBR package provides an algorithm for decoding names
    into phonetic codes, as pronounced in Portuguese. The goal is for
    homophones to be encoded to the same representation so that they can be
    matched despite minor differences in spelling. The algorithm mainly encodes
    consonants; a vowel will not be encoded unless it is the first letter. The
    soundex code resultant consists of a four digits long string composed by
    one letter followed by three numerical digits: the letter is the first
    letter of the name, and the digits encode the remaining consonants.</td>
</tr>
<tr>
<td>Suggests:</td>
<td>SciencesPo, stringr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0),stats,utils,graphics,grDevices</td>
</tr>
<tr>
<td>Enhances:</td>
<td>RecordLinkage</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="http://github.com/danielmarcelino/soundexBR">http://github.com/danielmarcelino/soundexBR</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>TRUE</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2015-07-14 00:29:32 UTC; daniel</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
</table>
<hr>
<h2 id='accent'>Get rid of Accent Marks</h2><span id='topic+accent'></span>

<h3>Description</h3>

<p>Replace lower and upper case accented letters with their counterpart without diacritical marks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>accent(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="accent_+3A_x">x</code></td>
<td>
<p>is a data object which contains diacritical marks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can replace a variety of common marks, but not all of them. It is designed to be expanded on demand.
</p>


<h3>Value</h3>

<p>a vector with same length of <code>x</code> without diacritic.
</p>


<h3>Author(s)</h3>

<p>Daniel Marcelino <a href="mailto:dmarcelino@live.com">dmarcelino@live.com</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ascii.table">ascii.table</a></code>.
</p>

<hr>
<h2 id='ascii.table'>ASCII Characters Table</h2><span id='topic+ascii.table'></span>

<h3>Description</h3>

<p>To detect ASCII characters, we may need to specify them literally. This function helps identifying what character is in ascii format and what is not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ascii.table(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ascii.table_+3A_x">x</code></td>
<td>
<p>A string whose characters is to be checked against.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>TRUE</code> if ASCII character and <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Daniel Marcelino, <a href="mailto:dmarcelino@live.com">dmarcelino@live.com</a>
</p>

<hr>
<h2 id='char2int'>Character to Integer</h2><span id='topic+char2int'></span>

<h3>Description</h3>

<p>Declares characters to integer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>char2int(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="char2int_+3A_x">x</code></td>
<td>
<p>A vector consisting of characters.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+int2char">int2char</a>, <a href="base.html#topic+iconv">iconv</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>char2int("This should be whole numbers")
</code></pre>

<hr>
<h2 id='int2char'>Interger to Character</h2><span id='topic+int2char'></span>

<h3>Description</h3>

<p>Declares integer inputs as UTF-8 output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int2char(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int2char_+3A_x">x</code></td>
<td>
<p>A vector consisting of whole numbers.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+char2int">char2int</a>, <a href="base.html#topic+iconv">iconv</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>int2char(c(84,104,105,115,32,115,104,111,117,108,
100, 32, 98, 101, 32, 119, 104, 111, 108, 101,
32, 110, 117, 109, 98, 101, 114, 115))
</code></pre>

<hr>
<h2 id='soundexBR'> Phonetic-Coding For Portuguese
</h2><span id='topic+soundexBR'></span>

<h3>Description</h3>

<p>The soundexBR function is an algorithm for decoding names into phonetic codes, as pronounced in Portuguese. Soundex coding can be useful to identify &lsquo;close&rsquo; matches which typically fail due to variant spellings of names. For instance, both &ldquo;Clair&rdquo; and &ldquo;Claire&rdquo; return the same string &ldquo;C460&rdquo;, but the slightly different spellings of these names is enough to cause a deterministic linkage to fail when comparing the actual names. Soundex does not help when the variants do not sound alike, or start with different letters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soundexBR(term, BR=TRUE, useBytes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="soundexBR_+3A_term">term</code></td>
<td>
<p>a list, a vector or a data frame with character strings.
</p>
</td></tr>
<tr><td><code id="soundexBR_+3A_br">BR</code></td>
<td>
<p>if <code>BR=TRUE</code>, commong mispelled first letters may be replaced</p>
</td></tr></table>
<p>.
</p>
<table>
<tr><td><code id="soundexBR_+3A_usebytes">useBytes</code></td>
<td>
<p> if <code>useBytes=TRUE</code> performs byte-wise comparison. The default is set to <code>FALSE</code>, which takes longer, but it may prevent different results depending on character encoding.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p> The soundexBR may help with identification of names even when they are spelled differently. However, the algorithm does not help when the variants do not sound alike, or start with different letters. For instance, while &ldquo;Carolina&rdquo; and &ldquo;Karolina&rdquo; both receive a similar code, respectively &ldquo;C645&rdquo; and &ldquo;K645&rdquo;, the first letter differ.
Further, this function is only meaningful for characters in the ranges a-z and A-Z. Although, I tried to minimize character encoding issues, there are several non-printable ascii characters and system-dependent characters that may cause the function to print a warning message.
</p>
<p>The numerical digits of the code are based on specific consonant sounds and can be computed by using the letters's &lsquo;power&rsquo;. For instance, (1) retain the first letter of the name and drop other occurrences of <code style="white-space: pre;">&#8288;A, E, I, O, U, Y, H, W&#8288;</code>. (2) replace consonants with digits as follows (after the first letter):
</p>
<pre>
B, F, P, V = 1
C, G, J, K, Q, S, X, Z = 2
D, T = 3
L = 4
M, N = 5
R = 6</pre>
<p>(3) If two or more letters with the same number are adjacent in the original name (before step 1), only retain the first letter; also two letters with the same number separated by ‘h’ or ‘w’ are coded as a single number, whereas such letters separated by a vowel are coded twice, for instance, &ldquo;Ashcraft&rdquo; and &ldquo;Ashcroft&rdquo; both yield &ldquo;A261&rdquo; (the chars &lsquo;s&rsquo; and &lsquo;c&rsquo; in the name receive a single number of 2 and not 22 since an &lsquo;h&rsquo; lies in between them).
(4) Iterate the previous step until you have one letter and three numbers. If you have too few letters in your word that you cannot assign three numbers, append with zeros until there are three numbers as in &ldquo;A500&rdquo;. If the resultant code has more than 3 numbers, just retain the first 3 numbers.
</p>
<p><em>Probabilistic Matching</em>: soundexBR may be used as a phonetic identifier to find results that do not match exactly the terms. Searching for names can be difficult as there are often multiple alternative spellings for names. An example is the name Claire. It has two alternatives, Clare and Clair, which are both pronounced the same. Searching for one spelling would not show results for the two others. Fortunately, soundexBR will produce the same code for all three variations, &ldquo;C460&rdquo;. Therefore, searching names based on the soundex code all three variations will be matched. In the examples below, you can instances of using soundexBR together with the <span class="pkg">RecordLinkage</span> package, by supplying it with a phonetic dictionary for Portuguese records.
</p>


<h3>Value</h3>

<p>A character vector with same dimensions as <code>term</code>.
</p>


<h3>Note</h3>

<p>This function was adapted from the US census soundex version.
See in <a href="http://archives.gov/research/census/soundex.html">http://archives.gov/research/census/soundex.html</a>
</p>


<h3>Author(s)</h3>

<p>Daniel Marcelino <a href="mailto:dmarcelino@live.com">dmarcelino@live.com</a>
</p>


<h3>References</h3>

<p>Borg, Andreas and Murat Sariyar. (2012) <em>RecordLinkage: Record Linkage in R,</em> R package version 0.4-1,  <a href="http://CRAN.R-project.org/package=RecordLinkage">http://CRAN.R-project.org/package=RecordLinkage</a>.
</p>
<p>Camargo Jr. and Coeli CM. (2000) Reclink: aplicativo para o relacionamento de bases de dados, implementando o método probabilistic record linkage. <em>Cad. Saúde Pública</em>, <b>16(2)</b>, Rio de Janeiro.
</p>
<p>Eastman, Dick <em>Soundex Calculator</em>, <a href="http://eogn.com/soundex/">http://eogn.com/soundex/</a>.
</p>
<p>Marcelino, Daniel (2013) <em>SciencesPo: A Tool Set for Analyzing Political Behaviour Data</em>, <a href="http://dx.doi.org/10.2139/ssrn.2320547">http://dx.doi.org/10.2139/ssrn.2320547</a>.
</p>
<p>Paula, Fátima de Lima (2014) <em>Readmissão Hospitalar de Idosos após Internação por Fratura Proximal do Fêmur no Município do Rio de Janeiro</em>, Doctoral thesis, Fiocruz.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### A silly example:
names &lt;- c('Ana Karolina Kuhnen', 'Ana Carolina Kuhnen', 'Ana Karolina','João Souza',
'João Souza', 'Dilma Vana Rousseff', 'Dilma Rousef','Aécio Neves', 'Aecio Neves')

soundexBR(names)

# Example with RecordLinkage:
#Some data:
data1 &lt;- data.frame(list(
fname=c('Ricardo','Maria','Tereza','Pedro','José','Rubens'),
lname=c('Cunha','Andrade','Silva','Soares','Silva','Lima'),
age=c(67,89,78,65,68,67),
birth=c(1945,1923,1934,1947,1944,1945),
date=c(20120907,20120703,20120301,20120805,20121004,20121209)
))

data2&lt;-data.frame( list( fname=c('Maria','Lúcia','Paulo','Marcos','Ricardo','Rubem'),
lname=c('Andrada','Silva','Soares','Pereira','Cunha','Lima'),
age=c(67,88,78,60,67,80),
birth=c(1945,1924,1934,1952,1945,1932),
date=c(20121208,20121103,20120302,20120105,20120907,20121209)
))

# Must call RecordLinkage package

## Not run: pairs&lt;-compare.linkage(data1, data2,
blockfld=list(c(1,2,4),c(1,2)),
phonetic&lt;-c(1,2), phonfun = soundexBR, strcmp = FALSE,
strcmpfun&lt;-jarowinkler, exclude=FALSE,identity1 = NA,
identity2=NA, n_match &lt;- NA, n_non_match = NA)

print(pairs)

editMatch(pairs)

# To access information in the object:
weights &lt;- epiWeights(pairs, e = 0.01, f = pairs$frequencies)
hist(weights$Wdata, plot = FALSE) # Plot TRUE
getPairs(pairs, max.weight = Inf, min.weight = -Inf)
	
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
