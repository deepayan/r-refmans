<!DOCTYPE html><html><head><title>Help for package timetk</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {timetk}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#anomalize'><p>Automatic group-wise Anomaly Detection</p></a></li>
<li><a href='#between_time'><p>Between (For Time Series): Range detection for date or date-time sequences</p></a></li>
<li><a href='#bike_sharing_daily'><p>Daily Bike Sharing Data</p></a></li>
<li><a href='#box_cox_vec'><p>Box Cox Transformation</p></a></li>
<li><a href='#condense_period'><p>Convert the Period to a Lower Periodicity (e.g. Go from Daily to Monthly)</p></a></li>
<li><a href='#diff_vec'><p>Differencing Transformation</p></a></li>
<li><a href='#FANG'><p>Stock prices for the &quot;FANG&quot; stocks.</p></a></li>
<li><a href='#filter_by_time'><p>Filter (for Time-Series Data)</p></a></li>
<li><a href='#filter_period'><p>Apply filtering expressions inside periods (windows)</p></a></li>
<li><a href='#fourier_vec'><p>Fourier Series</p></a></li>
<li><a href='#future_frame'><p>Make future time series from existing</p></a></li>
<li><a href='#is_date_class'><p>Check if an object is a date class</p></a></li>
<li><a href='#lag_vec'><p>Lag Transformation</p></a></li>
<li><a href='#log_interval_vec'><p>Log-Interval Transformation for Constrained Interval Forecasting</p></a></li>
<li><a href='#m4_daily'><p>Sample of 4 Daily Time Series Datasets from the M4 Competition</p></a></li>
<li><a href='#m4_hourly'><p>Sample of 4 Hourly Time Series Datasets from the M4 Competition</p></a></li>
<li><a href='#m4_monthly'><p>Sample of 4 Monthly Time Series Datasets from the M4 Competition</p></a></li>
<li><a href='#m4_quarterly'><p>Sample of 4 Quarterly Time Series Datasets from the M4 Competition</p></a></li>
<li><a href='#m4_weekly'><p>Sample of 4 Weekly Time Series Datasets from the M4 Competition</p></a></li>
<li><a href='#m4_yearly'><p>Sample of 4 Yearly Time Series Datasets from the M4 Competition</p></a></li>
<li><a href='#mutate_by_time'><p>Mutate (for Time Series Data)</p></a></li>
<li><a href='#normalize_vec'><p>Normalize to Range (0, 1)</p></a></li>
<li><a href='#pad_by_time'><p>Insert time series rows with regularly spaced timestamps</p></a></li>
<li><a href='#parse_date2'><p>Fast, flexible date and datetime parsing</p></a></li>
<li><a href='#plot_acf_diagnostics'><p>Visualize the ACF, PACF, and CCFs for One or More Time Series</p></a></li>
<li><a href='#plot_anomalies'><p>Visualize Anomalies for One or More Time Series</p></a></li>
<li><a href='#plot_anomaly_diagnostics'><p>Visualize Anomalies for One or More Time Series</p></a></li>
<li><a href='#plot_seasonal_diagnostics'><p>Visualize Multiple Seasonality Features for One or More Time Series</p></a></li>
<li><a href='#plot_stl_diagnostics'><p>Visualize STL Decomposition Features for One or More Time Series</p></a></li>
<li><a href='#plot_time_series'><p>Interactive Plotting for One or More Time Series</p></a></li>
<li><a href='#plot_time_series_boxplot'><p>Interactive Time Series Box Plots</p></a></li>
<li><a href='#plot_time_series_cv_plan'><p>Visualize a Time Series Resample Plan</p></a></li>
<li><a href='#plot_time_series_regression'><p>Visualize a Time Series Linear Regression Formula</p></a></li>
<li><a href='#required_pkgs.step_box_cox'><p>S3 methods for tracking which additional packages are needed for steps.</p></a></li>
<li><a href='#set_tk_time_scale_template'><p>Get and modify the Time Scale Template</p></a></li>
<li><a href='#slice_period'><p>Apply slice inside periods (windows)</p></a></li>
<li><a href='#slidify'><p>Create a rolling (sliding) version of any function</p></a></li>
<li><a href='#slidify_vec'><p>Rolling Window Transformation</p></a></li>
<li><a href='#smooth_vec'><p>Smoothing Transformation using Loess</p></a></li>
<li><a href='#standardize_vec'><p>Standardize to Mean 0, Standard Deviation 1 (Center &amp; Scale)</p></a></li>
<li><a href='#step_box_cox'><p>Box-Cox Transformation using Forecast Methods</p></a></li>
<li><a href='#step_diff'><p>Create a differenced predictor</p></a></li>
<li><a href='#step_fourier'><p>Fourier Features for Modeling Seasonality</p></a></li>
<li><a href='#step_holiday_signature'><p>Holiday Feature (Signature) Generator</p></a></li>
<li><a href='#step_log_interval'><p>Log Interval Transformation for Constrained Interval Forecasting</p></a></li>
<li><a href='#step_slidify'><p>Slidify Rolling Window Transformation</p></a></li>
<li><a href='#step_slidify_augment'><p>Slidify Rolling Window Transformation (Augmented Version)</p></a></li>
<li><a href='#step_smooth'><p>Smoothing Transformation using Loess</p></a></li>
<li><a href='#step_timeseries_signature'><p>Time Series Feature (Signature) Generator</p></a></li>
<li><a href='#step_ts_clean'><p>Clean Outliers and Missing Data for Time Series</p></a></li>
<li><a href='#step_ts_impute'><p>Missing Data Imputation for Time Series</p></a></li>
<li><a href='#step_ts_pad'><p>Pad: Add rows to fill gaps and go from low to high frequency</p></a></li>
<li><a href='#summarise_by_time'><p>Summarise (for Time Series Data)</p></a></li>
<li><a href='#taylor_30_min'><p>Half-hourly electricity demand</p></a></li>
<li><a href='#tidyeval'><p>Tidy eval helpers</p></a></li>
<li><a href='#time_arithmetic'><p>Add / Subtract (For Time Series)</p></a></li>
<li><a href='#time_series_cv'><p>Time Series Cross Validation</p></a></li>
<li><a href='#time_series_split'><p>Simple Training/Test Set Splitting for Time Series</p></a></li>
<li><a href='#timetk-package'><p>timetk: Time Series Analysis in the Tidyverse</p></a></li>
<li><a href='#tk_acf_diagnostics'><p>Group-wise ACF, PACF, and CCF Data Preparation</p></a></li>
<li><a href='#tk_anomaly_diagnostics'><p>Automatic group-wise Anomaly Detection by STL Decomposition</p></a></li>
<li><a href='#tk_augment_differences'><p>Add many differenced columns to the data</p></a></li>
<li><a href='#tk_augment_fourier'><p>Add many fourier series to the data</p></a></li>
<li><a href='#tk_augment_holiday'><p>Add many holiday features to the data</p></a></li>
<li><a href='#tk_augment_lags'><p>Add many lags to the data</p></a></li>
<li><a href='#tk_augment_slidify'><p>Add many rolling window calculations to the data</p></a></li>
<li><a href='#tk_augment_timeseries'><p>Add many time series features to the data</p></a></li>
<li><a href='#tk_get_frequency'><p>Automatic frequency and trend calculation from a time series index</p></a></li>
<li><a href='#tk_get_holiday'><p>Get holiday features from a time-series index</p></a></li>
<li><a href='#tk_get_timeseries'><p>Get date features from a time-series index</p></a></li>
<li><a href='#tk_get_timeseries_unit_frequency'><p>Get the timeseries unit frequency for the primary time scales</p></a></li>
<li><a href='#tk_get_timeseries_variables'><p>Get date or datetime variables (column names)</p></a></li>
<li><a href='#tk_index'><p>Extract an index of date or datetime from time series objects, models, forecasts</p></a></li>
<li><a href='#tk_make_future_timeseries'><p>Make future time series from existing</p></a></li>
<li><a href='#tk_make_holiday_sequence'><p>Make daily Holiday and Weekend date sequences</p></a></li>
<li><a href='#tk_make_timeseries'><p>Intelligent date and date-time sequence creation</p></a></li>
<li><a href='#tk_seasonal_diagnostics'><p>Group-wise Seasonality Data Preparation</p></a></li>
<li><a href='#tk_stl_diagnostics'><p>Group-wise STL Decomposition (Season, Trend, Remainder)</p></a></li>
<li><a href='#tk_summary_diagnostics'><p>Group-wise Time Series Summary</p></a></li>
<li><a href='#tk_tbl'><p>Coerce time-series objects to tibble.</p></a></li>
<li><a href='#tk_time_series_cv_plan'><p>Time Series Resample Plan Data Preparation</p></a></li>
<li><a href='#tk_ts'><p>Coerce time series objects and tibbles with date/date-time columns to ts.</p></a></li>
<li><a href='#tk_ts_dispatch_'><p>S3 methods for ts method dispatch</p></a></li>
<li><a href='#tk_tsfeatures'><p>Time series feature matrix (Tidy)</p></a></li>
<li><a href='#tk_xts'><p>Coerce time series objects and tibbles with date/date-time columns to xts.</p></a></li>
<li><a href='#tk_zoo'><p>Coerce time series objects and tibbles with date/date-time columns to xts.</p></a></li>
<li><a href='#tk_zooreg'><p>Coerce time series objects and tibbles with date/date-time columns to ts.</p></a></li>
<li><a href='#tk_zooreg_dispatch_'><p>S3 methods for zooreg method dispatch</p></a></li>
<li><a href='#ts_clean_vec'><p>Replace Outliers &amp; Missing Values in a Time Series</p></a></li>
<li><a href='#ts_impute_vec'><p>Missing Value Imputation for Time Series</p></a></li>
<li><a href='#walmart_sales_weekly'><p>Sample Time Series Retail Data from the Walmart Recruiting Store Sales Forecasting Competition</p></a></li>
<li><a href='#wikipedia_traffic_daily'><p>Sample Daily Time Series Data from the Web Traffic Forecasting (Wikipedia) Competition</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Tool Kit for Working with Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>2.9.0</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Easy visualization, wrangling, and feature engineering of time series data for 
    forecasting and machine learning prediction. Consolidates and extends time series functionality 
    from packages including 'dplyr', 'stats', 'xts', 'forecast', 'slider', 'padr', 'recipes', and 'rsample'.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/business-science/timetk">https://github.com/business-science/timetk</a>,
<a href="https://business-science.github.io/timetk/">https://business-science.github.io/timetk/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/business-science/timetk/issues">https://github.com/business-science/timetk/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>recipes (&ge; 1.0.4), rsample, dplyr (&ge; 1.0.0), ggplot2 (&ge;
3.4.0), forcats, stringr, plotly, lubridate (&ge; 1.6.0), padr
(&ge; 0.5.2), purrr (&ge; 0.2.2), readr (&ge; 1.3.0), stringi (&ge;
1.4.6), tibble (&ge; 3.0.3), tidyr (&ge; 1.1.0), xts (&ge; 0.9-7),
zoo (&ge; 1.7-14), rlang (&ge; 1.1.1), tidyselect (&ge; 1.1.0),
slider, anytime, timeDate, forecast, tsfeatures, hms, generics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>modeltime, glmnet, workflows, parsnip, tune (&ge; 0.1.2),
knitr, rmarkdown, broom, scales, testthat, fracdiff,
timeSeries, tseries, trelliscopejs</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-31 19:15:26 UTC; mdancho</td>
</tr>
<tr>
<td>Author:</td>
<td>Matt Dancho [aut, cre],
  Davis Vaughan [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matt Dancho &lt;mdancho@business-science.io&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-31 22:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='anomalize'>Automatic group-wise Anomaly Detection</h2><span id='topic+anomalize'></span>

<h3>Description</h3>

<p><code>anomalize()</code> is used to detect anomalies in time series data,
either for a single time series or for multiple time series grouped by a specific column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>anomalize(
  .data,
  .date_var,
  .value,
  .frequency = "auto",
  .trend = "auto",
  .method = "stl",
  .iqr_alpha = 0.05,
  .clean_alpha = 0.75,
  .max_anomalies = 0.2,
  .message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="anomalize_+3A_.data">.data</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code> with a time-based column</p>
</td></tr>
<tr><td><code id="anomalize_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing either date or date-time values</p>
</td></tr>
<tr><td><code id="anomalize_+3A_.value">.value</code></td>
<td>
<p>A column containing numeric values</p>
</td></tr>
<tr><td><code id="anomalize_+3A_.frequency">.frequency</code></td>
<td>
<p>Controls the seasonal adjustment (removal of seasonality).
Input can be either &quot;auto&quot;, a time-based definition (e.g. &quot;2 weeks&quot;),
or a numeric number of observations per frequency (e.g. 10).
Refer to <code><a href="#topic+tk_get_frequency">tk_get_frequency()</a></code>.</p>
</td></tr>
<tr><td><code id="anomalize_+3A_.trend">.trend</code></td>
<td>
<p>Controls the trend component.
For STL, trend controls the sensitivity of the LOESS smoother, which is used to remove the remainder.
Refer to <code><a href="#topic+tk_get_trend">tk_get_trend()</a></code>.</p>
</td></tr>
<tr><td><code id="anomalize_+3A_.method">.method</code></td>
<td>
<p>The outlier detection method. Default: &quot;stl&quot;. Currently
&quot;stl&quot; is the only method. &quot;twitter&quot; is planned.</p>
</td></tr>
<tr><td><code id="anomalize_+3A_.iqr_alpha">.iqr_alpha</code></td>
<td>
<p>Controls the width of the &quot;normal&quot; range. Lower values are more conservative
while higher values are less prone to incorrectly classifying &quot;normal&quot; observations.</p>
</td></tr>
<tr><td><code id="anomalize_+3A_.clean_alpha">.clean_alpha</code></td>
<td>
<p>Controls the threshold for cleaning
the outliers. The default is 0.75, which means that the anomalies will be
cleaned using the 0.75 * lower or upper bound of the recomposed time series,
depending on the direction of the anomaly.</p>
</td></tr>
<tr><td><code id="anomalize_+3A_.max_anomalies">.max_anomalies</code></td>
<td>
<p>The maximum percent of anomalies permitted to be identified.</p>
</td></tr>
<tr><td><code id="anomalize_+3A_.message">.message</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, will output information related to automatic frequency
and trend selection (if applicable).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>anomalize()</code> method for anomaly detection that implements a 2-step process to
detect outliers in time series.
</p>
<p><strong>Step 1: Detrend &amp; Remove Seasonality using STL Decomposition</strong>
</p>
<p>The decomposition separates the &quot;season&quot; and &quot;trend&quot; components from the &quot;observed&quot; values
leaving the &quot;remainder&quot; for anomaly detection.
</p>
<p>The user can control two parameters: frequency and trend.
</p>

<ol>
<li> <p><code>.frequency</code>: Adjusts the &quot;season&quot; component that is removed from the &quot;observed&quot; values.
</p>
</li>
<li> <p><code>.trend</code>: Adjusts the trend window (t.window parameter from <code><a href="stats.html#topic+stl">stats::stl()</a></code> that is used.
</p>
</li></ol>

<p>The user may supply both <code>.frequency</code> and <code>.trend</code> as time-based durations (e.g. &quot;6 weeks&quot;) or
numeric values (e.g. 180) or &quot;auto&quot;, which predetermines the frequency and/or trend based on
the scale of the time series using the <code><a href="#topic+tk_time_scale_template">tk_time_scale_template()</a></code>.
</p>
<p><strong>Step 2: Anomaly Detection</strong>
</p>
<p>Once &quot;trend&quot; and &quot;season&quot; (seasonality) is removed, anomaly detection is performed on the &quot;remainder&quot;.
Anomalies are identified, and boundaries (recomposed_l1 and recomposed_l2) are determined.
</p>
<p>The Anomaly Detection Method uses an inner quartile range (IQR) of +/-25 the median.
</p>
<p><em>IQR Adjustment, alpha parameter</em>
</p>
<p>With the default <code>alpha = 0.05</code>, the limits are established by expanding
the 25/75 baseline by an IQR Factor of 3 (3X).
The <em>IQR Factor = 0.15 / alpha</em> (hence 3X with alpha = 0.05):
</p>

<ul>
<li><p> To increase the IQR Factor controlling the limits, decrease the alpha,
which makes it more difficult to be an outlier.
</p>
</li>
<li><p> Increase alpha to make it easier to be an outlier.
</p>
</li>
<li><p> The IQR outlier detection method is used in <code>forecast::tsoutliers()</code>.
</p>
</li>
<li><p> A similar outlier detection method is used by Twitter's <code>AnomalyDetection</code> package.
</p>
</li>
<li><p> Both Twitter and Forecast tsoutliers methods have been implemented in Business Science's <code>anomalize</code>
package.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>tibble</code> or <code>data.frame</code> with the following columns:
</p>

<ul>
<li><p> observed: original data
</p>
</li>
<li><p> seasonal: seasonal component
</p>
</li>
<li><p> seasadaj: seasonal adjusted
</p>
</li>
<li><p> trend: trend component
</p>
</li>
<li><p> remainder: residual component
</p>
</li>
<li><p> anomaly: Yes/No flag for outlier detection
</p>
</li>
<li><p> anomaly score: distance from centerline
</p>
</li>
<li><p> anomaly direction: -1, 0, 1 inidicator for direction of the anomaly
</p>
</li>
<li><p> recomposed_l1: lower level bound of recomposed time series
</p>
</li>
<li><p> recomposed_l2: upper level bound of recomposed time series
</p>
</li>
<li><p> observed_clean: original data with anomalies interpolated
</p>
</li></ul>



<h3>References</h3>


<ol>
<li><p> CLEVELAND, R. B., CLEVELAND, W. S., MCRAE, J. E., AND TERPENNING, I.
STL: A Seasonal-Trend Decomposition Procedure Based on Loess.
Journal of Official Statistics, Vol. 6, No. 1 (1990), pp. 3-73.
</p>
</li>
<li><p> Owen S. Vallis, Jordan Hochenbaum and Arun Kejariwal (2014).
A Novel Technique for Long-Term Anomaly Detection in the Cloud. Twitter Inc.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

walmart_sales_weekly %&gt;%
    filter(id %in% c("1_1", "1_3")) %&gt;%
    group_by(id) %&gt;%
    anomalize(Date, Weekly_Sales)

</code></pre>

<hr>
<h2 id='between_time'>Between (For Time Series): Range detection for date or date-time sequences</h2><span id='topic+between_time'></span>

<h3>Description</h3>

<p>The easiest way to filter time series date or date-time vectors. Returns a
logical vector indicating which date or date-time values are within a range.
See <code><a href="#topic+filter_by_time">filter_by_time()</a></code> for the <code>data.frame</code> (<code>tibble</code>) implementation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>between_time(index, start_date = "start", end_date = "end")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="between_time_+3A_index">index</code></td>
<td>
<p>A date or date-time vector.</p>
</td></tr>
<tr><td><code id="between_time_+3A_start_date">start_date</code></td>
<td>
<p>The starting date</p>
</td></tr>
<tr><td><code id="between_time_+3A_end_date">end_date</code></td>
<td>
<p>The ending date</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Pure Time Series Filtering Flexibilty</strong>
</p>
<p>The <code>start_date</code>  and <code>end_date</code> parameters are designed with flexibility in mind.
</p>
<p>Each side of the <code>time_formula</code> is specified as the character
<code>'YYYY-MM-DD HH:MM:SS'</code>, but powerful shorthand is available.
Some examples are:
</p>

<ul>
<li> <p><strong>Year:</strong> <code style="white-space: pre;">&#8288;start_date = '2013', end_date = '2015'&#8288;</code>
</p>
</li>
<li> <p><strong>Month:</strong> <code style="white-space: pre;">&#8288;start_date = '2013-01', end_date = '2016-06'&#8288;</code>
</p>
</li>
<li> <p><strong>Day:</strong> <code style="white-space: pre;">&#8288;start_date = '2013-01-05', end_date = '2016-06-04'&#8288;</code>
</p>
</li>
<li> <p><strong>Second:</strong> <code style="white-space: pre;">&#8288;start_date = '2013-01-05 10:22:15', end_date = '2018-06-03 12:14:22'&#8288;</code>
</p>
</li>
<li> <p><strong>Variations:</strong> <code style="white-space: pre;">&#8288;start_date = '2013', end_date = '2016-06'&#8288;</code>
</p>
</li></ul>

<p><strong>Key Words: &quot;start&quot; and &quot;end&quot;</strong>
</p>
<p>Use the keywords &quot;start&quot; and &quot;end&quot; as shorthand, instead of specifying the
actual start and end values. Here are some examples:
</p>

<ul>
<li> <p><strong>Start of the series to end of 2015:</strong> <code style="white-space: pre;">&#8288;start_date = 'start', end_date = '2015'&#8288;</code>
</p>
</li>
<li> <p><strong>Start of 2014 to end of series:</strong> <code style="white-space: pre;">&#8288;start_date = '2014', end_date = 'end'&#8288;</code>
</p>
</li></ul>

<p><strong>Internal Calculations</strong>
</p>
<p>All shorthand dates are expanded:
</p>

<ul>
<li><p> The <code>start_date</code> is expanded to be the <em>first date</em> in that period
</p>
</li>
<li><p> The <code>end_date</code> side is expanded to be the <em>last date</em> in that period
</p>
</li></ul>

<p>This means that the following examples are equivalent (assuming your
index is a POSIXct):
</p>

<ul>
<li> <p><code>start_date = '2015'</code> is equivalent to <code>start_date = '2015-01-01 + 00:00:00' </code>
</p>
</li>
<li> <p><code>end_date = '2016'</code> is equivalent to <code style="white-space: pre;">&#8288;2016-12-31 + 23:59:59'&#8288;</code>
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>logical</code> vector the same length as <code>index</code> indicating whether or not
the timestamp value was within the <code>start_date</code> and <code>end_date</code> range.
</p>


<h3>References</h3>


<ul>
<li><p> This function is based on the <code>tibbletime::filter_time()</code> function developed by Davis Vaughan.
</p>
</li></ul>



<h3>See Also</h3>

<p>Time-Based dplyr functions:
</p>

<ul>
<li> <p><code><a href="#topic+summarise_by_time">summarise_by_time()</a></code> - Easily summarise using a date column.
</p>
</li>
<li> <p><code><a href="#topic+mutate_by_time">mutate_by_time()</a></code> - Simplifies applying mutations by time windows.
</p>
</li>
<li> <p><code><a href="#topic+pad_by_time">pad_by_time()</a></code> - Insert time series rows with regularly spaced timestamps
</p>
</li>
<li> <p><code><a href="#topic+filter_by_time">filter_by_time()</a></code> - Quickly filter using date ranges.
</p>
</li>
<li> <p><code><a href="#topic+filter_period">filter_period()</a></code> - Apply filtering expressions inside periods (windows)
</p>
</li>
<li> <p><code><a href="#topic+slice_period">slice_period()</a></code> - Apply slice inside periods (windows)
</p>
</li>
<li> <p><code><a href="#topic+condense_period">condense_period()</a></code> - Convert to a different periodicity
</p>
</li>
<li> <p><code><a href="#topic+between_time">between_time()</a></code> - Range detection for date or date-time sequences.
</p>
</li>
<li> <p><code><a href="#topic+slidify">slidify()</a></code> - Turn any function into a sliding (rolling) function
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

index_daily &lt;- tk_make_timeseries("2016-01-01", "2017-01-01", by = "day")
index_min   &lt;- tk_make_timeseries("2016-01-01", "2017-01-01", by = "min")

# How it works
# - Returns TRUE/FALSE length of index
# - Use sum() to tally the number of TRUE values
index_daily %&gt;% between_time("start", "2016-01") %&gt;% sum()

# ---- INDEX SLICING ----

# Daily Series: Month of January 2016
index_daily[index_daily %&gt;% between_time("start", "2016-01")]

# Daily Series: March 1st - June 15th, 2016
index_daily[index_daily %&gt;% between_time("2016-03", "2016-06-15")]

# Minute Series:
index_min[index_min %&gt;% between_time("2016-02-01 12:00", "2016-02-01 13:00")]

# ---- FILTERING WITH DPLYR ----
FANG %&gt;%
    group_by(symbol) %&gt;%
    filter(date %&gt;% between_time("2016-01", "2016-01"))

</code></pre>

<hr>
<h2 id='bike_sharing_daily'>Daily Bike Sharing Data</h2><span id='topic+bike_sharing_daily'></span>

<h3>Description</h3>

<p>This dataset contains the daily count of
rental bike transactions between years 2011 and 2012 in Capital bikeshare
system with the corresponding weather and seasonal information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bike_sharing_daily
</code></pre>


<h3>Format</h3>

<p>A tibble: 731 x 16
</p>

<ul>
<li><p> instant: record index
</p>
</li>
<li><p> dteday : date
</p>
</li>
<li><p> season : season (1:winter, 2:spring, 3:summer, 4:fall)
</p>
</li>
<li><p> yr : year (0: 2011, 1:2012)
</p>
</li>
<li><p> mnth : month ( 1 to 12)
</p>
</li>
<li><p> hr : hour (0 to 23)
</p>
</li>
<li><p> holiday : weather day is holiday or not
</p>
</li>
<li><p> weekday : day of the week
</p>
</li>
<li><p> workingday : if day is neither weekend nor holiday is 1, otherwise is 0.
</p>
</li>
<li><p> weathersit :
</p>

<ul>
<li><p> 1: Clear, Few clouds, Partly cloudy, Partly cloudy
</p>
</li>
<li><p> 2: Mist + Cloudy, Mist + Broken clouds, Mist + Few clouds, Mist
</p>
</li>
<li><p> 3: Light Snow, Light Rain + Thunderstorm + Scattered clouds, Light Rain + Scattered clouds
</p>
</li>
<li><p> 4: Heavy Rain + Ice Pallets + Thunderstorm + Mist, Snow + Fog
</p>
</li></ul>

</li>
<li><p> temp : Normalized temperature in Celsius. The values are derived via (t-t_min)/(t_max-t_min), t_min=-8, t_max=+39 (only in hourly scale)
</p>
</li>
<li><p> atemp: Normalized feeling temperature in Celsius. The values are derived via (t-t_min)/(t_max-t_min), t_min=-16, t_max=+50 (only in hourly scale)
</p>
</li>
<li><p> hum: Normalized humidity. The values are divided to 100 (max)
</p>
</li>
<li><p> windspeed: Normalized wind speed. The values are divided to 67 (max)
</p>
</li>
<li><p> casual: count of casual users
</p>
</li>
<li><p> registered: count of registered users
</p>
</li>
<li><p> cnt: count of total rental bikes including both casual and registered
</p>
</li></ul>



<h3>References</h3>

<p>Fanaee-T, Hadi, and Gama, Joao,
'Event labeling combining ensemble detectors and background knowledge',
Progress in Artificial Intelligence (2013): pp. 1-15, Springer Berlin Heidelberg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bike_sharing_daily

</code></pre>

<hr>
<h2 id='box_cox_vec'>Box Cox Transformation</h2><span id='topic+box_cox_vec'></span><span id='topic+box_cox_inv_vec'></span><span id='topic+auto_lambda'></span>

<h3>Description</h3>

<p>This is mainly a wrapper for the BoxCox transformation from the <code>forecast</code>
R package. The <code>box_cox_vec()</code> function performs the transformation.
<code>box_cox_inv_vec()</code> inverts the transformation.
<code>auto_lambda()</code> helps in selecting the optimal <code>lambda</code> value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>box_cox_vec(x, lambda = "auto", silent = FALSE)

box_cox_inv_vec(x, lambda)

auto_lambda(
  x,
  method = c("guerrero", "loglik"),
  lambda_lower = -1,
  lambda_upper = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="box_cox_vec_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="box_cox_vec_+3A_lambda">lambda</code></td>
<td>
<p>The box cox transformation parameter.
If set to &quot;auto&quot;, performs automated lambda selection using <code>auto_lambda()</code>.</p>
</td></tr>
<tr><td><code id="box_cox_vec_+3A_silent">silent</code></td>
<td>
<p>Whether or not to report the automated <code>lambda</code> selection as a message.</p>
</td></tr>
<tr><td><code id="box_cox_vec_+3A_method">method</code></td>
<td>
<p>The method used for automatic <code>lambda</code> selection.
Either &quot;guerrero&quot; or &quot;loglik&quot;.</p>
</td></tr>
<tr><td><code id="box_cox_vec_+3A_lambda_lower">lambda_lower</code></td>
<td>
<p>A lower limit for automatic <code>lambda</code> selection</p>
</td></tr>
<tr><td><code id="box_cox_vec_+3A_lambda_upper">lambda_upper</code></td>
<td>
<p>An upper limit for automatic <code>lambda</code> selection</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Box Cox transformation is a power transformation that is commonly
used to reduce variance of a time series.
</p>
<p><strong>Automatic Lambda Selection</strong>
</p>
<p>If desired, the <code>lambda</code> argument can be selected using <code>auto_lambda()</code>,
a wrapper for the Forecast R Package's <code>forecast::BoxCox.lambda()</code> function.
Use either of 2 methods:
</p>

<ol>
<li><p> &quot;guerrero&quot; - Minimizes the non-seasonal variance
</p>
</li>
<li><p> &quot;loglik&quot; - Maximizes the log-likelihood of a linear model fit to <code>x</code>
</p>
</li></ol>



<h3>Value</h3>

<p>Returns a <code>numeric</code> vector that has been transformed.
</p>


<h3>References</h3>


<ul>
<li> <p><a href="https://github.com/robjhyndman/forecast">Forecast R Package</a>
</p>
</li>
<li> <p><a href="https://otexts.com/fpp2/transformations.html">Forecasting: Principles &amp; Practices: Transformations &amp; Adjustments</a>
</p>
</li>
<li><p> Guerrero, V.M. (1993) Time-series analysis supported by power transformations. <em>Journal of Forecasting</em>, 12,  37&ndash;48.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li><p> Box Cox Transformation: <code><a href="#topic+box_cox_vec">box_cox_vec()</a></code>
</p>
</li>
<li><p> Lag Transformation: <code><a href="#topic+lag_vec">lag_vec()</a></code>
</p>
</li>
<li><p> Differencing Transformation: <code><a href="#topic+diff_vec">diff_vec()</a></code>
</p>
</li>
<li><p> Rolling Window Transformation: <code><a href="#topic+slidify_vec">slidify_vec()</a></code>
</p>
</li>
<li><p> Loess Smoothing Transformation: <code><a href="#topic+smooth_vec">smooth_vec()</a></code>
</p>
</li>
<li><p> Fourier Series: <code><a href="#topic+fourier_vec">fourier_vec()</a></code>
</p>
</li>
<li><p> Missing Value Imputation for Time Series: <code><a href="#topic+ts_impute_vec">ts_impute_vec()</a></code>, <code><a href="#topic+ts_clean_vec">ts_clean_vec()</a></code>
</p>
</li></ul>

<p>Other common transformations to reduce variance: <code>log()</code>, <code>log1p()</code> and <code>sqrt()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
d10_daily &lt;- m4_daily %&gt;% dplyr::filter(id == "D10")

# --- VECTOR ----

value_bc &lt;- box_cox_vec(d10_daily$value)
value    &lt;- box_cox_inv_vec(value_bc, lambda = 1.25119350454964)

# --- MUTATE ----

m4_daily %&gt;%
    dplyr::group_by(id) %&gt;%
    dplyr::mutate(value_bc = box_cox_vec(value))

</code></pre>

<hr>
<h2 id='condense_period'>Convert the Period to a Lower Periodicity (e.g. Go from Daily to Monthly)</h2><span id='topic+condense_period'></span>

<h3>Description</h3>

<p>Convert a <code>data.frame</code> object from daily to monthly,
from minute data to hourly, and more. This allows the user to easily
aggregate data to a less granular level by taking the value from either
the beginning or end of the period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>condense_period(.data, .date_var, .period = "1 day", .side = c("start", "end"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="condense_period_+3A_.data">.data</code></td>
<td>
<p>A <code>tbl</code> object or <code>data.frame</code></p>
</td></tr>
<tr><td><code id="condense_period_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing date or date-time values.
If missing, attempts to auto-detect date column.</p>
</td></tr>
<tr><td><code id="condense_period_+3A_.period">.period</code></td>
<td>
<p>A period to condense the time series to.
Time units are condensed using <code>lubridate::floor_date()</code> or <code>lubridate::ceiling_date()</code>.
</p>
<p>The value can be:
</p>

<ul>
<li> <p><code>second</code>
</p>
</li>
<li> <p><code>minute</code>
</p>
</li>
<li> <p><code>hour</code>
</p>
</li>
<li> <p><code>day</code>
</p>
</li>
<li> <p><code>week</code>
</p>
</li>
<li> <p><code>month</code>
</p>
</li>
<li> <p><code>bimonth</code>
</p>
</li>
<li> <p><code>quarter</code>
</p>
</li>
<li> <p><code>season</code>
</p>
</li>
<li> <p><code>halfyear</code>
</p>
</li>
<li> <p><code>year</code>
</p>
</li></ul>

<p>Arbitrary unique English abbreviations as in the <code>lubridate::period()</code> constructor are allowed:
</p>

<ul>
<li> <p><code>"1 year"</code>
</p>
</li>
<li> <p><code>"2 months"</code>
</p>
</li>
<li> <p><code>"30 seconds"</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="condense_period_+3A_.side">.side</code></td>
<td>
<p>One of &quot;start&quot; or &quot;end&quot;. Determines if the first observation in the period should be returned
or the last.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> or <code>data.frame</code>
</p>


<h3>See Also</h3>

<p>Time-Based dplyr functions:
</p>

<ul>
<li> <p><code><a href="#topic+summarise_by_time">summarise_by_time()</a></code> - Easily summarise using a date column.
</p>
</li>
<li> <p><code><a href="#topic+mutate_by_time">mutate_by_time()</a></code> - Simplifies applying mutations by time windows.
</p>
</li>
<li> <p><code><a href="#topic+pad_by_time">pad_by_time()</a></code> - Insert time series rows with regularly spaced timestamps
</p>
</li>
<li> <p><code><a href="#topic+filter_by_time">filter_by_time()</a></code> - Quickly filter using date ranges.
</p>
</li>
<li> <p><code><a href="#topic+filter_period">filter_period()</a></code> - Apply filtering expressions inside periods (windows)
</p>
</li>
<li> <p><code><a href="#topic+slice_period">slice_period()</a></code> - Apply slice inside periods (windows)
</p>
</li>
<li> <p><code><a href="#topic+condense_period">condense_period()</a></code> - Convert to a different periodicity
</p>
</li>
<li> <p><code><a href="#topic+between_time">between_time()</a></code> - Range detection for date or date-time sequences.
</p>
</li>
<li> <p><code><a href="#topic+slidify">slidify()</a></code> - Turn any function into a sliding (rolling) function
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Libraries
library(dplyr)

# First value in each month
m4_daily %&gt;%
    group_by(id) %&gt;%
    condense_period(.period = "1 month")

# Last value in each month
m4_daily %&gt;%
    group_by(id) %&gt;%
    condense_period(.period = "1 month", .side = "end")



</code></pre>

<hr>
<h2 id='diff_vec'>Differencing Transformation</h2><span id='topic+diff_vec'></span><span id='topic+diff_inv_vec'></span>

<h3>Description</h3>

<p><code>diff_vec()</code> applies a Differencing Transformation.
<code>diff_inv_vec()</code> inverts the differencing transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_vec(
  x,
  lag = 1,
  difference = 1,
  log = FALSE,
  initial_values = NULL,
  silent = FALSE
)

diff_inv_vec(x, lag = 1, difference = 1, log = FALSE, initial_values = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_vec_+3A_x">x</code></td>
<td>
<p>A numeric vector to be differenced or inverted.</p>
</td></tr>
<tr><td><code id="diff_vec_+3A_lag">lag</code></td>
<td>
<p>Which lag (how far back) to be included in the differencing calculation.</p>
</td></tr>
<tr><td><code id="diff_vec_+3A_difference">difference</code></td>
<td>
<p>The number of differences to perform.
</p>

<ul>
<li><p> 1 Difference is equivalent to measuring period change.
</p>
</li>
<li><p> 2 Differences is equivalent to measuring period acceleration.
</p>
</li></ul>
</td></tr>
<tr><td><code id="diff_vec_+3A_log">log</code></td>
<td>
<p>If log differences should be calculated.
<em>Note that difference inversion of a log-difference is approximate.</em></p>
</td></tr>
<tr><td><code id="diff_vec_+3A_initial_values">initial_values</code></td>
<td>
<p>Only used in the <code>diff_vec_inv()</code> operation.
A numeric vector of the initial values, which are used to invert differences.
This vector is the original values that are the length of the <code>NA</code> missing differences.</p>
</td></tr>
<tr><td><code id="diff_vec_+3A_silent">silent</code></td>
<td>
<p>Whether or not to report the initial values used to invert the difference
as a message.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Benefits:</strong>
</p>
<p>This function is <code>NA</code> padded by default so it works well with <code>dplyr::mutate()</code> operations.
</p>
<p><strong>Difference Calculation</strong>
</p>
<p>Single differencing, <code>diff_vec(x_t)</code> is equivalent to: <code>x_t - x_t1</code>,
where the subscript _t1 indicates the first lag.
<em>This transformation can be interpereted as change.</em>
</p>
<p><strong>Double Differencing Calculation</strong>
</p>
<p>Double differencing, <code>diff_vec(x_t, difference = 2)</code> is equivalent to:
<code style="white-space: pre;">&#8288;(x_t - x_t1) - (x_t - x_t1)_t1&#8288;</code>, where the subscript _t1 indicates the first lag.
<em>This transformation can be interpereted as acceleration.</em>
</p>
<p><strong>Log Difference Calculation</strong>
</p>
<p>Log differencing, <code>diff_vec(x_t, log = TRUE)</code> is equivalent to:
<code>log(x_t) - log(x_t1) = log(x_t / x_t1)</code>, where x_t is the series and x_t1 is the first lag.
</p>
<p>The 1st difference <code>diff_vec(difference = 1, log = TRUE)</code> has an interesting property
where <code>diff_vec(difference = 1, log = TRUE) %&gt;% exp()</code> is approximately <em>1 + rate of change.</em>
</p>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>See Also</h3>

<p>Advanced Differencing and Modeling:
</p>

<ul>
<li> <p><code><a href="#topic+step_diff">step_diff()</a></code> - Recipe for <code>tidymodels</code> workflow
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_differences">tk_augment_differences()</a></code> - Adds many differences to a <code>data.frame</code> (<code>tibble</code>)
</p>
</li></ul>

<p>Additional Vector Functions:
</p>

<ul>
<li><p> Box Cox Transformation: <code><a href="#topic+box_cox_vec">box_cox_vec()</a></code>
</p>
</li>
<li><p> Lag Transformation: <code><a href="#topic+lag_vec">lag_vec()</a></code>
</p>
</li>
<li><p> Differencing Transformation: <code><a href="#topic+diff_vec">diff_vec()</a></code>
</p>
</li>
<li><p> Rolling Window Transformation: <code><a href="#topic+slidify_vec">slidify_vec()</a></code>
</p>
</li>
<li><p> Loess Smoothing Transformation: <code><a href="#topic+smooth_vec">smooth_vec()</a></code>
</p>
</li>
<li><p> Fourier Series: <code><a href="#topic+fourier_vec">fourier_vec()</a></code>
</p>
</li>
<li><p> Missing Value Imputation for Time Series: <code><a href="#topic+ts_impute_vec">ts_impute_vec()</a></code>, <code><a href="#topic+ts_clean_vec">ts_clean_vec()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# --- USAGE ----

diff_vec(1:10, lag = 2, difference = 2) %&gt;%
    diff_inv_vec(lag = 2, difference = 2, initial_values = 1:4)

# --- VECTOR ----

# Get Change
1:10 %&gt;% diff_vec()

# Get Acceleration
1:10 %&gt;% diff_vec(difference = 2)

# Get approximate rate of change
1:10 %&gt;% diff_vec(log = TRUE) %&gt;% exp() - 1


# --- MUTATE ----

m4_daily %&gt;%
    group_by(id) %&gt;%
    mutate(difference = diff_vec(value, lag = 1)) %&gt;%
    mutate(
        difference_inv = diff_inv_vec(
            difference,
            lag = 1,
            # Add initial value to calculate the inverse difference
            initial_values = value[1]
        )
    )



</code></pre>

<hr>
<h2 id='FANG'>Stock prices for the &quot;FANG&quot; stocks.</h2><span id='topic+FANG'></span>

<h3>Description</h3>

<p>A dataset containing the daily historical stock prices for the &quot;FANG&quot; tech stocks,
&quot;FB&quot;, &quot;AMZN&quot;, &quot;NFLX&quot;, and &quot;GOOG&quot;, spanning from the beginning of
2013 through the end of 2016.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FANG
</code></pre>


<h3>Format</h3>

<p>A &quot;tibble&quot; (&quot;tidy&quot; data frame) with 4,032 rows and 8 variables:
</p>

<dl>
<dt>symbol</dt><dd><p>stock ticker symbol</p>
</dd>
<dt>date</dt><dd><p>trade date</p>
</dd>
<dt>open</dt><dd><p>stock price at the open of trading, in USD</p>
</dd>
<dt>high</dt><dd><p>stock price at the highest point during trading, in USD</p>
</dd>
<dt>low</dt><dd><p>stock price at the lowest point during trading, in USD</p>
</dd>
<dt>close</dt><dd><p>stock price at the close of trading, in USD</p>
</dd>
<dt>volume</dt><dd><p>number of shares traded</p>
</dd>
<dt>adjusted</dt><dd><p>stock price at the close of trading adjusted for stock splits, in USD</p>
</dd>
</dl>


<hr>
<h2 id='filter_by_time'>Filter (for Time-Series Data)</h2><span id='topic+filter_by_time'></span>

<h3>Description</h3>

<p>The easiest way to filter time-based <em><strong>start/end ranges</strong></em> using shorthand timeseries notation.
See <code><a href="#topic+filter_period">filter_period()</a></code> for applying filter expression by period (windows).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filter_by_time(.data, .date_var, .start_date = "start", .end_date = "end")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_by_time_+3A_.data">.data</code></td>
<td>
<p>A tibble with a time-based column.</p>
</td></tr>
<tr><td><code id="filter_by_time_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing date or date-time values to filter.
If missing, attempts to auto-detect date column.</p>
</td></tr>
<tr><td><code id="filter_by_time_+3A_.start_date">.start_date</code></td>
<td>
<p>The starting date for the filter sequence</p>
</td></tr>
<tr><td><code id="filter_by_time_+3A_.end_date">.end_date</code></td>
<td>
<p>The ending date for the filter sequence</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Pure Time Series Filtering Flexibilty</strong>
</p>
<p>The <code>.start_date</code>  and <code>.end_date</code> parameters are designed with flexibility in mind.
</p>
<p>Each side of the <code>time_formula</code> is specified as the character
<code>'YYYY-MM-DD HH:MM:SS'</code>, but powerful shorthand is available.
Some examples are:
</p>

<ul>
<li> <p><strong>Year:</strong> <code style="white-space: pre;">&#8288;.start_date = '2013', .end_date = '2015'&#8288;</code>
</p>
</li>
<li> <p><strong>Month:</strong> <code style="white-space: pre;">&#8288;.start_date = '2013-01', .end_date = '2016-06'&#8288;</code>
</p>
</li>
<li> <p><strong>Day:</strong> <code style="white-space: pre;">&#8288;.start_date = '2013-01-05', .end_date = '2016-06-04'&#8288;</code>
</p>
</li>
<li> <p><strong>Second:</strong> <code style="white-space: pre;">&#8288;.start_date = '2013-01-05 10:22:15', .end_date = '2018-06-03 12:14:22'&#8288;</code>
</p>
</li>
<li> <p><strong>Variations:</strong> <code style="white-space: pre;">&#8288;.start_date = '2013', .end_date = '2016-06'&#8288;</code>
</p>
</li></ul>

<p><strong>Key Words: &quot;start&quot; and &quot;end&quot;</strong>
</p>
<p>Use the keywords &quot;start&quot; and &quot;end&quot; as shorthand, instead of specifying the
actual start and end values. Here are some examples:
</p>

<ul>
<li> <p><strong>Start of the series to end of 2015:</strong> <code style="white-space: pre;">&#8288;.start_date = 'start', .end_date = '2015'&#8288;</code>
</p>
</li>
<li> <p><strong>Start of 2014 to end of series:</strong> <code style="white-space: pre;">&#8288;.start_date = '2014', .end_date = 'end'&#8288;</code>
</p>
</li></ul>

<p><strong>Internal Calculations</strong>
</p>
<p>All shorthand dates are expanded:
</p>

<ul>
<li><p> The <code>.start_date</code> is expanded to be the <em>first date</em> in that period
</p>
</li>
<li><p> The <code>.end_date</code> side is expanded to be the <em>last date</em> in that period
</p>
</li></ul>

<p>This means that the following examples are equivalent (assuming your
index is a POSIXct):
</p>

<ul>
<li> <p><code>.start_date = '2015'</code> is equivalent to <code>.start_date = '2015-01-01 + 00:00:00' </code>
</p>
</li>
<li> <p><code>.end_date = '2016'</code> is equivalent to <code style="white-space: pre;">&#8288;2016-12-31 + 23:59:59'&#8288;</code>
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a <code>tibble</code> or <code>data.frame</code> that has been filtered.
</p>


<h3>References</h3>


<ul>
<li><p> This function is based on the <code>tibbletime::filter_time()</code> function developed by Davis Vaughan.
</p>
</li></ul>



<h3>See Also</h3>

<p>Time-Based dplyr functions:
</p>

<ul>
<li> <p><code><a href="#topic+summarise_by_time">summarise_by_time()</a></code> - Easily summarise using a date column.
</p>
</li>
<li> <p><code><a href="#topic+mutate_by_time">mutate_by_time()</a></code> - Simplifies applying mutations by time windows.
</p>
</li>
<li> <p><code><a href="#topic+pad_by_time">pad_by_time()</a></code> - Insert time series rows with regularly spaced timestamps
</p>
</li>
<li> <p><code><a href="#topic+filter_by_time">filter_by_time()</a></code> - Quickly filter using date ranges.
</p>
</li>
<li> <p><code><a href="#topic+filter_period">filter_period()</a></code> - Apply filtering expressions inside periods (windows)
</p>
</li>
<li> <p><code><a href="#topic+slice_period">slice_period()</a></code> - Apply slice inside periods (windows)
</p>
</li>
<li> <p><code><a href="#topic+condense_period">condense_period()</a></code> - Convert to a different periodicity
</p>
</li>
<li> <p><code><a href="#topic+between_time">between_time()</a></code> - Range detection for date or date-time sequences.
</p>
</li>
<li> <p><code><a href="#topic+slidify">slidify()</a></code> - Turn any function into a sliding (rolling) function
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Filter values in January 1st through end of February, 2013
FANG %&gt;%
    group_by(symbol) %&gt;%
    filter_by_time(.start_date = "start", .end_date = "2013-02") %&gt;%
    plot_time_series(date, adjusted, .facet_ncol = 2, .interactive = FALSE)

</code></pre>

<hr>
<h2 id='filter_period'>Apply filtering expressions inside periods (windows)</h2><span id='topic+filter_period'></span>

<h3>Description</h3>

<p>Applies a dplyr <em><strong>filtering expression inside a time-based period (window).</strong></em>
See <code><a href="#topic+filter_by_time">filter_by_time()</a></code> for filtering continuous ranges defined by start/end dates.
<code>filter_period()</code> enables filtering expressions like:
</p>

<ul>
<li><p> Filtering to the maximum value each month.
</p>
</li>
<li><p> Filtering the first date each month.
</p>
</li>
<li><p> Filtering all rows with value greater than a monthly average
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>filter_period(.data, ..., .date_var, .period = "1 day")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filter_period_+3A_.data">.data</code></td>
<td>
<p>A <code>tbl</code> object or <code>data.frame</code></p>
</td></tr>
<tr><td><code id="filter_period_+3A_...">...</code></td>
<td>
<p>Filtering expression. Expressions that return a logical value, and are defined in
terms of the variables in .data. If multiple expressions are included, they are combined with
the &amp; operator. Only rows for which all conditions evaluate to TRUE are kept.</p>
</td></tr>
<tr><td><code id="filter_period_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing date or date-time values.
If missing, attempts to auto-detect date column.</p>
</td></tr>
<tr><td><code id="filter_period_+3A_.period">.period</code></td>
<td>
<p>A period to filter within.
Time units are grouped using <code>lubridate::floor_date()</code> or <code>lubridate::ceiling_date()</code>.
</p>
<p>The value can be:
</p>

<ul>
<li> <p><code>second</code>
</p>
</li>
<li> <p><code>minute</code>
</p>
</li>
<li> <p><code>hour</code>
</p>
</li>
<li> <p><code>day</code>
</p>
</li>
<li> <p><code>week</code>
</p>
</li>
<li> <p><code>month</code>
</p>
</li>
<li> <p><code>bimonth</code>
</p>
</li>
<li> <p><code>quarter</code>
</p>
</li>
<li> <p><code>season</code>
</p>
</li>
<li> <p><code>halfyear</code>
</p>
</li>
<li> <p><code>year</code>
</p>
</li></ul>

<p>Arbitrary unique English abbreviations as in the <code>lubridate::period()</code> constructor are allowed:
</p>

<ul>
<li> <p><code>"1 year"</code>
</p>
</li>
<li> <p><code>"2 months"</code>
</p>
</li>
<li> <p><code>"30 seconds"</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> or <code>data.frame</code>
</p>


<h3>See Also</h3>

<p>Time-Based dplyr functions:
</p>

<ul>
<li> <p><code><a href="#topic+summarise_by_time">summarise_by_time()</a></code> - Easily summarise using a date column.
</p>
</li>
<li> <p><code><a href="#topic+mutate_by_time">mutate_by_time()</a></code> - Simplifies applying mutations by time windows.
</p>
</li>
<li> <p><code><a href="#topic+pad_by_time">pad_by_time()</a></code> - Insert time series rows with regularly spaced timestamps
</p>
</li>
<li> <p><code><a href="#topic+filter_by_time">filter_by_time()</a></code> - Quickly filter using date ranges.
</p>
</li>
<li> <p><code><a href="#topic+filter_period">filter_period()</a></code> - Apply filtering expressions inside periods (windows)
</p>
</li>
<li> <p><code><a href="#topic+slice_period">slice_period()</a></code> - Apply slice inside periods (windows)
</p>
</li>
<li> <p><code><a href="#topic+condense_period">condense_period()</a></code> - Convert to a different periodicity
</p>
</li>
<li> <p><code><a href="#topic+between_time">between_time()</a></code> - Range detection for date or date-time sequences.
</p>
</li>
<li> <p><code><a href="#topic+slidify">slidify()</a></code> - Turn any function into a sliding (rolling) function
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Libraries
library(dplyr)

# Max value in each month
m4_daily %&gt;%
    group_by(id) %&gt;%
    filter_period(.period = "1 month", value == max(value))

# First date each month
m4_daily %&gt;%
    group_by(id) %&gt;%
    filter_period(.period = "1 month", date == first(date))

# All observations that are greater than a monthly average
m4_daily %&gt;%
    group_by(id) %&gt;%
    filter_period(.period = "1 month", value &gt; mean(value))

</code></pre>

<hr>
<h2 id='fourier_vec'>Fourier Series</h2><span id='topic+fourier_vec'></span>

<h3>Description</h3>

<p><code>fourier_vec()</code> calculates a Fourier Series from a date or date-time index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fourier_vec(x, period, K = 1, type = c("sin", "cos"), scale_factor = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fourier_vec_+3A_x">x</code></td>
<td>
<p>A date, POSIXct, yearmon, yearqtr, or numeric sequence (scaled to difference 1 for <code>period</code> alignment)
to be converted to a fourier series.</p>
</td></tr>
<tr><td><code id="fourier_vec_+3A_period">period</code></td>
<td>
<p>The number of observations that complete one cycle.</p>
</td></tr>
<tr><td><code id="fourier_vec_+3A_k">K</code></td>
<td>
<p>The fourier term order.</p>
</td></tr>
<tr><td><code id="fourier_vec_+3A_type">type</code></td>
<td>
<p>Either &quot;sin&quot; or &quot;cos&quot; for the appropriate type of fourier term.</p>
</td></tr>
<tr><td><code id="fourier_vec_+3A_scale_factor">scale_factor</code></td>
<td>
<p>Scale factor is a calculated value that scales date sequences to numeric sequences.
A user can provide a different value of scale factor to override the date scaling.
Default: NULL (auto-scale).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Benefits:</strong>
</p>
<p>This function is <code>NA</code> padded by default so it works well with <code>dplyr::mutate()</code> operations.
</p>
<p><strong>Fourier Series Calculation</strong>
</p>
<p>The internal calculation is relatively straightforward:
<code style="white-space: pre;">&#8288;fourier(x) = sin(2 * pi * term * x) or cos(2 * pi * term * x)&#8288;</code>,
where <code>term = K / period</code>.
</p>
<p><strong>Period Alignment, period</strong>
</p>
<p>The <code>period</code> alignment with the sequence is an essential part of fourier series calculation.
</p>

<ul>
<li> <p><strong>Date, Date-Time, and Zoo (yearqtr and yearmon) Sequences</strong> - Are scaled to unit difference of 1. This happens internally,
so there's nothing you need to do or to worry about. Future time series will be scaled appropriately.
</p>
</li>
<li> <p><strong>Numeric Sequences</strong> - Are not scaled, which means you should transform them to a unit difference of 1 so that
your x is a sequence that increases by 1. Otherwise your period and fourier order will be incorrectly calculated.
The solution is to just take your sequence and divide by the median difference between values.
</p>
</li></ul>

<p><strong>Fourier Order, K</strong>
</p>
<p>The fourier order is a parameter that increases the frequency. <code>K = 2</code> doubles the frequency.
It's common in time series analysis to add multiple fourier orders (e.g. 1 through 5) to account for
seasonalities that occur faster than the primary seasonality.
</p>
<p><strong>Type (Sin/Cos)</strong>
</p>
<p>The type of the fourier series can be either <code>sin</code> or <code>cos</code>. It's common in time series analysis
to add both sin and cos series.
</p>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>See Also</h3>

<p>Fourier Modeling Functions:
</p>

<ul>
<li> <p><code><a href="#topic+step_fourier">step_fourier()</a></code> - Recipe for <code>tidymodels</code> workflow
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_fourier">tk_augment_fourier()</a></code> - Adds many fourier series to a <code>data.frame</code> (<code>tibble</code>)
</p>
</li></ul>

<p>Additional Vector Functions:
</p>

<ul>
<li><p> Fourier Series: <code><a href="#topic+fourier_vec">fourier_vec()</a></code>
</p>
</li>
<li><p> Box Cox Transformation: <code><a href="#topic+box_cox_vec">box_cox_vec()</a></code>
</p>
</li>
<li><p> Lag Transformation: <code><a href="#topic+lag_vec">lag_vec()</a></code>
</p>
</li>
<li><p> Differencing Transformation: <code><a href="#topic+diff_vec">diff_vec()</a></code>
</p>
</li>
<li><p> Rolling Window Transformation: <code><a href="#topic+slidify_vec">slidify_vec()</a></code>
</p>
</li>
<li><p> Loess Smoothing Transformation: <code><a href="#topic+smooth_vec">smooth_vec()</a></code>
</p>
</li>
<li><p> Missing Value Imputation for Time Series: <code><a href="#topic+ts_impute_vec">ts_impute_vec()</a></code>, <code><a href="#topic+ts_clean_vec">ts_clean_vec()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Set max.print to 50
options_old &lt;- options()$max.print
options(max.print = 50)

date_sequence &lt;- tk_make_timeseries("2016-01-01", "2016-01-31", by = "hour")

# --- VECTOR ---

fourier_vec(date_sequence, period = 7 * 24, K = 1, type = "sin")

# --- MUTATE ---

tibble(date = date_sequence) %&gt;%
    # Add cosine series that oscilates at a 7-day period
    mutate(
        C1_7 = fourier_vec(date, period = 7*24, K = 1, type = "cos"),
        C2_7 = fourier_vec(date, period = 7*24, K = 2, type = "cos")
    ) %&gt;%
    # Visualize
    tidyr::pivot_longer(cols = contains("_"), names_to = "name", values_to = "value") %&gt;%
    plot_time_series(
        date, value, .color_var = name,
        .smooth = FALSE,
        .interactive = FALSE,
        .title = "7-Day Fourier Terms"
    )

options(max.print = options_old)

</code></pre>

<hr>
<h2 id='future_frame'>Make future time series from existing</h2><span id='topic+future_frame'></span>

<h3>Description</h3>

<p>Make future time series from existing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>future_frame(
  .data,
  .date_var,
  .length_out,
  .inspect_weekdays = FALSE,
  .inspect_months = FALSE,
  .skip_values = NULL,
  .insert_values = NULL,
  .bind_data = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="future_frame_+3A_.data">.data</code></td>
<td>
<p>A data.frame or tibble</p>
</td></tr>
<tr><td><code id="future_frame_+3A_.date_var">.date_var</code></td>
<td>
<p>A date or date-time variable.</p>
</td></tr>
<tr><td><code id="future_frame_+3A_.length_out">.length_out</code></td>
<td>
<p>Number of future observations. Can be numeric number or a phrase
like &quot;1 year&quot;.</p>
</td></tr>
<tr><td><code id="future_frame_+3A_.inspect_weekdays">.inspect_weekdays</code></td>
<td>
<p>Uses a logistic regression algorithm to inspect
whether certain weekdays (e.g. weekends) should be excluded from the future dates.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="future_frame_+3A_.inspect_months">.inspect_months</code></td>
<td>
<p>Uses a logistic regression algorithm to inspect
whether certain days of months (e.g. last two weeks of year or seasonal days)
should be excluded from the future dates.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="future_frame_+3A_.skip_values">.skip_values</code></td>
<td>
<p>A vector of same class as <code>idx</code> of timeseries
values to skip.</p>
</td></tr>
<tr><td><code id="future_frame_+3A_.insert_values">.insert_values</code></td>
<td>
<p>A vector of same class as <code>idx</code> of timeseries
values to insert.</p>
</td></tr>
<tr><td><code id="future_frame_+3A_.bind_data">.bind_data</code></td>
<td>
<p>Whether or not to perform a row-wise bind of the <code>.data</code> and
the future data. Default: <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper for <code><a href="#topic+tk_make_future_timeseries">tk_make_future_timeseries()</a></code> that works on data.frames. It respects <code>dplyr</code> groups.
</p>
<p><strong>Specifying Length of Future Observations</strong>
</p>
<p>The argument <code>.length_out</code> determines how many future index observations to compute. It can be specified
as:
</p>

<ul>
<li> <p><strong>A numeric value</strong> - the number of future observations to return.
</p>

<ul>
<li><p> The number of observations returned is <em>always</em> equal to the value the user inputs.
</p>
</li>
<li><p> The <strong>end date can vary</strong> based on the number of timestamps chosen.
</p>
</li></ul>

</li>
<li> <p><strong>A time-based phrase</strong> - The duration into the future to include (e.g. &quot;6 months&quot; or &quot;30 minutes&quot;).
</p>

<ul>
<li><p> The <em>duration</em> defines the <em>end date</em> for observations.
</p>
</li>
<li><p> The <strong>end date will not change</strong> and those timestamps that fall within the end date will be returned
(e.g. a quarterly time series will return 4 quarters if <code>.length_out = "1 year"</code>).
</p>
</li>
<li><p> The number of observations will vary to fit within the end date.
</p>
</li></ul>

</li></ul>

<p><strong>Weekday and Month Inspection</strong>
</p>
<p>The <code>.inspect_weekdays</code> and <code>.inspect_months</code> arguments apply to &quot;daily&quot; (scale = &quot;day&quot;) data
(refer to <code>tk_get_timeseries_summary()</code> to get the index scale).
</p>

<ul>
<li><p> The <code>.inspect_weekdays</code> argument is useful in determining missing days of the week
that occur on a weekly frequency such as every week, every other week, and so on.
It's recommended to have at least 60 days to use this option.
</p>
</li>
<li><p> The <code>.inspect_months</code> argument is useful in determining missing days of the month, quarter
or year; however, the algorithm can inadvertently select incorrect dates if the pattern
is erratic.
</p>
</li></ul>

<p><strong>Skipping / Inserting Values</strong>
</p>
<p>The <code>.skip_values</code> and <code>.insert_values</code> arguments can be used to remove and add
values into the series of future times. The values must be the same format as the <code>idx</code> class.
</p>

<ul>
<li><p> The <code>.skip_values</code> argument useful for passing holidays or special index values that should
be excluded from the future time series.
</p>
</li>
<li><p> The <code>.insert_values</code> argument is useful for adding values back that the algorithm may have
excluded.
</p>
</li></ul>

<p><strong>Binding with Data</strong>
</p>
<p>Rowwise binding with the original is so common that
I've added an argument <code>.bind_data</code> to perform a row-wise
bind of the future data and the incoming data.
</p>
<p>This <em>replaces</em> the need to do:
</p>
<div class="sourceCode"><pre>df %&gt;%
   future_frame(.length_out = "6 months") %&gt;%
   bind_rows(df, .)
</pre></div>
<p>Now you can just do:
</p>
<div class="sourceCode"><pre>df %&gt;%
    future_frame(.length_out = "6 months", .bind_data = TRUE)
</pre></div>


<h3>Value</h3>

<p>A tibble that has been extended with future date, date-time timestamps.
</p>


<h3>See Also</h3>


<ul>
<li><p> Making Future Time Series: <code><a href="#topic+tk_make_future_timeseries">tk_make_future_timeseries()</a></code> (Underlying function)
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

# 30-min interval data
taylor_30_min %&gt;%
    future_frame(date, .length_out = "1 week")

# Daily Data (Grouped)
m4_daily %&gt;%
    group_by(id) %&gt;%
    future_frame(date, .length_out = "6 weeks")

# Specify how many observations to project into the future
m4_daily %&gt;%
    group_by(id) %&gt;%
    future_frame(date, .length_out = 100)

# Bind with Original Data
m4_daily %&gt;%
    group_by(id) %&gt;%
    future_frame(date, .length_out = 100, .bind_data = TRUE)

holidays &lt;- tk_make_holiday_sequence(
    start_date = "2017-01-01",
    end_date   = "2017-12-31",
    calendar   = "NYSE")

weekends &lt;- tk_make_weekend_sequence(
    start_date = "2017-01-01",
    end_date   = "2017-12-31"
)

FANG %&gt;%
    group_by(symbol) %&gt;%
    future_frame(
        .length_out       = "1 year",
        .skip_values      = c(holidays, weekends)
    )


</code></pre>

<hr>
<h2 id='is_date_class'>Check if an object is a date class</h2><span id='topic+is_date_class'></span>

<h3>Description</h3>

<p>Check if an object is a date class
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_date_class(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_date_class_+3A_x">x</code></td>
<td>
<p>A vector to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical (TRUE/FALSE)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

tk_make_timeseries("2011") %&gt;% is_date_class()

letters %&gt;% is_date_class()


</code></pre>

<hr>
<h2 id='lag_vec'>Lag Transformation</h2><span id='topic+lag_vec'></span><span id='topic+lead_vec'></span>

<h3>Description</h3>

<p><code>lag_vec()</code> applies a Lag Transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lag_vec(x, lag = 1)

lead_vec(x, lag = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lag_vec_+3A_x">x</code></td>
<td>
<p>A vector to be lagged.</p>
</td></tr>
<tr><td><code id="lag_vec_+3A_lag">lag</code></td>
<td>
<p>Which lag (how far back) to be included in the differencing calculation.
Negative lags are leads.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Benefits:</strong>
</p>
<p>This function is <code>NA</code> padded by default so it works well with <code>dplyr::mutate()</code> operations.
The function allows both lags and leads (negative lags).
</p>
<p><strong>Lag Calculation</strong>
</p>
<p>A lag is an offset of <code>lag</code> periods. <code>NA</code> values are returned for the number of <code>lag</code> periods.
</p>
<p><strong>Lead Calculation</strong>
</p>
<p>A <em>negative lag</em> is considered a lead. The only difference between <code>lead_vec()</code> and <code>lag_vec()</code> is
that the <code>lead_vec()</code> function contains a starting negative value.
</p>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>See Also</h3>

<p>Modeling and Advanced Lagging:
</p>

<ul>
<li> <p><code><a href="recipes.html#topic+step_lag">recipes::step_lag()</a></code> - Recipe for adding lags in <code>tidymodels</code> modeling
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_lags">tk_augment_lags()</a></code> - Add many lags group-wise to a data.frame (tibble)
</p>
</li></ul>

<p>Vectorized Transformations:
</p>

<ul>
<li><p> Box Cox Transformation: <code><a href="#topic+box_cox_vec">box_cox_vec()</a></code>
</p>
</li>
<li><p> Lag Transformation: <code><a href="#topic+lag_vec">lag_vec()</a></code>
</p>
</li>
<li><p> Differencing Transformation: <code><a href="#topic+diff_vec">diff_vec()</a></code>
</p>
</li>
<li><p> Rolling Window Transformation: <code><a href="#topic+slidify_vec">slidify_vec()</a></code>
</p>
</li>
<li><p> Loess Smoothing Transformation: <code><a href="#topic+smooth_vec">smooth_vec()</a></code>
</p>
</li>
<li><p> Fourier Series: <code><a href="#topic+fourier_vec">fourier_vec()</a></code>
</p>
</li>
<li><p> Missing Value Imputation for Time Series: <code><a href="#topic+ts_impute_vec">ts_impute_vec()</a></code>, <code><a href="#topic+ts_clean_vec">ts_clean_vec()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# --- VECTOR ----

# Lag
1:10 %&gt;% lag_vec(lag = 1)

# Lead
1:10 %&gt;% lag_vec(lag = -1)


# --- MUTATE ----

m4_daily %&gt;%
    group_by(id) %&gt;%
    mutate(lag_1 = lag_vec(value, lag = 1))


</code></pre>

<hr>
<h2 id='log_interval_vec'>Log-Interval Transformation for Constrained Interval Forecasting</h2><span id='topic+log_interval_vec'></span><span id='topic+log_interval_inv_vec'></span>

<h3>Description</h3>

<p>The <code>log_interval_vec()</code> transformation constrains a forecast to an interval
specified by an <code>upper_limit</code> and a <code>lower_limit</code>. The transformation provides
similar benefits to <code>log()</code> transformation, while ensuring the inverted transformation
stays within an upper and lower limit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_interval_vec(
  x,
  limit_lower = "auto",
  limit_upper = "auto",
  offset = 0,
  silent = FALSE
)

log_interval_inv_vec(x, limit_lower, limit_upper, offset = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="log_interval_vec_+3A_x">x</code></td>
<td>
<p>A positive numeric vector.</p>
</td></tr>
<tr><td><code id="log_interval_vec_+3A_limit_lower">limit_lower</code></td>
<td>
<p>A lower limit. Must be less than the minimum value.
If set to &quot;auto&quot;, selects zero.</p>
</td></tr>
<tr><td><code id="log_interval_vec_+3A_limit_upper">limit_upper</code></td>
<td>
<p>An upper limit. Must be greater than the maximum value.
If set to &quot;auto&quot;,  selects a value that is 10% greater than the maximum value.</p>
</td></tr>
<tr><td><code id="log_interval_vec_+3A_offset">offset</code></td>
<td>
<p>An offset to include in the log transformation.
Useful when the data contains values less than or equal to zero.</p>
</td></tr>
<tr><td><code id="log_interval_vec_+3A_silent">silent</code></td>
<td>
<p>Whether or not to report the parameter selections as a message.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Log Interval Transformation</strong>
</p>
<p>The Log Interval Transformation constrains values to specified upper and lower limits.
The transformation maps limits to a function:
</p>
<p><code>log(((x + offset) - a)/(b - (x + offset)))</code>
</p>
<p>where <code>a</code> is the lower limit and <code>b</code> is the upper limit
</p>
<p><strong>Inverse Transformation</strong>
</p>
<p>The inverse transformation:
</p>
<p><code>(b-a)*(exp(x)) / (1 + exp(x)) + a - offset</code>
</p>


<h3>Value</h3>

<p>A <code>numeric</code> vector of the transformed series.
</p>


<h3>References</h3>


<ul>
<li> <p><a href="https://otexts.com/fpp2/limits.html">Forecasting: Principles &amp; Practices: Forecasts constrained to an interval</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li><p> Box Cox Transformation: <code><a href="#topic+box_cox_vec">box_cox_vec()</a></code>
</p>
</li>
<li><p> Lag Transformation: <code><a href="#topic+lag_vec">lag_vec()</a></code>
</p>
</li>
<li><p> Differencing Transformation: <code><a href="#topic+diff_vec">diff_vec()</a></code>
</p>
</li>
<li><p> Rolling Window Transformation: <code><a href="#topic+slidify_vec">slidify_vec()</a></code>
</p>
</li>
<li><p> Loess Smoothing Transformation: <code><a href="#topic+smooth_vec">smooth_vec()</a></code>
</p>
</li>
<li><p> Fourier Series: <code><a href="#topic+fourier_vec">fourier_vec()</a></code>
</p>
</li>
<li><p> Missing Value Imputation &amp; Anomaly Cleaning for Time Series: <code><a href="#topic+ts_impute_vec">ts_impute_vec()</a></code>, <code><a href="#topic+ts_clean_vec">ts_clean_vec()</a></code>
</p>
</li></ul>

<p>Other common transformations to reduce variance: <code>log()</code>, <code>log1p()</code> and <code>sqrt()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

values_trans &lt;- log_interval_vec(1:10, limit_lower = 0, limit_upper = 11)
values_trans

values_trans_forecast &lt;- c(values_trans, 3.4, 4.4, 5.4)

values_trans_forecast %&gt;%
    log_interval_inv_vec(limit_lower = 0, limit_upper = 11) %&gt;%
    plot()


</code></pre>

<hr>
<h2 id='m4_daily'>Sample of 4 Daily Time Series Datasets from the M4 Competition</h2><span id='topic+m4_daily'></span>

<h3>Description</h3>

<p>The fourth M Competition.
M4, started on 1 January 2018 and ended in 31 May 2018.
The competition included 100,000 time series datasets.
This dataset includes <strong>a sample of 4 daily time series from the competition.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m4_daily
</code></pre>


<h3>Format</h3>

<p>A tibble: 9,743 x 3
</p>

<ul>
<li> <p><code>id</code> Factor. Unique series identifier (4 total)
</p>
</li>
<li> <p><code>date</code> Date. Timestamp information. Daily format.
</p>
</li>
<li> <p><code>value</code> Numeric. Value at the corresponding timestamp.
</p>
</li></ul>



<h3>Details</h3>

<p>This is a sample of 4 daily data sets from the M4 competition.
</p>


<h3>Source</h3>


<ul>
<li> <p><a href="https://mofc.unic.ac.cy/m4/">M4 Competition Website</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>m4_daily

</code></pre>

<hr>
<h2 id='m4_hourly'>Sample of 4 Hourly Time Series Datasets from the M4 Competition</h2><span id='topic+m4_hourly'></span>

<h3>Description</h3>

<p>The fourth M Competition.
M4, started on 1 January 2018 and ended in 31 May 2018.
The competition included 100,000 time series datasets.
This dataset includes <strong>a sample of 4 hourly time series from the competition.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m4_hourly
</code></pre>


<h3>Format</h3>

<p>A tibble: 3,060 x 3
</p>

<ul>
<li> <p><code>id</code> Factor. Unique series identifier (4 total)
</p>
</li>
<li> <p><code>date</code> Date-time. Timestamp information. Hourly format.
</p>
</li>
<li> <p><code>value</code> Numeric. Value at the corresponding timestamp.
</p>
</li></ul>



<h3>Details</h3>

<p>This is a sample of 4 hourly data sets from the M4 competition.
</p>


<h3>Source</h3>


<ul>
<li> <p><a href="https://mofc.unic.ac.cy/m4/">M4 Competition Website</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>m4_hourly

</code></pre>

<hr>
<h2 id='m4_monthly'>Sample of 4 Monthly Time Series Datasets from the M4 Competition</h2><span id='topic+m4_monthly'></span>

<h3>Description</h3>

<p>The fourth M Competition.
M4, started on 1 January 2018 and ended in 31 May 2018.
The competition included 100,000 time series datasets.
This dataset includes <strong>a sample of 4 monthly time series from the competition.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m4_monthly
</code></pre>


<h3>Format</h3>

<p>A tibble: 9,743 x 3
</p>

<ul>
<li> <p><code>id</code> Factor. Unique series identifier (4 total)
</p>
</li>
<li> <p><code>date</code> Date. Timestamp information. Monthly format.
</p>
</li>
<li> <p><code>value</code> Numeric. Value at the corresponding timestamp.
</p>
</li></ul>



<h3>Details</h3>

<p>This is a sample of 4 Monthly data sets from the M4 competition.
</p>


<h3>Source</h3>


<ul>
<li> <p><a href="https://mofc.unic.ac.cy/m4/">M4 Competition Website</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>m4_monthly

</code></pre>

<hr>
<h2 id='m4_quarterly'>Sample of 4 Quarterly Time Series Datasets from the M4 Competition</h2><span id='topic+m4_quarterly'></span>

<h3>Description</h3>

<p>The fourth M Competition.
M4, started on 1 January 2018 and ended in 31 May 2018.
The competition included 100,000 time series datasets.
This dataset includes <strong>a sample of 4 quarterly time series from the competition.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m4_quarterly
</code></pre>


<h3>Format</h3>

<p>A tibble: 9,743 x 3
</p>

<ul>
<li> <p><code>id</code> Factor. Unique series identifier (4 total)
</p>
</li>
<li> <p><code>date</code> Date. Timestamp information. Quarterly format.
</p>
</li>
<li> <p><code>value</code> Numeric. Value at the corresponding timestamp.
</p>
</li></ul>



<h3>Details</h3>

<p>This is a sample of 4 Quarterly data sets from the M4 competition.
</p>


<h3>Source</h3>


<ul>
<li> <p><a href="https://mofc.unic.ac.cy/m4/">M4 Competition Website</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>m4_quarterly

</code></pre>

<hr>
<h2 id='m4_weekly'>Sample of 4 Weekly Time Series Datasets from the M4 Competition</h2><span id='topic+m4_weekly'></span>

<h3>Description</h3>

<p>The fourth M Competition.
M4, started on 1 January 2018 and ended in 31 May 2018.
The competition included 100,000 time series datasets.
This dataset includes <strong>a sample of 4 weekly time series from the competition.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m4_weekly
</code></pre>


<h3>Format</h3>

<p>A tibble: 9,743 x 3
</p>

<ul>
<li> <p><code>id</code> Factor. Unique series identifier (4 total)
</p>
</li>
<li> <p><code>date</code> Date. Timestamp information. Weekly format.
</p>
</li>
<li> <p><code>value</code> Numeric. Value at the corresponding timestamp.
</p>
</li></ul>



<h3>Details</h3>

<p>This is a sample of 4 Weekly data sets from the M4 competition.
</p>


<h3>Source</h3>


<ul>
<li> <p><a href="https://mofc.unic.ac.cy/m4/">M4 Competition Website</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>m4_weekly

</code></pre>

<hr>
<h2 id='m4_yearly'>Sample of 4 Yearly Time Series Datasets from the M4 Competition</h2><span id='topic+m4_yearly'></span>

<h3>Description</h3>

<p>The fourth M Competition.
M4, started on 1 January 2018 and ended in 31 May 2018.
The competition included 100,000 time series datasets.
This dataset includes <strong>a sample of 4 yearly time series from the competition.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m4_yearly
</code></pre>


<h3>Format</h3>

<p>A tibble: 9,743 x 3
</p>

<ul>
<li> <p><code>id</code> Factor. Unique series identifier (4 total)
</p>
</li>
<li> <p><code>date</code> Date. Timestamp information. Yearly format.
</p>
</li>
<li> <p><code>value</code> Numeric. Value at the corresponding timestamp.
</p>
</li></ul>



<h3>Details</h3>

<p>This is a sample of 4 Yearly data sets from the M4 competition.
</p>


<h3>Source</h3>


<ul>
<li> <p><a href="https://mofc.unic.ac.cy/m4/">M4 Competition Website</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
m4_yearly

</code></pre>

<hr>
<h2 id='mutate_by_time'>Mutate (for Time Series Data)</h2><span id='topic+mutate_by_time'></span>

<h3>Description</h3>

<p><code>mutate_by_time()</code> is a time-based variant of the popular <code>dplyr::mutate()</code> function
that uses <code>.date_var</code> to specify a date or date-time column and <code>.by</code> to group the
calculation by groups like &quot;5 seconds&quot;, &quot;week&quot;, or &quot;3 months&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mutate_by_time(
  .data,
  .date_var,
  .by = "day",
  ...,
  .type = c("floor", "ceiling", "round")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mutate_by_time_+3A_.data">.data</code></td>
<td>
<p>A <code>tbl</code> object or <code>data.frame</code></p>
</td></tr>
<tr><td><code id="mutate_by_time_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing date or date-time values to summarize.
If missing, attempts to auto-detect date column.</p>
</td></tr>
<tr><td><code id="mutate_by_time_+3A_.by">.by</code></td>
<td>
<p>A time unit to summarise by.
Time units are collapsed using <code>lubridate::floor_date()</code> or <code>lubridate::ceiling_date()</code>.
</p>
<p>The value can be:
</p>

<ul>
<li> <p><code>second</code>
</p>
</li>
<li> <p><code>minute</code>
</p>
</li>
<li> <p><code>hour</code>
</p>
</li>
<li> <p><code>day</code>
</p>
</li>
<li> <p><code>week</code>
</p>
</li>
<li> <p><code>month</code>
</p>
</li>
<li> <p><code>bimonth</code>
</p>
</li>
<li> <p><code>quarter</code>
</p>
</li>
<li> <p><code>season</code>
</p>
</li>
<li> <p><code>halfyear</code>
</p>
</li>
<li> <p><code>year</code>
</p>
</li></ul>

<p>Arbitrary unique English abbreviations as in the <code>lubridate::period()</code> constructor are allowed.</p>
</td></tr>
<tr><td><code id="mutate_by_time_+3A_...">...</code></td>
<td>
<p>Name-value pairs.
The name gives the name of the column in the output.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, which will be recycled to the correct length.
</p>
</li>
<li><p> A vector the same length as the current group (or the whole data frame
if ungrouped).
</p>
</li>
<li> <p><code>NULL</code>, to remove the column.
</p>
</li>
<li><p> A data frame or tibble, to create multiple columns in the output.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mutate_by_time_+3A_.type">.type</code></td>
<td>
<p>One of &quot;floor&quot;, &quot;ceiling&quot;, or &quot;round. Defaults to &quot;floor&quot;. See <code>lubridate::round_date</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> or <code>data.frame</code>
</p>


<h3>See Also</h3>

<p>Time-Based dplyr functions:
</p>

<ul>
<li> <p><code><a href="#topic+summarise_by_time">summarise_by_time()</a></code> - Easily summarise using a date column.
</p>
</li>
<li> <p><code><a href="#topic+mutate_by_time">mutate_by_time()</a></code> - Simplifies applying mutations by time windows.
</p>
</li>
<li> <p><code><a href="#topic+pad_by_time">pad_by_time()</a></code> - Insert time series rows with regularly spaced timestamps
</p>
</li>
<li> <p><code><a href="#topic+filter_by_time">filter_by_time()</a></code> - Quickly filter using date ranges.
</p>
</li>
<li> <p><code><a href="#topic+filter_period">filter_period()</a></code> - Apply filtering expressions inside periods (windows)
</p>
</li>
<li> <p><code><a href="#topic+slice_period">slice_period()</a></code> - Apply slice inside periods (windows)
</p>
</li>
<li> <p><code><a href="#topic+condense_period">condense_period()</a></code> - Convert to a different periodicity
</p>
</li>
<li> <p><code><a href="#topic+between_time">between_time()</a></code> - Range detection for date or date-time sequences.
</p>
</li>
<li> <p><code><a href="#topic+slidify">slidify()</a></code> - Turn any function into a sliding (rolling) function
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Libraries
library(dplyr)

# First value in each month
m4_daily_first_by_month_tbl &lt;- m4_daily %&gt;%
    group_by(id) %&gt;%
    mutate_by_time(
        .date_var = date,
        .by       = "month", # Setup for monthly aggregation
        # mutate recycles a single value
        first_value_by_month  = first(value)
    )
m4_daily_first_by_month_tbl

# Visualize Time Series vs 1st Value Each Month
m4_daily_first_by_month_tbl %&gt;%
    tidyr::pivot_longer(value:first_value_by_month) %&gt;%
    plot_time_series(date, value, name,
                     .facet_scale = "free", .facet_ncol = 2,
                     .smooth = FALSE, .interactive = FALSE)

</code></pre>

<hr>
<h2 id='normalize_vec'>Normalize to Range (0, 1)</h2><span id='topic+normalize_vec'></span><span id='topic+normalize_inv_vec'></span>

<h3>Description</h3>

<p>Normalization is commonly used to center and scale numeric features to prevent one from
dominating in algorithms that require data to be on the same scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_vec(x, min = NULL, max = NULL, silent = FALSE)

normalize_inv_vec(x, min, max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_vec_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="normalize_vec_+3A_min">min</code></td>
<td>
<p>The population min value in the normalization process.</p>
</td></tr>
<tr><td><code id="normalize_vec_+3A_max">max</code></td>
<td>
<p>The population max value in the normalization process.</p>
</td></tr>
<tr><td><code id="normalize_vec_+3A_silent">silent</code></td>
<td>
<p>Whether or not to report the automated <code>min</code> and <code>max</code> parameters as a message.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Standardization vs Normalization</strong>
</p>

<ul>
<li> <p><strong>Standardization</strong> refers to a transformation that reduces the range to
mean 0, standard deviation 1
</p>
</li>
<li> <p><strong>Normalization</strong> refers to a transformation that reduces the min-max range: (0, 1)
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>numeric</code> vector with the transformation applied.
</p>


<h3>See Also</h3>


<ul>
<li><p> Normalization/Standardization: <code><a href="#topic+standardize_vec">standardize_vec()</a></code>, <code><a href="#topic+normalize_vec">normalize_vec()</a></code>
</p>
</li>
<li><p> Box Cox Transformation: <code><a href="#topic+box_cox_vec">box_cox_vec()</a></code>
</p>
</li>
<li><p> Lag Transformation: <code><a href="#topic+lag_vec">lag_vec()</a></code>
</p>
</li>
<li><p> Differencing Transformation: <code><a href="#topic+diff_vec">diff_vec()</a></code>
</p>
</li>
<li><p> Rolling Window Transformation: <code><a href="#topic+slidify_vec">slidify_vec()</a></code>
</p>
</li>
<li><p> Loess Smoothing Transformation: <code><a href="#topic+smooth_vec">smooth_vec()</a></code>
</p>
</li>
<li><p> Fourier Series: <code><a href="#topic+fourier_vec">fourier_vec()</a></code>
</p>
</li>
<li><p> Missing Value Imputation for Time Series: <code><a href="#topic+ts_impute_vec">ts_impute_vec()</a></code>, <code><a href="#topic+ts_clean_vec">ts_clean_vec()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

d10_daily &lt;- m4_daily %&gt;% dplyr::filter(id == "D10")

# --- VECTOR ----

value_norm &lt;- normalize_vec(d10_daily$value)
value      &lt;- normalize_inv_vec(value_norm,
                                min = 1781.6,
                                max = 2649.3)

# --- MUTATE ----

m4_daily %&gt;%
    group_by(id) %&gt;%
    mutate(value_norm = normalize_vec(value))

</code></pre>

<hr>
<h2 id='pad_by_time'>Insert time series rows with regularly spaced timestamps</h2><span id='topic+pad_by_time'></span>

<h3>Description</h3>

<p>The easiest way to fill in missing timestamps or convert to a more
granular period (e.g. quarter to month). Wraps the <code>padr::pad()</code> function
for padding tibbles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pad_by_time(
  .data,
  .date_var,
  .by = "auto",
  .pad_value = NA,
  .fill_na_direction = c("none", "down", "up", "downup", "updown"),
  .start_date = NULL,
  .end_date = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pad_by_time_+3A_.data">.data</code></td>
<td>
<p>A tibble with a time-based column.</p>
</td></tr>
<tr><td><code id="pad_by_time_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing date or date-time values to pad</p>
</td></tr>
<tr><td><code id="pad_by_time_+3A_.by">.by</code></td>
<td>
<p>Either &quot;auto&quot;, a time-based frequency like &quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, etc,
or a time expression like &quot;5 min&quot;, or &quot;7 days&quot;. See Details.</p>
</td></tr>
<tr><td><code id="pad_by_time_+3A_.pad_value">.pad_value</code></td>
<td>
<p>Fills in padded values. Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="pad_by_time_+3A_.fill_na_direction">.fill_na_direction</code></td>
<td>
<p>Users can provide an <code>NA</code> fill strategy using <code>tidyr::fill()</code>.
Possible values: <code>'none'</code>, <code>'down'</code>, <code>'up'</code>, <code>'downup'</code>, <code>'updown'</code>. Default: <code>'none'</code></p>
</td></tr>
<tr><td><code id="pad_by_time_+3A_.start_date">.start_date</code></td>
<td>
<p>Specifies the start of the padded series.
If NULL it will use the lowest value of the input variable.</p>
</td></tr>
<tr><td><code id="pad_by_time_+3A_.end_date">.end_date</code></td>
<td>
<p>Specifies the end of the padded series.
If NULL it will use the highest value of the input variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Padding Missing Observations</strong>
</p>
<p>The most common use case for <code>pad_by_time()</code> is to add rows where timestamps
are missing. This could be from sales data that have missing values on weekends and holidays.
Or it could be high frequency data where observations are irregularly spaced and should be
reset to a regular frequency.
</p>
<p><strong>Going from Low to High Frequency</strong>
</p>
<p>The second use case is going from a low frequency (e.g. day) to high frequency (e.g. hour).
This is possible by supplying a higher frequency to <code>pad_by_time()</code>.
</p>
<p><strong>Interval, .by</strong>
</p>
<p>Padding can be applied in the following ways:
</p>

<ul>
<li> <p><code>.by = "auto"</code> - <code>pad_by_time()</code> will detect the time-stamp frequency and apply padding.
</p>
</li>
<li><p> The eight intervals in are: year, quarter, month, week, day, hour, min, and sec.
</p>
</li>
<li><p> Intervals like 5 minutes, 6 hours, 10 days are possible.
</p>
</li></ul>

<p><strong>Pad Value, .pad_value</strong>
</p>
<p>A pad value can be supplied that fills in missing numeric data. Note that this is only applied to numeric columns.
</p>
<p><strong>Fill NA Direction, .fill_na_directions</strong>
</p>
<p>Uses <code>tidyr::fill()</code> to fill missing observations using a fill strategy.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> or <code>data.frame</code> with rows containing missing timestamps added.
</p>


<h3>References</h3>


<ul>
<li><p> This function wraps the <code>padr::pad()</code> function developed by Edwin Thoen.
</p>
</li></ul>



<h3>See Also</h3>

<p>Imputation:
</p>

<ul>
<li> <p><code><a href="#topic+ts_impute_vec">ts_impute_vec()</a></code> - Impute missing values for time series.
</p>
</li></ul>

<p>Time-Based dplyr functions:
</p>

<ul>
<li> <p><code><a href="#topic+summarise_by_time">summarise_by_time()</a></code> - Easily summarise using a date column.
</p>
</li>
<li> <p><code><a href="#topic+mutate_by_time">mutate_by_time()</a></code> - Simplifies applying mutations by time windows.
</p>
</li>
<li> <p><code><a href="#topic+pad_by_time">pad_by_time()</a></code> - Insert time series rows with regularly spaced timestamps
</p>
</li>
<li> <p><code><a href="#topic+filter_by_time">filter_by_time()</a></code> - Quickly filter using date ranges.
</p>
</li>
<li> <p><code><a href="#topic+filter_period">filter_period()</a></code> - Apply filtering expressions inside periods (windows)
</p>
</li>
<li> <p><code><a href="#topic+slice_period">slice_period()</a></code> - Apply slice inside periods (windows)
</p>
</li>
<li> <p><code><a href="#topic+condense_period">condense_period()</a></code> - Convert to a different periodicity
</p>
</li>
<li> <p><code><a href="#topic+between_time">between_time()</a></code> - Range detection for date or date-time sequences.
</p>
</li>
<li> <p><code><a href="#topic+slidify">slidify()</a></code> - Turn any function into a sliding (rolling) function
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Create a quarterly series with 1 missing value
missing_data_tbl &lt;- tibble::tibble(
    date = tk_make_timeseries("2014-01-01", "2015-01-01", by = "quarter"),
    value = 1:5
) %&gt;%
    slice(-4) # Lose the 4th quarter on purpose
missing_data_tbl


# Detects missing quarter, and pads the missing regularly spaced quarter with NA
missing_data_tbl %&gt;% pad_by_time(date, .by = "quarter")

# Can specify a shorter period. This fills monthly.
missing_data_tbl %&gt;% pad_by_time(date, .by = "month")

# Can let pad_by_time() auto-detect date and period
missing_data_tbl %&gt;% pad_by_time()

# Can specify a .pad_value
missing_data_tbl %&gt;% pad_by_time(date, .by = "quarter", .pad_value = 0)

# Can then impute missing values
missing_data_tbl %&gt;%
    pad_by_time(date, .by = "quarter") %&gt;%
    mutate(value = ts_impute_vec(value, period = 1))

# Can specify a custom .start_date and .end_date
missing_data_tbl %&gt;%
   pad_by_time(date, .by = "quarter", .start_date = "2013", .end_date = "2015-07-01")

# Can specify a tidyr::fill() direction
missing_data_tbl %&gt;%
   pad_by_time(date, .by = "quarter",
               .fill_na_direction = "downup",
               .start_date = "2013", .end_date = "2015-07-01")

# --- GROUPS ----

# Apply standard NA padding to groups
FANG %&gt;%
    group_by(symbol) %&gt;%
    pad_by_time(.by = "day")

# Apply constant pad value
FANG %&gt;%
    group_by(symbol) %&gt;%
    pad_by_time(.by = "day", .pad_value = 0)

# Apply filled padding to groups
FANG %&gt;%
    group_by(symbol) %&gt;%
    pad_by_time(.by = "day", .fill_na_direction = "down")

</code></pre>

<hr>
<h2 id='parse_date2'>Fast, flexible date and datetime parsing</h2><span id='topic+parse_date2'></span><span id='topic+parse_datetime2'></span>

<h3>Description</h3>

<p>Significantly faster time series parsing than <code>readr::parse_date</code>, <code>readr::parse_datetime</code>,
<code>lubridate::as_date()</code>, and <code>lubridate::as_datetime()</code>. Uses <code>anytime</code> package, which relies on
<code>Boost.Date_Time</code> C++ library for date/datetime parsing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parse_date2(x, ..., silent = FALSE)

parse_datetime2(x, tz = "UTC", tz_shift = FALSE, ..., silent = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parse_date2_+3A_x">x</code></td>
<td>
<p>A character vector</p>
</td></tr>
<tr><td><code id="parse_date2_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="anytime.html#topic+anytime">anytime()</a></code> and <code><a href="anytime.html#topic+anydate">anydate()</a></code></p>
</td></tr>
<tr><td><code id="parse_date2_+3A_silent">silent</code></td>
<td>
<p>If <code>TRUE</code>, warns the user of parsing failures.</p>
</td></tr>
<tr><td><code id="parse_date2_+3A_tz">tz</code></td>
<td>
<p>Datetime only. A timezone (see <code>OlsenNames()</code>).</p>
</td></tr>
<tr><td><code id="parse_date2_+3A_tz_shift">tz_shift</code></td>
<td>
<p>Datetime only. If FALSE, forces the datetime into the time zone.
If TRUE, offsets the datetime from UTC to the new time zone.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Parsing Formats</strong>
</p>

<ul>
<li><p> Date Formats: Must follow a Year, Month, Day sequence.
(e.g. <code>parse_date2("2011 June")</code> is OK, <code>parse_date2("June 2011")</code> is NOT OK).
</p>
</li>
<li><p> Date Time Formats: Must follow a YMD HMS sequence.
</p>
</li></ul>

<p>Refer to <code>lubridate::mdy()</code> for Month, Day, Year and additional formats.
</p>
<p><strong>Time zones (Datetime)</strong>
</p>
<p>Time zones are handled in a similar way to <code>lubridate::as_datetime()</code> in that time zones
are forced rather than shifted. This is a key difference between <code>anytime::anytime()</code>, which
shifts datetimes to the specified timezone by default.
</p>


<h3>Value</h3>

<p>Returns a <code>date</code> or <code>datatime</code> vector from the transformation applied to character timestamp vector.
</p>


<h3>References</h3>


<ul>
<li><p> This function wraps the <code>anytime::anytime()</code> and <code>anytime::anydate()</code> functions developed by Dirk Eddelbuettel.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
# Fast date parsing
parse_date2("2011")
parse_date2("2011 June 3rd")

# Fast datetime parsing
parse_datetime2("2011")
parse_datetime2("2011 Jan 1 12:35:21")

# Time Zones (datetime only)
parse_datetime2("2011 Jan 1 12:35:21", tz = "Europe/London")

</code></pre>

<hr>
<h2 id='plot_acf_diagnostics'>Visualize the ACF, PACF, and CCFs for One or More Time Series</h2><span id='topic+plot_acf_diagnostics'></span>

<h3>Description</h3>

<p>Returns the <strong>ACF and PACF of a target</strong> and
optionally <strong>CCF's of one or more lagged predictors</strong> in interactive <code>plotly</code> plots. Scales
to multiple time series with <code>group_by()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_acf_diagnostics(
  .data,
  .date_var,
  .value,
  .ccf_vars = NULL,
  .lags = 1000,
  .show_ccf_vars_only = FALSE,
  .show_white_noise_bars = TRUE,
  .facet_ncol = 1,
  .facet_scales = "fixed",
  .line_color = "#2c3e50",
  .line_size = 0.5,
  .line_alpha = 1,
  .point_color = "#2c3e50",
  .point_size = 1,
  .point_alpha = 1,
  .x_intercept = NULL,
  .x_intercept_color = "#E31A1C",
  .hline_color = "#2c3e50",
  .white_noise_line_type = 2,
  .white_noise_line_color = "#A6CEE3",
  .title = "Lag Diagnostics",
  .x_lab = "Lag",
  .y_lab = "Correlation",
  .interactive = TRUE,
  .plotly_slider = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_acf_diagnostics_+3A_.data">.data</code></td>
<td>
<p>A data frame or tibble with numeric features (values) in descending
chronological order</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing either date or date-time values</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.value">.value</code></td>
<td>
<p>A numeric column with a value to have ACF and PACF calculations
performed.</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.ccf_vars">.ccf_vars</code></td>
<td>
<p>Additional features to perform Lag Cross Correlations (CCFs)
versus the <code>.value</code>. Useful for evaluating external lagged regressors.</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.lags">.lags</code></td>
<td>
<p>A sequence of one or more lags to evaluate.</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.show_ccf_vars_only">.show_ccf_vars_only</code></td>
<td>
<p>Hides the ACF and PACF plots so you can focus on only CCFs.</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.show_white_noise_bars">.show_white_noise_bars</code></td>
<td>
<p>Shows the white noise significance bounds.</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.facet_ncol">.facet_ncol</code></td>
<td>
<p>Facets: Number of facet columns. Has no effect if using <code>grouped_df</code>.</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.facet_scales">.facet_scales</code></td>
<td>
<p>Facets: Options include &quot;fixed&quot;, &quot;free&quot;, &quot;free_y&quot;, &quot;free_x&quot;</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.line_color">.line_color</code></td>
<td>
<p>Line color. Use keyword: &quot;scale_color&quot; to change the color by the facet.</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.line_size">.line_size</code></td>
<td>
<p>Line size (linewidth)</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.line_alpha">.line_alpha</code></td>
<td>
<p>Line opacity. Adjust the transparency of the line. Range: (0, 1)</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.point_color">.point_color</code></td>
<td>
<p>Point color. Use keyword: &quot;scale_color&quot; to change the color by the facet.</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.point_size">.point_size</code></td>
<td>
<p>Point size</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.point_alpha">.point_alpha</code></td>
<td>
<p>Opacity. Adjust the transparency of the points. Range: (0, 1)</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.x_intercept">.x_intercept</code></td>
<td>
<p>Numeric lag. Adds a vertical line.</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.x_intercept_color">.x_intercept_color</code></td>
<td>
<p>Color for the x-intercept line.</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.hline_color">.hline_color</code></td>
<td>
<p>Color for the y-intercept = 0 line.</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.white_noise_line_type">.white_noise_line_type</code></td>
<td>
<p>Line type for white noise bars. Set to 2 for &quot;dashed&quot; by default.</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.white_noise_line_color">.white_noise_line_color</code></td>
<td>
<p>Line color for white noise bars.
Set to <code>tidyquant::palette_light()</code> &quot;steel blue&quot; by default.</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.title">.title</code></td>
<td>
<p>Title for the plot</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.x_lab">.x_lab</code></td>
<td>
<p>X-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.y_lab">.y_lab</code></td>
<td>
<p>Y-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.interactive">.interactive</code></td>
<td>
<p>Returns either a static (<code>ggplot2</code>) visualization or an interactive (<code>plotly</code>) visualization</p>
</td></tr>
<tr><td><code id="plot_acf_diagnostics_+3A_.plotly_slider">.plotly_slider</code></td>
<td>
<p>If TRUE, returns a plotly x-axis range slider.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Simplified ACF, PACF, &amp; CCF</strong>
</p>
<p>We are often interested in all 3 of these functions. Why not get all 3+ at once?
Now you can.
</p>

<ul>
<li> <p><strong>ACF</strong> - Autocorrelation between a target variable and lagged versions of itself
</p>
</li>
<li> <p><strong>PACF</strong> - Partial Autocorrelation removes the dependence of lags on
other lags highlighting key seasonalities.
</p>
</li>
<li> <p><strong>CCF</strong> - Shows how lagged predictors can be used for prediction of a target
variable.
</p>
</li></ul>

<p><strong>Lag Specification</strong>
</p>
<p>Lags (<code>.lags</code>) can either be specified as:
</p>

<ul>
<li><p> A time-based phrase indicating a duraction (e.g. <code style="white-space: pre;">&#8288;2 months&#8288;</code>)
</p>
</li>
<li><p> A maximum lag (e.g. <code>.lags = 28</code>)
</p>
</li>
<li><p> A sequence of lags (e.g. <code>.lags = 7:28</code>)
</p>
</li></ul>

<p><strong>Scales to Multiple Time Series with Groups</strong>
</p>
<p>The <code>plot_acf_diagnostics()</code> works with <code>grouped_df</code>'s, meaning you can
group your time series by one or more categorical columns with <code>dplyr::group_by()</code>
and then apply <code>plot_acf_diagnostics()</code> to return group-wise lag diagnostics.
</p>
<p><strong>Special Note on Groups</strong>
</p>
<p>Unlike other plotting utilities, the <code>.facet_vars</code> arguments is NOT included.
Use <code>dplyr::group_by()</code> for processing multiple time series groups.
</p>
<p><strong>Calculating the White Noise Significance Bars</strong>
</p>
<p>The formula for the significance bars is <code>+2/sqrt(T)</code> and <code>-2/sqrt(T)</code> where <code>T</code> is the length of the
time series. For a white noise time series, 95% of the data points should fall
within this range. Those that don't may be significant autocorrelations.
</p>


<h3>Value</h3>

<p>A static <code>ggplot2</code> plot or an interactive <code>plotly</code> plot
</p>


<h3>See Also</h3>


<ul>
<li> <p><strong>Visualizing ACF, PACF, &amp; CCF:</strong> <code><a href="#topic+plot_acf_diagnostics">plot_acf_diagnostics()</a></code>
</p>
</li>
<li> <p><strong>Visualizing Seasonality:</strong> <code><a href="#topic+plot_seasonal_diagnostics">plot_seasonal_diagnostics()</a></code>
</p>
</li>
<li> <p><strong>Visualizing Time Series:</strong> <code><a href="#topic+plot_time_series">plot_time_series()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)


# Apply Transformations
# - Differencing transformation to identify ARIMA &amp; SARIMA Orders
m4_hourly %&gt;%
    group_by(id) %&gt;%
    plot_acf_diagnostics(
        date, value,               # ACF &amp; PACF
        .lags = "7 days",          # 7-Days of hourly lags
        .interactive = FALSE
    )

# Apply Transformations
# - Differencing transformation to identify ARIMA &amp; SARIMA Orders
m4_hourly %&gt;%
    group_by(id) %&gt;%
    plot_acf_diagnostics(
        date,
        diff_vec(value, lag = 1), # Difference the value column
        .lags        = 0:(24*7),   # 7-Days of hourly lags
        .interactive = FALSE
    ) +
    ggtitle("ACF Diagnostics",  subtitle = "1st Difference")

# CCFs Too!
walmart_sales_weekly %&gt;%
    select(id, Date, Weekly_Sales, Temperature, Fuel_Price) %&gt;%
    group_by(id) %&gt;%
    plot_acf_diagnostics(
        Date, Weekly_Sales,                        # ACF &amp; PACF
        .ccf_vars    = c(Temperature, Fuel_Price), # CCFs
        .lags        = "3 months", # 3 months of weekly lags
        .interactive = FALSE
    )

</code></pre>

<hr>
<h2 id='plot_anomalies'>Visualize Anomalies for One or More Time Series</h2><span id='topic+plot_anomalies'></span><span id='topic+plot_anomalies_decomp'></span><span id='topic+plot_anomalies_cleaned'></span>

<h3>Description</h3>

<p><code>plot_anomalies()</code> is an interactive and scalable function for visualizing anomalies in time series data.
Plots are available in interactive <code>plotly</code> (default) and static <code>ggplot2</code> format.
</p>
<p><code>plot_anomalies_decomp()</code>: Takes in data from the <code>anomalize()</code>
function, and returns a plot of the anomaly decomposition. Useful for interpeting
how the <code>anomalize()</code> function is determining outliers from &quot;remainder&quot;.
</p>
<p><code>plot_anomalies_cleaned()</code> helps users visualize the before/after of
cleaning anomalies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_anomalies(
  .data,
  .date_var,
  .facet_vars = NULL,
  .facet_ncol = 1,
  .facet_nrow = 1,
  .facet_scales = "free",
  .facet_dir = "h",
  .facet_collapse = FALSE,
  .facet_collapse_sep = " ",
  .facet_strip_remove = FALSE,
  .line_color = "#2c3e50",
  .line_size = 0.5,
  .line_type = 1,
  .line_alpha = 1,
  .anom_color = "#e31a1c",
  .anom_alpha = 1,
  .anom_size = 1.5,
  .ribbon_fill = "grey20",
  .ribbon_alpha = 0.2,
  .legend_show = TRUE,
  .title = "Anomaly Plot",
  .x_lab = "",
  .y_lab = "",
  .color_lab = "Anomaly",
  .interactive = TRUE,
  .trelliscope = FALSE,
  .trelliscope_params = list()
)

plot_anomalies_decomp(
  .data,
  .date_var,
  .facet_vars = NULL,
  .facet_scales = "free",
  .line_color = "#2c3e50",
  .line_size = 0.5,
  .line_type = 1,
  .line_alpha = 1,
  .title = "Anomaly Decomposition Plot",
  .x_lab = "",
  .y_lab = "",
  .interactive = TRUE
)

plot_anomalies_cleaned(
  .data,
  .date_var,
  .facet_vars = NULL,
  .facet_ncol = 1,
  .facet_nrow = 1,
  .facet_scales = "free",
  .facet_dir = "h",
  .facet_collapse = FALSE,
  .facet_collapse_sep = " ",
  .facet_strip_remove = FALSE,
  .line_color = "#2c3e50",
  .line_size = 0.5,
  .line_type = 1,
  .line_alpha = 1,
  .cleaned_line_color = "#e31a1c",
  .cleaned_line_size = 0.5,
  .cleaned_line_type = 1,
  .cleaned_line_alpha = 1,
  .legend_show = TRUE,
  .title = "Anomalies Cleaned Plot",
  .x_lab = "",
  .y_lab = "",
  .color_lab = "Legend",
  .interactive = TRUE,
  .trelliscope = FALSE,
  .trelliscope_params = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_anomalies_+3A_.data">.data</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code> that has been anomalized by <code>anomalize()</code></p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing either date or date-time values</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.facet_vars">.facet_vars</code></td>
<td>
<p>One or more grouping columns that broken out into <code>ggplot2</code> facets.
These can be selected using <code>tidyselect()</code> helpers (e.g <code>contains()</code>).</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.facet_ncol">.facet_ncol</code></td>
<td>
<p>Number of facet columns.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.facet_nrow">.facet_nrow</code></td>
<td>
<p>Number of facet rows (only used for <code>.trelliscope = TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.facet_scales">.facet_scales</code></td>
<td>
<p>Control facet x &amp; y-axis ranges. Options include &quot;fixed&quot;, &quot;free&quot;, &quot;free_y&quot;, &quot;free_x&quot;</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.facet_dir">.facet_dir</code></td>
<td>
<p>The direction of faceting (&quot;h&quot; for horizontal, &quot;v&quot; for vertical). Default is &quot;h&quot;.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.facet_collapse">.facet_collapse</code></td>
<td>
<p>Multiple facets included on one facet strip instead of
multiple facet strips.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.facet_collapse_sep">.facet_collapse_sep</code></td>
<td>
<p>The separator used for collapsing facets.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.facet_strip_remove">.facet_strip_remove</code></td>
<td>
<p>Whether or not to remove the strip and text label for each facet.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.line_color">.line_color</code></td>
<td>
<p>Line color.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.line_size">.line_size</code></td>
<td>
<p>Line size.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.line_type">.line_type</code></td>
<td>
<p>Line type.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.line_alpha">.line_alpha</code></td>
<td>
<p>Line alpha (opacity). Range: (0, 1).</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.anom_color">.anom_color</code></td>
<td>
<p>Color for the anomaly dots</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.anom_alpha">.anom_alpha</code></td>
<td>
<p>Opacity for the anomaly dots. Range: (0, 1).</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.anom_size">.anom_size</code></td>
<td>
<p>Size for the anomaly dots</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.ribbon_fill">.ribbon_fill</code></td>
<td>
<p>Fill color for the acceptable range</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.ribbon_alpha">.ribbon_alpha</code></td>
<td>
<p>Fill opacity for the acceptable range. Range: (0, 1).</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.legend_show">.legend_show</code></td>
<td>
<p>Toggles on/off the Legend</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.title">.title</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.x_lab">.x_lab</code></td>
<td>
<p>Plot x-axis label</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.y_lab">.y_lab</code></td>
<td>
<p>Plot y-axis label</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.color_lab">.color_lab</code></td>
<td>
<p>Plot label for the color legend</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.interactive">.interactive</code></td>
<td>
<p>If TRUE, returns a <code>plotly</code> interactive plot.
If FALSE, returns a static <code>ggplot2</code> plot.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.trelliscope">.trelliscope</code></td>
<td>
<p>Returns either a normal plot or a trelliscopejs plot (great for many time series)
Must have <code>trelliscopejs</code> installed.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.trelliscope_params">.trelliscope_params</code></td>
<td>
<p>Pass parameters to the <code>trelliscopejs::facet_trelliscope()</code> function as a <code>list()</code>.
The only parameters that cannot be passed are:
</p>

<ul>
<li> <p><code>ncol</code>: use <code>.facet_ncol</code>
</p>
</li>
<li> <p><code>nrow</code>: use <code>.facet_nrow</code>
</p>
</li>
<li> <p><code>scales</code>: use <code>facet_scales</code>
</p>
</li>
<li> <p><code>as_plotly</code>: use <code>.interactive</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.cleaned_line_color">.cleaned_line_color</code></td>
<td>
<p>Line color.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.cleaned_line_size">.cleaned_line_size</code></td>
<td>
<p>Line size.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.cleaned_line_type">.cleaned_line_type</code></td>
<td>
<p>Line type.</p>
</td></tr>
<tr><td><code id="plot_anomalies_+3A_.cleaned_line_alpha">.cleaned_line_alpha</code></td>
<td>
<p>Line alpha (opacity). Range: (0, 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>plotly</code> or <code>ggplot2</code> visualization
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Plot Anomalies
library(dplyr)

walmart_sales_weekly %&gt;%
    filter(id %in% c("1_1", "1_3")) %&gt;%
    group_by(id) %&gt;%
    anomalize(Date, Weekly_Sales) %&gt;%
    plot_anomalies(Date, .facet_ncol = 2, .ribbon_alpha = 0.25, .interactive = FALSE)

# Plot Anomalies Decomposition
library(dplyr)

walmart_sales_weekly %&gt;%
    filter(id %in% c("1_1", "1_3")) %&gt;%
    group_by(id) %&gt;%
    anomalize(Date, Weekly_Sales, .message = FALSE) %&gt;%
    plot_anomalies_decomp(Date, .interactive = FALSE)

# Plot Anomalies Cleaned
library(dplyr)

walmart_sales_weekly %&gt;%
    filter(id %in% c("1_1", "1_3")) %&gt;%
    group_by(id) %&gt;%
    anomalize(Date, Weekly_Sales, .message = FALSE) %&gt;%
    plot_anomalies_cleaned(Date, .facet_ncol = 2, .interactive = FALSE)

</code></pre>

<hr>
<h2 id='plot_anomaly_diagnostics'>Visualize Anomalies for One or More Time Series</h2><span id='topic+plot_anomaly_diagnostics'></span>

<h3>Description</h3>

<p>An interactive and scalable function for visualizing anomalies in time series data.
Plots are available in interactive <code>plotly</code> (default) and static <code>ggplot2</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_anomaly_diagnostics(
  .data,
  .date_var,
  .value,
  .facet_vars = NULL,
  .frequency = "auto",
  .trend = "auto",
  .alpha = 0.05,
  .max_anomalies = 0.2,
  .message = TRUE,
  .facet_ncol = 1,
  .facet_nrow = 1,
  .facet_scales = "free",
  .facet_dir = "h",
  .facet_collapse = FALSE,
  .facet_collapse_sep = " ",
  .facet_strip_remove = FALSE,
  .line_color = "#2c3e50",
  .line_size = 0.5,
  .line_type = 1,
  .line_alpha = 1,
  .anom_color = "#e31a1c",
  .anom_alpha = 1,
  .anom_size = 1.5,
  .ribbon_fill = "grey20",
  .ribbon_alpha = 0.2,
  .legend_show = TRUE,
  .title = "Anomaly Diagnostics",
  .x_lab = "",
  .y_lab = "",
  .color_lab = "Anomaly",
  .interactive = TRUE,
  .trelliscope = FALSE,
  .trelliscope_params = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.data">.data</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code> with a time-based column</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing either date or date-time values</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.value">.value</code></td>
<td>
<p>A column containing numeric values</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.facet_vars">.facet_vars</code></td>
<td>
<p>One or more grouping columns that broken out into <code>ggplot2</code> facets.
These can be selected using <code>tidyselect()</code> helpers (e.g <code>contains()</code>).</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.frequency">.frequency</code></td>
<td>
<p>Controls the seasonal adjustment (removal of seasonality).
Input can be either &quot;auto&quot;, a time-based definition (e.g. &quot;2 weeks&quot;),
or a numeric number of observations per frequency (e.g. 10).
Refer to <code><a href="#topic+tk_get_frequency">tk_get_frequency()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.trend">.trend</code></td>
<td>
<p>Controls the trend component.
For STL, trend controls the sensitivity of the LOESS smoother, which is used to remove the remainder.
Refer to <code><a href="#topic+tk_get_trend">tk_get_trend()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.alpha">.alpha</code></td>
<td>
<p>Controls the width of the &quot;normal&quot; range. Lower values are more conservative
while higher values are less prone to incorrectly classifying &quot;normal&quot; observations.</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.max_anomalies">.max_anomalies</code></td>
<td>
<p>The maximum percent of anomalies permitted to be identified.</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.message">.message</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, will output information related to automatic frequency
and trend selection (if applicable).</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.facet_ncol">.facet_ncol</code></td>
<td>
<p>Number of facet columns.</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.facet_nrow">.facet_nrow</code></td>
<td>
<p>Number of facet rows (only used for <code>.trelliscope = TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.facet_scales">.facet_scales</code></td>
<td>
<p>Control facet x &amp; y-axis ranges. Options include &quot;fixed&quot;, &quot;free&quot;, &quot;free_y&quot;, &quot;free_x&quot;</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.facet_dir">.facet_dir</code></td>
<td>
<p>The direction of faceting (&quot;h&quot; for horizontal, &quot;v&quot; for vertical). Default is &quot;h&quot;.</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.facet_collapse">.facet_collapse</code></td>
<td>
<p>Multiple facets included on one facet strip instead of
multiple facet strips.</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.facet_collapse_sep">.facet_collapse_sep</code></td>
<td>
<p>The separator used for collapsing facets.</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.facet_strip_remove">.facet_strip_remove</code></td>
<td>
<p>Whether or not to remove the strip and text label for each facet.</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.line_color">.line_color</code></td>
<td>
<p>Line color.</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.line_size">.line_size</code></td>
<td>
<p>Line size.</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.line_type">.line_type</code></td>
<td>
<p>Line type.</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.line_alpha">.line_alpha</code></td>
<td>
<p>Line alpha (opacity). Range: (0, 1).</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.anom_color">.anom_color</code></td>
<td>
<p>Color for the anomaly dots</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.anom_alpha">.anom_alpha</code></td>
<td>
<p>Opacity for the anomaly dots. Range: (0, 1).</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.anom_size">.anom_size</code></td>
<td>
<p>Size for the anomaly dots</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.ribbon_fill">.ribbon_fill</code></td>
<td>
<p>Fill color for the acceptable range</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.ribbon_alpha">.ribbon_alpha</code></td>
<td>
<p>Fill opacity for the acceptable range. Range: (0, 1).</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.legend_show">.legend_show</code></td>
<td>
<p>Toggles on/off the Legend</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.title">.title</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.x_lab">.x_lab</code></td>
<td>
<p>Plot x-axis label</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.y_lab">.y_lab</code></td>
<td>
<p>Plot y-axis label</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.color_lab">.color_lab</code></td>
<td>
<p>Plot label for the color legend</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.interactive">.interactive</code></td>
<td>
<p>If TRUE, returns a <code>plotly</code> interactive plot.
If FALSE, returns a static <code>ggplot2</code> plot.</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.trelliscope">.trelliscope</code></td>
<td>
<p>Returns either a normal plot or a trelliscopejs plot (great for many time series)
Must have <code>trelliscopejs</code> installed.</p>
</td></tr>
<tr><td><code id="plot_anomaly_diagnostics_+3A_.trelliscope_params">.trelliscope_params</code></td>
<td>
<p>Pass parameters to the <code>trelliscopejs::facet_trelliscope()</code> function as a <code>list()</code>.
The only parameters that cannot be passed are:
</p>

<ul>
<li> <p><code>ncol</code>: use <code>.facet_ncol</code>
</p>
</li>
<li> <p><code>nrow</code>: use <code>.facet_nrow</code>
</p>
</li>
<li> <p><code>scales</code>: use <code>facet_scales</code>
</p>
</li>
<li> <p><code>as_plotly</code>: use <code>.interactive</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot_anomaly_diagnostics()</code> is a visualization wrapper for <code>tk_anomaly_diagnostics()</code>
group-wise anomaly detection, implements a 2-step process to
detect outliers in time series.
</p>
<p><strong>Step 1: Detrend &amp; Remove Seasonality using STL Decomposition</strong>
</p>
<p>The decomposition separates the &quot;season&quot; and &quot;trend&quot; components from the &quot;observed&quot; values
leaving the &quot;remainder&quot; for anomaly detection.
</p>
<p>The user can control two parameters: frequency and trend.
</p>

<ol>
<li> <p><code>.frequency</code>: Adjusts the &quot;season&quot; component that is removed from the &quot;observed&quot; values.
</p>
</li>
<li> <p><code>.trend</code>: Adjusts the trend window (t.window parameter from <code><a href="stats.html#topic+stl">stats::stl()</a></code> that is used.
</p>
</li></ol>

<p>The user may supply both <code>.frequency</code> and <code>.trend</code> as time-based durations (e.g. &quot;6 weeks&quot;) or
numeric values (e.g. 180) or &quot;auto&quot;, which predetermines the frequency and/or trend based on
the scale of the time series using the <code><a href="#topic+tk_time_scale_template">tk_time_scale_template()</a></code>.
</p>
<p><strong>Step 2: Anomaly Detection</strong>
</p>
<p>Once &quot;trend&quot; and &quot;season&quot; (seasonality) is removed, anomaly detection is performed on the &quot;remainder&quot;.
Anomalies are identified, and boundaries (recomposed_l1 and recomposed_l2) are determined.
</p>
<p>The Anomaly Detection Method uses an inner quartile range (IQR) of +/-25 the median.
</p>
<p><em>IQR Adjustment, alpha parameter</em>
</p>
<p>With the default <code>alpha = 0.05</code>, the limits are established by expanding
the 25/75 baseline by an IQR Factor of 3 (3X).
The <em>IQR Factor = 0.15 / alpha</em> (hence 3X with alpha = 0.05):
</p>

<ul>
<li><p> To increase the IQR Factor controlling the limits, decrease the alpha,
which makes it more difficult to be an outlier.
</p>
</li>
<li><p> Increase alpha to make it easier to be an outlier.
</p>
</li>
<li><p> The IQR outlier detection method is used in <code>forecast::tsoutliers()</code>.
</p>
</li>
<li><p> A similar outlier detection method is used by Twitter's <code>AnomalyDetection</code> package.
</p>
</li>
<li><p> Both Twitter and Forecast tsoutliers methods have been implemented in Business Science's <code>anomalize</code>
package.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>plotly</code> or <code>ggplot2</code> visualization
</p>


<h3>References</h3>


<ol>
<li><p> CLEVELAND, R. B., CLEVELAND, W. S., MCRAE, J. E., AND TERPENNING, I.
STL: A Seasonal-Trend Decomposition Procedure Based on Loess.
Journal of Official Statistics, Vol. 6, No. 1 (1990), pp. 3-73.
</p>
</li>
<li><p> Owen S. Vallis, Jordan Hochenbaum and Arun Kejariwal (2014).
A Novel Technique for Long-Term Anomaly Detection in the Cloud. Twitter Inc.
</p>
</li></ol>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+tk_anomaly_diagnostics">tk_anomaly_diagnostics()</a></code>: Group-wise anomaly detection
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

walmart_sales_weekly %&gt;%
    group_by(id) %&gt;%
    plot_anomaly_diagnostics(Date, Weekly_Sales,
                             .message = FALSE,
                             .facet_ncol = 3,
                             .ribbon_alpha = 0.25,
                             .interactive = FALSE)



</code></pre>

<hr>
<h2 id='plot_seasonal_diagnostics'>Visualize Multiple Seasonality Features for One or More Time Series</h2><span id='topic+plot_seasonal_diagnostics'></span>

<h3>Description</h3>

<p>An interactive and scalable function for visualizing time series seasonality.
Plots are available in interactive <code>plotly</code> (default) and static <code>ggplot2</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_seasonal_diagnostics(
  .data,
  .date_var,
  .value,
  .facet_vars = NULL,
  .feature_set = "auto",
  .geom = c("boxplot", "violin"),
  .geom_color = "#2c3e50",
  .geom_outlier_color = "#2c3e50",
  .title = "Seasonal Diagnostics",
  .x_lab = "",
  .y_lab = "",
  .interactive = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_seasonal_diagnostics_+3A_.data">.data</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code> with a time-based column</p>
</td></tr>
<tr><td><code id="plot_seasonal_diagnostics_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing either date or date-time values</p>
</td></tr>
<tr><td><code id="plot_seasonal_diagnostics_+3A_.value">.value</code></td>
<td>
<p>A column containing numeric values</p>
</td></tr>
<tr><td><code id="plot_seasonal_diagnostics_+3A_.facet_vars">.facet_vars</code></td>
<td>
<p>One or more grouping columns that broken out into <code>ggplot2</code> facets.
These can be selected using <code>tidyselect()</code> helpers (e.g <code>contains()</code>).</p>
</td></tr>
<tr><td><code id="plot_seasonal_diagnostics_+3A_.feature_set">.feature_set</code></td>
<td>
<p>One or multiple selections to analyze for seasonality. Choices include:
</p>

<ul>
<li><p> &quot;auto&quot; - Automatically selects features based on the time stamps and length of the series.
</p>
</li>
<li><p> &quot;second&quot; - Good for analyzing seasonality by second of each minute.
</p>
</li>
<li><p> &quot;minute&quot; - Good for analyzing seasonality by minute of the hour
</p>
</li>
<li><p> &quot;hour&quot; - Good for analyzing seasonality by hour of the day
</p>
</li>
<li><p> &quot;wday.lbl&quot; - Labeled weekdays. Good for analyzing seasonality by day of the week.
</p>
</li>
<li><p> &quot;week&quot; - Good for analyzing seasonality by week of the year.
</p>
</li>
<li><p> &quot;month.lbl&quot; - Labeled months. Good for analyzing seasonality by month of the year.
</p>
</li>
<li><p> &quot;quarter&quot; - Good for analyzing seasonality by quarter of the year
</p>
</li>
<li><p> &quot;year&quot; - Good for analyzing seasonality over multiple years.
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_seasonal_diagnostics_+3A_.geom">.geom</code></td>
<td>
<p>Either &quot;boxplot&quot; or &quot;violin&quot;</p>
</td></tr>
<tr><td><code id="plot_seasonal_diagnostics_+3A_.geom_color">.geom_color</code></td>
<td>
<p>Geometry color. Line color.
Use keyword: &quot;scale_color&quot; to change the color by the facet.</p>
</td></tr>
<tr><td><code id="plot_seasonal_diagnostics_+3A_.geom_outlier_color">.geom_outlier_color</code></td>
<td>
<p>Color used to highlight outliers.</p>
</td></tr>
<tr><td><code id="plot_seasonal_diagnostics_+3A_.title">.title</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="plot_seasonal_diagnostics_+3A_.x_lab">.x_lab</code></td>
<td>
<p>Plot x-axis label</p>
</td></tr>
<tr><td><code id="plot_seasonal_diagnostics_+3A_.y_lab">.y_lab</code></td>
<td>
<p>Plot y-axis label</p>
</td></tr>
<tr><td><code id="plot_seasonal_diagnostics_+3A_.interactive">.interactive</code></td>
<td>
<p>If TRUE, returns a <code>plotly</code> interactive plot.
If FALSE, returns a static <code>ggplot2</code> plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Automatic Feature Selection</strong>
</p>
<p>Internal calculations are performed to detect a sub-range of features to include
useing the following logic:
</p>

<ul>
<li><p> The <em>minimum</em> feature is selected based on the median difference between consecutive
timestamps
</p>
</li>
<li><p> The <em>maximum</em> feature is selected based on having 2 full periods.
</p>
</li></ul>

<p>Example: Hourly timestamp data that lasts more than 2 weeks will have the following features:
&quot;hour&quot;, &quot;wday.lbl&quot;, and &quot;week&quot;.
</p>
<p><strong>Scalable with Grouped Data Frames</strong>
</p>
<p>This function respects grouped <code>data.frame</code> and <code>tibbles</code> that were made with <code>dplyr::group_by()</code>.
</p>
<p>For grouped data, the automatic feature selection returned is a collection of all
features within the sub-groups. This means extra features are returned even though
they may be meaningless for some of the groups.
</p>
<p><strong>Transformations</strong>
</p>
<p>The <code>.value</code> parameter respects transformations (e.g. <code>.value = log(sales)</code>).
</p>


<h3>Value</h3>

<p>A <code>plotly</code> or <code>ggplot2</code> visualization
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

# ---- MULTIPLE FREQUENCY ----
# Taylor 30-minute dataset from forecast package
taylor_30_min

# Visualize series
taylor_30_min %&gt;%
    plot_time_series(date, value, .interactive = FALSE)

# Visualize seasonality
taylor_30_min %&gt;%
    plot_seasonal_diagnostics(date, value, .interactive = FALSE)

# ---- GROUPED EXAMPLES ----
# m4 hourly dataset
m4_hourly

# Visualize series
m4_hourly %&gt;%
    group_by(id) %&gt;%
    plot_time_series(date, value, .facet_scales = "free", .interactive = FALSE)

# Visualize seasonality
m4_hourly %&gt;%
    group_by(id) %&gt;%
    plot_seasonal_diagnostics(date, value, .interactive = FALSE)



</code></pre>

<hr>
<h2 id='plot_stl_diagnostics'>Visualize STL Decomposition Features for One or More Time Series</h2><span id='topic+plot_stl_diagnostics'></span>

<h3>Description</h3>

<p>An interactive and scalable function for visualizing time series STL Decomposition.
Plots are available in interactive <code>plotly</code> (default) and static <code>ggplot2</code> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_stl_diagnostics(
  .data,
  .date_var,
  .value,
  .facet_vars = NULL,
  .feature_set = c("observed", "season", "trend", "remainder", "seasadj"),
  .frequency = "auto",
  .trend = "auto",
  .message = TRUE,
  .facet_scales = "free",
  .line_color = "#2c3e50",
  .line_size = 0.5,
  .line_type = 1,
  .line_alpha = 1,
  .title = "STL Diagnostics",
  .x_lab = "",
  .y_lab = "",
  .interactive = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_stl_diagnostics_+3A_.data">.data</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code> with a time-based column</p>
</td></tr>
<tr><td><code id="plot_stl_diagnostics_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing either date or date-time values</p>
</td></tr>
<tr><td><code id="plot_stl_diagnostics_+3A_.value">.value</code></td>
<td>
<p>A column containing numeric values</p>
</td></tr>
<tr><td><code id="plot_stl_diagnostics_+3A_.facet_vars">.facet_vars</code></td>
<td>
<p>One or more grouping columns that broken out into <code>ggplot2</code> facets.
These can be selected using <code>tidyselect()</code> helpers (e.g <code>contains()</code>).</p>
</td></tr>
<tr><td><code id="plot_stl_diagnostics_+3A_.feature_set">.feature_set</code></td>
<td>
<p>The STL decompositions to visualize.
Select one or more of &quot;observed&quot;, &quot;season&quot;, &quot;trend&quot;, &quot;remainder&quot;, &quot;seasadj&quot;.</p>
</td></tr>
<tr><td><code id="plot_stl_diagnostics_+3A_.frequency">.frequency</code></td>
<td>
<p>Controls the seasonal adjustment (removal of seasonality).
Input can be either &quot;auto&quot;, a time-based definition (e.g. &quot;2 weeks&quot;),
or a numeric number of observations per frequency (e.g. 10).
Refer to <code><a href="#topic+tk_get_frequency">tk_get_frequency()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_stl_diagnostics_+3A_.trend">.trend</code></td>
<td>
<p>Controls the trend component.
For STL, trend controls the sensitivity of the lowess smoother, which is used to remove the remainder.</p>
</td></tr>
<tr><td><code id="plot_stl_diagnostics_+3A_.message">.message</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, will output information related to automatic frequency
and trend selection (if applicable).</p>
</td></tr>
<tr><td><code id="plot_stl_diagnostics_+3A_.facet_scales">.facet_scales</code></td>
<td>
<p>Control facet x &amp; y-axis ranges. Options include &quot;fixed&quot;, &quot;free&quot;, &quot;free_y&quot;, &quot;free_x&quot;</p>
</td></tr>
<tr><td><code id="plot_stl_diagnostics_+3A_.line_color">.line_color</code></td>
<td>
<p>Line color.</p>
</td></tr>
<tr><td><code id="plot_stl_diagnostics_+3A_.line_size">.line_size</code></td>
<td>
<p>Line size.</p>
</td></tr>
<tr><td><code id="plot_stl_diagnostics_+3A_.line_type">.line_type</code></td>
<td>
<p>Line type.</p>
</td></tr>
<tr><td><code id="plot_stl_diagnostics_+3A_.line_alpha">.line_alpha</code></td>
<td>
<p>Line alpha (opacity). Range: (0, 1).</p>
</td></tr>
<tr><td><code id="plot_stl_diagnostics_+3A_.title">.title</code></td>
<td>
<p>Plot title.</p>
</td></tr>
<tr><td><code id="plot_stl_diagnostics_+3A_.x_lab">.x_lab</code></td>
<td>
<p>Plot x-axis label</p>
</td></tr>
<tr><td><code id="plot_stl_diagnostics_+3A_.y_lab">.y_lab</code></td>
<td>
<p>Plot y-axis label</p>
</td></tr>
<tr><td><code id="plot_stl_diagnostics_+3A_.interactive">.interactive</code></td>
<td>
<p>If TRUE, returns a <code>plotly</code> interactive plot.
If FALSE, returns a static <code>ggplot2</code> plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plot_stl_diagnostics()</code> function generates a Seasonal-Trend-Loess decomposition.
The function is &quot;tidy&quot; in the sense that it works
on data frames and is designed to work with <code>dplyr</code> groups.
</p>
<p><strong>STL method</strong>:
</p>
<p>The STL method implements time series decomposition using
the underlying <code><a href="stats.html#topic+stl">stats::stl()</a></code>. The decomposition separates the
&quot;season&quot; and &quot;trend&quot; components from
the &quot;observed&quot; values leaving the &quot;remainder&quot;.
</p>
<p><strong>Frequency &amp; Trend Selection</strong>
</p>
<p>The user can control two parameters: <code>.frequency</code> and <code>.trend</code>.
</p>

<ol>
<li><p> The <code>.frequency</code> parameter adjusts the &quot;season&quot; component that is removed
from the &quot;observed&quot; values.
</p>
</li>
<li><p> The <code>.trend</code> parameter adjusts the
trend window (<code>t.window</code> parameter from <code>stl()</code>) that is used.
</p>
</li></ol>

<p>The user may supply both <code>.frequency</code>
and <code>.trend</code> as time-based durations (e.g. &quot;6 weeks&quot;) or numeric values
(e.g. 180) or &quot;auto&quot;, which automatically selects the frequency and/or trend
based on the scale of the time series.
</p>


<h3>Value</h3>

<p>A <code>plotly</code> or <code>ggplot2</code> visualization
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# ---- SINGLE TIME SERIES DECOMPOSITION ----
m4_hourly %&gt;%
    filter(id == "H10") %&gt;%
    plot_stl_diagnostics(
        date, value,
        # Set features to return, desired frequency and trend
        .feature_set = c("observed", "season", "trend", "remainder"),
        .frequency   = "24 hours",
        .trend       = "1 week",
        .interactive = FALSE)


# ---- GROUPS ----
m4_hourly %&gt;%
    group_by(id) %&gt;%
    plot_stl_diagnostics(
        date, value,
        .feature_set = c("observed", "season", "trend"),
        .interactive = FALSE)



</code></pre>

<hr>
<h2 id='plot_time_series'>Interactive Plotting for One or More Time Series</h2><span id='topic+plot_time_series'></span>

<h3>Description</h3>

<p>A workhorse time-series plotting function that generates interactive <code>plotly</code> plots,
consolidates 20+ lines of <code>ggplot2</code> code, and scales well to many time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_time_series(
  .data,
  .date_var,
  .value,
  .color_var = NULL,
  .facet_vars = NULL,
  .facet_ncol = 1,
  .facet_nrow = 1,
  .facet_scales = "free_y",
  .facet_dir = "h",
  .facet_collapse = FALSE,
  .facet_collapse_sep = " ",
  .facet_strip_remove = FALSE,
  .line_color = "#2c3e50",
  .line_size = 0.5,
  .line_type = 1,
  .line_alpha = 1,
  .y_intercept = NULL,
  .y_intercept_color = "#2c3e50",
  .x_intercept = NULL,
  .x_intercept_color = "#2c3e50",
  .smooth = TRUE,
  .smooth_period = "auto",
  .smooth_message = FALSE,
  .smooth_span = NULL,
  .smooth_degree = 2,
  .smooth_color = "#3366FF",
  .smooth_size = 1,
  .smooth_alpha = 1,
  .legend_show = TRUE,
  .title = "Time Series Plot",
  .x_lab = "",
  .y_lab = "",
  .color_lab = "Legend",
  .interactive = TRUE,
  .plotly_slider = FALSE,
  .trelliscope = FALSE,
  .trelliscope_params = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_time_series_+3A_.data">.data</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code> with a time-based column</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing either date or date-time values</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.value">.value</code></td>
<td>
<p>A column containing numeric values</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.color_var">.color_var</code></td>
<td>
<p>A categorical column that can be used to change the
line color</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.facet_vars">.facet_vars</code></td>
<td>
<p>One or more grouping columns that broken out into <code>ggplot2</code> facets.
These can be selected using <code>tidyselect()</code> helpers (e.g <code>contains()</code>).</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.facet_ncol">.facet_ncol</code></td>
<td>
<p>Number of facet columns.</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.facet_nrow">.facet_nrow</code></td>
<td>
<p>Number of facet rows (only used for <code>.trelliscope = TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.facet_scales">.facet_scales</code></td>
<td>
<p>Control facet x &amp; y-axis ranges.
Options include &quot;fixed&quot;, &quot;free&quot;, &quot;free_y&quot;, &quot;free_x&quot;</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.facet_dir">.facet_dir</code></td>
<td>
<p>The direction of faceting (&quot;h&quot; for horizontal, &quot;v&quot; for vertical). Default is &quot;h&quot;.</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.facet_collapse">.facet_collapse</code></td>
<td>
<p>Multiple facets included on one facet strip instead of
multiple facet strips.</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.facet_collapse_sep">.facet_collapse_sep</code></td>
<td>
<p>The separator used for collapsing facets.</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.facet_strip_remove">.facet_strip_remove</code></td>
<td>
<p>Whether or not to remove the strip and text label for each facet.</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.line_color">.line_color</code></td>
<td>
<p>Line color. Overrided if <code>.color_var</code> is specified.</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.line_size">.line_size</code></td>
<td>
<p>Line size.</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.line_type">.line_type</code></td>
<td>
<p>Line type.</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.line_alpha">.line_alpha</code></td>
<td>
<p>Line alpha (opacity). Range: (0, 1).</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.y_intercept">.y_intercept</code></td>
<td>
<p>Value for a y-intercept on the plot</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.y_intercept_color">.y_intercept_color</code></td>
<td>
<p>Color for the y-intercept</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.x_intercept">.x_intercept</code></td>
<td>
<p>Value for a x-intercept on the plot</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.x_intercept_color">.x_intercept_color</code></td>
<td>
<p>Color for the x-intercept</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.smooth">.smooth</code></td>
<td>
<p>Logical - Whether or not to include a trendline smoother.
Uses See <code><a href="#topic+smooth_vec">smooth_vec()</a></code> to apply a LOESS smoother.</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.smooth_period">.smooth_period</code></td>
<td>
<p>Number of observations to include in the Loess Smoother.
Set to &quot;auto&quot; by default, which uses <code>tk_get_trend()</code>
to determine a logical trend cycle.</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.smooth_message">.smooth_message</code></td>
<td>
<p>Logical.
Whether or not to return the trend selected as a message.
Useful for those that want to see what <code>.smooth_period</code> was selected.</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.smooth_span">.smooth_span</code></td>
<td>
<p>Percentage of observations to include in the Loess Smoother.
You can use either period or span. See <code><a href="#topic+smooth_vec">smooth_vec()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.smooth_degree">.smooth_degree</code></td>
<td>
<p>Flexibility of Loess Polynomial.
Either 0, 1, 2 (0 = lest flexible, 2 = more flexible).</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.smooth_color">.smooth_color</code></td>
<td>
<p>Smoother line color</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.smooth_size">.smooth_size</code></td>
<td>
<p>Smoother line size</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.smooth_alpha">.smooth_alpha</code></td>
<td>
<p>Smoother alpha (opacity). Range: (0, 1).</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.legend_show">.legend_show</code></td>
<td>
<p>Toggles on/off the Legend</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.title">.title</code></td>
<td>
<p>Title for the plot</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.x_lab">.x_lab</code></td>
<td>
<p>X-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.y_lab">.y_lab</code></td>
<td>
<p>Y-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.color_lab">.color_lab</code></td>
<td>
<p>Legend label if a <code>color_var</code> is used.</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.interactive">.interactive</code></td>
<td>
<p>Returns either a static (<code>ggplot2</code>) visualization or an interactive (<code>plotly</code>) visualization</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.plotly_slider">.plotly_slider</code></td>
<td>
<p>If <code>TRUE</code>, returns a plotly date range slider.</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.trelliscope">.trelliscope</code></td>
<td>
<p>Returns either a normal plot or a trelliscopejs plot (great for many time series)
Must have <code>trelliscopejs</code> installed.</p>
</td></tr>
<tr><td><code id="plot_time_series_+3A_.trelliscope_params">.trelliscope_params</code></td>
<td>
<p>Pass parameters to the <code>trelliscopejs::facet_trelliscope()</code> function as a <code>list()</code>.
The only parameters that cannot be passed are:
</p>

<ul>
<li> <p><code>ncol</code>: use <code>.facet_ncol</code>
</p>
</li>
<li> <p><code>nrow</code>: use <code>.facet_nrow</code>
</p>
</li>
<li> <p><code>scales</code>: use <code>facet_scales</code>
</p>
</li>
<li> <p><code>as_plotly</code>: use <code>.interactive</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot_time_series()</code> is a scalable function that works with both <em>ungrouped</em> and <em>grouped</em>
<code>data.frame</code> objects (and <code>tibbles</code>!).
</p>
<p><strong>Interactive by Default</strong>
</p>
<p><code>plot_time_series()</code> is built for exploration using:
</p>

<ul>
<li> <p><strong>Interactive Plots:</strong> <code>plotly</code> (default) - Great for exploring!
</p>
</li>
<li> <p><strong>Static Plots:</strong> <code>ggplot2</code> (set <code>.interactive = FALSE</code>) - Great for PDF Reports
</p>
</li></ul>

<p>By default, an interactive <code>plotly</code> visualization is returned.
</p>
<p><strong>Scalable with Facets &amp; Dplyr Groups</strong>
</p>
<p><code>plot_time_series()</code> returns multiple time series plots using <code>ggplot2</code> facets:
</p>

<ul>
<li> <p><code>group_by()</code> - If groups are detected, multiple facets are returned
</p>
</li>
<li> <p><code>plot_time_series(.facet_vars)</code> - You can manually supply facets as well.
</p>
</li></ul>

<p><strong>Can Transform Values just like ggplot</strong>
</p>
<p>The <code>.values</code> argument accepts transformations just like <code>ggplot2</code>.
For example, if you want to take the log of sales you can use
a call like <code>plot_time_series(date, log(sales))</code> and the log transformation
will be applied.
</p>
<p><strong>Smoother Period / Span Calculation</strong>
</p>
<p>The <code>.smooth = TRUE</code> option returns a smoother that is calculated based on either:
</p>

<ol>
<li><p> A <code>.smooth_period</code>: Number of observations
</p>
</li>
<li><p> A <code>.smooth_span</code>: A percentage of observations
</p>
</li></ol>

<p>By default, the <code>.smooth_period</code> is automatically calculated using 75% of the observertions.
This is the same as <code>geom_smooth(method = "loess", span = 0.75)</code>.
</p>
<p>A user can specify a time-based window (e.g. <code>.smooth_period = "1 year"</code>)
or a numeric value (e.g. <code>smooth_period = 365</code>).
</p>
<p>Time-based windows return the median number of observations in a window using <code>tk_get_trend()</code>.
</p>


<h3>Value</h3>

<p>A static <code>ggplot2</code> plot or an interactive <code>plotly</code> plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(lubridate)

# Works with individual time series
FANG %&gt;%
    filter(symbol == "FB") %&gt;%
    plot_time_series(date, adjusted, .interactive = FALSE)

# Works with groups
FANG %&gt;%
    group_by(symbol) %&gt;%
    plot_time_series(date, adjusted,
                     .facet_ncol  = 2,     # 2-column layout
                     .interactive = FALSE)

# Can also group inside &amp; use .color_var
FANG %&gt;%
    mutate(year = year(date)) %&gt;%
    plot_time_series(date, adjusted,
                     .facet_vars     = c(symbol, year), # add groups/facets
                     .color_var      = year,            # color by year
                     .facet_ncol     = 4,
                     .facet_scales   = "free",
                     .facet_collapse = TRUE,  # combine group strip text into 1 line
                     .interactive    = FALSE)

# Can apply transformations to .value or .color_var
# - .value = log(adjusted)
# - .color_var = year(date)
FANG %&gt;%
    plot_time_series(date, log(adjusted),
                     .color_var    = year(date),
                     .facet_vars   = contains("symbol"),
                     .facet_ncol   = 2,
                     .facet_scales = "free",
                     .y_lab        = "Log Scale",
                     .interactive  = FALSE)



</code></pre>

<hr>
<h2 id='plot_time_series_boxplot'>Interactive Time Series Box Plots</h2><span id='topic+plot_time_series_boxplot'></span>

<h3>Description</h3>

<p>A boxplot function that generates interactive <code>plotly</code> plots
for time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_time_series_boxplot(
  .data,
  .date_var,
  .value,
  .period,
  .color_var = NULL,
  .facet_vars = NULL,
  .facet_ncol = 1,
  .facet_nrow = 1,
  .facet_scales = "free_y",
  .facet_dir = "h",
  .facet_collapse = FALSE,
  .facet_collapse_sep = " ",
  .facet_strip_remove = FALSE,
  .line_color = "#2c3e50",
  .line_size = 0.5,
  .line_type = 1,
  .line_alpha = 1,
  .y_intercept = NULL,
  .y_intercept_color = "#2c3e50",
  .smooth = TRUE,
  .smooth_func = ~mean(.x, na.rm = TRUE),
  .smooth_period = "auto",
  .smooth_message = FALSE,
  .smooth_span = NULL,
  .smooth_degree = 2,
  .smooth_color = "#3366FF",
  .smooth_size = 1,
  .smooth_alpha = 1,
  .legend_show = TRUE,
  .title = "Time Series Plot",
  .x_lab = "",
  .y_lab = "",
  .color_lab = "Legend",
  .interactive = TRUE,
  .plotly_slider = FALSE,
  .trelliscope = FALSE,
  .trelliscope_params = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_time_series_boxplot_+3A_.data">.data</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code> with a time-based column</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing either date or date-time values</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.value">.value</code></td>
<td>
<p>A column containing numeric values</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.period">.period</code></td>
<td>
<p>A time series unit of aggregation for the boxplot. Examples include:
</p>

<ul>
<li><p> &quot;1 week&quot;
</p>
</li>
<li><p> &quot;3 years&quot;
</p>
</li>
<li><p> &quot;30 minutes&quot;
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.color_var">.color_var</code></td>
<td>
<p>A categorical column that can be used to change the
line color</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.facet_vars">.facet_vars</code></td>
<td>
<p>One or more grouping columns that broken out into <code>ggplot2</code> facets.
These can be selected using <code>tidyselect()</code> helpers (e.g <code>contains()</code>).</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.facet_ncol">.facet_ncol</code></td>
<td>
<p>Number of facet columns.</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.facet_nrow">.facet_nrow</code></td>
<td>
<p>Number of facet rows (only used for <code>.trelliscope = TRUE</code>)</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.facet_scales">.facet_scales</code></td>
<td>
<p>Control facet x &amp; y-axis ranges.
Options include &quot;fixed&quot;, &quot;free&quot;, &quot;free_y&quot;, &quot;free_x&quot;</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.facet_dir">.facet_dir</code></td>
<td>
<p>The direction of faceting (&quot;h&quot; for horizontal, &quot;v&quot; for vertical). Default is &quot;h&quot;.</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.facet_collapse">.facet_collapse</code></td>
<td>
<p>Multiple facets included on one facet strip instead of
multiple facet strips.</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.facet_collapse_sep">.facet_collapse_sep</code></td>
<td>
<p>The separator used for collapsing facets.</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.facet_strip_remove">.facet_strip_remove</code></td>
<td>
<p>Whether or not to remove the strip and text label for each facet.</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.line_color">.line_color</code></td>
<td>
<p>Line color. Overrided if <code>.color_var</code> is specified.</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.line_size">.line_size</code></td>
<td>
<p>Line size.</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.line_type">.line_type</code></td>
<td>
<p>Line type.</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.line_alpha">.line_alpha</code></td>
<td>
<p>Line alpha (opacity). Range: (0, 1).</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.y_intercept">.y_intercept</code></td>
<td>
<p>Value for a y-intercept on the plot</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.y_intercept_color">.y_intercept_color</code></td>
<td>
<p>Color for the y-intercept</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.smooth">.smooth</code></td>
<td>
<p>Logical - Whether or not to include a trendline smoother.
Uses See <code><a href="#topic+smooth_vec">smooth_vec()</a></code> to apply a LOESS smoother.</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.smooth_func">.smooth_func</code></td>
<td>
<p>Defines how to aggregate the .value to show the smoothed trendline.
The default is <code>~ mean(.x, na.rm = TRUE)</code>, which uses lambda function to ensure <code>NA</code> values are removed.
Possible values are:
</p>

<ul>
<li><p> A function, e.g. <code>mean</code>.
</p>
</li>
<li><p> A purrr-style lambda, e.g. <code>~ mean(.x, na.rm = TRUE)</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.smooth_period">.smooth_period</code></td>
<td>
<p>Number of observations to include in the Loess Smoother.
Set to &quot;auto&quot; by default, which uses <code>tk_get_trend()</code>
to determine a logical trend cycle.</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.smooth_message">.smooth_message</code></td>
<td>
<p>Logical.
Whether or not to return the trend selected as a message.
Useful for those that want to see what <code>.smooth_period</code> was selected.</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.smooth_span">.smooth_span</code></td>
<td>
<p>Percentage of observations to include in the Loess Smoother.
You can use either period or span. See <code><a href="#topic+smooth_vec">smooth_vec()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.smooth_degree">.smooth_degree</code></td>
<td>
<p>Flexibility of Loess Polynomial.
Either 0, 1, 2 (0 = lest flexible, 2 = more flexible).</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.smooth_color">.smooth_color</code></td>
<td>
<p>Smoother line color</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.smooth_size">.smooth_size</code></td>
<td>
<p>Smoother line size</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.smooth_alpha">.smooth_alpha</code></td>
<td>
<p>Smoother alpha (opacity). Range: (0, 1).</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.legend_show">.legend_show</code></td>
<td>
<p>Toggles on/off the Legend</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.title">.title</code></td>
<td>
<p>Title for the plot</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.x_lab">.x_lab</code></td>
<td>
<p>X-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.y_lab">.y_lab</code></td>
<td>
<p>Y-axis label for the plot</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.color_lab">.color_lab</code></td>
<td>
<p>Legend label if a <code>color_var</code> is used.</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.interactive">.interactive</code></td>
<td>
<p>Returns either a static (<code>ggplot2</code>) visualization or an interactive (<code>plotly</code>) visualization</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.plotly_slider">.plotly_slider</code></td>
<td>
<p>If TRUE, returns a plotly date range slider.</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.trelliscope">.trelliscope</code></td>
<td>
<p>Returns either a normal plot or a trelliscopejs plot (great for many time series)
Must have <code>trelliscopejs</code> installed.</p>
</td></tr>
<tr><td><code id="plot_time_series_boxplot_+3A_.trelliscope_params">.trelliscope_params</code></td>
<td>
<p>Pass parameters to the <code>trelliscopejs::facet_trelliscope()</code> function as a <code>list()</code>.
The only parameters that cannot be passed are:
</p>

<ul>
<li> <p><code>ncol</code>: use <code>.facet_ncol</code>
</p>
</li>
<li> <p><code>nrow</code>: use <code>.facet_nrow</code>
</p>
</li>
<li> <p><code>scales</code>: use <code>facet_scales</code>
</p>
</li>
<li> <p><code>as_plotly</code>: use <code>.interactive</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot_time_series_boxplot()</code> is a scalable function that works with both <em>ungrouped</em> and <em>grouped</em>
<code>data.frame</code> objects (and <code>tibbles</code>!).
</p>
<p><strong>Interactive by Default</strong>
</p>
<p><code>plot_time_series_boxplot()</code> is built for exploration using:
</p>

<ul>
<li> <p><strong>Interactive Plots:</strong> <code>plotly</code> (default) - Great for exploring!
</p>
</li>
<li> <p><strong>Static Plots:</strong> <code>ggplot2</code> (set <code>.interactive = FALSE</code>) - Great for PDF Reports
</p>
</li></ul>

<p>By default, an interactive <code>plotly</code> visualization is returned.
</p>
<p><strong>Scalable with Facets &amp; Dplyr Groups</strong>
</p>
<p><code>plot_time_series_boxplot()</code> returns multiple time series plots using <code>ggplot2</code> facets:
</p>

<ul>
<li> <p><code>group_by()</code> - If groups are detected, multiple facets are returned
</p>
</li>
<li> <p><code>plot_time_series_boxplot(.facet_vars)</code> - You can manually supply facets as well.
</p>
</li></ul>

<p><strong>Can Transform Values just like ggplot</strong>
</p>
<p>The <code>.values</code> argument accepts transformations just like <code>ggplot2</code>.
For example, if you want to take the log of sales you can use
a call like <code>plot_time_series_boxplot(date, log(sales))</code> and the log transformation
will be applied.
</p>
<p><strong>Smoother Period / Span Calculation</strong>
</p>
<p>The <code>.smooth = TRUE</code> option returns a smoother that is calculated based on either:
</p>

<ol>
<li><p> A <code>.smooth_func</code>: The method of aggregation.
Usually an aggregation like <code>mean</code> is used.
The <code>purrr</code>-style function syntax can be used to apply complex functions.
</p>
</li>
<li><p> A <code>.smooth_period</code>: Number of observations
</p>
</li>
<li><p> A <code>.smooth_span</code>: A percentage of observations
</p>
</li></ol>

<p>By default, the <code>.smooth_period</code> is automatically calculated using 75% of the observertions.
This is the same as <code>geom_smooth(method = "loess", span = 0.75)</code>.
</p>
<p>A user can specify a time-based window (e.g. <code>.smooth_period = "1 year"</code>)
or a numeric value (e.g. <code>smooth_period = 365</code>).
</p>
<p>Time-based windows return the median number of observations in a window using <code>tk_get_trend()</code>.
</p>


<h3>Value</h3>

<p>A static <code>ggplot2</code> plot or an interactive <code>plotly</code> plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(lubridate)

# Works with individual time series
FANG %&gt;%
    filter(symbol == "FB") %&gt;%
    plot_time_series_boxplot(
        date, adjusted,
        .period      = "3 month",
        .interactive = FALSE)

# Works with groups
FANG %&gt;%
    group_by(symbol) %&gt;%
    plot_time_series_boxplot(
        date, adjusted,
        .period      = "3 months",
        .facet_ncol  = 2,     # 2-column layout
        .interactive = FALSE)


# Can also group inside &amp; use .color_var
FANG %&gt;%
    mutate(year = year(date)) %&gt;%
    plot_time_series_boxplot(
        date, adjusted,
        .period      = "3 months",
        .facet_vars   = c(symbol, year), # add groups/facets
        .color_var    = year,            # color by year
        .facet_ncol   = 4,
        .facet_scales = "free",
        .interactive  = FALSE)


# Can apply transformations to .value or .color_var
# - .value = log(adjusted)
# - .color_var = year(date)
FANG %&gt;%
    plot_time_series_boxplot(
        date, log(adjusted),
        .period      = "3 months",
        .color_var    = year(date),
        .facet_vars   = contains("symbol"),
        .facet_ncol   = 2,
        .facet_scales = "free",
        .y_lab        = "Log Scale",
        .interactive  = FALSE)

# Can adjust the smoother
FANG %&gt;%
    group_by(symbol) %&gt;%
    plot_time_series_boxplot(
        date, adjusted,
        .period           = "3 months",
        .smooth           = TRUE,
        .smooth_func      = median,    # Smoother function
        .smooth_period    = "5 years", # Smoother Period
        .facet_ncol       = 2,
        .interactive      = FALSE)

</code></pre>

<hr>
<h2 id='plot_time_series_cv_plan'>Visualize a Time Series Resample Plan</h2><span id='topic+plot_time_series_cv_plan'></span>

<h3>Description</h3>

<p>The <code>plot_time_series_cv_plan()</code> function provides a visualization
for a time series resample specification (<code>rset</code>) of either <code>rolling_origin</code>
or <code>time_series_cv</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_time_series_cv_plan(
  .data,
  .date_var,
  .value,
  ...,
  .smooth = FALSE,
  .title = "Time Series Cross Validation Plan"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_time_series_cv_plan_+3A_.data">.data</code></td>
<td>
<p>A time series resample specification of of either <code>rolling_origin</code>
or <code>time_series_cv</code> class or a data frame (tibble) that has been prepared
using <code><a href="#topic+tk_time_series_cv_plan">tk_time_series_cv_plan()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_time_series_cv_plan_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing either date or date-time values</p>
</td></tr>
<tr><td><code id="plot_time_series_cv_plan_+3A_.value">.value</code></td>
<td>
<p>A column containing numeric values</p>
</td></tr>
<tr><td><code id="plot_time_series_cv_plan_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code><a href="#topic+plot_time_series">plot_time_series()</a></code></p>
</td></tr>
<tr><td><code id="plot_time_series_cv_plan_+3A_.smooth">.smooth</code></td>
<td>
<p>Logical - Whether or not to include a trendline smoother.
Uses See <code><a href="#topic+smooth_vec">smooth_vec()</a></code> to apply a LOESS smoother.</p>
</td></tr>
<tr><td><code id="plot_time_series_cv_plan_+3A_.title">.title</code></td>
<td>
<p>Title for the plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Resample Set</strong>
</p>
<p>A resample set is an output of the <code>timetk::time_series_cv()</code> function or the
<code>rsample::rolling_origin()</code> function.
</p>


<h3>Value</h3>

<p>Returns a static <code>ggplot</code> or interactive <code>plotly</code> object depending on
whether or not <code>.interactive</code> is <code>FALSE</code> or <code>TRUE</code>, respectively.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+time_series_cv">time_series_cv()</a></code> and <code><a href="rsample.html#topic+rolling_origin">rsample::rolling_origin()</a></code> - Functions used to create
time series resample specfications.
</p>
</li>
<li> <p><code><a href="#topic+plot_time_series_cv_plan">plot_time_series_cv_plan()</a></code> - The plotting function used for visualizing the
time series resample plan.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(rsample)

FB_tbl &lt;- FANG %&gt;%
    filter(symbol == "FB") %&gt;%
    select(symbol, date, adjusted)

resample_spec &lt;- time_series_cv(
    FB_tbl,
    initial = "1 year",
    assess  = "6 weeks",
    skip    = "3 months",
    lag     = "1 month",
    cumulative  = FALSE,
    slice_limit = 6
)

resample_spec %&gt;% tk_time_series_cv_plan()

resample_spec %&gt;%
    tk_time_series_cv_plan() %&gt;%
    plot_time_series_cv_plan(
        date, adjusted, # date variable and value variable
        # Additional arguments passed to plot_time_series(),
        .facet_ncol = 2,
        .line_alpha = 0.5,
        .interactive = FALSE
    )

</code></pre>

<hr>
<h2 id='plot_time_series_regression'>Visualize a Time Series Linear Regression Formula</h2><span id='topic+plot_time_series_regression'></span>

<h3>Description</h3>

<p>A wrapper for <code><a href="stats.html#topic+lm">stats::lm()</a></code> that overlays a
linear regression fitted model over a time series, which can help
show the effect of feature engineering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_time_series_regression(
  .data,
  .date_var,
  .formula,
  .show_summary = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_time_series_regression_+3A_.data">.data</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code> with a time-based column</p>
</td></tr>
<tr><td><code id="plot_time_series_regression_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing either date or date-time values</p>
</td></tr>
<tr><td><code id="plot_time_series_regression_+3A_.formula">.formula</code></td>
<td>
<p>A linear regression formula. The left-hand side of the formula is used
as the y-axis value. The right-hand side of the formula is used to develop the linear regression model.
See <code><a href="stats.html#topic+lm">stats::lm()</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot_time_series_regression_+3A_.show_summary">.show_summary</code></td>
<td>
<p>If <code>TRUE</code>, prints the <code>summary.lm()</code>.</p>
</td></tr>
<tr><td><code id="plot_time_series_regression_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+plot_time_series">plot_time_series()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot_time_series_regression()</code> is a scalable function that works with both <em>ungrouped</em> and <em>grouped</em>
<code>data.frame</code> objects (and <code>tibbles</code>!).
</p>
<p><strong>Time Series Formula</strong>
</p>
<p>The <code>.formula</code> uses <code><a href="stats.html#topic+lm">stats::lm()</a></code> to apply a linear regression, which is used to visualize
the effect of feature engineering on a time series.
</p>

<ul>
<li><p> The left-hand side of the formula is used as the y-axis value.
</p>
</li>
<li><p> The right-hand side of the formula is used to develop the linear regression model.
</p>
</li></ul>

<p><strong>Interactive by Default</strong>
</p>
<p><code>plot_time_series_regression()</code> is built for exploration using:
</p>

<ul>
<li> <p><strong>Interactive Plots:</strong> <code>plotly</code> (default) - Great for exploring!
</p>
</li>
<li> <p><strong>Static Plots:</strong> <code>ggplot2</code> (set <code>.interactive = FALSE</code>) - Great for PDF Reports
</p>
</li></ul>

<p>By default, an interactive <code>plotly</code> visualization is returned.
</p>
<p><strong>Scalable with Facets &amp; Dplyr Groups</strong>
</p>
<p><code>plot_time_series_regression()</code> returns multiple time series plots using <code>ggplot2</code> facets:
</p>

<ul>
<li> <p><code>group_by()</code> - If groups are detected, multiple facets are returned
</p>
</li>
<li> <p><code>plot_time_series_regression(.facet_vars)</code> - You can manually supply facets as well.
</p>
</li></ul>



<h3>Value</h3>

<p>A static <code>ggplot2</code> plot or an interactive <code>plotly</code> plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(lubridate)

# ---- SINGLE SERIES ----
m4_monthly %&gt;%
    filter(id == "M750") %&gt;%
    plot_time_series_regression(
        .date_var     = date,
        .formula      = log(value) ~ as.numeric(date) + month(date, label = TRUE),
        .show_summary = TRUE,
        .facet_ncol   = 2,
        .interactive  = FALSE
    )


# ---- GROUPED SERIES ----
m4_monthly %&gt;%
    group_by(id) %&gt;%
    plot_time_series_regression(
        .date_var    = date,
        .formula     = log(value) ~ as.numeric(date) + month(date, label = TRUE),
        .facet_ncol  = 2,
        .interactive = FALSE
    )


</code></pre>

<hr>
<h2 id='required_pkgs.step_box_cox'>S3 methods for tracking which additional packages are needed for steps.</h2><span id='topic+required_pkgs.step_box_cox'></span><span id='topic+required_pkgs.step_diff'></span><span id='topic+required_pkgs.step_fourier'></span><span id='topic+required_pkgs.step_holiday_signature'></span><span id='topic+required_pkgs.step_log_interval'></span><span id='topic+required_pkgs.step_slidify'></span><span id='topic+required_pkgs.step_slidify_augment'></span><span id='topic+required_pkgs.step_smooth'></span><span id='topic+required_pkgs.step_timeseries_signature'></span><span id='topic+required_pkgs.step_ts_clean'></span><span id='topic+required_pkgs.step_ts_impute'></span><span id='topic+required_pkgs.step_ts_pad'></span>

<h3>Description</h3>

<p>Recipe-adjacent packages always list themselves as a required package so that
the steps can function properly within parallel processing schemes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'step_box_cox'
required_pkgs(x, ...)

## S3 method for class 'step_diff'
required_pkgs(x, ...)

## S3 method for class 'step_fourier'
required_pkgs(x, ...)

## S3 method for class 'step_holiday_signature'
required_pkgs(x, ...)

## S3 method for class 'step_log_interval'
required_pkgs(x, ...)

## S3 method for class 'step_slidify'
required_pkgs(x, ...)

## S3 method for class 'step_slidify_augment'
required_pkgs(x, ...)

## S3 method for class 'step_smooth'
required_pkgs(x, ...)

## S3 method for class 'step_timeseries_signature'
required_pkgs(x, ...)

## S3 method for class 'step_ts_clean'
required_pkgs(x, ...)

## S3 method for class 'step_ts_impute'
required_pkgs(x, ...)

## S3 method for class 'step_ts_pad'
required_pkgs(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="required_pkgs.step_box_cox_+3A_x">x</code></td>
<td>
<p>A recipe step</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>

<hr>
<h2 id='set_tk_time_scale_template'>Get and modify the Time Scale Template</h2><span id='topic+set_tk_time_scale_template'></span><span id='topic+get_tk_time_scale_template'></span><span id='topic+tk_time_scale_template'></span>

<h3>Description</h3>

<p>Get and modify the Time Scale Template
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_tk_time_scale_template(.data)

get_tk_time_scale_template()

tk_time_scale_template()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_tk_time_scale_template_+3A_.data">.data</code></td>
<td>
<p>A <code>tibble</code> with a &quot;time_scale&quot;, &quot;frequency&quot;, and &quot;trend&quot; columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used to get and set the time scale template, which is used by <code>tk_get_frequency()</code>
and <code>tk_get_trend()</code> when <code>period = "auto"</code>.
</p>
<p>The predefined template is stored in a function <code>tk_time_scale_template()</code>.
This is the default used by <code>timetk</code>.
</p>
<p><strong>Changing the Default Template</strong>
</p>

<ul>
<li><p> You can access the current template with <code>get_tk_time_scale_template()</code>.
</p>
</li>
<li><p> You can modify the current template with <code>set_tk_time_scale_template()</code>.
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li> <p><code>get_tk_time_scale_template()</code>: Returns <code>tibble</code> containing the time scale template information.
</p>
</li>
<li> <p><code>set_tk_time_scale_template()</code>: Returns nothing.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li><p> Automated Frequency and Trend Calculation: <code><a href="#topic+tk_get_frequency">tk_get_frequency()</a></code>, <code><a href="#topic+tk_get_trend">tk_get_trend()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
get_tk_time_scale_template()

set_tk_time_scale_template(tk_time_scale_template())

</code></pre>

<hr>
<h2 id='slice_period'>Apply slice inside periods (windows)</h2><span id='topic+slice_period'></span>

<h3>Description</h3>

<p>Applies a dplyr slice inside a time-based period (window).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slice_period(.data, ..., .date_var, .period = "1 day")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slice_period_+3A_.data">.data</code></td>
<td>
<p>A <code>tbl</code> object or <code>data.frame</code></p>
</td></tr>
<tr><td><code id="slice_period_+3A_...">...</code></td>
<td>
<p>For <code>slice()</code>: &lt;<code><a href="rlang.html#topic+args_data_masking">data-masking</a></code>&gt;
Integer row values.
</p>
<p>Provide either positive values to keep, or negative values to drop.
The values provided must be either all positive or all negative.
Indices beyond the number of rows in the input are silently ignored.
</p>
<p>For <code style="white-space: pre;">&#8288;slice_*()&#8288;</code>, these arguments are passed on to methods.</p>
</td></tr>
<tr><td><code id="slice_period_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing date or date-time values.
If missing, attempts to auto-detect date column.</p>
</td></tr>
<tr><td><code id="slice_period_+3A_.period">.period</code></td>
<td>
<p>A period to slice within.
Time units are grouped using <code>lubridate::floor_date()</code> or <code>lubridate::ceiling_date()</code>.
</p>
<p>The value can be:
</p>

<ul>
<li> <p><code>second</code>
</p>
</li>
<li> <p><code>minute</code>
</p>
</li>
<li> <p><code>hour</code>
</p>
</li>
<li> <p><code>day</code>
</p>
</li>
<li> <p><code>week</code>
</p>
</li>
<li> <p><code>month</code>
</p>
</li>
<li> <p><code>bimonth</code>
</p>
</li>
<li> <p><code>quarter</code>
</p>
</li>
<li> <p><code>season</code>
</p>
</li>
<li> <p><code>halfyear</code>
</p>
</li>
<li> <p><code>year</code>
</p>
</li></ul>

<p>Arbitrary unique English abbreviations as in the <code>lubridate::period()</code> constructor are allowed:
</p>

<ul>
<li> <p><code>"1 year"</code>
</p>
</li>
<li> <p><code>"2 months"</code>
</p>
</li>
<li> <p><code>"30 seconds"</code>
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> or <code>data.frame</code>
</p>


<h3>See Also</h3>

<p>Time-Based dplyr functions:
</p>

<ul>
<li> <p><code><a href="#topic+summarise_by_time">summarise_by_time()</a></code> - Easily summarise using a date column.
</p>
</li>
<li> <p><code><a href="#topic+mutate_by_time">mutate_by_time()</a></code> - Simplifies applying mutations by time windows.
</p>
</li>
<li> <p><code><a href="#topic+pad_by_time">pad_by_time()</a></code> - Insert time series rows with regularly spaced timestamps
</p>
</li>
<li> <p><code><a href="#topic+filter_by_time">filter_by_time()</a></code> - Quickly filter using date ranges.
</p>
</li>
<li> <p><code><a href="#topic+filter_period">filter_period()</a></code> - Apply filtering expressions inside periods (windows)
</p>
</li>
<li> <p><code><a href="#topic+slice_period">slice_period()</a></code> - Apply slice inside periods (windows)
</p>
</li>
<li> <p><code><a href="#topic+condense_period">condense_period()</a></code> - Convert to a different periodicity
</p>
</li>
<li> <p><code><a href="#topic+between_time">between_time()</a></code> - Range detection for date or date-time sequences.
</p>
</li>
<li> <p><code><a href="#topic+slidify">slidify()</a></code> - Turn any function into a sliding (rolling) function
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Libraries
library(dplyr)

# First 5 observations in each month
m4_daily %&gt;%
    group_by(id) %&gt;%
    slice_period(1:5, .period = "1 month")

# Last observation in each month
m4_daily %&gt;%
    group_by(id) %&gt;%
    slice_period(n(), .period = "1 month")

</code></pre>

<hr>
<h2 id='slidify'>Create a rolling (sliding) version of any function</h2><span id='topic+slidify'></span>

<h3>Description</h3>

<p><code>slidify</code> returns a rolling (sliding) version of the input function, with a
rolling (sliding) <code>.period</code> specified by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slidify(
  .f,
  .period = 1,
  .align = c("center", "left", "right"),
  .partial = FALSE,
  .unlist = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slidify_+3A_.f">.f</code></td>
<td>
<p>A function, formula, or vector (not necessarily atomic).
</p>
<p>If a <strong>function</strong>, it is used as is.
</p>
<p>If a <strong>formula</strong>, e.g. <code>~ .x + 2</code>, it is converted to a function. There
are three ways to refer to the arguments:
</p>

<ul>
<li><p> For a single argument function, use <code>.</code>
</p>
</li>
<li><p> For a two argument function, use <code>.x</code> and <code>.y</code>
</p>
</li>
<li><p> For more arguments, use <code>..1</code>, <code>..2</code>, <code>..3</code> etc
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous
functions. Note that formula functions conceptually take dots
(that's why you can use <code>..1</code> etc). They silently ignore
additional arguments that are not used in the formula expression.
</p>
<p>If <strong>character vector</strong>, <strong>numeric vector</strong>, or <strong>list</strong>, it is
converted to an extractor function. Character vectors index by
name and numeric vectors index by position; use a list to index
by position and name at different levels. If a component is not
present, the value of <code>.default</code> will be returned.</p>
</td></tr>
<tr><td><code id="slidify_+3A_.period">.period</code></td>
<td>
<p>The period size to roll over</p>
</td></tr>
<tr><td><code id="slidify_+3A_.align">.align</code></td>
<td>
<p>One of &quot;center&quot;, &quot;left&quot; or &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="slidify_+3A_.partial">.partial</code></td>
<td>
<p>Should the moving window be allowed to return partial (incomplete) windows
instead of <code>NA</code> values. Set to <code>FALSE</code> by default, but can be switched to <code>TRUE</code> to remove <code>NA</code>'s.</p>
</td></tr>
<tr><td><code id="slidify_+3A_.unlist">.unlist</code></td>
<td>
<p>If the function returns a single value each time it is called,
use <code>.unlist = TRUE</code>. If the function returns more than one value, or a more
complicated object (like a linear model), use <code>.unlist = FALSE</code> to create
a list-column of the rolling results.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>slidify()</code> function is almost identical to <code>tibbletime::rollify()</code>
with 3 improvements:
</p>

<ol>
<li><p> Alignment (&quot;center&quot;, &quot;left&quot;, &quot;right&quot;)
</p>
</li>
<li><p> Partial windows are allowed
</p>
</li>
<li><p> Uses <code>slider</code> under the hood, which improves speed and reliability by implementing
code at C++ level
</p>
</li></ol>

<p><strong>Make any function a Sliding (Rolling) Function</strong>
</p>
<p><code>slidify()</code> turns a function into a sliding version
of itself for use inside of a call to <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, however it works
equally as well when called from <code><a href="purrr.html#topic+map">purrr::map()</a></code>.
</p>
<p>Because of it's intended use with <code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code>, <code>slidify</code>
creates a function that always returns output with the same length of the
input
</p>
<p><strong>Alignment</strong>
</p>
<p>Rolling / Sliding functions generate <code>.period - 1</code> fewer values than the incoming vector.
Thus, the vector needs to be aligned. Alignment of the vector follows 3 types:
</p>

<ul>
<li> <p><strong>center (default):</strong> <code>NA</code> or <code>.partial</code> values are divided and added to the beginning and
end of the series to &quot;Center&quot; the moving average. This is common in Time Series applications (e.g. denoising).
</p>
</li>
<li> <p><strong>left:</strong> <code>NA</code> or <code>.partial</code> values are added to the end to shift the series to the Left.
</p>
</li>
<li> <p><strong>right:</strong> <code>NA</code> or <code>.partial</code> values are added to the beginning to shift the series to the Right. This is common in
Financial Applications (e.g moving average cross-overs).
</p>
</li></ul>

<p><strong>Allowing Partial Windows</strong>
</p>
<p>A key improvement over <code>tibbletime::slidify()</code> is that <code>timetk::slidify()</code> implements
<code>.partial</code> rolling windows. Just set <code>.partial = TRUE</code>.
</p>


<h3>Value</h3>

<p>A <code>function</code> with the rolling/sliding conversion applied.
</p>


<h3>References</h3>


<ul>
<li><p> The <a href="https://business-science.github.io/tibbletime/index.html">Tibbletime R Package</a>
by Davis Vaughan, which includes the original <code>rollify()</code>
Function
</p>
</li></ul>



<h3>See Also</h3>

<p>Transformation Functions:
</p>

<ul>
<li> <p><code><a href="#topic+slidify_vec">slidify_vec()</a></code> - A simple vectorized function for applying summary functions
to rolling windows.
</p>
</li></ul>

<p>Augmentation Functions (Add Rolling Multiple Columns):
</p>

<ul>
<li> <p><code><a href="#topic+tk_augment_slidify">tk_augment_slidify()</a></code> - For easily adding multiple rolling windows to you data
</p>
</li></ul>

<p>Slider R Package:
</p>

<ul>
<li> <p><code>slider::pslide()</code> - The workhorse function that powers <code>timetk::slidify()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

FB &lt;- FANG %&gt;% dplyr::filter(symbol == "FB")


# --- ROLLING MEAN (SINGLE ARG EXAMPLE) ---

# Turn the normal mean function into a rolling mean with a 5 row .period
mean_roll_5 &lt;- slidify(mean, .period = 5, .align = "right")

FB %&gt;%
    mutate(rolling_mean_5 = mean_roll_5(adjusted))

# Use `partial = TRUE` to allow partial windows (those with less than the full .period)
mean_roll_5_partial &lt;- slidify(mean, .period = 5, .align = "right", .partial = TRUE)

FB %&gt;%
    mutate(rolling_mean_5 = mean_roll_5_partial(adjusted))

# There's nothing stopping you from combining multiple rolling functions with
# different .period sizes in the same mutate call

mean_roll_10 &lt;- slidify(mean, .period = 10, .align = "right")

FB %&gt;%
    select(symbol, date, adjusted) %&gt;%
    mutate(
        rolling_mean_5  = mean_roll_5(adjusted),
        rolling_mean_10 = mean_roll_10(adjusted)
    )

# For summary operations like rolling means, we can accomplish large-scale
# multi-rolls with tk_augment_slidify()

FB %&gt;%
    select(symbol, date, adjusted) %&gt;%
    tk_augment_slidify(
        adjusted, .period = 5:10, .f = mean, .align = "right",
        .names = stringr::str_c("MA_", 5:10)
    )

# --- GROUPS AND ROLLING ----

# One of the most powerful things about this is that it works with
# groups since `mutate` is being used

mean_roll_3 &lt;- slidify(mean, .period = 3, .align = "right")

FANG %&gt;%
    group_by(symbol) %&gt;%
    mutate(mean_roll = mean_roll_3(adjusted)) %&gt;%
    slice(1:5)


# --- ROLLING CORRELATION (MULTIPLE ARG EXAMPLE) ---

# With 2 args, use the purrr syntax of ~ and .x, .y
# Rolling correlation example
cor_roll &lt;- slidify(~cor(.x, .y), .period = 5, .align = "right")

FB %&gt;%
    mutate(running_cor = cor_roll(adjusted, open))

# With &gt;2 args, create an anonymous function with &gt;2 args or use
# the purrr convention of ..1, ..2, ..3 to refer to the arguments
avg_of_avgs &lt;- slidify(
    function(x, y, z) (mean(x) + mean(y) + mean(z)) / 3,
    .period = 10,
    .align = "right"
)

# Or
avg_of_avgs &lt;- slidify(
    ~(mean(..1) + mean(..2) + mean(..3)) / 3,
    .period = 10,
    .align  = "right"
)

FB %&gt;%
    mutate(avg_of_avgs = avg_of_avgs(open, high, low))

# Optional arguments MUST be passed at the creation of the rolling function
# Only data arguments that are "rolled over" are allowed when calling the
# rolling version of the function
FB$adjusted[1] &lt;- NA

roll_mean_na_rm &lt;- slidify(~mean(.x, na.rm = TRUE), .period = 5, .align = "right")

FB %&gt;%
    mutate(roll_mean = roll_mean_na_rm(adjusted))


# --- ROLLING REGRESSIONS ----

# Rolling regressions are easy to implement using `.unlist = FALSE`
lm_roll &lt;- slidify(~lm(.x ~ .y), .period = 90, .unlist = FALSE, .align = "right")

FB %&gt;%
    tidyr::drop_na() %&gt;%
    mutate(numeric_date = as.numeric(date)) %&gt;%
    mutate(rolling_lm = lm_roll(adjusted, numeric_date)) %&gt;%
    filter(!is.na(rolling_lm))




</code></pre>

<hr>
<h2 id='slidify_vec'>Rolling Window Transformation</h2><span id='topic+slidify_vec'></span>

<h3>Description</h3>

<p><code>slidify_vec()</code> applies a <em>summary function</em> to a rolling sequence of windows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>slidify_vec(
  .x,
  .f,
  ...,
  .period = 1,
  .align = c("center", "left", "right"),
  .partial = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="slidify_vec_+3A_.x">.x</code></td>
<td>
<p>A vector to have a rolling window transformation applied.</p>
</td></tr>
<tr><td><code id="slidify_vec_+3A_.f">.f</code></td>
<td>
<p>A summary <code style="white-space: pre;">&#8288;[function / formula]&#8288;</code>
</p>

<ul>
<li><p> If a <strong>function</strong>, e.g. <code>mean</code>, the function is used with any
additional arguments, <code>...</code>.
</p>
</li>
<li><p> If a <strong>formula</strong>, e.g. <code>~ mean(., na.rm = TRUE)</code>, it is converted to a function.
</p>
</li></ul>

<p>This syntax allows you to create very compact anonymous functions.</p>
</td></tr>
<tr><td><code id="slidify_vec_+3A_...">...</code></td>
<td>
<p>Additional arguments passed on to the <code>.f</code> function.</p>
</td></tr>
<tr><td><code id="slidify_vec_+3A_.period">.period</code></td>
<td>
<p>The number of periods to include in the local rolling window.
This is effectively the &quot;window size&quot;.</p>
</td></tr>
<tr><td><code id="slidify_vec_+3A_.align">.align</code></td>
<td>
<p>One of &quot;center&quot;, &quot;left&quot; or &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="slidify_vec_+3A_.partial">.partial</code></td>
<td>
<p>Should the moving window be allowed to return partial (incomplete) windows instead of <code>NA</code> values.
Set to FALSE by default, but can be switched to TRUE to remove <code>NA</code>'s.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>slidify_vec()</code> function is a wrapper for <code>slider::slide_vec()</code> with parameters
simplified &quot;center&quot;, &quot;left&quot;, &quot;right&quot; alignment.
</p>
<p><strong>Vector Length In == Vector Length Out</strong>
</p>
<p><code>NA</code> values or <code>.partial</code> values
are always returned to ensure the length of the return vector
is the same length of the incoming vector. This ensures easier use with <code>dplyr::mutate()</code>.
</p>
<p><strong>Alignment</strong>
</p>
<p>Rolling functions generate <code>.period - 1</code> fewer values than the incoming vector.
Thus, the vector needs to be aligned. Alignment of the vector follows 3 types:
</p>

<ul>
<li> <p><strong>Center:</strong> <code>NA</code> or <code>.partial</code> values are divided and added to the beginning and
end of the series to &quot;Center&quot; the moving average.
This is common for de-noising operations. See also <code style="white-space: pre;">&#8288;[smooth_vec()]&#8288;</code> for LOESS without NA values.
</p>
</li>
<li> <p><strong>Left:</strong> <code>NA</code> or <code>.partial</code> values are added to the end to shift the series to the Left.
</p>
</li>
<li> <p><strong>Right:</strong> <code>NA</code> or <code>.partial</code> values are added to the beginning to shif the series to the Right. This is common in
Financial Applications such as moving average cross-overs.
</p>
</li></ul>

<p><strong>Partial Values</strong>
</p>

<ul>
<li><p> The advantage to using <code>.partial</code> values vs <code>NA</code> padding is that
the series can be filled (good for time-series de-noising operations).
</p>
</li>
<li><p> The downside to partial values is that the partials can become less stable
at the regions where incomplete windows are used.
</p>
</li></ul>

<p>If instability is not desirable for de-noising operations, a suitable alternative
is <code><a href="#topic+smooth_vec">smooth_vec()</a></code>, which implements local polynomial regression.
</p>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>References</h3>


<ul>
<li> <p><a href="https://slider.r-lib.org/">Slider R Package</a> by Davis Vaughan
</p>
</li></ul>



<h3>See Also</h3>

<p>Modeling and More Complex Rolling Operations:
</p>

<ul>
<li> <p><code><a href="#topic+step_slidify">step_slidify()</a></code> - Roll apply for <code>tidymodels</code> modeling
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_slidify">tk_augment_slidify()</a></code> - Add many rolling columns group-wise
</p>
</li>
<li> <p><code><a href="#topic+slidify">slidify()</a></code> - Turn any function into a rolling function. Great for
rolling cor, rolling regression, etc.
</p>
</li>
<li><p> For more complex rolling operations, check out the <code>slider</code> R package.
</p>
</li></ul>

<p>Vectorized Transformation Functions:
</p>

<ul>
<li><p> Box Cox Transformation: <code><a href="#topic+box_cox_vec">box_cox_vec()</a></code>
</p>
</li>
<li><p> Lag Transformation: <code><a href="#topic+lag_vec">lag_vec()</a></code>
</p>
</li>
<li><p> Differencing Transformation: <code><a href="#topic+diff_vec">diff_vec()</a></code>
</p>
</li>
<li><p> Rolling Window Transformation: <code><a href="#topic+slidify_vec">slidify_vec()</a></code>
</p>
</li>
<li><p> Loess Smoothing Transformation: <code><a href="#topic+smooth_vec">smooth_vec()</a></code>
</p>
</li>
<li><p> Fourier Series: <code><a href="#topic+fourier_vec">fourier_vec()</a></code>
</p>
</li>
<li><p> Missing Value Imputation for Time Series: <code><a href="#topic+ts_impute_vec">ts_impute_vec()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)

# Training Data
FB_tbl &lt;- FANG %&gt;%
    filter(symbol == "FB") %&gt;%
    select(symbol, date, adjusted)

# ---- FUNCTION FORMAT ----
# - The `.f = mean` function is used. Argument `na.rm = TRUE` is passed as ...
FB_tbl %&gt;%
    mutate(adjusted_30_ma = slidify_vec(
        .x      = adjusted,
        .period = 30,
        .f      = mean,
        na.rm   = TRUE,
        .align  = "center")) %&gt;%
        ggplot(aes(date, adjusted)) +
        geom_line() +
        geom_line(aes(y = adjusted_30_ma), color = "blue", na.rm = TRUE)

# ---- FORMULA FORMAT ----
# - Anonymous function `.f = ~ mean(., na.rm = TRUE)` is used
FB_tbl %&gt;%
    mutate(adjusted_30_ma = slidify_vec(
        .x      = adjusted,
        .period = 30,
        .f      = ~ mean(., na.rm = TRUE),
        .align  = "center")) %&gt;%
        ggplot(aes(date, adjusted)) +
        geom_line() +
        geom_line(aes(y = adjusted_30_ma), color = "blue", na.rm = TRUE)

# ---- PARTIAL VALUES ----
# - set `.partial = TRUE`
FB_tbl %&gt;%
    mutate(adjusted_30_ma = slidify_vec(
        .x       = adjusted,
        .f       = ~ mean(., na.rm = TRUE),
        .period  = 30,
        .align   = "center",
        .partial = TRUE)) %&gt;%
        ggplot(aes(date, adjusted)) +
        geom_line() +
        geom_line(aes(y = adjusted_30_ma), color = "blue")

# ---- Loess vs Moving Average ----
# - Loess: Using `.degree = 0` to make less flexible. Comparable to a moving average.

FB_tbl %&gt;%
    mutate(
        adjusted_loess_30 = smooth_vec(adjusted, period = 30, degree = 0),
        adjusted_ma_30    = slidify_vec(adjusted, .f = mean,
                                           .period = 30, .partial = TRUE)
    ) %&gt;%
    ggplot(aes(date, adjusted)) +
    geom_line() +
    geom_line(aes(y = adjusted_loess_30), color = "red") +
    geom_line(aes(y = adjusted_ma_30), color = "blue") +
    labs(title = "Loess vs Moving Average")



</code></pre>

<hr>
<h2 id='smooth_vec'>Smoothing Transformation using Loess</h2><span id='topic+smooth_vec'></span>

<h3>Description</h3>

<p><code>smooth_vec()</code> applies a LOESS transformation to a numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_vec(x, period = 30, span = NULL, degree = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_vec_+3A_x">x</code></td>
<td>
<p>A numeric vector to have a smoothing transformation applied.</p>
</td></tr>
<tr><td><code id="smooth_vec_+3A_period">period</code></td>
<td>
<p>The number of periods to include in the local smoothing.
Similar to window size for a moving average.
See details for an explanation <code>period</code> vs <code>span</code> specification.</p>
</td></tr>
<tr><td><code id="smooth_vec_+3A_span">span</code></td>
<td>
<p>The span is a percentage of data to be included
in the smoothing window. Period is preferred for shorter windows
to fix the window size.
See details for an explanation <code>period</code> vs <code>span</code> specification.</p>
</td></tr>
<tr><td><code id="smooth_vec_+3A_degree">degree</code></td>
<td>
<p>The degree of the polynomials to be used.
Accetable values (least to most flexible): 0, 1, 2.
Set to 2 by default for 2nd order polynomial (most flexible).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Benefits:</strong>
</p>

<ul>
<li><p> When using <code>period</code>, the effect is
<strong>similar to a moving average without creating missing values.</strong>
</p>
</li>
<li><p> When using <code>span</code>, the effect is to detect the trend in a series
<strong>using a percentage of the total number of observations.</strong>
</p>
</li></ul>

<p><strong>Loess Smoother Algorithm</strong>
This function is a simplified wrapper for the <code>stats::loess()</code>
with a modification to set a fixed <code>period</code> rather than a percentage of
data points via a <code>span</code>.
</p>
<p><strong>Why Period vs Span?</strong>
The <code>period</code> is fixed whereas the <code>span</code> changes as the number of observations change.
</p>
<p><strong>When to use Period?</strong>
The effect of using a <code>period</code> is similar to a Moving Average where the Window Size
is the <em><strong>Fixed Period</strong></em>. This helps when you are trying to smooth local trends.
If you want a 30-day moving average, specify <code>period = 30</code>.
</p>
<p><strong>When to use Span?</strong>
Span is easier to specify when you want a <em><strong>Long-Term Trendline</strong></em> where the
window size is unknown. You can specify <code>span = 0.75</code> to locally regress
using a window of 75% of the data.
</p>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>See Also</h3>

<p>Loess Modeling Functions:
</p>

<ul>
<li> <p><code><a href="#topic+step_smooth">step_smooth()</a></code> - Recipe for <code>tidymodels</code> workflow
</p>
</li></ul>

<p>Additional Vector Functions:
</p>

<ul>
<li><p> Box Cox Transformation: <code><a href="#topic+box_cox_vec">box_cox_vec()</a></code>
</p>
</li>
<li><p> Lag Transformation: <code><a href="#topic+lag_vec">lag_vec()</a></code>
</p>
</li>
<li><p> Differencing Transformation: <code><a href="#topic+diff_vec">diff_vec()</a></code>
</p>
</li>
<li><p> Rolling Window Transformation: <code><a href="#topic+slidify_vec">slidify_vec()</a></code>
</p>
</li>
<li><p> Loess Smoothing Transformation: <code><a href="#topic+smooth_vec">smooth_vec()</a></code>
</p>
</li>
<li><p> Fourier Series: <code><a href="#topic+fourier_vec">fourier_vec()</a></code>
</p>
</li>
<li><p> Missing Value Imputation for Time Series: <code><a href="#topic+ts_impute_vec">ts_impute_vec()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(ggplot2)

# Training Data
FB_tbl &lt;- FANG %&gt;%
    filter(symbol == "FB") %&gt;%
    select(symbol, date, adjusted)

# ---- PERIOD ----

FB_tbl %&gt;%
    mutate(adjusted_30 = smooth_vec(adjusted, period = 30, degree = 2)) %&gt;%
    ggplot(aes(date, adjusted)) +
    geom_line() +
    geom_line(aes(y = adjusted_30), color = "red")

# ---- SPAN ----

FB_tbl %&gt;%
    mutate(adjusted_30 = smooth_vec(adjusted, span = 0.75, degree = 2)) %&gt;%
    ggplot(aes(date, adjusted)) +
    geom_line() +
    geom_line(aes(y = adjusted_30), color = "red")

# ---- Loess vs Moving Average ----
# - Loess: Using `degree = 0` to make less flexible. Comperable to a moving average.

FB_tbl %&gt;%
    mutate(
        adjusted_loess_30 = smooth_vec(adjusted, period = 30, degree = 0),
        adjusted_ma_30    = slidify_vec(adjusted, .period = 30,
                                        .f = mean, .partial = TRUE)
    ) %&gt;%
    ggplot(aes(date, adjusted)) +
    geom_line() +
    geom_line(aes(y = adjusted_loess_30), color = "red") +
    geom_line(aes(y = adjusted_ma_30), color = "blue") +
    labs(title = "Loess vs Moving Average")



</code></pre>

<hr>
<h2 id='standardize_vec'>Standardize to Mean 0, Standard Deviation 1 (Center &amp; Scale)</h2><span id='topic+standardize_vec'></span><span id='topic+standardize_inv_vec'></span>

<h3>Description</h3>

<p>Standardization is commonly used to center and scale numeric features to prevent one from
dominating in algorithms that require data to be on the same scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardize_vec(x, mean = NULL, sd = NULL, silent = FALSE)

standardize_inv_vec(x, mean, sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardize_vec_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="standardize_vec_+3A_mean">mean</code></td>
<td>
<p>The mean used to invert the standardization</p>
</td></tr>
<tr><td><code id="standardize_vec_+3A_sd">sd</code></td>
<td>
<p>The standard deviation used to invert the standardization process.</p>
</td></tr>
<tr><td><code id="standardize_vec_+3A_silent">silent</code></td>
<td>
<p>Whether or not to report the automated <code>mean</code> and <code>sd</code> parameters as a message.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Standardization vs Normalization</strong>
</p>

<ul>
<li> <p><strong>Standardization</strong> refers to a transformation that reduces the range to
mean 0, standard deviation 1
</p>
</li>
<li> <p><strong>Normalization</strong> refers to a transformation that reduces the min-max range: (0, 1)
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a <code>numeric</code> vector with the standardization transformation applied.
</p>


<h3>See Also</h3>


<ul>
<li><p> Normalization/Standardization: <code><a href="#topic+standardize_vec">standardize_vec()</a></code>, <code><a href="#topic+normalize_vec">normalize_vec()</a></code>
</p>
</li>
<li><p> Box Cox Transformation: <code><a href="#topic+box_cox_vec">box_cox_vec()</a></code>
</p>
</li>
<li><p> Lag Transformation: <code><a href="#topic+lag_vec">lag_vec()</a></code>
</p>
</li>
<li><p> Differencing Transformation: <code><a href="#topic+diff_vec">diff_vec()</a></code>
</p>
</li>
<li><p> Rolling Window Transformation: <code><a href="#topic+slidify_vec">slidify_vec()</a></code>
</p>
</li>
<li><p> Loess Smoothing Transformation: <code><a href="#topic+smooth_vec">smooth_vec()</a></code>
</p>
</li>
<li><p> Fourier Series: <code><a href="#topic+fourier_vec">fourier_vec()</a></code>
</p>
</li>
<li><p> Missing Value Imputation for Time Series: <code><a href="#topic+ts_impute_vec">ts_impute_vec()</a></code>, <code><a href="#topic+ts_clean_vec">ts_clean_vec()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

d10_daily &lt;- m4_daily %&gt;% dplyr::filter(id == "D10")

# --- VECTOR ----

value_std &lt;- standardize_vec(d10_daily$value)
value     &lt;- standardize_inv_vec(value_std,
                                 mean = 2261.60682492582,
                                 sd   = 175.603721730477)

# --- MUTATE ----

m4_daily %&gt;%
    group_by(id) %&gt;%
    mutate(value_std = standardize_vec(value))

</code></pre>

<hr>
<h2 id='step_box_cox'>Box-Cox Transformation using Forecast Methods</h2><span id='topic+step_box_cox'></span><span id='topic+tidy.step_box_cox'></span>

<h3>Description</h3>

<p><code>step_box_cox</code> creates a <em>specification</em> of a recipe
step that will transform data using a Box-Cox
transformation. This function differs from
<code>recipes::step_BoxCox</code> by adding multiple methods
including Guerrero lambda optimization and handling for
negative data used in the Forecast R Package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_box_cox(
  recipe,
  ...,
  method = c("guerrero", "loglik"),
  limits = c(-1, 2),
  role = NA,
  trained = FALSE,
  lambdas_trained = NULL,
  skip = FALSE,
  id = rand_id("box_cox")
)

## S3 method for class 'step_box_cox'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_box_cox_+3A_recipe">recipe</code></td>
<td>
<p>A <code>recipe</code> object. The step will be added to the sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_box_cox_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which
variables are affected by the step. See <code><a href="recipes.html#topic+selections">selections()</a></code>
for more details. For the <code>tidy</code> method, these are not
currently used.</p>
</td></tr>
<tr><td><code id="step_box_cox_+3A_method">method</code></td>
<td>
<p>One of &quot;guerrero&quot; or &quot;loglik&quot;</p>
</td></tr>
<tr><td><code id="step_box_cox_+3A_limits">limits</code></td>
<td>
<p>A length 2 numeric vector defining the range to
compute the transformation parameter lambda.</p>
</td></tr>
<tr><td><code id="step_box_cox_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_box_cox_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_box_cox_+3A_lambdas_trained">lambdas_trained</code></td>
<td>
<p>A numeric vector of transformation values. This
is <code>NULL</code> until computed by <code>prep()</code>.</p>
</td></tr>
<tr><td><code id="step_box_cox_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the recipe
is baked by <code>bake.recipe()</code>? While all operations are baked when <code>prep.recipe()</code> is run,
some operations may not be able to be conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_box_cox_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
<tr><td><code id="step_box_cox_+3A_x">x</code></td>
<td>
<p>A <code>step_box_cox</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>step_box_cox()</code> function is designed specifically to handle time series
using methods implemented in the Forecast R Package.
</p>
<p><strong>Negative Data</strong>
</p>
<p>This function can be applied to Negative Data.
</p>
<p><strong>Lambda Optimization Methods</strong>
</p>
<p>This function uses 2 methods for optimizing the lambda selection
from the Forecast R Package:
</p>

<ol>
<li> <p><code>method = "guerrero"</code>: Guerrero's (1993) method is used, where lambda minimizes
the coefficient of variation for subseries of x.
</p>
</li>
<li> <p><code>method = loglik</code>: the value of lambda is chosen to maximize the profile
log likelihood of a linear model fitted to x. For non-seasonal data, a
linear time trend is fitted while for seasonal data, a linear time trend
with seasonal dummy variables is used.
</p>
</li></ol>



<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step
added to the sequence of existing steps (if any). For the
<code>tidy</code> method, a tibble with columns <code>terms</code> (the
selectors or variables selected) and <code>value</code> (the
lambda estimate).
</p>


<h3>References</h3>


<ol>
<li><p> Guerrero, V.M. (1993) Time-series analysis supported by power transformations. <em>Journal of Forecasting</em>, <strong>12</strong>, 3748.
</p>
</li>
<li><p> Box, G. E. P. and Cox, D. R. (1964) An analysis of transformations. <em>JRSS</em> B <strong>26</strong> 211246.
</p>
</li></ol>



<h3>See Also</h3>

<p>Time Series Analysis:
</p>

<ul>
<li><p> Engineered Features: <code><a href="#topic+step_timeseries_signature">step_timeseries_signature()</a></code>, <code><a href="#topic+step_holiday_signature">step_holiday_signature()</a></code>, <code><a href="#topic+step_fourier">step_fourier()</a></code>
</p>
</li>
<li><p> Diffs &amp; Lags <code><a href="#topic+step_diff">step_diff()</a></code>, <code>recipes::step_lag()</code>
</p>
</li>
<li><p> Smoothing: <code><a href="#topic+step_slidify">step_slidify()</a></code>, <code><a href="#topic+step_smooth">step_smooth()</a></code>
</p>
</li>
<li><p> Variance Reduction: <code><a href="#topic+step_box_cox">step_box_cox()</a></code>
</p>
</li>
<li><p> Imputation: <code><a href="#topic+step_ts_impute">step_ts_impute()</a></code>, <code><a href="#topic+step_ts_clean">step_ts_clean()</a></code>
</p>
</li>
<li><p> Padding: <code><a href="#topic+step_ts_pad">step_ts_pad()</a></code>
</p>
</li></ul>

<p>Transformations to reduce variance:
</p>

<ul>
<li> <p><code>recipes::step_log()</code> - Log transformation
</p>
</li>
<li> <p><code>recipes::step_sqrt()</code> - Square-Root Power Transformation
</p>
</li></ul>

<p>Recipe Setup and Application:
</p>

<ul>
<li> <p><code>recipes::recipe()</code>
</p>
</li>
<li> <p><code>recipes::prep()</code>
</p>
</li>
<li> <p><code>recipes::bake()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(recipes)

FANG_wide &lt;- FANG %&gt;%
    select(symbol, date, adjusted) %&gt;%
    tidyr::pivot_wider(names_from = symbol, values_from = adjusted)

recipe_box_cox &lt;- recipe(~ ., data = FANG_wide) %&gt;%
    step_box_cox(FB, AMZN, NFLX, GOOG) %&gt;%
    prep()

recipe_box_cox %&gt;% bake(FANG_wide)

recipe_box_cox %&gt;% tidy(1)

</code></pre>

<hr>
<h2 id='step_diff'>Create a differenced predictor</h2><span id='topic+step_diff'></span><span id='topic+tidy.step_diff'></span>

<h3>Description</h3>

<p><code>step_diff</code> creates a <em>specification</em> of a recipe step that
will add new columns of differenced data. Differenced data will
include NA values where a difference was induced.
These can be removed with <code><a href="recipes.html#topic+step_naomit">step_naomit()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_diff(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  lag = 1,
  difference = 1,
  log = FALSE,
  prefix = "diff_",
  columns = NULL,
  skip = FALSE,
  id = rand_id("diff")
)

## S3 method for class 'step_diff'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_diff_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the sequence of
operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_diff_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which variables are
affected by the step. See <code><a href="recipes.html#topic+selections">selections()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="step_diff_+3A_role">role</code></td>
<td>
<p>Defaults to &quot;predictor&quot;</p>
</td></tr>
<tr><td><code id="step_diff_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for preprocessing
have been estimated.</p>
</td></tr>
<tr><td><code id="step_diff_+3A_lag">lag</code></td>
<td>
<p>A vector of positive integers identifying which lags (how far back)
to be included in the differencing calculation.</p>
</td></tr>
<tr><td><code id="step_diff_+3A_difference">difference</code></td>
<td>
<p>The number of differences to perform.</p>
</td></tr>
<tr><td><code id="step_diff_+3A_log">log</code></td>
<td>
<p>Calculates log differences instead of differences.</p>
</td></tr>
<tr><td><code id="step_diff_+3A_prefix">prefix</code></td>
<td>
<p>A prefix for generated column names, default to &quot;diff_&quot;.</p>
</td></tr>
<tr><td><code id="step_diff_+3A_columns">columns</code></td>
<td>
<p>A character string of variable names that will
be populated (eventually) by the <code>terms</code> argument.</p>
</td></tr>
<tr><td><code id="step_diff_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code>bake.recipe()</code>? While all operations are baked
when <code>prep.recipe()</code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations</p>
</td></tr>
<tr><td><code id="step_diff_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
<tr><td><code id="step_diff_+3A_x">x</code></td>
<td>
<p>A <code>step_diff</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The step assumes that the data are already <em>in the proper sequential
order</em> for lagging.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the
new step added to the sequence of existing steps (if any).
</p>


<h3>See Also</h3>

<p>Time Series Analysis:
</p>

<ul>
<li><p> Engineered Features: <code><a href="#topic+step_timeseries_signature">step_timeseries_signature()</a></code>, <code><a href="#topic+step_holiday_signature">step_holiday_signature()</a></code>, <code><a href="#topic+step_fourier">step_fourier()</a></code>
</p>
</li>
<li><p> Diffs &amp; Lags <code><a href="#topic+step_diff">step_diff()</a></code>, <code><a href="recipes.html#topic+step_lag">recipes::step_lag()</a></code>
</p>
</li>
<li><p> Smoothing: <code><a href="#topic+step_slidify">step_slidify()</a></code>, <code><a href="#topic+step_smooth">step_smooth()</a></code>
</p>
</li>
<li><p> Variance Reduction: <code><a href="#topic+step_box_cox">step_box_cox()</a></code>
</p>
</li>
<li><p> Imputation: <code><a href="#topic+step_ts_impute">step_ts_impute()</a></code>, <code><a href="#topic+step_ts_clean">step_ts_clean()</a></code>
</p>
</li>
<li><p> Padding: <code><a href="#topic+step_ts_pad">step_ts_pad()</a></code>
</p>
</li></ul>

<p>Remove NA Values:
</p>

<ul>
<li> <p><code><a href="recipes.html#topic+step_naomit">recipes::step_naomit()</a></code>
</p>
</li></ul>

<p>Main Recipe Functions:
</p>

<ul>
<li> <p><code>recipes::recipe()</code>
</p>
</li>
<li> <p><code>recipes::prep()</code>
</p>
</li>
<li> <p><code>recipes::bake()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(recipes)


FANG_wide &lt;- FANG %&gt;%
    dplyr::select(symbol, date, adjusted) %&gt;%
    tidyr::pivot_wider(names_from = symbol, values_from = adjusted)


# Make and apply recipe ----

recipe_diff &lt;- recipe(~ ., data = FANG_wide) %&gt;%
  step_diff(FB, AMZN, NFLX, GOOG, lag = 1:3, difference = 1) %&gt;%
  prep()

recipe_diff %&gt;% bake(FANG_wide)


# Get information with tidy ----

recipe_diff %&gt;% tidy()

recipe_diff %&gt;% tidy(1)

</code></pre>

<hr>
<h2 id='step_fourier'>Fourier Features for Modeling Seasonality</h2><span id='topic+step_fourier'></span><span id='topic+tidy.step_fourier'></span>

<h3>Description</h3>

<p><code>step_fourier</code> creates a a <em>specification</em> of a recipe
step that will convert a Date or Date-time column into a Fourier
series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_fourier(
  recipe,
  ...,
  period,
  K,
  role = "predictor",
  trained = FALSE,
  columns = NULL,
  scale_factor = NULL,
  skip = FALSE,
  id = rand_id("fourier")
)

## S3 method for class 'step_fourier'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_fourier_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_fourier_+3A_...">...</code></td>
<td>
<p>A single column with class <code>Date</code> or
<code>POSIXct</code>. See <code><a href="recipes.html#topic+selections">recipes::selections()</a></code> for more details.
For the <code>tidy</code> method, these are not currently used.</p>
</td></tr>
<tr><td><code id="step_fourier_+3A_period">period</code></td>
<td>
<p>The numeric period for the oscillation frequency.
See details for examples of <code>period</code> specification.</p>
</td></tr>
<tr><td><code id="step_fourier_+3A_k">K</code></td>
<td>
<p>The number of orders to include for each sine/cosine
fourier series. More orders increase the number of fourier terms and
therefore the variance of the fitted
model at the expense of bias. See details for examples of <code>K</code> specification.</p>
</td></tr>
<tr><td><code id="step_fourier_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis
role should they be assigned?. By default, the function assumes
that the new variable columns created by the original variables
will be used as predictors in a model.</p>
</td></tr>
<tr><td><code id="step_fourier_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_fourier_+3A_columns">columns</code></td>
<td>
<p>A character string of variables that will be
used as inputs. This field is a placeholder and will be
populated once <code>recipes::prep()</code> is used.</p>
</td></tr>
<tr><td><code id="step_fourier_+3A_scale_factor">scale_factor</code></td>
<td>
<p>A factor for scaling the numeric index extracted
from the date or date-time feature. This is a placeholder and will be populated
once <code>recipes::prep()</code> is used.</p>
</td></tr>
<tr><td><code id="step_fourier_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the recipe is
baked by bake.recipe()? While all operations are baked when prep.recipe()
is run, some operations may not be able to be conducted on new data
(e.g. processing the outcome variable(s)). Care should be taken when
using skip = TRUE as it may affect the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_fourier_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
<tr><td><code id="step_fourier_+3A_x">x</code></td>
<td>
<p>A <code>step_fourier</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Date Variable</strong>
</p>
<p>Unlike other steps, <code>step_fourier</code> does <em>not</em>
remove the original date variables. <code><a href="recipes.html#topic+step_rm">recipes::step_rm()</a></code> can be
used for this purpose.
</p>
<p><strong>Period Specification</strong>
</p>
<p>The <code>period</code> argument is used to generate the distance between peaks
in the fourier sequence. The key is to line up the peaks with unique
seasonalities in the data.
</p>
<p>For Daily Data, typical period specifications are:
</p>

<ul>
<li><p> Yearly frequency is 365
</p>
</li>
<li><p> Quarterly frequency is 365 / 4 = 91.25
</p>
</li>
<li><p> Monthly frequency is 365 / 12 = 30.42
</p>
</li></ul>

<p><strong>K Specification</strong>
</p>
<p>The <code>K</code> argument specifies the maximum number of orders of Fourier terms.
Examples:
</p>

<ul>
<li><p> Specifying <code>period = 365</code> and <code>K = 1</code> will return a <code>cos365_K1</code> and <code>sin365_K1</code> fourier series
</p>
</li>
<li><p> Specifying <code>period = 365</code> and <code>K = 2</code> will return a <code>cos365_K1</code>, <code>cos365_K2</code>, <code>sin365_K1</code> and <code>sin365_K2</code>
sequence, which tends to increase the models ability to fit vs the <code>K = 1</code> specification
(at the expense of possibly overfitting).
</p>
</li></ul>

<p><strong>Multiple values of <code>period</code> and <code>K</code></strong>
</p>
<p>It's possible to specify multiple values of <code>period</code> in a single
step such as <code style="white-space: pre;">&#8288;step_fourier(period = c(91.25, 365), K = 2&#8288;</code>.
This returns 8 Fouriers series:
</p>

<ul>
<li> <p><code>cos91.25_K1</code>, <code>sin91.25_K1</code>, <code>cos91.25_K2</code>, <code>sin91.25_K2</code>
</p>
</li>
<li> <p><code>cos365_K1</code>, <code>sin365_K1</code>, <code>cos365_K2</code>, <code>sin365_K2</code>
</p>
</li></ul>



<h3>Value</h3>

<p>For <code>step_fourier</code>, an updated version of recipe with
the new step added to the sequence of existing steps (if any).
For the <code>tidy</code> method, a tibble with columns <code>terms</code>
(the selectors or variables selected), <code>value</code> (the feature
names).
</p>


<h3>See Also</h3>

<p>Time Series Analysis:
</p>

<ul>
<li><p> Engineered Features: <code><a href="#topic+step_timeseries_signature">step_timeseries_signature()</a></code>, <code><a href="#topic+step_holiday_signature">step_holiday_signature()</a></code>, <code><a href="#topic+step_fourier">step_fourier()</a></code>
</p>
</li>
<li><p> Diffs &amp; Lags <code><a href="#topic+step_diff">step_diff()</a></code>, <code>recipes::step_lag()</code>
</p>
</li>
<li><p> Smoothing: <code><a href="#topic+step_slidify">step_slidify()</a></code>, <code><a href="#topic+step_smooth">step_smooth()</a></code>
</p>
</li>
<li><p> Variance Reduction: <code><a href="#topic+step_box_cox">step_box_cox()</a></code>
</p>
</li>
<li><p> Imputation: <code><a href="#topic+step_ts_impute">step_ts_impute()</a></code>, <code><a href="#topic+step_ts_clean">step_ts_clean()</a></code>
</p>
</li>
<li><p> Padding: <code><a href="#topic+step_ts_pad">step_ts_pad()</a></code>
</p>
</li></ul>

<p>Main Recipe Functions:
</p>

<ul>
<li> <p><code>recipes::recipe()</code>
</p>
</li>
<li> <p><code>recipes::prep()</code>
</p>
</li>
<li> <p><code>recipes::bake()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(recipes)
library(dplyr)

FB_tbl &lt;- FANG %&gt;%
    filter(symbol == "FB") %&gt;%
    select(symbol, date, adjusted)

# Create a recipe object with a timeseries signature step
# - 252 Trade days per year
# - period = c(252/4, 252): Adds quarterly and yearly fourier series
# - K = 2: Adds 1st and 2nd fourier orders

rec_obj &lt;- recipe(adjusted ~ ., data = FB_tbl) %&gt;%
    step_fourier(date, period = c(252/4, 252), K = 2)

# View the recipe object
rec_obj

# Prepare the recipe object
prep(rec_obj)

# Bake the recipe object - Adds the Fourier Series
bake(prep(rec_obj), FB_tbl)

# Tidy shows which features have been added during the 1st step
#  in this case, step 1 is the step_timeseries_signature step
tidy(prep(rec_obj))
tidy(prep(rec_obj), number = 1)

</code></pre>

<hr>
<h2 id='step_holiday_signature'>Holiday Feature (Signature) Generator</h2><span id='topic+step_holiday_signature'></span><span id='topic+tidy.step_holiday_signature'></span>

<h3>Description</h3>

<p><code>step_holiday_signature</code> creates a a <em>specification</em> of a recipe
step that will convert date or date-time data into many
holiday features that can aid in machine learning with time-series data.
By default, many features are returned for different <em>holidays, locales, and stock exchanges</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_holiday_signature(
  recipe,
  ...,
  holiday_pattern = ".",
  locale_set = "all",
  exchange_set = "all",
  role = "predictor",
  trained = FALSE,
  columns = NULL,
  features = NULL,
  skip = FALSE,
  id = rand_id("holiday_signature")
)

## S3 method for class 'step_holiday_signature'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_holiday_signature_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_holiday_signature_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which
variables that will be used to create the new variables. The
selected variables should have class <code>Date</code> or
<code>POSIXct</code>. See <code><a href="recipes.html#topic+selections">recipes::selections()</a></code> for more details.
For the <code>tidy</code> method, these are not currently used.</p>
</td></tr>
<tr><td><code id="step_holiday_signature_+3A_holiday_pattern">holiday_pattern</code></td>
<td>
<p>A regular expression pattern to search the &quot;Holiday Set&quot;.</p>
</td></tr>
<tr><td><code id="step_holiday_signature_+3A_locale_set">locale_set</code></td>
<td>
<p>Return binary holidays based on locale.
One of: &quot;all&quot;, &quot;none&quot;, &quot;World&quot;, &quot;US&quot;, &quot;CA&quot;, &quot;GB&quot;, &quot;FR&quot;, &quot;IT&quot;, &quot;JP&quot;, &quot;CH&quot;, &quot;DE&quot;.</p>
</td></tr>
<tr><td><code id="step_holiday_signature_+3A_exchange_set">exchange_set</code></td>
<td>
<p>Return binary holidays based on Stock Exchange Calendars.
One of: &quot;all&quot;, &quot;none&quot;, &quot;NYSE&quot;, &quot;LONDON&quot;, &quot;NERC&quot;, &quot;TSX&quot;, &quot;ZURICH&quot;.</p>
</td></tr>
<tr><td><code id="step_holiday_signature_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis
role should they be assigned?. By default, the function assumes
that the new variable columns created by the original variables
will be used as predictors in a model.</p>
</td></tr>
<tr><td><code id="step_holiday_signature_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_holiday_signature_+3A_columns">columns</code></td>
<td>
<p>A character string of variables that will be
used as inputs. This field is a placeholder and will be
populated once <code>recipes::prep()</code> is used.</p>
</td></tr>
<tr><td><code id="step_holiday_signature_+3A_features">features</code></td>
<td>
<p>A character string of features that will be
generated. This field is a placeholder and will be
populated once <code>recipes::prep()</code> is used.</p>
</td></tr>
<tr><td><code id="step_holiday_signature_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the recipe is
baked by bake.recipe()? While all operations are baked when prep.recipe()
is run, some operations may not be able to be conducted on new data
(e.g. processing the outcome variable(s)). Care should be taken when
using skip = TRUE as it may affect the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_holiday_signature_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
<tr><td><code id="step_holiday_signature_+3A_x">x</code></td>
<td>
<p>A <code>step_holiday_signature</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Use Holiday Pattern and Feature Sets to Pare Down Features</strong>
By default, you're going to get A LOT of Features. This is a good thing because many
machine learning algorithms have regularization built in. But, in many cases you
will still want to reduce the number of <em>unnecessary features</em>. Here's how:
</p>

<ul>
<li> <p><strong>Holiday Pattern:</strong> This is a Regular Expression pattern that can be used to filter.
Try <code>holiday_pattern = "(US_Christ)|(US_Thanks)"</code> to return just Christmas and Thanksgiving
features.
</p>
</li>
<li> <p><strong>Locale Sets:</strong> This is a logical as to whether or not the locale has a holiday.
For locales outside of US you may want to combine multiple locales.
For example, <code>locale_set = c("World", "GB")</code> returns both World Holidays and Great Britain.
</p>
</li>
<li> <p><strong>Exchange Sets:</strong> This is a logical as to whether or not the <em>Business is off</em> due
to a holiday. Different Stock Exchanges are used as a proxy for business holiday calendars.
For example, <code>exchange_set = "NYSE"</code> returns business holidays for New York Stock Exchange.
</p>
</li></ul>

<p><strong>Removing Unnecessary Features</strong>
By default, many features are created automatically. Unnecessary features can
be removed using <code><a href="recipes.html#topic+step_rm">recipes::step_rm()</a></code> and <code><a href="recipes.html#topic+selections">recipes::selections()</a></code> for more details.
</p>


<h3>Value</h3>

<p>For <code>step_holiday_signature</code>, an updated version of recipe with
the new step added to the sequence of existing steps (if any).
For the <code>tidy</code> method, a tibble with columns <code>terms</code>
(the selectors or variables selected), <code>value</code> (the feature
names).
</p>


<h3>See Also</h3>

<p>Time Series Analysis:
</p>

<ul>
<li><p> Engineered Features: <code><a href="#topic+step_timeseries_signature">step_timeseries_signature()</a></code>, <code><a href="#topic+step_holiday_signature">step_holiday_signature()</a></code>, <code><a href="#topic+step_fourier">step_fourier()</a></code>
</p>
</li>
<li><p> Diffs &amp; Lags <code><a href="#topic+step_diff">step_diff()</a></code>, <code>recipes::step_lag()</code>
</p>
</li>
<li><p> Smoothing: <code><a href="#topic+step_slidify">step_slidify()</a></code>, <code><a href="#topic+step_smooth">step_smooth()</a></code>
</p>
</li>
<li><p> Variance Reduction: <code><a href="#topic+step_box_cox">step_box_cox()</a></code>
</p>
</li>
<li><p> Imputation: <code><a href="#topic+step_ts_impute">step_ts_impute()</a></code>, <code><a href="#topic+step_ts_clean">step_ts_clean()</a></code>
</p>
</li>
<li><p> Padding: <code><a href="#topic+step_ts_pad">step_ts_pad()</a></code>
</p>
</li></ul>

<p>Main Recipe Functions:
</p>

<ul>
<li> <p><code>recipes::recipe()</code>
</p>
</li>
<li> <p><code>recipes::prep()</code>
</p>
</li>
<li> <p><code>recipes::bake()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(recipes)
library(dplyr)

# Sample Data
dates_in_2017_tbl &lt;- tibble::tibble(
    index = tk_make_timeseries("2017-01-01", "2017-12-31", by = "day")
)

# Add US holidays and Non-Working Days due to Holidays
# - Physical Holidays are added with holiday pattern (individual) and locale_set
rec_holiday &lt;- recipe(~ ., dates_in_2017_tbl) %&gt;%
    step_holiday_signature(index,
                           holiday_pattern = "^US_",
                           locale_set      = "US",
                           exchange_set    = "NYSE")

# Not yet prep'ed - just returns parameters selected
rec_holiday %&gt;% tidy(1)

# Prep the recipe
rec_holiday_prep &lt;- prep(rec_holiday)

# Now prep'ed - returns new features that will be created
rec_holiday_prep %&gt;% tidy(1)

# Apply the recipe to add new holiday features!
bake(rec_holiday_prep, dates_in_2017_tbl)




</code></pre>

<hr>
<h2 id='step_log_interval'>Log Interval Transformation for Constrained Interval Forecasting</h2><span id='topic+step_log_interval'></span><span id='topic+tidy.step_log_interval'></span>

<h3>Description</h3>

<p><code>step_log_interval</code> creates a <em>specification</em> of a recipe
step that will transform data using a Log-Inerval
transformation. This function provides a <code>recipes</code> interface
for the <code>log_interval_vec()</code> transformation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_log_interval(
  recipe,
  ...,
  limit_lower = "auto",
  limit_upper = "auto",
  offset = 0,
  role = NA,
  trained = FALSE,
  limit_lower_trained = NULL,
  limit_upper_trained = NULL,
  skip = FALSE,
  id = rand_id("log_interval")
)

## S3 method for class 'step_log_interval'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_log_interval_+3A_recipe">recipe</code></td>
<td>
<p>A <code>recipe</code> object. The step will be added to the sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_log_interval_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which
variables are affected by the step. See <code><a href="recipes.html#topic+selections">selections()</a></code>
for more details. For the <code>tidy</code> method, these are not
currently used.</p>
</td></tr>
<tr><td><code id="step_log_interval_+3A_limit_lower">limit_lower</code></td>
<td>
<p>A lower limit. Must be less than the minimum value.
If set to &quot;auto&quot;, selects zero.</p>
</td></tr>
<tr><td><code id="step_log_interval_+3A_limit_upper">limit_upper</code></td>
<td>
<p>An upper limit. Must be greater than the maximum value.
If set to &quot;auto&quot;,  selects a value that is 10% greater than the maximum value.</p>
</td></tr>
<tr><td><code id="step_log_interval_+3A_offset">offset</code></td>
<td>
<p>An offset to include in the log transformation.
Useful when the data contains values less than or equal to zero.</p>
</td></tr>
<tr><td><code id="step_log_interval_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_log_interval_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_log_interval_+3A_limit_lower_trained">limit_lower_trained</code></td>
<td>
<p>A numeric vector of transformation values. This
is <code>NULL</code> until computed by <code>prep()</code>.</p>
</td></tr>
<tr><td><code id="step_log_interval_+3A_limit_upper_trained">limit_upper_trained</code></td>
<td>
<p>A numeric vector of transformation values. This
is <code>NULL</code> until computed by <code>prep()</code>.</p>
</td></tr>
<tr><td><code id="step_log_interval_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the recipe
is baked by <code>bake.recipe()</code>? While all operations are baked when <code>prep.recipe()</code> is run,
some operations may not be able to be conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_log_interval_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
<tr><td><code id="step_log_interval_+3A_x">x</code></td>
<td>
<p>A <code>step_log_interval</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>step_log_interval()</code> function is designed specifically to handle time series
using methods implemented in the Forecast R Package.
</p>
<p><strong>Positive Data</strong>
</p>
<p>If data includes values of zero, use <code>offset</code> to adjust the series to make the values positive.
</p>
<p><strong>Implementation</strong>
</p>
<p>Refer to the <code><a href="#topic+log_interval_vec">log_interval_vec()</a></code> function for the transformation implementation details.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step
added to the sequence of existing steps (if any). For the
<code>tidy</code> method, a tibble with columns <code>terms</code> (the
selectors or variables selected) and <code>value</code> (the
lambda estimate).
</p>


<h3>See Also</h3>

<p>Time Series Analysis:
</p>

<ul>
<li><p> Engineered Features: <code><a href="#topic+step_timeseries_signature">step_timeseries_signature()</a></code>, <code><a href="#topic+step_holiday_signature">step_holiday_signature()</a></code>, <code><a href="#topic+step_fourier">step_fourier()</a></code>
</p>
</li>
<li><p> Diffs &amp; Lags <code><a href="#topic+step_diff">step_diff()</a></code>, <code>recipes::step_lag()</code>
</p>
</li>
<li><p> Smoothing: <code><a href="#topic+step_slidify">step_slidify()</a></code>, <code><a href="#topic+step_smooth">step_smooth()</a></code>
</p>
</li>
<li><p> Variance Reduction: <code><a href="#topic+step_log_interval">step_log_interval()</a></code>
</p>
</li>
<li><p> Imputation: <code><a href="#topic+step_ts_impute">step_ts_impute()</a></code>, <code><a href="#topic+step_ts_clean">step_ts_clean()</a></code>
</p>
</li>
<li><p> Padding: <code><a href="#topic+step_ts_pad">step_ts_pad()</a></code>
</p>
</li></ul>

<p>Transformations to reduce variance:
</p>

<ul>
<li> <p><code>recipes::step_log()</code> - Log transformation
</p>
</li>
<li> <p><code>recipes::step_sqrt()</code> - Square-Root Power Transformation
</p>
</li></ul>

<p>Recipe Setup and Application:
</p>

<ul>
<li> <p><code>recipes::recipe()</code>
</p>
</li>
<li> <p><code>recipes::prep()</code>
</p>
</li>
<li> <p><code>recipes::bake()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(recipes)

FANG_wide &lt;- FANG %&gt;%
    select(symbol, date, adjusted) %&gt;%
    tidyr::pivot_wider(names_from = symbol, values_from = adjusted)

recipe_log_interval &lt;- recipe(~ ., data = FANG_wide) %&gt;%
    step_log_interval(FB, AMZN, NFLX, GOOG, offset = 1) %&gt;%
    prep()

recipe_log_interval %&gt;%
    bake(FANG_wide) %&gt;%
    tidyr::pivot_longer(-date) %&gt;%
    plot_time_series(date, value, name, .smooth = FALSE, .interactive = FALSE)

recipe_log_interval %&gt;% tidy(1)

</code></pre>

<hr>
<h2 id='step_slidify'>Slidify Rolling Window Transformation</h2><span id='topic+step_slidify'></span><span id='topic+tidy.step_slidify'></span>

<h3>Description</h3>

<p><code>step_slidify</code> creates a a <em>specification</em> of a recipe
step that will apply a function
to one or more a Numeric column(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_slidify(
  recipe,
  ...,
  period,
  .f,
  align = c("center", "left", "right"),
  partial = FALSE,
  names = NULL,
  role = "predictor",
  trained = FALSE,
  columns = NULL,
  f_name = NULL,
  skip = FALSE,
  id = rand_id("slidify")
)

## S3 method for class 'step_slidify'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_slidify_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_slidify_+3A_...">...</code></td>
<td>
<p>One or more numeric columns to be smoothed.
See <code><a href="recipes.html#topic+selections">recipes::selections()</a></code> for more details.
For the <code>tidy</code> method, these are not currently used.</p>
</td></tr>
<tr><td><code id="step_slidify_+3A_period">period</code></td>
<td>
<p>The number of periods to include in the local rolling window.
This is effectively the &quot;window size&quot;.</p>
</td></tr>
<tr><td><code id="step_slidify_+3A_.f">.f</code></td>
<td>
<p>A summary <strong>formula</strong> in one of the following formats:
</p>

<ul>
<li> <p><code>mean</code> with no arguments
</p>
</li>
<li> <p><code>function(x) mean(x, na.rm = TRUE)</code>
</p>
</li>
<li> <p><code>~ mean(.x, na.rm = TRUE)</code>, it is converted to a function.
</p>
</li></ul>
</td></tr>
<tr><td><code id="step_slidify_+3A_align">align</code></td>
<td>
<p>Rolling functions generate <code>period - 1</code> fewer values than the incoming vector.
Thus, the vector needs to be aligned. Alignment of the vector follows 3 types:
</p>

<ul>
<li> <p><strong>Center:</strong> <code>NA</code> or <code>.partial</code> values are divided and added to the beginning and
end of the series to &quot;Center&quot; the moving average.
This is common for de-noising operations. See also <code style="white-space: pre;">&#8288;[smooth_vec()]&#8288;</code> for LOESS without NA values.
</p>
</li>
<li> <p><strong>Left:</strong> <code>NA</code> or <code>.partial</code> values are added to the end to shift the series to the Left.
</p>
</li>
<li> <p><strong>Right:</strong> <code>NA</code> or <code>.partial</code> values are added to the beginning to shif the series to the Right. This is common in
Financial Applications such as moving average cross-overs.
</p>
</li></ul>
</td></tr>
<tr><td><code id="step_slidify_+3A_partial">partial</code></td>
<td>
<p>Should the moving window be allowed to return partial (incomplete) windows instead of NA values.
Set to FALSE by default, but can be switched to TRUE to remove NA's.</p>
</td></tr>
<tr><td><code id="step_slidify_+3A_names">names</code></td>
<td>
<p>An optional character string that is the same
length of the number of terms selected by <code>terms</code>. These will be
the names of the <strong>new columns</strong> created by the step.
</p>

<ul>
<li><p> If <code>NULL</code>, existing columns are transformed.
</p>
</li>
<li><p> If not <code>NULL</code>, new columns will be created.
</p>
</li></ul>
</td></tr>
<tr><td><code id="step_slidify_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis
role should they be assigned?. By default, the function assumes
that the new variable columns created by the original variables
will be used as predictors in a model.</p>
</td></tr>
<tr><td><code id="step_slidify_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_slidify_+3A_columns">columns</code></td>
<td>
<p>A character string of variables that will be
used as inputs. This field is a placeholder and will be
populated once <code>recipes::prep()</code> is used.</p>
</td></tr>
<tr><td><code id="step_slidify_+3A_f_name">f_name</code></td>
<td>
<p>A character string for the function being applied.
This field is a placeholder and will be populated during the <code>tidy()</code> step.</p>
</td></tr>
<tr><td><code id="step_slidify_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the recipe is
baked by bake.recipe()? While all operations are baked when prep.recipe()
is run, some operations may not be able to be conducted on new data
(e.g. processing the outcome variable(s)). Care should be taken when
using skip = TRUE as it may affect the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_slidify_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
<tr><td><code id="step_slidify_+3A_x">x</code></td>
<td>
<p>A <code>step_slidify</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Alignment</strong>
</p>
<p>Rolling functions generate <code>period - 1</code> fewer values than the incoming vector.
Thus, the vector needs to be aligned. Alignment of the vector follows 3 types:
</p>

<ul>
<li> <p><strong>Center:</strong> <code>NA</code> or <code>partial</code> values are divided and added to the beginning and
end of the series to &quot;Center&quot; the moving average.
This is common for de-noising operations. See also <code style="white-space: pre;">&#8288;[smooth_vec()]&#8288;</code> for LOESS without NA values.
</p>
</li>
<li> <p><strong>Left:</strong> <code>NA</code> or <code>partial</code> values are added to the end to shift the series to the Left.
</p>
</li>
<li> <p><strong>Right:</strong> <code>NA</code> or <code>partial</code> values are added to the beginning to shif the series to the Right. This is common in
Financial Applications such as moving average cross-overs.
</p>
</li></ul>

<p><strong>Partial Values</strong>
</p>

<ul>
<li><p> The advantage to using <code>partial</code> values vs <code>NA</code> padding is that
the series can be filled (good for time-series de-noising operations).
</p>
</li>
<li><p> The downside to partial values is that the partials can become less stable
at the regions where incomplete windows are used.
</p>
</li></ul>

<p>If instability is not desirable for de-noising operations, a suitable alternative
is <code><a href="#topic+step_smooth">step_smooth()</a></code>, which implements local polynomial regression.
</p>


<h3>Value</h3>

<p>For <code>step_slidify</code>, an updated version of recipe with
the new step added to the sequence of existing steps (if any).
For the <code>tidy</code> method, a tibble with columns <code>terms</code>
(the selectors or variables selected), <code>value</code> (the feature
names).
</p>


<h3>See Also</h3>

<p>Time Series Analysis:
</p>

<ul>
<li><p> Engineered Features: <code><a href="#topic+step_timeseries_signature">step_timeseries_signature()</a></code>, <code><a href="#topic+step_holiday_signature">step_holiday_signature()</a></code>, <code><a href="#topic+step_fourier">step_fourier()</a></code>
</p>
</li>
<li><p> Diffs &amp; Lags <code><a href="#topic+step_diff">step_diff()</a></code>, <code>recipes::step_lag()</code>
</p>
</li>
<li><p> Smoothing: <code><a href="#topic+step_slidify">step_slidify()</a></code>, <code><a href="#topic+step_smooth">step_smooth()</a></code>
</p>
</li>
<li><p> Variance Reduction: <code><a href="#topic+step_box_cox">step_box_cox()</a></code>
</p>
</li>
<li><p> Imputation: <code><a href="#topic+step_ts_impute">step_ts_impute()</a></code>, <code><a href="#topic+step_ts_clean">step_ts_clean()</a></code>
</p>
</li>
<li><p> Padding: <code><a href="#topic+step_ts_pad">step_ts_pad()</a></code>
</p>
</li></ul>

<p>Main Recipe Functions:
</p>

<ul>
<li> <p><code>recipes::recipe()</code>
</p>
</li>
<li> <p><code>recipes::prep()</code>
</p>
</li>
<li> <p><code>recipes::bake()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(recipes)
library(dplyr)
library(ggplot2)

# Training Data
FB_tbl &lt;- FANG %&gt;%
    filter(symbol == "FB") %&gt;%
    select(symbol, date, adjusted)

# New Data - Make some fake new data next 90 time stamps
new_data &lt;- FB_tbl %&gt;%
    tail(90) %&gt;%
    mutate(date = date %&gt;% tk_make_future_timeseries(length_out = 90))

# OVERWRITE EXISTING COLUMNS -----

# Create a recipe object with a step_slidify
rec_ma_50 &lt;- recipe(adjusted ~ ., data = FB_tbl) %&gt;%
    step_slidify(adjusted, period = 50, .f = ~ mean(.x))

# Bake the recipe object - Applies the Moving Average Transformation
training_data_baked &lt;- bake(prep(rec_ma_50), FB_tbl)

# Apply to New Data
new_data_baked &lt;- bake(prep(rec_ma_50), new_data)

# Visualize effect
training_data_baked %&gt;%
    ggplot(aes(date, adjusted)) +
    geom_line() +
    geom_line(color = "red", data = new_data_baked)

# ---- NEW COLUMNS ----
# Use the `names` argument to create new columns instead of overwriting existing

rec_ma_30_names &lt;- recipe(adjusted ~ ., data = FB_tbl) %&gt;%
    step_slidify(adjusted, period = 30, .f = mean, names = "adjusted_ma_30")

bake(prep(rec_ma_30_names), FB_tbl) %&gt;%
    ggplot(aes(date, adjusted)) +
    geom_line(alpha = 0.5) +
    geom_line(aes(y = adjusted_ma_30), color = "red", size = 1)



</code></pre>

<hr>
<h2 id='step_slidify_augment'>Slidify Rolling Window Transformation (Augmented Version)</h2><span id='topic+step_slidify_augment'></span><span id='topic+tidy.step_slidify_augment'></span>

<h3>Description</h3>

<p><code>step_slidify_augment</code> creates a a <em>specification</em> of a recipe
step that will &quot;augment&quot; (add multiple new columns) that have had a sliding function applied.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_slidify_augment(
  recipe,
  ...,
  period,
  .f,
  align = c("center", "left", "right"),
  partial = FALSE,
  prefix = "slidify_",
  role = "predictor",
  trained = FALSE,
  columns = NULL,
  f_name = NULL,
  skip = FALSE,
  id = rand_id("slidify_augment")
)

## S3 method for class 'step_slidify_augment'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_slidify_augment_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_slidify_augment_+3A_...">...</code></td>
<td>
<p>One or more numeric columns to be smoothed.
See <code><a href="recipes.html#topic+selections">recipes::selections()</a></code> for more details.
For the <code>tidy</code> method, these are not currently used.</p>
</td></tr>
<tr><td><code id="step_slidify_augment_+3A_period">period</code></td>
<td>
<p>The number of periods to include in the local rolling window.
This is effectively the &quot;window size&quot;.</p>
</td></tr>
<tr><td><code id="step_slidify_augment_+3A_.f">.f</code></td>
<td>
<p>A summary <strong>formula</strong> in one of the following formats:
</p>

<ul>
<li> <p><code>mean</code> with no arguments
</p>
</li>
<li> <p><code>function(x) mean(x, na.rm = TRUE)</code>
</p>
</li>
<li> <p><code>~ mean(.x, na.rm = TRUE)</code>, it is converted to a function.
</p>
</li></ul>
</td></tr>
<tr><td><code id="step_slidify_augment_+3A_align">align</code></td>
<td>
<p>Rolling functions generate <code>period - 1</code> fewer values than the incoming vector.
Thus, the vector needs to be aligned. Alignment of the vector follows 3 types:
</p>

<ul>
<li> <p><strong>Center:</strong> <code>NA</code> or <code>.partial</code> values are divided and added to the beginning and
end of the series to &quot;Center&quot; the moving average.
This is common for de-noising operations. See also <code style="white-space: pre;">&#8288;[smooth_vec()]&#8288;</code> for LOESS without NA values.
</p>
</li>
<li> <p><strong>Left:</strong> <code>NA</code> or <code>.partial</code> values are added to the end to shift the series to the Left.
</p>
</li>
<li> <p><strong>Right:</strong> <code>NA</code> or <code>.partial</code> values are added to the beginning to shif the series to the Right. This is common in
Financial Applications such as moving average cross-overs.
</p>
</li></ul>
</td></tr>
<tr><td><code id="step_slidify_augment_+3A_partial">partial</code></td>
<td>
<p>Should the moving window be allowed to return partial (incomplete) windows instead of NA values.
Set to FALSE by default, but can be switched to TRUE to remove NA's.</p>
</td></tr>
<tr><td><code id="step_slidify_augment_+3A_prefix">prefix</code></td>
<td>
<p>A prefix for generated column names, default to &quot;slidify_&quot;.</p>
</td></tr>
<tr><td><code id="step_slidify_augment_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis
role should they be assigned?. By default, the function assumes
that the new variable columns created by the original variables
will be used as predictors in a model.</p>
</td></tr>
<tr><td><code id="step_slidify_augment_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_slidify_augment_+3A_columns">columns</code></td>
<td>
<p>A character string of variable names that will
be populated (eventually) by the <code>terms</code> argument.</p>
</td></tr>
<tr><td><code id="step_slidify_augment_+3A_f_name">f_name</code></td>
<td>
<p>A character string for the function being applied.
This field is a placeholder and will be populated during the <code>tidy()</code> step.</p>
</td></tr>
<tr><td><code id="step_slidify_augment_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the
recipe is baked by <code>bake.recipe()</code>? While all operations are baked
when <code>prep.recipe()</code> is run, some operations may not be able to be
conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect
the computations for subsequent operations</p>
</td></tr>
<tr><td><code id="step_slidify_augment_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
<tr><td><code id="step_slidify_augment_+3A_x">x</code></td>
<td>
<p>A <code>step_slidify_augment</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Alignment</strong>
</p>
<p>Rolling functions generate <code>period - 1</code> fewer values than the incoming vector.
Thus, the vector needs to be aligned. Alignment of the vector follows 3 types:
</p>

<ul>
<li> <p><strong>Center:</strong> <code>NA</code> or <code>partial</code> values are divided and added to the beginning and
end of the series to &quot;Center&quot; the moving average.
This is common for de-noising operations. See also <code style="white-space: pre;">&#8288;[smooth_vec()]&#8288;</code> for LOESS without NA values.
</p>
</li>
<li> <p><strong>Left:</strong> <code>NA</code> or <code>partial</code> values are added to the end to shift the series to the Left.
</p>
</li>
<li> <p><strong>Right:</strong> <code>NA</code> or <code>partial</code> values are added to the beginning to shif the series to the Right. This is common in
Financial Applications such as moving average cross-overs.
</p>
</li></ul>

<p><strong>Partial Values</strong>
</p>

<ul>
<li><p> The advantage to using <code>partial</code> values vs <code>NA</code> padding is that
the series can be filled (good for time-series de-noising operations).
</p>
</li>
<li><p> The downside to partial values is that the partials can become less stable
at the regions where incomplete windows are used.
</p>
</li></ul>

<p>If instability is not desirable for de-noising operations, a suitable alternative
is <code><a href="#topic+step_smooth">step_smooth()</a></code>, which implements local polynomial regression.
</p>


<h3>Value</h3>

<p>For <code>step_slidify_augment</code>, an updated version of recipe with
the new step added to the sequence of existing steps (if any).
For the <code>tidy</code> method, a tibble with columns <code>terms</code>
(the selectors or variables selected), <code>value</code> (the feature
names).
</p>


<h3>See Also</h3>

<p>Time Series Analysis:
</p>

<ul>
<li><p> Engineered Features: <code><a href="#topic+step_timeseries_signature">step_timeseries_signature()</a></code>, <code><a href="#topic+step_holiday_signature">step_holiday_signature()</a></code>, <code><a href="#topic+step_fourier">step_fourier()</a></code>
</p>
</li>
<li><p> Diffs &amp; Lags <code><a href="#topic+step_diff">step_diff()</a></code>, <code>recipes::step_lag()</code>
</p>
</li>
<li><p> Smoothing: <code><a href="#topic+step_slidify">step_slidify()</a></code>, <code><a href="#topic+step_smooth">step_smooth()</a></code>
</p>
</li>
<li><p> Variance Reduction: <code><a href="#topic+step_box_cox">step_box_cox()</a></code>
</p>
</li>
<li><p> Imputation: <code><a href="#topic+step_ts_impute">step_ts_impute()</a></code>, <code><a href="#topic+step_ts_clean">step_ts_clean()</a></code>
</p>
</li>
<li><p> Padding: <code><a href="#topic+step_ts_pad">step_ts_pad()</a></code>
</p>
</li></ul>

<p>Main Recipe Functions:
</p>

<ul>
<li> <p><code>recipes::recipe()</code>
</p>
</li>
<li> <p><code>recipes::prep()</code>
</p>
</li>
<li> <p><code>recipes::bake()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># library(tidymodels)
library(dplyr)
library(recipes)
library(parsnip)

m750 &lt;- m4_monthly %&gt;%
    filter(id == "M750") %&gt;%
    mutate(value_2 = value / 2)

m750_splits &lt;- time_series_split(m750, assess = "2 years", cumulative = TRUE)

# Make a recipe
recipe_spec &lt;- recipe(value ~ date + value_2, rsample::training(m750_splits)) %&gt;%
    step_slidify_augment(
        value, value_2,
        period = c(6, 12, 24),
        .f = ~ mean(.x),
        align = "center",
        partial = FALSE
    )

recipe_spec %&gt;% prep() %&gt;% juice()

bake(prep(recipe_spec), rsample::testing(m750_splits))


</code></pre>

<hr>
<h2 id='step_smooth'>Smoothing Transformation using Loess</h2><span id='topic+step_smooth'></span><span id='topic+tidy.step_smooth'></span>

<h3>Description</h3>

<p><code>step_smooth</code> creates a a <em>specification</em> of a recipe
step that will apply local polynomial regression
to one or more a Numeric column(s). The effect is smoothing the time series
<strong>similar to a moving average without creating missing values or using partial smoothing.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_smooth(
  recipe,
  ...,
  period = 30,
  span = NULL,
  degree = 2,
  names = NULL,
  role = "predictor",
  trained = FALSE,
  columns = NULL,
  skip = FALSE,
  id = rand_id("smooth")
)

## S3 method for class 'step_smooth'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_smooth_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_smooth_+3A_...">...</code></td>
<td>
<p>One or more numeric columns to be smoothed.
See <code><a href="recipes.html#topic+selections">recipes::selections()</a></code> for more details.
For the <code>tidy</code> method, these are not currently used.</p>
</td></tr>
<tr><td><code id="step_smooth_+3A_period">period</code></td>
<td>
<p>The number of periods to include in the local smoothing.
Similar to window size for a moving average.
See details for an explanation <code>period</code> vs <code>span</code> specification.</p>
</td></tr>
<tr><td><code id="step_smooth_+3A_span">span</code></td>
<td>
<p>The span is a percentage of data to be included
in the smoothing window. Period is preferred for shorter windows
to fix the window size.
See details for an explanation <code>period</code> vs <code>span</code> specification.</p>
</td></tr>
<tr><td><code id="step_smooth_+3A_degree">degree</code></td>
<td>
<p>The degree of the polynomials to be used.
Set to 2 by default for 2nd order polynomial.</p>
</td></tr>
<tr><td><code id="step_smooth_+3A_names">names</code></td>
<td>
<p>An optional character string that is the same
length of the number of terms selected by <code>terms</code>. These will be
the names of the <strong>new columns</strong> created by the step.
</p>

<ul>
<li><p> If <code>NULL</code>, existing columns are transformed.
</p>
</li>
<li><p> If not <code>NULL</code>, new columns will be created.
</p>
</li></ul>
</td></tr>
<tr><td><code id="step_smooth_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis
role should they be assigned?. By default, the function assumes
that the new variable columns created by the original variables
will be used as predictors in a model.</p>
</td></tr>
<tr><td><code id="step_smooth_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_smooth_+3A_columns">columns</code></td>
<td>
<p>A character string of variables that will be
used as inputs. This field is a placeholder and will be
populated once <code>recipes::prep()</code> is used.</p>
</td></tr>
<tr><td><code id="step_smooth_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the recipe is
baked by bake.recipe()? While all operations are baked when prep.recipe()
is run, some operations may not be able to be conducted on new data
(e.g. processing the outcome variable(s)). Care should be taken when
using skip = TRUE as it may affect the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_smooth_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
<tr><td><code id="step_smooth_+3A_x">x</code></td>
<td>
<p>A <code>step_smooth</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Smoother Algorithm</strong>
This function is a <code>recipe</code> specification that wraps the <code>stats::loess()</code>
with a modification to set a fixed <code>period</code> rather than a percentage of
data points via a <code>span</code>.
</p>
<p><strong>Why Period vs Span?</strong>
The <code>period</code> is fixed whereas the <code>span</code> changes as the number of observations change.
</p>
<p><strong>When to use Period?</strong>
The effect of using a <code>period</code> is similar to a Moving Average where the Window Size
is the <em><strong>Fixed Period</strong></em>. This helps when you are trying to smooth local trends.
If you want a 30-day moving average, specify <code>period = 30</code>.
</p>
<p><strong>When to use Span?</strong>
Span is easier to specify when you want a <em><strong>Long-Term Trendline</strong></em> where the
window size is unknown. You can specify <code>span = 0.75</code> to locally regress
using a window of 75% of the data.
</p>
<p><strong>Warning - Using Span with New Data</strong>
When using span on New Data, the number of observations is likely different than
what you trained with. This means the trendline / smoother can be vastly different
than the smoother you trained with.
</p>
<p><strong>Solution to Span with New Data</strong>
Don't use <code>span</code>. Rather, use <code>period</code> to fix the window size.
This ensures that new data includes the same number of observations in the local
polynomial regression (loess) as the training data.
</p>


<h3>Value</h3>

<p>For <code>step_smooth</code>, an updated version of recipe with
the new step added to the sequence of existing steps (if any).
For the <code>tidy</code> method, a tibble with columns <code>terms</code>
(the selectors or variables selected), <code>value</code> (the feature
names).
</p>


<h3>See Also</h3>

<p>Time Series Analysis:
</p>

<ul>
<li><p> Engineered Features: <code><a href="#topic+step_timeseries_signature">step_timeseries_signature()</a></code>, <code><a href="#topic+step_holiday_signature">step_holiday_signature()</a></code>, <code><a href="#topic+step_fourier">step_fourier()</a></code>
</p>
</li>
<li><p> Diffs &amp; Lags <code><a href="#topic+step_diff">step_diff()</a></code>, <code>recipes::step_lag()</code>
</p>
</li>
<li><p> Smoothing: <code><a href="#topic+step_slidify">step_slidify()</a></code>, <code><a href="#topic+step_smooth">step_smooth()</a></code>
</p>
</li>
<li><p> Variance Reduction: <code><a href="#topic+step_box_cox">step_box_cox()</a></code>
</p>
</li>
<li><p> Imputation: <code><a href="#topic+step_ts_impute">step_ts_impute()</a></code>, <code><a href="#topic+step_ts_clean">step_ts_clean()</a></code>
</p>
</li>
<li><p> Padding: <code><a href="#topic+step_ts_pad">step_ts_pad()</a></code>
</p>
</li></ul>

<p>Main Recipe Functions:
</p>

<ul>
<li> <p><code>recipes::recipe()</code>
</p>
</li>
<li> <p><code>recipes::prep()</code>
</p>
</li>
<li> <p><code>recipes::bake()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(recipes)
library(dplyr)
library(ggplot2)

# Training Data
FB_tbl &lt;- FANG %&gt;%
    filter(symbol == "FB") %&gt;%
    select(symbol, date, adjusted)

# New Data - Make some fake new data next 90 time stamps
new_data &lt;- FB_tbl %&gt;%
    tail(90) %&gt;%
    mutate(date = date %&gt;% tk_make_future_timeseries(length_out = 90))

# ---- PERIOD ----

# Create a recipe object with a step_smooth()
rec_smooth_period &lt;- recipe(adjusted ~ ., data = FB_tbl) %&gt;%
    step_smooth(adjusted, period = 30)

# Bake the recipe object - Applies the Loess Transformation
training_data_baked &lt;- bake(prep(rec_smooth_period), FB_tbl)

# "Period" Effect on New Data
new_data_baked &lt;- bake(prep(rec_smooth_period), new_data)

# Smoother's fit on new data is very similar because
# 30 days are used in the new data regardless of the new data being 90 days
training_data_baked %&gt;%
    ggplot(aes(date, adjusted)) +
    geom_line() +
    geom_line(color = "red", data = new_data_baked)

# ---- SPAN ----

# Create a recipe object with a step_smooth
rec_smooth_span &lt;- recipe(adjusted ~ ., data = FB_tbl) %&gt;%
    step_smooth(adjusted, span = 0.03)

# Bake the recipe object - Applies the Loess Transformation
training_data_baked &lt;- bake(prep(rec_smooth_span), FB_tbl)

# "Period" Effect on New Data
new_data_baked &lt;- bake(prep(rec_smooth_span), new_data)

# Smoother's fit is not the same using span because new data is only 90 days
# and 0.03 x 90 = 2.7 days
training_data_baked %&gt;%
    ggplot(aes(date, adjusted)) +
    geom_line() +
    geom_line(color = "red", data = new_data_baked)

# ---- NEW COLUMNS ----
# Use the `names` argument to create new columns instead of overwriting existing

rec_smooth_names &lt;- recipe(adjusted ~ ., data = FB_tbl) %&gt;%
    step_smooth(adjusted, period = 30, names = "adjusted_smooth_30") %&gt;%
    step_smooth(adjusted, period = 180, names = "adjusted_smooth_180") %&gt;%
    step_smooth(adjusted, span = 0.75, names = "long_term_trend")

bake(prep(rec_smooth_names), FB_tbl) %&gt;%
    ggplot(aes(date, adjusted)) +
    geom_line(alpha = 0.5) +
    geom_line(aes(y = adjusted_smooth_30), color = "red", size = 1) +
    geom_line(aes(y = adjusted_smooth_180), color = "blue", size = 1) +
    geom_line(aes(y = long_term_trend), color = "orange", size = 1)



</code></pre>

<hr>
<h2 id='step_timeseries_signature'>Time Series Feature (Signature) Generator</h2><span id='topic+step_timeseries_signature'></span><span id='topic+tidy.step_timeseries_signature'></span>

<h3>Description</h3>

<p><code>step_timeseries_signature</code> creates a a <em>specification</em> of a recipe
step that will convert date or date-time data into many
features that can aid in machine learning with time-series data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_timeseries_signature(
  recipe,
  ...,
  role = "predictor",
  trained = FALSE,
  columns = NULL,
  skip = FALSE,
  id = rand_id("timeseries_signature")
)

## S3 method for class 'step_timeseries_signature'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_timeseries_signature_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_timeseries_signature_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which
variables that will be used to create the new variables. The
selected variables should have class <code>Date</code> or
<code>POSIXct</code>. See <code><a href="recipes.html#topic+selections">recipes::selections()</a></code> for more details.
For the <code>tidy</code> method, these are not currently used.</p>
</td></tr>
<tr><td><code id="step_timeseries_signature_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis
role should they be assigned?. By default, the function assumes
that the new variable columns created by the original variables
will be used as predictors in a model.</p>
</td></tr>
<tr><td><code id="step_timeseries_signature_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_timeseries_signature_+3A_columns">columns</code></td>
<td>
<p>A character string of variables that will be
used as inputs. This field is a placeholder and will be
populated once <code>recipes::prep()</code> is used.</p>
</td></tr>
<tr><td><code id="step_timeseries_signature_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the recipe is
baked by bake.recipe()? While all operations are baked when prep.recipe()
is run, some operations may not be able to be conducted on new data
(e.g. processing the outcome variable(s)). Care should be taken when
using skip = TRUE as it may affect the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_timeseries_signature_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
<tr><td><code id="step_timeseries_signature_+3A_x">x</code></td>
<td>
<p>A <code>step_timeseries_signature</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Date Variable</strong>
Unlike other steps, <code>step_timeseries_signature</code> does <em>not</em>
remove the original date variables. <code><a href="recipes.html#topic+step_rm">recipes::step_rm()</a></code> can be
used for this purpose.
</p>
<p><strong>Scaling index.num</strong>
The <code>index.num</code> feature created has a large magnitude (number of seconds since 1970-01-01).
It's a good idea to scale and center this feature (e.g. use  <code><a href="recipes.html#topic+step_normalize">recipes::step_normalize()</a></code>).
</p>
<p><strong>Removing Unnecessary Features</strong>
By default, many features are created automatically. Unnecessary features can
be removed using <code><a href="recipes.html#topic+step_rm">recipes::step_rm()</a></code>.
</p>


<h3>Value</h3>

<p>For <code>step_timeseries_signature</code>, an updated version of recipe with
the new step added to the sequence of existing steps (if any).
For the <code>tidy</code> method, a tibble with columns <code>terms</code>
(the selectors or variables selected), <code>value</code> (the feature
names).
</p>


<h3>See Also</h3>

<p>Time Series Analysis:
</p>

<ul>
<li><p> Engineered Features: <code><a href="#topic+step_timeseries_signature">step_timeseries_signature()</a></code>, <code><a href="#topic+step_holiday_signature">step_holiday_signature()</a></code>, <code><a href="#topic+step_fourier">step_fourier()</a></code>
</p>
</li>
<li><p> Diffs &amp; Lags <code><a href="#topic+step_diff">step_diff()</a></code>, <code>recipes::step_lag()</code>
</p>
</li>
<li><p> Smoothing: <code><a href="#topic+step_slidify">step_slidify()</a></code>, <code><a href="#topic+step_smooth">step_smooth()</a></code>
</p>
</li>
<li><p> Variance Reduction: <code><a href="#topic+step_box_cox">step_box_cox()</a></code>
</p>
</li>
<li><p> Imputation: <code><a href="#topic+step_ts_impute">step_ts_impute()</a></code>, <code><a href="#topic+step_ts_clean">step_ts_clean()</a></code>
</p>
</li>
<li><p> Padding: <code><a href="#topic+step_ts_pad">step_ts_pad()</a></code>
</p>
</li></ul>

<p>Main Recipe Functions:
</p>

<ul>
<li> <p><code>recipes::recipe()</code>
</p>
</li>
<li> <p><code>recipes::prep()</code>
</p>
</li>
<li> <p><code>recipes::bake()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(recipes)
library(dplyr)

FB_tbl &lt;- FANG %&gt;% dplyr::filter(symbol == "FB")

# Create a recipe object with a timeseries signature step
rec_obj &lt;- recipe(adjusted ~ ., data = FB_tbl) %&gt;%
    step_timeseries_signature(date)

# View the recipe object
rec_obj

# Prepare the recipe object
prep(rec_obj)

# Bake the recipe object - Adds the Time Series Signature
bake(prep(rec_obj), FB_tbl)

# Tidy shows which features have been added during the 1st step
#  in this case, step 1 is the step_timeseries_signature step
tidy(rec_obj)
tidy(rec_obj, number = 1)



</code></pre>

<hr>
<h2 id='step_ts_clean'>Clean Outliers and Missing Data for Time Series</h2><span id='topic+step_ts_clean'></span><span id='topic+tidy.step_ts_clean'></span>

<h3>Description</h3>

<p><code>step_ts_clean</code> creates a <em>specification</em> of a recipe
step that will clean outliers and impute time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_ts_clean(
  recipe,
  ...,
  period = 1,
  lambda = "auto",
  role = NA,
  trained = FALSE,
  lambdas_trained = NULL,
  skip = FALSE,
  id = rand_id("ts_clean")
)

## S3 method for class 'step_ts_clean'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_ts_clean_+3A_recipe">recipe</code></td>
<td>
<p>A <code>recipe</code> object. The step will be added to the sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_ts_clean_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which
variables are affected by the step. See <code><a href="recipes.html#topic+selections">selections()</a></code>
for more details. For the <code>tidy</code> method, these are not
currently used.</p>
</td></tr>
<tr><td><code id="step_ts_clean_+3A_period">period</code></td>
<td>
<p>A seasonal period to use during the transformation. If <code>period = 1</code>,
linear interpolation is performed. If <code>period &gt; 1</code>, a robust STL decomposition is
first performed and a linear interpolation is applied to the seasonally adjusted data.</p>
</td></tr>
<tr><td><code id="step_ts_clean_+3A_lambda">lambda</code></td>
<td>
<p>A box cox transformation parameter. If set to <code>"auto"</code>, performs
automated lambda selection.</p>
</td></tr>
<tr><td><code id="step_ts_clean_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_ts_clean_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_ts_clean_+3A_lambdas_trained">lambdas_trained</code></td>
<td>
<p>A named numeric vector of lambdas. This is <code>NULL</code> until computed
by <code>recipes::prep()</code>. Note that, if the original data are integers, the mean
will be converted to an integer to maintain the same a data type.</p>
</td></tr>
<tr><td><code id="step_ts_clean_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the recipe
is baked by <code>bake.recipe()</code>? While all operations are baked when <code>prep.recipe()</code> is run,
some operations may not be able to be conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_ts_clean_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
<tr><td><code id="step_ts_clean_+3A_x">x</code></td>
<td>
<p>A <code>step_ts_clean</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>step_ts_clean()</code> function is designed specifically to handle time series
using seasonal outlier detection methods implemented in the Forecast R Package.
</p>
<p><strong>Cleaning Outliers</strong>
</p>
<p>#' Outliers are replaced with missing values using the following methods:
</p>

<ol>
<li><p> Non-Seasonal (<code>period = 1</code>): Uses <code>stats::supsmu()</code>
</p>
</li>
<li><p> Seasonal (<code>period &gt; 1</code>): Uses <code>forecast::mstl()</code> with <code>robust = TRUE</code> (robust STL decomposition)
for seasonal series.
</p>
</li></ol>

<p><strong>Imputation using Linear Interpolation</strong>
</p>
<p>Three circumstances cause strictly linear interpolation:
</p>

<ol>
<li> <p><strong>Period is 1:</strong> With <code>period = 1</code>, a seasonality cannot be interpreted and therefore linear is used.
</p>
</li>
<li> <p><strong>Number of Non-Missing Values is less than 2-Periods</strong>: Insufficient values exist to detect seasonality.
</p>
</li>
<li> <p><strong>Number of Total Values is less than 3-Periods</strong>: Insufficient values exist to detect seasonality.
</p>
</li></ol>

<p><strong>Seasonal Imputation using Linear Interpolation</strong>
</p>
<p>For seasonal series with <code>period &gt; 1</code>, a robust Seasonal Trend Loess (STL) decomposition is first computed.
Then a linear interpolation is applied to the seasonally adjusted data, and
the seasonal component is added back.
</p>
<p><strong>Box Cox Transformation</strong>
</p>
<p>In many circumstances, a Box Cox transformation can help. Especially if the series is multiplicative
meaning the variance grows exponentially. A Box Cox transformation can be automated by setting <code>lambda = "auto"</code>
or can be specified by setting <code style="white-space: pre;">&#8288;lambda = numeric value&#8288;</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step
added to the sequence of existing steps (if any). For the
<code>tidy</code> method, a tibble with columns <code>terms</code> (the
selectors or variables selected) and <code>value</code> (the
lambda estimate).
</p>


<h3>References</h3>


<ul>
<li> <p><a href="https://github.com/robjhyndman/forecast">Forecast R Package</a>
</p>
</li>
<li> <p><a href="https://otexts.com/fpp2/missing-outliers.html">Forecasting Principles &amp; Practices: Dealing with missing values and outliers</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Time Series Analysis:
</p>

<ul>
<li><p> Engineered Features: <code><a href="#topic+step_timeseries_signature">step_timeseries_signature()</a></code>, <code><a href="#topic+step_holiday_signature">step_holiday_signature()</a></code>, <code><a href="#topic+step_fourier">step_fourier()</a></code>
</p>
</li>
<li><p> Diffs &amp; Lags <code><a href="#topic+step_diff">step_diff()</a></code>, <code>recipes::step_lag()</code>
</p>
</li>
<li><p> Smoothing: <code><a href="#topic+step_slidify">step_slidify()</a></code>, <code><a href="#topic+step_smooth">step_smooth()</a></code>
</p>
</li>
<li><p> Variance Reduction: <code><a href="#topic+step_box_cox">step_box_cox()</a></code>
</p>
</li>
<li><p> Imputation: <code><a href="#topic+step_ts_impute">step_ts_impute()</a></code>, <code><a href="#topic+step_ts_clean">step_ts_clean()</a></code>
</p>
</li>
<li><p> Padding: <code><a href="#topic+step_ts_pad">step_ts_pad()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(tidyr)
library(recipes)

# Get missing values
FANG_wide &lt;- FANG %&gt;%
    select(symbol, date, adjusted) %&gt;%
    pivot_wider(names_from = symbol, values_from = adjusted) %&gt;%
    pad_by_time()

FANG_wide

# Apply Imputation
recipe_box_cox &lt;- recipe(~ ., data = FANG_wide) %&gt;%
    step_ts_clean(FB, AMZN, NFLX, GOOG, period = 252) %&gt;%
    prep()

recipe_box_cox %&gt;% bake(FANG_wide)

# Lambda parameter used during imputation process
recipe_box_cox %&gt;% tidy(1)



</code></pre>

<hr>
<h2 id='step_ts_impute'>Missing Data Imputation for Time Series</h2><span id='topic+step_ts_impute'></span><span id='topic+tidy.step_ts_impute'></span>

<h3>Description</h3>

<p><code>step_ts_impute</code> creates a <em>specification</em> of a recipe
step that will impute time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_ts_impute(
  recipe,
  ...,
  period = 1,
  lambda = NULL,
  role = NA,
  trained = FALSE,
  lambdas_trained = NULL,
  skip = FALSE,
  id = rand_id("ts_impute")
)

## S3 method for class 'step_ts_impute'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_ts_impute_+3A_recipe">recipe</code></td>
<td>
<p>A <code>recipe</code> object. The step will be added to the sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_ts_impute_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which
variables are affected by the step. See <code><a href="recipes.html#topic+selections">selections()</a></code>
for more details. For the <code>tidy</code> method, these are not
currently used.</p>
</td></tr>
<tr><td><code id="step_ts_impute_+3A_period">period</code></td>
<td>
<p>A seasonal period to use during the transformation. If <code>period = 1</code>,
linear interpolation is performed. If <code>period &gt; 1</code>, a robust STL decomposition is
first performed and a linear interpolation is applied to the seasonally adjusted data.</p>
</td></tr>
<tr><td><code id="step_ts_impute_+3A_lambda">lambda</code></td>
<td>
<p>A box cox transformation parameter. If set to <code>"auto"</code>, performs
automated lambda selection.</p>
</td></tr>
<tr><td><code id="step_ts_impute_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are
created.</p>
</td></tr>
<tr><td><code id="step_ts_impute_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_ts_impute_+3A_lambdas_trained">lambdas_trained</code></td>
<td>
<p>A named numeric vector of lambdas. This is <code>NULL</code> until computed
by <code>recipes::prep()</code>. Note that, if the original data are integers, the mean
will be converted to an integer to maintain the same a data type.</p>
</td></tr>
<tr><td><code id="step_ts_impute_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the recipe
is baked by <code>bake.recipe()</code>? While all operations are baked when <code>prep.recipe()</code> is run,
some operations may not be able to be conducted on new data (e.g. processing the outcome variable(s)).
Care should be taken when using <code>skip = TRUE</code> as it may affect the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_ts_impute_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
<tr><td><code id="step_ts_impute_+3A_x">x</code></td>
<td>
<p>A <code>step_ts_impute</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>step_ts_impute()</code> function is designed specifically to handle time series
</p>
<p><strong>Imputation using Linear Interpolation</strong>
</p>
<p>Three circumstances cause strictly linear interpolation:
</p>

<ol>
<li> <p><strong>Period is 1:</strong> With <code>period = 1</code>, a seasonality cannot be interpreted and therefore linear is used.
</p>
</li>
<li> <p><strong>Number of Non-Missing Values is less than 2-Periods</strong>: Insufficient values exist to detect seasonality.
</p>
</li>
<li> <p><strong>Number of Total Values is less than 3-Periods</strong>: Insufficient values exist to detect seasonality.
</p>
</li></ol>

<p><strong>Seasonal Imputation using Linear Interpolation</strong>
</p>
<p>For seasonal series with <code>period &gt; 1</code>, a robust Seasonal Trend Loess (STL) decomposition is first computed.
Then a linear interpolation is applied to the seasonally adjusted data, and
the seasonal component is added back.
</p>
<p><strong>Box Cox Transformation</strong>
</p>
<p>In many circumstances, a Box Cox transformation can help. Especially if the series is multiplicative
meaning the variance grows exponentially. A Box Cox transformation can be automated by setting <code>lambda = "auto"</code>
or can be specified by setting <code style="white-space: pre;">&#8288;lambda = numeric value&#8288;</code>.
</p>


<h3>Value</h3>

<p>An updated version of <code>recipe</code> with the new step
added to the sequence of existing steps (if any). For the
<code>tidy</code> method, a tibble with columns <code>terms</code> (the
selectors or variables selected) and <code>value</code> (the
lambda estimate).
</p>


<h3>References</h3>


<ul>
<li> <p><a href="https://github.com/robjhyndman/forecast">Forecast R Package</a>
</p>
</li>
<li> <p><a href="https://otexts.com/fpp2/missing-outliers.html">Forecasting Principles &amp; Practices: Dealing with missing values and outliers</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Time Series Analysis:
</p>

<ul>
<li><p> Engineered Features: <code><a href="#topic+step_timeseries_signature">step_timeseries_signature()</a></code>, <code><a href="#topic+step_holiday_signature">step_holiday_signature()</a></code>, <code><a href="#topic+step_fourier">step_fourier()</a></code>
</p>
</li>
<li><p> Diffs &amp; Lags <code><a href="#topic+step_diff">step_diff()</a></code>, <code>recipes::step_lag()</code>
</p>
</li>
<li><p> Smoothing: <code><a href="#topic+step_slidify">step_slidify()</a></code>, <code><a href="#topic+step_smooth">step_smooth()</a></code>
</p>
</li>
<li><p> Variance Reduction: <code><a href="#topic+step_box_cox">step_box_cox()</a></code>
</p>
</li>
<li><p> Imputation: <code><a href="#topic+step_ts_impute">step_ts_impute()</a></code>, <code><a href="#topic+step_ts_clean">step_ts_clean()</a></code>
</p>
</li>
<li><p> Padding: <code><a href="#topic+step_ts_pad">step_ts_pad()</a></code>
</p>
</li></ul>

<p>Recipe Setup and Application:
</p>

<ul>
<li> <p><code>recipes::recipe()</code>
</p>
</li>
<li> <p><code>recipes::prep()</code>
</p>
</li>
<li> <p><code>recipes::bake()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
library(recipes)

# Get missing values
FANG_wide &lt;- FANG %&gt;%
    select(symbol, date, adjusted) %&gt;%
    tidyr::pivot_wider(names_from = symbol, values_from = adjusted) %&gt;%
    pad_by_time()

FANG_wide

# Apply Imputation
recipe_box_cox &lt;- recipe(~ ., data = FANG_wide) %&gt;%
    step_ts_impute(FB, AMZN, NFLX, GOOG, period = 252, lambda = "auto") %&gt;%
    prep()

recipe_box_cox %&gt;% bake(FANG_wide)

# Lambda parameter used during imputation process
recipe_box_cox %&gt;% tidy(1)


</code></pre>

<hr>
<h2 id='step_ts_pad'>Pad: Add rows to fill gaps and go from low to high frequency</h2><span id='topic+step_ts_pad'></span><span id='topic+tidy.step_ts_pad'></span>

<h3>Description</h3>

<p><code>step_ts_pad</code> creates a a <em>specification</em> of a recipe
step that will analyze a Date or Date-time column adding rows
at a specified interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_ts_pad(
  recipe,
  ...,
  by = "day",
  pad_value = NA,
  role = "predictor",
  trained = FALSE,
  columns = NULL,
  skip = FALSE,
  id = rand_id("ts_padding")
)

## S3 method for class 'step_ts_pad'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="step_ts_pad_+3A_recipe">recipe</code></td>
<td>
<p>A recipe object. The step will be added to the
sequence of operations for this recipe.</p>
</td></tr>
<tr><td><code id="step_ts_pad_+3A_...">...</code></td>
<td>
<p>A single column with class <code>Date</code> or
<code>POSIXct</code>. See <code><a href="recipes.html#topic+selections">recipes::selections()</a></code> for more details.
For the <code>tidy</code> method, these are not currently used.</p>
</td></tr>
<tr><td><code id="step_ts_pad_+3A_by">by</code></td>
<td>
<p>Either &quot;auto&quot;, a time-based frequency like &quot;year&quot;, &quot;month&quot;, &quot;day&quot;, &quot;hour&quot;, etc,
or a time expression like &quot;5 min&quot;, or &quot;7 days&quot;. See Details.</p>
</td></tr>
<tr><td><code id="step_ts_pad_+3A_pad_value">pad_value</code></td>
<td>
<p>Fills in padded values. Default is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="step_ts_pad_+3A_role">role</code></td>
<td>
<p>For model terms created by this step, what analysis
role should they be assigned?. By default, the function assumes
that the new variable columns created by the original variables
will be used as predictors in a model.</p>
</td></tr>
<tr><td><code id="step_ts_pad_+3A_trained">trained</code></td>
<td>
<p>A logical to indicate if the quantities for
preprocessing have been estimated.</p>
</td></tr>
<tr><td><code id="step_ts_pad_+3A_columns">columns</code></td>
<td>
<p>A character string of variables that will be
used as inputs. This field is a placeholder and will be
populated once <code>recipes::prep()</code> is used.</p>
</td></tr>
<tr><td><code id="step_ts_pad_+3A_skip">skip</code></td>
<td>
<p>A logical. Should the step be skipped when the recipe is
baked by bake.recipe()? While all operations are baked when prep.recipe()
is run, some operations may not be able to be conducted on new data
(e.g. processing the outcome variable(s)). Care should be taken when
using skip = TRUE as it may affect the computations for subsequent operations.</p>
</td></tr>
<tr><td><code id="step_ts_pad_+3A_id">id</code></td>
<td>
<p>A character string that is unique to this step to identify it.</p>
</td></tr>
<tr><td><code id="step_ts_pad_+3A_x">x</code></td>
<td>
<p>A <code>step_ts_pad</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Date Variable</strong>
</p>

<ul>
<li><p> Only one date or date-time variable may be supplied.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;step_ts_pad())&#8288;</code> does <em>not</em> remove the original date variables.
</p>
</li></ul>

<p><strong>Interval Specification (by)</strong>
</p>
<p>Padding can be applied in the following ways:
</p>

<ul>
<li><p> The eight intervals in are: year, quarter, month, week, day, hour, min, and sec.
</p>
</li>
<li><p> Intervals like 30 minutes, 1 hours, 14 days are possible.
</p>
</li></ul>

<p><strong>Imputing Missing Values</strong>
</p>
<p>The generic <code>pad_value</code> defaults to <code>NA</code>, which typically requires imputation.
Some common strategies include:
</p>

<ul>
<li> <p><strong>Numeric data:</strong> The <code>step_ts_impute()</code> preprocessing step can be used to impute
numeric time series data with or without seasonality
</p>
</li>
<li> <p><strong>Nominal data:</strong> The <code>step_mode_impute()</code> preprocessing step can be used to replace
missing values with the most common value.
</p>
</li></ul>



<h3>Value</h3>

<p>For <code>step_ts_pad</code>, an updated version of recipe with
the new step added to the sequence of existing steps (if any).
For the <code>tidy</code> method, a tibble with columns <code>terms</code>
(the selectors or variables selected), <code>value</code> (the feature
names).
</p>


<h3>See Also</h3>

<p>Padding &amp; Imputation:
</p>

<ul>
<li><p> Pad Time Series: <code><a href="#topic+step_ts_pad">step_ts_pad()</a></code>
</p>
</li>
<li><p> Impute missing values with these: <code><a href="#topic+step_ts_impute">step_ts_impute()</a></code>, <code><a href="#topic+step_ts_clean">step_ts_clean()</a></code>
</p>
</li></ul>

<p>Time Series Analysis:
</p>

<ul>
<li><p> Engineered Features: <code><a href="#topic+step_timeseries_signature">step_timeseries_signature()</a></code>, <code><a href="#topic+step_holiday_signature">step_holiday_signature()</a></code>, <code><a href="#topic+step_fourier">step_fourier()</a></code>
</p>
</li>
<li><p> Diffs &amp; Lags <code><a href="#topic+step_diff">step_diff()</a></code>, <code>recipes::step_lag()</code>
</p>
</li>
<li><p> Smoothing: <code><a href="#topic+step_slidify">step_slidify()</a></code>, <code><a href="#topic+step_smooth">step_smooth()</a></code>
</p>
</li>
<li><p> Variance Reduction: <code><a href="#topic+step_box_cox">step_box_cox()</a></code>
</p>
</li></ul>

<p>Main Recipe Functions:
</p>

<ul>
<li> <p><code>recipes::recipe()</code>
</p>
</li>
<li> <p><code>recipes::prep</code>
</p>
</li>
<li> <p><code>recipes::bake</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(recipes)
library(dplyr)

FB_tbl &lt;- FANG %&gt;%
    filter(symbol == "FB") %&gt;%
    select(symbol, date, adjusted)


rec_obj &lt;- recipe(adjusted ~ ., data = FB_tbl) %&gt;%
    step_ts_pad(date, by = "day", pad_value = NA)

# View the recipe object
rec_obj

# Prepare the recipe object
prep(rec_obj)

# Bake the recipe object - Adds the padding
bake(prep(rec_obj), FB_tbl)

# Tidy shows which features have been added during the 1st step
#  in this case, step 1 is the step_timeseries_signature step
tidy(prep(rec_obj))
tidy(prep(rec_obj), number = 1)

</code></pre>

<hr>
<h2 id='summarise_by_time'>Summarise (for Time Series Data)</h2><span id='topic+summarise_by_time'></span><span id='topic+summarize_by_time'></span>

<h3>Description</h3>

<p><code>summarise_by_time()</code> is a time-based variant of the popular <code>dplyr::summarise()</code> function
that uses <code>.date_var</code> to specify a date or date-time column and <code>.by</code> to group the
calculation by groups like &quot;5 seconds&quot;, &quot;week&quot;, or &quot;3 months&quot;.
</p>
<p><code>summarise_by_time()</code> and <code>summarize_by_time()</code> are synonyms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarise_by_time(
  .data,
  .date_var,
  .by = "day",
  ...,
  .type = c("floor", "ceiling", "round"),
  .week_start = NULL
)

summarize_by_time(
  .data,
  .date_var,
  .by = "day",
  ...,
  .type = c("floor", "ceiling", "round"),
  .week_start = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarise_by_time_+3A_.data">.data</code></td>
<td>
<p>A <code>tbl</code> object or <code>data.frame</code></p>
</td></tr>
<tr><td><code id="summarise_by_time_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing date or date-time values to summarize.
If missing, attempts to auto-detect date column.</p>
</td></tr>
<tr><td><code id="summarise_by_time_+3A_.by">.by</code></td>
<td>
<p>A time unit to summarise by.
Time units are collapsed using <code>lubridate::floor_date()</code> or <code>lubridate::ceiling_date()</code>.
</p>
<p>The value can be:
</p>

<ul>
<li> <p><code>second</code>
</p>
</li>
<li> <p><code>minute</code>
</p>
</li>
<li> <p><code>hour</code>
</p>
</li>
<li> <p><code>day</code>
</p>
</li>
<li> <p><code>week</code>
</p>
</li>
<li> <p><code>month</code>
</p>
</li>
<li> <p><code>bimonth</code>
</p>
</li>
<li> <p><code>quarter</code>
</p>
</li>
<li> <p><code>season</code>
</p>
</li>
<li> <p><code>halfyear</code>
</p>
</li>
<li> <p><code>year</code>
</p>
</li></ul>

<p>Arbitrary unique English abbreviations as in the <code>lubridate::period()</code> constructor are allowed.</p>
</td></tr>
<tr><td><code id="summarise_by_time_+3A_...">...</code></td>
<td>
<p>Name-value pairs of summary functions.
The name will be the name of the variable in the result.
</p>
<p>The value can be:
</p>

<ul>
<li><p> A vector of length 1, e.g. <code>min(x)</code>, <code>n()</code>, or <code>sum(is.na(y))</code>.
</p>
</li>
<li><p> A vector of length <code>n</code>, e.g. <code>quantile()</code>.
</p>
</li>
<li><p> A data frame, to add multiple columns from a single expression.
</p>
</li></ul>
</td></tr>
<tr><td><code id="summarise_by_time_+3A_.type">.type</code></td>
<td>
<p>One of &quot;floor&quot;, &quot;ceiling&quot;, or &quot;round. Defaults to &quot;floor&quot;. See <code>lubridate::round_date</code>.</p>
</td></tr>
<tr><td><code id="summarise_by_time_+3A_.week_start">.week_start</code></td>
<td>
<p>when unit is weeks, specify the reference day.
7 represents Sunday and 1 represents Monday.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> or <code>data.frame</code>
</p>


<h3>Useful summary functions</h3>


<ul>
<li><p> Sum: <code><a href="base.html#topic+sum">sum()</a></code>
</p>
</li>
<li><p> Center: <code><a href="base.html#topic+mean">mean()</a></code>, <code><a href="stats.html#topic+median">median()</a></code>
</p>
</li>
<li><p> Spread: <code><a href="stats.html#topic+sd">sd()</a></code>, <code><a href="stats.html#topic+var">var()</a></code>
</p>
</li>
<li><p> Range: <code><a href="base.html#topic+min">min()</a></code>, <code><a href="base.html#topic+max">max()</a></code>
</p>
</li>
<li><p> Count: <code>dplyr::n()</code>, <code>dplyr::n_distinct()</code>
</p>
</li>
<li><p> Position: <code>dplyr::first()</code>, <code>dplyr::last()</code>, <code>dplyr::nth()</code>
</p>
</li>
<li><p> Correlation: <code><a href="stats.html#topic+cor">cor()</a></code>, <code><a href="stats.html#topic+cov">cov()</a></code>
</p>
</li></ul>



<h3>See Also</h3>

<p>Time-Based dplyr functions:
</p>

<ul>
<li> <p><code><a href="#topic+summarise_by_time">summarise_by_time()</a></code> - Easily summarise using a date column.
</p>
</li>
<li> <p><code><a href="#topic+mutate_by_time">mutate_by_time()</a></code> - Simplifies applying mutations by time windows.
</p>
</li>
<li> <p><code><a href="#topic+filter_by_time">filter_by_time()</a></code> - Quickly filter using date ranges.
</p>
</li>
<li> <p><code><a href="#topic+filter_period">filter_period()</a></code> - Apply filtering expressions inside periods (windows)
</p>
</li>
<li> <p><code><a href="#topic+between_time">between_time()</a></code> - Range detection for date or date-time sequences.
</p>
</li>
<li> <p><code><a href="#topic+pad_by_time">pad_by_time()</a></code> - Insert time series rows with regularly spaced timestamps
</p>
</li>
<li> <p><code><a href="#topic+condense_period">condense_period()</a></code> - Convert to a different periodicity
</p>
</li>
<li> <p><code><a href="#topic+slidify">slidify()</a></code> - Turn any function into a sliding (rolling) function
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Libraries
library(dplyr)

# First value in each month
m4_daily %&gt;%
    group_by(id) %&gt;%
    summarise_by_time(
        .date_var = date,
        .by       = "month", # Setup for monthly aggregation
        # Summarization
        value  = first(value)
    )

# Last value in each month (day is first day of next month with ceiling option)
m4_daily %&gt;%
    group_by(id) %&gt;%
    summarise_by_time(
        .by        = "month",
        value      = last(value),
        .type      = "ceiling"
    ) %&gt;%
    # Shift to the last day of the month
    mutate(date = date %-time% "1 day")

# Total each year (.by is set to "year" now)
m4_daily %&gt;%
    group_by(id) %&gt;%
    summarise_by_time(
        .by        = "year",
        value      = sum(value)
    )


</code></pre>

<hr>
<h2 id='taylor_30_min'>Half-hourly electricity demand</h2><span id='topic+taylor_30_min'></span>

<h3>Description</h3>

<p>Half-hourly electricity demand in England and Wales from Monday 5 June 2000
to Sunday 27 August 2000. Discussed in Taylor (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>taylor_30_min
</code></pre>


<h3>Format</h3>

<p>A tibble: 4,032 x 2
</p>

<ul>
<li> <p><code>date</code>: A date-time variable in 30-minute increments
</p>
</li>
<li> <p><code>value</code>: Electricity demand in Megawatts
</p>
</li></ul>



<h3>Source</h3>

<p>James W Taylor
</p>


<h3>References</h3>

<p>Taylor, J.W. (2003) Short-term electricity demand forecasting
using double seasonal exponential smoothing. <em>Journal of the
Operational Research Society</em>, <b>54</b>, 799-805.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>taylor_30_min

</code></pre>

<hr>
<h2 id='tidyeval'>Tidy eval helpers</h2><span id='topic+tidyeval'></span><span id='topic+expr'></span><span id='topic+enquo'></span><span id='topic+enquos'></span><span id='topic+sym'></span><span id='topic+syms'></span><span id='topic+.data'></span><span id='topic++3A+3D'></span><span id='topic+as_name'></span><span id='topic+as_label'></span><span id='topic++25+7C+7C+25'></span>

<h3>Description</h3>


<ul>
<li> <p><code>sym</code> creates a symbol from a string and
<code>syms</code> creates a list of symbols from a
character vector.
</p>
</li>
<li> <p><code>enquo</code> and
<code>enquos</code> delay the execution of one or
several function arguments. <code>enquo()</code> returns a single quoted
expression, which is like a blueprint for the delayed computation.
<code>enquos()</code> returns a list of such quoted expressions.
</p>
</li>
<li> <p><code>expr</code> quotes a new expression <em>locally</em>. It
is mostly useful to build new expressions around arguments
captured with <code><a href="#topic+enquo">enquo()</a></code> or <code><a href="#topic+enquos">enquos()</a></code>:
<code>expr(mean(!!enquo(arg), na.rm = TRUE))</code>.
</p>
</li>
<li> <p><code>as_name</code> transforms a quoted variable name
into a string. Supplying something else than a quoted variable
name is an error.
</p>
<p>That's unlike <code>as_label</code> which also returns
a single string but supports any kind of R object as input,
including quoted function calls and vectors. Its purpose is to
summarise that object into a single label. That label is often
suitable as a default name.
</p>
<p>If you don't know what a quoted expression contains (for instance
expressions captured with <code>enquo()</code> could be a variable
name, a call to a function, or an unquoted constant), then use
<code>as_label()</code>. If you know you have quoted a simple variable
name, or would like to enforce this, use <code>as_name()</code>.
</p>
</li></ul>

<p>To learn more about tidy eval and how to use these tools, visit the
<a href="https://adv-r.hadley.nz/metaprogramming.html">Metaprogramming
section</a> of <a href="https://adv-r.hadley.nz">Advanced R</a>.
</p>


<h3>Value</h3>

<p>Nothing returned.
This is to document important functions from <code>rlang</code> that are used internal to this R package.
</p>

<hr>
<h2 id='time_arithmetic'>Add / Subtract (For Time Series)</h2><span id='topic+time_arithmetic'></span><span id='topic+add_time'></span><span id='topic+subtract_time'></span><span id='topic++25+2Btime+25'></span><span id='topic++25-time+25'></span>

<h3>Description</h3>

<p>The easiest way to add / subtract a period to a time series date or date-time vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_time(index, period)

subtract_time(index, period)

index %+time% period

index %-time% period
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_arithmetic_+3A_index">index</code></td>
<td>
<p>A date or date-time vector. Can also accept a character representation.</p>
</td></tr>
<tr><td><code id="time_arithmetic_+3A_period">period</code></td>
<td>
<p>A period to add. Accepts character strings like &quot;5 seconds&quot;, &quot;2 days&quot;,
and complex strings like &quot;1 month 4 days 34 minutes&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A convenient wrapper for <code>lubridate::period()</code>. Adds and subtracts a period from a
time-based index. Great for:
</p>

<ul>
<li><p> Finding a timestamp n-periods into the future or past
</p>
</li>
<li><p> Shifting a time-based index. Note that <code>NA</code> values may be present where dates don't exist.
</p>
</li></ul>

<p><strong>Period Specification</strong>
</p>
<p>The <code>period</code> argument accepts complex strings like:
</p>

<ul>
<li><p> &quot;1 month 4 days 43 minutes&quot;
</p>
</li>
<li><p> &quot;second = 3, minute = 1, hour = 2, day = 13, week = 1&quot;
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>date</code> or datetime (<code>POSIXct</code>) vector the same length as <code>index</code> with the
time values shifted +/- a period.
</p>


<h3>See Also</h3>

<p>Other Time-Based vector functions:
</p>

<ul>
<li> <p><code><a href="#topic+between_time">between_time()</a></code> - Range detection for date or date-time sequences.
</p>
</li></ul>

<p>Underlying function:
</p>

<ul>
<li> <p><code><a href="lubridate.html#topic+period">lubridate::period()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

# ---- LOCATING A DATE N-PERIODS IN FUTURE / PAST ----

# Forward (Plus Time)
"2021" %+time% "1 hour 34 seconds"
"2021" %+time% "3 months"
"2021" %+time% "1 year 3 months 6 days"

# Backward (Minus Time)
"2021" %-time% "1 hour 34 seconds"
"2021" %-time% "3 months"
"2021" %-time% "1 year 3 months 6 days"

# ---- INDEX SHIFTING ----

index_daily &lt;- tk_make_timeseries("2016", "2016-02-01")

# ADD TIME
# - Note `NA` values created where a daily dates aren't possible
#   (e.g. Feb 29 &amp; 30, 2016 doesn't exist).
index_daily %+time% "1 month"

# Subtracting Time
index_daily %-time% "1 month"




</code></pre>

<hr>
<h2 id='time_series_cv'>Time Series Cross Validation</h2><span id='topic+time_series_cv'></span>

<h3>Description</h3>

<p>Create <code>rsample</code> cross validation sets for time series.
This function produces a sampling plan starting with the most recent
time series observations, rolling backwards. The sampling procedure
is similar to <code>rsample::rolling_origin()</code>, but places the focus
of the cross validation on the most recent time series data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_series_cv(
  data,
  date_var = NULL,
  initial = 5,
  assess = 1,
  skip = 1,
  lag = 0,
  cumulative = FALSE,
  slice_limit = n(),
  point_forecast = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_series_cv_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="time_series_cv_+3A_date_var">date_var</code></td>
<td>
<p>A date or date-time variable.</p>
</td></tr>
<tr><td><code id="time_series_cv_+3A_initial">initial</code></td>
<td>
<p>The number of samples used for analysis/modeling in the
initial resample.</p>
</td></tr>
<tr><td><code id="time_series_cv_+3A_assess">assess</code></td>
<td>
<p>The number of samples used for each assessment resample.</p>
</td></tr>
<tr><td><code id="time_series_cv_+3A_skip">skip</code></td>
<td>
<p>A integer indicating how many (if any) <em>additional</em> resamples
to skip to thin the total amount of data points in the analysis resample.
See the example below.</p>
</td></tr>
<tr><td><code id="time_series_cv_+3A_lag">lag</code></td>
<td>
<p>A value to include an lag between the assessment
and analysis set. This is useful if lagged predictors will be used
during training and testing.</p>
</td></tr>
<tr><td><code id="time_series_cv_+3A_cumulative">cumulative</code></td>
<td>
<p>A logical. Should the analysis resample grow beyond the
size specified by <code>initial</code> at each resample?.</p>
</td></tr>
<tr><td><code id="time_series_cv_+3A_slice_limit">slice_limit</code></td>
<td>
<p>The number of slices to return. Set to <code>dplyr::n()</code>,
which returns the maximum number of slices.</p>
</td></tr>
<tr><td><code id="time_series_cv_+3A_point_forecast">point_forecast</code></td>
<td>
<p>Whether or not to have the testing set be a single point forecast or to be a forecast horizon.
The default is to be a forecast horizon. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="time_series_cv_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Time-Based Specification</strong>
</p>
<p>The <code>initial</code>, <code>assess</code>, <code>skip</code>, and <code>lag</code> variables can be specified as:
</p>

<ul>
<li><p> Numeric: <code>initial = 24</code>
</p>
</li>
<li><p> Time-Based Phrases: <code>initial = "2 years"</code>, if the <code>data</code> contains
a <code>date_var</code> (date or datetime)
</p>
</li></ul>

<p><strong>Initial (Training Set) and Assess (Testing Set)</strong>
</p>
<p>The main options, <code>initial</code> and <code>assess</code>, control the number of
data points from the original data that are in the analysis (training set)
and the assessment (testing set), respectively.
</p>
<p><strong>Skip</strong>
</p>
<p><code>skip</code> enables the function to not use every data point in the resamples.
When <code>skip = 1</code>, the resampling data sets will increment by one position.
</p>
<p>Example: Suppose that the rows of a data set are consecutive days. Using <code>skip = 7</code>
will make the analysis data set operate on <em>weeks</em> instead of days. The
assessment set size is not affected by this option.
</p>
<p><strong>Lag</strong>
</p>
<p>The Lag parameter creates an overlap between the Testing set. This is needed
when lagged predictors are used.
</p>
<p><strong>Cumulative vs Sliding Window</strong>
</p>
<p>When <code>cumulative = TRUE</code>, the <code>initial</code> parameter is ignored and the
analysis (training) set will grow as
resampling continues while the assessment (testing) set size will always remain
static.
</p>
<p>When <code>cumulative = FALSE</code>, the <code>initial</code> parameter fixes the analysis (training)
set and resampling occurs over a fixed window.
</p>
<p><strong>Slice Limit</strong>
</p>
<p>This controls the number of slices. If <code>slice_limit = 5</code>, only the most recent
5 slices will be returned.
</p>
<p><strong>Point Forecast</strong>
</p>
<p>A point forecast is sometimes desired such as if you want to forecast a value
&quot;4-weeks&quot; into the future. You can do this by setting the following parameters:
</p>

<ul>
<li><p> assess = &quot;4 weeks&quot;
</p>
</li>
<li><p> point_forecast = TRUE
</p>
</li></ul>

<p><strong>Panel Data / Time Series Groups / Overlapping Timestamps</strong>
</p>
<p>Overlapping timestamps occur when your data has more than one
time series group. This is sometimes called <em>Panel Data</em> or <em>Time Series Groups</em>.
</p>
<p>When timestamps are duplicated (as in the case of &quot;Panel Data&quot; or &quot;Time Series Groups&quot;),
the resample calculation applies a sliding window of
fixed length to the dataset. See the example using <code>walmart_sales_weekly</code>
dataset below.
</p>


<h3>Value</h3>

<p>An tibble with classes <code>time_series_cv</code>, <code>rset</code>, <code>tbl_df</code>, <code>tbl</code>,
and <code>data.frame</code>. The results include a column for the data split objects
and a column called <code>id</code> that has a character string with the resample
identifier.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+time_series_cv">time_series_cv()</a></code> and <code><a href="rsample.html#topic+rolling_origin">rsample::rolling_origin()</a></code> - Functions used to create
time series resample specifications.
</p>
</li>
<li> <p><code><a href="#topic+plot_time_series_cv_plan">plot_time_series_cv_plan()</a></code> - The plotting function used for visualizing the
time series resample plan.
</p>
</li>
<li> <p><code><a href="#topic+time_series_split">time_series_split()</a></code> - A convenience function to return a single time series
split containing a training/testing sample.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# DATA ----
m750 &lt;- m4_monthly %&gt;% dplyr::filter(id == "M750")


# RESAMPLE SPEC ----
resample_spec &lt;- time_series_cv(data = m750,
                                initial     = "6 years",
                                assess      = "24 months",
                                skip        = "24 months",
                                cumulative  = FALSE,
                                slice_limit = 3)

resample_spec

# VISUALIZE CV PLAN ----

# Select date and value columns from the tscv diagnostic tool
resample_spec %&gt;% tk_time_series_cv_plan()

# Plot the date and value columns to see the CV Plan
resample_spec %&gt;%
    plot_time_series_cv_plan(date, value, .interactive = FALSE)


# PANEL DATA / TIME SERIES GROUPS ----
# - Time Series Groups are processed using an *ungrouped* data set
# - The data has sliding windows applied starting with the beginning of the series
# - The seven groups of weekly time series are
#   processed together for &lt;split [358/78]&gt; dimensions

walmart_tscv &lt;- walmart_sales_weekly %&gt;%
    time_series_cv(
        date_var    = Date,
        initial     = "12 months",
        assess      = "3 months",
        skip        = "3 months",
        slice_limit = 4
    )

walmart_tscv

walmart_tscv %&gt;%
    plot_time_series_cv_plan(Date, Weekly_Sales, .interactive = FALSE)

</code></pre>

<hr>
<h2 id='time_series_split'>Simple Training/Test Set Splitting for Time Series</h2><span id='topic+time_series_split'></span>

<h3>Description</h3>

<p><code>time_series_split</code> creates resample splits using <code><a href="#topic+time_series_cv">time_series_cv()</a></code> but
returns only a <strong>single split.</strong> This is useful when creating a single
train/test split.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>time_series_split(
  data,
  date_var = NULL,
  initial = 5,
  assess = 1,
  skip = 1,
  lag = 0,
  cumulative = FALSE,
  slice = 1,
  point_forecast = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="time_series_split_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="time_series_split_+3A_date_var">date_var</code></td>
<td>
<p>A date or date-time variable.</p>
</td></tr>
<tr><td><code id="time_series_split_+3A_initial">initial</code></td>
<td>
<p>The number of samples used for analysis/modeling in the
initial resample.</p>
</td></tr>
<tr><td><code id="time_series_split_+3A_assess">assess</code></td>
<td>
<p>The number of samples used for each assessment resample.</p>
</td></tr>
<tr><td><code id="time_series_split_+3A_skip">skip</code></td>
<td>
<p>A integer indicating how many (if any) <em>additional</em> resamples
to skip to thin the total amount of data points in the analysis resample.
See the example below.</p>
</td></tr>
<tr><td><code id="time_series_split_+3A_lag">lag</code></td>
<td>
<p>A value to include an lag between the assessment
and analysis set. This is useful if lagged predictors will be used
during training and testing.</p>
</td></tr>
<tr><td><code id="time_series_split_+3A_cumulative">cumulative</code></td>
<td>
<p>A logical. Should the analysis resample grow beyond the
size specified by <code>initial</code> at each resample?.</p>
</td></tr>
<tr><td><code id="time_series_split_+3A_slice">slice</code></td>
<td>
<p>Returns a single slice from <a href="#topic+time_series_cv">time_series_cv</a></p>
</td></tr>
<tr><td><code id="time_series_split_+3A_point_forecast">point_forecast</code></td>
<td>
<p>Whether or not to have the testing set be a single point forecast or to be a forecast horizon.
The default is to be a forecast horizon. Default: <code>FALSE</code></p>
</td></tr>
<tr><td><code id="time_series_split_+3A_...">...</code></td>
<td>
<p>These dots are for future extensions and must be empty.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Time-Based Specification</strong>
</p>
<p>The <code>initial</code>, <code>assess</code>, <code>skip</code>, and <code>lag</code> variables can be specified as:
</p>

<ul>
<li><p> Numeric: <code>initial = 24</code>
</p>
</li>
<li><p> Time-Based Phrases: <code>initial = "2 years"</code>, if the <code>data</code> contains
a <code>date_var</code> (date or datetime)
</p>
</li></ul>

<p><strong>Initial (Training Set) and Assess (Testing Set)</strong>
</p>
<p>The main options, <code>initial</code> and <code>assess</code>, control the number of
data points from the original data that are in the analysis (training set)
and the assessment (testing set), respectively.
</p>
<p><strong>Skip</strong>
</p>
<p><code>skip</code> enables the function to not use every data point in the resamples.
When <code>skip = 1</code>, the resampling data sets will increment by one position.
</p>
<p>Example: Suppose that the rows of a data set are consecutive days. Using <code>skip = 7</code>
will make the analysis data set operate on <em>weeks</em> instead of days. The
assessment set size is not affected by this option.
</p>
<p><strong>Lag</strong>
</p>
<p>The Lag parameter creates an overlap between the Testing set. This is needed
when lagged predictors are used.
</p>
<p><strong>Cumulative vs Sliding Window</strong>
</p>
<p>When <code>cumulative = TRUE</code>, the <code>initial</code> parameter is ignored and the
analysis (training) set will grow as
resampling continues while the assessment (testing) set size will always remain
static.
</p>
<p>When <code>cumulative = FALSE</code>, the <code>initial</code> parameter fixes the analysis (training)
set and resampling occurs over a fixed window.
</p>
<p><strong>Slice</strong>
</p>
<p>This controls which slice is returned. If <code>slice = 1</code>, only the most recent
slice will be returned.
</p>


<h3>Value</h3>

<p>An <code>rsplit</code> object that can be used with the <code>training</code> and <code>testing</code>
functions to extract the data in each split.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+time_series_cv">time_series_cv()</a></code> and <code><a href="rsample.html#topic+rolling_origin">rsample::rolling_origin()</a></code> - Functions used to create
time series resample specifications.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# DATA ----
m750 &lt;- m4_monthly %&gt;% dplyr::filter(id == "M750")

# Get the most recent 3 years as testing, and previous 10 years as training
m750 %&gt;%
    time_series_split(initial = "10 years", assess = "3 years")

# Skip the most recent 3 years
m750 %&gt;%
    time_series_split(
        initial = "10 years",
        assess  = "3 years",
        skip    = "3 years",
        slice   = 2          # &lt;- Returns 2nd slice, 3-years back
    )

# Add 1 year lag for testing overlap
m750 %&gt;%
    time_series_split(
        initial = "10 years",
        assess  = "3 years",
        skip    = "3 years",
        slice   = 2,
        lag     = "1 year"   # &lt;- Overlaps training/testing by 1 year
    )


</code></pre>

<hr>
<h2 id='timetk-package'>timetk: Time Series Analysis in the Tidyverse</h2><span id='topic+timetk'></span><span id='topic+timetk-package'></span>

<h3>Description</h3>

<p>The <code>timetk</code> package combines a collection of coercion tools for
time series analysis.
</p>


<h3>Details</h3>

<p>The <code>timetk</code> package has several benefits:
</p>

<ol>
<li><p> Visualizing Time Series
</p>
</li>
<li><p> Wrangling Time Series.
</p>
</li>
<li><p> Preprocessing and Feature Engineering.
</p>
</li></ol>

<p>To learn more about <code>timetk</code>, start with the documentation:
<a href="https://business-science.github.io/timetk/">https://business-science.github.io/timetk/</a>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Matt Dancho <a href="mailto:mdancho@business-science.io">mdancho@business-science.io</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Davis Vaughan <a href="mailto:dvaughan@business-science.io">dvaughan@business-science.io</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/business-science/timetk">https://github.com/business-science/timetk</a>
</p>
</li>
<li> <p><a href="https://business-science.github.io/timetk/">https://business-science.github.io/timetk/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/business-science/timetk/issues">https://github.com/business-science/timetk/issues</a>
</p>
</li></ul>


<hr>
<h2 id='tk_acf_diagnostics'>Group-wise ACF, PACF, and CCF Data Preparation</h2><span id='topic+tk_acf_diagnostics'></span>

<h3>Description</h3>

<p>The <code>tk_acf_diagnostics()</code> function provides a simple interface to
detect Autocorrelation (ACF), Partial Autocorrelation (PACF), and Cross Correlation (CCF) of Lagged
Predictors in one <code>tibble</code>. This function powers the <code><a href="#topic+plot_acf_diagnostics">plot_acf_diagnostics()</a></code>
visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_acf_diagnostics(.data, .date_var, .value, .ccf_vars = NULL, .lags = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_acf_diagnostics_+3A_.data">.data</code></td>
<td>
<p>A data frame or tibble with numeric features (values) in descending
chronological order</p>
</td></tr>
<tr><td><code id="tk_acf_diagnostics_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing either date or date-time values</p>
</td></tr>
<tr><td><code id="tk_acf_diagnostics_+3A_.value">.value</code></td>
<td>
<p>A numeric column with a value to have ACF and PACF calculations
performed.</p>
</td></tr>
<tr><td><code id="tk_acf_diagnostics_+3A_.ccf_vars">.ccf_vars</code></td>
<td>
<p>Additional features to perform Lag Cross Correlations (CCFs)
versus the <code>.value</code>. Useful for evaluating external lagged regressors.</p>
</td></tr>
<tr><td><code id="tk_acf_diagnostics_+3A_.lags">.lags</code></td>
<td>
<p>A seqence of one or more lags to evaluate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Simplified ACF, PACF, &amp; CCF</strong>
</p>
<p>We are often interested in all 3 of these functions. Why not get all 3 at once?
Now you can!
</p>

<ul>
<li> <p><strong>ACF</strong> - Autocorrelation between a target variable and lagged versions of itself
</p>
</li>
<li> <p><strong>PACF</strong> - Partial Autocorrelation removes the dependence of lags on
other lags highlighting key seasonalities.
</p>
</li>
<li> <p><strong>CCF</strong> - Shows how lagged predictors can be used for prediction of a target
variable.
</p>
</li></ul>

<p><strong>Lag Specification</strong>
</p>
<p>Lags (<code>.lags</code>) can either be specified as:
</p>

<ul>
<li><p> A time-based phrase indicating a duraction (e.g. <code style="white-space: pre;">&#8288;2 months&#8288;</code>)
</p>
</li>
<li><p> A maximum lag (e.g. <code>.lags = 28</code>)
</p>
</li>
<li><p> A sequence of lags (e.g. <code>.lags = 7:28</code>)
</p>
</li></ul>

<p><strong>Scales to Multiple Time Series with Groupes</strong>
</p>
<p>The <code>tk_acf_diagnostics()</code> works with <code>grouped_df</code>'s, meaning you can
group your time series by one or more categorical columns with <code>dplyr::group_by()</code>
and then apply <code>tk_acf_diagnostics()</code> to return group-wise lag diagnostics.
</p>
<p><strong>Special Note on Dots (...)</strong>
</p>
<p>Unlike other plotting utilities, the <code>...</code> arguments is NOT used for
group-wise analysis. Rather, it's used for processing Cross Correlations (CCFs).
</p>
<p>Use <code>dplyr::group_by()</code> for processing multiple time series groups.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> or <code>data.frame</code> containing the autocorrelation, partial autocorrelation
and cross correlation data.
</p>


<h3>See Also</h3>


<ul>
<li> <p><strong>Visualizing ACF, PACF, &amp; CCF:</strong> <code><a href="#topic+plot_acf_diagnostics">plot_acf_diagnostics()</a></code>
</p>
</li>
<li> <p><strong>Visualizing Seasonality:</strong> <code><a href="#topic+plot_seasonal_diagnostics">plot_seasonal_diagnostics()</a></code>
</p>
</li>
<li> <p><strong>Visualizing Time Series:</strong> <code><a href="#topic+plot_time_series">plot_time_series()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# ACF, PACF, &amp; CCF in 1 Data Frame
# - Get ACF &amp; PACF for target (adjusted)
# - Get CCF between adjusted and volume and close
FANG %&gt;%
    filter(symbol == "FB") %&gt;%
    tk_acf_diagnostics(date, adjusted,                # ACF &amp; PACF
                       .ccf_vars = c(volume, close),  # CCFs
                       .lags     = 500)

# Scale with groups using group_by()
FANG %&gt;%
    group_by(symbol) %&gt;%
    tk_acf_diagnostics(date, adjusted,
                       .ccf_vars = c(volume, close),
                       .lags     = "3 months")

# Apply Transformations
FANG %&gt;%
    group_by(symbol) %&gt;%
    tk_acf_diagnostics(
        date, diff_vec(adjusted),  # Apply differencing transformation
        .lags = 0:500
    )


</code></pre>

<hr>
<h2 id='tk_anomaly_diagnostics'>Automatic group-wise Anomaly Detection by STL Decomposition</h2><span id='topic+tk_anomaly_diagnostics'></span>

<h3>Description</h3>

<p><code>tk_anomaly_diagnostics()</code> is the preprocessor for <code>plot_anomaly_diagnostics()</code>.
It performs automatic anomaly detection for one or more time series groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_anomaly_diagnostics(
  .data,
  .date_var,
  .value,
  .frequency = "auto",
  .trend = "auto",
  .alpha = 0.05,
  .max_anomalies = 0.2,
  .message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_anomaly_diagnostics_+3A_.data">.data</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code> with a time-based column</p>
</td></tr>
<tr><td><code id="tk_anomaly_diagnostics_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing either date or date-time values</p>
</td></tr>
<tr><td><code id="tk_anomaly_diagnostics_+3A_.value">.value</code></td>
<td>
<p>A column containing numeric values</p>
</td></tr>
<tr><td><code id="tk_anomaly_diagnostics_+3A_.frequency">.frequency</code></td>
<td>
<p>Controls the seasonal adjustment (removal of seasonality).
Input can be either &quot;auto&quot;, a time-based definition (e.g. &quot;2 weeks&quot;),
or a numeric number of observations per frequency (e.g. 10).
Refer to <code><a href="#topic+tk_get_frequency">tk_get_frequency()</a></code>.</p>
</td></tr>
<tr><td><code id="tk_anomaly_diagnostics_+3A_.trend">.trend</code></td>
<td>
<p>Controls the trend component.
For STL, trend controls the sensitivity of the LOESS smoother, which is used to remove the remainder.
Refer to <code><a href="#topic+tk_get_trend">tk_get_trend()</a></code>.</p>
</td></tr>
<tr><td><code id="tk_anomaly_diagnostics_+3A_.alpha">.alpha</code></td>
<td>
<p>Controls the width of the &quot;normal&quot; range. Lower values are more conservative
while higher values are less prone to incorrectly classifying &quot;normal&quot; observations.</p>
</td></tr>
<tr><td><code id="tk_anomaly_diagnostics_+3A_.max_anomalies">.max_anomalies</code></td>
<td>
<p>The maximum percent of anomalies permitted to be identified.</p>
</td></tr>
<tr><td><code id="tk_anomaly_diagnostics_+3A_.message">.message</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, will output information related to automatic frequency
and trend selection (if applicable).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>tk_anomaly_diagnostics()</code> method for anomaly detection that implements a 2-step process to
detect outliers in time series.
</p>
<p><strong>Step 1: Detrend &amp; Remove Seasonality using STL Decomposition</strong>
</p>
<p>The decomposition separates the &quot;season&quot; and &quot;trend&quot; components from the &quot;observed&quot; values
leaving the &quot;remainder&quot; for anomaly detection.
</p>
<p>The user can control two parameters: frequency and trend.
</p>

<ol>
<li> <p><code>.frequency</code>: Adjusts the &quot;season&quot; component that is removed from the &quot;observed&quot; values.
</p>
</li>
<li> <p><code>.trend</code>: Adjusts the trend window (t.window parameter from <code><a href="stats.html#topic+stl">stats::stl()</a></code> that is used.
</p>
</li></ol>

<p>The user may supply both <code>.frequency</code> and <code>.trend</code> as time-based durations (e.g. &quot;6 weeks&quot;) or
numeric values (e.g. 180) or &quot;auto&quot;, which predetermines the frequency and/or trend based on
the scale of the time series using the <code><a href="#topic+tk_time_scale_template">tk_time_scale_template()</a></code>.
</p>
<p><strong>Step 2: Anomaly Detection</strong>
</p>
<p>Once &quot;trend&quot; and &quot;season&quot; (seasonality) is removed, anomaly detection is performed on the &quot;remainder&quot;.
Anomalies are identified, and boundaries (recomposed_l1 and recomposed_l2) are determined.
</p>
<p>The Anomaly Detection Method uses an inner quartile range (IQR) of +/-25 the median.
</p>
<p><em>IQR Adjustment, alpha parameter</em>
</p>
<p>With the default <code>alpha = 0.05</code>, the limits are established by expanding
the 25/75 baseline by an IQR Factor of 3 (3X).
The <em>IQR Factor = 0.15 / alpha</em> (hence 3X with alpha = 0.05):
</p>

<ul>
<li><p> To increase the IQR Factor controlling the limits, decrease the alpha,
which makes it more difficult to be an outlier.
</p>
</li>
<li><p> Increase alpha to make it easier to be an outlier.
</p>
</li>
<li><p> The IQR outlier detection method is used in <code>forecast::tsoutliers()</code>.
</p>
</li>
<li><p> A similar outlier detection method is used by Twitter's <code>AnomalyDetection</code> package.
</p>
</li>
<li><p> Both Twitter and Forecast tsoutliers methods have been implemented in Business Science's <code>anomalize</code>
package.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>tibble</code> or <code>data.frame</code> with STL Decomposition Features
(observed, season, trend, remainder, seasadj) and
Anomaly Features (remainder_l1, remainder_l2, anomaly, recomposed_l1, and recomposed_l2)
</p>


<h3>References</h3>


<ol>
<li><p> CLEVELAND, R. B., CLEVELAND, W. S., MCRAE, J. E., AND TERPENNING, I.
STL: A Seasonal-Trend Decomposition Procedure Based on Loess.
Journal of Official Statistics, Vol. 6, No. 1 (1990), pp. 3-73.
</p>
</li>
<li><p> Owen S. Vallis, Jordan Hochenbaum and Arun Kejariwal (2014).
A Novel Technique for Long-Term Anomaly Detection in the Cloud. Twitter Inc.
</p>
</li></ol>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+plot_anomaly_diagnostics">plot_anomaly_diagnostics()</a></code>: Visual anomaly detection
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

walmart_sales_weekly %&gt;%
    filter(id %in% c("1_1", "1_3")) %&gt;%
    group_by(id) %&gt;%
    tk_anomaly_diagnostics(Date, Weekly_Sales)

</code></pre>

<hr>
<h2 id='tk_augment_differences'>Add many differenced columns to the data</h2><span id='topic+tk_augment_differences'></span>

<h3>Description</h3>

<p>A handy function for adding multiple lagged difference values to a data frame.
Works with <code>dplyr</code> groups too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_augment_differences(
  .data,
  .value,
  .lags = 1,
  .differences = 1,
  .log = FALSE,
  .names = "auto"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_augment_differences_+3A_.data">.data</code></td>
<td>
<p>A tibble.</p>
</td></tr>
<tr><td><code id="tk_augment_differences_+3A_.value">.value</code></td>
<td>
<p>One or more column(s) to have a transformation applied. Usage
of <code>tidyselect</code> functions (e.g. <code>contains()</code>) can be used to select multiple columns.</p>
</td></tr>
<tr><td><code id="tk_augment_differences_+3A_.lags">.lags</code></td>
<td>
<p>One or more lags for the difference(s)</p>
</td></tr>
<tr><td><code id="tk_augment_differences_+3A_.differences">.differences</code></td>
<td>
<p>The number of differences to apply.</p>
</td></tr>
<tr><td><code id="tk_augment_differences_+3A_.log">.log</code></td>
<td>
<p>If TRUE, applies log-differences.</p>
</td></tr>
<tr><td><code id="tk_augment_differences_+3A_.names">.names</code></td>
<td>
<p>A vector of names for the new columns. Must be of same length as the
number of output columns. Use &quot;auto&quot; to automatically rename the columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Benefits</strong>
</p>
<p>This is a scalable function that is:
</p>

<ul>
<li><p> Designed to work with grouped data using <code>dplyr::group_by()</code>
</p>
</li>
<li><p> Add multiple differences by adding a sequence of differences using
the <code>.lags</code> argument (e.g. <code>lags = 1:20</code>)
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a <code>tibble</code> object describing the timeseries.
</p>


<h3>See Also</h3>

<p>Augment Operations:
</p>

<ul>
<li> <p><code><a href="#topic+tk_augment_timeseries_signature">tk_augment_timeseries_signature()</a></code> - Group-wise augmentation of timestamp features
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_holiday_signature">tk_augment_holiday_signature()</a></code> - Group-wise augmentation of holiday features
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_slidify">tk_augment_slidify()</a></code> - Group-wise augmentation of rolling functions
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_lags">tk_augment_lags()</a></code> - Group-wise augmentation of lagged data
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_differences">tk_augment_differences()</a></code> - Group-wise augmentation of differenced data
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_fourier">tk_augment_fourier()</a></code> - Group-wise augmentation of fourier series
</p>
</li></ul>

<p>Underlying Function:
</p>

<ul>
<li> <p><code><a href="#topic+diff_vec">diff_vec()</a></code> - Underlying function that powers <code>tk_augment_differences()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

m4_monthly %&gt;%
    group_by(id) %&gt;%
    tk_augment_differences(value, .lags = 1:20)

</code></pre>

<hr>
<h2 id='tk_augment_fourier'>Add many fourier series to the data</h2><span id='topic+tk_augment_fourier'></span>

<h3>Description</h3>

<p>A handy function for adding multiple fourier series to a data frame.
Works with <code>dplyr</code> groups too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_augment_fourier(.data, .date_var, .periods, .K = 1, .names = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_augment_fourier_+3A_.data">.data</code></td>
<td>
<p>A tibble.</p>
</td></tr>
<tr><td><code id="tk_augment_fourier_+3A_.date_var">.date_var</code></td>
<td>
<p>A date or date-time column used to calculate a fourier series</p>
</td></tr>
<tr><td><code id="tk_augment_fourier_+3A_.periods">.periods</code></td>
<td>
<p>One or more periods for the fourier series</p>
</td></tr>
<tr><td><code id="tk_augment_fourier_+3A_.k">.K</code></td>
<td>
<p>The maximum number of fourier orders.</p>
</td></tr>
<tr><td><code id="tk_augment_fourier_+3A_.names">.names</code></td>
<td>
<p>A vector of names for the new columns. Must be of same length as the
number of output columns. Use &quot;auto&quot; to automatically rename the columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Benefits</strong>
</p>
<p>This is a scalable function that is:
</p>

<ul>
<li><p> Designed to work with grouped data using <code>dplyr::group_by()</code>
</p>
</li>
<li><p> Add multiple differences by adding a sequence of differences using
the <code>.periods</code> argument (e.g. <code>lags = 1:20</code>)
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a <code>tibble</code> object describing the timeseries.
</p>


<h3>See Also</h3>

<p>Augment Operations:
</p>

<ul>
<li> <p><code><a href="#topic+tk_augment_timeseries_signature">tk_augment_timeseries_signature()</a></code> - Group-wise augmentation of timestamp features
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_holiday_signature">tk_augment_holiday_signature()</a></code> - Group-wise augmentation of holiday features
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_slidify">tk_augment_slidify()</a></code> - Group-wise augmentation of rolling functions
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_lags">tk_augment_lags()</a></code> - Group-wise augmentation of lagged data
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_differences">tk_augment_differences()</a></code> - Group-wise augmentation of differenced data
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_fourier">tk_augment_fourier()</a></code> - Group-wise augmentation of fourier series
</p>
</li></ul>

<p>Underlying Function:
</p>

<ul>
<li> <p><code><a href="#topic+fourier_vec">fourier_vec()</a></code> - Underlying function that powers <code>tk_augment_fourier()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

m4_monthly %&gt;%
    group_by(id) %&gt;%
    tk_augment_fourier(date, .periods = c(6, 12), .K = 2)

</code></pre>

<hr>
<h2 id='tk_augment_holiday'>Add many holiday features to the data</h2><span id='topic+tk_augment_holiday'></span><span id='topic+tk_augment_holiday_signature'></span>

<h3>Description</h3>

<p>Quickly add the &quot;holiday signature&quot; - sets of holiday features that correspond
to calendar dates. Works with <code>dplyr</code> groups too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_augment_holiday_signature(
  .data,
  .date_var = NULL,
  .holiday_pattern = ".",
  .locale_set = c("all", "none", "World", "US", "CA", "GB", "FR", "IT", "JP", "CH", "DE"),
  .exchange_set = c("all", "none", "NYSE", "LONDON", "NERC", "TSX", "ZURICH")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_augment_holiday_+3A_.data">.data</code></td>
<td>
<p>A time-based tibble or time-series object.</p>
</td></tr>
<tr><td><code id="tk_augment_holiday_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing either date or date-time values.
If <code>NULL</code>, the time-based column will interpret from the object (tibble).</p>
</td></tr>
<tr><td><code id="tk_augment_holiday_+3A_.holiday_pattern">.holiday_pattern</code></td>
<td>
<p>A regular expression pattern to search the &quot;Holiday Set&quot;.</p>
</td></tr>
<tr><td><code id="tk_augment_holiday_+3A_.locale_set">.locale_set</code></td>
<td>
<p>Return binary holidays based on locale.
One of: &quot;all&quot;, &quot;none&quot;, &quot;World&quot;, &quot;US&quot;, &quot;CA&quot;, &quot;GB&quot;, &quot;FR&quot;, &quot;IT&quot;, &quot;JP&quot;, &quot;CH&quot;, &quot;DE&quot;.</p>
</td></tr>
<tr><td><code id="tk_augment_holiday_+3A_.exchange_set">.exchange_set</code></td>
<td>
<p>Return binary holidays based on Stock Exchange Calendars.
One of: &quot;all&quot;, &quot;none&quot;, &quot;NYSE&quot;, &quot;LONDON&quot;, &quot;NERC&quot;, &quot;TSX&quot;, &quot;ZURICH&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tk_augment_holiday_signature</code> adds the holiday signature
features. See <code><a href="#topic+tk_get_holiday_signature">tk_get_holiday_signature()</a></code> (powers the augment function)
for a full description and examples for how to use.
</p>
<p><strong>1. Individual Holidays</strong>
</p>
<p>These are <strong>single holiday features</strong> that can be filtered using a pattern.
This helps in identifying which holidays are important to a machine learning model.
This can be useful for example in <strong>e-commerce initiatives</strong>
(e.g. sales during Christmas and Thanskgiving).
</p>
<p><strong>2. Locale-Based Summary Sets</strong>
</p>
<p>Locale-based holdiay sets are useful for <strong>e-commerce initiatives</strong>
(e.g. sales during Christmas and Thanskgiving). Filter on a locale to
identify all holidays in that locale.
</p>
<p><strong>3. Stock Exchange Calendar Summary Sets</strong>
</p>
<p>Exchange-based holdiay sets are useful for identifying <strong>non-working days.</strong>
Filter on an index to identify all holidays that are commonly non-working.
</p>


<h3>Value</h3>

<p>Returns a <code>tibble</code> object describing the holiday timeseries.
</p>


<h3>See Also</h3>

<p>Augment Operations:
</p>

<ul>
<li> <p><code><a href="#topic+tk_augment_timeseries_signature">tk_augment_timeseries_signature()</a></code> - Group-wise augmentation of timestamp features
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_holiday_signature">tk_augment_holiday_signature()</a></code> - Group-wise augmentation of holiday features
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_slidify">tk_augment_slidify()</a></code> - Group-wise augmentation of rolling functions
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_lags">tk_augment_lags()</a></code> - Group-wise augmentation of lagged data
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_differences">tk_augment_differences()</a></code> - Group-wise augmentation of differenced data
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_fourier">tk_augment_fourier()</a></code> - Group-wise augmentation of fourier series
</p>
</li></ul>

<p>Underlying Function:
</p>

<ul>
<li> <p><code><a href="#topic+tk_get_holiday_signature">tk_get_holiday_signature()</a></code> - Underlying function that powers holiday feature generation
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

dates_in_2017_tbl &lt;- tibble(index = tk_make_timeseries("2017-01-01", "2017-12-31", by = "day"))

# Non-working days in US due to Holidays using NYSE stock exchange calendar
dates_in_2017_tbl %&gt;%
    tk_augment_holiday_signature(
        index,
        .holiday_pattern = "^$",   # Returns nothing on purpose
        .locale_set      = "none",
        .exchange_set    = "NYSE")

# All holidays in US
dates_in_2017_tbl %&gt;%
    tk_augment_holiday_signature(
        index,
        .holiday_pattern = "US_",
        .locale_set      = "US",
        .exchange_set    = "none")

# All holidays for World and Italy-specific Holidays
# - Note that Italy celebrates specific holidays in addition to many World Holidays
dates_in_2017_tbl %&gt;%
    tk_augment_holiday_signature(
        index,
        .holiday_pattern = "(World)|(IT_)",
        .locale_set      = c("World", "IT"),
        .exchange_set    = "none")



</code></pre>

<hr>
<h2 id='tk_augment_lags'>Add many lags to the data</h2><span id='topic+tk_augment_lags'></span><span id='topic+tk_augment_leads'></span>

<h3>Description</h3>

<p>A handy function for adding multiple lagged columns to a data frame.
Works with <code>dplyr</code> groups too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_augment_lags(.data, .value, .lags = 1, .names = "auto")

tk_augment_leads(.data, .value, .lags = -1, .names = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_augment_lags_+3A_.data">.data</code></td>
<td>
<p>A tibble.</p>
</td></tr>
<tr><td><code id="tk_augment_lags_+3A_.value">.value</code></td>
<td>
<p>One or more column(s) to have a transformation applied. Usage
of <code>tidyselect</code> functions (e.g. <code>contains()</code>) can be used to select multiple columns.</p>
</td></tr>
<tr><td><code id="tk_augment_lags_+3A_.lags">.lags</code></td>
<td>
<p>One or more lags for the difference(s)</p>
</td></tr>
<tr><td><code id="tk_augment_lags_+3A_.names">.names</code></td>
<td>
<p>A vector of names for the new columns. Must be of same length as <code>.lags</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Lags vs Leads</strong>
</p>
<p>A <em>negative lag</em> is considered a lead. The <code>tk_augment_leads()</code> function is
identical to <code>tk_augment_lags()</code> with the exception that the
automatic naming convetion (<code>.names = 'auto'</code>) will convert column names with negative lags to
leads.
</p>
<p><strong>Benefits</strong>
</p>
<p>This is a scalable function that is:
</p>

<ul>
<li><p> Designed to work with grouped data using <code>dplyr::group_by()</code>
</p>
</li>
<li><p> Add multiple lags by adding a sequence of lags using
the <code>.lags</code> argument (e.g. <code>.lags = 1:20</code>)
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a <code>tibble</code> object describing the timeseries.
</p>


<h3>See Also</h3>

<p>Augment Operations:
</p>

<ul>
<li> <p><code><a href="#topic+tk_augment_timeseries_signature">tk_augment_timeseries_signature()</a></code> - Group-wise augmentation of timestamp features
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_holiday_signature">tk_augment_holiday_signature()</a></code> - Group-wise augmentation of holiday features
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_slidify">tk_augment_slidify()</a></code> - Group-wise augmentation of rolling functions
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_lags">tk_augment_lags()</a></code> - Group-wise augmentation of lagged data
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_differences">tk_augment_differences()</a></code> - Group-wise augmentation of differenced data
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_fourier">tk_augment_fourier()</a></code> - Group-wise augmentation of fourier series
</p>
</li></ul>

<p>Underlying Function:
</p>

<ul>
<li> <p><code><a href="#topic+lag_vec">lag_vec()</a></code> - Underlying function that powers <code>tk_augment_lags()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Lags
m4_monthly %&gt;%
    group_by(id) %&gt;%
    tk_augment_lags(contains("value"), .lags = 1:20)

# Leads
m4_monthly %&gt;%
    group_by(id) %&gt;%
    tk_augment_leads(value, .lags = 1:-20)

</code></pre>

<hr>
<h2 id='tk_augment_slidify'>Add many rolling window calculations to the data</h2><span id='topic+tk_augment_slidify'></span>

<h3>Description</h3>

<p>Quickly use any function as a rolling function and apply to multiple <code>.periods</code>.
Works with <code>dplyr</code> groups too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_augment_slidify(
  .data,
  .value,
  .period,
  .f,
  ...,
  .align = c("center", "left", "right"),
  .partial = FALSE,
  .names = "auto"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_augment_slidify_+3A_.data">.data</code></td>
<td>
<p>A tibble.</p>
</td></tr>
<tr><td><code id="tk_augment_slidify_+3A_.value">.value</code></td>
<td>
<p>One or more column(s) to have a transformation applied. Usage
of <code>tidyselect</code> functions (e.g. <code>contains()</code>) can be used to select multiple columns.</p>
</td></tr>
<tr><td><code id="tk_augment_slidify_+3A_.period">.period</code></td>
<td>
<p>One or more periods for the rolling window(s)</p>
</td></tr>
<tr><td><code id="tk_augment_slidify_+3A_.f">.f</code></td>
<td>
<p>A summary <code style="white-space: pre;">&#8288;[function / formula]&#8288;</code>,</p>
</td></tr>
<tr><td><code id="tk_augment_slidify_+3A_...">...</code></td>
<td>
<p>Optional arguments for the summary function</p>
</td></tr>
<tr><td><code id="tk_augment_slidify_+3A_.align">.align</code></td>
<td>
<p>Rolling functions generate <code>.period - 1</code> fewer values than the incoming vector.
Thus, the vector needs to be aligned. Select one of &quot;center&quot;, &quot;left&quot;, or &quot;right&quot;.</p>
</td></tr>
<tr><td><code id="tk_augment_slidify_+3A_.partial">.partial</code></td>
<td>
<p>.partial Should the moving window be allowed to return partial (incomplete) windows instead of <code>NA</code> values.
Set to FALSE by default, but can be switched to TRUE to remove <code>NA</code>'s.</p>
</td></tr>
<tr><td><code id="tk_augment_slidify_+3A_.names">.names</code></td>
<td>
<p>A vector of names for the new columns. Must be of same length as <code>.period</code>. Default is &quot;auto&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tk_augment_slidify()</code> scales the <code><a href="#topic+slidify_vec">slidify_vec()</a></code> function to multiple
time series <code>.periods</code>. See <code><a href="#topic+slidify_vec">slidify_vec()</a></code> for examples and usage of the core function
arguments.
</p>


<h3>Value</h3>

<p>Returns a <code>tibble</code> object describing the timeseries.
</p>


<h3>See Also</h3>

<p>Augment Operations:
</p>

<ul>
<li> <p><code><a href="#topic+tk_augment_timeseries_signature">tk_augment_timeseries_signature()</a></code> - Group-wise augmentation of timestamp features
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_holiday_signature">tk_augment_holiday_signature()</a></code> - Group-wise augmentation of holiday features
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_slidify">tk_augment_slidify()</a></code> - Group-wise augmentation of rolling functions
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_lags">tk_augment_lags()</a></code> - Group-wise augmentation of lagged data
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_differences">tk_augment_differences()</a></code> - Group-wise augmentation of differenced data
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_fourier">tk_augment_fourier()</a></code> - Group-wise augmentation of fourier series
</p>
</li></ul>

<p>Underlying Function:
</p>

<ul>
<li> <p><code><a href="#topic+slidify_vec">slidify_vec()</a></code> - The underlying function that powers <code>tk_augment_slidify()</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Single Column | Multiple Rolling Windows
FANG %&gt;%
    select(symbol, date, adjusted) %&gt;%
    group_by(symbol) %&gt;%
    tk_augment_slidify(
        .value   = contains("adjust"),
        # Multiple rolling windows
        .period  = c(10, 30, 60, 90),
        .f       = mean,
        .partial = TRUE,
        .names   = stringr::str_c("MA_", c(10, 30, 60, 90))
    ) %&gt;%
    ungroup()

# Multiple Columns | Multiple Rolling Windows
FANG %&gt;%
    select(symbol, date, adjusted, volume) %&gt;%
    group_by(symbol) %&gt;%
    tk_augment_slidify(
        .value  = c(adjusted, volume),
        .period  = c(10, 30, 60, 90),
        .f       = mean,
        .partial = TRUE
    ) %&gt;%
    ungroup()

</code></pre>

<hr>
<h2 id='tk_augment_timeseries'>Add many time series features to the data</h2><span id='topic+tk_augment_timeseries'></span><span id='topic+tk_augment_timeseries_signature'></span>

<h3>Description</h3>

<p>Add many time series features to the data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_augment_timeseries_signature(.data, .date_var = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_augment_timeseries_+3A_.data">.data</code></td>
<td>
<p>A time-based tibble or time-series object.</p>
</td></tr>
<tr><td><code id="tk_augment_timeseries_+3A_.date_var">.date_var</code></td>
<td>
<p>For <code>tibbles</code>, a column containing either date or date-time values.
If <code>NULL</code>, the time-based column will interpret from the object (tibble, xts, zoo, etc).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tk_augment_timeseries_signature()</code> adds 25+ time series features including:
</p>

<ul>
<li> <p><strong>Trend in Seconds Granularity:</strong> index.num
</p>
</li>
<li> <p><strong>Yearly Seasonality:</strong> Year, Month, Quarter
</p>
</li>
<li> <p><strong>Weekly Seasonality:</strong> Week of Month, Day of Month, Day of Week, and more
</p>
</li>
<li> <p><strong>Daily Seasonality:</strong> Hour, Minute, Second
</p>
</li>
<li> <p><strong>Weekly Cyclic Patterns:</strong> 2 weeks, 3 weeks, 4 weeks
</p>
</li></ul>



<h3>Value</h3>

<p>Returns a <code>tibble</code> object describing the timeseries.
</p>


<h3>See Also</h3>

<p>Augment Operations:
</p>

<ul>
<li> <p><code><a href="#topic+tk_augment_timeseries_signature">tk_augment_timeseries_signature()</a></code> - Group-wise augmentation of timestamp features
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_holiday_signature">tk_augment_holiday_signature()</a></code> - Group-wise augmentation of holiday features
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_slidify">tk_augment_slidify()</a></code> - Group-wise augmentation of rolling functions
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_lags">tk_augment_lags()</a></code> - Group-wise augmentation of lagged data
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_differences">tk_augment_differences()</a></code> - Group-wise augmentation of differenced data
</p>
</li>
<li> <p><code><a href="#topic+tk_augment_fourier">tk_augment_fourier()</a></code> - Group-wise augmentation of fourier series
</p>
</li></ul>

<p>Underlying Function:
</p>

<ul>
<li> <p><code><a href="#topic+tk_get_timeseries_signature">tk_get_timeseries_signature()</a></code> - Returns timeseries features from an index
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

m4_daily %&gt;%
    group_by(id) %&gt;%
    tk_augment_timeseries_signature(date)

</code></pre>

<hr>
<h2 id='tk_get_frequency'>Automatic frequency and trend calculation from a time series index</h2><span id='topic+tk_get_frequency'></span><span id='topic+tk_get_trend'></span>

<h3>Description</h3>

<p>Automatic frequency and trend calculation from a time series index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_get_frequency(idx, period = "auto", message = TRUE)

tk_get_trend(idx, period = "auto", message = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_get_frequency_+3A_idx">idx</code></td>
<td>
<p>A date or datetime index.</p>
</td></tr>
<tr><td><code id="tk_get_frequency_+3A_period">period</code></td>
<td>
<p>Either &quot;auto&quot;, a time-based definition (e.g. &quot;2 weeks&quot;),
or a numeric number of observations per frequency (e.g. 10).</p>
</td></tr>
<tr><td><code id="tk_get_frequency_+3A_message">message</code></td>
<td>
<p>A boolean. If <code>message = TRUE</code>, the frequency or trend is output
as a message along with the units in the scale of the data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <em>frequency</em> is loosely defined as the number of observations that comprise a cycle
in a data set. The <em>trend</em> is loosely defined as time span that can
be aggregated across to visualize the central tendency of the data.
It's often easiest to think of frequency and trend in terms of the time-based units
that the data is already in. <strong>This is what <code>tk_get_frequency()</code> and <code>time_trend()</code>
enable: using time-based periods to define the frequency or trend.</strong>
</p>
<p><strong>Frequency</strong>:
</p>
<p>As an example, a weekly cycle is often 5-days (for working
days) or 7-days (for calendar days). Rather than specify a frequency of 5 or 7,
the user can specify <code>period = "1 week"</code>, and
<code>tk_get_frequency()</code> will detect the scale of the time series and return 5 or 7
based on the actual data.
</p>
<p>The <code>period</code> argument has three basic options for returning a frequency.
Options include:
</p>

<ul>
<li> <p><code>"auto"</code>: A target frequency is determined using a pre-defined template (see <code>template</code> below).
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;time-based duration&#8288;</code>: (e.g. &quot;1 week&quot; or &quot;2 quarters&quot; per cycle)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;numeric number of observations&#8288;</code>: (e.g. 5 for 5 observations per cycle)
</p>
</li></ul>

<p>When <code>period = "auto"</code>, the <code>tk_time_scale_template()</code> is used to calculate the frequency.
</p>
<p><strong>Trend</strong>:
</p>
<p>As an example, the trend of daily data is often best aggregated by evaluating
the moving average over a quarter or a month span. Rather than specify the number
of days in a quarter or month, the user can specify &quot;1 quarter&quot; or &quot;1 month&quot;,
and the <code>time_trend()</code> function will return the correct number of observations
per trend cycle. In addition, there is an option, <code>period = "auto"</code>, to
auto-detect an appropriate trend span depending on the data. The <code>template</code>
is used to define the appropriate trend span.
</p>
<p><strong>Time Scale Template</strong>
</p>
<p>The <code>tk_time_scale_template()</code> is a Look-Up Table used by the trend and period to find the
appropriate time scale. It contains three features: <code>time_scale</code>, <code>frequency</code>, and <code>trend</code>.
</p>
<p>The algorithm will inspect
the scale of the time series and select the best frequency or trend that matches the scale and
number of observations per target frequency. A frequency is then chosen on be the
best match.
</p>
<p>The predefined template is stored in a function <code>tk_time_scale_template()</code>.
You can modify the template with <code>set_tk_time_scale_template()</code>.
</p>


<h3>Value</h3>

<p>Returns a scalar numeric value indicating the number of observations in the frequency or trend span.
</p>


<h3>See Also</h3>


<ul>
<li><p> Time Scale Template Modifiers: <code><a href="#topic+get_tk_time_scale_template">get_tk_time_scale_template()</a></code>, <code><a href="#topic+set_tk_time_scale_template">set_tk_time_scale_template()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

idx_FB &lt;- FANG %&gt;%
    filter(symbol == "FB") %&gt;%
    pull(date)

# Automated Frequency Calculation
tk_get_frequency(idx_FB, period = "auto")

# Automated Trend Calculation
tk_get_trend(idx_FB, period = "auto")

# Manually Override Trend
tk_get_trend(idx_FB, period = "1 year")

</code></pre>

<hr>
<h2 id='tk_get_holiday'>Get holiday features from a time-series index</h2><span id='topic+tk_get_holiday'></span><span id='topic+tk_get_holiday_signature'></span><span id='topic+tk_get_holidays_by_year'></span>

<h3>Description</h3>

<p>Get holiday features from a time-series index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_get_holiday_signature(
  idx,
  holiday_pattern = ".",
  locale_set = c("all", "none", "World", "US", "CA", "GB", "FR", "IT", "JP", "CH", "DE"),
  exchange_set = c("all", "none", "NYSE", "LONDON", "NERC", "TSX", "ZURICH")
)

tk_get_holidays_by_year(years = year(today()))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_get_holiday_+3A_idx">idx</code></td>
<td>
<p>A time-series index that is a vector of dates or datetimes.</p>
</td></tr>
<tr><td><code id="tk_get_holiday_+3A_holiday_pattern">holiday_pattern</code></td>
<td>
<p>A regular expression pattern to search the &quot;Holiday Set&quot;.</p>
</td></tr>
<tr><td><code id="tk_get_holiday_+3A_locale_set">locale_set</code></td>
<td>
<p>Return binary holidays based on locale.
One of: &quot;all&quot;, &quot;none&quot;, &quot;World&quot;, &quot;US&quot;, &quot;CA&quot;, &quot;GB&quot;, &quot;FR&quot;, &quot;IT&quot;, &quot;JP&quot;, &quot;CH&quot;, &quot;DE&quot;.</p>
</td></tr>
<tr><td><code id="tk_get_holiday_+3A_exchange_set">exchange_set</code></td>
<td>
<p>Return binary holidays based on Stock Exchange Calendars.
One of: &quot;all&quot;, &quot;none&quot;, &quot;NYSE&quot;, &quot;LONDON&quot;, &quot;NERC&quot;, &quot;TSX&quot;, &quot;ZURICH&quot;.</p>
</td></tr>
<tr><td><code id="tk_get_holiday_+3A_years">years</code></td>
<td>
<p>One or more years to collect holidays for.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Feature engineering holidays can help identify critical patterns for
machine learning algorithms. <code>tk_get_holiday_signature()</code> helps by providing
feature sets for 3 types of features:
</p>
<p><strong>1. Individual Holidays</strong>
</p>
<p>These are <strong>single holiday features</strong> that can be filtered using a pattern.
This helps in identifying which holidays are important to a machine learning model.
This can be useful for example in <strong>e-commerce initiatives</strong>
(e.g. sales during Christmas and Thanskgiving).
</p>
<p><strong>2. Locale-Based Summary Sets</strong>
</p>
<p>Locale-based holdiay sets are useful for <strong>e-commerce initiatives</strong>
(e.g. sales during Christmas and Thanskgiving). Filter on a locale to
identify all holidays in that locale.
</p>
<p><strong>3. Stock Exchange Calendar Summary Sets</strong>
</p>
<p>Exchange-based holdiay sets are useful for identifying <strong>non-working days.</strong>
Filter on an index to identify all holidays that are commonly non-working.
</p>


<h3>Value</h3>

<p>Returns a <code>tibble</code> object describing the timeseries holidays.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+tk_augment_holiday_signature">tk_augment_holiday_signature()</a></code> - A quick way to add holiday features to a data.frame
</p>
</li>
<li> <p><code><a href="#topic+step_holiday_signature">step_holiday_signature()</a></code> - Preprocessing and feature engineering steps for use with <code>recipes</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(stringr)

# Works with time-based tibbles
idx &lt;- tk_make_timeseries("2017-01-01", "2017-12-31", by = "day")

# --- BASIC USAGE ----

tk_get_holiday_signature(idx)

# ---- FILTERING WITH PATTERNS &amp; SETS ----

# List available holidays - see patterns
tk_get_holidays_by_year(2020) %&gt;%
    filter(holiday_name %&gt;% str_detect("US_"))

# Filter using holiday patterns
# - Get New Years, Christmas and Thanksgiving Features in US
tk_get_holiday_signature(
    idx,
    holiday_pattern = "(US_NewYears)|(US_Christmas)|(US_Thanks)",
    locale_set      = "none",
    exchange_set    = "none")

# ---- APPLYING FILTERS ----

# Filter with locale sets - Signals all holidays in a locale
tk_get_holiday_signature(
    idx,
    holiday_pattern = "$^", # Matches nothing on purpose
    locale_set      = "US",
    exchange_set    = "none")

# Filter with exchange sets - Signals Common Non-Business Days
tk_get_holiday_signature(
    idx,
    holiday_pattern = "$^", # Matches nothing on purpose
    locale_set      = "none",
    exchange_set    = "NYSE")

</code></pre>

<hr>
<h2 id='tk_get_timeseries'>Get date features from a time-series index</h2><span id='topic+tk_get_timeseries'></span><span id='topic+tk_get_timeseries_signature'></span><span id='topic+tk_get_timeseries_summary'></span>

<h3>Description</h3>

<p>Get date features from a time-series index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_get_timeseries_signature(idx)

tk_get_timeseries_summary(idx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_get_timeseries_+3A_idx">idx</code></td>
<td>
<p>A time-series index that is a vector of dates or datetimes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tk_get_timeseries_signature</code> decomposes the timeseries into commonly
needed features such as
numeric value, differences,
year, month, day, day of week, day of month,
day of year, hour, minute, second.
</p>
<p><code>tk_get_timeseries_summary</code> returns the summary returns the
start, end, units, scale, and a &quot;summary&quot; of the timeseries differences
in seconds including
the minimum, 1st quartile, median, mean, 3rd quartile, and maximum frequency.
The timeseries
differences give the user a better picture of the index frequency
so the user can understand the level of regularity or irregularity.
A perfectly regular time series will have equal values in seconds for each metric.
However, this is not often the case.
</p>
<p><strong>Important Note</strong>: These functions only work with time-based indexes in
datetime, date, yearmon, and yearqtr values. Regularized dates cannot be decomposed.
</p>


<h3>Value</h3>

<p>Returns a <code>tibble</code> object describing the timeseries.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tk_index">tk_index()</a></code>, <code><a href="#topic+tk_augment_timeseries_signature">tk_augment_timeseries_signature()</a></code>, <code><a href="#topic+tk_make_future_timeseries">tk_make_future_timeseries()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(lubridate)
library(zoo)

# Works with time-based tibbles
FB_tbl &lt;- FANG %&gt;% dplyr::filter(symbol == "FB")
FB_idx &lt;- tk_index(FB_tbl)

tk_get_timeseries_signature(FB_idx)
tk_get_timeseries_summary(FB_idx)


# Works with dates in any periodicity
idx_weekly &lt;- seq.Date(from = lubridate::ymd("2016-01-01"), by = 'week', length.out = 6)

tk_get_timeseries_signature(idx_weekly)
tk_get_timeseries_summary(idx_weekly)


# Works with zoo yearmon and yearqtr classes
idx_yearmon &lt;- seq.Date(from       = lubridate::ymd("2016-01-01"),
                        by         = "month",
                        length.out = 12) %&gt;%
    zoo::as.yearmon()

tk_get_timeseries_signature(idx_yearmon)
tk_get_timeseries_summary(idx_yearmon)

</code></pre>

<hr>
<h2 id='tk_get_timeseries_unit_frequency'>Get the timeseries unit frequency for the primary time scales</h2><span id='topic+tk_get_timeseries_unit_frequency'></span>

<h3>Description</h3>

<p>Get the timeseries unit frequency for the primary time scales
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_get_timeseries_unit_frequency()
</code></pre>


<h3>Value</h3>

<p><code>tk_get_timeseries_unit_frequency</code> returns a tibble containing
the timeseries frequencies in seconds for the primary time scales including
&quot;sec&quot;, &quot;min&quot;, &quot;hour&quot;, &quot;day&quot;, &quot;week&quot;, &quot;month&quot;, &quot;quarter&quot;, and &quot;year&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tk_get_timeseries_unit_frequency()


</code></pre>

<hr>
<h2 id='tk_get_timeseries_variables'>Get date or datetime variables (column names)</h2><span id='topic+tk_get_timeseries_variables'></span>

<h3>Description</h3>

<p>Get date or datetime variables (column names)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_get_timeseries_variables(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_get_timeseries_variables_+3A_data">data</code></td>
<td>
<p>An object of class <code>data.frame</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tk_get_timeseries_variables</code> returns the column names of date or datetime variables
in a data frame.
Classes that meet criteria for return include those that inherit
<code>POSIXt</code>, <code>Date</code>, <code>zoo::yearmon</code>, <code>zoo::yearqtr</code>. Function was adapted from <code>padr:::get_date_variables()</code>.
See <a href="https://github.com/EdwinTh/padr/blob/master/R/helpers.R">padr helpers.R</a>
</p>


<h3>Value</h3>

<p><code>tk_get_timeseries_variables</code> returns a vector containing column names of date-like classes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

FANG %&gt;%
    tk_get_timeseries_variables()

</code></pre>

<hr>
<h2 id='tk_index'>Extract an index of date or datetime from time series objects, models, forecasts</h2><span id='topic+tk_index'></span><span id='topic+has_timetk_idx'></span>

<h3>Description</h3>

<p>Extract an index of date or datetime from time series objects, models, forecasts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_index(data, timetk_idx = FALSE, silent = FALSE)

has_timetk_idx(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_index_+3A_data">data</code></td>
<td>
<p>A time-based tibble, time-series object, time-series model,
or <code>forecast</code> object.</p>
</td></tr>
<tr><td><code id="tk_index_+3A_timetk_idx">timetk_idx</code></td>
<td>
<p>If <code>timetk_idx</code> is <code>TRUE</code> a timetk time-based index attribute is attempted to be returned.
If <code>FALSE</code> the default index is returned. See discussion below for further details.</p>
</td></tr>
<tr><td><code id="tk_index_+3A_silent">silent</code></td>
<td>
<p>Used to toggle printing of messages and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tk_index()</code> is used to extract the date or datetime index from various
time series objects, models and forecasts.
The method can be used on <code>tbl</code>, <code>xts</code>, <code>zoo</code>, <code>zooreg</code>, and <code>ts</code> objects.
The method can additionally be used on <code>forecast</code> objects and a number of
objects generated by modeling functions such as <code>Arima</code>, <code>ets</code>, and <code>HoltWinters</code>
classes to get the index of the underlying data.
</p>
<p>The boolean <code>timetk_idx</code> argument is applicable to regularized time series objects
such as <code>ts</code> and <code>zooreg</code> classes that have both a regularized index and <em>potentially</em>
a &quot;timetk index&quot; (a time-based attribute).
When set to <code>FALSE</code> the regularized index is returned.
When set to <code>TRUE</code> the time-based timetk index is returned <em>if present</em>.
</p>
<p><code>has_timetk_idx()</code> is used to determine if the object has a &quot;timetk index&quot; attribute
and can thus benefit from the <code>tk_index(timetk_idx = TRUE)</code>.
<code>TRUE</code> indicates the &quot;timetk index&quot; attribute is present.
<code>FALSE</code> indicates the &quot;timetk index&quot; attribute is not present.
If <code>FALSE</code>, the <code>tk_index()</code> function will return the default index for the data type.
</p>
<p><strong>Important Note</strong>: To gain the benefit of <code>timetk_idx</code> the time series
must have a timetk index.
Use <code>has_timetk_idx</code> to determine if the object has a timetk index.
This is particularly important for <code>ts</code> objects, which
by default do not contain a time-based index and therefore must be coerced from time-based
objects such as <code>tbl</code>, <code>xts</code>, or <code>zoo</code> using the <code>tk_ts()</code> function in order
to get the &quot;timetk index&quot; attribute.
Refer to <code><a href="#topic+tk_ts">tk_ts()</a></code> for creating persistent date / datetime index
during coercion to <code>ts</code>.
</p>


<h3>Value</h3>

<p>Returns a vector of date or date times
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tk_ts">tk_ts()</a></code>, <code><a href="#topic+tk_tbl">tk_tbl()</a></code>, <code><a href="#topic+tk_xts">tk_xts()</a></code>, <code><a href="#topic+tk_zoo">tk_zoo()</a></code>, <code><a href="#topic+tk_zooreg">tk_zooreg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create time-based tibble
data_tbl &lt;- tibble::tibble(
    date = seq.Date(from = as.Date("2000-01-01"), by = 1, length.out = 5),
    x    = rnorm(5) * 10,
    y    = 5:1
)
tk_index(data_tbl) # Returns time-based index vector

# Coerce to ts using tk_ts(): Preserves time-basis
data_ts &lt;- tk_ts(data_tbl)
tk_index(data_ts, timetk_idx = FALSE) # Returns regularized index
tk_index(data_ts, timetk_idx = TRUE)  # Returns original time-based index vector

# Coercing back to tbl
tk_tbl(data_ts, timetk_idx = FALSE) # Returns regularized tbl
tk_tbl(data_ts, timetk_idx = TRUE)  # Returns time-based tbl



</code></pre>

<hr>
<h2 id='tk_make_future_timeseries'>Make future time series from existing</h2><span id='topic+tk_make_future_timeseries'></span>

<h3>Description</h3>

<p>Make future time series from existing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_make_future_timeseries(
  idx,
  length_out,
  inspect_weekdays = FALSE,
  inspect_months = FALSE,
  skip_values = NULL,
  insert_values = NULL,
  n_future = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_make_future_timeseries_+3A_idx">idx</code></td>
<td>
<p>A vector of dates</p>
</td></tr>
<tr><td><code id="tk_make_future_timeseries_+3A_length_out">length_out</code></td>
<td>
<p>Number of future observations. Can be numeric number or a phrase
like &quot;1 year&quot;.</p>
</td></tr>
<tr><td><code id="tk_make_future_timeseries_+3A_inspect_weekdays">inspect_weekdays</code></td>
<td>
<p>Uses a logistic regression algorithm to inspect
whether certain weekdays (e.g. weekends) should be excluded from the future dates.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tk_make_future_timeseries_+3A_inspect_months">inspect_months</code></td>
<td>
<p>Uses a logistic regression algorithm to inspect
whether certain days of months (e.g. last two weeks of year or seasonal days)
should be excluded from the future dates.
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tk_make_future_timeseries_+3A_skip_values">skip_values</code></td>
<td>
<p>A vector of same class as <code>idx</code> of timeseries
values to skip.</p>
</td></tr>
<tr><td><code id="tk_make_future_timeseries_+3A_insert_values">insert_values</code></td>
<td>
<p>A vector of same class as <code>idx</code> of timeseries
values to insert.</p>
</td></tr>
<tr><td><code id="tk_make_future_timeseries_+3A_n_future">n_future</code></td>
<td>
<p>(DEPRECATED) Number of future observations. Can be numeric number or a phrase
like &quot;1 year&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Future Sequences</strong>
</p>
<p><code>tk_make_future_timeseries</code> returns a time series based
on the input index frequency and attributes.
</p>
<p><strong>Specifying Length of Future Observations</strong>
</p>
<p>The argument <code>length_out</code> determines how many future index observations to compute. It can be specified
as:
</p>

<ul>
<li> <p><strong>A numeric value</strong> - the number of future observations to return.
</p>

<ul>
<li><p> The number of observations returned is <em>always</em> equal to the value the user inputs.
</p>
</li>
<li><p> The <strong>end date can vary</strong> based on the number of timestamps chosen.
</p>
</li></ul>

</li>
<li> <p><strong>A time-based phrase</strong> - The duration into the future to include (e.g. &quot;6 months&quot; or &quot;30 minutes&quot;).
</p>

<ul>
<li><p> The <em>duration</em> defines the <em>end date</em> for observations.
</p>
</li>
<li><p> The <strong>end date will not change</strong> and those timestamps that fall within the end date will be returned
(e.g. a quarterly time series will return 4 quarters if <code>length_out = "1 year"</code>).
</p>
</li>
<li><p> The number of observations will vary to fit within the end date.
</p>
</li></ul>

</li></ul>

<p><strong>Weekday and Month Inspection</strong>
</p>
<p>The <code>inspect_weekdays</code> and <code>inspect_months</code> arguments apply to &quot;daily&quot; (scale = &quot;day&quot;) data
(refer to <code>tk_get_timeseries_summary()</code> to get the index scale).
</p>

<ul>
<li><p> The <code>inspect_weekdays</code> argument is useful in determining missing days of the week
that occur on a weekly frequency such as every week, every other week, and so on.
It's recommended to have at least 60 days to use this option.
</p>
</li>
<li><p> The <code>inspect_months</code> argument is useful in determining missing days of the month, quarter
or year; however, the algorithm can inadvertently select incorrect dates if the pattern
is erratic.
</p>
</li></ul>

<p><strong>Skipping / Inserting Values</strong>
</p>
<p>The <code>skip_values</code> and <code>insert_values</code> arguments can be used to remove and add
values into the series of future times. The values must be the same format as the <code>idx</code> class.
</p>

<ul>
<li><p> The <code>skip_values</code> argument useful for passing holidays or special index values that should
be excluded from the future time series.
</p>
</li>
<li><p> The <code>insert_values</code> argument is useful for adding values back that the algorithm may have
excluded.
</p>
</li></ul>



<h3>Value</h3>

<p>A vector containing future index of the same class as the incoming index <code>idx</code>
</p>


<h3>See Also</h3>


<ul>
<li><p> Making Time Series: <code><a href="#topic+tk_make_timeseries">tk_make_timeseries()</a></code>
</p>
</li>
<li><p> Working with Holidays &amp; Weekends: <code><a href="#topic+tk_make_holiday_sequence">tk_make_holiday_sequence()</a></code>, <code><a href="#topic+tk_make_weekend_sequence">tk_make_weekend_sequence()</a></code>, <code><a href="#topic+tk_make_weekday_sequence">tk_make_weekday_sequence()</a></code>
</p>
</li>
<li><p> Working with Timestamp Index: <code><a href="#topic+tk_index">tk_index()</a></code>, <code><a href="#topic+tk_get_timeseries_summary">tk_get_timeseries_summary()</a></code>, <code><a href="#topic+tk_get_timeseries_signature">tk_get_timeseries_signature()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Basic example - By 3 seconds
idx &lt;- tk_make_timeseries("2016-01-01 00:00:00", by = "3 sec", length_out = 3)
idx

# Make next three timestamps in series
idx %&gt;% tk_make_future_timeseries(length_out = 3)

# Make next 6 seconds of timestamps from the next timestamp
idx %&gt;% tk_make_future_timeseries(length_out = "6 sec")


# Basic Example - By 1 Month
idx &lt;- tk_make_timeseries("2016-01-01", by = "1 month",
                          length_out = "12 months")
idx

# Make 12 months of timestamps from the next timestamp
idx %&gt;% tk_make_future_timeseries(length_out = "12 months")



# --- APPLICATION ---
# - Combine holiday sequences with future sequences

# Create index of days that FB stock will be traded in 2017 based on 2016 + holidays
FB_tbl &lt;- FANG %&gt;% dplyr::filter(symbol == "FB")

holidays &lt;- tk_make_holiday_sequence(
    start_date = "2017-01-01",
    end_date   = "2017-12-31",
    calendar   = "NYSE")

# Remove holidays with skip_values, and remove weekends with inspect_weekdays = TRUE
FB_tbl %&gt;%
    tk_index() %&gt;%
    tk_make_future_timeseries(length_out       = "1 year",
                              inspect_weekdays = TRUE,
                              skip_values      = holidays)




</code></pre>

<hr>
<h2 id='tk_make_holiday_sequence'>Make daily Holiday and Weekend date sequences</h2><span id='topic+tk_make_holiday_sequence'></span><span id='topic+tk_make_weekend_sequence'></span><span id='topic+tk_make_weekday_sequence'></span>

<h3>Description</h3>

<p>Make daily Holiday and Weekend date sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_make_holiday_sequence(
  start_date,
  end_date,
  calendar = c("NYSE", "LONDON", "NERC", "TSX", "ZURICH"),
  skip_values = NULL,
  insert_values = NULL
)

tk_make_weekend_sequence(start_date, end_date)

tk_make_weekday_sequence(
  start_date,
  end_date,
  remove_weekends = TRUE,
  remove_holidays = FALSE,
  calendar = c("NYSE", "LONDON", "NERC", "TSX", "ZURICH"),
  skip_values = NULL,
  insert_values = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_make_holiday_sequence_+3A_start_date">start_date</code></td>
<td>
<p>Used to define the starting date for date sequence generation.
Provide in &quot;YYYY-MM-DD&quot; format.</p>
</td></tr>
<tr><td><code id="tk_make_holiday_sequence_+3A_end_date">end_date</code></td>
<td>
<p>Used to define the ending date for date sequence generation.
Provide in &quot;YYYY-MM-DD&quot; format.</p>
</td></tr>
<tr><td><code id="tk_make_holiday_sequence_+3A_calendar">calendar</code></td>
<td>
<p>The calendar to be used in Date Sequence calculations for Holidays
from the <code>timeDate</code> package.
Acceptable values are: <code>"NYSE"</code>, <code>"LONDON"</code>, <code>"NERC"</code>, <code>"TSX"</code>, <code>"ZURICH"</code>.</p>
</td></tr>
<tr><td><code id="tk_make_holiday_sequence_+3A_skip_values">skip_values</code></td>
<td>
<p>A daily date sequence to skip</p>
</td></tr>
<tr><td><code id="tk_make_holiday_sequence_+3A_insert_values">insert_values</code></td>
<td>
<p>A daily date sequence to insert</p>
</td></tr>
<tr><td><code id="tk_make_holiday_sequence_+3A_remove_weekends">remove_weekends</code></td>
<td>
<p>A logical value indicating whether or not to
remove weekends (Saturday and Sunday) from the date sequence</p>
</td></tr>
<tr><td><code id="tk_make_holiday_sequence_+3A_remove_holidays">remove_holidays</code></td>
<td>
<p>A logical value indicating whether or not to
remove common holidays from the date sequence</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Start and End Date Specification</strong>
</p>

<ul>
<li><p> Accept shorthand notation (i.e. <code>tk_make_timeseries()</code> specifications apply)
</p>
</li>
<li><p> Only available in Daily Periods.
</p>
</li></ul>

<p><strong>Holiday Sequences</strong>
</p>
<p><code>tk_make_holiday_sequence()</code> is a wrapper for various holiday calendars from the <code>timeDate</code> package,
making it easy to generate holiday sequences for common business calendars:
</p>

<ul>
<li><p> New York Stock Exchange: <code>calendar = "NYSE"</code>
</p>
</li>
<li><p> Londo Stock Exchange: <code>"LONDON"</code>
</p>
</li>
<li><p> North American Reliability Council: <code>"NERC"</code>
</p>
</li>
<li><p> Toronto Stock Exchange: <code>"TSX"</code>
</p>
</li>
<li><p> Zurich Stock Exchange: <code>"ZURICH"</code>
</p>
</li></ul>

<p><strong>Weekend and Weekday Sequences</strong>
</p>
<p>These simply populate
</p>


<h3>Value</h3>

<p>A vector containing future dates
</p>


<h3>See Also</h3>


<ul>
<li><p> Intelligent date or date-time sequence creation: <code><a href="#topic+tk_make_timeseries">tk_make_timeseries()</a></code>
</p>
</li>
<li><p> Holidays and weekends: <code><a href="#topic+tk_make_holiday_sequence">tk_make_holiday_sequence()</a></code>, <code><a href="#topic+tk_make_weekend_sequence">tk_make_weekend_sequence()</a></code>, <code><a href="#topic+tk_make_weekday_sequence">tk_make_weekday_sequence()</a></code>
</p>
</li>
<li><p> Make future index from existing: <code><a href="#topic+tk_make_future_timeseries">tk_make_future_timeseries()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Set max.print to 50
options_old &lt;- options()$max.print
options(max.print = 50)


# ---- HOLIDAYS &amp; WEEKENDS ----

# Business Holiday Sequence
tk_make_holiday_sequence("2017-01-01", "2017-12-31", calendar = "NYSE")

tk_make_holiday_sequence("2017", calendar = "NYSE") # Same thing as above (just shorter)

# Weekday Sequence
tk_make_weekday_sequence("2017", "2018", remove_holidays = TRUE)

# Weekday Sequence + Removing Business Holidays
tk_make_weekday_sequence("2017", "2018", remove_holidays = TRUE)


# ---- COMBINE HOLIDAYS WITH MAKE FUTURE TIMESERIES FROM EXISTING ----
# - A common machine learning application is creating a future time series data set
#   from an existing

# Create index of days that FB stock will be traded in 2017 based on 2016 + holidays
FB_tbl &lt;- FANG %&gt;% dplyr::filter(symbol == "FB")

holidays &lt;- tk_make_holiday_sequence(
    start_date = "2016",
    end_date   = "2017",
    calendar   = "NYSE")

weekends &lt;- tk_make_weekend_sequence(
    start_date = "2016",
    end_date   = "2017")

# Remove holidays and weekends with skip_values
# We could also remove weekends with inspect_weekdays = TRUE
FB_tbl %&gt;%
    tk_index() %&gt;%
    tk_make_future_timeseries(length_out       = 366,
                              skip_values      = c(holidays, weekends))


options(max.print = options_old)

</code></pre>

<hr>
<h2 id='tk_make_timeseries'>Intelligent date and date-time sequence creation</h2><span id='topic+tk_make_timeseries'></span>

<h3>Description</h3>

<p>Improves on the <code>seq.Date()</code> and <code>seq.POSIXt()</code> functions by simplifying
into 1 function <code>tk_make_timeseries()</code>. Intelligently handles character dates
and logical assumptions based on user inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_make_timeseries(
  start_date,
  end_date,
  by,
  length_out = NULL,
  include_endpoints = TRUE,
  skip_values = NULL,
  insert_values = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_make_timeseries_+3A_start_date">start_date</code></td>
<td>
<p>Used to define the starting date for date sequence generation.
Provide in &quot;YYYY-MM-DD&quot; format.</p>
</td></tr>
<tr><td><code id="tk_make_timeseries_+3A_end_date">end_date</code></td>
<td>
<p>Used to define the ending date for date sequence generation.
Provide in &quot;YYYY-MM-DD&quot; format.</p>
</td></tr>
<tr><td><code id="tk_make_timeseries_+3A_by">by</code></td>
<td>
<p>A character string, containing one of
<code>"sec"</code>, <code>"min"</code>, <code>"hour"</code>, <code>"day"</code>, <code>"week"</code>, <code>"month"</code>, <code>"quarter"</code> or <code>"year"</code>.
You can create regularly spaced sequences using phrases like <code>by = "10 min"</code>. See Details.</p>
</td></tr>
<tr><td><code id="tk_make_timeseries_+3A_length_out">length_out</code></td>
<td>
<p>Optional length of the sequence. Can be used instead of one of:
<code>start_date</code>, <code>end_date</code>, or <code>by</code>. Can be specified as a number or a time-based phrase.</p>
</td></tr>
<tr><td><code id="tk_make_timeseries_+3A_include_endpoints">include_endpoints</code></td>
<td>
<p>Logical. Whether or not to keep the last value when <code>length_out</code> is
a time-based phrase. Default is <code>TRUE</code> (keep last value).</p>
</td></tr>
<tr><td><code id="tk_make_timeseries_+3A_skip_values">skip_values</code></td>
<td>
<p>A sequence to skip</p>
</td></tr>
<tr><td><code id="tk_make_timeseries_+3A_insert_values">insert_values</code></td>
<td>
<p>A sequence to insert</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>tk_make_timeseries()</code> function handles both date and date-time sequences
automatically.
</p>

<ul>
<li><p> Parses date and date times from character
</p>
</li>
<li><p> Intelligently guesses the sequence desired based on arguments provided
</p>
</li>
<li><p> Handles spacing intelligently
</p>
</li>
<li><p> When both <code>by</code> and <code>length_out</code> are missing, guesses either second or day sequences
</p>
</li>
<li><p> Can skip and insert values if needed.
</p>
</li></ul>

<p><strong>Start and End Date Specification</strong>
</p>
<p>Start and end dates can be specified in reduced time-based phrases:
</p>

<ul>
<li> <p><code>start_date = "2014"</code>: Is converted to &quot;2014-01-01&quot; (start of period)
</p>
</li>
<li> <p><code>end_date = "2014"</code>: Is converted to &quot;2014-12-31&quot; (end of period)
</p>
</li>
<li> <p><code>start_date = "2014-03"</code>: Is converted to &quot;2014-03-01&quot; (start of period)
</p>
</li>
<li> <p><code>end_date = "2014-03"</code>: Is converted to &quot;2014-03-31&quot; (end of period)
</p>
</li></ul>

<p>A similar process can be used for date-times.
</p>
<p><strong>By: Daily Sequences</strong>
</p>
<p>Make a daily sequence with <code>tk_make_timeseries(by)</code>. Examples:
</p>

<ul>
<li><p> Every Day: <code>by = "day"</code>
</p>
</li>
<li><p> Every 2-Weeks: <code>by = "2 weeks"</code>
</p>
</li>
<li><p> Every 6-months: <code>by = "6 months"</code>
</p>
</li></ul>

<p>If missing, will guess <code>by = "day"</code>
</p>
<p><strong>By: Sub-Daily Sequences</strong>
</p>
<p>Make a sub-daily sequence with <code>tk_make_timeseries(by)</code>. Examples:
</p>

<ul>
<li><p> Every minute: <code>by = "min"</code>
</p>
</li>
<li><p> Every 30-seconds: <code>by = "30 sec"</code>
</p>
</li>
<li><p> Every 2-hours: <code style="white-space: pre;">&#8288;by = "2 hours&#8288;</code>
</p>
</li></ul>

<p>If missing, will guess <code>by = "sec"</code> if the start or end date is a date-time specification.
</p>
<p><strong>Length Out</strong>
</p>
<p>The <code>length_out</code> can be specified by number of observation or complex time-based expressions.
The following examples are all possible.
</p>

<ul>
<li> <p><code>length_out = 12</code> Creates 12 evenly spaced observations.
</p>
</li>
<li> <p><code>length_out = "12 months"</code> Adjusts the end date so it falls on the 12th month.
</p>
</li></ul>

<p><strong>Include Endpoint</strong>
</p>
<p>Sometimes the last date is not desired.
For example, if the user specifies <code style="white-space: pre;">&#8288;length_out = 12 months&#8288;</code>, the user may want the last value
to be the 12th month and not the 13th. Just toggle, <code>include_endpoint = FALSE</code> to obtain this
behavior.
</p>
<p><strong>Skip / Insert Timestamps</strong>
</p>
<p>Skips and inserts are performed after the sequence is generated. This means that if you use
the <code>length_out</code> parameter, the length may differ than the <code>length_out</code>.
</p>


<h3>Value</h3>

<p>A vector containing date or date-times
</p>


<h3>See Also</h3>


<ul>
<li><p> Intelligent date or date-time sequence creation: <code><a href="#topic+tk_make_timeseries">tk_make_timeseries()</a></code>
</p>
</li>
<li><p> Holidays and weekends: <code><a href="#topic+tk_make_holiday_sequence">tk_make_holiday_sequence()</a></code>, <code><a href="#topic+tk_make_weekend_sequence">tk_make_weekend_sequence()</a></code>, <code><a href="#topic+tk_make_weekday_sequence">tk_make_weekday_sequence()</a></code>
</p>
</li>
<li><p> Make future index from existing: <code><a href="#topic+tk_make_future_timeseries">tk_make_future_timeseries()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# Set max.print to 50
options_old &lt;- options()$max.print
options(max.print = 50)

# ---- DATE ----

# Start + End, Guesses by = "day"
tk_make_timeseries("2017-01-01", "2017-12-31")

# Just Start
tk_make_timeseries("2017") # Same result

# Only dates in February, 2017
tk_make_timeseries("2017-02")

# Start + Length Out, Guesses by = "day"
tk_make_timeseries("2012", length_out = 6) # Guesses by = "day"

# Start + By + Length Out, Spacing 6 observations by monthly interval
tk_make_timeseries("2012", by = "1 month", length_out = 6)

# Start + By + Length Out, Phrase "1 year 6 months"
tk_make_timeseries("2012", by = "1 month",
                   length_out = "1 year 6 months", include_endpoints = FALSE)

# Going in Reverse, End + Length Out
tk_make_timeseries(end_date = "2012-01-01", by = "1 month",
                   length_out = "1 year 6 months", include_endpoints = FALSE)

# ---- DATE-TIME ----

# Start + End, Guesses by second
tk_make_timeseries("2016-01-01 01:01:02", "2016-01-01 01:01:04")

# Date-Time Sequence - By 10 Minutes
# - Converts to date-time automatically &amp; applies 10-min interval
tk_make_timeseries("2017-01-01", "2017-01-02", by = "10 min")


# --- REMOVE / INCLUDE ENDPOINTS ----

# Last value in this case is desired
tk_make_timeseries("2017-01-01", by = "30 min", length_out = "6 hours")

# Last value in monthly case is not wanted
tk_make_timeseries("2012-01-01", by = "1 month",
                   length_out = "12 months",
                   include_endpoints = FALSE) # Removes unnecessary last value


# ---- SKIP &amp; INSERT VALUES ----

tk_make_timeseries(
    "2011-01-01", length_out = 5,
    skip_values   = "2011-01-05",
    insert_values = "2011-01-06"
)

options(max.print = options_old)

</code></pre>

<hr>
<h2 id='tk_seasonal_diagnostics'>Group-wise Seasonality Data Preparation</h2><span id='topic+tk_seasonal_diagnostics'></span>

<h3>Description</h3>

<p><code>tk_seasonal_diagnostics()</code> is the preprocessor for <code>plot_seasonal_diagnostics()</code>.
It helps by automating feature collection for time series seasonality analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_seasonal_diagnostics(.data, .date_var, .value, .feature_set = "auto")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_seasonal_diagnostics_+3A_.data">.data</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code> with a time-based column</p>
</td></tr>
<tr><td><code id="tk_seasonal_diagnostics_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing either date or date-time values</p>
</td></tr>
<tr><td><code id="tk_seasonal_diagnostics_+3A_.value">.value</code></td>
<td>
<p>A column containing numeric values</p>
</td></tr>
<tr><td><code id="tk_seasonal_diagnostics_+3A_.feature_set">.feature_set</code></td>
<td>
<p>One or multiple selections to analyze for seasonality. Choices include:
</p>

<ul>
<li><p> &quot;auto&quot; - Automatically selects features based on the time stamps and length of the series.
</p>
</li>
<li><p> &quot;second&quot; - Good for analyzing seasonality by second of each minute.
</p>
</li>
<li><p> &quot;minute&quot; - Good for analyzing seasonality by minute of the hour
</p>
</li>
<li><p> &quot;hour&quot; - Good for analyzing seasonality by hour of the day
</p>
</li>
<li><p> &quot;wday.lbl&quot; - Labeled weekdays. Good for analyzing seasonality by day of the week.
</p>
</li>
<li><p> &quot;week&quot; - Good for analyzing seasonality by week of the year.
</p>
</li>
<li><p> &quot;month.lbl&quot; - Labeled months. Good for analyzing seasonality by month of the year.
</p>
</li>
<li><p> &quot;quarter&quot; - Good for analyzing seasonality by quarter of the year
</p>
</li>
<li><p> &quot;year&quot; - Good for analyzing seasonality over multiple years.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Automatic Feature Selection</strong>
</p>
<p>Internal calculations are performed to detect a sub-range of features to include
useing the following logic:
</p>

<ul>
<li><p> The <em>minimum</em> feature is selected based on the median difference between consecutive
timestamps
</p>
</li>
<li><p> The <em>maximum</em> feature is selected based on having 2 full periods.
</p>
</li></ul>

<p>Example: Hourly timestamp data that lasts more than 2 weeks will have the following features:
&quot;hour&quot;, &quot;wday.lbl&quot;, and &quot;week&quot;.
</p>
<p><strong>Scalable with Grouped Data Frames</strong>
</p>
<p>This function respects grouped <code>data.frame</code> and <code>tibbles</code> that were made with <code>dplyr::group_by()</code>.
</p>
<p>For grouped data, the automatic feature selection returned is a collection of all
features within the sub-groups. This means extra features are returned even though
they may be meaningless for some of the groups.
</p>
<p><strong>Transformations</strong>
</p>
<p>The <code>.value</code> parameter respects transformations (e.g. <code>.value = log(sales)</code>).
</p>


<h3>Value</h3>

<p>A <code>tibble</code> or <code>data.frame</code> with seasonal features
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)

# ---- GROUPED EXAMPLES ----

# Hourly Data
m4_hourly %&gt;%
    group_by(id) %&gt;%
    tk_seasonal_diagnostics(date, value)

# Monthly Data
m4_monthly %&gt;%
    group_by(id) %&gt;%
    tk_seasonal_diagnostics(date, value)

# ---- TRANSFORMATION ----

m4_weekly %&gt;%
    group_by(id) %&gt;%
    tk_seasonal_diagnostics(date, log(value))

# ---- CUSTOM FEATURE SELECTION ----

m4_hourly %&gt;%
    group_by(id) %&gt;%
    tk_seasonal_diagnostics(date, value, .feature_set = c("hour", "week"))



</code></pre>

<hr>
<h2 id='tk_stl_diagnostics'>Group-wise STL Decomposition (Season, Trend, Remainder)</h2><span id='topic+tk_stl_diagnostics'></span>

<h3>Description</h3>

<p><code>tk_stl_diagnostics()</code> is the preprocessor for <code>plot_stl_diagnostics()</code>.
It helps by automating frequency and trend selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_stl_diagnostics(
  .data,
  .date_var,
  .value,
  .frequency = "auto",
  .trend = "auto",
  .message = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_stl_diagnostics_+3A_.data">.data</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code> with a time-based column</p>
</td></tr>
<tr><td><code id="tk_stl_diagnostics_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing either date or date-time values</p>
</td></tr>
<tr><td><code id="tk_stl_diagnostics_+3A_.value">.value</code></td>
<td>
<p>A column containing numeric values</p>
</td></tr>
<tr><td><code id="tk_stl_diagnostics_+3A_.frequency">.frequency</code></td>
<td>
<p>Controls the seasonal adjustment (removal of seasonality).
Input can be either &quot;auto&quot;, a time-based definition (e.g. &quot;2 weeks&quot;),
or a numeric number of observations per frequency (e.g. 10).
Refer to <code><a href="#topic+tk_get_frequency">tk_get_frequency()</a></code>.</p>
</td></tr>
<tr><td><code id="tk_stl_diagnostics_+3A_.trend">.trend</code></td>
<td>
<p>Controls the trend component.
For STL, trend controls the sensitivity of the lowess smoother, which is used to remove the remainder.</p>
</td></tr>
<tr><td><code id="tk_stl_diagnostics_+3A_.message">.message</code></td>
<td>
<p>A boolean. If <code>TRUE</code>, will output information related to automatic frequency
and trend selection (if applicable).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>tk_stl_diagnostics()</code> function generates a Seasonal-Trend-Loess decomposition.
The function is &quot;tidy&quot; in the sense that it works
on data frames and is designed to work with <code>dplyr</code> groups.
</p>
<p><strong>STL method</strong>:
</p>
<p>The STL method implements time series decomposition using
the underlying <code><a href="stats.html#topic+stl">stats::stl()</a></code>. The decomposition separates the
&quot;season&quot; and &quot;trend&quot; components from
the &quot;observed&quot; values leaving the &quot;remainder&quot;.
</p>
<p><strong>Frequency &amp; Trend Selection</strong>
</p>
<p>The user can control two parameters: <code>.frequency</code> and <code>.trend</code>.
</p>

<ol>
<li><p> The <code>.frequency</code> parameter adjusts the &quot;season&quot; component that is removed
from the &quot;observed&quot; values.
</p>
</li>
<li><p> The <code>.trend</code> parameter adjusts the
trend window (<code>t.window</code> parameter from <code>stl()</code>) that is used.
</p>
</li></ol>

<p>The user may supply both <code>.frequency</code>
and <code>.trend</code> as time-based durations (e.g. &quot;6 weeks&quot;) or numeric values
(e.g. 180) or &quot;auto&quot;, which automatically selects the frequency and/or trend
based on the scale of the time series.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> or <code>data.frame</code> with Observed, Season, Trend, Remainder,
and Seasonally-Adjusted features
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)


# ---- GROUPS &amp; TRANSFORMATION ----
m4_daily %&gt;%
    group_by(id) %&gt;%
    tk_stl_diagnostics(date, box_cox_vec(value))

# ---- CUSTOM TREND ----
m4_weekly %&gt;%
    group_by(id) %&gt;%
    tk_stl_diagnostics(date, box_cox_vec(value), .trend = "2 quarters")

</code></pre>

<hr>
<h2 id='tk_summary_diagnostics'>Group-wise Time Series Summary</h2><span id='topic+tk_summary_diagnostics'></span>

<h3>Description</h3>

<p><code>tk_summary_diagnostics()</code> returns the time series summary from
one or more timeseries groups in a tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_summary_diagnostics(.data, .date_var)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_summary_diagnostics_+3A_.data">.data</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code> with a time-based column</p>
</td></tr>
<tr><td><code id="tk_summary_diagnostics_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing either date or date-time values.
If missing, attempts to auto-detect the date or date-time column.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Applies <code><a href="#topic+tk_get_timeseries_summary">tk_get_timeseries_summary()</a></code> group-wise returning the summary of one or more
time series groups.
</p>

<ul>
<li><p> Respects <code>dplyr</code> groups
</p>
</li>
<li><p> Returns the time series summary from a time-based feature.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>tibble</code> or <code>data.frame</code> with timeseries summary features
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

# ---- NON-GROUPED EXAMPLES ----

# Monthly Data
m4_monthly %&gt;%
    filter(id == "M750") %&gt;%
    tk_summary_diagnostics()

# ---- GROUPED EXAMPLES ----

# Monthly Data
m4_monthly %&gt;%
    group_by(id) %&gt;%
    tk_summary_diagnostics()


</code></pre>

<hr>
<h2 id='tk_tbl'>Coerce time-series objects to tibble.</h2><span id='topic+tk_tbl'></span>

<h3>Description</h3>

<p>Coerce time-series objects to tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_tbl(
  data,
  preserve_index = TRUE,
  rename_index = "index",
  timetk_idx = FALSE,
  silent = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_tbl_+3A_data">data</code></td>
<td>
<p>A time-series object.</p>
</td></tr>
<tr><td><code id="tk_tbl_+3A_preserve_index">preserve_index</code></td>
<td>
<p>Attempts to preserve a time series index. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="tk_tbl_+3A_rename_index">rename_index</code></td>
<td>
<p>Enables the index column to be renamed.</p>
</td></tr>
<tr><td><code id="tk_tbl_+3A_timetk_idx">timetk_idx</code></td>
<td>
<p>Used to return a date / datetime index for
regularized objects that contain a timetk &quot;index&quot; attribute.
Refer to <code><a href="#topic+tk_index">tk_index()</a></code> for more information on returning index information
from regularized timeseries objects (i.e. <code>ts</code>).</p>
</td></tr>
<tr><td><code id="tk_tbl_+3A_silent">silent</code></td>
<td>
<p>Used to toggle printing of messages and warnings.</p>
</td></tr>
<tr><td><code id="tk_tbl_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the <code><a href="tibble.html#topic+as_tibble">tibble::as_tibble()</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tk_tbl</code> is designed
to coerce time series objects (e.g. <code>xts</code>, <code>zoo</code>, <code>ts</code>, <code>timeSeries</code>, etc)
to <code>tibble</code> objects. The main advantage is that the function keeps the
date / date-time information from the underlying time-series object.
</p>
<p>When <code>preserve_index = TRUE</code> is specified, a new column,
<code>index</code>, is created during object coercion, and the function attempts to preserve
the date or date-time information. The date / date-time column name
can be changed using the <code>rename_index</code> argument.
</p>
<p>The <code>timetk_idx</code> argument is applicable when coercing <code>ts</code> objects that were
created using <code>tk_ts()</code> from an object that had a time base
(e.g. <code>tbl</code>, <code>xts</code>, <code>zoo</code>).
Setting <code>timetk_idx = TRUE</code> enables returning the timetk &quot;index&quot; attribute if present,
which is the original (non-regularized) time-based index.
</p>


<h3>Value</h3>

<p>Returns a <code>tibble</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tk_xts">tk_xts()</a></code>, <code><a href="#topic+tk_zoo">tk_zoo()</a></code>, <code><a href="#topic+tk_zooreg">tk_zooreg()</a></code>, <code><a href="#topic+tk_ts">tk_ts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

data_tbl &lt;- tibble(
    date = seq.Date(from = as.Date("2010-01-01"), by = 1, length.out = 5),
    x    = seq(100, 120, by = 5)
)


### ts to tibble: Comparison between as.data.frame() and tk_tbl()
data_ts &lt;- tk_ts(data_tbl, start = c(2010,1), freq = 365)

# No index
as.data.frame(data_ts)

# Defualt index returned is regularized numeric index
tk_tbl(data_ts)

# Original date index returned (Only possible if original data has time-based index)
tk_tbl(data_ts, timetk_idx = TRUE)


### xts to tibble: Comparison between as.data.frame() and tk_tbl()
data_xts &lt;- tk_xts(data_tbl)

# Dates are character class stored in row names
as.data.frame(data_xts)

# Dates are appropriate date class and within the data frame
tk_tbl(data_xts)


### zooreg to tibble: Comparison between as.data.frame() and tk_tbl()
data_zooreg &lt;- tk_zooreg(1:8, start = zoo::yearqtr(2000), frequency = 4)

# Dates are character class stored in row names
as.data.frame(data_zooreg)

# Dates are appropriate zoo yearqtr class within the data frame
tk_tbl(data_zooreg)


### zoo to tibble: Comparison between as.data.frame() and tk_tbl()
data_zoo &lt;- zoo::zoo(1:12, zoo::yearmon(2016 + seq(0, 11)/12))

# Dates are character class stored in row names
as.data.frame(data_zoo)

# Dates are appropriate zoo yearmon class within the data frame
tk_tbl(data_zoo)



</code></pre>

<hr>
<h2 id='tk_time_series_cv_plan'>Time Series Resample Plan Data Preparation</h2><span id='topic+tk_time_series_cv_plan'></span>

<h3>Description</h3>

<p>The <code>tk_time_series_cv_plan()</code> function provides a simple interface to
prepare a time series resample specification (<code>rset</code>) of either <code>rolling_origin</code>
or <code>time_series_cv</code> class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_time_series_cv_plan(.data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_time_series_cv_plan_+3A_.data">.data</code></td>
<td>
<p>A time series resample specification of of either <code>rolling_origin</code>
or <code>time_series_cv</code> class.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Resample Set</strong>
</p>
<p>A resample set is an output of the <code>timetk::time_series_cv()</code> function or the
<code>rsample::rolling_origin()</code> function.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> containing the time series crossvalidation plan.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+time_series_cv">time_series_cv()</a></code> and <code><a href="rsample.html#topic+rolling_origin">rsample::rolling_origin()</a></code> - Functions used to create
time series resample specfications.
</p>
</li>
<li> <p><code><a href="#topic+plot_time_series_cv_plan">plot_time_series_cv_plan()</a></code> - The plotting function used for visualizing the
time series resample plan.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(rsample)

FB_tbl &lt;- FANG %&gt;%
    filter(symbol == "FB") %&gt;%
    select(symbol, date, adjusted)

resample_spec &lt;- time_series_cv(
    FB_tbl,
    initial = 150, assess = 50, skip = 50,
    cumulative = FALSE,
    lag = 30,
    slice_limit = n())

resample_spec %&gt;% tk_time_series_cv_plan()

</code></pre>

<hr>
<h2 id='tk_ts'>Coerce time series objects and tibbles with date/date-time columns to ts.</h2><span id='topic+tk_ts'></span><span id='topic+tk_ts_'></span>

<h3>Description</h3>

<p>Coerce time series objects and tibbles with date/date-time columns to ts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_ts(
  data,
  select = NULL,
  start = 1,
  end = numeric(),
  frequency = 1,
  deltat = 1,
  ts.eps = getOption("ts.eps"),
  silent = FALSE
)

tk_ts_(
  data,
  select = NULL,
  start = 1,
  end = numeric(),
  frequency = 1,
  deltat = 1,
  ts.eps = getOption("ts.eps"),
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_ts_+3A_data">data</code></td>
<td>
<p>A time-based tibble or time-series object.</p>
</td></tr>
<tr><td><code id="tk_ts_+3A_select">select</code></td>
<td>
<p><strong>Applicable to tibbles and data frames only</strong>.
The column or set of columns to be coerced to <code>ts</code> class.</p>
</td></tr>
<tr><td><code id="tk_ts_+3A_start">start</code></td>
<td>
<p>the time of the first observation.  Either a single
number or a vector of two numbers (the second of which is an integer),
which specify a natural time
unit and a (1-based) number of samples into the time unit.  See
the examples for the use of the second form.</p>
</td></tr>
<tr><td><code id="tk_ts_+3A_end">end</code></td>
<td>
<p>the time of the last observation, specified in the same way
as <code>start</code>.</p>
</td></tr>
<tr><td><code id="tk_ts_+3A_frequency">frequency</code></td>
<td>
<p>the number of observations per unit of time.</p>
</td></tr>
<tr><td><code id="tk_ts_+3A_deltat">deltat</code></td>
<td>
<p>the fraction of the sampling period between successive
observations; e.g., 1/12 for monthly data.  Only one of
<code>frequency</code> or <code>deltat</code> should be provided.</p>
</td></tr>
<tr><td><code id="tk_ts_+3A_ts.eps">ts.eps</code></td>
<td>
<p>time series comparison tolerance.  Frequencies are
considered equal if their absolute difference is less than
<code>ts.eps</code>.</p>
</td></tr>
<tr><td><code id="tk_ts_+3A_silent">silent</code></td>
<td>
<p>Used to toggle printing of messages and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tk_ts()</code> is a wrapper for <code>stats::ts()</code> that is designed
to coerce <code>tibble</code> objects that have a &quot;time-base&quot; (meaning the values vary with time)
to <code>ts</code> class objects. There are two main advantages:
</p>

<ol>
<li><p> Non-numeric columns get removed instead of being populated by NA's.
</p>
</li>
<li><p> The returned <code>ts</code> object retains a &quot;timetk index&quot; (and various other attributes) if detected.
The &quot;timetk index&quot; can be used to coerce between <code>tbl</code>, <code>xts</code>, <code>zoo</code>, and <code>ts</code> data types.
</p>
</li></ol>

<p>The <code>select</code> argument is used to select subsets
of columns from the incoming data.frame.
Only columns containing numeric data are coerced. <em>At a minimum, a <code>frequency</code>
and a <code>start</code> should be specified.</em>
</p>
<p>For non-data.frame object classes (e.g. <code>xts</code>, <code>zoo</code>, <code>timeSeries</code>, etc) the objects are coerced
using <code>stats::ts()</code>.
</p>
<p><code>tk_ts_</code> is a nonstandard evaluation method.
</p>


<h3>Value</h3>

<p>Returns a <code>ts</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tk_index">tk_index()</a></code>, <code><a href="#topic+tk_tbl">tk_tbl()</a></code>, <code><a href="#topic+tk_xts">tk_xts()</a></code>, <code><a href="#topic+tk_zoo">tk_zoo()</a></code>, <code><a href="#topic+tk_zooreg">tk_zooreg()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

### tibble to ts: Comparison between tk_ts() and stats::ts()
data_tbl &lt;- tibble::tibble(
    date = seq.Date(as.Date("2016-01-01"), by = 1, length.out = 5),
    x    = rep("chr values", 5),
    y    = cumsum(1:5),
    z    = cumsum(11:15) * rnorm(1))

# as.ts: Character columns introduce NA's; Result does not retain index
stats::ts(data_tbl[,-1], start = 2016)

# tk_ts: Only numeric columns get coerced; Result retains index in numeric format
data_ts &lt;- tk_ts(data_tbl, start = 2016)
data_ts

# timetk index
tk_index(data_ts, timetk_idx = FALSE)   # Regularized index returned
tk_index(data_ts, timetk_idx = TRUE)    # Original date index returned

# Coerce back to tibble
data_ts %&gt;% tk_tbl(timetk_idx = TRUE)


### Using select
tk_ts(data_tbl, select = y)


### NSE: Enables programming
select   &lt;- "y"
tk_ts_(data_tbl, select = select)

</code></pre>

<hr>
<h2 id='tk_ts_dispatch_'>S3 methods for ts method dispatch</h2><span id='topic+tk_ts_dispatch_'></span><span id='topic+tk_ts_.data.frame'></span><span id='topic+tk_ts_.default'></span>

<h3>Description</h3>

<p>Method dispatch for ts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_ts_dispatch_(data, select, start, end, frequency, deltat, ts.eps, silent)

tk_ts_.data.frame(data, select, start, end, frequency, deltat, ts.eps, silent)

tk_ts_.default(data, select, start, end, frequency, deltat, ts.eps, silent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_ts_dispatch__+3A_data">data</code></td>
<td>
<p>A time-based tibble or time-series object.</p>
</td></tr>
<tr><td><code id="tk_ts_dispatch__+3A_select">select</code></td>
<td>
<p><strong>Applicable to tibbles and data frames only</strong>.
The column or set of columns to be coerced to <code>ts</code> class.</p>
</td></tr>
<tr><td><code id="tk_ts_dispatch__+3A_start">start</code></td>
<td>
<p>the time of the first observation.  Either a single
number or a vector of two numbers (the second of which is an integer),
which specify a natural time
unit and a (1-based) number of samples into the time unit.  See
the examples for the use of the second form.</p>
</td></tr>
<tr><td><code id="tk_ts_dispatch__+3A_end">end</code></td>
<td>
<p>the time of the last observation, specified in the same way
as <code>start</code>.</p>
</td></tr>
<tr><td><code id="tk_ts_dispatch__+3A_frequency">frequency</code></td>
<td>
<p>the number of observations per unit of time.</p>
</td></tr>
<tr><td><code id="tk_ts_dispatch__+3A_deltat">deltat</code></td>
<td>
<p>the fraction of the sampling period between successive
observations; e.g., 1/12 for monthly data.  Only one of
<code>frequency</code> or <code>deltat</code> should be provided.</p>
</td></tr>
<tr><td><code id="tk_ts_dispatch__+3A_ts.eps">ts.eps</code></td>
<td>
<p>time series comparison tolerance.  Frequencies are
considered equal if their absolute difference is less than
<code>ts.eps</code>.</p>
</td></tr>
<tr><td><code id="tk_ts_dispatch__+3A_silent">silent</code></td>
<td>
<p>Used to toggle printing of messages and warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>

<hr>
<h2 id='tk_tsfeatures'>Time series feature matrix (Tidy)</h2><span id='topic+tk_tsfeatures'></span>

<h3>Description</h3>

<p><code>tk_tsfeatures()</code> is a tidyverse compliant wrapper for <code>tsfeatures::tsfeatures()</code>.
The function computes a matrix of time series features that describes the various time
series. It's designed for groupwise analysis using <code>dplyr</code> groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_tsfeatures(
  .data,
  .date_var,
  .value,
  .period = "auto",
  .features = c("frequency", "stl_features", "entropy", "acf_features"),
  .scale = TRUE,
  .trim = FALSE,
  .trim_amount = 0.1,
  .parallel = FALSE,
  .na_action = na.pass,
  .prefix = "ts_",
  .silent = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_tsfeatures_+3A_.data">.data</code></td>
<td>
<p>A <code>tibble</code> or <code>data.frame</code> with a time-based column</p>
</td></tr>
<tr><td><code id="tk_tsfeatures_+3A_.date_var">.date_var</code></td>
<td>
<p>A column containing either date or date-time values</p>
</td></tr>
<tr><td><code id="tk_tsfeatures_+3A_.value">.value</code></td>
<td>
<p>A column containing numeric values</p>
</td></tr>
<tr><td><code id="tk_tsfeatures_+3A_.period">.period</code></td>
<td>
<p>The periodicity (frequency) of the time series data. Values can be provided as follows:
</p>

<ul>
<li><p> &quot;auto&quot; (default) Calculates using <code>tk_get_frequency()</code>.
</p>
</li>
<li><p> &quot;2 weeks&quot;: Would calculate the median number of observations in a 2-week window.
</p>
</li>
<li><p> 7 (numeric): Would interpret the <code>ts</code> frequency as 7 observations per cycle (common for weekly data)
</p>
</li></ul>
</td></tr>
<tr><td><code id="tk_tsfeatures_+3A_.features">.features</code></td>
<td>
<p>Passed to <code>features</code> in the underlying <code>tsfeatures()</code> function.
A vector of function names that represent a feature aggregation function. Examples:
</p>

<ol>
<li><p> Use one of the function names from <code>tsfeatures</code> R package e.g.(&quot;lumpiness&quot;, &quot;stl_features&quot;).
</p>
</li>
<li><p> Use a function name (e.g. &quot;mean&quot; or &quot;median&quot;)
</p>
</li>
<li><p> Create your own function and provide the function name
</p>
</li></ol>
</td></tr>
<tr><td><code id="tk_tsfeatures_+3A_.scale">.scale</code></td>
<td>
<p>If <code>TRUE</code>, time series are scaled to mean 0 and sd 1 before features are computed.</p>
</td></tr>
<tr><td><code id="tk_tsfeatures_+3A_.trim">.trim</code></td>
<td>
<p>If <code>TRUE</code>, time series are trimmed by trim_amount before features are computed.
Values larger than trim_amount in absolute value are set to <code>NA</code>.</p>
</td></tr>
<tr><td><code id="tk_tsfeatures_+3A_.trim_amount">.trim_amount</code></td>
<td>
<p>Default level of trimming if trim==TRUE. Default: 0.1.</p>
</td></tr>
<tr><td><code id="tk_tsfeatures_+3A_.parallel">.parallel</code></td>
<td>
<p>If TRUE, multiple cores (or multiple sessions) will be used.
This only speeds things up when there are a large number of time series.
</p>
<p>When <code>.parallel = TRUE</code>, the <code>multiprocess = future::multisession</code>.
This can be adjusted by setting <code>multiprocess</code> parameter.
See the <code>tsfeatures::tsfeatures()</code> function for mor details.</p>
</td></tr>
<tr><td><code id="tk_tsfeatures_+3A_.na_action">.na_action</code></td>
<td>
<p>A function to handle missing values. Use na.interp to estimate missing values.</p>
</td></tr>
<tr><td><code id="tk_tsfeatures_+3A_.prefix">.prefix</code></td>
<td>
<p>A prefix to prefix the feature columns. Default: <code>"ts_"</code>.</p>
</td></tr>
<tr><td><code id="tk_tsfeatures_+3A_.silent">.silent</code></td>
<td>
<p>Whether or not to show messages and warnings.</p>
</td></tr>
<tr><td><code id="tk_tsfeatures_+3A_...">...</code></td>
<td>
<p>Other arguments get passed to the feature functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>timetk::tk_tsfeatures()</code> function implements the <code>tsfeatures</code> package
for computing aggregated feature matrix for time series that is useful in many types of
analysis such as clustering time series.
</p>
<p>The <code>timetk</code> version ports the <code>tsfeatures::tsfeatures()</code> function to a <code>tidyverse</code>-compliant
format that uses a tidy data frame containing grouping columns (optional), a date column, and
a value column. Other columns are ignored.
</p>
<p>It then becomes easy to summarize each time series by group-wise application of <code>.features</code>,
which are simply functions that evaluate a time series and return single aggregated value.
(Example: &quot;mean&quot; would return the mean of the time series (note that values are scaled to mean 1 and sd 0 first))
</p>
<p><strong>Function Internals:</strong>
</p>
<p>Internally, the time series are converted to <code>ts</code> class using <code>tk_ts(.period)</code> where the
period is the frequency of the time series. Values can be provided for <code>.period</code>, which will be used
prior to convertion to <code>ts</code> class.
</p>
<p>The function then leverages <code>tsfeatures::tsfeatures()</code> to compute the feature matrix of summarized
feature values.
</p>


<h3>Value</h3>

<p>A <code>tibble</code> or <code>data.frame</code> with aggregated features that describe each time series.
</p>


<h3>References</h3>


<ol>
<li><p> Rob Hyndman, Yanfei Kang, Pablo Montero-Manso, Thiyanga Talagala, Earo Wang, Yangzhuoran Yang,
Mitchell O'Hara-Wild: tsfeatures R package
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

walmart_sales_weekly %&gt;%
    group_by(id) %&gt;%
    tk_tsfeatures(
      .date_var = Date,
      .value    = Weekly_Sales,
      .period   = 52,
      .features = c("frequency", "stl_features", "entropy", "acf_features", "mean"),
      .scale    = TRUE,
      .prefix   = "ts_"
    )

</code></pre>

<hr>
<h2 id='tk_xts'>Coerce time series objects and tibbles with date/date-time columns to xts.</h2><span id='topic+tk_xts'></span><span id='topic+tk_xts_'></span>

<h3>Description</h3>

<p>Coerce time series objects and tibbles with date/date-time columns to xts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_xts(data, select = NULL, date_var = NULL, silent = FALSE, ...)

tk_xts_(data, select = NULL, date_var = NULL, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_xts_+3A_data">data</code></td>
<td>
<p>A time-based tibble or time-series object.</p>
</td></tr>
<tr><td><code id="tk_xts_+3A_select">select</code></td>
<td>
<p><strong>Applicable to tibbles and data frames only</strong>.
The column or set of columns to be coerced to <code>ts</code> class.</p>
</td></tr>
<tr><td><code id="tk_xts_+3A_date_var">date_var</code></td>
<td>
<p><strong>Applicable to tibbles and data frames only</strong>.
Column name to be used to <code>order.by</code>.
<code>NULL</code> by default. If <code>NULL</code>, function will find the date or date-time column.</p>
</td></tr>
<tr><td><code id="tk_xts_+3A_silent">silent</code></td>
<td>
<p>Used to toggle printing of messages and warnings.</p>
</td></tr>
<tr><td><code id="tk_xts_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code>xts::xts()</code>. Refer to <code>xts::xts()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tk_xts</code> is a wrapper for <code>xts::xts()</code> that is designed
to coerce <code>tibble</code> objects that have a &quot;time-base&quot; (meaning the values vary with time)
to <code>xts</code> class objects. There are three main advantages:
</p>

<ol>
<li><p> Non-numeric columns that are not removed via <code>select</code> are dropped and the user is warned.
This prevents an error or coercion issue from occurring.
</p>
</li>
<li><p> The date column is auto-detected if not specified by <code>date_var</code>. This takes
the effort off the user to assign a date vector during coercion.
</p>
</li>
<li> <p><code>ts</code> objects are automatically coerced if a &quot;timetk index&quot; is present. Refer to <code><a href="#topic+tk_ts">tk_ts()</a></code>.
</p>
</li></ol>

<p>The <code>select</code> argument can be used to select subsets
of columns from the incoming data.frame.
Only columns containing numeric data are coerced.
The <code>date_var</code> can be used to specify the column with the date index.
If <code>date_var = NULL</code>, the date / date-time column is interpreted.
Optionally, the <code>order.by</code> argument from the underlying <code>xts::xts()</code> function can be used.
The user must pass a vector of dates or date-times if <code>order.by</code> is used.
</p>
<p>For non-data.frame object classes (e.g. <code>xts</code>, <code>zoo</code>, <code>timeSeries</code>, etc) the objects are coerced
using <code>xts::xts()</code>.
</p>
<p><code>tk_xts_</code> is a nonstandard evaluation method.
</p>


<h3>Value</h3>

<p>Returns a <code>xts</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tk_tbl">tk_tbl()</a></code>, <code><a href="#topic+tk_zoo">tk_zoo()</a></code>, <code><a href="#topic+tk_zooreg">tk_zooreg()</a></code>, <code><a href="#topic+tk_ts">tk_ts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

### tibble to xts: Comparison between tk_xts() and xts::xts()
data_tbl &lt;- tibble::tibble(
    date = seq.Date(as.Date("2016-01-01"), by = 1, length.out = 5),
    x    = rep("chr values", 5),
    y    = cumsum(1:5),
    z    = cumsum(11:15) * rnorm(1))

# xts: Character columns cause coercion issues; order.by must be passed a vector of dates
xts::xts(data_tbl[,-1], order.by = data_tbl$date)

# tk_xts: Non-numeric columns automatically dropped; No need to specify date column
tk_xts(data_tbl)

# ts can be coerced back to xts
data_tbl %&gt;%
    tk_ts(start = 2016, freq = 365) %&gt;%
    tk_xts()

### Using select and date_var
tk_xts(data_tbl, select = y, date_var = date)


### NSE: Enables programming
date_var &lt;- "date"
select   &lt;- "y"
tk_xts_(data_tbl, select = select, date_var = date_var)

</code></pre>

<hr>
<h2 id='tk_zoo'>Coerce time series objects and tibbles with date/date-time columns to xts.</h2><span id='topic+tk_zoo'></span><span id='topic+tk_zoo_'></span>

<h3>Description</h3>

<p>Coerce time series objects and tibbles with date/date-time columns to xts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_zoo(data, select = NULL, date_var = NULL, silent = FALSE, ...)

tk_zoo_(data, select = NULL, date_var = NULL, silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_zoo_+3A_data">data</code></td>
<td>
<p>A time-based tibble or time-series object.</p>
</td></tr>
<tr><td><code id="tk_zoo_+3A_select">select</code></td>
<td>
<p><strong>Applicable to tibbles and data frames only</strong>.
The column or set of columns to be coerced to <code>ts</code> class.</p>
</td></tr>
<tr><td><code id="tk_zoo_+3A_date_var">date_var</code></td>
<td>
<p><strong>Applicable to tibbles and data frames only</strong>.
Column name to be used to <code>order.by</code>.
<code>NULL</code> by default. If <code>NULL</code>, function will find the date or date-time column.</p>
</td></tr>
<tr><td><code id="tk_zoo_+3A_silent">silent</code></td>
<td>
<p>Used to toggle printing of messages and warnings.</p>
</td></tr>
<tr><td><code id="tk_zoo_+3A_...">...</code></td>
<td>
<p>Additional parameters to be passed to <code>xts::xts()</code>. Refer to <code>xts::xts()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tk_zoo</code> is a wrapper for <code>zoo::zoo()</code> that is designed
to coerce <code>tibble</code> objects that have a &quot;time-base&quot; (meaning the values vary with time)
to <code>zoo</code> class objects. There are three main advantages:
</p>

<ol>
<li><p> Non-numeric columns that are not removed via <code>select</code> are dropped and the user is warned.
This prevents an error or coercion issue from occurring.
</p>
</li>
<li><p> The date column is auto-detected if not specified by <code>date_var</code>. This takes
the effort off the user to assign a date vector during coercion.
</p>
</li>
<li> <p><code>ts</code> objects are automatically coerced if a &quot;timetk index&quot; is present. Refer to <code><a href="#topic+tk_ts">tk_ts()</a></code>.
</p>
</li></ol>

<p>The <code>select</code> argument can be used to select subsets
of columns from the incoming data.frame.
Only columns containing numeric data are coerced.
The <code>date_var</code> can be used to specify the column with the date index.
If <code>date_var = NULL</code>, the date / date-time column is interpreted.
Optionally, the <code>order.by</code> argument from the underlying <code>zoo::zoo()</code> function can be used.
The user must pass a vector of dates or date-times if <code>order.by</code> is used.
<em>Important Note: The <code>...</code> arguments are passed to <code>xts::xts()</code>, which
enables additional information (e.g. time zone) to be an attribute of the <code>zoo</code> object.</em>
</p>
<p>For non-data.frame object classes (e.g. <code>xts</code>, <code>zoo</code>, <code>timeSeries</code>, etc) the objects are coerced
using <code>zoo::zoo()</code>.
</p>
<p><code>tk_zoo_</code> is a nonstandard evaluation method.
</p>


<h3>Value</h3>

<p>Returns a <code>zoo</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tk_tbl">tk_tbl()</a></code>, <code><a href="#topic+tk_xts">tk_xts()</a></code>, <code><a href="#topic+tk_zooreg">tk_zooreg()</a></code>, <code><a href="#topic+tk_ts">tk_ts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

### tibble to zoo: Comparison between tk_zoo() and zoo::zoo()
data_tbl &lt;- dplyr::tibble(
    date = seq.Date(as.Date("2016-01-01"), by = 1, length.out = 5),
    x    = rep("chr values", 5),
    y    = cumsum(1:5),
    z    = cumsum(11:15) * rnorm(1))

# zoo: Characters will cause error; order.by must be passed a vector of dates
zoo::zoo(data_tbl[,-c(1,2)], order.by = data_tbl$date)

# tk_zoo: Character columns dropped with a warning; No need to specify dates (auto detected)
tk_zoo(data_tbl)

# ts can be coerced back to zoo
data_tbl %&gt;%
    tk_ts(start = 2016, freq = 365) %&gt;%
    tk_zoo()


### Using select and date_var
tk_zoo(data_tbl, select = y, date_var = date)


### NSE: Enables programming
date_var &lt;- "date"
select   &lt;- "y"
tk_zoo_(data_tbl, select = select, date_var = date_var)

</code></pre>

<hr>
<h2 id='tk_zooreg'>Coerce time series objects and tibbles with date/date-time columns to ts.</h2><span id='topic+tk_zooreg'></span><span id='topic+tk_zooreg_'></span>

<h3>Description</h3>

<p>Coerce time series objects and tibbles with date/date-time columns to ts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_zooreg(
  data,
  select = NULL,
  date_var = NULL,
  start = 1,
  end = numeric(),
  frequency = 1,
  deltat = 1,
  ts.eps = getOption("ts.eps"),
  order.by = NULL,
  silent = FALSE
)

tk_zooreg_(
  data,
  select = NULL,
  date_var = NULL,
  start = 1,
  end = numeric(),
  frequency = 1,
  deltat = 1,
  ts.eps = getOption("ts.eps"),
  order.by = NULL,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_zooreg_+3A_data">data</code></td>
<td>
<p>A time-based tibble or time-series object.</p>
</td></tr>
<tr><td><code id="tk_zooreg_+3A_select">select</code></td>
<td>
<p><strong>Applicable to tibbles and data frames only</strong>.
The column or set of columns to be coerced to <code>zooreg</code> class.</p>
</td></tr>
<tr><td><code id="tk_zooreg_+3A_date_var">date_var</code></td>
<td>
<p><strong>Applicable to tibbles and data frames only</strong>.
Column name to be used to <code>order.by</code>.
<code>NULL</code> by default. If <code>NULL</code>, function will find the date or date-time column.</p>
</td></tr>
<tr><td><code id="tk_zooreg_+3A_start">start</code></td>
<td>
<p>the time of the first observation.  Either a single number or
a vector of two integers, which specify a natural time unit
and a (1-based) number of samples into the time unit.</p>
</td></tr>
<tr><td><code id="tk_zooreg_+3A_end">end</code></td>
<td>
<p>the time of the last observation, specified in the same way
as <code>start</code>.</p>
</td></tr>
<tr><td><code id="tk_zooreg_+3A_frequency">frequency</code></td>
<td>
<p>the number of observations per unit of time.</p>
</td></tr>
<tr><td><code id="tk_zooreg_+3A_deltat">deltat</code></td>
<td>
<p>the fraction of the sampling period between successive
observations; e.g., 1/12 for monthly data.  Only one of
<code>frequency</code> or <code>deltat</code> should be provided.</p>
</td></tr>
<tr><td><code id="tk_zooreg_+3A_ts.eps">ts.eps</code></td>
<td>
<p>time series comparison tolerance.  Frequencies are considered
equal if their absolute difference is less than <code>ts.eps</code>.</p>
</td></tr>
<tr><td><code id="tk_zooreg_+3A_order.by">order.by</code></td>
<td>
<p>a vector by which the observations in <code>x</code>
are ordered. If this is specified the arguments <code>start</code> and
<code>end</code> are ignored and <code>zoo(data, order.by, frequency)</code> is
called. See <code><a href="zoo.html#topic+zoo">zoo</a></code> for more information.</p>
</td></tr>
<tr><td><code id="tk_zooreg_+3A_silent">silent</code></td>
<td>
<p>Used to toggle printing of messages and warnings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>tk_zooreg()</code> is a wrapper for <code>zoo::zooreg()</code> that is designed
to coerce <code>tibble</code> objects that have a &quot;time-base&quot; (meaning the values vary with time)
to <code>zooreg</code> class objects. There are two main advantages:
</p>

<ol>
<li><p> Non-numeric columns get removed instead causing coercion issues.
</p>
</li>
<li><p> If an index is present, the returned <code>zooreg</code> object retains an index retrievable using <code><a href="#topic+tk_index">tk_index()</a></code>.
</p>
</li></ol>

<p>The <code>select</code> argument is used to select subsets
of columns from the incoming data.frame.
The <code>date_var</code> can be used to specify the column with the date index.
If <code>date_var = NULL</code>, the date / date-time column is interpreted.
Optionally, the <code>order.by</code> argument from the underlying <code>xts::xts()</code> function can be used.
The user must pass a vector of dates or date-times if <code>order.by</code> is used.
Only columns containing numeric data are coerced.
<em>At a minimum, a <code>frequency</code> and a <code>start</code> should be specified.</em>
</p>
<p>For non-data.frame object classes (e.g. <code>xts</code>, <code>zoo</code>, <code>timeSeries</code>, etc) the objects are coerced
using <code>zoo::zooreg()</code>.
</p>
<p><code>tk_zooreg_</code> is a nonstandard evaluation method.
</p>


<h3>Value</h3>

<p>Returns a <code>zooreg</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tk_tbl">tk_tbl()</a></code>, <code><a href="#topic+tk_xts">tk_xts()</a></code>, <code><a href="#topic+tk_zoo">tk_zoo()</a></code>, <code><a href="#topic+tk_ts">tk_ts()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### tibble to zooreg: Comparison between tk_zooreg() and zoo::zooreg()
data_tbl &lt;- tibble::tibble(
    date = seq.Date(as.Date("2016-01-01"), by = 1, length.out = 5),
    x    = rep("chr values", 5),
    y    = cumsum(1:5),
    z    = cumsum(11:15) * rnorm(1))

# zoo::zooreg: Values coerced to character; Result does not retain index
data_zooreg &lt;- zoo::zooreg(data_tbl[,-1], start = 2016, freq = 365)
data_zooreg                # Numeric values coerced to character
rownames(data_zooreg)      # NULL, no dates retained

# tk_zooreg: Only numeric columns get coerced; Result retains index as rownames
data_tk_zooreg &lt;- tk_zooreg(data_tbl, start = 2016, freq = 365)
data_tk_zooreg             # No inadvertent coercion to character class

# timetk index
tk_index(data_tk_zooreg, timetk_idx = FALSE)   # Regularized index returned
tk_index(data_tk_zooreg, timetk_idx = TRUE)    # Original date index returned

### Using select and date_var
tk_zooreg(data_tbl, select = y, date_var = date, start = 2016, freq = 365)


### NSE: Enables programming
select   &lt;- "y"
date_var &lt;- "date"
tk_zooreg_(data_tbl, select = select, date_var = date_var, start = 2016, freq = 365)

</code></pre>

<hr>
<h2 id='tk_zooreg_dispatch_'>S3 methods for zooreg method dispatch</h2><span id='topic+tk_zooreg_dispatch_'></span><span id='topic+tk_zooreg_.data.frame'></span><span id='topic+tk_zooreg_.default'></span>

<h3>Description</h3>

<p>Method dispatch for Zooreg
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tk_zooreg_dispatch_(
  data,
  select,
  date_var,
  start,
  end,
  frequency,
  deltat,
  ts.eps,
  order.by,
  silent
)

tk_zooreg_.data.frame(
  data,
  select,
  date_var,
  start,
  end,
  frequency,
  deltat,
  ts.eps,
  order.by,
  silent
)

tk_zooreg_.default(
  data,
  select,
  date_var,
  start,
  end,
  frequency,
  deltat,
  ts.eps,
  order.by,
  silent
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tk_zooreg_dispatch__+3A_data">data</code></td>
<td>
<p>A time-based tibble or time-series object.</p>
</td></tr>
<tr><td><code id="tk_zooreg_dispatch__+3A_select">select</code></td>
<td>
<p><strong>Applicable to tibbles and data frames only</strong>.
The column or set of columns to be coerced to <code>zooreg</code> class.</p>
</td></tr>
<tr><td><code id="tk_zooreg_dispatch__+3A_date_var">date_var</code></td>
<td>
<p><strong>Applicable to tibbles and data frames only</strong>.
Column name to be used to <code>order.by</code>.
<code>NULL</code> by default. If <code>NULL</code>, function will find the date or date-time column.</p>
</td></tr>
<tr><td><code id="tk_zooreg_dispatch__+3A_start">start</code></td>
<td>
<p>the time of the first observation.  Either a single number or
a vector of two integers, which specify a natural time unit
and a (1-based) number of samples into the time unit.</p>
</td></tr>
<tr><td><code id="tk_zooreg_dispatch__+3A_end">end</code></td>
<td>
<p>the time of the last observation, specified in the same way
as <code>start</code>.</p>
</td></tr>
<tr><td><code id="tk_zooreg_dispatch__+3A_frequency">frequency</code></td>
<td>
<p>the number of observations per unit of time.</p>
</td></tr>
<tr><td><code id="tk_zooreg_dispatch__+3A_deltat">deltat</code></td>
<td>
<p>the fraction of the sampling period between successive
observations; e.g., 1/12 for monthly data.  Only one of
<code>frequency</code> or <code>deltat</code> should be provided.</p>
</td></tr>
<tr><td><code id="tk_zooreg_dispatch__+3A_ts.eps">ts.eps</code></td>
<td>
<p>time series comparison tolerance.  Frequencies are considered
equal if their absolute difference is less than <code>ts.eps</code>.</p>
</td></tr>
<tr><td><code id="tk_zooreg_dispatch__+3A_order.by">order.by</code></td>
<td>
<p>a vector by which the observations in <code>x</code>
are ordered. If this is specified the arguments <code>start</code> and
<code>end</code> are ignored and <code>zoo(data, order.by, frequency)</code> is
called. See <code><a href="zoo.html#topic+zoo">zoo</a></code> for more information.</p>
</td></tr>
<tr><td><code id="tk_zooreg_dispatch__+3A_silent">silent</code></td>
<td>
<p>Used to toggle printing of messages and warnings.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector
</p>

<hr>
<h2 id='ts_clean_vec'>Replace Outliers &amp; Missing Values in a Time Series</h2><span id='topic+ts_clean_vec'></span>

<h3>Description</h3>

<p>This is mainly a wrapper for the outlier cleaning function,
<code>tsclean()</code>, from the <code>forecast</code> R package.
The <code>ts_clean_vec()</code> function includes arguments for applying
seasonality to numeric vector (non-<code>ts</code>) via the <code>period</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_clean_vec(x, period = 1, lambda = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_clean_vec_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="ts_clean_vec_+3A_period">period</code></td>
<td>
<p>A seasonal period to use during the transformation. If <code>period = 1</code>,
seasonality is not included and <code>supsmu()</code> is used to fit a trend.
If <code>period &gt; 1</code>, a robust STL decomposition is
first performed and a linear interpolation is applied to the seasonally adjusted data.</p>
</td></tr>
<tr><td><code id="ts_clean_vec_+3A_lambda">lambda</code></td>
<td>
<p>A box cox transformation parameter. If set to <code>"auto"</code>, performs
automated lambda selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Cleaning Outliers</strong>
</p>

<ol>
<li><p> Non-Seasonal (<code>period = 1</code>): Uses <code>stats::supsmu()</code>
</p>
</li>
<li><p> Seasonal (<code>period &gt; 1</code>): Uses <code>forecast::mstl()</code> with <code>robust = TRUE</code> (robust STL decomposition)
for seasonal series.
</p>
</li></ol>

<p>To estimate missing values and outlier replacements, linear interpolation is used on the
(possibly seasonally adjusted) series. See <code>forecast::tsoutliers()</code> for the outlier detection method.
</p>
<p><strong>Box Cox Transformation</strong>
</p>
<p>In many circumstances, a Box Cox transformation can help. Especially if the series is multiplicative
meaning the variance grows exponentially. A Box Cox transformation can be automated by setting <code>lambda = "auto"</code>
or can be specified by setting <code style="white-space: pre;">&#8288;lambda = numeric value&#8288;</code>.
</p>


<h3>Value</h3>

<p>A <code>numeric</code> vector with the missing values and/or anomalies transformed to imputed values.
</p>


<h3>References</h3>


<ul>
<li> <p><a href="https://github.com/robjhyndman/forecast">Forecast R Package</a>
</p>
</li>
<li> <p><a href="https://otexts.com/fpp2/missing-outliers.html">Forecasting Principles &amp; Practices: Dealing with missing values and outliers</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li><p> Box Cox Transformation: <code><a href="#topic+box_cox_vec">box_cox_vec()</a></code>
</p>
</li>
<li><p> Lag Transformation: <code><a href="#topic+lag_vec">lag_vec()</a></code>
</p>
</li>
<li><p> Differencing Transformation: <code><a href="#topic+diff_vec">diff_vec()</a></code>
</p>
</li>
<li><p> Rolling Window Transformation: <code><a href="#topic+slidify_vec">slidify_vec()</a></code>
</p>
</li>
<li><p> Loess Smoothing Transformation: <code><a href="#topic+smooth_vec">smooth_vec()</a></code>
</p>
</li>
<li><p> Fourier Series: <code><a href="#topic+fourier_vec">fourier_vec()</a></code>
</p>
</li>
<li><p> Missing Value Imputation for Time Series: <code><a href="#topic+ts_impute_vec">ts_impute_vec()</a></code>
</p>
</li>
<li><p> Outlier Cleaning for Time Series: <code><a href="#topic+ts_clean_vec">ts_clean_vec()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)


# --- VECTOR ----

values &lt;- c(1,2,3, 4*2, 5,6,7, NA, 9,10,11, 12*2)
values

# Linear interpolation + Outlier Cleansing
ts_clean_vec(values, period = 1, lambda = NULL)

# Seasonal Interpolation: set period = 4
ts_clean_vec(values, period = 4, lambda = NULL)

# Seasonal Interpolation with Box Cox Transformation (internal)
ts_clean_vec(values, period = 4, lambda = "auto")


</code></pre>

<hr>
<h2 id='ts_impute_vec'>Missing Value Imputation for Time Series</h2><span id='topic+ts_impute_vec'></span>

<h3>Description</h3>

<p>This is mainly a wrapper for the Seasonally Adjusted Missing Value using Linear Interpolation function,
<code>na.interp()</code>, from the <code>forecast</code> R package. The <code>ts_impute_vec()</code> function includes arguments for applying
seasonality to numeric vector (non-<code>ts</code>) via the <code>period</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ts_impute_vec(x, period = 1, lambda = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ts_impute_vec_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
<tr><td><code id="ts_impute_vec_+3A_period">period</code></td>
<td>
<p>A seasonal period to use during the transformation. If <code>period = 1</code>,
linear interpolation is performed. If <code>period &gt; 1</code>, a robust STL decomposition is
first performed and a linear interpolation is applied to the seasonally adjusted data.</p>
</td></tr>
<tr><td><code id="ts_impute_vec_+3A_lambda">lambda</code></td>
<td>
<p>A box cox transformation parameter. If set to <code>"auto"</code>, performs
automated lambda selection.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Imputation using Linear Interpolation</strong>
</p>
<p>Three circumstances cause strictly linear interpolation:
</p>

<ol>
<li> <p><strong>Period is 1:</strong> With <code>period = 1</code>, a seasonality cannot be interpreted and therefore linear is used.
</p>
</li>
<li> <p><strong>Number of Non-Missing Values is less than 2-Periods</strong>: Insufficient values exist to detect seasonality.
</p>
</li>
<li> <p><strong>Number of Total Values is less than 3-Periods</strong>: Insufficient values exist to detect seasonality.
</p>
</li></ol>

<p><strong>Seasonal Imputation using Linear Interpolation</strong>
</p>
<p>For seasonal series with <code>period &gt; 1</code>, a robust Seasonal Trend Loess (STL) decomposition is first computed.
Then a linear interpolation is applied to the seasonally adjusted data, and
the seasonal component is added back.
</p>
<p><strong>Box Cox Transformation</strong>
</p>
<p>In many circumstances, a Box Cox transformation can help. Especially if the series is multiplicative
meaning the variance grows exponentially. A Box Cox transformation can be automated by setting <code>lambda = "auto"</code>
or can be specified by setting <code style="white-space: pre;">&#8288;lambda = numeric value&#8288;</code>.
</p>


<h3>Value</h3>

<p>A <code>numeric</code> vector with the missing values imputed.
</p>


<h3>References</h3>


<ul>
<li> <p><a href="https://github.com/robjhyndman/forecast">Forecast R Package</a>
</p>
</li>
<li> <p><a href="https://otexts.com/fpp2/missing-outliers.html">Forecasting Principles &amp; Practices: Dealing with missing values and outliers</a>
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li><p> Box Cox Transformation: <code><a href="#topic+box_cox_vec">box_cox_vec()</a></code>
</p>
</li>
<li><p> Lag Transformation: <code><a href="#topic+lag_vec">lag_vec()</a></code>
</p>
</li>
<li><p> Differencing Transformation: <code><a href="#topic+diff_vec">diff_vec()</a></code>
</p>
</li>
<li><p> Rolling Window Transformation: <code><a href="#topic+slidify_vec">slidify_vec()</a></code>
</p>
</li>
<li><p> Loess Smoothing Transformation: <code><a href="#topic+smooth_vec">smooth_vec()</a></code>
</p>
</li>
<li><p> Fourier Series: <code><a href="#topic+fourier_vec">fourier_vec()</a></code>
</p>
</li>
<li><p> Missing Value Imputation for Time Series: <code><a href="#topic+ts_impute_vec">ts_impute_vec()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)


# --- VECTOR ----

values &lt;- c(1,2,3, 4*2, 5,6,7, NA, 9,10,11, 12*2)
values

# Linear interpolation
ts_impute_vec(values, period = 1, lambda = NULL)

# Seasonal Interpolation: set period = 4
ts_impute_vec(values, period = 4, lambda = NULL)

# Seasonal Interpolation with Box Cox Transformation (internal)
ts_impute_vec(values, period = 4, lambda = "auto")


</code></pre>

<hr>
<h2 id='walmart_sales_weekly'>Sample Time Series Retail Data from the Walmart Recruiting Store Sales Forecasting Competition</h2><span id='topic+walmart_sales_weekly'></span>

<h3>Description</h3>

<p>The Kaggle &quot;Walmart Recruiting - Store Sales Forecasting&quot; Competition
used <strong>retail data</strong> for combinations of stores and departments within each store.
The competition began February 20th, 2014 and ended May 5th, 2014.
The competition included data from 45 retail stores located in different regions.
The dataset included various external features including Holiday information,
Temperature, Fuel Price, and Markdown.
This dataset includes a <strong>Sample of 7 departments from the Store ID 1 (7 total time series)</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>walmart_sales_weekly
</code></pre>


<h3>Format</h3>

<p>A tibble: 9,743 x 3
</p>

<ul>
<li> <p><code>id</code> Factor. Unique series identifier (4 total)
</p>
</li>
<li> <p><code>Store</code> Numeric. Store ID.
</p>
</li>
<li> <p><code>Dept</code> Numeric. Department ID.
</p>
</li>
<li> <p><code>Date</code> Date. Weekly timestamp.
</p>
</li>
<li> <p><code>Weekly_Sales</code> Numeric. Sales for the given department in the given store.
</p>
</li>
<li> <p><code>IsHoliday</code> Logical. Whether the week is a &quot;special&quot; holiday for the store.
</p>
</li>
<li> <p><code>Type</code> Character. Type identifier of the store.
</p>
</li>
<li> <p><code>Size</code> Numeric. Store square-footage
</p>
</li>
<li> <p><code>Temperature</code> Numeric. Average temperature in the region.
</p>
</li>
<li> <p><code>Fuel_Price</code> Numeric. Cost of fuel in the region.
</p>
</li>
<li> <p><code>MarkDown1</code>, <code>MarkDown2</code>, <code>MarkDown3</code>, <code>MarkDown4</code>, <code>MarkDown5</code> Numeric.
Anonymized data related to promotional markdowns that Walmart is running.
MarkDown data is only available after Nov 2011, and is not available for
all stores all the time. Any missing value is marked with an NA.
</p>
</li>
<li> <p><code>CPI</code> Numeric. The consumer price index.
</p>
</li>
<li> <p><code>Unemployment</code> Numeric. The unemployment rate in the region.
</p>
</li></ul>



<h3>Details</h3>

<p>This is a sample of 7 Weekly data sets from the Kaggle Walmart Recruiting
Store Sales Forecasting competition.
</p>
<p><strong>Holiday Features</strong>
</p>
<p>The four holidays fall within the following weeks in the dataset (not all holidays are in the data):
</p>

<ul>
<li><p> Super Bowl: 12-Feb-10, 11-Feb-11, 10-Feb-12, 8-Feb-13
</p>
</li>
<li><p> Labor Day: 10-Sep-10, 9-Sep-11, 7-Sep-12, 6-Sep-13
</p>
</li>
<li><p> Thanksgiving: 26-Nov-10, 25-Nov-11, 23-Nov-12, 29-Nov-13
</p>
</li>
<li><p> Christmas: 31-Dec-10, 30-Dec-11, 28-Dec-12, 27-Dec-13
</p>
</li></ul>



<h3>Source</h3>


<ul>
<li> <p><a href="https://www.kaggle.com/c/walmart-recruiting-store-sales-forecasting">Kaggle Competition Website</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>walmart_sales_weekly

</code></pre>

<hr>
<h2 id='wikipedia_traffic_daily'>Sample Daily Time Series Data from the Web Traffic Forecasting (Wikipedia) Competition</h2><span id='topic+wikipedia_traffic_daily'></span>

<h3>Description</h3>

<p>The Kaggle &quot;Web Traffic Forecasting&quot; (Wikipedia) Competition
used <strong>Google Analytics Web Traffic Data</strong> for 145,000 websites.
Each of these time series represent a number of daily views of a different Wikipedia articles.
The competition began July 13th, 2017 and ended November 15th, 2017.
This dataset includes a <strong>Sample of 10 article pages (10 total time series)</strong>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wikipedia_traffic_daily
</code></pre>


<h3>Format</h3>

<p>A tibble: 9,743 x 3
</p>

<ul>
<li> <p><code>Page</code> Character. Page information.
</p>
</li>
<li> <p><code>date</code> Date. Daily timestamp.
</p>
</li>
<li> <p><code>value</code> Numeric. Daily views of the wikipedia article.
</p>
</li></ul>



<h3>Details</h3>

<p>This is a sample of 10 Daily data sets from the Kaggle Web Traffic Forecasting (Wikipedia) Competition
</p>


<h3>Source</h3>


<ul>
<li> <p><a href="https://www.kaggle.com/c/web-traffic-time-series-forecasting">Kaggle Competition Website</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
wikipedia_traffic_daily

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
