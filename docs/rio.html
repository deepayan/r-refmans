<!DOCTYPE html><html lang="en"><head><title>Help for package rio</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rio}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rio'><p>A Swiss-Army Knife for Data I/O</p></a></li>
<li><a href='#characterize'><p>Character conversion of labelled data</p></a></li>
<li><a href='#convert'><p>Convert from one file format to another</p></a></li>
<li><a href='#export'><p>Export</p></a></li>
<li><a href='#export_list'><p>Export list of data frames to files</p></a></li>
<li><a href='#gather_attrs'><p>Gather attributes from data frame variables</p></a></li>
<li><a href='#get_info'><p>Get File Info</p></a></li>
<li><a href='#import'><p>Import</p></a></li>
<li><a href='#import_list'><p>Import list of data frames</p></a></li>
<li><a href='#install_formats'><p>Install rio's &lsquo;Suggests&rsquo; Dependencies</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Swiss-Army Knife for Data I/O</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Streamlined data import and export by making assumptions that
    the user is probably willing to make: 'import()' and 'export()' determine
    the data format from the file extension, reasonable defaults are used for
    data import and export, web-based import is natively supported (including
    from SSL/HTTPS), compressed files can be read directly, and fast import
    packages are used where appropriate. An additional convenience function,
    'convert()', provides a simple method for converting between file types.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gesistsa.github.io/rio/">https://gesistsa.github.io/rio/</a>, <a href="https://github.com/gesistsa/rio">https://github.com/gesistsa/rio</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gesistsa/rio/issues">https://github.com/gesistsa/rio/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>tools, stats, utils, foreign, haven (&ge; 1.1.2), curl (&ge; 0.6),
data.table (&ge; 1.11.2), readxl (&ge; 0.1.1), tibble, writexl,
lifecycle, R.utils, readr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>datasets, bit64, testthat, knitr, magrittr, clipr, fst,
hexView, jsonlite, pzfx, readODS (&ge; 2.1.0), rmarkdown, rmatio,
xml2 (&ge; 1.2.0), yaml, qs, arrow (&ge; 0.17.0), stringi, withr,
nanoparquet</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>gesistsa/tsatemplate</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-09-25 14:30:58 UTC; chainsawriot</td>
</tr>
<tr>
<td>Author:</td>
<td>Jason Becker [aut],
  Chung-hong Chan <a href="https://orcid.org/0000-0002-6232-7530"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  David Schoch <a href="https://orcid.org/0000-0003-2952-4812"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Geoffrey CH Chan [ctb],
  Thomas J. Leeper <a href="https://orcid.org/0000-0003-4097-6326"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Christopher Gandrud [ctb],
  Andrew MacDonald [ctb],
  Ista Zahn [ctb],
  Stanislaus Stadlmann [ctb],
  Ruaridh Williamson [ctb],
  Patrick Kennedy [ctb],
  Ryan Price [ctb],
  Trevor L Davis [ctb],
  Nathan Day [ctb],
  Bill Denney <a href="https://orcid.org/0000-0002-5759-428X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Alex Bokov <a href="https://orcid.org/0000-0002-0511-9815"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Hugo Gruson <a href="https://orcid.org/0000-0002-4094-1476"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chung-hong Chan &lt;chainsawtiney@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-09-25 17:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rio'>A Swiss-Army Knife for Data I/O</h2><span id='topic+rio-package'></span><span id='topic+rio'></span>

<h3>Description</h3>

<p>The aim of rio is to make data file input and output as easy as possible. <code><a href="#topic+export">export()</a></code> and <code><a href="#topic+import">import()</a></code> serve as a Swiss-army knife for painless data I/O for data from almost any file format by inferring the data structure from the file extension, natively reading web-based data sources, setting reasonable defaults for import and export, and relying on efficient data import and export packages. An additional convenience function, <code><a href="#topic+convert">convert()</a></code>, provides a simple method for converting between file types.
</p>
<p>Note that some of rio's functionality is provided by &lsquo;Suggests&rsquo; dependendencies, meaning they are not installed by default. Use <code><a href="#topic+install_formats">install_formats()</a></code> to make sure these packages are available for use.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Chung-hong Chan <a href="mailto:chainsawtiney@gmail.com">chainsawtiney@gmail.com</a> (<a href="https://orcid.org/0000-0002-6232-7530">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Jason Becker <a href="mailto:jason@jbecker.co">jason@jbecker.co</a>
</p>
</li>
<li><p> David Schoch <a href="mailto:david@schochastics.net">david@schochastics.net</a> (<a href="https://orcid.org/0000-0003-2952-4812">ORCID</a>)
</p>
</li>
<li><p> Thomas J. Leeper <a href="mailto:thosjleeper@gmail.com">thosjleeper@gmail.com</a> (<a href="https://orcid.org/0000-0003-4097-6326">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Geoffrey CH Chan <a href="mailto:gefchchan@gmail.com">gefchchan@gmail.com</a> [contributor]
</p>
</li>
<li><p> Christopher Gandrud [contributor]
</p>
</li>
<li><p> Andrew MacDonald [contributor]
</p>
</li>
<li><p> Ista Zahn [contributor]
</p>
</li>
<li><p> Stanislaus Stadlmann [contributor]
</p>
</li>
<li><p> Ruaridh Williamson <a href="mailto:ruaridh.williamson@gmail.com">ruaridh.williamson@gmail.com</a> [contributor]
</p>
</li>
<li><p> Patrick Kennedy [contributor]
</p>
</li>
<li><p> Ryan Price <a href="mailto:ryapric@gmail.com">ryapric@gmail.com</a> [contributor]
</p>
</li>
<li><p> Trevor L Davis <a href="mailto:trevor.l.davis@gmail.com">trevor.l.davis@gmail.com</a> [contributor]
</p>
</li>
<li><p> Nathan Day <a href="mailto:nathancday@gmail.com">nathancday@gmail.com</a> [contributor]
</p>
</li>
<li><p> Bill Denney <a href="mailto:wdenney@humanpredictions.com">wdenney@humanpredictions.com</a> (<a href="https://orcid.org/0000-0002-5759-428X">ORCID</a>) [contributor]
</p>
</li>
<li><p> Alex Bokov <a href="mailto:alex.bokov@gmail.com">alex.bokov@gmail.com</a> (<a href="https://orcid.org/0000-0002-0511-9815">ORCID</a>) [contributor]
</p>
</li>
<li><p> Hugo Gruson (<a href="https://orcid.org/0000-0002-4094-1476">ORCID</a>) [contributor]
</p>
</li></ul>



<h3>References</h3>

<p><a href="https://cran.r-project.org/package=datamods">datamods</a> provides Shiny modules for importing data via <code>rio</code>.
</p>
<p><a href="https://github.com/Stan125/GREA">GREA</a> provides an RStudio add-in to import data using rio.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+import">import()</a></code>, <code><a href="#topic+import_list">import_list()</a></code>, <code><a href="#topic+export">export()</a></code>, <code><a href="#topic+export_list">export_list()</a></code>, <code><a href="#topic+convert">convert()</a></code>, <code><a href="#topic+install_formats">install_formats()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># export
library("datasets")
export(mtcars, csv_file &lt;- tempfile(fileext = ".csv")) # comma-separated values
export(mtcars, rds_file &lt;- tempfile(fileext = ".rds")) # R serialized
export(mtcars, sav_file &lt;- tempfile(fileext = ".sav")) # SPSS

# import
x &lt;- import(csv_file)
y &lt;- import(rds_file)
z &lt;- import(sav_file)

# convert sav (SPSS) to dta (Stata)
convert(sav_file, dta_file &lt;- tempfile(fileext = ".dta"))

# cleanup
unlink(c(csv_file, rds_file, sav_file, dta_file))

</code></pre>

<hr>
<h2 id='characterize'>Character conversion of labelled data</h2><span id='topic+characterize'></span><span id='topic+factorize'></span><span id='topic+characterize.default'></span><span id='topic+characterize.data.frame'></span><span id='topic+factorize.default'></span><span id='topic+factorize.data.frame'></span>

<h3>Description</h3>

<p>Convert labelled variables to character or factor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>characterize(x, ...)

factorize(x, ...)

## Default S3 method:
characterize(x, ...)

## S3 method for class 'data.frame'
characterize(x, ...)

## Default S3 method:
factorize(x, coerce_character = FALSE, ...)

## S3 method for class 'data.frame'
factorize(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="characterize_+3A_x">x</code></td>
<td>
<p>A vector or data frame.</p>
</td></tr>
<tr><td><code id="characterize_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods</p>
</td></tr>
<tr><td><code id="characterize_+3A_coerce_character">coerce_character</code></td>
<td>
<p>A logical indicating whether to additionally coerce character columns to factor (in <code>factorize</code>). Default <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>characterize</code> converts a vector with a <code>labels</code> attribute of named levels into a character vector. <code>factorize</code> does the same but to factors. This can be useful at two stages of a data workflow: (1) importing labelled data from metadata-rich file formats (e.g., Stata or SPSS), and (2) exporting such data to plain text files (e.g., CSV) in a way that preserves information.
</p>


<h3>Value</h3>

<p>a character vector (for <code>characterize</code>) or factor vector (for <code>factorize</code>)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gather_attrs">gather_attrs()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## vector method
x &lt;- structure(1:4, labels = c("A" = 1, "B" = 2, "C" = 3))
characterize(x)
factorize(x)

## data frame method
x &lt;- data.frame(v1 = structure(1:4, labels = c("A" = 1, "B" = 2, "C" = 3)),
                v2 = structure(c(1,0,0,1), labels = c("foo" = 0, "bar" = 1)))
str(factorize(x))
str(characterize(x))

## Application
csv_file &lt;- tempfile(fileext = ".csv")
## comparison of exported file contents
import(export(x, csv_file))
import(export(factorize(x), csv_file))
</code></pre>

<hr>
<h2 id='convert'>Convert from one file format to another</h2><span id='topic+convert'></span>

<h3>Description</h3>

<p>This function constructs a data frame from a data file using <code><a href="#topic+import">import()</a></code> and uses <code><a href="#topic+export">export()</a></code> to write the data to disk in the format indicated by the file extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert(in_file, out_file, in_opts = list(), out_opts = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convert_+3A_in_file">in_file</code></td>
<td>
<p>A character string naming an input file.</p>
</td></tr>
<tr><td><code id="convert_+3A_out_file">out_file</code></td>
<td>
<p>A character string naming an output file.</p>
</td></tr>
<tr><td><code id="convert_+3A_in_opts">in_opts</code></td>
<td>
<p>A named list of options to be passed to <code><a href="#topic+import">import()</a></code>.</p>
</td></tr>
<tr><td><code id="convert_+3A_out_opts">out_opts</code></td>
<td>
<p>A named list of options to be passed to <code><a href="#topic+export">export()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string containing the name of the output file (invisibly).
</p>


<h3>See Also</h3>

<p><a href="https://lbraglia.github.io/">Luca Braglia</a> has created a Shiny app called <a href="https://github.com/lbraglia/rioweb">rioweb</a> that provides access to the file conversion features of rio through a web browser.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For demo, a temp. file path is created with the file extension .dta (Stata)
dta_file &lt;- tempfile(fileext = ".dta")
## .csv
csv_file &lt;- tempfile(fileext = ".csv")
## .xlsx
xlsx_file &lt;- tempfile(fileext = ".xlsx")


## Create a Stata data file
export(mtcars, dta_file)

## convert Stata to CSV and open converted file
convert(dta_file, csv_file)
import(csv_file)

## correct an erroneous file format
export(mtcars, xlsx_file, format = "tsv") ## DON'T DO THIS
## import(xlsx_file) ## ERROR
## convert the file by specifying `in_opts`
convert(xlsx_file, xlsx_file, in_opts = list(format = "tsv"))
import(xlsx_file)

## convert from the command line:
## Rscript -e "rio::convert('mtcars.dta', 'mtcars.csv')"
</code></pre>

<hr>
<h2 id='export'>Export</h2><span id='topic+export'></span>

<h3>Description</h3>

<p>Write data.frame to a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export(x, file, format, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_+3A_x">x</code></td>
<td>
<p>A data frame, matrix or a single-item list of data frame to be written into a file. Exceptions to this rule are that <code>x</code> can be a list of multiple data frames if the output file format is an OpenDocument Spreadsheet (.ods, .fods), Excel .xlsx workbook, .Rdata file, or HTML file, or a variety of R objects if the output file format is RDS or JSON. See examples.) To export a list of data frames to multiple files, use <code><a href="#topic+export_list">export_list()</a></code> instead.</p>
</td></tr>
<tr><td><code id="export_+3A_file">file</code></td>
<td>
<p>A character string naming a file. Must specify <code>file</code> and/or <code>format</code>.</p>
</td></tr>
<tr><td><code id="export_+3A_format">format</code></td>
<td>
<p>An optional character string containing the file format, which can be used to override the format inferred from <code>file</code> or, in lieu of specifying <code>file</code>, a file with the symbol name of <code>x</code> and the specified file extension will be created. Must specify <code>file</code> and/or <code>format</code>. Shortcuts include: &ldquo;,&rdquo; (for comma-separated values), &ldquo;;&rdquo; (for semicolon-separated values), &ldquo;|&rdquo; (for pipe-separated values), and &ldquo;dump&rdquo; for <code><a href="base.html#topic+dump">base::dump()</a></code>.</p>
</td></tr>
<tr><td><code id="export_+3A_...">...</code></td>
<td>
<p>Additional arguments for the underlying export functions. This can be used to specify non-standard arguments. See examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function exports a data frame or matrix into a file with file format based on the file extension (or the manually specified format, if <code>format</code> is specified).
</p>
<p>The output file can be to a compressed directory, simply by adding an appropriate additional extensiont to the <code>file</code> argument, such as: &ldquo;mtcars.csv.tar&rdquo;, &ldquo;mtcars.csv.zip&rdquo;, or &ldquo;mtcars.csv.gz&rdquo;.
</p>
<p><code>export</code> supports many file formats. See the documentation for the underlying export functions for optional arguments that can be passed via <code>...</code>
</p>

<ul>
<li><p> Comma-separated data (.csv), using <code><a href="data.table.html#topic+fwrite">data.table::fwrite()</a></code>
</p>
</li>
<li><p> Pipe-separated data (.psv), using <code><a href="data.table.html#topic+fwrite">data.table::fwrite()</a></code>
</p>
</li>
<li><p> Tab-separated data (.tsv), using <code><a href="data.table.html#topic+fwrite">data.table::fwrite()</a></code>
</p>
</li>
<li><p> SAS (.sas7bdat), using <code><a href="haven.html#topic+write_sas">haven::write_sas()</a></code>.
</p>
</li>
<li><p> SAS XPORT (.xpt), using <code><a href="haven.html#topic+read_xpt">haven::write_xpt()</a></code>.
</p>
</li>
<li><p> SPSS (.sav), using <code><a href="haven.html#topic+read_spss">haven::write_sav()</a></code>
</p>
</li>
<li><p> SPSS compressed (.zsav), using <code><a href="haven.html#topic+read_spss">haven::write_sav()</a></code>
</p>
</li>
<li><p> Stata (.dta), using <code><a href="haven.html#topic+read_dta">haven::write_dta()</a></code>. Note that variable/column names containing dots (.) are not allowed and will produce an error.
</p>
</li>
<li><p> Excel (.xlsx), using <code><a href="writexl.html#topic+write_xlsx">writexl::write_xlsx()</a></code>. <code>x</code> can also be a list of data frames; the list entry names are used as sheet names.
</p>
</li>
<li><p> R syntax object (.R), using <code><a href="base.html#topic+dput">base::dput()</a></code> (by default) or <code><a href="base.html#topic+dump">base::dump()</a></code> (if <code>format = 'dump'</code>)
</p>
</li>
<li><p> Saved R objects (.RData,.rda), using <code><a href="base.html#topic+save">base::save()</a></code>. In this case, <code>x</code> can be a data frame, a named list of objects, an R environment, or a character vector containing the names of objects if a corresponding <code>envir</code> argument is specified.
</p>
</li>
<li><p> Serialized R objects (.rds), using <code><a href="base.html#topic+readRDS">base::saveRDS()</a></code>. In this case, <code>x</code> can be any serializable R object.
</p>
</li>
<li><p> Serialized R objects (.qs), using <code><a href="qs.html#topic+qsave">qs::qsave()</a></code>, which is
significantly faster than .rds. This can be any R
object (not just a data frame).
</p>
</li>
<li><p> &quot;XBASE&quot; database files (.dbf), using <code><a href="foreign.html#topic+write.dbf">foreign::write.dbf()</a></code>
</p>
</li>
<li><p> Weka Attribute-Relation File Format (.arff), using <code><a href="foreign.html#topic+write.arff">foreign::write.arff()</a></code>
</p>
</li>
<li><p> Fixed-width format data (.fwf), using <code><a href="utils.html#topic+write.table">utils::write.table()</a></code> with <code>row.names = FALSE</code>, <code>quote = FALSE</code>, and <code>col.names = FALSE</code>
</p>
</li>
<li> <p><a href="https://github.com/csvy">CSVY</a> (CSV with a YAML metadata header) using <code><a href="data.table.html#topic+fwrite">data.table::fwrite()</a></code>.
</p>
</li>
<li><p> Apache Arrow Parquet (.parquet), using <code><a href="nanoparquet.html#topic+write_parquet">nanoparquet::write_parquet()</a></code>
</p>
</li>
<li><p> Feather R/Python interchange format (.feather), using <code><a href="arrow.html#topic+write_feather">arrow::write_feather()</a></code>
</p>
</li>
<li><p> Fast storage (.fst), using <code><a href="fst.html#topic+write_fst">fst::write.fst()</a></code>
</p>
</li>
<li><p> JSON (.json), using <code><a href="jsonlite.html#topic+fromJSON">jsonlite::toJSON()</a></code>. In this case, <code>x</code> can be a variety of R objects, based on class mapping conventions in this paper: <a href="https://arxiv.org/abs/1403.2805">https://arxiv.org/abs/1403.2805</a>.
</p>
</li>
<li><p> Matlab (.mat), using <code><a href="rmatio.html#topic+write.mat-methods">rmatio::write.mat()</a></code>
</p>
</li>
<li><p> OpenDocument Spreadsheet (.ods, .fods), using <code><a href="readODS.html#topic+write_ods">readODS::write_ods()</a></code> or <code><a href="readODS.html#topic+write_ods">readODS::write_fods()</a></code>.
</p>
</li>
<li><p> HTML (.html), using a custom method based on <code><a href="xml2.html#topic+xml_replace">xml2::xml_add_child()</a></code> to create a simple HTML table and <code><a href="xml2.html#topic+write_xml">xml2::write_xml()</a></code> to write to disk.
</p>
</li>
<li><p> XML (.xml), using a custom method based on <code><a href="xml2.html#topic+xml_replace">xml2::xml_add_child()</a></code> to create a simple XML tree and <code><a href="xml2.html#topic+write_xml">xml2::write_xml()</a></code> to write to disk.
</p>
</li>
<li><p> YAML (.yml), using <code><a href="yaml.html#topic+write_yaml">yaml::write_yaml()</a></code>, default to write the content with UTF-8. Might not work on some older systems, e.g. default Windows locale for R &lt;= 4.2.
</p>
</li>
<li><p> Clipboard export (on Windows and Mac OS), using <code><a href="utils.html#topic+write.table">utils::write.table()</a></code> with <code>row.names = FALSE</code>
</p>
</li></ul>

<p>When exporting a data set that contains label attributes (e.g., if imported from an SPSS or Stata file) to a plain text file, <code><a href="#topic+characterize">characterize()</a></code> can be a useful pre-processing step that records value labels into the resulting file (e.g., <code>export(characterize(x), "file.csv")</code>) rather than the numeric values.
</p>
<p>Use <code><a href="#topic+export_list">export_list()</a></code> to export a list of dataframes to separate files.
</p>


<h3>Value</h3>

<p>The name of the output file as a character string (invisibly).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+characterize">characterize()</a></code>, <code><a href="#topic+import">import()</a></code>, <code><a href="#topic+convert">convert()</a></code>, <code><a href="#topic+export_list">export_list()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For demo, a temp. file path is created with the file extension .csv
csv_file &lt;- tempfile(fileext = ".csv")
## .xlsx
xlsx_file &lt;- tempfile(fileext = ".xlsx")

## create CSV to import
export(iris, csv_file)

## You can certainly export your data with the file name, which is not a variable:
## import(mtcars, "car_data.csv")

## pass arguments to the underlying function
## data.table::fwrite is the underlying function and `col.names` is an argument
export(iris, csv_file, col.names = FALSE)

## export a list of data frames as worksheets
export(list(a = mtcars, b = iris), xlsx_file)

# NOT RECOMMENDED

## specify `format` to override default format
export(iris, xlsx_file, format = "csv") ## That's confusing
## You can also specify only the format; in the following case
## "mtcars.dta" is written [also confusing]

## export(mtcars, format = "stata")
</code></pre>

<hr>
<h2 id='export_list'>Export list of data frames to files</h2><span id='topic+export_list'></span>

<h3>Description</h3>

<p>Use <code><a href="#topic+export">export()</a></code> to export a list of data frames to a vector of file names or a filename pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>export_list(x, file, archive = "", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="export_list_+3A_x">x</code></td>
<td>
<p>A list of data frames to be written to files.</p>
</td></tr>
<tr><td><code id="export_list_+3A_file">file</code></td>
<td>
<p>A character vector string containing a single file name with a <code style="white-space: pre;">&#8288;\%s&#8288;</code> wildcard placeholder, or a vector of file paths for multiple files to be imported. If <code>x</code> elements are named, these will be used in place of <code style="white-space: pre;">&#8288;\%s&#8288;</code>, otherwise numbers will be used; all elements must be named for names to be used.</p>
</td></tr>
<tr><td><code id="export_list_+3A_archive">archive</code></td>
<td>
<p>character. Either empty string (default) to save files in current
directory, a path to a (new) directory, or a .zip/.tar file to compress all
files into an archive.</p>
</td></tr>
<tr><td><code id="export_list_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+export">export()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+export">export()</a></code> can export a list of data frames to a single multi-dataset file (e.g., an Rdata or Excel .xlsx file). Use <code>export_list</code> to export such a list to <em>multiple</em> files.
</p>


<h3>Value</h3>

<p>The name(s) of the output file(s) as a character vector (invisibly).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+import">import()</a></code>, <code><a href="#topic+import_list">import_list()</a></code>, <code><a href="#topic+export">export()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For demo, a temp. file path is created with the file extension .xlsx
xlsx_file &lt;- tempfile(fileext = ".xlsx")
export(
    list(
        mtcars1 = mtcars[1:10, ],
        mtcars2 = mtcars[11:20, ],
        mtcars3 = mtcars[21:32, ]
    ),
    xlsx_file
)

# import a single file from multi-object workbook
import(xlsx_file, sheet = "mtcars1")
# import all worksheets, the return value is a list
import_list(xlsx_file)
library('datasets')
export(list(mtcars1 = mtcars[1:10,],
            mtcars2 = mtcars[11:20,],
            mtcars3 = mtcars[21:32,]),
    xlsx_file &lt;- tempfile(fileext = ".xlsx")
)

# import all worksheets
list_of_dfs &lt;- import_list(xlsx_file)

# re-export as separate named files

## export_list(list_of_dfs, file = c("file1.csv", "file2.csv", "file3.csv"))

# re-export as separate files using a name pattern; using the names in the list
## This will be written as "mtcars1.csv", "mtcars2.csv", "mtcars3.csv"

## export_list(list_of_dfs, file = "%s.csv")
</code></pre>

<hr>
<h2 id='gather_attrs'>Gather attributes from data frame variables</h2><span id='topic+gather_attrs'></span><span id='topic+spread_attrs'></span>

<h3>Description</h3>

<p><code>gather_attrs</code> moves variable-level attributes to the data frame level and <code>spread_attrs</code> reverses that operation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gather_attrs(x)

spread_attrs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gather_attrs_+3A_x">x</code></td>
<td>
<p>A data frame.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+import">import()</a></code> attempts to standardize the return value from the various import functions to the extent possible, thus providing a uniform data structure regardless of what import package or function is used. It achieves this by storing any optional variable-related attributes at the variable level (i.e., an attribute for <code>mtcars$mpg</code> is stored in <code>attributes(mtcars$mpg)</code> rather than <code>attributes(mtcars)</code>). <code>gather_attrs</code> moves these to the data frame level (i.e., in <code>attributes(mtcars)</code>). <code>spread_attrs</code> moves attributes back to the variable level.
</p>


<h3>Value</h3>

<p><code>x</code>, with variable-level attributes stored at the data frame level.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+import">import()</a></code>, <code><a href="#topic+characterize">characterize()</a></code>
</p>

<hr>
<h2 id='get_info'>Get File Info</h2><span id='topic+get_info'></span><span id='topic+get_ext'></span>

<h3>Description</h3>

<p>A utility function to retrieve the file information of a filename, path, or URL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_info(file)

get_ext(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_info_+3A_file">file</code></td>
<td>
<p>A character string containing a filename, file path, or URL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code><a href="#topic+get_info">get_info()</a></code>, a list is return with the following slots
</p>

<ul>
<li> <p><code>input</code> file extension or information used to identify the possible file format
</p>
</li>
<li> <p><code>format</code> file format, see <code>format</code> argument of <code><a href="#topic+import">import()</a></code>
</p>
</li>
<li> <p><code>type</code> &quot;import&quot; (supported by default); &quot;suggest&quot; (supported by suggested packages, see <code><a href="#topic+install_formats">install_formats()</a></code>); &quot;enhance&quot; and &quot;known &quot; are not directly supported; <code>NA</code> is unsupported
</p>
</li>
<li> <p><code>format_name</code> name of the format
</p>
</li>
<li> <p><code>import_function</code> What function is used to import this file
</p>
</li>
<li> <p><code>export_function</code> What function is used to export this file
</p>
</li>
<li> <p><code>file</code> <code>file</code>
</p>
</li></ul>

<p>For <code><a href="#topic+get_ext">get_ext()</a></code>, just <code>input</code> (usually file extension) is returned; retained for backward compatibility.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_info("starwars.xlsx")
get_info("starwars.ods")
get_info("https://github.com/ropensci/readODS/raw/v2.1/starwars.ods")
get_info("~/duran_duran_rio.mp3")
get_ext("clipboard") ## "clipboard"
get_ext("https://github.com/ropensci/readODS/raw/v2.1/starwars.ods")
</code></pre>

<hr>
<h2 id='import'>Import</h2><span id='topic+import'></span>

<h3>Description</h3>

<p>Read in a data.frame from a file. Exceptions to this rule are Rdata, RDS, and JSON input file formats, which return the originally saved object without changing its class.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import(
  file,
  format,
  setclass = getOption("rio.import.class", "data.frame"),
  which,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_+3A_file">file</code></td>
<td>
<p>A character string naming a file, URL, or single-file (can be Gzip or Bzip2 compressed), .zip or .tar archive.</p>
</td></tr>
<tr><td><code id="import_+3A_format">format</code></td>
<td>
<p>An optional character string code of file format, which can be used to override the format inferred from <code>file</code>. Shortcuts include: &ldquo;,&rdquo; (for comma-separated values), &ldquo;;&rdquo; (for semicolon-separated values), and &ldquo;|&rdquo; (for pipe-separated values).</p>
</td></tr>
<tr><td><code id="import_+3A_setclass">setclass</code></td>
<td>
<p>An optional character vector specifying one or more classes
to set on the import. By default, the return object is always a
&ldquo;data.frame&rdquo;. Allowed values include &ldquo;tbl_df&rdquo;, &ldquo;tbl&rdquo;, or
&ldquo;tibble&rdquo; (if using tibble), &ldquo;arrow&rdquo;, &ldquo;arrow_table&rdquo; (if using arrow table; the suggested package <code>arrow</code> must be installed) or &ldquo;data.table&rdquo; (if using
data.table). Other values are ignored, such that a data.frame is returned.
The parameter takes precedents over parameters in ... which set a different class.</p>
</td></tr>
<tr><td><code id="import_+3A_which">which</code></td>
<td>
<p>This argument is used to control import from multi-object files; as a rule <code>import</code> only ever returns a single data frame (use <code><a href="#topic+import_list">import_list()</a></code> to import multiple data frames from a multi-object file). If <code>file</code> is an archive format (zip and tar), <code>which</code> can be either a character string specifying a filename or an integer specifying which file (in locale sort order) to extract from the compressed directory. But please see the section <code>which</code> below. For Excel spreadsheets, this can be used to specify a sheet name or number. For .Rdata files, this can be an object name. For HTML files, it identifies which table to extract (from document order). Ignored otherwise. A character string value will be used as a regular expression, such that the extracted file is the first match of the regular expression against the file names in the archive.</p>
</td></tr>
<tr><td><code id="import_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the underlying import functions. For example, this can control column classes for delimited file types, or control the use of haven for Stata and SPSS or readxl for Excel (.xlsx) format. See details below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function imports a data frame or matrix from a data file with the file format based on the file extension (or the manually specified format, if <code>format</code> is specified).
</p>
<p><code>import</code> supports the following file formats:
</p>

<ul>
<li><p> Comma-separated data (.csv), using <code><a href="data.table.html#topic+fread">data.table::fread()</a></code>
</p>
</li>
<li><p> Pipe-separated data (.psv), using <code><a href="data.table.html#topic+fread">data.table::fread()</a></code>
</p>
</li>
<li><p> Tab-separated data (.tsv), using <code><a href="data.table.html#topic+fread">data.table::fread()</a></code>
</p>
</li>
<li><p> SAS (.sas7bdat), using <code><a href="haven.html#topic+read_sas">haven::read_sas()</a></code>
</p>
</li>
<li><p> SAS XPORT (.xpt), using <code><a href="haven.html#topic+read_xpt">haven::read_xpt()</a></code>
</p>
</li>
<li><p> SPSS (.sav), using <code><a href="haven.html#topic+read_spss">haven::read_sav()</a></code>
</p>
</li>
<li><p> SPSS compressed (.zsav), using <code><a href="haven.html#topic+read_spss">haven::read_sav()</a></code>.
</p>
</li>
<li><p> Stata (.dta), using <code><a href="haven.html#topic+read_dta">haven::read_dta()</a></code>
</p>
</li>
<li><p> SPSS Portable Files (.por), using <code><a href="haven.html#topic+read_spss">haven::read_por()</a></code>.
</p>
</li>
<li><p> Excel (.xls and .xlsx), using <code><a href="readxl.html#topic+read_excel">readxl::read_xlsx()</a></code> or <code><a href="readxl.html#topic+read_excel">readxl::read_xls()</a></code>. Use <code>which</code> to specify a sheet number.
</p>
</li>
<li><p> R syntax object (.R), using <code><a href="base.html#topic+dput">base::dget()</a></code>, see <code>trust</code> below.
</p>
</li>
<li><p> Saved R objects (.RData,.rda), using <code><a href="base.html#topic+load">base::load()</a></code> for single-object .Rdata files. Use <code>which</code> to specify an object name for multi-object .Rdata files. This can be any R object (not just a data frame), see <code>trust</code> below.
</p>
</li>
<li><p> Serialized R objects (.rds), using <code><a href="base.html#topic+readRDS">base::readRDS()</a></code>. This can be any R object (not just a data frame), see <code>trust</code> below.
</p>
</li>
<li><p> Serialized R objects (.qs), using <code><a href="qs.html#topic+qread">qs::qread()</a></code>, which is
significantly faster than .rds. This can be any R
object (not just a data frame).
</p>
</li>
<li><p> Epiinfo (.rec), using <code><a href="foreign.html#topic+read.epiinfo">foreign::read.epiinfo()</a></code>
</p>
</li>
<li><p> Minitab (.mtp), using <code><a href="foreign.html#topic+read.mtp">foreign::read.mtp()</a></code>
</p>
</li>
<li><p> Systat (.syd), using <code><a href="foreign.html#topic+read.systat">foreign::read.systat()</a></code>
</p>
</li>
<li><p> &quot;XBASE&quot; database files (.dbf), using <code><a href="foreign.html#topic+read.dbf">foreign::read.dbf()</a></code>
</p>
</li>
<li><p> Weka Attribute-Relation File Format (.arff), using <code><a href="foreign.html#topic+read.arff">foreign::read.arff()</a></code>
</p>
</li>
<li><p> Data Interchange Format (.dif), using <code><a href="utils.html#topic+read.DIF">utils::read.DIF()</a></code>
</p>
</li>
<li><p> Fortran data (no recognized extension), using <code><a href="utils.html#topic+read.fortran">utils::read.fortran()</a></code>
</p>
</li>
<li><p> Fixed-width format data (.fwf), using a faster version of <code><a href="utils.html#topic+read.fwf">utils::read.fwf()</a></code> that requires a <code>widths</code> argument and by default in rio has <code>stringsAsFactors = FALSE</code>
</p>
</li>
<li> <p><a href="https://github.com/csvy">CSVY</a> (CSV with a YAML metadata header) using <code><a href="data.table.html#topic+fread">data.table::fread()</a></code>.
</p>
</li>
<li><p> Apache Arrow Parquet (.parquet), using <code><a href="nanoparquet.html#topic+read_parquet">nanoparquet::read_parquet()</a></code>
</p>
</li>
<li><p> Feather R/Python interchange format (.feather), using <code><a href="arrow.html#topic+read_feather">arrow::read_feather()</a></code>
</p>
</li>
<li><p> Fast storage (.fst), using <code><a href="fst.html#topic+write_fst">fst::read.fst()</a></code>
</p>
</li>
<li><p> JSON (.json), using <code><a href="jsonlite.html#topic+fromJSON">jsonlite::fromJSON()</a></code>
</p>
</li>
<li><p> Matlab (.mat), using <code><a href="rmatio.html#topic+read.mat">rmatio::read.mat()</a></code>
</p>
</li>
<li><p> EViews (.wf1), using <code><a href="hexView.html#topic+readEViews">hexView::readEViews()</a></code>
</p>
</li>
<li><p> OpenDocument Spreadsheet (.ods, .fods), using <code><a href="readODS.html#topic+read_ods">readODS::read_ods()</a></code> or <code><a href="readODS.html#topic+read_ods">readODS::read_fods()</a></code>.  Use <code>which</code> to specify a sheet number.
</p>
</li>
<li><p> Single-table HTML documents (.html), using <code><a href="xml2.html#topic+read_xml">xml2::read_html()</a></code>. There is no standard HTML table and we have only tested this with HTML tables exported with this package. HTML tables will only be read correctly if the HTML file can be converted to a list via <code><a href="xml2.html#topic+as_list">xml2::as_list()</a></code>. This import feature is not robust, especially for HTML tables in the wild. Please use a proper web scraping framework, e.g. <code>rvest</code>.
</p>
</li>
<li><p> Shallow XML documents (.xml), using <code><a href="xml2.html#topic+read_xml">xml2::read_xml()</a></code>. The data structure will only be read correctly if the XML file can be converted to a list via <code><a href="xml2.html#topic+as_list">xml2::as_list()</a></code>.
</p>
</li>
<li><p> YAML (.yml), using <code><a href="yaml.html#topic+yaml.load">yaml::yaml.load()</a></code>
</p>
</li>
<li><p> Clipboard import, using <code><a href="utils.html#topic+read.table">utils::read.table()</a></code> with <code>row.names = FALSE</code>
</p>
</li>
<li><p> Google Sheets, as Comma-separated data (.csv)
</p>
</li>
<li><p> GraphPad Prism (.pzfx) using <code><a href="pzfx.html#topic+read_pzfx">pzfx::read_pzfx()</a></code>
</p>
</li></ul>

<p><code>import</code> attempts to standardize the return value from the various import functions to the extent possible, thus providing a uniform data structure regardless of what import package or function is used. It achieves this by storing any optional variable-related attributes at the variable level (i.e., an attribute for <code>mtcars$mpg</code> is stored in <code>attributes(mtcars$mpg)</code> rather than <code>attributes(mtcars)</code>). If you would prefer these attributes to be stored at the data.frame-level (i.e., in <code>attributes(mtcars)</code>), see <code><a href="#topic+gather_attrs">gather_attrs()</a></code>.
</p>
<p>After importing metadata-rich file formats (e.g., from Stata or SPSS), it may be helpful to recode labelled variables to character or factor using <code><a href="#topic+characterize">characterize()</a></code> or <code><a href="#topic+factorize">factorize()</a></code> respectively.
</p>


<h3>Value</h3>

<p>A data frame. If <code>setclass</code> is used, this data frame may have additional class attribute values, such as &ldquo;tibble&rdquo; or &ldquo;data.table&rdquo;.
</p>


<h3>Trust</h3>

<p>For serialization formats (.R, .RDS, and .RData), please note that you should only load these files from trusted sources. It is because these formats are not necessarily for storing rectangular data and can also be used to store many things, e.g. code. Importing these files could lead to arbitary code execution. Please read the security principles by the R Project (Plummer, 2024). When importing these files via <code>rio</code>, you should affirm that you trust these files, i.e. <code>trust = TRUE</code>. See example below. If this affirmation is missing, the current version assumes <code>trust</code> to be true for backward compatibility and a deprecation notice will be printed. In the next major release (2.0.0), you must explicitly affirm your trust when importing these files.
</p>


<h3>Which</h3>

<p>For compressed archives (zip and tar, where a compressed file can contain multiple files), it is possible to come to a situation where the parameter <code>which</code> is used twice to indicate two different concepts. For example, it is unclear for <code>.xlsx.zip</code>whether <code>which</code> refers to the selection of an exact file in the archive or the selection of an exact sheet in the decompressed Excel file. In these cases, <code>rio</code> assumes that <code>which</code> is only used for the selection of file. After the selection of file with <code>which</code>, <code>rio</code> will return the first item, e.g. the first sheet.
</p>
<p>Please note, however, <code>.gz</code> and <code>.bz2</code> (e.g. <code>.xlsx.gz</code>) are compressed, but not archive format. In those cases, <code>which</code> is used the same way as the non-compressed format, e.g. selection of sheet for Excel.
</p>


<h3>Note</h3>

<p>For csv and txt files with row names exported from <code><a href="#topic+export">export()</a></code>, it may be helpful to specify <code>row.names</code> as the column of the table which contain row names. See example below.
</p>


<h3>References</h3>

<p>Plummer, M (2024). Statement on CVE-2024-27322. <a href="https://blog.r-project.org/2024/05/10/statement-on-cve-2024-27322/">https://blog.r-project.org/2024/05/10/statement-on-cve-2024-27322/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+import_list">import_list()</a></code>, <code><a href="#topic+characterize">characterize()</a></code>, <code><a href="#topic+gather_attrs">gather_attrs()</a></code>, <code><a href="#topic+export">export()</a></code>, <code><a href="#topic+convert">convert()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For demo, a temp. file path is created with the file extension .csv
csv_file &lt;- tempfile(fileext = ".csv")
## .xlsx
xlsx_file &lt;- tempfile(fileext = ".xlsx")
## create CSV to import
export(iris, csv_file)
## specify `format` to override default format: see export()
export(iris, xlsx_file, format = "csv")

## basic
import(csv_file)

## You can certainly import your data with the file name, which is not a variable:
## import("starwars.csv"); import("mtcars.xlsx")

## Override the default format
## import(xlsx_file) # Error, it is actually not an Excel file
import(xlsx_file, format = "csv")

## import CSV as a `data.table`
import(csv_file, setclass = "data.table")

## import CSV as a tibble (or "tbl_df")
import(csv_file, setclass = "tbl_df")

## pass arguments to underlying import function
## data.table::fread is the underlying import function and `nrows` is its argument
import(csv_file, nrows = 20)

## data.table::fread has an argument `data.table` to set the class explicitely to data.table. The
## argument setclass, however, takes precedents over such undocumented features.
class(import(csv_file, setclass = "tibble", data.table = TRUE))

## the default import class can be set with options(rio.import.class = "data.table")
## options(rio.import.class = "tibble"), or options(rio.import.class = "arrow")

## Security
rds_file &lt;- tempfile(fileext = ".rds")
export(iris, rds_file)

## You should only import serialized formats from trusted sources
## In this case, you can trust it because it's generated by you.
import(rds_file, trust = TRUE)
</code></pre>

<hr>
<h2 id='import_list'>Import list of data frames</h2><span id='topic+import_list'></span>

<h3>Description</h3>

<p>Use <code><a href="#topic+import">import()</a></code> to import a list of data frames from a vector of file names or from a multi-object file (Excel workbook, .Rdata file, compressed directory in a zip file or tar archive, or HTML file)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import_list(
  file,
  setclass = getOption("rio.import.class", "data.frame"),
  which,
  rbind = FALSE,
  rbind_label = "_file",
  rbind_fill = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="import_list_+3A_file">file</code></td>
<td>
<p>A character string containing a single file name for a multi-object file (e.g., Excel workbook, zip file, tar archive, or HTML file), or a vector of file paths for multiple files to be imported.</p>
</td></tr>
<tr><td><code id="import_list_+3A_setclass">setclass</code></td>
<td>
<p>An optional character vector specifying one or more classes
to set on the import. By default, the return object is always a
&ldquo;data.frame&rdquo;. Allowed values include &ldquo;tbl_df&rdquo;, &ldquo;tbl&rdquo;, or
&ldquo;tibble&rdquo; (if using tibble), &ldquo;arrow&rdquo;, &ldquo;arrow_table&rdquo; (if using arrow table; the suggested package <code>arrow</code> must be installed) or &ldquo;data.table&rdquo; (if using
data.table). Other values are ignored, such that a data.frame is returned.
The parameter takes precedents over parameters in ... which set a different class.</p>
</td></tr>
<tr><td><code id="import_list_+3A_which">which</code></td>
<td>
<p>If <code>file</code> is a single file path, this specifies which objects should be extracted (passed to <code><a href="#topic+import">import()</a></code>'s <code>which</code> argument). Ignored otherwise.</p>
</td></tr>
<tr><td><code id="import_list_+3A_rbind">rbind</code></td>
<td>
<p>A logical indicating whether to pass the import list of data frames through <code><a href="data.table.html#topic+rbindlist">data.table::rbindlist()</a></code>.</p>
</td></tr>
<tr><td><code id="import_list_+3A_rbind_label">rbind_label</code></td>
<td>
<p>If <code>rbind = TRUE</code>, a character string specifying the name of a column to add to the data frame indicating its source file.</p>
</td></tr>
<tr><td><code id="import_list_+3A_rbind_fill">rbind_fill</code></td>
<td>
<p>If <code>rbind = TRUE</code>, a logical indicating whether to set the <code>fill = TRUE</code> (and fill missing columns with <code>NA</code>).</p>
</td></tr>
<tr><td><code id="import_list_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="#topic+import">import()</a></code>. Behavior may be unexpected if files are of different formats.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When file is a vector of file paths and any files are missing, those files are ignored (with warnings) and this function will not raise any error. For compressed files, the file name must also contain information about the file format of all compressed files, e.g. <code>files.csv.zip</code> for this function to work.
</p>


<h3>Value</h3>

<p>If <code>rbind=FALSE</code> (the default), a list of a data frames. Otherwise, that list is passed to <code><a href="data.table.html#topic+rbindlist">data.table::rbindlist()</a></code> with <code>fill = TRUE</code> and returns a data frame object of class set by the <code>setclass</code> argument; if this operation fails, the list is returned.
</p>


<h3>Trust</h3>

<p>For serialization formats (.R, .RDS, and .RData), please note that you should only load these files from trusted sources. It is because these formats are not necessarily for storing rectangular data and can also be used to store many things, e.g. code. Importing these files could lead to arbitary code execution. Please read the security principles by the R Project (Plummer, 2024). When importing these files via <code>rio</code>, you should affirm that you trust these files, i.e. <code>trust = TRUE</code>. See example below. If this affirmation is missing, the current version assumes <code>trust</code> to be true for backward compatibility and a deprecation notice will be printed. In the next major release (2.0.0), you must explicitly affirm your trust when importing these files.
</p>


<h3>Which</h3>

<p>For compressed archives (zip and tar, where a compressed file can contain multiple files), it is possible to come to a situation where the parameter <code>which</code> is used twice to indicate two different concepts. For example, it is unclear for <code>.xlsx.zip</code>whether <code>which</code> refers to the selection of an exact file in the archive or the selection of an exact sheet in the decompressed Excel file. In these cases, <code>rio</code> assumes that <code>which</code> is only used for the selection of file. After the selection of file with <code>which</code>, <code>rio</code> will return the first item, e.g. the first sheet.
</p>
<p>Please note, however, <code>.gz</code> and <code>.bz2</code> (e.g. <code>.xlsx.gz</code>) are compressed, but not archive format. In those cases, <code>which</code> is used the same way as the non-compressed format, e.g. selection of sheet for Excel.
</p>


<h3>References</h3>

<p>Plummer, M (2024). Statement on CVE-2024-27322. <a href="https://blog.r-project.org/2024/05/10/statement-on-cve-2024-27322/">https://blog.r-project.org/2024/05/10/statement-on-cve-2024-27322/</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+import">import()</a></code>, <code><a href="#topic+export_list">export_list()</a></code>, <code><a href="#topic+export">export()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## For demo, a temp. file path is created with the file extension .xlsx
xlsx_file &lt;- tempfile(fileext = ".xlsx")
export(
    list(
        mtcars1 = mtcars[1:10, ],
        mtcars2 = mtcars[11:20, ],
        mtcars3 = mtcars[21:32, ]
    ),
    xlsx_file
)

# import a single file from multi-object workbook
import(xlsx_file, sheet = "mtcars1")
# import all worksheets, the return value is a list
import_list(xlsx_file)

# import and rbind all worksheets, the return value is a data frame
import_list(xlsx_file, rbind = TRUE)
</code></pre>

<hr>
<h2 id='install_formats'>Install rio's &lsquo;Suggests&rsquo; Dependencies</h2><span id='topic+install_formats'></span><span id='topic+show_unsupported_formats'></span>

<h3>Description</h3>

<p>Not all suggested packages are installed by default. These packages are not installed or loaded by default in order to create a slimmer and faster package build, install, and load. Use <code>show_unsupported_formats()</code> to check all unsupported formats. <code>install_formats()</code> installs all missing &lsquo;Suggests&rsquo; dependencies for rio that expand its support to the full range of support import and export formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>install_formats(...)

show_unsupported_formats()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="install_formats_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="utils.html#topic+install.packages">utils::install.packages()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>show_unsupported_formats()</code>, if there is any missing unsupported formats, it return TRUE invisibly; otherwise FALSE. For <code>install_formats()</code> it returns TRUE invisibly if the installation is succuessful; otherwise errors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
    install_formats()
}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
