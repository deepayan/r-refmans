<!DOCTYPE html><html><head><title>Help for package smoothSurv</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {smoothSurv}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#a2c'>
<p>Work Function for 'smoothSurvReg'</p></a></li>
<li><a href='#c2a'>
<p>Work Function for 'smoothSurvReg'</p></a></li>
<li><a href='#confint.smoothSurvReg'>
<p>Confidence Intervals for Regression Parameters of 'smoothSurvReg' Model</p></a></li>
<li><a href='#derivative.cc3'>
<p>Work Function for 'smoothSurvReg', currently nowhere used</p></a></li>
<li><a href='#derivative.expAD'>
<p>Work Function for 'smoothSurvReg', currently nowhere used</p></a></li>
<li><a href='#estimTdiff'>
<p>Estimate expectation of survival times and their difference from the</p>
results given by survival regression function</a></li>
<li><a href='#eval.Gspline'>
<p>Evaluate a G-spline in a grid of values</p></a></li>
<li><a href='#extreme value'>
<p>Density of the Extreme Value Distribution of a Minimum.</p></a></li>
<li><a href='#fdensity.smoothSurvReg'>
<p>Density for Objects of Class 'smoothSurvReg'</p></a></li>
<li><a href='#find.c'>
<p>Work Function for 'smoothSurvReg'</p></a></li>
<li><a href='#give.c'>
<p>Work Function for 'smoothSurvReg'</p></a></li>
<li><a href='#hazard.smoothSurvReg'>
<p>Hazard Curves for Objects of Class 'smoothSurvReg'</p></a></li>
<li><a href='#minPenalty'>
<p>Minimize the penalty term under the two (mean and variance)</p>
constraints</a></li>
<li><a href='#MP.pseudoinv'>
<p>Work Function for 'smoothSurvReg', currently nowhere used.</p></a></li>
<li><a href='#piece'>
<p>Left Continuous Piecewise Constant Function with a Finite Support.</p></a></li>
<li><a href='#plot.smoothSurvReg'>
<p>Plot Objects of Class 'smoothSurvReg'</p></a></li>
<li><a href='#print.estimTdiff'>
<p>Print for Objects of Class 'estimTdiff'</p></a></li>
<li><a href='#print.smoothSurvReg'>
<p>Summary and Print for Objects of Class 'smoothSurvReg'</p></a></li>
<li><a href='#residuals.smoothSurvReg'>
<p>Residuals for Objects of Class 'smoothSurvReg'</p></a></li>
<li><a href='#smoothSurvReg'>
<p>Regression for a Survival Model with Smoothed Error Distribution</p></a></li>
<li><a href='#smoothSurvReg.control'>
<p>More Options for 'smoothSurvReg'</p></a></li>
<li><a href='#smoothSurvReg.fit'>
<p>Work Function to Fit the Model Using 'smoothSurvReg'</p></a></li>
<li><a href='#smoothSurvReg.object'>
<p>Smoothed Survival Regression Object</p></a></li>
<li><a href='#standardized logistic'>
<p>Density of Standardized Logistic Distribution.</p></a></li>
<li><a href='#std.data'>
<p>Standardization of the Data</p></a></li>
<li><a href='#survfit.smoothSurvReg'>
<p>Survivor Curves for Objects of Class 'smoothSurvReg'</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-13</td>
</tr>
<tr>
<td>Title:</td>
<td>Survival Regression with Smoothed Error Distribution</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0), survival</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains, as a main contribution, a function to fit
             a regression model with possibly right, left or interval
             censored observations and with the error distribution
             expressed as a mixture of G-splines. Core part
             of the computation is done in compiled 'C++' written
             using the 'Scythe' Statistical Library Version 0.3.</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://msekce.karlin.mff.cuni.cz/~komarek/">https://msekce.karlin.mff.cuni.cz/~komarek/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-13 14:10:54 UTC; komarek</td>
</tr>
<tr>
<td>Author:</td>
<td>Arnošt Komárek <a href="https://orcid.org/0000-0001-8778-3762"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Kevin M. Quinn [ctb, cph] (Scythe_*.[h,cpp] files in the /src
    subdirectory),
  Andrew D. Martin [ctb, cph] (Scythe_*.[h,cpp] files in the /src
    subdirectory),
  Daniel B. Pemstein [ctb, cph] (Scythe_*.[h,cpp] files in the /src
    subdirectory),
  Berwin A. Turlach [ctb] (Basis of the code in
    /src/solve.QP.compact.cpp)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arnošt Komárek &lt;arnost.komarek@mff.cuni.cz&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-13 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='a2c'>
Work Function for 'smoothSurvReg'
</h2><span id='topic+a2c'></span>

<h3>Description</h3>

<p>Compute the 'c' G-spline coefficients from 'a' G-spline coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a2c(acoef)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a2c_+3A_acoef">acoef</code></td>
<td>

<p>A vector of 'a' G-spline coefficients.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'c' and 'a' G-spline coefficients are related by the expression
</p>
<p style="text-align: center;"><code class="reqn">c_j = \frac{\exp(a_j)}{\sum_{l=1}^{g}\exp(a_l)}, j = 1,\dots, g,</code>
</p>

<p>where <code class="reqn">a_k = 0,</code> k = <code>which.zero</code>.
This function transforms the 'c' coefficients into their 'a' counterparts.
</p>


<h3>Value</h3>

<p>A vector of same length as <code>acoef</code> with 'c' G-spline coefficients.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+c2a">c2a</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ccoef &lt;- c(0.1, 0.2, 0.15, 0.3, 0.25)

### Compute 'a' counterparts
acoef &lt;- c2a(ccoef, 1)
print(acoef)

### And back 'c', ccoef2 should be same as ccoef
ccoef2 &lt;- a2c(acoef)
print(ccoef2)
</code></pre>

<hr>
<h2 id='c2a'>
Work Function for 'smoothSurvReg'
</h2><span id='topic+c2a'></span>

<h3>Description</h3>

<p>Compute the 'a' G-spline coefficients from 'c' G-spline coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c2a(ccoef, which.zero = which.max(ccoef), toler = 1e-6)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c2a_+3A_ccoef">ccoef</code></td>
<td>

<p>A vector of 'c' G-spline coefficients.
</p>
</td></tr>
<tr><td><code id="c2a_+3A_which.zero">which.zero</code></td>
<td>

<p>An index of the 'a' G-spline coefficient which will be zero (the reference one).
</p>
</td></tr>
<tr><td><code id="c2a_+3A_toler">toler</code></td>
<td>

<p>All 'c' coefficients smaller in absolute value than <code>toler</code>
are changed into <code>toler</code> (to avoid <code>log(0)</code>).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'c' and 'a' G-spline coefficients are related by the expression
</p>
<p style="text-align: center;"><code class="reqn">c_j = \frac{\exp(a_j)}{\sum_{l=1}^{g}\exp(a_l)}, j = 1,\dots, g,</code>
</p>

<p>where <code class="reqn">a_k = 0,</code> k = <code>which.zero</code>.
This function transforms the 'c' coefficients into their 'a' counterparts.
</p>


<h3>Value</h3>

<p>A vector of same length as <code>ccoef</code> with 'a' G-spline coefficients.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+a2c">a2c</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>ccoef &lt;- c(0.1, 0.2, 0.15, 0.3, 0.25)

### Compute 'a' counterparts
acoef &lt;- c2a(ccoef, 1)
print(acoef)

### And back 'c', ccoef2 should be same as ccoef
ccoef2 &lt;- a2c(acoef)
print(ccoef2)
</code></pre>

<hr>
<h2 id='confint.smoothSurvReg'>
Confidence Intervals for Regression Parameters of 'smoothSurvReg' Model
</h2><span id='topic+confint.smoothSurvReg'></span>

<h3>Description</h3>

<p>Computes confidence intervals for one or more regression related
parameters (regression coefficients, scale parameter or regression
coefficients in a model for scale) for a 'smoothSurvReg' model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smoothSurvReg'
confint(object, parm, level = 0.95,
    method = c("pseudo-variance", "asymptotic"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.smoothSurvReg_+3A_object">object</code></td>
<td>

<p>Object of class smoothSurvReg.
</p>
</td></tr>
<tr><td><code id="confint.smoothSurvReg_+3A_parm">parm</code></td>
<td>
<p>A specification of which parameters are to be given
confidence intervals, either a vector of numbers or a vector of
names. If missing, all parameters are considered.
</p>
</td></tr>
<tr><td><code id="confint.smoothSurvReg_+3A_level">level</code></td>
<td>
<p>The confidence level required.
</p>
</td></tr>  
<tr><td><code id="confint.smoothSurvReg_+3A_method">method</code></td>
<td>
<p>Type of confidence intervals to b calculated. Option
&ldquo;pseudo-variance&rdquo; provides confidence intervals derived from
inverted minus second derivatives of the penalized log-likelihood
(pseudo-variance matrix), option &ldquo;asymptotic&rdquo; provides
confidence intervals derived from the asyptotic covariance matrix
of the parameter estimates.
</p>
</td></tr>  
<tr><td><code id="confint.smoothSurvReg_+3A_...">...</code></td>
<td>

<p>Argument included in the function parameters for the compatibility 
with the generic function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (or vector) with columns giving lower and upper confidence
limits for each parameter. These will be labelled as (1 - level)/2
and 1 - (1 - level)/2 in % (by default 2.5 % and 97.5 %).
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smoothSurvReg">smoothSurvReg</a></code>
</p>

<hr>
<h2 id='derivative.cc3'>
Work Function for 'smoothSurvReg', currently nowhere used
</h2><span id='topic+derivative.cc3'></span>

<h3>Description</h3>

<p>Function to compute derivatives of all 'c' G-spline coefficients
with respect to chosen (g - 3) coefficients such that
the whole vector of g 'c' coefficients satisfies the constraints.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivative.cc3(knots, sdspline, last.three, all = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivative.cc3_+3A_knots">knots</code></td>
<td>

<p>A vector of G-spline knots <code class="reqn">\mu</code>.
</p>
</td></tr>
<tr><td><code id="derivative.cc3_+3A_sdspline">sdspline</code></td>
<td>

<p>Standard deviation <code class="reqn">sigma_0</code> of the basis G-spline .
</p>
</td></tr>
<tr><td><code id="derivative.cc3_+3A_last.three">last.three</code></td>
<td>

<p>Indeces of the three 'c' G-spline coefficients which are
expressed as a function of the remaining (g - 3)
'c' G-spline coefficients such that the three constraints
are satisfied.
This must be a vector of length 3 with three different numbers from
<code>1:length(knots)</code>.
</p>
</td></tr>
<tr><td><code id="derivative.cc3_+3A_all">all</code></td>
<td>

<p>If <code>TRUE</code>, matrix (g - 2) x g (there is one zero column) is returned.
If <code>FALSE</code>, matrix (g - 2) x 3 is returned.
The first row is always an intercept.
See details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To satisfy the three constraints
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^g c_j = 1,</code>
</p>

<p style="text-align: center;"><code class="reqn">\sum_{j=1}^g c_j \mu_j = 0,</code>
</p>

<p style="text-align: center;"><code class="reqn">\sum_{j=1}^g c_j \mu_j^2 = 1 - \sigma_0^2</code>
</p>

<p>imposed on the G-spline we can express the three 'c' coefficients as a function of
the remaining <code class="reqn">g - 3</code> 'c' coefficients in the following way.
</p>
<p style="text-align: center;"><code class="reqn">c_{k} = \omega_{0,k} + \sum_{j\neq last.three}\omega_{j,k} c_j, %
         \qquad k \in last.three,</code>
</p>

<p>where <code class="reqn">\omega</code> coefficients are a function of knots and G-spline
standard deviation.
If we denote <code class="reqn">d</code> the vector <code>c[-last.three]</code> this function computes
derivatives of <code class="reqn">c</code> w.r.t. <code class="reqn">d</code> together
with the intercept term used to compute <code class="reqn">c</code> from
<code class="reqn">d</code>. This is actually a matrix of <code class="reqn">\omega</code>
coefficients. If we denote it as <code class="reqn">\Omega</code> then
if <code>all == TRUE</code>
</p>
<p style="text-align: center;"><code class="reqn">c = \Omega_{1,\cdot}^T +  \Omega_{-1,\cdot}^T d</code>
</p>

<p>and if <code>all == FALSE</code>
</p>
<p style="text-align: center;"><code class="reqn">c[last.three] = \Omega_{1,\cdot}^T +  \Omega_{-1,\cdot}^T d.</code>
</p>



<h3>Value</h3>

<p>A matrix with <code class="reqn">\omega</code> coefficients.
</p>


<h3>Note</h3>

<p>WARNING: This function was primarily used inside <code><a href="#topic+smoothSurvReg">smoothSurvReg</a></code>.
Consequently, it has very few error checks on its input arguments.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='derivative.expAD'>
Work Function for 'smoothSurvReg', currently nowhere used
</h2><span id='topic+derivative.expAD'></span>

<h3>Description</h3>

<p>Function to compute derivatives of exp(a) w.r.t. exp(d)
where d stands for a shorter vector of 'a' G-spline coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivative.expAD(knots, sdspline, last.three, all = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivative.expAD_+3A_knots">knots</code></td>
<td>

<p>A vector of G-spline knots <code class="reqn">\mu</code>.
</p>
</td></tr>
<tr><td><code id="derivative.expAD_+3A_sdspline">sdspline</code></td>
<td>

<p>Standard deviation <code class="reqn">\sigma_0</code> of the basis G-spline.
</p>
</td></tr>
<tr><td><code id="derivative.expAD_+3A_last.three">last.three</code></td>
<td>

<p>Indeces of the three 'a' G-spline coefficients which are
expressed as a function of the remaining (g-3)
'a' G-spline coefficients such that the three constraints
are satisfied.
This must be a vector of length 3 with three different numbers from
<code>1:length(mu)</code>.
Consequently, <code>a[last.three[1]] &lt;- 0</code>.
</p>
</td></tr>
<tr><td><code id="derivative.expAD_+3A_all">all</code></td>
<td>

<p>If <code>TRUE</code>, matrix (g - 2) x g (there is one zero column) is returned.
If <code>FALSE</code>, matrix (g - 2) x 2 is returned.
The first row is always an intercept.
See details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To satisfy the three constraints
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^g c_j = 1,</code>
</p>

<p style="text-align: center;"><code class="reqn">\sum_{j=1}^g c_j \mu_j = 0,</code>
</p>

<p style="text-align: center;"><code class="reqn">\sum_{j=1}^g c_j \mu_j^2 = 1 - \sigma_0^2</code>
</p>

<p>imposed on the G-spline we use the following parametrization:
</p>
<p style="text-align: center;"><code class="reqn">c_j = \frac{\exp(a_j)}{\sum_{l=1}^{g}\exp(a_l)}, j = 1,\dots, g.</code>
</p>

<p>The constraints can be solved such that <code>a[last.three[1]] = 0</code> and
<code>a[last.three[2:3]]</code> are expressed as a function of
<code>a[-last.three]</code> in the following way:
</p>
<p style="text-align: center;"><code class="reqn">a_{k} = \log\Bigl\{\omega_{0,k} + \sum_{j\neq last.three}\omega_{j,k}\exp(a_j)\Bigr\},%
         \qquad k = last.three[2], last.three[3],</code>
</p>

<p>where <code class="reqn">\omega</code> coefficients are a function of knots and G-spline
standard deviation.
If we denote <code class="reqn">d</code> the vector <code>a[-last.three]</code> this function computes
derivatives of <code class="reqn">\exp(a)</code> w.r.t. <code class="reqn">\exp(d)</code> together
with the intercept term used to compute <code class="reqn">\exp(a)</code> from
<code class="reqn">\exp(d)</code>. This is actually a matrix of <code class="reqn">\omega</code>
coefficients. If we denote it as <code class="reqn">\Omega</code> then
if <code>all == TRUE</code>
</p>
<p style="text-align: center;"><code class="reqn">\exp(a) = \Omega_{1,\cdot}^T +  \Omega_{-1,\cdot}^T\exp(d)</code>
</p>

<p>and if <code>all == FALSE</code>
</p>
<p style="text-align: center;"><code class="reqn">\exp(a[last.three[2:3]]) = \Omega_{1,\cdot}^T +  \Omega_{-1,\cdot}^T\exp(d).</code>
</p>



<h3>Value</h3>

<p>A matrix with <code class="reqn">\omega</code> coefficients.
</p>


<h3>Note</h3>

<p>WARNING: This function is primarily used inside <code><a href="#topic+smoothSurvReg">smoothSurvReg</a></code>.
Consequently, it has very few error checks on its input arguments.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='estimTdiff'>
Estimate expectation of survival times and their difference from the
results given by survival regression function
</h2><span id='topic+estimTdiff'></span><span id='topic+estimTdiff.smoothSurvReg'></span>

<h3>Description</h3>

<p>Estimate expectation of survival times and their difference from the
results given by survival regression function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimTdiff(x, ...)
## S3 method for class 'smoothSurvReg'
estimTdiff(x, cov1, cov2, logscale.cov1, logscale.cov2,
    time0 = 0, conf.level=0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimTdiff_+3A_x">x</code></td>
<td>

<p>Object of an appropriate class.
</p>
</td></tr>
<tr><td><code id="estimTdiff_+3A_cov1">cov1</code></td>
<td>

<p>Vector or matrix with covariates values for which the expectations
of the first survival time are to be computed. It must be a matrix with as many 
columns as is the number of covariates (interactions included, intercept excluded) 
or the vector of length
equal to the number of covariates (interactions included,
intercept excluded). If matrix is supplied then is assumed that
each row of this matrix gives one covariate combination for the
first survival time.
Intercept is not to be included in <code>cov1</code>. If <code>cov1</code> is missing an
expectation of a survivor time
for the value of a covariate vector equal to zero is computed. If there is
only intercept in the model, this parameter must be always missing.
</p>
</td></tr>
<tr><td><code id="estimTdiff_+3A_cov2">cov2</code></td>
<td>

<p>Vector or matrix with covariate values for which the expectations
of the second survival time are to be computed. It must be of same
size as <code>cov1</code>.
</p>
</td></tr>          
<tr><td><code id="estimTdiff_+3A_logscale.cov1">logscale.cov1</code></td>
<td>

<p>Vector or matrix with covariate values for the expression of log-scale
(if this depended on covariates) for the first survival time. 
It can be omitted in the case that log-scale was common for all observations. 
</p>
</td></tr> 
<tr><td><code id="estimTdiff_+3A_logscale.cov2">logscale.cov2</code></td>
<td>

<p>Vector or matrix with covariate values for the expression of log-scale
(if this depended on covariates) for the second survival time. 
It can be omitted in the case that log-scale was common for all observations. 
</p>
</td></tr>
<tr><td><code id="estimTdiff_+3A_time0">time0</code></td>
<td>

<p>Starting time of the follow-up as used in the model. I.e. the
model is assumed to be <code class="reqn">\log(T-time0) = x'\beta + 
	\sigma\varepsilon</code> 
</p>
</td></tr>
<tr><td><code id="estimTdiff_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of produced confidence intervals.</p>
</td></tr>
<tr><td><code id="estimTdiff_+3A_...">...</code></td>
<td>
<p>who knows
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns named &ldquo;ET1&rdquo;, &ldquo;sd.ET1&rdquo;,
&ldquo;ET1.lower&rdquo;, &ldquo;ET1.upper&rdquo;, 
'ET2&rdquo;, &ldquo;sd.ET2&rdquo;, &ldquo;ET2.lower&rdquo;, &ldquo;ET2.upper&rdquo;, 
&ldquo;diffT&rdquo;, &ldquo;sd.diffT&rdquo;, &ldquo;diffT.lower&rdquo;, &ldquo;diffT.upper&rdquo;
giving the estimates of expected
values of the survival times for covariate values given in rows of
<code>cov1</code> and <code>logscale.cov1</code>, 
their standard errors, estimates of expected values of
survival times for covariate values given in rows of <code>cov2</code> 
and <code>logscale.cov2</code>,
their standard errors and estimates of a difference of expected
values of survival times for covariate values given in rows of
<code>cov1</code>, <code>logscale.cov1</code> and <code>cov2</code>, <code>logscale.cov2</code>,
their standard errors and confidence intervals.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smoothSurvReg">smoothSurvReg</a></code>
</p>

<hr>
<h2 id='eval.Gspline'>
Evaluate a G-spline in a grid of values
</h2><span id='topic+eval.Gspline'></span>

<h3>Description</h3>

<p>This function computes values of
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \sum_{j=1}^g c_j \varphi_{\mu_j, \sigma_j^2}(x)</code>
</p>

<p>in a grid of <code class="reqn">x</code> values.
</p>
<p>In above expression, <code class="reqn">\varphi_{\mu_j, \sigma_j^2}(x)</code>  
denotes a density of <code class="reqn">N(\mu_j, \sigma_j^2)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  eval.Gspline(Gspline, grid)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eval.Gspline_+3A_gspline">Gspline</code></td>
<td>
<p>A data frame with at least three columns named
&ldquo;Knot&rdquo;, &ldquo;SD basis&rdquo; and &ldquo;c coef.&rdquo; which determine
<code class="reqn">\mu_1, \dots,\mu_g</code>,
<code class="reqn">\sigma_1, \dots, \sigma_g</code> and
<code class="reqn">c_1,\dots, c_g</code>. Data.frame with such
properties can be found e.g. as <code>spline</code> component of the
resulting object returned by functions <code><a href="#topic+smoothSurvReg">smoothSurvReg</a></code>
and <code><a href="#topic+minPenalty">minPenalty</a></code>.    
</p>
</td></tr>
<tr><td><code id="eval.Gspline_+3A_grid">grid</code></td>
<td>
<p>A numeric vector giving the grid of <code class="reqn">x</code> values at
which the G-spline is to be evaluated.
</p>
</td></tr>      
</table>


<h3>Value</h3>

<p>A data.frame with columns named &ldquo;x&rdquo; (grid)  and &ldquo;y&rdquo; (G-spline
values).
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  spline &lt;- minPenalty(knots=seq(-4.2, 4.2, by=0.3), sdspline=0.2, difforder=3)$spline
  values &lt;- eval.Gspline(spline, seq(-4.5, 4.5, by=0.05))
  plot(values, type="l", bty="n", lwd=3)
</code></pre>

<hr>
<h2 id='extreme+20value'>
Density of the Extreme Value Distribution of a Minimum.
</h2><span id='topic+dextreme'></span><span id='topic+dstextreme'></span>

<h3>Description</h3>

<p>Density function of the extreme value distribution of a minimum
with location <code class="reqn">\alpha</code> and scale <code class="reqn">\beta</code>
and the density of the standardized version (with zero mean and unit variance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dextreme(x, alpha=0, beta=1)
dstextreme(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extreme+2B20value_+3A_x">x</code></td>
<td>

<p>Vector of quantiles.
</p>
</td></tr>
<tr><td><code id="extreme+2B20value_+3A_alpha">alpha</code></td>
<td>

<p>Vector of location parameters.
</p>
</td></tr>
<tr><td><code id="extreme+2B20value_+3A_beta">beta</code></td>
<td>

<p>Vector of scale parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extreme value distribution of a minimum with the location <code class="reqn">\alpha</code>
and the scale <code class="reqn">\beta</code> has a density
</p>
<p style="text-align: center;"><code class="reqn">f(x) = \frac{1}{\beta}\exp\left[\frac{x-\alpha}{\beta}-\exp\left(\frac{x-\alpha}{\beta}\right)\right]</code>
</p>

<p>the mean equal to <code class="reqn">\alpha - \beta\;e</code>, where <code class="reqn">e</code> is approximately
<code class="reqn">0.5772</code> and the variance equal to <code class="reqn">\beta^2\frac{\pi}{6}</code>.
Its standardized version is obtained with <code class="reqn">\alpha = \frac{\sqrt{6}}{\pi}\;e</code> 
and <code class="reqn">\beta = \frac{\sqrt{6}}{\pi}</code>
</p>


<h3>Value</h3>

<p>The value of the density.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dextreme(1, (sqrt(6)/pi)*0.5772, sqrt(6)/pi)
dstextreme(1)        ## approximately same result as on the previous row
</code></pre>

<hr>
<h2 id='fdensity.smoothSurvReg'>
Density for Objects of Class 'smoothSurvReg'
</h2><span id='topic+fdensity.smoothSurvReg'></span><span id='topic+fdensity'></span>

<h3>Description</h3>

<p>Compute and plot density function for given combinations
of covariates based on the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smoothSurvReg'
fdensity(x, cov, logscale.cov, time0 = 0, plot = TRUE,
    by, xlim, ylim, xlab = "t", ylab = "f(t)", 
    type = "l", lty, main, sub, legend, bty = "n", cex.legend = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdensity.smoothSurvReg_+3A_x">x</code></td>
<td>

<p>Object of class smoothSurvReg.
</p>
</td></tr>
<tr><td><code id="fdensity.smoothSurvReg_+3A_cov">cov</code></td>
<td>

<p>Vector or matrix with covariates values for which the survivor curve/cdf
is to be computed and plotted. It must be a matrix with as many columns as
is the number of covariates (interactions included) or the vector of length
equal to the number of covariates (interactions included). Intercept is not
to be included in <code>cov</code>. If <code>cov</code> is missing a survivor curve
for the value of a covariate vector equal to zero is plotted. If there is
only intercept in the model the survivor curve based on the fitted error
distribution is always plotted.
</p>
</td></tr>
<tr><td><code id="fdensity.smoothSurvReg_+3A_logscale.cov">logscale.cov</code></td>
<td>

<p>Vector or matrix with covariate values for the expression of log-scale
(if this depended on covariates).
It can be omitted in the case that log-scale was common for all observations. 
</p>
</td></tr>     
<tr><td><code id="fdensity.smoothSurvReg_+3A_time0">time0</code></td>
<td>

<p>Starting time of the follow-up as used in the model. I.e. the
model is assumed to be <code class="reqn">\log(T-time0) = x'\beta + 
	\sigma\varepsilon</code> 
</p>
</td></tr> 
<tr><td><code id="fdensity.smoothSurvReg_+3A_plot">plot</code></td>
<td>

<p>If <code>TRUE</code> the plot is directly produced, otherwise only a <code>data.frame</code>
with information used for later plotting is returned.
</p>
</td></tr>
<tr><td><code id="fdensity.smoothSurvReg_+3A_by">by</code></td>
<td>

<p>Step for a ploting grid. If <code>missing</code> it is automatically computed.
</p>
</td></tr>
<tr><td><code id="fdensity.smoothSurvReg_+3A_xlim">xlim</code>, <code id="fdensity.smoothSurvReg_+3A_ylim">ylim</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="fdensity.smoothSurvReg_+3A_xlab">xlab</code>, <code id="fdensity.smoothSurvReg_+3A_ylab">ylab</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="fdensity.smoothSurvReg_+3A_type">type</code>, <code id="fdensity.smoothSurvReg_+3A_lty">lty</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="fdensity.smoothSurvReg_+3A_main">main</code>, <code id="fdensity.smoothSurvReg_+3A_sub">sub</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="fdensity.smoothSurvReg_+3A_legend">legend</code>, <code id="fdensity.smoothSurvReg_+3A_bty">bty</code></td>
<td>

<p>Argument passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="fdensity.smoothSurvReg_+3A_cex.legend">cex.legend</code></td>
<td>
<p>argument passed to <code>cex</code> argument of the
<code><a href="graphics.html#topic+legend">legend</a></code> function.</p>
</td></tr>
<tr><td><code id="fdensity.smoothSurvReg_+3A_...">...</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with columns named <code>x</code> and <code>y</code> where <code>x</code> gives the grid
and <code>y</code> the values of the density function at that grid.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smoothSurvReg">smoothSurvReg</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>
</p>

<hr>
<h2 id='find.c'>
Work Function for 'smoothSurvReg'
</h2><span id='topic+find.c'></span>

<h3>Description</h3>

<p>Find mixture proportions that approximate
given distribution by a G-spline mixture.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find.c(knots, sdspline, dist = "dnorm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.c_+3A_knots">knots</code></td>
<td>

<p>A vector of G-spline knots <code class="reqn">\mu</code>.
</p>
</td></tr>
<tr><td><code id="find.c_+3A_sdspline">sdspline</code></td>
<td>

<p>Standard deviation <code class="reqn">\sigma_0</code> of the basis G-spline.
</p>
</td></tr>
<tr><td><code id="find.c_+3A_dist">dist</code></td>
<td>

<p>A character string specifying the function used to compute
a density of the distribution
you want to approximate.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function finds the G-spline coefficients that approximates
a density given by <code>dist</code> in such sense that the value
of the G-spline is exactly equal to the value of that density
in <code>knots</code>.
</p>


<h3>Value</h3>

<p>Either the vector of G-spline 'c' coefficients or <code>NULL</code>
if there are problems to find them.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>knots &lt;- seq(-4, 4, 0.5)
sd0 &lt;- 0.3
ccoef &lt;- find.c(knots, sd0, dist = "dstlogis")

### We plot the approximation together with the truth
###
grid &lt;- seq(-4, 4, 0.05)
truth &lt;- dstlogis(grid)

### Following lines compute the values of the approximation
grid.big &lt;- matrix(grid, nrow = length(grid), ncol = length(knots))
knots.big &lt;- matrix(knots, nrow = length(grid), ncol = length(knots), byrow = TRUE)
normals &lt;- dnorm(grid.big, mean = knots.big, sd = sd0)
approx &lt;- normals %*% ccoef

### Plot it
plot(grid, approx, type = "l", xlab = "y", ylab = "f(y)", bty = "n")
lines(grid, truth, lty = 2)
legend(-4, 0.35, c("approx", "truth"), lty = 1:2, bty = "n")
</code></pre>

<hr>
<h2 id='give.c'>
Work Function for 'smoothSurvReg'
</h2><span id='topic+give.c'></span>

<h3>Description</h3>

<p>Give a vector of all 'c' G-spline coefficients 
satisfying the three constrains (see below)
if only (g-3) c's are given.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>give.c(knots, sdspline, last.three, c.rest)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="give.c_+3A_knots">knots</code></td>
<td>

<p>A vector of G-spline knots <code class="reqn">\mu</code>.
</p>
</td></tr>
<tr><td><code id="give.c_+3A_sdspline">sdspline</code></td>
<td>

<p>Standard deviation <code class="reqn">\sigma_0</code> of the basis G-spline.
</p>
</td></tr>
<tr><td><code id="give.c_+3A_last.three">last.three</code></td>
<td>

<p>Indeces of the three 'c' G-spline coefficients which are 
not included in <code>c.rest</code>. This must be a vector
of length 3 with three different numbers from
<code>1:length(knots)</code>.
</p>
</td></tr>
<tr><td><code id="give.c_+3A_c.rest">c.rest</code></td>
<td>

<p>A vector of <code>length(knots) - 3</code> 'c' spline coefficients
corresponding to knots <code>knots[-last.three]</code>. 
They must all lie between zero and one and their sum must be lower 
or equal to one.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions computes remaining three 'c' G-spline coefficients
(if it is possible) such that the resulting G-spline satisfies
the following:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^g c_j = 1,</code>
</p>

<p style="text-align: center;"><code class="reqn">\sum_{j=1}^g c_j \mu_j = 0,</code>
</p>

<p style="text-align: center;"><code class="reqn">\sum_{j=1}^g c_j \mu_j^2 = 1 - \sigma_0^2.</code>
</p>



<h3>Value</h3>

<p>A vector of all <code>length(knots)</code> 'c' G-spline coefficients.
</p>


<h3>Note</h3>

<p>WARNING: This function is primarily used inside <code><a href="#topic+smoothSurvReg">smoothSurvReg</a></code>.
Consequently, it has very few error checks on its input arguments.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>knots &lt;- seq(-4, 4, 0.5)
sd0 &lt;- 0.3
ccoef &lt;- find.c(knots, sd0, dist = "dstlogis")

last.three &lt;- c(3, 7, 10)
c.rest &lt;- ccoef[-last.three]
ccoef2 &lt;- give.c(knots, sd0, last.three, c.rest)

print(ccoef)
print(ccoef2)    ## Almost no change
</code></pre>

<hr>
<h2 id='hazard.smoothSurvReg'>
Hazard Curves for Objects of Class 'smoothSurvReg'
</h2><span id='topic+hazard.smoothSurvReg'></span><span id='topic+hazard'></span>

<h3>Description</h3>

<p>Compute and plot hazard function for given combinations
of covariates based on the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smoothSurvReg'
hazard(x, cov, logscale.cov, time0 = 0, plot = TRUE,
    by, xlim, ylim, xlab = "t", ylab = "h(t)", 
    type = "l", lty, main, sub, legend, bty = "n", cex.legend = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hazard.smoothSurvReg_+3A_x">x</code></td>
<td>

<p>Object of class smoothSurvReg.
</p>
</td></tr>
<tr><td><code id="hazard.smoothSurvReg_+3A_cov">cov</code></td>
<td>

<p>Vector or matrix with covariates values for which the survivor curve/cdf
is to be computed and plotted. It must be a matrix with as many columns as
is the number of covariates (interactions included) or the vector of length
equal to the number of covariates (interactions included). Intercept is not
to be included in <code>cov</code>. If <code>cov</code> is missing a survivor curve
for the value of a covariate vector equal to zero is plotted. If there is
only intercept in the model the survivor curve based on the fitted error
distribution is always plotted.
</p>
</td></tr>
<tr><td><code id="hazard.smoothSurvReg_+3A_logscale.cov">logscale.cov</code></td>
<td>

<p>Vector or matrix with covariate values for the expression of log-scale
(if this depended on covariates).
It can be omitted in the case that log-scale was common for all observations. 
</p>
</td></tr>     
<tr><td><code id="hazard.smoothSurvReg_+3A_time0">time0</code></td>
<td>

<p>Starting time of the follow-up as used in the model. I.e. the
model is assumed to be <code class="reqn">\log(T-time0) = x'\beta + 
	\sigma\varepsilon</code> 
</p>
</td></tr> 
<tr><td><code id="hazard.smoothSurvReg_+3A_plot">plot</code></td>
<td>

<p>If <code>TRUE</code> the plot is directly produced, otherwise only a <code>data.frame</code>
with information used for later plotting is returned.
</p>
</td></tr>
<tr><td><code id="hazard.smoothSurvReg_+3A_by">by</code></td>
<td>

<p>Step for a ploting grid. If <code>missing</code> it is automatically computed.
</p>
</td></tr>
<tr><td><code id="hazard.smoothSurvReg_+3A_xlim">xlim</code>, <code id="hazard.smoothSurvReg_+3A_ylim">ylim</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="hazard.smoothSurvReg_+3A_xlab">xlab</code>, <code id="hazard.smoothSurvReg_+3A_ylab">ylab</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="hazard.smoothSurvReg_+3A_type">type</code>, <code id="hazard.smoothSurvReg_+3A_lty">lty</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="hazard.smoothSurvReg_+3A_main">main</code>, <code id="hazard.smoothSurvReg_+3A_sub">sub</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="hazard.smoothSurvReg_+3A_legend">legend</code>, <code id="hazard.smoothSurvReg_+3A_bty">bty</code></td>
<td>

<p>Argument passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="hazard.smoothSurvReg_+3A_cex.legend">cex.legend</code></td>
<td>
<p>argument passed to <code>cex</code> argument of the
<code><a href="graphics.html#topic+legend">legend</a></code> function.
</p>
</td></tr>    
<tr><td><code id="hazard.smoothSurvReg_+3A_...">...</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with columns named <code>x</code> and <code>y</code> where <code>x</code> gives the grid
and <code>y</code> the values of the hazard function at that grid.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smoothSurvReg">smoothSurvReg</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>
</p>

<hr>
<h2 id='minPenalty'>
Minimize the penalty term under the two (mean and variance)
constraints
</h2><span id='topic+minPenalty'></span>

<h3>Description</h3>

<p>This function minimizes </p>
<p style="text-align: center;"><code class="reqn">\frac{1}{2}\sum_{j=m+1}^g \Bigl(\Delta^m a_j\Bigr)^2</code>
</p>
<p> with respect to <code class="reqn">a_1,\dots, a_g</code>
under the constraints
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^g c_j \mu_j = 0</code>
</p>
<p> and
</p>
<p style="text-align: center;"><code class="reqn">\sum_{j=1}^g c_j (\mu_j^2 + \sigma_0^2) = 1,</code>
</p>

<p>where 
</p>
<p style="text-align: center;"><code class="reqn">c_j = \frac{\exp(a_j)}{\sum_{l=1}^g}\exp(a_l)</code>
</p>

<p>with one of <code class="reqn">a</code>'s fixed to zero.
</p>
<p>Note that the minimum is always zero. We are thus mainly interested in
the point where the minimum is reached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minPenalty(knots = NULL, dist.range = c(-6, 6), by.knots = 0.3, sdspline = NULL,
    difforder = 3, init.c,
    maxiter = 200, rel.tolerance = 1e-10, toler.chol = 1e-15, toler.eigen = 1e-3,
    maxhalf = 10, debug = 0, info = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minPenalty_+3A_knots">knots</code></td>
<td>

<p>A vector of knots <code class="reqn">\mu_1,\dots,\mu_g</code>.
</p>
</td></tr>       
<tr><td><code id="minPenalty_+3A_dist.range">dist.range</code></td>
<td>

<p>Approximate minimal and maximal knot. If not given by <code>knots</code> the knots
are determined as <code>c(seq(0, dist.range[2], by = by.knots), seq(0, dist.range[1], by = -by.knots))</code>.
The sequence of knots is sorted and multiple entries are removed.
</p>
</td></tr>
<tr><td><code id="minPenalty_+3A_by.knots">by.knots</code></td>
<td>

<p>The distance between the two knots used when building a vector of knots if these
are not given by <code>knots</code>.
</p>
</td></tr>
<tr><td><code id="minPenalty_+3A_sdspline">sdspline</code></td>
<td>

<p>Standard deviation <code class="reqn">\sigma_0^2</code> of the basis
G-spline (here it appeares only in the variance constraint).
If not given it is determined as 2/3 times the maximal distance between the two knots. If 
<code>sdspline</code> &gt;= 1 it is changed to 0.9 to be able to satisfy the constraints.
</p>
</td></tr>
<tr><td><code id="minPenalty_+3A_difforder">difforder</code></td>
<td>

<p>The order of the finite difference used in the penalty term.
</p>
</td></tr>
<tr><td><code id="minPenalty_+3A_init.c">init.c</code></td>
<td>

<p>Optional vector of the initial values for the G-spline
coefficients c, all values must lie between 0 and 1
and must sum up to 1.
</p>
</td></tr>
<tr><td><code id="minPenalty_+3A_maxiter">maxiter</code></td>
<td>

<p>Maximum number of Newton-Raphson iterations.
</p>
</td></tr>
<tr><td><code id="minPenalty_+3A_rel.tolerance">rel.tolerance</code></td>
<td>

<p>(Relative) tolerance to declare the convergence. For this
function, the convergence is declared if absolute value of the
penalty is lower than <code>rel.tolerance</code> and if both
constraints are satisfied up to <code>rel.tolerance</code>.
</p>
</td></tr>
<tr><td><code id="minPenalty_+3A_toler.chol">toler.chol</code></td>
<td>

<p>Tolerance to declare Cholesky decomposition singular.
</p>
</td></tr>
<tr><td><code id="minPenalty_+3A_toler.eigen">toler.eigen</code></td>
<td>

<p>Tolerance to declare an eigen value of a matrix to be zero.
</p>
</td></tr>
<tr><td><code id="minPenalty_+3A_maxhalf">maxhalf</code></td>
<td>

<p>Maximum number of step-halving steps if updated estimate leads to a decrease
of the objective function.
</p>
</td></tr>
<tr><td><code id="minPenalty_+3A_debug">debug</code></td>
<td>

<p>If non-zero print debugging information.
</p>
</td></tr>
<tr><td><code id="minPenalty_+3A_info">info</code></td>
<td>

<p>If TRUE information concerning the iteration process is printed
during the computation to the standard output.
</p>
</td></tr>      
</table>


<h3>Value</h3>

<p>A list with the components &ldquo;spline&rdquo;, &ldquo;penalty&rdquo;, &ldquo;warning&rdquo;,
&ldquo;fail&rdquo;.
</p>
<table>
<tr><td><code>spline</code></td>
<td>
<p>A data frame with columns named &ldquo;Knot&rdquo;, &ldquo;SD basis&rdquo;,
&ldquo;c coef.&rdquo; and &ldquo;a coef.&rdquo; which gives the optimal values of
<code class="reqn">c_1,\dots, c_g</code> and 
<code class="reqn">a_1,\dots, a_g</code> in the latter two columns. This
data.frame can be further worked out using the function <code><a href="#topic+eval.Gspline">eval.Gspline</a></code>.</p>
</td></tr>
<tr><td><code>penalty</code></td>
<td>
<p>The value of the penalty term when declaring
convergence.</p>
</td></tr>
<tr><td><code>warning</code></td>
<td>
<p>Possible warnings concerning the convergence.</p>
</td></tr>
<tr><td><code>fail</code></td>
<td>
<p>Failure indicator. It is zero if everything went OK.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>optimum &lt;- minPenalty(knots=seq(-4.2, 4.2, by = 0.3), sdspline=0.2, difforder=3)
where &lt;- optimum$spline
print(where)
show &lt;- eval.Gspline(where, seq(-4.2, 4.2, by=0.05))
plot(show, type="l", bty="n", lwd=2)
</code></pre>

<hr>
<h2 id='MP.pseudoinv'>
Work Function for 'smoothSurvReg', currently nowhere used.
</h2><span id='topic+MP.pseudoinv'></span>

<h3>Description</h3>

<p>Function to compute a Moore-Penrose pseudoinverse
of a symmetric matrix using eigen values decomposition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MP.pseudoinv(x, toler = 1e-7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MP.pseudoinv_+3A_x">x</code></td>
<td>

<p>A symmetric matrix (it is not checked).
</p>
</td></tr>
<tr><td><code id="MP.pseudoinv_+3A_toler">toler</code></td>
<td>

<p>Under the eigen values decomposition is computed, all
eigen values smaller in absolute value than <code>toler</code>
are assumed to be zero.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with the Moore-Penrose pseudoinverse of <code>x</code>.
</p>


<h3>Note</h3>

<p>WARNING: This function was primarily used inside <code><a href="#topic+smoothSurvReg">smoothSurvReg</a></code>.
Consequently, it has very few error checks on its input arguments.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='piece'>
Left Continuous Piecewise Constant Function with a Finite Support.
</h2><span id='topic+piece'></span>

<h3>Description</h3>

<p>Function to evaluate a left continuous piecewise constant function with a finite support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    piece(x, breaks, values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piece_+3A_x">x</code></td>
<td>

<p>Vector of values where the piecewise constant function should be evaluated.
</p>
</td></tr>
<tr><td><code id="piece_+3A_breaks">breaks</code></td>
<td>

<p>Vector of sorted breakpoints of the piecewise constant function.
</p>
</td></tr>
<tr><td><code id="piece_+3A_values">values</code></td>
<td>

<p>Values of the piecewise constant function. It takes the value
<code>value[i]</code> on the interval <code>(breaks[i], breaks[i+1]]</code>. 
The function is assumed to be zero outside its range specified
as <code>(breaks[1], breaks[length(breaks)]]</code>.
The length of the vector <code>values</code> must be equal to
<code>length(breaks) - 1</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the piecewise constant function.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my.breaks &lt;- c(-2, 1.5, 4, 7)
my.values &lt;- c(0.5, 0.9, -2)
grid &lt;- seq(-3, 8, by = 0.25)
piece(grid, my.breaks, my.values)
</code></pre>

<hr>
<h2 id='plot.smoothSurvReg'>
Plot Objects of Class 'smoothSurvReg'
</h2><span id='topic+plot.smoothSurvReg'></span>

<h3>Description</h3>

<p>Plot the fitted error distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smoothSurvReg'
plot(x, plot = TRUE, resid = TRUE, knots = TRUE,
   compare = TRUE, components = FALSE, standard = TRUE,
   by, toler.c = 1e-5,
   xlim, ylim,
   xlab = expression(epsilon), ylab = expression(paste("f(",epsilon,")", sep = "")),
   type = "l", lty = 1, main, sub, bty = "n", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.smoothSurvReg_+3A_x">x</code></td>
<td>

<p>Object of class smoothSurvReg.
</p>
</td></tr>
<tr><td><code id="plot.smoothSurvReg_+3A_plot">plot</code></td>
<td>

<p>If <code>TRUE</code> the plot is directly produced, otherwise only a <code>data.frame</code>
with information used for later plotting is returned.
</p>
</td></tr>
<tr><td><code id="plot.smoothSurvReg_+3A_resid">resid</code></td>
<td>

<p>If <code>resid &amp; plot</code> residuals are added
to the plot in the following way. Residuals based on exact observations
are plotted by <code>pch = 3</code> (+), residuals based on right censored
observations using <code>pch = 4</code> (x), residuals based on left censored
observations using <code>pch = 2</code> (traingle) and midpoints of
residuals based on interval censored observations using
<code>pch = 5</code> (diamond).
</p>
</td></tr>
<tr><td><code id="plot.smoothSurvReg_+3A_knots">knots</code></td>
<td>

<p>If <code>knots &amp; plot</code> bullets indicating (transformed)
knots corresponding to 'c' G-spline coefficients higher than <code>toler.c</code>
are added to the x-axis of the plot.
</p>
</td></tr>
<tr><td><code id="plot.smoothSurvReg_+3A_compare">compare</code></td>
<td>

<p>If <code>compare &amp; !components &amp; standard &amp; plot</code> plots of the three
parametric distributions (st. normal, st. logistic and st. minimum extreme value)
are added to the plot for comparison.
</p>
</td></tr>
<tr><td><code id="plot.smoothSurvReg_+3A_components">components</code></td>
<td>

<p>If <code>components &amp; standard &amp; plot</code> dashed lines with weighted
G-spline components are added to the plot.
</p>
</td></tr>
<tr><td><code id="plot.smoothSurvReg_+3A_standard">standard</code></td>
<td>

<p>If <code>standard</code> data for plotting the fitted error distribution
are created, otherwise data for plotting the distribution
of <code class="reqn">\alpha + \sigma\varepsilon</code> are created.
In the case that <code class="reqn">\log(\sigma)</code> depends on covariates
and <code>standard</code> is FALSE, all covariates equal to zero are used
to compute <code class="reqn">\log(\sigma)</code>.
</p>
</td></tr>
<tr><td><code id="plot.smoothSurvReg_+3A_by">by</code></td>
<td>

<p>Step for a ploting grid. If <code>NULL</code> it is automatically computed.
</p>
</td></tr>
<tr><td><code id="plot.smoothSurvReg_+3A_toler.c">toler.c</code></td>
<td>

<p>Tolerance to indicate zero 'c' G-spline coefficients used if <code>knots == TRUE</code>.
</p>
</td></tr>
<tr><td><code id="plot.smoothSurvReg_+3A_xlim">xlim</code>, <code id="plot.smoothSurvReg_+3A_ylim">ylim</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="plot.smoothSurvReg_+3A_xlab">xlab</code>, <code id="plot.smoothSurvReg_+3A_ylab">ylab</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="plot.smoothSurvReg_+3A_type">type</code>, <code id="plot.smoothSurvReg_+3A_lty">lty</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="plot.smoothSurvReg_+3A_main">main</code>, <code id="plot.smoothSurvReg_+3A_sub">sub</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="plot.smoothSurvReg_+3A_bty">bty</code></td>
<td>

<p>Argument passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="plot.smoothSurvReg_+3A_...">...</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with columns named <code>x</code> and <code>y</code> where <code>x</code> gives the grid
and <code>y</code> the values of the density at that grid.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smoothSurvReg">smoothSurvReg</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>
</p>

<hr>
<h2 id='print.estimTdiff'>
Print for Objects of Class 'estimTdiff'
</h2><span id='topic+print.estimTdiff'></span>

<h3>Description</h3>

<p>Print a summary information of the estimates and tests for expected
values of survival times based on a regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estimTdiff'
print(x, digits = min(options()$digits, 4), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.estimTdiff_+3A_x">x</code></td>
<td>

<p>Object of class estimTdiff.
</p>
</td></tr>
<tr><td><code id="print.estimTdiff_+3A_digits">digits</code></td>
<td>

<p>Controls the number of digits to print when printing numeric
values.  It is a suggestion only.  Valid values are 1...22.
</p>
</td></tr>
<tr><td><code id="print.estimTdiff_+3A_...">...</code></td>
<td>

<p>Further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to print the object.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smoothSurvReg">smoothSurvReg</a></code>, <code><a href="base.html#topic+print">print</a></code>
</p>

<hr>
<h2 id='print.smoothSurvReg'>
Summary and Print for Objects of Class 'smoothSurvReg'
</h2><span id='topic+print.smoothSurvReg'></span><span id='topic+summary.smoothSurvReg'></span>

<h3>Description</h3>

<p>Print a summary information of the fitted model.
</p>
<p>For <b>regression coefficients</b> the following information is given:
</p>

<table>
<tr>
 <td style="text-align: left;">
  &lsquo;<span class="samp">&#8288;Value&#8288;</span>&rsquo; </td><td style="text-align: left;"> - </td><td style="text-align: left;"> estimate of the coefficient </td>
</tr>
<tr>
 <td style="text-align: left;">
  &lsquo;<span class="samp">&#8288;Std.Error&#8288;</span>&rsquo; </td><td style="text-align: left;"> - </td><td style="text-align: left;"> estimated standard error based on the
    pseudo-variance estimate (3.1) </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> </td><td style="text-align: left;"> in
         Komárek, Lesaffre and Hilton (2005)
    </td>
</tr>
<tr>
 <td style="text-align: left;">
  &lsquo;<span class="samp">&#8288;Std.Error2&#8288;</span>&rsquo; </td><td style="text-align: left;"> - </td><td style="text-align: left;"> estimated standard error based on the
     asymptotic variance estimate (3.2) </td>
</tr>
<tr>
 <td style="text-align: left;">
     </td><td style="text-align: left;"> </td><td style="text-align: left;"> in
          Komárek, Lesaffre and Hilton (2005)
     </td>
</tr>
<tr>
 <td style="text-align: left;">
  &lsquo;<span class="samp">&#8288;Z&#8288;</span>&rsquo; </td><td style="text-align: left;"> - </td><td style="text-align: left;"> the Wald statistic obtained as &lsquo;<span class="samp">&#8288;Value&#8288;</span>&rsquo; divided by
    &lsquo;<span class="samp">&#8288;Std.Error&#8288;</span>&rsquo; </td>
</tr>
<tr>
 <td style="text-align: left;">
  &lsquo;<span class="samp">&#8288;Z2&#8288;</span>&rsquo; </td><td style="text-align: left;"> - </td><td style="text-align: left;"> the Wald statistic obtained as &lsquo;<span class="samp">&#8288;Value&#8288;</span>&rsquo; divided
    by &lsquo;<span class="samp">&#8288;Std.Error2&#8288;</span>&rsquo; </td>
</tr>
<tr>
 <td style="text-align: left;">
  &lsquo;<span class="samp">&#8288;p&#8288;</span>&rsquo; </td><td style="text-align: left;"> - </td><td style="text-align: left;"> the two-sided P-value based on normality of the statistic
    &lsquo;<span class="samp">&#8288;Z&#8288;</span>&rsquo; </td>
</tr>
<tr>
 <td style="text-align: left;">
  &lsquo;<span class="samp">&#8288;p2&#8288;</span>&rsquo; </td><td style="text-align: left;"> - </td><td style="text-align: left;"> the two-sided P-value based on normality of the statistic
    &lsquo;<span class="samp">&#8288;Z2&#8288;</span>&rsquo; </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>Further, we print:
</p>

<table>
<tr>
 <td style="text-align: left;">  
    &lsquo;<span class="samp">&#8288;Lambda&#8288;</span>&rsquo; </td><td style="text-align: left;"> - </td><td style="text-align: left;"> the optimal value of the smoothing
    hyperparameter </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> </td><td style="text-align: left;"> divided by the sample size,
    i.e., <code class="reqn">\lambda/n</code> in the notation </td>
</tr>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> </td><td style="text-align: left;"> of
    Komárek, Lesaffre and Hilton (2005)
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    &lsquo;<span class="samp">&#8288;Log(Lambda)&#8288;</span>&rsquo; </td><td style="text-align: left;"> - </td><td style="text-align: left;"> logarithm of the above </td>
</tr>
<tr>
 <td style="text-align: left;">
    &lsquo;<span class="samp">&#8288;df&#8288;</span>&rsquo; </td><td style="text-align: left;"> - </td><td style="text-align: left;"> effective degrees of freedom of the model, see
    Section 2.2.3 </td>
</tr>
<tr>
 <td style="text-align: left;">
        </td><td style="text-align: left;"> </td><td style="text-align: left;"> of Komárek, Lesaffre and Hilton (2005)
    </td>
</tr>
<tr>
 <td style="text-align: left;">
    &lsquo;<span class="samp">&#8288;AIC&#8288;</span>&rsquo; </td><td style="text-align: left;"> - </td><td style="text-align: left;"> Akaike's information criterion of the model, see
    Section 2.2.3 </td>
</tr>
<tr>
 <td style="text-align: left;">
      </td><td style="text-align: left;"> </td><td style="text-align: left;"> of Komárek, Lesaffre and Hilton (2005)
    </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>
  
<p>With argument <b>spline</b> set to <code>TRUE</code>, analogous table like
that for the regression coefficients is printed also for the weights of the
penalized Gaussian mixture (G-spline).           
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smoothSurvReg'
print(x, spline, digits = min(options()$digits, 4), ...)
## S3 method for class 'smoothSurvReg'
summary(object, spline, digits = min(options()$digits, 4), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.smoothSurvReg_+3A_x">x</code></td>
<td>
<p>Object of class smoothSurvReg.</p>
</td></tr>
<tr><td><code id="print.smoothSurvReg_+3A_object">object</code></td>
<td>
<p>Object of class smoothSurvReg.</p>
</td></tr>
<tr><td><code id="print.smoothSurvReg_+3A_spline">spline</code></td>
<td>

<p>TRUE/FALSE. If TRUE an information on fitted G-spline is printed.
</p>
</td></tr>
<tr><td><code id="print.smoothSurvReg_+3A_digits">digits</code></td>
<td>

<p>Controls the number of digits to print when printing numeric
values.  It is a suggestion only.  Valid values are 1...22.
</p>
</td></tr>
<tr><td><code id="print.smoothSurvReg_+3A_...">...</code></td>
<td>

<p>Further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called to print the object.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A., Lesaffre, E., and Hilton, J. F. (2005).
Accelerated failure time model for arbitrarily censored data with smoothed error distribution. 
<em>Journal of Computational and Graphical Statistics</em>, <b>14</b>,
726&ndash;745.
</p>
<p>Lesaffre, E., Komárek, A., and Declerck, D. (2005).
An overview of methods for interval-censored data with an emphasis on applications in dentistry.
<em>Statistical Methods in Medical Research</em>, <b>14</b>, 
539&ndash;552.  
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smoothSurvReg">smoothSurvReg</a></code>, <code><a href="base.html#topic+print">print</a></code>, <code><a href="base.html#topic+summary">summary</a></code>
</p>

<hr>
<h2 id='residuals.smoothSurvReg'>
Residuals for Objects of Class 'smoothSurvReg'
</h2><span id='topic+residuals.smoothSurvReg'></span>

<h3>Description</h3>

<p>Compute residuals for the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smoothSurvReg'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.smoothSurvReg_+3A_object">object</code></td>
<td>

<p>Object of class smoothSurvReg.
</p>
</td></tr>
<tr><td><code id="residuals.smoothSurvReg_+3A_...">...</code></td>
<td>

<p>Argument included in the function parameters for the compatibility 
with the generic function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with columns named <code>res</code>, <code>res2</code> and <code>censor</code>
where the column <code>res2</code> is included only if there are any interval censored
observations. Column <code>res</code> contains all residuals, column <code>res2</code>
is applicable only for interval censored observations. Column <code>censor</code>
gives the type of censoring (0 for right censoring, 1 for exact observations,
2 for left censoring and 3 for interval censoring).
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smoothSurvReg">smoothSurvReg</a></code>
</p>

<hr>
<h2 id='smoothSurvReg'>
Regression for a Survival Model with Smoothed Error Distribution
</h2><span id='topic+smoothSurvReg'></span><span id='topic+C_smoothSurvReg84'></span>

<h3>Description</h3>

<p>Regression for a survival model. These are all
time-transformed location models, with the most useful case being the
accelerated failure models that use a log transformation.
Error distribution is assumed to be a mixture of G-splines.
Parameters are estimated by the penalized maximum likelihood
method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothSurvReg(formula = formula(data), logscale = ~1, 
   data = parent.frame(), subset, na.action = na.fail,
   init.beta, init.logscale, init.c, init.dist = "best",
   update.init = TRUE, aic = TRUE, lambda = exp(2:(-9)),
   model = FALSE, control = smoothSurvReg.control(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothSurvReg_+3A_formula">formula</code></td>
<td>

<p>A formula expression as for other regression models.
See the documentation for <code><a href="stats.html#topic+lm">lm</a></code> and <code><a href="stats.html#topic+formula">formula</a></code> for details.
Use <code><a href="survival.html#topic+Surv">Surv</a></code> on the left hand side of the formula.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg_+3A_logscale">logscale</code></td>
<td>

<p>A formula expression to determine a possible dependence of the
log-scale on covariates.
</p>
</td></tr>     
<tr><td><code id="smoothSurvReg_+3A_data">data</code></td>
<td>

<p>Optional data frame in which to interpret the variables occurring in the
formula.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg_+3A_subset">subset</code></td>
<td>

<p>Subset of the observations to be used in the fit.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg_+3A_na.action">na.action</code></td>
<td>

<p>Function to be used to handle any NAs in the data. It's default
value is <code>na.fail</code>. It is not recommended to change it in the
case when <code>logscale</code> depends on covariates.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg_+3A_init.beta">init.beta</code></td>
<td>

<p>Optional vector of the initial values of the regression parameter <code class="reqn">\beta</code>
(intercept and regression itself).
</p>
</td></tr>
<tr><td><code id="smoothSurvReg_+3A_init.logscale">init.logscale</code></td>
<td>

<p>Optional value of the initial value of the parameters that
determines the log-scale parameter <code class="reqn">\log(\sigma)</code>.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg_+3A_init.c">init.c</code></td>
<td>

<p>Optional vector of the initial values for the G-spline
coefficients c, all values must lie between 0 and 1
and must sum up to 1.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg_+3A_init.dist">init.dist</code></td>
<td>

<p>A character string specifying the distribution used by <code><a href="survival.html#topic+survreg">survreg</a></code>
to find the initial values for parameters (if not given by the user).
It is assumed to name <code>"best"</code> or an
element from <code><a href="survival.html#topic+survreg.distributions">survreg.distributions</a></code>. These include
<code>"weibull"</code>, <code>"exponential"</code>, <code>"gaussian"</code>,
<code>"logistic"</code>, <code>"lognormal"</code> and <code>"loglogistic"</code>.
If &quot;best&quot; is specified one of <code>"lognormal"</code>,
<code>"weibull"</code> and <code>"loglogistic"</code> giving the highest
likelihood is used.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg_+3A_update.init">update.init</code></td>
<td>

<p>If TRUE, the initial values are updated during the grid search for the lambda
parameter giving the optimal AIC. Otherwise, fits with all lambdas during the
grid search start with same initials determine at the beginning either
from the values of <code>init.beta, init.scale, init.c</code> or from the initial
<code><a href="survival.html#topic+survreg">survreg</a></code> fit as determined by the parameter
<code>init.dist</code>.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg_+3A_aic">aic</code></td>
<td>

<p>If TRUE the optimal value of the tuning parameter <code class="reqn">\lambda</code>
is determined via a grid search through the values specified
by the parameter <code>lambda</code>. If FALSE, only the model with
<code class="reqn">\lambda = </code> <code>lambda[1]</code> is fitted.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg_+3A_lambda">lambda</code></td>
<td>

<p>A grid of values of the tuning parameter <code class="reqn">\lambda</code> searched
for the optimal value if <code>aic</code> = TRUE.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg_+3A_model">model</code></td>
<td>

<p>If TRUE, the model frame is returned.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg_+3A_control">control</code></td>
<td>

<p>A list of control values, in the format producted by <code><a href="#topic+smoothSurvReg.control">smoothSurvReg.control</a></code>.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg_+3A_...">...</code></td>
<td>

<p>Other arguments which will be passed to <code><a href="#topic+smoothSurvReg.control">smoothSurvReg.control</a></code>. See its help
page for more options to control the fit and for the possibility to fix some values
and not to estimate them.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Read the papers referred below.
</p>
<p>There is a slight difference in the definition of the penalty used by the R function compared
to what is written in the paper.
The penalized log-likelihood given in the paper has a form
</p>
<p style="text-align: center;"><code class="reqn">\ell_P(\theta) = \ell(\theta) - \frac{\lambda}{2}\sum_{j=m+1}^g(\Delta^m a_j)^2,</code>
</p>

<p>while the penalized log-likelihood used in the R function multiplies the tuning parameter
<code class="reqn">\lambda</code> given by <code>lambda</code> by a sample size <code class="reqn">n</code> to keep default values
more or less useful for samples of different sizes. So that the penalized log-likelihood
which is maximized by the R function has the form
</p>
<p style="text-align: center;"><code class="reqn">\ell_P(\theta) = \ell(\theta) - \frac{\lambda\cdot n}{2}\sum_{j=m+1}^g(\Delta^m a_j)^2.</code>
</p>



<h3>Value</h3>

<p>An object of class <code>smoothSurvReg</code> is returned.
See <code><a href="#topic+smoothSurvReg.object">smoothSurvReg.object</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>References</h3>

<p>Komárek, A., Lesaffre, E., and Hilton, J. F. (2005).
Accelerated failure time model for arbitrarily censored data with smoothed error distribution. 
<em>Journal of Computational and Graphical Statistics</em>, <b>14</b>,
726&ndash;745.
</p>
<p>Lesaffre, E., Komárek, A., and Declerck, D. (2005).
An overview of methods for interval-censored data with an emphasis on applications in dentistry.
<em>Statistical Methods in Medical Research</em>, <b>14</b>, 
539&ndash;552.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### EXAMPLE 1:  Common scale
##### ========================
### We generate interval censored data and fit a model with few artificial covariates
set.seed(221913282)
x1 &lt;- rbinom(50, 1, 0.4)                                         ## binary covariate
x2 &lt;- rnorm(50, 180, 10)                                         ## continuous covariate
y1 &lt;- 0.5*x1 - 0.01*x2 + 0.005 *x1*x2 + 1.5*rnorm(50, 0, 1)      ## generate log(T), left limit
t1 &lt;- exp(y1)                                                    ## left limit of the survival time
t2 &lt;- t1 + rgamma(50, 1, 1)                                      ## right limit of the survival time
surv &lt;- Surv(t1, t2, type = "interval2")                         ## survival object

## Fit the model with an interaction
fit1 &lt;- smoothSurvReg(surv ~ x1 * x2, logscale = ~1, info = FALSE, lambda = exp(2:(-1)))

## Print the summary information
summary(fit1, spline = TRUE)

## Plot the fitted error distribution
plot(fit1)

## Plot the fitted error distribution with its components
plot(fit1, components = TRUE)

## Plot the cumulative distribution function corresponding to the error density
survfit(fit1, cdf = TRUE)

## Plot survivor curves for persons with (x1, x2) = (0, 180) and (1, 180)
cov &lt;- matrix(c(0, 180, 0,   1, 180, 180), ncol = 3, byrow = TRUE)
survfit(fit1, cov = cov)

## Plot hazard curves for persons with (x1, x2) = (0, 180) and (1, 180)
cov &lt;- matrix(c(0, 180, 0,   1, 180, 180), ncol = 3, byrow = TRUE)
hazard(fit1, cov = cov)

## Plot densities for persons with (x1, x2) = (0, 180) and (1, 180)
cov &lt;- matrix(c(0, 180, 0,   1, 180, 180), ncol = 3, byrow = TRUE)
fdensity(fit1, cov = cov)

## Compute estimates expectations of survival times for persons with
## (x1, x2) = (0, 180), (1, 180), (0, 190), (1, 190), (0, 200), (1, 200)
## and estimates of a difference of these expectations:
## T(0, 180) - T(1, 180), T(0, 190) - T(1, 190), T(0, 200) - T(1, 200),
cov1 &lt;- matrix(c(0, 180, 0,   0, 190, 0,   0, 200, 0), ncol = 3, byrow = TRUE)
cov2 &lt;- matrix(c(1, 180, 180,   1, 190, 190,   1, 200, 200), ncol = 3, byrow = TRUE)
print(estimTdiff(fit1, cov1 = cov1, cov2 = cov2))


##### EXAMPLE 2:  Scale depends on covariates
##### =======================================
### We generate interval censored data and fit a model with few artificial covariates
set.seed(221913282)
x1 &lt;- rbinom(50, 1, 0.4)                                        ## binary covariate
x2 &lt;- rnorm(50, 180, 10)                                        ## continuous covariate
x3 &lt;- runif(50, 0, 1)                                           ## covariate for the scale parameter
logscale &lt;- 1 + x3
scale &lt;- exp(logscale)
y1 &lt;- 0.5*x1 - 0.01*x2 + 0.005 *x1*x2 + scale*rnorm(50, 0, 1)    ## generate log(T), left limit
t1 &lt;- exp(y1)                                                    ## left limit of the survival time
t2 &lt;- t1 + rgamma(50, 1, 1)                                      ## right limit of the survival time
surv &lt;- Surv(t1, t2, type = "interval2")                         ## survival object

## Fit the model with an interaction
fit2 &lt;- smoothSurvReg(surv ~ x1 * x2, logscale = ~x3, info = FALSE, lambda = exp(2:(-1)))

## Print the summary information
summary(fit2, spline = TRUE)

## Plot the fitted error distribution
plot(fit2)

## Plot the fitted error distribution with its components
plot(fit2, components = TRUE)

## Plot survivor curves for persons with (x1, x2) = (0, 180) and (1, 180)
## x3 = 0.8 and 0.9
cov &lt;- matrix(c(0, 180, 0,   1, 180, 180), ncol = 3, byrow = TRUE)
logscale.cov &lt;- c(0.8, 0.9)
survfit(fit2, cov = cov, logscale.cov = logscale.cov)

## Plot hazard curves for persons with (x1, x2) = (0, 180) and (1, 180)
## x3 = 0.8 and 0.9
cov &lt;- matrix(c(0, 180, 0,   1, 180, 180), ncol = 3, byrow = TRUE)
logscale.cov &lt;- c(0.8, 0.9)
hazard(fit2, cov = cov, logscale.cov=c(0.8, 0.9))

## Plot densities for persons with (x1, x2) = (0, 180) and (1, 180)
## x3 = 0.8 and 0.9
cov &lt;- matrix(c(0, 180, 0,   1, 180, 180), ncol = 3, byrow = TRUE)
logscale.cov &lt;- c(0.8, 0.9)
fdensity(fit2, cov = cov, logscale.cov = logscale.cov)


## More involved examples can be found in script files
## used to perform analyses  and draw pictures 
## presented in above mentioned references.
## These scripts and some additional files can be found as *.tar.gz files
## in the /inst/doc directory of this package.
##
</code></pre>

<hr>
<h2 id='smoothSurvReg.control'>
More Options for 'smoothSurvReg'
</h2><span id='topic+smoothSurvReg.control'></span>

<h3>Description</h3>

<p>This function checks and sets the fitting options for smoothSurvReg.
Its arguments can be used instead of ... in a call to smoothSurvReg.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothSurvReg.control(est.c = TRUE, est.scale = TRUE,
   maxiter = 200, firstiter = 0, rel.tolerance = 5e-5,
   toler.chol = 1e-15, toler.eigen = 1e-3,
   maxhalf = 10, debug = 0, info = TRUE, lambda.use = 1.0, sdspline = NULL,
   difforder = 3, dist.range = c(-6, 6), by.knots = 0.3,
   knots = NULL, nsplines = NULL, last.three = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothSurvReg.control_+3A_est.c">est.c</code></td>
<td>

<p>If TRUE the G-spline coefficients are estimated. Otherwise, they are fixed
to the values given by <code>init.c</code> parameter of <code><a href="#topic+smoothSurvReg">smoothSurvReg</a></code>.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.control_+3A_est.scale">est.scale</code></td>
<td>

<p>If TRUE the scale parameter <code class="reqn">\sigma</code> is estimated. Otherwise,
it is fixed to the value given by <code>init.scale</code> parameter
of <code><a href="#topic+smoothSurvReg">smoothSurvReg</a></code>.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.control_+3A_maxiter">maxiter</code></td>
<td>

<p>Maximum number of Newton-Raphson iterations.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.control_+3A_firstiter">firstiter</code></td>
<td>

<p>The index of the first iteration. This option comes from older versions
of this function.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.control_+3A_rel.tolerance">rel.tolerance</code></td>
<td>

<p>(Relative) tolerance to declare the convergence. In this version of the function,
the convergence is declared if the relative difference between two consecutive values
of the penalized log-likelihood are smaller than rel.tolerance.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.control_+3A_toler.chol">toler.chol</code></td>
<td>

<p>Tolerance to declare Cholesky decomposition singular.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.control_+3A_toler.eigen">toler.eigen</code></td>
<td>

<p>Tolerance to declare an eigen value of a matrix to be zero.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.control_+3A_maxhalf">maxhalf</code></td>
<td>

<p>Maximum number of step-halving steps if updated estimate leads to a decrease
of the objective function.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.control_+3A_debug">debug</code></td>
<td>

<p>If non-zero print debugging information.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.control_+3A_info">info</code></td>
<td>

<p>If TRUE information concerning the iteration process is printed
during the computation to the standard output.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.control_+3A_lambda.use">lambda.use</code></td>
<td>

<p>The value of the tuning (penalty) parameter <code class="reqn">\lambda</code> used 
in a current fit by the <code>smoothSurvReg.fit</code> function.
Value of this option is not interesting for the user. The parameter
<code>lambda</code> of the function <code>smoothSurvReg</code> is more important for 
the user.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.control_+3A_sdspline">sdspline</code></td>
<td>

<p>Standard deviation of the basis G-spline. If not given it is determined
as 2/3 times the maximal distance between the two knots. If <code>est.c</code> = TRUE
and <code>sdspline</code> &gt;= 1 it is changed to 0.9 to be able to satisfy the constraints
imposed to the fitted error distribution.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.control_+3A_difforder">difforder</code></td>
<td>

<p>The order of the finite difference used in the penalty term.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.control_+3A_dist.range">dist.range</code></td>
<td>

<p>Approximate minimal and maximal knot. If not given by <code>knots</code> the knots
are determined as <code>c(seq(0, dist.range[2], by = by.knots), seq(0, dist.range[1], by = -by.knots))</code>.
The sequence of knots is sorted and multiple entries are removed.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.control_+3A_by.knots">by.knots</code></td>
<td>

<p>The distance between the two knots used when building a vector of knots if these
are not given by <code>knots</code>. This option is ignored if <code>nsplines</code> is not <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.control_+3A_knots">knots</code></td>
<td>

<p>A vector of knots.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.control_+3A_nsplines">nsplines</code></td>
<td>

<p>This option is ignored at this moment. It is used to give the number of G-splines
to the function <code><a href="#topic+smoothSurvReg.fit">smoothSurvReg.fit</a></code>.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.control_+3A_last.three">last.three</code></td>
<td>

<p>A vector of length 3 with indeces of reference knots. The 'a' coefficient of
the <code>knot[last.three[1]]</code> is then equal to zero, 'a' coefficients
with indeces <code>last.three[2:3]</code> are expressed as a function of remaining
'a' coefficients such that resulting error distribution has zero mean and unit
variance. If <code>maxiter &gt; 0</code> <code>last.three</code> is determined after
the convergence is reached. If <code>maxiter == 0</code> <code>last.three</code> is used 
to compute variance matrices.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the same elements as the input except <code>dist.range</code> and <code>by.knots</code>
is returned.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='smoothSurvReg.fit'>
Work Function to Fit the Model Using 'smoothSurvReg'
</h2><span id='topic+smoothSurvReg.fit'></span>

<h3>Description</h3>

<p>Fit the survival regression model with smoothed error distribution.
This function is not to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoothSurvReg.fit(x, z, y, offset = NULL, correctlik, init, controlvals, common.logscale)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoothSurvReg.fit_+3A_x">x</code></td>
<td>

<p>A covariate matrix.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.fit_+3A_z">z</code></td>
<td>

<p>A covariate matrix for log(scale).
</p>
</td></tr>     
<tr><td><code id="smoothSurvReg.fit_+3A_y">y</code></td>
<td>

<p>A two- or three- column matrix with response. The last column
indicate the type of censoring. See <code><a href="survival.html#topic+Surv">Surv</a></code> for details.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.fit_+3A_offset">offset</code></td>
<td>

<p>A vector with possible offset term.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.fit_+3A_correctlik">correctlik</code></td>
<td>

<p>Correction term to the likelihood due to the log transformation of the response.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.fit_+3A_init">init</code></td>
<td>

<p>A list with components <code>beta</code>, <code>scale</code>, <code>ccoef</code>
giving the initial values for the fitting process.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.fit_+3A_controlvals">controlvals</code></td>
<td>

<p>A list returned by <code><a href="#topic+smoothSurvReg.control">smoothSurvReg.control</a></code>.
</p>
</td></tr>
<tr><td><code id="smoothSurvReg.fit_+3A_common.logscale">common.logscale</code></td>
<td>

<p>Indicator (TRUE/FALSE) indicating whether the log-scale is same for all observations 
or whether it depends on covariates.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components <code>regres, spline, loglik, aic,
     degree.smooth, var, var2, dCdC,
   iter, estimated, warning, fail, H, I, G, U</code>.
</p>


<h3>Note</h3>

<p>WARNING: Most users will call the higher level routine smoothSurvReg.
Consequently, this function has very few error checks on its input arguments.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='smoothSurvReg.object'>
Smoothed Survival Regression Object
</h2><span id='topic+smoothSurvReg.object'></span>

<h3>Description</h3>

<p>This class of objects is returned by the <code>smoothSurvReg</code> class of functions to represent
a fitted smoothed survival regression model.
</p>
<p>Objects of this class have methods for the functions <code>print</code>, <code>summary</code>, <code>plot</code>,
<code>residuals</code>, <code>survfit</code>.
</p>


<h3>COMPONENTS I</h3>

<p>The following components must be included in a legitimate <code>smoothSurvReg</code> object.
</p>

<dl>
<dt>fail</dt><dd>
<p>Indicator of the failure of the fitting procedure. Possible values are
0 for no problems,
3 if the iteration process was stopped because of non-positive definite minus Hessian,
4 if the eiteration process was stopped because too many halving steps were performed,
5 if it was not possible to find the three reference knots (it was not then possible
to perform optimization with respect to the full parameter vector),
6 if the maximal number of iterations was performed without reaching a convergence.
The <code>fail</code> component is increased by 10 if the final minus Hessian of the penalized
log-likelihood was not positive definite.
The <code>fail</code> component is further increased by 20 if the computed effective 
degrees of freedom were non-positive.
The <code>fail</code> component is further increased by 40 if there are negative estimates
of standard errors for some regression parameters.
The <code>fail</code> component is 99 or higher if the fitting procedure failed at all and
there is no fit produced.
</p>
</dd>
</dl>



<h3>COMPONENTS II</h3>

<p>The following components must be included in a legitimate <code>smoothSurvReg</code> object
if <code>fail</code> is lower than 99.
</p>

<dl>
<dt>regres</dt><dd>
<p>Estimates of the regression parameters <code class="reqn">\alpha, \beta, \sigma</code> if
these have been estimated with their standard errors stored in a data frame
with <code>colnames</code> &ldquo;Value&rdquo;, &ldquo;Std.Error&rdquo;, &ldquo;Std.Error2&rdquo; and <code>rownames</code> derived from
the names of the design matrix with &ldquo;(Intercept)&rdquo; for the intercept, &ldquo;Scale&rdquo; for the scale
and &ldquo;Log(scale)&rdquo; for the log-scale. If the log-scale depends on covariates then rows
named &ldquo;LScale.(Intercept)&rdquo;, &ldquo;LScale.cov1&rdquo; etc. give estimates of regression parameters
for log-scale.
The two standard errors are computed using either
<code>var</code> or <code>var2</code> described below.
</p>
</dd>
<dt>spline</dt><dd>
<p>Description of the fitted error density. 
A data frame with <code>colnames</code> &ldquo;Knot&rdquo;, &ldquo;SD basis&rdquo;,
&ldquo;c coef.&rdquo;, &ldquo;Std.Error.c&rdquo;, &ldquo;Std.Error2.c&rdquo;,
&ldquo;a coef.&rdquo;, &ldquo;Std.Error.a&rdquo; and &ldquo;Std.Error2.a&rdquo;
and <code>rownames</code> knot[1], ..., knot[g] where
<code class="reqn">g</code> stands for the number of basis G-splines. The column &ldquo;Knot&rdquo; contains the knots
in ascending order, &ldquo;SD basis&rdquo; the standard deviation of an appropriate basis G-spline,
&ldquo;c coef.&rdquo; estimates of the G-spline coefficients and &ldquo;Std.Error.c&rdquo; and &ldquo;Std.Error2.c&rdquo; 
the estimates of their standard errors based either on <code>var</code> or <code>var2</code>. 
The column &ldquo;a coef.&rdquo; contains the estimates of transformed <code class="reqn">c</code> coefficients where 
</p>
<p style="text-align: center;"><code class="reqn">c_j = \frac{\exp(a_j)}{\sum_{l=1}^{g}\exp(a_l)}, j = 1,\dots, g.</code>
</p>

<p>If the error distribution is estimated, one of the <code class="reqn">a</code> coefficients is set to zero and  
two other <code class="reqn">a</code>'s are expressed as a function of the remaining <code class="reqn">a</code> coefficients
(to avoid equality constraints concerning the mean and the variance of the error distribution).
The standard error for these three <code class="reqn">a</code> coefficients is then not available (it is equal
to <code>NA</code>).
Standard error is set to
<code>NaN</code> is a diagonal element of the appropriate covariance matrix was negative.
</p>
</dd>
<dt>loglik</dt><dd>
<p>Maximized penalized log-likelihood, log-likelihood and the penalty term. A data frame with 
one row and three columns named &ldquo;Log Likelihood&rdquo;, &ldquo;Penalty&rdquo; 
and &ldquo;Penalized Log Likelihood&rdquo;.
</p>
</dd>
<dt>aic</dt><dd>
<p>Akaike's information criterion of the fitted model computed as a maximized value of the 
penalized log-likelihood minus the effective degrees of freedom.
</p>
</dd>
<dt>degree.smooth</dt><dd>
<p>Effective degrees of freedom, number of parameters and related information. A data frame 
with one row
and columns named &ldquo;Lambda&rdquo;, &ldquo;Log(Lambda)&rdquo;, &ldquo;df&rdquo;, 
&ldquo;Number of parameters&rdquo;, &ldquo;Mean param.&rdquo;, &ldquo;Scale param.&rdquo;, &ldquo;Spline param.&rdquo; where
&ldquo;Lambda&rdquo; gives the value of the tunning parameter used in the final (optimal) fit, 
&ldquo;df&rdquo; the effective degrees of freedom, 
&ldquo;Number of parameters&rdquo; the real number of parameters and 
&ldquo;Mean param.&rdquo;, &ldquo;Scale param.&rdquo; and &ldquo;Spline param.&rdquo; its decomposition. 
Note that if G-spline coefficients are estimated &ldquo;Spline param.&rdquo;
is equal to the number of basis G-spline with non-zero coefficients minus three.
</p>
</dd>
<dt>var</dt><dd>
<p>The estimate of the covariance matrix of the estimates based on the Bayesian approximation.
It is equal to the inverse of the converged minus Hessian of the penalized log-likelihood.
Note that there are no columns and rows corresponding to the three
transformed G-spline coefficients since these are functions of the remaining transformed G-spline coefficients
(to avoid equality constraints).
</p>
</dd>
<dt>var2</dt><dd>
<p>The estimate of the covariance matrix of the estimates based on the asymptotic theory
for penalized models. It is equal to <code class="reqn">H^{-1}\,I\,H^{-1}</code> where
H is converged minus Hessian of the penalized log-likelihood and I is converged minus
Hessian of the log-likelihood component of the penalized log-likelihood.
</p>
</dd>
<dt>dCdD</dt><dd>
<p>A matrix with derivatives of <code class="reqn">c</code> spline coefficients with respect
to <code class="reqn">d</code> spline coefficients (these are <code class="reqn">a</code> coefficients
with three of them omitted). This matrix can be used later to compute
estimates and standard errors of functions of original parameters using
a Delta method. For closer definition of <code class="reqn">d</code> coefficients see an
enclosed document.
</p>
</dd>  
<dt>iter</dt><dd>
<p>Used number of iterations to fit the model with the optimal <code class="reqn">\lambda</code>.
</p>
</dd>
<dt>estimated</dt><dd>
<p>Indicator of what has really been estimated and not fixed. A four-component vector with 
component names &ldquo;(Intercept)&rdquo;, &ldquo;Scale&rdquo;, &ldquo;ccoef&rdquo;, &ldquo;common.logscale&rdquo;. 
The first component is TRUE if the intercept was included in the regression model.
The second component is TRUE if the scale parameter was not fixed, the third
component is TRUE is the G-spline coefficients were not fixed. The fourth
component is TRUE if the log-scale does not depend on covariates.
</p>
</dd>
<dt>warning</dt><dd>
<p>A data frame with one column called &ldquo;warnings&rdquo; and three rows called 
&ldquo;Convergence&rdquo;, &ldquo;Final minus Hessian&rdquo; and &ldquo;df&rdquo; 
containing a string information corresponding to the value of the <code>fail</code> component
of the object. It contains a string &ldquo;OK&rdquo; if there are no problems with the appropriate part
of the fitting process.
</p>
</dd>
<dt>H</dt><dd>
<p>Converged minus Hessian of the penalized log-likelihood. 
</p>
</dd>
<dt>I</dt><dd>
<p>Converged minus Hessian of the log-likelihood component of the penalized log-likelihood.
<code class="reqn">I = H - G</code>.
</p>
</dd>
<dt>G</dt><dd>
<p>Converged minus Hessian of the penalty term of the penalty term of the penalized log-likelihood.
<code class="reqn">G = H - I</code>.
</p>
</dd>
<dt>U</dt><dd>
<p>Converged score vector based on the penalized log-likelihood.
</p>
</dd>
<dt>na.action</dt><dd>
<p>The <code>na.action</code> attribute, if any, that was returned by the <code>na.action</code> routine.
</p>
</dd>
<dt>terms</dt><dd>
<p>The <code>terms</code> object used.
</p>
</dd>
<dt>formula</dt><dd>
<p>A symbolic description of the model to be fit.
</p>
</dd>
<dt>call</dt><dd>
<p>The matched call.
</p>
</dd>
<dt>init.dist</dt><dd>
<p>A string indicating the error distribution of the untransformed response to find the initial values. 
Possible values are &ldquo;lognormal&rdquo;, &ldquo;loglogistic&rdquo;, &ldquo;weibull&rdquo;.
</p>
</dd>
<dt>model</dt><dd>
<p>If requested, the model frame used.
</p>
</dd>
<dt>x</dt><dd>
<p>The model matrix used.
</p>
</dd>
<dt>y</dt><dd>
<p>The response matrix used (two columns if there were no interval censored observations,
three columns if there were some interval censored observations). The last column
indicates the death status.
</p>
</dd>
<dt>z</dt><dd>
<p>The model matrix used for the expression of log-scale.
</p>
</dd>
<dt>init.spline</dt><dd>
<p>A data frame describing the initial error density. It has columns named &ldquo;Knot&rdquo;, &ldquo;SD basis&rdquo;,
&ldquo;c coef.&rdquo; and rows named &ldquo;knot[1]&rdquo;, ..., &ldquo;knot[g]&rdquo;.
</p>
</dd>
<dt>init.regres</dt><dd>
<p>Initial estimates of the regression parameters. A data frame with one column named &ldquo;Value&rdquo;
and rows named as in the <code>regres</code> component of the <code>smoothSurvReg</code> object.
</p>
</dd>
<dt>adjust</dt><dd>
<p>Adjusted intercept and scale. A data frame with a column named &ldquo;Value&rdquo; and rows named &ldquo;(Intercept)&rdquo;
and &ldquo;Scale&rdquo;. &ldquo;(Intercept)&rdquo; gives the overall intercept taking into account the mean of the fitted
error distribution, &ldquo;Scale&rdquo; gives the overall scale taking into account the variance of the
fitted error distribution. If the error distribution is standardized
(always when G-spline coefficients are estimated)
then the &ldquo;(Intercept)&rdquo; is equal to the &ldquo;(Intercept)&rdquo; from the <code>regres</code> component and
&ldquo;Scale&rdquo; is equal to the &ldquo;Scale&rdquo; of either <code>regres</code> or <code>init.regres</code> component.
<code>NA</code>'s appeare in this <code>data.frame</code> in the case that log-scale depends on covariates.
</p>
</dd>
<dt>error.dist</dt><dd>
<p>A data frame with columns named &ldquo;Mean&rdquo;, &ldquo;Var&rdquo; and &ldquo;SD&rdquo; and a row named &ldquo;Error distribution:  &rdquo;
giving the mean, variance and the standard deviation of the fitted error distribution.
These are equal to 0, 1 and 1 if the G-spline coefficients were estimated.
</p>
</dd>
<dt>searched</dt><dd>
<p>Information concerning the searched values of the tunning paramater <code class="reqn">\lambda</code>
when looking for the best AIC. 
A data frame with columns named &ldquo;Lambda&rdquo;, &ldquo;Log(Lambda)&rdquo;, &ldquo;AIC&rdquo;, &ldquo;df&rdquo;,
&ldquo;PenalLogLik&rdquo;, &ldquo;LogLik&rdquo;, &ldquo;nOfParm&rdquo;, &ldquo;fail&rdquo;.
</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>

<hr>
<h2 id='standardized+20logistic'>
Density of Standardized Logistic Distribution.
</h2><span id='topic+dstlogis'></span>

<h3>Description</h3>

<p>Density function of the logistic distribution with zero mean and unit variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    dstlogis(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardized+2B20logistic_+3A_x">x</code></td>
<td>

<p>Vector of quantiles.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dstlogis(x) = dlogis(x, 0, sqrt(3)/pi)</code>
</p>


<h3>Value</h3>

<p>The value of the density.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dlogis">dlogis</a></code> for the logistic distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dstlogis(0)
dstlogis(seq(-3, 3, 0.2))
</code></pre>

<hr>
<h2 id='std.data'>
Standardization of the Data
</h2><span id='topic+std.data'></span>

<h3>Description</h3>

<p>Chosen columns of a <code>data.frame</code> are standardized by
using a sample mean and sample standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>std.data(datain, cols)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="std.data_+3A_datain">datain</code></td>
<td>

<p>Input data frame.
</p>
</td></tr>
<tr><td><code id="std.data_+3A_cols">cols</code></td>
<td>

<p>A character vector with names of the columns to be standardized.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each chosen column the sample mean and the sample standard deviation
is computed and then used to standardize the column. Missing values are 
ignored when computing the mean and the standard deviation.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> with same variables as the input <code>data.frame</code>.
Chosen columns are standardized.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+scale">scale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>variable1 &lt;- rnorm(30)
variable2 &lt;- rbinom(30, 1, 0.4)
variable3 &lt;- runif(30)
data.example &lt;- data.frame(variable1, variable2, variable3)
## We standardize only the first and the third column.
data.std &lt;- std.data(data.example, c("variable1", "variable3"))
print(data.std)
print(c(mean(data.std$variable1), sd(data.std$variable1)))
print(c(mean(data.std$variable3), sd(data.std$variable3)))
</code></pre>

<hr>
<h2 id='survfit.smoothSurvReg'>
Survivor Curves for Objects of Class 'smoothSurvReg'
</h2><span id='topic+survfit.smoothSurvReg'></span>

<h3>Description</h3>

<p>Compute and plot survivor function/cumulative distribution function
for given combinations of covariates based on the fitted model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'smoothSurvReg'
survfit(formula, cov, logscale.cov, time0 = 0, plot = TRUE, cdf = FALSE,
   by, xlim, ylim = c(0, 1), xlab = "t", ylab, 
   type = "l", lty, main, sub, legend, bty = "n", cex.legend = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survfit.smoothSurvReg_+3A_formula">formula</code></td>
<td>

<p>Object of class smoothSurvReg.
</p>
</td></tr>
<tr><td><code id="survfit.smoothSurvReg_+3A_cov">cov</code></td>
<td>

<p>Vector or matrix with covariates values for which the survivor curve/cdf
is to be computed and plotted. It must be a matrix with as many columns as
is the number of covariates (interactions included) or the vector of length
equal to the number of covariates (interactions included). Intercept is not
to be included in <code>cov</code>. If <code>cov</code> is missing  a survivor curve
for the value of a covariate vector equal to zero is plotted. If there is
only intercept in the model the survivor curve based on the fitted error
distribution is always plotted.
</p>
</td></tr>
<tr><td><code id="survfit.smoothSurvReg_+3A_logscale.cov">logscale.cov</code></td>
<td>

<p>Vector or matrix with covariate values for the expression of log-scale
(if this depended on covariates).
It can be omitted in the case that log-scale was common for all observations. 
</p>
</td></tr> 
<tr><td><code id="survfit.smoothSurvReg_+3A_time0">time0</code></td>
<td>

<p>Starting time of the follow-up as used in the model. I.e. the
model is assumed to be <code class="reqn">\log(T-time0) = x'\beta + 
	\sigma\varepsilon</code> 
</p>
</td></tr>     
<tr><td><code id="survfit.smoothSurvReg_+3A_plot">plot</code></td>
<td>

<p>If <code>TRUE</code> the plot is directly produced, otherwise only a <code>data.frame</code>
with information used for later plotting is returned.
</p>
</td></tr>
<tr><td><code id="survfit.smoothSurvReg_+3A_cdf">cdf</code></td>
<td>

<p>If <code>TRUE</code> cumulative distribution function is plotted instead of
the survivor function.
</p>
</td></tr>
<tr><td><code id="survfit.smoothSurvReg_+3A_by">by</code></td>
<td>

<p>Step for a ploting grid. If <code>NULL</code> it is automatically computed.
</p>
</td></tr>
<tr><td><code id="survfit.smoothSurvReg_+3A_xlim">xlim</code>, <code id="survfit.smoothSurvReg_+3A_ylim">ylim</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="survfit.smoothSurvReg_+3A_xlab">xlab</code>, <code id="survfit.smoothSurvReg_+3A_ylab">ylab</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="survfit.smoothSurvReg_+3A_type">type</code>, <code id="survfit.smoothSurvReg_+3A_lty">lty</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="survfit.smoothSurvReg_+3A_main">main</code>, <code id="survfit.smoothSurvReg_+3A_sub">sub</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="survfit.smoothSurvReg_+3A_legend">legend</code>, <code id="survfit.smoothSurvReg_+3A_bty">bty</code></td>
<td>

<p>Argument passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
<tr><td><code id="survfit.smoothSurvReg_+3A_cex.legend">cex.legend</code></td>
<td>
<p>argument passed to <code>cex</code> argument of the
<code><a href="graphics.html#topic+legend">legend</a></code> function.
</p>
</td></tr>    
<tr><td><code id="survfit.smoothSurvReg_+3A_...">...</code></td>
<td>

<p>Arguments passed to the <code><a href="graphics.html#topic+plot">plot</a></code> function.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe with columns named <code>x</code> and <code>y</code> where <code>x</code> gives the grid
and <code>y</code> the values of the survivor/cum. distribution function at that grid.
</p>


<h3>Author(s)</h3>

<p>Arnošt Komárek <a href="mailto:arnost.komarek@mff.cuni.cz">arnost.komarek@mff.cuni.cz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+smoothSurvReg">smoothSurvReg</a></code>, <code><a href="graphics.html#topic+plot">plot</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
