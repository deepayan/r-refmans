<!DOCTYPE html><html><head><title>Help for package WrightMap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {WrightMap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#WrightMap'>
<p>Wright Map: IRT Item-Person Map</p></a></li>
<li><a href='#CCCfit'>
<p>Empirical category characteristic curve plot for the Partial Credit Model</p></a></li>
<li><a href='#CQmodel'><p>ConQuest Output Processing</p></a></li>
<li><a href='#extract.deltas'>
<p>Extract Master's Delta parameters from a TAM model.</p></a></li>
<li><a href='#fitgraph'>
<p>Item Fit Graphs</p></a></li>
<li><a href='#ICCfit'>
<p>Empirical item characteristic curve plot for the Rasch Model~</p></a></li>
<li><a href='#item.person.data'>
<p>Processing CQmodel objects for plotting</p></a></li>
<li><a href='#item.side'><p>Wright Map item sides</p></a></li>
<li><a href='#make.deltas'>
<p>Calculate Master's Delta parameters.</p></a></li>
<li><a href='#make.thresholds'>
<p>Calculate Thurstonian thresholds.</p></a></li>
<li><a href='#person.side'>
<p>Wright Map person sides</p></a></li>
<li><a href='#plotCI'>
<p>Plotting confidence intervals and DIF</p></a></li>
<li><a href='#ppPlot'><p>Person probability plots</p></a></li>
<li><a href='#wrightMap'>
<p>wrightMap: item-person maps</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>IRT Item-Person Map with 'ConQuest' Integration</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-06-18</td>
</tr>
<tr>
<td>Author:</td>
<td>David Torres Irribarra &amp; Rebecca Freund</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Torres Irribarra &lt;david@torresirribarra.me&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A powerful yet simple graphical tool available in the field of psychometrics is the Wright Map (also known as item maps or item-person maps), which presents the location of both respondents and items on the same scale. Wright Maps are commonly used to present the results of dichotomous or polytomous item response models. The 'WrightMap' package provides functions to create these plots from item parameters and person estimates stored as R objects. Although the package can be used in conjunction with any software used to estimate the IRT model (e.g. 'TAM', 'mirt', 'eRm' or 'IRToys' in 'R', or 'Stata', 'Mplus', etc.),  'WrightMap' features special integration with 'ConQuest' to facilitate reading and plotting its output directly.The 'wrightMap' function creates Wright Maps based on person estimates and item parameters produced by an item response analysis. The 'CQmodel' function reads output files created using 'ConQuest' software and creates a set of data frames for easy data manipulation, bundled in a 'CQmodel' object. The 'wrightMap' function can take a 'CQmodel' object as input or it can be used to create Wright Maps directly from data frames of person and item parameters.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, RColorBrewer</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-06-18 19:43:24 UTC; dti</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-06-18 20:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='WrightMap'>
Wright Map: IRT Item-Person Map
</h2><span id='topic+WrightMap-package'></span><span id='topic+WrightMap'></span>

<h3>Description</h3>

<p>This package allows the easy generation of &lsquo;Wright Maps&rsquo; (named after Ben Wright), also known as item-person maps to display unidimensional and multidimensional assessment results. These maps represent simultaneously the proficiency distribution of respondents and the item difficulty parameters as estimated by a model of the Rasch Family. The package contains several other functions for graphing common IRT statistics.
</p>
<p>Additionally, the package contains the <code>CQmodel</code> function, which reads output files created using ConQuest software and creates a set of data frames for easy data manipulation, bundled in a CQmodel object. The wrightMap function can take a CQmodel object as input or it can be used to create Wright Maps directly from data frames of person and item parameters.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> WrightMap</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2014-03-02</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> BSD_3_clause | LICENSE </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>The wrightMap function relies on two main inputs: (a) <code>thetas</code>: a vector or matrix of respondent proficiences, and (b) <code>thresholds</code>: a vector or matrix of item thresholds. In the simplest case, say for a unidimensional Rasch model, <code>thetas</code> can be a vector of person proficiencies and <code>thresholds</code> a vector of item difficulties. 
</p>
<p>To plot multiple dimensions of person proficiency, simply provide them as a matrix were the results for each dimension is stored in a different column, such that for a 3-dimensional model with 1,000 persons, <code>theta</code> is a matrix of 1000 rows and 3 columns. 
</p>
<p>To plot polytomous items, the thresholds for each level must be passed to the functions through the <code>thresholds</code> matrix, where each row represents an item and each column represents a level. For instance, if the results of a Rating Scale model with 5 response categories and 10 items is being plotted, the <code>thresholds</code> matrix will have 10 rows and 4 columns ( column one represents the thresholds between the 1 and 2 response category, column 2 the threshold between categories 2 and 3, etc.).
</p>
<p>Alternatively, wrightMap can read directly the <code>.shw</code> and <code>.eap/.mle/.wle</code> output files from a Conquest analysis, and will automatically generate the <code>thetas</code> and <code>thresholds</code> matrices.
</p>


<h3>Author(s)</h3>

<p>David Torres Irribarra and Rebecca Freund
</p>
<p>Maintainer: David Torres Irribarra &lt;dti@berkeley.edu&gt; and Rebecca Freund &lt;rlfreund@berkeley.edu&gt;
</p>


<h3>References</h3>

<p>Andrich, D. (1978). A rating formulation for ordered response categories. <em>Psychometrika</em>, <em>43</em>(4), 561&ndash;573. 
Masters, G. N. (1982). A Rasch model for partial credit scoring. <em>Psychometrika</em>, <em>47</em>(2), 149&ndash;174. 
Wilson, M. (2005). Constructing measures: An item response modeling approach. 
Wright, B. D. and Stone, M. H. (1979). <em>Best test design.</em> Chicago: Mesa Press. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Plotting results of a unidimensional Rasch Model

## Mock results
	uni.proficiency &lt;- rnorm(1000, mean =  -0.5, sd = 1)
	difficulties  &lt;- sort( rnorm( 20))

## Default map
wrightMap( uni.proficiency, difficulties)

## Density version
wrightMap( uni.proficiency, difficulties, person.side = personDens)

# Plotting results of a multidimensional Rasch Model

## Mock results
	multi.proficiency &lt;- data.frame(
		d1 = rnorm(1000, mean =  -0.5, sd = 1),
		d2 = rnorm(1000, mean =   0.0, sd = 1),
		d3 = rnorm(1000, mean =  +0.5, sd = 1))

	difficulties  &lt;- sort( rnorm( 20))

dev.new(width=10, height=10)
wrightMap( multi.proficiency, difficulties)

# Plotting results of a unidimensional Rating Scale Model

## Mock results
	uni.proficiency &lt;- rnorm(1000, mean =  -0.5, sd = 1)

	items.loc &lt;- sort( rnorm( 20))
	thresholds &lt;- data.frame(
		l1 = items.loc - 0.5,
		l2 = items.loc - 0.25,
		l3 = items.loc + 0.25,
		l4 = items.loc + 0.5)

dev.new(width=10, height=10)
wrightMap( uni.proficiency, thresholds)

## Setting up labels, colors and symbols

	thresholds.labels &lt;- data.frame(
		l1 = paste('Lev',rep(1,20),sep = ''),
		l2 = paste('Lev',rep(2,20),sep = ''),
		l3 = paste('Lev',rep(3,20),sep = ''),
		l4 = paste('Lev',rep(4,20),sep = ''))

	thresholds.colors &lt;- data.frame(
		l1 = rep(  'green',20),
		l2 = rep(    'red',20),
		l3 = rep( 'yellow',20),
		l4 = rep(   'blue',20))

	thresholds.symbols &lt;- data.frame(
		l1 = rep( 15,20),
		l2 = rep( 16,20),
		l3 = rep( 17,20),
		l4 = rep( 18,20))

dev.new(width=10, height=10)
wrightMap( uni.proficiency, thresholds
	, thr.lab.text = thresholds.labels
	, thr.lab.col = thresholds.colors
	, thr.sym.pch = thresholds.symbols
	)

</code></pre>

<hr>
<h2 id='CCCfit'>
Empirical category characteristic curve plot for the Partial Credit Model
</h2><span id='topic+CCCfit'></span>

<h3>Description</h3>

<p>The <code>CCCfit</code> function is intended for contrasting a Rasch model's expected category characteristic curve against the empirical data from observed responses. The <code>CCCfit</code> function displays the expected probability asociated with all response categories and plots the observed response proportions for all non-zero response categories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCCfit(itemNumber, observedResponses, personEstimates, 
    itemParameters, xlim = c(-4, 4), method = "Quantile", NQtiles = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CCCfit_+3A_itemnumber">itemNumber</code></td>
<td>

<p>The position of the item in the test. This position is used to select the column of observed responses and the item difficulty among the item parameters.
</p>
</td></tr>
<tr><td><code id="CCCfit_+3A_observedresponses">observedResponses</code></td>
<td>

<p>Data frame or matrix with observed responses. The data frame or matrix should be of size  N * I, where N is the number of respondents and I is the number of items in the model.
</p>
</td></tr>
<tr><td><code id="CCCfit_+3A_personestimates">personEstimates</code></td>
<td>

<p>A vector of length N containing the model based person estimates or predictions.
</p>
</td></tr>
<tr><td><code id="CCCfit_+3A_itemparameters">itemParameters</code></td>
<td>

<p>A data frame or matrix with I rows (one for each item) and M columns, where M is equal to the maximum number of item scores minus 1. This matrix contains the model based estimates for the step parameters (deltas), where column 1 contains the parameter associated with the step between category 0 versus category 1, column 2 the step parameters of category 1 versus category 2, and so on.
</p>
</td></tr>
<tr><td><code id="CCCfit_+3A_xlim">xlim</code></td>
<td>

<p>Vector with two values indicating the minimum and maximum values to be used when plotting the item characteristic curve.
</p>
</td></tr>
<tr><td><code id="CCCfit_+3A_method">method</code></td>
<td>

<p>Selects the <code>Quantile</code> method to group the respondents (see &lsquo;Details&rsquo;).
</p>
</td></tr>
<tr><td><code id="CCCfit_+3A_nqtiles">NQtiles</code></td>
<td>

<p>This value controls how many grouping will be used: 4 groups cases groups respondents by quartiles, 5 by quintiles, 10 by deciles, etc.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the step difficulty parameters to generate the model based curve. The observed responses are then grouped using the <code>Quantile</code> method in order to contrast the model predicted response probability with the observed proportion (this is the only method implemented so far). By default the function uses deciles to generate the respondent groups.
</p>


<h3>Author(s)</h3>

<p>David Torres Irribarra
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ICCfit">ICCfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (itemNumber, observedResponses, personEstimates, itemParameters, 
    xlim = c(-4, 4), method = "Quantile", NQtiles = 10) 
{
    curve.cols &lt;- paste(RColorBrewer::brewer.pal(n = 8, name = "Dark2"), 
        "40", sep = "")
    points.cols &lt;- RColorBrewer::brewer.pal(n = 8, name = "Dark2")
    deltas &lt;- itemParameters[itemNumber, ]
    deltas &lt;- deltas[!is.na(deltas)]
    maxCat &lt;- length(deltas)
    probCCC &lt;- function(theta, deltas) {
        original.length &lt;- length(deltas) + 1
        deltas &lt;- deltas[!is.na(deltas)]
        deltas &lt;- c(0, deltas)
        lN &lt;- length(deltas)
        M &lt;- matrix(rep(NA, lN), ncol = lN)
        CM &lt;- matrix(rep(NA, lN), ncol = lN)
        M[, 1] &lt;- 0
        CM[, 1] &lt;- 1
        for (k in 2:lN) {
            M[, k] &lt;- M[, (k - 1)] + theta - deltas[k]
            CM[, k] &lt;- CM[, (k - 1)] + exp(M[, k])
        }
        output &lt;- exp(M)/CM[, k]
        length(output) &lt;- original.length
        output
    }
    categoryProbs &lt;- sapply(seq(xlim[1], xlim[2], length = 100), 
        probCCC, deltas = deltas)
    plot(seq(xlim[1], xlim[2], length = 100), categoryProbs[1, 
        ], type = "n", axes = FALSE, xlab = "Proficiency", ylab = "Proportion", 
        ylim = c(0, 1))
    axis(2, las = 1)
    axis(1)
    lines(seq(xlim[1], xlim[2], length = 100), categoryProbs[1, 
        ], type = "l", lwd = 3, lty = 1, col = "grey80")
    nCats &lt;- length(deltas) + 1
    for (i in 2:nCats) {
        lines(seq(xlim[1], xlim[2], length = 100), categoryProbs[i, 
            ], lwd = 3, col = curve.cols[i - 1])
    }
    if (method == "Quantile") {
        agg.data &lt;- list()
        size.data &lt;- list()
        for (i in 1:maxCat) {
            recodedResponses &lt;- observedResponses == i
            cutPoints &lt;- quantile(personEstimates, seq(0, 1, 
                length = NQtiles + 1))
            agg.data[[i]] &lt;- aggregate(recodedResponses, by = list(cut(personEstimates, 
                cutPoints)), FUN = mean, na.rm = TRUE)
            breakMeans &lt;- aggregate(personEstimates, by = list(cut(personEstimates, 
                cutPoints)), FUN = mean, na.rm = TRUE)
            agg.data[[i]][, 1] &lt;- breakMeans[, 2]
            agg.data[[i]][, -1][agg.data[[i]][, -1] == 1] &lt;- 0.999
            agg.data[[i]][, -1][agg.data[[i]][, -1] == 0] &lt;- 0.001
            size.data[[i]] &lt;- aggregate(is.na(recodedResponses), 
                by = list(cut(personEstimates, cutPoints)), FUN = length)
            size.data[[i]][, 1] &lt;- breakMeans[, 2]
            points(agg.data[[i]][, 1], agg.data[[i]][, itemNumber + 
                1], type = "b", pch = i, cex = 0.75, col = points.cols[i], 
                lwd = 2)
        }
    }
    legend("right", horiz = FALSE, legend = paste("Cat", seq(1:maxCat)), 
        col = points.cols[1:maxCat], pch = 1:maxCat, cex = 0.8, 
        bty = "n")
    title(paste("Item", itemNumber))
  }
</code></pre>

<hr>
<h2 id='CQmodel'>ConQuest Output Processing</h2><span id='topic+CQmodel'></span><span id='topic+print.CQmodel'></span><span id='topic+print.SOE'></span>

<h3>Description</h3>

<p>The CQmodel function reads ConQuest item parameter and person parameter output files and converts them into a list of data frames for more convenient data processing.</p>


<h3>Usage</h3>

<pre><code class='language-R'>CQmodel(p.est = NULL, show = NULL, p.type = NULL, equation = NULL)
## S3 method for class 'CQmodel'
print(x,...)
## S3 method for class 'SOE'
print(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CQmodel_+3A_p.est">p.est</code></td>
<td>
<p> Conquest person parameters file (EAPs, MLEs, etc.). </p>
</td></tr>
<tr><td><code id="CQmodel_+3A_show">show</code></td>
<td>
<p> ConQuest show file. </p>
</td></tr>
<tr><td><code id="CQmodel_+3A_p.type">p.type</code></td>
<td>
<p> Type of person parameter estimate (EAP, MLE or WLE). If not specified, will try to determine from the extension of the p.est file. </p>
</td></tr>
<tr><td><code id="CQmodel_+3A_equation">equation</code></td>
<td>
<p> String giving the model equation, if the Summary of Estimation table was not included in the show file.</p>
</td></tr>
<tr><td><code id="CQmodel_+3A_x">x</code></td>
<td>
<p> Object that determines which function to call. </p>
</td></tr>
<tr><td><code id="CQmodel_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>CQmodel returns an object of type CQmodel. Usually contains:
Tables:
</p>
<table>
<tr><td><code>RMP</code></td>
<td>
<p> A list of data frames containing the response model parameter estimates. One data frame is created for each table in the output. Each data frame contains parameter estimates, errors, and fit information.</p>
</td></tr>
<tr><td><code>GIN</code></td>
<td>
<p> A matrix containing the item thresholds (if included in the ConQuest output). The rows are items and the columns are steps.</p>
</td></tr>
<tr><td><code>p.est</code></td>
<td>
<p> A data frame containing the person parameter estimates </p>
</td></tr>
</table>
<p>Summary of estimation:
</p>
<table>
<tr><td><code>SOE</code></td>
<td>
<p>A list of various parameters related to the estimation</p>
</td></tr>
</table>
<p>Items that may be in the SOE list include:
</p>
<table>
<tr><td><code>method</code></td>
<td>
<p> Estimation method </p>
</td></tr>
<tr><td><code>distribution</code></td>
<td>
<p> Assumed population distribution </p>
</td></tr>
<tr><td><code>constraint</code></td>
<td>
<p> Constraint</p>
</td></tr>
<tr><td><code>format</code></td>
<td>
<p> Specified format of the datafile </p>
</td></tr>
<tr><td><code>equation</code></td>
<td>
<p> A character string containing the item model (e.g. &quot;item+item*step&quot;) </p>
</td></tr>
<tr><td><code>participants</code></td>
<td>
<p> Sample size </p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p> Final deviance of the model </p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p> Total number of estimated parameters </p>
</td></tr>
<tr><td><code>iterations</code></td>
<td>
<p> Number of iterations </p>
</td></tr>
<tr><td><code>seed</code></td>
<td>
<p> Random number generation seed </p>
</td></tr>
<tr><td><code>PV.nodes</code></td>
<td>
<p> Number of nodes used when drawing PVs </p>
</td></tr>
<tr><td><code>fit.nodes</code></td>
<td>
<p> Number of nodes used when computing fit </p>
</td></tr>
<tr><td><code>n.plausible.values</code></td>
<td>
<p> Number of plausible values drawn </p>
</td></tr>
<tr><td><code>max.iterations.no.improvement</code></td>
<td>
<p> Maximum number of iterations without a deviance improvement </p>
</td></tr>
<tr><td><code>max.steps</code></td>
<td>
<p> Maximum number of Newton steps in M-step </p>
</td></tr>
<tr><td><code>zero.perfect.value</code></td>
<td>
<p> Value for obtaining finite MLEs for zero/perfects </p>
</td></tr>
<tr><td><code>termination.reason</code></td>
<td>
<p> Reason for iteration termination </p>
</td></tr>
<tr><td><code>max.iterations</code></td>
<td>
</td></tr>
<tr><td><code>parameter.change</code></td>
<td>
</td></tr>
<tr><td><code>deviance.change</code></td>
<td>
</td></tr>
</table>
<p>Run details:
</p>
<table>
<tr><td><code>run.details</code></td>
<td>
<p> A list of details of the run </p>
</td></tr>
</table>
<p>Items that may be included in the run.details list include:
</p>
<table>
<tr><td><code>date</code></td>
<td>
<p> The date of the ConQuest run </p>
</td></tr>
<tr><td><code>data.file</code></td>
<td>
<p> The name of the datafile used </p>
</td></tr>
<tr><td><code>format</code></td>
<td>
<p> The specified format of the datafile </p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p> Names of items and/or dimensions </p>
</td></tr>
</table>
<p>Additional items:
</p>
<table>
<tr><td><code>deviance</code></td>
<td>
<p> The deviance of the model </p>
</td></tr>
<tr><td><code>equation</code></td>
<td>
<p> A character string containing the model specification (e.g. &quot;item+item*step&quot;) </p>
</td></tr>
<tr><td><code>participants</code></td>
<td>
<p> The number of participants </p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p> The number of parameters </p>
</td></tr>
<tr><td><code>title</code></td>
<td>
<p> The run title </p>
</td></tr>
<tr><td><code>reg.coef</code></td>
<td>
<p> Regression coefficients </p>
</td></tr>
<tr><td><code>rel.coef</code></td>
<td>
<p> Reliability coefficients </p>
</td></tr>
<tr><td><code>variances</code></td>
<td>
</td></tr>
<tr><td><code>nDim</code></td>
<td>
<p> Number of dimensions </p>
</td></tr>
<tr><td><code>dimensions</code></td>
<td>
<p> Dimension names </p>
</td></tr>
<tr><td><code>p.est.type</code></td>
<td>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rebecca Freund and David Torres Irribarra</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
fpath &lt;- system.file("extdata", package="WrightMap")

# Partial credit model
model1 &lt;- CQmodel(p.est = file.path(fpath,"ex2.eap"), 
show = file.path(fpath,"ex2.shw")) 
model1 #Shows what tables are available

model1$SOE #Summary of estimation
model1$equation # Model specification
model1$reg.coef # Regression coefficients
model1$rel.coef # Reliability coefficients
model1$variances # Variances

names(model1$RMP) # Names of parameter tables
head(model1$RMP$item) #Item parameters
head(model1$RMP$"item*step") #Item by step parameters

# Complex model
model2 &lt;- CQmodel(file.path(fpath,"ex4a.mle"), 
file.path(fpath,"ex4a.shw")) 
model2$equation # Model specification
names(model2$RMP) # Names of parameter tables
head(model2$RMP$"rater*topic*criteria*step") #An interaction table

model1$GIN #Item thresholds
model2$GIN #Item thresholds

head(model1$p.est)  ##EAPs
head(model2$p.est)  ##MLEs

</code></pre>

<hr>
<h2 id='extract.deltas'>
Extract Master's Delta parameters from a TAM model.
</h2><span id='topic+extract.deltas'></span>

<h3>Description</h3>

<p>This function takes as its input a TAM object. It adds reads the TAM item parameters and organizes them into a matrix that can be used as input in the <code><a href="#topic+CCCfit">CCCfit</a></code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract.deltas(tamObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract.deltas_+3A_tamobject">tamObject</code></td>
<td>

<p>TAM object containing the results of a a Rasch model or Partial Credit model.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function organizes the item parameter results into a matrix where each row is contains the parameters associated with an item and each columns is contains the parameters associated with a specific step (score 0 vs score 1, score 1 vs score 2, etc.). The resulting matrix will have as many rows as items and as many columns as the maximum number of steps among the items.
</p>


<h3>Value</h3>

<p>A matrix in which each row is an item and each column is a step
</p>


<h3>Author(s)</h3>

<p>David Torres Irribarra
</p>


<h3>References</h3>

<p>Masters, G. N. (1982). A Rasch model for partial credit scoring. <em>Psychometrika</em>, 47(2), 149-174. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CCCfit">CCCfit</a></code>
<code><a href="#topic+make.thresholds">make.thresholds</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (tamObject) 
{
    delta.long &lt;- tamObject$xsi
    n.deltas &lt;- apply(tamObject$B, 1, max)
    delta.mat &lt;- matrix(NA, nrow = length(n.deltas), ncol = max(n.deltas))
    matCoords.row &lt;- rep(1:length(n.deltas), n.deltas)
    matCoords.col &lt;- c()
    for (i in 1:length(n.deltas)) {
        for (j in 1:n.deltas[i]) {
            matCoords.col &lt;- c(matCoords.col, j)
        }
    }
    delta.long$matCoords.row &lt;- matCoords.row
    delta.long$matCoords.col &lt;- matCoords.col
    for (k in 1:nrow(delta.long)) {
        delta.mat[delta.long$matCoords.row[k], delta.long$matCoords.col[k]] &lt;- delta.long$xsi[k]
    }
    delta.mat
  }
</code></pre>

<hr>
<h2 id='fitgraph'>
Item Fit Graphs
</h2><span id='topic+fitgraph'></span><span id='topic+fitgraph.default'></span><span id='topic+fitgraph.CQmodel'></span><span id='topic+fitgraph.character'></span><span id='topic+fitgraph.numeric'></span>

<h3>Description</h3>

<p>This function creates a graphical summary of the item fit information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## Default S3 method:
fitgraph(fitEst, fitLB, fitUB, itemLabels, mainTitle = "Fit Plot", 
pch = 18, fitColours = c("gray70", "gray60", "gray50", "gray40", "gray0"), 
xlab = "Items", cex = 1.25, ...)
## S3 method for class 'numeric'
fitgraph(fitEst, fitLB, fitUB, itemLabels, mainTitle = "Fit Plot", 
pch = 18, fitColours = c("gray70", "gray60", "gray50", "gray40", "gray0"), 
xlab = "Items", cex = 1.25, ...)
## S3 method for class 'CQmodel'
fitgraph(fitEst, table = NULL, fit.type = "W", itemLabels = NULL, ...)
## S3 method for class 'character'
fitgraph(fitEst, ...)
</code></pre>


<h3>Arguments</h3>

<p>fitgraph arguments: 	
</p>
<table>
<tr><td><code id="fitgraph_+3A_fitest">fitEst</code></td>
<td>

<p>vector of item fit estimates. Could also be a CQmodel object or name of a ConQuest show file.
</p>
</td></tr>
<tr><td><code id="fitgraph_+3A_fitlb">fitLB</code></td>
<td>

<p>vector of lower bounds for critical intervals for each item.
</p>
</td></tr>
<tr><td><code id="fitgraph_+3A_fitub">fitUB</code></td>
<td>

<p>vector of upper bounds for critical intervals for each item.</p>
</td></tr>
<tr><td><code id="fitgraph_+3A_itemlabels">itemLabels</code></td>
<td>

<p>vector of item labels.
</p>
</td></tr>
<tr><td><code id="fitgraph_+3A_maintitle">mainTitle</code></td>
<td>

<p>string containing the title of the plot.
</p>
</td></tr>
<tr><td><code id="fitgraph_+3A_pch">pch</code></td>
<td>

<p>number or vector indicating the type of symbols to be used for each item.
</p>
</td></tr>
<tr><td><code id="fitgraph_+3A_fitcolours">fitColours</code></td>
<td>

<p>Color that will be used to shade the critical inteval area.
</p>
</td></tr>
<tr><td><code id="fitgraph_+3A_xlab">xlab</code></td>
<td>

<p>Label of the x-axis. The default is 'items'.
</p>
</td></tr>
<tr><td><code id="fitgraph_+3A_cex">cex</code></td>
<td>

<p>Size of the x-axis label.
</p>
</td></tr>
<tr><td><code id="fitgraph_+3A_...">...</code></td>
<td>

<p>Additional parameters.
</p>
</td></tr>
</table>
<p>Argument to use when passing a CQmodel object:
</p>
<table>
<tr><td><code id="fitgraph_+3A_table">table</code></td>
<td>

<p>Name of the RMP table that for which the fit will be plotted. By default <code>fitgraph</code> will plot the first RMP table of the CQmodel object, this argument overrides this default.
</p>
</td></tr>
<tr><td><code id="fitgraph_+3A_fit.type">fit.type</code></td>
<td>

<p>Type of fit estimate that will be used, it can be <code>W</code> for Weighted Fit (i.e. Infit, the default), or <code>U</code> for Unweighted Fit (i.e. Outfit). Called <code>type</code> in previous versions; use of that parameter is deprecated to avoid collision with the <code>type</code> parameter in the <code>link{plot}</code> function.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Torres Irribarra and Rebecca Freund.
</p>


<h3>References</h3>

<p>Wilson, M. (2005). Constructing measures: An item response modeling approach. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generating mock data
sampleLabels &lt;- paste('item',1:10)

fitBounds &lt;- (abs(rnorm(10, mean = 0, sd = .05)) * 2)
fitEst &lt;- rnorm(10, mean = 1, sd = .1)

fitLB &lt;- 1 - fitBounds
fitUB &lt;- 1 + fitBounds
par("mar")
# running fitgraph
fitgraph(fitEst,fitLB,fitUB,itemLabels=sampleLabels)

#From ConQuest output:
	
	fpath &lt;- system.file("extdata", package="WrightMap")

	fitgraph(file.path(fpath,"ex2.shw"))



</code></pre>

<hr>
<h2 id='ICCfit'>
Empirical item characteristic curve plot for the Rasch Model~
</h2><span id='topic+ICCfit'></span>

<h3>Description</h3>

<p>The <code>ICCfit</code> function is intended for contrasting a Rasch model's expected item characteristic curve against the empirical data from dichotomous responses. The <code>ICCfit</code> function displays a confidence interval for the model based curve and plots the confidence interval for the empirical proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICCfit(itemNumber, observedResponses, personEstimates, 
    itemParameters, xlim = c(-4, 4), method = "Quantile", NQtiles = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICCfit_+3A_itemnumber">itemNumber</code></td>
<td>

<p>The position of the item in the test. This position is used to select the column of observed responses and the item difficulty among the item parameters.
</p>
</td></tr>
<tr><td><code id="ICCfit_+3A_observedresponses">observedResponses</code></td>
<td>

<p>Data frame or matrix with observed responses. The data frame or matrix should be of size  N * I, where N is the number of respondents and I is the number of items in the model.
</p>
</td></tr>
<tr><td><code id="ICCfit_+3A_personestimates">personEstimates</code></td>
<td>

<p>A vector of length N containing the model based person estimates or predictions.
</p>
</td></tr>
<tr><td><code id="ICCfit_+3A_itemparameters">itemParameters</code></td>
<td>

<p>A data frame or matrix of dimensions I * 2 containing the model based item difficulty estimates in the firs column and the parameter standard error in the second column.
</p>
</td></tr>
<tr><td><code id="ICCfit_+3A_xlim">xlim</code></td>
<td>

<p>Vector with two values indicating the minimum and maximum values to be used when plotting the item characteristic curve.
</p>
</td></tr>
<tr><td><code id="ICCfit_+3A_method">method</code></td>
<td>

<p>Selects the method used to group the respondents: <code>Quantile</code> (default), <code>ByPersonEstimate</code>, and <code>Histogram</code> (see &lsquo;Details&rsquo;).
</p>
</td></tr>
<tr><td><code id="ICCfit_+3A_nqtiles">NQtiles</code></td>
<td>

<p>When using the <code>Quantile</code> method this value controls how many grouping will be used: 4 groups cases groups respondents by quartiles, 5 by quintiles, 10 by deciles, etc.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the item difficulty parameter to generate the model based curve and the item difficulty parameter standard error to plot a confidence interval around the curve. The observed responses are then grouped using the selected method in order to contrast the model predicted response probability with the observed proportion. By default the function uses deciles to generate the respondent groups. The function allows the method <code>ByPersonEstimate</code> in order to make a different group for each observed person estimate (potentially useful when analyzing test data with large numbers with no missing data), and the <code>Histogram</code> method, which uses the Freedman-Diaconis algorithm to select the width of the bands used for grouping.
</p>


<h3>Author(s)</h3>

<p>David Torres Irribarra
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CCCfit">CCCfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##---- Should be DIRECTLY executable !! ----
##-- ==&gt;  Define data, use random,
##--	or do  help(data=index)  for the standard data sets.

## The function is currently defined as
function (itemNumber, observedResponses, personEstimates, itemParameters, 
    xlim = c(-4, 4), method = "Quantile", NQtiles = 10) 
{
    propCI &lt;- function(propVector, nVector, alpha = 0.05) {
        propSE &lt;- sqrt(propVector * (1 - propVector)/nVector)
        propLB &lt;- propVector - (propSE * qnorm(1 - (alpha/2)))
        propUB &lt;- propVector + (propSE * qnorm(1 - (alpha/2)))
        data.frame(propSE = propSE, propLB = propLB, propUB = propUB)
    }
    plotICC &lt;- function(difficulty, range = xlim) {
        invlogit &lt;- function(x) {
            1/(1 + exp(-x))
        }
        params &lt;- data.frame(ability = seq(-4, 4, length.out = 1000), 
            difficulty = difficulty)
        probs &lt;- invlogit(params[, 1] - params[, 2])
        lines(params[, 1], probs)
    }
    plotICCerrors &lt;- function(difficulty, dSE, range = xlim) {
        invlogit &lt;- function(x) {
            1/(1 + exp(-x))
        }
        params &lt;- data.frame(ability = seq(-4, 4, length.out = 1000), 
            lb = difficulty - 1.96 * dSE, ub = difficulty + 1.96 * 
                dSE)
        probslb &lt;- invlogit(params[, 1] - params[, 2])
        probsub &lt;- invlogit(params[, 1] - params[, 3])
        xCoords &lt;- c(ability = seq(-4, 4, length.out = 1000), 
            ability = seq(4, -4, length.out = 1000))
        yCoords &lt;- c(probslb, rev(probsub))
        polygon(xCoords, yCoords, col = "grey75", border = NA)
    }
    if (method == "ByPersonEstimate") {
        aggdata &lt;- aggregate(observedResponses, by = list(round(personEstimates, 
            2)), FUN = mean, na.rm = TRUE)
        aggdata[, -1][aggdata[, -1] == 1] &lt;- 0.999
        aggdata[, -1][aggdata[, -1] == 0] &lt;- 0.001
        sampleSizeAggdata &lt;- aggregate(is.na(observedResponses), 
            by = list(round(personEstimates, 2)), FUN = length)
    }
    if (method == "Quantile") {
        cutPoints &lt;- quantile(personEstimates, seq(0, 1, length = NQtiles + 
            1))
        aggdata &lt;- aggregate(observedResponses, by = list(cut(personEstimates, 
            cutPoints)), FUN = mean, na.rm = TRUE)
        breakMeans &lt;- aggregate(personEstimates, by = list(cut(personEstimates, 
            cutPoints)), FUN = mean, na.rm = TRUE)
        aggdata[, 1] &lt;- breakMeans[, 2]
        aggdata[, -1][aggdata[, -1] == 1] &lt;- 0.999
        aggdata[, -1][aggdata[, -1] == 0] &lt;- 0.001
        sampleSizeAggdata &lt;- aggregate(is.na(observedResponses), 
            by = list(cut(personEstimates, cutPoints)), FUN = length)
        sampleSizeAggdata[, 1] &lt;- breakMeans[, 2]
    }
    if (method == "Histogram") {
        histData &lt;- hist(personEstimates, breaks = "FD", plot = FALSE)
        cutPoints &lt;- histData$breaks
        aggdata &lt;- aggregate(observedResponses, by = list(cut(personEstimates, 
            cutPoints)), FUN = mean, na.rm = TRUE, drop = FALSE)
        breakMeans &lt;- aggregate(personEstimates, by = list(cut(personEstimates, 
            cutPoints)), FUN = mean, na.rm = TRUE, drop = FALSE)
        aggdata[, 1] &lt;- histData$mids
        aggdata[, -1][aggdata[, -1] == 1] &lt;- 0.999
        aggdata[, -1][aggdata[, -1] == 0] &lt;- 0.001
        sampleSizeAggdata &lt;- aggregate(is.na(observedResponses), 
            by = list(cut(personEstimates, cutPoints)), FUN = length, 
            drop = FALSE)
        sampleSizeAggdata[, 1] &lt;- histData$mids
    }
    plot(aggdata[, 1], aggdata[, itemNumber + 1], type = "n", 
        axes = FALSE, , ylab = "Proportion", xlab = "Proficiency", 
        ylim = c(0, 1), xlim = xlim)
    plotICCerrors(itemParameters[itemNumber, 1], itemParameters[itemNumber, 
        2])
    plotICC(itemParameters[itemNumber, 1])
    cbind(aggdata[, 1], propCI(aggdata[, itemNumber + 1], sampleSizeAggdata[, 
        itemNumber + 1]))
    apply(cbind(aggdata[, 1], propCI(aggdata[, itemNumber + 1], 
        sampleSizeAggdata[, itemNumber + 1])), 1, function(x) segments(x0 = x[1], 
        y0 = x[3], x1 = x[1], y1 = x[4], col = "#31333450"))
    points(aggdata[, 1], aggdata[, itemNumber + 1], pch = 18, 
        cex = 0.75, col = "#31333450")
    axis(2, las = 1)
    axis(1)
    title(paste("Item", rownames(itemParameters)[itemNumber]))
    print(sampleSizeAggdata)
  }
</code></pre>

<hr>
<h2 id='item.person.data'>
Processing CQmodel objects for plotting
</h2><span id='topic+item.person.data'></span><span id='topic+itemData'></span><span id='topic+itemData.default'></span><span id='topic+itemData.CQmodel'></span><span id='topic+itemData.character'></span><span id='topic+personData'></span><span id='topic+personData.default'></span><span id='topic+personData.CQmodel'></span><span id='topic+personData.character'></span>

<h3>Description</h3>

<p>The <code>itemData</code> and <code>personData</code> functions take CQmodel objects (or ConQuest output files) as inputs and return a vector or matrix. They were originally developed for use by <code><a href="#topic+wrightMap">wrightMap</a></code>, but are separated out here to allow the outputs to be sent to other plotting functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemData(thresholds, ...)
## Default S3 method:
itemData(thresholds, item.type = "deltas",...)
## S3 method for class 'character'
itemData(thresholds, p.type = NULL, equation = NULL, ...)
## S3 method for class 'CQmodel'
itemData(thresholds, item.table = NULL, interactions = NULL, 
step.table = NULL, item.type = "default", throld = 0.5, ...)

personData(thetas,...)
## Default S3 method:
personData(thetas,...)
## S3 method for class 'character'
personData(thetas, p.type = NULL,...)
## S3 method for class 'CQmodel'
personData(thetas,...)
</code></pre>


<h3>Arguments</h3>

<p>itemData arguments:
</p>
<table>
<tr><td><code id="item.person.data_+3A_thresholds">thresholds</code></td>
<td>

<p>Usually, a CQmodel object or the name of a ConQuest show file. Will also accept a matrix, but this is only really for use within other functions. In general <code><a href="#topic+make.thresholds">make.thresholds</a></code> should be used instead.
</p>
</td></tr>
<tr><td><code id="item.person.data_+3A_item.type">item.type</code></td>
<td>

<p>Indicates whether to use <code>thresholds</code> or <code>deltas</code>.
</p>
</td></tr>
<tr><td><code id="item.person.data_+3A_equation">equation</code></td>
<td>

<p>string giving the model equation, if the Summary of Estimation table was not included in the show file.
</p>
</td></tr>
<tr><td><code id="item.person.data_+3A_item.table">item.table</code></td>
<td>

<p>Name of RMP table to use for the main effect of the item parameters.
</p>
</td></tr>
<tr><td><code id="item.person.data_+3A_interactions">interactions</code></td>
<td>

<p>Name of RMP interaction table to use in addition to <code>item.table</code>.
</p>
</td></tr>
<tr><td><code id="item.person.data_+3A_step.table">step.table</code></td>
<td>

<p>Name of RMP table to use in addition to <code>item.table</code>.
</p>
</td></tr>
<tr><td><code id="item.person.data_+3A_throld">throld</code></td>
<td>

<p>The probability level to be used for calculating thresholds.
</p>
</td></tr>
<tr><td><code id="item.person.data_+3A_...">...</code></td>
<td>

<p>Additional parameters to pass to <code><a href="#topic+make.thresholds">make.thresholds</a></code>.
</p>
</td></tr>
</table>
<p>personData arguments:
</p>
<table>
<tr><td><code id="item.person.data_+3A_thetas">thetas</code></td>
<td>
<p>a CQModel object or the name of the Conquest person parameters file (EAPs, MLEs, etc.)</p>
</td></tr>
<tr><td><code id="item.person.data_+3A_p.type">p.type</code></td>
<td>
<p> Type of person parameter estimate (EAP, MLE or WLE). </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The itemData and personData functions are usually called by <code><a href="#topic+wrightMap">wrightMap</a></code>. They can also be called directly.
</p>
<p>For the itemData function, note that the <code>item.table</code>, <code>interactions</code>, and <code>step.table</code> parameters must be the exact name of specific RMP tables. You cannot specify an interactions table or a step table without also specifying an item table (although JUST an item table is fine). If your model equation is more complicated, you will have to either use a GIN table or specify in the function call which tables to use for what. A model of the form item + item * step + booklet, for example, will not run unless there is a GIN table or you have defined at least the item.table.
</p>


<h3>Value</h3>

<p>The itemData functions return a vector of item parameters, or a matrix in which the rows are items and the columns are steps. The personData functions return a vector of person paramenters, or a matrix in which the rows are persons and the columns are dimensions.
</p>


<h3>Author(s)</h3>

<p>Rebecca Freund and David Torres Irribarra </p>


<h3>See Also</h3>

<p><code><a href="#topic+item.side">item.side</a></code>
<code><a href="#topic+person.side">person.side</a></code>
<code><a href="#topic+make.thresholds">make.thresholds</a></code>
<code><a href="#topic+make.deltas">make.deltas</a></code>
<code><a href="#topic+wrightMap">wrightMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
#As a call from wrightMap:

fpath &lt;- system.file("extdata", package="WrightMap")

model1 &lt;- CQmodel(file.path(fpath,"ex2a.eap"), file.path(fpath,"ex2a.shw"))
# Making thresholds if there are no GIN tables (partial credit model)
	wrightMap(model1, type = "thresholds") 
	
#Complex model:

model2 &lt;- CQmodel(file.path(fpath,"ex4a.mle"), file.path(fpath,"ex4a.shw")) 
wrightMap(model2, item.table = "rater")
	wrightMap(model2, item.table = "rater", interactions = "rater*topic", 
  step.table = "topic")


# Plotting item results
	
	fpath &lt;- system.file("extdata", package="WrightMap")
	model3 &lt;- CQmodel(file.path(fpath,"ex2a.eap"), file.path(fpath,"ex2a.shw"))
	m3.item &lt;- itemData(model3)
	
	dev.new(width=10, height=10)
	
	#control of oma allows us to give more space to longer item names
	itemModern(m3.item, label.items.srt= 90, oma = c(2,0,0,2)) 
	itemClassic(m3.item)
	itemHist(m3.item)
	
	m3.person &lt;- personData(model3)
	personHist(m3.person)
	personDens(m3.person)
  </code></pre>

<hr>
<h2 id='item.side'>Wright Map item sides</h2><span id='topic+item.side'></span><span id='topic+itemClassic'></span><span id='topic+itemModern'></span><span id='topic+itemHist'></span>

<h3>Description</h3>

<p>Draw the item side of a Wright Map in a variety of styles. Intended to be primarily called by <code><a href="#topic+wrightMap">wrightMap</a></code>, but also available for use on their own.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itemModern(thr, yRange = NULL, axis.items = "Items", show.thr.sym = TRUE
, thr.sym.cex = 0.8, thr.sym.lwd = 1, thr.sym.pch = 23
, thr.sym.col.fg = rgb(0, 0, 0, 0.3), thr.sym.col.bg = rgb(0, 0, 0, 0.3)
, show.thr.lab = TRUE, thr.lab.pos = c(2, 4), thr.lab.text = NULL
, thr.lab.col = "black", thr.lab.cex = 0.5, thr.lab.font = 2, label.items.rows = 1
, label.items.srt = 0, label.items = NULL, label.items.cex = 0.6
, label.items.ticks = TRUE, axis.logits = "Logits", show.axis.logits = "R"
, oma = c(0, 0, 0, 3), cutpoints = NULL, vertLines = FALSE, ...)

itemClassic(thr, yRange = NULL, axis.items = "Items", axis.logits = "Logits"
, show.axis.logits = "R", oma = c(0, 0, 0, 3), cutpoints = NULL, ...)

itemHist(thr, yRange = NULL, axis.items = "Items", axis.logits = "Logits"
, show.axis.logits = "R", oma = c(0, 0, 0, 3), cutpoints = NULL,...)
</code></pre>


<h3>Arguments</h3>

<p>General arguments:
</p>
<table>
<tr><td><code id="item.side_+3A_thr">thr</code></td>
<td>
<p>vector or matrix of threshold parameters. If a matrix, items should be in the rows and steps in the columns.</p>
</td></tr>
<tr><td><code id="item.side_+3A_yrange">yRange</code></td>
<td>
<p> vector with 2 elements specifying the lower and upper limits of the plot's y-axis.</p>
</td></tr>
<tr><td><code id="item.side_+3A_axis.items">axis.items</code></td>
<td>
<p>title of the x-axis.</p>
</td></tr>
<tr><td><code id="item.side_+3A_axis.logits">axis.logits</code></td>
<td>
<p>title of the y-axis.</p>
</td></tr>
<tr><td><code id="item.side_+3A_show.axis.logits">show.axis.logits</code></td>
<td>
<p> if equal to &quot;R&quot; or &quot;L&quot;, draws a logit axis on the right or left. Will also draw an axis on the right if the value is 
codeTRUE. If any other value, the axis is not drawn.</p>
</td></tr>
<tr><td><code id="item.side_+3A_oma">oma</code></td>
<td>
<p>values to use for the <code>oma</code> parameter (see <code><a href="graphics.html#topic+par">par</a></code>)</p>
</td></tr>
<tr><td><code id="item.side_+3A_cutpoints">cutpoints</code></td>
<td>
<p>values at which to draw horizontal lines (see <code><a href="#topic+cutLines">cutLines</a></code>)</p>
</td></tr>
<tr><td><code id="item.side_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="#topic+cutLines">cutLines</a></code></p>
</td></tr>
</table>
<p>itemModern arguments:
</p>
<table>
<tr><td><code id="item.side_+3A_show.thr.sym">show.thr.sym</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the plot will show symbols for the item thresholds.
</p>
</td></tr>
<tr><td><code id="item.side_+3A_thr.sym.cex">thr.sym.cex</code></td>
<td>

<p>an integer, vector or matrix of numerical values giving the amount by which the threshold symbols should be magnified relative to the default.
</p>
</td></tr>
<tr><td><code id="item.side_+3A_thr.sym.lwd">thr.sym.lwd</code></td>
<td>

<p>an integer, vector or matrix of positive numbers specifying the width of the lines used in the threshold symbols.
</p>
</td></tr>
<tr><td><code id="item.side_+3A_thr.sym.pch">thr.sym.pch</code></td>
<td>

<p>an integer, vector or matrix of integers specifying a symbol or a single character to be used to represent the item thresholds.
</p>
</td></tr>
<tr><td><code id="item.side_+3A_thr.sym.col.fg">thr.sym.col.fg</code></td>
<td>

<p>an integer, vector or matrix of numerical values indicating the foreground color to be used in the thresholds labels. 
</p>
</td></tr>
<tr><td><code id="item.side_+3A_thr.sym.col.bg">thr.sym.col.bg</code></td>
<td>

<p>an integer, vector or matrix of numerical values indicating the background color to be used in the thresholds labels. 
</p>
</td></tr>
<tr><td><code id="item.side_+3A_show.thr.lab">show.thr.lab</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), the plot will show labels for the item thresholds. 
</p>
</td></tr>
<tr><td><code id="item.side_+3A_thr.lab.pos">thr.lab.pos</code></td>
<td>

<p>an integer, vector or matrix containing the position in which to display the label for each threshold label. Values of 1, 2, 3 and 4, respectively indicate positions below, to the left of, above and to the right of the specified coordinates. 
</p>
</td></tr>
<tr><td><code id="item.side_+3A_thr.lab.text">thr.lab.text</code></td>
<td>

<p>a matrix containing the labels to display for each threshold. In the matrix each row represents an item and each column represents a level.
</p>
</td></tr>
<tr><td><code id="item.side_+3A_thr.lab.col">thr.lab.col</code></td>
<td>

<p>a matrix containing the color to display for each threshold label. In the matrix each row represents an item and each column represents a level. 
</p>
</td></tr>
<tr><td><code id="item.side_+3A_thr.lab.cex">thr.lab.cex</code></td>
<td>

<p>an integer, vector or matrix of numerical values giving the amount by which the threshold labels should be magnified relative to the default.
</p>
</td></tr>
<tr><td><code id="item.side_+3A_thr.lab.font">thr.lab.font</code></td>
<td>

<p>an integer, vector or matrix which specifies which font to use for threshold labels. 1 corresponds to plain text , 2 to bold face (the default), 3 to italic and 4 to bold italic.
</p>
</td></tr>
<tr><td><code id="item.side_+3A_label.items.rows">label.items.rows</code></td>
<td>

<p>an integer indicating the number of rows used to display the item labels. Can take values 1 (default), 2 and 3. Useful when item labels are overlaping.
</p>
</td></tr>
<tr><td><code id="item.side_+3A_label.items.srt">label.items.srt</code></td>
<td>

<p>angle of rotation for item labels. It only works if <code>label.item.rows</code> is set to 1.
</p>
</td></tr>
<tr><td><code id="item.side_+3A_label.items">label.items</code></td>
<td>

<p>a vector of strings containing the labels identifying the items.
</p>
</td></tr>
<tr><td><code id="item.side_+3A_label.items.cex">label.items.cex</code></td>
<td>

<p>an integer, vector or matrix of numerical values giving the amount by which the threshold labels should be magnified relative to the default.
</p>
</td></tr>
<tr><td><code id="item.side_+3A_label.items.ticks">label.items.ticks</code></td>
<td>

<p>logical. If <code>TRUE</code> (default), ticks are drawn in the x-axis of the item side.
</p>
</td></tr>
<tr><td><code id="item.side_+3A_vertlines">vertLines</code></td>
<td>

<p>logical. If <code>TRUE</code>, light gray vertical lines are drawn to mark all symbols associated with an item or feature in the x-axis.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are designed as helper functions for <code><a href="#topic+wrightMap">wrightMap</a></code> to draw the item side of a map. When called outside of that function, they can be used to create more customized maps. Possible uses inlcude:
</p>

<ul>
<li><p> draw an item map on its own
</p>
</li>
<li><p> compare two item maps in a single figure
</p>
</li>
<li><p> draw a Wright Map with the item side on the left and the person side on the right
</p>
</li>
<li><p> etc.
</p>
</li></ul>

<p>The <code>itemClassic</code> style draws a stacked plot, similar to the Wright Maps available in ConQuest text output files. The <code>itemModern</code> style is the default style for <code><a href="#topic+wrightMap">wrightMap</a></code> which plots each item as a column of difficulty parameters. The <code>itemHist</code> style plots a histogram.
</p>


<h3>Note</h3>

<p>When combining with a <code><a href="#topic+person.side">person.side</a></code> function, note that those functions use <code><a href="graphics.html#topic+split.screen">split.screen</a></code>, which are incompatible with <code><a href="graphics.html#topic+layout">layout</a></code> and some other plotting functions. Note also that all graphs on a single plot should usually have their yRange explicitly specified to ensure that values are comparable across plots. To plot data from ConQuest output, use <code><a href="#topic+itemData">itemData</a></code> first to extract the data table.
</p>


<h3>Author(s)</h3>

<p>Rebecca Freund and David Torres Irribarra</p>


<h3>See Also</h3>

<p><code><a href="#topic+person.side">person.side</a></code>
<code><a href="#topic+itemData">itemData</a></code>
<code><a href="#topic+wrightMap">wrightMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	#As a call from wrightMap:

  ## Mock results
  uni.proficiency &lt;- rnorm(1000, mean =  -0.5, sd = 1)

  items.loc &lt;- sort( rnorm( 20))
  thresholds &lt;- data.frame(
    l1 = items.loc - 0.5 ,
    l2 = items.loc - 0.25,
    l3 = items.loc + 0.25,
    l4 = items.loc + 0.5)
	
	## Setting up labels, colors and symbols

  thresholds.labels &lt;- data.frame(
    l1 = paste('Lev',rep(1,20),sep = ''),
    l2 = paste('Lev',rep(2,20),sep = ''),
    l3 = paste('Lev',rep(3,20),sep = ''),
    l4 = paste('Lev',rep(4,20),sep = ''))

  thresholds.colors &lt;- data.frame(
    l1 = rep(  'green',20),
    l2 = rep(    'red',20),
    l3 = rep( 'yellow',20),
    l4 = rep(   'blue',20))

  thresholds.symbols &lt;- data.frame(
    l1 = rep( 15,20),
    l2 = rep( 16,20),
    l3 = rep( 17,20),
    l4 = rep( 18,20))

wrightMap( uni.proficiency, thresholds
  , thr.lab.text = thresholds.labels
  , thr.lab.col = thresholds.colors
  , thr.sym.pch = thresholds.symbols
  )
	
	#As  direct call:
	
	## Plotting results of a unidimensional Rating Scale Model

  items.loc &lt;- sort( rnorm( 20))
  thresholds &lt;- data.frame(
    l1 = items.loc - 0.5 ,
    l2 = items.loc - 0.25,
    l3 = items.loc + 0.25,
    l4 = items.loc + 0.5)

	itemModern(thresholds)
	itemClassic(thresholds)
	itemHist(thresholds)
	
	## Plotting ConQuest results
	
	fpath &lt;- system.file("extdata", package="WrightMap")
	model1 &lt;- CQmodel(file.path(fpath,"ex2a.eap"), file.path(fpath,"ex2a.shw"))
	m1.item &lt;- itemData(model1)
	
  #control of oma allows us to give more space to longer item names
	itemModern(m1.item, label.items.srt= 90, oma = c(3,0,0,3)) 
	itemClassic(m1.item)
	itemHist(m1.item)
	
	## Creating a Wright Map with item side on the left
	
	 multi.proficiency &lt;- data.frame(
    d1 = rnorm(1000, mean =  -0.5, sd = 1),
    d2 = rnorm(1000, mean =   0.0, sd = 1),
    d3 = rnorm(1000, mean =  +0.5, sd = 1))

    # split.screen: Set up a split screen with the left side 80 percent of the screen
    # yRange = c(-3,4): Set the yRange to be the same for both sides
    # axis.logits.side = "L": Move the item logit axis to the left
    # oma = c(0,0,0,2): Adjust the spacing between the graphs
    # mtext("Wright Map", side = 3, font = 2, line = 1): add a title
    # screen(2): Start drawing on the second screen
    
    split.screen(figs = matrix(c(0,.8,0,1,.8,1,0,1),ncol = 4, byrow = TRUE)) 
    itemModern(thresholds, yRange = c(-3,4), show.axis.logits = "L", oma = c(0,0,0,2))
    mtext("Wright Map", side = 3, font = 2, line = 1)
    screen(2)
    personHist(multi.proficiency, axis.persons = "",yRange = c(-3,4)
    , axis.logits = "Persons", show.axis.logits = FALSE)
    
    
    ## Creating a multidimensional Wright Map with each dimension separate
    
    ## Mock results
  
    d1 = rnorm(1000, mean =  -0.5, sd = 1)
    d2 = rnorm(1000, mean =   0.0, sd = 1)

	dim1.diff &lt;- rnorm(5)
	dim2.diff &lt;- rnorm(5)

  dev.new(width=10, height=10)
	split.screen(figs = matrix(c(0,.1,0,1,
  								.12,.6,0,1,
  								.5,.6,0,1,
  								.5,1,0,1),ncol = 4,byrow = TRUE))
  

	personDens(d1,yRange = c(-3,3),show.axis.logits = FALSE,axis.logits = "")
	screen(2)
	itemModern(dim1.diff,yRange = c(-3,3),show.axis.logits = FALSE)
	mtext("Wright Map", side = 3, font = 2, line = 1)
	screen(3)
	personDens(d2,yRange = c(-3,3),show.axis.logits = FALSE,axis.logits = ""
  ,axis.persons = "",dim.names = "Dim2")
	screen(4)
	itemModern(dim2.diff,yRange = c(-3,3),show.axis.logits = FALSE
  ,label.items = paste("Item",6:10))
	
	

	
</code></pre>

<hr>
<h2 id='make.deltas'>
Calculate Master's Delta parameters.
</h2><span id='topic+make.deltas'></span><span id='topic+make.deltas.default'></span><span id='topic+make.deltas.CQmodel'></span><span id='topic+make.deltas.character'></span>

<h3>Description</h3>

<p>This function takes as its input a CQmodel object or the name of a ConQuest show file. It adds together the parameters as specified by the user, or if no tables are specified it reads the model equation to determine the appropriate tables to sum. This function is used by wrightMap to draw the item side of the map when a CQmodel is passed to wrightMap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.deltas(item.params, ...)
## S3 method for class 'character'
make.deltas(item.params, ...)
## S3 method for class 'CQmodel'
make.deltas(item.params, item.table = NULL, interactions = NULL, 
step.table = NULL, item.sign = NULL, inter.sign = NULL, 
	step.sign = NULL, ...)
## Default S3 method:
make.deltas(item.params, cross.params = 0, step.params = 0, 
item.sign = 1, step.sign = 1, inter.sign = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.deltas_+3A_item.params">item.params</code></td>
<td>

<p>The item parameters. Can either be a vector, a CQmodel object, or a path to a ConQuest show file</p>
</td></tr>
<tr><td><code id="make.deltas_+3A_item.table">item.table</code></td>
<td>
<p>If item.params is a CQmodel object or a path to a ConQuest show file, item.table is the name of the items table. Commonly &quot;item&quot; but can be any string representing the name of a table in the ConQuest show file. This identifies what variable will form the rows of the delta matrix. If not specified, will be the first variable mentioned in the model equation.</p>
</td></tr>
<tr><td><code id="make.deltas_+3A_interactions">interactions</code></td>
<td>
<p>If item.params is a CQmodel object or a path to a ConQuest show file, item.table is the name of the table with the interactions (if present). Commonly &quot;item*step&quot; but can be any string containing &quot;*&quot; that is the name of a table in the ConQuest show file. Should be the product of the item.table variable and the step.table variable (if present). If not specified, will be the product term of the model equation.</p>
</td></tr>
<tr><td><code id="make.deltas_+3A_step.table">step.table</code></td>
<td>
<p>If item.params is a CQmodel object or a path to a ConQuest show file, step.table is the name of the steps table (if present). Commonly &quot;step&quot; but can be any string representing the name of a table in the ConQuest show file. This identifies what variable will form the columns of the delta matrix. If not specified, will be the second variable mentioned in the model equation.</p>
</td></tr>
<tr><td><code id="make.deltas_+3A_item.sign">item.sign</code></td>
<td>
<p>Can be 1 or -1. Indicates whether the item parameters should be added or subtracted.</p>
</td></tr>
<tr><td><code id="make.deltas_+3A_inter.sign">inter.sign</code></td>
<td>
<p>Can be 1 or -1. Indicates whether the interaction parameters should be added or subtracted.</p>
</td></tr>
<tr><td><code id="make.deltas_+3A_step.sign">step.sign</code></td>
<td>
<p>Can be 1 or -1. Indicates whether the step parameters should be added or subtracted.</p>
</td></tr>
<tr><td><code id="make.deltas_+3A_cross.params">cross.params</code></td>
<td>
<p>If item.params is a vector, use this parameter to pass a matrix of interaction parameters.</p>
</td></tr>
<tr><td><code id="make.deltas_+3A_step.params">step.params</code></td>
<td>
<p>If item.params is a vector, use this parameter to pass a matrix of step parameters.</p>
</td></tr>
<tr><td><code id="make.deltas_+3A_...">...</code></td>
<td>
<p>Additional parameters
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function reshapes the tables in the ConQuest show file and adds the step parameters to the appropriate items. The vector version of this is rarely called by the user. 
</p>


<h3>Value</h3>

<p>A matrix in which each row is an item and each column is a step
</p>


<h3>Author(s)</h3>

<p>Rebecca Freund &amp; David Torres Irribarra
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.thresholds">make.thresholds</a></code>
<code><a href="#topic+CQmodel">CQmodel</a></code>
<code><a href="#topic+wrightMap">wrightMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fpath &lt;- system.file("extdata", package="WrightMap")

# Partial credit model
model1 &lt;- CQmodel(file.path(fpath,"ex2a.eap"), file.path(fpath,"ex2a.shw")) 
make.deltas(model1)

# Rating scale model
model2 &lt;- CQmodel(file.path(fpath,"ex2b.eap"), file.path(fpath,"ex2b-2.shw")) 
make.deltas(model2)

# Raters, criteria, topics
model3 &lt;- CQmodel(file.path(fpath,"ex4a.mle"), file.path(fpath,"ex4a.shw")) 
make.deltas(model3, item.table = "rater")
make.deltas(model3, item.table = "rater", interactions = "rater*topic", step.table = "topic")
</code></pre>

<hr>
<h2 id='make.thresholds'>
Calculate Thurstonian thresholds.
</h2><span id='topic+make.thresholds'></span><span id='topic+make.thresholds.default'></span><span id='topic+make.thresholds.CQmodel'></span><span id='topic+make.thresholds.character'></span><span id='topic+make.thresholds.matrix'></span>

<h3>Description</h3>

<p>This function accepts a matrix of delta parameters and converts them to thresholds (using a threshold of .5). It can also take as input a CQmodel object or a filename of a ConQuest show file.</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.thresholds(item.params, ...)
## S3 method for class 'character'
make.thresholds(item.params, design.matrix = "normal",...)
## S3 method for class 'CQmodel'
make.thresholds(item.params,item.table = NULL, interactions = NULL
,step.table = NULL, design.matrix = "normal", throld = 0.5, alpha = 1,...)
## Default S3 method:
make.thresholds(item.params, design.matrix = "normal"
, make.from = "deltas", theta.interval = c(-10, 10), throld = 0.5, alpha = 1
, c.params = 0,...)
## S3 method for class 'matrix'
make.thresholds(item.params, design.matrix = "normal"
, make.from = "deltas", theta.interval = c(-10, 10), throld = 0.5
, alpha = 1, c.params = 0,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.thresholds_+3A_item.params">item.params</code></td>
<td>
<p>The item parameters. Can either be a matrix, a CQmodel object, or a path to a ConQuest show file</p>
</td></tr>
<tr><td><code id="make.thresholds_+3A_design.matrix">design.matrix</code></td>
<td>
<p>Can be &quot;normal&quot; or &quot;ConQuest&quot;. Note that for a CQmodel object or ConQuest file, should be normal, NOT ConQuest.</p>
</td></tr>
<tr><td><code id="make.thresholds_+3A_make.from">make.from</code></td>
<td>
<p>Specifies whether the item.params matrix contains threshold or delta parameters.</p>
</td></tr>
<tr><td><code id="make.thresholds_+3A_item.table">item.table</code></td>
<td>
<p>If item.params is a CQmodel object or a path to a ConQuest show file, item.table is the name of the items table. Commonly &quot;item&quot; but can be any string representing the name of a table in the ConQuest show file. This identifies what variable will form the rows of the thresholds matrix. If not specified, will be the first variable mentioned in the model equation.</p>
</td></tr>
<tr><td><code id="make.thresholds_+3A_interactions">interactions</code></td>
<td>
<p>If item.params is a CQmodel object or a path to a ConQuest show file, item.table is the name of the table with the interactions (if present). Commonly &quot;item*step&quot; but can be any string containing &quot;*&quot; that is the name of a table in the ConQuest show file. Should be the product of the item.table variable and the step.table variable (if present). If not specified, will be the product term of the model equation.</p>
</td></tr>
<tr><td><code id="make.thresholds_+3A_step.table">step.table</code></td>
<td>
<p>If item.params is a CQmodel object or a path to a ConQuest show file, step.table is the name of the steps table (if present). Commonly &quot;step&quot; but can be any string representing the name of a table in the ConQuest show file. This identifies what variable will form the columns of the thresholds matrix. If not specified, will be the second variable mentioned in the model equation.</p>
</td></tr>
<tr><td><code id="make.thresholds_+3A_theta.interval">theta.interval</code></td>
<td>
<p>If item.params is a matrix, theta.interval specifies over what interval to search for the parameters.</p>
</td></tr>
<tr><td><code id="make.thresholds_+3A_throld">throld</code></td>
<td>
<p>The probability level to use for calculating the thresholds.</p>
</td></tr>
<tr><td><code id="make.thresholds_+3A_alpha">alpha</code></td>
<td>
<p>A vector or single value for the slope parameter or parameters.</p>
</td></tr>
<tr><td><code id="make.thresholds_+3A_c.params">c.params</code></td>
<td>
<p>A vector or single value for the guessing parameter or parameters.</p>
</td></tr>
<tr><td><code id="make.thresholds_+3A_...">...</code></td>
<td>

<p>Additional parameters.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of threshold parameters.
</p>


<h3>Author(s)</h3>

<p>Daniel Coulter Furr, Rebecca Freund, &amp; David Torres Irribarra
</p>


<h3>See Also</h3>

<p><code><a href="#topic+make.deltas">make.deltas</a></code>
<code><a href="#topic+itemData">itemData</a></code>
<code><a href="#topic+CQmodel">CQmodel</a></code>
<code><a href="#topic+wrightMap">wrightMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fpath &lt;- system.file("extdata", package="WrightMap")

# Partial credit model
model1 &lt;- CQmodel(file.path(fpath,"ex2a.eap"), file.path(fpath,"ex2a.shw")) 
deltas &lt;- make.deltas(model1)
make.thresholds(deltas)
make.thresholds(model1)
</code></pre>

<hr>
<h2 id='person.side'>
Wright Map person sides
</h2><span id='topic+person.side'></span><span id='topic+personHist'></span><span id='topic+personDens'></span>

<h3>Description</h3>

<p>Draw the person side of a Wright Map in a variety of styles. Intended to be primarily called by <code><a href="#topic+wrightMap">wrightMap</a></code>, but also available for use on their own.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>personHist(thetas, yRange = NULL, breaks = "FD", dim.lab.cex = 0.6, dim.lab.side = 3
  , dim.lab.adj = 0.5, dim.names = NULL, dim.color = "white", person.points = NULL
  , person.range = NULL, p.point.col = "gray45", p.range.col = "gray75"
  ,axis.persons = "Respondents", oma = c(0, 5, 0, 5), axis.logits = "Logits"
  , show.axis.logits = TRUE,...)

personDens(thetas, yRange = NULL, dim.lab.cex = 0.6, dim.lab.side = 3, dim.lab.adj = 0.5
  ,dim.names = NULL,dim.color = "black",person.points = NULL, person.range = NULL
  , p.point.col = "black", p.range.col = "gray70",oma = c(0, 5, 0, 5)
  , axis.logits = "Logits",show.axis.logits = TRUE, axis.persons = "Respondents",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="person.side_+3A_thetas">thetas</code></td>
<td>

<p>vector or matrix of person parameters. If a matrix, persons should be the rows and dimensions the columns.
</p>
</td></tr>
<tr><td><code id="person.side_+3A_yrange">yRange</code></td>
<td>

<p>vector with 2 elements specifying the lower and upper limits of the plot's y-axis.
</p>
</td></tr>
<tr><td><code id="person.side_+3A_dim.lab.cex">dim.lab.cex</code></td>
<td>

<p>An integer specifying the amount the dimension labels should be magnified relative to the default.
</p>
</td></tr>
<tr><td><code id="person.side_+3A_dim.lab.side">dim.lab.side</code></td>
<td>

<p>an integer specifying in which side to plot the dimension names. Values of 1, 2, 3 (default) and 4, respectively indicate positions below, to the left of, above and to the right of the person distributions.</p>
</td></tr>
<tr><td><code id="person.side_+3A_dim.lab.adj">dim.lab.adj</code></td>
<td>

<p>a numerical value adjusting the position of the dimension names.
</p>
</td></tr>
<tr><td><code id="person.side_+3A_dim.names">dim.names</code></td>
<td>

<p>a string or a vector of strings containing the names of each one of the dimensions.
</p>
</td></tr>
<tr><td><code id="person.side_+3A_dim.color">dim.color</code></td>
<td>

<p>a numerical value or vector indicating the colors to be used for representing each dimension.
</p>
</td></tr>
<tr><td><code id="person.side_+3A_person.points">person.points</code></td>
<td>

<p>a vector of individual values to highlight
</p>
</td></tr>
<tr><td><code id="person.side_+3A_person.range">person.range</code></td>
<td>

<p>Can be a pair of values, an even-lengthed vector, or a matrix with two rows. Values indicate the start and endpoints of ranges to highlight. If a matrix, the first row should be lower bounds and the second row upper bounds of the ranges. If a vector, the values should alternate: (lower1,upper1,lower2,upper2,...).
</p>
</td></tr>
<tr><td><code id="person.side_+3A_p.point.col">p.point.col</code></td>
<td>

<p>a string or vector of strings indicating the color to use for the highlighted points
</p>
</td></tr>
<tr><td><code id="person.side_+3A_p.range.col">p.range.col</code></td>
<td>

<p>a string or vector of strings indicating the color to use for the highlighted ranges.
</p>
</td></tr>
<tr><td><code id="person.side_+3A_axis.persons">axis.persons</code></td>
<td>

<p>title of the y-axis on the left side.
</p>
</td></tr>
<tr><td><code id="person.side_+3A_oma">oma</code></td>
<td>

<p>values to use for the <code>oma</code> parameter (see <code><a href="graphics.html#topic+par">par</a></code>)
</p>
</td></tr>
<tr><td><code id="person.side_+3A_show.axis.logits">show.axis.logits</code></td>
<td>

<p>logical indicating whether to show the logit axis
</p>
</td></tr>
<tr><td><code id="person.side_+3A_axis.logits">axis.logits</code></td>
<td>

<p>title of the y-axis on the right side
</p>
</td></tr>
<tr><td><code id="person.side_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>
<p>For <code>personHist</code>:
</p>
<table>
<tr><td><code id="person.side_+3A_breaks">breaks</code></td>
<td>

<p>See <code><a href="graphics.html#topic+hist">hist</a></code>). This argument is passed directly to hist, so it will accept all the options detailed in that function's manual.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are designed as helper functions for <code><a href="#topic+wrightMap">wrightMap</a></code> and <code><a href="#topic+ppPlot">ppPlot</a></code> to draw the person side of a map. When called outside of that function, they can be used to create more customized maps. Possible uses inlcude:
</p>

<ul>
<li><p> draw a person map on its own
</p>
</li>
<li><p> compare two person maps in a single figure
</p>
</li>
<li><p> draw a Wright Map with the item side on the left and the person side on the right
</p>
</li>
<li><p> etc.
</p>
</li></ul>

<p>The <code>personHist</code> style, the default, draws the person distribution as a histogram, and is equivalent to the <code>use.hist = TRUE</code> option from previous versions of wrightMap. The <code>personDens</code> style draws a density plot.
</p>
<p>The <code>person.points</code>, <code>person.range</code>, <code>p.point.col</code>, and <code>p.range.col</code> parameters are called directly by <code><a href="#topic+ppPlot">ppPlot</a></code> to show the estimate and standard deviation for a single person. However, they can also be specified without using <code><a href="#topic+ppPlot">ppPlot</a></code> to highlight arbitrary values or ranges.
</p>


<h3>Author(s)</h3>

<p>Rebecca Freund and David Torres Irribarra
</p>


<h3>See Also</h3>

<p><code><a href="#topic+item.side">item.side</a></code>
<code><a href="#topic+personData">personData</a></code>
<code><a href="#topic+wrightMap">wrightMap</a></code>
<code><a href="#topic+ppPlot">ppPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	# Creating a Wright Map with item side on the left
	
	multi.proficiency &lt;- data.frame(
    d1 = rnorm(1000, mean =  -0.5, sd = 1),
    d2 = rnorm(1000, mean =   0.0, sd = 1),
    d3 = rnorm(1000, mean =  +0.5, sd = 1))

    
  items.loc &lt;- sort( rnorm( 20))
  thresholds &lt;- data.frame(
    l1 = items.loc - 0.5 ,
    l2 = items.loc - 0.25,
    l3 = items.loc + 0.25,
    l4 = items.loc + 0.5)
    
    # split.screen: Set up a split screen with the left side 80 percent of the screen
    # yRange = c(-3,4): Set the yRange to be the same for both sides
    # axis.logits.side = "L": Move the item logit axis to the left
    # oma = c(0,0,0,2): Adjust the spacing between the graphs
    # mtext("Wright Map", side = 3, font = 2, line = 1): add a title
    # screen(2): Start drawing on the second screen
    
    split.screen(figs = matrix(c(0,.8,0,1,.8,1,0,1),ncol = 4, byrow = TRUE)) 
    itemModern(thresholds, yRange = c(-3,4), show.axis.logits = "L", oma = c(0,0,0,2))
    mtext("Wright Map", side = 3, font = 2, line = 1)
    screen(2)
    personHist(multi.proficiency, axis.persons = "",yRange = c(-3,4)
    , axis.logits = "Persons", show.axis.logits = FALSE)
    
     ## Creating a multidimensional Wright Map with each dimension separate
    
    ## Mock results
  
    d1 = rnorm(1000, mean =  -0.5, sd = 1)
    d2 = rnorm(1000, mean =   0.0, sd = 1)

	dim1.diff &lt;- rnorm(5)
	dim2.diff &lt;- rnorm(5)
  
	split.screen(figs = matrix(c(0,.1,0,1,
  								.12,.6,0,1,
  								.5,.6,0,1,
  								.5,1,0,1),ncol = 4,byrow = TRUE))
  							  
	personDens(d1,yRange = c(-3,3),show.axis.logits = FALSE
  , axis.logits = "")
	screen(2)
	itemModern(dim1.diff,yRange = c(-3,3),show.axis.logits = FALSE)
	mtext("Wright Map", side = 3, font = 2, line = 1)
	screen(3)
	personDens(d2,yRange = c(-3,3),show.axis.logits = FALSE
  , axis.logits = ""
  , axis.persons = "",dim.names = "Dim2")
	screen(4)
	itemModern(dim2.diff,yRange = c(-3,3),show.axis.logits = FALSE
  , label.items = paste("Item",6:10))
	

</code></pre>

<hr>
<h2 id='plotCI'>
Plotting confidence intervals and DIF
</h2><span id='topic+difplot'></span><span id='topic+difplot.default'></span><span id='topic+difplot.CQmodel'></span><span id='topic+difplot.character'></span><span id='topic+plotCI'></span>

<h3>Description</h3>

<p>The <code>plotCI</code> function is intended for graphing confidence intervals. The <code>difplot</code> function is a wrapper for <code>plotCI</code> specifcally intended for examining Differential Item Functioning from ConQuest output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCI(ests, errors, labels = "", zeroline = TRUE, incol = "gray", outcol = "blue"
, main.title = "Statistical Significance Plot", axes = FALSE, xlab = "", pch = 16, ...)
## Default S3 method:
difplot(data, grouptype = NULL, group = NULL, item.names = NULL
, ylim = c(-1, 1), ylab = NULL, ...)
## S3 method for class 'CQmodel'
difplot(data, table.name = NULL, grouptype = NULL
, group = NULL, ...)
## S3 method for class 'character'
difplot(data, equation, ...)
</code></pre>


<h3>Arguments</h3>

<p><code>plotCI</code> parameters:
</p>
<table>
<tr><td><code id="plotCI_+3A_ests">ests</code></td>
<td>
<p>vector of point estimates.</p>
</td></tr>
<tr><td><code id="plotCI_+3A_errors">errors</code></td>
<td>
<p>vector of standard errors.</p>
</td></tr>
<tr><td><code id="plotCI_+3A_labels">labels</code></td>
<td>
<p>vector of labels for the items.</p>
</td></tr>
<tr><td><code id="plotCI_+3A_zeroline">zeroline</code></td>
<td>
<p>logical indicating whether to draw a line at zero.</p>
</td></tr>
<tr><td><code id="plotCI_+3A_incol">incol</code></td>
<td>
<p>color of intervals containing zero.</p>
</td></tr>
<tr><td><code id="plotCI_+3A_outcol">outcol</code></td>
<td>
<p>color of intervals not containing zero.</p>
</td></tr>
<tr><td><code id="plotCI_+3A_main.title">main.title</code></td>
<td>
<p>title of the plot.</p>
</td></tr>
<tr><td><code id="plotCI_+3A_axes">axes</code>, <code id="plotCI_+3A_xlab">xlab</code>, <code id="plotCI_+3A_pch">pch</code></td>
<td>
<p>parameters passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>
<p><code>difplot</code> parameters:
</p>
<table>
<tr><td><code id="plotCI_+3A_data">data</code></td>
<td>
<p>A <code>CQmodel</code> object or the name of a ConQuest show file. Can also be a table of parameters taken from ConQuest output.</p>
</td></tr>
<tr><td><code id="plotCI_+3A_table.name">table.name</code></td>
<td>
<p>The RMP table to use for parameters. Should be an interactions table.</p>
</td></tr>
<tr><td><code id="plotCI_+3A_grouptype">grouptype</code></td>
<td>
<p>The name of the demographic variable (e.g. &ldquo;gender&rdquo;).</p>
</td></tr>
<tr><td><code id="plotCI_+3A_group">group</code></td>
<td>
<p>The name of the group to test for DIF (e.g. &ldquo;male&rdquo;).</p>
</td></tr>
<tr><td><code id="plotCI_+3A_item.names">item.names</code></td>
<td>
<p>vector of item names.</p>
</td></tr>
<tr><td><code id="plotCI_+3A_equation">equation</code></td>
<td>
<p>string specifying the model equation, if the Summary of Estimation table was not included in the show file. </p>
</td></tr>
<tr><td><code id="plotCI_+3A_ylim">ylim</code>, <code id="plotCI_+3A_ylab">ylab</code></td>
<td>
<p>more parameters passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plotCI_+3A_...">...</code></td>
<td>
<p>additional parameters to pass to <code>plot</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>plotCI</code> function takes point estimates and standard errors as inputs and plots 95 percent confidence intervals in relation to a zero-line. By default, it colors the intervals gray if they include zero, and blue if they do not. The <code>difplot</code> function is a wrapper for <code>plotCI</code> specifcally intended for examining Differential Item Functioning from ConQuest output and expects tables formatted exactly like ConQuest output to work correctly. For plotting DIF from other statistical packages, it is recommended to use <code>plotCI</code> directly.
</p>


<h3>Author(s)</h3>

<p>David Torres Irribarra and Rebecca Freund</p>


<h3>Examples</h3>

<pre><code class='language-R'>	#Plotting confidence intervals
	
	ests &lt;- rnorm(10,sd = .5)
	errors &lt;- runif(10,min = .1,max = .5)
	plotCI(ests,errors,ylim = c(-3,3))
	
	#DIF plot:
	
	fpath &lt;- system.file("extdata", package="WrightMap")

	# equation must be specified because there is no summary of estimation 
	# table in this example
	difplot(file.path(fpath,"ex6a.shw"), equation = "item-gender+item*gender") 

</code></pre>

<hr>
<h2 id='ppPlot'>Person probability plots
</h2><span id='topic+ppPlot'></span><span id='topic+cutLines'></span><span id='topic+kidmap'></span>

<h3>Description</h3>

<p>Plots a Wright Map for a single person (similar to a kidmap). On the person side, highlights their estimated ability and a range of one standard error. On the item side, draws lines representing item difficulties at which they are expected to have a 20%, 40%, 50%, 60%, and 80% chance of success.</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppPlot(thetas, thresholds, est, SE, main.title = "Person Probability Plot"
, cut.left = 0, cut.right = .94, cut.lab.adj = c(1,.5),...)

cutLines(cutpoints = NULL,cut.left = 0, cut.right = 1, cut.lab.text = NULL
, cut.lab.adj = c(0,1),...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppPlot_+3A_thetas">thetas</code></td>
<td>

<p>a vector, matrix or data frame of person parameter estimates. Can also be a character string specifying a ConQuest output file of person parameter estimates, or a CQmodel object. Will be sent to the function <code><a href="#topic+personData">personData</a></code>.
</p>
</td></tr>
<tr><td><code id="ppPlot_+3A_thresholds">thresholds</code></td>
<td>

<p>matrix or data frame of item parameter estimates. Can also be a character string specifying a ConQuest show file. Will be sent to the function <code><a href="#topic+itemData">itemData</a></code>.
</p>
</td></tr>
<tr><td><code id="ppPlot_+3A_est">est</code></td>
<td>

<p>estimated ability of the person
</p>
</td></tr>
<tr><td><code id="ppPlot_+3A_se">SE</code></td>
<td>

<p>standard error of the estimate
</p>
</td></tr>
<tr><td><code id="ppPlot_+3A_main.title">main.title</code></td>
<td>

<p>title of the Person Probability Plot.
</p>
</td></tr>
<tr><td><code id="ppPlot_+3A_cut.left">cut.left</code></td>
<td>

<p>value between 0 and 1 describing where to place the lefthand side of the cutpoints, as a fraction of the item plot.
</p>
</td></tr>
<tr><td><code id="ppPlot_+3A_cut.right">cut.right</code></td>
<td>

<p>value between 0 and 1 describing where to place the righthand side of the cutpoints, as a fraction of the item plot.
</p>
</td></tr>
<tr><td><code id="ppPlot_+3A_cut.lab.adj">cut.lab.adj</code></td>
<td>

<p>similar to the <code>adj</code> parameter in <code><a href="graphics.html#topic+text">text</a></code>, describes where to place the text for the cutpoints as a pair of values between 0 and 1 in terms of left-right and up-down alignment. Left-right alignment is 0 for the left side of the item plot and 1 for the right side, while up-down alignment is 0 for below the line and 1 for above the line.
</p>
</td></tr>
<tr><td><code id="ppPlot_+3A_cutpoints">cutpoints</code></td>
<td>

<p>argument to <code>cutLines</code> when called through <code>wrightMap</code> or one of the <code><a href="#topic+item.side">item.side</a></code> functions. Specifies locations of cutlines. When <code>cutLines</code> is called through <code>ppPlot</code>, the cutpoints are calculated rather than specified. 
</p>
</td></tr>
<tr><td><code id="ppPlot_+3A_cut.lab.text">cut.lab.text</code></td>
<td>

<p>argument to <code>cutLines</code> when called through <code>wrightMap</code> or one of the <code><a href="#topic+item.side">item.side</a></code> functions. Specifies text to appear for each cut line. When <code>cutLines</code> is called through <code>ppPlot</code>, the text is always the percent chance of success given the estimated ability level and difficulty location. 	
</p>
</td></tr>
<tr><td><code id="ppPlot_+3A_...">...</code></td>
<td>

<p>additional arguments to pass to <code><a href="#topic+wrightMap">wrightMap</a></code> or its associated functions.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ppPlot</code> function is a wrapper for <code><a href="#topic+wrightMap">wrightMap</a></code> that is specifically designed for person probability plots, and as such has access to all the parameters of wrightMap and its associated functions. It uses the <code>person.points</code>, <code>person.range</code>, <code>p.point.col</code>, and <code>p.range.col</code> parameters on the <code><a href="#topic+person.side">person.side</a></code> function to draw a range of one standard error around the estimated ability level. On the item side, it calculates at what item difficulty the respondent is expected to have a 20%, 40%, 50%, 60%, and 80% chance of success and then uses the <code>cutLines</code> function to illustrate these cutpoints. The cutLines function should not be called on its own and may be hidden in future versions. It is included here to show the available parameters, which can be included in a call to <code>wrightMap</code> or any of the <code>item.side</code> functions.
</p>


<h3>Author(s)</h3>

<p>David Torres Irribarra and Rebecca Freund</p>


<h3>See Also</h3>

<p><code><a href="#topic+wrightMap">wrightMap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
	fpath &lt;- system.file("extdata", package="WrightMap")
	model1 &lt;- CQmodel(p.est = file.path(fpath,"ex2.eap"), show = file.path(fpath,"ex2.shw"))
	
	#Person histogram, modern item
	ppPlot(model1,est = 0, SE = 1) 
	
	#Person density, classic item
	ppPlot(model1,est = 0, SE = 1, person.side = personDens,item.side = itemClassic) 
	
</code></pre>

<hr>
<h2 id='wrightMap'>
wrightMap: item-person maps
</h2><span id='topic+wrightMap'></span><span id='topic+plot.CQmodel'></span>

<h3>Description</h3>

<p>This function allows the easy generation of &lsquo;Wright Maps&rsquo; (named after Ben Wright), also known as item-person maps. They are used to to display unidimensional and multidimensional assessment results. These maps represent simultaneously the proficiency distribution of respondents and the item difficulty parameters as estimated by a model of the Rasch family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wrightMap(thetas, thresholds = NULL, item.side = itemModern, person.side = personHist
,  main.title = "Wright Map", min.logit.pad = 0.25, max.logit.pad = 0.25, min.l = NULL
, max.l = NULL, item.prop = 0.8, return.thresholds = TRUE, new.quartz = FALSE
, use.hist = NULL,...) 
## S3 method for class 'CQmodel'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<p>The parameters documented here do not include many of the options included in the Wright Map family of functions. For graphical parameters, see <code><a href="#topic+item.side">item.side</a></code> and <code><a href="#topic+person.side">person.side</a></code>. For data handling, see <code><a href="#topic+item.person.data">item.person.data</a></code> and <code><a href="#topic+CQmodel">CQmodel</a></code>.
</p>
<p>wrightMap parameters:
</p>
<table>
<tr><td><code id="wrightMap_+3A_thetas">thetas</code></td>
<td>

<p>a vector, matrix or data frame of person parameter estimates. Can also be a character string specifying a ConQuest output file of person parameter estimates, or a CQmodel object. Will be sent to the function <code><a href="#topic+personData">personData</a></code>.
</p>
</td></tr>
<tr><td><code id="wrightMap_+3A_thresholds">thresholds</code></td>
<td>

<p>matrix or data frame of item parameter estimates. Can also be a character string specifying a ConQuest show file. Will be sent to the function <code><a href="#topic+itemData">itemData</a></code>.
</p>
</td></tr>
<tr><td><code id="wrightMap_+3A_item.side">item.side</code></td>
<td>

<p>function to use to draw the item side of the map. Currently included options are itemModern (default), itemClassic (for ConQuest-style Wright Maps) and itemHist. See <code><a href="#topic+item.side">item.side</a></code> for details.
</p>
</td></tr>
<tr><td><code id="wrightMap_+3A_person.side">person.side</code></td>
<td>

<p>function to use to draw the person side of the map. Currently included options are personHist (default), to draw the person distribution as a histogram, and personDens, which draws a density plot. See <code><a href="#topic+person.side">person.side</a></code> for details.
</p>
</td></tr>
<tr><td><code id="wrightMap_+3A_main.title">main.title</code></td>
<td>

<p>title of the Wright Map.
</p>
</td></tr>
<tr><td><code id="wrightMap_+3A_min.logit.pad">min.logit.pad</code></td>
<td>

<p>numeric value indicating how much of the lower end of the logit scale should be included in the plot.
</p>
</td></tr>
<tr><td><code id="wrightMap_+3A_max.logit.pad">max.logit.pad</code></td>
<td>

<p>numeric value indicating how much of the upper end of the logit scale should be included in the plot.
</p>
</td></tr>
<tr><td><code id="wrightMap_+3A_min.l">min.l</code></td>
<td>

<p>numeric value for fixing the lower end of the logit scale. It overrides the automatic detection of the range and the <code>min.logit.pad</code> correction.
</p>
</td></tr>
<tr><td><code id="wrightMap_+3A_max.l">max.l</code></td>
<td>

<p>numeric value for fixing the upper end of the logit scale. It overrides the automatic detection of the range and the <code>max.logit.pad</code> correction.
</p>
</td></tr>
<tr><td><code id="wrightMap_+3A_item.prop">item.prop</code></td>
<td>

<p>numeric value greater than 0 and smaller than 1 indicating the proportion of the plot to be allocated to the item part of the Wright Map.
</p>
</td></tr>
<tr><td><code id="wrightMap_+3A_return.thresholds">return.thresholds</code></td>
<td>

<p>logical. Determines whether the to return or not the numeric values used to position the parameters on the item side of the Wright Map. Enabled by default.
</p>
</td></tr>
<tr><td><code id="wrightMap_+3A_new.quartz">new.quartz</code></td>
<td>

<p>logical. Determines whether the wrightMap will be created on a new graphical device or if it will reuse one already open. By default is set to <code>FALSE</code> to avoid creating new devices.
</p>
</td></tr>
<tr><td><code id="wrightMap_+3A_use.hist">use.hist</code></td>
<td>

<p>deprecated. Use the <code><a href="#topic+person.side">person.side</a></code> parameter instead
</p>
</td></tr>
<tr><td><code id="wrightMap_+3A_...">...</code></td>
<td>

<p>Additional arguments to pass to <code><a href="#topic+personData">personData</a></code>, <code><a href="#topic+itemData">itemData</a></code>, <code><a href="#topic+person.side">person.side</a></code>, or <code><a href="#topic+item.side">item.side</a></code>
</p>
</td></tr>
</table>
<p>wrightMap can also be called by passing a CQmodel object to plot:
</p>
<table>
<tr><td><code id="wrightMap_+3A_x">x</code></td>
<td>
<p> CQmodel object to pass to plot</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>David Torres Irribarra and Rebecca Freund</p>


<h3>References</h3>

<p>Wilson, M. (2005). Constructing measures: An item response modeling approach. 
Wright, B. D. and Stone, M. H. (1979). <em>Best test design.</em> Chicago: Mesa Press. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+person.side">person.side</a></code>
<code><a href="#topic+item.side">item.side</a></code>
<code><a href="#topic+personData">personData</a></code>
<code><a href="#topic+itemData">itemData</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Plotting results of a unidimensional Rasch Model

## Mock results
  uni.proficiency &lt;- rnorm(1000, mean =  -0.5, sd = 1)
  difficulties  &lt;- sort( rnorm( 20))

## Default map
wrightMap( uni.proficiency, difficulties)

## Density version
wrightMap( uni.proficiency, difficulties, person.side = personDens)


# Plotting results of a multidimensional Rasch Model

## Mock results
  multi.proficiency &lt;- data.frame(
    d1 = rnorm(1000, mean =  -0.5, sd = 1),
    d2 = rnorm(1000, mean =   0.0, sd = 1),
    d3 = rnorm(1000, mean =  +0.5, sd = 1))

  difficulties  &lt;- sort( rnorm( 20))

dev.new(width=10, height=10)
wrightMap( multi.proficiency, difficulties)

# Plotting results of a unidimensional Rating Scale Model

## Mock results
  uni.proficiency &lt;- rnorm(1000, mean =  -0.5, sd = 1)

  items.loc &lt;- sort( rnorm( 20))
  thresholds &lt;- data.frame(
    l1 = items.loc - 0.5 ,
    l2 = items.loc - 0.25,
    l3 = items.loc + 0.25,
    l4 = items.loc + 0.5)

wrightMap( uni.proficiency, thresholds)


  
    ####ConQuest integration###
  
  	fpath &lt;- system.file("extdata", package="WrightMap")
  	
  	#Partial credit model:

	model1 &lt;- CQmodel(p.est = file.path(fpath,"ex2.eap"), show = file.path(fpath,"ex2.shw"))
	wrightMap(model1) 
	
	# Rating scale model:
	model2 &lt;- CQmodel(file.path(fpath,"ex2b.eap"), file.path(fpath,"ex2b-2.shw"))
	wrightMap(model2, label.items.row = 2) 
		
  # Complex model
	model3 &lt;- CQmodel(file.path(fpath,"ex4a.mle"), file.path(fpath,"ex4a.shw")) 
	wrightMap(model3, min.logit.pad = -29, person.side = personDens)
	
	
  ### Skip CQmodel
	wrightMap(file.path(fpath,"ex2a.eap"), file.path(fpath,"ex2a.shw"), 
  label.items.row = 3) 

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
