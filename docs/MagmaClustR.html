<!DOCTYPE html><html><head><title>Help for package MagmaClustR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MagmaClustR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#MagmaClustR'><p>MagmaClustR : Clustering and Prediction using Multi-Task Gaussian Processes</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#chol_inv_jitter'><p>Inverse a matrix using an adaptive jitter term</p></a></li>
<li><a href='#data_allocate_cluster'><p>Allocate training data into the most probable cluster</p></a></li>
<li><a href='#dmnorm'><p>Compute the Multivariate Gaussian likelihood</p></a></li>
<li><a href='#draw'><p>Draw a number</p></a></li>
<li><a href='#e_step'><p>E-Step of the EM algorithm</p></a></li>
<li><a href='#elbo_clust_multi_GP'><p>Evidence Lower Bound for a mixture of GPs</p></a></li>
<li><a href='#elbo_clust_multi_GP_common_hp_i'><p>Penalised elbo for multiple individual GPs with common HPs</p></a></li>
<li><a href='#elbo_GP_mod_common_hp_k'><p>Penalised elbo for multiple mean GPs with common HPs</p></a></li>
<li><a href='#elbo_monitoring_VEM'><p>Evidence Lower Bound maximised in MagmaClust</p></a></li>
<li><a href='#expand_grid_inputs'><p>Expand a grid of inputs</p></a></li>
<li><a href='#gr_clust_multi_GP'><p>Gradient of the elbo for a mixture of GPs</p></a></li>
<li><a href='#gr_clust_multi_GP_common_hp_i'><p>Gradient of the penalised elbo for multiple individual GPs with common HPs</p></a></li>
<li><a href='#gr_GP'><p>Gradient of the logLikelihood of a Gaussian Process</p></a></li>
<li><a href='#gr_GP_mod'><p>Gradient of the modified logLikelihood for GPs in Magma</p></a></li>
<li><a href='#gr_GP_mod_common_hp'><p>Gradient of the modified logLikelihood with common HPs for GPs in Magma</p></a></li>
<li><a href='#gr_GP_mod_common_hp_k'><p>Gradient of the penalised elbo for multiple mean GPs with common HPs</p></a></li>
<li><a href='#gr_sum_logL_GP_clust'><p>Gradient of the mixture of Gaussian likelihoods</p></a></li>
<li><a href='#hp'><p>Generate random hyper-parameters</p></a></li>
<li><a href='#hyperposterior'><p>Compute the hyper-posterior distribution in Magma</p></a></li>
<li><a href='#hyperposterior_clust'><p>Compute the hyper-posterior distribution for each cluster in MagmaClust</p></a></li>
<li><a href='#ini_kmeans'><p>Run a k-means algorithm to initialise clusters' allocation</p></a></li>
<li><a href='#ini_mixture'><p>Mixture initialisation with kmeans</p></a></li>
<li><a href='#kern_to_cov'><p>Create covariance matrix from a kernel</p></a></li>
<li><a href='#kern_to_inv'><p>Create inverse of a covariance matrix from a kernel</p></a></li>
<li><a href='#lin_kernel'><p>Linear Kernel</p></a></li>
<li><a href='#list_kern_to_cov'><p>Compute a covariance matrix for multiple individuals</p></a></li>
<li><a href='#list_kern_to_inv'><p>Compute an inverse covariance matrix for multiple individuals</p></a></li>
<li><a href='#logL_GP'><p>Log-Likelihood function of a Gaussian Process</p></a></li>
<li><a href='#logL_GP_mod'><p>Modified log-Likelihood function for GPs</p></a></li>
<li><a href='#logL_GP_mod_common_hp'><p>Modified log-Likelihood function with common HPs for GPs</p></a></li>
<li><a href='#logL_monitoring'><p>Log-Likelihood for monitoring the EM algorithm in Magma</p></a></li>
<li><a href='#m_step'><p>M-Step of the EM algorithm</p></a></li>
<li><a href='#perio_kernel'><p>Periodic Kernel</p></a></li>
<li><a href='#plot_db'><p>Plot smoothed curves of raw data</p></a></li>
<li><a href='#plot_gif'><p>Create a GIF of Magma or GP predictions</p></a></li>
<li><a href='#plot_gp'><p>Plot Magma or GP predictions</p></a></li>
<li><a href='#plot_magmaclust'><p>Plot MagmaClust predictions</p></a></li>
<li><a href='#plot_samples'><p>Display realisations from a (mixture of) GP prediction</p></a></li>
<li><a href='#pred_gif'><p>Magma prediction for ploting GIFs</p></a></li>
<li><a href='#pred_gp'><p>Gaussian Process prediction</p></a></li>
<li><a href='#pred_magma'><p>Magma prediction</p></a></li>
<li><a href='#pred_magmaclust'><p>MagmaClust prediction</p></a></li>
<li><a href='#proba_max_cluster'><p>Indicates the most probable cluster</p></a></li>
<li><a href='#regularize_data'><p>Regularise a grid of inputs in a dataset</p></a></li>
<li><a href='#rq_kernel'><p>Rational Quadratic Kernel</p></a></li>
<li><a href='#sample_gp'><p>Draw samples from a posterior GP/Magma distribution</p></a></li>
<li><a href='#sample_magmaclust'><p>Draw samples from a MagmaClust posterior distribution</p></a></li>
<li><a href='#se_kernel'><p>Squared Exponential Kernel</p></a></li>
<li><a href='#select_nb_cluster'><p>Select the optimal number of clusters</p></a></li>
<li><a href='#simu_db'><p>Simulate a dataset tailored for MagmaClustR</p></a></li>
<li><a href='#simu_indiv_se'><p>Simulate a batch of data</p></a></li>
<li><a href='#sum_logL_GP_clust'><p>Compute a mixture of Gaussian log-likelihoods</p></a></li>
<li><a href='#swimmers'><p>French swimmers performances data on 100m freestyle events</p></a></li>
<li><a href='#train_gp'><p>Learning hyper-parameters of a Gaussian Process</p></a></li>
<li><a href='#train_gp_clust'><p>Prediction in MagmaClust: learning new HPs and mixture probabilities</p></a></li>
<li><a href='#train_magma'><p>Training Magma with an EM algorithm</p></a></li>
<li><a href='#train_magmaclust'><p>Training MagmaClust with a Variational EM algorithm</p></a></li>
<li><a href='#update_mixture'><p>Update the mixture probabilities for each individual and each cluster</p></a></li>
<li><a href='#ve_step'><p>E-Step of the VEM algorithm</p></a></li>
<li><a href='#vm_step'><p>V-Step of the VEM algorithm</p></a></li>
<li><a href='#weight'><p>Weight follow-up data of children in Singapore</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Clustering and Prediction using Multi-Task Gaussian Processes
with Common Mean</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.0</td>
</tr>
<tr>
<td>Description:</td>
<td>An implementation for the multi-task Gaussian processes with common 
    mean framework. Two main algorithms, called 'Magma' and 'MagmaClust', 
    are available to perform predictions for supervised learning problems, in
    particular for time series or any functional/continuous data applications.
    The corresponding articles has been respectively proposed by Arthur Leroy, 
    Pierre Latouche, Benjamin Guedj and Servane Gey (2022) 
    &lt;<a href="https://doi.org/10.1007%2Fs10994-022-06172-1">doi:10.1007/s10994-022-06172-1</a>&gt;, and Arthur Leroy, Pierre Latouche, 
    Benjamin Guedj and Servane Gey (2023) <a href="https://jmlr.org/papers/v24/20-1321.html">https://jmlr.org/papers/v24/20-1321.html</a>.
    Theses approaches leverage the learning of cluster-specific mean processes,
    which are common across similar tasks, to provide enhanced prediction
    performances (even far from data) at a linear computational cost (in
    the number of tasks).  'MagmaClust' is a generalisation of 'Magma'
    where the tasks are simultaneously clustered into groups, each being
    associated to a specific mean process.  User-oriented functions in the
    package are decomposed into training, prediction and plotting
    functions. Some basic features (classic kernels, training, prediction) of
    standard Gaussian processes are also implemented. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ArthurLeroy/MagmaClustR">https://github.com/ArthurLeroy/MagmaClustR</a>,
<a href="https://arthurleroy.github.io/MagmaClustR/">https://arthurleroy.github.io/MagmaClustR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ArthurLeroy/MagmaClustR/issues">https://github.com/ArthurLeroy/MagmaClustR/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>broom, dplyr, ggplot2, magrittr, methods, mvtnorm, plyr,
purrr, Rcpp, rlang, stats, tibble, tidyr, tidyselect</td>
</tr>
<tr>
<td>Suggests:</td>
<td>gganimate, gifski, gridExtra, knitr, plotly, png, rmarkdown,
testthat (&ge; 3.0.0), transformr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-21 16:36:10 UTC; Arthur Leroy</td>
</tr>
<tr>
<td>Author:</td>
<td>Arthur Leroy <a href="https://orcid.org/0000-0003-0806-8934"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Pierre Latouche [aut],
  Pierre Path√© [ctb],
  Alexia Grenouillat [ctb],
  Hugo Lelievre [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Arthur Leroy &lt;arthur.leroy.pro@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-21 17:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='MagmaClustR'>MagmaClustR : Clustering and Prediction using Multi-Task Gaussian Processes</h2><span id='topic+MagmaClustR'></span><span id='topic+MagmaClustR-package'></span>

<h3>Description</h3>

<p>The <strong>MagmaClustR</strong> package implements two main algorithms, called
<em>Magma</em> and <em>MagmaClust</em>, using a multi-task GPs model to perform
predictions for supervised learning problems. Theses approaches leverage
the learning of cluster-specific mean processes, which are common across
similar tasks, to provide enhanced prediction performances (even far from
data) at a linear computational cost (in the number of tasks).
<em>MagmaClust</em> is a generalisation of <em>Magma</em> where the tasks are
simultaneously clustered into groups, each being associated to a specific
mean process. User-oriented functions in the package are decomposed into
training, prediction and plotting functions. Some basic features of
standard GPs are also implemented.
</p>


<h3>Details</h3>

<p>For a quick introduction to <span class="pkg">MagmaClustR</span>, please refer to the README at
<a href="https://github.com/ArthurLeroy/MagmaClustR">https://github.com/ArthurLeroy/MagmaClustR</a>
</p>


<h3>Author(s)</h3>

<p>Arthur Leroy, Pierre Pathe and Pierre Latouche <br />
Maintainer: Arthur Leroy - <a href="mailto:arthur.leroy.pro@gmail.com">arthur.leroy.pro@gmail.com</a>
</p>


<h3>References</h3>

<p>Arthur Leroy, Pierre Latouche, Benjamin Guedj, and Servane Gey. <br />
MAGMA: Inference and Prediction with Multi-Task Gaussian Processes.
<em>Machine Learning</em>, 2022,
<a href="https://link.springer.com/article/10.1007/s10994-022-06172-1">https://link.springer.com/article/10.1007/s10994-022-06172-1</a>
</p>
<p>Arthur Leroy, Pierre Latouche, Benjamin Guedj, and Servane Gey. <br />
Cluster-Specific Predictions with Multi-Task Gaussian Processes.
<em>Journal of Machine Learning Research</em>, 2023,
<a href="https://jmlr.org/papers/v24/20-1321.html">https://jmlr.org/papers/v24/20-1321.html</a>
</p>


<h3>Examples</h3>



<h4>Simulate a dataset, train and predict with Magma <br /></h4>

<p>set.seed(4242) <br />
data_magma &lt;- simu_db(M = 11, N = 10, K = 1) <br />
magma_train &lt;- data_magma %&gt;% subset(ID %in% 1:10) <br />
magma_test &lt;- data_magma %&gt;% subset(ID == 11) %&gt;% head(7) <br />
</p>
<p>magma_model &lt;- train_magma(data = magma_train) <br />
magma_pred  &lt;- pred_magma(data = magma_test, trained_model = magma_model,
grid_inputs = seq(0, 10, 0.01)) <br />
</p>



<h4>Simulate a dataset, train and predict with MagmaClust <br /></h4>

<p>set.seed(4242) <br />
data_magmaclust &lt;- simu_db(M = 4, N = 10, K = 3) <br />
list_ID = unique(data_magmaclust$ID) <br />
magmaclust_train &lt;- data_magmaclust %&gt;% subset(ID %in% list_ID[1:11]) <br />
magmaclust_test &lt;- data_magmaclust %&gt;% subset(ID == list_ID[12]) %&gt;%
head(5)<br />
</p>
<p>magmaclust_model &lt;- train_magmaclust(data = magmaclust_train) <br />
magmaclust_pred  &lt;- pred_magmaclust(data = magmaclust_test, <br />
trained_model = magmaclust_model, grid_inputs = seq(0, 10, 0.01)) <br />
</p>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Arthur Leroy <a href="mailto:arthur.leroy.pro@gmail.com">arthur.leroy.pro@gmail.com</a> (<a href="https://orcid.org/0000-0003-0806-8934">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Pierre Latouche <a href="mailto:pierre.latouche@gmail.com">pierre.latouche@gmail.com</a>
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Pierre Path√© <a href="mailto:pathepierre@gmail.com">pathepierre@gmail.com</a> [contributor]
</p>
</li>
<li><p> Alexia Grenouillat <a href="mailto:grenouil@insa-toulouse.fr">grenouil@insa-toulouse.fr</a> [contributor]
</p>
</li>
<li><p> Hugo Lelievre <a href="mailto:lelievre@insa-toulouse.fr">lelievre@insa-toulouse.fr</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ArthurLeroy/MagmaClustR">https://github.com/ArthurLeroy/MagmaClustR</a>
</p>
</li>
<li> <p><a href="https://arthurleroy.github.io/MagmaClustR/">https://arthurleroy.github.io/MagmaClustR/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ArthurLeroy/MagmaClustR/issues">https://github.com/ArthurLeroy/MagmaClustR/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='chol_inv_jitter'>Inverse a matrix using an adaptive jitter term</h2><span id='topic+chol_inv_jitter'></span>

<h3>Description</h3>

<p>Inverse a matrix from its Choleski decomposition. If (nearly-)singular,
increase the order of magnitude of the jitter term added to the diagonal
until the matrix becomes non-singular.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chol_inv_jitter(mat, pen_diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chol_inv_jitter_+3A_mat">mat</code></td>
<td>
<p>A matrix, possibly singular.</p>
</td></tr>
<tr><td><code id="chol_inv_jitter_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A number, a jitter term to add on the diagonal.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix, inverse of <code>mat</code> plus an adaptive jitter term
added on the diagonal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='data_allocate_cluster'>Allocate training data into the most probable cluster</h2><span id='topic+data_allocate_cluster'></span>

<h3>Description</h3>

<p>Allocate training data into the most probable cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_allocate_cluster(trained_model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="data_allocate_cluster_+3A_trained_model">trained_model</code></td>
<td>
<p>A list, containing  the information coming from a
MagmaClust model, previously trained using the
<code><a href="#topic+train_magmaclust">train_magmaclust</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original dataset used to train the MagmaClust model, with
additional 'Cluster' and associated 'Proba' columns, indicating the most
probable cluster for each individual/task at the end of the training
procedure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='dmnorm'>Compute the Multivariate Gaussian likelihood</h2><span id='topic+dmnorm'></span>

<h3>Description</h3>

<p>Modification of the function <code>dmvnorm()</code> from the package
<code>mvtnorm</code>, providing an implementation of the Multivariate Gaussian
likelihood. This version uses inverse of the covariance function as argument
instead of the traditional covariance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmnorm(x, mu, inv_Sigma, log = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmnorm_+3A_x">x</code></td>
<td>
<p>A vector, containing values the likelihood is evaluated on.</p>
</td></tr>
<tr><td><code id="dmnorm_+3A_mu">mu</code></td>
<td>
<p>A vector or matrix, specifying the mean parameter.</p>
</td></tr>
<tr><td><code id="dmnorm_+3A_inv_sigma">inv_Sigma</code></td>
<td>
<p>A matrix, specifying the inverse of covariance parameter.</p>
</td></tr>
<tr><td><code id="dmnorm_+3A_log">log</code></td>
<td>
<p>A logical value, indicating whether we return the log-likelihood.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number, corresponding to the Multivariate Gaussian log-likelihood.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='draw'>Draw a number</h2><span id='topic+draw'></span>

<h3>Description</h3>

<p>Draw uniformly a number within a specified interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw(int)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_+3A_int">int</code></td>
<td>
<p>An interval of values we want to draw uniformly in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-decimals-rounded random number
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='e_step'>E-Step of the EM algorithm</h2><span id='topic+e_step'></span>

<h3>Description</h3>

<p>Expectation step of the EM algorithm to compute the parameters of the
hyper-posterior Gaussian distribution of the mean process in Magma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e_step(db, m_0, kern_0, kern_i, hp_0, hp_i, pen_diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="e_step_+3A_db">db</code></td>
<td>
<p>A tibble or data frame. Columns required: ID, Input, Output.
Additional columns for covariates can be specified.</p>
</td></tr>
<tr><td><code id="e_step_+3A_m_0">m_0</code></td>
<td>
<p>A vector, corresponding to the prior mean of the mean GP.</p>
</td></tr>
<tr><td><code id="e_step_+3A_kern_0">kern_0</code></td>
<td>
<p>A kernel function, associated with the mean GP.</p>
</td></tr>
<tr><td><code id="e_step_+3A_kern_i">kern_i</code></td>
<td>
<p>A kernel function, associated with the individual GPs.</p>
</td></tr>
<tr><td><code id="e_step_+3A_hp_0">hp_0</code></td>
<td>
<p>A named vector, tibble or data frame of hyper-parameters
associated with <code>kern_0</code>.</p>
</td></tr>
<tr><td><code id="e_step_+3A_hp_i">hp_i</code></td>
<td>
<p>A tibble or data frame of hyper-parameters
associated with <code>kern_i</code>.</p>
</td></tr>
<tr><td><code id="e_step_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A number. A jitter term, added on the diagonal to prevent
numerical issues when inverting nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list, containing the elements <code>mean</code>, a tibble
containing the Input and associated Output of the hyper-posterior's mean
parameter, and <code>cov</code>, the hyper-posterior's covariance matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='elbo_clust_multi_GP'>Evidence Lower Bound for a mixture of GPs</h2><span id='topic+elbo_clust_multi_GP'></span>

<h3>Description</h3>

<p>Evidence Lower Bound for a mixture of GPs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elbo_clust_multi_GP(hp, db, hyperpost, kern, pen_diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elbo_clust_multi_GP_+3A_hp">hp</code></td>
<td>
<p>A tibble, data frame or named vector containing hyper-parameters.</p>
</td></tr>
<tr><td><code id="elbo_clust_multi_GP_+3A_db">db</code></td>
<td>
<p>A tibble containing the values we want to compute the elbo on.
Required columns: Input, Output. Additional covariate columns are allowed.</p>
</td></tr>
<tr><td><code id="elbo_clust_multi_GP_+3A_hyperpost">hyperpost</code></td>
<td>
<p>List of parameters for the K mean GPs.</p>
</td></tr>
<tr><td><code id="elbo_clust_multi_GP_+3A_kern">kern</code></td>
<td>
<p>A kernel function used to compute the covariance matrix at
corresponding timestamps.</p>
</td></tr>
<tr><td><code id="elbo_clust_multi_GP_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A jitter term that is added to the covariance matrix to avoid
numerical issues when inverting, in cases of nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the penalised Gaussian elbo for a mixture of GPs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='elbo_clust_multi_GP_common_hp_i'>Penalised elbo for multiple individual GPs with common HPs</h2><span id='topic+elbo_clust_multi_GP_common_hp_i'></span>

<h3>Description</h3>

<p>Penalised elbo for multiple individual GPs with common HPs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elbo_clust_multi_GP_common_hp_i(hp, db, hyperpost, kern, pen_diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elbo_clust_multi_GP_common_hp_i_+3A_hp">hp</code></td>
<td>
<p>A tibble, data frame or named vector containing hyper-parameters.</p>
</td></tr>
<tr><td><code id="elbo_clust_multi_GP_common_hp_i_+3A_db">db</code></td>
<td>
<p>A tibble containing values we want to compute elbo on.
Required columns: Input, Output. Additional covariate columns are allowed.</p>
</td></tr>
<tr><td><code id="elbo_clust_multi_GP_common_hp_i_+3A_hyperpost">hyperpost</code></td>
<td>
<p>List of parameters for the K mean Gaussian processes.</p>
</td></tr>
<tr><td><code id="elbo_clust_multi_GP_common_hp_i_+3A_kern">kern</code></td>
<td>
<p>A kernel function used to compute the covariance matrix at
corresponding timestamps.</p>
</td></tr>
<tr><td><code id="elbo_clust_multi_GP_common_hp_i_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A jitter term that is added to the covariance matrix to avoid
numerical issues when inverting, in cases of nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the penalised Gaussian elbo for
the sum of the M individual GPs with common HPs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='elbo_GP_mod_common_hp_k'>Penalised elbo for multiple mean GPs with common HPs</h2><span id='topic+elbo_GP_mod_common_hp_k'></span>

<h3>Description</h3>

<p>Penalised elbo for multiple mean GPs with common HPs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elbo_GP_mod_common_hp_k(hp, db, mean, kern, post_cov, pen_diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elbo_GP_mod_common_hp_k_+3A_hp">hp</code></td>
<td>
<p>A tibble, data frame or named vector containing hyper-parameters.</p>
</td></tr>
<tr><td><code id="elbo_GP_mod_common_hp_k_+3A_db">db</code></td>
<td>
<p>A tibble containing values we want to compute elbo on.
Required columns: Input, Output. Additional covariate columns are allowed.</p>
</td></tr>
<tr><td><code id="elbo_GP_mod_common_hp_k_+3A_mean">mean</code></td>
<td>
<p>A list of the K mean GPs at union of observed timestamps.</p>
</td></tr>
<tr><td><code id="elbo_GP_mod_common_hp_k_+3A_kern">kern</code></td>
<td>
<p>A kernel function used to compute the covariance matrix at
corresponding timestamps.</p>
</td></tr>
<tr><td><code id="elbo_GP_mod_common_hp_k_+3A_post_cov">post_cov</code></td>
<td>
<p>A List of the K posterior covariance of the mean GP (mu_k).
Used to compute correction term (cor_term).</p>
</td></tr>
<tr><td><code id="elbo_GP_mod_common_hp_k_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A jitter term that is added to the covariance matrix to avoid
numerical issues when inverting, in cases of nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the penalised Gaussian elbo for
the sum of the k mean GPs with common HPs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='elbo_monitoring_VEM'>Evidence Lower Bound maximised in MagmaClust</h2><span id='topic+elbo_monitoring_VEM'></span>

<h3>Description</h3>

<p>Evidence Lower Bound maximised in MagmaClust
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elbo_monitoring_VEM(hp_k, hp_i, db, kern_i, kern_k, hyperpost, m_k, pen_diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elbo_monitoring_VEM_+3A_hp_k">hp_k</code></td>
<td>
<p>A tibble, data frame or named vector of hyper-parameters
for each clusters.</p>
</td></tr>
<tr><td><code id="elbo_monitoring_VEM_+3A_hp_i">hp_i</code></td>
<td>
<p>A tibble, data frame or named vector of hyper-parameters
for each individuals.</p>
</td></tr>
<tr><td><code id="elbo_monitoring_VEM_+3A_db">db</code></td>
<td>
<p>A tibble containing values we want to compute elbo on.
Required columns: Input, Output. Additional covariate columns are allowed.</p>
</td></tr>
<tr><td><code id="elbo_monitoring_VEM_+3A_kern_i">kern_i</code></td>
<td>
<p>Kernel used to compute the covariance matrix of individuals GPs
at corresponding inputs.</p>
</td></tr>
<tr><td><code id="elbo_monitoring_VEM_+3A_kern_k">kern_k</code></td>
<td>
<p>Kernel used to compute the covariance matrix of the mean GPs
at corresponding inputs.</p>
</td></tr>
<tr><td><code id="elbo_monitoring_VEM_+3A_hyperpost">hyperpost</code></td>
<td>
<p>A list of parameters for the variational distributions
of the K mean GPs.</p>
</td></tr>
<tr><td><code id="elbo_monitoring_VEM_+3A_m_k">m_k</code></td>
<td>
<p>Prior value of the mean parameter of the mean GPs (mu_k).
Length = 1 or nrow(db).</p>
</td></tr>
<tr><td><code id="elbo_monitoring_VEM_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A jitter term that is added to the covariance matrix to avoid
numerical issues when inverting, in cases of nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of the elbo that is maximised during the VEM algorithm used for
training in MagmaClust.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='expand_grid_inputs'>Expand a grid of inputs</h2><span id='topic+expand_grid_inputs'></span>

<h3>Description</h3>

<p>Expand a grid of inputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_grid_inputs(Input, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_grid_inputs_+3A_input">Input</code></td>
<td>
<p>A vector of inputs.</p>
</td></tr>
<tr><td><code id="expand_grid_inputs_+3A_...">...</code></td>
<td>
<p>As many vector of covariates as desired. We advise to give
explicit names when using the function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing all the combination of values of the
parameters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='gr_clust_multi_GP'>Gradient of the elbo for a mixture of GPs</h2><span id='topic+gr_clust_multi_GP'></span>

<h3>Description</h3>

<p>Gradient of the elbo for a mixture of GPs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gr_clust_multi_GP(hp, db, hyperpost, kern, pen_diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gr_clust_multi_GP_+3A_hp">hp</code></td>
<td>
<p>A tibble, data frame or named vector containing hyper-parameters.</p>
</td></tr>
<tr><td><code id="gr_clust_multi_GP_+3A_db">db</code></td>
<td>
<p>A tibble containing the values we want to compute the elbo on.
Required columns: Input, Output. Additional covariate columns are allowed.</p>
</td></tr>
<tr><td><code id="gr_clust_multi_GP_+3A_hyperpost">hyperpost</code></td>
<td>
<p>List of parameters for the K mean Gaussian processes.</p>
</td></tr>
<tr><td><code id="gr_clust_multi_GP_+3A_kern">kern</code></td>
<td>
<p>A kernel function.</p>
</td></tr>
<tr><td><code id="gr_clust_multi_GP_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A jitter term that is added to the covariance matrix to avoid
numerical issues when inverting, in cases of nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The gradient of the penalised Gaussian elbo for a mixture of GPs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='gr_clust_multi_GP_common_hp_i'>Gradient of the penalised elbo for multiple individual GPs with common HPs</h2><span id='topic+gr_clust_multi_GP_common_hp_i'></span>

<h3>Description</h3>

<p>Gradient of the penalised elbo for multiple individual GPs with common HPs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gr_clust_multi_GP_common_hp_i(hp, db, hyperpost, kern, pen_diag = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gr_clust_multi_GP_common_hp_i_+3A_hp">hp</code></td>
<td>
<p>A tibble, data frame or name vector of hyper-parameters.</p>
</td></tr>
<tr><td><code id="gr_clust_multi_GP_common_hp_i_+3A_db">db</code></td>
<td>
<p>A tibble containing values we want to compute elbo on.
Required columns: Input, Output. Additional covariate columns are allowed.</p>
</td></tr>
<tr><td><code id="gr_clust_multi_GP_common_hp_i_+3A_hyperpost">hyperpost</code></td>
<td>
<p>List of parameters for the K mean Gaussian processes.</p>
</td></tr>
<tr><td><code id="gr_clust_multi_GP_common_hp_i_+3A_kern">kern</code></td>
<td>
<p>A kernel function used to compute the covariance matrix at
corresponding timestamps.</p>
</td></tr>
<tr><td><code id="gr_clust_multi_GP_common_hp_i_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A jitter term that is added to the covariance matrix to avoid
numerical issues when inverting, in cases of nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The gradient of the penalised Gaussian elbo for
the sum of the M individual GPs with common HPs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='gr_GP'>Gradient of the logLikelihood of a Gaussian Process</h2><span id='topic+gr_GP'></span>

<h3>Description</h3>

<p>Gradient of the logLikelihood of a Gaussian Process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gr_GP(hp, db, mean, kern, post_cov, pen_diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gr_GP_+3A_hp">hp</code></td>
<td>
<p>A tibble, data frame or named vector containing hyper-parameters.</p>
</td></tr>
<tr><td><code id="gr_GP_+3A_db">db</code></td>
<td>
<p>A tibble containing the values we want to compute the logL on.
Required columns: Input, Output. Additional covariate columns are allowed.</p>
</td></tr>
<tr><td><code id="gr_GP_+3A_mean">mean</code></td>
<td>
<p>A vector, specifying the mean of the GP at the reference inputs.</p>
</td></tr>
<tr><td><code id="gr_GP_+3A_kern">kern</code></td>
<td>
<p>A kernel function.</p>
</td></tr>
<tr><td><code id="gr_GP_+3A_post_cov">post_cov</code></td>
<td>
<p>(optional) A matrix, corresponding to covariance parameter of
the hyper-posterior. Used to compute the hyper-prior distribution of a new
individual in Magma.</p>
</td></tr>
<tr><td><code id="gr_GP_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A jitter term that is added to the covariance matrix to avoid
numerical issues when inverting, in cases of nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector, corresponding to the value of the hyper-parameters
gradients for the Gaussian log-Likelihood (where the covariance can be the
sum of the individual and the hyper-posterior's mean process covariances).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='gr_GP_mod'>Gradient of the modified logLikelihood for GPs in Magma</h2><span id='topic+gr_GP_mod'></span>

<h3>Description</h3>

<p>Gradient of the modified logLikelihood for GPs in Magma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gr_GP_mod(hp, db, mean, kern, post_cov, pen_diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gr_GP_mod_+3A_hp">hp</code></td>
<td>
<p>A tibble, data frame or named vector containing hyper-parameters.</p>
</td></tr>
<tr><td><code id="gr_GP_mod_+3A_db">db</code></td>
<td>
<p>A tibble containing the values we want to compute the logL on.
Required columns: Input, Output. Additional covariate columns are allowed.</p>
</td></tr>
<tr><td><code id="gr_GP_mod_+3A_mean">mean</code></td>
<td>
<p>A vector, specifying the mean of the GPs at the reference inputs.</p>
</td></tr>
<tr><td><code id="gr_GP_mod_+3A_kern">kern</code></td>
<td>
<p>A kernel function.</p>
</td></tr>
<tr><td><code id="gr_GP_mod_+3A_post_cov">post_cov</code></td>
<td>
<p>A matrix, covariance parameter of the hyper-posterior.
Used to compute the correction term.</p>
</td></tr>
<tr><td><code id="gr_GP_mod_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A jitter term that is added to the covariance matrix to avoid
numerical issues when inverting, in cases of nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector, corresponding to the value of the hyper-parameters
gradients for the modified Gaussian log-Likelihood involved in Magma.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='gr_GP_mod_common_hp'>Gradient of the modified logLikelihood with common HPs for GPs in Magma</h2><span id='topic+gr_GP_mod_common_hp'></span>

<h3>Description</h3>

<p>Gradient of the modified logLikelihood with common HPs for GPs in Magma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gr_GP_mod_common_hp(hp, db, mean, kern, post_cov, pen_diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gr_GP_mod_common_hp_+3A_hp">hp</code></td>
<td>
<p>A tibble or data frame containing hyper-parameters for all
individuals.</p>
</td></tr>
<tr><td><code id="gr_GP_mod_common_hp_+3A_db">db</code></td>
<td>
<p>A tibble containing the values we want to compute the logL on.
Required columns: ID, Input, Output. Additional covariate columns are
allowed.</p>
</td></tr>
<tr><td><code id="gr_GP_mod_common_hp_+3A_mean">mean</code></td>
<td>
<p>A vector, specifying the mean of the GPs at the reference inputs.</p>
</td></tr>
<tr><td><code id="gr_GP_mod_common_hp_+3A_kern">kern</code></td>
<td>
<p>A kernel function.</p>
</td></tr>
<tr><td><code id="gr_GP_mod_common_hp_+3A_post_cov">post_cov</code></td>
<td>
<p>A matrix, covariance parameter of the hyper-posterior.
Used to compute the correction term.</p>
</td></tr>
<tr><td><code id="gr_GP_mod_common_hp_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A jitter term that is added to the covariance matrix to avoid
numerical issues when inverting, in cases of nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector, corresponding to the value of the hyper-parameters'
gradients for the modified Gaussian log-Likelihood involved in Magma with
the 'common HP' setting.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='gr_GP_mod_common_hp_k'>Gradient of the penalised elbo for multiple mean GPs with common HPs</h2><span id='topic+gr_GP_mod_common_hp_k'></span>

<h3>Description</h3>

<p>Gradient of the penalised elbo for multiple mean GPs with common HPs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gr_GP_mod_common_hp_k(hp, db, mean, kern, post_cov, pen_diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gr_GP_mod_common_hp_k_+3A_hp">hp</code></td>
<td>
<p>A tibble, data frame or named vector containing hyper-parameters.</p>
</td></tr>
<tr><td><code id="gr_GP_mod_common_hp_k_+3A_db">db</code></td>
<td>
<p>A tibble containing the values we want to compute the elbo on.
Required columns: Input, Output. Additional covariate columns are allowed.</p>
</td></tr>
<tr><td><code id="gr_GP_mod_common_hp_k_+3A_mean">mean</code></td>
<td>
<p>A list of the k means of the GPs at union of observed timestamps.</p>
</td></tr>
<tr><td><code id="gr_GP_mod_common_hp_k_+3A_kern">kern</code></td>
<td>
<p>A kernel function</p>
</td></tr>
<tr><td><code id="gr_GP_mod_common_hp_k_+3A_post_cov">post_cov</code></td>
<td>
<p>A list of the k posterior covariance of the mean GP (mu_k).
Used to compute correction term (cor_term)</p>
</td></tr>
<tr><td><code id="gr_GP_mod_common_hp_k_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A jitter term that is added to the covariance matrix to avoid
numerical issues when inverting, in cases of nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The gradient of the penalised Gaussian elbo for
the sum of the k mean GPs with common HPs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='gr_sum_logL_GP_clust'>Gradient of the mixture of Gaussian likelihoods</h2><span id='topic+gr_sum_logL_GP_clust'></span>

<h3>Description</h3>

<p>Compute the gradient of a sum of Gaussian log-likelihoods, weighted by their
mixture probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gr_sum_logL_GP_clust(hp, db, mixture, mean, kern, post_cov, pen_diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gr_sum_logL_GP_clust_+3A_hp">hp</code></td>
<td>
<p>A tibble, data frame or named vector of hyper-parameters.</p>
</td></tr>
<tr><td><code id="gr_sum_logL_GP_clust_+3A_db">db</code></td>
<td>
<p>A tibble containing data we want to evaluate the logL on.
Required columns: Input, Output. Additional covariate columns are allowed.</p>
</td></tr>
<tr><td><code id="gr_sum_logL_GP_clust_+3A_mixture">mixture</code></td>
<td>
<p>A tibble or data frame, indicating the mixture probabilities
of each cluster for the new individual/task.</p>
</td></tr>
<tr><td><code id="gr_sum_logL_GP_clust_+3A_mean">mean</code></td>
<td>
<p>A list of hyper-posterior mean parameters for all clusters.</p>
</td></tr>
<tr><td><code id="gr_sum_logL_GP_clust_+3A_kern">kern</code></td>
<td>
<p>A kernel function.</p>
</td></tr>
<tr><td><code id="gr_sum_logL_GP_clust_+3A_post_cov">post_cov</code></td>
<td>
<p>A list of hyper-posterior covariance parameters for all
clusters.</p>
</td></tr>
<tr><td><code id="gr_sum_logL_GP_clust_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A jitter term that is added to the covariance matrix to avoid
numerical issues when inverting, in cases of nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector, corresponding to the value of the hyper-parameters'
gradients for the mixture of Gaussian log-likelihoods involved in the
prediction step of MagmaClust.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='hp'>Generate random hyper-parameters</h2><span id='topic+hp'></span>

<h3>Description</h3>

<p>Generate a set of random hyper-parameters, specific to the chosen type of
kernel, under the format that is used in Magma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hp(
  kern = "SE",
  list_ID = NULL,
  list_hp = NULL,
  noise = FALSE,
  common_hp = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hp_+3A_kern">kern</code></td>
<td>
<p>A function, or a character string indicating the chosen type of
kernel among:
</p>

<ul>
<li><p> &quot;SE&quot;: the Squared Exponential kernel,
</p>
</li>
<li><p> &quot;LIN&quot;: the Linear kernel,
</p>
</li>
<li><p> &quot;PERIO&quot;: the Periodic kernel,
</p>
</li>
<li><p> &quot;RQ&quot;: the Rational Quadratic kernel.
Compound kernels can be created as sums or products of the above kernels.
For combining kernels, simply provide a formula as a character string
where elements are separated by whitespaces (e.g. &quot;SE + PERIO&quot;). As the
elements are treated sequentially from the left to the right, the product
operator '*' shall always be used before the '+' operators (e.g.
'SE * LIN + RQ' is valid whereas 'RQ + SE * LIN' is  not).
</p>
</li></ul>

<p>In case of a custom kernel function, the argument <code>list_hp</code> has to be
provided as well, for designing a tibble with the correct names of
hyper-parameters.</p>
</td></tr>
<tr><td><code id="hp_+3A_list_id">list_ID</code></td>
<td>
<p>A vector, associating an <code>ID</code> value with each individual
for whom hyper-parameters are generated. If NULL (default) only one set of
hyper-parameters is return without the <code>ID</code> column.</p>
</td></tr>
<tr><td><code id="hp_+3A_list_hp">list_hp</code></td>
<td>
<p>A vector of characters, providing the name of each
hyper-parameter, in case where <code>kern</code> is a custom kernel function.</p>
</td></tr>
<tr><td><code id="hp_+3A_noise">noise</code></td>
<td>
<p>A logical value, indicating whether a 'noise' hyper-parameter
should be included.</p>
</td></tr>
<tr><td><code id="hp_+3A_common_hp">common_hp</code></td>
<td>
<p>A logical value, indicating whether the set of
hyper-parameters is assumed to be common to all individuals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, providing a set of random hyper-parameters associated with
the kernel specified through the argument <code>kern</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='hyperposterior'>Compute the hyper-posterior distribution in Magma</h2><span id='topic+hyperposterior'></span>

<h3>Description</h3>

<p>Compute the parameters of the hyper-posterior Gaussian distribution of the
mean process in Magma (similarly to the expectation step of the EM
algorithm used for learning). This hyper-posterior distribution, evaluated
on a grid of inputs provided through the <code>grid_inputs</code> argument, is a
key component for making prediction in Magma, and is required in the function
<code><a href="#topic+pred_magma">pred_magma</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperposterior(
  trained_model = NULL,
  data = NULL,
  hp_0 = NULL,
  hp_i = NULL,
  kern_0 = NULL,
  kern_i = NULL,
  prior_mean = NULL,
  grid_inputs = NULL,
  pen_diag = 1e-10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyperposterior_+3A_trained_model">trained_model</code></td>
<td>
<p>A list, containing  the information coming from a
Magma model, previously trained using the <code><a href="#topic+train_magma">train_magma</a></code>
function. If <code>trained_model</code> is not provided, the arguments
<code>data</code>, <code>hp_0</code>, <code>hp_i</code>, <code>kern_0</code>, and <code>kern_i</code>
are all required.</p>
</td></tr>
<tr><td><code id="hyperposterior_+3A_data">data</code></td>
<td>
<p>A tibble or data frame. Required columns: 'Input',
'Output'. Additional columns for covariates can be specified.
The 'Input' column should define the variable that is used as
reference for the observations (e.g. time for longitudinal data). The
'Output' column specifies the observed values (the response
variable). The data frame can also provide as many covariates as desired,
with no constraints on the column names. These covariates are additional
inputs (explanatory variables) of the models that are also observed at
each reference 'Input'. Recovered from <code>trained_model</code> if not
provided.</p>
</td></tr>
<tr><td><code id="hyperposterior_+3A_hp_0">hp_0</code></td>
<td>
<p>A named vector, tibble or data frame of hyper-parameters
associated with <code>kern_0</code>. Recovered from <code>trained_model</code> if not
provided.</p>
</td></tr>
<tr><td><code id="hyperposterior_+3A_hp_i">hp_i</code></td>
<td>
<p>A tibble or data frame of hyper-parameters
associated with <code>kern_i</code>. Recovered from <code>trained_model</code> if not
provided.</p>
</td></tr>
<tr><td><code id="hyperposterior_+3A_kern_0">kern_0</code></td>
<td>
<p>A kernel function, associated with the mean GP.
Several popular kernels
(see <a href="https://www.cs.toronto.edu/~duvenaud/cookbook/">The Kernel
Cookbook</a>) are already implemented and can be selected within the
following list:
</p>

<ul>
<li><p> &quot;SE&quot;: (default value) the Squared Exponential Kernel (also called
Radial Basis Function or Gaussian kernel),
</p>
</li>
<li><p> &quot;LIN&quot;: the Linear kernel,
</p>
</li>
<li><p> &quot;PERIO&quot;: the Periodic kernel,
</p>
</li>
<li><p> &quot;RQ&quot;: the Rational Quadratic kernel.
Compound kernels can be created as sums or products of the above kernels.
For combining kernels, simply provide a formula as a character string
where elements are separated by whitespaces (e.g. &quot;SE + PERIO&quot;). As the
elements are treated sequentially from the left to the right, the product
operator '*' shall always be used before the '+' operators (e.g.
'SE * LIN + RQ' is valid whereas 'RQ + SE * LIN' is  not). Recovered from
<code>trained_model</code> if not provided.
</p>
</li></ul>
</td></tr>
<tr><td><code id="hyperposterior_+3A_kern_i">kern_i</code></td>
<td>
<p>A kernel function, associated with the individual GPs. (&quot;SE&quot;,
&quot;PERIO&quot; and &quot;RQ&quot; are aso available here). Recovered from
<code>trained_model</code> if not provided.</p>
</td></tr>
<tr><td><code id="hyperposterior_+3A_prior_mean">prior_mean</code></td>
<td>
<p>Hyper-prior mean parameter of the mean GP. This argument,
can be specified under various formats, such as:
</p>

<ul>
<li><p> NULL (default). The hyper-prior mean would be set to 0 everywhere.
</p>
</li>
<li><p> A number. The hyper-prior mean would be a constant function.
</p>
</li>
<li><p> A vector of the same length as all the distinct Input values in the
<code>data</code> argument. This vector would be considered as the evaluation
of the hyper-prior mean function at the training Inputs.
</p>
</li>
<li><p> A function. This function is defined as the hyper-prior mean.
</p>
</li>
<li><p> A tibble or data frame. Required columns: Input, Output. The Input
values should include at least the same values as in the <code>data</code>
argument.
</p>
</li></ul>
</td></tr>
<tr><td><code id="hyperposterior_+3A_grid_inputs">grid_inputs</code></td>
<td>
<p>A vector or a data frame, indicating the grid of
additional reference inputs on which the mean process' hyper-posterior
should be evaluated.</p>
</td></tr>
<tr><td><code id="hyperposterior_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A number. A jitter term, added on the diagonal to prevent
numerical issues when inverting nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list gathering the parameters of the mean processes'
hyper-posterior distributions, namely:
</p>

<ul>
<li><p> mean: A tibble, the hyper-posterior mean parameter
evaluated at each training <code>Input</code>.
</p>
</li>
<li><p> cov: A matrix, the covariance parameter for the
hyper-posterior distribution of the mean process.
</p>
</li>
<li><p> pred: A tibble, the predicted mean and variance at
<code>Input</code> for the mean process' hyper-posterior
distribution under a format that allows the direct
visualisation as a GP prediction.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='hyperposterior_clust'>Compute the hyper-posterior distribution for each cluster in MagmaClust</h2><span id='topic+hyperposterior_clust'></span>

<h3>Description</h3>

<p>Recompute the E-step of the VEM algorithm in MagmaClust for a new set of
reference <code>Input</code>. Once training is completed, it can be necessary to
evaluate the hyper-posterior distributions of the mean processes at specific
locations, for which we want to make predictions. This process is directly
implemented in the <code><a href="#topic+pred_magmaclust">pred_magmaclust</a></code> function but the user
might want to use <code>hyperpost_clust</code> for a tailored control of
the prediction procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hyperposterior_clust(
  trained_model = NULL,
  data = NULL,
  mixture = NULL,
  hp_k = NULL,
  hp_i = NULL,
  kern_k = NULL,
  kern_i = NULL,
  prior_mean_k = NULL,
  grid_inputs = NULL,
  pen_diag = 1e-10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hyperposterior_clust_+3A_trained_model">trained_model</code></td>
<td>
<p>A list, containing  the information coming from a
Magma model, previously trained using the <code><a href="#topic+train_magma">train_magma</a></code>
function. If <code>trained_model</code> is not provided, the arguments
<code>data</code>, <code>mixture</code>, <code>hp_k</code>, <code>hp_i</code>, <code>kern_k</code>, and
<code>kern_i</code> are all required.</p>
</td></tr>
<tr><td><code id="hyperposterior_clust_+3A_data">data</code></td>
<td>
<p>A tibble or data frame. Required columns: <code>ID</code>, <code>Input</code>
, <code>Output</code>. Additional columns for covariates can be specified.
The <code>ID</code> column contains the unique names/codes used to identify each
individual/task (or batch of data).
The <code>Input</code> column should define the variable that is used as
reference for the observations (e.g. time for longitudinal data). The
<code>Output</code> column specifies the observed values (the response
variable). The data frame can also provide as many covariates as desired,
with no constraints on the column names. These covariates are additional
inputs (explanatory variables) of the models that are also observed at
each reference <code>Input</code>. Recovered from <code>trained_model</code> if not
provided.</p>
</td></tr>
<tr><td><code id="hyperposterior_clust_+3A_mixture">mixture</code></td>
<td>
<p>A tibble or data frame, indicating the mixture probabilities
of each cluster for each individual. Required column: <code>ID</code>.
Recovered from <code>trained_model</code> if not
provided.</p>
</td></tr>
<tr><td><code id="hyperposterior_clust_+3A_hp_k">hp_k</code></td>
<td>
<p>A tibble or data frame of hyper-parameters
associated with <code>kern_k</code>. Recovered from <code>trained_model</code> if not
provided.</p>
</td></tr>
<tr><td><code id="hyperposterior_clust_+3A_hp_i">hp_i</code></td>
<td>
<p>A tibble or data frame of hyper-parameters
associated with <code>kern_i</code>. Recovered from <code>trained_model</code> if not
provided.</p>
</td></tr>
<tr><td><code id="hyperposterior_clust_+3A_kern_k">kern_k</code></td>
<td>
<p>A kernel function, associated with the mean GPs.
Several popular kernels
(see <a href="https://www.cs.toronto.edu/~duvenaud/cookbook/">The Kernel
Cookbook</a>) are already implemented and can be selected within the
following list:
</p>

<ul>
<li><p> &quot;SE&quot;: (default value) the Squared Exponential Kernel (also called
Radial Basis Function or Gaussian kernel),
</p>
</li>
<li><p> &quot;LIN&quot;: the Linear kernel,
</p>
</li>
<li><p> &quot;PERIO&quot;: the Periodic kernel,
</p>
</li>
<li><p> &quot;RQ&quot;: the Rational Quadratic kernel.
Compound kernels can be created as sums or products of the above kernels.
For combining kernels, simply provide a formula as a character string
where elements are separated by whitespaces (e.g. &quot;SE + PERIO&quot;). As the
elements are treated sequentially from the left to the right, the product
operator '*' shall always be used before the '+' operators (e.g.
'SE * LIN + RQ' is valid whereas 'RQ + SE * LIN' is  not). Recovered from
<code>trained_model</code> if not provided.
</p>
</li></ul>
</td></tr>
<tr><td><code id="hyperposterior_clust_+3A_kern_i">kern_i</code></td>
<td>
<p>A kernel function, associated with the individual GPs. (&quot;SE&quot;,
&quot;LIN&quot;, PERIO&quot; and &quot;RQ&quot; are also available here). Recovered from
<code>trained_model</code> if not provided.</p>
</td></tr>
<tr><td><code id="hyperposterior_clust_+3A_prior_mean_k">prior_mean_k</code></td>
<td>
<p>The set of hyper-prior mean parameters (m_k) for the K
mean GPs, one value for each cluster.
cluster. This argument can be specified under various formats, such as:
</p>

<ul>
<li><p> NULL (default). All hyper-prior means would be set to 0 everywhere.
</p>
</li>
<li><p> A numerical vector of the same length as the number of clusters.
Each number is associated with one cluster, and considered
to be the hyper-prior mean parameter of the cluster (i.e. a constant
function at all <code>Input</code>).
</p>
</li>
<li><p> A list of functions. Each function is associated with one cluster. These
functions are all evaluated at all <code>Input</code> values, to provide
specific hyper-prior mean vectors for each cluster.
</p>
</li></ul>
</td></tr>
<tr><td><code id="hyperposterior_clust_+3A_grid_inputs">grid_inputs</code></td>
<td>
<p>A vector or a data frame, indicating the grid of
additional reference inputs on which the mean process' hyper-posterior
should be evaluated.</p>
</td></tr>
<tr><td><code id="hyperposterior_clust_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A number. A jitter term, added on the diagonal to prevent
numerical issues when inverting nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the parameters of the mean processes'
hyper-posterior distribution, namely:
</p>

<ul>
<li><p> mean: A list of tibbles containing, for each cluster, the
hyper-posterior mean parameters evaluated at each
<code>Input</code>.
</p>
</li>
<li><p> cov: A list of matrices containing, for each cluster, the
hyper-posterior covariance parameter of the mean process.
</p>
</li>
<li><p> mixture: A tibble, indicating the mixture probabilities in
each cluster for each individual.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='ini_kmeans'>Run a k-means algorithm to initialise clusters' allocation</h2><span id='topic+ini_kmeans'></span>

<h3>Description</h3>

<p>Run a k-means algorithm to initialise clusters' allocation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ini_kmeans(data, k, nstart = 50, summary = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ini_kmeans_+3A_data">data</code></td>
<td>
<p>A tibble containing common Input and associated Output values
to cluster.</p>
</td></tr>
<tr><td><code id="ini_kmeans_+3A_k">k</code></td>
<td>
<p>A number of clusters assumed for running the kmeans algorithm.</p>
</td></tr>
<tr><td><code id="ini_kmeans_+3A_nstart">nstart</code></td>
<td>
<p>A number, indicating how many re-starts of kmeans are set.</p>
</td></tr>
<tr><td><code id="ini_kmeans_+3A_summary">summary</code></td>
<td>
<p>A boolean, indicating whether we want an outcome summary</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing the initial clustering obtained through kmeans.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='ini_mixture'>Mixture initialisation with kmeans</h2><span id='topic+ini_mixture'></span>

<h3>Description</h3>

<p>Provide an initial kmeans allocation of the individuals/tasks in a dataset
into a definite number of clusters, and return the associated mixture
probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ini_mixture(data, k, name_clust = NULL, nstart = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ini_mixture_+3A_data">data</code></td>
<td>
<p>A tibble or data frame. Required columns: <code>ID</code>, <code>Input</code>
, <code>Output</code>.</p>
</td></tr>
<tr><td><code id="ini_mixture_+3A_k">k</code></td>
<td>
<p>A number, indicating the number of clusters.</p>
</td></tr>
<tr><td><code id="ini_mixture_+3A_name_clust">name_clust</code></td>
<td>
<p>A vector of characters. Each element should correspond to
the name of one cluster.</p>
</td></tr>
<tr><td><code id="ini_mixture_+3A_nstart">nstart</code></td>
<td>
<p>A number of restart used in the underlying kmeans algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble indicating for each <code>ID</code> in which cluster it belongs
after a kmeans initialisation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='kern_to_cov'>Create covariance matrix from a kernel</h2><span id='topic+kern_to_cov'></span>

<h3>Description</h3>

<p><code>kern_to_cov()</code> creates a covariance matrix between input values (that
could be either scalars or vectors) evaluated within a kernel function,
which is characterised by specified hyper-parameters. This matrix is
a finite-dimensional evaluation of the infinite-dimensional covariance
structure of a GP, defined thanks to this kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kern_to_cov(input, kern = "SE", hp, deriv = NULL, input_2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kern_to_cov_+3A_input">input</code></td>
<td>
<p>A vector, matrix, data frame or tibble containing all inputs for
one individual. If a vector, the elements are used as reference, otherwise
, one column should be named 'Input' to indicate that it represents the
reference (e.g. 'Input' would contain the timestamps in time-series
applications). The other columns are considered as being covariates. If
no column is named 'Input', the first one is used by default.</p>
</td></tr>
<tr><td><code id="kern_to_cov_+3A_kern">kern</code></td>
<td>
<p>A kernel function. Several popular kernels
(see <a href="https://www.cs.toronto.edu/~duvenaud/cookbook/">The Kernel
Cookbook</a>) are already implemented and can be selected within the
following list:
</p>

<ul>
<li><p> &quot;SE&quot;: (default value) the Squared Exponential Kernel (also called
Radial Basis Function or Gaussian kernel),
</p>
</li>
<li><p> &quot;LIN&quot;: the Linear kernel,
</p>
</li>
<li><p> &quot;PERIO&quot;: the Periodic kernel,
</p>
</li>
<li><p> &quot;RQ&quot;: the Rational Quadratic kernel.
Compound kernels can be created as sums or products of the above kernels.
For combining kernels, simply provide a formula as a character string
where elements are separated by whitespaces (e.g. &quot;SE + PERIO&quot;). As the
elements are treated sequentially from the left to the right, the product
operator '*' shall always be used before the '+' operators (e.g.
'SE * LIN + RQ' is valid whereas 'RQ + SE * LIN' is  not).
</p>
</li></ul>
</td></tr>
<tr><td><code id="kern_to_cov_+3A_hp">hp</code></td>
<td>
<p>A list, data frame or tibble containing the hyper-parameters used
in the kernel. The name of the elements (or columns) should correspond
exactly to those used in the kernel definition. If <code>hp</code> contains an
element or a column 'Noise', its value will be added on the diagonal of
the covariance matrix.</p>
</td></tr>
<tr><td><code id="kern_to_cov_+3A_deriv">deriv</code></td>
<td>
<p>A character, indicating according to which hyper-parameter the
derivative should be computed. If NULL (default), the function simply
returns the covariance matrix.</p>
</td></tr>
<tr><td><code id="kern_to_cov_+3A_input_2">input_2</code></td>
<td>
<p>(optional) A vector, matrix, data frame or tibble under the
same format as <code>input</code>. This argument should be used only when the
kernel needs to be evaluated between two different sets of inputs,
typically resulting in a non-square matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A covariance matrix, where elements are evaluations of the associated
kernel for each pair of reference inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='kern_to_inv'>Create inverse of a covariance matrix from a kernel</h2><span id='topic+kern_to_inv'></span>

<h3>Description</h3>

<p><code>kern_to_inv()</code> creates the inverse of a covariance matrix between
input values (that could be either scalars or vectors) evaluated within
a kernel function, which is characterised by specified hyper-parameters.
This matrix is a finite-dimensional evaluation of the
infinite-dimensional covariance structure of a GP, defined thanks to this
kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kern_to_inv(input, kern, hp, pen_diag = 1e-10, deriv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kern_to_inv_+3A_input">input</code></td>
<td>
<p>A vector, matrix, data frame or tibble containing all inputs for
one individual. If a vector, the elements are used as reference, otherwise
,one column should be named 'Input' to indicate that it represents the
reference (e.g. 'Input' would contain the timestamps in time-series
applications). The other columns are considered as being covariates. If
no column is named 'Input', the first one is used by default.</p>
</td></tr>
<tr><td><code id="kern_to_inv_+3A_kern">kern</code></td>
<td>
<p>A kernel function. Several popular kernels
(see <a href="https://www.cs.toronto.edu/~duvenaud/cookbook/">The Kernel
Cookbook</a>) are already implemented and can be selected within the
following list:
</p>

<ul>
<li><p> &quot;SE&quot;: (default value) the Squared Exponential Kernel (also called
Radial Basis Function or Gaussian kernel),
</p>
</li>
<li><p> &quot;LIN&quot;: the Linear kernel,
</p>
</li>
<li><p> &quot;PERIO&quot;: the Periodic kernel,
</p>
</li>
<li><p> &quot;RQ&quot;: the Rational Quadratic kernel.
Compound kernels can be created as sums or products of the above kernels.
For combining kernels, simply provide a formula as a character string
where elements are separated by whitespaces (e.g. &quot;SE + PERIO&quot;). As the
elements are treated sequentially from the left to the right, the product
operator '*' shall always be used before the '+' operators (e.g.
'SE * LIN + RQ' is valid whereas 'RQ + SE * LIN' is  not).
</p>
</li></ul>
</td></tr>
<tr><td><code id="kern_to_inv_+3A_hp">hp</code></td>
<td>
<p>A list, data frame or tibble containing the hyper-parameters used
in the kernel. The name of the elements (or columns) should correspond
exactly to those used in the kernel definition.</p>
</td></tr>
<tr><td><code id="kern_to_inv_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A jitter term that is added to the covariance matrix to avoid
numerical issues when inverting, in cases of nearly singular matrices.</p>
</td></tr>
<tr><td><code id="kern_to_inv_+3A_deriv">deriv</code></td>
<td>
<p>A character, indicating according to which hyper-parameter the
derivative should be computed. If NULL (default), the function simply returns
the inverse covariance matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The inverse of a covariance matrix, which elements are evaluations of
the associated kernel for each pair of reference inputs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='lin_kernel'>Linear Kernel</h2><span id='topic+lin_kernel'></span>

<h3>Description</h3>

<p>Linear Kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lin_kernel(x, y, hp, deriv = NULL, vectorized = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lin_kernel_+3A_x">x</code></td>
<td>
<p>A vector (or matrix if vectorized = T) of inputs.</p>
</td></tr>
<tr><td><code id="lin_kernel_+3A_y">y</code></td>
<td>
<p>A vector (or matrix if vectorized = T) of inputs.</p>
</td></tr>
<tr><td><code id="lin_kernel_+3A_hp">hp</code></td>
<td>
<p>A tibble, data frame or named vector, containing the kernel's
hyperparameters. Required columns: 'lin_slope' and 'lin_offset'.</p>
</td></tr>
<tr><td><code id="lin_kernel_+3A_deriv">deriv</code></td>
<td>
<p>A character, indicating according to which hyper-parameter the
derivative should be computed. If NULL (default), the function simply
returns the evaluation of the kernel.</p>
</td></tr>
<tr><td><code id="lin_kernel_+3A_vectorized">vectorized</code></td>
<td>
<p>A logical value, indicating whether the function provides
a vectorized version for speeded-up calculations. If TRUE, the <code>x</code>
and <code>y</code> arguments should be the vector or matrix containing all
inputs for which the kernel is evaluated on all pairs of elements.
If FALSE, the <code>x</code> and <code>y</code> arguments are simply two inputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar, corresponding to the evaluation of the kernel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='list_kern_to_cov'>Compute a covariance matrix for multiple individuals</h2><span id='topic+list_kern_to_cov'></span>

<h3>Description</h3>

<p>Compute the covariance matrices associated with all individuals in the
database, taking into account their specific inputs and hyper-parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_kern_to_cov(data, kern, hp, deriv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_kern_to_cov_+3A_data">data</code></td>
<td>
<p>A tibble or data frame of input data. Required column: 'ID'.
Suggested column: 'Input' (for indicating the reference input).</p>
</td></tr>
<tr><td><code id="list_kern_to_cov_+3A_kern">kern</code></td>
<td>
<p>A kernel function.</p>
</td></tr>
<tr><td><code id="list_kern_to_cov_+3A_hp">hp</code></td>
<td>
<p>A tibble or data frame, containing the hyper-parameters associated
with each individual.</p>
</td></tr>
<tr><td><code id="list_kern_to_cov_+3A_deriv">deriv</code></td>
<td>
<p>A character, indicating according to which hyper-parameter the
derivative should be computed. If NULL (default), the function simply returns
the list of covariance matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing all of the inverse covariance matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='list_kern_to_inv'>Compute an inverse covariance matrix for multiple individuals</h2><span id='topic+list_kern_to_inv'></span>

<h3>Description</h3>

<p>Compute the inverse covariance matrices associated with all individuals
in the database, taking into account their specific inputs and
hyper-parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_kern_to_inv(db, kern, hp, pen_diag, deriv = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list_kern_to_inv_+3A_db">db</code></td>
<td>
<p>A tibble or data frame of input data. Required column: 'ID'.
Suggested column: 'Input' (for indicating the reference input).</p>
</td></tr>
<tr><td><code id="list_kern_to_inv_+3A_kern">kern</code></td>
<td>
<p>A kernel function.</p>
</td></tr>
<tr><td><code id="list_kern_to_inv_+3A_hp">hp</code></td>
<td>
<p>A tibble or data frame, containing the hyper-parameters associated
with each individual.</p>
</td></tr>
<tr><td><code id="list_kern_to_inv_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A number. A jitter term, added on the diagonal to prevent
numerical issues when inverting nearly singular matrices.</p>
</td></tr>
<tr><td><code id="list_kern_to_inv_+3A_deriv">deriv</code></td>
<td>
<p>A character, indicating according to which hyper-parameter the
derivative should be computed. If NULL (default), the function simply returns
the list of covariance matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list containing all of the inverse covariance matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='logL_GP'>Log-Likelihood function of a Gaussian Process</h2><span id='topic+logL_GP'></span>

<h3>Description</h3>

<p>Log-Likelihood function of a Gaussian Process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logL_GP(hp, db, mean, kern, post_cov, pen_diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logL_GP_+3A_hp">hp</code></td>
<td>
<p>A tibble, data frame or named vector containing hyper-parameters.</p>
</td></tr>
<tr><td><code id="logL_GP_+3A_db">db</code></td>
<td>
<p>A tibble containing the values we want to compute the logL on.
Required columns: Input, Output. Additional covariate columns are allowed.</p>
</td></tr>
<tr><td><code id="logL_GP_+3A_mean">mean</code></td>
<td>
<p>A vector, specifying the mean of the GP at the reference inputs.</p>
</td></tr>
<tr><td><code id="logL_GP_+3A_kern">kern</code></td>
<td>
<p>A kernel function.</p>
</td></tr>
<tr><td><code id="logL_GP_+3A_post_cov">post_cov</code></td>
<td>
<p>(optional) A matrix, corresponding to covariance parameter of
the hyper-posterior. Used to compute the hyper-prior distribution of a new
individual in Magma.</p>
</td></tr>
<tr><td><code id="logL_GP_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A jitter term that is added to the covariance matrix to avoid
numerical issues when inverting, in cases of nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number, corresponding to the value of Gaussian
log-Likelihood (where the covariance can be the sum of the individual and
the hyper-posterior's mean process covariances).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='logL_GP_mod'>Modified log-Likelihood function for GPs</h2><span id='topic+logL_GP_mod'></span>

<h3>Description</h3>

<p>Log-Likelihood function involved in Magma during the maximisation step of
the training. The log-Likelihood is defined as a simple Gaussian likelihood
added with correction trace term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logL_GP_mod(hp, db, mean, kern, post_cov, pen_diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logL_GP_mod_+3A_hp">hp</code></td>
<td>
<p>A tibble, data frame or named vector of hyper-parameters.</p>
</td></tr>
<tr><td><code id="logL_GP_mod_+3A_db">db</code></td>
<td>
<p>A tibble containing values we want to compute logL on.
Required columns: Input, Output. Additional covariate columns are allowed.</p>
</td></tr>
<tr><td><code id="logL_GP_mod_+3A_mean">mean</code></td>
<td>
<p>A vector, specifying the mean of the GP at the reference inputs.</p>
</td></tr>
<tr><td><code id="logL_GP_mod_+3A_kern">kern</code></td>
<td>
<p>A kernel function.</p>
</td></tr>
<tr><td><code id="logL_GP_mod_+3A_post_cov">post_cov</code></td>
<td>
<p>A matrix, covariance parameter of the hyper-posterior.
Used to compute the correction term.</p>
</td></tr>
<tr><td><code id="logL_GP_mod_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A jitter term that is added to the covariance matrix to avoid
numerical issues when inverting, in cases of nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number, corresponding to the value of the modified Gaussian
log-Likelihood defined in Magma.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='logL_GP_mod_common_hp'>Modified log-Likelihood function with common HPs for GPs</h2><span id='topic+logL_GP_mod_common_hp'></span>

<h3>Description</h3>

<p>Log-Likelihood function involved in Magma during the maximisation step of
the training, in the particular case where the hyper-parameters are shared by
all individuals. The log-Likelihood is defined as a sum over all individuals
of Gaussian likelihoods added with correction trace terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logL_GP_mod_common_hp(hp, db, mean, kern, post_cov, pen_diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logL_GP_mod_common_hp_+3A_hp">hp</code></td>
<td>
<p>A tibble, data frame of hyper-parameters.</p>
</td></tr>
<tr><td><code id="logL_GP_mod_common_hp_+3A_db">db</code></td>
<td>
<p>A tibble containing the values we want to compute the logL on.
Required columns: ID, Input, Output. Additional covariate columns are
allowed.</p>
</td></tr>
<tr><td><code id="logL_GP_mod_common_hp_+3A_mean">mean</code></td>
<td>
<p>A vector, specifying the mean of the GP at the reference inputs.</p>
</td></tr>
<tr><td><code id="logL_GP_mod_common_hp_+3A_kern">kern</code></td>
<td>
<p>A kernel function.</p>
</td></tr>
<tr><td><code id="logL_GP_mod_common_hp_+3A_post_cov">post_cov</code></td>
<td>
<p>A matrix, covariance parameter of the hyper-posterior.
Used to compute the correction term.</p>
</td></tr>
<tr><td><code id="logL_GP_mod_common_hp_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A jitter term that is added to the covariance matrix to avoid
numerical issues when inverting, in cases of nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number, corresponding to the value of the modified Gaussian
log-Likelihood with common hyper-parameters defined in Magma.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='logL_monitoring'>Log-Likelihood for monitoring the EM algorithm in Magma</h2><span id='topic+logL_monitoring'></span>

<h3>Description</h3>

<p>Log-Likelihood for monitoring the EM algorithm in Magma
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logL_monitoring(
  hp_0,
  hp_i,
  db,
  m_0,
  kern_0,
  kern_i,
  post_mean,
  post_cov,
  pen_diag
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logL_monitoring_+3A_hp_0">hp_0</code></td>
<td>
<p>A named vector, tibble or data frame, containing the
hyper-parameters associated with the mean GP.</p>
</td></tr>
<tr><td><code id="logL_monitoring_+3A_hp_i">hp_i</code></td>
<td>
<p>A tibble or data frame, containing the hyper-parameters with the
individual GPs.</p>
</td></tr>
<tr><td><code id="logL_monitoring_+3A_db">db</code></td>
<td>
<p>A tibble or data frame. Columns required: ID, Input, Output.
Additional columns for covariates can be specified.</p>
</td></tr>
<tr><td><code id="logL_monitoring_+3A_m_0">m_0</code></td>
<td>
<p>A vector, corresponding to the prior mean of the mean GP.</p>
</td></tr>
<tr><td><code id="logL_monitoring_+3A_kern_0">kern_0</code></td>
<td>
<p>A kernel function, associated with the mean GP.</p>
</td></tr>
<tr><td><code id="logL_monitoring_+3A_kern_i">kern_i</code></td>
<td>
<p>A kernel function, associated with the individual GPs.</p>
</td></tr>
<tr><td><code id="logL_monitoring_+3A_post_mean">post_mean</code></td>
<td>
<p>A tibble, coming out of the E step, containing the Input and
associated Output of the hyper-posterior mean parameter.</p>
</td></tr>
<tr><td><code id="logL_monitoring_+3A_post_cov">post_cov</code></td>
<td>
<p>A matrix, coming out of the E step, being the hyper-posterior
covariance parameter.</p>
</td></tr>
<tr><td><code id="logL_monitoring_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A jitter term that is added to the covariance matrix to avoid
numerical issues when inverting, in cases of nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number, expectation of joint log-likelihood of the model. This
quantity is supposed to increase at each step of the EM algorithm, and
thus used for monitoring the procedure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='m_step'>M-Step of the EM algorithm</h2><span id='topic+m_step'></span>

<h3>Description</h3>

<p>Maximisation step of the EM algorithm to compute hyper-parameters of all the
kernels involved in Magma.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>m_step(
  db,
  m_0,
  kern_0,
  kern_i,
  old_hp_0,
  old_hp_i,
  post_mean,
  post_cov,
  common_hp,
  pen_diag
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="m_step_+3A_db">db</code></td>
<td>
<p>A tibble or data frame. Columns required: ID, Input, Output.
Additional columns for covariates can be specified.</p>
</td></tr>
<tr><td><code id="m_step_+3A_m_0">m_0</code></td>
<td>
<p>A vector, corresponding to the prior mean of the mean GP.</p>
</td></tr>
<tr><td><code id="m_step_+3A_kern_0">kern_0</code></td>
<td>
<p>A kernel function, associated with the mean GP.</p>
</td></tr>
<tr><td><code id="m_step_+3A_kern_i">kern_i</code></td>
<td>
<p>A kernel function, associated with the individual GPs.</p>
</td></tr>
<tr><td><code id="m_step_+3A_old_hp_0">old_hp_0</code></td>
<td>
<p>A named vector, tibble or data frame, containing the
hyper-parameters from the previous M-step (or initialisation) associated
with the mean GP.</p>
</td></tr>
<tr><td><code id="m_step_+3A_old_hp_i">old_hp_i</code></td>
<td>
<p>A tibble or data frame, containing the hyper-parameters
from the previous M-step (or initialisation) associated with the
individual GPs.</p>
</td></tr>
<tr><td><code id="m_step_+3A_post_mean">post_mean</code></td>
<td>
<p>A tibble, coming out of the E step, containing the Input and
associated Output of the hyper-posterior mean parameter.</p>
</td></tr>
<tr><td><code id="m_step_+3A_post_cov">post_cov</code></td>
<td>
<p>A matrix, coming out of the E step, being the hyper-posterior
covariance parameter.</p>
</td></tr>
<tr><td><code id="m_step_+3A_common_hp">common_hp</code></td>
<td>
<p>A logical value, indicating whether the set of
hyper-parameters is assumed to be common to all indiviuals.</p>
</td></tr>
<tr><td><code id="m_step_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A number. A jitter term, added on the diagonal to prevent
numerical issues when inverting nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list, containing the elements <code>hp_0</code>, a tibble
containing the hyper-parameters associated with the mean GP,
<code>hp_i</code>, a tibble containing the hyper-parameters
associated with the individual GPs.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='perio_kernel'>Periodic Kernel</h2><span id='topic+perio_kernel'></span>

<h3>Description</h3>

<p>Periodic Kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perio_kernel(x, y, hp, deriv = NULL, vectorized = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perio_kernel_+3A_x">x</code></td>
<td>
<p>A vector (or matrix if vectorized = T) of inputs.</p>
</td></tr>
<tr><td><code id="perio_kernel_+3A_y">y</code></td>
<td>
<p>A vector (or matrix if vectorized = T) of inputs.</p>
</td></tr>
<tr><td><code id="perio_kernel_+3A_hp">hp</code></td>
<td>
<p>A tibble, data frame or named vector, containing the kernel's
hyperparameters. Required columns: 'perio_variance', 'perio_lengthscale',
and 'period'.</p>
</td></tr>
<tr><td><code id="perio_kernel_+3A_deriv">deriv</code></td>
<td>
<p>A character, indicating according to which hyper-parameter the
derivative should be computed. If NULL (default), the function simply returns
the evaluation of the kernel.</p>
</td></tr>
<tr><td><code id="perio_kernel_+3A_vectorized">vectorized</code></td>
<td>
<p>A logical value, indicating whether the function provides
a vectorized version for speeded-up calculations. If TRUE, the <code>x</code>
and <code>y</code> arguments should be the vector or matrix containing all
inputs for which the kernel is evaluated on all pairs of elements.
If FALSE, the <code>x</code> and <code>y</code> arguments are simply two inputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar, corresponding to the evaluation of the kernel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='plot_db'>Plot smoothed curves of raw data</h2><span id='topic+plot_db'></span>

<h3>Description</h3>

<p>Display raw data under the Magma format as smoothed curves.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_db(data, cluster = FALSE, legend = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_db_+3A_data">data</code></td>
<td>
<p>A data frame or tibble with format : ID, Input, Output.</p>
</td></tr>
<tr><td><code id="plot_db_+3A_cluster">cluster</code></td>
<td>
<p>A boolean indicating whether data should be coloured by
cluster. Requires a column named 'Cluster'.</p>
</td></tr>
<tr><td><code id="plot_db_+3A_legend">legend</code></td>
<td>
<p>A boolean indicating whether the legend should be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graph of smoothed curves of raw data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='plot_gif'>Create a GIF of Magma or GP predictions</h2><span id='topic+plot_gif'></span>

<h3>Description</h3>

<p>Create a GIF animation displaying how Magma or classic GP
predictions evolve and improve when the number of data points increase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gif(
  pred_gp,
  x_input = NULL,
  data = NULL,
  data_train = NULL,
  prior_mean = NULL,
  y_grid = NULL,
  heatmap = FALSE,
  prob_CI = 0.95,
  size_data = 3,
  size_data_train = 1,
  alpha_data_train = 0.5,
  export_gif = FALSE,
  path = "gif_gp.gif",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_gif_+3A_pred_gp">pred_gp</code></td>
<td>
<p>A tibble, typically coming from the <code><a href="#topic+pred_gif">pred_gif</a></code>
function. Required columns: 'Input', 'Mean', 'Var' and 'Index'.</p>
</td></tr>
<tr><td><code id="plot_gif_+3A_x_input">x_input</code></td>
<td>
<p>A vector of character strings, indicating which input should
be displayed. If NULL(default) the 'Input' column is used for the x-axis.
If providing a 2-dimensional vector, the corresponding columns are used
for the x-axis and y-axis.</p>
</td></tr>
<tr><td><code id="plot_gif_+3A_data">data</code></td>
<td>
<p>(Optional) A tibble or data frame. Required columns: 'Input',
'Output'. Additional columns for covariates can be specified.
The 'Input' column should define the variable that is used as
reference for the observations (e.g. time for longitudinal data). The
'Output' column specifies the observed values (the response
variable). The data frame can also provide as many covariates as desired,
with no constraints on the column names. These covariates are additional
inputs (explanatory variables) of the models that are also observed at
each reference 'Input'.</p>
</td></tr>
<tr><td><code id="plot_gif_+3A_data_train">data_train</code></td>
<td>
<p>(Optional) A tibble or data frame, containing the training
data of the Magma model. The data set should have the same format as the
<code>data</code> argument with an additional column 'ID' for identifying the
different individuals/tasks. If provided, those data are displayed as
backward colourful points (each colour corresponding to one
individual/task).</p>
</td></tr>
<tr><td><code id="plot_gif_+3A_prior_mean">prior_mean</code></td>
<td>
<p>(Optional) A tibble or a data frame, containing the 'Input'
and associated 'Output' prior mean parameter of the GP prediction.</p>
</td></tr>
<tr><td><code id="plot_gif_+3A_y_grid">y_grid</code></td>
<td>
<p>A vector, indicating the grid of values on the y-axis for which
probabilities should be computed for heatmaps of 1-dimensional
predictions. If NULL (default), a vector of length 50 is defined, ranging
between the min and max 'Output' values contained in <code>pred_gp</code>.</p>
</td></tr>
<tr><td><code id="plot_gif_+3A_heatmap">heatmap</code></td>
<td>
<p>A logical value indicating whether the GP prediction should be
represented as a heatmap of probabilities for 1-dimensional inputs. If
FALSE (default), the mean curve and associated 95% CI are displayed.</p>
</td></tr>
<tr><td><code id="plot_gif_+3A_prob_ci">prob_CI</code></td>
<td>
<p>A number between 0 and 1 (default is 0.95), indicating the
level of the Credible Interval associated with the posterior mean curve.</p>
</td></tr>
<tr><td><code id="plot_gif_+3A_size_data">size_data</code></td>
<td>
<p>A number, controlling the size of the <code>data</code> points.</p>
</td></tr>
<tr><td><code id="plot_gif_+3A_size_data_train">size_data_train</code></td>
<td>
<p>A number, controlling the size of the
<code>data_train</code> points.</p>
</td></tr>
<tr><td><code id="plot_gif_+3A_alpha_data_train">alpha_data_train</code></td>
<td>
<p>A number, between 0 and 1, controlling transparency
of the <code>data_train</code> points.</p>
</td></tr>
<tr><td><code id="plot_gif_+3A_export_gif">export_gif</code></td>
<td>
<p>A logical value indicating whether the animation should
be exported as a .gif file.</p>
</td></tr>
<tr><td><code id="plot_gif_+3A_path">path</code></td>
<td>
<p>A character string defining the path where the GIF file should be
exported.</p>
</td></tr>
<tr><td><code id="plot_gif_+3A_...">...</code></td>
<td>
<p>Any additional parameters that can be passed to the function
<code><a href="gganimate.html#topic+transition_states">transition_states</a></code> from the <code>gganimate</code>
package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Visualisation of a Magma or GP prediction (optional: display data
points, training data points and the prior mean function), where data
points are added sequentially for visualising changes in prediction as
information increases.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='plot_gp'>Plot Magma or GP predictions</h2><span id='topic+plot_gp'></span><span id='topic+plot_magma'></span>

<h3>Description</h3>

<p>Display Magma or classic GP predictions. According to the dimension of the
inputs, the graph may be a mean curve + Credible Interval or a heatmap of
probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_gp(
  pred_gp,
  x_input = NULL,
  data = NULL,
  data_train = NULL,
  prior_mean = NULL,
  y_grid = NULL,
  heatmap = FALSE,
  samples = FALSE,
  nb_samples = 50,
  plot_mean = TRUE,
  alpha_samples = 0.3,
  prob_CI = 0.95,
  size_data = 3,
  size_data_train = 1,
  alpha_data_train = 0.5
)

plot_magma(
  pred_gp,
  x_input = NULL,
  data = NULL,
  data_train = NULL,
  prior_mean = NULL,
  y_grid = NULL,
  heatmap = FALSE,
  samples = FALSE,
  nb_samples = 50,
  plot_mean = TRUE,
  alpha_samples = 0.3,
  prob_CI = 0.95,
  size_data = 3,
  size_data_train = 1,
  alpha_data_train = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_gp_+3A_pred_gp">pred_gp</code></td>
<td>
<p>A tibble or data frame, typically coming from
<code><a href="#topic+pred_magma">pred_magma</a></code> or <code><a href="#topic+pred_gp">pred_gp</a></code> functions. Required
columns: 'Input', 'Mean', 'Var'. Additional covariate columns may be
present in case of multi-dimensional inputs.</p>
</td></tr>
<tr><td><code id="plot_gp_+3A_x_input">x_input</code></td>
<td>
<p>A vector of character strings, indicating which input should
be displayed. If NULL (default) the 'Input' column is used for the x-axis.
If providing a 2-dimensional vector, the corresponding columns are used
for the x-axis and y-axis.</p>
</td></tr>
<tr><td><code id="plot_gp_+3A_data">data</code></td>
<td>
<p>(Optional) A tibble or data frame. Required columns: 'Input',
'Output'. Additional columns for covariates can be specified. This
argument corresponds to the raw data on which the prediction has been
performed.</p>
</td></tr>
<tr><td><code id="plot_gp_+3A_data_train">data_train</code></td>
<td>
<p>(Optional) A tibble or data frame, containing the training
data of the Magma model. The data set should have the same format as the
<code>data</code> argument with an additional required column 'ID' for
identifying the different individuals/tasks. If provided, those data are
displayed as backward colourful points (each colour corresponding to one
individual/task).</p>
</td></tr>
<tr><td><code id="plot_gp_+3A_prior_mean">prior_mean</code></td>
<td>
<p>(Optional) A tibble or a data frame, containing the 'Input'
and associated 'Output' prior mean parameter of the GP prediction.</p>
</td></tr>
<tr><td><code id="plot_gp_+3A_y_grid">y_grid</code></td>
<td>
<p>A vector, indicating the grid of values on the y-axis for which
probabilities should be computed for heatmaps of 1-dimensional
predictions. If NULL (default), a vector of length 50 is defined, ranging
between the min and max 'Output' values contained in <code>pred_gp</code>.</p>
</td></tr>
<tr><td><code id="plot_gp_+3A_heatmap">heatmap</code></td>
<td>
<p>A logical value indicating whether the GP prediction should be
represented as a heatmap of probabilities for 1-dimensional inputs. If
FALSE (default), the mean curve and associated Credible Interval are
displayed.</p>
</td></tr>
<tr><td><code id="plot_gp_+3A_samples">samples</code></td>
<td>
<p>A logical value indicating whether the GP prediction should be
represented as a collection of samples drawn from the posterior. If
FALSE (default), the mean curve and associated Credible Interval are
displayed.</p>
</td></tr>
<tr><td><code id="plot_gp_+3A_nb_samples">nb_samples</code></td>
<td>
<p>A number, indicating the number of samples to be drawn from
the predictive posterior distribution. For two-dimensional graphs, only
one sample can be displayed.</p>
</td></tr>
<tr><td><code id="plot_gp_+3A_plot_mean">plot_mean</code></td>
<td>
<p>A logical value, indicating whether the mean prediction
should be displayed on the graph when <code>samples = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_gp_+3A_alpha_samples">alpha_samples</code></td>
<td>
<p>A number, controlling transparency of the sample curves.</p>
</td></tr>
<tr><td><code id="plot_gp_+3A_prob_ci">prob_CI</code></td>
<td>
<p>A number between 0 and 1 (default is 0.95), indicating the
level of the Credible Interval associated with the posterior mean curve.
If this this argument is set to 1, the Credible Interval is not displayed.</p>
</td></tr>
<tr><td><code id="plot_gp_+3A_size_data">size_data</code></td>
<td>
<p>A number, controlling the size of the <code>data</code> points.</p>
</td></tr>
<tr><td><code id="plot_gp_+3A_size_data_train">size_data_train</code></td>
<td>
<p>A number, controlling the size of the
<code>data_train</code> points.</p>
</td></tr>
<tr><td><code id="plot_gp_+3A_alpha_data_train">alpha_data_train</code></td>
<td>
<p>A number, between 0 and 1, controlling transparency
of the <code>data_train</code> points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Visualisation of a Magma or GP prediction (optional: display data
points, training data points and the prior mean function). For 1-D
inputs, the prediction is represented as a mean curve and its associated
95%  Credible Interval, as a collection of samples drawn from the
posterior if <code>samples</code> = TRUE, or as a heatmap of probabilities if
<code>heatmap</code> = TRUE. For 2-D inputs, the prediction is represented as a
heatmap, where each couple of inputs on the x-axis and y-axis are
associated with a gradient of colours for the posterior mean values,
whereas the uncertainty is indicated by the transparency (the narrower is
the Credible Interval, the more opaque is the associated colour, and vice
versa)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='plot_magmaclust'>Plot MagmaClust predictions</h2><span id='topic+plot_magmaclust'></span>

<h3>Description</h3>

<p>Display MagmaClust predictions. According to the dimension of the
inputs, the graph may be a mean curve (dim inputs = 1) or a heatmap
(dim inputs = 2) of probabilities. Moreover, MagmaClust can provide credible
intervals only by visualising cluster-specific predictions (e.g. for the most
probable cluster). When visualising the full mixture-of-GPs prediction,
which can be multimodal, the user should choose between the simple mean
function or the full heatmap of probabilities (more informative but slower).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_magmaclust(
  pred_clust,
  cluster = "all",
  x_input = NULL,
  data = NULL,
  data_train = NULL,
  col_clust = FALSE,
  prior_mean = NULL,
  y_grid = NULL,
  heatmap = FALSE,
  samples = FALSE,
  nb_samples = 50,
  plot_mean = TRUE,
  alpha_samples = 0.3,
  prob_CI = 0.95,
  size_data = 3,
  size_data_train = 1,
  alpha_data_train = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_magmaclust_+3A_pred_clust">pred_clust</code></td>
<td>
<p>A list of predictions, typically coming from
<code><a href="#topic+pred_magmaclust">pred_magmaclust</a></code>. Required elements: <code>pred</code>,
<code>mixture</code>, <code>mixture_pred</code>.</p>
</td></tr>
<tr><td><code id="plot_magmaclust_+3A_cluster">cluster</code></td>
<td>
<p>A character string, indicating which cluster to plot from.
If 'all' (default) the mixture of GPs prediction is displayed as a mean
curve (1-D inputs) or a mean heatmap (2-D inputs). Alternatively, if the
name of one cluster is provided, the classic mean curve + credible
interval is displayed (1-D inputs), or a heatmap with colour gradient for
the mean and transparency gradient for the Credible Interval (2-D inputs).</p>
</td></tr>
<tr><td><code id="plot_magmaclust_+3A_x_input">x_input</code></td>
<td>
<p>A vector of character strings, indicating which input should
be displayed. If NULL (default) the 'Input' column is used for the x-axis.
If providing a 2-dimensional vector, the corresponding columns are used
for the x-axis and y-axis.</p>
</td></tr>
<tr><td><code id="plot_magmaclust_+3A_data">data</code></td>
<td>
<p>(Optional) A tibble or data frame. Required columns: <code>Input</code>
, <code>Output</code>. Additional columns for covariates can be specified. This
argument corresponds to the raw data on which the prediction has been
performed.</p>
</td></tr>
<tr><td><code id="plot_magmaclust_+3A_data_train">data_train</code></td>
<td>
<p>(Optional) A tibble or data frame, containing the training
data of the MagmaClust model. The data set should have the same format as
the <code>data</code> argument with an additional required column <code>ID</code> for
identifying the different individuals/tasks. If provided, those data are
displayed as backward colourful points (each colour corresponding to one
individual or a cluster, see <code>col_clust</code> below).</p>
</td></tr>
<tr><td><code id="plot_magmaclust_+3A_col_clust">col_clust</code></td>
<td>
<p>A boolean indicating whether backward points are coloured
according to the individuals or to their most probable cluster. If one
wants to colour by clusters, a column <code>Cluster</code> shall be present in
<code>data_train</code>. We advise to use <code><a href="#topic+data_allocate_cluster">data_allocate_cluster</a></code>
for automatically creating a well-formatted dataset from a trained
MagmaClust model.</p>
</td></tr>
<tr><td><code id="plot_magmaclust_+3A_prior_mean">prior_mean</code></td>
<td>
<p>(Optional) A list providing, for each cluster, a
tibble containing prior mean parameters of the prediction. This argument
typically comes as an outcome <code>hyperpost$mean</code>, available through
the <code><a href="#topic+train_magmaclust">train_magmaclust</a></code>, <code><a href="#topic+pred_magmaclust">pred_magmaclust</a></code>
functions.</p>
</td></tr>
<tr><td><code id="plot_magmaclust_+3A_y_grid">y_grid</code></td>
<td>
<p>A vector, indicating the grid of values on the y-axis for which
probabilities should be computed for heatmaps of 1-dimensional
predictions. If NULL (default), a vector of length 50 is defined, ranging
between the min and max 'Output' values contained in <code>pred</code>.</p>
</td></tr>
<tr><td><code id="plot_magmaclust_+3A_heatmap">heatmap</code></td>
<td>
<p>A logical value indicating whether the GP mixture should be
represented as a heatmap of probabilities for 1-dimensional inputs. If
FALSE (default), the mean curve (and associated Credible Interval if
available) are displayed.</p>
</td></tr>
<tr><td><code id="plot_magmaclust_+3A_samples">samples</code></td>
<td>
<p>A logical value indicating whether the GP mixture should be
represented as a collection of samples drawn from the posterior. If
FALSE (default), the mean curve (and associated Credible Interval if
available) are displayed.</p>
</td></tr>
<tr><td><code id="plot_magmaclust_+3A_nb_samples">nb_samples</code></td>
<td>
<p>A number, indicating the number of samples to be drawn from
the predictive posterior distribution. For two-dimensional graphs, only
one sample can be displayed.</p>
</td></tr>
<tr><td><code id="plot_magmaclust_+3A_plot_mean">plot_mean</code></td>
<td>
<p>A logical value, indicating whether the mean prediction
should be displayed on the graph when <code>samples = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot_magmaclust_+3A_alpha_samples">alpha_samples</code></td>
<td>
<p>A number, controlling transparency of the sample curves.</p>
</td></tr>
<tr><td><code id="plot_magmaclust_+3A_prob_ci">prob_CI</code></td>
<td>
<p>A number between 0 and 1 (default is 0.95), indicating the
level of the Credible Interval associated with the posterior mean curve.
If this this argument is set to 1, the Credible Interval is not displayed.</p>
</td></tr>
<tr><td><code id="plot_magmaclust_+3A_size_data">size_data</code></td>
<td>
<p>A number, controlling the size of the <code>data</code> points.</p>
</td></tr>
<tr><td><code id="plot_magmaclust_+3A_size_data_train">size_data_train</code></td>
<td>
<p>A number, controlling the size of the
<code>data_train</code> points.</p>
</td></tr>
<tr><td><code id="plot_magmaclust_+3A_alpha_data_train">alpha_data_train</code></td>
<td>
<p>A number, between 0 and 1, controlling transparency
of the <code>data_train</code> points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Visualisation of a MagmaClust prediction (optional: display data
points, training data points and the prior mean functions). For 1-D
inputs, the prediction is represented as a mean curve (and its associated
95% Credible Interval for cluster-specific predictions), or as a heatmap
of probabilities if <code>heatmap</code> = TRUE. In the case of MagmaClust,
the heatmap representation should be preferred for clarity, although the
default display remains mean curve for quicker execution. For 2-D inputs,
the prediction is represented as a heatmap, where each couple of inputs on
the x-axis and y-axis are associated with a gradient of colours for the
posterior mean values, whereas the uncertainty is indicated by the
transparency (the narrower is the Credible Interval, the more opaque is
the associated colour, and vice versa). As for 1-D inputs, Credible
Interval information is only available for cluster-specific predictions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='plot_samples'>Display realisations from a (mixture of) GP prediction</h2><span id='topic+plot_samples'></span>

<h3>Description</h3>

<p>Display samples drawn from the posterior of a GP, Magma or
MagmaClust prediction. According to the dimension of the inputs, the graph
may represent curves or a heatmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_samples(
  pred = NULL,
  samples = NULL,
  nb_samples = 50,
  x_input = NULL,
  plot_mean = TRUE,
  alpha_samples = 0.3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_samples_+3A_pred">pred</code></td>
<td>
<p>A list, typically coming from <code><a href="#topic+pred_gp">pred_gp</a></code>,
<code><a href="#topic+pred_magma">pred_magma</a></code> or <code><a href="#topic+pred_magmaclust">pred_magmaclust</a></code> functions, using
the argument 'get_full_cov = TRUE'. Required elements: <code>pred</code>,
<code>cov</code>. This argument is needed if <code>samples</code> is missing.</p>
</td></tr>
<tr><td><code id="plot_samples_+3A_samples">samples</code></td>
<td>
<p>A tibble or data frame, containing the samples generated from
a GP, Magma, or MagmaClust prediction. Required columns: <code>Input</code>,
<code>Sample</code>, <code>Output</code>.  This argument is needed if <code>pred</code>
is missing.</p>
</td></tr>
<tr><td><code id="plot_samples_+3A_nb_samples">nb_samples</code></td>
<td>
<p>A number, indicating the number of samples to be drawn from
the predictive posterior distribution. For two-dimensional graphs, only
one sample can be displayed.</p>
</td></tr>
<tr><td><code id="plot_samples_+3A_x_input">x_input</code></td>
<td>
<p>A vector of character strings, indicating which 'column'
should be displayed in the case of multidimensional inputs. If
NULL(default) the Input' column is used for the x-axis. If providing a
2-dimensional vector, the corresponding columns are used for the x-axis
and the y-axis.</p>
</td></tr>
<tr><td><code id="plot_samples_+3A_plot_mean">plot_mean</code></td>
<td>
<p>A logical value, indicating whether the mean prediction
should be displayed on the graph.</p>
</td></tr>
<tr><td><code id="plot_samples_+3A_alpha_samples">alpha_samples</code></td>
<td>
<p>A number, controlling transparency of the sample curves.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graph of samples drawn from a posterior distribution of a GP,
Magma, or MagmaClust prediction.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='pred_gif'>Magma prediction for ploting GIFs</h2><span id='topic+pred_gif'></span>

<h3>Description</h3>

<p>Generate a Magma or classic GP prediction under a format that is compatible
with a further GIF visualisation of the results. For a Magma prediction,
either the <code>trained_model</code> or <code>hyperpost</code> argument is required.
Otherwise, a classic GP prediction is applied and the prior mean can be
specified through the <code>mean</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred_gif(
  data,
  trained_model = NULL,
  grid_inputs = NULL,
  hyperpost = NULL,
  mean = NULL,
  hp = NULL,
  kern = "SE",
  pen_diag = 1e-10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred_gif_+3A_data">data</code></td>
<td>
<p>A tibble or data frame. Required columns: 'Input',
'Output'. Additional columns for covariates can be specified.
The 'Input' column should define the variable that is used as
reference for the observations (e.g. time for longitudinal data). The
'Output' column specifies the observed values (the response
variable). The data frame can also provide as many covariates as desired,
with no constraints on the column names. These covariates are additional
inputs (explanatory variables) of the models that are also observed at
each reference 'Input'.</p>
</td></tr>
<tr><td><code id="pred_gif_+3A_trained_model">trained_model</code></td>
<td>
<p>A list, containing  the information coming from a
Magma model, previously trained using the <code><a href="#topic+train_magma">train_magma</a></code>
function.</p>
</td></tr>
<tr><td><code id="pred_gif_+3A_grid_inputs">grid_inputs</code></td>
<td>
<p>The grid of inputs (reference Input and covariates) values
on which the GP should be evaluated. Ideally, this argument should be a
tibble or a data frame, providing the same columns as <code>data</code>, except
'Output'. Nonetheless, in cases where <code>data</code> provides only one
'Input' column, the <code>grid_inputs</code> argument can be NULL (default) or a
vector. This vector would be used as reference input for prediction and if
NULL, a vector of length 500 is defined, ranging between the min and max
Input values of <code>data</code>.</p>
</td></tr>
<tr><td><code id="pred_gif_+3A_hyperpost">hyperpost</code></td>
<td>
<p>A list, containing the elements 'mean' and 'cov', the
parameters of the hyper-posterior distribution of the mean process.
Typically, this argument should from a previous learning using
<code><a href="#topic+train_magma">train_magma</a></code>, or a previous prediction with
<code><a href="#topic+pred_magma">pred_magma</a></code>, with the argument <code>get_hyperpost</code> set to
TRUE. The 'mean' element should be a data frame with two columns 'Input'
and 'Output'. The 'cov' element should be a covariance matrix with
colnames and rownames corresponding to the 'Input' in 'mean'. In all
cases, the column 'Input' should contain all the values appearing both in
the 'Input' column of <code>data</code> and in <code>grid_inputs</code>.</p>
</td></tr>
<tr><td><code id="pred_gif_+3A_mean">mean</code></td>
<td>
<p>Mean parameter of the GP. This argument can be specified under
various formats, such as:
</p>

<ul>
<li><p> NULL (default). The mean would be set to 0 everywhere.
</p>
</li>
<li><p> A number. The mean would be a constant function.
</p>
</li>
<li><p> A function. This function is defined as the mean.
</p>
</li>
<li><p> A tibble or data frame. Required columns: Input, Output. The Input
values should include at least the same values as in the <code>data</code>
argument.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pred_gif_+3A_hp">hp</code></td>
<td>
<p>A named vector, tibble or data frame of hyper-parameters
associated with <code>kern</code>. The columns/elements should be named
according to the hyper-parameters that are used in <code>kern</code>. The
function <code><a href="#topic+train_gp">train_gp</a></code> can be used to learn maximum-likelihood
estimators of the hyper-parameters,</p>
</td></tr>
<tr><td><code id="pred_gif_+3A_kern">kern</code></td>
<td>
<p>A kernel function, defining the covariance structure of the GP.
Several popular kernels
(see <a href="https://www.cs.toronto.edu/~duvenaud/cookbook/">The Kernel
Cookbook</a>) are already implemented and can be selected within the
following list:
</p>

<ul>
<li><p> &quot;SE&quot;: (default value) the Squared Exponential Kernel (also called
Radial Basis Function or Gaussian kernel),
</p>
</li>
<li><p> &quot;LIN&quot;: the Linear kernel,
</p>
</li>
<li><p> &quot;PERIO&quot;: the Periodic kernel,
</p>
</li>
<li><p> &quot;RQ&quot;: the Rational Quadratic kernel.
Compound kernels can be created as sums or products of the above kernels.
For combining kernels, simply provide a formula as a character string
where elements are separated by whitespaces (e.g. &quot;SE + PERIO&quot;). As the
elements are treated sequentially from the left to the right, the product
operator '*' shall always be used before the '+' operators (e.g.
'SE * LIN + RQ' is valid whereas 'RQ + SE * LIN' is  not).
</p>
</li></ul>
</td></tr>
<tr><td><code id="pred_gif_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A number. A jitter term, added on the diagonal to prevent
numerical issues when inverting nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, representing Magma or GP predictions as two column 'Mean'
and 'Var', evaluated on the <code>grid_inputs</code>. The column 'Input' and
additional covariates columns are associated to each predicted values. An
additional 'Index' column is created for the sake of GIF creation using
the function <code><a href="#topic+plot_gif">plot_gif</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='pred_gp'>Gaussian Process prediction</h2><span id='topic+pred_gp'></span>

<h3>Description</h3>

<p>Compute the posterior distribution of a standard GP, using the formalism of
Magma. By providing observed data, the prior mean and covariance
matrix (by defining a kernel and its associated hyper-parameters), the mean
and covariance parameters of the posterior distribution are computed on the
grid of inputs that has been specified. This predictive distribution can be
evaluated on any arbitrary inputs since a GP is an infinite-dimensional
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred_gp(
  data = NULL,
  grid_inputs = NULL,
  mean = NULL,
  hp = NULL,
  kern = "SE",
  get_full_cov = FALSE,
  plot = TRUE,
  pen_diag = 1e-10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred_gp_+3A_data">data</code></td>
<td>
<p>A tibble or data frame. Required columns: 'Input',
'Output'. Additional columns for covariates can be specified.
The 'Input' column should define the variable that is used as
reference for the observations (e.g. time for longitudinal data). The
'Output' column specifies the observed values (the response
variable). The data frame can also provide as many covariates as desired,
with no constraints on the column names. These covariates are additional
inputs (explanatory variables) of the models that are also observed at
each reference 'Input'. If NULL, the prior GP is returned.</p>
</td></tr>
<tr><td><code id="pred_gp_+3A_grid_inputs">grid_inputs</code></td>
<td>
<p>The grid of inputs (reference Input and covariates) values
on which the GP should be evaluated. Ideally, this argument should be a
tibble or a data frame, providing the same columns as <code>data</code>, except
'Output'. Nonetheless, in cases where <code>data</code> provides only one
'Input' column, the <code>grid_inputs</code> argument can be NULL (default) or a
vector. This vector would be used as reference input for prediction and if
NULL, a vector of length 500 is defined, ranging between the min and max
Input values of <code>data</code>.</p>
</td></tr>
<tr><td><code id="pred_gp_+3A_mean">mean</code></td>
<td>
<p>Mean parameter of the GP. This argument can be specified under
various formats, such as:
</p>

<ul>
<li><p> NULL (default). The mean would be set to 0 everywhere.
</p>
</li>
<li><p> A number. The mean would be a constant function.
</p>
</li>
<li><p> A tibble or data frame. Required columns: Input, Output. The Input
values should include at least the same values as in the <code>data</code>
argument.
</p>
</li></ul>
</td></tr>
<tr><td><code id="pred_gp_+3A_hp">hp</code></td>
<td>
<p>A named vector, tibble or data frame of hyper-parameters
associated with <code>kern</code>. The columns/elements should be named
according to the hyper-parameters that are used in <code>kern</code>. If NULL
(default), the function <code><a href="#topic+train_gp">train_gp</a></code> is called with random
initial values for learning maximum-likelihood estimators of the
hyper-parameters associated with <code>kern</code>.</p>
</td></tr>
<tr><td><code id="pred_gp_+3A_kern">kern</code></td>
<td>
<p>A kernel function, defining the covariance structure of the GP.
Several popular kernels
(see <a href="https://www.cs.toronto.edu/~duvenaud/cookbook/">The Kernel
Cookbook</a>) are already implemented and can be selected within the
following list:
</p>

<ul>
<li><p> &quot;SE&quot;: (default value) the Squared Exponential Kernel (also called
Radial Basis Function or Gaussian kernel),
</p>
</li>
<li><p> &quot;LIN&quot;: the Linear kernel,
</p>
</li>
<li><p> &quot;PERIO&quot;: the Periodic kernel,
</p>
</li>
<li><p> &quot;RQ&quot;: the Rational Quadratic kernel.
Compound kernels can be created as sums or products of the above kernels.
For combining kernels, simply provide a formula as a character string
where elements are separated by whitespaces (e.g. &quot;SE + PERIO&quot;). As the
elements are treated sequentially from the left to the right, the product
operator '*' shall always be used before the '+' operators (e.g.
'SE * LIN + RQ' is valid whereas 'RQ + SE * LIN' is  not).
</p>
</li></ul>
</td></tr>
<tr><td><code id="pred_gp_+3A_get_full_cov">get_full_cov</code></td>
<td>
<p>A logical value, indicating whether the full posterior
covariance matrix should be returned.</p>
</td></tr>
<tr><td><code id="pred_gp_+3A_plot">plot</code></td>
<td>
<p>A logical value, indicating whether a plot of the results is
automatically displayed.</p>
</td></tr>
<tr><td><code id="pred_gp_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A number. A jitter term, added on the diagonal to prevent
numerical issues when inverting nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, representing the GP predictions as two column 'Mean' and
'Var', evaluated on the <code>grid_inputs</code>. The column 'Input' and
additional covariates columns are associated to each predicted values.
If the <code>get_full_cov</code> argument is TRUE, the function returns a list,
in which the tibble described above is defined as 'pred' and the full
posterior covariance matrix is defined as 'cov'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='pred_magma'>Magma prediction</h2><span id='topic+pred_magma'></span>

<h3>Description</h3>

<p>Compute the posterior predictive distribution in Magma. Providing data of any
new individual/task, its trained hyper-parameters and a previously trained
Magma model, the predictive distribution is evaluated on any arbitrary inputs
that are specified through the 'grid_inputs' argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred_magma(
  data = NULL,
  trained_model = NULL,
  grid_inputs = NULL,
  hp = NULL,
  kern = "SE",
  hyperpost = NULL,
  get_hyperpost = FALSE,
  get_full_cov = FALSE,
  plot = TRUE,
  pen_diag = 1e-10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred_magma_+3A_data">data</code></td>
<td>
<p>A tibble or data frame. Required columns: 'Input',
'Output'. Additional columns for covariates can be specified.
The 'Input' column should define the variable that is used as
reference for the observations (e.g. time for longitudinal data). The
'Output' column specifies the observed values (the response
variable). The data frame can also provide as many covariates as desired,
with no constraints on the column names. These covariates are additional
inputs (explanatory variables) of the models that are also observed at
each reference 'Input'. If NULL, the mean process from
<code>trained_model</code> is returned as a generic prediction.</p>
</td></tr>
<tr><td><code id="pred_magma_+3A_trained_model">trained_model</code></td>
<td>
<p>A list, containing  the information coming from a
Magma model, previously trained using the <code><a href="#topic+train_magma">train_magma</a></code>
function.</p>
</td></tr>
<tr><td><code id="pred_magma_+3A_grid_inputs">grid_inputs</code></td>
<td>
<p>The grid of inputs (reference Input and covariates) values
on which the GP should be evaluated. Ideally, this argument should be a
tibble or a data frame, providing the same columns as <code>data</code>, except
'Output'. Nonetheless, in cases where <code>data</code> provides only one
'Input' column, the <code>grid_inputs</code> argument can be NULL (default) or a
vector. This vector would be used as reference input for prediction and if
NULL, a vector of length 500 is defined, ranging between the min and max
Input values of <code>data</code>.</p>
</td></tr>
<tr><td><code id="pred_magma_+3A_hp">hp</code></td>
<td>
<p>A named vector, tibble or data frame of hyper-parameters
associated with <code>kern</code>. The columns/elements should be named
according to the hyper-parameters that are used in <code>kern</code>. The
function <code><a href="#topic+train_gp">train_gp</a></code> can be used to learn maximum-likelihood
estimators of the hyper-parameters.</p>
</td></tr>
<tr><td><code id="pred_magma_+3A_kern">kern</code></td>
<td>
<p>A kernel function, defining the covariance structure of the GP.
Several popular kernels
(see <a href="https://www.cs.toronto.edu/~duvenaud/cookbook/">The Kernel
Cookbook</a>) are already implemented and can be selected within the
following list:
</p>

<ul>
<li><p> &quot;SE&quot;: (default value) the Squared Exponential Kernel (also called
Radial Basis Function or Gaussian kernel),
</p>
</li>
<li><p> &quot;LIN&quot;: the Linear kernel,
</p>
</li>
<li><p> &quot;PERIO&quot;: the Periodic kernel,
</p>
</li>
<li><p> &quot;RQ&quot;: the Rational Quadratic kernel.
Compound kernels can be created as sums or products of the above kernels.
For combining kernels, simply provide a formula as a character string
where elements are separated by whitespaces (e.g. &quot;SE + PERIO&quot;). As the
elements are treated sequentially from the left to the right, the product
operator '*' shall always be used before the '+' operators (e.g.
'SE * LIN + RQ' is valid whereas 'RQ + SE * LIN' is  not).
</p>
</li></ul>
</td></tr>
<tr><td><code id="pred_magma_+3A_hyperpost">hyperpost</code></td>
<td>
<p>A list, containing the elements 'mean' and 'cov', the
parameters of the hyper-posterior distribution of the mean process.
Typically, this argument should come from a previous learning using
<code><a href="#topic+train_magma">train_magma</a></code>, or a previous prediction with
<code><a href="#topic+pred_magma">pred_magma</a></code>, with the argument <code>get_hyperpost</code> set to
TRUE. The 'mean' element should be a data frame with two columns 'Input'
and 'Output'. The 'cov' element should be a covariance matrix with
colnames and rownames corresponding to the 'Input' in 'mean'. In all
cases, the column 'Input' should contain all the values appearing both in
the 'Input' column of <code>data</code> and in <code>grid_inputs</code>.</p>
</td></tr>
<tr><td><code id="pred_magma_+3A_get_hyperpost">get_hyperpost</code></td>
<td>
<p>A logical value, indicating whether the hyper-posterior
distribution of the mean process should be returned. This can be useful
when planning to perform several predictions on the same grid of inputs,
since recomputation of the hyper-posterior can be prohibitive for high
dimensional grids.</p>
</td></tr>
<tr><td><code id="pred_magma_+3A_get_full_cov">get_full_cov</code></td>
<td>
<p>A logical value, indicating whether the full posterior
covariance matrix should be returned.</p>
</td></tr>
<tr><td><code id="pred_magma_+3A_plot">plot</code></td>
<td>
<p>A logical value, indicating whether a plot of the results is
automatically displayed.</p>
</td></tr>
<tr><td><code id="pred_magma_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A number. A jitter term, added on the diagonal to prevent
numerical issues when inverting nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, representing Magma predictions as two column 'Mean' and
'Var', evaluated on the <code>grid_inputs</code>. The column 'Input' and
additional covariates columns are associated to each predicted values.
If the <code>get_full_cov</code> or <code>get_hyperpost</code> arguments are TRUE,
the function returns a list, in which the tibble described above is
defined as 'pred_gp' and the full posterior covariance matrix is
defined as 'cov', and the hyper-posterior distribution of the mean process
is defined as 'hyperpost'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='pred_magmaclust'>MagmaClust prediction</h2><span id='topic+pred_magmaclust'></span>

<h3>Description</h3>

<p>Compute the posterior predictive distribution in MagmaClust.
Providing data from any new individual/task, its trained hyper-parameters
and a previously trained MagmaClust model, the multi-task posterior
distribution is evaluated on any arbitrary inputs that are specified through
the 'grid_inputs' argument. Due to the nature of the model, the prediction is
defined as a mixture of Gaussian distributions. Therefore the present
function computes the parameters of the predictive distribution
associated with each cluster, as well as the posterior mixture probabilities
for this new individual/task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred_magmaclust(
  data = NULL,
  trained_model = NULL,
  grid_inputs = NULL,
  mixture = NULL,
  hp = NULL,
  kern = "SE",
  hyperpost = NULL,
  prop_mixture = NULL,
  get_hyperpost = FALSE,
  get_full_cov = FALSE,
  plot = TRUE,
  pen_diag = 1e-10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred_magmaclust_+3A_data">data</code></td>
<td>
<p>A tibble or data frame. Required columns: <code>Input</code>,
<code>Output</code>. Additional columns for covariates can be specified.
The <code>Input</code> column should define the variable that is used as
reference for the observations (e.g. time for longitudinal data). The
<code>Output</code> column specifies the observed values (the response
variable). The data frame can also provide as many covariates as desired,
with no constraints on the column names. These covariates are additional
inputs (explanatory variables) of the models that are also observed at
each reference 'Input'. If NULL, the mixture of mean processes from
<code>trained_model</code> is returned as a generic prediction.</p>
</td></tr>
<tr><td><code id="pred_magmaclust_+3A_trained_model">trained_model</code></td>
<td>
<p>A list, containing  the information coming from a
MagmaClust model, previously trained using the
<code><a href="#topic+train_magmaclust">train_magmaclust</a></code> function. If <code>trained_model</code> is set to
NULL, the <code>hyperpost</code> and <code>prop_mixture</code> arguments are mandatory
to perform required re-computations for the prediction to succeed.</p>
</td></tr>
<tr><td><code id="pred_magmaclust_+3A_grid_inputs">grid_inputs</code></td>
<td>
<p>The grid of inputs (reference Input and covariates) values
on which the GP should be evaluated. Ideally, this argument should be a
tibble or a data frame, providing the same columns as <code>data</code>, except
'Output'. Nonetheless, in cases where <code>data</code> provides only one
'Input' column, the <code>grid_inputs</code> argument can be NULL (default) or a
vector. This vector would be used as reference input for prediction and if
NULL, a vector of length 500 is defined, ranging between the min and max
Input values of <code>data</code>.</p>
</td></tr>
<tr><td><code id="pred_magmaclust_+3A_mixture">mixture</code></td>
<td>
<p>A tibble or data frame, indicating the mixture probabilities
of each cluster for the new individual/task.
If NULL, the <code><a href="#topic+train_gp_clust">train_gp_clust</a></code> function is used to compute
these posterior probabilities according to <code>data</code>.</p>
</td></tr>
<tr><td><code id="pred_magmaclust_+3A_hp">hp</code></td>
<td>
<p>A named vector, tibble or data frame of hyper-parameters
associated with <code>kern</code>. The columns/elements should be named
according to the hyper-parameters that are used in <code>kern</code>. The
<code><a href="#topic+train_gp_clust">train_gp_clust</a></code> function can be used to learn
maximum-likelihood estimators of the hyper-parameters.</p>
</td></tr>
<tr><td><code id="pred_magmaclust_+3A_kern">kern</code></td>
<td>
<p>A kernel function, defining the covariance structure of the GP.
Several popular kernels
(see <a href="https://www.cs.toronto.edu/~duvenaud/cookbook/">The Kernel
Cookbook</a>) are already implemented and can be selected within the
following list:
</p>

<ul>
<li><p> &quot;SE&quot;: (default value) the Squared Exponential Kernel (also called
Radial Basis Function or Gaussian kernel),
</p>
</li>
<li><p> &quot;LIN&quot;: the Linear kernel,
</p>
</li>
<li><p> &quot;PERIO&quot;: the Periodic kernel,
</p>
</li>
<li><p> &quot;RQ&quot;: the Rational Quadratic kernel.
Compound kernels can be created as sums or products of the above kernels.
For combining kernels, simply provide a formula as a character string
where elements are separated by whitespaces (e.g. &quot;SE + PERIO&quot;). As the
elements are treated sequentially from the left to the right, the product
operator '*' shall always be used before the '+' operators (e.g.
'SE * LIN + RQ' is valid whereas 'RQ + SE * LIN' is  not).
</p>
</li></ul>
</td></tr>
<tr><td><code id="pred_magmaclust_+3A_hyperpost">hyperpost</code></td>
<td>
<p>A list, containing the elements <code>mean</code>, <code>cov</code> and
<code>mixture</code> the parameters of the hyper-posterior distributions of the
mean processes. Typically, this argument should come from a previous
learning using <code><a href="#topic+train_magmaclust">train_magmaclust</a></code>, or a previous prediction
with <code><a href="#topic+pred_magmaclust">pred_magmaclust</a></code>, with the argument <code>get_hyperpost</code>
set to TRUE.</p>
</td></tr>
<tr><td><code id="pred_magmaclust_+3A_prop_mixture">prop_mixture</code></td>
<td>
<p>A tibble or a named vector of the mixture proportions.
Each name of column or element should refer to a cluster. The value
associated with each cluster is a number between 0 and 1. If both
<code>mixture</code> and <code>trained_model</code> are set to NULL, this argument
allows to recompute mixture probabilities, thanks to the <code>hyperpost</code>
argument and the <code><a href="#topic+train_gp_clust">train_gp_clust</a></code> function.</p>
</td></tr>
<tr><td><code id="pred_magmaclust_+3A_get_hyperpost">get_hyperpost</code></td>
<td>
<p>A logical value, indicating whether the hyper-posterior
distributions of the mean processes should be returned. This can be useful
when planning to perform several predictions on the same grid of inputs,
since recomputation of the hyper-posterior can be prohibitive for high
dimensional grids.</p>
</td></tr>
<tr><td><code id="pred_magmaclust_+3A_get_full_cov">get_full_cov</code></td>
<td>
<p>A logical value, indicating whether the full posterior
covariance matrices should be returned.</p>
</td></tr>
<tr><td><code id="pred_magmaclust_+3A_plot">plot</code></td>
<td>
<p>A logical value, indicating whether a plot of the results is
automatically displayed.</p>
</td></tr>
<tr><td><code id="pred_magmaclust_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A number. A jitter term, added on the diagonal to prevent
numerical issues when inverting nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of GP prediction results composed of:
</p>

<ul>
<li><p> pred: As sub-list containing, for each cluster:
</p>

<ul>
<li><p> pred_gp: A tibble, representing the GP predictions as two
column <code>Mean</code> and <code>Var</code>, evaluated on the
<code>grid_inputs</code>. The column <code>Input</code> and additional
covariates columns are associated with each predicted values.
</p>
</li>
<li><p> proba: A number, the posterior probability associated with
this cluster.
</p>
</li>
<li><p> cov (if <code>get_full_cov</code> = TRUE): A matrix, the full
posterior covariance matrix associated with this cluster.
</p>
</li></ul>

</li>
<li><p> mixture: A tibble, indicating the mixture probabilities
of each cluster for the predicted individual/task.
</p>
</li>
<li><p> hyperpost (if <code>get_hyperpost</code> = TRUE): A list,
containing the hyper-posterior distributions information useful
for visualisation purposes.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='proba_max_cluster'>Indicates the most probable cluster</h2><span id='topic+proba_max_cluster'></span>

<h3>Description</h3>

<p>Indicates the most probable cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proba_max_cluster(mixture)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proba_max_cluster_+3A_mixture">mixture</code></td>
<td>
<p>A tibble or data frame containing mixture probabilities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, retaining only the most probable cluster. The column
<code>Cluster</code> indicates the the cluster's name whereas <code>Proba</code>
refers to its associated probability. If <code>ID</code> is initially
a column of <code>mixture</code> (optional), the function returns the most
probable cluster for all the different <code>ID</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='regularize_data'>Regularise a grid of inputs in a dataset</h2><span id='topic+regularize_data'></span><span id='topic+regularise_data'></span>

<h3>Description</h3>

<p>Modify the original grid of inputs to make it more 'regular' (in the sense
that the interval between each observation is constant, or corresponds to a
specific pattern defined by the user). In particular, this function can also
be used to summarise several data points into one, at a specific location. In
this case, the output values are averaged according to the 'summarise_fct'
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regularize_data(
  data,
  size_grid = 30,
  grid_inputs = NULL,
  summarise_fct = base::mean
)

regularise_data(
  data,
  size_grid = 30,
  grid_inputs = NULL,
  summarise_fct = base::mean
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regularize_data_+3A_data">data</code></td>
<td>
<p>A tibble or data frame. Required columns: <code>ID</code>,
<code>Output</code>. The <code>ID</code> column contains the unique names/codes used
to identify each individual/task (or batch of data). The <code>Output</code>
column specifies the observed values (the response variable). The data
frame can also provide as many inputs as desired, with no constraints
on the column names.</p>
</td></tr>
<tr><td><code id="regularize_data_+3A_size_grid">size_grid</code></td>
<td>
<p>An integer, which indicates the number of equispaced points
each column must contain. Each original input value will be collapsed to
the closest point of the new regular grid, and the associated outputs are
averaged using the 'summarise_fct' function. This argument is used when
'grid_inputs' is left to 'NULL'. Default value is 30.</p>
</td></tr>
<tr><td><code id="regularize_data_+3A_grid_inputs">grid_inputs</code></td>
<td>
<p>A data frame, corresponding to a pre-defined grid of
inputs according to which we want to regularise a dataset (for instance,
if we want to a data point each year between 0 and 10, we can define
grid_inputs = seq(0, 10, 1)). If
NULL (default), a dedicated grid of inputs is defined: for each
input column, a regular sequence is created from the min input
values to the max, with a number of equispaced points equal to the
'size_grid' argument.</p>
</td></tr>
<tr><td><code id="regularize_data_+3A_summarise_fct">summarise_fct</code></td>
<td>
<p>A character string or a function. If several similar
inputs are associated with different outputs, the user can choose the
summarising function for the output among the following: min, max, mean,
median. A custom function can be defined if necessary. Default is &quot;mean&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame, where input columns have been regularised as desired.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data = tibble::tibble(ID = 1, Input = 0:100, Output = -50:50)

## Define a 1D input grid of 10 points
regularize_data(data, size_grid = 10)

## Define a 1D custom grid
my_grid = tibble::tibble(Input = c(5, 10, 25, 50, 100))
regularize_data(data, grid_inputs = my_grid)

## Define a 2D input grid of 5x5 points
data_2D = cbind(ID = 1, expand.grid(Input=1:10, Input2=1:10), Output = 1:100)
regularize_data(data_2D, size_grid = 5)

## Define a 2D custom input grid
my_grid_2D = MagmaClustR::expand_grid_inputs(c(2, 4, 8), 'Input2' = c(3, 5))
regularize_data(data_2D, grid_inputs = my_grid_2D)
</code></pre>

<hr>
<h2 id='rq_kernel'>Rational Quadratic Kernel</h2><span id='topic+rq_kernel'></span>

<h3>Description</h3>

<p>Rational Quadratic Kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq_kernel(x, y, hp, deriv = NULL, vectorized = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rq_kernel_+3A_x">x</code></td>
<td>
<p>A vector (or matrix if vectorized = T) of inputs.</p>
</td></tr>
<tr><td><code id="rq_kernel_+3A_y">y</code></td>
<td>
<p>A vector (or matrix if vectorized = T) of inputs.</p>
</td></tr>
<tr><td><code id="rq_kernel_+3A_hp">hp</code></td>
<td>
<p>A tibble, data frame or named vector, containing the kernel's
hyperparameters. Required columns: 'rq_variance', 'rq_lengthscale', and
'rq_scale'.</p>
</td></tr>
<tr><td><code id="rq_kernel_+3A_deriv">deriv</code></td>
<td>
<p>A character, indicating according to which hyper-parameter the
derivative should be computed. If NULL (default), the function simply returns
the evaluation of the kernel.</p>
</td></tr>
<tr><td><code id="rq_kernel_+3A_vectorized">vectorized</code></td>
<td>
<p>A logical value, indicating whether the function provides
a vectorized version for speeded-up calculations. If TRUE, the <code>x</code>
and <code>y</code> arguments should be the vector or matrix containing all
inputs for which the kernel is evaluated on all pairs of elements.
If FALSE, the <code>x</code> and <code>y</code> arguments are simply two inputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar, corresponding to the evaluation of the kernel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='sample_gp'>Draw samples from a posterior GP/Magma distribution</h2><span id='topic+sample_gp'></span><span id='topic+sample_magma'></span>

<h3>Description</h3>

<p>Draw samples from a posterior GP/Magma distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_gp(pred_gp, nb_samples = 50)

sample_magma(pred_gp, nb_samples = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_gp_+3A_pred_gp">pred_gp</code></td>
<td>
<p>A list, typically coming from
<code><a href="#topic+pred_magma">pred_magma</a></code> or <code><a href="#topic+pred_gp">pred_gp</a></code> functions, with argument
'get_full_cov = TRUE'. Required elements: <code>pred</code>, <code>cov</code>.</p>
</td></tr>
<tr><td><code id="sample_gp_+3A_nb_samples">nb_samples</code></td>
<td>
<p>A number, indicating the number of samples to be drawn from
the predictive posterior distribution. For two-dimensional graphs, only
one sample can be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble or data frame, containing the samples generated from
a GP prediction. Format: <code>Input</code>, <code>Sample</code>, <code>Output</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='sample_magmaclust'>Draw samples from a MagmaClust posterior distribution</h2><span id='topic+sample_magmaclust'></span>

<h3>Description</h3>

<p>Draw samples from a MagmaClust posterior distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_magmaclust(pred_clust, nb_samples = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_magmaclust_+3A_pred_clust">pred_clust</code></td>
<td>
<p>A list, typically coming from
<code><a href="#topic+pred_magmaclust">pred_magmaclust</a></code>, with argument get_full_cov = TRUE'.
Required elements: <code>pred</code>, <code>cov</code>, <code>mixture</code>.</p>
</td></tr>
<tr><td><code id="sample_magmaclust_+3A_nb_samples">nb_samples</code></td>
<td>
<p>A number, indicating the number of samples to be drawn from
the predictive posterior distribution. For two-dimensional graphs, only
one sample can be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble or data frame, containing the samples generated from
a GP prediction. Format: <code>Cluster</code>, <code>Proba</code>, <code>Input</code>,
<code>Sample</code>, <code>Output</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='se_kernel'>Squared Exponential Kernel</h2><span id='topic+se_kernel'></span>

<h3>Description</h3>

<p>Squared Exponential Kernel
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se_kernel(x, y, hp, deriv = NULL, vectorized = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="se_kernel_+3A_x">x</code></td>
<td>
<p>A vector (or matrix if vectorized = T) of inputs.</p>
</td></tr>
<tr><td><code id="se_kernel_+3A_y">y</code></td>
<td>
<p>A vector (or matrix if vectorized = T) of inputs.</p>
</td></tr>
<tr><td><code id="se_kernel_+3A_hp">hp</code></td>
<td>
<p>A tibble, data frame or named vector, containing the kernel's
hyperparameters. Required columns: 'se_variance', 'se_lengthscale'.</p>
</td></tr>
<tr><td><code id="se_kernel_+3A_deriv">deriv</code></td>
<td>
<p>A character, indicating according to which hyper-parameter the
derivative should be computed. If NULL (default), the function simply
returns the evaluation of the kernel.</p>
</td></tr>
<tr><td><code id="se_kernel_+3A_vectorized">vectorized</code></td>
<td>
<p>A logical value, indicating whether the function provides
a vectorized version for speeded-up calculations. If TRUE, the <code>x</code>
and <code>y</code> arguments should be the vector or matrix containing all
inputs for which the kernel is evaluated on all pairs of elements.
If FALSE, the <code>x</code> and <code>y</code> arguments are simply two inputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar, corresponding to the evaluation of the kernel.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='select_nb_cluster'>Select the optimal number of clusters</h2><span id='topic+select_nb_cluster'></span>

<h3>Description</h3>

<p>In MagmaClust, as for any clustering method, the number K of clusters has to
be provided as an hypothesis of the model. This function implements a model
selection procedure, by maximising a variational BIC criterion, computed
for different values of K. A heuristic for a fast approximation of the
procedure is proposed as well, although the corresponding models would not
be properly trained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>select_nb_cluster(
  data,
  fast_approx = TRUE,
  grid_nb_cluster = 1:10,
  ini_hp_k = NULL,
  ini_hp_i = NULL,
  kern_k = "SE",
  kern_i = "SE",
  plot = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="select_nb_cluster_+3A_data">data</code></td>
<td>
<p>A tibble or data frame. Columns required: <code>ID</code>, <code>Input</code>
, <code>Output</code>. Additional columns for covariates can be specified.
The <code>ID</code> column contains the unique names/codes used to identify each
individual/task (or batch of data).
The <code>Input</code> column should define the variable that is used as
reference for the observations (e.g. time for longitudinal data). The
<code>Output</code> column specifies the observed values (the response
variable). The data frame can also provide as many covariates as desired,
with no constraints on the column names. These covariates are additional
inputs (explanatory variables) of the models that are also observed at
each reference <code>Input</code>.</p>
</td></tr>
<tr><td><code id="select_nb_cluster_+3A_fast_approx">fast_approx</code></td>
<td>
<p>A boolean, indicating whether a fast approximation should
be used for selecting the number of clusters. If TRUE, each Magma or
MagmaClust model will perform only one E-step of the training, using
the same fixed values for the hyper-parameters (<code>ini_hp_k</code> and
<code>ini_hp_i</code>, or random values if not provided) in all models. The
resulting models should not be considered as trained, but this approach
provides an convenient heuristic to avoid a cumbersome model selection
procedure.</p>
</td></tr>
<tr><td><code id="select_nb_cluster_+3A_grid_nb_cluster">grid_nb_cluster</code></td>
<td>
<p>A vector of integer, corresponding to grid of values
that will be tested for the number of clusters.</p>
</td></tr>
<tr><td><code id="select_nb_cluster_+3A_ini_hp_k">ini_hp_k</code></td>
<td>
<p>A tibble or data frame of hyper-parameters associated with
<code>kern_k</code>.</p>
</td></tr>
<tr><td><code id="select_nb_cluster_+3A_ini_hp_i">ini_hp_i</code></td>
<td>
<p>A tibble or data frame of hyper-parameters associated with
<code>kern_i</code>.</p>
</td></tr>
<tr><td><code id="select_nb_cluster_+3A_kern_k">kern_k</code></td>
<td>
<p>A kernel function associated to the mean processes.</p>
</td></tr>
<tr><td><code id="select_nb_cluster_+3A_kern_i">kern_i</code></td>
<td>
<p>A kernel function associated to the individuals/tasks.</p>
</td></tr>
<tr><td><code id="select_nb_cluster_+3A_plot">plot</code></td>
<td>
<p>A boolean indicating whether the plot of V-BIC values for all
numbers of clusters should displayed.</p>
</td></tr>
<tr><td><code id="select_nb_cluster_+3A_...">...</code></td>
<td>
<p>Any additional argument that could be passed to
<code><a href="#topic+train_magmaclust">train_magmaclust</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, containing the results of model selection procedure for
selecting the optimal number of clusters thanks to a V-BIC criterion
maximisation. The elements of the list are:
</p>

<ul>
<li><p> best_k: An integer, indicating the resulting optimal number of clusters
</p>
</li>
<li><p> seq_vbic: A vector, corresponding to the sequence of the V-BIC values
associated with the models trained for each provided cluster's number in
<code>grid_nb_cluster</code>.
</p>
</li>
<li><p> trained_models: A list, named by associated number of clusters, of
Magma or MagmaClust models that have been trained (or approximated if
<code>fast_approx</code> = T) during the model selection procedure.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='simu_db'>Simulate a dataset tailored for MagmaClustR</h2><span id='topic+simu_db'></span>

<h3>Description</h3>

<p>Simulate a complete training dataset, which may be representative of various
applications. Several flexible arguments allow adjustment of the number of
individuals, of observed inputs, and the values of many parameters
controlling the data generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_db(
  M = 10,
  N = 10,
  K = 1,
  covariate = FALSE,
  grid = seq(0, 10, 0.05),
  grid_cov = seq(0, 10, 0.5),
  common_input = TRUE,
  common_hp = TRUE,
  add_hp = FALSE,
  add_clust = FALSE,
  int_mu_v = c(4, 5),
  int_mu_l = c(0, 1),
  int_i_v = c(1, 2),
  int_i_l = c(0, 1),
  int_i_sigma = c(0, 0.2),
  lambda_int = c(30, 40),
  m_int = c(0, 10),
  lengthscale_int = c(30, 40),
  m0_slope = c(-5, 5),
  m0_intercept = c(-50, 50)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu_db_+3A_m">M</code></td>
<td>
<p>An integer. The number of individual per cluster.</p>
</td></tr>
<tr><td><code id="simu_db_+3A_n">N</code></td>
<td>
<p>An integer. The number of observations per individual.</p>
</td></tr>
<tr><td><code id="simu_db_+3A_k">K</code></td>
<td>
<p>An integer. The number of underlying clusters.</p>
</td></tr>
<tr><td><code id="simu_db_+3A_covariate">covariate</code></td>
<td>
<p>A logical value indicating whether the dataset should
include an additional input covariate named 'Covariate'.</p>
</td></tr>
<tr><td><code id="simu_db_+3A_grid">grid</code></td>
<td>
<p>A vector of numbers defining a grid of observations
(i.e. the reference inputs).</p>
</td></tr>
<tr><td><code id="simu_db_+3A_grid_cov">grid_cov</code></td>
<td>
<p>A vector of numbers defining a grid of observations
(i.e. the covariate reference inputs).</p>
</td></tr>
<tr><td><code id="simu_db_+3A_common_input">common_input</code></td>
<td>
<p>A logical value indicating whether the reference inputs
are common to all individual.</p>
</td></tr>
<tr><td><code id="simu_db_+3A_common_hp">common_hp</code></td>
<td>
<p>A logical value indicating whether the hyper-parameters are
common to all individual. If TRUE and K&gt;1, the hyper-parameters remain
different between the clusters.</p>
</td></tr>
<tr><td><code id="simu_db_+3A_add_hp">add_hp</code></td>
<td>
<p>A logical value indicating whether the values of
hyper-parameters should be added as columns in the dataset.</p>
</td></tr>
<tr><td><code id="simu_db_+3A_add_clust">add_clust</code></td>
<td>
<p>A logical value indicating whether the name of the
clusters should be added as a column in the dataset.</p>
</td></tr>
<tr><td><code id="simu_db_+3A_int_mu_v">int_mu_v</code></td>
<td>
<p>A vector of 2 numbers, defining an interval of admissible
values for the variance hyper-parameter of the mean process' kernel.</p>
</td></tr>
<tr><td><code id="simu_db_+3A_int_mu_l">int_mu_l</code></td>
<td>
<p>A vector of 2 numbers, defining an interval of admissible
values for the lengthscale hyper-parameter of the mean process' kernel.</p>
</td></tr>
<tr><td><code id="simu_db_+3A_int_i_v">int_i_v</code></td>
<td>
<p>A vector of 2 numbers, defining an interval of admissible
values for the variance hyper-parameter of the individual process' kernel.</p>
</td></tr>
<tr><td><code id="simu_db_+3A_int_i_l">int_i_l</code></td>
<td>
<p>A vector of 2 numbers, defining an interval of admissible
values for the lengthscale hyper-parameter of the individual process'
kernel.</p>
</td></tr>
<tr><td><code id="simu_db_+3A_int_i_sigma">int_i_sigma</code></td>
<td>
<p>A vector of 2 numbers, defining an interval of admissible
values for the noise hyper-parameter.</p>
</td></tr>
<tr><td><code id="simu_db_+3A_lambda_int">lambda_int</code></td>
<td>
<p>A vector of 2 numbers, defining an interval of admissible
values for the lambda parameter of the 2D exponential.</p>
</td></tr>
<tr><td><code id="simu_db_+3A_m_int">m_int</code></td>
<td>
<p>A vector of 2 numbers, defining an interval of admissible
values for the mean of the 2D exponential.</p>
</td></tr>
<tr><td><code id="simu_db_+3A_lengthscale_int">lengthscale_int</code></td>
<td>
<p>A vector of 2 numbers, defining an interval of
admissible values for the lengthscale parameter of the 2D exponential.</p>
</td></tr>
<tr><td><code id="simu_db_+3A_m0_slope">m0_slope</code></td>
<td>
<p>A vector of 2 numbers, defining an interval of admissible
values for the slope of m0.</p>
</td></tr>
<tr><td><code id="simu_db_+3A_m0_intercept">m0_intercept</code></td>
<td>
<p>A vector of 2 numbers, defining an interval of admissible
values for the intercept of m0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A full dataset of simulated training data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate a dataset with 3 clusters of 4 individuals, observed at 10 inputs
data = simu_db(M = 4, N = 10, K = 3)

## Generate a 2-D dataset with an additional input 'Covariate'
data = simu_db(covariate = TRUE)

## Generate a dataset where input locations are different among individuals
data = simu_db(common_input = FALSE)

## Generate a dataset with an additional column indicating the true clusters
data = simu_db(K = 3, add_clust = TRUE)
</code></pre>

<hr>
<h2 id='simu_indiv_se'>Simulate a batch of data</h2><span id='topic+simu_indiv_se'></span>

<h3>Description</h3>

<p>Simulate a batch of output data, corresponding to one individual, coming from
a GP with a the Squared Exponential kernel as covariance structure, and
specified hyper-parameters and input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simu_indiv_se(ID, input, mean, v, l, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simu_indiv_se_+3A_id">ID</code></td>
<td>
<p>An identification code, whether numeric or character.</p>
</td></tr>
<tr><td><code id="simu_indiv_se_+3A_input">input</code></td>
<td>
<p>A vector of numbers. The input variable that is used as
'reference' for input and outputs.</p>
</td></tr>
<tr><td><code id="simu_indiv_se_+3A_mean">mean</code></td>
<td>
<p>A vector of numbers. Prior mean values of the GP.</p>
</td></tr>
<tr><td><code id="simu_indiv_se_+3A_v">v</code></td>
<td>
<p>A number. The variance hyper-parameter of the SE kernel.</p>
</td></tr>
<tr><td><code id="simu_indiv_se_+3A_l">l</code></td>
<td>
<p>A number. The lengthscale hyper-parameter of the SE kernel.</p>
</td></tr>
<tr><td><code id="simu_indiv_se_+3A_sigma">sigma</code></td>
<td>
<p>A number. The noise hyper-parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble containing a batch of output data along with input and
additional information for a simulated individual.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='sum_logL_GP_clust'>Compute a mixture of Gaussian log-likelihoods</h2><span id='topic+sum_logL_GP_clust'></span>

<h3>Description</h3>

<p>During the prediction step of MagmaClust, an EM algorithm is used to compute
the maximum likelihood estimator of the hyper-parameters along with
mixture probabilities for the new individual/task. This function implements
the quantity that is maximised (i.e. a sum of Gaussian log-likelihoods,
weighted by their mixture probabilities). It can also be used to monitor the
EM algorithm when providing the 'prop_mixture' argument, for proper
penalisation of the full log-likelihood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_logL_GP_clust(
  hp,
  db,
  mixture,
  mean,
  kern,
  post_cov,
  prop_mixture = NULL,
  pen_diag
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_logL_GP_clust_+3A_hp">hp</code></td>
<td>
<p>A tibble, data frame or named vector of hyper-parameters.</p>
</td></tr>
<tr><td><code id="sum_logL_GP_clust_+3A_db">db</code></td>
<td>
<p>A tibble containing data we want to evaluate the logL on.
Required columns: Input, Output. Additional covariate columns are allowed.</p>
</td></tr>
<tr><td><code id="sum_logL_GP_clust_+3A_mixture">mixture</code></td>
<td>
<p>A tibble or data frame, indicating the mixture probabilities
of each cluster for the new individual/task.</p>
</td></tr>
<tr><td><code id="sum_logL_GP_clust_+3A_mean">mean</code></td>
<td>
<p>A list of hyper-posterior mean parameters for all clusters.</p>
</td></tr>
<tr><td><code id="sum_logL_GP_clust_+3A_kern">kern</code></td>
<td>
<p>A kernel function.</p>
</td></tr>
<tr><td><code id="sum_logL_GP_clust_+3A_post_cov">post_cov</code></td>
<td>
<p>A list of hyper-posterior covariance parameters for all
clusters.</p>
</td></tr>
<tr><td><code id="sum_logL_GP_clust_+3A_prop_mixture">prop_mixture</code></td>
<td>
<p>A tibble or a named vector. Each name of column or
element should refer to a cluster. The value associated with each cluster
is a number between 0 and 1, corresponding to the mixture
proportions.</p>
</td></tr>
<tr><td><code id="sum_logL_GP_clust_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A jitter term that is added to the covariance matrix to avoid
numerical issues when inverting, in cases of nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A number, expectation of mixture of Gaussian log-likelihoods in
the prediction step of MagmaClust. This quantity is supposed to increase
at each step of the EM algorithm, and can be used for monitoring the
procedure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='swimmers'>French swimmers performances data on 100m freestyle events</h2><span id='topic+swimmers'></span>

<h3>Description</h3>

<p>A subset of data from reported performances of French swimmers during
100m freestyle competitions between 2002 and 2016. See
https://link.springer.com/article/10.1007/s10994-022-06172-1 and
https://www.mdpi.com/2076-3417/8/10/1766 for dedicated description and
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swimmers
</code></pre>


<h3>Format</h3>



<h4><code>swimmers</code></h4>

<p>A data frame with 76,832 rows and 4 columns:
</p>

<dl>
<dt>ID</dt><dd><p>Indentifying number associated to each swimmer</p>
</dd>
<dt>Input</dt><dd><p>Age in years</p>
</dd>
<dt>Output</dt><dd><p>Performance in seconds on a 100m freestyle event</p>
</dd>
<dt>Gender</dt><dd><p>Competition gender</p>
</dd>
</dl>




<h3>Source</h3>

<p><a href="https://ffn.extranat.fr/webffn/competitions.php?idact=nat">https://ffn.extranat.fr/webffn/competitions.php?idact=nat</a>
</p>

<hr>
<h2 id='train_gp'>Learning hyper-parameters of a Gaussian Process</h2><span id='topic+train_gp'></span>

<h3>Description</h3>

<p>Learning hyper-parameters of any new individual/task in <code>Magma</code> is
required in the prediction procedure. This function can also be used to learn
hyper-parameters of a simple GP (just let the <code>hyperpost</code> argument set
to NULL, and use <code>prior_mean</code> instead). When using within <code>Magma</code>,
by providing data for the new individual/task, the hyper-posterior mean and
covariance parameters, and initialisation values for the hyper-parameters,
the function computes maximum likelihood estimates of the hyper-parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_gp(
  data,
  prior_mean = NULL,
  ini_hp = NULL,
  kern = "SE",
  hyperpost = NULL,
  pen_diag = 1e-10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="train_gp_+3A_data">data</code></td>
<td>
<p>A tibble or data frame. Required columns: <code>Input</code>,
<code>Output</code>. Additional columns for covariates can be specified.
The <code>Input</code> column should define the variable that is used as
reference for the observations (e.g. time for longitudinal data). The
<code>Output</code> column specifies the observed values (the response
variable). The data frame can also provide as many covariates as desired,
with no constraints on the column names. These covariates are additional
inputs (explanatory variables) of the models that are also observed at
each reference <code>Input</code>.</p>
</td></tr>
<tr><td><code id="train_gp_+3A_prior_mean">prior_mean</code></td>
<td>
<p>Mean parameter of the GP. This argument can be
specified under various formats, such as:
</p>

<ul>
<li><p> NULL (default). The hyper-posterior mean would be set to 0 everywhere.
</p>
</li>
<li><p> A number. The hyper-posterior mean would be a constant function.
</p>
</li>
<li><p> A vector of the same length as all the distinct Input values in the
<code>data</code> argument. This vector would be considered as the evaluation
of the hyper-posterior mean function at the training Inputs.
</p>
</li>
<li><p> A function. This function is defined as the hyper-posterior mean.
</p>
</li>
<li><p> A tibble or data frame. Required columns: Input, Output. The Input
values should include at least the same values as in the <code>data</code>
argument.
</p>
</li></ul>
</td></tr>
<tr><td><code id="train_gp_+3A_ini_hp">ini_hp</code></td>
<td>
<p>A named vector, tibble or data frame of hyper-parameters
associated with the <code>kern</code> of the new individual/task.
The columns should be named according to the hyper-parameters that are
used in <code>kern</code>. In cases where the model includes a noise term,
<code>ini_hp</code> should contain an additional 'noise' column. If NULL
(default), random values are used as initialisation.</p>
</td></tr>
<tr><td><code id="train_gp_+3A_kern">kern</code></td>
<td>
<p>A kernel function, defining the covariance structure of the GP.
Several popular kernels
(see <a href="https://www.cs.toronto.edu/~duvenaud/cookbook/">The Kernel
Cookbook</a>) are already implemented and can be selected within the
following list:
</p>

<ul>
<li><p> &quot;SE&quot;: (default value) the Squared Exponential Kernel (also called
Radial Basis Function or Gaussian kernel),
</p>
</li>
<li><p> &quot;LIN&quot;: the Linear kernel,
</p>
</li>
<li><p> &quot;PERIO&quot;: the Periodic kernel,
</p>
</li>
<li><p> &quot;RQ&quot;: the Rational Quadratic kernel.
Compound kernels can be created as sums or products of the above kernels.
For combining kernels, simply provide a formula as a character string
where elements are separated by whitespaces (e.g. &quot;SE + PERIO&quot;). As the¬≤
elements are treated sequentially from the left to the right, the product
operator '*' shall always be used before the '+' operators (e.g.
'SE * LIN + RQ' is valid whereas 'RQ + SE * LIN' is  not).
</p>
</li></ul>
</td></tr>
<tr><td><code id="train_gp_+3A_hyperpost">hyperpost</code></td>
<td>
<p>A list, containing the elements 'mean' and 'cov',
the parameters of the hyper-posterior distribution of the mean process.
Typically, this argument should come from a previous learning using
<code><a href="#topic+train_magma">train_magma</a></code>, or from the <code><a href="#topic+hyperposterior">hyperposterior</a></code>
function. If <code>hyperpost</code> is provided, the likelihood that is
maximised is the one involved during Magma's prediction step, and the
<code>prior_mean</code> argument is ignored. For classic GP training, leave
<code>hyperpost</code> to NULL.</p>
</td></tr>
<tr><td><code id="train_gp_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A number. A jitter term, added on the diagonal to prevent
numerical issues when inverting nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble, containing the trained hyper-parameters for the kernel of
the new individual/task.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='train_gp_clust'>Prediction in MagmaClust: learning new HPs and mixture probabilities</h2><span id='topic+train_gp_clust'></span>

<h3>Description</h3>

<p>Learning hyper-parameters and mixture probabilities of any new
individual/task is required in <code>MagmaClust</code> in the prediction procedure.
By providing data for the new individual/task, the hyper-posterior mean and
covariance parameters, the mixture proportions, and initialisation values for
the hyper-parameters, <code>train_gp_clust</code> uses an EM algorithm to compute
maximum likelihood estimates of the hyper-parameters and hyper-posterior
mixture probabilities of the new individual/task.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_gp_clust(
  data,
  prop_mixture = NULL,
  ini_hp = NULL,
  kern = "SE",
  hyperpost = NULL,
  pen_diag = 1e-10,
  n_iter_max = 25,
  cv_threshold = 0.001
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="train_gp_clust_+3A_data">data</code></td>
<td>
<p>A tibble or data frame. Required columns: <code>Input</code>,
<code>Output</code>. Additional columns for covariates can be specified.
The <code>Input</code> column should define the variable that is used as
reference for the observations (e.g. time for longitudinal data). The
<code>Output</code> column specifies the observed values (the response
variable). The data frame can also provide as many covariates as desired,
with no constraints on the column names. These covariates are additional
inputs (explanatory variables) of the models that are also observed at
each reference <code>Input</code>.</p>
</td></tr>
<tr><td><code id="train_gp_clust_+3A_prop_mixture">prop_mixture</code></td>
<td>
<p>A tibble or a named vector. Each name of column or
element should refer to a cluster. The value associated with each cluster
is a number between 0 and 1, corresponding to the mixture
proportions.</p>
</td></tr>
<tr><td><code id="train_gp_clust_+3A_ini_hp">ini_hp</code></td>
<td>
<p>A tibble or data frame of hyper-parameters
associated with <code>kern</code>, the individual process kernel.</p>
</td></tr>
<tr><td><code id="train_gp_clust_+3A_kern">kern</code></td>
<td>
<p>A kernel function, defining the covariance structure of the GP.
Several popular kernels
(see <a href="https://www.cs.toronto.edu/~duvenaud/cookbook/">The Kernel
Cookbook</a>) are already implemented and can be selected within the
following list:
</p>

<ul>
<li><p> &quot;SE&quot;: (default value) the Squared Exponential Kernel (also called
Radial Basis Function or Gaussian kernel),
</p>
</li>
<li><p> &quot;LIN&quot;: the Linear kernel,
</p>
</li>
<li><p> &quot;PERIO&quot;: the Periodic kernel,
</p>
</li>
<li><p> &quot;RQ&quot;: the Rational Quadratic kernel.
Compound kernels can be created as sums or products of the above kernels.
For combining kernels, simply provide a formula as a character string
where elements are separated by whitespaces (e.g. &quot;SE + PERIO&quot;). As the¬≤
elements are treated sequentially from the left to the right, the product
operator '*' shall always be used before the '+' operators (e.g.
'SE * LIN + RQ' is valid whereas 'RQ + SE * LIN' is  not).
</p>
</li></ul>
</td></tr>
<tr><td><code id="train_gp_clust_+3A_hyperpost">hyperpost</code></td>
<td>
<p>A list, containing the elements <code>mean</code>, <code>cov</code> and
<code>mixture</code> the parameters of the hyper-posterior distributions of the
mean processes. Typically, this argument should come from a previous
learning using <code><a href="#topic+train_magmaclust">train_magmaclust</a></code>, or a previous prediction
with <code><a href="#topic+pred_magmaclust">pred_magmaclust</a></code>, with the argument <code>get_hyperpost</code>
set to TRUE.</p>
</td></tr>
<tr><td><code id="train_gp_clust_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A number. A jitter term, added on the diagonal to prevent
numerical issues when inverting nearly singular matrices.</p>
</td></tr>
<tr><td><code id="train_gp_clust_+3A_n_iter_max">n_iter_max</code></td>
<td>
<p>A number, indicating the maximum number of iterations of
the EM algorithm to proceed while not reaching convergence.</p>
</td></tr>
<tr><td><code id="train_gp_clust_+3A_cv_threshold">cv_threshold</code></td>
<td>
<p>A number, indicating the threshold of the likelihood gain
under which the EM algorithm will stop.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, containing the results of the EM algorithm used during the
prediction step of MagmaClust. The elements of the list are:
</p>

<ul>
<li><p> hp: A tibble of optimal hyper-parameters for the new individual's GP.
</p>
</li>
<li><p> mixture: A tibble of mixture probabilities for the new individual.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='train_magma'>Training Magma with an EM algorithm</h2><span id='topic+train_magma'></span>

<h3>Description</h3>

<p>The hyper-parameters and the hyper-posterior distribution involved in Magma
can be learned thanks to an EM algorithm implemented in <code>train_magma</code>.
By providing a dataset, the model hypotheses (hyper-prior mean parameter and
covariance kernels) and initialisation values for the hyper-parameters, the
function computes maximum likelihood estimates of the HPs as well as the
mean and covariance parameters of the Gaussian hyper-posterior distribution
of the mean process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_magma(
  data,
  prior_mean = NULL,
  ini_hp_0 = NULL,
  ini_hp_i = NULL,
  kern_0 = "SE",
  kern_i = "SE",
  common_hp = TRUE,
  grid_inputs = NULL,
  pen_diag = 1e-10,
  n_iter_max = 25,
  cv_threshold = 0.001,
  fast_approx = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="train_magma_+3A_data">data</code></td>
<td>
<p>A tibble or data frame. Required columns: <code>ID</code>, <code>Input</code>
, <code>Output</code>. Additional columns for covariates can be specified.
The <code>ID</code> column contains the unique names/codes used to identify each
individual/task (or batch of data).
The <code>Input</code> column should define the variable that is used as
reference for the observations (e.g. time for longitudinal data). The
<code>Output</code> column specifies the observed values (the response
variable). The data frame can also provide as many covariates as desired,
with no constraints on the column names. These covariates are additional
inputs (explanatory variables) of the models that are also observed at
each reference <code>Input</code>.</p>
</td></tr>
<tr><td><code id="train_magma_+3A_prior_mean">prior_mean</code></td>
<td>
<p>Hyper-prior mean parameter (m_0) of the mean GP. This
argument can be specified under various formats, such as:
</p>

<ul>
<li><p> NULL (default). The hyper-prior mean would be set to 0 everywhere.
</p>
</li>
<li><p> A number. The hyper-prior mean would be a constant function.
</p>
</li>
<li><p> A vector of the same length as all the distinct Input values in the
<code>data</code> argument. This vector would be considered as the evaluation
of the hyper-prior mean function at the training Inputs.
</p>
</li>
<li><p> A function. This function is defined as the hyper_prior mean.
</p>
</li>
<li><p> A tibble or data frame. Required columns: Input, Output. The Input
values should include at least the same values as in the <code>data</code>
argument.
</p>
</li></ul>
</td></tr>
<tr><td><code id="train_magma_+3A_ini_hp_0">ini_hp_0</code></td>
<td>
<p>A named vector, tibble or data frame of hyper-parameters
associated with <code>kern_0</code>, the mean process' kernel. The
columns/elements should be named according to the hyper-parameters
that are used in <code>kern_0</code>. If NULL (default), random values are used
as initialisation.</p>
</td></tr>
<tr><td><code id="train_magma_+3A_ini_hp_i">ini_hp_i</code></td>
<td>
<p>A tibble or data frame of hyper-parameters
associated with <code>kern_i</code>, the individual processes' kernel.
Required column : <code>ID</code>. The <code>ID</code> column contains the unique
names/codes used to identify each individual/task. The other columns
should be named according to the hyper-parameters that are used in
<code>kern_i</code>. Compared to <code>ini_hp_0</code> should contain an additional
'noise' column to initialise the noise hyper-parameter of the model. If
NULL (default), random values are used as initialisation.</p>
</td></tr>
<tr><td><code id="train_magma_+3A_kern_0">kern_0</code></td>
<td>
<p>A kernel function, associated with the mean GP.
Several popular kernels
(see <a href="https://www.cs.toronto.edu/~duvenaud/cookbook/">The Kernel
Cookbook</a>) are already implemented and can be selected within the
following list:
</p>

<ul>
<li><p> &quot;SE&quot;: (default value) the Squared Exponential Kernel (also called
Radial Basis Function or Gaussian kernel),
</p>
</li>
<li><p> &quot;LIN&quot;: the Linear kernel,
</p>
</li>
<li><p> &quot;PERIO&quot;: the Periodic kernel,
</p>
</li>
<li><p> &quot;RQ&quot;: the Rational Quadratic kernel.
Compound kernels can be created as sums or products of the above kernels.
For combining kernels, simply provide a formula as a character string
where elements are separated by whitespaces (e.g. &quot;SE + PERIO&quot;). As the
elements are treated sequentially from the left to the right, the product
operator '*' shall always be used before the '+' operators (e.g.
'SE * LIN + RQ' is valid whereas 'RQ + SE * LIN' is  not).
</p>
</li></ul>
</td></tr>
<tr><td><code id="train_magma_+3A_kern_i">kern_i</code></td>
<td>
<p>A kernel function, associated with the individual GPs. (&quot;SE&quot;,
&quot;PERIO&quot; and &quot;RQ&quot; are also available here).</p>
</td></tr>
<tr><td><code id="train_magma_+3A_common_hp">common_hp</code></td>
<td>
<p>A logical value, indicating whether the set of
hyper-parameters is assumed to be common to all individuals.</p>
</td></tr>
<tr><td><code id="train_magma_+3A_grid_inputs">grid_inputs</code></td>
<td>
<p>A vector, indicating the grid of additional reference
inputs on which the mean process' hyper-posterior should be evaluated.</p>
</td></tr>
<tr><td><code id="train_magma_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A number. A jitter term, added on the diagonal to prevent
numerical issues when inverting nearly singular matrices.</p>
</td></tr>
<tr><td><code id="train_magma_+3A_n_iter_max">n_iter_max</code></td>
<td>
<p>A number, indicating the maximum number of iterations of
the EM algorithm to proceed while not reaching convergence.</p>
</td></tr>
<tr><td><code id="train_magma_+3A_cv_threshold">cv_threshold</code></td>
<td>
<p>A number, indicating the threshold of the likelihood gain
under which the EM algorithm will stop. The convergence condition is
defined as the difference of likelihoods between two consecutive steps,
divided by the absolute value of the last one
( <code class="reqn">(LL_n - LL_n-1) / |LL_n|</code> ).</p>
</td></tr>
<tr><td><code id="train_magma_+3A_fast_approx">fast_approx</code></td>
<td>
<p>A boolean, indicating whether the EM algorithm should
stop after only one iteration of the E-step. This advanced feature is
mainly used to provide a faster approximation of the model selection
procedure, by preventing any optimisation over the hyper-parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user can specify custom kernel functions for the argument
<code>kern_0</code> and <code>kern_i</code>. The hyper-parameters used in the kernel
should have explicit names, and be contained within the <code>hp</code>
argument. <code>hp</code> should typically be defined as a named vector or a
data frame. Although it is not mandatory for the <code>train_magma</code>
function to run, gradients can be provided within kernel function
definition. See for example <code><a href="#topic+se_kernel">se_kernel</a></code> to create a custom
kernel function displaying an adequate format to be used in Magma.
</p>


<h3>Value</h3>

<p>A list, gathering the results of the EM algorithm used for training
in Magma. The elements of the list are:
</p>

<ul>
<li><p> hp_0: A tibble of the trained hyper-parameters for the mean
process' kernel.
</p>
</li>
<li><p> hp_i: A tibble of all the trained hyper-parameters for the
individual processes' kernels.
</p>
</li>
<li><p> hyperpost: A sub-list gathering the parameters of the mean processes'
hyper-posterior distributions, namely:
</p>

<ul>
<li><p> mean: A tibble, the hyper-posterior mean parameter
(<code>Output</code>) evaluated at each training reference <code>Input</code>.
</p>
</li>
<li><p> cov: A matrix, the covariance parameter for the hyper-posterior
distribution of the mean process.
</p>
</li>
<li><p> pred: A tibble, the predicted mean and variance at <code>Input</code>
for the mean process' hyper-posterior distribution under a format
that allows the direct visualisation as a GP prediction.
</p>
</li></ul>

</li>
<li><p> ini_args: A list containing the initial function arguments and values
for the hyper-prior mean, the hyper-parameters. In particular, if
those arguments were set to NULL, <code>ini_args</code> allows us to retrieve
the (randomly chosen) initialisations used during training.
</p>
</li>
<li><p> seq_loglikelihood: A vector, containing the sequence of log-likelihood
values associated with each iteration.
</p>
</li>
<li><p> converged: A logical value indicated whether the EM algorithm converged
or not.
</p>
</li>
<li><p> training_time: Total running time of the complete training.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='train_magmaclust'>Training MagmaClust with a Variational EM algorithm</h2><span id='topic+train_magmaclust'></span>

<h3>Description</h3>

<p>The hyper-parameters and the hyper-posterior distributions involved in
MagmaClust can be learned thanks to a VEM algorithm implemented in
<code>train_magmaclust</code>. By providing a dataset, the model hypotheses
(hyper-prior mean parameters, covariance kernels and number of clusters) and
initialisation values for the hyper-parameters, the function computes
maximum likelihood estimates of the HPs as well as the mean and covariance
parameters of the Gaussian hyper-posterior distributions of the mean
processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>train_magmaclust(
  data,
  nb_cluster = NULL,
  prior_mean_k = NULL,
  ini_hp_k = NULL,
  ini_hp_i = NULL,
  kern_k = "SE",
  kern_i = "SE",
  ini_mixture = NULL,
  common_hp_k = TRUE,
  common_hp_i = TRUE,
  grid_inputs = NULL,
  pen_diag = 1e-10,
  n_iter_max = 25,
  cv_threshold = 0.001,
  fast_approx = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="train_magmaclust_+3A_data">data</code></td>
<td>
<p>A tibble or data frame. Columns required: <code>ID</code>, <code>Input</code>
, <code>Output</code>. Additional columns for covariates can be specified.
The <code>ID</code> column contains the unique names/codes used to identify each
individual/task (or batch of data).
The <code>Input</code> column should define the variable that is used as
reference for the observations (e.g. time for longitudinal data). The
<code>Output</code> column specifies the observed values (the response
variable). The data frame can also provide as many covariates as desired,
with no constraints on the column names. These covariates are additional
inputs (explanatory variables) of the models that are also observed at
each reference <code>Input</code>.</p>
</td></tr>
<tr><td><code id="train_magmaclust_+3A_nb_cluster">nb_cluster</code></td>
<td>
<p>A number, indicating the number of clusters of
individuals/tasks that are assumed to exist among the dataset.</p>
</td></tr>
<tr><td><code id="train_magmaclust_+3A_prior_mean_k">prior_mean_k</code></td>
<td>
<p>The set of hyper-prior mean parameters (m_k) for the K
mean GPs, one value for each cluster.
cluster. This argument can be specified under various formats, such as:
</p>

<ul>
<li><p> NULL (default). All hyper-prior means would be set to 0 everywhere.
</p>
</li>
<li><p> A numerical vector of the same length as the number of clusters.
Each number is associated with one cluster, and considered
to be the hyper-prior mean parameter of the cluster (i.e. a constant
function at all <code>Input</code>).
</p>
</li>
<li><p> A list of functions. Each function is associated with one cluster. These
functions are all evaluated at all <code>Input</code> values, to provide
specific hyper-prior mean vectors for each cluster.
</p>
</li></ul>
</td></tr>
<tr><td><code id="train_magmaclust_+3A_ini_hp_k">ini_hp_k</code></td>
<td>
<p>A tibble or data frame of hyper-parameters
associated with <code>kern_k</code>, the mean process' kernel.
Required column : <code>ID</code>. The <code>ID</code> column contains the unique
names/codes used to identify each cluster. The other columns
should be named according to the hyper-parameters that are used in
<code>kern_k</code>.</p>
</td></tr>
<tr><td><code id="train_magmaclust_+3A_ini_hp_i">ini_hp_i</code></td>
<td>
<p>A tibble or data frame of hyper-parameters
associated with <code>kern_i</code>, the individual processes' kernel.
Required column : <code>ID</code>. The <code>ID</code> column contains the unique
names/codes used to identify each individual/task. The other columns
should be named according to the hyper-parameters that are used in
<code>kern_i</code>.</p>
</td></tr>
<tr><td><code id="train_magmaclust_+3A_kern_k">kern_k</code></td>
<td>
<p>A kernel function, associated with the mean GPs.
Several popular kernels
(see <a href="https://www.cs.toronto.edu/~duvenaud/cookbook/">The Kernel
Cookbook</a>) are already implemented and can be selected within the
following list:
</p>

<ul>
<li><p> &quot;SE&quot;: (default value) the Squared Exponential Kernel (also called
Radial Basis Function or Gaussian kernel),
</p>
</li>
<li><p> &quot;LIN&quot;: the Linear kernel,
</p>
</li>
<li><p> &quot;PERIO&quot;: the Periodic kernel,
</p>
</li>
<li><p> &quot;RQ&quot;: the Rational Quadratic kernel.
Compound kernels can be created as sums or products of the above kernels.
For combining kernels, simply provide a formula as a character string
where elements are separated by whitespaces (e.g. &quot;SE + PERIO&quot;). As the
elements are treated sequentially from the left to the right, the product
operator '*' shall always be used before the '+' operators (e.g.
'SE * LIN + RQ' is valid whereas 'RQ + SE * LIN' is  not).
</p>
</li></ul>
</td></tr>
<tr><td><code id="train_magmaclust_+3A_kern_i">kern_i</code></td>
<td>
<p>A kernel function, associated with the individual GPs. (See
details above in <code>kern_k</code>).</p>
</td></tr>
<tr><td><code id="train_magmaclust_+3A_ini_mixture">ini_mixture</code></td>
<td>
<p>Initial values of the probability to belong to each
cluster for each individual (<code><a href="#topic+ini_mixture">ini_mixture</a></code> can be used for
a k-means initialisation. Used by default if NULL).</p>
</td></tr>
<tr><td><code id="train_magmaclust_+3A_common_hp_k">common_hp_k</code></td>
<td>
<p>A boolean indicating whether hyper-parameters are common
among the mean GPs.</p>
</td></tr>
<tr><td><code id="train_magmaclust_+3A_common_hp_i">common_hp_i</code></td>
<td>
<p>A boolean indicating whether hyper-parameters are common
among the individual GPs.</p>
</td></tr>
<tr><td><code id="train_magmaclust_+3A_grid_inputs">grid_inputs</code></td>
<td>
<p>A vector, indicating the grid of additional reference
inputs on which the mean processes' hyper-posteriors should be evaluated.</p>
</td></tr>
<tr><td><code id="train_magmaclust_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A number. A jitter term, added on the diagonal to prevent
numerical issues when inverting nearly singular matrices.</p>
</td></tr>
<tr><td><code id="train_magmaclust_+3A_n_iter_max">n_iter_max</code></td>
<td>
<p>A number, indicating the maximum number of iterations of
the VEM algorithm to proceed while not reaching convergence.</p>
</td></tr>
<tr><td><code id="train_magmaclust_+3A_cv_threshold">cv_threshold</code></td>
<td>
<p>A number, indicating the threshold of the likelihood gain
under which the VEM algorithm will stop. The convergence condition is
defined as the difference of elbo between two consecutive steps,
divided by the absolute value of the last one
( <code class="reqn">(ELBO_n - ELBO_{n-1}) / |ELBO_n| </code> ).</p>
</td></tr>
<tr><td><code id="train_magmaclust_+3A_fast_approx">fast_approx</code></td>
<td>
<p>A boolean, indicating whether the VEM algorithm should
stop after only one iteration of the VE-step. This advanced feature is
mainly used to provide a faster approximation of the model selection
procedure, by preventing any optimisation over the hyper-parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user can specify custom kernel functions for the argument
<code>kern_k</code> and <code>kern_i</code>. The hyper-parameters used in the kernel
should have explicit names, and be contained within the <code>hp</code>
argument. <code>hp</code> should typically be defined as a named vector or a
data frame. Although it is not mandatory for the <code>train_magmaclust</code>
function to run, gradients be can provided within kernel function
definition. See for example <code><a href="#topic+se_kernel">se_kernel</a></code> to create a custom
kernel function displaying an adequate format to be used in
MagmaClust.
</p>


<h3>Value</h3>

<p>A list, containing the results of the VEM algorithm used in the
training step of MagmaClust. The elements of the list are:
</p>

<ul>
<li><p> hp_k: A tibble containing the trained hyper-parameters for the mean
process' kernel and the mixture proportions for each cluster.
</p>
</li>
<li><p> hp_i: A tibble containing the trained hyper-parameters for the
individual processes' kernels.
</p>
</li>
<li><p> hyperpost: A sub-list containing the parameters of the mean processes'
hyper-posterior distribution, namely:
</p>

<ul>
<li><p> mean: A list of tibbles containing, for each cluster, the
hyper-posterior mean parameters evaluated at each <code>Input</code>.
</p>
</li>
<li><p> cov: A list of matrices containing, for each cluster, the
hyper-posterior covariance parameter of the mean process.
</p>
</li>
<li><p> mixture: A tibble, indicating the mixture probabilities in each
cluster for each individual.
</p>
</li></ul>

</li>
<li><p> ini_args: A list containing the initial function arguments and values
for the hyper-prior means, the hyper-parameters. In particular, if
those arguments were set to NULL, <code>ini_args</code> allows us to retrieve
the (randomly chosen) initialisations used during training.
</p>
</li>
<li><p> seq_elbo: A vector, containing the sequence of ELBO values associated
with each iteration.
</p>
</li>
<li><p> converged: A logical value indicated whether the algorithm converged.
</p>
</li>
<li><p> training_time: Total running time of the complete training.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='update_mixture'>Update the mixture probabilities for each individual and each cluster</h2><span id='topic+update_mixture'></span>

<h3>Description</h3>

<p>Update the mixture probabilities for each individual and each cluster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_mixture(db, mean_k, cov_k, hp, kern, prop_mixture, pen_diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_mixture_+3A_db">db</code></td>
<td>
<p>A tibble or data frame. Columns required: <code>ID</code>,
<code>Input</code>, <code>Output</code>. Additional columns for covariates can be
specified.</p>
</td></tr>
<tr><td><code id="update_mixture_+3A_mean_k">mean_k</code></td>
<td>
<p>A list of the K hyper-posterior mean parameters.</p>
</td></tr>
<tr><td><code id="update_mixture_+3A_cov_k">cov_k</code></td>
<td>
<p>A list of the K hyper-posterior covariance matrices.</p>
</td></tr>
<tr><td><code id="update_mixture_+3A_hp">hp</code></td>
<td>
<p>A named vector, tibble or data frame of hyper-parameters
associated with <code>kern</code>, the individual process' kernel. The
columns/elements should be named according to the hyper-parameters
that are used in <code>kern</code>.</p>
</td></tr>
<tr><td><code id="update_mixture_+3A_kern">kern</code></td>
<td>
<p>A kernel function, defining the covariance structure of
the individual GPs.</p>
</td></tr>
<tr><td><code id="update_mixture_+3A_prop_mixture">prop_mixture</code></td>
<td>
<p>A tibble containing the hyper-parameters associated
with each individual, indicating in which cluster it belongs.</p>
</td></tr>
<tr><td><code id="update_mixture_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A number. A jitter term, added on the diagonal to prevent
numerical issues when inverting nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Compute the hyper-posterior multinomial distributions by updating
mixture probabilities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='ve_step'>E-Step of the VEM algorithm</h2><span id='topic+ve_step'></span>

<h3>Description</h3>

<p>Expectation step of the Variational EM algorithm used to compute
the parameters of the hyper-posteriors distributions
for the mean processes and mixture variables involved in MagmaClust.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ve_step(db, m_k, kern_k, kern_i, hp_k, hp_i, old_mixture, iter, pen_diag)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ve_step_+3A_db">db</code></td>
<td>
<p>A tibble or data frame. Columns required: ID, Input, Output.
Additional columns for covariates can be specified.</p>
</td></tr>
<tr><td><code id="ve_step_+3A_m_k">m_k</code></td>
<td>
<p>A named list of vectors, corresponding to the prior mean
parameters of the K mean GPs.</p>
</td></tr>
<tr><td><code id="ve_step_+3A_kern_k">kern_k</code></td>
<td>
<p>A kernel function, associated with the K mean GPs.</p>
</td></tr>
<tr><td><code id="ve_step_+3A_kern_i">kern_i</code></td>
<td>
<p>A kernel function, associated with the M individual GPs.</p>
</td></tr>
<tr><td><code id="ve_step_+3A_hp_k">hp_k</code></td>
<td>
<p>A named vector, tibble or data frame of hyper-parameters
associated with <code>kern_k</code>.</p>
</td></tr>
<tr><td><code id="ve_step_+3A_hp_i">hp_i</code></td>
<td>
<p>A named vector, tibble or data frame of hyper-parameters
associated with <code>kern_i</code>.</p>
</td></tr>
<tr><td><code id="ve_step_+3A_old_mixture">old_mixture</code></td>
<td>
<p>A list of mixture values from the previous iteration.</p>
</td></tr>
<tr><td><code id="ve_step_+3A_iter">iter</code></td>
<td>
<p>A number, indicating the current iteration of the VEM algorithm.</p>
</td></tr>
<tr><td><code id="ve_step_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A number. A jitter term, added on the diagonal to prevent
numerical issues when inverting nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list, containing the elements <code>mean</code>, a tibble
containing the Input and associated Output of the hyper-posterior mean
parameters, <code>cov</code>, the hyper-posterior covariance matrices,
and <code>mixture</code>, the probabilities to belong to each cluster for each
individual.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='vm_step'>V-Step of the VEM algorithm</h2><span id='topic+vm_step'></span>

<h3>Description</h3>

<p>Maximization step of the Variational EM algorithm used to compute
hyper-parameters of all the kernels involved in MagmaClust.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vm_step(
  db,
  old_hp_k,
  old_hp_i,
  list_mu_param,
  kern_k,
  kern_i,
  m_k,
  common_hp_k,
  common_hp_i,
  pen_diag
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vm_step_+3A_db">db</code></td>
<td>
<p>A tibble or data frame. Columns required: ID, Input, Output.
Additional columns for covariates can be specified.</p>
</td></tr>
<tr><td><code id="vm_step_+3A_old_hp_k">old_hp_k</code></td>
<td>
<p>A named vector, tibble or data frame, containing the
hyper-parameters from the previous M-step (or initialisation) associated
with the mean GPs.</p>
</td></tr>
<tr><td><code id="vm_step_+3A_old_hp_i">old_hp_i</code></td>
<td>
<p>A named vector, tibble or data frame, containing the
hyper-parameters from the previous  M-step (or initialisation) associated
with the individual GPs.</p>
</td></tr>
<tr><td><code id="vm_step_+3A_list_mu_param">list_mu_param</code></td>
<td>
<p>List of parameters of the K mean GPs.</p>
</td></tr>
<tr><td><code id="vm_step_+3A_kern_k">kern_k</code></td>
<td>
<p>A kernel used to compute the covariance matrix of the mean GP
at corresponding timestamps.</p>
</td></tr>
<tr><td><code id="vm_step_+3A_kern_i">kern_i</code></td>
<td>
<p>A kernel used to compute the covariance matrix of individuals
GP at corresponding timestamps.</p>
</td></tr>
<tr><td><code id="vm_step_+3A_m_k">m_k</code></td>
<td>
<p>A named list of prior mean parameters for the K mean GPs.
Length = 1 or nrow(unique(db$Input))</p>
</td></tr>
<tr><td><code id="vm_step_+3A_common_hp_k">common_hp_k</code></td>
<td>
<p>A boolean indicating whether hp are common among
mean GPs (for each mu_k)</p>
</td></tr>
<tr><td><code id="vm_step_+3A_common_hp_i">common_hp_i</code></td>
<td>
<p>A boolean indicating whether hp are common among
individual GPs (for each y_i)</p>
</td></tr>
<tr><td><code id="vm_step_+3A_pen_diag">pen_diag</code></td>
<td>
<p>A number. A jitter term, added on the diagonal to prevent
numerical issues when inverting nearly singular matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list, containing the elements <code>hp_k</code>, a tibble
containing the hyper-parameters associated with each cluster,
<code>hp_i</code>, a tibble containing the hyper-parameters
associated with the individual GPs, and <code>prop_mixture_k</code>,
a tibble containing the hyper-parameters associated with each individual,
indicating the probabilities to belong to each cluster.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>TRUE
</code></pre>

<hr>
<h2 id='weight'>Weight follow-up data of children in Singapore</h2><span id='topic+weight'></span>

<h3>Description</h3>

<p>A subset of data from the GUSTO project (https://www.gusto.sg/) collecting
the weight over time of several children in Singapore.
See https://arxiv.org/abs/2011.07866 for dedicated description and
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weight
</code></pre>


<h3>Format</h3>



<h4><code>weight</code></h4>

<p>A data frame with 3,629 rows and 4 columns:
</p>

<dl>
<dt>ID</dt><dd><p>Indentifying number associated to each child</p>
</dd>
<dt>sex</dt><dd><p>Biological gender</p>
</dd>
<dt>Input</dt><dd><p>Age in months</p>
</dd>
<dt>Output</dt><dd><p>Weight in kilograms</p>
</dd>
</dl>




<h3>Source</h3>

<p><a href="https://www.gusto.sg/">https://www.gusto.sg/</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
