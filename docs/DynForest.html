<!DOCTYPE html><html><head><title>Help for package DynForest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DynForest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#checking'><p>Internal checking function</p></a></li>
<li><a href='#combine_times'><p>Extend predictions for new times</p></a></li>
<li><a href='#compute_gVIMP'><p>Compute the grouped importance of variables (gVIMP) statistic</p></a></li>
<li><a href='#compute_OOBerror'><p>Compute the Out-Of-Bag error (OOB error)</p></a></li>
<li><a href='#compute_VIMP'><p>Compute the importance of variables (VIMP) statistic</p></a></li>
<li><a href='#data_simu1'><p>data_simu1 dataset</p></a></li>
<li><a href='#data_simu2'><p>data_simu1 dataset</p></a></li>
<li><a href='#DynForest'><p>Random forest with multivariate longitudinal endogenous covariates</p></a></li>
<li><a href='#DynTree'><p>Grow random survival tree using multivariate longitudinal endogenous covariates</p></a></li>
<li><a href='#DynTree_surv'><p>Grow random survival tree using multivariate longitudinal endogenous covariates</p></a></li>
<li><a href='#Fact.partitions'><p>Factor partitions finder</p></a></li>
<li><a href='#getParamMM'><p>Function to update the list of parameters for each marker using those estimated from previous node</p></a></li>
<li><a href='#getTree'><p>Extract some information about the split for a tree by user</p></a></li>
<li><a href='#getTreeNodes'><p>Extract nodes identifiers for a given tree</p></a></li>
<li><a href='#impurity'><p>Compute the impurity of a given vector</p></a></li>
<li><a href='#impurity_split'><p>Impurity Split</p></a></li>
<li><a href='#OOB.rfshape'><p>Compute the Out-Of-Bag error on the random survival forest</p></a></li>
<li><a href='#OOB.tree'><p>Compute Out-Of-Bag error on the tree</p></a></li>
<li><a href='#pbc2'><p>pbc2 dataset</p></a></li>
<li><a href='#plot.DynForest'><p>Plot function in DynForest</p></a></li>
<li><a href='#pred.MMT'><p>Predict the leaf by dropping down the subject in the tree</p></a></li>
<li><a href='#predict.DynForest'><p>Prediction using dynamic random forests</p></a></li>
<li><a href='#predRE'><p>Function to compute individual random effects using hlme output parameters</p></a></li>
<li><a href='#print.DynForest'><p>Print function</p></a></li>
<li><a href='#rf_shape_para'><p>Paralleled random survival Forest using multivariate longitudinal endogenous covariates</p></a></li>
<li><a href='#summary.DynForest'><p>Display the summary of DynForest</p></a></li>
<li><a href='#var_depth'><p>Extract characteristics from the trees building process</p></a></li>
<li><a href='#var_split_factor'><p>Split function to build the two daughter nodes from factor predictor</p></a></li>
<li><a href='#var_split_long'><p>Split function to build the two daughter nodes from longitudinal predictors</p></a></li>
<li><a href='#var_split_num'><p>Split function to build the two daughter nodes from numeric predictors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Random Forest with Multivariate Longitudinal Predictors</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Based on random forest principle, 'DynForest' is able to include 
    multiple longitudinal predictors to provide individual predictions. 
    Longitudinal predictors are modeled through the random forest. The 
    methodology is fully described for a survival outcome in: 
    Devaux, Helmer, Genuer &amp; Proust-Lima (2023) 
    &lt;<a href="https://doi.org/10.1177%2F09622802231206477">doi:10.1177/09622802231206477</a>&gt;.</td>
</tr>
<tr>
<td>Imports:</td>
<td>DescTools, cmprsk, doParallel, doRNG, foreach, ggplot2, lcmm,
methods, pbapply, pec, prodlim, stringr, survival, zoo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/anthonydevaux/DynForest">https://github.com/anthonydevaux/DynForest</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/anthonydevaux/DynForest/issues">https://github.com/anthonydevaux/DynForest/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-22 11:18:00 UTC; antho</td>
</tr>
<tr>
<td>Author:</td>
<td>Anthony Devaux <a href="https://orcid.org/0000-0002-8862-4218"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Robin Genuer <a href="https://orcid.org/0000-0002-0981-3943"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  CÃ©cile Proust-Lima
    <a href="https://orcid.org/0000-0002-9884-955X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Louis Capitaine <a href="https://orcid.org/0000-0001-6800-2342"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anthony Devaux &lt;anthony.devauxbarault@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-22 11:30:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='checking'>Internal checking function</h2><span id='topic+checking'></span>

<h3>Description</h3>

<p>Internal checking function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checking(
  DynForest_obj = NULL,
  timeData,
  fixedData,
  idVar,
  timeVar,
  timeVarModel,
  Y,
  ntree = 200,
  mtry = 1,
  nodesize = 1,
  minsplit = 2,
  cause = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checking_+3A_dynforest_obj">DynForest_obj</code></td>
<td>
<p>A <code>DynForest</code> object resulting from <code>DynForest()</code> function</p>
</td></tr>
<tr><td><code id="checking_+3A_timedata">timeData</code></td>
<td>
<p>A data.frame containing the id and time measurements variables and the time-dependent predictors.</p>
</td></tr>
<tr><td><code id="checking_+3A_fixeddata">fixedData</code></td>
<td>
<p>A data.frame containing the id variable and the time-fixed predictors. Non-continuous variables should be characterized as factor.</p>
</td></tr>
<tr><td><code id="checking_+3A_idvar">idVar</code></td>
<td>
<p>A character indicating the name of variable to identify the subjects</p>
</td></tr>
<tr><td><code id="checking_+3A_timevar">timeVar</code></td>
<td>
<p>A character indicating the name of time variable</p>
</td></tr>
<tr><td><code id="checking_+3A_timevarmodel">timeVarModel</code></td>
<td>
<p>A list for each time-dependent predictors containing a list of formula for fixed and random part from the mixed model</p>
</td></tr>
<tr><td><code id="checking_+3A_y">Y</code></td>
<td>
<p>A list of output which should contain: <code>type</code> defines the nature of the output, can be &quot;<code>surv</code>&quot;, &quot;<code>scalar</code>&quot; or &quot;<code>factor</code>&quot;; <code>Y</code> is the output variable; <code>id</code> is the vector of the identifiers for each individuals, they should be the same as the identifiers of the inputs.</p>
</td></tr>
<tr><td><code id="checking_+3A_ntree">ntree</code></td>
<td>
<p>Number of trees to grow. Default value set to 200.</p>
</td></tr>
<tr><td><code id="checking_+3A_mtry">mtry</code></td>
<td>
<p>Number of candidate variables randomly drawn at each node of the trees. This parameter should be tuned by minimizing the OOB error.</p>
</td></tr>
<tr><td><code id="checking_+3A_minsplit">minsplit</code></td>
<td>
<p>(Only with survival outcome) Minimal number of events required to split the node. Cannot be smaller than 2.</p>
</td></tr>
<tr><td><code id="checking_+3A_cause">cause</code></td>
<td>
<p>(Only with competing events) Number indicates the event of interest.</p>
</td></tr>
</table>

<hr>
<h2 id='combine_times'>Extend predictions for new times</h2><span id='topic+combine_times'></span>

<h3>Description</h3>

<p>Extend predictions for new times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_times(pred, newtimes, type = "surv")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_times_+3A_pred">pred</code></td>
<td>
<p>Prediction matrix</p>
</td></tr>
<tr><td><code id="combine_times_+3A_newtimes">newtimes</code></td>
<td>
<p>Numeric vector of new times</p>
</td></tr>
<tr><td><code id="combine_times_+3A_type">type</code></td>
<td>
<p>Character indicating survival function (<code>type</code>=&quot;surv&quot;) or risk function (<code>type</code>=&quot;risk&quot;)</p>
</td></tr>
</table>

<hr>
<h2 id='compute_gVIMP'>Compute the grouped importance of variables (gVIMP) statistic</h2><span id='topic+compute_gVIMP'></span>

<h3>Description</h3>

<p>Compute the grouped importance of variables (gVIMP) statistic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_gVIMP(
  DynForest_obj,
  IBS.min = 0,
  IBS.max = NULL,
  group = NULL,
  ncores = NULL,
  seed = 1234
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_gVIMP_+3A_dynforest_obj">DynForest_obj</code></td>
<td>
<p><code>DynForest</code> object containing the dynamic random forest used on train data</p>
</td></tr>
<tr><td><code id="compute_gVIMP_+3A_ibs.min">IBS.min</code></td>
<td>
<p>(Only with survival outcome) Minimal time to compute the Integrated Brier Score. Default value is set to 0.</p>
</td></tr>
<tr><td><code id="compute_gVIMP_+3A_ibs.max">IBS.max</code></td>
<td>
<p>(Only with survival outcome) Maximal time to compute the Integrated Brier Score. Default value is set to the maximal time-to-event found.</p>
</td></tr>
<tr><td><code id="compute_gVIMP_+3A_group">group</code></td>
<td>
<p>A list of groups with the name of the predictors assigned in each group</p>
</td></tr>
<tr><td><code id="compute_gVIMP_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used to grow trees in parallel. Default value is the number of cores of the computer-1.</p>
</td></tr>
<tr><td><code id="compute_gVIMP_+3A_seed">seed</code></td>
<td>
<p>Seed to replicate results</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>compute_gVIMP()</code> function returns a list with the following elements:</p>

<table>
<tr>
 <td style="text-align: left;">
<code>Inputs</code> </td><td style="text-align: left;"> A list of 3 elements: <code>Longitudinal</code>, <code>Numeric</code> and <code>Factor</code>. Each element contains the names of the predictors </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>group</code> </td><td style="text-align: left;"> A list of each group defined in <code>group</code> argument </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>gVIMP</code> </td><td style="text-align: left;"> A numeric vector containing the gVIMP for each group defined in <code>group</code> argument </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>tree_oob_err</code> </td><td style="text-align: left;"> A numeric vector containing the OOB error for each tree needed to compute the VIMP statistic </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>IBS.range</code> </td><td style="text-align: left;"> A vector containing the IBS min and max </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc2)

# Get Gaussian distribution for longitudinal predictors
pbc2$serBilir &lt;- log(pbc2$serBilir)
pbc2$SGOT &lt;- log(pbc2$SGOT)
pbc2$albumin &lt;- log(pbc2$albumin)
pbc2$alkaline &lt;- log(pbc2$alkaline)

# Sample 100 subjects
set.seed(1234)
id &lt;- unique(pbc2$id)
id_sample &lt;- sample(id, 100)
id_row &lt;- which(pbc2$id%in%id_sample)

pbc2_train &lt;- pbc2[id_row,]

timeData_train &lt;- pbc2_train[,c("id","time",
                                "serBilir","SGOT",
                                "albumin","alkaline")]

# Create object with longitudinal association for each predictor
timeVarModel &lt;- list(serBilir = list(fixed = serBilir ~ time,
                                     random = ~ time),
                     SGOT = list(fixed = SGOT ~ time + I(time^2),
                                 random = ~ time + I(time^2)),
                     albumin = list(fixed = albumin ~ time,
                                    random = ~ time),
                     alkaline = list(fixed = alkaline ~ time,
                                     random = ~ time))

# Build fixed data
fixedData_train &lt;- unique(pbc2_train[,c("id","age","drug","sex")])

# Build outcome data
Y &lt;- list(type = "surv",
          Y = unique(pbc2_train[,c("id","years","event")]))

# Run DynForest function
res_dyn &lt;- DynForest(timeData = timeData_train, fixedData = fixedData_train,
                     timeVar = "time", idVar = "id",
                     timeVarModel = timeVarModel, Y = Y,
                     ntree = 50, nodesize = 5, minsplit = 5,
                     cause = 2, ncores = 2, seed = 1234)

# Compute gVIMP statistic
res_dyn_gVIMP &lt;- compute_gVIMP(DynForest_obj = res_dyn,
                               group = list(group1 = c("serBilir","SGOT"),
                                            group2 = c("albumin","alkaline")),
                               ncores = 2, seed = 1234)

</code></pre>

<hr>
<h2 id='compute_OOBerror'>Compute the Out-Of-Bag error (OOB error)</h2><span id='topic+compute_OOBerror'></span>

<h3>Description</h3>

<p>Compute the Out-Of-Bag error (OOB error)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_OOBerror(DynForest_obj, IBS.min = 0, IBS.max = NULL, ncores = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_OOBerror_+3A_dynforest_obj">DynForest_obj</code></td>
<td>
<p><code>DynForest</code> object containing the dynamic random forest used on train data</p>
</td></tr>
<tr><td><code id="compute_OOBerror_+3A_ibs.min">IBS.min</code></td>
<td>
<p>(Only with survival outcome) Minimal time to compute the Integrated Brier Score. Default value is set to 0.</p>
</td></tr>
<tr><td><code id="compute_OOBerror_+3A_ibs.max">IBS.max</code></td>
<td>
<p>(Only with survival outcome) Maximal time to compute the Integrated Brier Score. Default value is set to the maximal time-to-event found.</p>
</td></tr>
<tr><td><code id="compute_OOBerror_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used to grow trees in parallel. Default value is the number of cores of the computer-1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>compute_OOBerror()</code> function return a list with the following elements:</p>

<table>
<tr>
 <td style="text-align: left;">
<code>data</code> </td><td style="text-align: left;"> A list containing the data used to grow the trees </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>rf</code> </td><td style="text-align: left;"> A table with each tree in column. Provide multiple characteristics about the tree building </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>type</code> </td><td style="text-align: left;"> Outcome type </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>times</code> </td><td style="text-align: left;"> A numeric vector containing the time-to-event for all subjects </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cause</code> </td><td style="text-align: left;"> Indicating the cause of interest </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>causes</code> </td><td style="text-align: left;"> A numeric vector containing the causes indicator </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Inputs</code> </td><td style="text-align: left;"> A list of 3 elements: <code>Longitudinal</code>, <code>Numeric</code> and <code>Factor</code>. Each element contains the names of the predictors </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Longitudinal.model</code> </td><td style="text-align: left;"> A list of longitudinal markers containing the formula used for modeling in the random forest </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>param</code> </td><td style="text-align: left;"> A list containing the hyperparameters </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>oob.err</code> </td><td style="text-align: left;"> A numeric vector containing the OOB error for each subject </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>oob.pred</code> </td><td style="text-align: left;"> Outcome prediction for all subjects </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>IBS.range</code> </td><td style="text-align: left;"> A vector containing the IBS min and max </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc2)

# Get Gaussian distribution for longitudinal predictors
pbc2$serBilir &lt;- log(pbc2$serBilir)
pbc2$SGOT &lt;- log(pbc2$SGOT)
pbc2$albumin &lt;- log(pbc2$albumin)
pbc2$alkaline &lt;- log(pbc2$alkaline)

# Sample 100 subjects
set.seed(1234)
id &lt;- unique(pbc2$id)
id_sample &lt;- sample(id, 100)
id_row &lt;- which(pbc2$id%in%id_sample)

pbc2_train &lt;- pbc2[id_row,]

timeData_train &lt;- pbc2_train[,c("id","time",
                                "serBilir","SGOT",
                                "albumin","alkaline")]

# Create object with longitudinal association for each predictor
timeVarModel &lt;- list(serBilir = list(fixed = serBilir ~ time,
                                     random = ~ time),
                     SGOT = list(fixed = SGOT ~ time + I(time^2),
                                 random = ~ time + I(time^2)),
                     albumin = list(fixed = albumin ~ time,
                                    random = ~ time),
                     alkaline = list(fixed = alkaline ~ time,
                                     random = ~ time))

# Build fixed data
fixedData_train &lt;- unique(pbc2_train[,c("id","age","drug","sex")])

# Build outcome data
Y &lt;- list(type = "surv",
          Y = unique(pbc2_train[,c("id","years","event")]))

# Run DynForest function
res_dyn &lt;- DynForest(timeData = timeData_train, fixedData = fixedData_train,
                     timeVar = "time", idVar = "id",
                     timeVarModel = timeVarModel, Y = Y,
                     ntree = 50, nodesize = 5, minsplit = 5,
                     cause = 2, ncores = 2, seed = 1234)

# Compute OOB error
res_dyn_OOB &lt;- compute_OOBerror(DynForest_obj = res_dyn, ncores = 2)

</code></pre>

<hr>
<h2 id='compute_VIMP'>Compute the importance of variables (VIMP) statistic</h2><span id='topic+compute_VIMP'></span>

<h3>Description</h3>

<p>Compute the importance of variables (VIMP) statistic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute_VIMP(
  DynForest_obj,
  IBS.min = 0,
  IBS.max = NULL,
  ncores = NULL,
  seed = 1234
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_VIMP_+3A_dynforest_obj">DynForest_obj</code></td>
<td>
<p><code>DynForest</code> object containing the dynamic random forest used on train data</p>
</td></tr>
<tr><td><code id="compute_VIMP_+3A_ibs.min">IBS.min</code></td>
<td>
<p>(Only with survival outcome) Minimal time to compute the Integrated Brier Score. Default value is set to 0.</p>
</td></tr>
<tr><td><code id="compute_VIMP_+3A_ibs.max">IBS.max</code></td>
<td>
<p>(Only with survival outcome) Maximal time to compute the Integrated Brier Score. Default value is set to the maximal time-to-event found.</p>
</td></tr>
<tr><td><code id="compute_VIMP_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used to grow trees in parallel. Default value is the number of cores of the computer-1.</p>
</td></tr>
<tr><td><code id="compute_VIMP_+3A_seed">seed</code></td>
<td>
<p>Seed to replicate results</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>compute_VIMP()</code> function returns a list with the following elements:</p>

<table>
<tr>
 <td style="text-align: left;">
<code>Inputs</code> </td><td style="text-align: left;"> A list of 3 elements: <code>Longitudinal</code>, <code>Numeric</code> and <code>Factor</code>. Each element contains the names of the predictors </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Importance</code> </td><td style="text-align: left;"> A list of 3 elements: <code>Longitudinal</code>, <code>Numeric</code> and <code>Factor</code>. Each element contains a numeric vector of VIMP statistic predictor in <code>Inputs</code> value </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>tree_oob_err</code> </td><td style="text-align: left;"> A numeric vector containing the OOB error for each tree needed to compute the VIMP statistic </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>IBS.range</code> </td><td style="text-align: left;"> A vector containing the IBS min and max </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc2)

# Get Gaussian distribution for longitudinal predictors
pbc2$serBilir &lt;- log(pbc2$serBilir)
pbc2$SGOT &lt;- log(pbc2$SGOT)
pbc2$albumin &lt;- log(pbc2$albumin)
pbc2$alkaline &lt;- log(pbc2$alkaline)

# Sample 100 subjects
set.seed(1234)
id &lt;- unique(pbc2$id)
id_sample &lt;- sample(id, 100)
id_row &lt;- which(pbc2$id%in%id_sample)

pbc2_train &lt;- pbc2[id_row,]

timeData_train &lt;- pbc2_train[,c("id","time",
                                "serBilir","SGOT",
                                "albumin","alkaline")]

# Create object with longitudinal association for each predictor
timeVarModel &lt;- list(serBilir = list(fixed = serBilir ~ time,
                                     random = ~ time),
                     SGOT = list(fixed = SGOT ~ time + I(time^2),
                                 random = ~ time + I(time^2)),
                     albumin = list(fixed = albumin ~ time,
                                    random = ~ time),
                     alkaline = list(fixed = alkaline ~ time,
                                     random = ~ time))

# Build fixed data
fixedData_train &lt;- unique(pbc2_train[,c("id","age","drug","sex")])

# Build outcome data
Y &lt;- list(type = "surv",
          Y = unique(pbc2_train[,c("id","years","event")]))

# Run DynForest function
res_dyn &lt;- DynForest(timeData = timeData_train, fixedData = fixedData_train,
                     timeVar = "time", idVar = "id",
                     timeVarModel = timeVarModel, Y = Y,
                     ntree = 50, nodesize = 5, minsplit = 5,
                     cause = 2, ncores = 2, seed = 1234)

# Compute VIMP statistic
res_dyn_VIMP &lt;- compute_VIMP(DynForest_obj = res_dyn, ncores = 2, seed = 1234)


</code></pre>

<hr>
<h2 id='data_simu1'>data_simu1 dataset</h2><span id='topic+data_simu1'></span>

<h3>Description</h3>

<p>Simulated dataset 1 with continuous outcome
</p>


<h3>Format</h3>

<p>Longitudinal dataset with 1200 rows and 13 columns for 200 subjects
</p>

<dl>
<dt>id</dt><dd><p>Subject identifier</p>
</dd>
<dt>time</dt><dd><p>Time measurement</p>
</dd>
<dt>cont_covar1</dt><dd><p>Continuous time-fixed predictor 1</p>
</dd>
<dt>cont_covar2</dt><dd><p>Continuous time-fixed predictor 2</p>
</dd>
<dt>bin_covar1</dt><dd><p>Binary time-fixed predictor 1</p>
</dd>
<dt>bin_covar2</dt><dd><p>Binary time-fixed predictor 2</p>
</dd>
<dt>marker1</dt><dd><p>Continuous time-dependent predictor 1</p>
</dd>
<dt>marker2</dt><dd><p>Continuous time-dependent predictor 2</p>
</dd>
<dt>marker3</dt><dd><p>Continuous time-dependent predictor 3</p>
</dd>
<dt>marker4</dt><dd><p>Continuous time-dependent predictor 4</p>
</dd>
<dt>marker5</dt><dd><p>Continuous time-dependent predictor 5</p>
</dd>
<dt>marker6</dt><dd><p>Continuous time-dependent predictor 6</p>
</dd>
<dt>Y_res</dt><dd><p>Continuous outcome</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data_simu1)
</code></pre>

<hr>
<h2 id='data_simu2'>data_simu1 dataset</h2><span id='topic+data_simu2'></span>

<h3>Description</h3>

<p>Simulated dataset 2 with continuous outcome
</p>


<h3>Format</h3>

<p>Longitudinal dataset with 1200 rows and 13 columns for 200 subjects
</p>

<dl>
<dt>id</dt><dd><p>Subject identifier</p>
</dd>
<dt>time</dt><dd><p>Time measurement</p>
</dd>
<dt>cont_covar1</dt><dd><p>Continuous time-fixed predictor 1</p>
</dd>
<dt>cont_covar2</dt><dd><p>Continuous time-fixed predictor 2</p>
</dd>
<dt>bin_covar1</dt><dd><p>Binary time-fixed predictor 1</p>
</dd>
<dt>bin_covar2</dt><dd><p>Binary time-fixed predictor 2</p>
</dd>
<dt>marker1</dt><dd><p>Continuous time-dependent predictor 1</p>
</dd>
<dt>marker2</dt><dd><p>Continuous time-dependent predictor 2</p>
</dd>
<dt>marker3</dt><dd><p>Continuous time-dependent predictor 3</p>
</dd>
<dt>marker4</dt><dd><p>Continuous time-dependent predictor 4</p>
</dd>
<dt>marker5</dt><dd><p>Continuous time-dependent predictor 5</p>
</dd>
<dt>marker6</dt><dd><p>Continuous time-dependent predictor 6</p>
</dd>
<dt>Y_res</dt><dd><p>Continuous outcome</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>data(data_simu2)
</code></pre>

<hr>
<h2 id='DynForest'>Random forest with multivariate longitudinal endogenous covariates</h2><span id='topic+DynForest'></span>

<h3>Description</h3>

<p>Build a random forest using multivariate longitudinal endogenous covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DynForest(
  timeData = NULL,
  fixedData = NULL,
  idVar = NULL,
  timeVar = NULL,
  timeVarModel = NULL,
  Y = NULL,
  ntree = 200,
  mtry = NULL,
  nodesize = 1,
  minsplit = 2,
  cause = 1,
  nsplit_option = "quantile",
  ncores = NULL,
  seed = 1234,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DynForest_+3A_timedata">timeData</code></td>
<td>
<p>A data.frame containing the id and time measurements variables and the time-dependent predictors.</p>
</td></tr>
<tr><td><code id="DynForest_+3A_fixeddata">fixedData</code></td>
<td>
<p>A data.frame containing the id variable and the time-fixed predictors. Categorical variables should be characterized as factor.</p>
</td></tr>
<tr><td><code id="DynForest_+3A_idvar">idVar</code></td>
<td>
<p>A character indicating the name of variable to identify the subjects</p>
</td></tr>
<tr><td><code id="DynForest_+3A_timevar">timeVar</code></td>
<td>
<p>A character indicating the name of time variable</p>
</td></tr>
<tr><td><code id="DynForest_+3A_timevarmodel">timeVarModel</code></td>
<td>
<p>A list for each time-dependent predictors containing a list of formula for fixed and random part from the mixed model</p>
</td></tr>
<tr><td><code id="DynForest_+3A_y">Y</code></td>
<td>
<p>A list of output which should contain: <code>type</code> defines the nature of the outcome, can be &quot;<code>surv</code>&quot;, &quot;<code>numeric</code>&quot; or &quot;<code>factor</code>&quot;; .</p>
</td></tr>
<tr><td><code id="DynForest_+3A_ntree">ntree</code></td>
<td>
<p>Number of trees to grow. Default value set to 200.</p>
</td></tr>
<tr><td><code id="DynForest_+3A_mtry">mtry</code></td>
<td>
<p>Number of candidate variables randomly drawn at each node of the trees. This parameter should be tuned by minimizing the OOB error. Default is defined as the square root of the number of predictors.</p>
</td></tr>
<tr><td><code id="DynForest_+3A_nodesize">nodesize</code></td>
<td>
<p>Minimal number of subjects required in both child nodes to split. Cannot be smaller than 1.</p>
</td></tr>
<tr><td><code id="DynForest_+3A_minsplit">minsplit</code></td>
<td>
<p>(Only with survival outcome) Minimal number of events required to split the node. Cannot be smaller than 2.</p>
</td></tr>
<tr><td><code id="DynForest_+3A_cause">cause</code></td>
<td>
<p>(Only with competing events) Number indicates the event of interest.</p>
</td></tr>
<tr><td><code id="DynForest_+3A_nsplit_option">nsplit_option</code></td>
<td>
<p>A character indicates how the values are chosen to build the two groups for the splitting rule (only for continuous predictors). Values are chosen using deciles (<code>nsplit_option</code>=&quot;quantile&quot;) or randomly (<code>nsplit_option</code>=&quot;sample&quot;). Default value is &quot;quantile&quot;.</p>
</td></tr>
<tr><td><code id="DynForest_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used to grow trees in parallel. Default value is the number of cores of the computer-1.</p>
</td></tr>
<tr><td><code id="DynForest_+3A_seed">seed</code></td>
<td>
<p>Seed to replicate results</p>
</td></tr>
<tr><td><code id="DynForest_+3A_verbose">verbose</code></td>
<td>
<p>A logical controlling the function progress. Default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function currently supports survival (competing or single event), continuous or categorical outcome.
</p>
<p>FUTUR IMPLEMENTATIONS:
</p>

<ul>
<li><p> Continuous longitudinal outcome
</p>
</li>
<li><p> Functional data analysis
</p>
</li></ul>



<h3>Value</h3>

<p>DynForest function returns a list with the following elements:</p>

<table>
<tr>
 <td style="text-align: left;">
<code>data</code> </td><td style="text-align: left;"> A list containing the data used to grow the trees </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>rf</code> </td><td style="text-align: left;"> A table with each tree in column. Provide multiple characteristics about the tree building </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>type</code> </td><td style="text-align: left;"> Outcome type </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>times</code> </td><td style="text-align: left;"> A numeric vector containing the time-to-event for all subjects </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>cause</code> </td><td style="text-align: left;"> Indicating the cause of interest </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>causes</code> </td><td style="text-align: left;"> A numeric vector containing the causes indicator </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Inputs</code> </td><td style="text-align: left;"> A list of 3 elements: <code>Longitudinal</code>, <code>Numeric</code> and <code>Factor</code>. Each element contains the names of the predictors </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Longitudinal.model</code> </td><td style="text-align: left;"> A list of longitudinal markers containing the formula used for modeling in the random forest </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>param</code> </td><td style="text-align: left;"> A list containing the hyperparameters </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>comput.time</code> </td><td style="text-align: left;"> Computation time </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Anthony Devaux (<a href="mailto:anthony.devauxbarault@gmail.com">anthony.devauxbarault@gmail.com</a>)
</p>


<h3>References</h3>


<ul>
<li><p> Devaux A., Helmer C., Genuer R., Proust-Lima C. (2023). Random survival forests with multivariate longitudinal endogenous covariates. SMMR <a href="doi:10.1177/09622802231206477">doi:10.1177/09622802231206477</a>
</p>
</li>
<li><p> Devaux A., Proust-Lima C., Genuer R. (2023). Random Forests for time-fixed and time-dependent predictors: The DynForest R package. arXiv <a href="doi:10.48550/arXiv.2302.02670">doi:10.48550/arXiv.2302.02670</a>
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+summary.DynForest">summary.DynForest</a> <a href="#topic+compute_OOBerror">compute_OOBerror</a> <a href="#topic+compute_VIMP">compute_VIMP</a> <a href="#topic+compute_gVIMP">compute_gVIMP</a> <a href="#topic+predict.DynForest">predict.DynForest</a> <a href="#topic+plot.DynForest">plot.DynForest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc2)

# Get Gaussian distribution for longitudinal predictors
pbc2$serBilir &lt;- log(pbc2$serBilir)
pbc2$SGOT &lt;- log(pbc2$SGOT)
pbc2$albumin &lt;- log(pbc2$albumin)
pbc2$alkaline &lt;- log(pbc2$alkaline)

# Sample 100 subjects
set.seed(1234)
id &lt;- unique(pbc2$id)
id_sample &lt;- sample(id, 100)
id_row &lt;- which(pbc2$id%in%id_sample)

pbc2_train &lt;- pbc2[id_row,]

timeData_train &lt;- pbc2_train[,c("id","time",
                                "serBilir","SGOT",
                                "albumin","alkaline")]

# Create object with longitudinal association for each predictor
timeVarModel &lt;- list(serBilir = list(fixed = serBilir ~ time,
                                     random = ~ time),
                     SGOT = list(fixed = SGOT ~ time + I(time^2),
                                 random = ~ time + I(time^2)),
                     albumin = list(fixed = albumin ~ time,
                                    random = ~ time),
                     alkaline = list(fixed = alkaline ~ time,
                                     random = ~ time))

# Build fixed data
fixedData_train &lt;- unique(pbc2_train[,c("id","age","drug","sex")])

# Build outcome data
Y &lt;- list(type = "surv",
          Y = unique(pbc2_train[,c("id","years","event")]))

# Run DynForest function
res_dyn &lt;- DynForest(timeData = timeData_train, fixedData = fixedData_train,
                     timeVar = "time", idVar = "id",
                     timeVarModel = timeVarModel, Y = Y,
                     ntree = 50, nodesize = 5, minsplit = 5,
                     cause = 2, ncores = 2, seed = 1234)

</code></pre>

<hr>
<h2 id='DynTree'>Grow random survival tree using multivariate longitudinal endogenous covariates</h2><span id='topic+DynTree'></span>

<h3>Description</h3>

<p>Grow random survival tree using multivariate longitudinal endogenous covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DynTree(
  Y,
  Longitudinal = NULL,
  Numeric = NULL,
  Factor = NULL,
  timeVar = NULL,
  mtry = 1,
  nsplit_option = "quantile",
  nodesize = 1,
  seed = 1234
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DynTree_+3A_y">Y</code></td>
<td>
<p>A list of output which should contain: <code>type</code> defines the nature of the outcome, can be &quot;<code>surv</code>&quot;, &quot;<code>numeric</code>&quot; or &quot;<code>factor</code>&quot;; <code>Y</code> is the output variable; <code>id</code> is the vector of the identifiers for each individuals, they should be the same as the identifiers of the inputs.</p>
</td></tr>
<tr><td><code id="DynTree_+3A_longitudinal">Longitudinal</code></td>
<td>
<p>A list of longitudinal predictors which should contain: <code>X</code> a dataframe with one row for repeated measurement and as many columns as markers; <code>id</code> is the vector of the identifiers for the repeated measurements contained in <code>X</code>; <code>time</code> is the vector of the measurement times contained in <code>X</code>.</p>
</td></tr>
<tr><td><code id="DynTree_+3A_numeric">Numeric</code></td>
<td>
<p>A list of numeric predictors which should contain: <code>X</code> a dataframe with as many columns as numeric predictors; <code>id</code> is the vector of the identifiers for each individual.</p>
</td></tr>
<tr><td><code id="DynTree_+3A_factor">Factor</code></td>
<td>
<p>A list of factor predictors which should contain: <code>X</code> a dataframe with as many columns as factor predictors; <code>id</code> is the vector of the identifiers for each individual.</p>
</td></tr>
<tr><td><code id="DynTree_+3A_timevar">timeVar</code></td>
<td>
<p>A character indicating the name of time variable</p>
</td></tr>
<tr><td><code id="DynTree_+3A_mtry">mtry</code></td>
<td>
<p>Number of candidate variables randomly drawn at each node of the trees. This parameter should be tuned by minimizing the OOB error. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="DynTree_+3A_nsplit_option">nsplit_option</code></td>
<td>
<p>A character indicates how the values are chosen to build the two groups for the splitting rule (only for continuous predictors). Values are chosen using deciles (<code>nsplit_option</code>=&quot;quantile&quot;) or randomly (<code>nsplit_option</code>=&quot;sample&quot;). Default value is &quot;quantile&quot;.</p>
</td></tr>
<tr><td><code id="DynTree_+3A_nodesize">nodesize</code></td>
<td>
<p>Minimal number of subjects required in both child nodes to split. Cannot be smaller than 1.</p>
</td></tr>
<tr><td><code id="DynTree_+3A_seed">seed</code></td>
<td>
<p>Seed to replicate results</p>
</td></tr>
</table>

<hr>
<h2 id='DynTree_surv'>Grow random survival tree using multivariate longitudinal endogenous covariates</h2><span id='topic+DynTree_surv'></span>

<h3>Description</h3>

<p>Grow random survival tree using multivariate longitudinal endogenous covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DynTree_surv(
  Y,
  Longitudinal = NULL,
  Numeric = NULL,
  Factor = NULL,
  timeVar = NULL,
  mtry = 1,
  nsplit_option = "quantile",
  nodesize = 1,
  minsplit = 2,
  cause = 1,
  seed = 1234
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DynTree_surv_+3A_y">Y</code></td>
<td>
<p>A list of output which should contain: <code>type</code> defines the nature of the outcome, can be &quot;<code>surv</code>&quot;, &quot;<code>numeric</code>&quot; or &quot;<code>factor</code>&quot;; <code>Y</code> is the output variable; <code>id</code> is the vector of the identifiers for each individuals, they should be the same as the identifiers of the inputs.</p>
</td></tr>
<tr><td><code id="DynTree_surv_+3A_longitudinal">Longitudinal</code></td>
<td>
<p>A list of longitudinal predictors which should contain: <code>X</code> a dataframe with one row for repeated measurement and as many columns as markers; <code>id</code> is the vector of the identifiers for the repeated measurements contained in <code>X</code>; <code>time</code> is the vector of the measurement times contained in <code>X</code>.</p>
</td></tr>
<tr><td><code id="DynTree_surv_+3A_numeric">Numeric</code></td>
<td>
<p>A list of numeric predictors which should contain: <code>X</code> a dataframe with as many columns as numeric predictors; <code>id</code> is the vector of the identifiers for each individual.</p>
</td></tr>
<tr><td><code id="DynTree_surv_+3A_factor">Factor</code></td>
<td>
<p>A list of factor predictors which should contain: <code>X</code> a dataframe with as many columns as factor predictors; <code>id</code> is the vector of the identifiers for each individual.</p>
</td></tr>
<tr><td><code id="DynTree_surv_+3A_timevar">timeVar</code></td>
<td>
<p>A character indicating the name of time variable</p>
</td></tr>
<tr><td><code id="DynTree_surv_+3A_mtry">mtry</code></td>
<td>
<p>Number of candidate variables randomly drawn at each node of the trees. This parameter should be tuned by minimizing the OOB error. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="DynTree_surv_+3A_nsplit_option">nsplit_option</code></td>
<td>
<p>A character indicates how the values are chosen to build the two groups for the splitting rule (only for continuous predictors). Values are chosen using deciles (<code>nsplit_option</code>=&quot;quantile&quot;) or randomly (<code>nsplit_option</code>=&quot;sample&quot;). Default value is &quot;quantile&quot;.</p>
</td></tr>
<tr><td><code id="DynTree_surv_+3A_nodesize">nodesize</code></td>
<td>
<p>Minimal number of subjects required in both child nodes to split. Cannot be smaller than 1.</p>
</td></tr>
<tr><td><code id="DynTree_surv_+3A_minsplit">minsplit</code></td>
<td>
<p>(Only with survival outcome) Minimal number of events required to split the node. Cannot be smaller than 2.</p>
</td></tr>
<tr><td><code id="DynTree_surv_+3A_cause">cause</code></td>
<td>
<p>(Only with competing events) Number indicates the event of interest.</p>
</td></tr>
<tr><td><code id="DynTree_surv_+3A_seed">seed</code></td>
<td>
<p>Seed to replicate results</p>
</td></tr>
</table>

<hr>
<h2 id='Fact.partitions'>Factor partitions finder</h2><span id='topic+Fact.partitions'></span>

<h3>Description</h3>

<p>This function is used to find all the unique partitions of k factors into 2 groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fact.partitions(Factor, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fact.partitions_+3A_factor">Factor</code></td>
<td>
<p>Character vector</p>
</td></tr>
<tr><td><code id="Fact.partitions_+3A_id">id</code></td>
<td>
<p>List of id</p>
</td></tr>
</table>

<hr>
<h2 id='getParamMM'>Function to update the list of parameters for each marker using those estimated from previous node</h2><span id='topic+getParamMM'></span>

<h3>Description</h3>

<p>Function to update the list of parameters for each marker using those estimated from previous node
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getParamMM(current_node, markers, params)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getParamMM_+3A_current_node">current_node</code></td>
<td>
<p>Current node of the tree</p>
</td></tr>
<tr><td><code id="getParamMM_+3A_markers">markers</code></td>
<td>
<p>Character vector indicating the name of the markers to be updated</p>
</td></tr>
<tr><td><code id="getParamMM_+3A_params">params</code></td>
<td>
<p>List to be updated for the current node</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the updated parameters from the requested markers
</p>

<hr>
<h2 id='getTree'>Extract some information about the split for a tree by user</h2><span id='topic+getTree'></span>

<h3>Description</h3>

<p>Extract some information about the split for a tree by user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTree(DynForest_obj, tree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTree_+3A_dynforest_obj">DynForest_obj</code></td>
<td>
<p><code>DynForest</code> object containing the dynamic random forest used on train data</p>
</td></tr>
<tr><td><code id="getTree_+3A_tree">tree</code></td>
<td>
<p>Integer indicating the tree identifier</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table sorted by the node/leaf identifier with each row representing a node/leaf. Each column provides information about the splits:</p>

<table>
<tr>
 <td style="text-align: left;">
<code>type</code> </td><td style="text-align: left;"> The nature of the predictor (<code>Longitudinal</code> for longitudinal predictor, <code>Numeric</code> for continuous predictor or <code>Factor</code> for categorical predictor) if the node was split, <code>Leaf</code> otherwise </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>var_split</code> </td><td style="text-align: left;"> The predictor used for the split defined by its order in <code>timeData</code> and <code>fixedData</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>feature</code> </td><td style="text-align: left;"> The feature used for the split defined by its position in random statistic </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>threshold</code> </td><td style="text-align: left;"> The threshold used for the split (only with <code>Longitudinal</code> and <code>Numeric</code>). No information is returned for <code>Factor</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>N</code> </td><td style="text-align: left;"> The number of subjects in the node/leaf </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Nevent</code> </td><td style="text-align: left;"> The number of events of interest in the node/leaf (only with survival outcome) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>depth</code> </td><td style="text-align: left;"> the depth level of the node/leaf </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><code><a href="#topic+DynForest">DynForest</a> <a href="#topic+summary.DynForest">summary.DynForest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc2)

# Get Gaussian distribution for longitudinal predictors
pbc2$serBilir &lt;- log(pbc2$serBilir)
pbc2$SGOT &lt;- log(pbc2$SGOT)
pbc2$albumin &lt;- log(pbc2$albumin)
pbc2$alkaline &lt;- log(pbc2$alkaline)

# Sample 100 subjects
set.seed(1234)
id &lt;- unique(pbc2$id)
id_sample &lt;- sample(id, 100)
id_row &lt;- which(pbc2$id%in%id_sample)

pbc2_train &lt;- pbc2[id_row,]

timeData_train &lt;- pbc2_train[,c("id","time",
                                "serBilir","SGOT",
                                "albumin","alkaline")]

# Create object with longitudinal association for each predictor
timeVarModel &lt;- list(serBilir = list(fixed = serBilir ~ time,
                                     random = ~ time),
                     SGOT = list(fixed = SGOT ~ time + I(time^2),
                                 random = ~ time + I(time^2)),
                     albumin = list(fixed = albumin ~ time,
                                    random = ~ time),
                     alkaline = list(fixed = alkaline ~ time,
                                     random = ~ time))

# Build fixed data
fixedData_train &lt;- unique(pbc2_train[,c("id","age","drug","sex")])

# Build outcome data
Y &lt;- list(type = "surv",
          Y = unique(pbc2_train[,c("id","years","event")]))

# Run DynForest function
res_dyn &lt;- DynForest(timeData = timeData_train, fixedData = fixedData_train,
                     timeVar = "time", idVar = "id",
                     timeVarModel = timeVarModel, Y = Y,
                     ntree = 50, nodesize = 5, minsplit = 5,
                     cause = 2, ncores = 2, seed = 1234)

# Extract split information from tree 4
res_tree4 &lt;- getTree(DynForest_obj = res_dyn, tree = 4)

</code></pre>

<hr>
<h2 id='getTreeNodes'>Extract nodes identifiers for a given tree</h2><span id='topic+getTreeNodes'></span>

<h3>Description</h3>

<p>Extract nodes identifiers for a given tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getTreeNodes(DynForest_obj, tree = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getTreeNodes_+3A_dynforest_obj">DynForest_obj</code></td>
<td>
<p>A DynForest object from <code>DynForest()</code> function</p>
</td></tr>
<tr><td><code id="getTreeNodes_+3A_tree">tree</code></td>
<td>
<p>Integer indicating the tree identifier</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Extract nodes identifiers for a given tree
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc2)

# Get Gaussian distribution for longitudinal predictors
pbc2$serBilir &lt;- log(pbc2$serBilir)
pbc2$SGOT &lt;- log(pbc2$SGOT)
pbc2$albumin &lt;- log(pbc2$albumin)
pbc2$alkaline &lt;- log(pbc2$alkaline)

# Sample 100 subjects
set.seed(1234)
id &lt;- unique(pbc2$id)
id_sample &lt;- sample(id, 100)
id_row &lt;- which(pbc2$id%in%id_sample)

pbc2_train &lt;- pbc2[id_row,]

timeData_train &lt;- pbc2_train[,c("id","time",
                                "serBilir","SGOT",
                                "albumin","alkaline")]

# Create object with longitudinal association for each predictor
timeVarModel &lt;- list(serBilir = list(fixed = serBilir ~ time,
                                     random = ~ time),
                     SGOT = list(fixed = SGOT ~ time + I(time^2),
                                 random = ~ time + I(time^2)),
                     albumin = list(fixed = albumin ~ time,
                                    random = ~ time),
                     alkaline = list(fixed = alkaline ~ time,
                                     random = ~ time))

# Build fixed data
fixedData_train &lt;- unique(pbc2_train[,c("id","age","drug","sex")])

# Build outcome data
Y &lt;- list(type = "surv",
          Y = unique(pbc2_train[,c("id","years","event")]))

# Run DynForest function
res_dyn &lt;- DynForest(timeData = timeData_train, fixedData = fixedData_train,
                     timeVar = "time", idVar = "id",
                     timeVarModel = timeVarModel, Y = Y,
                     ntree = 50, nodesize = 5, minsplit = 5,
                     cause = 2, ncores = 2, seed = 1234)

# Extract nodes identifiers for a given tree
getTreeNodes(DynForest_obj = res_dyn, tree = 1)

</code></pre>

<hr>
<h2 id='impurity'>Compute the impurity of a given vector</h2><span id='topic+impurity'></span>

<h3>Description</h3>

<p>Compute the impurity of a given vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impurity(Y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impurity_+3A_y">Y</code></td>
<td>
<p>Outcome data</p>
</td></tr>
</table>

<hr>
<h2 id='impurity_split'>Impurity Split</h2><span id='topic+impurity_split'></span>

<h3>Description</h3>

<p>Impurity Split
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impurity_split(Y, split, cause = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impurity_split_+3A_y">Y</code></td>
<td>
<p>Outcome data</p>
</td></tr>
<tr><td><code id="impurity_split_+3A_split">split</code></td>
<td>
<p>Vector containing the subjects groups</p>
</td></tr>
<tr><td><code id="impurity_split_+3A_cause">cause</code></td>
<td>
<p>(Only with competing events) Number indicates the event of interest.</p>
</td></tr>
</table>

<hr>
<h2 id='OOB.rfshape'>Compute the Out-Of-Bag error on the random survival forest</h2><span id='topic+OOB.rfshape'></span>

<h3>Description</h3>

<p>Compute the Out-Of-Bag error on the random survival forest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OOB.rfshape(
  rf,
  Longitudinal = NULL,
  Numeric = NULL,
  Factor = NULL,
  Y,
  timeVar = NULL,
  IBS.min = 0,
  IBS.max = NULL,
  cause = 1,
  ncores = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OOB.rfshape_+3A_rf">rf</code></td>
<td>
<p>Trees object resulting from <code>rf_shape_para</code> function</p>
</td></tr>
<tr><td><code id="OOB.rfshape_+3A_longitudinal">Longitudinal</code></td>
<td>
<p>A list of longitudinal predictors which should contain: <code>X</code> a dataframe with one row for repeated measurement and as many columns as markers; <code>id</code> is the vector of the identifiers for the repeated measurements contained in <code>X</code>; <code>time</code> is the vector of the measurement times contained in <code>X</code>.</p>
</td></tr>
<tr><td><code id="OOB.rfshape_+3A_numeric">Numeric</code></td>
<td>
<p>A list of numeric predictors which should contain: <code>X</code> a dataframe with as many columns as numeric predictors; <code>id</code> is the vector of the identifiers for each individual.</p>
</td></tr>
<tr><td><code id="OOB.rfshape_+3A_factor">Factor</code></td>
<td>
<p>A list of factor predictors which should contain: <code>X</code> a dataframe with as many columns as factor predictors; <code>id</code> is the vector of the identifiers for each individual.</p>
</td></tr>
<tr><td><code id="OOB.rfshape_+3A_y">Y</code></td>
<td>
<p>A list of output which should contain: <code>type</code> defines the nature of the output, can be &quot;<code>surv</code>&quot;, &quot;<code>numeric</code>&quot; or &quot;<code>factor</code>&quot;; <code>Y</code> is the output variable; <code>id</code> is the vector of the identifiers for each individuals, they should be the same as the identifiers of the Inputs.</p>
</td></tr>
<tr><td><code id="OOB.rfshape_+3A_timevar">timeVar</code></td>
<td>
<p>A character indicating the name of time variable</p>
</td></tr>
<tr><td><code id="OOB.rfshape_+3A_ibs.min">IBS.min</code></td>
<td>
<p>(Only with survival outcome) Minimal time to compute the Integrated Brier Score. Default value is set to 0.</p>
</td></tr>
<tr><td><code id="OOB.rfshape_+3A_ibs.max">IBS.max</code></td>
<td>
<p>(Only with survival outcome) Maximal time to compute the Integrated Brier Score. Default value is set to the maximal time-to-event found.</p>
</td></tr>
<tr><td><code id="OOB.rfshape_+3A_cause">cause</code></td>
<td>
<p>(Only with competing events) Number indicates the event of interest.</p>
</td></tr>
<tr><td><code id="OOB.rfshape_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used to grow trees in parallel. Default value is the number of cores of the computer-1.</p>
</td></tr>
</table>

<hr>
<h2 id='OOB.tree'>Compute Out-Of-Bag error on the tree</h2><span id='topic+OOB.tree'></span>

<h3>Description</h3>

<p>Compute Out-Of-Bag error on the tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OOB.tree(
  tree,
  Longitudinal = NULL,
  Numeric = NULL,
  Factor = NULL,
  Y,
  timeVar = NULL,
  IBS.min = 0,
  IBS.max = NULL,
  cause = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OOB.tree_+3A_tree">tree</code></td>
<td>
<p>Tree object resulting from <code>Rtmax_surv</code> function</p>
</td></tr>
<tr><td><code id="OOB.tree_+3A_longitudinal">Longitudinal</code></td>
<td>
<p>A list of longitudinal predictors which should contain: <code>X</code> a dataframe with one row for repeated measurement and as many columns as markers; <code>id</code> is the vector of the identifiers for the repeated measurements contained in <code>X</code>; <code>time</code> is the vector of the measurement times contained in <code>X</code>.</p>
</td></tr>
<tr><td><code id="OOB.tree_+3A_numeric">Numeric</code></td>
<td>
<p>A list of numeric predictors which should contain: <code>X</code> a dataframe with as many columns as numeric predictors; <code>id</code> is the vector of the identifiers for each individual.</p>
</td></tr>
<tr><td><code id="OOB.tree_+3A_factor">Factor</code></td>
<td>
<p>A list of factor predictors which should contain: <code>X</code> a dataframe with as many columns as factor predictors; <code>id</code> is the vector of the identifiers for each individual.</p>
</td></tr>
<tr><td><code id="OOB.tree_+3A_y">Y</code></td>
<td>
<p>A list of output which should contain: <code>type</code> defines the nature of the outcome, can be &quot;<code>surv</code>&quot;, &quot;<code>numeric</code>&quot; or &quot;<code>factor</code>&quot;; <code>Y</code> is the output variable; <code>id</code> is the vector of the identifiers for each individuals, they should be the same as the identifiers of the Inputs.</p>
</td></tr>
<tr><td><code id="OOB.tree_+3A_timevar">timeVar</code></td>
<td>
<p>A character indicating the name of time variable</p>
</td></tr>
<tr><td><code id="OOB.tree_+3A_ibs.min">IBS.min</code></td>
<td>
<p>(Only with survival outcome) Minimal time to compute the Integrated Brier Score. Default value is set to 0.</p>
</td></tr>
<tr><td><code id="OOB.tree_+3A_ibs.max">IBS.max</code></td>
<td>
<p>(Only with survival outcome) Maximal time to compute the Integrated Brier Score. Default value is set to the maximal time-to-event found.</p>
</td></tr>
<tr><td><code id="OOB.tree_+3A_cause">cause</code></td>
<td>
<p>(Only with competing events) Number indicates the event of interest.</p>
</td></tr>
</table>

<hr>
<h2 id='pbc2'>pbc2 dataset</h2><span id='topic+pbc2'></span>

<h3>Description</h3>

<p>pbc2 data from Mayo clinic
</p>


<h3>Format</h3>

<p>Longitudinal dataset with 1945 rows and 19 columns for 312 patients
</p>

<dl>
<dt>id</dt><dd><p>Patient identifier</p>
</dd>
<dt>time</dt><dd><p>Time measurement</p>
</dd>
<dt>ascites</dt><dd><p>Presence of ascites (Yes/No)</p>
</dd>
<dt>hepatomegaly</dt><dd><p>Presence of hepatomegaly (Yes/No)</p>
</dd>
<dt>spiders</dt><dd><p>Blood vessel malformations in the skin (Yes/No)</p>
</dd>
<dt>edema</dt><dd><p>Edema levels (No edema/edema no diuretics/edema despite diuretics)</p>
</dd>
<dt>serBilir</dt><dd><p>Level of serum bilirubin</p>
</dd>
<dt>serChol</dt><dd><p>Level of serum cholesterol</p>
</dd>
<dt>albumin</dt><dd><p>Level of albumin</p>
</dd>
<dt>alkaline</dt><dd><p>Level of alkaline phosphatase</p>
</dd>
<dt>SGOT</dt><dd><p>Level of aspartate aminotransferase</p>
</dd>
<dt>platelets</dt><dd><p>Platelet count</p>
</dd>
<dt>prothrombin</dt><dd><p>Prothrombin time</p>
</dd>
<dt>histologic</dt><dd><p>Histologic stage of disease</p>
</dd>
<dt>drug</dt><dd><p>Drug treatment (D-penicillmain/Placebo)</p>
</dd>
<dt>age</dt><dd><p>Age at enrollment</p>
</dd>
<dt>sex</dt><dd><p>Sex of patient</p>
</dd>
<dt>years</dt><dd><p>Time-to-event in years</p>
</dd>
<dt>event</dt><dd><p>Event indicator: 0 (alive), 1 (transplanted) and 2 (dead)</p>
</dd>
</dl>



<h3>Source</h3>

<p>pbc2 joineRML
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbc2)
</code></pre>

<hr>
<h2 id='plot.DynForest'>Plot function in DynForest</h2><span id='topic+plot.DynForest'></span><span id='topic+plot.DynForestVarDepth'></span><span id='topic+plot.DynForestVIMP'></span><span id='topic+plot.DynForestgVIMP'></span><span id='topic+plot.DynForestPred'></span>

<h3>Description</h3>

<p>This function displays a plot of CIF for a given node and tree (for class <code>DynForest</code>), the most predictive variables with the minimal depth (for class <code>DynForestVarDepth</code>), the variable importance (for class <code>DynForestVIMP</code>) or the grouped variable importance (for class <code>DynForestgVIMP</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DynForest'
plot(x, tree = NULL, nodes = NULL, id = NULL, max_tree = NULL, ...)

## S3 method for class 'DynForestVarDepth'
plot(x, plot_level = c("predictor", "feature"), ...)

## S3 method for class 'DynForestVIMP'
plot(x, PCT = FALSE, ordering = TRUE, ...)

## S3 method for class 'DynForestgVIMP'
plot(x, PCT = FALSE, ...)

## S3 method for class 'DynForestPred'
plot(x, id = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.DynForest_+3A_x">x</code></td>
<td>
<p>Object inheriting from classes <code>DynForest</code>, <code>DynForestVarDepth</code>, <code>DynForestVIMP</code> or <code>DynForestgVIMP</code>, to respectively plot the CIF, the minimal depth, the variable importance or grouped variable importance.</p>
</td></tr>
<tr><td><code id="plot.DynForest_+3A_tree">tree</code></td>
<td>
<p>For <code>DynForest</code> class, integer indicating the tree identifier</p>
</td></tr>
<tr><td><code id="plot.DynForest_+3A_nodes">nodes</code></td>
<td>
<p>For <code>DynForest</code> class, identifiers for the selected nodes</p>
</td></tr>
<tr><td><code id="plot.DynForest_+3A_id">id</code></td>
<td>
<p>For <code>DynForest</code> and <code>DynForestPred</code> classes, identifier for a given subject</p>
</td></tr>
<tr><td><code id="plot.DynForest_+3A_max_tree">max_tree</code></td>
<td>
<p>For <code>DynForest</code> class, integer indicating the number of tree to display while using <code>id</code> argument</p>
</td></tr>
<tr><td><code id="plot.DynForest_+3A_...">...</code></td>
<td>
<p>Optional parameters to be passed to the low level function</p>
</td></tr>
<tr><td><code id="plot.DynForest_+3A_plot_level">plot_level</code></td>
<td>
<p>For <code>DynForestVarDepth</code> class, compute the statistic at predictor (<code>plot_level</code>=&quot;predictor&quot;) or feature (<code>plot_level</code>=&quot;feature&quot;) level</p>
</td></tr>
<tr><td><code id="plot.DynForest_+3A_pct">PCT</code></td>
<td>
<p>For <code>DynForestVIMP</code> or <code>DynForestgVIMP</code> class, display VIMP statistic in percentage. Default value is FALSE.</p>
</td></tr>
<tr><td><code id="plot.DynForest_+3A_ordering">ordering</code></td>
<td>
<p>For <code>DynForestVIMP</code> class, order predictors according to VIMP value. Default value is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>plot()</code> function displays: </p>

<table>
<tr>
 <td style="text-align: left;">
With <code>DynForestVarDepth</code> </td><td style="text-align: left;"> the minimal depth for each predictor/feature </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
With <code>DynForestVIMP</code> </td><td style="text-align: left;"> the VIMP for each predictor </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
With <code>DynForestgVIMP</code> </td><td style="text-align: left;"> the grouped-VIMP for each given group </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><code><a href="#topic+DynForest">DynForest</a> <a href="#topic+var_depth">var_depth</a> <a href="#topic+compute_VIMP">compute_VIMP</a> <a href="#topic+compute_gVIMP">compute_gVIMP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc2)

# Get Gaussian distribution for longitudinal predictors
pbc2$serBilir &lt;- log(pbc2$serBilir)
pbc2$SGOT &lt;- log(pbc2$SGOT)
pbc2$albumin &lt;- log(pbc2$albumin)
pbc2$alkaline &lt;- log(pbc2$alkaline)

# Sample 100 subjects
set.seed(1234)
id &lt;- unique(pbc2$id)
id_sample &lt;- sample(id, 100)
id_row &lt;- which(pbc2$id%in%id_sample)

pbc2_train &lt;- pbc2[id_row,]

timeData_train &lt;- pbc2_train[,c("id","time",
                                "serBilir","SGOT",
                                "albumin","alkaline")]

# Create object with longitudinal association for each predictor
timeVarModel &lt;- list(serBilir = list(fixed = serBilir ~ time,
                                     random = ~ time),
                     SGOT = list(fixed = SGOT ~ time + I(time^2),
                                 random = ~ time + I(time^2)),
                     albumin = list(fixed = albumin ~ time,
                                    random = ~ time),
                     alkaline = list(fixed = alkaline ~ time,
                                     random = ~ time))

# Build fixed data
fixedData_train &lt;- unique(pbc2_train[,c("id","age","drug","sex")])

# Build outcome data
Y &lt;- list(type = "surv",
          Y = unique(pbc2_train[,c("id","years","event")]))

# Run DynForest function
res_dyn &lt;- DynForest(timeData = timeData_train, fixedData = fixedData_train,
                     timeVar = "time", idVar = "id",
                     timeVarModel = timeVarModel, Y = Y,
                     ntree = 50, nodesize = 5, minsplit = 5,
                     cause = 2, ncores = 2, seed = 1234)

# Plot estimated CIF at nodes 17 and 32
plot(x = res_dyn, tree = 1, nodes = c(17,32))

# Run var_depth function
res_varDepth &lt;- var_depth(res_dyn)

# Plot minimal depth
plot(x = res_varDepth, plot_level = "feature")

# Compute VIMP statistic
res_dyn_VIMP &lt;- compute_VIMP(DynForest_obj = res_dyn, ncores = 2)

# Plot VIMP
plot(x = res_dyn_VIMP, PCT = TRUE)

# Compute gVIMP statistic
res_dyn_gVIMP &lt;- compute_gVIMP(DynForest_obj = res_dyn,
                               group = list(group1 = c("serBilir","SGOT"),
                                            group2 = c("albumin","alkaline")),
                               ncores = 2)

# Plot gVIMP
plot(x = res_dyn_gVIMP, PCT = TRUE)

# Sample 5 subjects to predict the event
set.seed(123)
id_pred &lt;- sample(id, 5)

# Create predictors objects
pbc2_pred &lt;- pbc2[which(pbc2$id%in%id_pred),]
timeData_pred &lt;- pbc2_pred[,c("id", "time", "serBilir", "SGOT", "albumin", "alkaline")]
fixedData_pred &lt;- unique(pbc2_pred[,c("id","age","drug","sex")])

# Predict the CIF function for the new subjects with landmark time at 4 years
pred_dyn &lt;- predict(object = res_dyn,
                    timeData = timeData_pred, fixedData = fixedData_pred,
                    idVar = "id", timeVar = "time",
                    t0 = 4)

# Plot predicted CIF for subjects 26 and 110
plot(x = pred_dyn, id = c(26, 110))



</code></pre>

<hr>
<h2 id='pred.MMT'>Predict the leaf by dropping down the subject in the tree</h2><span id='topic+pred.MMT'></span>

<h3>Description</h3>

<p>Predict the leaf by dropping down the subject in the tree
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pred.MMT(
  tree,
  Longitudinal = NULL,
  Numeric = NULL,
  Factor = NULL,
  timeVar = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pred.MMT_+3A_tree">tree</code></td>
<td>
<p>Tree object resulting from <code>Rtmax_surv</code> function</p>
</td></tr>
<tr><td><code id="pred.MMT_+3A_longitudinal">Longitudinal</code></td>
<td>
<p>A list of longitudinal predictors which should contain: <code>X</code> a dataframe with one row for repeated measurement and as many columns as markers; <code>id</code> is the vector of the identifiers for the repeated measurements contained in <code>X</code>; <code>time</code> is the vector of the measurement times contained in <code>X</code>.</p>
</td></tr>
<tr><td><code id="pred.MMT_+3A_numeric">Numeric</code></td>
<td>
<p>A list of numeric predictors which should contain: <code>X</code> a dataframe with as many columns as numeric predictors; <code>id</code> is the vector of the identifiers for each individual.</p>
</td></tr>
<tr><td><code id="pred.MMT_+3A_factor">Factor</code></td>
<td>
<p>A list of factor predictors which should contain: <code>X</code> a dataframe with as many columns as factor predictors; <code>id</code> is the vector of the identifiers for each individual.</p>
</td></tr>
<tr><td><code id="pred.MMT_+3A_timevar">timeVar</code></td>
<td>
<p>A character indicating the name of time variable</p>
</td></tr>
</table>

<hr>
<h2 id='predict.DynForest'>Prediction using dynamic random forests</h2><span id='topic+predict.DynForest'></span>

<h3>Description</h3>

<p>Prediction using dynamic random forests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DynForest'
predict(
  object,
  timeData = NULL,
  fixedData = NULL,
  idVar,
  timeVar,
  t0 = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.DynForest_+3A_object">object</code></td>
<td>
<p><code>DynForest</code> object containing the dynamic random forest used on train data</p>
</td></tr>
<tr><td><code id="predict.DynForest_+3A_timedata">timeData</code></td>
<td>
<p>A data.frame containing the id and time measurements variables and the time-dependent predictors.</p>
</td></tr>
<tr><td><code id="predict.DynForest_+3A_fixeddata">fixedData</code></td>
<td>
<p>A data.frame containing the id variable and the time-fixed predictors. Non-continuous variables should be characterized as factor.</p>
</td></tr>
<tr><td><code id="predict.DynForest_+3A_idvar">idVar</code></td>
<td>
<p>A character indicating the name of variable to identify the subjects</p>
</td></tr>
<tr><td><code id="predict.DynForest_+3A_timevar">timeVar</code></td>
<td>
<p>A character indicating the name of time variable</p>
</td></tr>
<tr><td><code id="predict.DynForest_+3A_t0">t0</code></td>
<td>
<p>Landmark time</p>
</td></tr>
<tr><td><code id="predict.DynForest_+3A_...">...</code></td>
<td>
<p>Optional parameters to be passed to the low level function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the outcome of interest for the new subjects: matrix of probability of event of interest in survival mode, average value in regression mode and most likely value in classification mode
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc2)

# Get Gaussian distribution for longitudinal predictors
pbc2$serBilir &lt;- log(pbc2$serBilir)
pbc2$SGOT &lt;- log(pbc2$SGOT)
pbc2$albumin &lt;- log(pbc2$albumin)
pbc2$alkaline &lt;- log(pbc2$alkaline)

# Sample 100 subjects
set.seed(1234)
id &lt;- unique(pbc2$id)
id_sample &lt;- sample(id, 100)
id_row &lt;- which(pbc2$id%in%id_sample)

pbc2_train &lt;- pbc2[id_row,]

timeData_train &lt;- pbc2_train[,c("id","time",
                                "serBilir","SGOT",
                                "albumin","alkaline")]

# Create object with longitudinal association for each predictor
timeVarModel &lt;- list(serBilir = list(fixed = serBilir ~ time,
                                     random = ~ time),
                     SGOT = list(fixed = SGOT ~ time + I(time^2),
                                 random = ~ time + I(time^2)),
                     albumin = list(fixed = albumin ~ time,
                                    random = ~ time),
                     alkaline = list(fixed = alkaline ~ time,
                                     random = ~ time))

# Build fixed data
fixedData_train &lt;- unique(pbc2_train[,c("id","age","drug","sex")])

# Build outcome data
Y &lt;- list(type = "surv",
          Y = unique(pbc2_train[,c("id","years","event")]))

# Run DynForest function
res_dyn &lt;- DynForest(timeData = timeData_train, fixedData = fixedData_train,
                     timeVar = "time", idVar = "id",
                     timeVarModel = timeVarModel, Y = Y,
                     ntree = 50, nodesize = 5, minsplit = 5,
                     cause = 2, ncores = 2, seed = 1234)

# Sample 5 subjects to predict the event
set.seed(123)
id_pred &lt;- sample(id, 5)

# Create predictors objects
pbc2_pred &lt;- pbc2[which(pbc2$id%in%id_pred),]
timeData_pred &lt;- pbc2_pred[,c("id", "time", "serBilir", "SGOT", "albumin", "alkaline")]
fixedData_pred &lt;- unique(pbc2_pred[,c("id","age","drug","sex")])

# Predict the CIF function for the new subjects with landmark time at 4 years
pred_dyn &lt;- predict(object = res_dyn,
                    timeData = timeData_pred, fixedData = fixedData_pred,
                    idVar = "id", timeVar = "time",
                    t0 = 4)

</code></pre>

<hr>
<h2 id='predRE'>Function to compute individual random effects using hlme output parameters</h2><span id='topic+predRE'></span>

<h3>Description</h3>

<p>Function to compute individual random effects using hlme output parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predRE(model, formula, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predRE_+3A_model">model</code></td>
<td>
<p>output object from hlme function</p>
</td></tr>
<tr><td><code id="predRE_+3A_formula">formula</code></td>
<td>
<p>list of formula for fixed and random part</p>
</td></tr>
<tr><td><code id="predRE_+3A_data">data</code></td>
<td>
<p>data to compute random effect</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table of random-effects in column by subjects in row
</p>

<hr>
<h2 id='print.DynForest'>Print function</h2><span id='topic+print.DynForest'></span><span id='topic+print.DynForestVIMP'></span><span id='topic+print.DynForestgVIMP'></span><span id='topic+print.DynForestVarDepth'></span><span id='topic+print.DynForestOOB'></span><span id='topic+print.DynForestPred'></span>

<h3>Description</h3>

<p>This function displays a brief summary regarding the trees (for class <code>DynForest</code>), a data frame with variable importance (for class <code>DynForestVIMP</code>) or the grouped variable importance (for class <code>DynForestgVIMP</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DynForest'
print(x, ...)

## S3 method for class 'DynForestVIMP'
print(x, ...)

## S3 method for class 'DynForestgVIMP'
print(x, ...)

## S3 method for class 'DynForestVarDepth'
print(x, ...)

## S3 method for class 'DynForestOOB'
print(x, ...)

## S3 method for class 'DynForestPred'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.DynForest_+3A_x">x</code></td>
<td>
<p>Object inheriting from classes <code>DynForest</code>, <code>DynForestVIMP</code> or <code>DynForestgVIMP</code>.</p>
</td></tr>
<tr><td><code id="print.DynForest_+3A_...">...</code></td>
<td>
<p>Optional parameters to be passed to the low level function</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+DynForest">DynForest</a> <a href="#topic+var_depth">var_depth</a> <a href="#topic+compute_VIMP">compute_VIMP</a> <a href="#topic+compute_gVIMP">compute_gVIMP</a> <a href="#topic+compute_OOBerror">compute_OOBerror</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc2)

# Get Gaussian distribution for longitudinal predictors
pbc2$serBilir &lt;- log(pbc2$serBilir)
pbc2$SGOT &lt;- log(pbc2$SGOT)
pbc2$albumin &lt;- log(pbc2$albumin)
pbc2$alkaline &lt;- log(pbc2$alkaline)

# Sample 100 subjects
set.seed(1234)
id &lt;- unique(pbc2$id)
id_sample &lt;- sample(id, 100)
id_row &lt;- which(pbc2$id%in%id_sample)

pbc2_train &lt;- pbc2[id_row,]

timeData_train &lt;- pbc2_train[,c("id","time",
                                "serBilir","SGOT",
                                "albumin","alkaline")]

# Create object with longitudinal association for each predictor
timeVarModel &lt;- list(serBilir = list(fixed = serBilir ~ time,
                                     random = ~ time),
                     SGOT = list(fixed = SGOT ~ time + I(time^2),
                                 random = ~ time + I(time^2)),
                     albumin = list(fixed = albumin ~ time,
                                    random = ~ time),
                     alkaline = list(fixed = alkaline ~ time,
                                     random = ~ time))

# Build fixed data
fixedData_train &lt;- unique(pbc2_train[,c("id","age","drug","sex")])

# Build outcome data
Y &lt;- list(type = "surv",
          Y = unique(pbc2_train[,c("id","years","event")]))

# Run DynForest function
res_dyn &lt;- DynForest(timeData = timeData_train, fixedData = fixedData_train,
                     timeVar = "time", idVar = "id",
                     timeVarModel = timeVarModel, Y = Y,
                     ntree = 50, nodesize = 5, minsplit = 5,
                     cause = 2, ncores = 2, seed = 1234)

# Print function
print(res_dyn)

# Compute VIMP statistic
res_dyn_VIMP &lt;- compute_VIMP(DynForest_obj = res_dyn, ncores = 2, seed = 1234)

# Print function
print(res_dyn_VIMP)

# Compute gVIMP statistic
res_dyn_gVIMP &lt;- compute_gVIMP(DynForest_obj = res_dyn,
                               group = list(group1 = c("serBilir","SGOT"),
                                            group2 = c("albumin","alkaline")),
                               ncores = 2, seed = 1234)

# Print function
print(res_dyn_gVIMP)

# Run var_depth function
res_varDepth &lt;- var_depth(res_dyn)

# Print function
print(res_varDepth)



</code></pre>

<hr>
<h2 id='rf_shape_para'>Paralleled random survival Forest using multivariate longitudinal endogenous covariates</h2><span id='topic+rf_shape_para'></span>

<h3>Description</h3>

<p>Paralleled random survival Forest using multivariate longitudinal endogenous covariates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rf_shape_para(
  Longitudinal = NULL,
  Numeric = NULL,
  Factor = NULL,
  timeVar = NULL,
  Y,
  mtry,
  ntree,
  ncores,
  nsplit_option = "quantile",
  nodesize = 1,
  minsplit = 2,
  cause = 1,
  seed = 1234,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rf_shape_para_+3A_longitudinal">Longitudinal</code></td>
<td>
<p>A list of longitudinal predictors which should contain: <code>X</code> a dataframe with one row for repeated measurement and as many columns as markers; <code>id</code> is the vector of the identifiers for the repeated measurements contained in <code>X</code>; <code>time</code> is the vector of the measurement times contained in <code>X</code>.</p>
</td></tr>
<tr><td><code id="rf_shape_para_+3A_numeric">Numeric</code></td>
<td>
<p>A list of numeric predictors which should contain: <code>X</code> a dataframe with as many columns as numeric predictors; <code>id</code> is the vector of the identifiers for each individual.</p>
</td></tr>
<tr><td><code id="rf_shape_para_+3A_factor">Factor</code></td>
<td>
<p>A list of categorical predictors which should contain: <code>X</code> a dataframe with as many columns as categorical predictors; <code>id</code> is the vector of the identifiers for each individual.</p>
</td></tr>
<tr><td><code id="rf_shape_para_+3A_timevar">timeVar</code></td>
<td>
<p>A character indicating the name of time variable</p>
</td></tr>
<tr><td><code id="rf_shape_para_+3A_y">Y</code></td>
<td>
<p>A list of output which should contain: <code>type</code> defines the nature of the output, can be &quot;<code>surv</code>&quot;, &quot;<code>numeric</code>&quot; or &quot;<code>factor</code>&quot;; <code>Y</code> is the outcome variable; <code>id</code> is the vector of the identifiers for each individuals, they should be the same as the identifiers of the inputs.</p>
</td></tr>
<tr><td><code id="rf_shape_para_+3A_mtry">mtry</code></td>
<td>
<p>Number of candidate variables randomly drawn at each node of the trees. This parameter should be tuned by minimizing the OOB error. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rf_shape_para_+3A_ntree">ntree</code></td>
<td>
<p>Number of trees to grow. Default value set to 200.</p>
</td></tr>
<tr><td><code id="rf_shape_para_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used to grow trees in parallel. Default value is the number of cores of the computer-1.</p>
</td></tr>
<tr><td><code id="rf_shape_para_+3A_nsplit_option">nsplit_option</code></td>
<td>
<p>A character indicates how the values are chosen to build the two groups for the splitting rule (only for continuous predictors). Values are chosen using deciles (<code>nsplit_option</code>=&quot;quantile&quot;) or randomly (<code>nsplit_option</code>=&quot;sample&quot;). Default value is &quot;quantile&quot;.</p>
</td></tr>
<tr><td><code id="rf_shape_para_+3A_nodesize">nodesize</code></td>
<td>
<p>Minimal number of subjects required in both child nodes to split. Cannot be smaller than 1.</p>
</td></tr>
<tr><td><code id="rf_shape_para_+3A_minsplit">minsplit</code></td>
<td>
<p>(Only with survival outcome) Minimal number of events required to split the node. Cannot be smaller than 2.</p>
</td></tr>
<tr><td><code id="rf_shape_para_+3A_cause">cause</code></td>
<td>
<p>(Only with competing events) Number indicates the event of interest.</p>
</td></tr>
<tr><td><code id="rf_shape_para_+3A_seed">seed</code></td>
<td>
<p>Seed to replicate results</p>
</td></tr>
<tr><td><code id="rf_shape_para_+3A_verbose">verbose</code></td>
<td>
<p>A logical controlling the function progress. Default is <code>TRUE</code></p>
</td></tr>
</table>

<hr>
<h2 id='summary.DynForest'>Display the summary of DynForest</h2><span id='topic+summary.DynForest'></span><span id='topic+summary.DynForestOOB'></span>

<h3>Description</h3>

<p>Display the summary of DynForest
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'DynForest'
summary(object, ...)

## S3 method for class 'DynForestOOB'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.DynForest_+3A_object">object</code></td>
<td>
<p><code>DynForest</code> or <code>DynForestOOB</code> object</p>
</td></tr>
<tr><td><code id="summary.DynForest_+3A_...">...</code></td>
<td>
<p>Optional parameters to be passed to the low level function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return some information about the random forest
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc2)

# Get Gaussian distribution for longitudinal predictors
pbc2$serBilir &lt;- log(pbc2$serBilir)
pbc2$SGOT &lt;- log(pbc2$SGOT)
pbc2$albumin &lt;- log(pbc2$albumin)
pbc2$alkaline &lt;- log(pbc2$alkaline)

# Sample 100 subjects
set.seed(1234)
id &lt;- unique(pbc2$id)
id_sample &lt;- sample(id, 100)
id_row &lt;- which(pbc2$id%in%id_sample)

pbc2_train &lt;- pbc2[id_row,]

timeData_train &lt;- pbc2_train[,c("id","time",
                                "serBilir","SGOT",
                                "albumin","alkaline")]

# Create object with longitudinal association for each predictor
timeVarModel &lt;- list(serBilir = list(fixed = serBilir ~ time,
                                     random = ~ time),
                     SGOT = list(fixed = SGOT ~ time + I(time^2),
                                 random = ~ time + I(time^2)),
                     albumin = list(fixed = albumin ~ time,
                                    random = ~ time),
                     alkaline = list(fixed = alkaline ~ time,
                                     random = ~ time))

# Build fixed data
fixedData_train &lt;- unique(pbc2_train[,c("id","age","drug","sex")])

# Build outcome data
Y &lt;- list(type = "surv",
          Y = unique(pbc2_train[,c("id","years","event")]))

# Run DynForest function
res_dyn &lt;- DynForest(timeData = timeData_train, fixedData = fixedData_train,
                     timeVar = "time", idVar = "id",
                     timeVarModel = timeVarModel, Y = Y,
                     ntree = 50, nodesize = 5, minsplit = 5,
                     cause = 2, ncores = 2, seed = 1234)

# Compute OOB error
res_dyn_OOB &lt;- compute_OOBerror(DynForest_obj = res_dyn, ncores = 2)

# DynForest summary
summary(object = res_dyn_OOB)

</code></pre>

<hr>
<h2 id='var_depth'>Extract characteristics from the trees building process</h2><span id='topic+var_depth'></span>

<h3>Description</h3>

<p>Extract characteristics from the trees building process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_depth(DynForest_obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_depth_+3A_dynforest_obj">DynForest_obj</code></td>
<td>
<p><code>DynForest</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>var_depth function return a list with the following elements:</p>

<table>
<tr>
 <td style="text-align: left;">
<code>min_depth</code> </td><td style="text-align: left;"> A table providing for each feature in row: the average depth and the rank </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>var_node_depth</code> </td><td style="text-align: left;"> A table providing for each tree in column the minimal depth for each feature in row. NA indicates that the feature was not used for the corresponding tree </td>
</tr>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>var_count</code> </td><td style="text-align: left;"> A table providing for each tree in column the number of times where the feature is used (in row). 0 value indicates that the feature was not used for the corresponding tree </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>See Also</h3>

<p><code><a href="#topic+DynForest">DynForest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pbc2)

# Get Gaussian distribution for longitudinal predictors
pbc2$serBilir &lt;- log(pbc2$serBilir)
pbc2$SGOT &lt;- log(pbc2$SGOT)
pbc2$albumin &lt;- log(pbc2$albumin)
pbc2$alkaline &lt;- log(pbc2$alkaline)

# Sample 100 subjects
set.seed(1234)
id &lt;- unique(pbc2$id)
id_sample &lt;- sample(id, 100)
id_row &lt;- which(pbc2$id%in%id_sample)

pbc2_train &lt;- pbc2[id_row,]

timeData_train &lt;- pbc2_train[,c("id","time",
                                "serBilir","SGOT",
                                "albumin","alkaline")]

# Create object with longitudinal association for each predictor
timeVarModel &lt;- list(serBilir = list(fixed = serBilir ~ time,
                                     random = ~ time),
                     SGOT = list(fixed = SGOT ~ time + I(time^2),
                                 random = ~ time + I(time^2)),
                     albumin = list(fixed = albumin ~ time,
                                    random = ~ time),
                     alkaline = list(fixed = alkaline ~ time,
                                     random = ~ time))

# Build fixed data
fixedData_train &lt;- unique(pbc2_train[,c("id","age","drug","sex")])

# Build outcome data
Y &lt;- list(type = "surv",
          Y = unique(pbc2_train[,c("id","years","event")]))

# Run DynForest function
res_dyn &lt;- DynForest(timeData = timeData_train, fixedData = fixedData_train,
                     timeVar = "time", idVar = "id",
                     timeVarModel = timeVarModel, Y = Y,
                     ntree = 50, nodesize = 5, minsplit = 5,
                     cause = 2, ncores = 2, seed = 1234)

# Run var_depth function
res_varDepth &lt;- var_depth(res_dyn)

</code></pre>

<hr>
<h2 id='var_split_factor'>Split function to build the two daughter nodes from factor predictor</h2><span id='topic+var_split_factor'></span>

<h3>Description</h3>

<p>Split function to build the two daughter nodes from factor predictor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_split_factor(X, Y, cause = 1, nodesize = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_split_factor_+3A_x">X</code></td>
<td>
<p>Input data</p>
</td></tr>
<tr><td><code id="var_split_factor_+3A_y">Y</code></td>
<td>
<p>Outcome data</p>
</td></tr>
<tr><td><code id="var_split_factor_+3A_cause">cause</code></td>
<td>
<p>(Only with competing events) Number indicates the event of interest.</p>
</td></tr>
<tr><td><code id="var_split_factor_+3A_nodesize">nodesize</code></td>
<td>
<p>Minimal number of subjects required in both child nodes to split. Cannot be smaller than 1.</p>
</td></tr>
</table>

<hr>
<h2 id='var_split_long'>Split function to build the two daughter nodes from longitudinal predictors</h2><span id='topic+var_split_long'></span>

<h3>Description</h3>

<p>Split function to build the two daughter nodes from longitudinal predictors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_split_long(
  X,
  Y,
  timeVar = NULL,
  nsplit_option = "quantile",
  cause = 1,
  nodesize = 1,
  init = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_split_long_+3A_x">X</code></td>
<td>
<p>Input data</p>
</td></tr>
<tr><td><code id="var_split_long_+3A_y">Y</code></td>
<td>
<p>Outcome data</p>
</td></tr>
<tr><td><code id="var_split_long_+3A_timevar">timeVar</code></td>
<td>
<p>A character indicating the name of time variable</p>
</td></tr>
<tr><td><code id="var_split_long_+3A_nsplit_option">nsplit_option</code></td>
<td>
<p>A character indicates how the values are chosen to build the two groups for the splitting rule (only for continuous predictors). Values are chosen using deciles (<code>nsplit_option</code>=&quot;quantile&quot;) or randomly (<code>nsplit_option</code>=&quot;sample&quot;). Default value is &quot;quantile&quot;.</p>
</td></tr>
<tr><td><code id="var_split_long_+3A_cause">cause</code></td>
<td>
<p>(Only with competing events) Number indicates the event of interest.</p>
</td></tr>
<tr><td><code id="var_split_long_+3A_nodesize">nodesize</code></td>
<td>
<p>Minimal number of subjects required in both child nodes to split. Cannot be smaller than 1.</p>
</td></tr>
<tr><td><code id="var_split_long_+3A_init">init</code></td>
<td>
<p>(Optional) Initial values for linear mixed models</p>
</td></tr>
</table>

<hr>
<h2 id='var_split_num'>Split function to build the two daughter nodes from numeric predictors</h2><span id='topic+var_split_num'></span>

<h3>Description</h3>

<p>Split function to build the two daughter nodes from numeric predictors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_split_num(X, Y, nsplit_option = "quantile", cause = 1, nodesize = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var_split_num_+3A_x">X</code></td>
<td>
<p>Input data</p>
</td></tr>
<tr><td><code id="var_split_num_+3A_y">Y</code></td>
<td>
<p>Outcome data</p>
</td></tr>
<tr><td><code id="var_split_num_+3A_nsplit_option">nsplit_option</code></td>
<td>
<p>A character indicates how the values are chosen to build the two groups for the splitting rule (only for continuous predictors). Values are chosen using deciles (<code>nsplit_option</code>=&quot;quantile&quot;) or randomly (<code>nsplit_option</code>=&quot;sample&quot;). Default value is &quot;quantile&quot;.</p>
</td></tr>
<tr><td><code id="var_split_num_+3A_cause">cause</code></td>
<td>
<p>(Only with competing events) Number indicates the event of interest.</p>
</td></tr>
<tr><td><code id="var_split_num_+3A_nodesize">nodesize</code></td>
<td>
<p>Minimal number of subjects required in both child nodes to split. Cannot be smaller than 1.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
