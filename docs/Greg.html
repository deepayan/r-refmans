<!DOCTYPE html><html lang="en"><head><title>Help for package Greg</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Greg}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Greg-package'><p>Regression Helper Functions</p></a></li>
<li><a href='#addNonlinearity'><p>Add a nonlinear function to the model</p></a></li>
<li><a href='#bread.ols'><p>Getting the bread for the <code>vcovHC</code></p></a></li>
<li><a href='#caDescribeOpts'><p>A function for gathering all the description options</p></a></li>
<li><a href='#confint_robust'><p>The confint function adapted for vcovHC</p></a></li>
<li><a href='#confint.ols'><p>A <code>confint</code> function for the <code>ols</code></p></a></li>
<li><a href='#estfun.ols'><p>Fix for the Extract Empirical Estimating Functions</p></a></li>
<li><a href='#forestplotCombineRegrObj'><p>Compares different scores in different regression objects.</p></a></li>
<li><a href='#forestplotRegrObj'><p>Forest plot for multiple models</p></a></li>
<li><a href='#getCrudeAndAdjustedModelData'><p>This function helps with printing regression models</p></a></li>
<li><a href='#getModelData4Forestplot'><p>Get model data</p></a></li>
<li><a href='#hatvalues.ols'><p>Get the hat matrix for the OLS</p></a></li>
<li><a href='#isFitCoxPH'><p>Functions for checking regression type</p></a></li>
<li><a href='#model.matrix.ols'><p>A fix for the <code>model.matrix</code></p></a></li>
<li><a href='#plotHR'><p>Plot a spline in a Cox regression model</p></a></li>
<li><a href='#prCaAddRefAndStat'><p>Add reference according to the model</p></a></li>
<li><a href='#prCaAddReference'><p>Adds a reference to value matrix</p></a></li>
<li><a href='#prCaAddUserReferences'><p>Adds references</p></a></li>
<li><a href='#prCaDefaultGetCoefAndCI'><p>Get the confidence intervals</p></a></li>
<li><a href='#prCaGetImputationCols'><p>Function for retrieving the imputation arguments</p></a></li>
<li><a href='#prCaGetRowname'><p>Gets the labelled rowname if it exists</p></a></li>
<li><a href='#prCaGetVnStats'><p>Gets the variable stats</p></a></li>
<li><a href='#prCaPrepareCrudeAndAdjusted'><p>Prettify the text</p></a></li>
<li><a href='#prCaReorder'><p>Reorder according to the requested variables</p></a></li>
<li><a href='#prCaReorderReferenceDescribe'><p>Adds the ordering, references, and descriptions</p></a></li>
<li><a href='#prCaSelectAndOrderVars'><p>Re-order variables</p></a></li>
<li><a href='#prCaSetRownames'><p>Sets the rownames of the reordered_groups</p></a></li>
<li><a href='#prClearPCAclass'><p>Removes the printCrudeAndAdjusted class from arguments</p></a></li>
<li><a href='#prConvertShowMissing'><p>A function for converting a useNA variable</p></a></li>
<li><a href='#prEnvModelCall'><p>Runs an <code>fastDoCall()</code> within the environment of the model</p></a></li>
<li><a href='#prExtractOutcomeFromModel'><p>Get model outcome</p></a></li>
<li><a href='#prFindRownameMatches'><p>Looks for unique rowname match without grep</p></a></li>
<li><a href='#prGetModelData'><p>Get model data.frame</p></a></li>
<li><a href='#prGetModelVariables'><p>Get the models variables</p></a></li>
<li><a href='#prGetStatistics'><p>Get statistics according to the type</p></a></li>
<li><a href='#printCrudeAndAdjustedModel'><p>Output crude and adjusted model data</p></a></li>
<li><a href='#prMapVariable2Name'><p>A function that tries to resolve what variable corresponds to what row</p></a></li>
<li><a href='#prNlChooseDf'><p>Chooses the degrees of freedom for the non-linearity</p></a></li>
<li><a href='#prPhConfIntPlot'><p>Plots the confidence intervals</p></a></li>
<li><a href='#prPhDensityPlot'><p>Plot a density on the datapoints</p></a></li>
<li><a href='#prPhEstimate'><p>Gets the non-linear function's estimate</p></a></li>
<li><a href='#prPhNewData'><p>A function for retrieving new_data argument for predict</p></a></li>
<li><a href='#prPhRugPlot'><p>Plot a rug on the datapoints</p></a></li>
<li><a href='#prPrintCAstring'><p>Prep for printing</p></a></li>
<li><a href='#robcov_alt'><p>Robust covariance matrix based upon the 'sandwich'-package</p></a></li>
<li><a href='#simpleRmsAnova'><p>A simpler latex output of the latex.anova.rms</p></a></li>
<li><a href='#tidy.rms'><p>Tidy a(n) rms model object</p></a></li>
<li><a href='#timeSplitter'><p>A function for splitting a time according to time periods</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Title:</td>
<td>Regression Helper Functions</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Max Gordon &lt;max@gforge.se&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods for manipulating regression models and for describing these in a style adapted for medical journals.
  Contains functions for generating an HTML table with crude and adjusted estimates, plotting hazard ratio, plotting model
  estimates and confidence intervals using forest plots, extending this to comparing multiple models in a single forest plots.
  In addition to the descriptive methods, there are functions for the robust covariance matrix provided by the 'sandwich'
  package, a function for adding non-linearities to a model, and a wrapper around the 'Epi' package's Lexis() functions for
  time-splitting a dataset when modeling non-proportional hazards in Cox regressions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://gforge.se">http://gforge.se</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gforge/Greg/issues">https://github.com/gforge/Greg/issues</a></td>
</tr>
<tr>
<td>Biarch:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>broom, Epi, dplyr, glue, graphics, grDevices, htmlTable (&ge;
2.0.0), Hmisc, knitr, methods, nlme, purrr, rlang, rms,
sandwich, stats, stringr, tibble, tidyr, tidyselect, utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>Gmisc (&ge; 1.0.3), forestplot, R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>boot, testthat, cmprsk, survival, ggplot2, parallel,
rmarkdown, rmeta, tidyverse</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-29 11:04:04 UTC; max</td>
</tr>
<tr>
<td>Author:</td>
<td>Max Gordon [aut, cre],
  Reinhard Seifert [aut] (Author of original plotHR)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-29 13:30:21 UTC</td>
</tr>
</table>
<hr>
<h2 id='Greg-package'>Regression Helper Functions</h2><span id='topic+Greg-package'></span>

<h3>Description</h3>

<p>This R-package provides functions that primarily aimed at helping 
you work with regression models. While much of the data presented by the
standard regression output is useful and important - there is often a
need for further simplification prior to publication. The methods implemented
in this package are inspired by some of the top journals such as NEJM, BMJ,
and other medical journals as this is my research field.
</p>


<h3>Output functions</h3>

<p>The package has function that automatically prints the crude unadjusted estimates
of a function next to the adjusted estimates, a common practice for medical
publications. 
</p>
<p>The forestplot wrappers allows for easily displaying regression
estimates, often convenient for models with a large number of variables. 
There is also functionality that can help you comparing different models,
e.g. subsets of patients or compare different regression types.
</p>


<h3>Time-splitter</h3>

<p>When working with Cox regressions the proportional hazards can sometimes be violated.
As the <code>tt()</code> approach doesn't lend itself that well to big datasets I often
rely on time-splitting the dataset and then using the start time as an interaction
term. See the function <code><a href="#topic+timeSplitter">timeSplitter</a>()</code> and the associated 
<code>vignette("timeSplitter")</code>.
</p>


<h3>Other regression functions</h3>

<p>In addition to these funciton the package has some extentions to linear regression
where it extends the functionality by allowing for robust covariance matrices. 
by integrating the <span class="pkg">'sandwich'</span>-package for <code>rms::<a href="rms.html#topic+ols">ols</a>()</code>.
</p>


<h3>Important notice</h3>

<p>This package has an extensive test-set for ensuring that everything behaves as expected.
Despite this I strongly urge you to check that the values make sense. I commonly use
the regression methods available in the <span class="pkg">'rms'</span>-package and in the <span class="pkg">'stats'</span>-package.
In addition I use the <code><a href="survival.html#topic+coxph">coxph</a>()</code> in many of my analyses and should
also be safe. Please send me a notice if you are using the package with some other 
regression models, especially if you have some tests verifying the functionality.
</p>


<h3>Author(s)</h3>

<p>Max Gordon
</p>

<hr>
<h2 id='addNonlinearity'>Add a nonlinear function to the model</h2><span id='topic+addNonlinearity'></span><span id='topic+addNonlinearity.negbin'></span>

<h3>Description</h3>

<p>This function takes a model and adds a non-linear function if
the likelihood-ratio supports this (via the
<code><a href="stats.html#topic+anova">anova</a>(..., test = "chisq")</code> test for <span class="pkg">stats</span>
while for <span class="pkg">rms</span> you need to use the <code><a href="rms.html#topic+rms.trans">rcs</a>()</code> spline
that is automatically evaluated for non-linearity).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNonlinearity(
  model,
  variable,
  spline_fn,
  flex_param = 2:7,
  min_fn = AIC,
  sig_level = 0.05,
  verbal = FALSE,
  workers,
  ...
)

## S3 method for class 'negbin'
addNonlinearity(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addNonlinearity_+3A_model">model</code></td>
<td>
<p>The model that is to be evaluated and adapted for non-linearity</p>
</td></tr>
<tr><td><code id="addNonlinearity_+3A_variable">variable</code></td>
<td>
<p>The name of the parameter that is to be tested for non-linearity.
<em>Note</em> that the variable should be included plain (i.e. as a linear variable)
form in the model.</p>
</td></tr>
<tr><td><code id="addNonlinearity_+3A_spline_fn">spline_fn</code></td>
<td>
<p>Either a string or a function that is to be used
for testing alternative non-linearity models</p>
</td></tr>
<tr><td><code id="addNonlinearity_+3A_flex_param">flex_param</code></td>
<td>
<p>A <code>vector</code> with values that are to be tested as the
default second parameter for the non-linearity function that you want to
evaluate. This defaults to 2:7, for the <code><a href="splines.html#topic+ns">ns</a>()</code> it tests
the degrees of freedom ranging between 2 and 7.</p>
</td></tr>
<tr><td><code id="addNonlinearity_+3A_min_fn">min_fn</code></td>
<td>
<p>This is the function that we want to minimized if the variable supports
the non-linearity assumption. E.g. <code><a href="stats.html#topic+AIC">BIC</a>()</code> or
<code><a href="stats.html#topic+AIC">AIC</a></code>, note that the <code><a href="stats.html#topic+AIC">BIC</a>()</code> will in the majority of cases
support a lower complexity than the <code><a href="stats.html#topic+AIC">AIC</a>()</code>.</p>
</td></tr>
<tr><td><code id="addNonlinearity_+3A_sig_level">sig_level</code></td>
<td>
<p>The significance level for which the non-linearity is deemed
as significant, defaults to 0.05.</p>
</td></tr>
<tr><td><code id="addNonlinearity_+3A_verbal">verbal</code></td>
<td>
<p>Set this to <code>TRUE</code> if you want print statements with the
anova test and the chosen knots.</p>
</td></tr>
<tr><td><code id="addNonlinearity_+3A_workers">workers</code></td>
<td>
<p>The function tries to run everything in parallel. Under some
circumstances you may want to restrict the number of parallel threads to less
than the default <code><a href="parallel.html#topic+detectCores">detectCores</a>() - 1</code>, e.g. you may run out of memory
then you can provide this parameter. If you do not want to use parallel then
simply set workers to <code>FALSE</code>. The cluster created using <code><a href="parallel.html#topic+makeCluster">makeCluster</a>()</code>
function.</p>
</td></tr>
<tr><td><code id="addNonlinearity_+3A_...">...</code></td>
<td>
<p>Passed onto internal <code><a href="#topic+prNlChooseDf">prNlChooseDf</a>()</code> function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(Greg)
data("melanoma", package = "boot", envir = environment())

library(dplyr)
melanoma &lt;- mutate(melanoma, 
                   status = factor(status,
                                   levels = 1:3,
                                   labels = c("Died from melanoma", 
                                              "Alive", 
                                              "Died from other causes")),
                   ulcer = factor(ulcer,
                                  levels = 0:1,
                                  labels = c("Absent", "Present")),
                   time = time/365.25, # All variables should be in the same time unit
                   sex = factor(sex,
                                levels = 0:1,
                                labels = c("Female", "Male")))

library(survival)
model &lt;- coxph(Surv(time, status == "Died from melanoma") ~ sex + age,
  data = melanoma
)

nl_model &lt;- addNonlinearity(model, "age",
  spline_fn = "pspline",
  verbal = TRUE,
  workers = FALSE
)
# Note that there is no support for nonlinearity in this case
</code></pre>

<hr>
<h2 id='bread.ols'>Getting the bread for the <code>vcovHC</code></h2><span id='topic+bread.ols'></span>

<h3>Description</h3>

<p>The original <code>bread.lm</code> uses the <code>summary.lm</code> function
it seems like a quick fix and I've therefore created
the original bread definition: $(X'X)^-1$
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ols'
bread(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bread.ols_+3A_x">x</code></td>
<td>
<p>The <code>ols</code> model fit</p>
</td></tr>
<tr><td><code id="bread.ols_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix The bread for the sandwich <code>vcovHC</code> function
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some data
n &lt;- 500
x1 &lt;- runif(n) * 2
x2 &lt;- runif(n)
y &lt;- x1^3 + x2 + rnorm(n)

library(rms)
library(sandwich)
dd &lt;- datadist(x1, x2, y)
org.op &lt;- options(datadist = "dd")

# Main function
f &lt;- ols(y ~ rcs(x1, 3) + x2)

# Check the bread
bread(f)
# Check the HC-matrix
vcovHC(f, type = "HC4m")
# Adjust the model so that it uses the HC4m variance
f_rob &lt;- robcov_alt(f, type = "HC4m")
# Get the new HC4m-matrix
# - this function just returns the f_rob$var matrix
vcov(f_rob)
# Now check the confidence interval for the function
confint(f_rob)

options(org.op)
</code></pre>

<hr>
<h2 id='caDescribeOpts'>A function for gathering all the description options</h2><span id='topic+caDescribeOpts'></span>

<h3>Description</h3>

<p>Since there are so many different description options
for the <code><a href="#topic+printCrudeAndAdjustedModel">printCrudeAndAdjustedModel</a>()</code> function they
have been gathered into a list. This function is simply a
helper in order to generate a valid list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>caDescribeOpts(
  show_tot_perc = FALSE,
  numb_first = TRUE,
  continuous_fn = describeMean,
  prop_fn = describeFactors,
  factor_fn = describeFactors,
  digits = 1,
  colnames = c("Total", "Event")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="caDescribeOpts_+3A_show_tot_perc">show_tot_perc</code></td>
<td>
<p>Show percentages for the total column</p>
</td></tr>
<tr><td><code id="caDescribeOpts_+3A_numb_first">numb_first</code></td>
<td>
<p>Whether to show the number before the percentages</p>
</td></tr>
<tr><td><code id="caDescribeOpts_+3A_continuous_fn">continuous_fn</code></td>
<td>
<p>Stat function used for the descriptive statistics,
defaults to <code>describeMean()</code></p>
</td></tr>
<tr><td><code id="caDescribeOpts_+3A_prop_fn">prop_fn</code></td>
<td>
<p>Stat function used for the descriptive statistics,
defaults to <code>describeFactors()</code> since there has to be a reference
in the current setup.</p>
</td></tr>
<tr><td><code id="caDescribeOpts_+3A_factor_fn">factor_fn</code></td>
<td>
<p>Stat function used for the descriptive statistics,
defaults to <code>describeFactors()</code></p>
</td></tr>
<tr><td><code id="caDescribeOpts_+3A_digits">digits</code></td>
<td>
<p>Number of digits to use in the descriptive columns.
Defaults to the general digits if not specified.</p>
</td></tr>
<tr><td><code id="caDescribeOpts_+3A_colnames">colnames</code></td>
<td>
<p>The names of the two descriptive columns. By default
Total and Event.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> Returns a list with all the options
</p>

<hr>
<h2 id='confint_robust'>The confint function adapted for vcovHC</h2><span id='topic+confint_robust'></span>

<h3>Description</h3>

<p>The confint.lm uses the t-distribution as the default
confidence interval estimator. When there is reason to believe that
the normal distribution is violated an alternative approach using
the <code><a href="sandwich.html#topic+vcovHC">vcovHC</a>()</code> may be more suitable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>confint_robust(
  object,
  parm,
  level = 0.95,
  HC_type = "HC3",
  t_distribution = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint_robust_+3A_object">object</code></td>
<td>
<p>The regression model object, either an ols or lm object</p>
</td></tr>
<tr><td><code id="confint_robust_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given
confidence intervals, either a vector of numbers or a vector of
names.  If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint_robust_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="confint_robust_+3A_hc_type">HC_type</code></td>
<td>
<p>See options for <code><a href="sandwich.html#topic+vcovHC">vcovHC</a>()</code></p>
</td></tr>
<tr><td><code id="confint_robust_+3A_t_distribution">t_distribution</code></td>
<td>
<p>A boolean for if the t-distribution should be used
or not. Defaults to FALSE. According to Cribari-Nieto and Lima's study from
2009 this should not be the case.</p>
</td></tr>
<tr><td><code id="confint_robust_+3A_...">...</code></td>
<td>
<p>Additional parameters that are passed on to
<code><a href="sandwich.html#topic+vcovHC">vcovHC</a>()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> A matrix (or vector) with columns giving lower and
upper confidence limits for each parameter. These will be labelled as
(1-level)/2 and 1 - (1-level)/2 in 
</p>


<h3>References</h3>


<p>F. Cribari-Neto and M. da G. A. Lima,
&quot;Heteroskedasticity-consistent interval estimators&quot;,
Journal of Statistical Computation and Simulation,
vol. 79, no. 6, pp. 787-803, 2009 (<a href="https://doi.org/10.1080/00949650801935327">doi:10.1080/00949650801935327</a>)

</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 50
x &lt;- runif(n)
y &lt;- x + rnorm(n)

fit &lt;- lm(y~x)
library("sandwich")
confint_robust(fit, HC_type = "HC4m")
</code></pre>

<hr>
<h2 id='confint.ols'>A <code>confint</code> function for the <code>ols</code></h2><span id='topic+confint.ols'></span>

<h3>Description</h3>

<p>This function checks that there is a <code>df.residual</code>
before running the <code>qt()</code>. If not found it then
defaults to the <code>qnorm()</code> function. Otherwise it is
a copy of the <code><a href="stats.html#topic+confint">confint</a>()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ols'
confint(object, parm, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="confint.ols_+3A_object">object</code></td>
<td>
<p>a fitted <code><a href="rms.html#topic+ols">ols</a></code>-model object.</p>
</td></tr>
<tr><td><code id="confint.ols_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters
are to be given confidence intervals, either a vector
of numbers or a vector of names. If missing, all
parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.ols_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="confint.ols_+3A_...">...</code></td>
<td>
<p>additional argument(s) for methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix (or vector) with columns giving lower
and upper confidence limits for each parameter. These
will be labelled as (1-level)/2 and 1 - (1-level)/2
in 
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some data
n &lt;- 500
x1 &lt;- runif(n) * 2
x2 &lt;- runif(n)
y &lt;- x1^3 + x2 + rnorm(n)

library(rms)
library(sandwich)
dd &lt;- datadist(x1, x2, y)
org.op &lt;- options(datadist = "dd")

# Main function
f &lt;- ols(y ~ rcs(x1, 3) + x2)

# Check the bread
bread(f)
# Check the HC-matrix
vcovHC(f, type = "HC4m")
# Adjust the model so that it uses the HC4m variance
f_rob &lt;- robcov_alt(f, type = "HC4m")
# Get the new HC4m-matrix
# - this function just returns the f_rob$var matrix
vcov(f_rob)
# Now check the confidence interval for the function
confint(f_rob)

options(org.op)
</code></pre>

<hr>
<h2 id='estfun.ols'>Fix for the Extract Empirical Estimating Functions</h2><span id='topic+estfun.ols'></span>

<h3>Description</h3>

<p>As missing data is handled a little different for the <code><a href="rms.html#topic+ols">ols</a></code>
than for the <code><a href="stats.html#topic+lm">lm</a></code> we need to change the 
<code><a href="sandwich.html#topic+estfun">estfun</a></code> to work with the <code><a href="rms.html#topic+ols">ols</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ols'
estfun(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estfun.ols_+3A_x">x</code></td>
<td>
<p>A fitted <code><a href="rms.html#topic+ols">ols</a></code> model object.</p>
</td></tr>
<tr><td><code id="estfun.ols_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>I have never worked with weights and this should probably be checked
as this just uses the original <code>estfun.lm</code> as a template.
</p>


<h3>Value</h3>

<p>matrix A matrix containing the empirical estimating functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some data
n &lt;- 500
x1 &lt;- runif(n) * 2
x2 &lt;- runif(n)
y &lt;- x1^3 + x2 + rnorm(n)

library(rms)
library(sandwich)
dd &lt;- datadist(x1, x2, y)
org.op &lt;- options(datadist = "dd")

# Main function
f &lt;- ols(y ~ rcs(x1, 3) + x2)

# Check the bread
bread(f)
# Check the HC-matrix
vcovHC(f, type = "HC4m")
# Adjust the model so that it uses the HC4m variance
f_rob &lt;- robcov_alt(f, type = "HC4m")
# Get the new HC4m-matrix
# - this function just returns the f_rob$var matrix
vcov(f_rob)
# Now check the confidence interval for the function
confint(f_rob)

options(org.op)
</code></pre>

<hr>
<h2 id='forestplotCombineRegrObj'>Compares different scores in different regression objects.</h2><span id='topic+forestplotCombineRegrObj'></span>

<h3>Description</h3>

<p>Creates a composite from different regression objects into
one forestplot where you can choose the variables of interest
to get an overview and easier comparison.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forestplotCombineRegrObj(
  regr.obj,
  variablesOfInterest.regexp = NULL,
  estimate.txt = NULL,
  add_first_as_ref = FALSE,
  ref_txt = "ref.",
  digits = 1,
  post_process_data = function(x) x,
  is.summary = NULL,
  xlab = NULL,
  zero = NULL,
  xlog = NULL,
  exp = xlog,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forestplotCombineRegrObj_+3A_regr.obj">regr.obj</code></td>
<td>
<p>A list with all the fits that have variables that are to
be identified through the regular expression</p>
</td></tr>
<tr><td><code id="forestplotCombineRegrObj_+3A_variablesofinterest.regexp">variablesOfInterest.regexp</code></td>
<td>
<p>A regular expression identifying the variables
that are of interest of comparing. For instance it can be &quot;(score|index|measure)&quot;
that finds scores in different models that should be compared.</p>
</td></tr>
<tr><td><code id="forestplotCombineRegrObj_+3A_estimate.txt">estimate.txt</code></td>
<td>
<p>The text of the estimate, usually HR for hazard ratio, OR for
odds ratio</p>
</td></tr>
<tr><td><code id="forestplotCombineRegrObj_+3A_add_first_as_ref">add_first_as_ref</code></td>
<td>
<p>If you want that the first variable should be reference for
that group of variables. The ref is a variable with the estimate 1 or 0 depending
if exp() and the confidence interval 0.</p>
</td></tr>
<tr><td><code id="forestplotCombineRegrObj_+3A_ref_txt">ref_txt</code></td>
<td>
<p>Text instead of estimate number</p>
</td></tr>
<tr><td><code id="forestplotCombineRegrObj_+3A_digits">digits</code></td>
<td>
<p>Number of digits to use for the estimate output</p>
</td></tr>
<tr><td><code id="forestplotCombineRegrObj_+3A_post_process_data">post_process_data</code></td>
<td>
<p>A function that takes the data frame just prior to calling 'forestplot'
and allows you to manipulate it. Primarily used for changing the 'column_label'
that has the names shown in the final plot.</p>
</td></tr>
<tr><td><code id="forestplotCombineRegrObj_+3A_is.summary">is.summary</code></td>
<td>
<p>A vector indicating by <code>TRUE</code>/<code>FALSE</code> if
the value is a summary value which means that it will have a different
font-style</p>
</td></tr>
<tr><td><code id="forestplotCombineRegrObj_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="forestplotCombineRegrObj_+3A_zero">zero</code></td>
<td>
<p>Indicates what is zero effect. For survival/logistic fits the zero is
1 while in most other cases it's 0.</p>
</td></tr>
<tr><td><code id="forestplotCombineRegrObj_+3A_xlog">xlog</code></td>
<td>
<p>If TRUE, x-axis tick marks are to follow a logarithmic scale, e.g. for
logistic regression (OR), survival estimates (HR), Poisson regression etc.
<em>Note:</em> This is an intentional break with the original <code>forestplot</code>
function as I've found that exponentiated ticks/clips/zero effect are more
difficult to for non-statisticians and there are sometimes issues with rounding
the tick marks properly.</p>
</td></tr>
<tr><td><code id="forestplotCombineRegrObj_+3A_exp">exp</code></td>
<td>
<p>Report in exponential form. Default true since the function was built for
use with survival models.</p>
</td></tr>
<tr><td><code id="forestplotCombineRegrObj_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="forestplot.html#topic+forestplot">forestplot</a>()</code></p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other forestplot wrappers: 
<code><a href="#topic+forestplotRegrObj">forestplotRegrObj</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>org.par &lt;- par("ask" = TRUE)

# simulated data to test
library(tidyverse)
set.seed(10)
cov &lt;- tibble(ftime = rexp(200),
              fstatus = sample(0:1, 200, replace = TRUE),
              x1 = runif(200),
              x2 = runif(200),
              x3 = runif(200)) |&gt; 
  # Add some column labels
  Gmisc::set_column_labels(x1 = "First variable",
                           x2 = "Second variable")

library(rms)
ddist &lt;- datadist(cov)
options(datadist = "ddist")

fit1 &lt;- cph(Surv(ftime, fstatus) ~ x1 + x2, data = cov)
fit2 &lt;- cph(Surv(ftime, fstatus) ~ x1 + x3, data = cov)

list(`First model` = fit1, 
     `Second model` = fit2) |&gt; 
  forestplotCombineRegrObj(variablesOfInterest.regexp = "(x2|x3)") |&gt; 
  fp_set_style(lines = "steelblue",
               box = "darkblue")

# How to add expressions to the plot label
list(fit1, fit2) |&gt; 
  forestplotCombineRegrObj(variablesOfInterest.regexp = "(x2|x3)",
                           reference.names = c("First model", "Second model"),
                           post_process_data = \(data) {
                             data$column_label[4] &lt;- c(rlang::expr(expression(Fever &gt;= 38.5)))
                             return(data)
                           })

par(org.par)
</code></pre>

<hr>
<h2 id='forestplotRegrObj'>Forest plot for multiple models</h2><span id='topic+forestplotRegrObj'></span><span id='topic+forestplotRegrObj.default'></span><span id='topic+forestplotRegrObj.coxph'></span><span id='topic+forestplotRegrObj.lrm'></span><span id='topic+forestplotRegrObj.lm'></span><span id='topic+forestplotRegrObj.glm'></span><span id='topic+forestplotRegrObj.list'></span><span id='topic+fpBoxSize'></span>

<h3>Description</h3>

<p>Plot different model fits with similar variables in order to
compare the model's estimates and confidence intervals. Each
model is represented by a separate line on top of eachother
and are therefore ideal for comparing different models. This
extra appealing when you have lots of variables included in
the models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forestplotRegrObj(
  regr.obj,
  postprocess_estimates.fn = function(x) x,
  rowname = "Variable",
  ci.txt = "CI",
  ci.glue = "{lower} to {higher}",
  digits = 1,
  get_box_size = fpBoxSize,
  ...
)

## Default S3 method:
forestplotRegrObj(
  regr.obj,
  postprocess_estimates.fn = function(x) x,
  rowname = "Variable",
  ci.txt = "CI",
  ci.glue = "{lower} to {higher}",
  digits = 1,
  get_box_size = fpBoxSize,
  ...
)

## S3 method for class 'coxph'
forestplotRegrObj(
  regr.obj,
  postprocess_estimates.fn = function(x) x,
  rowname = "Variable",
  ci.txt = "CI",
  ci.glue = "{lower} to {higher}",
  digits = 1,
  get_box_size = fpBoxSize,
  xlab = "Hazard Ratio",
  estimate.txt = "HR",
  xlog = TRUE,
  zero = 1,
  exp = TRUE,
  ...
)

## S3 method for class 'lrm'
forestplotRegrObj(
  regr.obj,
  postprocess_estimates.fn = function(x) x,
  rowname = "Variable",
  ci.txt = "CI",
  ci.glue = "{lower} to {higher}",
  digits = 1,
  get_box_size = fpBoxSize,
  xlab = "Odds ratio",
  estimate.txt = "HR",
  xlog = TRUE,
  zero = 1,
  exp = TRUE,
  ...
)

## S3 method for class 'lm'
forestplotRegrObj(
  regr.obj,
  postprocess_estimates.fn = function(x) x,
  rowname = "Variable",
  ci.txt = "CI",
  ci.glue = "{lower} to {higher}",
  digits = 1,
  get_box_size = fpBoxSize,
  xlab = "Effect",
  estimate.txt = "Coef",
  xlog = FALSE,
  zero = 0,
  exp = FALSE,
  ...
)

## S3 method for class 'glm'
forestplotRegrObj(
  regr.obj,
  postprocess_estimates.fn = function(x) x,
  rowname = "Variable",
  ci.txt = "CI",
  ci.glue = "{lower} to {higher}",
  digits = 1,
  get_box_size = fpBoxSize,
  xlab = NULL,
  xlog = NULL,
  zero = NULL,
  estimate.txt = NULL,
  exp = NULL,
  ...
)

## S3 method for class 'list'
forestplotRegrObj(
  regr.obj,
  postprocess_estimates.fn = function(x) x,
  rowname = "Variable",
  ci.txt = "CI",
  ci.glue = "{lower} to {higher}",
  digits = 1,
  get_box_size = fpBoxSize,
  xlab = NULL,
  xlog = NULL,
  zero = NULL,
  estimate.txt = NULL,
  exp = NULL,
  ...
)

fpBoxSize(p_values, variable_count, boxsize, significant = 0.05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forestplotRegrObj_+3A_regr.obj">regr.obj</code></td>
<td>
<p>A regression model object. It should be of coxph, crr or glm class.
Warning: The glm is not fully tested.</p>
</td></tr>
<tr><td><code id="forestplotRegrObj_+3A_postprocess_estimates.fn">postprocess_estimates.fn</code></td>
<td>
<p>A function that takes the regression outputs and returns
the same data with modifications. The input columns are:
</p>
<p>* 'Rowname'
* 'Coef'
* 'Lower'
* 'Upper'
* 'Sort'</p>
</td></tr>
<tr><td><code id="forestplotRegrObj_+3A_rowname">rowname</code></td>
<td>
<p>The name of the variables</p>
</td></tr>
<tr><td><code id="forestplotRegrObj_+3A_ci.txt">ci.txt</code></td>
<td>
<p>The text above the confidence interval, defaults to '&quot;CI&quot;'</p>
</td></tr>
<tr><td><code id="forestplotRegrObj_+3A_ci.glue">ci.glue</code></td>
<td>
<p>The string used for [glue::glue()] the 'lower' and 'higher'
confidence intervals together.</p>
</td></tr>
<tr><td><code id="forestplotRegrObj_+3A_digits">digits</code></td>
<td>
<p>The number of digits to round presented values to</p>
</td></tr>
<tr><td><code id="forestplotRegrObj_+3A_get_box_size">get_box_size</code></td>
<td>
<p>A function for extracting the box sizes</p>
</td></tr>
<tr><td><code id="forestplotRegrObj_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="forestplot.html#topic+forestplot">forestplot</a>()</code></p>
</td></tr>
<tr><td><code id="forestplotRegrObj_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label</p>
</td></tr>
<tr><td><code id="forestplotRegrObj_+3A_estimate.txt">estimate.txt</code></td>
<td>
<p>The text above the estimate, e.g. Est, HR</p>
</td></tr>
<tr><td><code id="forestplotRegrObj_+3A_xlog">xlog</code></td>
<td>
<p>If TRUE, x-axis tick marks are to follow a logarithmic scale, e.g. for
logistic regression (OR), survival estimates (HR), Poisson regression etc.
<em>Note:</em> This is an intentional break with the original <code>forestplot</code>
function as I've found that exponentiated ticks/clips/zero effect are more
difficult to for non-statisticians and there are sometimes issues with rounding
the tick marks properly.</p>
</td></tr>
<tr><td><code id="forestplotRegrObj_+3A_zero">zero</code></td>
<td>
<p>Indicates what is zero effect. For survival/logistic fits the zero is
1 while in most other cases it's 0.</p>
</td></tr>
<tr><td><code id="forestplotRegrObj_+3A_exp">exp</code></td>
<td>
<p>Report in exponential form. Default true since the function was built for
use with survival models.</p>
</td></tr>
<tr><td><code id="forestplotRegrObj_+3A_p_values">p_values</code></td>
<td>
<p>The p-values that will work as the foundation for the box size</p>
</td></tr>
<tr><td><code id="forestplotRegrObj_+3A_variable_count">variable_count</code></td>
<td>
<p>The number of variables</p>
</td></tr>
<tr><td><code id="forestplotRegrObj_+3A_boxsize">boxsize</code></td>
<td>
<p>The default box size</p>
</td></tr>
<tr><td><code id="forestplotRegrObj_+3A_significant">significant</code></td>
<td>
<p>Level of significance .05</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Other forestplot wrappers: 
<code><a href="#topic+forestplotCombineRegrObj">forestplotCombineRegrObj</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>org.par &lt;- par("ask" = TRUE)

library(tidyverse)
# simulated data to test
set.seed(102)
cov &lt;- tibble(ftime = rexp(200)) |&gt; 
  mutate(x1 = runif(n()),
         x2 = runif(n()),
         x3 = runif(n()),
         fstatus1 = if_else(x1 * 1 + 
                              x2 * 0.2 + 
                              x3 * 0.5 + 
                              runif(n()) * 0.5 &gt; 1, 
                            1, 0),
         fstatus2 = if_else(x1 * 0.2 + 
                              x2 * 0.5 + 
                              x3 * 0.1 + 
                              runif(n()) * 2 &gt; 1, 
                            1, 0)) |&gt; 
  # Add some column labels
  Gmisc::set_column_labels(x1 = "First variable",
                           x2 = "Second variable")

library(rms)
dd &lt;- datadist(cov)
options(datadist = "dd")

fit1 &lt;- cph(Surv(ftime, fstatus1 == 1) ~ x1 + x2 + x3, data = cov)

fit1 |&gt; 
  forestplotRegrObj() |&gt; 
  fp_set_zebra_style("#f0f0f0")

fit2 &lt;- update(fit1, Surv(ftime, fstatus2 == 1) ~ .)
list("Frist model" = fit1, "Second model"  = fit2) |&gt; 
  forestplotRegrObj(legend_args = fpLegend(title = "Type of regression"),
                    postprocess_estimates.fn = function(x) {
                      x |&gt; 
                        filter(str_detect(column_term, "(x2|x3)"))
                    }) |&gt; 
  fp_set_style(box = rep(c("darkblue", "darkred"), each = 3))


par(org.par)
</code></pre>

<hr>
<h2 id='getCrudeAndAdjustedModelData'>This function helps with printing regression models</h2><span id='topic+getCrudeAndAdjustedModelData'></span><span id='topic++5B.getCrudeAndAdjustedModelData'></span>

<h3>Description</h3>

<p>This function is used for getting the adjusted and unadjusted values
for a regression model. It takes a full model and walks through each
variable, removes in the regression all variables except one then
reruns that variable to get the unadjusted value. This functions not
intended for direct use, it's better to use <code><a href="#topic+printCrudeAndAdjustedModel">printCrudeAndAdjustedModel</a>()</code>
that utilizes this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCrudeAndAdjustedModelData(
  model,
  level = 0.95,
  remove_interaction_vars = TRUE,
  remove_strata = FALSE,
  remove_cluster = FALSE,
  var_select,
  ...
)

## S3 method for class 'getCrudeAndAdjustedModelData'
x[i, j, ...]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getCrudeAndAdjustedModelData_+3A_model">model</code></td>
<td>
<p>The regression model</p>
</td></tr>
<tr><td><code id="getCrudeAndAdjustedModelData_+3A_level">level</code></td>
<td>
<p>The confidence interval level</p>
</td></tr>
<tr><td><code id="getCrudeAndAdjustedModelData_+3A_remove_interaction_vars">remove_interaction_vars</code></td>
<td>
<p>Removes the interaction terms as they in
the raw state are difficult to understand</p>
</td></tr>
<tr><td><code id="getCrudeAndAdjustedModelData_+3A_remove_strata">remove_strata</code></td>
<td>
<p>Strata should most likely not be removed in the crude
version. If you want to force the removal of stratas you can specify the
<code>remove_strata = TRUE</code></p>
</td></tr>
<tr><td><code id="getCrudeAndAdjustedModelData_+3A_remove_cluster">remove_cluster</code></td>
<td>
<p>Cluster information should most likely also retain
just as the <code>remove_strata</code> option. Clusters are sometimes used in
cox regression models, <code><a href="survival.html#topic+cluster">cluster</a>()</code></p>
</td></tr>
<tr><td><code id="getCrudeAndAdjustedModelData_+3A_var_select">var_select</code></td>
<td>
<p>A vector with regular expressions for choosing what variables
to return (the same format as for the <code>order</code> argument in
<code><a href="#topic+printCrudeAndAdjustedModel">printCrudeAndAdjustedModel</a>()</code> call). It can be useful when working with
large datasets only to report a subsection of all tested variables. This
makes the function both run faster and the data presentation more concise.</p>
</td></tr>
<tr><td><code id="getCrudeAndAdjustedModelData_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function saves a lot of time creating tables since it compiles a fully
unadjusted list of all your used covariates.
</p>
<p>If the model is an exponential poisson/logit/cox regression model then it automatically
reports the exp() values instead of the original values
</p>
<p>The function skips by default all spline variables since this becomes very complicated
and there is no simple </p>
<p style="text-align: center;"><code class="reqn">\beta</code>
</p>
<p> to display. For the same reason it skips
any interaction variables since it's probably better to display these as a contrast table.
</p>
<p>Note that the rms regression has a separate function that uses the <code>rms:::summaryrms</code> function
that returns a matrix that is then pruned.
</p>


<h3>Value</h3>

<p>Returns a matrix with the columns:
<code>c("Crude", "2.5 %", "97.5 %", "Adjusted", "2.5 %", "97.5 %")</code>.
The row order is not changed from the original model. The percentages can vary depending
on the set level.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+printCrudeAndAdjustedModel">printCrudeAndAdjustedModel</a>()</code>
</p>
<p>Other crudeAndAdjusted functions: 
<code><a href="#topic+printCrudeAndAdjustedModel">printCrudeAndAdjustedModel</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulated data to use
set.seed(10)
ds &lt;- data.frame(
  ftime = rexp(200),
  fstatus = sample(0:1, 200, replace = TRUE),
  x1 = runif(200),
  x2 = runif(200),
  x3 = runif(200),
  x4 = runif(200),
  x5 = runif(200)
)

library(rms)
dd &lt;- datadist(ds)
options(datadist = "dd")

s &lt;- Surv(ds$ftime, ds$fstatus == 1)
fit &lt;- cph(s ~ x1 + x2 + x3, data = ds)

data_matrix &lt;- getCrudeAndAdjustedModelData(fit)

print(data_matrix)

# If we have interaction then those variable are not
# reported
fit &lt;- cph(s ~ x1 + x2 + x3 + x4 * x5, data = ds)
data_matrix &lt;- getCrudeAndAdjustedModelData(fit)

print(data_matrix)
</code></pre>

<hr>
<h2 id='getModelData4Forestplot'>Get model data</h2><span id='topic+getModelData4Forestplot'></span>

<h3>Description</h3>

<p>A helper function for <code><a href="#topic+forestplotCombineRegrObj">forestplotCombineRegrObj</a>()</code>. Extracts
the data from the regression model fits and returns a <code>list</code>
with model data gathered by the function [broom::tidy()]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getModelData4Forestplot(
  regr.obj,
  exp = TRUE,
  variablesOfInterest.regexp = NULL,
  add_first_as_ref = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getModelData4Forestplot_+3A_regr.obj">regr.obj</code></td>
<td>
<p>A list with all the fits that have variables that are to
be identified through the regular expression</p>
</td></tr>
<tr><td><code id="getModelData4Forestplot_+3A_exp">exp</code></td>
<td>
<p>Report in exponential form. Default true since the function was built for
use with survival models.</p>
</td></tr>
<tr><td><code id="getModelData4Forestplot_+3A_variablesofinterest.regexp">variablesOfInterest.regexp</code></td>
<td>
<p>A regular expression identifying the variables
that are of interest of comparing. For instance it can be &quot;(score|index|measure)&quot;
that finds scores in different models that should be compared.</p>
</td></tr>
<tr><td><code id="getModelData4Forestplot_+3A_add_first_as_ref">add_first_as_ref</code></td>
<td>
<p>If you want that the first variable should be reference for
that group of variables. The ref is a variable with the estimate 1 or 0 depending
if exp() and the confidence interval 0.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>org.par &lt;- par("ask" = TRUE)

# simulated data to test
library(tidyverse)
set.seed(10)
cov &lt;- tibble(ftime = rexp(200),
              fstatus = sample(0:1, 200, replace = TRUE),
              x1 = runif(200),
              x2 = runif(200),
              x3 = runif(200)) |&gt; 
  # Add some column labels
  Gmisc::set_column_labels(x1 = "First variable",
                           x2 = "Second variable")

library(rms)
ddist &lt;- datadist(cov)
options(datadist = "ddist")

fit1 &lt;- cph(Surv(ftime, fstatus) ~ x1 + x2, data = cov)
fit2 &lt;- cph(Surv(ftime, fstatus) ~ x1 + x3, data = cov)

list(`First model` = fit1, 
     `Second model` = fit2) |&gt; 
  forestplotCombineRegrObj(variablesOfInterest.regexp = "(x2|x3)") |&gt; 
  fp_set_style(lines = "steelblue",
               box = "darkblue")

# How to add expressions to the plot label
list(fit1, fit2) |&gt; 
  forestplotCombineRegrObj(variablesOfInterest.regexp = "(x2|x3)",
                           reference.names = c("First model", "Second model"),
                           post_process_data = \(data) {
                             data$column_label[4] &lt;- c(rlang::expr(expression(Fever &gt;= 38.5)))
                             return(data)
                           })

par(org.par)
</code></pre>

<hr>
<h2 id='hatvalues.ols'>Get the hat matrix for the OLS</h2><span id='topic+hatvalues.ols'></span>

<h3>Description</h3>

<p>The hat matrix comes from the residual definition:
</p>
<p style="text-align: center;"><code class="reqn">\hat{\epsilon} = y-X\hat{\beta} = \{I_n-X(X'X)X'\}y = (I_n-H)y</code>
</p>

<p>where the H is called the hat matrix since </p>
<p style="text-align: center;"><code class="reqn">Hy = \hat{y}</code>
</p>
<p>. The hat
values are actually the diagonal elements of the matrix that sum up
to p (the rank of X, i.e. the number of parameters + 1). 
See <code><a href="rms.html#topic+rms-internal">ols.influence</a>()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ols'
hatvalues(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hatvalues.ols_+3A_model">model</code></td>
<td>
<p>The ols model fit</p>
</td></tr>
<tr><td><code id="hatvalues.ols_+3A_...">...</code></td>
<td>
<p>arguments passed to methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some data
n &lt;- 500
x1 &lt;- runif(n) * 2
x2 &lt;- runif(n)
y &lt;- x1^3 + x2 + rnorm(n)

library(rms)
library(sandwich)
dd &lt;- datadist(x1, x2, y)
org.op &lt;- options(datadist = "dd")

# Main function
f &lt;- ols(y ~ rcs(x1, 3) + x2)

# Check the bread
bread(f)
# Check the HC-matrix
vcovHC(f, type = "HC4m")
# Adjust the model so that it uses the HC4m variance
f_rob &lt;- robcov_alt(f, type = "HC4m")
# Get the new HC4m-matrix
# - this function just returns the f_rob$var matrix
vcov(f_rob)
# Now check the confidence interval for the function
confint(f_rob)

options(org.op)
</code></pre>

<hr>
<h2 id='isFitCoxPH'>Functions for checking regression type</h2><span id='topic+isFitCoxPH'></span><span id='topic+isFitLogit'></span>

<h3>Description</h3>

<p>The <em>isFitCoxPH</em> A simple check if object inherits either 
&quot;coxph&quot; or &quot;crr&quot; class indicating
that it is a survival function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isFitCoxPH(fit)

isFitLogit(fit)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isFitCoxPH_+3A_fit">fit</code></td>
<td>
<p>Regression object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>boolean</code> Returns <code>TRUE</code> if the object is of that type
otherwise it returns <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulated data to use
set.seed(10)
ds &lt;- data.frame(
  ftime = rexp(200),
  fstatus = sample(0:1, 200, replace = TRUE),
  x1 = runif(200),
  x2 = runif(200),
  x3 = runif(200)
)

library(survival)
library(rms)

dd &lt;- datadist(ds)
options(datadist = "dd")

s &lt;- Surv(ds$ftime, ds$fstatus == 1)
fit &lt;- cph(s ~ x1 + x2 + x3, data = ds)

if (isFitCoxPH(fit)) {
  print("Correct, the cph is of cox PH hazard type")
}

fit &lt;- coxph(s ~ x1 + x2 + x3, data = ds)
if (isFitCoxPH(fit)) {
  print("Correct, the coxph is of cox PH hazard type")
}

library(cmprsk)
set.seed(10)
ftime &lt;- rexp(200)
fstatus &lt;- sample(0:2, 200, replace = TRUE)
cov &lt;- matrix(runif(600), nrow = 200)
dimnames(cov)[[2]] &lt;- c("x1", "x2", "x3")
fit &lt;- crr(ftime, fstatus, cov)

if (isFitCoxPH(fit)) {
  print(paste(
    "Correct, the competing risk regression is",
    "considered a type of cox regression",
    "since it has a Hazard Ratio"
  ))
}
# ** Borrowed code from the lrm example **

# Fit a logistic model containing predictors age, blood.pressure, sex
# and cholesterol, with age fitted with a smooth 5-knot restricted cubic
# spline function and a different shape of the age relationship for males
# and females.

n &lt;- 1000 # define sample size
set.seed(17) # so can reproduce the results
age &lt;- rnorm(n, 50, 10)
blood.pressure &lt;- rnorm(n, 120, 15)
cholesterol &lt;- rnorm(n, 200, 25)
sex &lt;- factor(sample(c("female", "male"), n, TRUE))
label(age) &lt;- "Age" # label is in Hmisc
label(cholesterol) &lt;- "Total Cholesterol"
label(blood.pressure) &lt;- "Systolic Blood Pressure"
label(sex) &lt;- "Sex"
units(cholesterol) &lt;- "mg/dl" # uses units.default in Hmisc
units(blood.pressure) &lt;- "mmHg"

# To use prop. odds model, avoid using a huge number of intercepts by
# grouping cholesterol into 40-tiles

# Specify population model for log odds that Y = 1
L &lt;- .4 * (sex == "male") + .045 * (age - 50) +
  (log(cholesterol - 10) - 5.2) * (-2 * (sex == "female") + 2 * (sex == "male"))
# Simulate binary y to have Prob(y = 1) = 1/[1+exp(-L)]
y &lt;- ifelse(runif(n) &lt; plogis(L), 1, 0)
cholesterol[1:3] &lt;- NA # 3 missings, at random

ddist &lt;- datadist(age, blood.pressure, cholesterol, sex)
options(datadist = "ddist")

fit_lrm &lt;- lrm(y ~ blood.pressure + sex * (age + rcs(cholesterol, 4)),
  x = TRUE, y = TRUE
)

if (isFitLogit(fit_lrm) == TRUE) {
  print("Correct, the lrm is a logistic regression")
}

fit_lm &lt;- lm(blood.pressure ~ sex)
if (isFitLogit(fit_lm) == FALSE) {
  print("Correct, the lm is not a logistic regression")
}

fit_glm_logit &lt;- glm(y ~ blood.pressure + sex * (age + rcs(cholesterol, 4)),
  family = binomial()
)

if (isFitLogit(fit_glm_logit) == TRUE) {
  print("Correct, the glm with a family of binomial is a logistic regression")
}

fit_glm &lt;- glm(blood.pressure ~ sex)
if (isFitLogit(fit_glm) == FALSE) {
  print("Correct, the glm without logit as a family is not a logistic regression")
}
</code></pre>

<hr>
<h2 id='model.matrix.ols'>A fix for the <code>model.matrix</code></h2><span id='topic+model.matrix.ols'></span>

<h3>Description</h3>

<p>The <code><a href="stats.html#topic+model.matrix">model.matrix.lm</a>()</code> that the <code><a href="rms.html#topic+ols">ols</a>()</code> falls back upon
&quot;forgets&quot; the intercept value and behaves unreliable in
the <code><a href="sandwich.html#topic+vcovHC">vcovHC</a>()</code> functions. I've therefore created this sub-function
to generate the actual <code><a href="stats.html#topic+model.matrix">model.matrix</a>()</code> by just accessing the formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ols'
model.matrix(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.matrix.ols_+3A_object">object</code></td>
<td>
<p>A Model</p>
</td></tr>
<tr><td><code id="model.matrix.ols_+3A_...">...</code></td>
<td>
<p>Parameters passed on</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>

<hr>
<h2 id='plotHR'>Plot a spline in a Cox regression model</h2><span id='topic+plotHR'></span><span id='topic+print.plotHR'></span><span id='topic+plot.plotHR'></span>

<h3>Description</h3>

<p>This function is a more specialized version of the <code><a href="stats.html#topic+termplot">termplot</a>()</code> function. It
creates a plot with the spline against hazard ratio. The plot can additianally have
indicator of variable density and have multiple lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotHR(
  models,
  term = 1,
  se = TRUE,
  cntrst = ifelse(inherits(models, "rms") || inherits(models[[1]], "rms"), TRUE, FALSE),
  polygon_ci = TRUE,
  rug = "density",
  xlab = "",
  ylab = "Hazard Ratio",
  main = NULL,
  xlim = NULL,
  ylim = NULL,
  col.term = "#08519C",
  col.se = "#DEEBF7",
  col.dens = grey(0.9),
  lwd.term = 3,
  lty.term = 1,
  lwd.se = lwd.term,
  lty.se = lty.term,
  x.ticks = NULL,
  y.ticks = NULL,
  ylog = TRUE,
  cex = 1,
  y_axis_side = 2,
  plot.bty = "n",
  axes = TRUE,
  alpha = 0.05,
  ...
)

## S3 method for class 'plotHR'
print(x, ...)

## S3 method for class 'plotHR'
plot(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotHR_+3A_models">models</code></td>
<td>
<p>A single model or a list() with several models</p>
</td></tr>
<tr><td><code id="plotHR_+3A_term">term</code></td>
<td>
<p>The term of interest. Can be either the name or the number of the
covariate in the model.</p>
</td></tr>
<tr><td><code id="plotHR_+3A_se">se</code></td>
<td>
<p>Boolean if you want the confidence intervals or not</p>
</td></tr>
<tr><td><code id="plotHR_+3A_cntrst">cntrst</code></td>
<td>
<p>By contrasting values you can have the median as a reference
point making it easier to compare hazard ratios.</p>
</td></tr>
<tr><td><code id="plotHR_+3A_polygon_ci">polygon_ci</code></td>
<td>
<p>If you want a polygon as indicator for your confidence interval.
This can also be in the form of a vector if you have several models. Sometimes
you only want one model to have a polygon and the rest to be dotted lines. This
gives the reader an indication of which model is important.</p>
</td></tr>
<tr><td><code id="plotHR_+3A_rug">rug</code></td>
<td>
<p>The rug is the density of the population along the spline variable. Often
this is displayed as a jitter with bars that are thicker &amp; more common when there
are more observations in that area or a smooth density plot that looks like a
mountain. Use &quot;density&quot; for the mountain view and &quot;ticks&quot; for the jitter format.</p>
</td></tr>
<tr><td><code id="plotHR_+3A_xlab">xlab</code></td>
<td>
<p>The label of the x-axis</p>
</td></tr>
<tr><td><code id="plotHR_+3A_ylab">ylab</code></td>
<td>
<p>The label of the y-axis</p>
</td></tr>
<tr><td><code id="plotHR_+3A_main">main</code></td>
<td>
<p>The main title of the plot</p>
</td></tr>
<tr><td><code id="plotHR_+3A_xlim">xlim</code></td>
<td>
<p>A vector with 2 elements containing the upper &amp; the lower bound of the x-axis</p>
</td></tr>
<tr><td><code id="plotHR_+3A_ylim">ylim</code></td>
<td>
<p>A vector with 2 elements containing the upper &amp; the lower bound of the y-axis</p>
</td></tr>
<tr><td><code id="plotHR_+3A_col.term">col.term</code></td>
<td>
<p>The color of the estimate line. If multiple lines you can have
different colors by giving a vector.</p>
</td></tr>
<tr><td><code id="plotHR_+3A_col.se">col.se</code></td>
<td>
<p>The color of the confidence interval. If multiple lines you can have
different colors by giving a vector.</p>
</td></tr>
<tr><td><code id="plotHR_+3A_col.dens">col.dens</code></td>
<td>
<p>The color of the density plot. Ignored if you're using jitter</p>
</td></tr>
<tr><td><code id="plotHR_+3A_lwd.term">lwd.term</code></td>
<td>
<p>The width of the estimated line. If you have more than one model then
provide the function with a vector if you want to have different lines for
different width for each model.</p>
</td></tr>
<tr><td><code id="plotHR_+3A_lty.term">lty.term</code></td>
<td>
<p>The typeof the estimated line, see lty. If you have more than one model
then provide the function with a vector if you want to have different line types for
for each model.</p>
</td></tr>
<tr><td><code id="plotHR_+3A_lwd.se">lwd.se</code></td>
<td>
<p>The line width of your confidence interval. This is ignored if you're using
polygons for all the confidence intervals.</p>
</td></tr>
<tr><td><code id="plotHR_+3A_lty.se">lty.se</code></td>
<td>
<p>The line type of your confidence interval.  This is ignored if you're using
polygons for all the confidence intervals.</p>
</td></tr>
<tr><td><code id="plotHR_+3A_x.ticks">x.ticks</code></td>
<td>
<p>The ticks for the x-axis if you desire other than the default.</p>
</td></tr>
<tr><td><code id="plotHR_+3A_y.ticks">y.ticks</code></td>
<td>
<p>The ticks for the y-axis if you desire other than the default.</p>
</td></tr>
<tr><td><code id="plotHR_+3A_ylog">ylog</code></td>
<td>
<p>Show a logarithmic y-axis. Not having a logarithmic axis might seem easier
to understand but it's actually not really a good idea. The distance between HR 0.5 and
2.0 should be the same. This will only show on a logarithmic scale and therefore it is
strongly recommended to use the logarithmic scale.</p>
</td></tr>
<tr><td><code id="plotHR_+3A_cex">cex</code></td>
<td>
<p>Increase if you want larger font size in the graph.</p>
</td></tr>
<tr><td><code id="plotHR_+3A_y_axis_side">y_axis_side</code></td>
<td>
<p>The side that the y axis is to be plotted, see axis() for details</p>
</td></tr>
<tr><td><code id="plotHR_+3A_plot.bty">plot.bty</code></td>
<td>
<p>Type of box that you want. See the bty description in
graphical parameters (par). If bty is one of &quot;o&quot; (the default),
&quot;l&quot;, &quot;7&quot;, &quot;c&quot;, &quot;u&quot;, or &quot;]&quot; the resulting box resembles the corresponding
upper case letter. A value of &quot;n&quot; suppresses the box.</p>
</td></tr>
<tr><td><code id="plotHR_+3A_axes">axes</code></td>
<td>
<p>A boolean that is used to identify if axes are to be plotted</p>
</td></tr>
<tr><td><code id="plotHR_+3A_alpha">alpha</code></td>
<td>
<p>The alpha level for the confidence intervals</p>
</td></tr>
<tr><td><code id="plotHR_+3A_...">...</code></td>
<td>
<p>Any additional values that are to be sent to the plot() function</p>
</td></tr>
<tr><td><code id="plotHR_+3A_x">x</code></td>
<td>
<p>Sent the 'plotHR' object to plot</p>
</td></tr>
<tr><td><code id="plotHR_+3A_y">y</code></td>
<td>
<p>Ignored in plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function does not return anything
</p>


<h3>Multiple models in one plot</h3>

<p>The function allows for plotting multiple splines in one graph. Sometimes you
might want to show more than one spline for the same variable. This allows
you to create that comparison.
</p>
<p>Examples of a situation where I've used multiple splines in one plot is when
I want to look at a variables behavior in different time periods. This is another
way of looking at the proportional hazards assumption. The Schoenfeld residuals
can be a little tricky to look at when you have the splines.
</p>
<p>Another example of when I've used this is when I've wanted to plot adjusted and
unadjusted splines. This can very nicely demonstrate which of the variable span is
mostly confounded. For instance - younger persons may exhibit a higher risk for a
procedure but when you put in your covariates you find that the increased hazard
changes back to the basic
</p>


<h3>Author(s)</h3>

<p>Reinhard Seifert, Max Gordon
</p>


<h3>Examples</h3>

<pre><code class='language-R'>org_par &lt;- par(xaxs = "i", ask = TRUE)
library(survival)
library(rms)
library(dplyr)
library(Gmisc)

# Get data for example
n &lt;- 1000
set.seed(731)

ds &lt;- tibble(age = round(50 + 12 * rnorm(n), 1),
             smoking = sample(c("Yes", "No"), n, rep = TRUE, prob = c(.2, .75)),
             sex = sample(c("Male", "Female"), n, rep = TRUE, prob = c(.6, .4))) |&gt;
  # Build outcome
  mutate(h = .02 * exp(.02 * (age - 50) + .1 *
                         ((age - 50) / 10)^3 + .8 *
                         (sex == "Female") + 2 *
                         (smoking == "Yes")),
         cens = 15 * runif(n),
         dt = -log(runif(n)) / h,
         e = if_else(dt &lt;= cens, 1, 0),
         dt = pmin(dt, cens),
         # Add missing data to smoking
         smoking = case_when(runif(n) &lt; 0.05 ~ NA_character_,
                             TRUE ~ smoking)) |&gt;
  set_column_labels(age = "Age",
                    dt = "Follow-up time") |&gt;
  set_column_units(dt = "Year")


library(splines)
fit.coxph &lt;- coxph(Surv(dt, e) ~ bs(age, 3) + sex + smoking, data = ds)

plotHR(fit.coxph, term = "age", plot.bty = "o", xlim = c(30, 70), xlab = "Age")

dd &lt;- datadist(ds)
options(datadist = "dd")
fit.cph &lt;- cph(Surv(dt, e) ~ rcs(age, 4) + sex + smoking, data = ds, x = TRUE, y = TRUE)

plotHR(fit.cph,
       term = 1,
       plot.bty = "L",
       xlim = c(30, 70),
       ylim = 2^c(-3, 3),
       xlab = "Age"
)

plotHR(fit.cph,
       term = "age",
       plot.bty = "l",
       xlim = c(30, 70),
       ylog = FALSE,
       rug = "ticks",
       xlab = "Age"
)

unadjusted_fit &lt;- cph(Surv(dt, e) ~ rcs(age, 4), data = ds, x = TRUE, y = TRUE)
plotHR(list(fit.cph, unadjusted_fit),
       term = "age",
       xlab = "Age",
       polygon_ci = c(TRUE, FALSE),
       col.term = c("#08519C", "#77777799"),
       col.se = c("#DEEBF7BB", grey(0.6)),
       lty.term = c(1, 2),
       plot.bty = "l", xlim = c(30, 70)
)
par(org_par)
</code></pre>

<hr>
<h2 id='prCaAddRefAndStat'>Add reference according to the model</h2><span id='topic+prCaAddRefAndStat'></span>

<h3>Description</h3>

<p>This is of course for factored variables and not in general.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prCaAddRefAndStat(
  model,
  var_order,
  add_references,
  add_references_pos,
  reference_zero_effect,
  values,
  ds,
  desc_column,
  desc_args,
  use_labels
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prCaAddRefAndStat_+3A_model">model</code></td>
<td>
<p>A regression model fit, i.e. the returned object from your
regression function, or the output from <code><a href="#topic+getCrudeAndAdjustedModelData">getCrudeAndAdjustedModelData</a>()</code></p>
</td></tr>
<tr><td><code id="prCaAddRefAndStat_+3A_var_order">var_order</code></td>
<td>
<p>The output from the <code><a href="#topic+prMapVariable2Name">prMapVariable2Name</a></code></p>
</td></tr>
<tr><td><code id="prCaAddRefAndStat_+3A_add_references">add_references</code></td>
<td>
<p>True if it should use the data set to look for
references, otherwise supply the function with a vector with names.
Sometimes you want to indicate the reference row for each group.
This needs to be just as many as the  groups as the order identified.
Use NA if you don't want to have a reference for that particular group.</p>
</td></tr>
<tr><td><code id="prCaAddRefAndStat_+3A_add_references_pos">add_references_pos</code></td>
<td>
<p>The position where a reference should be added.
Sometimes you don't want the reference to be at the top, for instance
if you have age groups then you may have &lt; 25, 25-39, 40-55, &gt; 55 and
you have the reference to be 25-39 then you should set the reference
list for <code>age_groups</code> as <code>add_references_pos = list(age_groups = 2)</code>
so that you have the second group as the position for the reference.</p>
</td></tr>
<tr><td><code id="prCaAddRefAndStat_+3A_reference_zero_effect">reference_zero_effect</code></td>
<td>
<p>Used with references, tells if zero effect
is in exponential form, i.e. <code>exp(0) = 1</code>, or in regular format,
i.e. <code>0 = 0</code> (can be set to any value)</p>
</td></tr>
<tr><td><code id="prCaAddRefAndStat_+3A_values">values</code></td>
<td>
<p>The values that are to be outputted</p>
</td></tr>
<tr><td><code id="prCaAddRefAndStat_+3A_ds">ds</code></td>
<td>
<p>The dataset</p>
</td></tr>
<tr><td><code id="prCaAddRefAndStat_+3A_desc_column">desc_column</code></td>
<td>
<p>Add descriptive column to the crude and adjusted table</p>
</td></tr>
<tr><td><code id="prCaAddRefAndStat_+3A_desc_args">desc_args</code></td>
<td>
<p>The description arguments that are to be used for the
the description columns. The options/arguments should be generated by the
<code><a href="#topic+caDescribeOpts">caDescribeOpts</a></code> function.</p>
</td></tr>
<tr><td><code id="prCaAddRefAndStat_+3A_use_labels">use_labels</code></td>
<td>
<p>If the rowname.fn function doesn't change the name then
the label should be used instead of the name, that is if there is a
label and it isn't a factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code>
</p>


<h3>See Also</h3>

<p>Other printCrudeAndAdjusted functions: 
<code><a href="#topic+prCaAddReference">prCaAddReference</a>()</code>,
<code><a href="#topic+prCaAddUserReferences">prCaAddUserReferences</a>()</code>,
<code><a href="#topic+prCaGetImputationCols">prCaGetImputationCols</a>()</code>,
<code><a href="#topic+prCaGetRowname">prCaGetRowname</a>()</code>,
<code><a href="#topic+prCaGetVnStats">prCaGetVnStats</a>()</code>,
<code><a href="#topic+prCaPrepareCrudeAndAdjusted">prCaPrepareCrudeAndAdjusted</a>()</code>,
<code><a href="#topic+prCaReorderReferenceDescribe">prCaReorderReferenceDescribe</a>()</code>,
<code><a href="#topic+prCaReorder">prCaReorder</a>()</code>,
<code><a href="#topic+prCaSelectAndOrderVars">prCaSelectAndOrderVars</a>()</code>,
<code><a href="#topic+prCaSetRownames">prCaSetRownames</a>()</code>
</p>

<hr>
<h2 id='prCaAddReference'>Adds a reference to value matrix</h2><span id='topic+prCaAddReference'></span>

<h3>Description</h3>

<p>Adds a reference to value matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prCaAddReference(
  vn,
  var_order,
  values,
  add_references_pos,
  reference_zero_effect,
  ds,
  use_labels
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prCaAddReference_+3A_vn">vn</code></td>
<td>
<p>Variable name</p>
</td></tr>
<tr><td><code id="prCaAddReference_+3A_var_order">var_order</code></td>
<td>
<p>The output from the <code><a href="#topic+prMapVariable2Name">prMapVariable2Name</a></code></p>
</td></tr>
<tr><td><code id="prCaAddReference_+3A_values">values</code></td>
<td>
<p>The value matrix</p>
</td></tr>
<tr><td><code id="prCaAddReference_+3A_add_references_pos">add_references_pos</code></td>
<td>
<p>The position where a reference should be added.
Sometimes you don't want the reference to be at the top, for instance
if you have age groups then you may have &lt; 25, 25-39, 40-55, &gt; 55 and
you have the reference to be 25-39 then you should set the reference
list for <code>age_groups</code> as <code>add_references_pos = list(age_groups = 2)</code>
so that you have the second group as the position for the reference.</p>
</td></tr>
<tr><td><code id="prCaAddReference_+3A_reference_zero_effect">reference_zero_effect</code></td>
<td>
<p>Used with references, tells if zero effect
is in exponential form, i.e. <code>exp(0) = 1</code>, or in regular format,
i.e. <code>0 = 0</code> (can be set to any value)</p>
</td></tr>
<tr><td><code id="prCaAddReference_+3A_ds">ds</code></td>
<td>
<p>The data set</p>
</td></tr>
<tr><td><code id="prCaAddReference_+3A_use_labels">use_labels</code></td>
<td>
<p>If the rowname.fn function doesn't change the name then
the label should be used instead of the name, that is if there is a
label and it isn't a factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> A matrix with rgroup and n.rgroup attributes
</p>


<h3>See Also</h3>

<p>Other printCrudeAndAdjusted functions: 
<code><a href="#topic+prCaAddRefAndStat">prCaAddRefAndStat</a>()</code>,
<code><a href="#topic+prCaAddUserReferences">prCaAddUserReferences</a>()</code>,
<code><a href="#topic+prCaGetImputationCols">prCaGetImputationCols</a>()</code>,
<code><a href="#topic+prCaGetRowname">prCaGetRowname</a>()</code>,
<code><a href="#topic+prCaGetVnStats">prCaGetVnStats</a>()</code>,
<code><a href="#topic+prCaPrepareCrudeAndAdjusted">prCaPrepareCrudeAndAdjusted</a>()</code>,
<code><a href="#topic+prCaReorderReferenceDescribe">prCaReorderReferenceDescribe</a>()</code>,
<code><a href="#topic+prCaReorder">prCaReorder</a>()</code>,
<code><a href="#topic+prCaSelectAndOrderVars">prCaSelectAndOrderVars</a>()</code>,
<code><a href="#topic+prCaSetRownames">prCaSetRownames</a>()</code>
</p>

<hr>
<h2 id='prCaAddUserReferences'>Adds references</h2><span id='topic+prCaAddUserReferences'></span>

<h3>Description</h3>

<p>Adds references
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prCaAddUserReferences(
  reordered_groups,
  var_order,
  add_references,
  add_references_pos,
  reference_zero_effect
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prCaAddUserReferences_+3A_reordered_groups">reordered_groups</code></td>
<td>
<p>The value matrix that needs refrences</p>
</td></tr>
<tr><td><code id="prCaAddUserReferences_+3A_var_order">var_order</code></td>
<td>
<p>The output from the <code><a href="#topic+prMapVariable2Name">prMapVariable2Name</a></code></p>
</td></tr>
<tr><td><code id="prCaAddUserReferences_+3A_add_references">add_references</code></td>
<td>
<p>True if it should use the data set to look for
references, otherwise supply the function with a vector with names.
Sometimes you want to indicate the reference row for each group.
This needs to be just as many as the  groups as the order identified.
Use NA if you don't want to have a reference for that particular group.</p>
</td></tr>
<tr><td><code id="prCaAddUserReferences_+3A_add_references_pos">add_references_pos</code></td>
<td>
<p>The position where a reference should be added.
Sometimes you don't want the reference to be at the top, for instance
if you have age groups then you may have &lt; 25, 25-39, 40-55, &gt; 55 and
you have the reference to be 25-39 then you should set the reference
list for <code>age_groups</code> as <code>add_references_pos = list(age_groups = 2)</code>
so that you have the second group as the position for the reference.</p>
</td></tr>
<tr><td><code id="prCaAddUserReferences_+3A_reference_zero_effect">reference_zero_effect</code></td>
<td>
<p>Used with references, tells if zero effect
is in exponential form, i.e. <code>exp(0) = 1</code>, or in regular format,
i.e. <code>0 = 0</code> (can be set to any value)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> The <code>reordered_groups</code> with references and the
attribute &quot;var_order&quot; in order to keep track of no. of variables per row.
</p>


<h3>See Also</h3>

<p>Other printCrudeAndAdjusted functions: 
<code><a href="#topic+prCaAddRefAndStat">prCaAddRefAndStat</a>()</code>,
<code><a href="#topic+prCaAddReference">prCaAddReference</a>()</code>,
<code><a href="#topic+prCaGetImputationCols">prCaGetImputationCols</a>()</code>,
<code><a href="#topic+prCaGetRowname">prCaGetRowname</a>()</code>,
<code><a href="#topic+prCaGetVnStats">prCaGetVnStats</a>()</code>,
<code><a href="#topic+prCaPrepareCrudeAndAdjusted">prCaPrepareCrudeAndAdjusted</a>()</code>,
<code><a href="#topic+prCaReorderReferenceDescribe">prCaReorderReferenceDescribe</a>()</code>,
<code><a href="#topic+prCaReorder">prCaReorder</a>()</code>,
<code><a href="#topic+prCaSelectAndOrderVars">prCaSelectAndOrderVars</a>()</code>,
<code><a href="#topic+prCaSetRownames">prCaSetRownames</a>()</code>
</p>

<hr>
<h2 id='prCaDefaultGetCoefAndCI'>Get the confidence intervals</h2><span id='topic+prCaDefaultGetCoefAndCI'></span><span id='topic+prCaRmsGetCoefAndCI'></span>

<h3>Description</h3>

<p>These are functions that get the estimates and the confidence intervals.
Due to package differences there are some local modifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prCaDefaultGetCoefAndCI(model, level, skip_intercept = FALSE)

prCaRmsGetCoefAndCI(model, level, vn, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prCaDefaultGetCoefAndCI_+3A_model">model</code></td>
<td>
<p>The regression model</p>
</td></tr>
<tr><td><code id="prCaDefaultGetCoefAndCI_+3A_level">level</code></td>
<td>
<p>The confidence interval level</p>
</td></tr>
<tr><td><code id="prCaDefaultGetCoefAndCI_+3A_skip_intercept">skip_intercept</code></td>
<td>
<p>If the model should remove the intercept from
the returned values.</p>
</td></tr>
<tr><td><code id="prCaDefaultGetCoefAndCI_+3A_vn">vn</code></td>
<td>
<p>The variable names</p>
</td></tr>
<tr><td><code id="prCaDefaultGetCoefAndCI_+3A_data">data</code></td>
<td>
<p>The data set</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> Returns a n x 3 matrix where the n equals the number
of variables.
</p>


<h3>The default</h3>

<p>Gets the estimate and confidence interval using the <code><a href="stats.html#topic+confint">confint</a></code>
and  <code><a href="stats.html#topic+coef">coef</a></code>.
</p>


<h3>The rms</h3>

<p>The rms-package does not have confint implemented and it is therefore a
better option to go through the summary function (<code>rms:::summary.rms</code>).
Infortunately skip intercept is not an option as the summary doesn't
include the intercept for the rms regression outputs
</p>

<hr>
<h2 id='prCaGetImputationCols'>Function for retrieving the imputation arguments</h2><span id='topic+prCaGetImputationCols'></span>

<h3>Description</h3>

<p>Function for retrieving the imputation arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prCaGetImputationCols(impute_args, output_mtrx, model, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prCaGetImputationCols_+3A_impute_args">impute_args</code></td>
<td>
<p>The imputation arguments from <code><a href="#topic+printCrudeAndAdjustedModel">printCrudeAndAdjustedModel</a></code>
function call.</p>
</td></tr>
<tr><td><code id="prCaGetImputationCols_+3A_output_mtrx">output_mtrx</code></td>
<td>
<p>The reordered groups matrix (a nx4 matrix)
that have been prepared in for the <code><a href="#topic+printCrudeAndAdjustedModel">printCrudeAndAdjustedModel</a></code>
function. It is important that the references
if any have been added.</p>
</td></tr>
<tr><td><code id="prCaGetImputationCols_+3A_model">model</code></td>
<td>
<p>The imputation model. Currently only <code><a href="Hmisc.html#topic+transcan">fit.mult.impute</a></code>
is supported by the function.</p>
</td></tr>
<tr><td><code id="prCaGetImputationCols_+3A_data">data</code></td>
<td>
<p>The data that has been used for generating the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> Returns a matrix with the requested columns
</p>


<h3>See Also</h3>

<p>Other printCrudeAndAdjusted functions: 
<code><a href="#topic+prCaAddRefAndStat">prCaAddRefAndStat</a>()</code>,
<code><a href="#topic+prCaAddReference">prCaAddReference</a>()</code>,
<code><a href="#topic+prCaAddUserReferences">prCaAddUserReferences</a>()</code>,
<code><a href="#topic+prCaGetRowname">prCaGetRowname</a>()</code>,
<code><a href="#topic+prCaGetVnStats">prCaGetVnStats</a>()</code>,
<code><a href="#topic+prCaPrepareCrudeAndAdjusted">prCaPrepareCrudeAndAdjusted</a>()</code>,
<code><a href="#topic+prCaReorderReferenceDescribe">prCaReorderReferenceDescribe</a>()</code>,
<code><a href="#topic+prCaReorder">prCaReorder</a>()</code>,
<code><a href="#topic+prCaSelectAndOrderVars">prCaSelectAndOrderVars</a>()</code>,
<code><a href="#topic+prCaSetRownames">prCaSetRownames</a>()</code>
</p>

<hr>
<h2 id='prCaGetRowname'>Gets the labelled rowname if it exists</h2><span id='topic+prCaGetRowname'></span>

<h3>Description</h3>

<p>Looks for matches inside factors if rowname
contains the name of the column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prCaGetRowname(vn, use_labels, dataset)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prCaGetRowname_+3A_vn">vn</code></td>
<td>
<p>The variable name</p>
</td></tr>
<tr><td><code id="prCaGetRowname_+3A_use_labels">use_labels</code></td>
<td>
<p>If labels should be used</p>
</td></tr>
<tr><td><code id="prCaGetRowname_+3A_dataset">dataset</code></td>
<td>
<p>The dataset</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>string</code> The rowname
</p>


<h3>See Also</h3>

<p>Other printCrudeAndAdjusted functions: 
<code><a href="#topic+prCaAddRefAndStat">prCaAddRefAndStat</a>()</code>,
<code><a href="#topic+prCaAddReference">prCaAddReference</a>()</code>,
<code><a href="#topic+prCaAddUserReferences">prCaAddUserReferences</a>()</code>,
<code><a href="#topic+prCaGetImputationCols">prCaGetImputationCols</a>()</code>,
<code><a href="#topic+prCaGetVnStats">prCaGetVnStats</a>()</code>,
<code><a href="#topic+prCaPrepareCrudeAndAdjusted">prCaPrepareCrudeAndAdjusted</a>()</code>,
<code><a href="#topic+prCaReorderReferenceDescribe">prCaReorderReferenceDescribe</a>()</code>,
<code><a href="#topic+prCaReorder">prCaReorder</a>()</code>,
<code><a href="#topic+prCaSelectAndOrderVars">prCaSelectAndOrderVars</a>()</code>,
<code><a href="#topic+prCaSetRownames">prCaSetRownames</a>()</code>
</p>

<hr>
<h2 id='prCaGetVnStats'>Gets the variable stats</h2><span id='topic+prCaGetVnStats'></span>

<h3>Description</h3>

<p>Gets the variable stats
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prCaGetVnStats(
  model,
  vn,
  outcome,
  ds,
  add_references,
  add_references_pos,
  desc_args
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prCaGetVnStats_+3A_model">model</code></td>
<td>
<p>The model</p>
</td></tr>
<tr><td><code id="prCaGetVnStats_+3A_vn">vn</code></td>
<td>
<p>The variable name</p>
</td></tr>
<tr><td><code id="prCaGetVnStats_+3A_outcome">outcome</code></td>
<td>
<p>The outcome vector</p>
</td></tr>
<tr><td><code id="prCaGetVnStats_+3A_ds">ds</code></td>
<td>
<p>The dataset</p>
</td></tr>
<tr><td><code id="prCaGetVnStats_+3A_add_references">add_references</code></td>
<td>
<p>True if it should use the data set to look for
references, otherwise supply the function with a vector with names.
Sometimes you want to indicate the reference row for each group.
This needs to be just as many as the  groups as the order identified.
Use NA if you don't want to have a reference for that particular group.</p>
</td></tr>
<tr><td><code id="prCaGetVnStats_+3A_add_references_pos">add_references_pos</code></td>
<td>
<p>The position where a reference should be added.
Sometimes you don't want the reference to be at the top, for instance
if you have age groups then you may have &lt; 25, 25-39, 40-55, &gt; 55 and
you have the reference to be 25-39 then you should set the reference
list for <code>age_groups</code> as <code>add_references_pos = list(age_groups = 2)</code>
so that you have the second group as the position for the reference.</p>
</td></tr>
<tr><td><code id="prCaGetVnStats_+3A_desc_args">desc_args</code></td>
<td>
<p>The description arguments that are to be used for the
the description columns. The options/arguments should be generated by the
<code><a href="#topic+caDescribeOpts">caDescribeOpts</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> A matrix from <code><a href="Gmisc.html#topic+getDescriptionStatsBy">getDescriptionStatsBy</a></code> or
<code><a href="#topic+prGetStatistics">prGetStatistics</a></code>
</p>


<h3>See Also</h3>

<p>Other printCrudeAndAdjusted functions: 
<code><a href="#topic+prCaAddRefAndStat">prCaAddRefAndStat</a>()</code>,
<code><a href="#topic+prCaAddReference">prCaAddReference</a>()</code>,
<code><a href="#topic+prCaAddUserReferences">prCaAddUserReferences</a>()</code>,
<code><a href="#topic+prCaGetImputationCols">prCaGetImputationCols</a>()</code>,
<code><a href="#topic+prCaGetRowname">prCaGetRowname</a>()</code>,
<code><a href="#topic+prCaPrepareCrudeAndAdjusted">prCaPrepareCrudeAndAdjusted</a>()</code>,
<code><a href="#topic+prCaReorderReferenceDescribe">prCaReorderReferenceDescribe</a>()</code>,
<code><a href="#topic+prCaReorder">prCaReorder</a>()</code>,
<code><a href="#topic+prCaSelectAndOrderVars">prCaSelectAndOrderVars</a>()</code>,
<code><a href="#topic+prCaSetRownames">prCaSetRownames</a>()</code>
</p>

<hr>
<h2 id='prCaPrepareCrudeAndAdjusted'>Prettify the text</h2><span id='topic+prCaPrepareCrudeAndAdjusted'></span>

<h3>Description</h3>

<p>Sets the number of digits, formats the confidence interval and
changes the number of cols into 4 where the upper and lower CI
meet in one string column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prCaPrepareCrudeAndAdjusted(x, ci_lim, digits, sprintf_ci_str)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prCaPrepareCrudeAndAdjusted_+3A_x">x</code></td>
<td>
<p>The value matrix from getCrudeAndAdjusted</p>
</td></tr>
<tr><td><code id="prCaPrepareCrudeAndAdjusted_+3A_ci_lim">ci_lim</code></td>
<td>
<p>The limits of the confidence interval</p>
</td></tr>
<tr><td><code id="prCaPrepareCrudeAndAdjusted_+3A_digits">digits</code></td>
<td>
<p>The number of decimal digits to use</p>
</td></tr>
<tr><td><code id="prCaPrepareCrudeAndAdjusted_+3A_sprintf_ci_str">sprintf_ci_str</code></td>
<td>
<p>The <code><a href="base.html#topic+sprintf">sprintf</a></code> code for the confidence interval</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> A string matrix with the values formated
</p>


<h3>See Also</h3>

<p>Other printCrudeAndAdjusted functions: 
<code><a href="#topic+prCaAddRefAndStat">prCaAddRefAndStat</a>()</code>,
<code><a href="#topic+prCaAddReference">prCaAddReference</a>()</code>,
<code><a href="#topic+prCaAddUserReferences">prCaAddUserReferences</a>()</code>,
<code><a href="#topic+prCaGetImputationCols">prCaGetImputationCols</a>()</code>,
<code><a href="#topic+prCaGetRowname">prCaGetRowname</a>()</code>,
<code><a href="#topic+prCaGetVnStats">prCaGetVnStats</a>()</code>,
<code><a href="#topic+prCaReorderReferenceDescribe">prCaReorderReferenceDescribe</a>()</code>,
<code><a href="#topic+prCaReorder">prCaReorder</a>()</code>,
<code><a href="#topic+prCaSelectAndOrderVars">prCaSelectAndOrderVars</a>()</code>,
<code><a href="#topic+prCaSetRownames">prCaSetRownames</a>()</code>
</p>

<hr>
<h2 id='prCaReorder'>Reorder according to the requested variables</h2><span id='topic+prCaReorder'></span>

<h3>Description</h3>

<p>Uses the <code><a href="#topic+prCaSelectAndOrderVars">prCaSelectAndOrderVars</a></code> for finding the
orders according to the <code>order</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prCaReorder(mtrx2reorder, var_order, order)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prCaReorder_+3A_mtrx2reorder">mtrx2reorder</code></td>
<td>
<p>The matrix to reorder</p>
</td></tr>
<tr><td><code id="prCaReorder_+3A_var_order">var_order</code></td>
<td>
<p>The variables representing different rows
<code><a href="#topic+prMapVariable2Name">prMapVariable2Name</a></code></p>
</td></tr>
<tr><td><code id="prCaReorder_+3A_order">order</code></td>
<td>
<p>A vector of strings used for <code><a href="#topic+prCaSelectAndOrderVars">prCaSelectAndOrderVars</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> Returns the <code>mtrx2reorder</code> rearranged with the
attribute &quot;greps&quot; for the greps from <code><a href="#topic+prCaSelectAndOrderVars">prCaSelectAndOrderVars</a></code>
and the attribute &quot;var_order&quot; for the new var_order
</p>


<h3>See Also</h3>

<p>Other printCrudeAndAdjusted functions: 
<code><a href="#topic+prCaAddRefAndStat">prCaAddRefAndStat</a>()</code>,
<code><a href="#topic+prCaAddReference">prCaAddReference</a>()</code>,
<code><a href="#topic+prCaAddUserReferences">prCaAddUserReferences</a>()</code>,
<code><a href="#topic+prCaGetImputationCols">prCaGetImputationCols</a>()</code>,
<code><a href="#topic+prCaGetRowname">prCaGetRowname</a>()</code>,
<code><a href="#topic+prCaGetVnStats">prCaGetVnStats</a>()</code>,
<code><a href="#topic+prCaPrepareCrudeAndAdjusted">prCaPrepareCrudeAndAdjusted</a>()</code>,
<code><a href="#topic+prCaReorderReferenceDescribe">prCaReorderReferenceDescribe</a>()</code>,
<code><a href="#topic+prCaSelectAndOrderVars">prCaSelectAndOrderVars</a>()</code>,
<code><a href="#topic+prCaSetRownames">prCaSetRownames</a>()</code>
</p>

<hr>
<h2 id='prCaReorderReferenceDescribe'>Adds the ordering, references, and descriptions</h2><span id='topic+prCaReorderReferenceDescribe'></span>

<h3>Description</h3>

<p>This is a wrapper function around some more basic functions that
<code><a href="#topic+printCrudeAndAdjustedModel">printCrudeAndAdjustedModel</a>()</code> uses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prCaReorderReferenceDescribe(
  x,
  model,
  order,
  var_order,
  add_references,
  add_references_pos,
  reference_zero_effect,
  ds,
  desc_column,
  desc_args,
  use_labels
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prCaReorderReferenceDescribe_+3A_x">x</code></td>
<td>
<p>The main value matrix from the <code><a href="#topic+prCaPrepareCrudeAndAdjusted">prCaPrepareCrudeAndAdjusted</a>()</code></p>
</td></tr>
<tr><td><code id="prCaReorderReferenceDescribe_+3A_model">model</code></td>
<td>
<p>The model</p>
</td></tr>
<tr><td><code id="prCaReorderReferenceDescribe_+3A_order">order</code></td>
<td>
<p>A vector A vector with regular expressions for each group.</p>
</td></tr>
<tr><td><code id="prCaReorderReferenceDescribe_+3A_var_order">var_order</code></td>
<td>
<p>The output from the <code><a href="#topic+prMapVariable2Name">prMapVariable2Name</a>()</code></p>
</td></tr>
<tr><td><code id="prCaReorderReferenceDescribe_+3A_add_references">add_references</code></td>
<td>
<p>True if it should use the data set to look for
references, otherwise supply the function with a vector with names.
Sometimes you want to indicate the reference row for each group.
This needs to be just as many as the  groups as the order identified.
Use NA if you don't want to have a reference for that particular group.</p>
</td></tr>
<tr><td><code id="prCaReorderReferenceDescribe_+3A_add_references_pos">add_references_pos</code></td>
<td>
<p>The position where a reference should be added.
Sometimes you don't want the reference to be at the top, for instance
if you have age groups then you may have &lt; 25, 25-39, 40-55, &gt; 55 and
you have the reference to be 25-39 then you should set the reference
list for <code>age_groups</code> as <code>add_references_pos = list(age_groups = 2)</code>
so that you have the second group as the position for the reference.</p>
</td></tr>
<tr><td><code id="prCaReorderReferenceDescribe_+3A_reference_zero_effect">reference_zero_effect</code></td>
<td>
<p>Used with references, tells if zero effect
is in exponential form, i.e. <code>exp(0) = 1</code>, or in regular format,
i.e. <code>0 = 0</code> (can be set to any value)</p>
</td></tr>
<tr><td><code id="prCaReorderReferenceDescribe_+3A_ds">ds</code></td>
<td>
<p>The dataset from the model</p>
</td></tr>
<tr><td><code id="prCaReorderReferenceDescribe_+3A_desc_column">desc_column</code></td>
<td>
<p>Add descriptive column to the crude and adjusted table</p>
</td></tr>
<tr><td><code id="prCaReorderReferenceDescribe_+3A_desc_args">desc_args</code></td>
<td>
<p>The description arguments that are to be used for the
the description columns. The options/arguments should be generated by the
<code><a href="#topic+caDescribeOpts">caDescribeOpts</a></code> function.</p>
</td></tr>
<tr><td><code id="prCaReorderReferenceDescribe_+3A_use_labels">use_labels</code></td>
<td>
<p>If the rowname.fn function doesn't change the name then
the label should be used instead of the name, that is if there is a
label and it isn't a factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The reordered groups as a matrix
</p>


<h3>See Also</h3>

<p>Other printCrudeAndAdjusted functions: 
<code><a href="#topic+prCaAddRefAndStat">prCaAddRefAndStat</a>()</code>,
<code><a href="#topic+prCaAddReference">prCaAddReference</a>()</code>,
<code><a href="#topic+prCaAddUserReferences">prCaAddUserReferences</a>()</code>,
<code><a href="#topic+prCaGetImputationCols">prCaGetImputationCols</a>()</code>,
<code><a href="#topic+prCaGetRowname">prCaGetRowname</a>()</code>,
<code><a href="#topic+prCaGetVnStats">prCaGetVnStats</a>()</code>,
<code><a href="#topic+prCaPrepareCrudeAndAdjusted">prCaPrepareCrudeAndAdjusted</a>()</code>,
<code><a href="#topic+prCaReorder">prCaReorder</a>()</code>,
<code><a href="#topic+prCaSelectAndOrderVars">prCaSelectAndOrderVars</a>()</code>,
<code><a href="#topic+prCaSetRownames">prCaSetRownames</a>()</code>
</p>

<hr>
<h2 id='prCaSelectAndOrderVars'>Re-order variables</h2><span id='topic+prCaSelectAndOrderVars'></span>

<h3>Description</h3>

<p>Re-order variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prCaSelectAndOrderVars(names, order, ok2skip = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prCaSelectAndOrderVars_+3A_names">names</code></td>
<td>
<p>The names of the variables</p>
</td></tr>
<tr><td><code id="prCaSelectAndOrderVars_+3A_order">order</code></td>
<td>
<p>The order regular expression</p>
</td></tr>
<tr><td><code id="prCaSelectAndOrderVars_+3A_ok2skip">ok2skip</code></td>
<td>
<p>If you have the intercept then
it should be ok for the function to skip that
variable if it isn't found among the variable list</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>vector</code> A vector containing the greps
</p>


<h3>See Also</h3>

<p>Other printCrudeAndAdjusted functions: 
<code><a href="#topic+prCaAddRefAndStat">prCaAddRefAndStat</a>()</code>,
<code><a href="#topic+prCaAddReference">prCaAddReference</a>()</code>,
<code><a href="#topic+prCaAddUserReferences">prCaAddUserReferences</a>()</code>,
<code><a href="#topic+prCaGetImputationCols">prCaGetImputationCols</a>()</code>,
<code><a href="#topic+prCaGetRowname">prCaGetRowname</a>()</code>,
<code><a href="#topic+prCaGetVnStats">prCaGetVnStats</a>()</code>,
<code><a href="#topic+prCaPrepareCrudeAndAdjusted">prCaPrepareCrudeAndAdjusted</a>()</code>,
<code><a href="#topic+prCaReorderReferenceDescribe">prCaReorderReferenceDescribe</a>()</code>,
<code><a href="#topic+prCaReorder">prCaReorder</a>()</code>,
<code><a href="#topic+prCaSetRownames">prCaSetRownames</a>()</code>
</p>

<hr>
<h2 id='prCaSetRownames'>Sets the rownames of the reordered_groups</h2><span id='topic+prCaSetRownames'></span>

<h3>Description</h3>

<p>Sets the rownames of the reordered_groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prCaSetRownames(reordered_groups, var_order, rowname.fn, use_labels, ds)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prCaSetRownames_+3A_reordered_groups">reordered_groups</code></td>
<td>
<p>The value matrix that needs refrences</p>
</td></tr>
<tr><td><code id="prCaSetRownames_+3A_var_order">var_order</code></td>
<td>
<p>The output from the <code><a href="#topic+prMapVariable2Name">prMapVariable2Name</a></code></p>
</td></tr>
<tr><td><code id="prCaSetRownames_+3A_rowname.fn">rowname.fn</code></td>
<td>
<p>A rowname function for tailoring names</p>
</td></tr>
<tr><td><code id="prCaSetRownames_+3A_use_labels">use_labels</code></td>
<td>
<p>Whether to use labels or not</p>
</td></tr>
<tr><td><code id="prCaSetRownames_+3A_ds">ds</code></td>
<td>
<p>The model data set</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> Returns the reordered_groups
</p>


<h3>See Also</h3>

<p>Other printCrudeAndAdjusted functions: 
<code><a href="#topic+prCaAddRefAndStat">prCaAddRefAndStat</a>()</code>,
<code><a href="#topic+prCaAddReference">prCaAddReference</a>()</code>,
<code><a href="#topic+prCaAddUserReferences">prCaAddUserReferences</a>()</code>,
<code><a href="#topic+prCaGetImputationCols">prCaGetImputationCols</a>()</code>,
<code><a href="#topic+prCaGetRowname">prCaGetRowname</a>()</code>,
<code><a href="#topic+prCaGetVnStats">prCaGetVnStats</a>()</code>,
<code><a href="#topic+prCaPrepareCrudeAndAdjusted">prCaPrepareCrudeAndAdjusted</a>()</code>,
<code><a href="#topic+prCaReorderReferenceDescribe">prCaReorderReferenceDescribe</a>()</code>,
<code><a href="#topic+prCaReorder">prCaReorder</a>()</code>,
<code><a href="#topic+prCaSelectAndOrderVars">prCaSelectAndOrderVars</a>()</code>
</p>

<hr>
<h2 id='prClearPCAclass'>Removes the printCrudeAndAdjusted class from arguments</h2><span id='topic+prClearPCAclass'></span>

<h3>Description</h3>

<p>Removes the printCrudeAndAdjusted class from arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prClearPCAclass(pca)
</code></pre>


<h3>Value</h3>

<p>list
</p>

<hr>
<h2 id='prConvertShowMissing'>A function for converting a useNA variable</h2><span id='topic+prConvertShowMissing'></span>

<h3>Description</h3>

<p>The variable is suppose to be directly compatible with
table(..., useNA = useNA). It throughs an error
if not compatible
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prConvertShowMissing(useNA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prConvertShowMissing_+3A_usena">useNA</code></td>
<td>
<p>Boolean or &quot;no&quot;, &quot;ifany&quot;, &quot;always&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string
</p>

<hr>
<h2 id='prEnvModelCall'>Runs an <code><a href="Gmisc.html#topic+fastDoCall">fastDoCall</a>()</code> within the environment of the model</h2><span id='topic+prEnvModelCall'></span>

<h3>Description</h3>

<p>Sometimes the function can't find some of the variables that
were available when running the original variable. This function
uses the <code><a href="stats.html#topic+formula">as.formula</a>()</code> together with
<code><a href="base.html#topic+environment">environment</a>()</code> in order to get the environment
that the original code used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prEnvModelCall(model, what, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prEnvModelCall_+3A_model">model</code></td>
<td>
<p>The model used</p>
</td></tr>
<tr><td><code id="prEnvModelCall_+3A_what">what</code></td>
<td>
<p>The function or non-empty character string used for
<code><a href="Gmisc.html#topic+fastDoCall">fastDoCall</a>()</code></p>
</td></tr>
<tr><td><code id="prEnvModelCall_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function</p>
</td></tr>
</table>

<hr>
<h2 id='prExtractOutcomeFromModel'>Get model outcome</h2><span id='topic+prExtractOutcomeFromModel'></span>

<h3>Description</h3>

<p>Uses the model to extract the outcome variable. Throws
error if unable to find the outcome.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prExtractOutcomeFromModel(model, mf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prExtractOutcomeFromModel_+3A_model">model</code></td>
<td>
<p>The fitted model</p>
</td></tr>
<tr><td><code id="prExtractOutcomeFromModel_+3A_mf">mf</code></td>
<td>
<p>The dataset that the model is fitted to - if missing it
uses the <code><a href="stats.html#topic+model.frame">model.frame</a>()</code> dataset. This can cause
length issues as there may be variables that are excluded from the
model for different reasons.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector
</p>

<hr>
<h2 id='prFindRownameMatches'>Looks for unique rowname match without grep</h2><span id='topic+prFindRownameMatches'></span>

<h3>Description</h3>

<p>Since a rowname may contain characters reserved by regular
expressions I've found it easier to deal with the rowname
finding by just checking for matching strings at the beginning
of the name while at the same time excluding names that have the
same stem, i.e. DM and DM_COMP will cause an issue since DM will
match both rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prFindRownameMatches(rnames, vn, vars)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prFindRownameMatches_+3A_rnames">rnames</code></td>
<td>
<p>A vector with the rownames that are looked for</p>
</td></tr>
<tr><td><code id="prFindRownameMatches_+3A_vn">vn</code></td>
<td>
<p>The variable name that is of interest</p>
</td></tr>
<tr><td><code id="prFindRownameMatches_+3A_vars">vars</code></td>
<td>
<p>A vector with all the names and the potentially competing names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>integer A vector containing the position of the matches
</p>
<p>TODO: remove this function in favor of the more powerful prMapVariable2Name
</p>

<hr>
<h2 id='prGetModelData'>Get model data.frame</h2><span id='topic+prGetModelData'></span>

<h3>Description</h3>

<p>Returns the raw variables from the original data
frame using the <code><a href="stats.html#topic+model.frame">get_all_vars</a>()</code>
but with the twist that it also performs any associated
subsetting based on the model's <code><a href="base.html#topic+subset">subset</a>()</code> argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prGetModelData(x, terms_only = FALSE, term.label)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prGetModelData_+3A_x">x</code></td>
<td>
<p>The fitted model.</p>
</td></tr>
<tr><td><code id="prGetModelData_+3A_terms_only">terms_only</code></td>
<td>
<p>Only use the right side of the equation by selecting the terms</p>
</td></tr>
<tr><td><code id="prGetModelData_+3A_term.label">term.label</code></td>
<td>
<p>Sometimes need to retrieve specific spline labels that are not among
the 'labels(terms(x))'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>

<hr>
<h2 id='prGetModelVariables'>Get the models variables</h2><span id='topic+prGetModelVariables'></span>

<h3>Description</h3>

<p>This function extract the modelled variables. Any interaction
terms are removed as those should already be represented by
the individual terms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prGetModelVariables(
  model,
  remove_splines = TRUE,
  remove_interaction_vars = FALSE,
  add_intercept = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prGetModelVariables_+3A_model">model</code></td>
<td>
<p>A model fit</p>
</td></tr>
<tr><td><code id="prGetModelVariables_+3A_remove_splines">remove_splines</code></td>
<td>
<p>If splines, etc. should be cleaned
from the variables as these no longer are &quot;pure&quot; variables</p>
</td></tr>
<tr><td><code id="prGetModelVariables_+3A_remove_interaction_vars">remove_interaction_vars</code></td>
<td>
<p>If interaction variables are
not interesting then these should be removed. Often in
the case of <code><a href="#topic+printCrudeAndAdjustedModel">printCrudeAndAdjustedModel</a>()</code> it is impossible
to properly show interaction variables and it's better to show
these in a separate table</p>
</td></tr>
<tr><td><code id="prGetModelVariables_+3A_add_intercept">add_intercept</code></td>
<td>
<p>Adds the intercept if it exists</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with names
</p>

<hr>
<h2 id='prGetStatistics'>Get statistics according to the type</h2><span id='topic+prGetStatistics'></span>

<h3>Description</h3>

<p>A simple function applied by the <code><a href="Gmisc.html#topic+getDescriptionStatsBy">getDescriptionStatsBy</a>()</code>
for the total column. This function is also used by <code><a href="#topic+printCrudeAndAdjustedModel">printCrudeAndAdjustedModel</a>()</code>
in case of a basic linear regression is asked for a raw stat column
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prGetStatistics(
  x,
  show_perc = FALSE,
  html = TRUE,
  digits = 1,
  numbers_first = TRUE,
  useNA = "no",
  show_all_values = FALSE,
  continuous_fn = describeMean,
  factor_fn = describeFactors,
  prop_fn = factor_fn,
  percentage_sign = percentage_sign
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prGetStatistics_+3A_x">x</code></td>
<td>
<p>The variable that we want the statistics for</p>
</td></tr>
<tr><td><code id="prGetStatistics_+3A_show_perc">show_perc</code></td>
<td>
<p>If this is a factor/proportion variable then we
might want to show the percentages</p>
</td></tr>
<tr><td><code id="prGetStatistics_+3A_html">html</code></td>
<td>
<p>If the output should be in html or LaTeX formatting</p>
</td></tr>
<tr><td><code id="prGetStatistics_+3A_digits">digits</code></td>
<td>
<p>Number of decimal digits</p>
</td></tr>
<tr><td><code id="prGetStatistics_+3A_numbers_first">numbers_first</code></td>
<td>
<p>If number is to be prior to the percentage</p>
</td></tr>
<tr><td><code id="prGetStatistics_+3A_usena">useNA</code></td>
<td>
<p>If missing should be included</p>
</td></tr>
<tr><td><code id="prGetStatistics_+3A_show_all_values">show_all_values</code></td>
<td>
<p>This is by default false as for instance if there is
no missing and there is only one variable then it is most sane to only show
one option as the other one will just be a complement to the first. For instance
sex - if you know gender then automatically you know the distribution of the
other sex as it's 100 % - other %.</p>
</td></tr>
<tr><td><code id="prGetStatistics_+3A_continuous_fn">continuous_fn</code></td>
<td>
<p>A function for describing continuous variables
defaults to <code>describeMean()</code></p>
</td></tr>
<tr><td><code id="prGetStatistics_+3A_factor_fn">factor_fn</code></td>
<td>
<p>A function for describing factors, defaults to
<code>describeFactors()</code></p>
</td></tr>
<tr><td><code id="prGetStatistics_+3A_prop_fn">prop_fn</code></td>
<td>
<p>A function for describing proportions, defaults to
the factor function</p>
</td></tr>
<tr><td><code id="prGetStatistics_+3A_percentage_sign">percentage_sign</code></td>
<td>
<p>If you want to suppress the percentage sign you
can set this variable to FALSE. You can also choose something else that
the default % if you so wish by setting this variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or a vector depending on the settings
</p>
<p>TODO: Use the Gmisc function instead of this copy
</p>

<hr>
<h2 id='printCrudeAndAdjustedModel'>Output crude and adjusted model data</h2><span id='topic+printCrudeAndAdjustedModel'></span><span id='topic+rbind.printCrudeAndAdjusted'></span><span id='topic+print.printCrudeAndAdjusted'></span><span id='topic+htmlTable.printCrudeAndAdjusted'></span><span id='topic++5B.printCrudeAndAdjusted'></span><span id='topic+cbind.printCrudeAndAdjusted'></span><span id='topic+knit_print.printCrudeAndAdjusted'></span><span id='topic+latex.printCrudeAndAdjusted'></span>

<h3>Description</h3>

<p>Prints table for a fitted object. It prints by default a latex table but can
also be converted into a HTML table that should be more compatible with common
word processors. For details run <code>vignette("printCrudeAndAdjustedModel")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printCrudeAndAdjustedModel(
  model,
  order,
  digits = 2,
  ci_lim = c(-Inf, Inf),
  sprintf_ci_str = getOption("sprintf_ci_str", "%s to %s"),
  add_references,
  add_references_pos,
  reference_zero_effect,
  groups,
  rowname.fn,
  use_labels = TRUE,
  desc_column = FALSE,
  desc_args = caDescribeOpts(digits = digits),
  impute_args,
  ...
)

## S3 method for class 'printCrudeAndAdjusted'
rbind(..., alt.names, deparse.level = 1)

## S3 method for class 'printCrudeAndAdjusted'
print(x, ...)

## S3 method for class 'printCrudeAndAdjusted'
htmlTable(x, ...)

## S3 method for class 'printCrudeAndAdjusted'
x[i, j, ...]

## S3 method for class 'printCrudeAndAdjusted'
cbind(..., alt.names, deparse.level = 1)

## S3 method for class 'printCrudeAndAdjusted'
knit_print(x, ...)

## S3 method for class 'printCrudeAndAdjusted'
latex(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="printCrudeAndAdjustedModel_+3A_model">model</code></td>
<td>
<p>A regression model fit, i.e. the returned object from your
regression function, or the output from <code><a href="#topic+getCrudeAndAdjustedModelData">getCrudeAndAdjustedModelData</a>()</code></p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_order">order</code></td>
<td>
<p>A vector with regular expressions for each group, use if youe
want to reorder the groups in another way than what you've used in your original
function. You can also use this in order to skip certain variables from the output.</p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_digits">digits</code></td>
<td>
<p>The number of digits to round to</p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_ci_lim">ci_lim</code></td>
<td>
<p>A limit vector number that specifies if any values should be
abbreviated above or below this value, for instance a value of 1000
would give a value of <code>&gt; -1000</code> for a value of 1001. This gives
a prettier table when you have very wide confidence intervals.</p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_sprintf_ci_str">sprintf_ci_str</code></td>
<td>
<p>A string according to <code><a href="base.html#topic+sprintf">sprintf</a>()</code> to
write the confidence interval where the first %s is the lower and
the second the upper. You can choose to set this through setting the option
<code>sprintf_ci_str</code>, e.g. <code>options(sprintf_ci_str = "%s - %s")</code>.</p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_add_references">add_references</code></td>
<td>
<p>True if it should use the data set to look for
references, otherwise supply the function with a vector with names.
Sometimes you want to indicate the reference row for each group.
This needs to be just as many as the  groups as the order identified.
Use NA if you don't want to have a reference for that particular group.</p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_add_references_pos">add_references_pos</code></td>
<td>
<p>The position where a reference should be added.
Sometimes you don't want the reference to be at the top, for instance
if you have age groups then you may have &lt; 25, 25-39, 40-55, &gt; 55 and
you have the reference to be 25-39 then you should set the reference
list for <code>age_groups</code> as <code>add_references_pos = list(age_groups = 2)</code>
so that you have the second group as the position for the reference.</p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_reference_zero_effect">reference_zero_effect</code></td>
<td>
<p>Used with references, tells if zero effect
is in exponential form, i.e. <code>exp(0) = 1</code>, or in regular format,
i.e. <code>0 = 0</code> (can be set to any value)</p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_groups">groups</code></td>
<td>
<p>If you wish to have other than the default <code>rgroup</code> names
for the grouping parameter</p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_rowname.fn">rowname.fn</code></td>
<td>
<p>A function that takes a row name and sees if it needs
beautifying. The function has only one parameter the coefficients name and
should return a string or expression.</p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_use_labels">use_labels</code></td>
<td>
<p>If the rowname.fn function doesn't change the name then
the label should be used instead of the name, that is if there is a
label and it isn't a factor.</p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_desc_column">desc_column</code></td>
<td>
<p>Add descriptive column to the crude and adjusted table</p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_desc_args">desc_args</code></td>
<td>
<p>The description arguments that are to be used for the
the description columns. The options/arguments should be generated by the
<code><a href="#topic+caDescribeOpts">caDescribeOpts</a></code> function.</p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_impute_args">impute_args</code></td>
<td>
<p>A list with additional arguments if the provided input is
a imputed object. Currently the list options <code>coef_change</code> and
<code>variance.inflation</code> are supported. If you want both columns then
the simplest way is to provide the list:
<code>list(coef_change = TRUE, variance.inflation = TRUE)</code>.
The <code>coef_change</code> adds a column with the change in coefficients due to
the imputation, the the &quot;raw&quot; model is subtracted from the imputed results.
The &quot;raw&quot; model is the unimputed model, <code>coef(imputed_model) - coef(raw_model)</code>.
The <code>variance.inflation</code> adds the <code>variance.inflation.impute</code> from the
<code><a href="Hmisc.html#topic+transcan">fit.mult.impute</a>()</code> to a separate column. See the description
for the <code>variance.inflation.impute</code> in in the <code><a href="Hmisc.html#topic+transcan">fit.mult.impute</a>()</code>
description.
Both arguments can be customized by providing a <code>list</code>. The list can have
the elements <code>type</code>, <code>name</code>, <code>out_str</code>, and/or <code>digits</code>.
The <code>type</code> can for <code>coef_change</code>/<code>variance.impute</code> be either
&quot;percent&quot; or &quot;ratio&quot;, note that <code>variance.inflation.impute</code> was not
originally intended to be interpreted as %. The default for <code>coef_change</code> is to
have &quot;diff&quot;, that gives the absolute difference in the coefficient.
The <code>name</code> provides the column name, the <code>out_str</code> should be a string
that is compatible with <code><a href="base.html#topic+sprintf">sprintf</a>()</code> and also contains an argument
for accepting a float value, e.g. &quot;
column. The <code>digits</code> can be used if you are not using the <code>out_str</code>
argument, it simply specifies the number of digits to show. See the example
for how for a working example.
<em>Note</em> that currently only the <code><a href="Hmisc.html#topic+transcan">fit.mult.impute</a>()</code>
is supported by this option.</p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_...">...</code></td>
<td>
<p>outputs from <code>printCrudeAndAdjusted</code>. If mixed then it defaults to rbind.data.frame</p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_alt.names">alt.names</code></td>
<td>
<p>If you don't want to use named arguments for the <code>tspanner</code> attribute in the <code>rbind</code>
or the <code>cgroup</code> in the <code>cbind</code> but a vector with names then use this argument.</p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_deparse.level">deparse.level</code></td>
<td>
<p>backward compatibility</p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_x">x</code></td>
<td>
<p>The output object from the <code>printCrudeAndAdjustedModel</code> function</p>
</td></tr>
<tr><td><code id="printCrudeAndAdjustedModel_+3A_object">object</code></td>
<td>
<p>The output object from the printCrudeAndAdjustedModel function</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> Returns a matrix of class printCrudeAndAdjusted that
has a default print method associated with
</p>


<h3>Warning</h3>

<p>If you call this function and you've changed any of the variables
used in the original call, i.e. the premises are changed, this function will not
remember the original values and the statistics will be faulty!
</p>


<h3>See Also</h3>

<p><code><a href="Hmisc.html#topic+latex">latex</a>()</code> for details.
</p>
<p>Other crudeAndAdjusted functions: 
<code><a href="#topic+getCrudeAndAdjustedModelData">getCrudeAndAdjustedModelData</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># simulated data to use
set.seed(10)
ds &lt;- data.frame(
  ftime = rexp(200),
  fstatus = sample(0:1, 200, replace = TRUE),
  Variable1 = runif(200),
  Variable2 = runif(200),
  Variable3 = runif(200),
  Variable4 = factor(sample(LETTERS[1:4], size = 200, replace = TRUE))
)

library(rms)
dd &lt;- datadist(ds)
options(datadist = "dd")

fit &lt;- cph(Surv(ftime, fstatus) ~ Variable1 + Variable3 + Variable2 + Variable4,
  data = ds, x = TRUE, y = TRUE
)
printCrudeAndAdjustedModel(fit, order = c("Variable[12]", "Variable3"))
printCrudeAndAdjustedModel(fit,
  order = c("Variable3", "Variable4"),
  add_references = TRUE,
  desc_column = TRUE
)

# Now to a missing example
n &lt;- 500
ds &lt;- data.frame(
  x1 = factor(sample(LETTERS[1:4], size = n, replace = TRUE)),
  x2 = rnorm(n, mean = 3, 2),
  x3 = factor(sample(letters[1:3], size = n, replace = TRUE))
)

ds$Missing_var1 &lt;- factor(sample(letters[1:4], size = n, replace = TRUE))
ds$Missing_var2 &lt;- factor(sample(letters[1:4], size = n, replace = TRUE))
ds$y &lt;- rnorm(nrow(ds)) +
  (as.numeric(ds$x1) - 1) * 1 +
  (as.numeric(ds$Missing_var1) - 1) * 1 +
  (as.numeric(ds$Missing_var2) - 1) * .5

# Create a messy missing variable
non_random_missing &lt;- sample(which(ds$Missing_var1 %in% c("b", "d")),
  size = 150, replace = FALSE
)
# Restrict the non-random number on the x2 variables
non_random_missing &lt;- non_random_missing[non_random_missing %in%
  which(ds$x2 &gt; mean(ds$x2) * 1.5) &amp;
  non_random_missing %in%
    which(ds$x2 &gt; mean(ds$y))]
ds$Missing_var1[non_random_missing] &lt;- NA

# Simple missing variable
ds$Missing_var2[sample(1:nrow(ds), size = 50)] &lt;- NA

# Setup the rms environment
ddist &lt;- datadist(ds)
options(datadist = "ddist")

impute_formula &lt;-
  as.formula(paste(
    "~",
    paste(colnames(ds),
      collapse = "+"
    )
  ))

imp_ds &lt;- aregImpute(impute_formula, data = ds, n.impute = 10)

fmult &lt;- fit.mult.impute(y ~ x1 + x2 + x3 +
  Missing_var1 + Missing_var2,
fitter = ols, xtrans = imp_ds, data = ds
)

printCrudeAndAdjustedModel(fmult,
  impute_args = list(
    variance.inflation = TRUE,
    coef_change = list(
      type = "diff",
      digits = 3
    )
  )
)


# Use some labels and style to prettify the output
# fro the mtcars dataset
data("mtcars")

label(mtcars$mpg) &lt;- "Gas"
units(mtcars$mpg) &lt;- "Miles/(US) gallon"

label(mtcars$wt) &lt;- "Weight"
units(mtcars$wt) &lt;- "10^3 kg" # not sure the unit is correct

mtcars$am &lt;- factor(mtcars$am, levels = 0:1, labels = c("Automatic", "Manual"))
label(mtcars$am) &lt;- "Transmission"

mtcars$gear &lt;- factor(mtcars$gear)
label(mtcars$gear) &lt;- "Gears"

# Make up some data for making it slightly more interesting
mtcars$col &lt;- factor(sample(c("red", "black", "silver"), size = NROW(mtcars), replace = TRUE))
label(mtcars$col) &lt;- "Car color"

require(splines)
fit_mtcar &lt;- lm(mpg ~ wt + gear + col, data = mtcars)
printCrudeAndAdjustedModel(fit_mtcar,
  add_references = TRUE,
  ctable = TRUE,
  desc_column = TRUE,
  digits = 1,
  desc_args = caDescribeOpts(
    digits = 1,
    colnames = c("Avg.")
  )) |&gt;
  htmlTable::addHtmlTableStyle(css.rgroup = "",
                               css.header = "font-weight: normal")

printCrudeAndAdjustedModel(fit_mtcar,
  add_references = TRUE,
  desc_column = TRUE,
  order = c("Interc", "gear")
)

# Alterntive print - just an example, doesn't make sense to skip reference
printCrudeAndAdjustedModel(fit_mtcar,
  order = c("col", "gear"),
  groups = c("Color", "Gears"),
  add_references = c("black", NA),
  ctable = TRUE
)

# Now we can also combine models into one table using rbind()
mpg_model &lt;- printCrudeAndAdjustedModel(lm(mpg ~ wt + gear + col, data = mtcars),
  add_references = TRUE,
  ctable = TRUE,
  desc_column = TRUE,
  digits = 1,
  desc_args = caDescribeOpts(
    digits = 1,
    colnames = c("Avg.")
  )
)

wt_model &lt;- printCrudeAndAdjustedModel(lm(wt ~ mpg + gear + col, data = mtcars),
  add_references = TRUE,
  ctable = TRUE,
  desc_column = TRUE,
  digits = 1,
  desc_args = caDescribeOpts(
    digits = 1,
    colnames = c("Avg.")
  )
)

library(htmlTable)
rbind(Miles = mpg_model, Weight = wt_model) |&gt;
  addHtmlTableStyle(pos.caption = "bottom") |&gt;
  htmlTable(caption = paste("Combining models together with a table spanner element",
                            "separating each model"))
</code></pre>

<hr>
<h2 id='prMapVariable2Name'>A function that tries to resolve what variable corresponds to what row</h2><span id='topic+prMapVariable2Name'></span>

<h3>Description</h3>

<p>As both the <code><a href="#topic+getCrudeAndAdjustedModelData">getCrudeAndAdjustedModelData</a>()</code> and the
<code><a href="#topic+printCrudeAndAdjustedModel">printCrudeAndAdjustedModel</a>()</code> need to now exactly
what name from the <code><a href="stats.html#topic+coef">coef</a>()</code>/<code><a href="rms.html#topic+summary.rms">summary.rms</a>()</code>
correspond to we for generalizeability this rather elaborate function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prMapVariable2Name(var_names, available_names, data, force_match = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prMapVariable2Name_+3A_var_names">var_names</code></td>
<td>
<p>The variable names that are saught after</p>
</td></tr>
<tr><td><code id="prMapVariable2Name_+3A_available_names">available_names</code></td>
<td>
<p>The names that are available to search through</p>
</td></tr>
<tr><td><code id="prMapVariable2Name_+3A_data">data</code></td>
<td>
<p>The data set that is saught after</p>
</td></tr>
<tr><td><code id="prMapVariable2Name_+3A_force_match">force_match</code></td>
<td>
<p>Whether all variables need to be identified or not.
E.g. you may only want to use some variables and already pruned the
<code>available_names</code> and therefore wont have matches. This is the
case when <code><a href="#topic+getCrudeAndAdjustedModelData">getCrudeAndAdjustedModelData</a>()</code> has been used together
with the <code>var_select</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>list</code> Returns a list with each element has the corresponding
variable name and a subsequent list with the parameters <code>no_rows</code>
and <code>location</code> indiciting the number of rows corresponding to that
element and where those rows are located. For factors the list also contains
<code>lvls</code> and <code>no_lvls</code>.
</p>

<hr>
<h2 id='prNlChooseDf'>Chooses the degrees of freedom for the non-linearity</h2><span id='topic+prNlChooseDf'></span>

<h3>Description</h3>

<p>Looks for the model with the minimal <code>min_fn</code> within the flex_param span.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prNlChooseDf(
  model,
  flex_param,
  variable,
  spline_fn,
  min_fn,
  simplest_nonlinear,
  verbal,
  workers,
  libraries
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prNlChooseDf_+3A_model">model</code></td>
<td>
<p>The model that is to be evaluated and adapted for non-linearity</p>
</td></tr>
<tr><td><code id="prNlChooseDf_+3A_flex_param">flex_param</code></td>
<td>
<p>A <code>vector</code> with values that are to be tested as the
default second parameter for the non-linearity function that you want to
evaluate. This defaults to 2:7, for the <code><a href="splines.html#topic+ns">ns</a>()</code> it tests
the degrees of freedom ranging between 2 and 7.</p>
</td></tr>
<tr><td><code id="prNlChooseDf_+3A_variable">variable</code></td>
<td>
<p>The name of the parameter that is to be tested for non-linearity.
<em>Note</em> that the variable should be included plain (i.e. as a linear variable)
form in the model.</p>
</td></tr>
<tr><td><code id="prNlChooseDf_+3A_spline_fn">spline_fn</code></td>
<td>
<p>Either a string or a function that is to be used
for testing alternative non-linearity models</p>
</td></tr>
<tr><td><code id="prNlChooseDf_+3A_min_fn">min_fn</code></td>
<td>
<p>This is the function that we want to minimized if the variable supports
the non-linearity assumption. E.g. <code><a href="stats.html#topic+AIC">BIC</a>()</code> or
<code><a href="stats.html#topic+AIC">AIC</a></code>, note that the <code><a href="stats.html#topic+AIC">BIC</a>()</code> will in the majority of cases
support a lower complexity than the <code><a href="stats.html#topic+AIC">AIC</a>()</code>.</p>
</td></tr>
<tr><td><code id="prNlChooseDf_+3A_simplest_nonlinear">simplest_nonlinear</code></td>
<td>
<p>The simplest non-linear form that the ANOVA has been tested against</p>
</td></tr>
<tr><td><code id="prNlChooseDf_+3A_verbal">verbal</code></td>
<td>
<p>Set this to <code>TRUE</code> if you want print statements with the
anova test and the chosen knots.</p>
</td></tr>
<tr><td><code id="prNlChooseDf_+3A_workers">workers</code></td>
<td>
<p>The function tries to run everything in parallel. Under some
circumstances you may want to restrict the number of parallel threads to less
than the default <code><a href="parallel.html#topic+detectCores">detectCores</a>() - 1</code>, e.g. you may run out of memory
then you can provide this parameter. If you do not want to use parallel then
simply set workers to <code>FALSE</code>. The cluster created using <code><a href="parallel.html#topic+makeCluster">makeCluster</a>()</code>
function.</p>
</td></tr>
<tr><td><code id="prNlChooseDf_+3A_libraries">libraries</code></td>
<td>
<p>If we use the parallel approach we need to make sure that the
right libraries are available in the threads</p>
</td></tr>
</table>

<hr>
<h2 id='prPhConfIntPlot'>Plots the confidence intervals</h2><span id='topic+prPhConfIntPlot'></span>

<h3>Description</h3>

<p>Uses <code><a href="graphics.html#topic+polygon">polygon</a>()</code> or
<code><a href="graphics.html#topic+lines">lines</a>()</code> to plot confidence
intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prPhConfIntPlot(model_data, color, polygon, lwd, lty)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prPhConfIntPlot_+3A_model_data">model_data</code></td>
<td>
<p>A data frame with 'xvalues', 'upper', and 'lower'
columns.</p>
</td></tr>
<tr><td><code id="prPhConfIntPlot_+3A_color">color</code></td>
<td>
<p>The color of the line/polygon</p>
</td></tr>
<tr><td><code id="prPhConfIntPlot_+3A_polygon">polygon</code></td>
<td>
<p>Boolean indicating polygon or line</p>
</td></tr>
<tr><td><code id="prPhConfIntPlot_+3A_lwd">lwd</code></td>
<td>
<p>Line width - see <code><a href="grid.html#topic+gpar">gpar</a>()</code></p>
</td></tr>
<tr><td><code id="prPhConfIntPlot_+3A_lty">lty</code></td>
<td>
<p>Line type - see <code><a href="grid.html#topic+gpar">gpar</a>()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>void</code> The function performs the print
</p>

<hr>
<h2 id='prPhDensityPlot'>Plot a density on the datapoints</h2><span id='topic+prPhDensityPlot'></span>

<h3>Description</h3>

<p>Plot a density on the datapoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prPhDensityPlot(xvalues, color)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prPhDensityPlot_+3A_xvalues">xvalues</code></td>
<td>
<p>The xvalues that are used for the density</p>
</td></tr>
<tr><td><code id="prPhDensityPlot_+3A_color">color</code></td>
<td>
<p>The color of the density polygon</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>void</code>
</p>

<hr>
<h2 id='prPhEstimate'>Gets the non-linear function's estimate</h2><span id='topic+prPhEstimate'></span>

<h3>Description</h3>

<p>The function uses predict if not specified contrast
in order to attain the estimate, upper, and lower
confidence interval
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prPhEstimate(model, term.label, ylog, cntrst, xlim, alpha, new_data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prPhEstimate_+3A_model">model</code></td>
<td>
<p>The fit of the model to be plotted</p>
</td></tr>
<tr><td><code id="prPhEstimate_+3A_term.label">term.label</code></td>
<td>
<p>The name of the label</p>
</td></tr>
<tr><td><code id="prPhEstimate_+3A_ylog">ylog</code></td>
<td>
<p>If the outcome should be presented in the anti-log form, i.e.
<code>exp()</code>.</p>
</td></tr>
<tr><td><code id="prPhEstimate_+3A_cntrst">cntrst</code></td>
<td>
<p>A boolean that indicates if the <code><a href="rms.html#topic+contrast">contrast</a>()</code>
function is to be deployed for <span class="pkg">rms</span> generated functions. The nice
thing is that you get the median as a reference by default.</p>
</td></tr>
<tr><td><code id="prPhEstimate_+3A_xlim">xlim</code></td>
<td>
<p>The xlim if provided</p>
</td></tr>
<tr><td><code id="prPhEstimate_+3A_new_data">new_data</code></td>
<td>
<p>If not provided the function looks for the most common values
i.e. median for continuous and mode for factors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code> with the columns xvalues, fit, ucl, lcl
</p>

<hr>
<h2 id='prPhNewData'>A function for retrieving new_data argument for predict</h2><span id='topic+prPhNewData'></span>

<h3>Description</h3>

<p>A function for retrieving new_data argument for predict
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prPhNewData(model, term.label, xlim)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prPhNewData_+3A_model">model</code></td>
<td>
<p>The model fit from <code><a href="survival.html#topic+coxph">coxph</a>()</code>
or <code><a href="rms.html#topic+cph">cph</a>()</code></p>
</td></tr>
<tr><td><code id="prPhNewData_+3A_term.label">term.label</code></td>
<td>
<p>The label that is the one that <code><a href="#topic+plotHR">plotHR</a>()</code>
intends to plot.</p>
</td></tr>
<tr><td><code id="prPhNewData_+3A_xlim">xlim</code></td>
<td>
<p>The x-limits for the plot if any</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>data.frame</code>
</p>

<hr>
<h2 id='prPhRugPlot'>Plot a rug on the datapoints</h2><span id='topic+prPhRugPlot'></span>

<h3>Description</h3>

<p>Plot a rug on the datapoints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prPhRugPlot(xvalues)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prPhRugPlot_+3A_xvalues">xvalues</code></td>
<td>
<p>The xvalues that are used for the density</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>void</code>
</p>

<hr>
<h2 id='prPrintCAstring'>Prep for printing</h2><span id='topic+prPrintCAstring'></span>

<h3>Description</h3>

<p>Since we have both the <code><a href="base.html#topic+print">print</a>()</code> and the
<code><a href="knitr.html#topic+knit_print">knit_print</a>()</code> that we need to call it is
useful to have a common string preparation.
<em>Note:</em> Currently knit_print doesn't work as expected...
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prPrintCAstring(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prPrintCAstring_+3A_x">x</code></td>
<td>
<p>The output object from the <code>printCrudeAndAdjustedModel</code> function</p>
</td></tr>
<tr><td><code id="prPrintCAstring_+3A_...">...</code></td>
<td>
<p>outputs from <code>printCrudeAndAdjusted</code>. If mixed then it defaults to rbind.data.frame</p>
</td></tr>
</table>

<hr>
<h2 id='robcov_alt'>Robust covariance matrix based upon the 'sandwich'-package</h2><span id='topic+robcov_alt'></span>

<h3>Description</h3>

<p>This is an alternative to the 'rms'-package robust covariance
matrix that uses the <span class="pkg">'sandwich'</span> package <code><a href="sandwich.html#topic+vcovHC">vcovHC</a>()</code> function
instead of the <span class="pkg">'rms'</span>-built-in estimator. The advantage being that
many more estimation types are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robcov_alt(fit, type = "HC3", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robcov_alt_+3A_fit">fit</code></td>
<td>
<p>The ols fit that</p>
</td></tr>
<tr><td><code id="robcov_alt_+3A_type">type</code></td>
<td>
<p>a character string specifying the estimation type. See
<code><a href="sandwich.html#topic+vcovHC">vcovHC</a>()</code> for options.</p>
</td></tr>
<tr><td><code id="robcov_alt_+3A_...">...</code></td>
<td>
<p>You should specify type= followed by some of the alternative available
for the <code><a href="sandwich.html#topic+vcovHC">vcovHC</a>()</code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model The fitted model with adjusted variance and df.residual set to NULL
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate some data
n &lt;- 500
x1 &lt;- runif(n) * 2
x2 &lt;- runif(n)
y &lt;- x1^3 + x2 + rnorm(n)

library(rms)
library(sandwich)
dd &lt;- datadist(x1, x2, y)
org.op &lt;- options(datadist = "dd")

# Main function
f &lt;- ols(y ~ rcs(x1, 3) + x2)

# Check the bread
bread(f)
# Check the HC-matrix
vcovHC(f, type = "HC4m")
# Adjust the model so that it uses the HC4m variance
f_rob &lt;- robcov_alt(f, type = "HC4m")
# Get the new HC4m-matrix
# - this function just returns the f_rob$var matrix
vcov(f_rob)
# Now check the confidence interval for the function
confint(f_rob)

options(org.op)
</code></pre>

<hr>
<h2 id='simpleRmsAnova'>A simpler latex output of the latex.anova.rms</h2><span id='topic+simpleRmsAnova'></span><span id='topic+print.simpleRmsAnova'></span>

<h3>Description</h3>

<p>The original problem is that the anova default function
output is very detailed and cause a complaint in Sweave/knitr that
\hbox is overfull. It basically changes capitalized TOTAL,
TOTAL INTERACTION and TOTAL NONLINEAR INTERACTION into lower
case letters. It also deletes the (Factor + Higher Order Factors).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleRmsAnova(
  anova_output,
  subregexps,
  digits = 4,
  pval_lim.sig = 10^-4,
  rowlabel = "",
  ...
)

## S3 method for class 'simpleRmsAnova'
print(x, html = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="simpleRmsAnova_+3A_anova_output">anova_output</code></td>
<td>
<p>An object from the <code><a href="stats.html#topic+anova">anova</a>()</code> function</p>
</td></tr>
<tr><td><code id="simpleRmsAnova_+3A_subregexps">subregexps</code></td>
<td>
<p>A 2 column matrix with sub() regular expressions
to search for and their substitutions. The regular expression
should be located in column 1 and the substitution in column
2.</p>
</td></tr>
<tr><td><code id="simpleRmsAnova_+3A_digits">digits</code></td>
<td>
<p>Number of digits in using the round</p>
</td></tr>
<tr><td><code id="simpleRmsAnova_+3A_pval_lim.sig">pval_lim.sig</code></td>
<td>
<p>The threshold before setting &quot;&lt;&quot;, default is &lt; 0.0001</p>
</td></tr>
<tr><td><code id="simpleRmsAnova_+3A_rowlabel">rowlabel</code></td>
<td>
<p>The label of the rows</p>
</td></tr>
<tr><td><code id="simpleRmsAnova_+3A_...">...</code></td>
<td>
<p>Passed on to latex() or htmlTable</p>
</td></tr>
<tr><td><code id="simpleRmsAnova_+3A_x">x</code></td>
<td>
<p>The output object from the SimpleRmsAnova function</p>
</td></tr>
<tr><td><code id="simpleRmsAnova_+3A_html">html</code></td>
<td>
<p>If HTML output through the htmlTable should be used
instead of traditional latex() function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>void See the latex() function
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ** Borrowed code from the lrm example **

# Fit a logistic model containing predictors age, blood.pressure, sex
# and cholesterol, with age fitted with a smooth 5-knot restricted cubic
# spline function and a different shape of the age relationship for males
# and females.

library(rms)
n &lt;- 1000 # define sample size
set.seed(17) # so can reproduce the results
age &lt;- rnorm(n, 50, 10)
blood.pressure &lt;- rnorm(n, 120, 15)
cholesterol &lt;- rnorm(n, 200, 25)
sex &lt;- factor(sample(c("female", "male"), n, TRUE))
label(age) &lt;- "Age" # label is in Hmisc
label(cholesterol) &lt;- "Total Cholesterol"
label(blood.pressure) &lt;- "Systolic Blood Pressure"
label(sex) &lt;- "Sex"
units(cholesterol) &lt;- "mg/dl" # uses units.default in Hmisc
units(blood.pressure) &lt;- "mmHg"

# To use prop. odds model, avoid using a huge number of intercepts by
# grouping cholesterol into 40-tiles

# Specify population model for log odds that Y = 1
L &lt;- .4 * (sex == "male") + .045 * (age - 50) +
     (log(cholesterol - 10) - 5.2) * (-2 * (sex == "female") + 2 * (sex == "male"))
# Simulate binary y to have Prob(y = 1) = 1/[1+exp(-L)]
y &lt;- ifelse(runif(n) &lt; plogis(L), 1, 0)
cholesterol[1:3] &lt;- NA # 3 missings, at random

ddist &lt;- datadist(age, blood.pressure, cholesterol, sex)
options(datadist = "ddist")

fit_lrm &lt;- lrm(y ~ blood.pressure + sex * (age + rcs(cholesterol, 4)),
     x = TRUE, y = TRUE
)

a_out &lt;- anova(fit_lrm,
     dec.F = 1,
     ss = FALSE
)

simpleRmsAnova(a_out,
     subregexps = rbind(
          c("age", "Age"),
          c("cholesterol", "Cholesterol"),
          c("sex", "Sex")
     ),
     caption = "Anova output for a logistic regression model"
)
</code></pre>

<hr>
<h2 id='tidy.rms'>Tidy a(n) rms model object</h2><span id='topic+tidy.rms'></span>

<h3>Description</h3>

<p>Tidy summarizes information about the components of a model. A model component 
might be a single term in a regressions. Exactly what tidy considers to be a model 
component varies across models but is usually self-evident. If a model has several 
distinct types of components, you will need to specify which components to return.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rms'
tidy(
  x,
  conf.int = FALSE,
  conf.level = 0.95,
  exponentiate = FALSE,
  ...,
  .add_print_p_and_stat_values = getOption("Greg.tidy_add_p_and_stat_values", default =
    FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tidy.rms_+3A_x">x</code></td>
<td>
<p>An rms model, e.g. ['rms::cph()'], ['rms::lrm()']</p>
</td></tr>
<tr><td><code id="tidy.rms_+3A_conf.int">conf.int</code></td>
<td>
<p>Logical indicating whether or not to include a confidence
interval in the tidied output. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.rms_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level to use for the confidence interval
if <code>conf.int = TRUE</code>. Must be strictly greater than 0 and less than 1.
Defaults to 0.95, which corresponds to a 95 percent confidence interval.</p>
</td></tr>
<tr><td><code id="tidy.rms_+3A_exponentiate">exponentiate</code></td>
<td>
<p>Logical indicating whether or not to exponentiate the
the coefficient estimates. This is typical for logistic and multinomial
regressions, but a bad idea if there is no log or logit link. Defaults
to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="tidy.rms_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not used. Needed to match generic
signature only. <strong>Cautionary note:</strong> Misspelled arguments will be
absorbed in <code>...</code>, where they will be ignored. If the misspelled
argument has a default value, the default value will be used.
For example, if you pass <code>conf.lvel = 0.9</code>, all computation will
proceed using <code>conf.level = 0.95</code>. Two exceptions here are:
</p>

<ul>
<li> <p><code>tidy()</code> methods will warn when supplied an <code>exponentiate</code> argument if
it will be ignored.
</p>
</li>
<li> <p><code>augment()</code> methods will warn when supplied a <code>newdata</code> argument if it
will be ignored.
</p>
</li></ul>
</td></tr>
<tr><td><code id="tidy.rms_+3A_.add_print_p_and_stat_values">.add_print_p_and_stat_values</code></td>
<td>
<p>For estimating print values there is a workaround that
relies on capturing output from the 'print(x)' and is not considered safe.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a quick fix for addressing the lack of 'rms'-compatibility with the 'broom'
package, see [broom issue 30](https://github.com/tidymodels/broom/issues/30).
</p>


<h3>Value</h3>

<p>A tibble::tibble() with columns:
- 'term' The name of the regression term.
- 'factor' The factor if the term is a character/factor term.
- 'column_term' The full name as in the original input data
- 'estimate'	The estimated value of the regression term.
- 'conf.high'	Upper bound on the confidence interval for the estimate.c
- 'conf.low'	Lower bound on the confidence interval for the estimate.
- 'p.value' The two-sided p-value associated with the observed statistic.
- 'statistic' The value of a statistic to use in a hypothesis that the regression term is non-zero.
- 'std.error' The standard error of the regression term.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(rms)
library(broom)
library(tidyverse)

set.seed(10)
cov &lt;- tibble(x1 = runif(200)) |&gt; 
  mutate(x_bool_fact = if_else(x1 &gt; 0.5,
                               "Yes",
                               sample(c("Yes", "No"), size = n(), replace = TRUE)),
         x_multi_fact = sample(c("Strange", "Factor", "Names"), size = n(), replace = TRUE),
         ftime = rexp(n()),
         fstatus = sample(0:1, size = n(), replace = TRUE),
         x_good_predictor = fstatus * runif(n()))

ddist &lt;- datadist(cov)
options(datadist = "ddist")

cph_fit &lt;- cph(Surv(ftime, fstatus) ~ x1 + x_bool_fact + 
                 x_multi_fact + x_good_predictor, data = cov)
tidy(cph_fit)
</code></pre>

<hr>
<h2 id='timeSplitter'>A function for splitting a time according to time periods</h2><span id='topic+timeSplitter'></span>

<h3>Description</h3>

<p>If we have a violation of the cox proprtional hazards assumption we need to
split an individual's followup time into several. See <code>vignette("timeSplitter", package = "Greg")</code>
for a detailed description.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeSplitter(
  data,
  by,
  time_var,
  event_var,
  event_start_status,
  time_related_vars,
  time_offset
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="timeSplitter_+3A_data">data</code></td>
<td>
<p>The dataset that you want to split according to the <code>time_var</code>
option.</p>
</td></tr>
<tr><td><code id="timeSplitter_+3A_by">by</code></td>
<td>
<p>The time period that you want to split the dataset by. The size of the variable
must be in proportion to the the <code>time_var</code>. The by variable can also be a vector
for each time split, useful if the effect has large varyations over time.</p>
</td></tr>
<tr><td><code id="timeSplitter_+3A_time_var">time_var</code></td>
<td>
<p>The name of the main time variable in the dataset. This variable
must be a numeric variable.</p>
</td></tr>
<tr><td><code id="timeSplitter_+3A_event_var">event_var</code></td>
<td>
<p>The event variable</p>
</td></tr>
<tr><td><code id="timeSplitter_+3A_event_start_status">event_start_status</code></td>
<td>
<p>The start status of the event status, e.g. &quot;Alive&quot;</p>
</td></tr>
<tr><td><code id="timeSplitter_+3A_time_related_vars">time_related_vars</code></td>
<td>
<p>A dataset often contains other variabels that you want
to update during the split, most commonly these are age or calendar time.</p>
</td></tr>
<tr><td><code id="timeSplitter_+3A_time_offset">time_offset</code></td>
<td>
<p>If you want to skip the initial years you can offset the
entire dataset by setting this variable. See detailed description below.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Important note:</em> The time variables must have the same time unit. I.e. function can not dedu
if all variables are in years or if one happens to be in days.
</p>


<h3>Value</h3>

<p><code>data.frame</code> with the split data. The starting time for each period
is named <code>Start_time</code> and the ending time is called <code>Stop_time</code>. Note
that the resulting event_var will now contain the time-splitted eventvar.
</p>


<h3>The time_offset - details</h3>

<p>Both time_var and other variables will be adjusted by the time_offset,
e.g. if we the time scale is in years and we want to skip the first 4 years
we set the <code>time_offset = 4</code>. In the outputted dataset the smallest
<code>time_var</code> will be 0. <em>Note:</em> 0 will not be included as we
generally want to look at those that survived the start date, e.g. if a
patient dies on the 4-year mark we would not include him/her in our study.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_data &lt;- data.frame(
  id = 1:4,
  time = c(4, 3.5, 1, 5),
  event = c("alive", "censored", "dead", "dead"),
  age = c(62.2, 55.3, 73.7, 46.3),
  date = as.Date(
    c("2003-01-01", 
      "2010-04-01", 
      "2013-09-20",
      "2002-02-23")),
  stringsAsFactors = TRUE
)
timeSplitter(test_data, .5, 
             time_var = "time",
             time_related_vars = c("age", "date"),
             event_var = "event")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
