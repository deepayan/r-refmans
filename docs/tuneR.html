<!DOCTYPE html><html><head><title>Help for package tuneR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tuneR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tuneR'><p>tuneR</p></a></li>
<li><a href='#[-methods'><p>Extract or Replace Parts of an Object</p></a></li>
<li><a href='#Arith-methods'><p>Arithmetics on Waves</p></a></li>
<li><a href='#audspec'><p>Frequency band conversion</p></a></li>
<li><a href='#bind'><p>Concatenating Wave objects</p></a></li>
<li><a href='#channel'><p>Channel conversion for Wave objects</p></a></li>
<li><a href='#deltas'><p> Calculate delta features</p></a></li>
<li><a href='#dolpc'><p> (Perceptive) Linear Prediction</p></a></li>
<li><a href='#downsample'><p>Downsampling a Wave or WaveMC object</p></a></li>
<li><a href='#equalWave'><p>Checking Wave objects</p></a></li>
<li><a href='#extractWave'><p>Extractor for Wave and WaveMC objects</p></a></li>
<li><a href='#FF'><p>Estimation of Fundamental Frequencies from a Wspec object</p></a></li>
<li><a href='#fftfreqconvmx'><p>Internal: Convert FFT frequency bins to Bark/Mel bins</p></a></li>
<li><a href='#freqconv'><p> Frequency scale conversion</p></a></li>
<li><a href='#getMidiNotes'><p>Extract note events from objects returned by readMidi</p></a></li>
<li><a href='#length'><p>S4 generic for length</p></a></li>
<li><a href='#lifter'><p> Liftering of cepstra</p></a></li>
<li><a href='#lilyinput'><p>Providing LilyPond compatible input</p></a></li>
<li><a href='#lpc2cep'><p> LPC to cepstra conversion</p></a></li>
<li><a href='#MCnames'><p>Default channel ordering for multi channel wave files</p></a></li>
<li><a href='#melfcc'><p> MFCC Calculation</p></a></li>
<li><a href='#melodyplot'><p>Plotting a melody</p></a></li>
<li><a href='#Mono-Stereo'><p>Converting (extracting, joining) stereo to mono and vice versa</p></a></li>
<li><a href='#nchannel'><p>Number of channels</p></a></li>
<li><a href='#normalize-methods'><p>Rescale the range of values</p></a></li>
<li><a href='#noSilence'><p>Cut off silence from a Wave or WaveMC object</p></a></li>
<li><a href='#noteFromFF'><p>Deriving notes from frequencies</p></a></li>
<li><a href='#notenames'><p>Generating note names from numbers</p></a></li>
<li><a href='#panorama'><p>Narrow the Panorama of a Stereo Sample</p></a></li>
<li><a href='#periodogram-methods'><p>Periodogram (Spectral Density) Estimation on Wave objects</p></a></li>
<li><a href='#play-methods'><p>Playing Waves</p></a></li>
<li><a href='#plot-Wave'><p>Plotting Wave objects</p></a></li>
<li><a href='#plot-Wspec'><p>Plotting Wspec objects</p></a></li>
<li><a href='#plot-WspecMat'><p>Plotting WspecMat objects</p></a></li>
<li><a href='#postaud'><p>Equal loudness compression</p></a></li>
<li><a href='#powspec'><p> Powerspectrum</p></a></li>
<li><a href='#prepComb'><p>Preparing the combination/concatenation of Wave or WaveMC objects</p></a></li>
<li><a href='#quantize'><p>Functions for the quantization of notes</p></a></li>
<li><a href='#quantplot'><p>Plotting the quantization of a melody</p></a></li>
<li><a href='#readMidi'><p>Read a MIDI file</p></a></li>
<li><a href='#readMP3'>
<p>Read an MPEG-2 layer 3 file into a Wave object</p></a></li>
<li><a href='#readWave'><p>Reading Wave files</p></a></li>
<li><a href='#show-WaveWspec-methods'><p>Showing objects</p></a></li>
<li><a href='#smoother'><p>Meta Function for Smoothers</p></a></li>
<li><a href='#spec2cep'><p> Spectra to Cepstra Conversion</p></a></li>
<li><a href='#summary-methods'><p>Object Summaries</p></a></li>
<li><a href='#updateWave'><p>Update old Wave objects for use with new versions of tuneR</p></a></li>
<li><a href='#Wave'><p>Constructors and coercion for class Wave objects</p></a></li>
<li><a href='#Wave-class'><p>Class Wave</p></a></li>
<li><a href='#Waveforms'><p>Create Wave Objects of Special Waveforms</p></a></li>
<li><a href='#Waveforms-internal'><p>Internal support functions for Waveforms</p></a></li>
<li><a href='#WaveMC'><p>Constructors and coercion for class WaveMC objects</p></a></li>
<li><a href='#WaveMC-class'><p>Class WaveMC</p></a></li>
<li><a href='#WavPlayer'><p>Getting and setting the default player for Wave files</p></a></li>
<li><a href='#writeWave'><p>Writing Wave files</p></a></li>
<li><a href='#Wspec-class'><p>Class Wspec</p></a></li>
<li><a href='#WspecMat-class'><p>Class WspecMat</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.4.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-11-27</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Music and Speech</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Suggests:</td>
<td>pastecs</td>
</tr>
<tr>
<td>Imports:</td>
<td>signal, methods</td>
</tr>
<tr>
<td>Description:</td>
<td>Analyze music and speech, extract features like MFCCs, handle wave files and their representation in various ways, read mp3, read midi, perform steps of a transcription, ...
        Also contains functions ported from the 'rastamat' 'Matlab' package.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-27 13:50:25 UTC; ligges</td>
</tr>
<tr>
<td>Author:</td>
<td>Uwe Ligges <a href="https://orcid.org/0000-0001-5875-6167"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Sebastian Krey [aut, cph],
  Olaf Mersmann [aut, cph],
  Sarah Schnackenberg [aut, cph],
  Guillaume Guénard [aut, cph] (for the 'pulse' functionality),
  Daniel P. W. Ellis [aut, cph] (functions ported from 'rastamat'),
  Underbit Technologies [aut, cph] (for the included 'libmad MPEG audio
    decoder library'),
  Andrea Preusser [ctb],
  Anita Thieler [ctb],
  Johanna Mielke [ctb],
  Claus Weihs [ctb],
  Brian D. Ripley [ctb],
  Matthias Heymann [ctb] (for ideas from the former 'sound' package)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Uwe Ligges &lt;ligges@statistik.tu-dortmund.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-27 15:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='tuneR'>tuneR</h2><span id='topic+tuneR'></span><span id='topic+tuneR-package'></span>

<h3>Description</h3>

<p>tuneR, a collection of examples</p>


<h3>Functions in tuneR</h3>

<p><em>tuneR</em> consists of several functions to work with and to analyze Wave files.
In the following examples, some of the functions 
to generate some data (such as <code><a href="#topic+sine">sine</a></code>),
to read and write Wave files (<code><a href="#topic+readWave">readWave</a></code>, <code><a href="#topic+writeWave">writeWave</a></code>),
to represent or construct (multi channel) Wave files (<code><a href="#topic+Wave">Wave</a></code>, <code><a href="#topic+WaveMC">WaveMC</a></code>),
to transform  Wave objects (<code><a href="#topic+bind">bind</a></code>, <code><a href="#topic+channel">channel</a></code>, 
<code><a href="#topic+downsample">downsample</a></code>, <code><a href="#topic+extractWave">extractWave</a></code>, <code><a href="#topic+mono">mono</a></code>, <code><a href="#topic+stereo">stereo</a></code>),
and to <code><a href="#topic+play">play</a></code> Wave objects are used.
</p>
<p>Other functions and classes are available to 
calculate several periodograms of a signal (<code><a href="#topic+periodogram">periodogram</a></code>, <code><a href="#topic+Wspec">Wspec</a></code>),
to estimate the corresponding fundamental frequencies (<code><a href="#topic+FF">FF</a></code>, <code><a href="#topic+FFpure">FFpure</a></code>),
to derive the corresponding notes (<code><a href="#topic+noteFromFF">noteFromFF</a></code>), 
and to apply a <code><a href="#topic+smoother">smoother</a></code>.
Now, the melody and corresponding energy values can be plotted using the function 
<code><a href="#topic+melodyplot">melodyplot</a></code>.
</p>
<p>A next step is the quantization (<code><a href="#topic+quantize">quantize</a></code>) and a corresponding plot 
(<code><a href="#topic+quantplot">quantplot</a></code>) showing the note values for binned data.
Moreover, a function called <code><a href="#topic+lilyinput">lilyinput</a></code> 
(and a data-preprocessing function <code><a href="#topic+quantMerge">quantMerge</a></code>)
can prepare a data frame to be presented as sheet music by 
postprocessing with the music typesetting software LilyPond.
</p>
<p>Of course, print (show), plot and summary methods are available for most classes.
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges &lt;ligges@statistik.tu-dortmund.de&gt; with contributions
from Sebastian Krey, Olaf Mersmann, Sarah Schnackenberg,
Andrea Preusser, Anita Thieler, and Claus Weihs, as well as code fragments
and ideas from the former package <span class="pkg">sound</span> by Matthias Heymann
and functions from &lsquo;rastamat&rsquo; by Daniel P. W. Ellis.
The included parts of the libmad MPEG audio decoder library are
authored by Underbit Technologies.</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("tuneR") # in a regular session, we are loading tuneR
  
# constructing a mono Wave object (2 sec.) containing sinus 
# sound with 440Hz and folled by 220Hz:
Wobj &lt;- bind(sine(440), sine(220))
show(Wobj)
plot(Wobj) # it does not make sense to plot the whole stuff
plot(extractWave(Wobj, from = 1, to = 500))
## Not run: 
play(Wobj) # listen to the sound

## End(Not run)

tmpfile &lt;- file.path(tempdir(), "testfile.wav")
# write the Wave object into a Wave file (can be played with any player):
writeWave(Wobj, tmpfile)
# reading it in again:
Wobj2 &lt;- readWave(tmpfile)

Wobjm &lt;- mono(Wobj, "left") # extract the left channel
# and downsample to 11025 samples/sec.:
Wobjm11 &lt;- downsample(Wobjm, 11025)
# extract a part of the signal interactively (click for left/right limits):
## Not run: 
Wobjm11s &lt;- extractWave(Wobjm11)

## End(Not run)
# or extract some values reproducibly 
Wobjm11s &lt;- extractWave(Wobjm11, from=1000, to=17000)

# calculating periodograms of sections each consisting of 1024 observations,
# overlapping by 512 observations:
WspecObject &lt;- periodogram(Wobjm11s, normalize = TRUE, width = 1024, overlap = 512)
# Let's look at the first periodogram:
plot(WspecObject, xlim = c(0, 2000), which = 1)
# or a spectrogram
image(WspecObject, ylim = c(0, 1000))
# calculate the fundamental frequency:
ff &lt;- FF(WspecObject)
print(ff)
# derive note from FF given diapason a'=440
notes &lt;- noteFromFF(ff, 440)
# smooth the notes:
snotes &lt;- smoother(notes)
# outcome should be 0 for diapason "a'" and -12 (12 halftones lower) for "a"
print(snotes) 
# plot melody and energy of the sound:
melodyplot(WspecObject, snotes)

# apply some quantization (into 8 parts): 
qnotes &lt;- quantize(snotes, WspecObject@energy, parts = 8) 
# an plot it, 4 parts a bar (including expected values):
quantplot(qnotes, expected = rep(c(0, -12), each = 4), bars = 2)
# now prepare for LilyPond
qlily &lt;- quantMerge(snotes, 4, 4, 2)
qlily
</code></pre>

<hr>
<h2 id='+5B-methods'>Extract or Replace Parts of an Object</h2><span id='topic++5B+2CANY-method'></span>

<h3>Description</h3>

<p>Operators act on objects to extract or replace subsets.</p>


<h3>See Also</h3>

<p><a href="base.html#topic+Extract">Extract</a> for the S3 generic.</p>

<hr>
<h2 id='Arith-methods'>Arithmetics on Waves</h2><span id='topic+Arith+2CWave+2Cmissing-method'></span><span id='topic+Arith+2CWave+2Cnumeric-method'></span><span id='topic+Arith+2CWave+2CWave-method'></span><span id='topic+Arith+2Cnumeric+2CWave-method'></span><span id='topic+Arith+2CWaveMC+2Cnumeric-method'></span><span id='topic+Arith+2CWaveMC+2CWaveMC-method'></span><span id='topic+Arith+2Cnumeric+2CWaveMC-method'></span>

<h3>Description</h3>

<p>Methods for arithmetics on Wave and WaveMC objects</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Wave&quot;</dt><dd><p>An object of class <code><a href="#topic+Wave">Wave</a></code>.</p>
</dd>
<dt>object = &quot;WaveMC&quot;</dt><dd><p>An object of class <code><a href="#topic+WaveMC">WaveMC</a></code>.</p>
</dd>
<dt>object = &quot;numeric&quot;</dt><dd><p>For, e.g., adding a number to the whole Wave, e.g. useful for demeaning.</p>
</dd>
<dt>object = &quot;missing&quot;</dt><dd><p>For unary Wave operations.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p>For the S3 generic: <code><a href="base.html#topic+groupGeneric">groupGeneric</a></code>, <a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code>, <a href="#topic+WaveMC-class">WaveMC-class</a>, <code><a href="#topic+WaveMC">WaveMC</a></code></p>

<hr>
<h2 id='audspec'>Frequency band conversion</h2><span id='topic+audspec'></span>

<h3>Description</h3>

<p>Perform critical band analysis (see PLP), which means the reduction of the
fourier frequencies of a signal's powerspectrum to a reduced number of frequency
bands in an auditory frequency scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>audspec(pspectrum, sr = 16000, nfilts = ceiling(hz2bark(sr/2)) + 1, 
    fbtype = c("bark", "mel", "htkmel", "fcmel"), minfreq = 0, 
    maxfreq = sr/2, sumpower = TRUE, bwidth = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="audspec_+3A_pspectrum">pspectrum</code></td>
<td>
<p> Output of <code><a href="#topic+powspec">powspec</a></code>, matrix with the powerspectrum of each time frame in its columns. </p>
</td></tr>
<tr><td><code id="audspec_+3A_sr">sr</code></td>
<td>
<p> Sample rate of the original recording.  </p>
</td></tr>
<tr><td><code id="audspec_+3A_nfilts">nfilts</code></td>
<td>
<p> Number of filters/frequency bins in the auditory frequency scale. </p>
</td></tr>
<tr><td><code id="audspec_+3A_fbtype">fbtype</code></td>
<td>
<p> Used auditory frequency scale. </p>
</td></tr>
<tr><td><code id="audspec_+3A_minfreq">minfreq</code></td>
<td>
<p> Lowest frequency. </p>
</td></tr>
<tr><td><code id="audspec_+3A_maxfreq">maxfreq</code></td>
<td>
<p> Highest frequency. </p>
</td></tr>
<tr><td><code id="audspec_+3A_sumpower">sumpower</code></td>
<td>
<p> If <code>sumpower = TRUE</code>, the frequency scale transformation is based on the
powerspectrum, if <code>sumpower = FALSE</code>, it is based on its squareroot (absolute value of the spectrum) and
squared afterwards.</p>
</td></tr>
<tr><td><code id="audspec_+3A_bwidth">bwidth</code></td>
<td>
<p> Modify the width of the frequency bands. </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>aspectrum</code></td>
<td>
<p>Matrix with the auditory spectrum of each time frame in its columns.</p>
</td></tr>
<tr><td><code>wts</code></td>
<td>
<p>Weight matrix for the frequency band conversion.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Sebastian Krey <a href="mailto:krey@statistik.tu-dortmund.de">krey@statistik.tu-dortmund.de</a> </p>


<h3>References</h3>

<p>Daniel P. W. Ellis: <a href="https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/">https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+fft2melmx">fft2melmx</a></code>, <code><a href="#topic+fft2barkmx">fft2barkmx</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  testsound &lt;- normalize(sine(400) + sine(1000) + square(250), "16")
  pspectrum &lt;- powspec(testsound@left, testsound@samp.rate)
  aspectrum &lt;- audspec(pspectrum, testsound@samp.rate)
</code></pre>

<hr>
<h2 id='bind'>Concatenating Wave objects</h2><span id='topic+bind'></span><span id='topic+bind+2CWave-method'></span><span id='topic+bind+2CWaveMC-method'></span>

<h3>Description</h3>

<p>Generic function for concatenating objects of class <code>Wave</code> or <code>WaveMC</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind(object, ...)
## S4 method for signature 'Wave'
bind(object, ...)
## S4 method for signature 'WaveMC'
bind(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_+3A_object">object</code>, <code id="bind_+3A_...">...</code></td>
<td>
<p>Objects of class <code><a href="#topic+Wave">Wave</a></code> or class <code><a href="#topic+WaveMC">WaveMC</a></code>, each of the same class and of the same kind (checked by <code><a href="#topic+equalWave">equalWave</a></code>),
i.e. identical sampling rate, resolution (bit), and number of channels (for <code>WaveMC</code>, resp. stereo/mono for <code>Wave</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+Wave">Wave</a></code> or class <code><a href="#topic+WaveMC">WaveMC</a></code> that corresponds to the class of the input.
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a>, Sarah Schnackenberg</p>


<h3>See Also</h3>

<p><code><a href="#topic+prepComb">prepComb</a></code> for preparing the concatenation, <a href="#topic+Wave-class">Wave-class</a>,
<code><a href="#topic+Wave">Wave</a></code>, <a href="#topic+WaveMC-class">WaveMC-class</a>, <code><a href="#topic+WaveMC">WaveMC</a></code>, <code><a href="#topic+extractWave">extractWave</a></code>, <code><a href="#topic+stereo">stereo</a></code></p>

<hr>
<h2 id='channel'>Channel conversion for Wave objects</h2><span id='topic+channel'></span>

<h3>Description</h3>

<p>Convenient wrapper to extract one or more channels (or mirror channels) from an object of class <code>Wave</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>channel(object, which = c("both", "left", "right", "mirror"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="channel_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+Wave">Wave</a></code>.</p>
</td></tr>
<tr><td><code id="channel_+3A_which">which</code></td>
<td>
<p>Character indicating which channel(s) should be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For objects of <a href="#topic+WaveMC-class">WaveMC-class</a>, channel selection can be performed by simple matrix indexing, e.g. <code>WaveMCobject[,2]</code> selects the second channel.</p>


<h3>Value</h3>

<p><code>Wave</code> object including channels specified by <code>which</code>.</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Wave">Wave</a></code>, <a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+mono">mono</a></code>, <code><a href="#topic+extractWave">extractWave</a></code></p>

<hr>
<h2 id='deltas'> Calculate delta features </h2><span id='topic+deltas'></span>

<h3>Description</h3>

<p>Calculate the deltas (derivatives) of a sequence of features using a w-point
window with a simple linear slope.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltas(x, w = 9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deltas_+3A_x">x</code></td>
<td>
<p> Matrix of features. Every column represents one time frame.
Each row is filtered separately. </p>
</td></tr>
<tr><td><code id="deltas_+3A_w">w</code></td>
<td>
<p> Window width (usually odd). </p>
</td></tr>
</table>


<h3>Details</h3>

<p> This function mirrors the delta calculation performed in HTKs &lsquo;feacalc&rsquo;.</p>


<h3>Value</h3>

<p>Returns a matrix of the delta features (one column per frame).
</p>


<h3>Author(s)</h3>

<p> Sebastian Krey <a href="mailto:krey@statistik.tu-dortmund.de">krey@statistik.tu-dortmund.de</a> </p>


<h3>References</h3>

<p>Daniel P. W. Ellis: <a href="https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/">https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>  testsound &lt;- normalize(sine(400) + sine(1000) + square(250), "16")
  m &lt;- melfcc(testsound, frames_in_rows=FALSE)
  d &lt;- deltas(m)
</code></pre>

<hr>
<h2 id='dolpc'> (Perceptive) Linear Prediction </h2><span id='topic+dolpc'></span>

<h3>Description</h3>

<p>Compute autoregressive model from spectral magnitude samples via Levinson-Durbin
recursion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dolpc(x, modelorder = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dolpc_+3A_x">x</code></td>
<td>
<p> Matrix of spectral magnitude samples (each sample/time frame in one
column). </p>
</td></tr>
<tr><td><code id="dolpc_+3A_modelorder">modelorder</code></td>
<td>
<p> Lag of the AR model. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix of the normalized AR coefficients (depending on the input
spectrum: LPC or PLP coefficients). Every column represents one time frame.
</p>


<h3>Author(s)</h3>

<p> Sebastian Krey <a href="mailto:krey@statistik.tu-dortmund.de">krey@statistik.tu-dortmund.de</a> </p>


<h3>References</h3>

<p>Daniel P. W. Ellis: <a href="https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/">https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/</a> </p>


<h3>See Also</h3>

 <p><code><a href="signal.html#topic+levinson">levinson</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  testsound &lt;- normalize(sine(400) + sine(1000) + square(250), "16")
  pspectrum &lt;- powspec(testsound@left, testsound@samp.rate)
  aspectrum &lt;- audspec(pspectrum, testsound@samp.rate)$aspectrum
  lpcas &lt;- dolpc(aspectrum, 10)
</code></pre>

<hr>
<h2 id='downsample'>Downsampling a Wave or WaveMC object</h2><span id='topic+downsample'></span>

<h3>Description</h3>

<p>Downsampling an object of class <code>Wave</code> or class <code>WaveMC</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>downsample(object, samp.rate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downsample_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+Wave">Wave</a></code> or class <code><a href="#topic+WaveMC">WaveMC</a></code>.</p>
</td></tr>
<tr><td><code id="downsample_+3A_samp.rate">samp.rate</code></td>
<td>
<p>Sampling rate the object is to be downsampled to.
<code>samp.rate</code> must be in <code>[2000, 192000]</code>; 
typical values are 11025, 22050, and 44100 for CD quality.
If the <code>object</code>'s sampling rate is already equal or smaller than <code>samp.rate</code>,
the <code>object</code> will be returned unchanged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+Wave">Wave</a></code> or class <code><a href="#topic+WaveMC">WaveMC</a></code>.
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p><a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code>, <a href="#topic+WaveMC-class">WaveMC-class</a>, <code><a href="#topic+WaveMC">WaveMC</a></code></p>

<hr>
<h2 id='equalWave'>Checking Wave objects</h2><span id='topic+equalWave'></span>

<h3>Description</h3>

<p>Internal S4 generic function that checks for some kind of equality of objects of class <code>Wave</code> or class <code>WaveMC</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>equalWave(object1, object2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equalWave_+3A_object1">object1</code>, <code id="equalWave_+3A_object2">object2</code></td>
<td>
<p>Object(s) of class <code><a href="#topic+Wave">Wave</a></code> or class <code><a href="#topic+WaveMC">WaveMC</a></code> (both of the same class).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Does not return anything. 
It <code><a href="base.html#topic+stop">stop</a></code>s code execution with an error message indicating the problem 
if the objects are not of the same class (either <code>Wave</code> oder <code>WaveMC</code>) or if 
the two objects don't have the same properties, i.e.
identical sampling rate, resolution (bit), and number of channels (for <code>WaveMC</code>, resp. stereo/mono for <code>Wave</code>).
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a>, Sarah Schnackenberg</p>


<h3>See Also</h3>

<p><a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code>, <a href="#topic+WaveMC-class">WaveMC-class</a>, <code><a href="#topic+WaveMC">WaveMC</a></code></p>

<hr>
<h2 id='extractWave'>Extractor for Wave and WaveMC objects</h2><span id='topic+extractWave'></span>

<h3>Description</h3>

<p>Extractor function that allows to extract inner parts for <code>Wave</code> or <code>WaveMC</code> objects (interactively).</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractWave(object, from = 1, to = length(object), 
    interact = interactive(), xunit = c("samples", "time"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractWave_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+Wave">Wave</a></code> or class <code><a href="#topic+WaveMC">WaveMC</a></code>.</p>
</td></tr>
<tr><td><code id="extractWave_+3A_from">from</code></td>
<td>
<p>Sample number or time in seconds (see <code>xunit</code>) at which to <em>start</em> extraction.</p>
</td></tr>
<tr><td><code id="extractWave_+3A_to">to</code></td>
<td>
<p>Sample number or time in seconds (see <code>xunit</code>) at which to <em>stop</em> extraction.
If <code>to &lt; from</code>, <code>object</code> will be returned as is.</p>
</td></tr>
<tr><td><code id="extractWave_+3A_interact">interact</code></td>
<td>
<p>Logical indicating whether to choose the range to be extracted interactively (if <code>TRUE</code>). 
See Section Details.</p>
</td></tr>
<tr><td><code id="extractWave_+3A_xunit">xunit</code></td>
<td>
<p>Character indicating which units are used to specify the range to be extracted
(both in arguments <code>from</code> and <code>to</code>, and in the plot, if <code>interact = TRUE</code>).
If <code>xunit = "time"</code>, the unit is time in seconds, otherwise the number of samples.</p>
</td></tr>
<tr><td><code id="extractWave_+3A_...">...</code></td>
<td>
<p>Parameters to be passed to the underlying plot function (<code><a href="stats4.html#topic+plot-methods">plot-methods</a></code>) 
if <code>interact = TRUE</code>.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>This function allows interactive selection of a range to be extracted from an object of class <code><a href="#topic+Wave">Wave</a></code> or class <code><a href="#topic+WaveMC">WaveMC</a></code>.
The default is to use interactive selection if the current R session is <code><a href="base.html#topic+interactive">interactive</a></code>.
In case of interactive selection, <code><a href="stats4.html#topic+plot-methods">plot-methods</a></code> plot the <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code> object,
and the user may click on the starting and ending points of his selection (given neither <code>from</code> nor <code>to</code>
have been specified, see below). 
The cut-points are drawn and the corresponding selection will be returned in form of a <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code> object.
</p>
<p>Setting <code>interact = TRUE</code> in a non-interactive session does not work.
</p>
<p>Setting arguments <code>from</code> or <code>to</code> explicitly means that the specified one 
does not need to be selected interactively, hence only the non-specified one will be selected interactively.
Moreover, setting both <code>from</code> or <code>to</code> implies <code>interact = FALSE</code>.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+Wave">Wave</a></code> or class <code><a href="#topic+WaveMC">WaveMC</a></code>.
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a>, Sarah Schnackenberg</p>


<h3>See Also</h3>

<p><a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code>, <a href="#topic+WaveMC-class">WaveMC-class</a>, <code><a href="#topic+WaveMC">WaveMC</a></code>, <code><a href="#topic+bind">bind</a></code>, <code><a href="#topic+channel">channel</a></code>, <code><a href="#topic+mono">mono</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Wobj &lt;- sine(440)
# extracting the middle 0.5 seconds of that 1 sec. sound:
Wobj2 &lt;- extractWave(Wobj, from = 0.25, to = 0.75, xunit = "time")
Wobj2

## Not run: 
# or interactively:
Wobj2 &lt;- extractWave(Wobj)

## End(Not run)
</code></pre>

<hr>
<h2 id='FF'>Estimation of Fundamental Frequencies from a Wspec object</h2><span id='topic+FF'></span><span id='topic+FFpure'></span>

<h3>Description</h3>

<p>Estimation of Fundamental Frequencies from an object of class <code><a href="#topic+Wspec">Wspec</a></code>.
Additionally, some heuristics are used to distinguish silence, noise (and breathing for singers) 
from real tones.</p>


<h3>Usage</h3>

<pre><code class='language-R'>FF(object, peakheight = 0.01, silence = 0.2, minpeak = 9, diapason = 440, 
    notes = NULL, interest.frqs = seq(along = object@freq),
    search.par = c(0.8, 10, 1.3, 1.7))
    
FFpure(object, peakheight = 0.01, diapason = 440, 
    notes = NULL, interest.frqs = seq(along = object@freq),
    search.par = c(0.8, 10, 1.3, 1.7))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FF_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+Wspec">Wspec</a></code>.</p>
</td></tr>
<tr><td><code id="FF_+3A_peakheight">peakheight</code></td>
<td>
<p>The peak's proportion of the maximal peak height to be 
considered for fundamental frequency detection.
The default (0.01) means peaks smaller than 0.02 times the maximal peak height are omitted.</p>
</td></tr>
<tr><td><code id="FF_+3A_silence">silence</code></td>
<td>
<p>The maximum proportion of periodograms to be considered as silence or noise (such as breathing).
The default (0.2) means that less than 20 out of 100 periodograms represent silence or noise.</p>
</td></tr>
<tr><td><code id="FF_+3A_minpeak">minpeak</code></td>
<td>
<p>If more than <code>minpeak</code> peaks are considered for detection and passed argument <code>peakheight</code>,
such periodograms are detected to be silence or noise (if <code>silence &gt; 0</code>).</p>
</td></tr>
<tr><td><code id="FF_+3A_diapason">diapason</code></td>
<td>
<p>Frequency of diapason a, default is 440 (Hertz).</p>
</td></tr>
<tr><td><code id="FF_+3A_notes">notes</code></td>
<td>
<p>Optional, a vector of integers indicating the notes (in halftones from diapason a)
that are expected. By applying this restriction, the &ldquo;detection error&rdquo; might be reduced in some cases.</p>
</td></tr>
<tr><td><code id="FF_+3A_interest.frqs">interest.frqs</code></td>
<td>
<p>Optional, either a vector of integers indicating the 
indices of (fundamental) frequencies in <code>object</code> that are expected,
or one of the character strings <code>"bass"</code>, <code>"tenor"</code>, <code>"alto"</code> or <code>"soprano"</code>.
For these voice types, only typical frequency ranges are considered for detection.
</p>
<p>By applying this restriction, the &ldquo;detection error&rdquo; might be reduced in some cases.</p>
</td></tr>
<tr><td><code id="FF_+3A_search.par">search.par</code></td>
<td>
<p>Parameters to look for peaks:
</p>

<ol>
<li><p> The first peak larger than <code>peakheight * 'largest_peak'</code> is taken.
</p>
</li>
<li><p> Its frequency is multiplied by <code>1+search.par[1]</code>
Now, any larger peak between the old peak and that value is taken,
if (a) it exists and if (b) it is above the <code>search.par[2]</code>-th Fourier-Frequency.
</p>
</li>
<li><p> Within the interval of frequencies <code>'current peak' * search.par[3:4]</code>,
another high peak is looked for. If any high peak exists in that interval, 
it can be assumed we got the wrong partial and the &lsquo;real&rsquo; fundamental frequency can be re-estimated 
from the next two partials.</p>
</li></ol>
</td></tr>
</table>


<h3>Details</h3>

<p><code>FFpure</code> just estimates the fundamental frequencies for all periodograms contained in the 
<code>object</code> (of class <code><a href="#topic+Wspec">Wspec</a></code>).
</p>
<p><code>FF</code> additionally uses some heuristics to distinguish silence, noise (and breathing for singers) 
from real tones. It is recommended to use the wrapper function <code>FF</code> rather than <code>FFpure</code>.
If silence detecion can be omitted by specifying <code>silence = 0</code>.
</p>


<h3>Value</h3>

<p>Vector of estimated fundamental frequencies (in Hertz) for each periodogram conatined in <code>object</code>.
</p>


<h3>Note</h3>

<p>These functions are still in development and may be changed in due course.</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Wspec">Wspec</a></code>, <code><a href="#topic+periodogram">periodogram</a></code> (including an example), <code><a href="#topic+noteFromFF">noteFromFF</a></code>,
and <a href="#topic+tuneR">tuneR</a> for a very complete example.</p>

<hr>
<h2 id='fftfreqconvmx'>Internal: Convert FFT frequency bins to Bark/Mel bins </h2><span id='topic+fft2barkmx'></span><span id='topic+fft2melmx'></span>

<h3>Description</h3>

<p>Generate a matrix of weights to combine FFT bins into Bark/Mel bins.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fft2barkmx(nfft, sr = 8000, nfilts = NULL, width = 1, minfreq = 0, 
    maxfreq = sr/2)
    
fft2melmx(nfft, sr = 8000, nfilts = 40, width = 1, minfreq = 0, 
    maxfreq = sr/2, htkmel = FALSE, constamp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fftfreqconvmx_+3A_nfft">nfft</code></td>
<td>
<p> Source FFT size. </p>
</td></tr>
<tr><td><code id="fftfreqconvmx_+3A_sr">sr</code></td>
<td>
<p> Sampling rate of the signal. </p>
</td></tr>
<tr><td><code id="fftfreqconvmx_+3A_nfilts">nfilts</code></td>
<td>
<p> Number of desired output frequency bands. If <code>NULL</code> then one
per Bark/Mel between <code>minfreq</code> and <code>maxfreq</code>. </p>
</td></tr>
<tr><td><code id="fftfreqconvmx_+3A_width">width</code></td>
<td>
<p> Width of each output frequency band in Bark/Mel. </p>
</td></tr>
<tr><td><code id="fftfreqconvmx_+3A_minfreq">minfreq</code></td>
<td>
<p> Minimum frequency. </p>
</td></tr>
<tr><td><code id="fftfreqconvmx_+3A_maxfreq">maxfreq</code></td>
<td>
<p> Maximum frequency. </p>
</td></tr>
<tr><td><code id="fftfreqconvmx_+3A_htkmel">htkmel</code></td>
<td>
<p> Use HTK- or Slaney's curve of the Melscale. </p>
</td></tr>
<tr><td><code id="fftfreqconvmx_+3A_constamp">constamp</code></td>
<td>
<p> Make integration windows peak at 1 (<code>constamp=TRUE</code>) or
sum to 1 (<code>constamp=FALSE</code>) </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>wts</code></td>
<td>
<p>The weight matrix with 'nfft' columns and 'nfilts' rows.</p>
</td></tr>
<tr><td><code>binfreqs</code></td>
<td>
<p>Edge frequencies of the bins.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>While wts has nfft columns, the second half are all zero. 
Hence, Bark spectrum is <code>fft2barkmx(nfft, sr) %*% abs(fft(xincols, nfft))</code>.
</p>


<h3>Author(s)</h3>

<p> Sebastian Krey <a href="mailto:krey@statistik.tu-dortmund.de">krey@statistik.tu-dortmund.de</a> </p>


<h3>References</h3>

<p>Daniel P. W. Ellis:
<a href="https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/">https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/</a>, Malcolm
Slaney: Auditory Toolbox
<a href="https://engineering.purdue.edu/~malcolm/interval/1998-010/">https://engineering.purdue.edu/~malcolm/interval/1998-010/</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+hz2bark">hz2bark</a></code>, <code><a href="#topic+hz2mel">hz2mel</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  #Mel matrix in Slaney's mfcc.m:
  #tuneR:::fft2melmx(512, 8000, 40, 1, 133.33, 6855.5, FALSE, FALSE)
</code></pre>

<hr>
<h2 id='freqconv'> Frequency scale conversion </h2><span id='topic+bark2hz'></span><span id='topic+hz2bark'></span><span id='topic+mel2hz'></span><span id='topic+hz2mel'></span>

<h3>Description</h3>

<p>Perform frequency scale conversions between Hertz, Bark- and different variants
von the Melscale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bark2hz(z)
hz2bark(f)
hz2mel(f, htk = FALSE)
mel2hz(z, htk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqconv_+3A_f">f</code></td>
<td>
<p> Frequency in Hertz </p>
</td></tr>
<tr><td><code id="freqconv_+3A_z">z</code></td>
<td>
<p> Frequency in the auditory frequency scale </p>
</td></tr>
<tr><td><code id="freqconv_+3A_htk">htk</code></td>
<td>
<p> Use the HTK-Melscale (<code>htk = TRUE</code>) or Slaney's Melscale from the
Auditory Toolbox (<code>htk = FALSE</code>) </p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the input in the target frequency scale.
</p>


<h3>Author(s)</h3>

<p> Sebastian Krey <a href="mailto:krey@statistik.tu-dortmund.de">krey@statistik.tu-dortmund.de</a> </p>


<h3>References</h3>

<p>Daniel P. W. Ellis:
<a href="https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/">https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/</a>, Malcolm
Slaney: Auditory Toolbox </p>


<h3>Examples</h3>

<pre><code class='language-R'>hz2bark(440)
bark2hz(hz2bark(440))
hz2mel(440, htk = TRUE)
mel2hz(hz2mel(440, htk = TRUE), htk = TRUE)
hz2mel(440, htk = FALSE)
mel2hz(hz2mel(440, htk = FALSE), htk = FALSE)
</code></pre>

<hr>
<h2 id='getMidiNotes'>Extract note events from objects returned by readMidi</h2><span id='topic+getMidiNotes'></span>

<h3>Description</h3>

<p>Extract only note events from an object returned by the <code><a href="#topic+readMidi">readMidi</a></code> function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMidiNotes(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMidiNotes_+3A_x">x</code></td>
<td>
<p>A data.frame returned by the <code><a href="#topic+readMidi">readMidi</a></code> function.</p>
</td></tr>
<tr><td><code id="getMidiNotes_+3A_...">...</code></td>
<td>
<p>Further arguments are passed to the <code><a href="#topic+notenames">notenames</a></code> function for extracting 
the human readable note names rather than their integer representations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>start time</p>
</td></tr>
<tr><td><code>length</code></td>
<td>
<p>length</p>
</td></tr>
<tr><td><code>track</code></td>
<td>
<p>track number</p>
</td></tr>
<tr><td><code>channel</code></td>
<td>
<p>channel number</p>
</td></tr>
<tr><td><code>note</code></td>
<td>
<p>note</p>
</td></tr>
<tr><td><code>notename</code></td>
<td>
<p>notename</p>
</td></tr>
<tr><td><code>velocity</code></td>
<td>
<p>note velocity</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Uwe Ligges and Johanna Mielke</p>


<h3>See Also</h3>

<p><code><a href="#topic+readMidi">readMidi</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>content &lt;- readMidi(system.file("example_files", "Bass_sample.mid", package="tuneR"))
getMidiNotes(content)
</code></pre>

<hr>
<h2 id='length'>S4 generic for length</h2><span id='topic+length+2CWave-method'></span><span id='topic+length+2CWaveMC-method'></span><span id='topic+length+2CANY-method'></span>

<h3>Description</h3>

<p>S4 generic for length.</p>


<h3>Methods</h3>


<dl>
<dt>x = &quot;Wave&quot;</dt><dd><p>The length of the left channel (in samples) of this object of class <code><a href="#topic+Wave">Wave</a></code> will be returned.</p>
</dd>
<dt>x = &quot;WaveMC&quot;</dt><dd><p>The length for each of the time series in the <code><a href="#topic+WaveMC">WaveMC</a></code> will be returned.</p>
</dd>
<dt>object = &quot;ANY&quot;</dt><dd><p>For compatibility.</p>
</dd>
</dl>


<h3>See Also</h3>

<p>For the primitive: <code><a href="base.html#topic+length">length</a></code></p>

<hr>
<h2 id='lifter'> Liftering of cepstra </h2><span id='topic+lifter'></span>

<h3>Description</h3>

<p>Apply liftering to a matrix of cepstra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lifter(x, lift = 0.6, inv = FALSE, htk = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lifter_+3A_x">x</code></td>
<td>
<p> Matrix of cepstra, one sample/time frame per column. </p>
</td></tr>
<tr><td><code id="lifter_+3A_lift">lift</code></td>
<td>
<p> Liftering exponent/length. </p>
</td></tr>
<tr><td><code id="lifter_+3A_inv">inv</code></td>
<td>
<p> Invert the liftering (undo a previous liftering). </p>
</td></tr>
<tr><td><code id="lifter_+3A_htk">htk</code></td>
<td>
<p> Switch liftering type. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>htk = FALSE</code>, then perform <code class="reqn">x i^lift</code>, <code class="reqn">i = 1, \ldots,</code> <code>nrow(x)</code>
liftering. If <code>htk = TRUE</code>, then perform HTK-style sin-curve
liftering with length <code>lift</code>.
</p>


<h3>Value</h3>

<p>Matrix of the liftered cepstra.
</p>


<h3>Author(s)</h3>

<p> Sebastian Krey <a href="mailto:krey@statistik.tu-dortmund.de">krey@statistik.tu-dortmund.de</a> </p>


<h3>References</h3>

<p>Daniel P. W. Ellis: <a href="https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/">https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  testsound &lt;- normalize(sine(400) + sine(1000) + square(250), "16")
  m &lt;- melfcc(testsound, frames_in_rows=FALSE)
  unlm &lt;- lifter(m, inv=TRUE)
</code></pre>

<hr>
<h2 id='lilyinput'>Providing LilyPond compatible input</h2><span id='topic+lilyinput'></span>

<h3>Description</h3>

<p>A function <em>(in development!)</em> that writes a file to be processed by <em>LilyPond</em>
by extracting the relevant information (e.g. pitch, length, ...) from columns of a data frame.
The music notation software <em>LilyPond</em> can &ldquo;transcribe&rdquo; such an input file into sheet music.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lilyinput(X, file = "Rsong.ly", Major = TRUE, key = "c", 
    clef = c("treble", "bass", "alto", "tenor"), time = "4/4", 
    endbar = TRUE, midi = TRUE, tempo = "2 = 60", 
    textheight = 220, linewidth = 150, indent = 0, fontsize = 14)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lilyinput_+3A_x">X</code></td>
<td>
<p>A data frame containing 4 named components (columns):
</p>

<ul>
<li> <p><code>note</code>: Integer - the notes' pitch in halftones from diapason (a),
i.e. 0 for diapason a, 3 for c', ...
</p>
</li>
<li> <p><code>duration</code>: Integer - denominator of lengths of the notes, e.g. 8 for a quaver.
</p>
</li>
<li> <p><code>punctate</code>: Logical - whether to punctate a note.
</p>
</li>
<li> <p><code>slur</code>: Logical - <code>TRUE</code> indicates to start a slur, or to end it.
That means that the first, third, ... occurences of <code>TRUE</code> start slurps,
while the second, fourth, ... occurences end slurps.
Note that it is only possible to draw one slur at a time.
</p>
</li></ul>

</td></tr>
<tr><td><code id="lilyinput_+3A_file">file</code></td>
<td>
<p>The file to be written for <em>LilyPond</em>'s input.</p>
</td></tr>
<tr><td><code id="lilyinput_+3A_major">Major</code></td>
<td>
<p>Logical indicating major key (if <code>TRUE</code>) or minor key.</p>
</td></tr>
<tr><td><code id="lilyinput_+3A_key">key</code></td>
<td>
<p>Keynote, necessary to set sharps/flats.</p>
</td></tr>
<tr><td><code id="lilyinput_+3A_clef">clef</code></td>
<td>
<p>Integer indicating the kind of clef, supported are <code>"treble"</code> (default),
<code>"bass"</code>, <code>"alto"</code>, and <code>"tenor"</code>.</p>
</td></tr>
<tr><td><code id="lilyinput_+3A_time">time</code></td>
<td>
<p>Character indicating which meter to use, examples are: <code>"3/4"</code>, <code>"4/4"</code>.</p>
</td></tr>
<tr><td><code id="lilyinput_+3A_endbar">endbar</code></td>
<td>
<p>Logical indicating whether to set an ending bar at the end of the sheet music.</p>
</td></tr>
<tr><td><code id="lilyinput_+3A_midi">midi</code></td>
<td>
<p>Logical indicating whether Midi output (by <em>LilyPond</em>) is desirable.</p>
</td></tr>
<tr><td><code id="lilyinput_+3A_tempo">tempo</code></td>
<td>
<p>Character specifying the tempo to be used for the Midi file if <code>midi = TRUE</code>.
The default, <code>"2 = 60"</code> indicates: 60 half notes per minute, whereas <code>"4 = 90"</code>
indicates 90 quarters per minute.</p>
</td></tr>
<tr><td><code id="lilyinput_+3A_textheight">textheight</code></td>
<td>
<p>Textheight of the sheet music to be written by <em>LilyPond</em>.</p>
</td></tr>
<tr><td><code id="lilyinput_+3A_linewidth">linewidth</code></td>
<td>
<p>Linewidth of the sheet music to be written by <em>LilyPond</em>.</p>
</td></tr>
<tr><td><code id="lilyinput_+3A_indent">indent</code></td>
<td>
<p>Indentation of the sheet music to be written by <em>LilyPond</em>.</p>
</td></tr>
<tr><td><code id="lilyinput_+3A_fontsize">fontsize</code></td>
<td>
<p>Fontsize of the sheet music to be written by <em>LilyPond</em>.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Details will be given when development has reached a stable stage ...!
</p>


<h3>Value</h3>

<p>Nothing is returned, but a <code>file</code> is written.
</p>


<h3>Note</h3>

<p>This function is in development!!!<br />
Everything (and in particular its user interface) is subject to change!!!
</p>


<h3>Author(s)</h3>

<p>Andrea Preußer and Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>References</h3>

<p>The LilyPond development team (2005):
<em>LilyPond - The music typesetter</em>.
<a href="https://lilypond.org/">https://lilypond.org/</a>, Version 2.7.20.
</p>
<p>Preußer, A., Ligges, U. und Weihs, C. (2002): 
<em>Ein R Exportfilter für das Notations- und Midi-Programm LilyPond</em>.   
Arbeitsbericht 35. Fachbereich Statistik, Universität Dortmund. (german)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+quantMerge">quantMerge</a></code> prepares the data to be written into the LilyPond format;
<code><a href="#topic+quantize">quantize</a></code> and <code><a href="#topic+quantplot">quantplot</a></code> generate another kind of plot;
and exhaustive example is given in <a href="#topic+tuneR">tuneR</a>.</p>

<hr>
<h2 id='lpc2cep'> LPC to cepstra conversion </h2><span id='topic+lpc2cep'></span>

<h3>Description</h3>

<p>Convert the LPC coefficients in each column of <code>a</code> into frames of cepstra.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpc2cep(a, nout = nrow(a))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpc2cep_+3A_a">a</code></td>
<td>
<p> Matrix of LPC coefficients. </p>
</td></tr>
<tr><td><code id="lpc2cep_+3A_nout">nout</code></td>
<td>
<p> Number of cepstra to produce. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of cepstra (one column per time frame).
</p>


<h3>Author(s)</h3>

<p> Sebastian Krey <a href="mailto:krey@statistik.tu-dortmund.de">krey@statistik.tu-dortmund.de</a> </p>


<h3>References</h3>

<p>Daniel P. W. Ellis: <a href="https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/">https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+spec2cep">spec2cep</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  testsound &lt;- normalize(sine(400) + sine(1000) + square(250), "16")
  pspectrum &lt;- powspec(testsound@left, testsound@samp.rate)
  aspectrum &lt;- audspec(pspectrum, testsound@samp.rate)
  lpcas &lt;- dolpc(aspectrum$aspectrum, 8)
  cepstra &lt;- lpc2cep(lpcas)
</code></pre>

<hr>
<h2 id='MCnames'>Default channel ordering for multi channel wave files</h2><span id='topic+MCnames'></span>

<h3>Description</h3>

<p>A data frame representing the default channel ordering with id, descriptive label, and abbreviated name for multi channel wave files.</p>


<h3>Format</h3>

<p>A data frame with 18 observations on the following 3 variables:
</p>

<dl>
<dt><code>id</code></dt><dd><p>id of the channel</p>
</dd>
<dt><code>label</code></dt><dd><p>full label for the channel</p>
</dd>
<dt><code>name</code></dt><dd><p>abbreviated name for the channel</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data derived from the technical documentation given at <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ksmedia/ns-ksmedia-waveformatextensible">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ksmedia/ns-ksmedia-waveformatextensible</a>.</p>


<h3>References</h3>

<p>Microsoft Corporation (2018): WAVEFORMATEXTENSIBLE structure, <a href="https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ksmedia/ns-ksmedia-waveformatextensible">https://docs.microsoft.com/en-us/windows-hardware/drivers/ddi/content/ksmedia/ns-ksmedia-waveformatextensible</a>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>MCnames # the 18 predefined channels in a multi channel Wave file (WaveMC object)
</code></pre>

<hr>
<h2 id='melfcc'> MFCC Calculation </h2><span id='topic+melfcc'></span>

<h3>Description</h3>

<p>Calculate Mel-frequency cepstral coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>melfcc(samples, sr = samples@samp.rate, wintime = 0.025, 
    hoptime = 0.01, numcep = 12, lifterexp = 0.6, htklifter = FALSE,
    sumpower = TRUE, preemph = 0.97, dither = FALSE,
    minfreq = 0, maxfreq = sr/2, nbands = 40, bwidth = 1, 
    dcttype = c("t2", "t1", "t3", "t4"), 
    fbtype = c("mel", "htkmel", "fcmel", "bark"), usecmp = FALSE, 
    modelorder = NULL, spec_out = FALSE, frames_in_rows = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melfcc_+3A_samples">samples</code></td>
<td>
<p> Object of <a href="#topic+Wave-class">Wave-class</a> or <a href="#topic+WaveMC-class">WaveMC-class</a>. Only the first channel will be used.</p>
</td></tr>
<tr><td><code id="melfcc_+3A_sr">sr</code></td>
<td>
<p> Sampling rate of the signal. </p>
</td></tr>
<tr><td><code id="melfcc_+3A_wintime">wintime</code></td>
<td>
<p> Window length in sec. </p>
</td></tr>
<tr><td><code id="melfcc_+3A_hoptime">hoptime</code></td>
<td>
<p> Step between successive windows in sec. </p>
</td></tr>
<tr><td><code id="melfcc_+3A_numcep">numcep</code></td>
<td>
<p> Number of cepstra to return. </p>
</td></tr>
<tr><td><code id="melfcc_+3A_lifterexp">lifterexp</code></td>
<td>
<p> Exponent for liftering; 0 = none. </p>
</td></tr>
<tr><td><code id="melfcc_+3A_htklifter">htklifter</code></td>
<td>
<p> Use HTK sin lifter. </p>
</td></tr>
<tr><td><code id="melfcc_+3A_sumpower">sumpower</code></td>
<td>
<p> If <code>sumpower = TRUE</code> the frequency scale transformation is based on the
powerspectrum, if <code>sumpower = FALSE</code> it is based on its squareroot (absolute value of the spectrum) and
squared afterwards. 

</p>
</td></tr>
<tr><td><code id="melfcc_+3A_preemph">preemph</code></td>
<td>
<p> Apply pre-emphasis filter [1 -preemph] (0 = none). </p>
</td></tr>
<tr><td><code id="melfcc_+3A_dither">dither</code></td>
<td>
<p> Add offset to spectrum as if dither noise. </p>
</td></tr>
<tr><td><code id="melfcc_+3A_minfreq">minfreq</code></td>
<td>
<p> Lowest band edge of mel filters (Hz). </p>
</td></tr>
<tr><td><code id="melfcc_+3A_maxfreq">maxfreq</code></td>
<td>
<p> Highest band edge of mel filters (Hz). </p>
</td></tr>
<tr><td><code id="melfcc_+3A_nbands">nbands</code></td>
<td>
<p> Number of warped spectral bands to use. </p>
</td></tr>
<tr><td><code id="melfcc_+3A_bwidth">bwidth</code></td>
<td>
<p> Width of spectral bands in Bark/Mel. </p>
</td></tr>
<tr><td><code id="melfcc_+3A_dcttype">dcttype</code></td>
<td>
<p> Type of DCT used - 1 or 2 (or 3 for HTK or 4 for feacalc). </p>
</td></tr>
<tr><td><code id="melfcc_+3A_fbtype">fbtype</code></td>
<td>
<p> Auditory frequency scale to use: <code>"mel"</code>,
<code>"bark"</code>, <code>"htkmel"</code>, <code>"fcmel"</code>. </p>
</td></tr>
<tr><td><code id="melfcc_+3A_usecmp">usecmp</code></td>
<td>
<p> Apply equal-loudness weighting and cube-root compression (PLP
instead of LPC). </p>
</td></tr>
<tr><td><code id="melfcc_+3A_modelorder">modelorder</code></td>
<td>
<p> If <code>modelorder &gt; 0</code>, fit a linear prediction (autoregressive-) model of this order and
calculation of cepstra out of <code>lpcas</code>. </p>
</td></tr>
<tr><td><code id="melfcc_+3A_spec_out">spec_out</code></td>
<td>
<p> Should matrices of the power- and the auditory-spectrum be
returned.</p>
</td></tr>
<tr><td><code id="melfcc_+3A_frames_in_rows">frames_in_rows</code></td>
<td>
<p> Return time frames in rows instead of columns (original Matlab code).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculation of the MFCCs imlcudes the following steps:
</p>

<ol>
<li><p>Preemphasis filtering
</p>
</li>
<li><p>Take the absolute value of the STFT (usage of Hamming window)
</p>
</li>
<li><p>Warp to auditory frequency scale (Mel/Bark)
</p>
</li>
<li><p>Take the DCT of the log-auditory-spectrum
</p>
</li>
<li><p>Return the first &lsquo;ncep&rsquo; components
</p>
</li></ol>



<h3>Value</h3>

<table>
<tr><td><code>cepstra</code></td>
<td>
<p>Cepstral coefficients of the input signal (one time frame per
row/column)</p>
</td></tr>
<tr><td><code>aspectrum</code></td>
<td>
<p>Auditory spectrum (spectrum after transformation to Mel/Bark
scale) of the signal</p>
</td></tr>
<tr><td><code>pspectrum</code></td>
<td>
<p>Power spectrum of the input signal.</p>
</td></tr>
<tr><td><code>lpcas</code></td>
<td>
<p>If <code>modelorder &gt; 0</code>, the linear prediction coefficients (LPC/PLP).</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The following non-default values nearly duplicate Malcolm Slaney's mfcc (i.e. 
</p>
<pre>
melfcc(d, 16000, wintime=0.016, lifterexp=0, minfreq=133.33, 
       maxfreq=6855.6, sumpower=FALSE)
</pre>
<p>=~= <code>log(10) * 2 * mfcc(d, 16000)</code> in the Auditory toolbox for Matlab).
</p>
<p>The following non-default values nearly duplicate HTK's MFCC (i.e. 
</p>
<pre>
melfcc(d, 16000, lifterexp=22, htklifter=TRUE, nbands=20, maxfreq=8000, 
    sumpower=FALSE, fbtype="htkmel", dcttype="t3")
</pre> 
<p>=~= <code>2 * htkmelfcc(:,[13,[1:12]])</code>
where HTK config has &lsquo;PREEMCOEF = 0.97&rsquo;, &lsquo;NUMCHANS = 20&rsquo;,
&lsquo;CEPLIFTER = 22&rsquo;, &lsquo;NUMCEPS = 12&rsquo;, &lsquo;WINDOWSIZE = 250000.0&rsquo;, &lsquo;USEHAMMING = T&rsquo;,
&lsquo;TARGETKIND = MFCC_0&rsquo;).
</p>
<p>For more detail on reproducing other programs' outputs, see
<a href="https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/mfccs.html">https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/mfccs.html</a>
</p>


<h3>Author(s)</h3>

<p> Sebastian Krey <a href="mailto:krey@statistik.tu-dortmund.de">krey@statistik.tu-dortmund.de</a> </p>


<h3>References</h3>

<p>Daniel P. W. Ellis: <a href="https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/">https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  testsound &lt;- normalize(sine(400) + sine(1000) + square(250), "16")
  m1 &lt;- melfcc(testsound)

  #Use PLP features to calculate cepstra and output the matrices like the
  #original Matlab code (note: modelorder limits the number of cepstra)
  m2 &lt;- melfcc(testsound, numcep=9, usecmp=TRUE, modelorder=8, 
    spec_out=TRUE, frames_in_rows=FALSE)
</code></pre>

<hr>
<h2 id='melodyplot'>Plotting a melody</h2><span id='topic+melodyplot'></span>

<h3>Description</h3>

<p>Plot a observed melody and (optional) an expected melody, 
as well as corresponding energy values (corresponding to the loudness of the sound).</p>


<h3>Usage</h3>

<pre><code class='language-R'>melodyplot(object, observed, expected = NULL, bars = NULL, 
    main = NULL, xlab = NULL, ylab = "note", xlim = NULL, ylim = NULL, 
    observedtype = "l", observedcol = "red", expectedcol = "grey", 
    gridcol = "grey", lwd = 2, las = 1, cex.axis = 0.9, 
    mar = c(5, 4, 4, 4) + 0.1, notenames = NULL, thin = 1, 
    silence = "silence", plotenergy = TRUE, ...,
    axispar = list(ax1 = list(side=1),
                   ax2 = list(side=2), 
                   ax4 = list(side=4)),
    boxpar = list(), 
    energylabel = list(text="energy", side=4, line=2.5, at=rg.s-0.25, las=3),
    energypar = list(), 
    expectedpar = list(),
    gridpar = list(col=gridcol), 
    observedpar = list(col=observedcol, type=observedtype, lwd=2, pch=15))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="melodyplot_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+Wspec">Wspec</a></code>.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_observed">observed</code></td>
<td>
<p>Observed notes, probably as a result from <code><a href="#topic+noteFromFF">noteFromFF</a></code> (or a smoothed version).
This should correspond to the <code><a href="#topic+Wspec">Wspec</a></code> <code>object</code>.
It can also be a matrix of <code>k</code> columns where those <code>k</code> notes in the same row 
are displayed at the same timepoint.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_expected">expected</code></td>
<td>
<p>Expected notes (optional; in order to compare results), same format as <code>observed</code>.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_bars">bars</code></td>
<td>
<p>Number of bars to be plotted (a virtual static segmentation takes place).
If <code>NULL</code> (default), time rather than bars are used.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_main">main</code></td>
<td>
<p>Main title of the plot.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_xlab">xlab</code>, <code id="melodyplot_+3A_ylab">ylab</code></td>
<td>
<p>Annotation of -/y-axes.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_xlim">xlim</code>, <code id="melodyplot_+3A_ylim">ylim</code></td>
<td>
<p>Range of x-/y-axis, where <code>ylim</code> must be an integer 
that represents the range of note heights that should be displayed.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_observedtype">observedtype</code></td>
<td>
<p>Type (either <code>"p"</code> for points or <code>"l"</code> for lines) 
used for representing observed notes. 
<code>"l"</code> (the default) is not sensible for polyphonic representations.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_observedcol">observedcol</code></td>
<td>
<p>Colour for the observed melody.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_expectedcol">expectedcol</code></td>
<td>
<p>Colour for the expected melody.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_gridcol">gridcol</code></td>
<td>
<p>Colour of the grid.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_lwd">lwd</code></td>
<td>
<p>Line width, see <code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_las">las</code></td>
<td>
<p>Orientation of axis labels, see <code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Size of tick mark labels, see <code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_mar">mar</code></td>
<td>
<p>Margins of the plot, see <code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_notenames">notenames</code></td>
<td>
<p>Optionally specify other notenames (character) for the y axis.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_thin">thin</code></td>
<td>
<p>Amount of thinning of notenames, i.e. only each <code>thin</code>th notename is displayed on the y-axis.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_silence">silence</code></td>
<td>
<p>Character string for label of the &lsquo;silence&rsquo; (default) axis.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_plotenergy">plotenergy</code></td>
<td>
<p>Logical (default: <code>TRUE</code>), 
whether to plot energy values in the bottom part of the plot.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters to be passed to underlying <code>plot</code> function.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_axispar">axispar</code></td>
<td>
<p>A named list of three other lists (<code>ax1</code>, <code>ax2</code>, and <code>ax4</code>)
containing parameters passed to the corresponding <code><a href="graphics.html#topic+axis">axis</a></code> calls for the three axis
time (<code>ax1</code>), notes (<code>ax2</code>), and energy (<code>ax4</code>).</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_boxpar">boxpar</code></td>
<td>
<p>A list of parameters to be passed to the box generating functions.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_energylabel">energylabel</code></td>
<td>
<p>A list of parameters to be passed to the energy-label 
generating <code><a href="graphics.html#topic+mtext">mtext</a></code> call.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_energypar">energypar</code></td>
<td>
<p>A list of parameters to be passed to the <code><a href="graphics.html#topic+lines">lines</a></code> function that draws the energy curve.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_expectedpar">expectedpar</code></td>
<td>
<p>A list of parameters to be passed to the <code><a href="graphics.html#topic+rect">rect</a></code> 
function that draws the rectangles for expected values.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_gridpar">gridpar</code></td>
<td>
<p>A list of parameters to be passed to the <code><a href="graphics.html#topic+abline">abline</a></code> 
function that draws the grid lines.</p>
</td></tr>
<tr><td><code id="melodyplot_+3A_observedpar">observedpar</code></td>
<td>
<p>A list of parameters to be passed to the <code><a href="graphics.html#topic+lines">lines</a></code> 
function that draws the observed values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+noteFromFF">noteFromFF</a></code>, <code><a href="#topic+FF">FF</a></code>, <code><a href="#topic+quantplot">quantplot</a></code>; 
for an example, see the help in <a href="#topic+tuneR">tuneR</a>.</p>

<hr>
<h2 id='Mono-Stereo'>Converting (extracting, joining) stereo to mono and vice versa</h2><span id='topic+mono'></span><span id='topic+stereo'></span>

<h3>Description</h3>

<p>Functions to extract a channel from a stereo <code>Wave</code> object,
and to join channels of two monophonic <code>Wave</code> objects to a stereophonic one.</p>


<h3>Usage</h3>

<pre><code class='language-R'>mono(object, which = c("left", "right", "both"))
stereo(left, right)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mono-Stereo_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+Wave">Wave</a></code>.</p>
</td></tr>
<tr><td><code id="Mono-Stereo_+3A_which">which</code></td>
<td>
<p>Character, indicating whether the &ldquo;left&rdquo; or &ldquo;right&rdquo; channel should be extracted,
or whether &ldquo;both&rdquo; channels should be averaged.</p>
</td></tr>
<tr><td><code id="Mono-Stereo_+3A_left">left</code></td>
<td>
<p>Object of class <code><a href="#topic+Wave">Wave</a></code> containing <code>mono</code>phonic sound,
to be used for the left channel.</p>
</td></tr>
<tr><td><code id="Mono-Stereo_+3A_right">right</code></td>
<td>
<p>Object of class <code><a href="#topic+Wave">Wave</a></code> containing <code>mono</code>phonic sound,
to be used for the right channel (if missing, the <code>left</code> channel is duplicated).
If <code>right</code> is missing, <code>stereo</code> returns whether <code>left</code> is 
stereo (<code>TRUE</code>) or mono (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For objects of <a href="#topic+WaveMC-class">WaveMC-class</a>, a mono channel can be created by simple matrix indexing, e.g. <code>WaveMCobject[,2]</code> selects the second channel.</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+Wave">Wave</a></code>.
</p>
<p>If argument <code>right</code> is missing in <code>stereo</code>, a logical values is returned 
that indicates whether <code>left</code> is stereo (<code>TRUE</code>) or mono (<code>FALSE</code>).
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p><a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Wobj &lt;- sine(440)
Wobj
Wobj2 &lt;- stereo(Wobj, Wobj)
Wobj2
mono(Wobj2, "right")
</code></pre>

<hr>
<h2 id='nchannel'>Number of channels</h2><span id='topic+nchannel'></span><span id='topic+nchannel+2CWave-method'></span><span id='topic+nchannel+2CWaveMC-method'></span>

<h3>Description</h3>

<p>Get the number of channels from a Wave or WaveMC object</p>


<h3>Usage</h3>

<pre><code class='language-R'>nchannel(object)
## S4 method for signature 'Wave'
nchannel(object)
## S4 method for signature 'WaveMC'
nchannel(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nchannel_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+Wave">Wave</a></code> or class <code><a href="#topic+WaveMC">WaveMC</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer, the number of channels given in the object.</p>


<h3>See Also</h3>

<p><a href="#topic+Wave-class">Wave-class</a>, <a href="#topic+WaveMC-class">WaveMC-class</a></p>

<hr>
<h2 id='normalize-methods'>Rescale the range of values</h2><span id='topic+normalize'></span><span id='topic+normalize+2CWave-method'></span><span id='topic+normalize+2CWaveMC-method'></span>

<h3>Description</h3>

<p>Centering and rescaling the waveform of a <code>Wave</code> or <code>WaveMC</code> object to a canonical interval 
corresponding to the Wave format (e.g. [-1, 1], [0, 254], 
[-32767, 32767], [-8388607, 8388607], or [-2147483647, 2147483647]).</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(object, unit = c("1", "8", "16", "24", "32", "64", "0"), 
    center = TRUE, level = 1, rescale = TRUE, pcm = object@pcm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize-methods_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code>.</p>
</td></tr>
<tr><td><code id="normalize-methods_+3A_unit">unit</code></td>
<td>
<p>Unit to rescale to.<br />
<code>"1"</code> (default) for rescaling to numeric values in [-1, 1],<br />
<code>"8"</code> (i.e. 8-bit) for rescaling to integers in [0, 254],<br />
<code>"16"</code> (i.e. 16-bit) for rescaling to integers in [-32767, 32767],<br />
<code>"24"</code> (i.e. 24-bit) for rescaling to integers in [-8388607, 8388607],<br />
<code>"32"</code> (i.e. 32-bit) for rescaling either to integers in [-2147483647, 2147483647] 
(PCM Wave format if <code>pcm=TRUE</code>) or to numeric values in [-1, 1] 
(FLOAT_IEEE Wave format if <code>pcm = FALSE</code>),<br />
<code>"64"</code> (i.e. 64-bit) for rescaling to real values in [-1, 1] (FLOAT_IEEE Wave format), and<br />
<code>"0"</code> for not rescaling (hence only centering if <code>center = TRUE</code>).</p>
</td></tr>
<tr><td><code id="normalize-methods_+3A_center">center</code></td>
<td>
<p>If <code>TRUE</code> (default), values are centered around 0 (or 127 if <code>unit = "8"</code>).</p>
</td></tr>
<tr><td><code id="normalize-methods_+3A_level">level</code></td>
<td>
<p>Maximal percentage of the amplitude used for normalizing (default is 1).</p>
</td></tr> 
<tr><td><code id="normalize-methods_+3A_rescale">rescale</code></td>
<td>
<p>Logical, whether to rescale to the maximal possible dynamic range.</p>
</td></tr>
<tr><td><code id="normalize-methods_+3A_pcm">pcm</code></td>
<td>
<p>Logical. By default, the <code>pcm</code> information from the <code>object</code> is kept.
Otherwise, if <code>TRUE</code>, the object is coerced to the PCM Wave format. If <code>FALSE</code>, the object is coerced to the FLOAT_IEEE format, i.e. numeric values in [-1, 1].</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object containing the normalized data of the same class as the input <code>object</code>, 
i.e. either <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code>.
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a>, Sarah Schnackenberg,
based on code from Matthias Heymann's former package &lsquo;sound&rsquo;.</p>


<h3>See Also</h3>

<p><code><a href="#topic+writeWave">writeWave</a></code>, <a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code>, <a href="#topic+WaveMC-class">WaveMC-class</a>, <code><a href="#topic+WaveMC">WaveMC</a></code></p>

<hr>
<h2 id='noSilence'>Cut off silence from a Wave or WaveMC object</h2><span id='topic+noSilence'></span><span id='topic+noSilence+2CWave-method'></span><span id='topic+noSilence+2CWaveMC-method'></span>

<h3>Description</h3>

<p>Generic function to cut off silence or low noise at the beginning and/or at the end of an object of class <code>Wave</code> or class <code>WaveMC</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>noSilence(object, zero = 0, level = 0, where = c("both", "start", "end"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noSilence_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+Wave">Wave</a></code> or class <code><a href="#topic+WaveMC">WaveMC</a></code>.</p>
</td></tr>
<tr><td><code id="noSilence_+3A_zero">zero</code></td>
<td>
<p>The zero level (default: 0) at which ideal cut points are determined (see Details).
A typical alternative would be 127 for 8 bit <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code> objects.
If <code>zero = NA</code>, the mean of the left Wave channel (for <code>Wave</code>, resp. the mean of the first channel for <code>WaveMC</code>) is taken as zero level.</p>
</td></tr>
<tr><td><code id="noSilence_+3A_level">level</code></td>
<td>
<p>Values in the interval between <code>zero</code> and <code>zero - level</code>/<code>zero + level</code>
are considered as silence.</p>
</td></tr>  
<tr><td><code id="noSilence_+3A_where">where</code></td>
<td>
<p>One of <code>"both"</code> (default), <code>"start"</code>, or <code>"end"</code>
indicating at <code>where</code> to prepare the <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code> object for concatenation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Silcence is removed at the locations given by <code>where</code> of the <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code> object,
where silence is defined such that (in both channels if stereo, in all channels if multichannel for <code>WaveMC</code>) all values are in 
the interval between <code>zero - level</code> and <code>zero + level</code>.
All values before (or after, respectively) the first non-silent value are removed from the object.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code>.
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a>, Sarah Schnackenberg,
based on code from Matthias Heymann's former package &lsquo;sound&rsquo;.</p>


<h3>See Also</h3>

<p><code><a href="#topic+silence">silence</a></code>, <a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code>, <a href="#topic+WaveMC-class">WaveMC-class</a>, <code><a href="#topic+WaveMC">WaveMC</a></code>, <code><a href="#topic+extractWave">extractWave</a></code></p>

<hr>
<h2 id='noteFromFF'>Deriving notes from frequencies</h2><span id='topic+noteFromFF'></span>

<h3>Description</h3>

<p>Deriving notes from given (fundamental) frequencies.</p>


<h3>Usage</h3>

<pre><code class='language-R'>noteFromFF(x, diapason = 440, roundshift = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="noteFromFF_+3A_x">x</code></td>
<td>
<p>Fundamental frequency.</p>
</td></tr>
<tr><td><code id="noteFromFF_+3A_diapason">diapason</code></td>
<td>
<p>Frequency of diapason a, default is 440 (Hertz).</p>
</td></tr>
<tr><td><code id="noteFromFF_+3A_roundshift">roundshift</code></td>
<td>
<p>Shift that indicates from here to round to the next integer (note).
The default (0) is &ldquo;classical&rdquo; rounding as described in <code><a href="base.html#topic+round">round</a></code>.
A higher value means that <code>roundshift</code> is added to the calculated real note value
before rounding to an integer. This is useful if it is unclear that some instruments really 
shift the note in the center between two theoretical frequencies.
</p>
<p>Example: if <code>x = 452</code> and <code>diapason = 440</code>, the internally calculated 
real value of 0.46583 is rounded to 0,
but for <code>roundshift = 0.1</code> we get 0.56583 and it is rounded to note 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The formula used is simply <code>round(12 * log(x / diapason, 2) + roundshift)</code>.</p>


<h3>Value</h3>

<p>An integer representing the (rounded) difference in halftones from diapason a,
i.e. indicating the note that corresponds to fundamental frequency <code>x</code> given the value of <code>diapason</code>.
For example: 0 indicates diapason a, 3: c', 12: a', ...
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+FF">FF</a></code>, <code><a href="#topic+periodogram">periodogram</a></code>, and <a href="#topic+tuneR">tuneR</a> for a very complete example.</p>

<hr>
<h2 id='notenames'>Generating note names from numbers</h2><span id='topic+notenames'></span>

<h3>Description</h3>

<p>A function that generates note names from numbers</p>


<h3>Usage</h3>

<pre><code class='language-R'>notenames(notes, language = c("english", "german"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="notenames_+3A_notes">notes</code></td>
<td>
<p>An interger values vector, where 0 corresponds to <kbd>a'</kbd>, 
notes below and above have to be specified in the corresponding halftone distance.</p>
</td></tr>
<tr><td><code id="notenames_+3A_language">language</code></td>
<td>
<p>Language of the note names. Currently only english and german are supported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of note names.
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>notenames(c(-24, -12, 0, 12)) # octaves of a
notenames(3:15)               # chromaticism

## same in german:
notenames(3:15, language = "german")
</code></pre>

<hr>
<h2 id='panorama'>Narrow the Panorama of a Stereo Sample</h2><span id='topic+panorama'></span><span id='topic+panorama+2CWave-method'></span><span id='topic+panorama+2CWaveMC-method'></span>

<h3>Description</h3>

<p>Generic function to narrow the panorama of a stereo <code>Wave</code> or <code>WaveMC</code> object.</p>


<h3>Usage</h3>

<pre><code class='language-R'>panorama(object, pan = 1)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panorama_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+Wave">Wave</a></code> or class <code><a href="#topic+WaveMC">WaveMC</a></code>.</p>
</td></tr>
<tr><td><code id="panorama_+3A_pan">pan</code></td>
<td>
<p>Value in [-1,1] to narrow the panorama, see the Details below. 
The default (1) does not change anything.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>abs(pan) &lt; 1</code>, mixtures of the two channels of the <code>Wave</code> or <code>WaveMC</code> objects 
are used for the left and the right channel of the returned Sample object if the object is of class <code>Wave</code>, resp. 
for the first and second channel of the returned Sample object if the object is of class <code>WaveMC</code>, 
so that they appear closer to the center. 
</p>
<p>For <code>pan = 0</code>, both sounds are completely in the center (i.e. averaged).
</p>
<p>If <code>pan &lt; 0</code>, the left and the right channel (for <code>Wave</code> objects, the first and the second channel for <code>WaveMC</code> objects) are interchanged.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+Wave">Wave</a></code> or class <code><a href="#topic+WaveMC">WaveMC</a></code> with the transformed panorama.</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a>, Sarah Schnackenberg, based on code by Matthias Heymann</p>


<h3>See Also</h3>

<p><a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code>, <a href="#topic+WaveMC-class">WaveMC-class</a>, <code><a href="#topic+WaveMC">WaveMC</a></code></p>

<hr>
<h2 id='periodogram-methods'>Periodogram (Spectral Density) Estimation on Wave objects</h2><span id='topic+periodogram'></span><span id='topic+periodogram+2CWaveGeneral-method'></span><span id='topic+periodogram+2Ccharacter-method'></span>

<h3>Description</h3>

<p>This function estimates one or more periodograms (spectral densities) 
of the time series contained in an object of class <code>Wave</code> or <code>WaveMC</code> (or directly in a Wave file)
using a window running through the time series (possibly with overlapping).
It returns an object of class <code>Wspec</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>periodogram(object, ...)
## S4 method for signature 'WaveGeneral'
periodogram(object, width = length(object), overlap = 0,
    starts = NULL, ends = NULL, taper = 0, normalize = TRUE, 
    frqRange = c(-Inf, Inf), ...)
## S4 method for signature 'character'
periodogram(object, width, overlap = 0, from = 1, to = Inf, 
    units = c("samples", "seconds", "minutes", "hours"), 
    downsample = NA, channel = c("left", "right"), pieces = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="periodogram-methods_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+Wave">Wave</a></code>, <code><a href="#topic+WaveMC">WaveMC</a></code>, or a character string pointing to a Wave file.</p>
</td></tr>
<tr><td><code id="periodogram-methods_+3A_width">width</code></td>
<td>
<p>A window of width &lsquo;<code>width</code>&rsquo; running through the time series selects the samples 
from which the periodograms are to be calculated.</p>
</td></tr>
<tr><td><code id="periodogram-methods_+3A_overlap">overlap</code></td>
<td>
<p>The window can be applied by each overlapping <code>overlap</code> samples.</p>
</td></tr>
<tr><td><code id="periodogram-methods_+3A_starts">starts</code></td>
<td>
<p>Start number (in samples) for a window.
If not given, this value is derived from argument <code>ends</code>,
or will be derived <code>width</code> and <code>overlap</code>.</p>
</td></tr>
<tr><td><code id="periodogram-methods_+3A_ends">ends</code></td>
<td>
<p>End number (in samples) for a window.
If not given, this value is derived from argument <code>starts</code>,
or will be derived from <code>width</code> and <code>overlap</code>.</p>
</td></tr>
<tr><td><code id="periodogram-methods_+3A_taper">taper</code></td>
<td>
<p>proportion of data to taper. See <code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code> for details.</p>
</td></tr>
<tr><td><code id="periodogram-methods_+3A_normalize">normalize</code></td>
<td>
<p>Logical; if <code>TRUE</code> (default), two steps will be applied:
(i) the input signal will be normalized to amplitude <code>max(abs(amplitude)) == 1</code>,
(ii) the resulting <code>spec</code> values will be normalized to sum up to one for each periodogram.</p>
</td></tr>
<tr><td><code id="periodogram-methods_+3A_frqrange">frqRange</code></td>
<td>
<p>Numeric vector of two elements indicating minimum and maximum of the frequency range 
that is to be stored in the resulting object. This is useful to reduce memory consumption.</p>
</td></tr>
<tr><td><code id="periodogram-methods_+3A_from">from</code></td>
<td>
<p>Where to start reading in the Wave file, in <code>units</code>.</p>
</td></tr>
<tr><td><code id="periodogram-methods_+3A_to">to</code></td>
<td>
<p>Where to stop reading in the Wave file, in <code>units</code>.</p>
</td></tr>
<tr><td><code id="periodogram-methods_+3A_units">units</code></td>
<td>
<p>Units in which <code>from</code> and <code>to</code> is given, the default is &ldquo;samples&rdquo;,
but can be set to time intervals such as &ldquo;seconds&rdquo;, see the Usage Section above.</p>
</td></tr>
<tr><td><code id="periodogram-methods_+3A_downsample">downsample</code></td>
<td>
<p>Sampling rate the object is to be downsampled to.
If <code>NA</code>, the default, no changes are applied. Otherwise <code>downsample</code> must be in <code>[2000, 192000]</code>; 
typical values are 11025, 22050, and 44100 for CD quality. See also <code><a href="#topic+downsample">downsample</a></code>.</p>
</td></tr>
<tr><td><code id="periodogram-methods_+3A_channel">channel</code></td>
<td>
<p>Character, indicating whether the &ldquo;left&rdquo; or &ldquo;right&rdquo; channel should be extracted 
(see <code><a href="#topic+mono">mono</a></code> for details) - stereo processing is not yet implemented.</p>
</td></tr>
<tr><td><code id="periodogram-methods_+3A_pieces">pieces</code></td>
<td>
<p>The Wave file will be read in in <code>pieces</code> steps in order to reduce the amount 
of required memory.</p>
</td></tr>
<tr><td><code id="periodogram-methods_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the underlying function <code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+Wspec">Wspec</a></code> is returned containing the following slots.
</p>
<table>
<tr><td><code>freq</code></td>
<td>
<p>Vector of frequencies at which the spectral density is estimated. 
See <code><a href="stats.html#topic+spectrum">spectrum</a></code> for details. (1)</p>
</td></tr>
<tr><td><code>spec</code></td>
<td>
<p>List of vectors or matrices of the <code>spec</code> values returned by <code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code>
at frequencies corresponding to <code>freq</code>.
Each element of the list corresponds to one periodogram estimated from samples of the window
beginning at <code>start</code> of the <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code> object.</p>
</td></tr>
<tr><td><code>kernel</code></td>
<td>
<p>The kernel argument, or the kernel constructed from spans returned by <code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code>. (1)</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>The distribution of the spectral density estimate can be approximated by a chi square distribution with 
<code>df</code> degrees of freedom. (1)</p>
</td></tr>
<tr><td><code>taper</code></td>
<td>
<p>The value of the <code>taper</code> argument. (1)</p>
</td></tr>
<tr><td><code>width</code></td>
<td>
<p>The value of the <code>width</code> argument. (1)</p>
</td></tr>
<tr><td><code>overlap</code></td>
<td>
<p>The value of the <code>overlap</code> argument. (1)</p>
</td></tr>
<tr><td><code>normalize</code></td>
<td>
<p>The value of the <code>normalize</code> argument. (1)</p>
</td></tr>
<tr><td><code>starts</code></td>
<td>
<p>If the argument <code>starts</code> was given in the call, its value.
If the argument <code>ends</code> was given in the call, &lsquo;<code>ends - width</code>&rsquo;.
If neither <code>starts</code> nor <code>ends</code> was given, the start points of all periodograms.
In the latter case the start points are calculated from the arguments <code>width</code> and <code>overlap</code>.</p>
</td></tr>
<tr><td><code>stereo</code></td>
<td>
<p>Always <code>FALSE</code> (for back compatibility). (1)</p>
</td></tr>
<tr><td><code>samp.rate</code></td>
<td>
<p>Sampling rate of the underlying <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code> <code>object</code>. (1)</p>
</td></tr>
<tr><td><code>variance</code></td>
<td>
<p>The variance of samples in each window, corresponding to amplitude / loudness of sound.</p>
</td></tr>
<tr><td><code>energy</code></td>
<td>
<p>The &ldquo;energy&rdquo; <code class="reqn">E</code>, also an indicator for the amplitude / loudness of sound:
</p>
<p style="text-align: center;"><code class="reqn">E(x_I) := 20 * log_{10} \sum_{j\in I}|x_j|,</code>
</p>

<p>where <code class="reqn">I</code> indicates the interval <code class="reqn">I:=</code> <code>start[i]:end[i]</code> for all 
<code class="reqn">i:=1,\dots,</code> <code>length(starts)</code>.
</p>
</td></tr>
</table>
<p>Those slots marked with &ldquo;(1)&rdquo; contain the information once, 
because it is unique for all periodograms of estimated by the function call.
</p>


<h3>Note</h3>

<p>Support for processing more than one channel of <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code> objects has not yet been implemented.
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>


<ul>
<li><p> for the resulting objects' class: <code><a href="#topic+Wspec">Wspec</a></code>,
</p>
</li>
<li><p> for plotting: <code><a href="#topic+plot-Wspec">plot-Wspec</a></code>,  
</p>
</li>
<li><p> for the underlying periodogram calculations: <code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code>,
</p>
</li>
<li><p> for the input data class: <a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code>, <a href="#topic+WaveMC-class">WaveMC-class</a>, <code><a href="#topic+WaveMC">WaveMC</a></code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'># constructing a Wave object (1 sec.) containing sinus sound with 440Hz:
Wobj &lt;- sine(440)
Wobj

# Calculate periodograms in windows of 4096 samples each - without
#   any overlap - resulting in an Wspec object that is printed:
Wspecobj &lt;- periodogram(Wobj, width = 4096)
Wspecobj

# Plot the first periodogram from Wspecobj:
plot(Wspecobj)
# Plot the third one and choose a reasonable xlim:
plot(Wspecobj, which = 3, xlim = c(0, 1000))
# Mark frequency that has been generated before:
abline(v = 440, col="red")
# plot the spectrogram
image(Wspecobj, ylim=c(0, 2000))

# same again with normalize = FALSE and with logarithmic y-axis plotted:
Wspecobj2 &lt;- periodogram(Wobj, width = 4096, normalize = FALSE)
Wspecobj2

plot(Wspecobj2, which = 3, xlim = c(0, 1000), log="y")
abline(v = 440, col="red")
image(Wspecobj2, ylim=c(0, 2000), log="z")


FF(Wspecobj)              # all ~ 440 Hertz
noteFromFF(FF(Wspecobj))  # all diapason a
</code></pre>

<hr>
<h2 id='play-methods'>Playing Waves</h2><span id='topic+play'></span><span id='topic+play+2Ccharacter-method'></span><span id='topic+play+2CWaveGeneral-method'></span>

<h3>Description</h3>

<p>Plays wave files and objects of class <code>Wave</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>play(object, player, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="play-methods_+3A_object">object</code></td>
<td>
<p>Either a filename pointing to a Wave file, 
or an object of class <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code>.
If the latter, it is written to a temporary file by <code><a href="#topic+writeWave">writeWave</a></code>,
played by the chosen player, and deleted afterwards.</p>
</td></tr>
<tr><td><code id="play-methods_+3A_player">player</code></td>
<td>
<p>(Path to) a program capable of playing a wave file by invocation from the command line.
If under Windows and no player is given, &ldquo;mplay32.exe&rdquo; or &ldquo;wmplayer.exe&rdquo; 
(if the former does not exists as under Windows 7) will be chosen as the default.</p>
</td></tr>
<tr><td><code id="play-methods_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the Wave file <code>player</code>.
If no <code>player</code> and no further arguments are given under Windows, the default is: <code>"/play /close"</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p><a href="#topic+Wave-class">Wave-class</a>, <a href="#topic+WaveMC-class">WaveMC-class</a>, <code><a href="#topic+Wave">Wave</a></code>, <code><a href="#topic+WaveMC">WaveMC</a></code>, <code><a href="#topic+writeWave">writeWave</a></code>, <code><a href="#topic+setWavPlayer">setWavPlayer</a></code></p>

<hr>
<h2 id='plot-Wave'>Plotting Wave objects</h2><span id='topic+plot+2CWave+2Cmissing-method'></span><span id='topic+plot+2CWaveMC+2Cmissing-method'></span><span id='topic+plot_Wave_channel'></span>

<h3>Description</h3>

<p>Plotting objects of class <code>Wave</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Wave,missing'
plot(x, info = FALSE, xunit = c("time", "samples"), 
    ylim = NULL, main = NULL, sub = NULL, xlab = NULL, ylab = NULL, 
    simplify = TRUE, nr = 2500, axes = TRUE, yaxt = par("yaxt"), las = 1, 
    center = TRUE, ...)

## S4 method for signature 'WaveMC,missing'
plot(x, info = FALSE, xunit = c("time", "samples"), 
    ylim = NULL, main = NULL, sub = NULL, xlab = NULL, ylab = colnames(x), 
    simplify = TRUE, nr = 2500, axes = TRUE, yaxt = par("yaxt"), las = 1, 
    center = TRUE, mfrow = NULL, ...)
    
plot_Wave_channel(x, xunit, ylim, xlab, ylab, main, nr, simplify, axes = TRUE, 
    yaxt = par("yaxt"), las = 1, center = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-Wave_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code>, respectively.</p>
</td></tr>
<tr><td><code id="plot-Wave_+3A_info">info</code></td>
<td>
<p>Logical, whether to include (written) information on the <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code> object within the plot.</p>
</td></tr>
<tr><td><code id="plot-Wave_+3A_xunit">xunit</code></td>
<td>
<p>Character indicating which units are used for setting up user coordinates (see <code><a href="graphics.html#topic+par">par</a></code>)
and x-axis labeling. If <code>xunit = "time"</code>, the unit is time in seconds, otherwise the number of samples.</p>
</td></tr>
<tr><td><code id="plot-Wave_+3A_ylim">ylim</code></td>
<td>
<p>The <code>y</code> (amplitude) limits of the plot.</p>
</td></tr>
<tr><td><code id="plot-Wave_+3A_main">main</code>, <code id="plot-Wave_+3A_sub">sub</code></td>
<td>
<p>A title / subtitle for the plot.</p>
</td></tr>
<tr><td><code id="plot-Wave_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis.</p>
</td></tr>
<tr><td><code id="plot-Wave_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis (on the right side of the plot). For <code>WaveMC</code> objects, this can be the default <code>colnames(x)</code> 
(i.e. channel names of the <code>WaveMC</code> object), <code>NULL</code> for &ldquo;channel 1&rdquo;, ..., &ldquo;channel nc&rdquo; 
where nc is <code>ncol(x)</code>, <code>NA</code> for no labels, or a character vector of labels (one element for each channel).
For <code>Wave</code> objects, this can be de default &ldquo;left channel&rdquo; (for mono) or 
&ldquo;left channel&rdquo; and &ldquo;right channel&rdquo; (for stereo), <code>NA</code> for no labels, 
or a character vector of labels (one element for each channel).</p>
</td></tr>
<tr><td><code id="plot-Wave_+3A_simplify">simplify</code></td>
<td>
<p>Logical, whether the plot should be &ldquo;simplified&rdquo;.
If <code>TRUE</code> (default), not all (thousand/millions/billions) of points (samples) of the 
<code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code> object are drawn, 
but the <code>nr</code> (see below) ranges (in form of segments) within <code>nr</code> windows of the time series.
</p>
<p>Plotting with <code>simplify = FALSE</code> may take several minutes (depending on the number of samples in the <code>Wave</code> or <code>WaveMC</code>)
and output in any vector format may be really huge.</p>
</td></tr>
<tr><td><code id="plot-Wave_+3A_nr">nr</code></td>
<td>
<p>Number of windows (segments) to be used <em>approximately</em>
(an appropriate number close to <code>nr</code> is selected)
to <code>simplify</code> (see above) the plot.
Only used if <code>simplify = TRUE</code> and the number of samples of the <code>Wave</code> or <code>WaveMC</code> object <code>x</code> is larger.</p>
</td></tr>
<tr><td><code id="plot-Wave_+3A_axes">axes</code></td>
<td>
<p>Whether to plot axes, default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot-Wave_+3A_yaxt">yaxt</code></td>
<td>
<p>How to plot the y-axis (<code>"n"</code> for no y-axis).</p>
</td></tr> 
<tr><td><code id="plot-Wave_+3A_las">las</code></td>
<td>
<p>The style of the axis labels, default is <code>las = 1</code> (always horizontal), see <code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot-Wave_+3A_center">center</code></td>
<td>
<p>Whether to plot with y-axes centered around 0 (or 127 if 8-bit), default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot-Wave_+3A_mfrow">mfrow</code></td>
<td>
<p>A vector indicating the arrangement of the figures, see <code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot-Wave_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the underlying plot functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>plot_Wave_channel</code> is a helper function
to plot a single channel (left for a <code>Wave</code> object, first channel / first column of data slot of a <code>WaveMC</code> object); 
in particular it is <em>not</em> intended to be called by the user directly.</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a>, Sarah Schnackenberg</p>


<h3>See Also</h3>

<p><a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code>, <a href="#topic+WaveMC-class">WaveMC-class</a>, <code><a href="#topic+WaveMC">WaveMC</a></code> and <a href="#topic+tuneR">tuneR</a></p>

<hr>
<h2 id='plot-Wspec'>Plotting Wspec objects</h2><span id='topic+plot-Wspec'></span><span id='topic+plot+2CWspec+2Cmissing-method'></span>

<h3>Description</h3>

<p>Plotting a periodogram contained in an object of class <code>Wspec</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Wspec,missing'
plot(x, which = 1, type = "h", xlab = "Frequency", 
    ylab = NULL, log = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-Wspec_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+Wspec">Wspec</a></code>.</p>
</td></tr>
<tr><td><code id="plot-Wspec_+3A_which">which</code></td>
<td>
<p>Integer indicating which of the periodograms contained in object <code>x</code> to plot.
Default is to plot the first one.</p>
</td></tr>
<tr><td><code id="plot-Wspec_+3A_type">type</code></td>
<td>
<p>The default is to plot horizontal lines, rather than points. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code> for details.</p>
</td></tr>
<tr><td><code id="plot-Wspec_+3A_xlab">xlab</code>, <code id="plot-Wspec_+3A_ylab">ylab</code></td>
<td>
<p>Label for x-/y-axis.</p>
</td></tr>
<tr><td><code id="plot-Wspec_+3A_log">log</code></td>
<td>
<p>Character - <code>"x"</code> if the x-axis is to be logarithmic, 
<code>"y"</code> if the y-axis is to be logarithmic (quite typical for some visualizations of periodograms), 
and <code>"xy"</code> or <code>"yx"</code> if both axes are to be logarithmic.</p>
</td></tr>
<tr><td><code id="plot-Wspec_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the underlying plot functions. 
See <code><a href="graphics.html#topic+plot.default">plot.default</a></code> for details.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p>see <code><a href="#topic+Wspec">Wspec</a></code>, <code><a href="#topic+periodogram">periodogram</a></code> and <a href="#topic+tuneR">tuneR</a> 
for the constructor function and some examples.</p>

<hr>
<h2 id='plot-WspecMat'>Plotting WspecMat objects</h2><span id='topic+plot-WspecMat'></span><span id='topic+plot+2CWspecMat+2Cmissing-method'></span><span id='topic+image+2CANY-method'></span><span id='topic+image-Wspec'></span><span id='topic+image+2CWspec-method'></span>

<h3>Description</h3>

<p>Plotting a spectogram (image) of an object of class <code>Wspec</code> or <code>WspecMat</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'WspecMat,missing'
plot(x, xlab = "time", ylab = "Frequency", 
    xunit = c("samples", "time"), log = "", ...)
## S4 method for signature 'Wspec'
image(x, xlab = "time", ylab = "Frequency", 
    xunit = c("samples", "time"), log = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot-WspecMat_+3A_x">x</code></td>
<td>
<p>Object of class <code><a href="#topic+WspecMat">WspecMat</a></code> (for <code>plot</code>) or <code><a href="#topic+Wspec">Wspec</a></code> (for <code>image</code>).</p>
</td></tr>
<tr><td><code id="plot-WspecMat_+3A_xlab">xlab</code>, <code id="plot-WspecMat_+3A_ylab">ylab</code></td>
<td>
<p>Label for x-/y-axis.</p>
</td></tr>
<tr><td><code id="plot-WspecMat_+3A_xunit">xunit</code></td>
<td>
<p>Character indicating which units are used to annotate the x-axis.
If <code>xunit = "time"</code>, the unit is time in seconds, otherwise the number of samples.</p>
</td></tr>
<tr><td><code id="plot-WspecMat_+3A_log">log</code></td>
<td>
<p>Character - <code>"z"</code> if the z values are to be logarithmic.</p>
</td></tr>
<tr><td><code id="plot-WspecMat_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the underlying <code><a href="Matrix.html#topic+image">image</a></code> function. 
See <code><a href="Matrix.html#topic+image">image</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calling <code>image</code> on a <code>Wspec</code> object converts it to class 
<code>WspecMat</code> and calls the corresponding <code>plot</code> function.<br />
Calling <code>plot</code> on a <code>WspecMat</code> object
generates an <code><a href="Matrix.html#topic+image">image</a></code> with correct annotated axes.
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p>see <code><a href="Matrix.html#topic+image">image</a></code>, <code><a href="#topic+Wspec">Wspec</a></code>, <code><a href="#topic+WspecMat">WspecMat</a></code>, <code><a href="#topic+periodogram">periodogram</a></code> and <a href="#topic+tuneR">tuneR</a> 
for the constructor function and some examples.</p>

<hr>
<h2 id='postaud'>Equal loudness compression </h2><span id='topic+postaud'></span>

<h3>Description</h3>

<p>Do loudness equalization and cube root compression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postaud(x, fmax, fbtype = c("bark", "mel", "htkmel", "fcmel"), 
    broaden = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postaud_+3A_x">x</code></td>
<td>
<p> Matrix of spectra (output of <code><a href="#topic+audspec">audspec</a></code>). </p>
</td></tr>
<tr><td><code id="postaud_+3A_fmax">fmax</code></td>
<td>
<p> Maximum frequency im Hertz. </p>
</td></tr>
<tr><td><code id="postaud_+3A_fbtype">fbtype</code></td>
<td>
<p> Auditory frequency scale. </p>
</td></tr>
<tr><td><code id="postaud_+3A_broaden">broaden</code></td>
<td>
<p> Use two additional frequency bands for calculation. </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>Matrix of the per sample/frame (columns) spectra after applying the frequency
dependant loudness equalization and compression. </p>
</td></tr>
<tr><td><code>eql</code></td>
<td>
<p>Vector of the equal loudness curve. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Sebastian Krey <a href="mailto:krey@statistik.tu-dortmund.de">krey@statistik.tu-dortmund.de</a> </p>


<h3>References</h3>

<p>Daniel P. W. Ellis
<a href="https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/">https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/</a>, Hynek
Hermansky </p>


<h3>See Also</h3>

 <p><code><a href="#topic+audspec">audspec</a></code>, <code><a href="#topic+dolpc">dolpc</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  testsound &lt;- normalize(sine(400) + sine(1000) + square(250), "16")
  pspectrum &lt;- powspec(testsound@left, testsound@samp.rate)
  aspectrum &lt;- audspec(pspectrum, testsound@samp.rate)
  paspectrum &lt;- postaud(x = aspectrum$aspectrum, fmax = 5000, 
    fbtype = "mel")
</code></pre>

<hr>
<h2 id='powspec'> Powerspectrum </h2><span id='topic+powspec'></span>

<h3>Description</h3>

<p>Compute the powerspectrum of the input signal.
Basically output a power spectrogram using a Hamming window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>powspec(x, sr = 8000, wintime = 0.025, steptime = 0.01, dither = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="powspec_+3A_x">x</code></td>
<td>
<p> Vector of samples. </p>
</td></tr>
<tr><td><code id="powspec_+3A_sr">sr</code></td>
<td>
<p> Sampling rate of the signal. </p>
</td></tr>
<tr><td><code id="powspec_+3A_wintime">wintime</code></td>
<td>
<p> Window length in sec. </p>
</td></tr>
<tr><td><code id="powspec_+3A_steptime">steptime</code></td>
<td>
<p> Step between successive windows in sec. </p>
</td></tr>
<tr><td><code id="powspec_+3A_dither">dither</code></td>
<td>
<p> Add offset to spectrum as if dither noise. </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix, where each column represents a power spectrum for a given frame
and each row represents a frequency.
</p>


<h3>Author(s)</h3>

<p> Sebastian Krey <a href="mailto:krey@statistik.tu-dortmund.de">krey@statistik.tu-dortmund.de</a> </p>


<h3>References</h3>

<p>Daniel P. W. Ellis: <a href="https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/">https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/</a> </p>


<h3>See Also</h3>

 <p><code><a href="signal.html#topic+specgram">specgram</a></code> </p>


<h3>Examples</h3>

<pre><code class='language-R'>  testsound &lt;- normalize(sine(400) + sine(1000) + square(250), "16")
  pspectrum &lt;- powspec(testsound@left, testsound@samp.rate)
</code></pre>

<hr>
<h2 id='prepComb'>Preparing the combination/concatenation of Wave or WaveMC objects</h2><span id='topic+prepComb'></span>

<h3>Description</h3>

<p>Preparing objects of class <code>Wave</code> or class <code>WaveMC</code> for binding/combination/concatenation by
removing small amounts at the beginning/end of the <code>Wave</code> or <code>WaveMC</code> in order to make the transition smooth by avoiding clicks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepComb(object, zero = 0, where = c("both", "start", "end"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepComb_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+Wave">Wave</a></code> or class <code><a href="#topic+WaveMC">WaveMC</a></code>.</p>
</td></tr>
<tr><td><code id="prepComb_+3A_zero">zero</code></td>
<td>
<p>The zero level (default: 0) at which ideal cut points are determined (see Details).
A typical alternative would be 127 for 8 bit <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code> objects.
If <code>zero = NA</code>, the mean of the left Wave channel (for a <code>Wave</code> object) 
or the mean of the first channel (for a <code>WaveMC</code> object) is taken as zero level.</p>
</td></tr>
<tr><td><code id="prepComb_+3A_where">where</code></td>
<td>
<p>One of <code>"both"</code> (default), <code>"start"</code>, or <code>"end"</code>
indicating at <code>where</code> to prepare the <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code> object for concatenation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful to prepare objects of class <code>Wave</code> or class <code>WaveMC</code> for binding/combination/concatenation.
At the side(s) indicated by <code>where</code> small amounts of the <code>Wave</code> or <code>WaveMC</code> are removed
in order to make the transition between two <code>Wave</code>s or <code>WaveMC</code>s smooth (avoiding clicks).
</p>
<p>This is done by dropping all values at the <em>beginning</em> of a <code>Wave</code> or <code>WaveMC</code> before the first positive point 
after the <code>zero</code> level is crossed from negative to positive.
Analogously, at the <em>end</em> of a <code>Wave</code> or <code>WaveMC</code> all points are cut after the last negative value 
before the last <code>zero</code> level crossing from negative to positive.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+Wave">Wave</a></code> or class <code><a href="#topic+WaveMC">WaveMC</a></code>.
</p>


<h3>Note</h3>

<p>If stereo (for <code>Wave</code>), only the left channel is analyzed while the right channel will simply be cut at the same locations.
If multi channel  (for <code>WaveMC</code>), only the first channel is analyzed while all other channels will simply be cut at the same locations.</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a>, Sarah Schnackenberg,
based on code from Matthias Heymann's former package &lsquo;sound&rsquo;.</p>


<h3>See Also</h3>

<p><code><a href="#topic+bind">bind</a></code>, <a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code>, <a href="#topic+WaveMC-class">WaveMC-class</a>, 
<code><a href="#topic+WaveMC">WaveMC</a></code>, <code><a href="#topic+extractWave">extractWave</a></code>, and <code><a href="#topic+noSilence">noSilence</a></code> to cut off silence</p>


<h3>Examples</h3>

<pre><code class='language-R'>Wobj1 &lt;- sine(440, duration = 520)
Wobj2 &lt;- extractWave(sine(330, duration = 500), from = 110, to = 500)
par(mfrow = c(2,1))
plot(bind(Wobj1, Wobj2), xunit = "samples")
abline(v = 520, col = "red")  # here is a "click"!

# now remove the "click" by deleting a minimal amount of information:
Wobj1 &lt;- prepComb(Wobj1, where = "end")
Wobj2 &lt;- prepComb(Wobj2, where = "start")
plot(bind(Wobj1, Wobj2), xunit = "samples")
</code></pre>

<hr>
<h2 id='quantize'>Functions for the quantization of notes</h2><span id='topic+quantMerge'></span><span id='topic+quantize'></span>

<h3>Description</h3>

<p>These functions apply (static) quantization of notes in order 
to produce sheet music by pressing the notes into bars.</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantize(notes, energy, parts)
quantMerge(notes, minlength, barsize, bars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantize_+3A_notes">notes</code></td>
<td>
<p>Series of notes, a vector of integers such as returned by <code><a href="#topic+noteFromFF">noteFromFF</a></code>.
At least one argument (<code>notes</code> and/or <code>energy</code>) must be specified.</p>
</td></tr>
<tr><td><code id="quantize_+3A_energy">energy</code></td>
<td>
<p>Series of energy values, a vector of numerics such as corresponding components of a 
<code><a href="#topic+Wspec">Wspec</a></code> object.</p>
</td></tr>
<tr><td><code id="quantize_+3A_parts">parts</code></td>
<td>
<p>Number of outcoming parts. The <code>notes</code> vector is divided into <code>parts</code> bins,
the outcome is a vector of the modes of all bins.</p>
</td></tr>
<tr><td><code id="quantize_+3A_minlength">minlength</code></td>
<td>
<p>1/(length of the shortest note).<br />
Example: if the shortest note is a quaver (1/8), set <code>minlength = 8</code>.</p>
</td></tr> 
<tr><td><code id="quantize_+3A_barsize">barsize</code></td>
<td>
<p>One bar contains <code>barsize</code> number of notes of length <code>minlength</code>.</p>
</td></tr>
<tr><td><code id="quantize_+3A_bars">bars</code></td>
<td>
<p>We expect <code>bars</code> number of bars.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>quantize</code> returns a list with components:
</p>
<table>
<tr><td><code>notes</code></td>
<td>
<p>Vector of length <code>parts</code> corresponding to the input data
The data is binned and modes corresponding to the data in those bins are returned.</p>
</td></tr>
<tr><td><code>energy</code></td>
<td>
<p>Same as <code>notes</code>, but for the <code>energy</code> argument.</p>
</td></tr></table>
<p><br />
</p>
<p><code>quantMerge</code> returns a data.frame with components:
</p>
<table>
<tr><td><code>note</code></td>
<td>
<p>integer representation of a note (see Arguments).</p>
</td></tr>
<tr><td><code>duration</code></td>
<td>
<p>1/duration of a note (see <code>minlength</code> in Section Arguments),
if <code>punctuation = FALSE</code>.</p>
</td></tr>
<tr><td><code>punctuation</code></td>
<td>
<p>Whether the note should be punctuated. If <code>TRUE</code>, 
the real duration is 1.5 times the duration given in <code>duration</code>.</p>
</td></tr>
<tr><td><code>slur</code></td>
<td>
<p>currently always <code>FALSE</code>, sensible processing is not yet implemented.<br />
It is supposed to indicate the beginning and ending positions of slurs.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p>to get the input: <code><a href="#topic+noteFromFF">noteFromFF</a></code>, 
for plotting: <code><a href="#topic+quantplot">quantplot</a></code>, 
for further processing: <code><a href="#topic+lilyinput">lilyinput</a></code>,
to get notenames: <code><a href="#topic+notenames">notenames</a></code>;
for an example, see the help in <a href="#topic+tuneR">tuneR</a>.</p>

<hr>
<h2 id='quantplot'>Plotting the quantization of a melody</h2><span id='topic+quantplot'></span>

<h3>Description</h3>

<p>Plot an observed melody and (optional) an expected melody, 
as well as corresponding energy values (corresponding to the loudness of the sound)
within a quantization grid.</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantplot(observed, energy = NULL, expected = NULL, bars, 
    barseg = round(length(observed) / bars), 
    main = NULL, xlab = NULL, ylab = "note", xlim = NULL, ylim = NULL, 
    observedcol = "red", expectedcol = "grey", gridcol = "grey",
    lwd = 2, las = 1, cex.axis = 0.9, mar = c(5, 4, 4, 4) + 0.1,
    notenames = NULL, silence = "silence", plotenergy = TRUE, ...,
    axispar = list(ax1 = list(side=1), ax2 = list(side=2), ax4 = list(side=4)),
    boxpar = list(), 
    energylabel = list(text="energy", side=4, line=2.5, at=rg.s-0.25, las=3),
    energypar = list(pch=20), 
    expectedpar = list(),
    gridpar = list(gridbar = list(col = 1), gridinner = list(col=gridcol)),
    observedpar = list(col=observedcol, pch=15))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantplot_+3A_observed">observed</code></td>
<td>
<p>Either a vector of observed notes resulting from some quantization, 
or a list with components <code>notes</code> (observed notes) and <code>energy</code> (corresponding energy values),
e.g. the result from a call to <code><a href="#topic+quantize">quantize</a></code>.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_energy">energy</code></td>
<td>
<p>A vector of energy values with same quantization as <code>observed</code>     
(overwrites any given energy values if <code>observed</code> is a list).</p>
</td></tr>
<tr><td><code id="quantplot_+3A_expected">expected</code></td>
<td>
<p>Expected notes (optional; in order to compare results).</p>
</td></tr>
<tr><td><code id="quantplot_+3A_bars">bars</code></td>
<td>
<p>Number of bars to be plotted (e.g. corresponding to <code>quantize</code> arguments).</p>
</td></tr>
<tr><td><code id="quantplot_+3A_barseg">barseg</code></td>
<td>
<p>Number of segments (minimal length notes) in each bar.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_main">main</code></td>
<td>
<p>Main title of the plot.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_xlab">xlab</code>, <code id="quantplot_+3A_ylab">ylab</code></td>
<td>
<p>Annotation of x-/y-axes.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_xlim">xlim</code>, <code id="quantplot_+3A_ylim">ylim</code></td>
<td>
<p>Range of x-/y-axis.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_observedcol">observedcol</code></td>
<td>
<p>Colour for the observed notes.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_expectedcol">expectedcol</code></td>
<td>
<p>Colour for the expected notes.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_gridcol">gridcol</code></td>
<td>
<p>Colour of the inner-bar grid.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_lwd">lwd</code></td>
<td>
<p>Line width, see <code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_las">las</code></td>
<td>
<p>Orientation of axis labels, see <code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_cex.axis">cex.axis</code></td>
<td>
<p>Size of tick mark labels, see <code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_mar">mar</code></td>
<td>
<p>Margins of the plot, see <code><a href="graphics.html#topic+par">par</a></code> for details.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_notenames">notenames</code></td>
<td>
<p>Optionally specify other notenames (character) for the y-axis.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_silence">silence</code></td>
<td>
<p>Character string for label of the &lsquo;silence&rsquo; (default) axis.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_plotenergy">plotenergy</code></td>
<td>
<p>Logical indicating whether to plot energy values in the bottom part of the plot (default is <code>TRUE</code>) 
if energy values are specified, and <code>FALSE</code> otherwise.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters to be passed to underlying <code>plot</code> function.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_axispar">axispar</code></td>
<td>
<p>A named list of three other lists (<code>ax1</code>, <code>ax2</code>, and <code>ax4</code>)
containing parameters passed to the corresponding <code><a href="graphics.html#topic+axis">axis</a></code> calls for the three axis
time (<code>ax1</code>), notes (<code>ax2</code>), and energy (<code>ax4</code>).</p>
</td></tr>
<tr><td><code id="quantplot_+3A_boxpar">boxpar</code></td>
<td>
<p>A list of parameters to be passed to the box generating functions.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_energylabel">energylabel</code></td>
<td>
<p>A list of parameters to be passed to the energy-label 
generating <code><a href="graphics.html#topic+mtext">mtext</a></code> call.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_energypar">energypar</code></td>
<td>
<p>A list of parameters to be passed to the <code><a href="graphics.html#topic+points">points</a></code> function 
that draws the energy values.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_expectedpar">expectedpar</code></td>
<td>
<p>A list of parameters to be passed to the <code><a href="graphics.html#topic+rect">rect</a></code> 
function that draws the rectangles for expected values.</p>
</td></tr>
<tr><td><code id="quantplot_+3A_gridpar">gridpar</code></td>
<td>
<p>A named list of two other lists (<code>gridbar</code> and <code>gridinner</code>) 
containing parameters passed to the <code><a href="graphics.html#topic+abline">abline</a></code> functions that draw the grid lines 
(for bar separators and inner bar (note) separators).</p>
</td></tr>
<tr><td><code id="quantplot_+3A_observedpar">observedpar</code></td>
<td>
<p>A list of parameters to be passed to the <code><a href="graphics.html#topic+lines">lines</a></code> 
function that draws the observed values.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+noteFromFF">noteFromFF</a></code>, <code><a href="#topic+FF">FF</a></code>, <code><a href="#topic+melodyplot">melodyplot</a></code>, <code><a href="#topic+quantize">quantize</a></code>; 
for an example, see the help in <a href="#topic+tuneR">tuneR</a>.</p>

<hr>
<h2 id='readMidi'>Read a MIDI file</h2><span id='topic+readMidi'></span>

<h3>Description</h3>

<p>A MIDI file is read and returned in form of a structured data frame containing 
most event information (minus some meta events and minus all system events). 
For details about the represented information see the reference given below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMidi(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMidi_+3A_file">file</code></td>
<td>
<p>Filename of MIDI file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame consisting of columns
</p>
<table>
<tr><td><code>time</code></td>
<td>
<p>Time or delta-time of the events, depending on the MIDI format.</p>
</td></tr>
<tr><td><code>event</code></td>
<td>
<p>A factor indicating the event.</p>
</td></tr>       
<tr><td><code>type</code></td>
<td>
<p>An integer indicating the type of a &ldquo;meta event&rdquo;, otherwise <code>NA</code>.</p>
</td></tr>
<tr><td><code>channel</code></td>
<td>
<p>The channel number or <code>NA</code> if not applicable.</p>
</td></tr>
<tr><td><code>parameter1</code></td>
<td>
<p>First parameter of an event, e.g. a representation for a note in a &ldquo;note event&rdquo;.</p>
</td></tr>
<tr><td><code>parameter2</code></td>
<td>
<p>Second parameter of an event.</p>
</td></tr>
<tr><td><code>parameterMetaSystem</code></td>
<td>
<p>Information in a &ldquo;meta event&rdquo;, currently all meta events are converted to a character representation (of hex, if all fails), but future versions may have more appropriate representations.</p>
</td></tr>
<tr><td><code>track</code></td>
<td>
<p>The track number.</p>
</td></tr>
</table>
<p>Please see the given reference about the MIDI file format about details.
</p>


<h3>Note</h3>

<p>The data structure may be changed or extended in future versions.</p>


<h3>Author(s)</h3>

<p>Uwe Ligges and Johanna Mielke</p>


<h3>References</h3>

<p>A good reference about the Midi file format can be found at <a href="http://www.music.mcgill.ca/~ich/classes/mumt306/StandardMIDIfileformat.html">http://www.music.mcgill.ca/~ich/classes/mumt306/StandardMIDIfileformat.html</a>.</p>


<h3>See Also</h3>

<p>The function <code><a href="#topic+getMidiNotes">getMidiNotes</a></code> extracts a more readable representation of note events only.
</p>
<p>You may also want to read Wave (<code><a href="#topic+readWave">readWave</a></code>) or MP3 (<code><a href="#topic+readMP3">readMP3</a></code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>content &lt;- readMidi(system.file("example_files", "Bass_sample.mid", package="tuneR"))
str(content)
content
</code></pre>

<hr>
<h2 id='readMP3'>
Read an MPEG-2 layer 3 file into a Wave object
</h2><span id='topic+readMP3'></span>

<h3>Description</h3>

<p>A bare bones MPEG-2 layer 3 (MP3) file reader that returns the results
as 16bit PCM data stored in a Wave object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMP3(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMP3_+3A_filename">filename</code></td>
<td>
<p>Filename of MP3 file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+Wave-class">Wave</a></code> object.
</p>


<h3>Note</h3>

<p>The decoder can currently only handle files which are either mono or
stereo. This is a limitation of the Wave object and the underlying MAD
decoder.  
</p>


<h3>Author(s)</h3>

<p>Olaf Mersmann <a href="mailto:olafm@statistik.tu-dortmund.de">olafm@statistik.tu-dortmund.de</a></p>


<h3>References</h3>

<p>The decoder source code is taken from the MAD library, see
<a href="http://www.underbit.com/products/mad/">http://www.underbit.com/products/mad/</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Wave-class">Wave</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Requires an mp3 file named sample.mp3 in the current directory.
mpt &lt;- readMP3("sample.mp3")
summary(mpt)

## End(Not run)
</code></pre>

<hr>
<h2 id='readWave'>Reading Wave files</h2><span id='topic+readWave'></span>

<h3>Description</h3>

<p>Reading Wave files.</p>


<h3>Usage</h3>

<pre><code class='language-R'>readWave(filename, from = 1, to = Inf, 
    units = c("samples", "seconds", "minutes", "hours"), header = FALSE, toWaveMC = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readWave_+3A_filename">filename</code></td>
<td>
<p>Filename of the file to be read.</p>
</td></tr>
<tr><td><code id="readWave_+3A_from">from</code></td>
<td>
<p>Where to start reading (in order to save memory by reading wave file piecewise), in <code>units</code>.</p>
</td></tr>
<tr><td><code id="readWave_+3A_to">to</code></td>
<td>
<p>Where to stop reading (in order to save memory by reading wave file piecewise), in <code>units</code>.</p>
</td></tr>
<tr><td><code id="readWave_+3A_units">units</code></td>
<td>
<p>Units in which <code>from</code> and <code>to</code> is given, the default is <code>"samples"</code>,
but can be set to time intervals such as <code>"seconds"</code>, see the Usage Section above.</p>
</td></tr>
<tr><td><code id="readWave_+3A_header">header</code></td>
<td>
<p>If <code>TRUE</code>, just header information of the Wave file are returned, 
otherwise (the default) the whole Wave object.</p>
</td></tr>
<tr><td><code id="readWave_+3A_towavemc">toWaveMC</code></td>
<td>
<p>If <code>TRUE</code>, a <a href="#topic+WaveMC-class">WaveMC-class</a> object is returned. 
If <code>NULL</code> (default) or <code>FALSE</code> and a non-extensible Wave file or an extensible Wave file with no other than the &ldquo;FL&rdquo; and &ldquo;FR&rdquo;
channels is found, a <a href="#topic+Wave-class">Wave-class</a> object is returned, otherwise a <a href="#topic+WaveMC-class">WaveMC-class</a> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="#topic+Wave">Wave</a></code>  or <code><a href="#topic+WaveMC">WaveMC</a></code> 
or a list containing just the header information if <code>header = TRUE</code>.
If the latter, some experimental support for reading <code>bext</code> chunks in 
Broadcast Wave Format files is implemented, and the content is returned as an unprocessed string (character).
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a>, Sarah Schnackenberg</p>


<h3>See Also</h3>

<p><a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code>, <a href="#topic+WaveMC-class">WaveMC-class</a>, <code><a href="#topic+WaveMC">WaveMC</a></code>,  <code><a href="#topic+writeWave">writeWave</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Wobj &lt;- sine(440)

tdir &lt;- tempdir()
tfile &lt;- file.path(tdir, "myWave.wav")
writeWave(Wobj, filename = tfile)
list.files(tdir, pattern = "\\.wav$")
newWobj &lt;- readWave(tfile)
newWobj
file.remove(tfile)
</code></pre>

<hr>
<h2 id='show-WaveWspec-methods'>Showing objects</h2><span id='topic+show+2CWave-method'></span><span id='topic+show+2CWaveMC-method'></span><span id='topic+show+2CWspec-method'></span><span id='topic+show+2CWspecMat-method'></span>

<h3>Description</h3>

<p>Showing <code>Wave</code>, <code>Wspec</code>, and <code>WspecMat</code> objects.</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;Wave&quot;</dt><dd><p>The <code>Wave</code> object is being <code>show</code>n.
The number of samples, duration in seconds, Samplingrate (Hertz),
Stereo / Mono, PCM / IEEE, and the resolution in bits are printed.
Note that it does not make sense to print the whole channels 
containing several thousands or millions of samples.</p>
</dd>
<dt>object = &quot;WaveMC&quot;</dt><dd><p>The <code>WaveMC</code> object is being <code>show</code>n.
The number of samples, duration in seconds, Samplingrate (Hertz),
number of channels, PCM / IEEE, and the resolution in bits are printed.
Note that it does not make sense to print the whole channels 
containing several thousands or millions of samples.</p>
</dd>
<dt>object = &quot;Wspec&quot;</dt><dd><p>The number of periodograms, Fourier frequencies, window width (used amount of data), 
amount of overlap of neighboring windows, and whether the periodogram(s) has/have been normalized
will be printed.</p>
</dd>
<dt>object = &quot;WspecMat&quot;</dt><dd><p>The number of periodograms, Fourier frequencies, window width (used amount of data), 
amount of overlap of neighboring windows, and whether the periodogram(s) has/have been normalized
will be printed.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p><a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code>, <a href="#topic+WaveMC-class">WaveMC-class</a>, <code><a href="#topic+WaveMC">WaveMC</a></code>, <code><a href="#topic+Wspec">Wspec</a></code>, <code><a href="#topic+WspecMat">WspecMat</a></code>, 
<code><a href="stats4.html#topic+plot-methods">plot-methods</a></code>, <code><a href="stats4.html#topic+summary-methods">summary-methods</a></code>,
and <code><a href="#topic+periodogram">periodogram</a></code> for the constructor function and some examples</p>

<hr>
<h2 id='smoother'>Meta Function for Smoothers</h2><span id='topic+smoother'></span>

<h3>Description</h3>

<p>Apply a smoother to estimated notes.
Currently, only a running median (using <code><a href="pastecs.html#topic+decmedian">decmedian</a></code> in package <span class="pkg">pastecs</span>) is available.</p>


<h3>Usage</h3>

<pre><code class='language-R'>smoother(notes, method = "median", order = 4, times = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smoother_+3A_notes">notes</code></td>
<td>
<p>Series of notes, a vector of integers such as returned by <code><a href="#topic+noteFromFF">noteFromFF</a></code>.</p>
</td></tr>
<tr><td><code id="smoother_+3A_method">method</code></td>
<td>
<p>Currently, only a running <code>'median'</code> 
(using <code><a href="pastecs.html#topic+decmedian">decmedian</a></code> in package <span class="pkg">pastecs</span>) is available.</p>
</td></tr>
<tr><td><code id="smoother_+3A_order">order</code></td>
<td>
<p>The window used for the running median corresponds to 2*order + 1.</p>
</td></tr>
<tr><td><code id="smoother_+3A_times">times</code></td>
<td>
<p>The number of times the running median is applied (default: 2).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The smoothed series of notes.
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>

<hr>
<h2 id='spec2cep'> Spectra to Cepstra Conversion </h2><span id='topic+spec2cep'></span>

<h3>Description</h3>

<p>Calculate cepstra from spectral samples (in columns of spec) through Discrete
Cosine Transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec2cep(spec, ncep = 12, type = c("t2", "t1", "t3", "t4"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec2cep_+3A_spec">spec</code></td>
<td>
<p> Input spectra (samples/time frames in columns).</p>
</td></tr>
<tr><td><code id="spec2cep_+3A_ncep">ncep</code></td>
<td>
<p> Number of cepstra to return. </p>
</td></tr>
<tr><td><code id="spec2cep_+3A_type">type</code></td>
<td>
<p> DCT Type. </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>cep</code></td>
<td>
<p>Matrix of resulting cepstra.</p>
</td></tr>
<tr><td><code>dctm</code></td>
<td>
<p>Returns the DCT matrix that spec was multiplied by to give cep.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Sebastian Krey <a href="mailto:krey@statistik.tu-dortmund.de">krey@statistik.tu-dortmund.de</a> </p>


<h3>References</h3>

<p>Daniel P. W. Ellis: <a href="https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/">https://www.ee.columbia.edu/~dpwe/resources/matlab/rastamat/</a> </p>


<h3>See Also</h3>

<p><code><a href="#topic+lpc2cep">lpc2cep</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  testsound &lt;- normalize(sine(400) + sine(1000) + square(250), "16")
  pspectrum &lt;- powspec(testsound@left, testsound@samp.rate)
  aspectrum &lt;- audspec(pspectrum, testsound@samp.rate)
  cepstra &lt;- spec2cep(aspectrum$aspectrum)
</code></pre>

<hr>
<h2 id='summary-methods'>Object Summaries</h2><span id='topic+summary+2CANY-method'></span><span id='topic+summary+2CWave-method'></span><span id='topic+summary+2CWaveMC-method'></span><span id='topic+summary+2CWspec-method'></span><span id='topic+summary+2CWspecMat-method'></span>

<h3>Description</h3>

<p>summary is a generic function used to produce result summaries of the results of various model fitting functions. 
The function invokes particular methods which depend on the class of the first argument. 
</p>


<h3>Methods</h3>


<dl>
<dt>object = &quot;ANY&quot;</dt><dd><p>Any object for which a summary is desired, 
dispatches to the S3 generic.</p>
</dd>
<dt>object = &quot;Wave&quot;</dt><dd><p>The <code><a href="#topic+Wave">Wave</a></code> object is being <code>show</code>n and an additional summary of the 
<code>Wave</code>-object's (one or two) channels is given.</p>
</dd>
<dt>object = &quot;WaveMC&quot;</dt><dd><p>The <code><a href="#topic+WaveMC">WaveMC</a></code> object is being <code>show</code>n and an additional summary of the 
<code>WaveMC</code>-object's channels is given.</p>
</dd>
<dt>object = &quot;Wspec&quot;</dt><dd><p>The <code><a href="#topic+Wspec">Wspec</a></code> object is being <code>show</code>n and as an additional output is given:
<code>df</code>, <code>taper</code> (see <code><a href="stats.html#topic+spectrum">spectrum</a></code>) 
and for the underlying <code><a href="#topic+Wave">Wave</a></code> object the number of channels and its sampling rate.</p>
</dd>
<dt>object = &quot;WspecMat&quot;</dt><dd><p>The <code><a href="#topic+WspecMat">WspecMat</a></code> object is being <code>show</code>n and as an additional output is given:
<code>df</code>, <code>taper</code> (see <code><a href="stats.html#topic+spectrum">spectrum</a></code>) 
and for the underlying <code><a href="#topic+Wave">Wave</a></code> object the number of channels and its sampling rate.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p>For the S3 generic: <code><a href="base.html#topic+summary.default">summary.default</a></code>, <code><a href="stats4.html#topic+plot-methods">plot-methods</a></code>, 
<a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code>, <a href="#topic+WaveMC-class">WaveMC-class</a>, <code><a href="#topic+WaveMC">WaveMC</a></code>, <code><a href="#topic+Wspec">Wspec</a></code>, <code><a href="#topic+WspecMat">WspecMat</a></code>, <code><a href="methods.html#topic+show">show</a></code></p>

<hr>
<h2 id='updateWave'>Update old Wave objects for use with new versions of tuneR</h2><span id='topic+updateWave'></span>

<h3>Description</h3>

<p>Update old Wave objects generated with <span class="pkg">tuneR</span> &lt; 1.0.0 to the new class definition for use with new versions of the package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>updateWave(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="updateWave_+3A_object">object</code></td>
<td>
<p>An object of <a href="#topic+Wave-class">Wave-class</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only needed to convert <a href="#topic+Wave-class">Wave-class</a> objects that have been saved with <span class="pkg">tuneR</span> versions prior to 1.0-0 to match the new class definition.</p>


<h3>Value</h3>

<p>An object of <a href="#topic+Wave-class">Wave-class</a> as implemented in <span class="pkg">tuneR</span> versions &gt;= 1.0-0.</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a>, Sarah Schnackenberg</p>


<h3>See Also</h3>

<p><a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- sine(440)
updateWave(x)
</code></pre>

<hr>
<h2 id='Wave'>Constructors and coercion for class Wave objects</h2><span id='topic+Wave'></span><span id='topic+Wave+2CANY-method'></span><span id='topic+Wave+2CWaveMC-method'></span><span id='topic+Wave+2Cnumeric-method'></span><span id='topic+Wave+2Cmatrix-method'></span><span id='topic+Wave+2Cdata.frame-method'></span><span id='topic+Wave+2Clist-method'></span><span id='topic++5B+2CWave-method'></span><span id='topic+coerce+2Cmatrix+2CWave-method'></span><span id='topic+coerce+2Cdata.frame+2CWave-method'></span><span id='topic+coerce+2Clist+2CWave-method'></span><span id='topic+coerce+2Cnumeric+2CWave-method'></span><span id='topic+coerce+2CWave+2Cdata.frame-method'></span><span id='topic+coerce+2CWave+2Cmatrix-method'></span><span id='topic+coerce+2CWaveGeneral+2Clist-method'></span><span id='topic+coerce+2CWave+2CWaveMC-method'></span>

<h3>Description</h3>

<p>Constructors and coercion for class <code>Wave</code> objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>Wave(left, ...)
## S4 method for signature 'numeric'
Wave(left, right = numeric(0), samp.rate = 44100, bit = 16, pcm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Wave_+3A_left">left</code>, <code id="Wave_+3A_right">right</code>, <code id="Wave_+3A_samp.rate">samp.rate</code>, <code id="Wave_+3A_bit">bit</code>, <code id="Wave_+3A_pcm">pcm</code></td>
<td>
<p>See Section &ldquo;Slots&rdquo; on the help page <a href="#topic+Wave-class">Wave-class</a>.
Except for numeric, the argument <code>left</code> can also be a matrix (1 or 2 columns), data.frame (1 or 2 columns), list (1 or 2 elements), or <code>WaveMC</code> (1 or 2 channels) object 
representing the channels.</p>
</td></tr>
<tr><td><code id="Wave_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the numeric method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The class definition has been extended in <span class="pkg">tuneR</span> version 1.0-0. Saved objects of class <code>Wave</code> generated with former versions can be 
updated with <code><a href="#topic+updateWave">updateWave</a></code> to match the new definition.</p>


<h3>Value</h3>

<p>An object of <a href="#topic+Wave-class">Wave-class</a>.
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p><a href="#topic+Wave-class">Wave-class</a>, <a href="#topic+WaveMC-class">WaveMC-class</a>, <code><a href="#topic+writeWave">writeWave</a></code>, <code><a href="#topic+readWave">readWave</a></code>, <code><a href="#topic+updateWave">updateWave</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># constructing a Wave object (1 sec.) containing sinus sound with 440Hz:
x &lt;- seq(0, 2*pi, length = 44100)
channel &lt;- round(32000 * sin(440 * x))
Wobj &lt;- Wave(left = channel)
Wobj

# or more easily:
Wobj &lt;- sine(440)
</code></pre>

<hr>
<h2 id='Wave-class'>Class Wave</h2><span id='topic+Wave-class'></span>

<h3>Description</h3>

<p>Class &ldquo;Wave&rdquo;.</p>


<h3>Details</h3>

<p>The class definition has been extended in <span class="pkg">tuneR</span> version 1.0-0. Saved objects of class Wave generated with former versions can be 
updated with <code><a href="#topic+updateWave">updateWave</a></code> to match the new definition.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Wave", ...)</code>,
or more conveniently using the function <code><a href="#topic+Wave">Wave</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>left</code>:</dt><dd><p>Object of class <code>"numeric"</code> representing the left channel.</p>
</dd>
<dt><code>right</code>:</dt><dd><p>Object of class <code>"numeric"</code> representing the right channel,
<code>NULL</code> if mono.</p>
</dd>
<dt><code>stereo</code>:</dt><dd><p>Object of class <code>"logical"</code> indicating whether this
is a stereo (two channels) or mono representation.</p>
</dd>
<dt><code>samp.rate</code>:</dt><dd><p>Object of class <code>"numeric"</code> - the sampling rate, e.g. 44100 for CD quality.</p>
</dd>
<dt><code>bit</code>:</dt><dd><p>Object of class <code>"numeric"</code>, common is 16 for CD quality, or
8 for a rather rough representation.</p>
</dd>
<dt><code>pcm</code>:</dt><dd><p>Object of class <code>"logical"</code> indicating whether this is a 
PCM or IEEE_FLOAT Wave format.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+Wave">Wave</a></code>, <code><a href="#topic+updateWave">updateWave</a></code>, and for multi channel Wave files see <a href="#topic+WaveMC-class">WaveMC-class</a></p>

<hr>
<h2 id='Waveforms'>Create Wave Objects of Special Waveforms</h2><span id='topic+Waveforms'></span><span id='topic+sine'></span><span id='topic+sawtooth'></span><span id='topic+square'></span><span id='topic+silence'></span><span id='topic+noise'></span><span id='topic+pulse'></span>

<h3>Description</h3>

<p>Create a <code><a href="#topic+Wave">Wave</a></code> object of special waveform such as
silcence, power law (white, red, pink, ...) noise, sawtooth, sine, square, and pulse.</p>


<h3>Usage</h3>

<pre><code class='language-R'>noise(kind = c("white", "pink", "power", "red"), duration = samp.rate, 
      samp.rate = 44100, bit = 1, stereo = FALSE, 
      xunit = c("samples", "time"), alpha = 1, ...)

pulse(freq, duration = samp.rate, from = 0, samp.rate = 44100,
      bit = 1, stereo = FALSE, xunit = c("samples", "time"),
      width = 0.1, plateau = 0.2, interval = 0.5, ...)

sawtooth(freq, duration = samp.rate, from = 0, samp.rate = 44100, 
         bit = 1, stereo = FALSE, xunit = c("samples", "time"), 
         reverse = FALSE, ...)

silence(duration = samp.rate, from = 0, samp.rate = 44100, 
        bit = 1, stereo = FALSE, xunit = c("samples", "time"), ...)

sine(freq, duration = samp.rate, from = 0, samp.rate = 44100, 
     bit = 1, stereo = FALSE, xunit = c("samples", "time"), ...)

square(freq, duration = samp.rate, from = 0, samp.rate = 44100, 
       bit = 1, stereo = FALSE, xunit = c("samples", "time"), 
       up = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Waveforms_+3A_kind">kind</code></td>
<td>
<p>The kind of noise, &ldquo;white&rdquo;, &ldquo;pink&rdquo;, &ldquo;power&rdquo;, or &ldquo;red&rdquo;
(these are not dB adjusted (!) but all except for &ldquo;white&rdquo; are linear decreasing on a log-log scale).
Algorithm for generating power law noise is taken from Timmer and König (1995).</p>
</td></tr>
<tr><td><code id="Waveforms_+3A_freq">freq</code></td>
<td>
<p>The frequency (in Hertz) to be generated.</p>
</td></tr>
<tr><td><code id="Waveforms_+3A_duration">duration</code></td>
<td>
<p>Duration of the <code>Wave</code> in <code>xunit</code>.</p>
</td></tr>
<tr><td><code id="Waveforms_+3A_from">from</code></td>
<td>
<p>Starting value of the <code>Wave</code> in <code>xunit</code>.</p>
</td></tr>
<tr><td><code id="Waveforms_+3A_samp.rate">samp.rate</code></td>
<td>
<p>Sampling rate of the <code>Wave</code>.</p>
</td></tr>
<tr><td><code id="Waveforms_+3A_bit">bit</code></td>
<td>
<p>Resolution of the <code>Wave</code> and rescaling unit. This may be<br />
<code>1</code> (default) for rescaling to numeric values in [-1,1],<br />
<code>8</code> (i.e. 8-bit) for rescaling to integers in [0, 254],<br />
<code>16</code> (i.e. 16-bit) for rescaling to integers in [-32767, 32767],<br />
<code>24</code> (i.e. 24-bit) for rescaling to integers in [-8388607, 8388607],<br />
<code>32</code> (i.e. 32-bit) for rescaling either to integers in [-2147483647, 2147483647] 
(PCM Wave format if <code>pcm = TRUE</code>) or to numeric values in [-1, 1] 
(FLOAT_IEEE Wave format if <code>pcm = FALSE</code>),<br />
<code>64</code> (i.e. 64-bit) for rescaling to numeric values in [-1, 1] (FLOAT_IEEE Wave format), and<br />
<code>0</code> for not rescaling at all. These numbers are internally passed to <code><a href="#topic+normalize">normalize</a></code>.
</p>
<p>The <code>Wave</code> slot <code>bit</code> will be set to 32 if <code>bit = 0</code>, <code>bit = 1</code> or <code>bit = 32</code>.</p>
</td></tr>  
<tr><td><code id="Waveforms_+3A_stereo">stereo</code></td>
<td>
<p>Logical, if <code>TRUE</code>, a stereo sample will be generated.
The right channel is identical to the left one for <code>sawtooth</code>, <code>silence</code>,
<code>sine</code>, and <code>square</code>. For <code>noise</code>, both channel are independent.</p>
</td></tr>
<tr><td><code id="Waveforms_+3A_xunit">xunit</code></td>
<td>
<p>Character indicating which units are used
(both in arguments <code>duration</code> and <code>from</code>).
If <code>xunit = "time"</code>, the unit is time in seconds, otherwise the number of samples.</p>
</td></tr>
<tr><td><code id="Waveforms_+3A_alpha">alpha</code></td>
<td>
<p>The power for the power law noise (defaults are 1 for pink and 1.5 for red noise)
<code class="reqn">1/f^{\alpha}</code>.</p>
</td></tr>
<tr><td><code id="Waveforms_+3A_reverse">reverse</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the waveform will be mirrored vertically.</p>
</td></tr>
<tr><td><code id="Waveforms_+3A_up">up</code></td>
<td>
<p>A number between 0 and 1 giving the percentage of the waveform at max value 
(= 1 - percentage of min value).</p>
</td></tr>
<tr><td><code id="Waveforms_+3A_width">width</code></td>
<td>
<p>Relative pulses width: the proportion of time the amplitude is non-zero.</p>
</td></tr>
<tr><td><code id="Waveforms_+3A_plateau">plateau</code></td>
<td>
<p>Relative plateau width: the proportion of the pulse width where amplitude is ±1.</p>
</td></tr>
<tr><td><code id="Waveforms_+3A_interval">interval</code></td>
<td>
<p>Relative interval between the up-going and down-going pulses with respect to the center of the wave
period (0: immediatly after up-going, 1: center of the wave period).</p>
</td></tr>
<tr><td><code id="Waveforms_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="#topic+Wave">Wave</a></code> through the internal function <code>postWaveform</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+Wave">Wave</a></code> object.
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a>,
partly based on code from Matthias Heymann's former package &lsquo;sound&rsquo;,
Anita Thieler, Guillaume Guénard</p>


<h3>References</h3>

<p>J. Timmer and M. König (1995): On generating power law noise. Astron. Astrophys. 300, 707-710.
</p>


<h3>See Also</h3>

<p><a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code>, <code><a href="#topic+normalize">normalize</a></code>, <code><a href="#topic+noSilence">noSilence</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Wobj &lt;- sine(440, duration = 1000)
Wobj2 &lt;- noise(duration = 1000)
Wobj3 &lt;- pulse(220, duration = 1000)
plot(Wobj)
plot(Wobj2)
plot(Wobj3)
</code></pre>

<hr>
<h2 id='Waveforms-internal'>Internal support functions for Waveforms</h2><span id='topic+preWaveform'></span><span id='topic+postWaveform'></span>

<h3>Description</h3>

<p>Internal functions to support those for generating <a href="#topic+Waveforms">Waveforms</a>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>preWaveform(freq, duration, from, xunit, samp.rate)
postWaveform(channel, samp.rate, bit, stereo, pcm = FALSE, ...)
</code></pre>


<h3>See Also</h3>

<p><code><a href="#topic+Waveforms">Waveforms</a></code></p>

<hr>
<h2 id='WaveMC'>Constructors and coercion for class WaveMC objects</h2><span id='topic+WaveMC'></span><span id='topic+WaveMC+2CANY-method'></span><span id='topic+WaveMC+2CWave-method'></span><span id='topic+WaveMC+2Cnumeric-method'></span><span id='topic+WaveMC+2Cmatrix-method'></span><span id='topic+WaveMC+2Cdata.frame-method'></span><span id='topic+WaveMC+2Clist-method'></span><span id='topic++5B+2CWaveMC-method'></span><span id='topic+coerce+2Cmatrix+2CWaveMC-method'></span><span id='topic+coerce+2Cdata.frame+2CWaveMC-method'></span><span id='topic+coerce+2Clist+2CWaveMC-method'></span><span id='topic+coerce+2Cnumeric+2CWaveMC-method'></span><span id='topic+coerce+2CWaveMC+2Cdata.frame-method'></span><span id='topic+coerce+2CWaveMC+2Cmatrix-method'></span><span id='topic+coerce+2CWaveMC+2CWave-method'></span>

<h3>Description</h3>

<p>Constructors and coercion for class <code>WaveMC</code> objects</p>


<h3>Usage</h3>

<pre><code class='language-R'>WaveMC(data, ...)
## S4 method for signature 'matrix'
WaveMC(data = matrix(numeric(0), 0, 0), samp.rate = 44100, bit = 16, pcm = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WaveMC_+3A_data">data</code></td>
<td>
<p>Except for a numeric matrix, the argument <code>data</code> can also be a numeric vector (for one channel), data.frame (columns representing channels), 
list (elements containing numeric vectors that represent the channels), or <code>Wave</code> object.</p>
</td></tr>
<tr><td><code id="WaveMC_+3A_samp.rate">samp.rate</code>, <code id="WaveMC_+3A_bit">bit</code>, <code id="WaveMC_+3A_pcm">pcm</code></td>
<td>
<p>See Section &ldquo;Slots&rdquo; on the help page <a href="#topic+WaveMC-class">WaveMC-class</a>.</p>
</td></tr>
<tr><td><code id="WaveMC_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the matrix method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of <a href="#topic+WaveMC-class">WaveMC-class</a>.
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a>, Sarah Schnackenberg</p>


<h3>See Also</h3>

<p><a href="#topic+WaveMC-class">WaveMC-class</a>, <a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+writeWave">writeWave</a></code>, <code><a href="#topic+readWave">readWave</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># constructing a WaveMC object (1 sec.) containing sinus sound with 440Hz:
x &lt;- seq(0, 2*pi, length = 44100)
channel &lt;- round(32000 * sin(440 * x))
WMCobj &lt;- WaveMC(data = channel)
WMCobj
</code></pre>

<hr>
<h2 id='WaveMC-class'>Class WaveMC</h2><span id='topic+WaveMC-class'></span>

<h3>Description</h3>

<p>Class &ldquo;WaveMC&rdquo;.</p>


<h3>Details</h3>

<p>This class has been added in <span class="pkg">tuneR</span> version 1.0-0 for representation and construction 
of multi channel Wave files. Objects of class <code>Wave</code> can be transformed to the new class definition 
by calls of the form <code>as(..., "WaveMC")</code>. Coercion from the <code>WaveMC</code> class to the <a href="#topic+Wave-class">Wave-class</a> 
works via  <code>as(..., "Wave")</code> if there are no more than 2 channels.
Coercing back to the <a href="#topic+Wave-class">Wave-class</a> can be useful since some (very few) functions cannot yet deal with multi channel Wave objects.
</p>
<p>Note that also the <a href="#topic+Wave-class">Wave-class</a> definition has been extended 
in <span class="pkg">tuneR</span> version 1.0-0. For more details see <a href="#topic+Wave-class">Wave-class</a>.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("WaveMC", ...)</code>,
or more conveniently using the function <code><a href="#topic+WaveMC">WaveMC</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"matrix"</code> containing numeric data, where each column is representing one channel.
Column names are the appropriate way to name different channels. 
The data object <code><a href="#topic+MCnames">MCnames</a></code> contains a data frame of standard names for channels in multi channel Wave files.</p>
</dd>
<dt><code>samp.rate</code>:</dt><dd><p>Object of class <code>"numeric"</code> - the sampling rate, e.g. 44100 for CD quality.</p>
</dd>
<dt><code>bit</code>:</dt><dd><p>Object of class <code>"numeric"</code>, common is 16 for CD quality, or
8 for a rather rough representation.</p>
</dd>
<dt><code>pcm</code>:</dt><dd><p>Object of class <code>"logical"</code> indicating whether this is a 
PCM or IEEE_FLOAT Wave format.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a>, Sarah Schnackenberg</p>


<h3>See Also</h3>

<p><code><a href="#topic+WaveMC">WaveMC</a></code>, <a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+MCnames">MCnames</a></code></p>

<hr>
<h2 id='WavPlayer'>Getting and setting the default player for Wave files</h2><span id='topic+setWavPlayer'></span><span id='topic+getWavPlayer'></span>

<h3>Description</h3>

<p>Getting and setting the default player for Wave files</p>


<h3>Usage</h3>

<pre><code class='language-R'>setWavPlayer(player)
getWavPlayer()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WavPlayer_+3A_player">player</code></td>
<td>
<p>Set the character string to call a Wave file player (including optional arguments) 
using <code><a href="base.html#topic+options">options</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>getWavPlayer</code> returns the character string that has been set by <code>setWavPlayer</code>.
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p><a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code>, <code><a href="#topic+play">play</a></code></p>

<hr>
<h2 id='writeWave'>Writing Wave files</h2><span id='topic+writeWave'></span>

<h3>Description</h3>

<p>Writing Wave files.</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeWave(object, filename, extensible = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeWave_+3A_object">object</code></td>
<td>
<p>Object of class <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code> to be written to a Wave file.</p>
</td></tr>
<tr><td><code id="writeWave_+3A_filename">filename</code></td>
<td>
<p>Filename of the file to be written.</p>
</td></tr>
<tr><td><code id="writeWave_+3A_extensible">extensible</code></td>
<td>
<p>If <code>TRUE</code> (default), an extensible Wave format file is written. If <code>FALSE</code>, a non-extensible Wave file is written.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is only possible to write a non-extensible Wave format file for objects of class <code><a href="#topic+Wave">Wave</a></code> or
for objects of class <code><a href="#topic+WaveMC">WaveMC</a></code> with one or two channels (mono or stereo).
</p>
<p>If the argument <code>object</code> is a <a href="#topic+Wave-class">Wave-class</a> object, the channels are automatically chosen to be
&ldquo;FL&rdquo; (for mono) or &ldquo;FL&rdquo; and &ldquo;FR&rdquo; (for stereo).
</p>
<p>The channel mask used to arrange the channel ordering in multi channel Wave files is written
according to Microsoft standards as given in the data frame <code><a href="#topic+MCnames">MCnames</a></code> containing the first 18 standard channels.
In the case of writing a multi channel Wave file, the column names of the object <code>object</code> (<code>colnames(object)</code>) must be specified and
must uniquely identify the channel ordering for WaveMC objects.
The column names of the object of class <code><a href="#topic+WaveMC">WaveMC</a></code> have to be a subset of the 18 standard channels
and have to match the corresponding abbreviated names.
(See <code><a href="#topic+MCnames">MCnames</a></code> for possible channels and the abbreviated names: 
&ldquo;FL&rdquo;, &ldquo;FR&rdquo;, &ldquo;FC&rdquo;, &ldquo;LF&rdquo;, &ldquo;BL&rdquo;, &ldquo;BR&rdquo;,
&ldquo;FLC&rdquo;, &ldquo;FRC&rdquo;, &ldquo;BC&rdquo;, &ldquo;SL&rdquo;, &ldquo;SR&rdquo;, &ldquo;TC&rdquo;, 
&ldquo;TFL&rdquo;, &ldquo;TFC&rdquo;, &ldquo;TFR&rdquo;, &ldquo;TBL&rdquo;, &ldquo;TBC&rdquo; and &ldquo;TBR&rdquo;).
</p>
<p>The function <code><a href="#topic+normalize">normalize</a></code> can be used to transform and rescale data to an appropriate amplitude range for
various Wave file formats (either pcm with 8-, 16-, 24- or 32-bit or IEEE_FLOAT with 32- or 64-bit).
</p>


<h3>Value</h3>

<p><code>writeWave</code> creates a Wave file, but returns nothing.
</p>


<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a>, Sarah Schnackenberg</p>


<h3>See Also</h3>

<p><a href="#topic+Wave-class">Wave-class</a>, <code><a href="#topic+Wave">Wave</a></code>, <a href="#topic+WaveMC-class">WaveMC-class</a>, <code><a href="#topic+WaveMC">WaveMC</a></code>, <code><a href="#topic+normalize">normalize</a></code>, <code><a href="#topic+MCnames">MCnames</a></code>, <code><a href="#topic+readWave">readWave</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>Wobj &lt;- sine(440)

tdir &lt;- tempdir()
tfile &lt;- file.path(tdir, "myWave.wav")
writeWave(Wobj, filename = tfile)
list.files(tdir, pattern = "\\.wav$")
newWobj &lt;- readWave(tfile)
newWobj
file.remove(tfile)
</code></pre>

<hr>
<h2 id='Wspec-class'>Class Wspec</h2><span id='topic+Wspec-class'></span><span id='topic++5B+2CWspec-method'></span><span id='topic+Wspec'></span>

<h3>Description</h3>

<p>Class &ldquo;Wspec&rdquo; (<em>W</em>ave <em>spec</em>trums).
Objects of this class represent a bunch of periodograms 
(see <code><a href="#topic+periodogram">periodogram</a></code>, each generated by <code><a href="stats.html#topic+spectrum">spectrum</a></code>)
corresponding to one or several windows of one <code><a href="#topic+Wave">Wave</a></code> or  <code><a href="#topic+WaveMC">WaveMC</a></code> object.
Redundancy (e.g. same frequencies in each of the periodograms) will be omitted, 
hence reducing memory consumption.
</p>


<h3>Details</h3>

<p>The subset function &ldquo;<code>[</code>&rdquo; extracts the selected 
elements of slots <code>spec</code>, <code>starts</code>, <code>variance</code> and <code>energy</code>
and returns the other slots unchanged.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("Wspec", ...)</code>,
but regularly they will be created by calls to the function <code><a href="#topic+periodogram">periodogram</a></code>.
</p>


<h3>Slots</h3>

<p>The following slots are defined. For details see the constructor function <code><a href="#topic+periodogram">periodogram</a></code>.
</p>

<dl>
<dt><code>freq</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>spec</code>:</dt><dd><p>Object of class <code>"list"</code>.</p>
</dd>
<dt><code>kernel</code>:</dt><dd><p>Object of class <code>"ANY"</code>.</p>
</dd>
<dt><code>df</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>taper</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>width</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>overlap</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>normalize</code>:</dt><dd><p>Object of class <code>"logical"</code>.</p>
</dd>
<dt><code>starts</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>stereo</code>:</dt><dd><p>Object of class <code>"logical"</code>.</p>
</dd>
<dt><code>samp.rate</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>variance</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>energy</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>


<ul>
<li><p> the <code>show</code>, <code>plot</code> and <code>summary</code> methods,
</p>
</li>
<li><p> for the constructor function and some examples: <code><a href="#topic+periodogram">periodogram</a></code> 
(and hence also <code><a href="stats.html#topic+spec.pgram">spec.pgram</a></code>, <a href="#topic+Wave-class">Wave-class</a>,  <code><a href="#topic+Wave">Wave</a></code>, <a href="#topic+WaveMC-class">WaveMC-class</a>, and <code><a href="#topic+WaveMC">WaveMC</a></code>)
</p>
</li>
<li> <p><code><a href="#topic+WspecMat">WspecMat</a></code> for a similar class that represents the spectrum in form of a matrix.
</p>
</li></ul>


<hr>
<h2 id='WspecMat-class'>Class WspecMat</h2><span id='topic+WspecMat-class'></span><span id='topic++5B+2CWspecMat-method'></span><span id='topic+coerce+2CWspec+2CWspecMat-method'></span><span id='topic++5B+2CWspecMat-method'></span><span id='topic+WspecMat'></span>

<h3>Description</h3>

<p>Class &ldquo;WspecMat&rdquo; (<em>W</em>ave <em>spec</em>trums as <em>Mat</em>rix).
Objects of this class represent a bunch of periodograms 
(see <code><a href="#topic+periodogram">periodogram</a></code>, each generated by <code><a href="stats.html#topic+spectrum">spectrum</a></code>)
corresponding to one or several windows of one <code><a href="#topic+Wave">Wave</a></code> or <code><a href="#topic+WaveMC">WaveMC</a></code> object.
Redundancy (e.g. same frequencies in each of the periodograms) will be omitted, 
hence reducing memory consumption.
</p>


<h3>Details</h3>

<p>The subset function &ldquo;<code>[</code>&rdquo; extracts the selected 
elements of slots <code>spec</code>, <code>starts</code>, <code>variance</code> and <code>energy</code>
and returns the other slots unchanged.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("WspecMat", ...)</code>,
but regularly they will be created from a <code><a href="#topic+Wspec">Wspec</a></code> object 
by calls such as <code>as(Wspec_Object, "WspecMat")</code>.
</p>


<h3>Slots</h3>

<p>The following slots are defined. For details see the constructor function <code><a href="#topic+periodogram">periodogram</a></code>.
</p>

<dl>
<dt><code>freq</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>spec</code>:</dt><dd><p>Object of class <code>"matrix"</code>.</p>
</dd>
<dt><code>kernel</code>:</dt><dd><p>Object of class <code>"ANY"</code>.</p>
</dd>
<dt><code>df</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>taper</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>width</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>overlap</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>normalize</code>:</dt><dd><p>Object of class <code>"logical"</code>.</p>
</dd>
<dt><code>starts</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>stereo</code>:</dt><dd><p>Object of class <code>"logical"</code>.</p>
</dd>
<dt><code>samp.rate</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>variance</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
<dt><code>energy</code>:</dt><dd><p>Object of class <code>"numeric"</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Uwe Ligges <a href="mailto:ligges@statistik.tu-dortmund.de">ligges@statistik.tu-dortmund.de</a></p>


<h3>See Also</h3>

<p>the <code>show</code>, <code>plot</code> and <code>summary</code> methods</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
