<!DOCTYPE html><html lang="en"><head><title>Help for package prior3D</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {prior3D}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#biodiv_df'><p>Example biodiversity data.frame</p></a></li>
<li><a href='#coherence'><p>Coherence metrics</p></a></li>
<li><a href='#Compare_2D_3D'><p>Compare 2D vs 3D prioritization algorithms</p></a></li>
<li><a href='#evaluate_3D'><p>Evaluate prioritization solution over 3D feature distributions</p></a></li>
<li><a href='#get_biodiv_raster'><p>Example biodiversity raster</p></a></li>
<li><a href='#get_depth_raster'><p>Example depth raster</p></a></li>
<li><a href='#get_rast'><p>Read multiple rast files</p></a></li>
<li><a href='#plot_3D'><p>Plot output of prioritize_3D</p></a></li>
<li><a href='#plot_Compare_2D_3D'><p>Plot output of Compare_2D_3D</p></a></li>
<li><a href='#plot_sumrast'><p>Plot sum list of SpatRaster objects.</p></a></li>
<li><a href='#prioritize_3D'><p>3D prioritization algorithm</p></a></li>
<li><a href='#split_rast'><p>Split 2D feature distributions into 3D ones</p></a></li>
<li><a href='#sumrast'><p>Sum list of SpatRaster objects.</p></a></li>
<li><a href='#terra_jaccard'><p>Jaccard similarity coefficient among two SpatRaster objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>3D Prioritization Algorithm</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christos Adam &lt;econp266@econ.soc.uoc.gr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Three-dimensional systematic conservation planning, conducting
             nested prioritization analyses across multiple depth levels and
             ensuring efficient resource allocation throughout the water column.
             It provides a structured workflow designed to address biodiversity
             conservation and management challenges in the 3 dimensions, while
             facilitating users’ choices and parameterization (Doxa et al. 2025
             &lt;<a href="https://doi.org/10.1016%2Fj.ecolmodel.2024.110919">doi:10.1016/j.ecolmodel.2024.110919</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cadam00/prior3D">https://github.com/cadam00/prior3D</a>,
<a href="https://cadam00.github.io/prior3D/">https://cadam00.github.io/prior3D/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/cadam00/prior3D/issues">https://github.com/cadam00/prior3D/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>prioritizr (&ge; 8.0.4), terra, maps (&ge; 3.4.2), highs, viridis
(&ge; 0.6.5), readxl (&ge; 1.4.3), rasterdiv (&ge; 0.3.4), geodiv (&ge;
1.1.0), methods, stats, utils, graphics, grDevices</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-25 07:42:27 UTC; Administrator</td>
</tr>
<tr>
<td>Author:</td>
<td>Aggeliki Doxa <a href="https://orcid.org/0000-0003-4279-1499"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Christos Adam <a href="https://orcid.org/0009-0003-3244-7034"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Nikolaos Nagkoulis
    <a href="https://orcid.org/0000-0002-1900-2634"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Antonios D. Mazaris
    <a href="https://orcid.org/0000-0002-4961-5490"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Stelios Katsanevakis
    <a href="https://orcid.org/0000-0002-5137-7540"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-25 08:10:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='biodiv_df'>Example biodiversity data.frame</h2><span id='topic+biodiv_df'></span>

<h3>Description</h3>

<p>Example biodiversity data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(biodiv_df)
</code></pre>


<h3>Details</h3>

<p>Example of input <code>biodiv_df</code> used for functions.
</p>


<h3>Value</h3>

<p>data.frame object with information about features.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(biodiv_df)
head(biodiv_df)
</code></pre>

<hr>
<h2 id='coherence'>Coherence metrics</h2><span id='topic+coherence'></span>

<h3>Description</h3>

<p>Coherence metrics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coherence(x, w, metric = "sa", normalize = TRUE, plot = TRUE, addlines = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coherence_+3A_x">x</code></td>
<td>

<p>Output of <b>Compare_2D_3D</b> function.
</p>
</td></tr>
<tr><td><code id="coherence_+3A_w">w</code></td>
<td>

<p>Integer indicating square window dimensions.
</p>
</td></tr>
<tr><td><code id="coherence_+3A_metric">metric</code></td>
<td>

<p>Cohension metric to use. It must be one of <code>"sa"</code>, <code>"sku"</code> and <code>"rao"</code>
</p>
</td></tr>
<tr><td><code id="coherence_+3A_normalize">normalize</code></td>
<td>

<p>If <code>TRUE</code>, then sum of solutions is normalized at a <code class="reqn">[0,1]</code> scale.
</p>
</td></tr>
<tr><td><code id="coherence_+3A_plot">plot</code></td>
<td>

<p>If <code>TRUE</code>, then coherence maps are ploted.
</p>
</td></tr>
<tr><td><code id="coherence_+3A_addlines">addlines</code></td>
<td>

<p>If <code>TRUE</code>, then border lines from <code>maps::map</code> are ploted.
</p>
</td></tr>
<tr><td><code id="coherence_+3A_...">...</code></td>
<td>

<p>Further arguments passed in function, based on metric choice. See more in Details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>"sa"</code> and <code>"sku"</code> are derived from <code>geodiv::focal_metrics</code> and
in ellipsis (<code>...</code>) further arguments of
<code>geodiv::focal_metrics</code>  are passed.
</p>
<p><code>metric = "rao"</code> is derived from <code>rasterdiv::paRao</code> and in ellipsis
(<code>...</code>) further arguments of <code>rasterdiv::paRao</code> are passed.
</p>


<h3>Value</h3>

<p><code>numeric</code> vector with 2D and 3D metrics. The result maps are optionally
ploted.
</p>


<h3>References</h3>

<p>Rocchini, Duccio, Matteo Marcantonio, Daniele Da Re, Giovanni Bacaro, Enrico Feoli, Giles
Foody, Reinhard Furrer, et al. 2021. &quot;From zero to infinity: Minimum to maximum diversity
of the planet by spatio-parametric Rao’s quadratic entropy.&quot; Global Ecology and
Biogeography 30 (5): 2315.
<a href="https://doi.org/10.1111/geb.13270">doi:10.1111/geb.13270</a>.
</p>
<p>Rocchini, Duccio, Elisa Thouverai, Matteo Marcantonio, Martina Iannacito, Daniele Da Re,
Michele Torresani, Giovanni Bacaro, et al. 2021. &quot;rasterdiv - An Information Theory
tailored R package for measuring ecosystem heterogeneity from space: To the origin and
back.&quot; Methods in Ecology and Evolution 12 (6): 2195.
<a href="https://doi.org/10.1111/2041-210X.13583">doi:10.1111/2041-210X.13583</a>.
</p>
<p>Smith, Annie C., Phoebe Zarnetske, Kyla Dahlin, Adam Wilson, and Andrew Latimer. 2023.
Geodiv: Methods for Calculating Gradient Surface Metrics.
<a href="https://CRAN.R-project.org/package=geodiv">
https://CRAN.R-project.org/package=geodiv</a>.
</p>
<p>Becker OScbRA, Minka ARWRvbRBEbTP, Deckmyn. A (2023). maps: Draw
Geographical Maps. R package version 3.4.2,
<a href="https://CRAN.R-project.org/package=maps">
https://CRAN.R-project.org/package=maps</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Compare_2D_3D">Compare_2D_3D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This example requires commercial solver from 'gurobi' package for
## portfolio = "gap". Else replace it with e.g. portfolio = "shuffle" for using
## a free solver like the one from 'highs' package.

biodiv_raster &lt;- get_biodiv_raster()
depth_raster &lt;- get_depth_raster()
data(biodiv_df)

out_2D_3D &lt;- Compare_2D_3D(biodiv_raster = biodiv_raster,
                           depth_raster = depth_raster,
                           breaks = c(0, -40, -200, -2000, -Inf),
                           biodiv_df = biodiv_df,
                           budget_percents = seq(0, 1, 0.1),
                           budget_weights = "richness",
                           threads = parallel::detectCores(),
                           portfolio = "gap",
                           portfolio_opts = list(number_solutions = 10))

coherence(out_2D_3D, w = 3, metric = "sa")
coherence(out_2D_3D, w = 3, metric = "sku")
coherence(out_2D_3D, w = 3, metric = "rao")

## End(Not run)
</code></pre>

<hr>
<h2 id='Compare_2D_3D'>Compare 2D vs 3D prioritization algorithms</h2><span id='topic+Compare_2D_3D'></span>

<h3>Description</h3>

<p>Compare 2D vs 3D prioritization algorithms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Compare_2D_3D(biodiv_raster, depth_raster, breaks, biodiv_df, val_depth_range = TRUE,
priority_weights = NULL, budget_percents = seq(0,1,0.1), budget_weights = "equal",
penalty = 0, edge_factor = 0.5, gap = 0.1, threads = 1L, sep_priority_weights = ",",
portfolio = "gap", portfolio_opts = list(number_solutions = 10, pool_gap = 0.1),
sep_biodiv_df = ",", locked_in_raster = NULL, locked_out_raster = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Compare_2D_3D_+3A_biodiv_raster">biodiv_raster</code></td>
<td>

<p>SpatRaster object or folder path with 2D feature distributions as layers.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_depth_raster">depth_raster</code></td>
<td>

<p>SpatRaster object or file path with elevation/bathymetric map.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_breaks">breaks</code></td>
<td>

<p>Numeric vector defining the range of depth layers to use.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_biodiv_df">biodiv_df</code></td>
<td>

<p><code>data.frame</code> or a file path (CSV, TXT, XLS, or XLSX) containing additional
information about biodiversity features.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_val_depth_range">val_depth_range</code></td>
<td>

<p>No correction of the splitted 3D distributions based on depth range of the biodiversity
features (<code>"min_z"</code> and <code>"max_z"</code> from <code>biodiv_df</code>) is needed.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_priority_weights">priority_weights</code></td>
<td>

<p><code>data.frame</code> object or file path (CSV, TXT, XLS, or XLSX) containing group names of
biodiversity features in the first column and corresponding group weights in the second
column. This data.frame attributes distinct prioritization weights to different
biodiversity features or groups of features.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_budget_percents">budget_percents</code></td>
<td>

<p>Numeric value <code class="reqn">[0,1]</code> or vector containing budget percentages to use. The default is
<code>seq(0,1,0.1)</code>.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_budget_weights">budget_weights</code></td>
<td>

<p>Numeric weight vector for budget_percents allocation among depth levels.
Otherwise it can be a string with one of the choices <code>"equal"</code>, <code>"area"</code> or
<code>"richness"</code>.
Alternatively, it can be a numerical vector with custom weights corresponding to each
depth layer, where the first value corresponds to the surface and last one corresponds to
the bottom of the sea. The weights are normalized if their sum exceeds 1. If not
specified, an equal distribution of budget among depth levels is used, as the default.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_penalty">penalty</code></td>
<td>

<p>Numeric penalty applied to each depth zone, as defined in the<br />
<code>prioritizr::add_boundary_penalties</code>.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_edge_factor">edge_factor</code></td>
<td>

<p>Numeric edge factor applied to each depth zone, as defined in the<br />
<code>prioritizr::add_boundary_penalties</code>.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_gap">gap</code></td>
<td>

<p>The optimality gap for the solver, as defined in the <span class="pkg">prioritizr</span> package.
The default gap is 0.1.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_threads">threads</code></td>
<td>

<p>The number of solver threads to be used. The default is 1.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_sep_priority_weights">sep_priority_weights</code></td>
<td>

<p>Separator used in priority_weights file, if priority_weights is in path format.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_portfolio">portfolio</code></td>
<td>

<p>The portfolio to be used, choosing between <code>"extra"</code>,
<code>"gap"</code>, <code>"cuts"</code> and <code>"shuffle"</code> portfolios.
The default is <code>"gap"</code>. <code>portfolio=""</code> indicates that no portfolio is used.
For more about <code>portfolios</code> see <span class="pkg">prioritizr</span>.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_portfolio_opts">portfolio_opts</code></td>
<td>

<p>The <span class="pkg">prioritizr</span> portfolio options to be used.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_sep_biodiv_df">sep_biodiv_df</code></td>
<td>

<p>Separator<br />
used in biodiv_df file, if biodiv_df is in path format.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_locked_in_raster">locked_in_raster</code></td>
<td>

<p>An optional <code>locked_in_raster</code> SpatRaster to be used.
Note that these areas are considered as zero-cost.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_locked_out_raster">locked_out_raster</code></td>
<td>

<p>An optional <code>locked_out_raster</code> SpatRaster to be used.
Note that these areas are excluded from the solution.
</p>
</td></tr>
<tr><td><code id="Compare_2D_3D_+3A_verbose">verbose</code></td>
<td>

<p>If <code>verbose = TRUE</code>, then solver messages are printed as well. The default is
<code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To facilitate comparisons between 3D and 2D approaches, the <code>compare_2D_3D()</code>
function is provided in the package. This function enables users to conduct all steps of
the analysis (data generation, setting and solving the optimization problem
and producing outputs), by executing both 2D and 3D approaches, with similar settings,
that facilitate comparisons.  The function generates corresponding maps and graphs for
both approaches.
</p>
<p>The <code><a href="#topic+split_rast">split_rast</a></code> function is used to convert 2D distributions of
biodiversity features (rasters) into a 3D format.
</p>
<p>Here the <code>biodiv_df</code> can have the following
column names (independently of their order and any other names are ignored):
</p>

<ul>
<li><p><code>"species_name"</code>: <b>Mandatory</b> column with the feature names, which must
be the same with biodiv_raster.
</p>
</li>
<li><p><code>"pelagic"</code>: <b>Mandatory</b> column about the features' behaviour.
<code>TRUE</code> means that this feature is pelagic and <code>FALSE</code> means that this feature is
benthic.
</p>
</li>
<li><p><code>"min_z"</code>: <b>Optional</b> column about the minimum vertical range of
features. <code>NA</code> values are translated as unlimited upward feature movement.
</p>
</li>
<li><p><code>"max_z"</code>: <b>Optional</b> column about the maximum vertical range of
features. <code>NA</code> values are translated as unlimited downward feature movement.
</p>
</li>
<li><p><code>"group"</code>: <b>Optional</b> column with the group weights names.
</p>
</li></ul>

<p>Except from <code>biodiv_df</code>, an additional <code>data.frame</code> object can also be used for
defining group weights, named <code>priority_weights</code>. If used, this <code>data.frame</code>
object must have two columns:
</p>

<ul>
<li><p><code>"group"</code>: <b>Mandatory</b> column with the group weights names.
</p>
</li>
<li><p><code>"weight"</code>: <b>Mandatory</b> column with the group weights.
</p>
</li></ul>

<p>In case that no feature weights are desired, then <code>priority_weights</code> can be kept
to <code>NULL</code>.
</p>
<p><code>breaks</code> must be in correspondence to depth_raster file.
For example, if depth_raster has range <code class="reqn">[10, -3000]</code>, then a breaks vector of
<code>c(0,-40,-200,-2000,-Inf)</code> will create depth levels
<code class="reqn">[0,-40],\\(-40,-200], (-200, -2000], (-2000, -\infty)</code>
and set to NA cells with values greater than <code class="reqn">0</code>.
</p>
<p>If <code>val_depth_range = TRUE</code> (default), then no correction is done and the depth range
of the biodiversity features is derived from the corresponding feature distribution
raster and so <code>"min_z"</code> and <code>"max_z"</code> are ignored.
If <code>val_depth_range = FALSE</code>, then the function uses the minimum and maximum depth
information provided in the biodiv_df, so as to remove feature occurrences outside their
expected range.
</p>
<p><code>budget_percents</code>: Budget reflects the desired level of protection to be modeled.
It ranges from 0 to 1, with 0 indicating no resources available for protection,
while 1 signifies resources sufficient to protect the entire study area. Typically,
setting a budget of 0.3 corresponds to the 30% conservation target (i.e. 30% of the
total area set aside for conservation).
Users also have the flexibility to define multiple budget levels using a vector,
allowing for the exploration of various protection scenarios. For instance, a vector like
<code>c(0.1, 0.3, 0.5)</code> represents three scenarios where 10%, 30%, and 50% of the
study area are designated for protection.
</p>
<p><code>budget_weights</code>: The <b>Compare_2D_3D</b> function allows users to specify how the
budget is distributed among depth levels. Three allocation methods are available:
</p>

<ol>
<li><p>Equal Distribution: Allocates an equal share of the budget to each depth level<br />
(<code>budget_weights = "equal"</code>).
</p>
</li>
<li><p>Proportional to Area: Allocates budget based on the spatial extent of each depth
level<br />
(<code>budget_weights = "area"</code>).
</p>
</li>
<li><p>Proportional to Species Richness: Prioritizes budget allocation to depth levels with
higher species diversity (number of species). (<code>budget_weights = "richness"</code>)
</p>
</li></ol>

<p>Otherwise, it can be a numeric vector with length equal to the number of depth levels,
where each number indicates the budget share per depth level.
</p>
<p>The solver used for solving the prioritization problems is the best available on the
computer, following the solver hierarchy of <span class="pkg">prioritizr</span>.
</p>


<h3>Value</h3>

<p>A list containing the following objects (non-referenced are identical to the input ones):
</p>

<ul>
<li><p>split_features: output of <code><a href="#topic+split_rast">split_rast</a></code>
</p>
</li>
<li><p>solution3D: list with 3D solution per budget percentage
</p>
</li>
<li><p>absolute_held3D: <code>absolute_held</code> for 3D solutions (see
<code><a href="#topic+evaluate_3D">evaluate_3D</a></code>)
</p>
</li>
<li><p>overall_available3D: <code>overall_available</code> for 3D solutions (see
<code><a href="#topic+evaluate_3D">evaluate_3D</a></code>)
</p>
</li>
<li><p>overall_held3D: <code>overall_held</code> for 3D solutions (see
<code><a href="#topic+evaluate_3D">evaluate_3D</a></code>)
</p>
</li>
<li><p>relative_helds3D: <code>relative_held</code> for 3D solutions (see
<code><a href="#topic+evaluate_3D">evaluate_3D</a></code>)
</p>
</li>
<li><p>mean_overall_helds3D: <code>base::mean</code> of <code>overall_held</code>
for 3D solution (see <code><a href="#topic+evaluate_3D">evaluate_3D</a></code>) per budget
</p>
</li>
<li><p>sd_overall_helds3D: <code>stats::sd</code> of <code>overall_held</code>
for 3D solution (see <code><a href="#topic+evaluate_3D">evaluate_3D</a></code>) per budget
</p>
</li>
<li><p>depth_overall_available3D: <code>depth_overall_available</code> for 3D
solutions (see <code><a href="#topic+evaluate_3D">evaluate_3D</a></code>)
</p>
</li>
<li><p>solution2D: list with 2D solution per budget percentage
</p>
</li>
<li><p>absolute_held2D: <code>absolute_held</code> for 2D solutions (see
<code><a href="#topic+evaluate_3D">evaluate_3D</a></code>)
</p>
</li>
<li><p>overall_available2D: <code>overall_available</code> for 2D solutions (see
<code><a href="#topic+evaluate_3D">evaluate_3D</a></code>)
</p>
</li>
<li><p>overall_held2D: <code>overall_held</code> for 2D solutions (see
<code><a href="#topic+evaluate_3D">evaluate_3D</a></code>)
</p>
</li>
<li><p>relative_helds2D: <code>relative_held</code> for 2D solutions (see
<code><a href="#topic+evaluate_3D">evaluate_3D</a></code>)
</p>
</li>
<li><p>mean_overall_helds2D: <code>base::mean</code> of <code>overall_held</code>
for 2D solution (see <code><a href="#topic+evaluate_3D">evaluate_3D</a></code>) per budget
</p>
</li>
<li><p>sd_overall_helds2D: <code>stats::sd</code> of <code>overall_held</code>
for 2D solution (see <code><a href="#topic+evaluate_3D">evaluate_3D</a></code>) per budget
</p>
</li>
<li><p>depth_overall_available2D: <code>depth_overall_available</code> for 2D
solutions (see <code><a href="#topic+evaluate_3D">evaluate_3D</a></code>)
</p>
</li>
<li><p>names_features: names of features used
</p>
</li>
<li><p>total_amount: <code>total_amount</code> of features used
(see <code><a href="#topic+evaluate_3D">evaluate_3D</a></code>)
</p>
</li>
<li><p>overall_total_amount: <code>overal_total_amount</code> of names of features
used (see <code><a href="#topic+evaluate_3D">evaluate_3D</a></code>)
</p>
</li>
<li><p>jaccard_coef: <code><a href="#topic+terra_jaccard">terra_jaccard</a></code> per pair of 2D and 3D
solutions, given each budget
</p>
</li>
<li><p>depth_levels_names: Depth levels names
</p>
</li>
<li><p>biodiv_raster: <code>biodiv_raster</code> used, after cleaning
</p>
</li>
<li><p>biodiv_df: <code>biodiv_df</code> used after cleaning
</p>
</li></ul>



<h3>References</h3>

<p>Hanson, Jeffrey O, Richard Schuster, Nina Morrell, Matthew Strimas-Mackey, Brandon
P M Edwards, Matthew E Watts, Peter Arcese, Joseph Bennett, and Hugh P Possingham. 2024.
prioritizr: Systematic Conservation Prioritization in R. <a href="https://prioritizr.net">
https://prioritizr.net</a>.
</p>
<p>Lehtomäki, Joona (2016). Comparing prioritization methods, 21 June.<br />
Available at: <a href="https://rpubs.com/jlehtoma/priocomp">
https://rpubs.com/jlehtoma/priocomp</a>
(Accessed 1 June 2024).
</p>


<h3>See Also</h3>

<p><code>
<a href="#topic+evaluate_3D">evaluate_3D</a>,
<a href="#topic+terra_jaccard">terra_jaccard</a>,
<a href="#topic+split_rast">split_rast</a>,
<a href="#topic+plot_Compare_2D_3D">plot_Compare_2D_3D</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This example requires commercial solver from 'gurobi' package for
## portfolio = "gap". Else replace it with e.g. portfolio = "shuffle" for using
## a free solver like the one from 'highs' package.

biodiv_raster &lt;- get_biodiv_raster()
depth_raster &lt;- get_depth_raster()
data(biodiv_df)

out_2D_3D &lt;- Compare_2D_3D(biodiv_raster = biodiv_raster,
                           depth_raster = depth_raster,
                           breaks = c(0, -40, -200, -2000, -Inf),
                           biodiv_df = biodiv_df,
                           budget_percents = seq(0, 1, 0.1),
                           budget_weights = "richness",
                           threads = parallel::detectCores(),
                           portfolio = "gap",
                           portfolio_opts = list(number_solutions = 10))

plot_Compare_2D_3D(out_2D_3D, to_plot = "all", add_lines=TRUE)

# Arbitrary random weights
priority_weights &lt;- data.frame(c("A", "B", "C"), c(0.001, 1000, 1))
names(priority_weights) &lt;- c("group", "weight")
biodiv_df$group &lt;- rep(c("A", "B", "C"), length.out=20)
out_2D_3D &lt;- Compare_2D_3D(biodiv_raster = biodiv_raster,
                           depth_raster = depth_raster,
                           breaks = c(0, -40, -200, -2000, -Inf),
                           biodiv_df = biodiv_df,
                           priority_weights = priority_weights,
                           budget_percents = seq(0, 1, 0.1),
                           budget_weights = "richness",
                           threads = parallel::detectCores(),
                           portfolio = "gap",
                           portfolio_opts = list(number_solutions = 10))

plot_Compare_2D_3D(out_2D_3D, to_plot = "all", add_lines=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='evaluate_3D'>Evaluate prioritization solution over 3D feature distributions</h2><span id='topic+evaluate_3D'></span>

<h3>Description</h3>

<p>Evaluate prioritization solution over 3D feature distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_3D(solution, split_features)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate_3D_+3A_solution">solution</code></td>
<td>

<p>prioritization solution SpatRaster object.
</p>
</td></tr>
<tr><td><code id="evaluate_3D_+3A_split_features">split_features</code></td>
<td>

<p>A list of SpatRaster objects representing depth zones, where each element
corresponds to a different depth level, ranging from surface to the bottom of the sea.
The function uses the output of the split_rast function, but other multilevel (3D)
distribution data that conform to this structure is also acceptable.
First list element corresponds to the shallowest distribution and the last list element to
the deepest one.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function evaluates a prioritization solution over 3D feature distributions, by
estimating the relative and overall percentages of features under protection, as
designated by the prioritization solution.
</p>


<h3>Value</h3>

<p>A list containing the following evaluation metrics:
</p>

<ul>
<li><p>relative_held_raw: relative percentage under protection per feature and
per depth level
</p>
</li>
<li><p>relative_held: mean percentage under protection of all features per depth level
</p>
</li>
<li><p>overall_held: overall percentage under protection per feature
</p>
</li>
<li><p>overall_available: relative percentage under protection per feature and per
depth level, over total amount of each feature
</p>
</li>
<li><p>depth_overall_available: averages of overall_available per depth
</p>
</li>
<li><p>absolute_held: absolute value per feature and per depth under protection
</p>
</li>
<li><p>total_amount: absolute value per feature and depth level
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This example requires commercial solver from 'gurobi' package for
## portfolio = "gap". Else replace it with e.g. portfolio = "shuffle" for using
## a free solver like the one from 'highs' package.

biodiv_raster &lt;- get_biodiv_raster()
depth_raster &lt;- get_depth_raster()
data(biodiv_df)

# You can split features' 2D distributions into 3D ones and then run only 3D analysis
split_features &lt;- split_rast(biodiv_raster,
                             depth_raster,
                             breaks = c(0, -40, -200, -2000, -Inf),
                             biodiv_df)

out_3D &lt;- prioritize_3D(split_features = split_features,
                        depth_raster = depth_raster,
                        breaks = c(0, -40, -200, -2000, -Inf),
                        biodiv_df = biodiv_df,
                        budget_percents = seq(0, 1, 0.1),
                        budget_weights = "richness",
                        threads = parallel::detectCores(),
                        portfolio = "gap",
                        portfolio_opts = list(number_solutions = 10))

evaluate_3D(out_3D$solution3D$budget0.3, split_features)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_biodiv_raster'>Example biodiversity raster</h2><span id='topic+get_biodiv_raster'></span>

<h3>Description</h3>

<p>Example biodiversity raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_biodiv_raster()
</code></pre>


<h3>Details</h3>

<p>Example of input <code>biodiv_raster</code> used for functions.
</p>


<h3>Value</h3>

<p>SpatRaster object with distribution of features.
</p>


<h3>References</h3>

<p>Kaschner, K., Kesner-Reyes, K., Garilao, C., Segschneider, J., Rius-Barile,
J., Rees, T., &amp; Froese, R. (2019). AquaMaps: Predicted range maps
for aquatic species. <a href="https://www.aquamaps.org">https://www.aquamaps.org</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biodiv_raster &lt;- get_biodiv_raster()
terra::plot(biodiv_raster[[1:4]])
</code></pre>

<hr>
<h2 id='get_depth_raster'>Example depth raster</h2><span id='topic+get_depth_raster'></span>

<h3>Description</h3>

<p>Example depth raster
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_depth_raster()
</code></pre>


<h3>Details</h3>

<p>Example of input <code>depth_df</code> object for functions.
</p>


<h3>Value</h3>

<p>SpatRaster object with depth levels for Mediterranean.
</p>


<h3>References</h3>

<p>GEBCO Compilation Group. (2021). GEBCO 2021 Grid.
<a href="https://doi.org/10.5285/c6612cbe-50b3-0cff-e053-6c86abc09f8f">doi:10.5285/c6612cbe-50b3-0cff-e053-6c86abc09f8f</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>depth_raster &lt;- get_depth_raster()
terra::plot(depth_raster)
</code></pre>

<hr>
<h2 id='get_rast'>Read multiple rast files</h2><span id='topic+get_rast'></span>

<h3>Description</h3>

<p>Read multiple rast files contained in a folder path. Raster files must have either
.asc or .tif extension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_rast(path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_rast_+3A_path">path</code></td>
<td>

<p>Path string of folder containing rast files.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatRaster object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>feature_folder &lt;- system.file("get_rast_example", package="prior3D")
get_rast(feature_folder)
</code></pre>

<hr>
<h2 id='plot_3D'>Plot output of <a href="#topic+prioritize_3D">prioritize_3D</a></h2><span id='topic+plot_3D'></span>

<h3>Description</h3>

<p>Plot summarized output of <a href="#topic+prioritize_3D">prioritize_3D</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_3D(x, to_plot = "all", add_lines = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_3D_+3A_x">x</code></td>
<td>

<p>Output of <a href="#topic+prioritize_3D">prioritize_3D</a>.
</p>
</td></tr>
<tr><td><code id="plot_3D_+3A_to_plot">to_plot</code></td>
<td>

<p>Any of <code>"maps"</code>, <code>"relative_held"</code> or <code>"all"</code>. The default is <code>"all"</code>.
See more in Details.
</p>
</td></tr>
<tr><td><code id="plot_3D_+3A_add_lines">add_lines</code></td>
<td>

<p>If <code>TRUE</code>, then border lines from <strong>maps::map</strong> are ploted as well.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots the summarized output of <a href="#topic+prioritize_3D">prioritize_3D</a>
for all the selected budgets.
The produced plot can contain information about:
</p>

<ul>
<li><p><code>"maps"</code>: produced maps normalized at a <code class="reqn">[0,1]</code> scale.
</p>
</li>
<li><p><code>"relative_held"</code>: percentage of protection for all features per depth level.
</p>
</li>
<li><p><code>"all"</code>: both <code>"maps"</code> and <code>"relative_held"</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A plot.
</p>


<h3>References</h3>

<p>Becker, R.A., Wilks, A.R., Brownrigg, R., &amp; Minka, T.P. (2023). maps: Draw
Geographical Maps. R package version 3.4.2,
<a href="https://CRAN.R-project.org/package=maps">
https://CRAN.R-project.org/package=maps</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prioritize_3D">prioritize_3D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This example requires commercial solver from 'gurobi' package for
## portfolio = "gap". Else replace it with e.g. portfolio = "shuffle" for using
## a free solver like the one from 'highs' package.

biodiv_raster &lt;- get_biodiv_raster()
depth_raster &lt;- get_depth_raster()
data(biodiv_df)

# You can split features' 2D distributions into 3D ones and then run only 3D analysis
split_features &lt;- split_rast(biodiv_raster,
                             depth_raster,
                             breaks = c(0, -40, -200, -2000, -Inf),
                             biodiv_df,
                             val_depth_range=TRUE)

out_3D &lt;- prioritize_3D(split_features = split_features,
                        depth_raster = depth_raster,
                        breaks = c(0, -40, -200, -2000, -Inf),
                        biodiv_df = biodiv_df,
                        priority_weights = NULL,#priority_weights,
                        budget_percents = seq(0, 1, 0.1),
                        budget_weights = "equal",
                        penalty = 0,
                        edge_factor = 0.5,
                        gap = 0.1,
                        threads = parallel::detectCores(),
                        sep_priority_weights = ",",
                        portfolio = "gap",
                        portfolio_opts = list(number_solutions = 10),
                        sep_biodiv_df = ",",
                        locked_in_raster = NULL,
                        locked_out_raster = NULL)

plot_3D(out_3D, to_plot="all", add_lines=FALSE)
plot_3D(out_3D, to_plot="all", add_lines=TRUE)
plot_3D(out_3D, to_plot="maps", add_lines=TRUE)
plot_3D(out_3D, to_plot="relative_held", add_lines=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_Compare_2D_3D'>Plot output of <a href="#topic+Compare_2D_3D">Compare_2D_3D</a></h2><span id='topic+plot_Compare_2D_3D'></span>

<h3>Description</h3>

<p>Plot summarized output of <a href="#topic+Compare_2D_3D">Compare_2D_3D</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_Compare_2D_3D(x, to_plot = "all", add_lines = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_Compare_2D_3D_+3A_x">x</code></td>
<td>

<p>Output of <a href="#topic+Compare_2D_3D">Compare_2D_3D</a>.
</p>
</td></tr>
<tr><td><code id="plot_Compare_2D_3D_+3A_to_plot">to_plot</code></td>
<td>

<p>Any of <code>"maps"</code>, <code>"relative_held"</code> or <code>"all"</code>. The default is <code>"all"</code>.
See more in Details.
</p>
</td></tr>
<tr><td><code id="plot_Compare_2D_3D_+3A_add_lines">add_lines</code></td>
<td>

<p>If <code>TRUE</code>, then border lines from <strong>maps::map</strong> are ploted as well.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots the summarized output of <a href="#topic+Compare_2D_3D">Compare_2D_3D</a>
for all selected budgets.
The produced plot can contain information about:
</p>

<ul>
<li><p><code>"maps"</code>: produced maps normalized at a <code class="reqn">[0,1]</code> scale.
</p>
</li>
<li><p><code>"relative_held"</code>: percentage of protection for all features per depth level.
</p>
</li>
<li><p><code>"all"</code>: both <code>"maps"</code> and <code>"relative_held"</code>.
</p>
</li></ul>



<h3>Value</h3>

<p>A plot.
</p>


<h3>References</h3>

<p>Becker, R. A., Wilks, A. R., Brownrigg, R., &amp; Minka, T. P. (2023). maps: Draw
Geographical Maps. R package version 3.4.2,
<a href="https://CRAN.R-project.org/package=maps">
https://CRAN.R-project.org/package=maps</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Compare_2D_3D">Compare_2D_3D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This example requires commercial solver from 'gurobi' package for
## portfolio = "gap". Else replace it with e.g. portfolio = "shuffle" for using
## a free solver like the one from 'highs' package.

biodiv_raster &lt;- get_biodiv_raster()
depth_raster &lt;- get_depth_raster()
data(biodiv_df)

out_2D_3D &lt;- Compare_2D_3D(biodiv_raster = biodiv_raster,
                           depth_raster = depth_raster,
                           breaks = c(0, -40, -200, -2000, -Inf),
                           biodiv_df = biodiv_df,
                           budget_percents = seq(0, 1, 0.1),
                           budget_weights = "richness",
                           threads = parallel::detectCores(),
                           portfolio = "gap",
                           portfolio_opts = list(number_solutions = 10))

plot_Compare_2D_3D(out_2D_3D, to_plot="all", add_lines=FALSE)
plot_Compare_2D_3D(out_2D_3D, to_plot="all", add_lines=TRUE)
plot_Compare_2D_3D(out_2D_3D, to_plot="maps", add_lines=TRUE)
plot_Compare_2D_3D(out_2D_3D, to_plot="relative_held", add_lines=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_sumrast'>Plot sum list of SpatRaster objects.</h2><span id='topic+plot_sumrast'></span>

<h3>Description</h3>

<p>Plot sum list of SpatRaster objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_sumrast(x, normalize = TRUE, add_lines = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_sumrast_+3A_x">x</code></td>
<td>

<p>List of SpatRaster objects.
</p>
</td></tr>
<tr><td><code id="plot_sumrast_+3A_normalize">normalize</code></td>
<td>

<p>If <code>TRUE</code>, then sum of solutions is normalized at a <code class="reqn">[0,1]</code> scale.
</p>
</td></tr>
<tr><td><code id="plot_sumrast_+3A_add_lines">add_lines</code></td>
<td>

<p>If <code>TRUE</code>, then border lines from <strong>maps::map</strong> are ploted as well.
</p>
</td></tr>
<tr><td><code id="plot_sumrast_+3A_...">...</code></td>
<td>

<p>Further arguments passed to <strong>terra::plot</strong>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sumrast">sumrast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x &lt;- terra::rast(matrix(rbinom(100, 1, 0.2), nrow=10))
y &lt;- terra::rast(matrix(rbinom(100, 1, 0.8), nrow=10))
plot_sumrast(list(x, y), add_lines = FALSE)
</code></pre>

<hr>
<h2 id='prioritize_3D'>3D prioritization algorithm</h2><span id='topic+prioritize_3D'></span>

<h3>Description</h3>

<p>3D prioritization algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prioritize_3D(split_features, depth_raster, breaks, biodiv_df,
priority_weights = NULL, budget_percents = seq(0,1,0.1), budget_weights = "equal",
penalty = 0, edge_factor = 0.5, gap = 0.1, threads = 1L, sep_priority_weights = ",",
portfolio = "gap", portfolio_opts = list(number_solutions = 10, pool_gap = 0.1),
sep_biodiv_df = ",", locked_in_raster = NULL, locked_out_raster = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prioritize_3D_+3A_split_features">split_features</code></td>
<td>

<p><code>list</code> of SpatRaster objects representing depth zones, where each element corresponds to a
different depth level, ranging from surface to the bottom of the sea.
The function uses the output of the split_rast function, but other multilevel (3D)
distribution data that conform to this structure is also acceptable.
First list element corresponds to the shallowest distribution and the last list element to
the deepest one.
</p>
</td></tr>
<tr><td><code id="prioritize_3D_+3A_depth_raster">depth_raster</code></td>
<td>

<p>SpatRaster object or file path with elevation/bathymetric map.
</p>
</td></tr>
<tr><td><code id="prioritize_3D_+3A_breaks">breaks</code></td>
<td>

<p>Numeric vector defining the range of depth layers to use.
</p>
</td></tr>
<tr><td><code id="prioritize_3D_+3A_biodiv_df">biodiv_df</code></td>
<td>

<p><code>data.frame</code> or a file path (CSV, TXT, XLS, or XLSX) containing additional
information about biodiversity features.
</p>
</td></tr>
<tr><td><code id="prioritize_3D_+3A_priority_weights">priority_weights</code></td>
<td>

<p><code>data.frame</code> object or file path (CSV, TXT, XLS, or XLSX) containing group names of
biodiversity features in the first column and corresponding group weights in the second
column. This data.frame attributes distinct prioritization weights to different
biodiversity features or groups of features.
</p>
</td></tr>
<tr><td><code id="prioritize_3D_+3A_budget_percents">budget_percents</code></td>
<td>

<p>Numeric value <code class="reqn">[0,1]</code> or vector containing budget percentages to use. The default is
<code>seq(0,1,0.1)</code>.
</p>
</td></tr>
<tr><td><code id="prioritize_3D_+3A_budget_weights">budget_weights</code></td>
<td>

<p>Numeric weight vector for budget_percents allocation among depth levels.
Otherwise it can be a string with one of the choices <code>"equal"</code>, <code>"area"</code> or
<code>"richness"</code>.
Alternatively, it can be a numerical vector with custom weights corresponding to each
depth layer, where the first value corresponds to the surface and last one corresponds to
the bottom of the sea. The weights are normalized if their sum exceeds 1. If not
specified, an equal distribution of budget among depth levels is used, as the default.
</p>
</td></tr>
<tr><td><code id="prioritize_3D_+3A_penalty">penalty</code></td>
<td>

<p>A single numeric penalty applied to each depth zone, as defined in the<br />
<code>prioritizr::add_boundary_penalties</code>.
</p>
</td></tr>
<tr><td><code id="prioritize_3D_+3A_edge_factor">edge_factor</code></td>
<td>

<p>A single numeric edge factor applied to each depth zone, as defined in the<br />
<code>prioritizr::add_boundary_penalties</code>.
</p>
</td></tr>
<tr><td><code id="prioritize_3D_+3A_gap">gap</code></td>
<td>

<p>The optimality gap for the solver, as defined in the <span class="pkg">prioritizr</span> package.
The default gap is 0.1.
</p>
</td></tr>
<tr><td><code id="prioritize_3D_+3A_threads">threads</code></td>
<td>

<p>The number of solver threads to be used. The default is 1.
</p>
</td></tr>
<tr><td><code id="prioritize_3D_+3A_sep_priority_weights">sep_priority_weights</code></td>
<td>

<p>Separator used in priority_weights file, if priority_weights is in path format.
</p>
</td></tr>
<tr><td><code id="prioritize_3D_+3A_portfolio">portfolio</code></td>
<td>

<p>The portfolio to be used, choosing between <code>"extra"</code>,
<code>"gap"</code>, <code>"cuts"</code> and <code>"shuffle"</code> portfolios.
The default is <code>"gap"</code>. <code>portfolio=""</code> indicates that no portfolio is used.
For more about <code>portfolios</code> see <span class="pkg">prioritizr</span>.
</p>
</td></tr>
<tr><td><code id="prioritize_3D_+3A_portfolio_opts">portfolio_opts</code></td>
<td>

<p>The <span class="pkg">prioritizr</span> portfolio options to be used.
</p>
</td></tr>
<tr><td><code id="prioritize_3D_+3A_sep_biodiv_df">sep_biodiv_df</code></td>
<td>

<p>Separator used in biodiv_df file, if biodiv_df is in path format.
</p>
</td></tr>
<tr><td><code id="prioritize_3D_+3A_locked_in_raster">locked_in_raster</code></td>
<td>

<p>An optional <code>locked_in_raster</code> SpatRaster to be used.
Note that these areas are considered as zero-cost.
</p>
</td></tr>
<tr><td><code id="prioritize_3D_+3A_locked_out_raster">locked_out_raster</code></td>
<td>

<p>An optional <code>locked_out_raster</code> SpatRaster to be used.
Note that these areas are excluded from the solution.
</p>
</td></tr>
<tr><td><code id="prioritize_3D_+3A_verbose">verbose</code></td>
<td>

<p>If <code>verbose = TRUE</code>, then solver messages are printed as well. The default is
<code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to generate prioritization maps. Single budget settings
(ex. <code>total_budget = 0.3</code>) produce standard maps, as typical Marxan outputs.
Multiple budgets, by using a vector (ex. <code>c(0.1,0.3,0.5)</code>, result in
cumulative (frequency) maps, illustrating areas selected by various budget levels.
Although this output follows a different approach, it resembles to typical Zonation
output maps.
</p>
<p>The main reason for <code>biodiv_df</code> here is defining prioritization weights for features.
In this package weights are defined per group of features (if needed). <code>biodiv_df</code>
has <code>mandatory</code> column names (and any other names are ignored):
</p>

<ul>
<li><p><code>"species_name"</code>: <b>Mandatory</b> column with the feature names, which must
be the same with <code>split_rast</code>.
</p>
</li>
<li><p><code>"group"</code>: <b>Mandatory</b> column with the group weights names.
</p>
</li></ul>

<p>Except from <code>biodiv_df</code>, an additional <code>data.frame</code> object can also be used,
named <code>priority_weights</code>. If used, this <code>data.frame</code> object must have two
columns:
</p>

<ul>
<li><p><code>"group"</code>: <b>Mandatory</b> column with the group weights names.
</p>
</li>
<li><p><code>"weight"</code>: <b>Mandatory</b> column with the group weights.
</p>
</li></ul>

<p>In case that no feature weights are desired, then <code>biodiv_df</code> and
<code>priority_weights</code> can be both kept to <code>NULL</code>.
</p>
<p><code>breaks</code> must be in correspondence to depth_raster file.
For example, if depth_raster has range <code class="reqn">[10, -3000]</code>, then a breaks vector of
<code>c(0,-40,-200,-2000,-Inf)</code> will create depth levels
<code class="reqn">[0,-40],\\(-40,-200], (-200, -2000], (-2000, -\infty)</code>
and set to NA cells with values greater than <code class="reqn">10</code>.
</p>
<p><code>budget_percents</code>: Budget reflects the desired level of protection to be modeled.
It ranges from 0 to 1, with 0 indicating no resources available for protection,
while 1 signifies resources sufficient to protect the entire study area. Typically,
setting a budget of 0.3 corresponds to the 30% conservation target (i.e. 30% of the
total area set aside for conservation).
Users also have the flexibility to define multiple budget levels using a vector,
allowing for the exploration of various protection scenarios. For instance, a vector like
<code>c(0.1, 0.3, 0.5)</code> represents three scenarios where 10%, 30%, and 50% of the
study area are designated for protection.
</p>
<p><code>budget_weights</code>: The <b>prioritize_3D</b> function allows users to specify how the
budget is distributed among depth levels. Three allocation methods are available:
</p>

<ol>
<li><p>Equal Distribution: Allocates an equal share of the budget to each depth level<br />
(<code>budget_weights = "equal"</code>).
</p>
</li>
<li><p>Proportional to Area: Allocates budget based on the spatial extent of each depth<br />
level (<code>budget_weights = "area"</code>).
</p>
</li>
<li><p>Proportional to Species Richness: Prioritizes budget allocation to depth levels with
higher species diversity (number of species) (<code>budget_weights = "richness"</code>).
</p>
</li></ol>

<p>Otherwise, it can be a numeric vector with length equal to the number of depth levels,
where each number indicates the budget share per depth level.
</p>
<p>The solver used for solving the prioritization problems is the best available on the
computer, following the solver hierarchy of <span class="pkg">prioritizr</span>.
</p>


<h3>Value</h3>

<p>A list containing the following objects (non-referenced are identical to the input ones):
</p>

<ul>
<li><p>solution3D: list with 3D solution per budget percentage
</p>
</li>
<li><p>absolute_held3D: <code>absolute_held</code> for 3D solutions (see
<code><a href="#topic+evaluate_3D">evaluate_3D</a></code>)
</p>
</li>
<li><p>overall_available3D: <code>overall_available</code> for 3D solutions (see
<code><a href="#topic+evaluate_3D">evaluate_3D</a></code>)
</p>
</li>
<li><p>overall_held3D: <code>overall_held</code> for 3D solutions (see
<code><a href="#topic+evaluate_3D">evaluate_3D</a></code>)
</p>
</li>
<li><p>relative_helds3D: <code>relative_held</code> for 3D solutions (see
<code><a href="#topic+evaluate_3D">evaluate_3D</a></code>)
</p>
</li>
<li><p>mean_overall_helds3D: <code>base::mean</code> of <code>overall_held</code>
for 3D solution (see <code><a href="#topic+evaluate_3D">evaluate_3D</a></code>) per budget
</p>
</li>
<li><p>sd_overall_helds3D: <code>base::mean</code> of <code>overall_held</code>
for 3D solution (see <code><a href="#topic+evaluate_3D">evaluate_3D</a></code>) per budget
</p>
</li>
<li><p>depth_overall_available3D: <code>depth_overall_available</code> for 3D solutions (see
<code><a href="#topic+evaluate_3D">evaluate_3D</a></code>)
</p>
</li></ul>



<h3>References</h3>

<p>Hanson, Jeffrey O, Richard Schuster, Nina Morrell, Matthew Strimas-Mackey, Brandon
P M Edwards, Matthew E Watts, Peter Arcese, Joseph Bennett, and Hugh P Possingham. 2024.
prioritizr: Systematic Conservation Prioritization in R. <a href="https://prioritizr.net">
https://prioritizr.net</a>.
</p>
<p>Lehtomäki, Joona (2016). Comparing prioritization methods, 21 June.<br />
Available at: <a href="https://rpubs.com/jlehtoma/priocomp">
https://rpubs.com/jlehtoma/priocomp</a>
(Accessed 1 June 2024).
</p>


<h3>See Also</h3>

<p><code>
<a href="#topic+evaluate_3D">evaluate_3D</a>,
<a href="#topic+terra_jaccard">terra_jaccard</a>,
<a href="#topic+plot_3D">plot_3D</a>
</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This example requires commercial solver from 'gurobi' package for
## portfolio = "gap". Else replace it with e.g. portfolio = "shuffle" for using
## a free solver like the one from 'highs' package.

biodiv_raster &lt;- get_biodiv_raster()
depth_raster &lt;- get_depth_raster()
data(biodiv_df)

# You can split features' 2D distributions into 3D ones and then run only 3D analysis
split_features &lt;- split_rast(biodiv_raster,
                             depth_raster,
                             breaks = c(0, -40, -200, -2000, -Inf),
                             biodiv_df)

out_3D &lt;- prioritize_3D(split_features = split_features,
                        depth_raster = depth_raster,
                        breaks = c(0, -40, -200, -2000, -Inf),
                        biodiv_df = biodiv_df,
                        budget_percents = seq(0, 1, 0.1),
                        budget_weights = "richness",
                        threads = parallel::detectCores(),
                        portfolio = "gap",
                        portfolio_opts = list(number_solutions = 10))

plot_3D(out_3D, to_plot="all", add_lines=TRUE)

# Arbitrary random weights
priority_weights &lt;- data.frame(c("A", "B", "C"), c(0.001, 1000, 1))
names(priority_weights) &lt;- c("group", "weight")
biodiv_df$group &lt;- rep(c("A", "B", "C"), length.out=20)
out_3D &lt;- prioritize_3D(split_features = split_features,
                        depth_raster = depth_raster,
                        biodiv_df = biodiv_df,
                        priority_weights = priority_weights,
                        breaks = c(0, -40, -200, -2000, -Inf),
                        budget_percents = seq(0, 1, 0.1),
                        budget_weights = "richness",
                        threads = parallel::detectCores(),
                        portfolio = "gap",
                        portfolio_opts = list(number_solutions = 10))

plot_3D(out_3D, to_plot="all", add_lines=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='split_rast'>Split 2D feature distributions into 3D ones</h2><span id='topic+split_rast'></span>

<h3>Description</h3>

<p>Split 2D feature distributions into 3D ones
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_rast(biodiv_raster, depth_raster, breaks, biodiv_df, val_depth_range=TRUE,
sep_biodiv_df=",")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split_rast_+3A_biodiv_raster">biodiv_raster</code></td>
<td>

<p>SpatRaster object or folder path with 2D feature distributions as layers.
</p>
</td></tr>
<tr><td><code id="split_rast_+3A_depth_raster">depth_raster</code></td>
<td>

<p>SpatRaster object or file path with elevation/bathymetric map.
</p>
</td></tr>
<tr><td><code id="split_rast_+3A_breaks">breaks</code></td>
<td>

<p>Numeric vector defining the range of depth layers to use.
</p>
</td></tr>
<tr><td><code id="split_rast_+3A_biodiv_df">biodiv_df</code></td>
<td>

<p><code>data.frame</code> or a file path (CSV, TXT, XLS, or XLSX) containing additional
information about biodiversity features.
</p>
</td></tr>
<tr><td><code id="split_rast_+3A_val_depth_range">val_depth_range</code></td>
<td>

<p>No correction of the splitted 3D distributions based on depth range of the biodiversity
features (<code>"min_z"</code> and <code>"max_z"</code> from <code>biodiv_df</code>) is needed.
</p>
</td></tr>
<tr><td><code id="split_rast_+3A_sep_biodiv_df">sep_biodiv_df</code></td>
<td>

<p>The separator used in biodiv_df file, if biodiv_df is in path format.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to convert 2D distributions of biodiversity
features (rasters) into a 3D format. Here the <code>biodiv_df</code> can have the
following column names (independently of their order and any other names are ignored):
</p>

<ul>
<li><p><code>"species_name"</code>: <b>Mandatory</b> column with the feature names, which must
be the same with biodiv_raster.
</p>
</li>
<li><p><code>"pelagic"</code>: <b>Mandatory</b> column about the features' behaviour.
<code>TRUE</code> means that this feature is pelagic and <code>FALSE</code> means that this feature is
benthic.
</p>
</li>
<li><p><code>"min_z"</code>: <b>Optional</b> column about the minimum vertical range of
features. <code>NA</code> values are translated as unlimited upward feature movement.
</p>
</li>
<li><p><code>"max_z"</code>: <b>Optional</b> column about the maximum vertical range of
features. <code>NA</code> values are translated as unlimited downward feature movement.
</p>
</li></ul>

<p><code>breaks</code> must be in correspondence to depth_raster file.
For example, if depth_raster has range <code class="reqn">[10, -3000]</code>, then a breaks vector of
<code>c(0,-40,-200,-2000,-Inf)</code> will create depth levels <code class="reqn">[0,-40],\\
(-40,200], (-200, -2000], (-2000, -\infty)</code>
and set to NA cells with values greater than <code class="reqn">0</code>.
</p>
<p>If <code>val_depth_range = TRUE</code> (default), then no correction is done and the depth range
of the biodiversity features is derived from the corresponding feature distribution
raster and so <code>"min_z"</code> and <code>"max_z"</code> are ignored.
If <code>val_depth_range = FALSE</code>, then the function uses the minimum and maximum depth
information provided in the biodiv_df, so as to remove feature occurrences outside their
expected range.
</p>


<h3>Value</h3>

<p>A list containing species distributions for each bathymetric layer, that are necessary for
further 3D analysis. List names are indicating the depth levels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>biodiv_raster &lt;- get_biodiv_raster()
depth_raster &lt;- get_depth_raster()
data(biodiv_df)

# You can split features' 2D distributions into 3D ones and then run only 3D analysis
split_features &lt;- split_rast(biodiv_raster,
                             depth_raster,
                             breaks = c(0, -40, -200, -2000, -Inf),
                             biodiv_df)
</code></pre>

<hr>
<h2 id='sumrast'>Sum list of SpatRaster objects.</h2><span id='topic+sumrast'></span>

<h3>Description</h3>

<p>Sum list of SpatRaster objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sumrast(x, normalize = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sumrast_+3A_x">x</code></td>
<td>

<p>List of SpatRaster objects.
</p>
</td></tr>
<tr><td><code id="sumrast_+3A_normalize">normalize</code></td>
<td>

<p>If <code>TRUE</code>, then sum of solutions is normalized at a <code class="reqn">[0,1]</code> scale.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A SpatRaster object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_sumrast">plot_sumrast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x &lt;- terra::rast(matrix(rbinom(100, 1, 0.2), nrow=10))
y &lt;- terra::rast(matrix(rbinom(100, 1, 0.8), nrow=10))
sumrast(list(x, y))
</code></pre>

<hr>
<h2 id='terra_jaccard'>Jaccard similarity coefficient among two SpatRaster objects</h2><span id='topic+terra_jaccard'></span>

<h3>Description</h3>

<p>Jaccard coefficient among two SpatRaster objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>terra_jaccard(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="terra_jaccard_+3A_x">x</code></td>
<td>

<p>SpatRaster object with binary values.
</p>
</td></tr>
<tr><td><code id="terra_jaccard_+3A_y">y</code></td>
<td>

<p>SpatRaster object with binary values.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Jaccard similarity coefficient evaluates the percentage number equal to the intersection
between two sets, divided by the size of the union of these sets.
</p>


<h3>Value</h3>

<p>A numeric value <code class="reqn">[0,1]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x &lt;- terra::rast(matrix(rbinom(100, 1, 0.2), nrow=10))
y &lt;- terra::rast(matrix(rbinom(100, 1, 0.8), nrow=10))
terra_jaccard(x, y)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
