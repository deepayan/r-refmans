<!DOCTYPE html><html><head><title>Help for package idar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {idar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#checktree'><p>Check Trait and Phylo Data</p></a></li>
<li><a href='#envelope4idar'><p>Compute Simulation Envelopes for IDAR(r) Functions</p></a></li>
<li><a href='#fdis'><p>Average Functional Dispersion</p></a></li>
<li><a href='#ipsim'><p>Simulate Multivariate Point Patterns</p></a></li>
<li><a href='#isar'><p>Individual Diversity Area Relationships</p></a></li>
<li><a href='#LF.gof'><p>Loosmore and Ford Goodness of Fit Test</p></a></li>
<li><a href='#localdar'>
<p>Map Local Diversity Area Relationships</p></a></li>
<li><a href='#midar'>
<p>Customize the Individual Diversity-Area Relationship Function</p></a></li>
<li><a href='#mitable'><p>Tabulate Marks in Neighbourhood of Every Point in a Point Pattern</p></a></li>
<li><a href='#pisar'>
<p>Phylogenetic Individual Species Area Relationship</p></a></li>
<li><a href='#proportion.idar'><p>Determine the Proportion of Accumulator and Repeller Species</p></a></li>
<li><a href='#SF'>
<p>San Francisco forest plot.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-12-26</td>
</tr>
<tr>
<td>Title:</td>
<td>Individual Diversity-Area Relationships</td>
</tr>
<tr>
<td>Author:</td>
<td>Marcelino de la Cruz</td>
</tr>
<tr>
<td>Depends:</td>
<td>FD, picante, spatstat (&ge; 2.0-0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ape, spatstat.geom, spatstat.explore, spatstat.random</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ecespa, vegan</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marcelino de la Cruz &lt;marcelino.delacruz@urjc.es&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes and tests individual (species, phylogenetic and functional) diversity-area relationships, i.e., how species-, phylogenetic- and functional-diversity varies with spatial scale around the individuals of some species in a community. See applications of these methods in Wiegand et al. (2007) &lt;<a href="https://doi.org/10.1073%2Fpnas.0705621104">doi:10.1073/pnas.0705621104</a>&gt; or Chacon-Labella et al. (2016) &lt;<a href="https://doi.org/10.1007%2Fs00442-016-3547-z">doi:10.1007/s00442-016-3547-z</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-12-26 11:50:38 UTC; marcelino</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-05 15:50:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='checktree'>Check Trait and Phylo Data</h2><span id='topic+checktree'></span><span id='topic+checktraits'></span>

<h3>Description</h3>

<p>Checks consistency of names of species in spatial, phylogenetic and traits data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  checktree(tree,  mippp, idar, correct.phylo)
  checktraits(traits, mippp, idar, correct.trait.na, correct.trait)
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checktree_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree in <code>phylo</code> format (<span class="pkg">ape</span>) or a phylogenetic covariance matrix</p>
</td></tr>
<tr><td><code id="checktree_+3A_traits">traits</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a> of traits, or a distance matrix among species (in <a href="stats.html#topic+dist">dist</a> or <a href="base.html#topic+matrix">matrix</a> format) computed on a data.frame of traits.</p>
</td></tr> 
<tr><td><code id="checktree_+3A_mippp">mippp</code></td>
<td>
<p>A multitype (a.k.a. multivariate) marked point pattern . An object with the <a href="spatstat.geom.html#topic+ppp">ppp</a> format of <span class="pkg">spatstat</span>, with the names of species as marks.</p>
</td></tr>
<tr><td><code id="checktree_+3A_idar">idar</code></td>
<td>
<p>Character. The name of the idar fucntion to be computed. Either &quot;isar&quot;, &quot;ipsvar&quot;, &quot;ipsrar&quot;, &quot;ipsear&quot;, &quot;ipscar&quot;, or &quot;imntdar&quot;</p>
</td></tr>
<tr><td><code id="checktree_+3A_correct.phylo">correct.phylo</code></td>
<td>
<p>Character. Either <code>"mean"</code> meaning <em>&quot;include missing species in the tree with a constant mean phylogenetic covariance&quot;</em> or <code>"exclude"</code>, meaning <em>&quot;exclude missing species in the tree from the analysis&quot;</em> </p>
</td></tr>
<tr><td><code id="checktree_+3A_correct.trait.na">correct.trait.na</code></td>
<td>
<p>Logical flag indicating whether <code>NA</code> values in the matrix of traits should be &quot;corrected&quot;: NA values will be assigned the mean trait value.</p>
</td></tr>
<tr><td><code id="checktree_+3A_correct.trait">correct.trait</code></td>
<td>
<p>Character. Either <code>"mean"</code> or <code>"exclude"</code>. Species missing in the data.frame of traits will be assigned mean trait values or  will be excluded from the analysis, respectively. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions check for the coincidence of  species in the point pattern and in the phylogenetic or trait data and for the existence of missing data. If <code>correct.phylo="mean"</code>, species which are absent in the phylogenetic tree or covariance matrix will be included and assigned mean phylogenetic covariance. If <code>correct.phylo="exclude"</code>, missing species in the tree will be excluded from the analysis (i.e., will not be considered in the computation of the local phylogenetic indices). If <code>correct.trait.na="TRUE"</code>, NA values for traits in the data.frame of traits will be assigned the mean trait value. If <code>correct.trait="mean"</code>, missing species in the data.frame of traits will be included and assigned mean trait values.  If <code>correct.trait="exclude"</code>, missing species in the data.frame of traits will be excluded from the analysis (i.e., will not be considered in the computation of the local functional indices).
</p>


<h3>Value</h3>

<p><code>checktree</code> returns a covariance matrix with the appropriate species corrections.   <code>checktraits</code> returns a data.frame of traits with the appropriate corrections or a Gower distance matrix among the species from the corrected data.frame of traits if   <code>idar="ifdar"</code>.
</p>


<h3>Warning</h3>

<p>The transcription of species names in the multivariate <code>mippp</code>, in the row names of  the <code>data.frame</code> of traits (or in the names or <code>dimnames</code> of  the distance matrices) should be identical. The same applies to the <code>tiplabels</code> of the phylogenetic tree.
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz <a href="mailto:marcelino.delacruz@urjc.es">marcelino.delacruz@urjc.es</a></p>

<hr>
<h2 id='envelope4idar'>Compute Simulation Envelopes for IDAR(r) Functions</h2><span id='topic+envelope4idar'></span><span id='topic+idar2'></span><span id='topic+raoDmod'></span>

<h3>Description</h3>

<p>Compute simulation envelopes for IDAR(r) functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  envelope4idar(mippp, mippp.sp.sim, mippp.sp, mimark=NULL,
    namesmark=NULL, r, idar="isar", buffer="adapt", bfw=NULL,
    nsim=NULL, nrank=1, tree = NULL, traits = NULL, 
    cross.idar=FALSE, savefuns=TRUE, correct.phylo="exclude",
    correct.trait.na=FALSE, correct.trait="mean" )
idar2(mippp.sp, mippp, mimark, idar="isar", buffer,bfw, r, 
    cross.idar=FALSE,  tree = NULL, traits = NULL)
    raoDmod(comm, phy = NULL) 
  
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="envelope4idar_+3A_mippp">mippp</code></td>
<td>
<p>A multitype (a.k.a. multivariate) marked point pattern. An object with the <a href="spatstat.geom.html#topic+ppp">ppp</a> format of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_mippp.sp">mippp.sp</code></td>
<td>
<p>Univariate point pattern of the focal species. An object with the <a href="spatstat.geom.html#topic+ppp">ppp</a> format of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_mippp.sp.sim">mippp.sp.sim</code></td>
<td>
<p>A list with simulations of the focal species point pattern created with <code><a href="#topic+simulador2">simulador2</a></code> </p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_mimark">mimark</code></td>
<td>
<p>Character. Name of the focal species in the multitype <code>mippp</code>.</p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_namesmark">namesmark</code></td>
<td>
<p>Character. If the marks in <code>mippp</code> are within a <code>data.frame</code>, the name of the column with the species names</p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_r">r</code></td>
<td>
<p>Vector of distances to compute IDAR(r) functions</p>
</td></tr>  
<tr><td><code id="envelope4idar_+3A_idar">idar</code></td>
<td>
<p>Character. The name of the idar fucntion to be computed. Either &quot;isar&quot;, &quot;ipsvar&quot;, &quot;ipsrar&quot;, &quot;ipsear&quot;, &quot;ipscar&quot;, &quot;icwmar&quot;, &quot;icwmar.O&quot;,  &quot;iraodar&quot;or &quot;imntdar&quot;</p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_buffer">buffer</code></td>
<td>
<p>Character or numeric. Either &quot;adapt&quot; (i.e., compute an adaptive buffer), or a number indicating de width of a fixed buffer area around the plot border</p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_bfw">bfw</code></td>
<td>
<p>An <a href="spatstat.geom.html#topic+owin">owin</a> object indicating the limits of the buffer area.</p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_nsim">nsim</code></td>
<td>
<p>The number of simulations.</p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_nrank">nrank</code></td>
<td>
<p>Integer. Rank of the envelope value amongst the nsim simulated values. A rank of 1 means that the minimum and maximum simulated values will be used.</p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree in <code>phylo</code> format (<span class="pkg">ape</span>) or a phylogenetic covariance matrix</p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_traits">traits</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a> of traits, or a distance matrix among species (in <code><a href="stats.html#topic+dist">dist</a></code> or <code><a href="base.html#topic+matrix">matrix</a></code> format) computed on a data.frame of traits.</p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_cross.idar">cross.idar</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the focal pattern be excluded form the community being measured. </p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_savefuns">savefuns</code></td>
<td>
<p>Logical flag indicating whether to save all the simulated function values.</p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_correct.phylo">correct.phylo</code></td>
<td>
<p>Character. Either <code>"mean"</code> meaning <em>&quot;include missing species in the tree with a constant mean phylogenetic covariance&quot;</em> or <code>"exclude"</code>, meaning <em>&quot;exclude missing species in the tree from the analysis&quot;</em> </p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_correct.trait.na">correct.trait.na</code></td>
<td>
<p>Logical flag indicating whether <code>NA</code> values in the matrix of traits should be &quot;corrected&quot;: NA values will be assigned the mean trait value.</p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_correct.trait">correct.trait</code></td>
<td>
<p>Character. Either <code>"mean"</code> or <code>"exclude"</code>. Species missing in the data.frame of traits will be assigned mean trait values or  will be excluded from the analysis, respectively. </p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_comm">comm</code></td>
<td>
<p>A data.frame with community data</p>
</td></tr>
<tr><td><code id="envelope4idar_+3A_phy">phy</code></td>
<td>
<p>a phylogenetic tree in <code>phylo</code> format (<span class="pkg">ape</span>) or more probably, a distance matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In 2007, Wiegand et al. developed the concept of Individual Species-Area Relationship. Basically, this consist in computing species accumulation curves by samping areas with varying radius <code class="reqn">r</code> around the individual trees of a <em>focal</em> species. Here we provide a version of <em>ISAR(r)</em> (<code>idar="isar"</code>), but we also extend this concept to other diversity-area relationships and provide functions to compute individual phylogenetic diversity-area and individual functional diversity-area relationships. The individual phylogenetic functions  are based in Helmus et al. (2007) measures, i.e., phylogenetic species variability (<code>idar="ipsvar"</code>), phylogenetic species richness (<code>idar="ipsrar"</code>), phylogenetic species evenness (<code>idar="ipsear"</code>), and phylogenetic species clustering (<code>idar="ipscar"</code>). Also, an individual version of the mean nearest taxon distance of Webb et al. (2002) (<code>idar="imntd"</code>).  The individual functional-diversity function (<code>idar="ifdar"</code>) is based in the functional dispersion measure (FDis) of Laliberté and Legendre (2010). Other available functions are based in a weighted community mean of traits (<code>idar="icwmar"</code>),  on  a verison of Rao quadratic entropy (<code>idar="iraodar"</code>), and on the same functions but computed in &quot;rings&quot; defined by the neighbour <code>r</code> values (<code>idar="icwmar.O"</code> and <code>idar="iraodar.O"</code>), which would eliminate the &quot;accumulative&quot; or &quot;memory&quot; effect on <em>ICWMAR(r)</em> and <em>IRAODAR(r)</em>. 
</p>
<p>Although recent litterature (e.g., Wiegand and Moloney 2014) suggest that buffer correction is not necessary for this type of statistics, and by default all functions are estimated without buffer (e.g., <code>buffer=0</code>), several  edge correction coould be employed. For example,  an adaptative buffer correction could be used (<code>buffer="adapt"</code>), i.e., for each radius <code class="reqn">r</code>, only individuals of the focal species that are placed at a distance <code class="reqn">&gt;=r</code> from the border of the plot are considered in the computation of the different meassures. It is also possible to set a fixed buffer width  (e.g., <code>buffer=30</code>), which will accelerate te computations but will discard many useful trees. It is also possible to provide also a fixed window (in the argument <code>bfw</code>) to indicate the limits of the buffer area. This could be useful to computing the IDAR(r) functions in different subsets of the original plot (e.g., in different &quot;habitats&quot;).
</p>
<p>In general, computing envelopes with <code>envelope4idar</code> is a little faster than using <a href="spatstat.explore.html#topic+envelope">envelope</a> and the individual functions (e.g., <a href="#topic+ipsvar">ipsvar</a>, <a href="#topic+ifdar">ifdar</a>, etc). In addition, <code>envelope4idar</code> has the possibility of computing &quot;crossed&quot; individual functions, i.e., using a focal species that is not part of the community whose diversities are being measured. This allows evaluating the diversity of e.g., young trees around older trees, etc. This is accomplished by seting the argument <code>cross.idar=TRUE</code>.
</p>
<p>While  <code>envelope4idar</code> manages data and results, <code>idar2</code> actually computes the individual functions (both observed and simulated) . In general, <code>idar2</code> would not be called directly by the user.
</p>
<p><code>raoDmod</code> is a modification of the function <a href="picante.html#topic+raoD">raoD</a> of <span class="pkg">picante</span> to accept distance matrices instead of phylogenetoc trees. It would not be called directly by the user.
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>fv</code>&quot;, see  <a href="spatstat.explore.html#topic+fv.object">fv.object</a>, and <a href="spatstat.explore.html#topic+envelope">envelope</a>,which can be plotted directly using  <a href="spatstat.explore.html#topic+plot.fv">plot.fv</a>. 
Essentially a data frame containing columns 
</p>

<dl>
<dt>r</dt><dd><p>the vector of values of the argument r at which the <code>idar(r)</code> function has been estimated</p>
</dd>
<dt>obs</dt><dd><p>values of the summary function for the data point pattern </p>
</dd>
<dt>lo</dt><dd><p>lower envelope of simulations</p>
</dd>
<dt>hi</dt><dd><p>upper envelope of simulations </p>
</dd>
<dt>nmean</dt><dd><p>estimated theoretical value of the summary function under the considered null model, computed by averaging simulated values</p>
</dd>
</dl>



<h3>Warning</h3>

<p>The transcription of species names in the multivariate <code>mippp</code>, in the row names of  the data.frame of traits (or in the names or dimnames of  the distance matrices) should be identical. The same applies to the tiplabels of the phylogenetic tree.
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz <a href="mailto:marcelino.delacruz@urjc.es">marcelino.delacruz@urjc.es</a></p>


<h3>References</h3>

<p>Helmus M.R., Bland T.J., Williams C.K. and Ives A.R. (2007) Phylogenetic measures of biodiversity. <em>American Naturalist</em>, 169, E68-E83.
</p>
<p>Laliberté, E. and  Legendre, P. (2010) A distance-based framework for measuring functional diversity from multiple traits. <em>Ecology</em> 91, 299-305. 
</p>
<p>Wiegand,T., Gunatilleke, C.V.S., Gunatilleke, I.A.U.N. and  Huth, A. (2007) How individual species structure diversity in tropical forests. <em>PNAS</em> 104, 19029-19033.
</p>
<p>Webb, C., Ackerly, D., McPeek, M., and Donoghue M.  2002. Phylogenies and community ecology. <em>Annual Review of Ecology and Systematics</em> 33:475-505
</p>


<h3>See Also</h3>

<p><code><a href="picante.html#topic+psd">psd</a></code> for a description of the phylogenetic measures of Helmus et al. (2007).
</p>
<p><code><a href="FD.html#topic+fdisp">fdisp</a></code> for a description of the functional dispersion measure (FDis) of Laliberté and Legendre (2010).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


# compute envelope for isar around sp_44
data(SF)
data(SFtraits)
data(SFphylotree)

  
# 1) Create a list with simulations of the focal species point pattern  with simulador2()
#     or by hand. # Beware that each simulated ppp should be marked (with the mark
#      of the focal species)

#  Example for simulations of an inomogenous PP
# Adjust an IPP:
    
    sp_44.ipp&lt;- density.ppp(unmark(SF[SF$marks$species=="sp_44"]))
   
# simulate 19 realizations of the adjusted IPP
# (BEWARE: in real tests you should use 199 or higher)
    sp_44.ipp.sim &lt;- vector(mode="list", le=19)
    sp_44.ipp.sim &lt;- lapply(sp_44.ipp.sim, function(x) x=rpoispp(sp_44.ipp))
   # mark each simulated pattern
    sp_44.ipp.sim.m &lt;- lapply(sp_44.ipp.sim, function(x) 
                                       {marks(x) = factor(rep("sp_44", x$n)); return(x)})

# 2) compute.envelopes
     # ISAR
  isar.sp_44.ipp.env&lt;- envelope4idar(mippp=SF, mippp.sp.sim= sp_44.ipp.sim.m,
                mimark="sp_44", namesmark="species",r=1:30, buffer=0) 
## Not run: 
     # IFDAR
 ifdar.sp_44.ipp.env&lt;- envelope4idar(mippp=SF, mippp.sp.sim= sp_44.ipp.sim.m,
                mimark="sp_44",  namesmark="species", r=1:30, idar="ifdar", buffer=0, 
		 traits=SFtraits, correct.trait.na=TRUE)

    #IPSVAR
   ipsvar.sp_44.ipp.env&lt;- envelope4idar(mippp=SF, mippp.sp.sim= sp_44.ipp.sim.m,
                 mimark="sp_44", namesmark="species", r=1:30, idar="ipsvar", buffer=0, 
		  tree=SFphylotree)

####################################
# Computing CROSS_IDAR
#--------------------------------------------------

# You need a focal pattern that its not part of the multivariate pattern which is "measured"
# to estimate diversity.
# For example, let's measure diversity of small trees  around large trees of the focal species.

# First, obtain the pattern of large and small trees
# the pattern of small trees will be the "measured" one, i.e., the argument "mippp"

SFlarge&lt;- SF[SF$marks$dbh&gt;=10]
SFsmall &lt;- SF[SF$marks$dbh&lt;10]

# pattern of the focal species (this will be the argument "mippp.sp")
sp_44.large&lt;- SFlarge[SFlarge$marks$species=="sp_44"]

# list of simulated patterns of the focal species (e.g., from an IPP)
sp_44.large.ipp&lt;- density.ppp(sp_44.large)
sp_44.large.ipp.sim &lt;- vector(mode="list", le=99)
sp_44.large.ipp.sim &lt;- lapply(sp_44.large.ipp.sim, function(x) x=rpoispp(sp_44.large.ipp))

# COMPUTE envelopes for cross-ISAR(r)
 isar.sp_44.large.cross.ipp.env&lt;- envelope4idar(mippp=SFsmall, r=1:30, buffer=0,
			mippp.sp.sim= sp_44.large.ipp.sim, mippp.sp=sp_44.large,
                        namesmark="species", cross.idar =TRUE) 

# COMPUTE envelopes for cross-IFDAR(r)
ifdar.sp_44.large.cross.ipp.env&lt;- envelope4idar(mippp=SFsmall, r=1:30, idar="ifdar", 
                       buffer=0, mippp.sp.sim= sp_44.large.ipp.sim,  mippp.sp=sp_44.large,
                       namesmark="species", traits=SFtraits, correct.trait.na=TRUE,
                       cross.idar =TRUE) 

# COMPUTE envelopes for cross-IPSVAR(r)
ipsvar.sp_44.large.cross.ipp.env&lt;- envelope4idar(mippp=SFsmall, r=1:30, idar="ipsvar", 
                      buffer=0, mippp.sp.sim= sp_44.large.ipp.sim,  mippp.sp=sp_44.large,
                      namesmark="species",  tree=SFphylotree, cross.idar =TRUE) 


####################################
# Comparing the performance of envelope() and envelope4idar()
# 
#--------------------------------------------------
require(ecespa) # for the ipc.estK() function
data(SF)
SFsp&lt;- unmark(SF)
marks(SFsp)&lt;- SF$marks$species
sp_44.ppp&lt;-unmark(SF[SF$marks$species=="sp_44"])
sp_44.pc&lt;- ipc.estK(sp_44.ppp)


# use multifocalsimulator() to use the same simulations with both functions.
sp_44.pc.sim.mf0&lt;-multifocalsimulator(pp=SFsp, mimark="sp_44",
                           simulate=expression(rIPCP(sp_44.pc)), nsim=99, nmin=sp_44.ppp$n)

# envelopes with function envelope()
gc()
t0&lt;- Sys.time()
  ifdar.sp_44.pc.env.e2&lt;- envelope(SFsp, fun=ifdar, mimark="sp_44", traits=SFtraits,
                            correct.trait.na=TRUE, nsim=99, simulate=sp_44.pc.sim.mf0, r=1:30,
                            savefuns=TRUE, buffer=0)
Sys.time()-t0

# envelopes with function envelope4idar()

# Here you should input simulated patterns only for the focal species so, first,
# extract it fom the list of simulated multivariate ppp

sp_44.pc.sim.mf00&lt;- lapply(sp_44.pc.sim.mf0, function(x) {x=x[x$marks=="sp_44"];return(x)})

gc()
t0&lt;- Sys.time()
ifdar.sp_44.pc.env2&lt;- envelope4idar(mippp=SF, mippp.sp.sim= sp_44.pc.sim.mf00, mimark="sp_44",
				namesmark="species", r=1:30, idar="ifdar", buffer=0, 
                                nsim=99, traits=SFtraits, correct.trait.na=TRUE)
Sys.time()-t0



## End(Not run)
</code></pre>

<hr>
<h2 id='fdis'>Average Functional Dispersion</h2><span id='topic+fdis'></span>

<h3>Description</h3>

<p>Computes average Functional Dispersion for several communities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  fdis(x, traits)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdis_+3A_x">x</code></td>
<td>
<p>A community data matrix containing the abundances of the species in the different communities. Rows are sites and species are columns.</p>
</td></tr>
<tr><td><code id="fdis_+3A_traits">traits</code></td>
<td>
<p>A distance matrix among species in <code><a href="base.html#topic+matrix">matrix</a></code> format, i.e. obtained using  <code><a href="base.html#topic+as.matrix">as.matrix</a></code>(<em>d</em>), where <em>d</em> is a  <code>dist</code> object from <code><a href="FD.html#topic+gowdis">gowdis</a></code>, <code><a href="stats.html#topic+dist">dist</a></code> or similar functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrap to <code><a href="FD.html#topic+fdisp">fdisp</a></code> in package <span class="pkg">FD</span>. It manages some of the possible problems that could appear when computing automatically functional dispersion for local communities in <a href="#topic+ifdar">ifdar</a> (mainly &quot;empty&quot; communities, common when computing ifdar(r) for very small <em>r</em>'s). It is a kind of internal function that wouldn't be usually called by the user.
</p>


<h3>Value</h3>

<p>Numeric. The average functional dispersion of the communities in matrix <code>x</code>
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz <a href="mailto:marcelino.delacruz@urjc.es">marcelino.delacruz@urjc.es</a></p>


<h3>References</h3>

<p>Laliberté, E. and  Legendre, P. (2010) A distance-based framework for measuring functional diversity from multiple traits. <em>Ecology</em> 91, 299-305. 
</p>


<h3>See Also</h3>

<p><code><a href="FD.html#topic+fdisp">fdisp</a></code> for a description of the functional dispersion measure (FDis) of Laliberté and Legendre (2010).
</p>

<hr>
<h2 id='ipsim'>Simulate Multivariate Point Patterns</h2><span id='topic+ipsim'></span><span id='topic+ipsimlist'></span><span id='topic+simulador2'></span><span id='topic+multifocalsimulator'></span>

<h3>Description</h3>

<p>These functions simulate  multivariate point patterns from a variety of null models, in the way required to test IDAR(r) functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ipsim(pp, mimark,sigma=0, lambda=NULL, namesmark=NULL)
  ipsimlist(pp, mimark, listsim)
  simulador2(mimark, milambda, nsim=99)
  multifocalsimulator(pp, mimark, simulate,nsim=99,nmin=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipsim_+3A_pp">pp</code></td>
<td>
<p>A multitype (a.k.a. multivariate) marked point pattern. An object with the <a href="spatstat.geom.html#topic+ppp">ppp</a> format of <span class="pkg">spatstat</span></p>
</td></tr>
<tr><td><code id="ipsim_+3A_mimark">mimark</code></td>
<td>
<p>Character. Name of the focal species in the multitype <code>pp</code>.</p>
</td></tr>
<tr><td><code id="ipsim_+3A_namesmark">namesmark</code></td>
<td>
<p>Character. If the marks in <code>pp</code> are within a <code>data.frame</code>, the name of the column with the species names</p>
</td></tr>
<tr><td><code id="ipsim_+3A_sigma">sigma</code></td>
<td>
<p>Sigma for the Gaussian kernel to estimate the intensity of the point pattern to simulate</p>
</td></tr>
<tr><td><code id="ipsim_+3A_listsim">listsim</code></td>
<td>
<p>List with simulated point paterns from <code>simulador2</code></p>
</td></tr>
<tr><td><code id="ipsim_+3A_lambda">lambda</code></td>
<td>
<p>intensity surface, e.g., an image from density.ppp or predict.ppm</p>
</td></tr>
<tr><td><code id="ipsim_+3A_milambda">milambda</code></td>
<td>
<p>intensity surface, e.g., an image from density.ppp or predict.ppm</p>
</td></tr>
<tr><td><code id="ipsim_+3A_nsim">nsim</code></td>
<td>
<p>number of simulations</p>
</td></tr>
<tr><td><code id="ipsim_+3A_nmin">nmin</code></td>
<td>
<p>expected minimum number of points in each simulated pattern</p>
</td></tr>
<tr><td><code id="ipsim_+3A_simulate">simulate</code></td>
<td>
<p>either a list of pre-computed univariate point patterns or an expression in the R language indicating how to simulate the patterns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions produce simulated point patterns appropriate to to compute envelopes of IDAR(r) functions. The usual tests of IDAR(r) functions require that the multivariate (i.e. multispecies) pattern remains fixed, except for the focal species, that is simulated acording to, e.g., an (inhomogeneous) Poisson process.
</p>
<p><code>ipsim</code> returns the multivariate <code>pp</code> pattern with all species in the same locations except the &quot;focal&quot; one (i.e., the one indicated by the argument <code>mimark</code>) that is simulated using <a href="spatstat.random.html#topic+rpoispp">rpoispp</a>. If  an intensity surface (argument <code>lambda</code>) is provided, the focal species will be simulated from this surface. If no <code>lambda</code> is provided but the argument <code>sigma</code> is &gt;0, an intensity surface will be estimated with a Gaussian kernel with the sigma provided (using <a href="spatstat.explore.html#topic+density.ppp">density.ppp</a>) and the simulation will be made form this surface. If no lambda is provided and <code>sigma</code>=0, a homogeneos Poisson process will be simulated.
</p>
<p><code>simulador2</code> generates a list (length = <em>nsim</em>) of marked (with mark = <em>mimark</em>) univariate point patterns from an intensity surface using <a href="spatstat.random.html#topic+rpoispp">rpoispp</a>.
</p>
<p><code>ipsimlist</code> uses the results of <code>simulador2</code> and the multivariate <code>pp</code> pattern to generate a list of multivariate point patterns with all species in the same locations except the &quot;focal&quot; one (i.e., the one indicated by the argument <code>mimark</code>) that has the locations simulated with <code>simulador2</code>.
</p>
<p><code>multifocalsimulator</code> is more flexible and allows the simulation of whichever null model of the focal species that could be described by an R expression.
</p>


<h3>Value</h3>

<p><code>ipsim</code> produces a multivariate point pattern (with the <a href="spatstat.geom.html#topic+ppp">ppp</a> format of <span class="pkg">spatstat</span>); <code>ipsimlist</code>  and <code>multifocalsimulator</code> produce a list of multivariate point patterns; <code>simulador2</code> produces a list of univariate marked patterns.
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz <a href="mailto:marcelino.delacruz@urjc.es">marcelino.delacruz@urjc.es</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Build a multivariate point pattern where maple is simulated according to a Poisson process
# and where all the other species are keep fixed in their original coordinates.
# (The warnings are because in the original lansing point pattern there is a dupplicated
#  point)

data(lansing) 
ipsim(pp=lansing, mimark="maple")

# Build a multivariate point pattern where maple is simulated according to an Inhomogeneous
# Poisson process from an intensity surface estimated "on the fly" with a Gaussian kernel with
# sd = "sigma", and where all the other species are keep fixed in their original coordinates.

ipsim(pp=lansing, mimark="maple", sigma=0.1)

# Build a multivariate point pattern where maple is simulated according to an Inhomogeneous
# Poisson process from a predefined  intensity surface "lambda" and where all the other
# species are keep fixed in their original coordinates. "Lambda" is an im object resulting
# from density.ppp(), from predict.ppm() or converted from any other rasterized image. 

maple.lambda&lt;- density.ppp(lansing[lansing$marks=="maple"])
ipsim(pp=lansing, mimark="maple", lambda=maple.lambda)

# Build a list of 19 multivariate point pattern where maple is simulated according to an
# Inhomogeneous Poisson process from a predefined  intensity surface "lambda" and where all
# the other species are keep fixed in their original coordinates. "Lambda" is an im object
# resulting  from density.ppp(), # from predict.ppm() or converted from any other rasterized
# image. 

  # Estimate the intensity of maple
   maple.lambda&lt;- density(unmark(lansing[lansing$marks=="maple"]))

  # first simulate the individual maple patterns
   maple.sim&lt;- simulador2(mimark="maple", milambda=maple.lambda, nsim=19)

  # Then, mix the simulated maple patterns with the rest of the multivariate pattern
  # (which remains "fixed")
   multi.maple.sim&lt;- ipsimlist(pp=lansing, mimark="maple", listsim=maple.sim)


## Use of multifocalsimulator() ##

# The same but in a single step with multifocalsimulator(): Build a list of 19 multivariate
# point pattern where maple is simulated according to an Inhomogeneous Poisson process
# from a predefined  intensity surface "lambda" and where all the other species are keep 
# fixed in their original coordinates. "Lambda" is an im object resulting from density.ppp(),
# from predict.ppm() or converted from any other rasterized image. 

   # Estimate the intensity of maple
   maple.lambda&lt;- density(unmark(lansing[lansing$marks=="maple"]))

   # get 99 simulated multivariate point patterns where only maple varies,
   # according to an inhomogeneous Poisson process
   multi.maple.sim &lt;- multifocalsimulator(lansing, "maple", nsim=99,
                                         simulate=expression(rpoispp(maple.lambda)))

## Not run: 
   # Use the simulated multivariate patterns to compute  envelopes for the ISAR against
   # a null model of IPP for maple 
   isar.maple.env&lt;- envelope(lansing, fun=isar, mimark="maple", nsim=99, savefuns=TRUE,
                                         r=seq(0.01, 0.25, le=100), simulate=multi.maple.sim)
   plot( isar.maple.env)



# Use multifocalsimulator()  to compute  envelopes for the ISAR against a null model of
# Poisson cluster for maple.

   # First, adjust a Poisson Cluster process to maple
   require(ecespa)
   maple.pc&lt;- ipc.estK(unmark(lansing[lansing$marks=="maple"]))

  # generate list of simulated multivariate partterns (all other species fixed and maple
  # simulated according to the adjusted PC process):
   maple.pc.sim&lt;-multifocalsimulator(pp=lansing, mimark="maple", nsim=99,nmin=NULL,
                                                 simulate=expression(rIPCP(maple.pc)))

  # compute envelopes
   isar.maple.pc.env&lt;- envelope(lansing, fun=isar, mimark="maple", nsim=99, savefuns=TRUE, 
                                            simulate=maple.pc.sim, r=seq(0.01, 0.25, le=100))
   plot( isar.maple.pc.env)


# Compute  envelopes for the IFDAR against a null model of Poisson cluster for sp_44 in
# San Francisco forest.
   data(SF)
   data(SFtraits)

   # first, get the original point pattern but with marks only for the species (i.e., dsicard 
   # the data.frame of marks and keep only the vector of species names)
   SFsp&lt;- unmark(SF)
   marks(SFsp)&lt;- SF$marks$species

   # second, adjust a PCP to sp_44
   sp_44.pc&lt;- ipc.estK(unmark(SFsp[SFsp$marks=="sp_44"]))

  # third, generate multivariate simulated patterns with only sp_44 varying according
  # to the adjusted PCP
   sp_44.pc.sim&lt;-multifocalsimulator(pp=SFsp, mimark="sp_44",nsim=99,nmin=NULL,
                                                 simulate=expression(rIPCP(sp_44.pc)))

   # finally, compute envelopes
   ifdar.sp_44.pc.env&lt;- envelope(SFsp, fun=ifdar, mimark="sp_44", traits=SFtraits, r=1:30,
                        correct.trait.na=TRUE, nsim=99, simulate=sp_44.pc.sim,  savefuns=TRUE)

   plot( ifdar.sp_44.pc.env)


## End(Not run)
</code></pre>

<hr>
<h2 id='isar'>Individual Diversity Area Relationships</h2><span id='topic+isar'></span><span id='topic+ipscar'></span><span id='topic+ipsear'></span><span id='topic+ipsvar'></span><span id='topic+ipsrar'></span><span id='topic+ifdar'></span>

<h3>Description</h3>

<p>Estimate different Individual Diversity-Area Relationships from a multivariate point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  isar(mippp, mippp.sp=NULL, mimark=NULL,  namesmark=NULL, r=NULL,
   buffer=0, bfw=NULL)
  ipscar(mippp, mippp.sp=NULL, mimark=NULL,  namesmark=NULL,
   tree=NULL, r=NULL, buffer=0, bfw=NULL, correct.phylo="mean")
  ipsear(mippp, mippp.sp=NULL, mimark=NULL,  namesmark=NULL,
   tree=NULL, r=NULL, buffer=0, bfw=NULL, correct.phylo="mean")
  ipsvar(mippp, mippp.sp=NULL, mimark=NULL,  namesmark=NULL,
   tree=NULL, r=NULL, buffer=0, bfw=NULL, correct.phylo="mean")
  ipsrar(mippp, mippp.sp=NULL, mimark=NULL,  namesmark=NULL,
   tree=NULL, r=NULL, buffer=0, bfw=NULL, correct.phylo="mean")
  ifdar(mippp, mippp.sp=NULL, mimark=NULL,  namesmark=NULL,
   traits=NULL, r=NULL, buffer=0, bfw=NULL, correct.trait.na=FALSE,
     correct.trait="mean")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isar_+3A_mippp">mippp</code></td>
<td>
<p>A multitype (a.k.a. multivariate) marked point pattern. An object with the <a href="spatstat.geom.html#topic+ppp">ppp</a> format of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="isar_+3A_mippp.sp">mippp.sp</code></td>
<td>
<p>Univariate point pattern of the focal species. An object with the <a href="spatstat.geom.html#topic+ppp">ppp</a> format of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="isar_+3A_mimark">mimark</code></td>
<td>
<p>Character. Name of the focal species in the multitype <code>mippp</code>.</p>
</td></tr>
<tr><td><code id="isar_+3A_namesmark">namesmark</code></td>
<td>
<p>Character. If the marks in <code>mippp</code> are within a <code>data.frame</code>, the name of the column with the species names</p>
</td></tr>
<tr><td><code id="isar_+3A_buffer">buffer</code></td>
<td>
<p>One of &quot;adapt&quot;, i.e., compute an adaptive buffer, or a number indicating de width of a fixed buffer area around the plot border</p>
</td></tr>
<tr><td><code id="isar_+3A_bfw">bfw</code></td>
<td>
<p>An <a href="spatstat.geom.html#topic+owin">owin</a> object indicating the limits of the buffer area.</p>
</td></tr>
<tr><td><code id="isar_+3A_r">r</code></td>
<td>
<p>Vector of distances to compute IDAR(r) functions</p>
</td></tr>
<tr><td><code id="isar_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree in <code>phylo</code> format (<span class="pkg">ape</span>) or a phylogenetic covariance matrix</p>
</td></tr>
<tr><td><code id="isar_+3A_traits">traits</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a> of traits, or a distance matrix among species (in <code><a href="stats.html#topic+dist">dist</a></code> or <code><a href="base.html#topic+matrix">matrix</a></code> format) computed on a data.frame of traits.</p>
</td></tr>
<tr><td><code id="isar_+3A_correct.phylo">correct.phylo</code></td>
<td>
<p>Character. Either <code>"mean"</code> meaning <em>&quot;include missing species in the tree with a constant mean phylogenetic covariance&quot;</em> or <code>"exclude"</code>, meaning <em>&quot;exclude missing species in the tree from the analysis&quot;</em> </p>
</td></tr>
<tr><td><code id="isar_+3A_correct.trait.na">correct.trait.na</code></td>
<td>
<p>Logical flag indicating whether <code>NA</code> values in the matrix of traits should be &quot;corrected&quot;: NA values will be assigned the mean trait value.</p>
</td></tr>
<tr><td><code id="isar_+3A_correct.trait">correct.trait</code></td>
<td>
<p>Character. Either <code>"mean"</code> or <code>"exclude"</code>. Species missing in the data.frame of traits will be assigned mean trait values or  will be excluded from the analysis, respectively. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>In 2007, Wiegand et al. developed the concept of Individual Species-Area Relationship. Basically, this consist in computing species accumulation curves by samping areas with varying radius <code class="reqn">r</code> around the individual trees of a <em>focal</em> species. Here we extend this concept to other diversity-area relationships and provide functions to compute individual phylogenetic diversity-area and individual functional diversity-area relationships. The individual phylogenetic functions are based in Helmus et al. (2007) measures, i.e., phylogenetic species variability (<code>ipsvar</code>), phylogenetic species richness (<code>ipsrar</code>), phylogenetic species evenness (<code>ipsear</code>), and phylogenetic species clustering (<code>ipscar</code>). The individual functional-diversity function (<code>ifdar</code>) is based in the functional dispersion measure (FDis) of Laliberté and Legendre (2010).
</p>
<p>Although recent litterature (e.g., Wiegand and Moloney 2014) suggest that buffer correction is not necessary for this type of statistics, and by default all functionsare estimated without buffer (e.g., <code>buffer=0</code>), several  edge correction coould be employed. For example,  an adaptative buffer correction could be used (<code>buffer="adapt"</code>), i.e., for each radius <code class="reqn">r</code>, only individuals of the focal species that are placed at a distance <code class="reqn">&gt;=r</code> from the border of the plot are considered in the computation of the different meassures. It is also possible to set a fixed buffer width  (e.g., <code>buffer=30</code>), which will accelerate te computations but will discard many useful trees. It is also possible to provide also a fixed window (in the argument <code>bfw</code>) to indicate the limits of the buffer area. This could be useful to computing the IDAR(r) functions in different subsets of the original plot (e.g., in different &quot;habitats&quot;). 
</p>


<h3>Value</h3>

<p>An object of class &quot;<code>fv</code>&quot;, see  <a href="spatstat.explore.html#topic+fv.object">fv.object</a>, which can be plotted directly using  <a href="spatstat.explore.html#topic+plot.fv">plot.fv</a>. 
</p>
<p>Essentially a data frame containing a column named <em>r</em> with the vector of values of the argument r at which the IDAR(r) function has been estimated and  aonther column, named <em>&quot;isar&quot;, &quot;ipsvar&quot;, &quot;ipsrar&quot;, &quot;ipsear&quot;, &quot;ipscar&quot;</em> or <em>&quot;ifdar&quot;</em>, according to the selected idar argment. This column contains an estimate of the selected IDAR(R) function.
</p>


<h3>Warning</h3>

<p>The transcription of species names in the multivariate <code>mippp</code>, in the row names of  the <code>data.frame</code> of traits (or in the names or <code>dimnames</code> of  the distance matrices) should be identical. The same applies to the <code>tiplabels</code> of the phylogenetic tree.
</p>


<h3>Simulation envelopes</h3>

<p>To compute simulation envelopes for the IDAR(r) functions,  use <code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>. See the examples in this help page and in <code><a href="#topic+ipsim">ipsim</a></code> to know how to compute simulation envelopes from appropriate null models.
</p>
<p>To compute envelopes for &quot;crossed&quot; IDAR(r) functions or to accelerate the computation of &quot;single&quot; IDAR(r) functions, use <code><a href="#topic+envelope4idar">envelope4idar</a></code>.
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz <a href="mailto:marcelino.delacruz@urjc.es">marcelino.delacruz@urjc.es</a></p>


<h3>References</h3>

<p>Helmus M.R., Bland T.J., Williams C.K. and Ives A.R. (2007) Phylogenetic measures of biodiversity. <em>American Naturalist</em>, 169, E68-E83.
</p>
<p>Laliberté, E. and  Legendre, P. (2010) A distance-based framework for measuring functional diversity from multiple traits. <em>Ecology</em> 91, 299-305. 
</p>
<p>Wiegand,T., Gunatilleke, C.V.S., Gunatilleke, I.A.U.N. and  Huth, A. (2007) How individual species structure diversity in tropical forests. <em>PNAS</em> 104, 19029-19033.
</p>


<h3>See Also</h3>

<p><code><a href="picante.html#topic+psd">psd</a></code> for a description of the phylogenetic measures of Helmus et al. (2007).
</p>
<p><code><a href="FD.html#topic+fdisp">fdisp</a></code> for a description of the functional dispersion measure (FDis) of Laliberté and Legendre (2010).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ISAR
   # Point pattern with a data.frame of marks
   data(SF)
   isar.sp_44 &lt;- isar(mippp = SF, mimark="sp_44", namesmark="species", r=1:40) 
   plot(isar.sp_44)
 
   # Point pattern with just a vector of marks
    data(lansing)
    isar.blackoak &lt;- isar(mippp = lansing, mimark="blackoak",  r=seq(0.01, 0.25, le=100))
    plot(isar.blackoak)

   # Examples of the use of different buffers
     # No  buffer at all (by deffault, buffer = 0)
     isar.sp_44.0 &lt;- isar(mippp = SF, mimark="sp_44", namesmark="species", r=1:18)    

     # Adaptive buffer (for each r, use only points within a r distance form the border)
     isar.sp_44.a &lt;- isar(mippp = SF, mimark="sp_44", namesmark="species", r=1:18,
                                buffer="adapt") 

     # Predefined window, for example with a buffer of 7 m within plot limits
     mibfw&lt;- erosion(SF$win, r=7)
      isar.sp_44.w &lt;- isar(mippp = SF, mimark="sp_44", namesmark="species", r=1:18, bfw=mibfw) 


   ######################
   ### Phylogenetic functions ###
   ######################
   
data(SFphylotree)

# IPSCAR
    ipscar.sp_44 &lt;- ipscar(mippp = SF, mimark="sp_44", namesmark="species", r=1:40,
                                     tree=SFphylotree)
    plot(ipscar.sp_44)
 
# IPSEAR
    ipsear.sp_44 &lt;- ipsear(mippp = SF, mimark="sp_44", namesmark="species", r=1:40,
                                  tree=SFphylotree)
    plot(ipsear.sp_44)

# IPSVAR
    ipsvar.sp_44 &lt;- ipsvar(mippp = SF, mimark="sp_44", namesmark="species", r=1:40,
                                   tree=SFphylotree)
    plot(ipsvar.sp_44)

# IPSRAR
    ipsrar.sp_44 &lt;- ipsrar(mippp = SF, mimark="sp_44", namesmark="species", r=1:40,
                                  tree=SFphylotree)
    plot(ipsrar.sp_44)
 
  #####################
  ###  Functional functions ###
  #####################
 
data(SFtraits)

# IFDAR
   # this will cause an error becuse some species have NA's in the vector of trait values
## Not run: 
  # ifdar.sp_44 &lt;- ifdar(mippp = SF, mimark="sp_44", namesmark="species", traits=SFtraits,
  #                           r=1:40, correct.trait="exclude")

## End(Not run)
   # "correct" NA's in trait values  by assigning tospecies without traits the average of the trait 
   # for  all the other species
   ifdar.sp_44 &lt;- ifdar(mippp = SF, mimark="sp_44", namesmark="species",  traits=SFtraits,
			      r=1:40, correct.trait.na=TRUE)

    #"correct"  the existence of NA's in trait values  by excluding species without traits from the
    # analysis
    ifdar.sp_44 &lt;- ifdar(mippp = SF, mimark="sp_44", namesmark="species", traits=SFtraits,
                               r=1:40, correct.trait.na=TRUE,correct.trait="exclude")

     plot(ifdar.sp_44)

# For examples of envelopes for these functions  see the help page of ipsim() or envelope4idar()

</code></pre>

<hr>
<h2 id='LF.gof'>Loosmore and Ford Goodness of Fit Test</h2><span id='topic+LF.gof'></span>

<h3>Description</h3>

 
<p>Performs the Loosmore and Ford (2006) test or the Maximum Absolute Deviation test for a spatial point pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  LF.gof(X, rmin=NULL, rmax=NULL, na.rm=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LF.gof_+3A_x">X</code></td>
<td>
<p>An object resulting from the function <code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>,  i.e., with an attribute &quot;<em>simfuns</em>&quot; (obtained using the argument  <code>savefuns=TRUE</code> in <code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>) ,which is an object of class &quot;<code><a href="spatstat.explore.html#topic+fv">fv</a></code>&quot; containing the summary functions computed for each of the simulated patterns.</p>
</td></tr>
<tr><td><code id="LF.gof_+3A_rmin">rmin</code></td>
<td>
<p>Minimum value of the function argument r over which the maximum absolute deviation, or the integral, will be computed for the test.</p>
</td></tr>
<tr><td><code id="LF.gof_+3A_rmax">rmax</code></td>
<td>
<p>Maximum value of the function argument r over which the maximum absolute deviation, or the integral, will be computed for the test.</p>
</td></tr>
<tr><td><code id="LF.gof_+3A_na.rm">na.rm</code></td>
<td>
<p>Should NA's be removed to compute the integral?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These function perform a tests for goodness-of-fit of a point pattern dataset to a point process model, based on Monte Carlo simulation from the model. The simulations should have been previously computed with the function <code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>, applied with the argument <code>savefuns=TRUE</code> in order to save all the simulated functions, required for the computation of the test.
</p>
<p>The test, popularized in the ecological field by Loosmore and Ford (2006) is also described in Diggle (2003, page 14), and according to Baddeley and Turner (2005) also in Diggle (1986) and  Cressie (1991, page 667, equation (8.5.42)).
If the arguments <code>rmin</code> and <code>rmax</code> are set to <code>NULL</code>, the integral of the GoF statistics will be computed over the complete range of r values.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>

<dl>
<dt>u</dt><dd><p>The GoF statistic, i.e., the value of the integral over the range of <em>r</em>'s</p>
</dd>
<dt>p</dt><dd><p>The p-value of the test</p>
</dd>
<dt>na.count.by.r</dt><dd><p>Number of <code>NA</code> values for each r. It helps to evaluate the reliability of the computed u's, specially for small <em>r</em>'s</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p> Marcelino de la Cruz <a href="mailto:marcelino.delacruz@urjc.es">marcelino.delacruz@urjc.es</a></p>


<h3>References</h3>

<p>Cressie, N.A.C. (1991) <em>Statistics for spatial data</em>. John Wiley and Sons, 1991. 
</p>
<p>Diggle, P. J. (1986). Displaced amacrine cells in the retina of a rabbit : analysis of a bivariate spatial point pattern. <em>J. Neuroscience Methods</em> 18, 115-125. 
</p>
<p>Diggle, P.J. (2003) <em>Statistical analysis of spatial point patterns</em>, Second edition. Arnold. 
</p>
<p>Loosmore, N.B. and Ford, E.D. (2006) Statistical inference using the G or K point pattern spatial statistics. <em>Ecology</em> 87, 1925-1931. 
</p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+dclf.test">dclf.test</a></code> for an alternative implementation of the test in <span class="pkg">spatstat</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># some envelopesfor some idar function
# The argument "savefuns" must be set to "TRUE"
# BEWARE: in real tests nsim shpuld be 199 or higher
data(lansing)
maple.lambda&lt;- density(unmark(lansing[lansing$marks=="maple"]))
multi.maple.sim &lt;- multifocalsimulator(lansing, "maple", nsim=10,
                               simulate=expression(rpoispp(maple.lambda)))

isar.maple.env&lt;- envelope(lansing, fun=isar, mimark="maple", nsim=10,
                                     simulate=multi.maple.sim, r=seq(0.01, 0.25, le=100),
                                      savefuns=TRUE)
# Estimate GoF test
LF.gof(isar.maple.env)

</code></pre>

<hr>
<h2 id='localdar'>
Map Local Diversity Area Relationships
</h2><span id='topic+localdar'></span><span id='topic+fdismap'></span><span id='topic+raoDmap'></span>

<h3>Description</h3>

<p>Estimates and maps local diversity-area relationships.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>localdar(mippp, mippp.sp = NULL, nx = NULL, ny = NULL, mimark = NULL, idar = "isar", 
            buffer = 0, bfw = NULL, r, cross.idar = FALSE, tree = NULL, traits = NULL, 
            namesmark = NULL, correct.trait.na = TRUE, correct.trait = "mean",
            correct.phylo="mean")
fdismap(comm, traits)
raoDmap(comm, phy = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="localdar_+3A_mippp">mippp</code></td>
<td>
<p>A multitype (a.k.a. multivariate) marked point pattern. An object with the <a href="spatstat.geom.html#topic+ppp">ppp</a> format of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="localdar_+3A_mippp.sp">mippp.sp</code></td>
<td>
<p>Univariate point pattern of the focal species. An object with the <a href="spatstat.geom.html#topic+ppp">ppp</a> format of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="localdar_+3A_nx">nx</code></td>
<td>
<p>Number of points of the grid along the x axis.</p>
</td></tr>
<tr><td><code id="localdar_+3A_ny">ny</code></td>
<td>
<p>Number of points of the grid along the y axis.</p>
</td></tr>
<tr><td><code id="localdar_+3A_mimark">mimark</code></td>
<td>
<p>Character. Name of the focal species in the multitype <code>mippp</code>.</p>
</td></tr>
<tr><td><code id="localdar_+3A_idar">idar</code></td>
<td>
<p>Character. The name of the idar function to be computed. Either &quot;isar&quot;, &quot;ipsvar&quot;, &quot;ipsrar&quot;, &quot;ipsear&quot;, &quot;ipscar&quot;, &quot;icwmar&quot;, &quot;icwmar.O&quot;,  &quot;iraodar&quot;or &quot;imntdar&quot;</p>
</td></tr>
<tr><td><code id="localdar_+3A_buffer">buffer</code></td>
<td>
<p>One of &quot;adapt&quot;, i.e., compute an adaptive buffer, or a number indicating the width of a fixed buffer area around the plot border</p>
</td></tr>
<tr><td><code id="localdar_+3A_bfw">bfw</code></td>
<td>
<p>An <a href="spatstat.geom.html#topic+owin">owin</a> object indicating the limits of the buffer area.</p>
</td></tr>
<tr><td><code id="localdar_+3A_r">r</code></td>
<td>
<p>Vector of distances to compute IDAR(r) functions</p>
</td></tr>
<tr><td><code id="localdar_+3A_cross.idar">cross.idar</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the focal pattern will be excluded form the community being measured. </p>
</td></tr>
<tr><td><code id="localdar_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree in <code>phylo</code> format (<span class="pkg">ape</span>) or a phylogenetic covariance matrix</p>
</td></tr>
<tr><td><code id="localdar_+3A_traits">traits</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a> of traits, or a distance matrix among species (in <code><a href="stats.html#topic+dist">dist</a></code> or <code><a href="base.html#topic+matrix">matrix</a></code> format) computed on a data.frame of traits.</p>
</td></tr>
<tr><td><code id="localdar_+3A_namesmark">namesmark</code></td>
<td>
<p>Character. If the marks in <code>mippp</code> are within a <code>data.frame</code>, the name of the column with the species names</p>
</td></tr>
<tr><td><code id="localdar_+3A_correct.trait.na">correct.trait.na</code></td>
<td>
<p>Logical flag indicating whether <code>NA</code> values in the matrix of traits should be &quot;corrected&quot;: NA values will be assigned the mean trait value.</p>
</td></tr>
<tr><td><code id="localdar_+3A_correct.trait">correct.trait</code></td>
<td>
<p>Character. Either <code>"mean"</code> or <code>"exclude"</code>. Species missing in the data.frame of traits will be assigned mean trait values or  will be excluded from the analysis, respectively. </p>
</td></tr>
<tr><td><code id="localdar_+3A_correct.phylo">correct.phylo</code></td>
<td>
<p>Character. Either <code>"mean"</code> meaning <em>&quot;include missing species in the tree with a constant mean phylogenetic covariance&quot;</em> or <code>"exclude"</code>, meaning <em>&quot;exclude missing species in the tree from the analysis&quot;</em> </p>
</td></tr>
<tr><td><code id="localdar_+3A_comm">comm</code></td>
<td>
<p>A comunity data table (sites x species).</p>
</td></tr>
<tr><td><code id="localdar_+3A_phy">phy</code></td>
<td>
<p>A comunity data table (sites x species).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>localdar</code> estimates any of the individual diversity area indices (isar, ipsvar,ipsrar, ipsear, ipscar, icwmar, icwmar.O,  iraodar or imntdar) at specific locations, such as the locations of trees of a &quot;focal&quot; point partern or at some grid of points (i.e., &quot;mapping&quot; local diversity area relationships). If no predefined focal point  pattern is provided (by the arguments <code>mippp.sp</code> or <code>mimark</code>), <code>localdar</code> will, by default, estimate the selected idar function in a 30 x 30 point-grid and return a map (the size of the grid can be modified by the arguments <code>nx</code> and <code>ny</code>).
<code>fdismap</code> and <code>raoDmap</code> are internal functions used by <code>localdar</code> to get the individual componentes of iraoD and FDis, instead of the averages obtained by <code><a href="#topic+envelope4idar">envelope4idar</a></code>.
</p>


<h3>Value</h3>

<p>If a focal point patternn has been provided by the arguments <code>mippp.sp</code> or <code>mimark</code>, <code>localdar</code> will return a list of marked point patterns (as long as the vector <code>r</code>) with the marks showing the estimation of the selected diversity index for the local community defined by a circle of radius <em>r</em> around each of the points of the focal pattern. If no focal point pattern is provided, it will return a list of maps (as long as the vector <code>r</code>)  each with the format <a href="spatstat.geom.html#topic+im">im</a> of <span class="pkg">spatstat</span>, each pixel showing the estimation of the selected diversity index for the local community defined by a circle of radius <em>r</em> around the pixel center.
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz <a href="mailto:marcelino.delacruz@urjc.es">marcelino.delacruz@urjc.es</a></p>


<h3>See Also</h3>

 <p><code><a href="#topic+envelope4idar">envelope4idar</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Map of local species area-relationship [ISAR(r)] in San Francisco plot at r=5 and r= 6 m
  data(SF)
  data(SFphylotree)
  data(SFtraits)

  isarSF &lt;- localdar(SF, r=5:6, namesmark="species")
  
  isarSF
  
  plot(isarSF[[1]])
  
  
# Map of local species area-relationship [ISAR(r)] in San Francisco plot at r=5 and r= 6 m,
# with an adaptive buffer

isarSF &lt;- localdar(SF, r=5:6, namesmark="species",buffer="adapt")



# Map of local species area-relationship [ISAR(r)] in lansing woods at different radii,
# with an fixed  buffer (only for rectangular windows).

data(lansing)
lansing.bfw&lt;- owin(c(0.2,0.8),c(0.2,0.8))
lansing.lsar.bf&lt;-localdar(lansing, r=seq(0.05,0.2,by=0.05), bfw=lansing.bfw)


# Map of local species area-relationship [ISAR(r)] in San Francisco plot at r=5 and r= 6 m,
# with a buffer of 7 m within plot limits

  mibfw&lt;- erosion(SF$win, r=7)

 isarSF &lt;- localdar(SF, r=5:6, namesmark="species", bfw=mibfw)



# Estimate local species area-relationship [ISAR(r)] in the local communities 
#  in circles with radius  r=5 and r= 6 m around the individuals of sp_44

  sp_44_sar &lt;- localdar(SF, r=5:6, namesmark="species", mimark="sp_44")
  sp_44_sar
  plot(sp_44_sar[[1]])
  sp_44_sar[[1]]$marks
  


# Estimate local species area-relationship [ISAR(r)] in the local communities 
#  in circles with radius  r=5 and r= 6 m around the individuals of sp_44
# EXCLUDING the focal species from species counts.

  sp_44_sar &lt;- localdar(SF, r=5:6, namesmark="species", mimark="sp_44", cross.idar=TRUE)
  sp_44_sar
  plot(sp_44_sar[[1]])
  sp_44_sar[[1]]$marks
 
  
  


# Map and estimation of local Phylogenetic Species Variety
local_psvar&lt;-localdar(SF, r=5:6, idar="ipsvar", tree=SFphylotree, namesmark="species")
sp44_psvar &lt;- localdar(SF, r=5:6, idar="ipsvar", tree=SFphylotree, namesmark="species",
                                    mimark="sp_44", buffer="adapt")

# Map and estimation of local Functional Dispersion
local_fdar &lt;- localdar(SF, nx=50, ny=25, r=5:6,  idar="ifdar", traits=SFtraits,
                                 namesmark="species", correct.trait.na=TRUE)
sp44_fdar &lt;- localdar(SF, nx=50, ny=25, r=5:6,  idar="ifdar", traits=SFtraits,
                                  namesmark="species", mimark="sp_44", correct.trait.na=TRUE)


# Map of a local community weighted mean of wood density
# first, put the wood desnsity data as a named vector
 wood.density.vec&lt;-unlist(SFtraits[,  "wood.density", drop=FALSE])
    names(wood.density.vec)&lt;- rownames(SFtraits)
    
local_cwd &lt;- localdar(SF, r=5:6,  idar="icwmar", traits=wood.density.vec,
                                  namesmark="species", correct.trait.na=TRUE)
local_O.cwm &lt;-localdar(SF, r=5:6, idar="icwmar.O", traits=wood.density.vec, 
                                     namesmark="species", correct.trait.na=TRUE)

# Map of Rao's phylogenetic diversity
local_rao&lt;- localdar(SF,  r=5:6, idar="iraodar",  tree=SFphylotree, namesmark="species")
local_O.rao &lt;- localdar(SF, r=5:6, idar="iraodar.O",  tree=SFphylotree, namesmark="species")

# Map of local mean nearest taxon distance 
local_mntd &lt;- localdar(SF, r=5:6, idar="imntdar",  tree=SFphylotree, namesmark="species")


</code></pre>

<hr>
<h2 id='midar'>
Customize the Individual Diversity-Area Relationship Function
</h2><span id='topic+midar'></span>

<h3>Description</h3>

<p>A wrapper to develop new Individual Diversity-Area Relationship functions on the fly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>midar(mippp, mippp.sp = NULL, mimark = NULL, namesmark = NULL, traits = NULL,
tree = NULL, r = NULL, buffer = 0, bfw = NULL, what = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="midar_+3A_mippp">mippp</code></td>
<td>
<p>A multitype (a.k.a. multivariate) marked point pattern. An object with the <a href="spatstat.geom.html#topic+ppp">ppp</a> format of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="midar_+3A_mippp.sp">mippp.sp</code></td>
<td>
<p>Univariate point pattern of the focal species. An object with the <a href="spatstat.geom.html#topic+ppp">ppp</a> format of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="midar_+3A_mimark">mimark</code></td>
<td>
<p>Character. Name of the focal species in the multitype <code>mippp</code>.</p>
</td></tr>
<tr><td><code id="midar_+3A_namesmark">namesmark</code></td>
<td>
<p>Character. If the marks in <code>mippp</code> are within a <code>data.frame</code>, the name of the column with the species names</p>
</td></tr>
<tr><td><code id="midar_+3A_buffer">buffer</code></td>
<td>
<p>One of &quot;adapt&quot;, i.e., compute an adaptive buffer, or a number indicating the width of a fixed buffer area around the plot border</p>
</td></tr>
<tr><td><code id="midar_+3A_bfw">bfw</code></td>
<td>
<p>An <a href="spatstat.geom.html#topic+owin">owin</a> object indicating the limits of the buffer area.</p>
</td></tr>
<tr><td><code id="midar_+3A_r">r</code></td>
<td>
<p>Vector of distances to compute IDAR(r) functions</p>
</td></tr>
<tr><td><code id="midar_+3A_tree">tree</code></td>
<td>
<p>A phylogenetic tree in <code>phylo</code> format (<span class="pkg">ape</span>) or a phylogenetic covariance matrix</p>
</td></tr>
<tr><td><code id="midar_+3A_traits">traits</code></td>
<td>
<p>A <a href="base.html#topic+data.frame">data.frame</a> of traits, or a distance matrix among species (in <code><a href="stats.html#topic+dist">dist</a></code> or <code><a href="base.html#topic+matrix">matrix</a></code> format) computed on a data.frame of traits.</p>
</td></tr>
<tr><td><code id="midar_+3A_what">what</code></td>
<td>
<p>A valid R expression or function that would accept a community matrix (sites x species) and return a unique value</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>midar</code> allows computing new <em>IDAR</em>(<em>r</em>) functions. The basis of all idar functions are the local communities defined around each point (e.g., each tree) of a focal species (<code>mimark</code>) for a certain circular neighborhood of radius <em>r</em>. Some diversity measure is computed on each community an the average of all of them is returned as the idar value for this <em>r</em>, i.e., as <em>IDAR</em>(<em>r</em>). The function <code>midar</code> applies the R function or expression defined by the argument <code>what</code> to each of the  &quot;community data tables&quot; (matrices) generated by <code><a href="#topic+mitable">mitable</a></code> (one for each <em>r</em> interval defined by the argument <code>r</code>) and return the result as a spatial summary function like all the others in the <span class="pkg">idar</span> package (e.g., <code><a href="#topic+isar">isar</a></code> or <code><a href="#topic+pisar">pisar</a></code>). The R expression or function should accept a community matrix (sites x species) as input and return a unique numeric value.
</p>


<h3>Value</h3>

<p><code>midar</code> return an object of class <code>fv</code>, see  <a href="spatstat.explore.html#topic+fv.object">fv.object</a>, which can be plotted directly using  <a href="spatstat.explore.html#topic+plot.fv">plot.fv</a>. 
Essentially, a data frame containing a column named <em>r</em> with the vector of values of the argument r at which the proposed function had been estimated and  another column, named <em>&quot;midar&quot;</em> which  contains an estimate of the selected function.
</p>


<h3>Simulation envelopes</h3>

<p>To compute simulation envelopes for  <code>midar</code>  functions,  use <code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>. See the examples in this help page and in <code><a href="#topic+multifocalsimulator">multifocalsimulator</a></code> to know how to compute simulation envelopes from appropriate null models.
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz <a href="mailto:marcelino.delacruz@urjc.es">marcelino.delacruz@urjc.es</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+isar">isar</a></code> or <code><a href="#topic+pisar">pisar</a></code> in this package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(SF)
data(SFphylotree)
 # Discard the size mark and keep the species mark in SF ppp:
  sfsp&lt;- ppp(SF$x, SF$y, window=SF$window, marks=SF$marks$species)

# compute "individual Simpsom diversity-area relationship" around sp_44
# using function diversity from package vegan
require(vegan)
simpsom_sp_44&lt;- midar(sfsp, mimark="sp_44", what =function(x) mean(diversity(x, "simpson")),
                                  r=1:15)


# test "individual Simpsom diversity-area relationship" against an inhomogeneous Poisson
# null modellfor sp_44. 
  # estimate intensityh surface for sp_44
   lambda&lt;- density.ppp(unmark(sfsp[sfsp$marks=="sp_44"]), positive=TRUE)
  
  # generate 19 realizations of the null model, keeping all the other species fixed in their
  #  original coordinates.
   simulados&lt;- multifocalsimulator(sfsp, mimark="sp_44", simulate=expression(rpoispp(lambda)),
                      nsim=19, nmin=15)

  # for simplicity define the function that we want to apply to each "local community"
  #  around each tree of sp_44
  mean_simpsom &lt;- function(x) mean(diversity(x, "simpson"))

  # compute envelopes and plot them.
  simpsom_sp_44.env&lt;-envelope(sfsp, midar, mimark="sp_44", what =mean_simpsom ,r=1:15,
                      nsim=19, simulate=simulados)
  plot(simpsom_sp_44.env)


# compute IPSVAR(r) "by hand"
   # first, check tree as would check it ipsvar
   arbol &lt;- checktree(SFphylotree,  SF, "ipsvar", correct.phylo="exclude")

    # define function to obtain the averge psv from the set of local communities
    #  at each neigborhood radii r
     mipsv &lt;- expression(mean(psv(x, tree=tree, compute.var=FALSE)$PSVs, na.rm=TRUE))
     # compute ipsvar "by hand" 
     sp_44_psv&lt;- midar(sfsp, mimark="sp_44", tree=arbol, what =mipsv ,r=1:15)
     plot(sp_44_psv)

# compare it with the result of the built-in function
     plot(ipsvar(sfsp, mimark="sp_44", tree=arbol, r=1:15), add=TRUE, col="blue")
    
</code></pre>

<hr>
<h2 id='mitable'>Tabulate Marks in Neighbourhood of Every Point in a Point Pattern</h2><span id='topic+mitable'></span>

<h3>Description</h3>

<p>For a sequence of radii defining different neighbourhood sizes, visit each point in a focal point pattern, find the neighbouring points in a target point pattern, and compile a frequency table of the marks of these neighbour points for each radii.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  mitable(ppp1,ppp2,r)
  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mitable_+3A_ppp1">ppp1</code></td>
<td>
<p>&quot;Focal&quot; point pattern (an <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> object of <span class="pkg">spatstat</span>) or a <a href="base.html#topic+data.frame">data.frame</a> with columns named &quot;x&quot; and &quot;y&quot;</p>
</td></tr>
<tr><td><code id="mitable_+3A_ppp2">ppp2</code></td>
<td>
<p>&quot;Target&quot; multivariate point pattern (an <code><a href="spatstat.geom.html#topic+ppp">ppp</a></code> object of <span class="pkg">spatstat</span>) or a <a href="base.html#topic+data.frame">data.frame</a> with columns named &quot;x&quot;, &quot;y&quot;, and &quot;marks&quot;. The column &quot;marks&quot; wears the (species) name of each point</p>
</td></tr>
<tr><td><code id="mitable_+3A_r">r</code></td>
<td>
<p>Vector with the sequence of radii (<em>r&gt;0</em>) that define different neiborhood sizes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given both a &quot;focal&quot; and a &quot;target&quot; point patterns, <code>mitable</code> visits each point in the focal point pattern, finds the neighbouring points in the target point pattern, and compile a frequency table of the marks of these neighbour points, where the neibourhood is defined by circles orf radius <em>r</em> around the focal points. From an ecological point of view, it provides a <em>relevé</em> of the local community around each focal tree. It repeats the process for each provided <em>r</em>.
</p>


<h3>Value</h3>

<p>A list, with length = <em>length(r)</em>. Within each element of the list, a matrix with dimensions <em>np</em> X <em>nsp</em>, where <em>np</em> is the number of points of the focal point pattern and <em>nsp</em> is the number of unique species (i.e., unique marks) in the target point pattern. Cell values in the matrix represent number of neighbours of the <em>j</em> species for individual <em>i</em> at the considered neibourhood size.
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz <a href="mailto:marcelino.delacruz@urjc.es">marcelino.delacruz@urjc.es</a></p>


<h3>See Also</h3>

<p><code><a href="spatstat.explore.html#topic+marktable">marktable</a></code> for a similar function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Compute number of trees of different species  within circles of several  radii r 
# around each individual maple tree in lansing woods

data(lansing)

maple&lt;- unmark(lansing[lansing$marks=="maple"])
maple
r= c(0.05, 0.08, 0.1)

counts &lt;- mitable(ppp1=maple, ppp2=lansing, r=r) 
dim(counts[[1]])
head(counts[[1]])


</code></pre>

<hr>
<h2 id='pisar'>
Phylogenetic Individual Species Area Relationship
</h2><span id='topic+pisar'></span><span id='topic+risar'></span><span id='topic+controldis'></span>

<h3>Description</h3>

<p>Compute Phylogenetic Individual Species Area Relationship function, i.e., PISAR(r) and its normalized version rISAR(r).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pisar(mippp, mippp.sp = NULL, mimark = NULL, namesmark = NULL, d = NULL, r = NULL,
         buffer = 0, bfw = NULL)
risar(mippp, mippp.sp = NULL, mimark = NULL, namesmark = NULL, d = NULL, d0 = NULL,
        r = NULL, buffer = 0, bfw = NULL)
controldis(d, m, mimark)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pisar_+3A_mippp">mippp</code></td>
<td>
<p>A multitype (a.k.a. multivariate) marked point pattern. An object with the <a href="spatstat.geom.html#topic+ppp">ppp</a> format of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="pisar_+3A_mippp.sp">mippp.sp</code></td>
<td>
<p>Univariate point pattern of the focal species. An object with the <a href="spatstat.geom.html#topic+ppp">ppp</a> format of <span class="pkg">spatstat</span>.</p>
</td></tr>
<tr><td><code id="pisar_+3A_mimark">mimark</code></td>
<td>
<p>Character. Name of the focal species in the multitype <code>mippp</code>.</p>
</td></tr>
<tr><td><code id="pisar_+3A_namesmark">namesmark</code></td>
<td>
<p>Character. If the marks in <code>mippp</code> are within a <code>data.frame</code>, the name of the column with the species names.</p>
</td></tr>
<tr><td><code id="pisar_+3A_buffer">buffer</code></td>
<td>
<p>One of &quot;adapt&quot;, i.e., compute an adaptive buffer, or a number indicating the width of a fixed buffer area around the plot border.</p>
</td></tr>
<tr><td><code id="pisar_+3A_bfw">bfw</code></td>
<td>
<p>An <a href="spatstat.geom.html#topic+owin">owin</a> object indicating the limits of the buffer area.</p>
</td></tr>
<tr><td><code id="pisar_+3A_r">r</code></td>
<td>
<p>Vector of distances to compute PIDAR(r) functions.</p>
</td></tr>
<tr><td><code id="pisar_+3A_d">d</code></td>
<td>
<p>A matrix expresing relationships (usually functional or phylogenetic) between species present in the multivariate point pattern.</p>
</td></tr>
<tr><td><code id="pisar_+3A_d0">d0</code></td>
<td>
<p>Another matrix expresing relationships (usually functional or phylogenetic) between species present in the multivariate point pattern.</p>
</td></tr>
<tr><td><code id="pisar_+3A_m">m</code></td>
<td>
<p>A community (sites x species) data table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The original definition of <em>ISAR</em>(<em>r</em>) (Wiegand et al. 2007) was reformulated as:
</p>
<p style="text-align: center;"><code class="reqn">ISAR_f (r) =\sum_{m=1}^{S} \delta_{fm} D_{fm} (r)</code>
</p>

<p>(Wiegand and Moloney 2014; Wang et al. 2016), where <code class="reqn">D_{fm}(r)</code> describe the probabilities that the nearest species <em>m</em> neighbor of the typical
individual of the focal species <em>f</em> is located within distance <em>r</em>, and <code class="reqn">\delta_{fm} </code> yields a value of zero if <em>f = m</em> and a value of one otherwise (note that in their original proposal ISAR was formulated as if the value assigned to <code class="reqn">\delta_{fm} </code> were 1 for all species pairs, including <em>f = m</em>). Based in  this re-formulation, they defined the <em>Phylogenetic Individual Species Area Relationship</em>, i.e., <em>PISAR</em>(<em>r</em>), as:
</p>
<p style="text-align: center;"><code class="reqn">PISAR_f (r) =\sum_{m=1}^{S} \delta_{fm}^{phy}D_{fm} (r)</code>
</p>

<p>where <code class="reqn">\delta_{fm}^{phy}</code> is an index of phylogenetic (or functional) dissimilarity between species <em>f</em>
and <em>m</em>. <em>PISAR</em>(<em>r</em>) quantifies the expected phylogenetic (or functional) diversity of species within the
neighborhood with radius <em>r</em> around the typical individual of the focal species <em>f</em>.
</p>
<p>They also defined <em>rISAR</em>(<em>r</em>) as a  a function that is independent of local species richness within the neighborhood <em>r</em>; for this, they divided the PISAR function by the ISAR function:
</p>
<p style="text-align: center;"><code class="reqn">rISAR_f (r) = \frac{\sum_{m=1}^{S} \delta_{fm}^{phy}D_{fm} (r)}{\sum_{m=1}^{S} \delta_{fm}D_{fm} (r)}  </code>
</p>

<p>If the placement of the focal species <em>f</em> is unrelated with functional or phylogenetic relationships with their neighbors, the <code class="reqn">rISAR_f(r)</code> will approximate the mean pairwise functional (or phylogenetic) dissimilarity 
<code class="reqn">\Delta_f^P = \sum_m \delta_{fm}^{phy}/(S-1)</code> between an individual of the
focal species <em>f</em> and all other species in the plot.
</p>
<p>The function <code>controldis</code> controls that the order of species in the phylogenetic distance matrix matches the order of species amomng the levels of species marks in the point pattern, and extracts the vector of distances from all species to the focal one (<code>mimark</code>).  
</p>


<h3>Value</h3>

<p><code>pisar</code> and <code>risar</code> return an object of class <code>fv</code>, see  <a href="spatstat.explore.html#topic+fv.object">fv.object</a>, which can be plotted directly using  <a href="spatstat.explore.html#topic+plot.fv">plot.fv</a>. 
</p>
<p>Essentially a data frame containing a column named <em>r</em> with the vector of values of the argument r at which the PISAR(r) or rISAR(r) function had been estimated and  another column, named <em>&quot;risar&quot;</em> or <em>&quot;pidar&quot;</em>,which  contains an estimate of the selected function.
</p>
<p><code>controldis</code> returns either the vector of distances between the focal and the rest of species or a vector of 1's if there is not phyloegenetic distance provided.
</p>


<h3>Simulation envelopes</h3>

<p>To compute simulation envelopes for  <code>pisar</code> or <code>risar</code> functions,  use <code><a href="spatstat.explore.html#topic+envelope">envelope</a></code>. See the examples in this help page and in <code><a href="#topic+multifocalsimulator">multifocalsimulator</a></code> to know how to compute simulation envelopes from appropriate null models.
</p>


<h3>NOTE</h3>

<p>When computing risar it is necessary to provide a phylogenetic or functional distance matrix to the argument <code>d</code>. By default,  argument <code>d0</code> will be set to a vector of 1's. It is however possible to provide a different matrix to <code>d0</code> and compute instead, e.g.,  a ratio of phylogenetic to functional diversity.
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz <a href="mailto:marcelino.delacruz@urjc.es">marcelino.delacruz@urjc.es</a></p>


<h3>References</h3>

<p>Wang, X., et al. (2016). Stochastic dilution effects weaken deterministic effects of niche-based processes in species rich forests. <em>Ecology, in press</em>
</p>
<p>Wiegand,T., Gunatilleke, C.V.S., Gunatilleke, I.A.U.N. and  Huth, A. (2007) How individual species structure diversity in tropical forests. <em>PNAS</em> 104, 19029-19033.
</p>
<p>Wiegand, T., and K.A. Moloney. (2014). <em>A handbook of spatial point pattern analysis in ecology</em>. Chapman and Hall/CRC press, Boca Raton, FL 
</p>


<h3>See Also</h3>

<p>See also <code><a href="#topic+isar">isar</a></code> for other individual diversity area functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(SF)
data(SFphylotree)

# Discard the size mark and keep the species mark in SF ppp:
sfsp&lt;- ppp(SF$x, SF$y, window=SF$window, marks=SF$marks$species)

# compute phylogenetic distance among species
dphy &lt;- cophenetic(SFphylotree)

# compute and plot PISAR function for sp_44
pisar_44 &lt;- pisar(sfsp, mimark="sp_44", r=1:15,  d=dphy)
plot(pisar_44)

## Not run: 

# Compute rISAR and plot envelopes for an inhomogeneous Poisson model
#  of each species in San Francisco plot 
# BEWARE: THIS TAKES QUITE A FEW MINUTES !!!

# Split sfsp point pattern ppp by species
sfsp.sp&lt;- split(sfsp)

#  Species with &gt;= 10 individuals
sfsp10 &lt;- sapply(sfsp.sp, function(x) x$n&gt;=10)
#names of those species
nombressf&lt;- names(sfsp10[sfsp10])

# parameters for the simulations, estimation of intensity, etc.
nsim&lt;-199
nmin&lt;-10
sigma &lt;- 8
r&lt;- seq(1,15, by=0.5)

# list to store results
risar.sf&lt;- list()
# start computation
for( sp in nombressf){
   print(sp)
   # estimate intensity of the focal species
   lambda&lt;- density(unmark(sfsp[sfsp$marks==sp]), sigma=sigma, positive=TRUE)      
   # obtain simulated patterns were all species ecept the focal remain fixed 
   #  and the focal varies according to an inhomomgeneous Poiisson process 
   simulados&lt;- multifocalsimulator(sfsp, mimark=sp,
              simulate=expression(rpoispp(lambda)), nsim=nsim,nmin=nmin)
   # compute risar
   risar.sf[[sp]] &lt;- envelope(sfsp, risar, mimark=sp, d=dphy, r=r,
        simulate=simulados,nsim=nsim, savefuns=T, buffer=0)
}

# plot the results
 dev.new(height=7, width=16)
 par(mfrow=c(3,9))
 for(i in 1:27) plot(risar.sf[[i]], legend=F, main=nombressf[i])


## End(Not run)


</code></pre>

<hr>
<h2 id='proportion.idar'>Determine the Proportion of Accumulator and Repeller Species</h2><span id='topic+proportion.idar'></span><span id='topic+plot.pidar'></span>

<h3>Description</h3>

<p>This function determines the proportion of species in a community that &quot;accumulate&quot; or &quot;repell&quot; diversity, in the sense of Wiegand et al. (2007).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  proportion.idar(envlist, alfa = 0.05)
     ## S3 method for class 'pidar'
plot(x,cols=c(1,2,3),type=c("l","o","o"), pch=c(NA,19,19),
    lty=c(1,1,1),  legend=TRUE, p.legend="topleft",...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proportion.idar_+3A_envlist">envlist</code></td>
<td>
<p>A list whose elements are the result of applying <a href="spatstat.explore.html#topic+envelope">envelope</a> to a set of point patterns.</p>
</td></tr>
<tr><td><code id="proportion.idar_+3A_alfa">alfa</code></td>
<td>
<p>alpha value to calculate deviations from null model</p>
</td></tr>
<tr><td><code id="proportion.idar_+3A_x">x</code></td>
<td>
<p>The result of <code>proportion.idar</code></p>
</td></tr>
<tr><td><code id="proportion.idar_+3A_cols">cols</code></td>
<td>
<p>A vector (length =3) with the color names or codes for the curves of each of the 3 categories: &quot;neutral&quot;, &quot;accumulator&quot;, &quot;repeller&quot;.</p>
</td></tr>
<tr><td><code id="proportion.idar_+3A_type">type</code></td>
<td>
<p>A vector (length =3), with the type of plot for each category. See <a href="graphics.html#topic+plot.default">plot.default</a>.</p>
</td></tr>
<tr><td><code id="proportion.idar_+3A_pch">pch</code></td>
<td>
<p>A vector (length =3), with the point type  for each category. See <a href="graphics.html#topic+points">points</a></p>
</td></tr>
<tr><td><code id="proportion.idar_+3A_lty">lty</code></td>
<td>
<p>A vector (length =3), with the line type  for each category. See <a href="graphics.html#topic+par">par</a></p>
</td></tr>
<tr><td><code id="proportion.idar_+3A_legend">legend</code></td>
<td>
<p>Logical. Should a legend be added to the plot?</p>
</td></tr>
<tr><td><code id="proportion.idar_+3A_p.legend">p.legend</code></td>
<td>
<p>Position of the legend. It can be a vector wit the xycoordinates of the upperleft corner of the legend box or a  keyword accepted by <code><a href="graphics.html#topic+legend">legend</a></code></p>
</td></tr>
<tr><td><code id="proportion.idar_+3A_...">...</code></td>
<td>
<p>Additional graphical parameters passed both to funtions <code>plot</code> and <code>lines</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function determines the proportion of accumulator, repeller and neutral species at each scale <em>r</em>, following the approach of Wiegand et al (2007). A species is classified as an accumulator at scale <em>r</em> if there are less than <code class="reqn">(nsim+1) *alpha/2</code> simulated values greater than the observed <em>idar(r)</em>. On the contrary, a species is classified as repeller at scale if there are less than <code class="reqn">(nsim+1) *alpha/2</code> simulated values smaller than the observed <em>idar(r)</em>.  The percentage is computed over the total of species in<code> envlist</code>. It is necessary that the objects in envlist (i.e. the envelope objects) had been computed with the argument &quot;<code>simfuns=TRUE</code>&quot;.
</p>


<h3>Value</h3>

<p><code>proportion.idar</code> produces an object of class &quot;<code>pidar</code>&quot;, basically a list with components
</p>

<dl>
<dt>percentage</dt><dd><p>A <code>data.frame</code> with 3 columns (&quot;p.accumulators&quot;, &quot;p.repellers&quot;, &quot;p.neutrals&quot;) indicating the percentage in each category for each <em>r</em> (rows)</p>
</dd>
<dt>nsp</dt><dd><p>The total number of species for which the percentage has been computed.</p>
</dd>
<dt>nsim</dt><dd><p>The number of simulations</p>
</dd>
<dt>alfa</dt><dd><p>The alpha value employed to calculate the deviations from null model and the assignation to each of the categories</p>
</dd>
<dt>r</dt><dd><p>The vector of r values at which the idar(r) functions have been estimated</p>
</dd>
<dt>behaviour</dt><dd><p>A data.frame with the behaviour (&quot;A&quot;= accumulator, &quot;R&quot; = repeller) of each species at each radius r</p>
</dd>
</dl>

<p><code>plot.pidar</code> plots the result.
</p>


<h3>Author(s)</h3>

<p> Marcelino de la Cruz <a href="mailto:marcelino.delacruz@urjc.es">marcelino.delacruz@urjc.es</a></p>


<h3>References</h3>

<p>Wiegand,T., Gunatilleke, C.V.S., Gunatilleke, I.A.U.N. and  Huth, A. (2007) How individual species structure diversity in tropical forests. <em>PNAS</em> 104, 19029-19033.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Compute percentage of accumulator, neutral an repeller species (for ISAR) in Lansing woods
# In this example, against a null model of IPP.
data(lansing)

# Compute rISAR and plot envelopes for an inhomogeneous Poisson model
# of each species in San Francisco plot
# Split sfsp point pattern ppp by species
lansing.sp&lt;- split(lansing)

# Set parameters for the simulations, estimation of intensity surface for IPP, etc.
# BEWARE: THIS is for R-TESTING ALONE. REAL TESTS SHOULD EMPLOY 199 simulations or higher
nsim&lt;-8
r&lt;- seq(0.01,0.25, by=0.01)
# Create list to store the results
isar.lansing&lt;- list()
# start computation

for( i in 1: length(lansing.sp)){
   print(i)
   # estimate intensity of the focal species
   lambda&lt;- density(lansing.sp[[i]])
   # obtain simulated patterns were all species except the focal remain fixed
   # and the focal varies according to an inhomomgeneous Poiisson process
   simulados&lt;- multifocalsimulator(lansing, mimark=levels(lansing$marks)[i],
                            simulate=expression(rpoispp(lambda)), nsim=nsim)
  # compute isar and envelopes for each species
  # It is COMPULSORY that the argument "savefuns" it is set to TRUE
   isar.lansing[[i]] &lt;- envelope(lansing, isar, mimark=levels(lansing$marks)[i],  r=r,
         simulate=simulados,nsim=nsim, savefuns=TRUE, buffer=0)
}


prop.isar.lansing &lt;- proportion.idar(isar.lansing)
head(prop.isar.lansing $percentage)
head(prop.isar.lansing $behaviour)
plot(prop.isar.lansing, p.legend=c(0.15,60))

## Not run: 

# Compute percentage of accumulator, neutral an repeller species (for ISAR) in San Francisco
# forest.  In this example, against a null model of IPP.
data(SF)

# Discard the size mark and keep the species mark in SF ppp:
sfsp&lt;- ppp(SF$x, SF$y, window=SF$window, marks=SF$marks$species)

# Compute ISAR and plot envelopes for an inhomogeneous Poisson model
# of each species in San Francisco plot
# Split sfsp point pattern ppp by species
sfsp.sp&lt;- split(sfsp)
# Select species with &gt;= 10 individuals (to get some statistical power)
sfsp10 &lt;- sapply(sfsp.sp, function(x) x$n&gt;=10)
#Get names of those species
nombressf&lt;- names(sfsp10[sfsp10])
# Set parameters for the simulations, estimation of intensity surface for IPP, etc.
nsim&lt;-199
nmin&lt;-10
sigma &lt;- 8
r&lt;- seq(1,15, by=0.5)
# Create list to store the results
isar.sf&lt;- list()
# start computation
# BEWARE: THIS TAKES QUITE A FEW MINUTES!!!
for( sp in nombressf){
   print(sp)
   # estimate intensity of the focal species
   lambda&lt;- density(unmark(sfsp[sfsp$marks==sp]), sigma=sigma, positive=TRUE)
   # obtain simulated patterns were all species except the focal remain fixed
   # and the focal varies according to an inhomomgeneous Poiisson process
   simulados&lt;- multifocalsimulator(sfsp, mimark=sp,
                            simulate=expression(rpoispp(lambda)), nsim=nsim,nmin=nmin)
  # compute isar and envelopes for each species
  # It is COMPULSORY that the argument "savefuns" it is set to TRUE
   isar.sf[[sp]] &lt;- envelope(sfsp, isar, mimark=sp,  r=r,
         simulate=simulados,nsim=nsim, savefuns=TRUE, buffer=0)
}


prop.isar.SF &lt;- proportion.idar(isar.sf)
head(prop.isar.SF$percentage)
head(prop.isar.SF$behaviour)
plot(prop.isar.SF)


## End(Not run)
</code></pre>

<hr>
<h2 id='SF'>
San Francisco forest plot.
</h2><span id='topic+SF'></span><span id='topic+SFphylotree'></span><span id='topic+SFtraits'></span>

<h3>Description</h3>

<p>Point pattern describing the locations of  822 trees (belonging to 113 species) in the San Francisco forest (southern Ecuador). Accompanied by a phylogenetic tree and a file with wood density of some of the species.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(SF)
data(SFphylotree)
data(SFtraits)
</code></pre>


<h3>Format</h3>

<p><code>SF</code> is an object of class <code>ppp</code>  of <span class="pkg">spatstat</span> representing the point pattern of trees locations, with a data.frame of marks. See <code><a href="spatstat.geom.html#topic+ppp.object">ppp.object</a></code> 
for details of the format.The dataset has 822 points with the following marks: 
</p>

<dl>
<dt>species</dt><dd><p>Species to which each tree belongs</p>
</dd>
<dt>dbh</dt><dd><p>Diameter at breast height of each tree</p>
</dd>
</dl>

<p><code>SFphylotree</code> is a  phylogenetic tree of the class  <a href="ape.html#topic+phylo">phylo</a> of <span class="pkg">ape</span>, showing the phylogenetic relationshios among  296 tree species.
</p>
<p><code>SFtraits</code> is a data.frame with just one column, giving the estimated wood density for some of the 296 tree species.
</p>


<h3>Details</h3>

<p>This dataset represents the locations of trees with <em>dbh</em> &gt;= 5 cm in a polygonal plot of approx. 100 x 70 m in the montane forest near to Reserva Biológica San Francisco  (Zamora-Chinchipe, southern Ecuador). These are part of the data collected by Vicuña (2016) and other Ecuadorian botanists and have been  analyzed several times ( e.g., Chacón et al.  2014). The coordinates of trees are given in meters and the <em>dbh</em> in cm. The phylogenetic tree has been extracted from Phylomatic and calibrated with the BLADJ algorithm of Phylocom. The data about wood density have been compiled from several sources and is expressed in <code class="reqn">g/cm^3</code>.
</p>


<h3>Source</h3>

<p>Vicuña, R.  (2016) <em>Estructura espacial y dinámica del bosque montano del Sur del Ecuador. Interacciones bióticas y limitaciones abióticas</em>. Tesis Doctoral. Universidad Politécnica de Madrid.
</p>


<h3>References</h3>

<p>Chacón-Labella et al. (2014) Negative density dependence and environmental heterogeneity effects on tree ferns across succession in a tropical montane forest.
<em>Perspectives in Plant Ecology, Evolution and Systematics</em>  16(2): 52-63.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
