<!DOCTYPE html><html><head><title>Help for package EFDR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EFDR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EFDR-package'><p>Wavelet-Based Enhanced FDR for Signal Detection in Noisy Images</p></a></li>
<li><a href='#df.to.mat'><p>Change xyz data-frame into a Z image</p></a></li>
<li><a href='#diagnostic.table'><p>2x2 diagnostic table</p></a></li>
<li><a href='#fdrpower'><p>Power function</p></a></li>
<li><a href='#nei.efdr'><p>Find wavelet neighbourhood</p></a></li>
<li><a href='#regrid'><p>Regrid ir/regular data</p></a></li>
<li><a href='#test_image'><p>Create a test image</p></a></li>
<li><a href='#test.efdr.condsim'><p>Test for anomalies in wavelet space via conditional simulation</p></a></li>
<li><a href='#wav_th'><p>Indices of wavelets exceeding a given threshold</p></a></li>
<li><a href='#wavelet-test'><p>Test for anomalies in wavelet space</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Wavelet-Based Enhanced FDR for Detecting Signals from Complete
or Incomplete Spatially Aggregated Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-23</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, markdown, ggplot2, RCurl, fields,
gridExtra, animation</td>
</tr>
<tr>
<td>Description:</td>
<td>Enhanced False Discovery Rate (EFDR) is a tool to detect anomalies
    in an image. The image is first transformed into the wavelet domain in
    order to decorrelate any noise components, following which the coefficients
    at each resolution are standardised. Statistical tests (in a multiple
    hypothesis testing setting) are then carried out to find the anomalies. The
    power of EFDR exceeds that of standard FDR, which would carry out tests on
    every wavelet coefficient: EFDR choose which wavelets to test based on a
    criterion described in Shen et al. (2002). The package also provides
    elementary tools to interpolate spatially irregular data onto a grid of the
    required size. The work is based on Shen, X., Huang, H.-C., and Cressie, N.
    'Nonparametric hypothesis testing for a spatial signal.' Journal of the
    American Statistical Association 97.460 (2002): 1122-1140.</td>
</tr>
<tr>
<td>Imports:</td>
<td>copula, Matrix, methods, foreach (&ge; 1.4.2), doParallel (&ge;
1.0.8), waveslim (&ge; 1.7.5), parallel, gstat (&ge; 1.0-19), tidyr
(&ge; 0.1.0.9000), dplyr (&ge; 0.3.0.2), sp (&ge; 1.0-15)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/andrewzm/EFDR/">https://github.com/andrewzm/EFDR/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-22 21:42:39 UTC; andrew</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew Zammit-Mangion [aut, cre],
  Hsin-Cheng Huang [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew Zammit-Mangion &lt;andrewzm@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-22 22:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='EFDR-package'>Wavelet-Based Enhanced FDR for Signal Detection in Noisy Images</h2><span id='topic+EFDR'></span><span id='topic+EFDR-package'></span>

<h3>Description</h3>

<p>Enhanced False Discovery Rate (EFDR) is a tool to detect anomalies in an image. The image is first transformed into the wavelet domain in order to decorrelate any noise components, following which the coefficients at each resolution are standardised. Statistical tests (in a multiple hypothesis testing setting) are then carried out to find the anomalies. The power of EFDR exceeds that of standard FDR, which would carry out tests on every wavelet coefficient: EFDR choose which wavelets to test based on a criterion described in Shen et al. (2002). The package also provides elementary tools to interpolate spatially irregular data onto a grid of the required size. The work is based on Shen, X., Huang, H.-C., and Cressie, N. 'Nonparametric hypothesis testing for a spatial signal.' Journal of the American Statistical Association 97.460 (2002): 1122-1140.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Andrew Zammit-Mangion <a href="mailto:andrewzm@gmail.com">andrewzm@gmail.com</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Hsin-Cheng Huang
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/andrewzm/EFDR/">https://github.com/andrewzm/EFDR/</a>
</p>
</li></ul>


<hr>
<h2 id='df.to.mat'>Change xyz data-frame into a Z image</h2><span id='topic+df.to.mat'></span>

<h3>Description</h3>

<p>Given a data frame with fields <code>x, y</code> and <code>z</code>, <code>df.to.mat</code> uses the <code>x</code> and 
<code>y</code> coordinates to rearrange <code>z</code> into a rectangular matrix image <code>Z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df.to.mat(df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df.to.mat_+3A_df">df</code></td>
<td>
<p>data frame with fields <code>x</code>, <code>y</code> and <code>z</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function requires that <em>all</em> pixels in the image are defined, that is <code>df$x</code> and <code>df$y</code> must be the 
column outputs of the function <code>expand.grid(x0,y0)</code> where <code>x0, y0</code> are axes values. Note that <code>x0</code> and 
<code>y0</code> do not need to be regularly spaced.
</p>


<h3>Value</h3>

<p>matrix image
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(expand.grid(1:10,1:10))
names(df) &lt;- c("x","y")
df$z &lt;- rnorm(nrow(df))
Z &lt;- df.to.mat(df)
</code></pre>

<hr>
<h2 id='diagnostic.table'>2x2 diagnostic table</h2><span id='topic+diagnostic.table'></span>

<h3>Description</h3>

<p>Returns the a 2x2 table resulting from diagnostic evaluation. 
The cells contain the number of true negatives, true positives, false negatives 
and false positives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnostic.table(reject.true, reject, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnostic.table_+3A_reject.true">reject.true</code></td>
<td>
<p>indices of the true alternative hypotheses</p>
</td></tr>
<tr><td><code id="diagnostic.table_+3A_reject">reject</code></td>
<td>
<p>indices of the rejected null hypotheses</p>
</td></tr>
<tr><td><code id="diagnostic.table_+3A_n">n</code></td>
<td>
<p>total number of tests</p>
</td></tr>
</table>


<h3>Value</h3>

<p>2x2 matrix
</p>


<h3>References</h3>

<p>Noel Cressie and Sandy Burden (2015). &quot;Evaluation of diagnostics for hierarchical spatial statistical models.&quot; Contribution to K. V. Mardia Festschrift, Wiley, Chichester, forthcoming.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
wf = "la8"
J = 3
n = 64
h = 0.5
Z &lt;- test_image(h = h, r = 14, n1 = n)$z
sig &lt;- wav_th(Z, wf=wf, J=J, th = h)

Z &lt;- Z + rnorm(n^2)*0.5
m1 &lt;- test.bonferroni(Z, wf="la8",J=3, alpha = 0.05)
m2 &lt;- test.fdr(Z, wf="la8",J=3, alpha = 0.05)

cat("Bonferroni diagnostic table: ",sep="\n")
diagnostic.table(sig,m1$reject_coeff,n = n^2)
cat("FDR diagnostic table: ",sep="\n")
diagnostic.table(sig,m2$reject_coeff,n = n^2)
</code></pre>

<hr>
<h2 id='fdrpower'>Power function</h2><span id='topic+fdrpower'></span>

<h3>Description</h3>

<p>Returns the power of the multiple hypothesis test, by finding
the proportion of the correctly rejected null hypotheses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdrpower(reject.true, reject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fdrpower_+3A_reject.true">reject.true</code></td>
<td>
<p>indices of the true alternative hypotheses</p>
</td></tr>
<tr><td><code id="fdrpower_+3A_reject">reject</code></td>
<td>
<p>indices of the rejected null hypotheses</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Single value (proportion)
</p>


<h3>References</h3>

<p>Shen, X., Huang, H.-C., and Cressie, N. 'Nonparametric hypothesis testing for a spatial signal.' Journal of the American Statistical Association 97.460 (2002): 1122-1140.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
wf = "la8"
J = 3
n = 64
h = 0.5
Z &lt;- test_image(h = h, r = 14, n1 = n)$z
sig &lt;- wav_th(Z, wf=wf, J=J, th = h)

Z &lt;- Z + rnorm(n^2)*0.5
m1 &lt;- test.bonferroni(Z, wf="la8",J=3, alpha = 0.05)
m2 &lt;- test.fdr(Z, wf="la8",J=3, alpha = 0.05)

cat(paste0("Bonferroni power: ",fdrpower(sig,m1$reject_coeff)))
cat(paste0("FDR power: ",fdrpower(sig,m2$reject_coeff)))
</code></pre>

<hr>
<h2 id='nei.efdr'>Find wavelet neighbourhood</h2><span id='topic+nei.efdr'></span>

<h3>Description</h3>

<p>Given an image, this function first computes the 2d DWT and  then returns a 
matrix of size <code>N</code> by <code>b</code> where <code>N</code> is the number of wavelets and <code>b</code> 
is the number of neighbours per wavelet. Two wavelets are deemed
to be neighbours according to the metric of Shen, Huang and Cressie (2002). The distance metric is a function of  the
spatial separation, the resolution and the orientation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nei.efdr(Z, wf = "la8", J = 2, b = 11, parallel = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nei.efdr_+3A_z">Z</code></td>
<td>
<p>image of size <code>n1</code> by <code>n2</code> where both <code>n1,n2</code> have to be powers of two</p>
</td></tr>
<tr><td><code id="nei.efdr_+3A_wf">wf</code></td>
<td>
<p>type of wavelet to employ. Please see <code>waveslim::wave.filter</code>  for a full list of wavelet names</p>
</td></tr>
<tr><td><code id="nei.efdr_+3A_j">J</code></td>
<td>
<p>number of resolutions to employ in the wavelet decomposition</p>
</td></tr>
<tr><td><code id="nei.efdr_+3A_b">b</code></td>
<td>
<p>number of neighbours to consider in EFDR</p>
</td></tr>
<tr><td><code id="nei.efdr_+3A_parallel">parallel</code></td>
<td>
<p>number of cores to use with parallel backend; needs to be an integer less than the number of available cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix of size <code>N</code> by <code>b</code>
</p>


<h3>References</h3>

<p>Shen, X., Huang, H.-C., and Cressie, N. 'Nonparametric hypothesis testing for a spatial signal.' Journal of the American Statistical Association 97.460 (2002): 1122-1140.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>image &lt;- matrix(rnorm(64),8,8)
</code></pre>

<hr>
<h2 id='regrid'>Regrid ir/regular data</h2><span id='topic+regrid'></span>

<h3>Description</h3>

<p>Given a data frame with fields <code>x, y</code> and <code>z</code>, <code>regrid</code> returns a data frame with
fields <code>x, y</code> and <code>z</code>, this time with <code>x, y</code> arranged on a regular grid of size <code>n2</code> by 
<code>n1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regrid(
  df,
  n1 = 128,
  n2 = n1,
  method = "idw",
  idp = 0.5,
  nmax = 7,
  model = "Exp"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regrid_+3A_df">df</code></td>
<td>
<p>data frame with fields <code>x</code>, <code>y</code> and <code>z</code></p>
</td></tr>
<tr><td><code id="regrid_+3A_n1">n1</code></td>
<td>
<p>image length in pixels</p>
</td></tr>
<tr><td><code id="regrid_+3A_n2">n2</code></td>
<td>
<p>image height in pixels</p>
</td></tr>
<tr><td><code id="regrid_+3A_method">method</code></td>
<td>
<p>method to be used, see details</p>
</td></tr>
<tr><td><code id="regrid_+3A_idp">idp</code></td>
<td>
<p>inverse distance power</p>
</td></tr>
<tr><td><code id="regrid_+3A_nmax">nmax</code></td>
<td>
<p>when using inverse distance weighting, the number of nearest neighbours to consider when interpolating using idw. 
When using conditional simulation, the number of nearest observations to used for a kriging simulation</p>
</td></tr>
<tr><td><code id="regrid_+3A_model">model</code></td>
<td>
<p>the model type when using conditional simulation (use <code>gstat::vgm()</code> to list all
possible models)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are three supported methods for regridding. The first, &quot;idw&quot;, is 
the inverse-distance-weighting method. The function overlays a grid over the data. 
The cells are constructed evenly within the bounding 
box of the data and filled with interpolated values using the inverse weighting distance metric 
with power <code>idp</code>. <code>nmax</code> determines the maximum number of neighbours when using the distance weighting.
With this method, interpolation uses the inverse distance weight function <code>gstat</code> in the <code>gstat</code> package.
Refer to the package <code>gstat</code> for more details and formulae.
</p>
<p>The second method &quot;cond_sim&quot; uses conditional simulation to generate a realisation of 
the unobserved process at the grid points. This is a model-based approach, and the 
variogram model may be selected through the parameter <code>model</code>. The exponential
variogram is used by default. For a complete list of possible models use <code>gstat::vgm()</code>.   
For a tutorial on how the conditional simulation is carried out see the <code>gstat</code> vignette. 
</p>
<p>The third method &quot;median_polishing&quot; applies a median polish to the data. First, a grid is overlayed. If more than one
data point is present in each grid box, the mean of the data is taken. Where there is no data, the grid box is assigned
a value of NA. This gridded image is then passed to the function <code>medpolish</code> which carried out Tukey's median
polish procedure to obtain an interpolant of the form <code class="reqn">z(s) = \mu + a(s1) + b(s2)</code> where <code class="reqn">s1</code> is the x-axis and
<code class="reqn">s2</code> is the y-axis. Missing points in the gridded image are then replaced with <code class="reqn">z(s)</code> evaluated at these points. This method 
cannot be used if all rows and columns do not contain at least one data point.
</p>


<h3>Value</h3>

<p>data frame with fields <code>x,y,z</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(x = runif(200),y = runif(200),z=rnorm(200))
df.gridded &lt;- regrid(df, n1=10)
</code></pre>

<hr>
<h2 id='test_image'>Create a test image</h2><span id='topic+test_image'></span>

<h3>Description</h3>

<p>This function generates an image for test purposes. The image is that of a filled circle
at the centre.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_image(h = 1, r = 10, n1 = 64, n2 = 64)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_image_+3A_h">h</code></td>
<td>
<p>amplitude of the filled circle</p>
</td></tr>
<tr><td><code id="test_image_+3A_r">r</code></td>
<td>
<p>radius of the circle (in pixels)</p>
</td></tr>
<tr><td><code id="test_image_+3A_n1">n1</code></td>
<td>
<p>image height in pixels</p>
</td></tr>
<tr><td><code id="test_image_+3A_n2">n2</code></td>
<td>
<p>image width in pixels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with two elements
</p>

<dl>
<dt><code>z</code></dt><dd><p>the test image</p>
</dd>
<dt><code>signal.grid</code></dt><dd><p>the x-y grid in long table format</p>
</dd> 
</dl>



<h3>References</h3>

<p>Shen, X., Huang, H.-C., and Cressie, N. 'Nonparametric hypothesis testing for a spatial signal.' Journal of the American Statistical Association 97.460 (2002): 1122-1140.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- test_image()$z
</code></pre>

<hr>
<h2 id='test.efdr.condsim'>Test for anomalies in wavelet space via conditional simulation</h2><span id='topic+test.efdr.condsim'></span>

<h3>Description</h3>

<p>Test for anomalies using <code>EFDR</code> and conditional simulation. The noisy image 
can be partially observed, or/and aggregated at different resolutions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.efdr.condsim(
  Zvec,
  H,
  n1,
  n2,
  rho_est_method = c("CPL", "MOM"),
  iter.cs = 100,
  wf = "la8",
  J = 2,
  alpha = 0.05,
  n.hyp = 100,
  b = 11,
  iteration = 200,
  parallel = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test.efdr.condsim_+3A_zvec">Zvec</code></td>
<td>
<p>vector of observations such that <code class="reqn">Ztilde = H.Z</code></p>
</td></tr>
<tr><td><code id="test.efdr.condsim_+3A_h">H</code></td>
<td>
<p>matrix mapping the fine-resolution image <code>Z</code> in vector form to <code>Ztllde</code>. Must have 
as many rows as <code>Ztilde</code> and <code>n1</code> x <code>n2</code> columns</p>
</td></tr>
<tr><td><code id="test.efdr.condsim_+3A_n1">n1</code></td>
<td>
<p>number of rows in fine-resolution image</p>
</td></tr>
<tr><td><code id="test.efdr.condsim_+3A_n2">n2</code></td>
<td>
<p>number of columns in fine-resolution image</p>
</td></tr>
<tr><td><code id="test.efdr.condsim_+3A_rho_est_method">rho_est_method</code></td>
<td>
<p>method with which to estimate the level of exchangeability rho; can be either &quot;CPL&quot; (copula model) or &quot;MOM&quot; (method of moments)</p>
</td></tr>
<tr><td><code id="test.efdr.condsim_+3A_iter.cs">iter.cs</code></td>
<td>
<p>number of conditional simulations to carry out</p>
</td></tr>
<tr><td><code id="test.efdr.condsim_+3A_wf">wf</code></td>
<td>
<p>type of wavelet to employ. Defaults to &lsquo;la8&rsquo;, the Daubechies orthonormal compactly supported wavelet of length <code>L = 8</code> (Daubechies, 1992), least asymmetric family. Other options include &lsquo;haar&rsquo; (Haar wavelet), &lsquo;fk8&rsquo; (Fejer-Korovkin wavelet with <code>L=8</code>) and &lsquo;mb8&rsquo; (minimum-bandwidth wavelet with <code>L=8</code>). Please type '<code>waveslim::wave.filter</code>' in the console for a full list of wavelet names</p>
</td></tr>
<tr><td><code id="test.efdr.condsim_+3A_j">J</code></td>
<td>
<p>number of resolutions to employ in wavelet decomposition</p>
</td></tr>
<tr><td><code id="test.efdr.condsim_+3A_alpha">alpha</code></td>
<td>
<p>significance level at which tests are carried out</p>
</td></tr>
<tr><td><code id="test.efdr.condsim_+3A_n.hyp">n.hyp</code></td>
<td>
<p>number of hypotheses tests to carry out with EFDR. If a vector is supplied, the optimal one from 
the set of proposed number of tests is chosen</p>
</td></tr>
<tr><td><code id="test.efdr.condsim_+3A_b">b</code></td>
<td>
<p>the number of neighbours to consider in EFDR</p>
</td></tr>
<tr><td><code id="test.efdr.condsim_+3A_iteration">iteration</code></td>
<td>
<p>number of Monte Carlo iterations to employ when determining which of the proposed number of tests 
in <code>n.hyp</code> is the optimal number of tests</p>
</td></tr>
<tr><td><code id="test.efdr.condsim_+3A_parallel">parallel</code></td>
<td>
<p>number of cores to use with parallel backend; needs to be an integer less than or equal to the number of available cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with three fields:
</p>

<dl>
<dt><code>filtered</code></dt><dd><p>the discrete wavelet transform containing the anomalous wavelet coefficients in the signal</p>
</dd>
<dt><code>Z</code></dt><dd><p>the image containing the anomalous wavelets in the signal</p>
</dd>
<dt><code>reject_coeff</code></dt><dd><p>indices of wavelets under which the null hypothesis of no anomaly was rejected</p>
</dd>
<dt><code>pvalue_ordered</code></dt><dd><p>ordered p-values under the null hypothesis. The column names indicate the 
wavelet to which the p-value belongs</p>
</dd>
<dt><code>nhat</code></dt><dd><p>the number of tests carried out.</p>
</dd>
</dl>



<h3>References</h3>

<p>Daubechies, I. (1992) Ten Lectures on Wavelets, CBMS-NSF Regional Conference Series in Applied Mathematics, SIAM: Philadelphia.
</p>
<p>Shen, X., Huang, H.-C., and Cressie, N. 'Nonparametric hypothesis testing for a spatial signal.' Journal of the American Statistical Association 97.460 (2002): 1122-1140.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Set up experiment
n &lt;- 32       # 32 x 32 images
r &lt;- 10       # signal of size 10 x 10
h &lt;- 5        # intensity of 5
grid &lt;- 8     # aggregated to 8 x 8 image
parallel &lt;- 4 # use 4 cores

## Simulate the pixel-level data
raw_grid &lt;- expand.grid(x = seq(1, n), y = seq(1, n))
df &lt;- data.frame(raw_grid)                        # spatial grid
dd &lt;- as.matrix(dist(raw_grid, diag = TRUE))      # distance matrix
Sigma &lt;- exp(-dd/5)                               # cov. fn.
diag(Sigma) &lt;- 1                                  # fix diagonal
L &lt;- t(chol(Sigma))                               # lower Cholesky factor
mu &lt;- matrix(0, n, n)                             # zero mean
mu[(n/2-r/2):(n/2+r/2), (n/2-r/2):(n/2+r/2)] &lt;- h # add signal
Z &lt;- mu + matrix(L %*% rnorm(n^2), n, n)          # simulate data

## Construct H (aggregation) matrix
H &lt;- matrix(0, grid^2, n^2)
for(i in 1:grid^2) {
  ind &lt;- rep(rep(c(0L,1L,0L),
             c((n/grid)*((i-1)%%grid),n/grid,(n-n/grid-n/grid*((i-1)%%grid)))),
          n/grid)
  H[i,which(c(rep(0L,(ceiling(i/grid)-1)*n^2/grid),ind) == TRUE)] &lt;- 1/(n/grid)^2
}

## Aggregate the signal
z_tilde &lt;- c(H %*% c(Z))

## Run EFDR using conditional simulation
## Not run: out2 &lt;- test.efdr.condsim(Zvec = z_tilde, H = H, n1 = n, n2 = n, 
                                   parallel = parallel)
## End(Not run)
</code></pre>

<hr>
<h2 id='wav_th'>Indices of wavelets exceeding a given threshold</h2><span id='topic+wav_th'></span>

<h3>Description</h3>

<p>This function is primarily used for testing the power of a method in the
wavelet domain. Given an image, the discrete wavelet transform is found. 
The indices of the coefficients which exceed a certain threshold are then
considered the 'signal' for testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wav_th(Z, wf = "la8", J = 2, th = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wav_th_+3A_z">Z</code></td>
<td>
<p>image of size <code>n1</code> by <code>n2</code> where <code>n1,n2</code> have to be powers of two</p>
</td></tr>
<tr><td><code id="wav_th_+3A_wf">wf</code></td>
<td>
<p>type of wavelet to employ. Please see <code>waveslim::wave.filter</code>  for a full list of wavelet names</p>
</td></tr>
<tr><td><code id="wav_th_+3A_j">J</code></td>
<td>
<p>number of resolutions to employ in the wavelet decomposition</p>
</td></tr>
<tr><td><code id="wav_th_+3A_th">th</code></td>
<td>
<p>threshold</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Indices of wavelet coefficients in a vector
</p>


<h3>References</h3>

<p>Shen, X., Huang, H.-C., and Cressie, N. 'Nonparametric hypothesis testing for a spatial signal.' Journal of the American Statistical Association 97.460 (2002): 1122-1140.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- test_image(h = 0.5, r = 14, n1 = 64)$z
print(wav_th(Z,wf="la8",J=3,th=0.5))
</code></pre>

<hr>
<h2 id='wavelet-test'>Test for anomalies in wavelet space</h2><span id='topic+wavelet-test'></span><span id='topic+test.efdr'></span><span id='topic+test.bonferroni'></span><span id='topic+test.fdr'></span><span id='topic+test.los'></span>

<h3>Description</h3>

<p>Test for anomalies using either <code>bonferroni</code>, <code>FDR</code>, <code>EFDR</code> or <code>LOS</code> in the wavelet domain using the 2D wavelet transform.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test.efdr(
  Z,
  wf = "la8",
  J = 2,
  alpha = 0.05,
  n.hyp = 100,
  b = 11,
  iteration = 200,
  parallel = 1L
)

test.fdr(Z, wf = "la8", J = 2, alpha = 0.05)

test.bonferroni(Z, wf = "la8", J = 2, alpha = 0.05)

test.los(Z, wf = "la8", J = 2, alpha = 0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wavelet-test_+3A_z">Z</code></td>
<td>
<p>image of size <code>n1</code> by <code>2n</code> where <code>n1,n2</code> have to be powers of two</p>
</td></tr>
<tr><td><code id="wavelet-test_+3A_wf">wf</code></td>
<td>
<p>type of wavelet to employ. Defaults to &lsquo;la8&rsquo;, the Daubechies orthonormal compactly supported wavelet of length <code>L = 8</code> (Daubechies, 1992), least asymmetric family. Other options include &lsquo;haar&rsquo; (Haar wavelet), &lsquo;fk8&rsquo; (Fejer-Korovkin wavelet with <code>L=8</code>) and &lsquo;mb8&rsquo; (minimum-bandwidth wavelet with <code>L=8</code>). Please type '<code>waveslim::wave.filter</code>' in the console for a full list of wavelet names</p>
</td></tr>
<tr><td><code id="wavelet-test_+3A_j">J</code></td>
<td>
<p>number of resolutions to employ in wavelet decomposition</p>
</td></tr>
<tr><td><code id="wavelet-test_+3A_alpha">alpha</code></td>
<td>
<p>significance level at which tests are carried out</p>
</td></tr>
<tr><td><code id="wavelet-test_+3A_n.hyp">n.hyp</code></td>
<td>
<p>number of hypotheses tests to carry out with EFDR. If a vector is supplied, the optimal one from 
the set of proposed number of tests is chosen</p>
</td></tr>
<tr><td><code id="wavelet-test_+3A_b">b</code></td>
<td>
<p>the number of neighbours to consider in EFDR</p>
</td></tr>
<tr><td><code id="wavelet-test_+3A_iteration">iteration</code></td>
<td>
<p>number of Monte Carlo iterations to employ when determining which of the proposed number of tests 
in <code>n.hyp</code> is the optimal number of tests</p>
</td></tr>
<tr><td><code id="wavelet-test_+3A_parallel">parallel</code></td>
<td>
<p>number of cores to use with parallel backend; needs to be an integer less than or equal to the number of available cores</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with three fields:
</p>

<dl>
<dt><code>filtered</code></dt><dd><p>the discrete wavelet transform containing the anomalous wavelet coefficients in the signal</p>
</dd>
<dt><code>Z</code></dt><dd><p>the image containing the anomalous wavelets in the signal</p>
</dd>
<dt><code>reject_coeff</code></dt><dd><p>indices of wavelets under which the null hypothesis of no anomaly was rejected</p>
</dd>
<dt><code>pvalue_ordered</code></dt><dd><p>ordered p-values under the null hypothesis. The column names indicate the 
wavelet to which the p-value belongs</p>
</dd>
<dt><code>nhat</code></dt><dd><p>the number of tests carried out.</p>
</dd>
</dl>



<h3>References</h3>

<p>Daubechies, I. (1992) Ten Lectures on Wavelets, CBMS-NSF Regional Conference Series in Applied Mathematics, SIAM: Philadelphia.
</p>
<p>Shen, X., Huang, H.-C., and Cressie, N. 'Nonparametric hypothesis testing for a spatial signal.' Journal of the American Statistical Association 97.460 (2002): 1122-1140.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See vignettes by typing vignette("EFDR_vignettes")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
