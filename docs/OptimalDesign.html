<!DOCTYPE html><html><head><title>Help for package OptimalDesign</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {OptimalDesign}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#OptimalDesign-package'>
<p>OptimalDesign</p></a></li>
<li><a href='#dirder'>
<p>Vector of directional derivatives</p></a></li>
<li><a href='#effbound'>
<p>Lower bound on efficiency</p></a></li>
<li><a href='#Fx_blocks'>
<p>Matrix of candidate regressors for a block size-two model</p></a></li>
<li><a href='#Fx_CtoA'>
<p>Transformation of candidate regressors for regularized c-optimality</p></a></li>
<li><a href='#Fx_cube'>
<p>Matrix of candidate regressors for a model on a cuboid grid</p></a></li>
<li><a href='#Fx_dose'>
<p>Matrix of candidate regressors for a dose-response model</p></a></li>
<li><a href='#Fx_glm'>
<p>Matrix of candidate regressors for a generalized linear model</p></a></li>
<li><a href='#Fx_ItoA'>
<p>Transformation of candidate regressors for I-optimality</p></a></li>
<li><a href='#Fx_simplex'>
<p>Matrix of candidate regressors for a regression model on a simplex grid</p></a></li>
<li><a href='#Fx_survival'>
<p>Matrix of candidate regressors for a survival model</p></a></li>
<li><a href='#infmat'>
<p>Information matrix of a design</p></a></li>
<li><a href='#mvee_REX'>
<p>Minimum-volume enclosing ellipsoid</p></a></li>
<li><a href='#od_AQUA'><p>Efficient exact design using a quadratic approximation</p></a></li>
<li><a href='#od_DEL'>
<p>Removal of redundant design points</p></a></li>
<li><a href='#od_KL'>
<p>The KL exchange algorithm for efficient exact designs</p></a></li>
<li><a href='#od_MISOCP'>
<p>Optimal exact design using mixed integer second-order cone programming</p></a></li>
<li><a href='#od_PIN'>
<p>Efficient saturated exact design</p></a></li>
<li><a href='#od_plot'>
<p>Visualization of a design</p></a></li>
<li><a href='#od_pool'>
<p>Pool of a vector</p></a></li>
<li><a href='#od_print'>
<p>Compact information about a design</p></a></li>
<li><a href='#od_PUK'>
<p>Efficient rounding of an approximate design</p></a></li>
<li><a href='#od_RC'><p>Efficient exact design using the RC heuristic</p></a></li>
<li><a href='#od_REX'><p>Optimal approximate size-constrained design</p></a></li>
<li><a href='#od_SYM'>
<p>Symmetrization of an approximate design</p></a></li>
<li><a href='#optcrit'>
<p>Criterion value of a design</p></a></li>
<li><a href='#OptimalDesign-internal'><p>Internal OptimalDesign Functions</p></a></li>
<li><a href='#varfun'>
<p>Vector of variances</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>A Toolbox for Computing Efficient Designs of Experiments</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Radoslav Harman, Lenka Filova</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Lenka Filova &lt;OptimalDesignR@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Algorithms for D-, A-, I-, and c-optimal designs. Some of the functions in this package require the 'gurobi' software and its accompanying R package. For their installation, please follow the instructions at <a href="https://www.gurobi.com">https://www.gurobi.com</a> and the file gurobi_inst.txt, respectively.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td>&lt; <a href="http://www.iam.fmph.uniba.sk/design/">http://www.iam.fmph.uniba.sk/design/</a> &gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.1)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, Matrix, lpSolve, matrixStats, matrixcalc,
plyr, quadprog, rgl, stats, utils</td>
</tr>
<tr>
<td>Enhances:</td>
<td>gurobi, slam</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-01 18:23:59 UTC; Lenka</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-02 08:50:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='OptimalDesign-package'>
OptimalDesign
</h2><span id='topic+OptimalDesign-package'></span><span id='topic+OptimalDesign'></span>

<h3>Description</h3>

<p>Procedures for computing D-, A-, I-, and c-optimal approximate and exact designs of experiments on finite domains, for regression models with uncorrelated observations. 
</p>


<h3>Author(s)</h3>

 
<p>Radoslav Harman, Lenka Filova
</p>

<hr>
<h2 id='dirder'>
Vector of directional derivatives
</h2><span id='topic+dirder'></span>

<h3>Description</h3>

<p>Computes the vector of derivatives at a normalized approximate design <code>w</code> of length <code>n</code> in the directions of singular designs e_i, where i ranges from <code>1</code> to <code>n</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dirder(Fx, w, crit="D", h=NULL, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dirder_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> matrix of candidate regressors (as rows), where <code>n</code> is the number of candidate design points and <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) is the number of parameters.
</p>
</td></tr>
<tr><td><code id="dirder_+3A_w">w</code></td>
<td>

<p>a non-negative vector of length <code>n</code> representing the design. It is normalized prior to the computation of the directional derivatives.
</p>
</td></tr>
<tr><td><code id="dirder_+3A_crit">crit</code></td>
<td>

<p>the criterion; possible values are <code>"D"</code>, <code>"A"</code>, <code>"I"</code>, <code>"C"</code> and <code>"c"</code>.
</p>
</td></tr>
<tr><td><code id="dirder_+3A_h">h</code></td>
<td>

<p>a non-zero vector of length <code>m</code> corresponding to the coefficients of the linear parameter combination of interest. If <code>crit</code> is not <code>"C"</code> nor <code>"c"</code> then <code>h</code> is ignored. If <code>crit</code> is <code>"C"</code> or <code>"c"</code> and <code>h=NULL</code> then <code>h</code> is assumed to be <code>c(0,...,0,1)</code>.
</p>
</td></tr>
<tr><td><code id="dirder_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The i-th directional derivative measures the increase of the criterion value provided that we infinitesimally increase the i-th design weight (and decrease other weights by the same proportion). For a concave optimality criterion, an approximate design is optimal in the class of all normalized approximate designs if and only if all its directional derivatives are non-positive. This statement can be rewritten to the form of the so-called equivalence theorem. See the reference paper at <a href="http://www.iam.fmph.uniba.sk/design/">http://www.iam.fmph.uniba.sk/design/</a> for mathematical details.
</p>


<h3>Value</h3>

<p>The vector of directional derivatives of the chosen criterion at <code>w/sum(w)</code> in the direction of the singular designs e_i, where i ranges from <code>1</code> to <code>n</code>.
</p>


<h3>Note</h3>

<p>The design <code>w</code> should have a non-singular information matrix.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+effbound">effbound</a>, <a href="#topic+varfun">varfun</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The directional derivatives of the D-optimal approximate design
# for a cubic regression on a square grid.

form.cube &lt;- ~x1 + x2 + I(x1^2) + I(x2^2) + I(x1*x2) +
              I(x1^3) + I(x1^2*x2) + I(x1*x2^2) + I(x2^3)
Fx &lt;- Fx_cube(form.cube, n.levels = c(101, 101))
w &lt;- od_REX(Fx)$w.best

# Because w is optimal approximate, no directional derivative is positive:
boxplot(dirder(Fx, w))

# The yellow values indicate the directional derivative at each design point:
od_plot(Fx, w, Fx[, 2:3])

# An alternative view is a "projection" of the above plot:
od_plot(Fx, w, Fx[, 2], dd.pool = c("max", "min"))

## End(Not run)
</code></pre>

<hr>
<h2 id='effbound'>
Lower bound on efficiency
</h2><span id='topic+effbound'></span>

<h3>Description</h3>

<p>Computes a lower bound on the efficiency of a design <code>w</code> in the class of all approximate designs of the same size as <code>w</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>effbound(Fx, w, crit="D", h=NULL, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="effbound_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> matrix of candidate regressors (as rows), where <code>n</code> is the number of candidate design points and <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) is the number of parameters.
</p>
</td></tr>
<tr><td><code id="effbound_+3A_w">w</code></td>
<td>

<p>a non-negative vector of length <code>n</code> representing the design.
</p>
</td></tr>
<tr><td><code id="effbound_+3A_crit">crit</code></td>
<td>

<p>the criterion; possible values are <code>"D"</code>, <code>"A"</code>, <code>"I"</code>, <code>"C"</code> and <code>"c"</code>.
</p>
</td></tr>
<tr><td><code id="effbound_+3A_h">h</code></td>
<td>

<p>a non-zero vector of length <code>m</code> corresponding to the coefficients of the linear parameter combination of interest. If <code>crit</code> is not <code>"C"</code> nor <code>"c"</code> then <code>h</code> is ignored. If <code>crit</code> is <code>"C"</code> or <code>"c"</code> and <code>h=NULL</code> then <code>h</code> is assumed to be <code>c(0,...,0,1)</code>.
</p>
</td></tr>
<tr><td><code id="effbound_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lower bounds are based on the standard methods of convex analysis. See the reference paper at <a href="http://www.iam.fmph.uniba.sk/design/">http://www.iam.fmph.uniba.sk/design/</a> for mathematical details.
</p>


<h3>Value</h3>

<p>A lower bound on the D-, A-, I-, c-, or C-efficiency of <code>w</code> in the class of all approximate designs of the same size as <code>w</code> at the set of candidate regressors given by <code>Fx</code>.
</p>


<h3>Note</h3>

<p>The design <code>w</code> should have a non-singular information matrix. Occasionally, the lower bound is very conservative. The exact value of the efficiency of <code>w</code> is the ratio of the criterion value of <code>w</code> and the criterion value of the optimal design.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varfun">varfun</a></code>, <code><a href="#topic+dirder">dirder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A lower bound on the D-efficiencies of the uniform designs
# for the quadratic regression on a line grid

Fx &lt;- Fx_cube(~x1 + I(x1^2), n.levels = 101)
effbound(Fx, rep(1/101, 101))

# The precise value of the D-efficiency
# requires computing the D-optimal design:

w.opt &lt;- od_REX(Fx)$w.best
optcrit(Fx, rep(1/101, 101)) / optcrit(Fx, w.opt)

## Not run: 
# Let us do this for polynomial regressions of various degrees:

n &lt;- 101; d.max &lt;- 10; x &lt;- seq(-1, 1, length = n)
effs &lt;- matrix(0, ncol = 2, nrow = d.max)
Fx &lt;- matrix(1, ncol = 1, nrow = n)
for(d in 1:d.max) {
  Fx &lt;- cbind(Fx, x^d)
  effs[d, 1] &lt;- effbound(Fx, rep(1/n, n))
  w.opt &lt;- od_REX(Fx)$w.best
  effs[d, 2] &lt;- optcrit(Fx, rep(1/n, n)) / optcrit(Fx, w.opt)
}
print(effs)

# We see that the lower bound becomes more and more conservative
# compared to the real efficiency which actually increases with d.


# Compute a D-optimal design for the main effects model
# on a random subsample of a 6D cube

n &lt;- 1000000; m &lt;- 6
Fx &lt;- cbind(1, matrix(runif(n*m), ncol = m))
w &lt;- od_REX(Fx, eff = 0.99)$w.best
Fx &lt;- od_DEL(Fx, w)$Fx.keep
w &lt;- od_REX(Fx)$w.best

# Now we will compute a lower bound on efficiency of such design
# on the entire (continuous) cube:
Fx &lt;- rbind(Fx, Fx_cube(~x1 + x2 + x3 + x4 + x5 + x6, lower = rep(0, 6)))
w &lt;- c(w, rep(0, 2^6))
effbound(Fx, w)

# The real D-efficiency of w on the entire cube is
optcrit(Fx, w)/od_REX(Fx)$Phi.best

## End(Not run)
</code></pre>

<hr>
<h2 id='Fx_blocks'>
Matrix of candidate regressors for a block size-two model
</h2><span id='topic+Fx_blocks'></span>

<h3>Description</h3>

<p>Creates the matrix of all candidate regressors of a linear regression model corresponding to the problem of the optimal block size-two design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fx_blocks(n.treats, blocks=NULL, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fx_blocks_+3A_n.treats">n.treats</code></td>
<td>

<p>the number of &quot;treatments&quot; in the block experiment.
</p>
</td></tr>
<tr><td><code id="Fx_blocks_+3A_blocks">blocks</code></td>
<td>

<p>the <code>2</code> times <code>n</code> matrix of all permissible blocks (that is, permissible pairings of treatments). If <code>blocks=NULL</code>, <code>blocks</code> is set to <code>combn(n.treats, 2)</code>, which means that all treatment pairings are permissible.
</p>
</td></tr>
<tr><td><code id="Fx_blocks_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates the matrix <code>Fx</code> of artificial regressors, such that the D- and A-optimal designs for the corresponding artificial LRM are are the same as what is called the D- and A-optimal design in the original block model with blocks of size two.
</p>


<h3>Value</h3>

<p>the <code>n</code> times <code>m</code> matrix of all candidate regressors of an auxiliary linear regression model corresponding to the problem of the optimal block size-two design (<code>n</code> is <code>ncol(blocks)</code>, <code>m</code> is <code>n.treats-1</code>).
</p>


<h3>Note</h3>

<p>This optimal design problem is equivalent to various optimum-subgraph problems, depending on the criterion.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>References</h3>

<p>Harman R, Filova, L: Computing efficient exact designs of experiments using integer quadratic programming, Computational Statistics and Data Analysis 71 (2014) 1159-1167.
</p>
<p>Sagnol G, Harman R: Computing Exact D-optimal designs by mixed integer second-order cone programming, The Annals of Statistics 43 (2015), 2198-2224.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fx_cube">Fx_cube</a>, <a href="#topic+Fx_simplex">Fx_simplex</a>, <a href="#topic+Fx_glm">Fx_glm</a>, <a href="#topic+Fx_dose">Fx_dose</a>, <a href="#topic+Fx_survival">Fx_survival</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Compute a D-efficient block size-two design
# with 15 treatments and 10 blocks of size two

Fx &lt;- Fx_blocks(10)
w &lt;- od_KL(Fx, 15, t.max = 5)$w.best
des &lt;- combn(10, 2)[, as.logical(w)]
print(des)


# We can visualize the design as a graph
library(igraph)
grp &lt;- graph_(t(des), from_edgelist(directed = FALSE))
plot(grp, layout=layout_with_graphopt)

## End(Not run)
</code></pre>

<hr>
<h2 id='Fx_CtoA'>
Transformation of candidate regressors for regularized c-optimality
</h2><span id='topic+Fx_CtoA'></span>

<h3>Description</h3>

<p>Pre-transforms the matrix of all candidate regressors to the form suitable for computing regularized c-optimal designs via A-optimum algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fx_CtoA(Fx, h=NULL, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fx_CtoA_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> matrix of candidate regressors (as rows), where <code>n</code> is the number of candidate design points and <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) is the number of parameters.
</p>
</td></tr>
<tr><td><code id="Fx_CtoA_+3A_h">h</code></td>
<td>

<p>a non-zero vector of length <code>m</code> corresponding to the coefficients of the linear parameter combination of interest. If <code>crit</code> is not <code>"C"</code> nor <code>"c"</code> then <code>h</code> is ignored. If <code>crit</code> is <code>"C"</code> or <code>"c"</code> and <code>h=NULL</code> then <code>h</code> is assumed to be <code>c(0,...,0,1)</code>.
</p>
</td></tr>
<tr><td><code id="Fx_CtoA_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The standard c-optimal designs are often singular, which may render them unsuitable for practical use. The regularized c-optimality, which we call C-optimality, is an approach to computing designs that are non-singular, but still efficient with respect to the criterion of c-optimality. See <a href="http://www.iam.fmph.uniba.sk/design/">http://www.iam.fmph.uniba.sk/design/</a> for more details.
</p>


<h3>Value</h3>

<p>The <code>n</code> times <code>m</code> matrix <code>Fx.trans</code> of all candidate regressors with the following property: The A-optimal design for the problem defined by <code>Fx.trans</code> is the same as the regularized c-optimal (i.e., C-optimal) design for the problem defined by <code>Fx</code>.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman and Lenka Filova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fx_ItoA">Fx_ItoA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># We will compute a C-efficient (regularized c-optimal) design
# for estimating the mean response in x=1 for a quadratic regression
# using and algorithm for A-optimality.

Fx &lt;- Fx_cube(~x1 + I(x1^2), n.levels=101)
Fx.trans &lt;- Fx_CtoA(Fx, h=c(1, 1, 1))
w &lt;- od_REX(Fx.trans, crit="A")$w.best
od_print(Fx, w, h=c(1, 1, 1))

# Compare the design to the (non-regularized) c-optimal design
w.crisp &lt;- od_REX(Fx, crit="c", h=c(1, 1, 1))$w.best
od_print(Fx, w.crisp, h=c(1, 1, 1))

# The c-efficiency of the C-optimal design is about 0.68
# The D-efficiency of the c-optimal design is 0
# The D-efficiency of the C-optimal design is a very decent
optcrit(Fx, w) / od_REX(Fx)$Phi.best
</code></pre>

<hr>
<h2 id='Fx_cube'>
Matrix of candidate regressors for a model on a cuboid grid
</h2><span id='topic+Fx_cube'></span>

<h3>Description</h3>

<p>Creates the matrix of all candidate regressors for a factor regression model on a cuboid grid (up to 9 factors).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fx_cube(formula, lower=NULL, upper=NULL, n.levels=NULL, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fx_cube_+3A_formula">formula</code></td>
<td>

<p>the formula of the model. The rules for creating the formula are standard for R but: 1) the formula must not contain the dependent variable (it is one-sided); 2) the <code>d</code> factors (variables) must be labeled <code>x1,x2,x3,</code>...
</p>
</td></tr>
<tr><td><code id="Fx_cube_+3A_lower">lower</code></td>
<td>

<p>the <code>d</code>-dimensional vector of the smallest values of factors. If <code>lower=NULL</code>, the program sets <code>lower &lt;- rep(-1, d)</code>.
</p>
</td></tr>
<tr><td><code id="Fx_cube_+3A_upper">upper</code></td>
<td>

<p>the <code>d</code>-dimensional vector of the largest values of factors. If <code>upper=NULL</code>, the program sets <code>upper &lt;- rep(1, d)</code>.
</p>
</td></tr>
<tr><td><code id="Fx_cube_+3A_n.levels">n.levels</code></td>
<td>

<p>the <code>d</code>-dimensional vector of the numbers of levels of each factor. If <code>n.levels=NULL</code>, the program sets <code>n.levels &lt;- rep(2, d)</code>.
</p>
</td></tr>
<tr><td><code id="Fx_cube_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>n</code> times <code>m</code> matrix of all candidate regressors for a factor regression model on a cuboid grid. The rows of <code>Fx</code> are the regressors <code>f(x)</code> for all candidate design points <code>x</code>.
</p>


<h3>Note</h3>

<p>Note that <code>Fx</code> is <em>not</em> the design matrix (which is also sometimes called the regression matrix, or the model matrix). The design matrix depends on <code>Fx</code> as well as on the exact experimental design <code>w</code>. For this package, an exact experimental design is formalized as the vector of non-negative integer values corresponding to the replication of trials (observations) in individual design points. Thus, if <code>Fx</code> is the matrix of all candidate regressors and <code>w</code> is the exact design then <code>Fx[rep(1:nrow(Fx), w),]</code> is the actual design matrix for the experiment.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fx_simplex">Fx_simplex</a>, <a href="#topic+Fx_blocks">Fx_blocks</a>, <a href="#topic+Fx_glm">Fx_glm</a>, <a href="#topic+Fx_survival">Fx_survival</a>, <a href="#topic+Fx_dose">Fx_dose</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The Fx for the cubic model on a discretized interval
Fx &lt;- Fx_cube(~x1 + I(x1^2) + I(x1^3), lower=0, upper=2, n.levels=101)

# The D-optimal design of size 20
w &lt;- od_KL(Fx, 20, t.max=5)$w.best
od_plot(Fx, w, Fx[, 2])


# The Fx for the full quadratic response surface model on a non-convex region
Fx &lt;- Fx_cube(~x1 + x2 + I(x1^2) + I(x2^2) + I(x1*x2), n.levels=c(51, 51))
keep &lt;- rep(TRUE, nrow(Fx))
for(i in 1:nrow(Fx)) if(prod(abs(Fx[i, 2:3])) &gt; 0.2) keep[i] &lt;- FALSE
Fx &lt;- Fx[keep, ]

# The D-optimal design of size 29 without replications
w &lt;- od_KL(Fx, 29, bin=TRUE, t.max=5)$w.best
od_plot(Fx, w, Fx[, 2:3])


# The Fx for the chemical weighing with 3 items and a bias term
Fx &lt;- Fx_cube(~x1 + x2 + x3, n.levels=c(3, 3, 3))

# The D-optimal design of size 12
w &lt;- od_KL(Fx, 12, t.max=2)$w.best
od_plot(Fx, w, Fx[, 2:4])

## End(Not run)
</code></pre>

<hr>
<h2 id='Fx_dose'>
Matrix of candidate regressors for a dose-response model
</h2><span id='topic+Fx_dose'></span>

<h3>Description</h3>

<p>Creates the matrix of all candidate regressors for a linearization of a dose response model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fx_dose(dose.levels, theta0, dose.model="emax", echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fx_dose_+3A_dose.levels">dose.levels</code></td>
<td>

<p>the <code>n</code>-dimensional vector of admissible doses.
</p>
</td></tr>
<tr><td><code id="Fx_dose_+3A_theta0">theta0</code></td>
<td>

<p>the 3-dimensional vector of values of the unknown parameter in which to linearize the model.
</p>
</td></tr>
<tr><td><code id="Fx_dose_+3A_dose.model">dose.model</code></td>
<td>

<p>the type of the dose-response model, possible values are <code>"emax"</code>, <code>"loglin"</code>, and <code>"exp"</code>.
</p>
</td></tr>
<tr><td><code id="Fx_dose_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For mathematical details, see the referenced paper.
</p>


<h3>Value</h3>

<p>The <code>n</code> times <code>3</code> matrix of all candidate regressors of a dose-response model linearized in <code>theta0</code>.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>References</h3>

<p>Dette H, Kiss C, Bevanda M, Bretz F (2010). Optimal designs for the EMAX, log-linear and exponential models. Biometrika, 97(2), 513-518.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fx_cube">Fx_cube</a>, <a href="#topic+Fx_simplex">Fx_simplex</a>, <a href="#topic+Fx_blocks">Fx_blocks</a>, <a href="#topic+Fx_glm">Fx_glm</a>, <a href="#topic+Fx_survival">Fx_survival</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The loglinear model for the doses 1:150
# Localized at the values of theta0=c(0, 0.0797, 1)
Fx &lt;- Fx_dose(1:150, c(0, 0.0797, 1), dose.model="loglin")

# The locally D-optimal approximate design
w_a &lt;- od_REX(Fx)$w.best
od_plot(Fx, w_a, 1:150)

# The locally D-optimal exact design of size 10
w_e &lt;- od_KL(Fx, 10, t.max=3)$w.best
od_plot(Fx, w_e, 1:150)
</code></pre>

<hr>
<h2 id='Fx_glm'>
Matrix of candidate regressors for a generalized linear model
</h2><span id='topic+Fx_glm'></span>

<h3>Description</h3>

<p>Creates the matrix of all candidate regressors for a linearization of a generalized linear model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fx_glm(formula, theta0, glm.model="bin-logit", lower=NULL, upper=NULL,
       n.levels=NULL, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fx_glm_+3A_formula">formula</code></td>
<td>

<p>the formula of the linear part of the model. The rules for creating the formula are standard for R but: 1) the formula must not contain the dependent variable (it is one-sided); 2) the <code>d</code> factors (variables) must be labeled <code>x1,x2,x3,</code>...
</p>
</td></tr>
<tr><td><code id="Fx_glm_+3A_theta0">theta0</code></td>
<td>

<p>the <code>d</code>-dimensional vector of values of the unknown parameter in which to linearize the model
</p>
</td></tr>
<tr><td><code id="Fx_glm_+3A_glm.model">glm.model</code></td>
<td>

<p>the type of the generalized linear model. Available models are <code>"bin-logit"</code>, <code>"bin-probit"</code>,  <code>"bin-cloglog"</code>, and <code>Poisson-log</code>.
</p>
</td></tr>
<tr><td><code id="Fx_glm_+3A_lower">lower</code></td>
<td>

<p>the <code>d</code>-dimensional vector of the smallest values of factors. If <code>lower=NULL</code>, the program sets <code>lower &lt;- rep(-1, d)</code>.
</p>
</td></tr>
<tr><td><code id="Fx_glm_+3A_upper">upper</code></td>
<td>

<p>the <code>d</code>-dimensional vector of the largest values of factors. If <code>upper=NULL</code>, the program sets <code>upper &lt;- rep(1, d)</code>.
</p>
</td></tr>
<tr><td><code id="Fx_glm_+3A_n.levels">n.levels</code></td>
<td>

<p>the <code>d</code>-dimensional vector of the numbers of levels of each factor. If <code>n.levels=NULL</code>, the program sets <code>n.levels &lt;- rep(2, d)</code>.
</p>
</td></tr>
<tr><td><code id="Fx_glm_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For mathematical details, see the referenced paper.
</p>


<h3>Value</h3>

<p>The <code>n</code> times <code>m</code> matrix of all candidate regressors of a generalized linear regression model linearized in <code>theta0</code>.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>References</h3>

<p>Atkinson AC, Woods DC (2015). Designs for generalized linear models. Handbook of Design and Analysis of Experiments, 471-514.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fx_cube">Fx_cube</a>, <a href="#topic+Fx_simplex">Fx_simplex</a>, <a href="#topic+Fx_blocks">Fx_blocks</a>, <a href="#topic+Fx_survival">Fx_survival</a>, <a href="#topic+Fx_dose">Fx_dose</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The logistic model with second-order predictors x1, x2 in [-1,1]
# discretized into 21 points and theta0=c(1, 2, 2, -1, -1.5, 1.5)

form.quad &lt;- ~ x1 + x2 + I(x1*x2) + I(x1^2) + I(x2^2)
Fx &lt;- Fx_glm(form.quad, c(1, 2, 2, -1, -1.5, 1.5),
             glm.model="bin-logit", n.levels=c(21,21))

# The locally D-optimal approximate design
w &lt;- od_REX(Fx)$w.best
Fx.lin &lt;- Fx_cube(form.quad, n.levels=c(21,21)) # Just for the plot
od_plot(Fx, w, Fx.lin[, 2:3], dd.size=2)

## Not run: 
#The GLM with Poisson link and 2 linear predictors x1,x2 in [-1,1]
# discretized into 21 points and theta0=c(0,2,2)
Fx &lt;- Fx_glm(~x1+x2, c(0, 2, 2), glm.model="Poisson-log", n.levels=c(21, 21))

# The locally D-optimal exact design of size 50 without replications
w &lt;- od_KL(Fx, 50, bin=TRUE, t.max=5)$w.best
Fx.lin &lt;- Fx_cube(~x1+x2, n.levels=c(21, 21))
od_plot(Fx, w, Fx.lin[, 2:3], w.lim=Inf)

## End(Not run)
</code></pre>

<hr>
<h2 id='Fx_ItoA'>
Transformation of candidate regressors for I-optimality
</h2><span id='topic+Fx_ItoA'></span>

<h3>Description</h3>

<p>Pre-transforms the matrix of all candidate regressors to the form suitable for computing I-optimal designs via A-optimum algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fx_ItoA(Fx, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fx_ItoA_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> matrix of candidate regressors (as rows), where <code>n</code> is the number of candidate design points and <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) is the number of parameters.
</p>
</td></tr>
<tr><td><code id="Fx_ItoA_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is simple to see that the problem of I-optimality is equivalent to the problem of A-optimality for a transformed matrix of candidate regressors. This function performs the transformation. See <a href="http://www.iam.fmph.uniba.sk/design/">http://www.iam.fmph.uniba.sk/design/</a> for more details.
</p>


<h3>Value</h3>

<p>The <code>n</code> times <code>m</code> matrix <code>Fx.trans</code> of all candidate regressors with the following property: The A-optimal design for the problem defined by <code>Fx.trans</code> is the same as the I-optimal design for the problem defined by <code>Fx</code>.
</p>


<h3>Note</h3>

<p>It is also simple to transform the <em>weighted</em> I-optimality to A-optimality; just multiply the rows of <code>Fx</code> by the squares roots of weights of individual design points and transform the resulting matrix by <code>Fx_ItoA</code>.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fx_CtoA">Fx_CtoA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Compute an I-efficient exact size 20 design without replications
# for the Scheffe mixture model with 4 components
# using the AQUA heuristic for A-optimality.

Fx &lt;- Fx_simplex(~x1 + x2 + x3 + x4 + I(x1*x2) + I(x1*x3) + I(x1*x4) +
                  I(x2*x3) + I(x2*x4) + I(x3*x4) - 1, 11)

w &lt;- od_AQUA(Fx_ItoA(Fx), b3=24, bin=TRUE, crit="I", conic=FALSE)$w.best
od_plot(Fx, w, Fx[, 2:4])

## End(Not run)
</code></pre>

<hr>
<h2 id='Fx_simplex'>
Matrix of candidate regressors for a regression model on a simplex grid
</h2><span id='topic+Fx_simplex'></span>

<h3>Description</h3>

<p>Creates the matrix of all candidate regressors for a mixture regression model on a regular simplex grid (up to 9 factors).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fx_simplex(formula, n.levels.mix=NULL, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fx_simplex_+3A_formula">formula</code></td>
<td>

<p>the formula of the model. The rules for creating the formula are standard for R but: 1) the formula must not contain the dependent variable (it is one-sided); 2) the <code>d</code> factors (variables) must be labeled <code>x1,x2,x3,</code>...
</p>
</td></tr>
<tr><td><code id="Fx_simplex_+3A_n.levels.mix">n.levels.mix</code></td>
<td>

<p>the number of levels of each factor (each factor has the same number of levels). If <code>n.levels=NULL</code>, the program sets <code>n.levels &lt;- 2*d + 1</code>.
</p>
</td></tr>
<tr><td><code id="Fx_simplex_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>n</code> times <code>m</code> matrix of all candidate regressors of a mixture regression model on a regular simplex grid.
</p>


<h3>Note</h3>

<p>Note that <code>Fx</code> is <em>not</em> the design matrix (which is also sometimes called the regression matrix, or the model matrix). The design matrix depends on <code>Fx</code> as well as on the exact experimental design <code>w</code>. For this package, an exact experimental design is formalized as the vector of non-negative integer values corresponding to the replication of trials (observations) in individual design points. Thus, if <code>Fx</code> is the matrix of all candidate regressors and <code>w</code> is the exact design then <code>Fx[rep(1:nrow(Fx), w),]</code> is the actual design matrix for the experiment.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fx_cube">Fx_cube</a>, <a href="#topic+Fx_glm">Fx_glm</a>, <a href="#topic+Fx_dose">Fx_dose</a>, <a href="#topic+Fx_survival">Fx_survival</a>, <a href="#topic+Fx_blocks">Fx_blocks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# The Fx of the Scheffe quadratic mixture model
# with 3 mixture components, each with 21 levels.
Fx &lt;- Fx_simplex(~x1 + x2 + x3 + I(x1*x2) + I(x1*x3) + I(x2*x3) - 1, 21)

# The approximate I-optimal design of size 20
# bound by 1 at each design point
w &lt;- od_MISOCP(Fx, b3=20, bin=TRUE, crit="I", type="approximate")$w.best
od_plot(Fx, w, Fx[, 2:3])

# As above, with constraints on the proportions
r &lt;- c(); for (i in 1:nrow(Fx)) if (max(Fx[i, 2:4]) &gt; 0.7) r &lt;- c(r, i)
w &lt;- od_MISOCP(Fx[-r, ], b3=20, bin=TRUE, crit="I", type="approximate")$w.best
od_plot(Fx[-r, ], w, Fx[-r, 2:3])

# Note that one must be careful when choosing a model for a mixture experiment:
# Let us compute the matrix of regressors of the simple linear mixture model
# with 4 mixture components, each with levels {0, 0.5, 1}.

Fx &lt;- Fx_simplex(~x1 + x2 + x3 + x4, 3)

# The model has only 5 parameters and as many as 10 design points,
# but there is no design that guarantees estimability of the parameters.
# This can be shown by evaluating:
det(infmat(Fx, rep(1, 10)))

## End(Not run)
</code></pre>

<hr>
<h2 id='Fx_survival'>
Matrix of candidate regressors for a survival model
</h2><span id='topic+Fx_survival'></span>

<h3>Description</h3>

<p>Creates the matrix of all candidate regressors for a linearization of a proportional hazards survival model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Fx_survival(formula, theta0, censor.time, survival.model="phI", lower=NULL,
            upper=NULL, n.levels=NULL, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Fx_survival_+3A_formula">formula</code></td>
<td>

<p>the formula of the linear part of the model. The rules for creating the formula are standard for R but: 1) the formula must not contain the dependent variable (it is one-sided); 2) the <code>d</code> factors (variables) must be labeled <code>x1,x2,x3,</code>...
</p>
</td></tr>
<tr><td><code id="Fx_survival_+3A_theta0">theta0</code></td>
<td>

<p>the <code>d</code>-dimensional vector of values of the unknown parameter in which to linearize the model.
</p>
</td></tr>
<tr><td><code id="Fx_survival_+3A_censor.time">censor.time</code></td>
<td>

<p>the censoring time, a positive constant.
</p>
</td></tr>
<tr><td><code id="Fx_survival_+3A_survival.model">survival.model</code></td>
<td>

<p>the type of the survival model, can be either proportional hazards with Type I censoring (<code>"phI"</code>) or with random censoring (<code>"phrand"</code>). Both models assume a constant baseline hazard.
</p>
</td></tr>
<tr><td><code id="Fx_survival_+3A_lower">lower</code></td>
<td>

<p>the <code>d</code>-dimensional vector of the smallest values of factors. If <code>lower=NULL</code>, the program sets <code>lower &lt;- rep(-1, d)</code>.
</p>
</td></tr>
<tr><td><code id="Fx_survival_+3A_upper">upper</code></td>
<td>

<p>the <code>d</code>-dimensional vector of the largest values of factors. If <code>upper=NULL</code>, the program sets <code>upper &lt;- rep(1, d)</code>.
</p>
</td></tr>
<tr><td><code id="Fx_survival_+3A_n.levels">n.levels</code></td>
<td>

<p>the <code>d</code>-dimensional vector of the numbers of levels of each factor. If <code>n.levels=NULL</code>, the program sets <code>n.levels &lt;- rep(2, d)</code>.
</p>
</td></tr>
<tr><td><code id="Fx_survival_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For mathematical details, see the referenced paper.
</p>


<h3>Value</h3>

<p>The <code>n</code> times <code>m</code> matrix of all candidate regressors of a proportional hazards model linearized in <code>theta0</code>.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>References</h3>

<p>Konstantinou M, Biedermann S, Kimber A (2014). Optimal designs for two-parameter nonlinear models with application to survival models. Statistica Sinica, 24(1), 415-428.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Fx_cube">Fx_cube</a>, <a href="#topic+Fx_simplex">Fx_simplex</a>, <a href="#topic+Fx_blocks">Fx_blocks</a>, <a href="#topic+Fx_glm">Fx_glm</a>, <a href="#topic+Fx_dose">Fx_dose</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The proportional hazards model with random censoring
# for three binary explanatory variables x1,x2,x3 without intercept
# censoring time 30 and parameter values theta0=c(1,1,1)
Fx &lt;- Fx_survival(~x1 + x2 + x3 - 1, c(1, 1, 1), 30, "phrand",
      lower = c(0, 0, 0), upper = c(1, 1, 1), n.levels = c(2, 2, 2))

# The locally D-optimal approximate design
w &lt;- od_REX(Fx, crit="D")$w.best
od_print(Fx, w, Fx)

## Not run: 
# The proportional hazards model with random censoring
# for explanatory variables x1,x2,x3 in the range [0,1] discretized into 11 points
# censoring time 30 and parameter values theta0=c(1,1,1)
Fx &lt;- Fx_survival(~x1 + x2 + x3 - 1, c(1, 1, 1), 30, "phrand",
      lower = c(0, 0, 0), upper = c(1, 1, 1), n.levels = c(11, 11, 11))

# The locally A-optimal exact design of size 50 without replications
w &lt;- od_KL(Fx, 50, crit="A", bin=TRUE, t.max=5)$w.best
od_plot(Fx, w, Fx)

## End(Not run)
</code></pre>

<hr>
<h2 id='infmat'>
Information matrix of a design
</h2><span id='topic+infmat'></span>

<h3>Description</h3>

<p>Computes the information matrix of a design <code>w</code> in the model determined by the matrix <code>Fx</code> of candidate regressors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>infmat(Fx, w, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="infmat_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> matrix of candidate regressors (as rows), where <code>n</code> is the number of candidate design points and <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) is the number of parameters.
</p>
</td></tr>
<tr><td><code id="infmat_+3A_w">w</code></td>
<td>

<p>a non-negative vector of length <code>n</code> representing the design.
</p>
</td></tr>
<tr><td><code id="infmat_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The information matrix of the design <code>w</code> in the model with all candidate regresors given by the rows of <code>Fx</code>.
</p>


<h3>Note</h3>

<p>The information matrix is standardized, i.e., it assumes that the variance of the errors is 1.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+optcrit">optcrit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Compute its information matrix for the design that is
# uniform on all the points with at most two levels equal to 1
# in the main effects model with 2 factors.

Fx &lt;- Fx_cube(~x1 + x2 + x3 + x4 + x5, lower = rep(0, 5))
w &lt;- rep(0, 2^5)
for (i in 1:(2^5)) if (sum(Fx[i, 2:6]) &lt;= 2) w[i] &lt;- 1
print(M &lt;- infmat(Fx, w))

## Not run: 
# Visualize the correlation matrix of the parameter estimators

V &lt;- solve(M); Y &lt;- diag(1/sqrt(diag(V)))
library(corrplot); corrplot(Y %*% V %*% Y)

## End(Not run)
</code></pre>

<hr>
<h2 id='mvee_REX'>
Minimum-volume enclosing ellipsoid
</h2><span id='topic+mvee_REX'></span>

<h3>Description</h3>

<p>Computes the shape matrix <code>H</code> and the center <code>z</code> of the minimum-volume ellipsoid enclosing a finite set of data-points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvee_REX(Data, alg.AA="REX", eff=0.999999, it.max=Inf, t.max=60,
         picture=FALSE, echo=TRUE, track=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvee_REX_+3A_data">Data</code></td>
<td>

<p>the <code>n</code> times <code>d</code> (where <code>d&lt;n</code>) matrix containing the <code>d</code>-dimensional data-vectors as rows.
</p>
</td></tr>
<tr><td><code id="mvee_REX_+3A_alg.aa">alg.AA</code></td>
<td>

<p>the underlying computational method for approximate D-optimal design; possible values are <code>"REX"</code>, <code>"MUL"</code> and <code>"VDM"</code>.
</p>
</td></tr>
<tr><td><code id="mvee_REX_+3A_eff">eff</code></td>
<td>

<p>the minimum required efficiency.
</p>
</td></tr>
<tr><td><code id="mvee_REX_+3A_it.max">it.max</code></td>
<td>

<p>a limit on the number of iterations of the underlying D-optimum approximate design algorithm.
</p>
</td></tr>
<tr><td><code id="mvee_REX_+3A_t.max">t.max</code></td>
<td>

<p>a limit on the time of computation.
</p>
</td></tr>
<tr><td><code id="mvee_REX_+3A_picture">picture</code></td>
<td>

<p>Should a picture be plotted? (For the picture, the data need to be either two- or three-dimensional.)
</p>
</td></tr>
<tr><td><code id="mvee_REX_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
<tr><td><code id="mvee_REX_+3A_track">track</code></td>
<td>

<p>Display the progress of the computation?
</p>
</td></tr></table>


<h3>Details</h3>

<p>The problem of the minimum-volume data-enclosing ellipsoid (MVEE) is computationally equivalent to the problem of D-optimal approximate design for an artificial problem based on the data. This procedure performs the computation and the proper conversion of the D-optimal approximate design to the MVEE parameters (the center and the shape matrix).
</p>


<h3>Value</h3>

<p>Output is a list with components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call of the function</p>
</td></tr>
<tr><td><code>H</code></td>
<td>
<p>the shape matrix of the MVEE</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>the center of the MVEE</p>
</td></tr>
<tr><td><code>bpts</code></td>
<td>
<p>a set containing the boundary points of the MVEE</p>
</td></tr>
<tr><td><code>vol</code></td>
<td>
<p>the volume of the MVEE</p>
</td></tr>
<tr><td><code>eff.best</code></td>
<td>
<p>the actual precision of the result (1 is the perfect precision)</p>
</td></tr>
<tr><td><code>t.iter</code></td>
<td>
<p>the number of iterations of the underlying D-optimum design algorithm</p>
</td></tr>
<tr><td><code>t.act</code></td>
<td>
<p>the actual time of the computation</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Note: The affine hull of the rows of <code>X</code> should be the full space of dimension <code>d</code>. For the choice of the algorithm, see the comments in <code><a href="#topic+od_REX">od_REX</a></code>.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>References</h3>

<p>Harman R, Filova L, Richtarik P (2019). A randomized exchange algorithm for computing optimal approximate designs of experiments. Journal of the American Statistical Association, 1-30.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+od_REX">od_REX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate random 1000 points in a 3-dimensional space
# and compute the MVEE

Data &lt;- matrix(rnorm(3000), ncol = 3)
mvee_REX(Data, picture = FALSE)
</code></pre>

<hr>
<h2 id='od_AQUA'>Efficient exact design using a quadratic approximation</h2><span id='topic+od_AQUA'></span>

<h3>Description</h3>

<p>Computes an efficient exact design under general linear constraints via a quadratic approximation of the optimality criterion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_AQUA(Fx, b1=NULL, A1=NULL, b2=NULL, A2=NULL, b3=NULL, A3=NULL, w0=NULL,
      bin=FALSE, crit="D", h=NULL, M.anchor=NULL, ver.qa="+", conic=TRUE,
      t.max=120, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_AQUA_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) matrix containing all candidate regressors (as rows), i.e., <code>n</code> is the number of design points, and <code>m</code> (where <code>m&gt;=2</code>) is the number of parameters
</p>
</td></tr>
<tr><td><code id="od_AQUA_+3A_b1">b1</code>, <code id="od_AQUA_+3A_a1">A1</code>, <code id="od_AQUA_+3A_b2">b2</code>, <code id="od_AQUA_+3A_a2">A2</code>, <code id="od_AQUA_+3A_b3">b3</code>, <code id="od_AQUA_+3A_a3">A3</code></td>
<td>

<p>the real vectors and matrices that define the constraints on permissible designs <code>w</code> as follows: <code>A1 %*% w &lt;= b1</code>, <code>A2 %*% w &gt;= b2</code>, <code>A3 %*% w == b3</code>. Each of the arguments can be <code>NULL</code>, but at least one of <code>b1</code>, <code>b2</code>, <code>b3</code> must be non-<code>NULL</code>. If some <code>bi</code> is non-<code>NULL</code> and <code>Ai</code> is <code>NULL</code>, then <code>Ai</code> is set to be <code>matrix(1, nrow =1, ncol = n)</code>.
</p>
</td></tr>
<tr><td><code id="od_AQUA_+3A_w0">w0</code></td>
<td>

<p>a non-negative vector of length <code>n</code> representing the design to be augmented (i.e., the function adds the constraint <code>w &gt;= w0</code> for permissible designs <code>w</code>). This argument can also be <code>NULL</code>; in that case, <code>w0</code> is set to the vector of zeros.
</p>
</td></tr>
<tr><td><code id="od_AQUA_+3A_bin">bin</code></td>
<td>

<p>Should each design point be used at most once?
</p>
</td></tr>
<tr><td><code id="od_AQUA_+3A_crit">crit</code></td>
<td>

<p>The optimality criterion. Possible values are <code>"D"</code>, <code>"A"</code>, <code>"I"</code>, <code>"C"</code>.
</p>
</td></tr>
<tr><td><code id="od_AQUA_+3A_h">h</code></td>
<td>

<p>a non-zero vector of length <code>m</code> corresponding to the coefficients of the linear parameter combination of interest. If <code>crit</code> is not <code>"C"</code> then <code>h</code> is ignored. If <code>crit</code> is <code>"C"</code> and <code>h=NULL</code> then <code>h</code> is assumed to be <code>c(0,...,0,1)</code>.
</p>
</td></tr>
<tr><td><code id="od_AQUA_+3A_m.anchor">M.anchor</code></td>
<td>

<p>the <code>m</code> times <code>m</code> information matrix of the optimal or nearly-optimal approximate design for the design problem (for the non-normalized version of the problem and including the design constraints). The argument <code>M.anchor</code> can also be <code>NULL</code>. In that case the procedure computes <code>M.anchor</code> using an appropriate approximate design procedure from the package.
</p>
</td></tr>
<tr><td><code id="od_AQUA_+3A_ver.qa">ver.qa</code></td>
<td>

<p>version of the criterion; possible values are <code>"+"</code> and <cite>&quot;-&quot;</cite>.
</p>
</td></tr>
<tr><td><code id="od_AQUA_+3A_conic">conic</code></td>
<td>

<p>Should the conic reformulation be used?
</p>
</td></tr>
<tr><td><code id="od_AQUA_+3A_t.max">t.max</code></td>
<td>

<p>the time limit for the computation.
</p>
</td></tr>
<tr><td><code id="od_AQUA_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At least one of <code>b1</code>, <code>b2</code>, <code>b3</code> must be non-<code>NULL</code>.
If <code>bi</code> is non-<code>NULL</code> and <code>Ai</code> is <code>NULL</code> for some <code>i</code> then <code>Ai</code> is set to be the vector of ones. If <code>bi</code> is <code>NULL</code> for some <code>i</code> then <code>Ai</code> is ignored.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The call of the function.</p>
</td></tr>
<tr><td><code>w.best</code></td>
<td>
<p>The permissible design found, or <code>NULL</code>. The value <code>NULL</code> indicates a failed computation.</p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>The indices of the support of <code>w.best</code>.</p>
</td></tr>
<tr><td><code>w.supp</code></td>
<td>
<p>The weights of <code>w.best</code> on the support.</p>
</td></tr>
<tr><td><code>M.best</code></td>
<td>
<p>The information matrix of <code>w.best</code> or <code>NULL</code> if <code>w.best</code> is <code>NULL</code>.</p>
</td></tr>
<tr><td><code>Phi.best</code></td>
<td>
<p>The value of the criterion of optimality of the design <code>w.best</code>. If <code>w.best</code> has a singular information matrix or if the computation fails, the value of <code>Phi.best</code> is <code>0</code>.</p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>The status variable of the gurobi optimization procedure; see the gurobi solver documentation for details.</p>
</td></tr>
<tr><td><code>t.act</code></td>
<td>
<p>The actual time of the computation.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function does not support the classical c-optimality, but it includes its regularized version referred to as C-optimality. The computation is generally stable, but it may fail for instance if the model is numerically singular, there is no exact design satisfying the constraints, no permissible exact design was found within the time limit, the set of feasible exact designs is unbounded and so on; see the <code>status</code> variable for more details. Note, however, that <code>status = "OPTIMAL"</code> indicates that the auxiliary integer programming problem was completely solved, which for this procedure does not guarantee that the result is a globally optimal design.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>References</h3>

<p>Harman R., Filova L. (2014): Computing efficient exact designs of experiments using integer quadratic programming, Computational Statistics &amp; Data Analysis, Volume 71, pp. 1159-1167
</p>
<p>Filova L., Harman R. (2018). Ascent with Quadratic Assistance for the Construction of Exact Experimental Designs. arXiv preprint arXiv:1801.09124. (Submitted to Computational Statistics)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+od_KL">od_KL</a>, <a href="#topic+od_RC">od_RC</a>, <a href="#topic+od_MISOCP">od_MISOCP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Compute an I-efficient non-replicated exact design of size 51
# for the "special cubic" model with 3 mixture components

# Each factor has 11 levels:
form.sc &lt;- ~x1 + x2 + x3 + I(x1*x2) + I(x1*x3) + I(x2*x3) + I(x1*x2*x3) - 1
Fx &lt;- Fx_simplex(form.sc, 11)
w &lt;- od_AQUA(Fx, b3 = 51, crit = "I", bin = TRUE)$w.best
od_plot(Fx, w, Fx[, 1:3])

# Each factor has 101 levels (memory intensive without the conic trick)
Fx &lt;- Fx_simplex(form.sc, 101)
w &lt;- od_AQUA(Fx, b3 = 51, crit = "I", bin = TRUE, t.max = 10)$w.best
od_plot(Fx, w, Fx[, 1:3])

# Find an A-efficient exact design for the spring balance model
# with 5 items and 10 weighings
Fx &lt;- Fx_cube(~x1 + x2 + x3 + x4 + x5 - 1, lower = rep(0, 5))
w &lt;- od_AQUA(Fx, b3 = 10, crit = "A", t.max = 10)$w.best
od_print(Fx, w)


## End(Not run)
</code></pre>

<hr>
<h2 id='od_DEL'>
Removal of redundant design points
</h2><span id='topic+od_DEL'></span>

<h3>Description</h3>

<p>Removes the design points (or, equivalently, candidate regressors) that cannot support an optimal approximate design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_DEL(Fx, w, crit = "D", h=NULL, echo = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_DEL_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) matrix containing all candidate regressors (as rows), i.e., <code>n</code> is the number of candidate design points, and <code>m</code> is the number of parameters
</p>
</td></tr>
<tr><td><code id="od_DEL_+3A_w">w</code></td>
<td>

<p>a non-negative vector of length <code>n</code> representing the design
</p>
</td></tr>
<tr><td><code id="od_DEL_+3A_crit">crit</code></td>
<td>

<p>the optimality criterion. Possible values are <code>"D"</code>, <code>"A"</code>, <code>"I"</code>, <code>"C"</code>.
</p>
</td></tr>
<tr><td><code id="od_DEL_+3A_h">h</code></td>
<td>

<p>a non-zero vector of length <code>m</code> corresponding to the coefficients of the linear parameter combination of interest. If <code>crit</code> is not <code>"C"</code> nor <code>"c"</code> then <code>h</code> is ignored. If <code>crit</code> is <code>"C"</code> or <code>"c"</code> and <code>h=NULL</code> then <code>h</code> is assumed to be <code>c(0,...,0,1)</code>.
</p>
</td></tr>
<tr><td><code id="od_DEL_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output is the list with components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call of the function</p>
</td></tr>
<tr><td><code>keep</code></td>
<td>
<p>the indices of <code>w</code> that have not been removed</p>
</td></tr>
<tr><td><code>w.keep</code></td>
<td>
<p>the approximate design on the reduced space</p>
</td></tr>
<tr><td><code>Fx.keep</code></td>
<td>
<p>the model matrix of the regressors on the reduced space</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The design vector <code>w</code> should have a non-singular information matrix. The procedure is valid only for the standard (size) constraint.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>References</h3>

<p>Harman R, Pronzato L (2007): Improvements on removing non-optimal support points in D-optimum design algorithms, Statistics &amp; Probability Letters 77, 90-94
</p>
<p>Pronzato L (2013): A delimitation of the support of optimal designs for Kiefers Phi_p-class of criteria. Statistics &amp; Probability Letters 83, 2721-2728</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Generate a model matrix for the quadratic model
# on a semi-circle with a huge number of design points
form.q &lt;- ~x1 + x2 + I(x1^2) + I(x2^2) + I(x1*x2)
Fx &lt;- Fx_cube(form.q, lower = c(-1, 0), n.levels = c(1001, 501))
remove &lt;- (1:nrow(Fx))[Fx[ ,2]^2 + Fx[ ,3]^2 &gt; 1]
Fx &lt;- Fx[-remove, ]

# Compute an approximate design w with an efficiency of cca 0.999
w &lt;- od_REX(Fx, eff = 0.999)$w.best

# Remove the redundant design points based on w
Fx &lt;- od_DEL(Fx, w)$Fx.keep

# Now an almost perfect design can be computed very rapidly:
w &lt;- od_REX(Fx, eff = 0.9999999999)$w.best

# Plotting of the relevant directional derivative is also faster:
od_plot(Fx, w, Fx[ , 2:3], dd.size = 0.1)

## End(Not run)
</code></pre>

<hr>
<h2 id='od_KL'>
The KL exchange algorithm for efficient exact designs
</h2><span id='topic+od_KL'></span>

<h3>Description</h3>

<p>Computes an optimal or near-optimal exact design of experiments under the standard (size) constraint on the size of the experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_KL(Fx, N, bin=FALSE, Phi.app=NULL, crit="D", h=NULL, w1=NULL, K=NULL,
      L=NULL, rest.max=Inf, t.max=120, echo=TRUE, track=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_KL_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) matrix containing all candidate regressors (as rows), i.e., <code>n</code> is the number of candidate design points, and <code>m</code> (where <code>m&gt;=2</code>) is the number of parameters.
</p>
</td></tr>
<tr><td><code id="od_KL_+3A_n">N</code></td>
<td>

<p>the size of the experiment (i.e., the required number of trials).
</p>
</td></tr>
<tr><td><code id="od_KL_+3A_bin">bin</code></td>
<td>

<p>Should each design point be used at most once?
</p>
</td></tr>
<tr><td><code id="od_KL_+3A_phi.app">Phi.app</code></td>
<td>

<p>the optimal value of the corresponding approximate (relaxed) problem. If <code>Phi.app = NULL</code>, the value is pre-computed using <code><a href="#topic+od_REX">od_REX</a></code>.
</p>
</td></tr>
<tr><td><code id="od_KL_+3A_crit">crit</code></td>
<td>

<p>the optimality criterion. Possible values are <code>"D"</code>, <code>"A"</code>, <code>"I"</code>, <code>"C"</code>.
</p>
</td></tr>
<tr><td><code id="od_KL_+3A_h">h</code></td>
<td>

<p>a non-zero vector of length <code>m</code> corresponding to the coefficients of the linear parameter combination of interest. If <code>crit</code> is not <code>"C"</code> nor <code>"c"</code> then <code>h</code> is ignored. If <code>crit</code> is <code>"C"</code> or <code>"c"</code> and <code>h=NULL</code> then <code>h</code> is assumed to be <code>c(0,...,0,1)</code>.
</p>
</td></tr>
<tr><td><code id="od_KL_+3A_w1">w1</code></td>
<td>

<p>the initial design; it must have a non-singular information matrix and the size <code>sum(w1)</code> of <code>w1</code> must be <code>N</code>. The default option <code>w1 = NULL</code> prompts the algorithm to generate its own initial design using <code><a href="#topic+od_PIN">od_PIN</a></code>.
</p>
</td></tr>
<tr><td><code id="od_KL_+3A_k">K</code>, <code id="od_KL_+3A_l">L</code></td>
<td>

<p>integer numbers (or <code>Inf</code>) representing parameters of the method. Various combinations of <code>K</code> and <code>L</code> lead to specific variants of the exchange method. If <code>K = NULL</code> or <code>L = NULL</code>, the algorithm automatically chooses appropriate values.
</p>
</td></tr>
<tr><td><code id="od_KL_+3A_rest.max">rest.max</code></td>
<td>

<p>the limit on the number of restarts of the method.
</p>
</td></tr>
<tr><td><code id="od_KL_+3A_t.max">t.max</code></td>
<td>

<p>the time limit for the computation.
</p>
</td></tr>
<tr><td><code id="od_KL_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
<tr><td><code id="od_KL_+3A_track">track</code></td>
<td>

<p>Display the progress of the computation?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implementation of the KL algorithm is loosely based on the ideas described in Atkinson et al. (2007); see the references.
</p>
<p>The tuning parameter <code>K</code> is the (upper bound on the) number of &quot;least promising&quot; support points of the current design, for which exchanges are attempted. The tuning parameter <code>L</code> is the (upper bound on the) number of &quot;most promising&quot; candidate design points for which exchanges are attempted.
</p>
<p>The implemented method is greedy in the sense that each improving exchange is immediately executed. If the algorithm stops in a local optimum before the allotted time elapsed, the computation is restarted with a random initial design (independent of <code>w1</code>). The final result is the best design found within all restarts.
</p>
<p>The performance of the function depends on the problem, on the chosen parameters, and on the hardware used, but in most cases the function can compute a nearly-optimal exact design for a problem with a ten thousands design points within seconds of computing time. Because this is only a heuristic, we advise the user to verify the quality of the resulting design by comparing it to the result of an alternative method (such as <code><a href="#topic+od_RC">od_RC</a></code>).
</p>


<h3>Value</h3>

<p>Output is the list with components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call of the function</p>
</td></tr>
<tr><td><code>w.best</code></td>
<td>
<p>the best exact design found by the algorithm</p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>the indices of the support of w.best</p>
</td></tr>
<tr><td><code>w.supp</code></td>
<td>
<p>the weights of w.best on the support</p>
</td></tr>
<tr><td><code>M.best</code></td>
<td>
<p>the information matrix of w.best</p>
</td></tr>
<tr><td><code>Phi.best</code></td>
<td>
<p>the criterion value of w.best</p>
</td></tr>
<tr><td><code>eff.best</code></td>
<td>
<p>a lower bound on the eff of w.best with respect to <code>Phi.app</code></p>
</td></tr>
<tr><td><code>n.rest</code></td>
<td>
<p>number of restarts performed</p>
</td></tr>
<tr><td><code>n.ex</code></td>
<td>
<p>the total number of exchanges performed</p>
</td></tr>
<tr><td><code>t.act</code></td>
<td>
<p>the actual time of the computation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>References</h3>

<p>Atkinson AC, Donev AN, Tobias RD (2007): Optimum experimental designs, with SAS. Vol. 34. Oxford: Oxford University Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+od_RC">od_RC</a></code>, <code><a href="#topic+od_AQUA">od_AQUA</a></code>, <code><a href="#topic+od_MISOCP">od_MISOCP</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Compute a D-efficient exact design of size 27 on a unit square
# for the full quadratic model with 2 discretized factors

form.q &lt;- ~x1 + x2 + I(x1^2) + I(x2^2) + I(x1*x2)
Fx &lt;- Fx_cube(form.q, n.levels = c(101, 101))
w &lt;- od_KL(Fx, 13, t.max = 8)$w.best
od_plot(Fx, w, Fx[, 2:3])
od_print(Fx, w)


# Compute an I-efficient exact design of size 100 without replications
# on a discretized L1 ball for the full quadratic model with 3 factors

form.q &lt;- ~x1 + x2 + x3 + I(x1^2) + I(x2^2) + I(x3^2) + I(x1*x2) + I(x1*x3) + I(x2*x3)
Fx &lt;- Fx_cube(form.q, n.levels = c(21, 21, 21))
remove &lt;- (1:nrow(Fx))[apply(abs(Fx[, 2:4]), 1, sum) &gt; 1 + 1e-9]
Fx &lt;- Fx[-remove, ]
w &lt;- od_KL(Fx, 100, bin = TRUE, crit = "I", t.max = 3)$w.best
od_plot(Fx, w, Fx[, 2:4])

# Compute a D-efficient exact design of size 20 on a 4D cube
# for the full quadratic model with 4 continuous factors

# We can begin with a crude discretization and compute
# an initial (already good) exact design using the KL algorithm

form.q &lt;- ~x1 + x2 + x3 + x4 + I(x1^2) + I(x2^2) + I(x3^2) + I(x4^2) +
           I(x1*x2) + I(x1*x3) + I(x1*x4) + I(x2*x3) + I(x2*x4) + I(x3*x4)
Fx &lt;- Fx_cube(form.q, n.levels = rep(11, 4))
w &lt;- od_KL(Fx, 20, t.max = 10)$w.best
od_print(Fx, w)$design[, c(2:5, 16)]
print(paste("D-criterion value:", optcrit(Fx, w)))

# Now we can fine-tune the positions of the design points
# using any general-purpose continuous optimization method

F &lt;- Fx[rep(1:nrow(Fx), w), ]
f &lt;- function(x) {c(1, x, x^2, x[1]*x[2], x[1]*x[3], x[1]*x[4],
                               x[2]*x[3], x[2]*x[4], x[3]*x[4])}
obj &lt;- function(x, M.red) {-log(det(M.red + f(x) %*% t(f(x))))}
for (i in 1:10)
  for (j in 1:20) {
    F[j, ] &lt;- f(optim(F[j, 2:5], obj, M.red = t(F[-j, ]) %*% F[-j, ],
              method = "L-BFGS-B", lower = rep(-1, 3), upper = rep(1, 3))$par)
  }

tune &lt;- od_pool(round(F, 4), rep(1, 20))
Fx.tune &lt;- tune$X.unique; w.tune &lt;- tune$val.pooled
od_print(Fx.tune, w.tune)$design[, c(2:5, 16)]
print(paste("D-criterion value:", optcrit(Fx.tune, w.tune)))

## End(Not run)
</code></pre>

<hr>
<h2 id='od_MISOCP'>
Optimal exact design using mixed integer second-order cone programming
</h2><span id='topic+od_MISOCP'></span>

<h3>Description</h3>

<p>Computes an optimal or nearly-optimal approximate or exact experimental design using mixed integer second-order cone programming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_MISOCP(Fx, b1=NULL, A1=NULL, b2=NULL, A2=NULL, b3=NULL, A3=NULL, w0=NULL,
          bin=FALSE, type="exact", crit="D", h=NULL, gap=NULL,
          t.max=120, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_MISOCP_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) matrix containing all candidate regressors (as rows), i.e., <code>n</code> is the number of candidate design points, and <code>m</code> (where <code>m&gt;=2</code>) is the number of parameters
</p>
</td></tr>
<tr><td><code id="od_MISOCP_+3A_b1">b1</code>, <code id="od_MISOCP_+3A_a1">A1</code>, <code id="od_MISOCP_+3A_b2">b2</code>, <code id="od_MISOCP_+3A_a2">A2</code>, <code id="od_MISOCP_+3A_b3">b3</code>, <code id="od_MISOCP_+3A_a3">A3</code></td>
<td>

<p>the real vectors and matrices that define the constraints on permissible designs <code>w</code> as follows: <code>A1 %*% w &lt;= b1</code>, <code>A2 %*% w &gt;= b2</code>, <code>A3 %*% w == b3</code>. Each of the arguments can be <code>NULL</code>, but at least one of <code>b1</code>, <code>b2</code>, <code>b3</code> must be non-<code>NULL</code>. If some <code>bi</code> is non-<code>NULL</code> and <code>Ai</code> is <code>NULL</code>, then <code>Ai</code> is set to be <code>matrix(1, nrow =1, ncol = n)</code>.
</p>
</td></tr>
<tr><td><code id="od_MISOCP_+3A_w0">w0</code></td>
<td>

<p>a non-negative vector of length <code>n</code> representing the design to be augmented (i.e., the function adds the constraint <code>w &gt;= w0</code> for permissible designs <code>w</code>). This argument can also be <code>NULL</code>; in that case, <code>w0</code> is set to the vector of zeros.
</p>
</td></tr>
<tr><td><code id="od_MISOCP_+3A_bin">bin</code></td>
<td>

<p>Should each design point be used at most once?
</p>
</td></tr>
<tr><td><code id="od_MISOCP_+3A_type">type</code></td>
<td>

<p>the type of the design. Permissible values are <code>"approximate"</code> and <code>"exact"</code>.
</p>
</td></tr>
<tr><td><code id="od_MISOCP_+3A_crit">crit</code></td>
<td>

<p>the optimality criterion. Possible values are <code>"D"</code>, <code>"A"</code>, <code>"I"</code>, <code>"C"</code>, <code>"c"</code>.
</p>
</td></tr>
<tr><td><code id="od_MISOCP_+3A_h">h</code></td>
<td>

<p>a non-zero vector of length <code>m</code> corresponding to the coefficients of the linear parameter combination of interest. If <code>crit</code> is not <code>"C"</code> nor <code>"c"</code> then <code>h</code> is ignored. If <code>crit</code> is <code>"C"</code> or <code>"c"</code> and <code>h=NULL</code> then <code>h</code> is assumed to be <code>c(0,...,0,1)</code>.
</p>
</td></tr>
<tr><td><code id="od_MISOCP_+3A_gap">gap</code></td>
<td>

<p>the gap for the MISOCP solver to stop the computation. If <code>NULL</code>, the default gap is used.  Setting <code>gap=0</code> and <code>t.max=Inf</code> will ultimately provide the optimal exact design, but the computation may be extremely time consuming.
</p>
</td></tr>
<tr><td><code id="od_MISOCP_+3A_t.max">t.max</code></td>
<td>

<p>the time limit for the computation.
</p>
</td></tr>
<tr><td><code id="od_MISOCP_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At least one of <code>b1</code>, <code>b2</code>, <code>b3</code> must be non-<code>NULL</code>.
If <code>bi</code> is non-<code>NULL</code> and <code>Ai</code> is <code>NULL</code> for some <code>i</code> then <code>Ai</code> is set to be the vector of ones. If <code>bi</code> is <code>NULL</code> for some <code>i</code> then <code>Ai</code> is ignored.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call of the function</p>
</td></tr>
<tr><td><code>w.best</code></td>
<td>
<p>the permissible design found, or <code>NULL</code>. The value <code>NULL</code> indicates a failed computation</p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>the indices of the support of <code>w.best</code></p>
</td></tr>
<tr><td><code>w.supp</code></td>
<td>
<p>the weights of <code>w.best</code> on the support</p>
</td></tr>
<tr><td><code>M.best</code></td>
<td>
<p>the information matrix of <code>w.best</code> or <code>NULL</code> if <code>w.best</code> is <code>NULL</code></p>
</td></tr>
<tr><td><code>Phi.best</code></td>
<td>
<p>the value of the criterion of optimality of the design <code>w.best</code>. If <code>w.best</code> has a singular information matrix or if the computation fails, the value of <code>Phi.best</code> is <code>0</code></p>
</td></tr>
<tr><td><code>status</code></td>
<td>
<p>the status variable of the gurobi optimization procedure; see the gurobi solver documentation for details</p>
</td></tr>
<tr><td><code>t.act</code></td>
<td>
<p>the actual time of the computation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>References</h3>

<p>Sagnol G, Harman R (2015): Computing exact D-optimal designs by mixed integer second order cone programming. The Annals of Statistics, Volume 43, Number 5, pp. 2198-2224.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+od_KL">od_KL</a>, <a href="#topic+od_RC">od_RC</a>, <a href="#topic+od_AQUA">od_AQUA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Compute an A-optimal block size two design
# for 6 treatments and 9 blocks

Fx &lt;- Fx_blocks(6)
w &lt;- od_MISOCP(Fx, b3 = 9, crit = "A", bin = TRUE)$w.best
des &lt;- combn(6, 2)[, as.logical(w)]
print(des)

library(igraph)
grp &lt;- graph_(t(des), from_edgelist(directed = FALSE))
plot(grp, layout=layout_with_graphopt)

# Compute a symmetrized D-optimal approximate design
# for the full quadratic model on a square grid
# with uniform marginal constraints

Fx &lt;- Fx_cube(~x1 + x2 + I(x1^2) + I(x2^2) + I(x1*x2), n.levels = c(21, 21))
A3 &lt;- matrix(0, nrow = 21, ncol = 21^2)
for(i in 1:21) A3[i, (i*21 - 20):(i*21)] &lt;- 1
w &lt;- od_MISOCP(Fx, b3 = rep(1, 21), A3 = A3, crit = "D", type = "approximate")$w.best
w.sym &lt;- od_SYM(Fx, w, b3 = rep(1, 21), A3 = A3)$w.sym
od_plot(Fx, w.sym, Fx[, 2:3], dd.size = 2)

## End(Not run)
</code></pre>

<hr>
<h2 id='od_PIN'>
Efficient saturated exact design
</h2><span id='topic+od_PIN'></span>

<h3>Description</h3>

<p>Use a fast greedy method to compute an efficient saturated subset (saturated exact design).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_PIN(Fx, alg.PIN="KYM", echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_PIN_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) matrix containing all candidate regressors (as rows), i.e., <code>n</code> is the number of candidate design points, and <code>m</code> is the number of parameters.
</p>
</td></tr>
<tr><td><code id="od_PIN_+3A_alg.pin">alg.PIN</code></td>
<td>

<p>the method used (either <code>"KYM"</code> or <code>"GKM"</code>). KYM is randomized, faster but provides somewhat less efficient subsets/designs. GKM is deterministic, slower, but tends to give more efficient subsets/designs.
</p>
</td></tr>
<tr><td><code id="od_PIN_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is developed with the criterion of D-optimality in mind, but it also gives reasonably efficient subset/designs with respect to other criteria. The main purpose of <code>od_PIN</code> is to initialize algorithms for computing optimal approximate and exact designs. It can also be used to verify whether a model, represented by a matrix <code>Fx</code> of candidate regressors, permits a non-singular design.
</p>


<h3>Value</h3>

<p>Output is the list with components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call of the function</p>
</td></tr>
<tr><td><code>w.pin</code></td>
<td>
<p>the resulting exact design</p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>the indices of the support of w.pin</p>
</td></tr>
<tr><td><code>M.pin</code></td>
<td>
<p>the information matrix of w.pin</p>
</td></tr>
<tr><td><code>Phi.D</code></td>
<td>
<p>the D-criterion value of w.pin</p>
</td></tr>
<tr><td><code>t.act</code></td>
<td>
<p>the actual time of the computation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Radoslav Harman, Samuel Rosa, Lenka Filova
</p>


<h3>References</h3>

<p>Harman R, Rosa S (2019): On greedy heuristics for computing D-efficient saturated subsets, (submitted to Operations Research Letters), <a href="https://arxiv.org/abs/1905.07647">https://arxiv.org/abs/1905.07647</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute a saturated subset of a random Fx
Fx &lt;- matrix(rnorm(10000), ncol = 5)
w.KYM &lt;- od_PIN(Fx)$w.pin
w.GKM &lt;- od_PIN(Fx, alg.PIN = "GKM")$w.pin
w.REX &lt;- 5*od_REX(Fx)$w.best
optcrit(Fx, w.KYM)
optcrit(Fx, w.GKM)
optcrit(Fx, w.REX)

</code></pre>

<hr>
<h2 id='od_plot'>
Visualization of a design
</h2><span id='topic+od_plot'></span>

<h3>Description</h3>

<p>Visualizes selected aspects of an experimental design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_plot(Fx, w, X=NULL, w.pool=c("sum", "0"), w.color="darkblue",
        w.size=1, w.pch=16, w.cex=0.8, w.lim=0.01, crit="D",
        h=NULL, dd.pool=c("max", "mean"), dd.color="orange",
        dd.size=1.5, dd.pch=15, asp = NA, main.lab="",
        y.lab="", return.pools=FALSE, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_plot_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) matrix containing all candidate regressors (as rows), i.e., <code>n</code> is the number of candidate design points, and <code>m</code> is the number of parameters
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_w">w</code></td>
<td>

<p>the vector of non-negative real numbers of length <code>n</code> representing the design
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_x">X</code></td>
<td>

<p>an <code>n</code> times <code>k</code> matrix of coordinates of design points
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_w.pool">w.pool</code></td>
<td>

<p>a vector with components from the set <code>"sum"</code>, <code>"min"</code>, <code>"max"</code>, <code>"mean"</code>, <code>"median"</code>, <code>"0"</code> that determines various &quot;pools&quot; of the design weights along the projections defined by the coordinates provided by <code>X</code>
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_w.color">w.color</code></td>
<td>

<p>the color string for plotting the design weight (from the standard list of R colors)
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_w.size">w.size</code></td>
<td>

<p>the size of the characters/balls that represent the non-zero design weights
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_w.pch">w.pch</code></td>
<td>

<p>the numerical code of the characters used to plot the non-zero design weights
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_w.cex">w.cex</code></td>
<td>

<p>the size of the text labels representing the magnitudes of the design weights
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_w.lim">w.lim</code></td>
<td>

<p>a threshold fraction of the total design weight to plot the labels
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_crit">crit</code></td>
<td>

<p>the optimality criterion. Possible values are <code>"D"</code>, <code>"A"</code>, <code>"I"</code>, <code>"C"</code>
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_h">h</code></td>
<td>

<p>a non-zero vector of length <code>m</code> corresponding to the coefficients of the linear parameter combination of interest. If <code>crit</code> is not <code>"C"</code> then <code>h</code> is ignored. If <code>crit</code> is <code>"C"</code> and <code>h=NULL</code> then <code>h</code> is assumed to be <code>c(0,...,0,1)</code>
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_dd.pool">dd.pool</code></td>
<td>

<p>a vector with components from the set <code>"sum"</code>, <code>"min"</code>, <code>"max"</code>, <code>"mean"</code>, <code>"median"</code>, <code>"0"</code> that determines various &quot;pools&quot; of the directional derivatives along the projections defined by the coordinates provided by <code>X</code>
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_dd.color">dd.color</code></td>
<td>

<p>the color string for plotting the directional derivatives (from the standard list of R colors)
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_dd.size">dd.size</code></td>
<td>

<p>the size of the characters that represent the directional derivatives
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_dd.pch">dd.pch</code></td>
<td>

<p>the numerical code of the character used to plot the directional derivatives
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_asp">asp</code></td>
<td>

<p>the aspect ration of the axes
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_main.lab">main.lab</code></td>
<td>

<p>the main title of the plot
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_y.lab">y.lab</code></td>
<td>

<p>the label of the y axis
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_return.pools">return.pools</code></td>
<td>

<p>Return the pooled values?
</p>
</td></tr>
<tr><td><code id="od_plot_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs a simple visualization of some aspects of an experimental design. It visualizes (the selected pools of) the design weights and (the selected pools of) the directional derivative. The type of graph depends on the number of columns in <code>X</code>.
</p>


<h3>Value</h3>

<p>If <code>return.pool</code> is set to <code>TRUE</code>, the procedure returns the data used to plot the figure. The data can be used to plot a different figure according to the user's needs.
</p>


<h3>Note</h3>

<p>The labels of the axes correspond to the column names of <code>X</code>. For a large <code>unique(Fx)</code>, rendering the plot can take a considerable time. Note also that using RStudio, it may be a good idea to open an external graphical window (using the command <code>windows()</code>) before running <code>od_plot</code>.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+od_pool">od_pool</a></code>, <code><a href="#topic+od_print">od_print</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Compute a D-optimal approximate design
# for the 2nd degree Fourier regression on a partial circle
# Use several types of graphs to visualize the design

Fx &lt;- Fx_cube(~I(cos(x1)) + I(sin(x1)) + I(cos(2*x1)) + I(sin(2*x1)),
              lower = -2*pi/3, upper = 2*pi/3, n.levels = 121)
w &lt;- od_REX(Fx)$w.best
par(mfrow = c(2, 2))
od_plot(Fx, w, X = seq(-2*pi/3, 2*pi/3, length = 121), main = "Plot 1")
od_plot(Fx, w, X = Fx[, 2:3], asp = 1, main = "Plot 2")
od_plot(Fx, w, X = Fx[, c(2,5)], asp = 1, main = "Plot 3")
od_plot(Fx, w, X = Fx[, c(3,4)], asp = 1, main = "Plot 4")
par(mfrow = c(1, 1))

## Not run: 
# Compute an I-efficient exact design of size 20 without replications
# for the Scheffe mixture model
# Use several types of graphs to visualize the design

Fx &lt;- Fx_simplex(~x1 + x2 + x3 + I(x1*x2) + I(x1*x3) + I(x2*x3) - 1, 21)
w &lt;- od_AQUA(Fx, b3=20, bin=TRUE, crit="I")$w.best
X &lt;- Fx[, 1:2] 
colnames(X) &lt;- c("", "")
od_plot(Fx, w, X, asp = 1, main = "Plot 1")
od_plot(Fx, w, Fx[, 1:3], main = "Plot 2")

# Compute a symmetrized D-optimal approximate design
# for the full quadratic model with 4 factors
# Use several types of graphs to visualize the design

form.q &lt;- ~x1 + x2 + x3 + x4 + I(x1^2) + I(x2^2) + I(x3^2) + I(x4^2) +
           I(x1*x2) + I(x1*x3) + I(x1*x4) + I(x2*x3) + I(x2*x4) + I(x3*x4)
Fx &lt;- Fx_cube(form.q, n.levels = rep(11, 4))
w &lt;- od_REX(Fx)$w.best
od_plot(Fx, w, Fx[, 2:3], dd.size=3)
od_plot(Fx, w, Fx[, 2:4], w.lim=Inf)


# A more complex example:

# Compute the D-optimal 17 point exact design
# for the spring-balance weighing model with 4 items

Fx &lt;- Fx_cube(~x1 + x2 + x3 + x4 - 1, lower = rep(0, 4))
w &lt;- od_KL(Fx, 17, t.max = 5)$w.best
od_print(Fx, w)$design
U &lt;- eigen(diag(4) - 0.25 * rep(1, 4) 

# A 2D visualization

X &lt;- Fx[, 1:4] 
X[, 2] &lt;- -2*X[, 2]
colnames(X) &lt;- c("V", "Number of items on the pan")
od_plot(Fx, w+0.001, X)
for(i in 1:16) for(j in 1:16)
  if(sum(abs(Fx[i,1:4]-Fx[j,1:4]))==1)
    lines(X[c(i,j),1], X[c(i,j),2])

# A 3D visualization

X &lt;- Fx[, 1:4] 
colnames(X) &lt;- c("V1", "V2", "V3")
od_plot(Fx, w+0.001, X)
for(i in 1:16) for(j in 1:16)
  if(sum(abs(Fx[i, 1:4] - Fx[j, 1:4])) == 1)
    rgl::lines3d(X[c(i, j), 1], X[c(i, j), 2], X[c(i, j), 3])

## End(Not run)
</code></pre>

<hr>
<h2 id='od_pool'>
Pool of a vector
</h2><span id='topic+od_pool'></span>

<h3>Description</h3>

<p>A function <code>pool.fun</code> is applied to all the elements of a vector <code>val</code> that appear within the groups formed by identical rows of a matrix <code>X</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_pool(X, val=NULL, pool.fun="sum", echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_pool_+3A_x">X</code></td>
<td>

<p>the <code>n</code> times <code>k</code> matrix of real values.
</p>
</td></tr>
<tr><td><code id="od_pool_+3A_val">val</code></td>
<td>

<p>a real vector of length <code>n</code>. 
</p>
</td></tr>
<tr><td><code id="od_pool_+3A_pool.fun">pool.fun</code></td>
<td>

<p>a string denoting the function to be applied to the subgroups of elements of <code>val</code> corresponding to the identical rows of <code>X</code>. Possible values are  <code>"sum"</code>, <code>"min"</code>, <code>"max"</code>, <code>"mean"</code>, <code>"median"</code> and <code>"0"</code>. 
</p>
</td></tr>
<tr><td><code id="od_pool_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is useful for plotting (and understanding) of designs of experiments with more factors than the dimension of the plot.  
</p>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call of the function</p>
</td></tr>
<tr><td><code>X.unique</code></td>
<td>
<p>the matrix of unique rows of <code>X</code></p>
</td></tr>
<tr><td><code>val.pooled</code></td>
<td>
<p>the vector of the length <code>nrows(X.unique)</code> containing the values of <code>val</code> pooled using <code>pool.fun</code></p>
</td></tr> 
</table>


<h3>Note</h3>

<p>The function performs a non-trivial operation only if some of the rows of <code>X</code> are identical.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+od_plot">od_plot</a></code>, <code><a href="#topic+od_print">od_print</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v1 &lt;- c(1, 2, 3); v2 &lt;- c(2, 4, 6); v3 &lt;- c(2, 5, 3)
X &lt;- rbind(v1, v1, v1, v1, v2, v3, v2, v3, v3)
val &lt;- c(1, 2, 7, 9, 5, 8, 4, 3, 6)
od_pool(X, val, "sum")

# The result $val.pooled is a vector with components:
# 19 (=1+2+7+9) because the first 4 rows of X are identical
# 9 (=5+4) because the 5th and the 7th rows of X are identical
# 17 (=8+3+6) because the 6th, the 8th and the 9th rows of X are identical
</code></pre>

<hr>
<h2 id='od_print'>
Compact information about a design
</h2><span id='topic+od_print'></span>

<h3>Description</h3>

<p>Prints various characteristics of an experimental design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_print(Fx, w, X=NULL, h=NULL, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_print_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) matrix containing all candidate regressors (as rows), i.e., <code>n</code> is the number of candidate design points, and <code>m</code> is the number of parameters
</p>
</td></tr>
<tr><td><code id="od_print_+3A_w">w</code></td>
<td>

<p>the vector of non-negative real numbers of length <code>n</code> representing the design
</p>
</td></tr>
<tr><td><code id="od_print_+3A_x">X</code></td>
<td>

<p>an <code>n</code> times <code>k</code> matrix of coordinates of design points
</p>
</td></tr>
<tr><td><code id="od_print_+3A_h">h</code></td>
<td>

<p>a non-zero vector of length <code>m</code> corresponding to the coefficients of the linear parameter combination of interest. If <code>crit</code> is not <code>"C"</code> then <code>h</code> is ignored. If <code>crit</code> is <code>"C"</code> and <code>h=NULL</code> then <code>h</code> is assumed to be <code>c(0,...,0,1)</code>
</p>
</td></tr>
<tr><td><code id="od_print_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Output is a list with components
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>the call of the function</p>
</td></tr>
<tr><td><code>design</code></td>
<td>
<p>a matrix with the rows of <code>Fx</code> corresponding to non-zero design weights and the non-weights themselves</p>
</td></tr>
<tr><td><code>M</code></td>
<td>
<p>the information matrix of <code>w</code></p>
</td></tr>
<tr><td><code>eigenvalues</code></td>
<td>
<p>the eigenvalues of <code>M</code></p>
</td></tr>
<tr><td><code>D.value</code></td>
<td>
<p>the value of the D-optimality criterion for <code>w</code></p>
</td></tr>
<tr><td><code>A.value</code></td>
<td>
<p>the value of the A-optimality criterion for <code>w</code></p>
</td></tr>
<tr><td><code>I.value</code></td>
<td>
<p>the value of the I-optimality criterion for <code>w</code></p>
</td></tr>
<tr><td><code>C.value</code></td>
<td>
<p>the value of the C-optimality criterion for <code>w</code></p>
</td></tr>
<tr><td><code>c.value</code></td>
<td>
<p>the value of the c-optimality criterion for <code>w</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+od_plot">od_plot</a></code>, <code><a href="#topic+od_pool">od_pool</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Fx &lt;- Fx_cube(~x1 + I(x1^2), n.levels = 11)
w &lt;- 1:11/sum(1:11)
od_print(Fx, w, Fx[, 2])
</code></pre>

<hr>
<h2 id='od_PUK'>
Efficient rounding of an approximate design
</h2><span id='topic+od_PUK'></span>

<h3>Description</h3>

<p>Compute the classical efficient rounding of a non-normalized approximate design <code>w</code> such that the resulting exact design has size <code>floor(sum(w))</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_PUK(Fx, w, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_PUK_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) matrix containing all candidate regressors (as rows), i.e., <code>n</code> is the number of candidate design points, and <code>m</code> (where <code>m&gt;=2</code>) is the number of parameters
</p>
</td></tr>
<tr><td><code id="od_PUK_+3A_w">w</code></td>
<td>

<p>the vector of non-negative real numbers of length <code>n</code> representing the design
</p>
</td></tr>
<tr><td><code id="od_PUK_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The rounded version of <code>w</code>
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman and Samuel Rosa
</p>


<h3>References</h3>

<p>Pukelsheim F, Rieder S (1992) Efficient rounding of approximate designs. Biometrika, 79(4), 763&ndash;770.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute a D-optimal approximate design
# Round it using the efficient rounding to various sizes
# Visualize the designs

Fx &lt;- Fx_cube(~x1 + I(x1^2) + I(x1^3), lower = 0, upper = 1, n.levels = 11)
w.app &lt;- od_REX(Fx)$w.best
Phi.app &lt;- optcrit(Fx, w.app)

w.ex10 &lt;- od_PUK(Fx, 10*w.app)$w.round
w.ex20 &lt;- od_PUK(Fx, 20*w.app)$w.round
w.ex30 &lt;- od_PUK(Fx, 30*w.app)$w.round

par(mfrow = c(2, 2))
od_plot(Fx, w.app, main.lab = "Approximate")
od_plot(Fx, w.ex10, main.lab = paste("N=10, Eff:", round(optcrit(Fx, w.ex10)/Phi.app/10, 4)))
od_plot(Fx, w.ex20, main.lab = paste("N=20, Eff:", round(optcrit(Fx, w.ex20)/Phi.app/20, 4)))
od_plot(Fx, w.ex30, main.lab = paste("N=30, Eff:", round(optcrit(Fx, w.ex30)/Phi.app/30, 4)))
par(mfrow = c(1, 1))
</code></pre>

<hr>
<h2 id='od_RC'>Efficient exact design using the RC heuristic</h2><span id='topic+od_RC'></span>

<h3>Description</h3>

<p>Computes an efficient exact design under multiple linear resource constraints using the RC heuristic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_RC(Fx, b, A = NULL, w0 = NULL, bin = FALSE, Phi.app = NULL, crit = "D",
      h=NULL, w1 = NULL, rest.max = Inf, t.max = 120,
      echo = TRUE, track=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_RC_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) matrix containing all candidate regressors (as rows), i.e., <code>n</code> is the number of candidate design points, and <code>m</code> is the number of parameters.
</p>
</td></tr>
<tr><td><code id="od_RC_+3A_b">b</code>, <code id="od_RC_+3A_a">A</code></td>
<td>

<p>the vector of length <code>k</code> with positive real components and the <code>k</code> times <code>n</code> matrix of non-negative reals numbers. Each column of <code>A</code> must have at least one strictly positive element. The linear constraints <code>A%*%w&lt;=b, w0&lt;=w</code> define the set of permissible designs <code>w</code> (where <code>w0</code> is a described below.) The argument <code>A</code> can also be <code>NULL</code>; in that case <code>b</code> must be a positive number and <code>A</code> is set to the <code>1</code> times <code>n</code> matrix of ones.
</p>
</td></tr>
<tr><td><code id="od_RC_+3A_w0">w0</code></td>
<td>

<p>a non-negative vector of length <code>n</code> representing the design to be augmented (i.e., the function adds the constraint <code>w &gt;= w0</code> for permissible designs <code>w</code>). This argument can also be <code>NULL</code>; in that case, <code>w0</code> is set to the vector of zeros.
</p>
</td></tr>
<tr><td><code id="od_RC_+3A_bin">bin</code></td>
<td>

<p>Should each design point be used at most once?
</p>
</td></tr>
<tr><td><code id="od_RC_+3A_phi.app">Phi.app</code></td>
<td>

<p>the optimal value of the corresponding approximate (relaxed) problem. If <code>Phi.app = NULL</code>, a very conservative upper bound on <code>Phi.app</code> is pre-computed.
</p>
</td></tr>
<tr><td><code id="od_RC_+3A_crit">crit</code></td>
<td>

<p>the optimality criterion. Possible values are <code>"D"</code>, <code>"A"</code>, <code>"I"</code>, <code>"C"</code>.
</p>
</td></tr>
<tr><td><code id="od_RC_+3A_h">h</code></td>
<td>

<p>a non-zero vector of length <code>m</code> corresponding to the coefficients of the linear parameter combination of interest. If <code>crit</code> is not <code>"C"</code> then <code>h</code> is ignored. If <code>crit</code> is <code>"C"</code> and <code>h=NULL</code> then <code>h</code> is assumed to be <code>c(0,...,0,1)</code>.
</p>
</td></tr>
<tr><td><code id="od_RC_+3A_w1">w1</code></td>
<td>

<p>an <code>n</code> times <code>1</code> nonnegative vector that represents the initial design. The design <code>w1</code> must satisfy <code>w0&lt;=w1</code> and <code>A*w1&lt;=b</code>. The argument <code>w1</code> can also be <code>NULL</code>; in that case the procedure sets <code>w1</code> to be <code>w0</code>.
</p>
</td></tr>
<tr><td><code id="od_RC_+3A_rest.max">rest.max</code></td>
<td>

<p>the maximum allowed number of restarts of the method.
</p>
</td></tr>
<tr><td><code id="od_RC_+3A_t.max">t.max</code></td>
<td>

<p>the time limit for the computation.
</p>
</td></tr>
<tr><td><code id="od_RC_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
<tr><td><code id="od_RC_+3A_track">track</code></td>
<td>

<p>Trace the computation?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is an implementation of the algorithm proposed by Harman et al. (2016); see the references. The inequalities <code>A%*%w&lt;=b</code>, <code>w0&lt;=w</code> with the specific properties mentioned above, form the so-called resource constraints. They encompass many practical restrictions on the design, and lead to a bounded set of feasible solutions.
</p>
<p>The information matrix of <code>w1</code> should preferably have the reciprocal condition number of at least <code>1e-5</code>. Note that the floor of an optimal approximate design (computed for instance using <code><a href="#topic+od_MISOCP">od_MISOCP</a></code>) is often a good initial design. Alternatively, the initial design can be the result of another optimal design procedure, such as <code><a href="#topic+od_AQUA">od_AQUA</a></code>. Even if no initial design is provided, the model should be non-singular in the sense that there <em>exists</em> an exact design <code>w</code> with a well conditioned information matrix, satisfying all constraints. If this requirement is not satisfied, the computation may fail, or it may produce a deficient design.
</p>
<p>The procedure always returns a permissible design, but in some cases, especially if <code>t.max</code> is too small, the resulting design can be inefficient. The performance depends on the problem and on the hardware used, but in most cases the function can compute a nearly-optimal exact design for a problem with a few hundreds design points and tens of constraints within minutes of computing time. Because this is a heuristic method, we advise the user to verify the quality of the resulting design by comparing it to the result of an alternative method (such as <code><a href="#topic+od_AQUA">od_AQUA</a></code> and <code><a href="#topic+od_MISOCP">od_MISOCP</a></code>) and/or by computing its efficiency relative to the corresponding optimal approximate design.
</p>
<p>In the very special (but frequently used) case of the single constraint on the experimental size, it is generally more efficient to use the function <code><a href="#topic+od_KL">od_KL</a></code>.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The call of the function.</p>
</td></tr>
<tr><td><code>w.best</code></td>
<td>
<p>The resulting exact design.</p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>The indices of the support of <code>w.best</code>.</p>
</td></tr>
<tr><td><code>w.supp</code></td>
<td>
<p>The weights of <code>w.best</code> on the support.</p>
</td></tr>
<tr><td><code>M.best</code></td>
<td>
<p>The information matrix of <code>w.best</code>.</p>
</td></tr>
<tr><td><code>Phi.best</code></td>
<td>
<p>The criterion value of <code>w.best</code>.</p>
</td></tr>
<tr><td><code>eff.best</code></td>
<td>
<p>A lower bound on the efficiency of <code>w.best</code> with respect to the optimal approximate design.</p>
</td></tr>
<tr><td><code>n.rest</code></td>
<td>
<p>The number of restarts performed.</p>
</td></tr>
<tr><td><code>t.act</code></td>
<td>
<p>The actual time of the computation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Radoslav Harman, Alena Bachrata, Lenka Filova
</p>


<h3>References</h3>

<p>Harman R, Bachrata A, Filova L (2016): Heuristic construction of exact experimental designs under multiple resource constraints, Applied Stochastic Models in Business and Industry, Volume 32, pp. 3-17
</p>


<h3>See Also</h3>

<p><code><a href="#topic+od_AQUA">od_AQUA</a>, <a href="#topic+od_MISOCP">od_MISOCP</a>, <a href="#topic+od_KL">od_KL</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# A D-efficient exact design for a quadratic model with 2 factors
# constrained by the total time and the total cost of the experiment.
# The cost of a single trial in (x1, x2) is 10 + x1 + 2*x2
# The limit on the total cost is 1000
# (we do not know the number of trials in advance)

form.quad &lt;- ~x1 + x2 + I(x1^2) + I(x2^2) + I(x1 * x2)
Fx &lt;- Fx_cube(form.quad, lower = c(0, 0), upper = c(10, 10), n.levels = c(11, 11))
n &lt;- nrow(Fx); A &lt;- matrix(0, nrow = 1, ncol = n)
for(i in 1:n) A[1, i] &lt;- 5 + Fx[i, 2] + 2*Fx[i, 3]
w &lt;- od_RC(Fx, 1000, A, bin = TRUE, t.max = 8)$w.best
od_plot(Fx, w, Fx[, 2:3], dd.size = 3)

## End(Not run)
</code></pre>

<hr>
<h2 id='od_REX'>Optimal approximate size-constrained design</h2><span id='topic+od_REX'></span>

<h3>Description</h3>

<p>Computes an optimal approximate design under the standard (size) constraint using one of three methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  od_REX(Fx, crit="D", h=NULL, w1=NULL, alg.AA="REX",
         eff=0.999999, it.max=Inf, t.max=60, echo=TRUE, track=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_REX_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) matrix containing all candidate regressors (as rows), i.e., <code>n</code> is the number of candidate design points, and <code>m</code> (where <code>m&gt;=2</code>) is the number of parameters
</p>
</td></tr>
<tr><td><code id="od_REX_+3A_crit">crit</code></td>
<td>

<p>the optimality criterion. Possible values are <code>"D"</code>, <code>"A"</code>, <code>"I"</code>, <code>"C"</code> and <code>"c"</code>.
</p>
</td></tr>
<tr><td><code id="od_REX_+3A_h">h</code></td>
<td>

<p>a non-zero vector of length <code>m</code> corresponding to the coefficients of the linear parameter combination of interest. If <code>crit</code> is not <code>"C"</code> nor <code>"c"</code> then <code>h</code> is ignored. If <code>crit</code> is <code>"C"</code> or <code>"c"</code> and <code>h=NULL</code> then <code>h</code> is assumed to be <code>c(0,...,0,1)</code>.
</p>
</td></tr>
<tr><td><code id="od_REX_+3A_w1">w1</code></td>
<td>

<p>a real vector of length <code>n</code> with non-negative components, representing the initial design. The information matrix of <code>w1</code> must be nonsingular. It should have a small support (e.g., <code>m</code>) provided that <code>alg.AA="REX"</code> and it should have the full support of length <code>n</code> provided that <code>alg.AA="MUL"</code>. The argument <code>w1</code> can also be <code>NULL</code>; in that case a non-singular initial design is generated by <code>od_PIN</code>.
</p>
</td></tr>
<tr><td><code id="od_REX_+3A_alg.aa">alg.AA</code></td>
<td>

<p>the computational method to be applied; possible choices are <code>"REX"</code>, <code>"MUL"</code>, and <code>"VDM"</code>. For <code>crit="c"</code>, argument <code>alg.AA</code> is ignored and the function uses the rapid linear programming approach (see the references).
</p>
</td></tr>
<tr><td><code id="od_REX_+3A_eff">eff</code></td>
<td>

<p>the efficiency for the stopping rule in the interval <code>(0,1)</code>. The algorithm will be stopped if a lower bound on the efficiency of the actual design is equal or greater than <code>eff</code>.
</p>
</td></tr>
<tr><td><code id="od_REX_+3A_it.max">it.max</code></td>
<td>

<p>the maximum allowed number of iterations of the method.
</p>
</td></tr>
<tr><td><code id="od_REX_+3A_t.max">t.max</code></td>
<td>

<p>the time limit for the computation.
</p>
</td></tr>
<tr><td><code id="od_REX_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
<tr><td><code id="od_REX_+3A_track">track</code></td>
<td>

<p>Trace the computation?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements three algorithms for the computation of optimal approximate designs with respect to the criteria of D-, A-, I-, and C-optimality: the standard vertex-direction method (<code>"VDM"</code>), the standard multiplicative method (<code>"MUL"</code>), and the randomized exchange method (<code>"REX"</code>). The first two methods are classical and the method REX is proposed in Harman et al (2019).
</p>
<p>For the specific criterion of c-optimality, the function runs the LP-based method from Harman and Jurik (2008).
</p>
<p>The information matrix of <code>w1</code> should have the reciprocal condition number of at least <code>1e-5</code>. Even if no initial design is provided, the model should be non-singular in the sense that there <em>exists</em> an approximate design <code>w</code> with an information matrix that is not severely ill-conditioned. If this requirement is not satisfied, the computation may fail, or it may produce a deficient design. If <code>w1=NULL</code>, the initial design is computed with <code><a href="#topic+od_PIN">od_PIN</a></code>.
</p>
<p>Since the result is a normalized approximate design, it only gives recommended <em>proportions</em> of trials in individual design points. To convert it to an optimal approximate design of size N (under the standard, i.e., size, constraints), just multiply <code>w.best</code> by N. To obtain an efficient exact design with N trials, <code>w.best</code> must be multiplied by N and the result should be properly rounded to the neighboring integers by, for example, <code>od_PUK</code>. However, it is often more efficient to directly use <code>od_KL</code> to obtain an efficient exact design of size N.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The call of the function.</p>
</td></tr>
<tr><td><code>w.best</code></td>
<td>
<p>The resulting exact design.</p>
</td></tr>
<tr><td><code>supp</code></td>
<td>
<p>The indices of the support of <code>w.best</code>.</p>
</td></tr>
<tr><td><code>w.supp</code></td>
<td>
<p>The weights of <code>w.best</code> on the support.</p>
</td></tr>
<tr><td><code>M.best</code></td>
<td>
<p>The information matrix of <code>w.best</code>.</p>
</td></tr>
<tr><td><code>Phi.best</code></td>
<td>
<p>The criterion value of <code>w.best</code>.</p>
</td></tr>
<tr><td><code>eff.best</code></td>
<td>
<p>A lower bound on the efficiency of <code>w.best</code> with respect to the optimal approximate design.</p>
</td></tr>
<tr><td><code>n.iter</code></td>
<td>
<p>The number of iterations performed.</p>
</td></tr>
<tr><td><code>t.act</code></td>
<td>
<p>The actual time of the computation.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>REX is a randomized algorithm, therefore the resulting designs may differ from run to run. In case that the optimal design is unique, the fluctuation of the results are minor and can be made negligible by setting <code>eff</code> to a value very close to 1.
</p>
<p>If the optimal design is not unique, REX provides a selection of significantly different optimal designs by running it multiple times, which can help choosing the best optimal design based on a secondary criterion.
</p>
<p>A unique and often &quot;symmetric&quot; optimal design (within the possibly infinite set of optimal designs) can be computed by <code>od_SYM</code>.
</p>
<p>Note also that the optimal <em>information matrix</em> is always unique for criteria of D-, A-, I- and C-optimality, even if the optimal design is not unique.
</p>
<p>While the default choice is <code>alg.AA="REX"</code>, our numerical experience suggests that <code>alg.AA="MUL"</code> may be a better choice in problems with a relatively small <code>n</code> and a relatively large <code>m</code>.
</p>
<p>The method VDM is included mostly for teaching purposes; it is only rarely competitive with REX or MUL. Its advantage is that it tends to be easy to generalize to more complex optimum design problems.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>References</h3>

<p>Harman R, Jurik T (2008). Computing c-optimal experimental designs using the simplex method of linear programming. Computational Statistics and Data Analysis 53 (2008) 247-254
</p>
<p>Harman R, Filova L, Richtarik P (2019). A randomized exchange algorithm for computing optimal approximate designs of experiments. Journal of the American Statistical Association, 1-30.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+od_KL">od_KL</a>, <a href="#topic+od_RC">od_RC</a>, <a href="#topic+od_MISOCP">od_MISOCP</a>, <a href="#topic+od_AQUA">od_AQUA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Note: Many small examples of od_REX are in other help files.

# Compute an essentially perfect D-optimal design
# on 10 million design points in a few seconds
n &lt;- 10000000; m &lt;- 5
Fx &lt;- matrix(rnorm(n*m), ncol = m)
w &lt;- od_REX(Fx, t.max = 10)$w.best
Fx.small &lt;- od_DEL(Fx, w)$Fx.keep
w &lt;- od_REX(Fx.small, eff = 0.999999999)$w.best
od_plot(Fx.small, w, Fx.small[, 1:2], dd.pch = 16, dd.size = 0.35)

## End(Not run)
</code></pre>

<hr>
<h2 id='od_SYM'>
Symmetrization of an approximate design
</h2><span id='topic+od_SYM'></span>

<h3>Description</h3>

<p>Attempts to &quot;symmetrize&quot; an approximate design <code>w</code> by minimizing its norm while keeping its information matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>od_SYM(Fx, w, b1=NULL, A1=NULL, b2=NULL, A2=NULL, b3=NULL, A3=NULL, w0=NULL,
      crit="D", h=NULL, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="od_SYM_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) matrix containing all candidate regressors (as rows), i.e., <code>n</code> is the number of candidate design points, and <code>m</code> is the number of parameters
</p>
</td></tr>
<tr><td><code id="od_SYM_+3A_w">w</code></td>
<td>

<p>a non-negative vector of length <code>n</code> representing the design
</p>
</td></tr>
<tr><td><code id="od_SYM_+3A_b1">b1</code>, <code id="od_SYM_+3A_a1">A1</code>, <code id="od_SYM_+3A_b2">b2</code>, <code id="od_SYM_+3A_a2">A2</code>, <code id="od_SYM_+3A_b3">b3</code>, <code id="od_SYM_+3A_a3">A3</code></td>
<td>

<p>the real vectors and matrices that define the constraints on permissible designs <code>w</code> as follows: <code>A1 %*% w &lt;= b1</code>, <code>A2 %*% w &gt;= b2</code>, <code>A3 %*% w == b3</code>. Each of the arguments can be <code>NULL</code>, but at least one of <code>b1</code>, <code>b2</code>, <code>b3</code> must be non-<code>NULL</code>. If some <code>bi</code> is non-<code>NULL</code> and <code>Ai</code> is <code>NULL</code>, then <code>Ai</code> is set to be <code>matrix(1, nrow =1, ncol = n)</code>.
</p>
</td></tr>
<tr><td><code id="od_SYM_+3A_w0">w0</code></td>
<td>

<p>a non-negative vector of length <code>n</code> representing the design to be augmented (i.e., the function adds the constraint <code>w &gt;= w0</code> for permissible designs <code>w</code>). This argument can also be <code>NULL</code>; in that case, <code>w0</code> is set to the vector of zeros.
</p>
</td></tr>
<tr><td><code id="od_SYM_+3A_crit">crit</code></td>
<td>

<p>the optimality criterion. Possible values are <code>"D"</code>, <code>"A"</code>, <code>"I"</code>, <code>"C"</code>, <code>"c"</code>.
</p>
</td></tr>
<tr><td><code id="od_SYM_+3A_h">h</code></td>
<td>

<p>a non-zero vector of length <code>m</code> corresponding to the coefficients of the linear parameter combination of interest. If <code>crit</code> is not <code>"C"</code> nor <code>"c"</code> then <code>h</code> is ignored. If <code>crit</code> is <code>"C"</code> or <code>"c"</code> and <code>h=NULL</code> then <code>h</code> is assumed to be <code>c(0,...,0,1)</code>.
</p>
</td></tr>
<tr><td><code id="od_SYM_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For some models, the optimum approximate design is not unique (although the optimum information matrix usually <em>is</em> unique). This function uses one optimal approximate design to produce an optimal approximate design with a minimum Euclidean norm, which is unique and usually more &quot;symmetric&quot;.
</p>


<h3>Value</h3>

<p>A list with the following components:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The call of the function</p>
</td></tr>
<tr><td><code>w.sym</code></td>
<td>
<p>The resulting &quot;symmetrized&quot; approximate design</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>References</h3>

<p>Harman R, Filova L, Richtarik P (2019). A randomized exchange algorithm for computing optimal approximate designs of experiments. Journal of the American Statistical Association, 1-30. (Subsection 5.1)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Compute a D-optimal approximate design using the randomized method REX.
# Visualize both the design obtained by REX and its symmetrized version.

form.q &lt;- ~x1 + x2 + x3 + I(x1^2) + I(x2^2) + I(x3^2) + I(x1*x2) + I(x1*x3) + I(x2*x3)
Fx &lt;- Fx_cube(form.q, n.levels = c(5, 5, 5))
w.app &lt;- od_REX(Fx)$w.best
od_plot(Fx, w.app, X=Fx[, 2:3])
w.app.sym &lt;- od_SYM(Fx, w.app, b3 = 1)$w.sym
od_plot(Fx, w.app.sym, X=Fx[, 2:3])
</code></pre>

<hr>
<h2 id='optcrit'>
Criterion value of a design
</h2><span id='topic+optcrit'></span>

<h3>Description</h3>

<p>Computes the criterion value of a design <code>w</code> in the model determined by the matrix <code>Fx</code> of all regressors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>optcrit(Fx, w, crit="D", h=NULL, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="optcrit_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) matrix containing all candidate regressors (as rows), i.e., <code>n</code> is the number of candidate design points, and <code>m</code> (where <code>m&gt;=2</code>) is the number of parameters.
</p>
</td></tr>
<tr><td><code id="optcrit_+3A_w">w</code></td>
<td>

<p>a non-negative vector of length <code>n</code> representing the design.
</p>
</td></tr>
<tr><td><code id="optcrit_+3A_crit">crit</code></td>
<td>

<p>the criterion; possible values are <code>"D"</code>, <code>"A"</code>, <code>"I"</code>, <code>"C"</code> and <code>"c"</code>.
</p>
</td></tr>
<tr><td><code id="optcrit_+3A_h">h</code></td>
<td>

<p>a non-zero vector of length <code>m</code> corresponding to the coefficients of the linear parameter combination of interest. If <code>crit</code> is not <code>"C"</code> nor <code>"c"</code> then <code>h</code> is ignored. If <code>crit</code> is <code>"C"</code> or <code>"c"</code> and <code>h=NULL</code> then <code>h</code> is assumed to be <code>c(0,...,0,1)</code>.
</p>
</td></tr>
<tr><td><code id="optcrit_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The package works with optimality criteria as information functions, i.e., the criteria are concave, positive homogeneous and upper semicontinuous on the set of all non-negative definite matrices. The criteria are normalized such that they assign the value of 1 to any design with information matrix equal to the identity matrix.
</p>


<h3>Value</h3>

<p>A non-negative number corresponding to the criterion value.
</p>


<h3>Note</h3>

<p>Since the criteria are positive homogeneous, the relative efficiency of two designs is just the ratio of their criterion values.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+infmat">infmat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The Fx matrix for the spring balance weighing model with 6 weighed items.
Fx &lt;- Fx_cube(~x1 + x2 + x3 + x4 + x5 + x6 - 1, lower = rep(0, 6), n.levels = rep(2, 6))

# Criteria of the design of size 15 that weighs each pair of items exactly once.
w2 &lt;- rep(0, 64); w2[apply(Fx, 1, sum) == 2] &lt;- 1
optcrit(Fx, w2, crit = "D")
optcrit(Fx, w2, crit = "A")
optcrit(Fx, w2, crit = "I")

# Criteria for the design of size 15 that weighs each quadruple of items exactly once.
w4 &lt;- rep(0, 64); w4[apply(Fx, 1, sum) == 4] &lt;- 1
optcrit(Fx, w4, crit = "D")
optcrit(Fx, w4, crit = "A")
optcrit(Fx, w4, crit = "I")
</code></pre>

<hr>
<h2 id='OptimalDesign-internal'>Internal OptimalDesign Functions</h2><span id='topic+od_A_AQUA'></span><span id='topic+od_A_DEL'></span><span id='topic+od_A_KL'></span><span id='topic+od_A_KL_bin'></span><span id='topic+od_A_MISOCP'></span><span id='topic+od_A_MUL'></span><span id='topic+od_A_RC'></span><span id='topic+od_A_REX'></span><span id='topic+od_A_VDM'></span><span id='topic+od_c_LP'></span><span id='topic+od_c_MISOCP'></span><span id='topic+od_D_AQUA'></span><span id='topic+od_D_DEL'></span><span id='topic+od_D_KL'></span><span id='topic+od_D_KL_bin'></span><span id='topic+od_D_MISOCP'></span><span id='topic+od_D_MUL'></span><span id='topic+od_D_RC'></span><span id='topic+od_D_REX'></span><span id='topic+od_D_VDM'></span><span id='topic+ginv'></span><span id='topic+verify'></span>

<h3>Description</h3>

<p>Internal OptimalDesign functions
</p>


<h3>Details</h3>

<p>These are not to be called by the user.
</p>

<hr>
<h2 id='varfun'>
Vector of variances
</h2><span id='topic+varfun'></span>

<h3>Description</h3>

<p>Computes the vector of variances (sensitivities) for a given design <code>w</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varfun(Fx, w, crit="D", h=NULL, echo=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varfun_+3A_fx">Fx</code></td>
<td>

<p>the <code>n</code> times <code>m</code> matrix of candidate regressors (as rows), where <code>n</code> is the number of candidate design points and <code>m</code> (where <code>m&gt;=2</code>, <code>m&lt;=n</code>) is the number of parameters.
</p>
</td></tr>
<tr><td><code id="varfun_+3A_w">w</code></td>
<td>

<p>a non-negative vector of length <code>n</code> representing the design.
</p>
</td></tr>
<tr><td><code id="varfun_+3A_crit">crit</code></td>
<td>

<p>the criterion; possible values are <code>"D"</code>, <code>"A"</code>, <code>"I"</code>, <code>"C"</code> and <code>"c"</code>.
</p>
</td></tr>
<tr><td><code id="varfun_+3A_h">h</code></td>
<td>

<p>a non-zero vector of length <code>m</code> corresponding to the coefficients of the linear parameter combination of interest. If crit is not <code>"C"</code> nor <code>"c"</code> then <code>h</code> is ignored. If <code>crit</code> is <code>"C"</code> or <code>"c"</code> and <code>h=NULL</code> then <code>h</code> is assumed to be <code>c(0,...,0,1)</code>.
</p>
</td></tr>
<tr><td><code id="varfun_+3A_echo">echo</code></td>
<td>

<p>Print the call of the function?
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For D-optimality, the i-th element of the vector of variances is the variance of the best linear unbiased estimator of the mean value of observations under the experimental conditions represented by the i-th design point (where the variance of the observational errors is assumed to be 1). There is a linear transformation relation of the vector of variances and the vector of directional derivatives for the criterion of D-optimality. See the reference paper at <a href="http://www.iam.fmph.uniba.sk/design/">http://www.iam.fmph.uniba.sk/design/</a> for mathematical details.
</p>


<h3>Value</h3>

<p>The vector of variances (sensitivities) for a given design <code>w</code>.
</p>


<h3>Note</h3>

<p>The design <code>w</code> should have a non-singular information matrix.
</p>


<h3>Author(s)</h3>

<p>Radoslav Harman, Lenka Filova
</p>


<h3>See Also</h3>

<p><code><a href="#topic+effbound">effbound</a>, <a href="#topic+dirder">dirder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The values of the variance function (for crit=D)
# of D-, I-, and C-optimal approximate design

Fx &lt;- Fx_cube(~x1 + I(x1^2), n.levels = 21)
wD &lt;- od_REX(Fx)$w.best
wI &lt;- od_REX(Fx, crit="I")$w.best
wC &lt;- od_REX(Fx, crit="C", h=c(1, 0, 0))$w.best
vD &lt;- varfun(Fx, wD)
vI &lt;- varfun(Fx, wI)
vC &lt;- varfun(Fx, wC)
plot(Fx[, 2], rep(0, nrow(Fx)), ylim = c(0, max(vD, vI, vC)),
     type = "n", xlab = "x", ylab = "var", lwd = 2)
grid()
lines(Fx[, 2], vD, col = "red")
lines(Fx[, 2], vI, col = "blue")
lines(Fx[, 2], vC, col = "green")

# The D-optimal approximate design minimized the maximum
# of the var. function (it is "G-optimal").
# The I-optimal approximate design minimizes the integral of the var. function.
# The C-optimal design with h=f(0) makes the var. function small around 0.
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
