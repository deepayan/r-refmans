<!DOCTYPE html><html><head><title>Help for package RMVL</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RMVL}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+5B.MVL'><p>MVL handle subscription operator</p></a></li>
<li><a href='#+5B.MVL_OBJECT'><p>MVL object subscription operator</p></a></li>
<li><a href='#+5B+5B.MVL_OBJECT'><p>MVL object subscription operator</p></a></li>
<li><a href='#+24.MVL'><p>MVL handle subscription operator</p></a></li>
<li><a href='#dim.MVL_OBJECT'><p>Obtain dimensions of MVL object</p></a></li>
<li><a href='#length.MVL_OBJECT'><p>Obtain length of MVL object</p></a></li>
<li><a href='#mvl_add_directory_entries'><p>Add entries to MVL directory</p></a></li>
<li><a href='#mvl_class'><p>Return underlying R class of object</p></a></li>
<li><a href='#mvl_close'><p>Close MVL file</p></a></li>
<li><a href='#mvl_compute_repeats'><p>Find stretches of repeated rows among vectors</p></a></li>
<li><a href='#mvl_extent_index_lapply'><p>Apply function to indices of rows with matching hashes</p></a></li>
<li><a href='#mvl_find_matches'><p>Find matching rows</p></a></li>
<li><a href='#mvl_fused_write_objects'><p>Concatenate objects and write result into MVL file.</p></a></li>
<li><a href='#mvl_get_groups'><p>Retrieve indices belonging to one or more groups</p></a></li>
<li><a href='#mvl_get_neighbors'><p>Retrieve indices of nearby rows.</p></a></li>
<li><a href='#mvl_group'><p>Group identical rows</p></a></li>
<li><a href='#mvl_group_lapply'><p>Apply function to index stretches</p></a></li>
<li><a href='#mvl_hash_vectors'><p>Return hash values for each row</p></a></li>
<li><a href='#mvl_index_lapply'><p>Apply function to indices of nearby rows</p></a></li>
<li><a href='#mvl_indexed_copy'><p>Index copy vector</p></a></li>
<li><a href='#mvl_inherits'><p>Check inheritance of R or MVL objects</p></a></li>
<li><a href='#mvl_merge'><p>Merge two MVL data frames and write the result</p></a></li>
<li><a href='#mvl_neighbors_lapply'><p>Apply function to indices of nearby rows</p></a></li>
<li><a href='#mvl_object_stats'><p>Return MVL object properties</p></a></li>
<li><a href='#mvl_open'><p>Open an MVL file</p></a></li>
<li><a href='#mvl_order_vectors'><p>Return permutation sorting vector entries</p></a></li>
<li><a href='#mvl_remap'><p>Enlarge memory map to include recently loaded data.</p></a></li>
<li><a href='#mvl_start_write_vector'><p>Piecewise output of very long numeric and integer vectors</p></a></li>
<li><a href='#mvl_status'><p>Return status of MVL package</p></a></li>
<li><a href='#mvl_write_extent_index'><p>Compute and write extent index</p></a></li>
<li><a href='#mvl_write_groups'><p>Write group information for each row</p></a></li>
<li><a href='#mvl_write_hash_vectors'><p>Write hash values for each row</p></a></li>
<li><a href='#mvl_write_object'><p>Write R object into MVL file</p></a></li>
<li><a href='#mvl_write_serialized_object'><p>Write R object in serialized form</p></a></li>
<li><a href='#mvl_write_spatial_groups'><p>Write spatial group information for each row</p></a></li>
<li><a href='#mvl_write_spatial_index1'><p>Write spatial group information for each row</p></a></li>
<li><a href='#mvl_xlength'><p>Return length of MVL or R vector as a numeric value</p></a></li>
<li><a href='#mvl2R'><p>Make sure the object is fully converted to its R representation</p></a></li>
<li><a href='#names.MVL'><p>Print MVL directory</p></a></li>
<li><a href='#names.MVL_OBJECT'><p>Retrieve MVL object names</p></a></li>
<li><a href='#print.MVL'><p>Print MVL</p></a></li>
<li><a href='#print.MVL_OBJECT'><p>Print MVL object</p>
This is a convenience function for displaying MVL_OBJECTs.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Mappable Vector Library for Handling Large Datasets</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Mappable vector library provides convenient way to access large datasets. Use all of your data at once, with few limits. Memory mapped data can be shared between multiple R processes. Access speed depends on storage medium, so solid state drive is recommended, preferably with PCI Express (or M.2 nvme) interface or a fast network file system. The data is memory mapped into R and then accessed using usual R list and array subscription operators. Convenience functions are provided for merging, grouping and indexing large vectors and data.frames. The layout of underlying MVL files is optimized for large datasets. The vectors are stored to guarantee alignment for vector intrinsics after memory map. The package is built on top of libMVL, which can be used as a standalone C library. libMVL has simple C API making it easy to interchange datasets with outside programs. Large MVL datasets are distributed via Academic Torrents <a href="https://academictorrents.com/collection/mvl-datasets">https://academictorrents.com/collection/mvl-datasets</a>. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://academictorrents.com/collection/mvl-datasets">https://academictorrents.com/collection/mvl-datasets</a>,
<a href="https://github.com/volodya31415/RMVL">https://github.com/volodya31415/RMVL</a>,
<a href="https://github.com/volodya31415/libMVL">https://github.com/volodya31415/libMVL</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-08 17:24:26 UTC; volodya</td>
</tr>
<tr>
<td>Author:</td>
<td>Vladimir Dergachev
    <a href="https://orcid.org/0000-0003-4708-6625"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Vladimir Dergachev &lt;support@altumrete.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-08 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+5B.MVL'>MVL handle subscription operator</h2><span id='topic++5B.MVL'></span>

<h3>Description</h3>

<p>Retrieve objects stored in mappable vector library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MVL'
MVLHANDLE[y, raw = FALSE, ref = FALSE, drop = TRUE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.MVL_+3A_mvlhandle">MVLHANDLE</code></td>
<td>
<p>- handle to opened MVL file as generated by <code>mvl_open</code></p>
</td></tr>
<tr><td><code id="+2B5B.MVL_+3A_y">y</code></td>
<td>
<p>- name of object to retrieve</p>
</td></tr>
<tr><td><code id="+2B5B.MVL_+3A_raw">raw</code></td>
<td>
<p>- request to return data in raw format when it does not map exactly to R data types.</p>
</td></tr>
<tr><td><code id="+2B5B.MVL_+3A_ref">ref</code></td>
<td>
<p>- always return an MVL_OBJECT</p>
</td></tr>
<tr><td><code id="+2B5B.MVL_+3A_drop">drop</code></td>
<td>
<p>- whether to drop dimensionality, such as when a sublist contains only one element</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>mvl_open</code> for example.
</p>


<h3>Value</h3>

<p>Stored object
</p>

<hr>
<h2 id='+5B.MVL_OBJECT'>MVL object subscription operator</h2><span id='topic++5B.MVL_OBJECT'></span>

<h3>Description</h3>

<p>Retrieve objects stored in mappable vector library. Large nested objects are returned as instances of MVL_OBJECT to delay access until needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MVL_OBJECT'
obj[i, ..., drop = TRUE, raw = FALSE, recurse = FALSE, ref = FALSE]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B.MVL_OBJECT_+3A_obj">obj</code></td>
<td>
<p>- MVL object retrieved by subscription of MVL library or other objects</p>
</td></tr>
<tr><td><code id="+2B5B.MVL_OBJECT_+3A_i">i</code></td>
<td>
<p>- optional index.</p>
</td></tr>
<tr><td><code id="+2B5B.MVL_OBJECT_+3A_drop">drop</code></td>
<td>
<p>- whether to drop dimensionality, such as done with R array or data frames</p>
</td></tr>
<tr><td><code id="+2B5B.MVL_OBJECT_+3A_raw">raw</code></td>
<td>
<p>- request to return data in raw format when it does not map exactly to R data types.</p>
</td></tr>
<tr><td><code id="+2B5B.MVL_OBJECT_+3A_recurse">recurse</code></td>
<td>
<p>- force recursive conversion to pure R objects.</p>
</td></tr>
<tr><td><code id="+2B5B.MVL_OBJECT_+3A_ref">ref</code></td>
<td>
<p>- always return an MVL_OBJECT</p>
</td></tr>
<tr><td><code id="+2B5B.MVL_OBJECT_+3A_...">...</code></td>
<td>
<p>optional additional indices for multidimensional arrays and data frames</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>mvl_open</code> for example.
</p>


<h3>Value</h3>

<p>Stored object
</p>

<hr>
<h2 id='+5B+5B.MVL_OBJECT'>MVL object subscription operator</h2><span id='topic++5B+5B.MVL_OBJECT'></span>

<h3>Description</h3>

<p>Retrieve objects stored in mappable vector library. Large nested objects are returned as instances of MVL_OBJECT to delay access until needed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MVL_OBJECT'
obj[[i, raw = FALSE, recurse = FALSE, ref = FALSE]]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B5B+2B5B.MVL_OBJECT_+3A_obj">obj</code></td>
<td>
<p>- MVL object retrieved by subscription of MVL library or other objects</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.MVL_OBJECT_+3A_i">i</code></td>
<td>
<p>- index.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.MVL_OBJECT_+3A_raw">raw</code></td>
<td>
<p>- request to return data in raw format when it does not map exactly to R data types.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.MVL_OBJECT_+3A_recurse">recurse</code></td>
<td>
<p>- force recursive conversion to pure R objects.</p>
</td></tr>
<tr><td><code id="+2B5B+2B5B.MVL_OBJECT_+3A_ref">ref</code></td>
<td>
<p>- always return an MVL_OBJECT</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code>mvl_open</code> for example.
</p>


<h3>Value</h3>

<p>Stored object
</p>

<hr>
<h2 id='+24.MVL'>MVL handle subscription operator</h2><span id='topic++24.MVL'></span>

<h3>Description</h3>

<p>Retrieve objects stored in the library. Unlike for R lists the match on name is always exact.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MVL'
MVLHANDLE$name
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B24.MVL_+3A_mvlhandle">MVLHANDLE</code></td>
<td>
<p>- handle to opened MVL file as generated by <code>mvl_open</code></p>
</td></tr>
<tr><td><code id="+2B24.MVL_+3A_name">name</code></td>
<td>
<p>- name of object to retrieve</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Stored object
</p>

<hr>
<h2 id='dim.MVL_OBJECT'>Obtain dimensions of MVL object</h2><span id='topic+dim.MVL_OBJECT'></span>

<h3>Description</h3>

<p>Obtain dimensions of MVL object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MVL_OBJECT'
dim(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dim.MVL_OBJECT_+3A_x">x</code></td>
<td>
<p>MVL_OBJECT as retrieved by subscription operators</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object dimensions, or NULL if not present
</p>

<hr>
<h2 id='length.MVL_OBJECT'>Obtain length of MVL object</h2><span id='topic+length.MVL_OBJECT'></span>

<h3>Description</h3>

<p>Obtain length of MVL object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MVL_OBJECT'
length(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length.MVL_OBJECT_+3A_x">x</code></td>
<td>
<p>MVL_OBJECT as retrieved by subscription operators</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object length as stored in MVL file. This is the total length of object for arrays, and number of columns for data frames.
</p>

<hr>
<h2 id='mvl_add_directory_entries'>Add entries to MVL directory</h2><span id='topic+mvl_add_directory_entries'></span>

<h3>Description</h3>

<p>Add one or more entries to MVL directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_add_directory_entries(MVLHANDLE, tag, offsets)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_add_directory_entries_+3A_mvlhandle">MVLHANDLE</code></td>
<td>
<p>handle to open MVL file created by <code>mvl_open</code></p>
</td></tr>
<tr><td><code id="mvl_add_directory_entries_+3A_tag">tag</code></td>
<td>
<p>a vector of one or more character tags</p>
</td></tr>
<tr><td><code id="mvl_add_directory_entries_+3A_offsets">offsets</code></td>
<td>
<p>a vector of MVL_OFFSET objects, one per tag, created by <code>mvl_write_object</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to expand MVL directory. The offsets must be created by calling <code>mvl_write_object</code> on the same handle.
Note that <code>mvl_write_object</code> has an optional parameter <code>name</code> that will add an entry when specified.
Thus this function is meant for special circumstances, such as creating multiple entries in the directory that point to the same offset
</p>

<hr>
<h2 id='mvl_class'>Return underlying R class of object</h2><span id='topic+mvl_class'></span>

<h3>Description</h3>

<p>This function returns the equivalent R class of underlying MVL object, i.e. the class it would have if converted into a regular R object.
For non-MVL objects the function simply calls the usual R class(), so it can be used instead of class() for code that operates on both usual R objects and MVL objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_class(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_class_+3A_x">x</code></td>
<td>
<p>any object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string giving object class
</p>

<hr>
<h2 id='mvl_close'>Close MVL file</h2><span id='topic+mvl_close'></span>

<h3>Description</h3>

<p>Closes MVL file releasing all resources.
For read-only files the memory is unmapped, reducing the virtual memory footprint.
For files opened for writing the directory is written out, so it is important to call <code>mvl_close</code> or the newly written file will be corrupt.
After <code>mvl_close()</code> all previously obtained MVL_OBJECT's with this handle become invalid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_close(MVLHANDLE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_close_+3A_mvlhandle">MVLHANDLE</code></td>
<td>
<p>handle to opened MVL file as generated by mvl_open()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_open">mvl_open</a></code>, <code><a href="#topic+mvl_remap">mvl_remap</a></code>
</p>

<hr>
<h2 id='mvl_compute_repeats'>Find stretches of repeated rows among vectors</h2><span id='topic+mvl_compute_repeats'></span>

<h3>Description</h3>

<p>This function is passed a list of vector like MVL_OBJECTs which are considered as columns in a table.
It returns a vector V starting with 1 and ending with number of rows plus 1, so that stretches of repeated rows can be found as V[i]:V[i+1]
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_compute_repeats(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_compute_repeats_+3A_l">L</code></td>
<td>
<p>list of vector like MVL_OBJECTs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>partition describing repeated rows
</p>

<hr>
<h2 id='mvl_extent_index_lapply'>Apply function to indices of rows with matching hashes</h2><span id='topic+mvl_extent_index_lapply'></span>

<h3>Description</h3>

<p>Please use generic function <code>mvl_index_lapply()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_extent_index_lapply(extent_index, data_list, fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_extent_index_lapply_+3A_extent_index">extent_index</code></td>
<td>
<p>MVL_OBJECT computed by <code>mvl_write_extent_index()</code></p>
</td></tr>
<tr><td><code id="mvl_extent_index_lapply_+3A_data_list">data_list</code></td>
<td>
<p>a list of vectors of equal length. They can be MVL_OBJECTs or R vectors. If missing, scan the entire table one hash at a time.</p>
</td></tr>
<tr><td><code id="mvl_extent_index_lapply_+3A_fn">fn</code></td>
<td>
<p>a function of two arguments - and index into <code>data_list</code> and a corresponding list of indices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is passed the index computed by <code>mvl_write_extent_index()</code> and a list of vectors, which rows are used to compute 64-bit hashes.
For each row, we call the function <code>fn(i, idx)</code>, where <code>i</code> gives the index of query row, and <code>idx</code> gives the indices of with matching hashes.
</p>
<p>64-bit hashes have very few collisions, nevertheless the user is advised to double check that the values actually match.
</p>
<p>The hash computation is type dependent, so <code>1</code> stored as an integer will produce a different hash than when stored as floating point. This function accounts for this by internally converting to types the index was generated with.
</p>


<h3>Value</h3>

<p>a list of results of function <code>fn</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_index_lapply">mvl_index_lapply</a></code>, <code><a href="#topic+mvl_group">mvl_group</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, data.frame(x=runif(100), y=(1:100) %% 10), "df1")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_write_extent_index(Mtmp, list(Mtmp$df1[,"y",ref=TRUE]), "df1_extent_index_y")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_extent_index_lapply(Mtmp["df1_extent_index_y", ref=TRUE], list(c(2, 3)),
                                           function(i, idx) { return(list(i, idx))})
# Example of full scan
mvl_extent_index_lapply(Mtmp["df1_extent_index_y", ref=TRUE], ,
                                           function(i, idx) { return(list(i, idx))})

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_find_matches'>Find matching rows</h2><span id='topic+mvl_find_matches'></span>

<h3>Description</h3>

<p>This function is passed two lists of MVL vectors which are interpreted in data.frame fashion. 
The indices of pairwise matches are returned in order of the arguments (&quot;index1&quot; and &quot;index2&quot;). 
In addition we return indices describing stretches with &quot;index1&quot; value constant ( stretch_index1[i] to stretch_index1[i+1]-1)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_find_matches(L1, L2, indices1 = NULL, indices2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_find_matches_+3A_l1">L1</code></td>
<td>
<p>list of vector like MVL_OBJECTs</p>
</td></tr>
<tr><td><code id="mvl_find_matches_+3A_l2">L2</code></td>
<td>
<p>list of vector like MVL_OBJECTs</p>
</td></tr>
<tr><td><code id="mvl_find_matches_+3A_indices1">indices1</code></td>
<td>
<p>list of indices into objects to sort. If absent or NULL it is assumed to be from 1 to the length of the object.</p>
</td></tr>
<tr><td><code id="mvl_find_matches_+3A_indices2">indices2</code></td>
<td>
<p>list of indices into objects to sort. If absent or NULL it is assumed to be from 1 to the length of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of matches and match stretches
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_hash_vectors">mvl_hash_vectors</a></code>, <code><a href="#topic+mvl_order_vectors">mvl_order_vectors</a></code>, <code><a href="#topic+mvl_group">mvl_group</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_indexed_copy">mvl_indexed_copy</a></code>, <code><a href="#topic+mvl_merge">mvl_merge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, data.frame(x=rep(c("a", "b"), 50), y=1:100), "df1")
mvl_write_object(Mtmp, data.frame(x=rep(c("b", "c"), 50), y=21:120), "df2")
Mtmp&lt;-mvl_remap(Mtmp)
L&lt;-mvl_find_matches(list(Mtmp$df1[,"x",ref=TRUE], Mtmp$df1[,"y", ref=TRUE]), 
                        list(Mtmp$df2[,"x",ref=TRUE], Mtmp$df2[,"y", ref=TRUE]))

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_fused_write_objects'>Concatenate objects and write result into MVL file.</h2><span id='topic+mvl_fused_write_objects'></span>

<h3>Description</h3>

<p>This function can concatenate a mixture of R and MVL objects. For vectors it is the equivalent of <code>c()</code>. For array and matrices it works as <code>cbind()</code>
For data frames it works as <code>rbind</code>, but row names are always dropped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_fused_write_objects(MVLHANDLE, L, name = NULL, drop.rownames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_fused_write_objects_+3A_mvlhandle">MVLHANDLE</code></td>
<td>
<p>a handle to MVL file produced by <code>mvl_open()</code></p>
</td></tr>
<tr><td><code id="mvl_fused_write_objects_+3A_l">L</code></td>
<td>
<p>a list of suitable R objects (vector, array, data.frame) or equivalent MVL objects.</p>
</td></tr>
<tr><td><code id="mvl_fused_write_objects_+3A_name">name</code></td>
<td>
<p>if specified add a named entry to MVL file directory</p>
</td></tr>
<tr><td><code id="mvl_fused_write_objects_+3A_drop.rownames">drop.rownames</code></td>
<td>
<p>set to TRUE to prevent rownames from being written</p>
</td></tr>
</table>


<h3>Value</h3>

<p>any object of class MVL_OFFSET that describes an offset into this MVL file. MVL offsets are vectors and can be concatenated. They can be written to MVL file directly, or as part of another object such as list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, runif(100), "vec1")
mvl_write_object(Mtmp, runif(100), "vec2")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_fused_write_objects(Mtmp, list(Mtmp["vec1", ref=TRUE], Mtmp["vec2", ref=TRUE], runif(3)),
                                                                                  name="vec3")

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_get_groups'>Retrieve indices belonging to one or more groups</h2><span id='topic+mvl_get_groups'></span>

<h3>Description</h3>

<p>This function is passed the <code>prev</code> vector computed by <code>mvl_write_groups</code> and one or more indices from the <code>first</code> vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_get_groups(prev, first_indices)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_get_groups_+3A_prev">prev</code></td>
<td>
<p>MVL_OBJECT <code>prev</code> computed by <code>mvl_write_groups</code></p>
</td></tr>
<tr><td><code id="mvl_get_groups_+3A_first_indices">first_indices</code></td>
<td>
<p>indices from <code>first</code> vector computed by <code>mvl_write_groups</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of indices
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_group">mvl_group</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, data.frame(x=runif(100), y=1:100), "df1")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_write_groups(Mtmp, list(Mtmp$df1[,"x",ref=TRUE], Mtmp$df1[,"y", ref=TRUE]), "df1_groups")
Mtmp&lt;-mvl_remap(Mtmp)
print(mvl_get_groups(Mtmp["df1_groups", ref=TRUE]["prev", ref=TRUE], Mtmp$df1_groups$first[1:5]))

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_get_neighbors'>Retrieve indices of nearby rows.</h2><span id='topic+mvl_get_neighbors'></span>

<h3>Description</h3>

<p>This function is passed the index computed by <code>mvl_write_spatial_index1</code> and a list of vectors, which rows are interpreted as points.
For each row, the function returns a vector of indices describing rows that are close to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_get_neighbors(spatial_index, data_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_get_neighbors_+3A_spatial_index">spatial_index</code></td>
<td>
<p>MVL_OBJECT computed by <code>mvl_write_spatial_index1</code></p>
</td></tr>
<tr><td><code id="mvl_get_neighbors_+3A_data_list">data_list</code></td>
<td>
<p>a list of vectors of equal length. They can be MVL_OBJECTs or R vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of vectors of indices
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_write_spatial_index1">mvl_write_spatial_index1</a></code>, <code><a href="#topic+mvl_index_lapply">mvl_index_lapply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, data.frame(x=runif(100), y=1:100), "df1")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_write_spatial_index1(Mtmp, list(Mtmp$df1[,"x",ref=TRUE], Mtmp$df1[,"y", ref=TRUE]),
                                                              c(2, 3), "df1_sp_groups")
Mtmp&lt;-mvl_remap(Mtmp)
print(mvl_get_neighbors(Mtmp["df1_sp_groups", ref=TRUE], list(c(0.5, 0.6), c(2, 3))))

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_group'>Group identical rows</h2><span id='topic+mvl_group'></span>

<h3>Description</h3>

<p>This function groups identical rows. The result is formatted as two vectors <code>stretch_index</code> and <code>index</code>
Vector <code>index</code> contains stretches of indices with identical rows. Vector <code>stretch_index</code> describes stretches as stretch_index[i] to stretch_index[i+1]-1
This allows fast iteration over indices without creating excessive numbers of R objects when group sizes are small.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_group(L, indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_group_+3A_l">L</code></td>
<td>
<p>list of vector like MVL_OBJECTs</p>
</td></tr>
<tr><td><code id="mvl_group_+3A_indices">indices</code></td>
<td>
<p>list of indices into objects to group. If absent or NULL it is assumed to be from 1 to the length of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of groups and group stretches
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_group_lapply">mvl_group_lapply</a></code>, <code><a href="#topic+mvl_hash_vectors">mvl_hash_vectors</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_order_vectors">mvl_order_vectors</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_indexed_copy">mvl_indexed_copy</a></code>, <code><a href="#topic+mvl_merge">mvl_merge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, data.frame(x=rep(c("a", "b"), 50), y=(1:100)/5), "df1")
Mtmp&lt;-mvl_remap(Mtmp)
df1&lt;-Mtmp["df1", ref=TRUE]
G&lt;-mvl_group(list(df1[,"x",ref=TRUE], df1[,"y", ref=TRUE]))
mvl_group_lapply(G, function(idx) { return(sum(df1[idx, "y"]))})

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_group_lapply'>Apply function to index stretches</h2><span id='topic+mvl_group_lapply'></span>

<h3>Description</h3>

<p>Iteratively call function <code>fn(idx)</code> over index stretches previously computed with <code>mvl_group</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_group_lapply(G, fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_group_lapply_+3A_g">G</code></td>
<td>
<p>a list of groups and group stretches produced by <code>mvl_group</code></p>
</td></tr>
<tr><td><code id="mvl_group_lapply_+3A_fn">fn</code></td>
<td>
<p>a function of one argument - list of indices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of results of function <code>fn</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_group">mvl_group</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, data.frame(x=rep(c("a", "b"), 50), y=(1:100)/5), "df1")
Mtmp&lt;-mvl_remap(Mtmp)
df1&lt;-Mtmp$df1
G&lt;-mvl_group(list(df1[,"x",ref=TRUE], df1[,"y", ref=TRUE]))
mvl_group_lapply(G, function(idx) { return(sum(df1[idx, "y"]))})

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_hash_vectors'>Return hash values for each row</h2><span id='topic+mvl_hash_vectors'></span>

<h3>Description</h3>

<p>This function is passed a list of MVL vectors which are interpreted in data.frame fashion. For each row, i.e. set of vector values with the same index
we compute a hash value. Identical rows produce identical hash values. The hash values have good entropy and can be used to map row values into random numbers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_hash_vectors(L, indices = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_hash_vectors_+3A_l">L</code></td>
<td>
<p>list of vector like MVL_OBJECTs</p>
</td></tr>
<tr><td><code id="mvl_hash_vectors_+3A_indices">indices</code></td>
<td>
<p>list of indices into objects to sort. If absent or NULL it is assumed to be from 1 to the length of the object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>hash values in numeric format, with 52 valid bits. Each value is uniform between 1 and 2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_order_vectors">mvl_order_vectors</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_group">mvl_group</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_indexed_copy">mvl_indexed_copy</a></code>, <code><a href="#topic+mvl_merge">mvl_merge</a></code>, <code><a href="#topic+mvl_write_hash_vectors">mvl_write_hash_vectors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, runif(100), "vec1")
Mtmp&lt;-mvl_remap(Mtmp)
hash1&lt;-mvl_hash_vectors(list(Mtmp["vec1", ref=TRUE]))

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_index_lapply'>Apply function to indices of nearby rows</h2><span id='topic+mvl_index_lapply'></span>

<h3>Description</h3>

<p>This function is passed the index computed by <code>mvl_write_spatial_index1</code> or <code>mvl_write_extent_index</code> and a list of vectors, which are interpreted in a data frame fashion, or an R data.frame.
For each row we retrieve that set of indices that matches it and call function fn(i, idx) with index i of row being processed and vector idx listing matched indices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_index_lapply(index, data_list, fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_index_lapply_+3A_index">index</code></td>
<td>
<p>MVL_OBJECT computed by <code>mvl_write_spatial_index1</code> or <code>mvl_write_extent_index</code></p>
</td></tr>
<tr><td><code id="mvl_index_lapply_+3A_data_list">data_list</code></td>
<td>
<p>a list of vectors of equal length. They can be MVL_OBJECTs or R vectors, or a data.fame.</p>
</td></tr>
<tr><td><code id="mvl_index_lapply_+3A_fn">fn</code></td>
<td>
<p>a function of two arguments - and index into <code>data_list</code> and a corresponding list of indices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The notion of &quot;matched indices&quot; is specific to the type of index being used.
</p>
<p>For an index created with <code>mvl_write_spatial_index1</code> we return the indices of nearby rows. The user should apply an additional cut to narrow down to actual indices needed.
</p>
<p>For an index created with <code>mvl_write_extent_index</code> we return the indices of rows with identical hashes. Even though 64-bit hashes produce very few collisions, it is recommended to apply additional cut to ensure that only the exactly matching rows are returned.
</p>


<h3>Value</h3>

<p>a list of results of function <code>fn</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_group">mvl_group</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, data.frame(x=runif(100), y=1:100), "df1")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_write_spatial_index1(Mtmp, list(Mtmp$df1[,"x",ref=TRUE], Mtmp$df1[,"y", ref=TRUE]),
                                                               c(2, 3), "df1_sp_groups")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_index_lapply(Mtmp["df1_sp_groups", ref=TRUE], list(c(0.5, 0.6), c(2, 3)),
                                           function(i, idx) { return(list(i, idx))})

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_indexed_copy'>Index copy vector</h2><span id='topic+mvl_indexed_copy'></span>

<h3>Description</h3>

<p>This function creates new MVL vectors and data frames by copying only rows or values specified by given indices. 
The vector indices can be an R integer or numeric vector, a logical vector of the size matching to the object being copied, 
or a suitable vector stored in MVL file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_indexed_copy(MVLHANDLE, x, indices, name = NULL, only.columns = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_indexed_copy_+3A_mvlhandle">MVLHANDLE</code></td>
<td>
<p>a handle to MVL file produced by mvl_open()</p>
</td></tr>
<tr><td><code id="mvl_indexed_copy_+3A_x">x</code></td>
<td>
<p>a vector-like MVL_OBJECT or a data.frame stored in MVL file</p>
</td></tr>
<tr><td><code id="mvl_indexed_copy_+3A_indices">indices</code></td>
<td>
<p>a vector of indices into x</p>
</td></tr>
<tr><td><code id="mvl_indexed_copy_+3A_name">name</code></td>
<td>
<p>if specified add a named entry to MVL file directory</p>
</td></tr>
<tr><td><code id="mvl_indexed_copy_+3A_only.columns">only.columns</code></td>
<td>
<p>if x is MVL_OBJECT with class data.frame copy only columns specified in this character or integer vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class MVL_OFFSET that describes an offset into this MVL file. MVL offsets are vectors and can be concatenated. They can be written to MVL file directly, or as part of another object such as list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_hash_vectors">mvl_hash_vectors</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_group">mvl_group</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_order_vectors">mvl_order_vectors</a></code>, <code><a href="#topic+mvl_merge">mvl_merge</a></code>, <code><a href="#topic+mvl_write_object">mvl_write_object</a></code>, <code><a href="#topic+mvl_fused_write_objects">mvl_fused_write_objects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, runif(100), "vec1")
Mtmp&lt;-mvl_remap(Mtmp)
permutation1&lt;-mvl_order_vectors(list(Mtmp["vec1", ref=TRUE]))
mvl_indexed_copy(Mtmp, Mtmp["vec1", ref=TRUE], permutation1, name="vec1_sorted")
Mtmp&lt;-mvl_remap(Mtmp)
print(Mtmp$vec1_sorted)

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_inherits'>Check inheritance of R or MVL objects</h2><span id='topic+mvl_inherits'></span>

<h3>Description</h3>

<p>This function works just like the usual R <code>inherits()</code>, except that for MVL_OBJECTS it used the class value stored in the MVL file.
For non-MVL objects the function simply calls the usual R <code>inherit()</code>, so it can be used instead of <code>inherit()</code> for code that operates on both usual R objects and MVL objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_inherits(x, clstr, which = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_inherits_+3A_x">x</code></td>
<td>
<p>any object</p>
</td></tr>
<tr><td><code id="mvl_inherits_+3A_clstr">clstr</code></td>
<td>
<p>classes to match against</p>
</td></tr>
<tr><td><code id="mvl_inherits_+3A_which">which</code></td>
<td>
<p>when TRUE return a boolean array indicating of which classes named in <code>clstr</code> are inherited by x. When FALSE return a single boolean indicating inheritance of any class named in <code>clstr</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character string giving object class
</p>

<hr>
<h2 id='mvl_merge'>Merge two MVL data frames and write the result</h2><span id='topic+mvl_merge'></span>

<h3>Description</h3>

<p>Merge two MVL data frames and write the result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_merge(
  MVLHANDLE,
  df1,
  df2,
  name = NULL,
  by = NULL,
  by.x = by,
  by.y = by,
  suffixes = c(".x", ".y"),
  only.columns.x = NULL,
  only.columns.y = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_merge_+3A_mvlhandle">MVLHANDLE</code></td>
<td>
<p>a handle to MVL file produced by <code>mvl_open()</code></p>
</td></tr>
<tr><td><code id="mvl_merge_+3A_df1">df1</code></td>
<td>
<p>a data.frame stored in MVL file</p>
</td></tr>
<tr><td><code id="mvl_merge_+3A_df2">df2</code></td>
<td>
<p>a data.frame stored in MVL file</p>
</td></tr>
<tr><td><code id="mvl_merge_+3A_name">name</code></td>
<td>
<p>if specified add a named entry to MVL file directory</p>
</td></tr>
<tr><td><code id="mvl_merge_+3A_by">by</code></td>
<td>
<p>list of columns to use as key</p>
</td></tr>
<tr><td><code id="mvl_merge_+3A_by.x">by.x</code></td>
<td>
<p>list of columns to use as key for <code>df1</code></p>
</td></tr>
<tr><td><code id="mvl_merge_+3A_by.y">by.y</code></td>
<td>
<p>list of columns to use as key for <code>df1</code></p>
</td></tr>
<tr><td><code id="mvl_merge_+3A_suffixes">suffixes</code></td>
<td>
<p>rename columns with identical names using these suffixes</p>
</td></tr>
<tr><td><code id="mvl_merge_+3A_only.columns.x">only.columns.x</code></td>
<td>
<p>only copy these columns from df1</p>
</td></tr>
<tr><td><code id="mvl_merge_+3A_only.columns.y">only.columns.y</code></td>
<td>
<p>only copy these columns from df2</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class MVL_OFFSET that describes an offset into this MVL file. MVL offsets are vectors and can be concatenated. They can be written to MVL file directly, or as part of another object such as list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_hash_vectors">mvl_hash_vectors</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_group">mvl_group</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_indexed_copy">mvl_indexed_copy</a></code>, <code><a href="#topic+mvl_order_vectors">mvl_order_vectors</a></code>, <code><a href="#topic+mvl_fused_write_objects">mvl_fused_write_objects</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, data.frame(x=rep(c("a", "b"), 50), y=1:100), "df1")
mvl_write_object(Mtmp, data.frame(x=rep(c("b", "c"), 50), y=runif(100), z=21:120), "df2")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_merge(Mtmp, Mtmp$df1, Mtmp$df2, by.x="y", by.y="z", only.columns.y=c("x"), name="df_merged")
Mtmp&lt;-mvl_remap(Mtmp)
print(Mtmp$df_merged[1:10,])

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_neighbors_lapply'>Apply function to indices of nearby rows</h2><span id='topic+mvl_neighbors_lapply'></span>

<h3>Description</h3>

<p>Please use generic function <code>mvl_index_lapply()</code> instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_neighbors_lapply(spatial_index, data_list, fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_neighbors_lapply_+3A_spatial_index">spatial_index</code></td>
<td>
<p>MVL_OBJECT computed by <code>mvl_write_spatial_index1</code></p>
</td></tr>
<tr><td><code id="mvl_neighbors_lapply_+3A_data_list">data_list</code></td>
<td>
<p>a list of vectors of equal length. They can be MVL_OBJECTs or R vectors.</p>
</td></tr>
<tr><td><code id="mvl_neighbors_lapply_+3A_fn">fn</code></td>
<td>
<p>a function of two arguments - and index into <code>data_list</code> and a corresponding list of indices</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is passed the index computed by <code>mvl_write_spatial_index1</code> and a list of vectors, which rows are interpreted as points.
For each row, we call the function <code>fn(i, idx)</code>, where <code>i</code> gives the index of query row, and <code>idx</code> gives the indices of nearby rows.
</p>


<h3>Value</h3>

<p>a list of results of function <code>fn</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_group">mvl_group</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, data.frame(x=runif(100), y=1:100), "df1")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_write_spatial_index1(Mtmp, list(Mtmp$df1[,"x",ref=TRUE], Mtmp$df1[,"y", ref=TRUE]),
                                                               c(2, 3), "df1_sp_groups")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_neighbors_lapply(Mtmp["df1_sp_groups", ref=TRUE], list(c(0.5, 0.6), c(2, 3)),
                                           function(i, idx) { return(list(i, idx))})

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_object_stats'>Return MVL object properties</h2><span id='topic+mvl_object_stats'></span>

<h3>Description</h3>

<p>Provide detailed information on stored MVL object without retrieving it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_object_stats(MVLHANDLE, offset = NULL, scan = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_object_stats_+3A_mvlhandle">MVLHANDLE</code></td>
<td>
<p>either a handle provided by mvl_open() or an MVL object such as produced by indexing operators</p>
</td></tr>
<tr><td><code id="mvl_object_stats_+3A_offset">offset</code></td>
<td>
<p>offset to the object which properties are to be retrieved</p>
</td></tr>
<tr><td><code id="mvl_object_stats_+3A_scan">scan</code></td>
<td>
<p>scan vector element to obtain additional statistics</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is given either an MVL handle and an offset in MVL file to examine, or just a single parameter of class MVL_OBJECT that contains
both handle and offset
</p>
<p>This function returns a list of object parameters describing total number of elements, element type (as used by libMVL) and a pointer to the underlying data.
The pointer is passed via a cast to double to preserve its 64-bit value and can be used with custom C code, for example by using package inline.
</p>


<h3>Value</h3>

<p>list with object properties
</p>

<hr>
<h2 id='mvl_open'>Open an MVL file</h2><span id='topic+mvl_open'></span>

<h3>Description</h3>

<p>Open an MVL format file for reading and/or writing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_open(filename, append = FALSE, create = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_open_+3A_filename">filename</code></td>
<td>
<p>path to file.</p>
</td></tr>
<tr><td><code id="mvl_open_+3A_append">append</code></td>
<td>
<p>specify TRUE when you intend to write data into the file</p>
</td></tr>
<tr><td><code id="mvl_open_+3A_create">create</code></td>
<td>
<p>when TRUE create file if it did not exist</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MVL stands for &quot;Mapped vector library&quot; and is a file format designed for efficient memory mapped access. 
An MVL file can be much larger than physical memory of the machine.
</p>
<p><code>mvl_open</code> returns a handle that can be used to access MVL files. Files opened read-only are memory mapped and do not use a file descriptor, and thus are not
subject to limits on the number of open files.
Files opened for writing data do use a file descriptor.
Once opened for read access the data can be accessed using usual R semantics for lists, data.frames and arrays.
</p>


<h3>Value</h3>

<p>handle to opened MVL file
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_close">mvl_close</a></code>, <code><a href="#topic+mvl_remap">mvl_remap</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
M1&lt;-mvl_open("test1.mvl", append=TRUE, create=TRUE)
mvl_write_object(M1, data.frame(x=1:2, y=rnorm(2)), "test_frame")
mvl_close(M1)

M2&lt;-mvl_open("test1.mvl")
print(names(M2))
print(M2["test_frame"])
mvl_close(M2)

M3&lt;-mvl_open("test2.mvl", append=TRUE, create=TRUE)
L&lt;-list()
df&lt;-data.frame(x=1:1e6, y=rnorm(1e6), s=rep(c("a", "b"), 5e5))
L[["x"]]&lt;-mvl_write_object(M3, df, drop.rownames=TRUE)
L[["description"]]&lt;-"Example of large data frame"
mvl_write_object(M3, L, "test_object")
mvl_close(M3)

M4&lt;-mvl_open("test2.mvl")
print(names(M4))
L&lt;-M4["test_object"]
print(L)
print(L[["x"]][1:20,])
mvl_object_stats(L[["x"]])
# If you need to get the whole x, one can use mvl2R(L[["x"]])
mvl_close(M4)

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_order_vectors'>Return permutation sorting vector entries</h2><span id='topic+mvl_order_vectors'></span>

<h3>Description</h3>

<p>This function is similar to R  order() function, but operates on MVL_OBJECTS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_order_vectors(
  L,
  indices = NULL,
  decreasing = FALSE,
  sort_function = ifelse(decreasing, 2, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_order_vectors_+3A_l">L</code></td>
<td>
<p>list of vector like MVL_OBJECTs</p>
</td></tr>
<tr><td><code id="mvl_order_vectors_+3A_indices">indices</code></td>
<td>
<p>list of indices into objects to sort. If absent or NULL it is assumed to be from 1 to length of the object.</p>
</td></tr>
<tr><td><code id="mvl_order_vectors_+3A_decreasing">decreasing</code></td>
<td>
<p>whether to sort in ascending or decreasing order. This parameter is provided for compatibility with <code>order()</code> function</p>
</td></tr>
<tr><td><code id="mvl_order_vectors_+3A_sort_function">sort_function</code></td>
<td>
<p>specifies desired sort order</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sorted indices
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_hash_vectors">mvl_hash_vectors</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_group">mvl_group</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_indexed_copy">mvl_indexed_copy</a></code>, <code><a href="#topic+mvl_merge">mvl_merge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, runif(100), "vec1")
Mtmp&lt;-mvl_remap(Mtmp)
permutation1&lt;-mvl_order_vectors(list(Mtmp["vec1", ref=TRUE]))

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_remap'>Enlarge memory map to include recently loaded data.</h2><span id='topic+mvl_remap'></span>

<h3>Description</h3>

<p>This function operates on MVL files opened for writing. When writing new data to the MVL file that data is appended at the end and past the end of previously mapped data. 
Calling <code>mvl_remap()</code> updates the memory mapping to include all the data written before mvl_remap() was called.
The MVL file directory is also updated to include recently added entries.  Old handles can still be used, but will not include updated directory information.
MVL_OBJECT's previously obtained from this handle continue to be valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_remap(MVLHANDLE, append = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_remap_+3A_mvlhandle">MVLHANDLE</code></td>
<td>
<p>handle to opened MVL file as generated by <code>mvl_open()</code> or <code>mvl_remap()</code></p>
</td></tr>
<tr><td><code id="mvl_remap_+3A_append">append</code></td>
<td>
<p>specify FALSE when you do not intend to write the file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mvl_remap</code> returns a handle with updated directory.
</p>


<h3>Value</h3>

<p>handle to MVL file, with updated directory.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_open">mvl_open</a></code>, <code><a href="#topic+mvl_close">mvl_close</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, runif(100), "vec1")
Mtmp&lt;-mvl_remap(Mtmp)
print(Mtmp["vec1"])

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_start_write_vector'>Piecewise output of very long numeric and integer vectors</h2><span id='topic+mvl_start_write_vector'></span><span id='topic+mvl_rewrite_vector'></span>

<h3>Description</h3>

<p>While <code>mvl_fused_write_objects</code> can be used to create very large vectors and data frames of arbitrary type, it requires
piecewise data to be written first into an MVL file. Functions <code>mvl_start_write_vector()</code> and <code>mvl_rewrite_vector()</code> provide a way to create very long vectors in one pass.
Only numeric and integer vectors are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_start_write_vector(MVLHANDLE, x, expected.length = NULL, name = NULL)

mvl_rewrite_vector(obj, offset, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_start_write_vector_+3A_mvlhandle">MVLHANDLE</code></td>
<td>
<p>handle to opened MVL file as generated by mvl_open()</p>
</td></tr>
<tr><td><code id="mvl_start_write_vector_+3A_x">x</code></td>
<td>
<p>an integer or numeric vector</p>
</td></tr>
<tr><td><code id="mvl_start_write_vector_+3A_expected.length">expected.length</code></td>
<td>
<p>the length of vector to create. Use double to pass large values</p>
</td></tr>
<tr><td><code id="mvl_start_write_vector_+3A_name">name</code></td>
<td>
<p>if specified add a named entry to MVL file directory</p>
</td></tr>
<tr><td><code id="mvl_start_write_vector_+3A_obj">obj</code></td>
<td>
<p>an MVL vector object to modify</p>
</td></tr>
<tr><td><code id="mvl_start_write_vector_+3A_offset">offset</code></td>
<td>
<p>the offset into MVL vector (starting with 1) to write x</p>
</td></tr>
</table>


<h3>Details</h3>

<p>One convenient use is to compute <code>f(x,y,z,...)</code> with very long vector arguments by iterating over indices. The iteration can be done using fixed blocks of indices, or by using groups of indices computed with other MVL functions. 
</p>
<p>It is generally recommended to call <code>mvl_rewrite_vector()</code> with large blocks to improve I/O performance and reduce number of writes to underlying media.
</p>


<h3>See Also</h3>

<p>mvl_fused_write_objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
offset&lt;-mvl_start_write_object(Mtmp, runif(10), expected.length=1000, "vec1")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_rewrite_vector(Mtmp[offset], 50, rnorm(20))

## End(Not run)


</code></pre>

<hr>
<h2 id='mvl_status'>Return status of MVL package</h2><span id='topic+mvl_status'></span>

<h3>Description</h3>

<p>Return status of MVL package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_status()
</code></pre>


<h3>Value</h3>

<p>list of status values
</p>

<hr>
<h2 id='mvl_write_extent_index'>Compute and write extent index</h2><span id='topic+mvl_write_extent_index'></span>

<h3>Description</h3>

<p>This function computes a hash-based index that allows to find indices of rows which hashes match query values.
While it can be applied to arbitrary data, it is optimized for the common case when vectors contain stretches of repeated values
describing row groups to be processed. This is particularly relevant for R because vectorized processing of row batches is the only practical way to scan very large tables using pure-R code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_write_extent_index(MVLHANDLE, L, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_write_extent_index_+3A_mvlhandle">MVLHANDLE</code></td>
<td>
<p>a handle to MVL file produced by mvl_open()</p>
</td></tr>
<tr><td><code id="mvl_write_extent_index_+3A_l">L</code></td>
<td>
<p>list of vector like MVL_OBJECTs</p>
</td></tr>
<tr><td><code id="mvl_write_extent_index_+3A_name">name</code></td>
<td>
<p>if specified add a named entry to MVL file directory</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mvl_write_extent_index()</code> creates the index in memory and then writes it out. The memory usage is proportional to the number of 
repeat stretches. Sorting tables improves performance, but is not a requirement.
</p>


<h3>Value</h3>

<p>an object of class MVL_OFFSET that describes an offset into this MVL file. MVL offsets are vectors and can be concatenated. They can be written to MVL file directly, or as part of another object such as list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_order_vectors">mvl_order_vectors</a></code>, <code><a href="#topic+mvl_index_lapply">mvl_index_lapply</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_group">mvl_group</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_indexed_copy">mvl_indexed_copy</a></code>, <code><a href="#topic+mvl_merge">mvl_merge</a></code>, <code><a href="#topic+mvl_hash_vectors">mvl_hash_vectors</a></code>, <code><a href="#topic+mvl_get_groups">mvl_get_groups</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, data.frame(x=runif(100), y=(1:100) %% 10), "df1")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_write_extent_index(Mtmp, list(Mtmp$df1[,"y",ref=TRUE]), "df1_extent_index_y")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_index_lapply(Mtmp["df1_extent_index_y", ref=TRUE], list(c(2, 3)),
                                           function(i, idx) { return(list(i, idx))})
# Example of full scan
mvl_index_lapply(Mtmp["df1_extent_index_y", ref=TRUE], ,
                                           function(i, idx) { return(list(i, idx))})

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_write_groups'>Write group information for each row</h2><span id='topic+mvl_write_groups'></span>

<h3>Description</h3>

<p>This function is passed a list of MVL vectors which are interpreted in data.frame fashion. These rows 
are split into groups so that identical rows are guaranteed to belong to the same group. This is done internally based on 20-bit hash values.
This function is convenient to use as a way to partition very large datasets before applying <code>mvl_group</code> or <code>mvl_find_matches</code>. 
The groups can be obtained by using <code>mvl_get_groups</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_write_groups(MVLHANDLE, L, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_write_groups_+3A_mvlhandle">MVLHANDLE</code></td>
<td>
<p>a handle to MVL file produced by mvl_open()</p>
</td></tr>
<tr><td><code id="mvl_write_groups_+3A_l">L</code></td>
<td>
<p>list of vector like MVL_OBJECTs</p>
</td></tr>
<tr><td><code id="mvl_write_groups_+3A_name">name</code></td>
<td>
<p>if specified add a named entry to MVL file directory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class MVL_OFFSET that describes an offset into this MVL file. MVL offsets are vectors and can be concatenated. They can be written to MVL file directly, or as part of another object such as list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_order_vectors">mvl_order_vectors</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_group">mvl_group</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_indexed_copy">mvl_indexed_copy</a></code>, <code><a href="#topic+mvl_merge">mvl_merge</a></code>, <code><a href="#topic+mvl_hash_vectors">mvl_hash_vectors</a></code>, <code><a href="#topic+mvl_get_groups">mvl_get_groups</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, data.frame(x=runif(100), y=1:100), "df1")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_write_groups(Mtmp, list(Mtmp$df1[,"x",ref=TRUE], Mtmp$df1[,"y", ref=TRUE]), "df1_groups")
Mtmp&lt;-mvl_remap(Mtmp)
print(mvl_get_groups(Mtmp["df1_groups", ref=TRUE]["prev", ref=TRUE], Mtmp$df1_groups$first[1:5]))

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_write_hash_vectors'>Write hash values for each row</h2><span id='topic+mvl_write_hash_vectors'></span>

<h3>Description</h3>

<p>This function is passed a list of MVL vectors which are interpreted in data.frame fashion. For each row, i.e. set of vector values with the same index
we compute a 64-bit hash value. Identical rows produce identical hash values. The hash values are written into 64-bit integer vector. 
This function is meant for use with data that is too large to handle comfortably.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_write_hash_vectors(MVLHANDLE, L, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_write_hash_vectors_+3A_mvlhandle">MVLHANDLE</code></td>
<td>
<p>a handle to MVL file produced by mvl_open()</p>
</td></tr>
<tr><td><code id="mvl_write_hash_vectors_+3A_l">L</code></td>
<td>
<p>list of vector like MVL_OBJECTs</p>
</td></tr>
<tr><td><code id="mvl_write_hash_vectors_+3A_name">name</code></td>
<td>
<p>if specified add a named entry to MVL file directory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class MVL_OFFSET that describes an offset into this MVL file. MVL offsets are vectors and can be concatenated. They can be written to MVL file directly, or as part of another object such as list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_order_vectors">mvl_order_vectors</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_group">mvl_group</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_indexed_copy">mvl_indexed_copy</a></code>, <code><a href="#topic+mvl_merge">mvl_merge</a></code>, <code><a href="#topic+mvl_hash_vectors">mvl_hash_vectors</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, runif(100), "vec1")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_write_hash_vectors(Mtmp, list(Mtmp["vec1", ref=TRUE]), "vec1_hash")
Mtmp&lt;-mvl_remap(Mtmp)
print(length(Mtmp["vec1_hash"]))

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_write_object'>Write R object into MVL file</h2><span id='topic+mvl_write_object'></span>

<h3>Description</h3>

<p>Write R object into MVL file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_write_object(MVLHANDLE, x, name = NULL, drop.rownames = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_write_object_+3A_mvlhandle">MVLHANDLE</code></td>
<td>
<p>a handle to MVL file produced by mvl_open()</p>
</td></tr>
<tr><td><code id="mvl_write_object_+3A_x">x</code></td>
<td>
<p>a suitable R object (vector, array, list, data.frame) or a vector-like MVL_OBJECT</p>
</td></tr>
<tr><td><code id="mvl_write_object_+3A_name">name</code></td>
<td>
<p>if specified add a named entry to MVL file directory</p>
</td></tr>
<tr><td><code id="mvl_write_object_+3A_drop.rownames">drop.rownames</code></td>
<td>
<p>set to TRUE to prevent rownames from being written</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class MVL_OFFSET that describes an offset into this MVL file. MVL offsets are vectors and can be concatenated. They can be written to MVL file directly, or as part of another object such as list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_indexed_copy">mvl_indexed_copy</a></code>, <code><a href="#topic+mvl_merge">mvl_merge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, runif(100), "vec1")
L&lt;-list()
L[["x"]]&lt;-mvl_write_object(Mtmp, 1:5)
L[["y"]]&lt;-mvl_write_object(Mtmp, c("a", "b"))
L[["df"]]&lt;-mvl_write_object(Mtmp, data.frame(x=1:100, z=runif(100)))
mvl_write_object(Mtmp, L, "L")
Mtmp&lt;-mvl_remap(Mtmp)
print(Mtmp$L)

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_write_serialized_object'>Write R object in serialized form</h2><span id='topic+mvl_write_serialized_object'></span>

<h3>Description</h3>

<p>This function packages the object into a raw vector before writing it out. The raw vector is tagged with 
special class that assures the object is automatically converted back to R representation when reading.
Serialized objects can only be read completely.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_write_serialized_object(MVLHANDLE, x, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_write_serialized_object_+3A_mvlhandle">MVLHANDLE</code></td>
<td>
<p>a handle to MVL file produced by mvl_open()</p>
</td></tr>
<tr><td><code id="mvl_write_serialized_object_+3A_x">x</code></td>
<td>
<p>a suitable R object (vector, array, list, data.frame) or a vector-like MVL_OBJECT</p>
</td></tr>
<tr><td><code id="mvl_write_serialized_object_+3A_name">name</code></td>
<td>
<p>if specified add a named entry to MVL file directory</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used in rare cases when it is important to store a complete R object, but it is not
important for it to be accessible by other programs, and it is not important to conserve memory or bandwidth.
</p>


<h3>Value</h3>

<p>an object of class MVL_OFFSET that describes an offset into this MVL file. MVL offsets are vectors and can be concatenated. They can be written to MVL file directly, or as part of another object such as list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_write_object">mvl_write_object</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_serialized_object(Mtmp, lm(rnorm(100)~runif(100)), "LM1")
Mtmp&lt;-mvl_remap(Mtmp)
print(mvl2R(Mtmp$LM1))

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_write_spatial_groups'>Write spatial group information for each row</h2><span id='topic+mvl_write_spatial_groups'></span>

<h3>Description</h3>

<p>Please use mvl_write_spatial_index1() instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_write_spatial_groups(MVLHANDLE, L, bits, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_write_spatial_groups_+3A_mvlhandle">MVLHANDLE</code></td>
<td>
<p>a handle to MVL file produced by mvl_open()</p>
</td></tr>
<tr><td><code id="mvl_write_spatial_groups_+3A_l">L</code></td>
<td>
<p>list of vector like MVL_OBJECTs</p>
</td></tr>
<tr><td><code id="mvl_write_spatial_groups_+3A_bits">bits</code></td>
<td>
<p>a vector of bit values to use for each member of L</p>
</td></tr>
<tr><td><code id="mvl_write_spatial_groups_+3A_name">name</code></td>
<td>
<p>if specified add a named entry to MVL file directory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class MVL_OFFSET that describes an offset into this MVL file. MVL offsets are vectors and can be concatenated. They can be written to MVL file directly, or as part of another object such as list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_order_vectors">mvl_order_vectors</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_group">mvl_group</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_indexed_copy">mvl_indexed_copy</a></code>, <code><a href="#topic+mvl_merge">mvl_merge</a></code>, <code><a href="#topic+mvl_hash_vectors">mvl_hash_vectors</a></code>, <code><a href="#topic+mvl_get_groups">mvl_get_groups</a></code>
</p>

<hr>
<h2 id='mvl_write_spatial_index1'>Write spatial group information for each row</h2><span id='topic+mvl_write_spatial_index1'></span>

<h3>Description</h3>

<p>This function is passed a list of MVL vectors which are interpreted in data.frame fashion. These rows 
are split into groups so that identical rows are guaranteed to belong to the same group. This is done using partition into equal sized bins.
This function is meant for constructing spatial indexes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_write_spatial_index1(MVLHANDLE, L, bits, name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_write_spatial_index1_+3A_mvlhandle">MVLHANDLE</code></td>
<td>
<p>a handle to MVL file produced by mvl_open()</p>
</td></tr>
<tr><td><code id="mvl_write_spatial_index1_+3A_l">L</code></td>
<td>
<p>list of vector like MVL_OBJECTs</p>
</td></tr>
<tr><td><code id="mvl_write_spatial_index1_+3A_bits">bits</code></td>
<td>
<p>a vector of bit values to use for each member of L</p>
</td></tr>
<tr><td><code id="mvl_write_spatial_index1_+3A_name">name</code></td>
<td>
<p>if specified add a named entry to MVL file directory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class MVL_OFFSET that describes an offset into this MVL file. MVL offsets are vectors and can be concatenated. They can be written to MVL file directly, or as part of another object such as list.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvl_order_vectors">mvl_order_vectors</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_group">mvl_group</a></code>, <code><a href="#topic+mvl_find_matches">mvl_find_matches</a></code>, <code><a href="#topic+mvl_indexed_copy">mvl_indexed_copy</a></code>, <code><a href="#topic+mvl_merge">mvl_merge</a></code>, <code><a href="#topic+mvl_hash_vectors">mvl_hash_vectors</a></code>, <code><a href="#topic+mvl_get_groups">mvl_get_groups</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Mtmp&lt;-mvl_open("tmp_a.mvl", append=TRUE, create=TRUE)
mvl_write_object(Mtmp, data.frame(x=runif(100), y=1:100), "df1")
Mtmp&lt;-mvl_remap(Mtmp)
mvl_write_spatial_index1(Mtmp, list(Mtmp$df1[,"x",ref=TRUE], Mtmp$df1[,"y", ref=TRUE]),
                                                             c(2, 3), "df1_sp_groups")
Mtmp&lt;-mvl_remap(Mtmp)
print(mvl_get_neighbors(Mtmp["df1_sp_groups", ref=TRUE], list(c(0.5, 0.6), c(2, 3))))

## End(Not run)
</code></pre>

<hr>
<h2 id='mvl_xlength'>Return length of MVL or R vector as a numeric value</h2><span id='topic+mvl_xlength'></span>

<h3>Description</h3>

<p>Internally this calls R function xlength() rather than length(). This allows to obtain length of larger vectors. For MVL vectors this returns the length of the vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl_xlength(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl_xlength_+3A_x">x</code></td>
<td>
<p>any R object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>length of object as as numeric value
</p>

<hr>
<h2 id='mvl2R'>Make sure the object is fully converted to its R representation</h2><span id='topic+mvl2R'></span>

<h3>Description</h3>

<p>If the object is stored in MVL file, we return its pure R representation. 
Otherwise, we return the object itself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvl2R(obj, raw = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvl2R_+3A_obj">obj</code></td>
<td>
<p>- MVL object retrieved by subscription of MVL library or other objects</p>
</td></tr>
<tr><td><code id="mvl2R_+3A_raw">raw</code></td>
<td>
<p>- request to return data in raw format when it does not map exactly to R data types.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Stored object
</p>

<hr>
<h2 id='names.MVL'>Print MVL directory</h2><span id='topic+names.MVL'></span>

<h3>Description</h3>

<p>Print MVL directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MVL'
names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names.MVL_+3A_x">x</code></td>
<td>
<p>handle to MVL file as created by <code>mvl_open</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of names present in the directory
</p>

<hr>
<h2 id='names.MVL_OBJECT'>Retrieve MVL object names</h2><span id='topic+names.MVL_OBJECT'></span>

<h3>Description</h3>

<p>Retrieve MVL object names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MVL_OBJECT'
names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="names.MVL_OBJECT_+3A_x">x</code></td>
<td>
<p>MVL_OBJECT as retrieved by subscription operators</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector of names
</p>

<hr>
<h2 id='print.MVL'>Print MVL</h2><span id='topic+print.MVL'></span>

<h3>Description</h3>

<p>Print MVL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MVL'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.MVL_+3A_x">x</code></td>
<td>
<p>handle to MVL file as created by <code>mvl_open</code></p>
</td></tr>
<tr><td><code id="print.MVL_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible(MVLHANDLE)
</p>

<hr>
<h2 id='print.MVL_OBJECT'>Print MVL object
This is a convenience function for displaying MVL_OBJECTs.</h2><span id='topic+print.MVL_OBJECT'></span>

<h3>Description</h3>

<p>Print MVL object
This is a convenience function for displaying MVL_OBJECTs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MVL_OBJECT'
print(x, ..., small_length = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.MVL_OBJECT_+3A_x">x</code></td>
<td>
<p>MVL_OBJECT as retrieved by subscription operators</p>
</td></tr>
<tr><td><code id="print.MVL_OBJECT_+3A_small_length">small_length</code></td>
<td>
<p>do not list more than this number of columns in data frames</p>
</td></tr>
<tr><td><code id="print.MVL_OBJECT_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible(obj)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
