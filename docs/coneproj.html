<!DOCTYPE html><html lang="en"><head><title>Help for package coneproj</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {coneproj}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_irred'>
<p>Routine for Checking Irreducibility</p></a></li>
<li><a href='#conc'><p>Specify a Concave Shape-Restriction in a SHAPEREG Formula</p></a></li>
<li><a href='#coneA'><p>Cone Projection &ndash; Polar Cone</p></a></li>
<li><a href='#coneB'><p>Cone Projection &ndash; Constraint Cone</p></a></li>
<li><a href='#constreg'><p>Constrained Parametric Regression</p></a></li>
<li><a href='#conv'><p>Specify a Convex Shape-Restriction in a SHAPEREG Formula</p></a></li>
<li><a href='#cubic'><p>A Data Set for the Example of the Qprog Function</p></a></li>
<li><a href='#decr'><p>Specify a Decreasing Shape-Restriction in a SHAPEREG Formula</p></a></li>
<li><a href='#decr.conc'><p>Specify a Decreasing and Concave Shape-Restriction in a SHAPEREG Formula</p></a></li>
<li><a href='#decr.conv'><p>Specify a Decreasing and Convex Shape-Restriction in a SHAPEREG Formula</p></a></li>
<li><a href='#feet'><p>Foot Measurements for Fourth Grade Children</p></a></li>
<li><a href='#FEV'><p>Forced Expiratory Volume</p></a></li>
<li><a href='#incr'><p>Specify an Increasing Shape-Restriction in a SHAPEREG Formula</p></a></li>
<li><a href='#incr.conc'><p>Specify an Increasing and Concave Shape-Restriction in a SHAPEREG Formula</p></a></li>
<li><a href='#incr.conv'><p>Specify an Increasing and Convex Shape-Restriction in a SHAPEREG Formula</p></a></li>
<li><a href='#qprog'><p>Quadratic Programming</p></a></li>
<li><a href='#shapereg'><p>Shape-Restricted Regression</p></a></li>
<li><a href='#TwoDamat'><p>A Two Dimensional Constraint Matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Primal or Dual Cone Projections with Routines for Constrained
Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>1.20</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-02-19</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xiyue Liao &lt;xliao@sdsu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Routines doing cone projection and quadratic programming, as well as doing estimation and inference for constrained parametric regression and shape-restricted regression problems. See Mary C. Meyer (2013)&lt;<a href="https://doi.org/10.1080%2F03610918.2012.659820">doi:10.1080/03610918.2012.659820</a>&gt; for more details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R(&ge; 4.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.10.4)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>RcppArmadillo, Rcpp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Suggests:</td>
<td>stats, graphics, grDevices, utils</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-19 16:11:37 UTC; xliao</td>
</tr>
<tr>
<td>Author:</td>
<td>Mary C. Meyer [aut],
  Xiyue Liao <a href="https://orcid.org/0000-0002-4508-9219"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-19 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_irred'>
Routine for Checking Irreducibility 
</h2><span id='topic+check_irred'></span>

<h3>Description</h3>

<p>This routine checks the irreducibility of a set of edges, which are supposed to form the columns of a matrix. If a column is a positive linear combination of other columns, then it can be removed without affecting the problem; if there is a positive linear combination of columns of the matrix that equals the zero vector, then there is an implicit equality constraint in the matrix. In the former case, this routine delete the redundant columns and return a set of irreducible edges, while in the latter case, this routine will give the number of equality constraints in the matrix, and will leave this issue to the user to fix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_irred(mat)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="check_irred_+3A_mat">mat</code></td>
<td>
<p>A matrix whose columns are edges.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>edge</code></td>
<td>
<p>The edges kept after being checked about irreducibility.</p>
</td></tr>
<tr><td><code>reducible</code></td>
<td>
<p>A vector of the indice of the edges that are redundant in the original set of edges.</p>
</td></tr>
<tr><td><code>equal</code></td>
<td>
<p>A vector showing the number of equality constraints in the original set of edges.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao  
</p>


<h3>References</h3>

<p>Meyer, M. C. (1999) An extension of the mixed primal-dual bases algorithm to the case of more constraints than 
dimensions. <em>Journal of Statistical Planning and Inference <b>81</b></em>, 13&ndash;31.
</p>
<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications
in Statistics <b>42(5)</b></em>, 1126&ndash;1139.  
</p>
<p>Liao, X. and M. C. Meyer (2014) coneproj: An R package for the primal or dual cone projections with routines for constrained regression. <em>Journal of Statistical Software <b>61(12)</b></em>, 1&ndash;22.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  data(TwoDamat)
  dim(TwoDamat)
  ans &lt;- check_irred(t(TwoDamat))
  
## End(Not run)
</code></pre>

<hr>
<h2 id='conc'>Specify a Concave Shape-Restriction in a SHAPEREG Formula</h2><span id='topic+conc'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the mean vector is concave in a predictor in a formula argument to coneproj.</p>


<h3>Usage</h3>

<pre><code class='language-R'>conc(x, numknots = 0, knots = 0, space = "E")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conc_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="conc_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="conc_+3A_knots">knots</code></td>
<td>
<p>The knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="conc_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used for a shape-restricted predictor without smoothing. The default value is &quot;E&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;conc&quot; returns the vector &quot;x&quot; and imposes on it two attributes: name and shape. 
</p>
<p>The shape attribute is 4 (&quot;concave&quot;), and according to the value of the vector itself and this attribute, the cone edges of the cone generated by the constraint matrix, which constrains the relationship between the mean vector and &quot;x&quot; to be concave,  will be made. The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;conc&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in coneproj.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with the shape attribute, i.e., shape: 4 (&quot;concave&quot;).</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x &lt;- seq(-1, 2, by = 0.1)
  n &lt;- length(x)
  y &lt;- - x^2 + rnorm(n, .3)  

  # regress y on x under the shape-restriction: "concave"
  ans &lt;- shapereg(y ~ conc(x))

  # make a plot
  plot(x, y)
  lines(x, fitted(ans), col = 2)
  legend("bottomleft", bty = "n", "shapereg: concave fit", col = 2, lty = 1)
</code></pre>

<hr>
<h2 id='coneA'>Cone Projection &ndash; Polar Cone</h2><span id='topic+coneA'></span>

<h3>Description</h3>

<p>This routine implements the hinge algorithm for cone projection to minimize 
<code class="reqn">||y - \theta||^2</code> over the cone <code class="reqn">C</code> of the form <code class="reqn">\{\theta: A\theta \ge 0\}</code>. </p>


<h3>Usage</h3>

<pre><code class='language-R'>coneA(y, amat, w = NULL, face = NULL, msg = TRUE)  </code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coneA_+3A_y">y</code></td>
<td>
<p>A vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="coneA_+3A_amat">amat</code></td>
<td>
<p>A constraint matrix. The rows of amat must be irreducible. The column number of amat must equal the length of <code class="reqn">y</code>.</p>
</td></tr>
<tr><td><code id="coneA_+3A_w">w</code></td>
<td>
<p>An optional nonnegative vector of weights of length <code class="reqn">n</code>. If w is not given, all weights are taken to equal 1. Otherwise, the minimization of <code class="reqn">(y - \theta)'w(y - \theta)</code> over <code class="reqn">C</code> is returned. The default is w = NULL.</p>
</td></tr>
<tr><td><code id="coneA_+3A_face">face</code></td>
<td>
<p>A vector of the positions of edges, which define the initial face for the cone projection. For example, when there are <code class="reqn">m</code> cone edges, then face is a subset of <code class="reqn">1,\ldots,m</code>. The default is face = NULL.</p>
</td></tr>
<tr><td><code id="coneA_+3A_msg">msg</code></td>
<td>
<p>A logical flag. If msg is TRUE, then a warning message will be printed when there is a non-convergence problem; otherwise no warning message will be printed. The default is msg = TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine coneA dynamically loads a C++ subroutine &quot;coneACpp&quot;. The rows
of <code class="reqn">- A</code> are the edges of the polar cone <code class="reqn">\Omega^o</code>. This routine first projects <code class="reqn">y</code> onto <code class="reqn">\Omega^o</code> to get the residual of the projection onto the constraint cone <code class="reqn">C</code>, and then uses the fact that <code class="reqn">y</code> is equal to the sum of the projection of <code class="reqn">y</code> onto <code class="reqn">C</code> and the projection of <code class="reqn">y</code> onto <code class="reqn">\Omega^o</code> to get the estimation of <code class="reqn">\theta</code>. See references cited in this section for more details about the relationship between polar cone and constraint cone. </p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>df</code></td>
<td>
<p>The dimension of the face of the constraint cone on which the projection lands.</p>
</td></tr>
<tr><td><code>thetahat</code></td>
<td>
<p>The projection of <code class="reqn">y</code> on the constraint cone.</p>
</td></tr>
<tr><td><code>steps</code></td>
<td>
<p>The number of iterations before the algorithm converges.</p>
</td></tr>
<tr><td><code>xmat</code></td>
<td>
<p>The rows of the matrix are the edges of the face in the polar cone on which the residual of the projection onto the constraint cone lands.</p>
</td></tr>
<tr><td><code>face</code></td>
<td>
<p>A vector of the positions of edges in the polar cone, which define the face on which the final projection lands on. For example, when there are <code class="reqn">m</code> cone edges, then face is a subset of <code class="reqn">1,\ldots,m</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao  </p>


<h3>References</h3>

<p>Meyer, M. C. (1999) An extension of the mixed primal-dual bases algorithm to the case of more constraints than 
dimensions. <em>Journal of Statistical Planning and Inference <b>81</b></em>, 13&ndash;31.
</p>
<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications
in Statistics <b>42(5)</b></em>, 1126&ndash;1139.  
</p>
<p>Liao, X. and M. C. Meyer (2014) coneproj: An R package for the primal or dual cone projections with routines for constrained regression. <em>Journal of Statistical Software <b>61(12)</b></em>, 1&ndash;22.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coneB">coneB</a></code>, <code><a href="#topic+constreg">constreg</a></code>, <code><a href="#topic+qprog">qprog</a></code>  </p>


<h3>Examples</h3>

<pre><code class='language-R'># generate y
    set.seed(123)
    n &lt;- 50
    x &lt;- seq(-2, 2, length = 50)
    y &lt;- - x^2 + rnorm(n)

# create the constraint matrix to make the first half of y monotonically increasing
# and the second half of y monotonically decreasing
    amat &lt;- matrix(0, n - 1, n)
    for(i in 1:(n/2 - 1)){
       amat[i, i] &lt;- -1; amat[i, i + 1] &lt;- 1
    }
    for(i in (n/2):(n - 1)){
       amat[i, i] &lt;- 1; amat[i, i + 1] &lt;- -1
    }

# call coneA
    ans1 &lt;- coneA(y, amat)
    ans2 &lt;- coneA(y, amat, w = (1:n)/n)

# make a plot to compare the unweighted fit and the weighted fit
    par(mar = c(4, 4, 1, 1))
    plot(y, cex = .7, ylab = "y")
    lines(fitted(ans1), col = 2, lty = 2)
    lines(fitted(ans2), col = 4, lty = 2)
    legend("topleft", bty = "n", c("unweighted fit", "weighted fit"), col = c(2, 4), lty = c(2, 2))
    title("ConeA Example Plot")  
</code></pre>

<hr>
<h2 id='coneB'>Cone Projection &ndash; Constraint Cone</h2><span id='topic+coneB'></span>

<h3>Description</h3>

<p>This routine implements the hinge algorithm for cone projection to minimize <code class="reqn">||y - \theta||^2</code> over the cone
<code class="reqn">C</code> of the form <code class="reqn">\{\theta: \theta = v + \sum b_i\delta_i,   i = 1,\ldots,m,  b_1,\ldots, b_m \ge 0\}</code>, <code class="reqn">v</code> is in <code class="reqn">V</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>coneB(y, delta, vmat = NULL, w = NULL, face = NULL, msg = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coneB_+3A_y">y</code></td>
<td>
<p>A vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="coneB_+3A_delta">delta</code></td>
<td>
<p>A matrix whose columns are the constraint cone edges. The columns of delta must be irreducible. Its row number must equal the length of <code class="reqn">y</code>. No column of delta is contained in the column space of vmat.</p>
</td></tr>
<tr><td><code id="coneB_+3A_vmat">vmat</code></td>
<td>
<p>A matrix whose columns are the basis of the linear space contained in the constraint cone. Its row number must equal the length of <code class="reqn">y</code>. The columns of vmat must be linearly independent. The default is vmat = NULL</p>
</td></tr>
<tr><td><code id="coneB_+3A_w">w</code></td>
<td>
<p>An optional nonnegative vector of weights of length <code class="reqn">n</code>. If w is not given, all weights are taken to equal 1. Otherwise, the minimization of <code class="reqn">(y - \theta)'w(y - \theta)</code> over <code class="reqn">C</code> is returned. The default is w = NULL.</p>
</td></tr>
<tr><td><code id="coneB_+3A_face">face</code></td>
<td>
<p>A vector of the positions of edges, which define the initial face for the cone projection. For example, when there are <code class="reqn">m</code> cone edges, then face is a subset of <code class="reqn">1,\ldots,m</code>. The default is face = NULL.</p>
</td></tr>
<tr><td><code id="coneB_+3A_msg">msg</code></td>
<td>
<p>A logical flag. If msg is TRUE, then a warning message will be printed when there is a non-convergence problem; otherwise no warning message will be printed. The default is msg = TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The routine coneB dynamically loads a C++ subroutine &quot;coneBCpp&quot;. </p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>df</code></td>
<td>
<p>The dimension of the face of the constraint cone on which the projection lands.</p>
</td></tr>
<tr><td><code>yhat</code></td>
<td>
<p>The projection of <code class="reqn">y</code> on the constraint cone.</p>
</td></tr>
<tr><td><code>steps</code></td>
<td>
<p>The number of iterations before the algorithm converges.</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p>The coefficients of the basis of the linear space and the constraint cone edges contained in the constraint cone.</p>
</td></tr>
<tr><td><code>face</code></td>
<td>
<p>A vector of the positions of edges, which define the face on which the final projection lands on. For example, when there are <code class="reqn">m</code> cone edges, then face is a subset of <code class="reqn">1,\ldots,m</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (1999) An extension of the mixed primal-dual bases algorithm to the case of more constraints than 
dimensions. <em>Journal of Statistical Planning and Inference <b>81</b></em>, 13&ndash;31.
</p>
<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications
in Statistics <b>42(5)</b></em>, 1126&ndash;1139.
</p>
<p>Liao, X. and M. C. Meyer (2014) coneproj: An R package for the primal or dual cone projections with routines for constrained regression. <em>Journal of Statistical Software <b>61(12)</b></em>, 1&ndash;22.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coneA">coneA</a></code>, <code><a href="#topic+shapereg">shapereg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate y
    set.seed(123)
    n &lt;- 50
    x &lt;- seq(-2, 2, length = 50)
    y &lt;- - x^2 + rnorm(n)

# create the edges of the constraint cone to make the first half of y monotonically increasing 
# and the second half of y monotonically decreasing    
    amat &lt;- matrix(0, n - 1, n)
    for(i in 1:(n/2 - 1)){
       amat[i, i] &lt;- -1; amat[i, i + 1] &lt;- 1
    }
    for(i in (n/2):(n - 1)){
       amat[i, i] &lt;- 1; amat[i, i + 1] &lt;- -1
    }

# note that in coneB, the transpose of the edges of the constraint cone is provided
    delta &lt;- crossprod(amat, solve(tcrossprod(amat)))
    
# make the basis of V
    vmat &lt;- matrix(rep(1, n), ncol = 1)

# call coneB
    ans3 &lt;- coneB(y, delta, vmat)
    ans4 &lt;- coneB(y, delta, vmat, w = (1:n)/n)

# make a plot to compare the unweighted fit and weighted fit
    par(mar = c(4, 4, 1, 1))
    plot(y, cex = .7, ylab = "y")
    lines(fitted(ans3), col = 2, lty = 2)
    lines(fitted(ans4), col = 4, lty = 2)
    legend("topleft", bty = "n", c("unweighted fit", "weighted fit"), col = c(2, 4), lty = c(2, 2))
    title("ConeB Example Plot")
</code></pre>

<hr>
<h2 id='constreg'>Constrained Parametric Regression</h2><span id='topic+constreg'></span>

<h3>Description</h3>

<p>The least-squares regression model <code class="reqn">y = X\beta + \varepsilon</code> is considered, where the object is to find <code class="reqn">\beta</code> to minimize
<code class="reqn">||y - X\beta||^2</code>, subject to <code class="reqn">A\beta \ge 0</code>.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>constreg(y, xmat, amat, w = NULL, test = FALSE, nloop = 1e+4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="constreg_+3A_y">y</code></td>
<td>
<p>A vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="constreg_+3A_xmat">xmat</code></td>
<td>
<p>A full column-rank design matrix. The column number of xmat must equal the length of <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="constreg_+3A_amat">amat</code></td>
<td>
<p>A constraint matrix. The rows of amat must be irreducible. The column number of amat must equal the length of <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code id="constreg_+3A_w">w</code></td>
<td>
<p>An optional nonnegative vector of weights of length <code class="reqn">n</code>. If w is not given, all weights are taken to equal 1. Otherwise, the minimization of <code class="reqn">(y - X\beta)'w(y - X\beta)</code> over <code class="reqn">C</code> is returned. The default is w = NULL.</p>
</td></tr>
<tr><td><code id="constreg_+3A_test">test</code></td>
<td>
<p>A logical scalar. If test == TRUE, then the p-value for the test <code class="reqn">H_0:\beta</code> is in <code class="reqn">V</code> versus <code class="reqn">H_1:\beta</code> is in <code class="reqn">C</code> is returned. <code class="reqn">C</code> is the constraint cone of the form <code class="reqn">\{\beta: A\beta \ge 0\}</code>, and <code class="reqn">V</code> is the null space of <code class="reqn">A</code>. The default is test = FALSE.</p>
</td></tr>  
<tr><td><code id="constreg_+3A_nloop">nloop</code></td>
<td>
<p> The number of simulations used to get the p-value for the <code class="reqn">E_{01}</code> test. The default is 1e+4. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hypothesis test <code class="reqn">H_0:\beta</code> is in <code class="reqn">V</code> versus <code class="reqn">H_1:\beta</code> is in <code class="reqn">C</code> is an exact one-sided test, and the test statistic is <code class="reqn">E_{01} = (SSE_0 - SSE_1)/SSE_0</code>, which has a mixture-of-betas distribution when <code class="reqn">H_0</code> is true and <code class="reqn">\varepsilon</code> is a vector following a standard multivariate normal distribution with mean <code class="reqn">0</code>. The mixing parameters are found through simulations. The number of simulations used to obtain the mixing distribution parameters for the test is 10,000. Such simulations usually take some time. For the &quot;FEV&quot; data set used as an example in this section, whose sample size is 654, the time to get a p-value is roughly 6 seconds.
</p>
<p>The constreg function calls coneA for the cone projection part.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>constr.fit</code></td>
<td>
<p>The constrained fit of <code class="reqn">y</code> given that <code class="reqn">\beta</code> is in the cone <code class="reqn">C</code> of the form <code class="reqn">\{\beta: A\beta \ge 0 \}</code>.</p>
</td></tr>
<tr><td><code>unconstr.fit</code></td>
<td>
<p>The unconstrainted fit, i.e., the least-squares regression of <code class="reqn">y</code> on the space spanned by <code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>The p-value for the hypothesis test <code class="reqn">H_0:\beta</code> is in <code class="reqn">V</code> versus <code class="reqn">H_1:\beta</code> is in <code class="reqn">C</code>. The constraint cone <code class="reqn">C</code> has the form <code class="reqn">\{\beta: A\beta \ge 0 \}</code> and <code class="reqn">V</code> is the null space of <code class="reqn">A</code>. If test == TRUE, a p-value is returned. Otherwise, the test is skipped and no p-value is returned.</p>
</td></tr>
<tr><td><code>coefs</code></td>
<td>
<p>The estimated constrained parameters, i.e., the estimation of the vector <code class="reqn">\beta</code>.</p>
</td></tr>  
</table>


<h3>Note</h3>

<p>In the 3D plot of the &quot;FEV&quot; example, it is shown that the unconstrained fit increases as &quot;age&quot; increases when &quot;height&quot; is large, but decreases as &quot;age&quot; increases when &quot;height&quot; is small. This does not make sense, since &quot;FEV&quot; should not decrease with respect to &quot;age&quot; given any value of &quot;height&quot;. The constrained fit avoids this situation by keeping the fit of &quot;FEV&quot; non-decreasing with respect to &quot;age&quot;.
</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao 
</p>


<h3>References</h3>

<p>Brunk, H. D. (1958) On the estimation of parameters restricted by inequalities.
<em>The Annals of Mathematical Statistics <b>29 (2)</b></em>, 437&ndash;454.
</p>
<p>Raubertas, R. F., C.-I. C. Lee, and E. V. Nordheim (1986) Hypothesis tests for normals
means constrained by linear inequalities. <em>Communications in Statistics - Theory and 
Methods <b>15 (9)</b></em>, 2809&ndash;2833.
</p>
<p>Meyer, M. C. and J. C. Wang (2012) Improved power of one-sided tests. <em>Statistics and 
Probability Letters <b>82</b></em>, 1619&ndash;1622.  
</p>
<p>Liao, X. and M. C. Meyer (2014) coneproj: An R package for the primal or dual cone projections with routines for constrained regression. <em>Journal of Statistical Software <b>61(12)</b></em>, 1&ndash;22.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coneA">coneA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the FEV data set
    data(FEV)

# extract the variables
    y &lt;- FEV$FEV
    age &lt;- FEV$age
    height &lt;- FEV$height
    sex &lt;- FEV$sex
    smoke &lt;- FEV$smoke

# scale age and height
    scale_age &lt;- (age - min(age)) / (max(age) - min(age))
    scale_height &lt;- (height - min(height)) / (max(height) - min(height))

# make xmat
    xmat &lt;- cbind(1, scale_age, scale_height, scale_age * scale_height, sex, smoke)

# make the constraint matrix 
    amat &lt;- matrix(0, 4, 6)
    amat[1, 2] &lt;- 1; amat[2, 2] &lt;- 1; amat[2, 4] &lt;- 1 
    amat[3, 3] &lt;- 1; amat[4, 3] &lt;- 1; amat[4, 4] &lt;- 1

# call constreg to get constrained coefficient estimates
    ans1 &lt;- constreg(y, xmat, amat)
    bhat1 &lt;- coef(ans1)

# call lm to get unconstrained coefficient estimates
    ans2 &lt;- lm(y ~ xmat[,-1])
    bhat2 &lt;- coef(ans2)

# create a 3D plot to show the constrained fit and the unconstrained fit 
    n &lt;- 25
    xgrid &lt;- seq(0, 1, by = 1/n)
    ygrid &lt;- seq(0, 1, by = 1/n)
    x1 &lt;- rep(xgrid, each = length(ygrid))
    x2 &lt;- rep(ygrid, length(xgrid))
    xinterp &lt;- cbind(x1, x2)
    xmatp &lt;- cbind(1, xinterp, x1 * x2, 0, 0)
    
    thint1 &lt;- crossprod(t(xmatp), bhat1)
    A1 &lt;- matrix(thint1, length(xgrid), length(ygrid), byrow = TRUE) 
    thint2 &lt;- crossprod(t(xmatp), bhat2)
    A2 &lt;- matrix(thint2, length(xgrid), length(ygrid), byrow = TRUE) 

    par(mfrow = c(1, 2))
    par(mar = c(4, 1, 1, 1))
    persp(xgrid, ygrid, A1, xlab = "age", ylab = "height", 
    zlab = "FEV", theta = -30)
    title("Constrained Fit")

    par(mar = c(4, 1, 1, 1))
    persp(xgrid, ygrid, A2, xlab = "age", ylab = "height", 
    zlab = "FEV", theta = -30)
    title("Unconstrained Fit")
</code></pre>

<hr>
<h2 id='conv'>Specify a Convex Shape-Restriction in a SHAPEREG Formula</h2><span id='topic+conv'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the mean vector is convex in a predictor in a formula argument to coneproj.</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv(x, numknots = 0, knots = 0, space = "E")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conv_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="conv_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="conv_+3A_knots">knots</code></td>
<td>
<p>The knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="conv_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used for a shape-restricted predictor without smoothing. The default value is &quot;E&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;conv&quot; returns the vector &quot;x&quot; and imposes on it two attributes: name and shape. 
</p>
<p>The shape attribute is 3 (&quot;convex&quot;), and according to the value of the vector itself and this attribute, the cone edges of the cone generated by the constraint matrix, which constrains the relationship between the mean vector and &quot;x&quot; to be convex,  will be made. The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;conv&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in coneproj.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with the shape attribute, i.e., shape: 3 (&quot;convex&quot;).</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # generate y
  x &lt;- seq(-1, 2, by = 0.1)
  n &lt;- length(x)
  y &lt;- x^2 + rnorm(n, .3)  

  # regress y on x under the shape-restriction: "convex"
  ans &lt;- shapereg(y ~ conv(x))

  # make a plot
  plot(x, y)
  lines(x, fitted(ans), col = 2)
  legend("topleft", bty = "n", "shapereg: convex fit", col = 2, lty = 1)

</code></pre>

<hr>
<h2 id='cubic'>A Data Set for the Example of the Qprog Function</h2><span id='topic+cubic'></span>

<h3>Description</h3>

<p>This data set is used for the example of the qprog function.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cubic)</code></pre>


<h3>Format</h3>

<p>A data frame with 50 observations on the following 2 variables.
</p>

<dl>
<dt><code>x</code></dt><dd><p>The predictor vector.</p>
</dd>
<dt><code>y</code></dt><dd><p>The response vector.</p>
</dd>  </dl>
  

<h3>Details</h3>

<p>We use the qprog function to fit a constrained cubic to this data set. The constraint is that the true regression is increasing, convex and nonnegative. </p>


<h3>Source</h3>

<p>STAT640 HW 14 given by Dr. Meyer.  </p>

<hr>
<h2 id='decr'>Specify a Decreasing Shape-Restriction in a SHAPEREG Formula</h2><span id='topic+decr'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the mean vector is decreasing in a predictor in a formula argument to shapereg.</p>


<h3>Usage</h3>

<pre><code class='language-R'>decr(x, numknots = 0, knots = 0, space = "E")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decr_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="decr_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="decr_+3A_knots">knots</code></td>
<td>
<p>The knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="decr_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used for a shape-restricted predictor without smoothing. The default value is &quot;E&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;decr&quot; returns the vector &quot;x&quot; and imposes on it two attributes: name and shape. 
</p>
<p>The shape attribute is 2 (&quot;decreasing&quot;), and according to the value of the vector itself and this attribute, the cone edges of the cone generated by the constraint matrix, which constrains the relationship between the mean vector and &quot;x&quot; to be decreasing,  will be made. The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;decr&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in coneproj.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with the shape attribute, i.e., shape: 2 (&quot;decreasing&quot;).</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decr.conc">decr.conc</a></code>, <code><a href="#topic+decr.conv">decr.conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;- - cubic$x

  # extract y
  y &lt;- cubic$y

  # regress y on x with the shape restriction: "decreasing"
  ans &lt;- shapereg(y ~ decr(x))

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, fitted(ans), col = 2)
  legend("topleft", bty = "n", "shapereg: decreasing fit", col = 2, lty = 1)
</code></pre>

<hr>
<h2 id='decr.conc'>Specify a Decreasing and Concave Shape-Restriction in a SHAPEREG Formula</h2><span id='topic+decr.conc'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the mean vector is decreasing and concave in a predictor in a formula argument to coneproj.</p>


<h3>Usage</h3>

<pre><code class='language-R'>decr.conc(x, numknots = 0, knots = 0, space = "E")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decr.conc_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="decr.conc_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="decr.conc_+3A_knots">knots</code></td>
<td>
<p>The knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="decr.conc_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used for a shape-restricted predictor without smoothing. The default value is &quot;E&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;decr.conc&quot; returns the vector &quot;x&quot; and imposes on it two attributes: name and shape. 
</p>
<p>The shape attribute is 8 (&quot;decreasing and concave&quot;), and according to the value of the vector itself and this attribute, the cone edges of the cone generated by the constraint matrix, which constrains the relationship between the mean vector and &quot;x&quot; to be decreasing and concave,  will be made. The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;decr.conc&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in coneproj.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with the shape attribute, i.e., shape: 8 (&quot;decreasing and concave&quot;).</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+incr.conv">incr.conv</a></code>, <code><a href="#topic+incr">incr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;-  cubic$x

  # extract y
  y &lt;- - cubic$y

  # regress y on x with the shape restriction: "decreasing" and "concave"
  ans &lt;- shapereg(y ~ decr.conc(x))

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, fitted(ans), col = 2)
  legend("bottomleft", bty = "n", "shapereg: decreasing and concave fit", col = 2, lty = 1)

</code></pre>

<hr>
<h2 id='decr.conv'>Specify a Decreasing and Convex Shape-Restriction in a SHAPEREG Formula</h2><span id='topic+decr.conv'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the mean vector is decreasing and convex in a predictor in a formula argument to coneproj.</p>


<h3>Usage</h3>

<pre><code class='language-R'>decr.conv(x, numknots = 0, knots = 0, space = "E")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decr.conv_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="decr.conv_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="decr.conv_+3A_knots">knots</code></td>
<td>
<p>The knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="decr.conv_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used for a shape-restricted predictor without smoothing. The default value is &quot;E&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;decr.conv&quot; returns the vector &quot;x&quot; and imposes on it two attributes: name and shape. 
</p>
<p>The shape attribute is 6 (&quot;decreasing and convex&quot;), and according to the value of the vector itself and this attribute, the cone edges of the cone generated by the constraint matrix, which constrains the relationship between the mean vector and &quot;x&quot; to be decreasing and convex,  will be made. The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;decr.conv&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in coneproj.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with the shape attribute, i.e., shape: 6 (&quot;decreasing and convex&quot;).</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+decr.conc">decr.conc</a></code>, <code><a href="#topic+decr">decr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;- - cubic$x

  # extract y
  y &lt;- cubic$y

  # regress y on x with the shape restriction: "decreasing" and "convex"
  ans &lt;- shapereg(y ~ decr.conv(x))

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, fitted(ans), col = 2)
  legend("bottomright", bty = "n", "shapereg: decreasing and convex fit", col = 2, lty = 1)


</code></pre>

<hr>
<h2 id='feet'>Foot Measurements for Fourth Grade Children</h2><span id='topic+feet'></span>

<h3>Description</h3>

<p>This data set was collected by the first author in a fourth grade classroom in Ann Arbor, MI, October 1997. We use the shapereg function to make a shape-restricted fit to this data set. &quot;Width&quot; is a continuous response variable, &quot;length&quot; is a continuous predictor variable, and &quot;sex&quot; is a categorical covariate. The constraint is that &quot;width&quot; is increasing with respect to &quot;length&quot;.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(feet)</code></pre>


<h3>Format</h3>

<p>A data frame with 39 observations on the following 8 variables.
</p>

<dl>
<dt><code>name</code></dt><dd><p>First name of child.</p>
</dd>
<dt><code>month</code></dt><dd><p>Birth month.</p>
</dd>
<dt><code>year</code></dt><dd><p>Birth year.</p>
</dd>
<dt><code>length</code></dt><dd><p>Length of longer foot (cm).</p>
</dd>
<dt><code>width</code></dt><dd><p>Width of longer foot (cm), measured at widest part of foot.</p>
</dd>
<dt><code>sex</code></dt><dd><p>Boy or girl.</p>
</dd>
<dt><code>foot</code></dt><dd><p>Foot measured (right or left).</p>
</dd>
<dt><code>hand</code></dt><dd><p>Right- or left-handedness.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Meyer, M. C. (2006) Wider Shoes for Wider Feet? <em>Journal of Statistics Education <b>Volume 14, Number 1</b></em>. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(feet)
    l &lt;- feet$length
    w &lt;- feet$width
    s &lt;- feet$sex
    plot(l, w, type = "n", xlab = "Foot Length (cm)", ylab = "Foot Width (cm)")
    points(l[s == "G"], w[s == "G"], pch = 24, col = 2)
    points(l[s == "B"], w[s == "B"], pch = 21, col = 4)
    legend("topleft", bty = "n", c("Girl", "Boy"), pch = c(24, 21), col = c(2, 4))
    title("Kidsfeet Width vs Length Scatterplot")
</code></pre>

<hr>
<h2 id='FEV'>Forced Expiratory Volume</h2><span id='topic+FEV'></span>

<h3>Description</h3>

<p>This data set consists of 654 observations on children aged 3 to 19. Forced Expiratory Volume (FEV), which is a measure of lung capacity, is the variable in interest. Age and height are two continuous predictors. Sex and smoke are two categorical predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(FEV)</code></pre>


<h3>Format</h3>

<p>A data frame with 654 observations on the following 5 variables.
</p>

<dl>
<dt><code>age</code></dt><dd><p>Age of the 654 children.</p>
</dd>
<dt><code>FEV</code></dt><dd><p>Forced expiratory volume(liters).</p>
</dd>
<dt><code>height</code></dt><dd><p>Height(inches).</p>
</dd>
<dt><code>sex</code></dt><dd><p>Female is 0. Male is 1.</p>
</dd>
<dt><code>smoke</code></dt><dd><p>Nonsmoker is 0. Smoker is 1.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Rosner, B. (1999) <em>Fundamentals of Biostatistics, 5th Ed., Pacific Grove, CA: Duxbur</em>.
</p>
<p>Michael J. Kahn (2005) An Exhalent Problem for Teaching Statistics <em>Journal of Statistics Education <b>Volume 13, Number 2</b></em>.
</p>

<hr>
<h2 id='incr'>Specify an Increasing Shape-Restriction in a SHAPEREG Formula</h2><span id='topic+incr'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the mean vector is increasing in a predictor in a formula argument to shapereg.</p>


<h3>Usage</h3>

<pre><code class='language-R'>incr(x, numknots = 0, knots = 0, space = "E")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="incr_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="incr_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="incr_+3A_knots">knots</code></td>
<td>
<p>The knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="incr_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used for a shape-restricted predictor without smoothing. The default value is &quot;E&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;incr&quot; returns the vector &quot;x&quot; and imposes on it two attributes: name and shape. 
</p>
<p>The shape attribute is 1 (&quot;increasing&quot;), and according to the value of the vector itself and this attribute, the cone edges of the cone generated by the constraint matrix, which constrains the relationship between the mean vector and &quot;x&quot; to be increasing,  will be made. The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;incr&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in coneproj.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with the shape attribute, i.e., shape: 1 (&quot;increasing&quot;).</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+incr.conc">incr.conc</a></code>, <code><a href="#topic+incr.conv">incr.conv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;- cubic$x

  # extract y
  y &lt;- cubic$y

  # regress y on x with the shape restriction: "increasing"
  ans &lt;- shapereg(y ~ incr(x))

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, fitted(ans), col = 2)
  legend("topleft", bty = "n", "shapereg: increasing fit", col = 2, lty = 1)
</code></pre>

<hr>
<h2 id='incr.conc'>Specify an Increasing and Concave Shape-Restriction in a SHAPEREG Formula</h2><span id='topic+incr.conc'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the mean vector is increasing and concave in a predictor in a formula argument to coneproj.</p>


<h3>Usage</h3>

<pre><code class='language-R'>incr.conc(x, numknots = 0, knots = 0, space = "E")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="incr.conc_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="incr.conc_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="incr.conc_+3A_knots">knots</code></td>
<td>
<p>The knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="incr.conc_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used for a shape-restricted predictor without smoothing. The default value is &quot;E&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;incr.conc&quot; returns the vector &quot;x&quot; and imposes on it two attributes: name and shape. 
</p>
<p>The shape attribute is 7 (&quot;increasing and concave&quot;), and according to the value of the vector itself and this attribute, the cone edges of the cone generated by the constraint matrix, which constrains the relationship between the mean vector and &quot;x&quot; to be increasing and concave,  will be made. The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;incr.conc&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in coneproj.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with the shape attribute, i.e., shape: 7 (&quot;increasing and concave&quot;).</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+incr.conv">incr.conv</a></code>, <code><a href="#topic+incr">incr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;- - cubic$x

  # extract y
  y &lt;- - cubic$y

  # regress y on x with the shape restriction: "increasing" and "concave"
  ans &lt;- shapereg(y ~ incr.conc(x))

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, fitted(ans), col = 2)
  legend("topleft", bty = "n", "shapereg: increasing and concave fit", col = 2, lty = 1)

</code></pre>

<hr>
<h2 id='incr.conv'>Specify an Increasing and Convex Shape-Restriction in a SHAPEREG Formula</h2><span id='topic+incr.conv'></span>

<h3>Description</h3>

<p>A symbolic routine to define that the mean vector is increasing and convex in a predictor in a formula argument to coneproj.</p>


<h3>Usage</h3>

<pre><code class='language-R'>incr.conv(x, numknots = 0, knots = 0, space = "E")</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="incr.conv_+3A_x">x</code></td>
<td>
<p>A numeric predictor which has the same length as the response vector.</p>
</td></tr>
<tr><td><code id="incr.conv_+3A_numknots">numknots</code></td>
<td>
<p>The number of knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="incr.conv_+3A_knots">knots</code></td>
<td>
<p>The knots used to smoothly constrain a predictor. The value should be <code class="reqn">0</code> for a shape-restricted predictor without smoothing. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="incr.conv_+3A_space">space</code></td>
<td>
<p>A character specifying the method to create knots. It will not be used for a shape-restricted predictor without smoothing. The default value is &quot;E&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>&quot;incr.conv&quot; returns the vector &quot;x&quot; and imposes on it two attributes: name and shape. 
</p>
<p>The shape attribute is 5 (&quot;increasing and convex&quot;), and according to the value of the vector itself and this attribute, the cone edges of the cone generated by the constraint matrix, which constrains the relationship between the mean vector and &quot;x&quot; to be increasing and convex,  will be made. The cone edges are a set of basis employed in the hinge algorithm. 
</p>
<p>Note that &quot;incr.conv&quot; does not make the corresponding cone edges itself. It sets things up to a subroutine called makedelta in coneproj.
</p>
<p>See references cited in this section for more details.
</p>


<h3>Value</h3>

<p>The vector x with the shape attribute, i.e., shape: 5 (&quot;increasing and convex&quot;).</p>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao
</p>


<h3>References</h3>

<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications in Statistics <b>42(5)</b></em>, 1126&ndash;1139. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+incr.conc">incr.conc</a></code>, <code><a href="#topic+incr">incr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(cubic)

  # extract x
  x &lt;- cubic$x

  # extract y
  y &lt;- cubic$y

  # regress y on x with the shape restriction: "increasing" and "convex"
  ans &lt;- shapereg(y ~ incr.conv(x))

  # make a plot
  par(mar = c(4, 4, 1, 1))
  plot(x, y, cex = .7, xlab = "x", ylab = "y")
  lines(x, fitted(ans), col = 2)
  legend("topleft", bty = "n", "shapereg: increasing and convex fit", col = 2, lty = 1)


</code></pre>

<hr>
<h2 id='qprog'>Quadratic Programming</h2><span id='topic+qprog'></span>

<h3>Description</h3>

<p>Given a positive definite <code class="reqn">n</code> by <code class="reqn">n</code> matrix <code class="reqn">Q</code> and a constant vector <code class="reqn">c</code> in <code class="reqn">R^n</code>, the object is to find <code class="reqn">\theta</code> in <code class="reqn">R^n</code> to minimize <code class="reqn">\theta'Q\theta - 2c'\theta</code> subject to <code class="reqn">A\theta \ge b</code>, for an irreducible constraint matrix <code class="reqn">A</code>. This routine transforms into a cone projection problem for the constrained solution. </p>


<h3>Usage</h3>

<pre><code class='language-R'>qprog(q, c, amat, b, face = NULL, msg = TRUE)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qprog_+3A_q">q</code></td>
<td>
<p>A <code class="reqn">n</code> by <code class="reqn">n</code> positive definite matrix.</p>
</td></tr>
<tr><td><code id="qprog_+3A_c">c</code></td>
<td>
<p>A vector of length <code class="reqn">n</code>.</p>
</td></tr>
<tr><td><code id="qprog_+3A_amat">amat</code></td>
<td>
<p>A <code class="reqn">m</code> by <code class="reqn">n</code> constraint matrix. The rows of amat must be irreducible.</p>
</td></tr>
<tr><td><code id="qprog_+3A_b">b</code></td>
<td>
<p>A vector of length <code class="reqn">m</code>. Its default value is 0.</p>
</td></tr>
<tr><td><code id="qprog_+3A_face">face</code></td>
<td>
<p>A vector of the positions of edges, which define the initial face for the cone projection. For example, when there are <code class="reqn">m</code> cone edges, then face is a subset of <code class="reqn">1,\ldots,m</code>. The default is face = NULL.</p>
</td></tr>
<tr><td><code id="qprog_+3A_msg">msg</code></td>
<td>
<p>A logical flag. If msg is TRUE, then a warning message will be printed when there is a non-convergence problem; otherwise no warning message will be printed. The default is msg = TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To get the constrained solution to <code class="reqn">\theta'Q\theta - 2c'\theta</code> subject to <code class="reqn">A\theta \ge b</code>, this routine makes the Cholesky decomposition of <code class="reqn">Q</code>. Let <code class="reqn">U'U = Q</code>, and define <code class="reqn">\phi = U\theta</code> and <code class="reqn">z = U^{-1}c</code>, where <code class="reqn">U^{-1}</code> is the inverse of <code class="reqn">U</code>.
Then we minimize <code class="reqn">||z - \phi||^2</code>, subject to <code class="reqn">B\phi \ge 0</code>, where <code class="reqn">B = AU^{-1}</code>. It is now a cone projection problem with the constraint cone <code class="reqn">C</code> of the form <code class="reqn">\{\phi: B\phi \ge 0 \}</code>. This routine gives the estimation of <code class="reqn">\theta</code>, which is <code class="reqn">U^{-1}</code> times the estimation of <code class="reqn">\phi</code>. 
</p>
<p>The routine qprog dynamically loads a C++ subroutine &quot;qprogCpp&quot;.
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>df</code></td>
<td>
<p>The dimension of the face of the constraint cone on which the projection lands.</p>
</td></tr>
<tr><td><code>thetahat</code></td>
<td>
<p>A vector minimizing <code class="reqn">\theta'Q\theta - 2c'\theta</code>.</p>
</td></tr>
<tr><td><code>steps</code></td>
<td>
<p>The number of iterations before the algorithm converges.</p>
</td></tr>
<tr><td><code>xmat</code></td>
<td>
<p>The rows of the matrix are the edges of the face of the polar cone on which the residual of the projection onto the constraint cone lands.</p>
</td></tr>
<tr><td><code>face</code></td>
<td>
<p>A vector of the positions of edges, which define the face on which the final projection lands on. For example, when there are <code class="reqn">m</code> cone edges, then face is a subset of <code class="reqn">1,\ldots,m</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao 
</p>


<h3>References</h3>

<p>Goldfarb, D. and A. Idnani (1983) A numerically stable dual method for solving strictly convex quadratic programs.
<em>Mathematical Programming <b>27</b></em>, 1&ndash;33.
</p>
<p>Fraser, D. A. S. and H. Massam (1989) A mixed primal-dual bases algorithm for regression
under inequality constraints application to concave regression. <em>Scandinavian Journal of Statistics <b>16</b></em>, 65&ndash;74.
</p>
<p>Fang,S.-C. and S. Puthenpura (1993) <em>Linear Optimization and Extensions</em>. Englewood Cliffs, New Jersey: Prentice Hall.
</p>
<p>Silvapulle, M. J. and P. Sen (2005) <em>Constrained Statistical Inference</em>. John Wiley and Sons.
</p>
<p>Meyer, M. C. (2013b) A simple new algorithm for quadratic programming with applications in statistics. <em>Communications
in Statistics <b>42(5)</b></em>, 1126&ndash;1139.
</p>
<p>Liao, X. and M. C. Meyer (2014) coneproj: An R package for the primal or dual cone projections with routines for constrained regression. <em>Journal of Statistical Software <b>61(12)</b></em>, 1&ndash;22.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coneA">coneA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the cubic data set
    data(cubic)

# extract x
    x &lt;- cubic$x

# extract y
    y &lt;- cubic$y

# make the design matrix
    xmat &lt;- cbind(1, x, x^2, x^3)

# make the q matrix
    q &lt;- crossprod(xmat)

# make the c vector
    c &lt;- crossprod(xmat, y)

# make the constraint matrix to constrain the regression to be increasing, nonnegative and convex
    amat &lt;- matrix(0, 4, 4)
    amat[1, 1] &lt;- 1; amat[2, 2] &lt;- 1
    amat[3, 3] &lt;- 1; amat[4, 3] &lt;- 1
    amat[4, 4] &lt;- 6
    b &lt;- rep(0, 4)

# call qprog 
    ans &lt;- qprog(q, c, amat, b)

# get the constrained fit of y
    betahat &lt;- fitted(ans)
    fitc &lt;- crossprod(t(xmat), betahat)

# get the unconstrained fit of y
    fitu &lt;- lm(y ~ x + I(x^2) + I(x^3))

# make a plot to compare fitc and fitu
    par(mar = c(4, 4, 1, 1))
    plot(x, y, cex = .7, xlab = "x", ylab = "y")
    lines(x, fitted(fitu))
    lines(x, fitc, col = 2, lty = 4)
    legend("topleft", bty = "n", c("constr.fit", "unconstr.fit"), lty = c(4, 1), col = c(2, 1))
    title("Qprog Example Plot")
</code></pre>

<hr>
<h2 id='shapereg'>Shape-Restricted Regression</h2><span id='topic+shapereg'></span>

<h3>Description</h3>

<p>The regression model <code class="reqn">y_i = f(t_i) + x_i'\beta + \varepsilon_i, i = 1,\ldots,n</code> is considered, where the only assumptions about <code class="reqn">f</code> concern its shape. The vector expression for the model is <code class="reqn">y = \theta + X\beta + \varepsilon</code>. <code class="reqn">X</code> represents a parametrically modelled covariate, which could be a categorical covariate or a linear term. The shapereg function allows eight shapes: increasing, decreasing, convex, concave, increasing-convex, increasing-concave, decreasing-convex, and decreasing-concave. This routine employs a single cone projection to find <code class="reqn">\theta</code> and <code class="reqn">\beta</code> simultaneously.  </p>


<h3>Usage</h3>

<pre><code class='language-R'>shapereg(formula, data = NULL, weights = NULL, test = FALSE, nloop = 1e+4)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shapereg_+3A_formula">formula</code></td>
<td>
<p>  A formula object which gives a symbolic description of the model to be fitted. It has the form &quot;response ~ predictor&quot;. The response is a vector of length <code class="reqn">n</code>.  A predictor can be a non-parametrically modelled variable with a shape restriction or a parametrically modelled unconstrained covariate. In terms of a non-parametrically modelled predictor, the user is supposed to indicate the relationship between <code class="reqn">E(y)</code> and a predictor <code class="reqn">t</code> in the following way:
</p>

<dl>
<dt>incr(t): </dt><dd><p><code class="reqn">E(y)</code> is increasing in <code class="reqn">t</code>. See <code><a href="#topic+incr">incr</a></code> for more details.</p>
</dd>
<dt>decr(t): </dt><dd><p><code class="reqn">E(y)</code> is decreasing in <code class="reqn">t</code>.  See <code><a href="#topic+decr">decr</a></code> for more details.</p>
</dd>
<dt>conc(t): </dt><dd><p><code class="reqn">E(y)</code> is concave in <code class="reqn">t</code>.  See <code><a href="#topic+conc">conc</a></code> for more details.</p>
</dd>
<dt>conv(t): </dt><dd><p><code class="reqn">E(y)</code> is convex in <code class="reqn">t</code>.  See <code><a href="#topic+conv">conv</a></code> for more details.</p>
</dd>
<dt>incr.conc(t): </dt><dd><p><code class="reqn">E(y)</code> is increasing and concave in <code class="reqn">t</code>.  See <code><a href="#topic+incr.conc">incr.conc</a></code> for more details.</p>
</dd>
<dt>decr.conc(t): </dt><dd><p><code class="reqn">E(y)</code> is decreasing and concave in <code class="reqn">t</code>. See <code><a href="#topic+decr.conc">decr.conc</a></code> for more details.</p>
</dd>
<dt>incr.conv(t): </dt><dd><p><code class="reqn">E(y)</code> is increasing and convex in <code class="reqn">t</code>. See <code><a href="#topic+incr.conv">incr.conv</a></code> for more details.</p>
</dd>
<dt>decr.conv(t): </dt><dd><p><code class="reqn">E(y)</code> is decreasing and convex in <code class="reqn">t</code>. See <code><a href="#topic+decr.conv">decr.conv</a></code> for more details.</p>
</dd>
</dl>

</td></tr>
<tr><td><code id="shapereg_+3A_data">data</code></td>
<td>
<p>An optional data frame, list or environment containing the variables in the model. The default is data = NULL.</p>
</td></tr>
<tr><td><code id="shapereg_+3A_weights">weights</code></td>
<td>
<p>  An optional non-negative vector of &quot;replicate weights&quot; which has the same length as the response vector. If weights are not given, all weights are taken to equal 1. The default is weights = NULL.</p>
</td></tr>
<tr><td><code id="shapereg_+3A_test">test</code></td>
<td>
<p>The test parameter given by the user.</p>
</td></tr>
<tr><td><code id="shapereg_+3A_nloop">nloop</code></td>
<td>
<p> The number of simulations used to get the p-value for the <code class="reqn">E_{01}</code> test. The default is 1e+4. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This routine constrains <code class="reqn">\theta</code> in the equation <code class="reqn">y = \theta + X\beta + \varepsilon</code> by a shape parameter. 
</p>
<p>The constraint cone <code class="reqn">C</code> has the form <code class="reqn">\{\phi: \phi = v + \sum b_i\delta_i, i = 1,\ldots,m, b_1,\ldots, b_m \ge 0 \}</code>, <code class="reqn">v</code> is in <code class="reqn">V</code>. The column vectors of <code class="reqn">X</code> are in <code class="reqn">V</code>, i.e., the linear space contained in the constraint cone. 
</p>
<p>The hypothesis test <code class="reqn">H_0: \phi</code> is in <code class="reqn">V</code> versus <code class="reqn">H_1: \phi</code> is in <code class="reqn">C</code> is an exact one-sided test, and the test statistic is <code class="reqn">E_{01} = (SSE_0 - SSE_1)/(SSE_0)</code>, which has a mixture-of-betas distribution when <code class="reqn">H_0</code> is true and <code class="reqn">\varepsilon</code> is a vector following a standard multivariate normal distribution with mean 0. The mixing parameters are found through simulations. The number of simulations used to obtain the mixing distribution parameters for the test is 10,000. Such simulations usually take some time. For the &quot;feet&quot; data set used as an example in this section, whose sample size is 39, the time to get a p-value is roughly between 4 seconds. 
</p>
<p>This routine calls coneB for the cone projection part. 
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>coefs</code></td>
<td>
<p>The estimated coefficients for <code class="reqn">X</code>, i.e., the estimation for the vector <code class="reqn">\beta</code>. Note that even if the user does not provide a constant vector in <code class="reqn">X</code>, the coefficient for the intercept will be returned.</p>
</td></tr>
<tr><td><code>constr.fit</code></td>
<td>
<p>The shape-restricted fit over the constraint cone <code class="reqn">C</code> of the form <code class="reqn">\{\phi: \phi = v + \sum b_i\delta_i, 
i = 1,\ldots,m, b_1,\ldots, b_m \ge 0 \}</code>, <code class="reqn">v</code> is in <code class="reqn">V</code>.</p>
</td></tr>
<tr><td><code>linear.fit</code></td>
<td>
<p>The least-squares regression of <code class="reqn">y</code> on <code class="reqn">V</code>, i.e., the linear space contained in the constraint cone. If shape is 3 or shape is 4, <code class="reqn">V</code> is spanned by <code class="reqn">X</code> and <code class="reqn">t</code>. Otherwise, it is spanned by <code class="reqn">X</code>. <code class="reqn">X</code> must be full column rank, and the matrix formed by combining <code class="reqn">X</code> and <code class="reqn">t</code> must also be full column rank.</p>
</td></tr>
<tr><td><code>se.beta</code></td>
<td>
<p>The standard errors for the estimation of the vector <code class="reqn">\beta</code>. The degree of freedom is returned by coneB and is multiplied by 1.5. Note that even if the user does not provide a constant vector in <code class="reqn">X</code>, the standard error for the intercept will be returned.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>The p-value for the hypothesis test <code class="reqn">H_0: \phi</code> is in <code class="reqn">V</code> versus <code class="reqn">H_1: \phi</code> is in <code class="reqn">C</code>. <code class="reqn">C</code> is the constraint cone of the form <code class="reqn">\{\phi: \phi = v + \sum b_i\delta_i, i = 1,\ldots,m, b_1,\ldots, b_m \ge 0 \}</code>, <code class="reqn">v</code> is in <code class="reqn">V</code>, and <code class="reqn">V</code> is the linear space contained in the constraint cone. If test == TRUE, a p-value is returned. Otherwise, the test is skipped and no p-value is returned.</p>
</td></tr>
<tr><td><code>pvals.beta</code></td>
<td>
<p>The approximate p-values for the estimation of the vector <code class="reqn">\beta</code>. A t-distribution is used as the approximate distribution. Note that even if the user does not provide a constant vector in <code class="reqn">X</code>, the approximate p-value for the intercept will be returned. </p>
</td></tr>
<tr><td><code>test</code></td>
<td>
<p>The test parameter given by the user.</p>
</td></tr>
<tr><td><code>SSE0</code></td>
<td>
<p>The sum of squared residuals for the linear part.</p>
</td></tr>
<tr><td><code>SSE1</code></td>
<td>
<p>The sum of squared residuals for the full model.</p>
</td></tr>
<tr><td><code>shape</code></td>
<td>
<p>A number showing the shape constraint given by the user in a shapereg fit.</p>
</td></tr>
<tr><td><code>tms</code></td>
<td>
<p>The terms objects extracted by the generic function <em>terms</em> from a shapereg fit.</p>
</td></tr>
<tr><td><code>zid</code></td>
<td>
<p>A vector keeping track of the position of the parametrically modelled covariate.</p>
</td></tr>
<tr><td><code>vals</code></td>
<td>
<p>A vector storing the levels of each variable used as a factor.</p>
</td></tr>
<tr><td><code>zid1</code></td>
<td>
<p>A vector keeping track of the beginning position of the levels of each variable used as a factor.</p>
</td></tr>
<tr><td><code>zid2</code></td>
<td>
<p>A vector keeping track of the end position of the levels of each variable used as a factor.</p>
</td></tr>
<tr><td><code>tnm</code></td>
<td>
<p>The name of the shape-restricted predictor.</p>
</td></tr>
<tr><td><code>ynm</code></td>
<td>
<p>The name of the response variable.</p>
</td></tr>
<tr><td><code>znms</code></td>
<td>
<p>A vector storing the name of the parametrically modelled covariate.</p>
</td></tr>
<tr><td><code>is_param</code></td>
<td>
<p>A logical scalar showing if or not a variable is a parametrically modelled covariate, which could be a factor or a linear term.</p>
</td></tr>
<tr><td><code>is_fac</code></td>
<td>
<p>A logical scalar showing if or not a variable is a factor.</p>
</td></tr>
<tr><td><code>xmat</code></td>
<td>
<p>A matrix whose columns represent the parametrically modelled covariate.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The matched call.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mary C. Meyer and Xiyue Liao</p>


<h3>References</h3>

<p>Raubertas, R. F., C.-I. C. Lee, and E. V. Nordheim (1986) Hypothesis tests for normals
means constrained by linear inequalities. <em>Communications in Statistics - Theory and 
Methods <b>15 (9)</b></em>, 2809&ndash;2833.
</p>
<p>Robertson, T., F. Wright, and R. Dykstra (1988) <em>Order Restricted Statistical Inference</em>
New York: John Wiley and Sons.
</p>
<p>Fraser, D. A. S. and H. Massam (1989) A mixed primal-dual bases algorithm for regression
under inequality constraints application to concave regression. <em>Scandinavian Journal of Statistics <b>16</b></em>, 65&ndash;74.
</p>
<p>Meyer, M. C. (2003) A test for linear vs convex regression function using shape-restricted
regression. <em>Biometrika <b>90(1)</b></em>, 223&ndash;232.
</p>
<p>Cheng, G.(2009) Semiparametric additive isotonic regression. <em>Journal of Statistical Planning and Inference <b>139</b></em>, 1980&ndash;1991.
</p>
<p>Meyer, M.C.(2013a) Semiparametric additive constrained regression. <em>Journal of Nonparametric Statistics <b>25(3)</b></em>, 715&ndash;743.  
</p>
<p>Liao, X. and M. C. Meyer (2014) coneproj: An R package for the primal or dual cone projections with routines for constrained regression. <em>Journal of Statistical Software <b>61(12)</b></em>, 1&ndash;22.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+coneB">coneB</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the feet data set
    data(feet)

# extract the continuous and constrained predictor
    l &lt;- feet$length

# extract the continuous response
    w &lt;- feet$width

# extract the categorical covariate: sex
    s &lt;- feet$sex

# make an increasing fit with test set as FALSE
    ans &lt;- shapereg(w ~ incr(l) + factor(s))

# check the summary table 
    summary(ans)

# make an increasing fit with test set as TRUE
    ans &lt;- shapereg(w ~ incr(l) + factor(s), test = TRUE, nloop = 1e+3)

# check the summary table 
    summary(ans)

# make a plot comparing the unconstrained fit and the constrained fit
    par(mar = c(4, 4, 1, 1))
    ord &lt;- order(l)
    plot(sort(l), w[ord], type = "n", xlab = "foot length (cm)", ylab = "foot width (cm)")
    title("Shapereg Example Plot")

# sort l according to sex
    ord1 &lt;- order(l[s == "G"])
    ord2 &lt;- order(l[s == "B"])

# make the scatterplot of l vs w for boys and girls
    points(sort(l[s == "G"]), w[s == "G"][ord1], pch = 21, col = 1)
    points(sort(l[s == "B"]), w[s == "B"][ord2], pch = 24, col = 2)

# make an unconstrained fit to boys and girls
    fit &lt;- lm(w ~ l + factor(s))

# plot the unconstrained fit 
    lines(sort(l), (coef(fit)[1] + coef(fit)[2] * l + coef(fit)[3])[ord], lty = 2)
    lines(sort(l), (coef(fit)[1] + coef(fit)[2] * l)[ord], lty = 2, col = 2)
    legend(21.5, 9.8, c("boy","girl"), pch = c(24, 21), col = c(2, 1)) 

# plot the constrained fit
    lines(sort(l), (ans$constr.fit - ans$linear.fit + coef(ans)[1])[ord], col = 1)
    lines(sort(l), (ans$constr.fit - ans$linear.fit + coef(ans)[1] + coef(ans)[2])[ord], col = 2)
</code></pre>

<hr>
<h2 id='TwoDamat'>A Two Dimensional Constraint Matrix
</h2><span id='topic+TwoDamat'></span>

<h3>Description</h3>

<p>This is a two dimensional constraint matrix which will be used in the example for the check_irred routine.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(TwoDamat)</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
