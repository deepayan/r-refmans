<!DOCTYPE html><html><head><title>Help for package MetaIntegrator</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {MetaIntegrator}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#backwardSearch'><p>Backward Search Function</p></a></li>
<li><a href='#calcMetaPower'><p>Calculates the statistical power of a random effects meta-analysis</p></a></li>
<li><a href='#calculateROC'><p>Calculate ROC Curve Statistics</p></a></li>
<li><a href='#calculateScore'><p>Calculate a signature Z-score for a set of genes in a single dataset</p></a></li>
<li><a href='#checkDataObject'><p>Check for errors in objects used for analysis</p></a></li>
<li><a href='#classFunction'><p>Helper function to build the class vector</p></a></li>
<li><a href='#cleanUpPheno'><p>Automatic preprocessing of $pheno dataframe</p></a></li>
<li><a href='#coconutMetaIntegrator'><p>A wrapper function to run COCONUT on the MetaIntegrator objects.</p></a></li>
<li><a href='#ens_ensgID_table'>
<p>ENSEMBL gene id table cache</p></a></li>
<li><a href='#ens_entrez_table'>
<p>ENSEMBL entrez table cache</p></a></li>
<li><a href='#filterGenes'><p>Filter out significant genes from meta-analysis results</p></a></li>
<li><a href='#forestPlot'><p>Compare effect sizes of a gene across all datasets in meta-analysis</p></a></li>
<li><a href='#forwardSearch'><p>Forward Search Function</p></a></li>
<li><a href='#geneSymbolCorrection'><p>Correct/update gene symbols in a metaObject</p></a></li>
<li><a href='#getGEOData'><p>GEO download/processing through GEOquery</p></a></li>
<li><a href='#getMostRecentFilter'><p>Get name of most recent filter</p></a></li>
<li><a href='#getSampleLevelGeneData'><p>Extract gene-level data from a given data object</p></a></li>
<li><a href='#ggForestPlot'><p>Compare effect sizes of a gene across all datasets in meta-analysis</p></a></li>
<li><a href='#heatmapPlot'><p>Generates a heatmap with effect sizes for all genes which pass a filter in all measured diseases</p></a></li>
<li><a href='#immunoStatesDecov'><p>immunoStates deconvolution analysis on MetaIntegrator object(s)</p></a></li>
<li><a href='#immunoStatesGenePropCorr'><p>Correct gene expression using cell proportions from immunoStates</p></a></li>
<li><a href='#immunoStatesMatrix'><p>immunoStates basis matrix</p></a></li>
<li><a href='#immunoStatesMeta'><p>immunoStates deconvolution analysis on MetaIntegrator object(s)</p></a></li>
<li><a href='#imputeSex'><p>Imputes biological sex of each sample in a Dataset object</p></a></li>
<li><a href='#lincsBaitCorr'><p>Run Shane's LINCS bait-based correlation on MetaIntegrator</p></a></li>
<li><a href='#lincsCorrelate'><p>Run Shane's LINCS Correlate on MetaIntegrator</p></a></li>
<li><a href='#lincsTools'><p>Run Shane's LINCS Tools on MetaIntegrator</p></a></li>
<li><a href='#manhattanPlot'><p>Generates a Manhattan plot with effect size FDR as y-axis</p></a></li>
<li><a href='#MetaIntegrator'>
<p>MetaIntegrator package for meta-analysis of gene expression data</p></a></li>
<li><a href='#multiplePRCPlot'><p>Generate a plot with multiple PRC curves</p></a></li>
<li><a href='#multipleROCPlot'><p>Generate a plot with multiple ROC curves</p></a></li>
<li><a href='#pooledROCPlot'><p>Generate a plot with a pooled ROC curve</p></a></li>
<li><a href='#prcPlot'><p>Plot the PRC Curve for a Dataset</p></a></li>
<li><a href='#predvalPlot'><p>Plot positive and negative predictive values across different prevalences</p></a></li>
<li><a href='#regressionPlot'><p>Generate a plot which draws a regression line between the Meta Score and a continuous variable phenotype.</p></a></li>
<li><a href='#rocPlot'><p>Plot ROC Curve for a Dataset</p></a></li>
<li><a href='#runMetaAnalysis'><p>Run the meta-analysis algorithm</p></a></li>
<li><a href='#subsetOriginalData'><p>Subset samples for a particular dataset</p></a></li>
<li><a href='#summarizeFilterResults'><p>Summarize the filtered analysis results</p></a></li>
<li><a href='#summaryROCCalc'><p>Calculate the summaryROC statistics</p></a></li>
<li><a href='#summaryROCPlot'><p>Generate a plot with a summary ROC curve</p></a></li>
<li><a href='#tinyMetaObject'>
<p>A Tiny MetaObject</p></a></li>
<li><a href='#ucsc_genbank_table'>
<p>UCSC genbank table cache</p></a></li>
<li><a href='#ucsc_refseq_table'>
<p>UCSC refseq table cache</p></a></li>
<li><a href='#violinPlot'><p>Compare groups within a single dataset in a violin plot</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Meta-Analysis of Gene Expression Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-02-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Winston A. Haynes, Francesco Vallania, Aurelie Tomczak, Timothy Sweeney,
    Erika Bongen, Aditya M. Rao, Purvesh Khatri</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Aditya M. Rao &lt;adityamr@stanford.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A pipeline for the meta-analysis  of gene expression data. We have
	assembled several analysis and plot functions to
    perform integrated multi-cohort analysis of gene expression data (meta-
    analysis). Methodology described in:
	<a href="http://biorxiv.org/content/early/2016/08/25/071514">http://biorxiv.org/content/early/2016/08/25/071514</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-2">LGPL-2</a> | <a href="https://www.r-project.org/Licenses/LGPL-2.1">LGPL-2.1</a> | <a href="https://www.r-project.org/Licenses/LGPL-3">LGPL-3</a> [expanded from: LGPL]</td>
</tr>
<tr>
<td>Imports:</td>
<td>BiocManager, rmeta, multtest, ggplot2, parallel, Rmisc,
gplots, Biobase, RMySQL, DBI, stringr, preprocessCore,
GEOquery, GEOmetadb, RSQLite, data.table, ggpubr, ROCR, zoo,
pracma, COCONUT, Metrics, manhattanly, DT, pheatmap, plyr,
boot, dplyr, reshape2, rmarkdown, AnnotationDbi, HGNChelper,
magrittr, readr, plotly, httpuv</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BiocStyle, knitr, RUnit, BiocGenerics, snplist, magick</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://biorxiv.org/content/early/2016/08/25/071514">http://biorxiv.org/content/early/2016/08/25/071514</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-02-25 12:56:02 UTC; adityamr</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-02-26 13:00:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='backwardSearch'>Backward Search Function</h2><span id='topic+backwardSearch'></span>

<h3>Description</h3>

<p>Backward search is useful for reducing the size of the gene set in your filterObject. In general, backward search identifies a small set of genes with maximum ability to distinguish cases from controls.
</p>
<p>backwardSearch is a method of optimizing a given set of significant genes to maximize discriminatory power, as measured by area under the ROC curve (AUC). The function works by taking a given set of genes (presumably a set that has been filtered for statistical significance), and iteratively removing one gene at a time, until the stopping threshold is reached. At each round, the gene whose removal contributes the greatest increase in weighted AUC is removed. Weight AUC is defined as the sum of the AUC of each dataset, times the number of samples in that dataset. The stopping threshold is in units of weighted AUC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>backwardSearch(metaObject, filterObject, backThresh = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="backwardSearch_+3A_metaobject">metaObject</code></td>
<td>
<p>The metaObject from the main metaIntegrator function.</p>
</td></tr>
<tr><td><code id="backwardSearch_+3A_filterobject">filterObject</code></td>
<td>
<p>An object matching the specifications for Filter</p>
</td></tr>
<tr><td><code id="backwardSearch_+3A_backthresh">backThresh</code></td>
<td>
<p>Stopping threshold for the backward search. Default=0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The forwardSearch and backwardSearch functions are designed to assist in selection of gene sets optimized for discriminatory power. The selection of an optimized set is a non-convex problem, and hence both functions will yield gene sets that are only locally optimized (ie, they are not global optima). Both the forwardSearch and backwardSearch functions follow a greedy algorithm, either adding (or removing) genes that contribute the most (or the least) to the overall weighted AUC of the discovery datasets from the metaObject. 
</p>
<p>Both search functions allow a user to set a stopping threshold; the fundamental tradeoff here will be sparsity of the returned gene set vs. overall discriminatory power. The default threshold is 0, such the functions will return the set of genes at which no gene could be added or removed for the forward or backward functions, respectively, and increase the weighted AUC. 
</p>
<p>Note that the weighted AUC returned during the function run is dependent on sample size; this was done (instead of a simple mean) so that the gene set discriminates the MOST SAMPLES, rather than being optimized for any particular dataset.
</p>


<h3>Value</h3>

<p>A Filter  object which has results from backward search
</p>


<h3>Author(s)</h3>

<p>Timothy E. Sweeney
</p>


<h3>References</h3>

<p>Sweeney et al., Science Translational Medicine, 2015
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forwardSearch">forwardSearch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Run backward search to reduce the size of our filter results
backwardRes &lt;- backwardSearch(tinyMetaObject, tinyMetaObject$filterResults[[1]], backThresh = -3) 
#See the results
print(backwardRes$posGeneNames)
 print(backwardRes$negGeneNames)
</code></pre>

<hr>
<h2 id='calcMetaPower'>Calculates the statistical power of a random effects meta-analysis</h2><span id='topic+calcMetaPower'></span>

<h3>Description</h3>

<p>Calculates the statistical power of a random effects meta-analysis
based on the methods described by Valentine et al. 2010, J of Educational and Behavioral Studies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcMetaPower(es, avg_n, nStudies, hg, tail=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcMetaPower_+3A_es">es</code></td>
<td>
<p>effect size you're trying to detect (e.g. 0.6)</p>
</td></tr>
<tr><td><code id="calcMetaPower_+3A_avg_n">avg_n</code></td>
<td>
<p>the average sample size of each GROUP in each STUDY (e.g. 10)</p>
</td></tr>
<tr><td><code id="calcMetaPower_+3A_nstudies">nStudies</code></td>
<td>
<p>the number of studies you put in the meta-analysis (aka Discovery cohort) (e.g. 5)</p>
</td></tr>
<tr><td><code id="calcMetaPower_+3A_hg">hg</code></td>
<td>
<p>heterogeneity, (&quot;.33&quot; for small, &quot;1&quot; for moderate, &amp; &quot;3&quot; for large) (e.g. 0.33)</p>
</td></tr>
<tr><td><code id="calcMetaPower_+3A_tail">tail</code></td>
<td>
<p>whether you have a one tail or two tail p-value</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on the paper by Valentine et al.:
JC Valentine, TD Pigott, and HR Rothstein. 
How Many Studies Do You Need? A Primer on Statistical Power for Meta-Analysis
J of Educational and Behavioral Statistics
April 2010 Vol 35, No 2, pp 215-247
</p>
<p>The code itself is adapted from a blog post by 
Dan Quintana, Researcher at Oslo University in Biological Psychiatry
On the website Towards Data Science, July 2017
</p>
<p>https://towardsdatascience.com/how-to-calculate-statistical-power-for-your-meta-analysis-e108ee586ae8
</p>
<p><code>avg_n</code> is the average number people in each group in each study, so if you have
4 studies, and each study compared 10 cases and 10 controls, then <code>avg_n</code> = 10. 
</p>
<p>NOTE: THIS CODE DOES NOT TAKE MULTIPLE HYPOTHESIS TESTING INTO ACCOUNT
IT ASSUMES P&lt; 0.05
</p>
<p>For clarity, avg_n is the average number people in each group in each study, so if you have
4 studies, and each study compared 10 cases and 10 controls, then avg_n = 10.
</p>


<h3>Value</h3>

<p>Statistic <code>Power</code> of the random effects meta-analysis described. 
Most statisticians want a statistical power of at least 0.8, which means that there is an 80
that if there is a true effect, you will detect it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># effect size =0.7
# 10 samples on average in each group in each study
# 5 studies included in meta-analysis
# low heterogeneity (0.33)
calcMetaPower(es=0.7, avg_n=10, nStudies=5, hg=0.33)
</code></pre>

<hr>
<h2 id='calculateROC'>Calculate ROC Curve Statistics</h2><span id='topic+calculateROC'></span>

<h3>Description</h3>

<p>Calculates receiver operating characteristic curve data, including AUC (using trapezoidal method). Takes only a vector of labels and a vector of predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateROC(labels, predictions, AUConly = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateROC_+3A_labels">labels</code></td>
<td>
<p>Vector of labels; must have exactly two unique values (ie, cases and controls).</p>
</td></tr>
<tr><td><code id="calculateROC_+3A_predictions">predictions</code></td>
<td>
<p>Vector of predictions (for instance, test scores) to be evaluated for ability to separate the two classes. Must be exactly the same length as labels.</p>
</td></tr>
<tr><td><code id="calculateROC_+3A_auconly">AUConly</code></td>
<td>
<p>Return all ROC values, or just the AUC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The code borrows its core ROC calculations from the ROCR package. AUC is calculated by the trapezoidal method. AUC standard errors are calculated according to Hanley's method.
</p>


<h3>Value</h3>

<p>Assuming AUConly=F, returns a list of values:
</p>
<table>
<tr><td><code>roc</code></td>
<td>
<p>dataframe consisting of two columns, FPR and TPR, meant for plotting</p>
</td></tr>
<tr><td><code>auc</code></td>
<td>
<p>area under the curve</p>
</td></tr>
<tr><td><code>auc.CI</code></td>
<td>
<p>95% confidence interval for AUC</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Timothy E. Sweeney
</p>


<h3>References</h3>

<p>The code borrows its core ROC calculations from the ROCR package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculateScore">calculateScore</a></code>, <code><a href="#topic+rocPlot">rocPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># expect an AUC near 0.5 with random test
labels &lt;- c(rep(0, 500), rep(1, 500))
scores &lt;- runif(1000)
calculateROC(labels, scores)
#With the real data, AUC should be around 0.85606
scoreResults &lt;- calculateScore(tinyMetaObject$filterResults[[1]], tinyMetaObject$originalData[[1]]) 
rocRes &lt;- calculateROC(predictions=scoreResults, labels=tinyMetaObject$originalData[[1]]$class)
print(rocRes$auc[[1]])
</code></pre>

<hr>
<h2 id='calculateScore'>Calculate a signature Z-score for a set of genes in a single dataset</h2><span id='topic+calculateScore'></span>

<h3>Description</h3>

<p>Given a gene set of interest, it is often desirable to summarize the expression of that gene set using a single integrated score.
The <code>calculateScore</code> method calculates the geometric mean of the expression level of all positive genes, 
minus the geometric mean of the expression level of all negative genes. The resulting scores are then standardized within the given dataset, such that the output Z-score has mean=0 and std. dev=1.
Such a Z-score can then be used for classification, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculateScore(filterObject, datasetObject, suppressMessages=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculateScore_+3A_filterobject">filterObject</code></td>
<td>
<p>a MetaFilter object generated with <code>filterGenes()</code> containing the signature genes that will be used for Z-score calculation.</p>
</td></tr>
<tr><td><code id="calculateScore_+3A_datasetobject">datasetObject</code></td>
<td>
<p>A Dataset object for which the signature score (Z-score) will be calculated. This vector would typically be added as <code>$score</code> column in <code>datasetObject$pheno</code>.</p>
</td></tr>
<tr><td><code id="calculateScore_+3A_suppressmessages">suppressMessages</code></td>
<td>
<p>Boolean value (TRUE/FALSE) about whether to display verbose output. Default: FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Z-score is based off of the geometric mean of expression. As such, negative expression values are not allowed. A dataset is thus always scaled by its minimum value + 1, such that the lowest value = 1. Any individual NANs or NAs are also set to 1. If a dataset does not have any information on a given gene, the entire gene is simply left out of the score. When run, the function will print to command line the number of genes used, and the number passed in. 
Although mostly used internally, the function has been exported in case users want to compare multiple classes, etc., using the same Z-score as is used for producing two-class comparisons.
</p>


<h3>Value</h3>

<p>A vector of Z-scores, of length <code>ncols(datasetObject$expr)</code> (and in the same order).
</p>


<h3>Author(s)</h3>

<p>Timothy E. Sweeney, Winston A. Haynes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterGenes">filterGenes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calculateScore(tinyMetaObject$filterResults[[1]], tinyMetaObject$originalData[[1]]) 
</code></pre>

<hr>
<h2 id='checkDataObject'>Check for errors in objects used for analysis</h2><span id='topic+checkDataObject'></span>

<h3>Description</h3>

<p>Given an object to check, its objectType and the objectStage, the function <code>checkDataObject</code> looks for errors within Meta, Dataset, MetaAnalyis, or MetaFilter objects. 
It returns TRUE if the object passed error checking, FALSE otherwise, and it prints warning messages explaining failed checks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkDataObject(object, objectType, objectStage="")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkDataObject_+3A_object">object</code></td>
<td>
<p>the object to be checked</p>
</td></tr>
<tr><td><code id="checkDataObject_+3A_objecttype">objectType</code></td>
<td>
<p>one type of &quot;Meta&quot;, &quot;Dataset&quot;, &quot;MetaAnalysis&quot;, &quot;MetaFilter&quot;</p>
</td></tr>
<tr><td><code id="checkDataObject_+3A_objectstage">objectStage</code></td>
<td>
<p>if a <code>metaObject</code>, one of &quot;Pre-Analysis&quot;, &quot;Pre-Filter&quot;, or &quot;Post-Filter&quot;. Otherwise: &quot;&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>metaAnalysisObject</code> and <code>filterObject</code>, it makes sure that each entry within the object is 1) not NULL and 2) the correct type.
For <code>datasetObjects</code>, it makes sure that:
1) the entries are not null (except <code>$class</code>, which is permitted to be NULL)  
2) the entries are the correct type and     
3) the sample names (within <code>$pheno</code>, <code>$expr</code>, and <code>$class</code>) match     
4) the probeIDs (within <code>$expr</code> and <code>$keys</code>) match.    
</p>
<p>For <code>metaObject</code>, it recursively checks the Dataset, MetaAnalysis, and MetaFilter objects contained within the <code>metaObject</code>. 
</p>
<p>The <code>objectStage</code> defines what entries a <code>metaObject</code> contains. Thus, &quot;Pre-Analysis&quot; <code>metaObjects</code> only contain <code>$originalData</code>. 
&quot;Pre-Filter&quot; <code>metaObjects</code> contain <code>$originalData</code>, <code>$metaAnalysis</code>, and <code>$leaveOneOutAnalysis</code>. 
&quot;Post-Filter&quot; <code>metaObjects</code> contain <code>$originalData</code>, <code>$metaAnalysis</code>, <code>$leaveOneOutAnalysis</code>, and <code>$filterResults</code>.
</p>


<h3>Value</h3>

<p>TRUE if passed error checking, FALSE otherwise
Prints warning messages explaining the portion of the error checking failed
</p>


<h3>Author(s)</h3>

<p>Erika Bongen
</p>


<h3>Examples</h3>

<pre><code class='language-R'># check a datasetObject
checkDataObject(tinyMetaObject$originalData$Whole.Blood.Study.1, "Dataset")

# check a metaObject before running the meta-analysis 
checkDataObject(tinyMetaObject, "Meta", "Pre-Analysis")

# check a metaObject after running the meta-analysis with runMetaAnalysis()
checkDataObject(tinyMetaObject, "Meta", "Pre-Filter")

# check a metaObject after filtering the meta-analysis results with filterGenes()
checkDataObject(tinyMetaObject, "Meta", "Post-Filter")

# check a metaAnalysisObject
checkDataObject(tinyMetaObject$metaAnalysis, "MetaAnalysis")

# check a filterObject
checkDataObject(tinyMetaObject$filterResults[[1]], "MetaFilter")
</code></pre>

<hr>
<h2 id='classFunction'>Helper function to build the class vector</h2><span id='topic+classFunction'></span>

<h3>Description</h3>

<p>Helper function to build the class vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>classFunction(datasetObject, column, diseaseTerms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="classFunction_+3A_datasetobject">datasetObject</code></td>
<td>
<p>the Dataset object to build a class vector for</p>
</td></tr>
<tr><td><code id="classFunction_+3A_column">column</code></td>
<td>
<p>column from the $pheno slot to look for the disease terms</p>
</td></tr>
<tr><td><code id="classFunction_+3A_diseaseterms">diseaseTerms</code></td>
<td>
<p>a list of terms identifying the disease samples</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on a defined set of disease terms, builds a class vector.
</p>


<h3>Value</h3>

<p>returns a Dataset object that has a class vector inserted
</p>


<h3>Author(s)</h3>

<p>Winston A. Haynes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>classObj &lt;- classFunction(tinyMetaObject$originalData$Whole.Blood.Study.1, 
   column="group", diseaseTerms=c("Disease"))
</code></pre>

<hr>
<h2 id='cleanUpPheno'>Automatic preprocessing of $pheno dataframe</h2><span id='topic+cleanUpPheno'></span>

<h3>Description</h3>

<p>Takes a Dataset object and:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cleanUpPheno(myDataset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cleanUpPheno_+3A_mydataset">myDataset</code></td>
<td>
<p>a <code>datasetObject</code> that contains unprocessed <code>$pheno</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>myDataset a <code>datasetObject</code> that contains processed <code>$pheno</code> and original unprocessed <code>$rawPheno</code>
</p>


<h3>Author(s)</h3>

<p>Erika Bongen
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Download and automatically preprocess pheno
gse53195 = getGEOData("GSE53195")
gse53195 = gse53195$originalData$GSE53195
View(gse53195$pheno) # Original $pheno
gse53195 = cleanUpPheno(gse53195)
View(gse53195$rawPheno) # Original $pheno
View(gse53195$pheno) # Preprocessed $Pheno

## End(Not run)

</code></pre>

<hr>
<h2 id='coconutMetaIntegrator'>A wrapper function to run COCONUT on the MetaIntegrator objects.</h2><span id='topic+coconutMetaIntegrator'></span>

<h3>Description</h3>

<p>A wrapper function to run COCONUT on the MetaIntegrator objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coconutMetaIntegrator(metaObject, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coconutMetaIntegrator_+3A_metaobject">metaObject</code></td>
<td>
<p>a MetaIntegrator formatted Meta object.</p>
</td></tr>
<tr><td><code id="coconutMetaIntegrator_+3A_...">...</code></td>
<td>
<p>pass along arguments to COCONUT</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Results from COCONUT analysis on the MetaIntegrator object
</p>


<h3>Author(s)</h3>

<p>Winston A. Haynes
</p>

<hr>
<h2 id='ens_ensgID_table'>
ENSEMBL gene id table cache
</h2><span id='topic+ens_ensgID_table'></span>

<h3>Description</h3>

<p>Cached data to prevent cumbersome database connections.
</p>

<hr>
<h2 id='ens_entrez_table'>
ENSEMBL entrez table cache
</h2><span id='topic+ens_entrez_table'></span>

<h3>Description</h3>

<p>Cached data to prevent cumbersome database connections.
</p>

<hr>
<h2 id='filterGenes'>Filter out significant genes from meta-analysis results</h2><span id='topic+filterGenes'></span>

<h3>Description</h3>

<p>After the Meta-Analysis results have been written to the <code>metaObject</code>, 
the results can be examined using different gene filtering criteria. 
This function will use the given filterParameter to select genes that fulfill the filter conditions. 
The function returns a modified version of the <code>metaObject</code> with results stored in <code>metaObject$filterResults</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterGenes(metaObject, isLeaveOneOut = TRUE, effectSizeThresh = 0,
  FDRThresh = 0.05, numberStudiesThresh = 1,
  heterogeneityPvalThresh = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filterGenes_+3A_metaobject">metaObject</code></td>
<td>
<p>a Meta object which must have the <code>$originalData</code>, <code>$metaAnalysis</code> populated</p>
</td></tr>
<tr><td><code id="filterGenes_+3A_isleaveoneout">isLeaveOneOut</code></td>
<td>
<p>Do leave-one-out analysis on discovery datasets (default: TRUE). Needs at least 2 datasets for discovery.</p>
</td></tr>
<tr><td><code id="filterGenes_+3A_effectsizethresh">effectSizeThresh</code></td>
<td>
<p>a gene is selected, if the absolute value of its effect size is above this threshold (default: 0)</p>
</td></tr>
<tr><td><code id="filterGenes_+3A_fdrthresh">FDRThresh</code></td>
<td>
<p>FDR cutoff: a gene is selected, if it has a p-value less than or equal to the FDR cutoff (default: 0.05)</p>
</td></tr>
<tr><td><code id="filterGenes_+3A_numberstudiesthresh">numberStudiesThresh</code></td>
<td>
<p>number of studies in which a selected gene has to be significantly up/down regulated (default: 1)</p>
</td></tr>
<tr><td><code id="filterGenes_+3A_heterogeneitypvalthresh">heterogeneityPvalThresh</code></td>
<td>
<p>heterogeneity p-value cutoff (filter is off by default: <code>heterogeneityPvalThresh = 0</code>). 
Genes with significant heterogeneity and, thus a significant (low) heterogeneity p-value, can be filtered out by using e.g.: 
<code>heterogeneityPvalThresh = 0.05</code> (removes all genes with heterogeneity p-value &lt; 0.05)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of the input metaObject with an additional filterObject stored within <code>metaObject$filterResults</code>
</p>


<h3>Note</h3>

<p>Use <code>checkDataObject(metaObject, "Meta", "Pre-Filter")</code> to make sure your metaObject has the right format for filtering after running the meta-analysis with <code>runMetaAnalysis().</code>
</p>


<h3>Author(s)</h3>

<p>Francesco Vallania
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkDataObject">checkDataObject</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	# filter genes with default settings 
	#(false discovery rate cutoff of 5 percent and WITH leave-one-out analysis)
	testMetaObject &lt;- filterGenes(tinyMetaObject)
	summarizeFilterResults(testMetaObject, getMostRecentFilter(testMetaObject))
	
	# filter genes with false discovery rate of 1 percent and WITHOUT leave-one-out analysis  
	testMetaObject &lt;- filterGenes(testMetaObject, FDRThresh = 0.01, isLeaveOneOut = FALSE)
	summarizeFilterResults(testMetaObject, getMostRecentFilter(testMetaObject))
</code></pre>

<hr>
<h2 id='forestPlot'>Compare effect sizes of a gene across all datasets in meta-analysis</h2><span id='topic+forestPlot'></span>

<h3>Description</h3>

<p>A forest plot can be used to compare the expression values of a gene across different datasets. The size of the blue boxes is proportional to the number of samples in the study and light blue lines indicate the standard error of the effect sizes for each study (95% confidence interval). The summary effect size for all studies is indicated as yellow diamond below and the width of the diamond indicates the summary standard error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forestPlot(metaObject, geneName, boxColor = "blue", whiskerColor = "lightblue", 
zeroLineColor = "black", summaryColor = "orange", textColor = "red")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forestPlot_+3A_metaobject">metaObject</code></td>
<td>
<p>a filtered metaObject, i.e. it needs to include a <code>filterObject</code> generated by the function <code>filterGenes()</code></p>
</td></tr>
<tr><td><code id="forestPlot_+3A_genename">geneName</code></td>
<td>
<p>name of the gene for which the forest plot should be generated</p>
</td></tr>
<tr><td><code id="forestPlot_+3A_boxcolor">boxColor</code></td>
<td>
<p>desired color for the box (default: &quot;blue&quot;)</p>
</td></tr>
<tr><td><code id="forestPlot_+3A_whiskercolor">whiskerColor</code></td>
<td>
<p>desired color for the whiskers (default: &quot;lightblue&quot;)</p>
</td></tr>
<tr><td><code id="forestPlot_+3A_zerolinecolor">zeroLineColor</code></td>
<td>
<p>desired color for the line indicating 0 (default: &quot;black&quot;)</p>
</td></tr>
<tr><td><code id="forestPlot_+3A_summarycolor">summaryColor</code></td>
<td>
<p>desired color for the diamond representing the summary effect size (default: &quot;orange&quot;)</p>
</td></tr>
<tr><td><code id="forestPlot_+3A_textcolor">textColor</code></td>
<td>
<p>desired color for the text of the dataset names (default: &quot;red&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plot to compare effect sizes of a gene across datasets
</p>


<h3>Author(s)</h3>

<p>Winston A. Haynes, Jiaying Toh
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterGenes">filterGenes</a></code>,  <code><a href="#topic+runMetaAnalysis">runMetaAnalysis</a></code>,  <code><a href="#topic+violinPlot">violinPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compare effect sizes of the Gene1 for all discovery datasets in tinyMetaObject 
forestPlot(tinyMetaObject, geneName="Gene1")
</code></pre>

<hr>
<h2 id='forwardSearch'>Forward Search Function</h2><span id='topic+forwardSearch'></span>

<h3>Description</h3>

<p>Forward search is useful for reducing the size of the gene set in your filterObject. In general, forward search identifies a small set of genes with maximum ability to distinguish cases from controls.
</p>
<p>forwardSearch is a method of optimizing a given set of significant genes to maximize discriminatory power, as measured by area under the ROC curve (AUC). The function works by taking a given set of genes (presumably a set that has been filtered for statistical significance), and iteratively adding one gene at a time, until the stopping threshold is reached. At each round, the gene whose addition contributes the greatest increase in weighted AUC is added. Weight AUC is defined as the sum of the AUC of each dataset, times the number of samples in that dataset. The stopping threshold is in units of weighted AUC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forwardSearch(metaObject, filterObject, yes.pos = NULL, yes.neg = NULL,
  forwardThresh = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forwardSearch_+3A_metaobject">metaObject</code></td>
<td>
<p>The metaObject from the main metaIntegrator function.</p>
</td></tr>
<tr><td><code id="forwardSearch_+3A_filterobject">filterObject</code></td>
<td>
<p>An object matching the specifications for Filter</p>
</td></tr>
<tr><td><code id="forwardSearch_+3A_yes.pos">yes.pos</code></td>
<td>
<p>Optional- if passed, the forwardSearch will start with the genes in yes.pos and yes.neg (instead of starting from zero genes).</p>
</td></tr>
<tr><td><code id="forwardSearch_+3A_yes.neg">yes.neg</code></td>
<td>
<p>Optional- if passed, the forwardSearch will start with the genes in yes.pos and yes.neg (instead of starting from zero genes).</p>
</td></tr>
<tr><td><code id="forwardSearch_+3A_forwardthresh">forwardThresh</code></td>
<td>
<p>Stopping threshold for the forward search. Default=0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The forwardSearch and backwardSearch functions are designed to assist in selection of gene sets optimized for discriminatory power. The selection of an optimized set is a non-convex problem, and hence both functions will yield gene sets that are only locally optimized (ie, they are not global optima). Both the forwardSearch and backwardSearch functions follow a greedy algorithm, either adding (or removing) genes that contribute the most (or the least) to the overall weighted AUC of the discovery datasets from the metaObject. 
</p>
<p>Both search functions allow a user to set a stopping threshold; the fundamental tradeoff here will be sparsity of the returned gene set vs. overall discriminatory power. The default threshold is 0, such the functions will return the set of genes at which no gene could be added or removed for the forward or backward functions, respectively, and increase the weighted AUC. 
</p>
<p>Note that the weighted AUC returned during the function run is dependent on sample size; this was done (instead of a simple mean) so that the gene set discriminates the MOST SAMPLES, rather than being optimized for any particular dataset.
</p>


<h3>Value</h3>

<p>A Filter object which has results from forward search
</p>


<h3>Author(s)</h3>

<p>Timothy E. Sweeney
</p>


<h3>References</h3>

<p>Sweeney et al., Science Translational Medicine, 2015
</p>


<h3>See Also</h3>

<p><code><a href="#topic+backwardSearch">backwardSearch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Run forward search to reduce the size of our filter results
forwardRes &lt;- forwardSearch(tinyMetaObject,
                            tinyMetaObject$filterResults[[1]],
                            forwardThresh = 0) 
#See the results
print(forwardRes$posGeneNames)
print(forwardRes$negGeneNames)
</code></pre>

<hr>
<h2 id='geneSymbolCorrection'>Correct/update gene symbols in a metaObject</h2><span id='topic+geneSymbolCorrection'></span>

<h3>Description</h3>

<p>The gene symbols in gene expression data are sometimes outdated or incorrect, so this function goes through
your metaObject and updates the symbols based on the HGNChelper package, as well as correcting some other known issues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geneSymbolCorrection(metaObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geneSymbolCorrection_+3A_metaobject">metaObject</code></td>
<td>
<p>your metaObject</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified version of the input metaObject with updated gene symbols for each dataset in <code>metaObject$originalData</code>
</p>


<h3>Author(s)</h3>

<p>Aditya M. Rao
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tinyMetaObject = geneSymbolCorrection(tinyMetaObject)
</code></pre>

<hr>
<h2 id='getGEOData'>GEO download/processing through GEOquery</h2><span id='topic+getGEOData'></span>

<h3>Description</h3>

<p>Creates MetaIntegrator formatted objects by downloading and formatting data from GEO.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGEOData(gseVector, formattedNames = gseVector, qNorm = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGEOData_+3A_gsevector">gseVector</code></td>
<td>
<p>a vector of GSE ids (each a string)</p>
</td></tr>
<tr><td><code id="getGEOData_+3A_formattednames">formattedNames</code></td>
<td>
<p>a vector of formatted names corresponding to the GSE ids. Default: gseVector</p>
</td></tr>
<tr><td><code id="getGEOData_+3A_qnorm">qNorm</code></td>
<td>
<p>perform quantile normalization of expression data within a dataset or not. Default: FALSE</p>
</td></tr>
<tr><td><code id="getGEOData_+3A_...">...</code></td>
<td>
<p>will pass additional parameters to getGEO, including <code>destdir</code>, which specifies download location</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: if you get the error &quot;Error: Couldn't find driver MySQL&quot; then just library(RMySQL) and then re-run getGEOData
</p>


<h3>Value</h3>

<p>a Pre-Analysis MetaObject containing the datasets loaded in $originalData
</p>


<h3>Author(s)</h3>

<p>Francesco Vallania, Andrew Tam, Ravi Shankar, Aditya M. Rao
</p>

<hr>
<h2 id='getMostRecentFilter'>Get name of most recent filter</h2><span id='topic+getMostRecentFilter'></span>

<h3>Description</h3>

<p>Given a <code>metaObject</code> this function will look through <code>$filterResults</code> 
for the most recent filter used and return the filter name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getMostRecentFilter(metaObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getMostRecentFilter_+3A_metaobject">metaObject</code></td>
<td>
<p>A meta object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Name of the most recent filter
</p>


<h3>Author(s)</h3>

<p>Francesco Vallania
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	getMostRecentFilter(tinyMetaObject)
</code></pre>

<hr>
<h2 id='getSampleLevelGeneData'>Extract gene-level data from a given data object</h2><span id='topic+getSampleLevelGeneData'></span>

<h3>Description</h3>

<p>Given a <code>datsetObject</code>, and a set of target genes, this function will summarize probe-level data to gene-level data for the target genes. Returns a data frame with only the genes of interest, for each sample in the dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getSampleLevelGeneData(datasetObject, geneNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getSampleLevelGeneData_+3A_datasetobject">datasetObject</code></td>
<td>
<p>a Dataset object that is used to extract sample level data (At least, must have a <code>$expr</code> of probe-level data, and <code>$keys</code> of probe:gene mappings).</p>
</td></tr>
<tr><td><code id="getSampleLevelGeneData_+3A_genenames">geneNames</code></td>
<td>
<p>A vector of geneNames</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarizes probe-level data to gene-level data, using the mean of the probes, according to the probe:gene mapping in the <code>$keys</code> item in the dataset object. This is done only for the genes in the filter object.
</p>


<h3>Value</h3>

<p>Returns a data frame with expression levels of only the genes of interest, for each sample in the dataset. 
Mostly used internally, but has been exposed to the user to allow advanced functionality on external datasets if desired.
</p>


<h3>Author(s)</h3>

<p>Timothy E. Sweeney, Winston A. Haynes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sampleResults &lt;- getSampleLevelGeneData(datasetObject=tinyMetaObject$originalData[[1]], 
geneNames=c(tinyMetaObject$filterResults[[1]]$posGeneNames, 
  tinyMetaObject$filterResults[[1]]$negGeneNames))
</code></pre>

<hr>
<h2 id='ggForestPlot'>Compare effect sizes of a gene across all datasets in meta-analysis</h2><span id='topic+ggForestPlot'></span>

<h3>Description</h3>

<p>A forest plot can be used to compare the expression values of a gene across different datasets. 
The area of the blue boxes is proportional to the number of samples in the study and black lines indicate the standard error of the effect sizes for each study (by default the 95% confidence interval). 
The summary effect size for all studies is indicated as an orange diamond below and the width of the diamond indicates the summary standard error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggForestPlot(metaObject, genes, confLevel = 0.95, facetCols = NULL,
  facetScales = "free_x", boxScales = c(6, 16))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggForestPlot_+3A_metaobject">metaObject</code></td>
<td>
<p>a filtered metaObject, i.e. it needs to include a <code>filterObject</code> generated by the function <code>filterGenes()</code></p>
</td></tr>
<tr><td><code id="ggForestPlot_+3A_genes">genes</code></td>
<td>
<p>character vector containing the genes for which the forest plot should be generated</p>
</td></tr>
<tr><td><code id="ggForestPlot_+3A_conflevel">confLevel</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="ggForestPlot_+3A_facetcols">facetCols</code></td>
<td>
<p>integer that specifies how many columns are going to be used for the plot</p>
</td></tr>
<tr><td><code id="ggForestPlot_+3A_facetscales">facetScales</code></td>
<td>
<p>same as ggplot's facet_wrap: should Scales be fixed (&quot;fixed&quot;, the default), free (&quot;free&quot;), or free in one dimension (&quot;free_x&quot;, &quot;free_y&quot;)</p>
</td></tr>
<tr><td><code id="ggForestPlot_+3A_boxscales">boxScales</code></td>
<td>
<p>a numeric vector of length 2 providing scaling factors for the plot. Specifies minimum and maximum size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 Plot comparing effect sizes of a gene across datasets
</p>


<h3>Author(s)</h3>

<p>Winston A. Haynes, Jiaying Toh, Michele Donato
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterGenes">filterGenes</a></code>,  <code><a href="#topic+runMetaAnalysis">runMetaAnalysis</a></code>,  <code><a href="#topic+violinPlot">violinPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># compare effect sizes of the Gene1 for all discovery datasets in tinyMetaObject 
ggForestPlot(tinyMetaObject, genes="Gene1")
</code></pre>

<hr>
<h2 id='heatmapPlot'>Generates a heatmap with effect sizes for all genes which pass a filter in all measured diseases</h2><span id='topic+heatmapPlot'></span>

<h3>Description</h3>

<p>Generates a heatmap with effect sizes for all genes which pass a filter in all measured diseases
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heatmapPlot(metaObject, filterObject, colorRange = c(-1, 1),
  geneOrder = FALSE, datasetOrder = FALSE, displayPooled = TRUE,
  useFormattedNames = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heatmapPlot_+3A_metaobject">metaObject</code></td>
<td>
<p>a Meta object which must have the $originalData, $metaAnalysis populated</p>
</td></tr>
<tr><td><code id="heatmapPlot_+3A_filterobject">filterObject</code></td>
<td>
<p>a MetaFilter object containing the signature genes that will be used for the heatmap</p>
</td></tr>
<tr><td><code id="heatmapPlot_+3A_colorrange">colorRange</code></td>
<td>
<p>a vector of length two with the minimum and maximum values for the heatmap colors. (default: c(-1,1))</p>
</td></tr>
<tr><td><code id="heatmapPlot_+3A_geneorder">geneOrder</code></td>
<td>
<p>FALSE if the genes should be ordered by pooled effect size in this datasets. Otherwise, the ordered names of the genes. (default: FALSE)</p>
</td></tr>
<tr><td><code id="heatmapPlot_+3A_datasetorder">datasetOrder</code></td>
<td>
<p>FALSE if the datasets should be ordered alphabetically. Otherwise, the ordered names of the datasets (default: FALSE)</p>
</td></tr>
<tr><td><code id="heatmapPlot_+3A_displaypooled">displayPooled</code></td>
<td>
<p>TRUE if the pooled effect sizes should be displayed. (default: TRUE)</p>
</td></tr>
<tr><td><code id="heatmapPlot_+3A_useformattednames">useFormattedNames</code></td>
<td>
<p>TRUE if the formatted datasetNames should be displayed. (default: TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates a heatmap with effect sizes for all genes which pass a filter
</p>


<h3>Author(s)</h3>

<p>Winston A. Haynes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>heatmapPlot(tinyMetaObject, tinyMetaObject$filterResults[[1]])
</code></pre>

<hr>
<h2 id='immunoStatesDecov'>immunoStates deconvolution analysis on MetaIntegrator object(s)</h2><span id='topic+immunoStatesDecov'></span>

<h3>Description</h3>

<p>immunoStates deconvolution analysis on MetaIntegrator object(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>immunoStatesDecov(metaObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="immunoStatesDecov_+3A_metaobject">metaObject</code></td>
<td>
<p>a MetaIntegrator formatted Meta object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Results from immunoStates on the MetaIntegrator object are 
stored in $immunoStates of the original Meta object
</p>


<h3>Author(s)</h3>

<p>Francesco Vallania
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example won't work on tinyMetaObject because it requires real gene names
# Download the needed datasets for processing. 
sleData &lt;- getGEOData(c("GSE11909","GSE50635", "GSE39088"))

# Run immunoStates
immunoStatesEstimates &lt;- immunoStateDecov(sleData)

## End(Not run)
</code></pre>

<hr>
<h2 id='immunoStatesGenePropCorr'>Correct gene expression using cell proportions from immunoStates</h2><span id='topic+immunoStatesGenePropCorr'></span>

<h3>Description</h3>

<p>Correct gene expression using cell proportions from immunoStates
</p>


<h3>Usage</h3>

<pre><code class='language-R'>immunoStatesGenePropCorr(metaObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="immunoStatesGenePropCorr_+3A_metaobject">metaObject</code></td>
<td>
<p>a MetaIntegrator formatted Meta object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Results from immunoStates gene proportion correction on the MetaIntegrator 
object are stored in $iScorrExp of the original Meta object
</p>


<h3>Author(s)</h3>

<p>Francesco Vallania
copyright by Francesco Vallania
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example won't work on tinyMetaObject because it requires real gene names
# Download the needed datasets for processing. 
sleData &lt;- getGEOData(c("GSE11909","GSE50635", "GSE39088"))

# Run immunoStates
immunoStatesCorrected &lt;- immunoStateGenePropCorr(sleData)

## End(Not run)
</code></pre>

<hr>
<h2 id='immunoStatesMatrix'>immunoStates basis matrix</h2><span id='topic+immunoStatesMatrix'></span>

<h3>Description</h3>

<p>immunoStates basis matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("immunoStatesMatrix")</code></pre>

<hr>
<h2 id='immunoStatesMeta'>immunoStates deconvolution analysis on MetaIntegrator object(s)</h2><span id='topic+immunoStatesMeta'></span>

<h3>Description</h3>

<p>Run immunoStates and load the results into $originalData for 
running meta-analysis on the cell proportion estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>immunoStatesMeta(metaObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="immunoStatesMeta_+3A_metaobject">metaObject</code></td>
<td>
<p>a MetaIntegrator formatted Meta object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Results from immunoStates stored in $originalData
</p>


<h3>Author(s)</h3>

<p>Francesco Vallania
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Example won't work on tinyMetaObject because it requires real gene names
# Download the needed datasets for processing. 
sleData &lt;- getGEOData(c("GSE11909","GSE50635", "GSE39088"))

# Run immunoStates
immunoStatesEstimates &lt;- immunoStateMeta(sleData)

## End(Not run)
</code></pre>

<hr>
<h2 id='imputeSex'>Imputes biological sex of each sample in a Dataset object</h2><span id='topic+imputeSex'></span>

<h3>Description</h3>

<p>Imputes biological sex of each sample in a Dataset object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>imputeSex(myDataset, femGenes = NULL, malGenes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="imputeSex_+3A_mydataset">myDataset</code></td>
<td>
<p><code>datasetObject</code></p>
</td></tr>
<tr><td><code id="imputeSex_+3A_femgenes">femGenes</code></td>
<td>
<p>vector of gene symbols of genes higher expressed in females. Defaults to NULL</p>
</td></tr>
<tr><td><code id="imputeSex_+3A_malgenes">malGenes</code></td>
<td>
<p>vector of gene symbols of genes higher expressed in males. Defaults to NULL</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Imputes the sex of each sample in a Dataset object by performing K means
clustering. If genes higher expressed in females (femGenes) and genes higher
expressed in males (malGenes) are not supplied, then clustering
is performed on a default set of known X-escape genes (Tukiainen et al. 2017 Nature) 
and Y-chromosome genes. 
Genes were chosen as a subset of the immune Sex Expression Signature (iSEXS) (Bongen et al. In Prep.)
</p>
<p>Known X-Escape genes: 
&quot;XIST&quot;,&quot;RPS4X&quot;,&quot;CD40LG&quot;,&quot;ZRSR2&quot;,&quot;EFHC2&quot;,&quot;CA5B&quot;,&quot;ZFX&quot;,&quot;EIF1AX&quot;,&quot;CA5BP1&quot;,&quot;UBA1&quot;,&quot;SYAP1&quot;,&quot;DDX3X&quot;,&quot;FUNDC1&quot;,&quot;USP9X&quot;,&quot;SMC1A&quot;,&quot;NUP62CL&quot;,&quot;NAA10&quot;
</p>
<p>Y-Chromosome genes:
&quot;KDM5D&quot;,&quot;RPS4Y1&quot;,&quot;EIF1AY&quot;,&quot;USP9Y&quot;,&quot;DDX3Y&quot;,&quot;UTY&quot;,&quot;PRKY&quot;,&quot;ZFY&quot;,&quot;TMSB4Y&quot;
</p>


<h3>Value</h3>

<p>a vector indicating whether each sample is classified as &quot;male&quot; or &quot;female&quot;
</p>


<h3>Author(s)</h3>

<p>Erika Bongen
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Add sex labels to your dataset of choice
## Not run: 
myDatasets = getGEOData(c("GSE13485","GSE17156","GSE19442"))
myDatasets$originalData$GSE13485$pheno$sex = imputeSex(myDatasets$originalData$GSE13485)
myDatasets$originalData$GSE13485$pheno$sex

## End(Not run)
</code></pre>

<hr>
<h2 id='lincsBaitCorr'>Run Shane's LINCS bait-based correlation on MetaIntegrator</h2><span id='topic+lincsBaitCorr'></span>

<h3>Description</h3>

<p>LINCS Bait Corr finds perturbagens similar to a set of interest, called baits.  
It searches within a defined sub space of relevant genes, usually a disease signature
See below for an example that recreates the work we did to find the antiviral drugs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lincsBaitCorr(metaObject, filterObject, dataset = "CP", baits,
  just_clin = F, hit.number.hm = 20, hm_baits = T,
  direction = "aggravate", bait_type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lincsBaitCorr_+3A_metaobject">metaObject</code></td>
<td>
<p>a Meta object which must have the $originalData populated</p>
</td></tr>
<tr><td><code id="lincsBaitCorr_+3A_filterobject">filterObject</code></td>
<td>
<p>a MetaFilter object containing the signature genes that will be used for calculating the score</p>
</td></tr>
<tr><td><code id="lincsBaitCorr_+3A_dataset">dataset</code></td>
<td>
<p>The LINCS dataset to use. One of &quot;CP&quot; (drugs),&quot;SH&quot; (shRNA),&quot;OE&quot; (over-expression),
&quot;LIG&quot; (ligands),&quot;MUT&quot; (mutants) (default: CP)</p>
</td></tr>
<tr><td><code id="lincsBaitCorr_+3A_baits">baits</code></td>
<td>
<p>vector containing names of the baits being used (relevant drugs, shRNAs, etc.). See example.</p>
</td></tr>
<tr><td><code id="lincsBaitCorr_+3A_just_clin">just_clin</code></td>
<td>
<p>only consider clinically relevant results (default: FALSE)</p>
</td></tr>
<tr><td><code id="lincsBaitCorr_+3A_hit.number.hm">hit.number.hm</code></td>
<td>
<p>How many hits to show in a heatmap (default: 20)</p>
</td></tr>
<tr><td><code id="lincsBaitCorr_+3A_hm_baits">hm_baits</code></td>
<td>
<p>whether or not to include the baits in the heatmap (default: FALSE)</p>
</td></tr>
<tr><td><code id="lincsBaitCorr_+3A_direction">direction</code></td>
<td>
<p>one of &quot;reverse&quot;, &quot;aggravate&quot;, or &quot;absolute&quot; (default: &quot;reverse&quot;) 
for whether you want to reverse the signature, aggravate it, or just want the top absolute hits.</p>
</td></tr>
<tr><td><code id="lincsBaitCorr_+3A_bait_type">bait_type</code></td>
<td>
<p>The LINCS dataset where the baits come from. 
One of &quot;CP&quot; (drugs),&quot;SH&quot; (shRNA),&quot;OE&quot; (over-expression),
&quot;LIG&quot; (ligands),&quot;MUT&quot; (mutants), or NULL (don't specify) (default:NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The full list of correlations as well as the dataframe with the expression of the top hits.
Also generates the heatmap of the top hits.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
####### DATA SETUP ##########
# Example won't work on tinyMetaObject because it requires real gene names
# Download the needed datasets for processing. 
sleData &lt;- getGEOData(c("GSE11909","GSE50635", "GSE39088"))

#Label classes in the datasets
sleData$originalData$GSE50635 &lt;- classFunction(sleData$originalData$GSE50635, 
  column = "subject type:ch1", diseaseTerms = c("Subject RBP +", "Subject RBP -"))
sleData$originalData$GSE11909_GPL96 &lt;- classFunction(sleData$originalData$GSE11909_GPL96, 
   column = "Illness:ch1", diseaseTerms = c("SLE"))
sleData$originalData$GSE39088 &lt;- classFunction(sleData$originalData$GSE39088, 
   column= "disease state:ch1", diseaseTerms=c("SLE"))
 #Remove the GPL97 platform that was downloaded
sleData$originalData$GSE11909_GPL97 &lt;- NULL

#Run Meta-Analysis
sleMetaAnalysis &lt;- runMetaAnalysis(sleData, runLeaveOneOutAnalysis = F, maxCores = 1)

#Filter genes
sleMetaAnalysis &lt;- filterGenes(sleMetaAnalysis, isLeaveOneOut = F, 
   effectSizeThresh = 1, FDRThresh = 0.05)
####### END DATA SETUP ##########

#Note: these are note relevant baits for SLE, just examples
 lincsBaitCorr(metaObject = sleMetaAnalysis, filterObject = sleMetaAnalysis$filterResults[[1]], 
   dataset = "CP", baits = c("NICLOSAMIDE","TYRPHOSTINA9","DISULFIRAM","SU4312","RESERPINE"))
 
## End(Not run)

</code></pre>

<hr>
<h2 id='lincsCorrelate'>Run Shane's LINCS Correlate on MetaIntegrator</h2><span id='topic+lincsCorrelate'></span>

<h3>Description</h3>

<p>Run Shane's LINCS Correlate on MetaIntegrator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lincsCorrelate(metaObject, filterObject, dataset = "CP",
  hit.number.hm = 20, direction = "reverse", cor.method = "pearson",
  drop.string = NULL, just_clin = F, show_clin = F, gene_ann = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lincsCorrelate_+3A_metaobject">metaObject</code></td>
<td>
<p>a Meta object which must have the $originalData populated</p>
</td></tr>
<tr><td><code id="lincsCorrelate_+3A_filterobject">filterObject</code></td>
<td>
<p>a MetaFilter object containing the signature genes that will be used for calculating the score</p>
</td></tr>
<tr><td><code id="lincsCorrelate_+3A_dataset">dataset</code></td>
<td>
<p>The LINCS dataset to use. One of &quot;CP&quot; (drugs),&quot;SH&quot; (shRNA),&quot;OE&quot; (over-expression),
&quot;LIG&quot; (ligands),&quot;MUT&quot; (mutants) (default: CP)</p>
</td></tr>
<tr><td><code id="lincsCorrelate_+3A_hit.number.hm">hit.number.hm</code></td>
<td>
<p>How many hits to show in a heatmap (default: 20)</p>
</td></tr>
<tr><td><code id="lincsCorrelate_+3A_direction">direction</code></td>
<td>
<p>one of &quot;reverse&quot;, &quot;aggravate&quot;, or &quot;absolute&quot; (default: &quot;reverse&quot;) 
for whether you want to reverse the signature, aggravate it, or just want the top absolute hits.</p>
</td></tr>
<tr><td><code id="lincsCorrelate_+3A_cor.method">cor.method</code></td>
<td>
<p>method to use for correlation (pearson or spearman) (default: &quot;pearson&quot;)</p>
</td></tr>
<tr><td><code id="lincsCorrelate_+3A_drop.string">drop.string</code></td>
<td>
<p>lets you include a string to drop drugs that contain a regular expression.
Useful for getting rid of screening hits.  
One useful option is &quot;^BRD&quot;, which gets rid of all of the Broad screening hits that aren't characterized. (default: NULL)</p>
</td></tr>
<tr><td><code id="lincsCorrelate_+3A_just_clin">just_clin</code></td>
<td>
<p>only consider clinically relevant results (default: FALSE)</p>
</td></tr>
<tr><td><code id="lincsCorrelate_+3A_show_clin">show_clin</code></td>
<td>
<p>Generate a list of clinically relevant results (default: FALSE)</p>
</td></tr>
<tr><td><code id="lincsCorrelate_+3A_gene_ann">gene_ann</code></td>
<td>
<p>whether to annotate genes (default: FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The full list of correlations as well as the dataframe with the expression of the top hits.
Also generates the heatmap of the top hits.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
####### DATA SETUP ##########
# Example won't work on tinyMetaObject because it requires real gene names
# Download the needed datasets for processing. 
sleData &lt;- getGEOData(c("GSE11909","GSE50635", "GSE39088"))

#Label classes in the datasets
sleData$originalData$GSE50635 &lt;- classFunction(sleData$originalData$GSE50635, 
  column = "subject type:ch1", diseaseTerms = c("Subject RBP +", "Subject RBP -"))
sleData$originalData$GSE11909_GPL96 &lt;- classFunction(sleData$originalData$GSE11909_GPL96, 
   column = "Illness:ch1", diseaseTerms = c("SLE"))
sleData$originalData$GSE39088 &lt;- classFunction(sleData$originalData$GSE39088, 
   column= "disease state:ch1", diseaseTerms=c("SLE"))
 #Remove the GPL97 platform that was downloaded
sleData$originalData$GSE11909_GPL97 &lt;- NULL

#Run Meta-Analysis
sleMetaAnalysis &lt;- runMetaAnalysis(sleData, runLeaveOneOutAnalysis = F, maxCores = 1)

#Filter genes
sleMetaAnalysis &lt;- filterGenes(sleMetaAnalysis, isLeaveOneOut = F, 
   effectSizeThresh = 1, FDRThresh = 0.05)
####### END DATA SETUP ##########

 lincsCorrelate( metaObject = sleMetaAnalysis, filterObject = sleMetaAnalysis$filterResults[[1]], 
    dataset = "CP", direction = "reverse")

## End(Not run)
</code></pre>

<hr>
<h2 id='lincsTools'>Run Shane's LINCS Tools on MetaIntegrator</h2><span id='topic+lincsTools'></span>

<h3>Description</h3>

<p>Run Shane's LINCS Tools on MetaIntegrator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lincsTools(metaObject, filterObject, report.out.folder,
  hit.number.hm = 10, hit.number.tbl = 10, resize = F,
  reportTitle = "lincsReport")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lincsTools_+3A_metaobject">metaObject</code></td>
<td>
<p>a Meta object which must have the $originalData populated</p>
</td></tr>
<tr><td><code id="lincsTools_+3A_filterobject">filterObject</code></td>
<td>
<p>a MetaFilter object containing the signature genes that will be used for calculating the score</p>
</td></tr>
<tr><td><code id="lincsTools_+3A_report.out.folder">report.out.folder</code></td>
<td>
<p>Directory where a report with all figures and tables will be generated.</p>
</td></tr>
<tr><td><code id="lincsTools_+3A_hit.number.hm">hit.number.hm</code></td>
<td>
<p>How many hits to show in a heatmap (default:10)</p>
</td></tr>
<tr><td><code id="lincsTools_+3A_hit.number.tbl">hit.number.tbl</code></td>
<td>
<p>How many hits to show in a displayed table (default:10)</p>
</td></tr>
<tr><td><code id="lincsTools_+3A_resize">resize</code></td>
<td>
<p>Whether to resize tables in the way Purvesh prefers for figures (default: FALSE)</p>
</td></tr>
<tr><td><code id="lincsTools_+3A_reporttitle">reportTitle</code></td>
<td>
<p>file prefix for report outputs (default: &quot;lincsReport&quot;)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>LINCS report for the data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
####### DATA SETUP ##########
# Example won't work on tinyMetaObject because it requires real gene names
# Download the needed datasets for processing. 
sleData &lt;- getGEOData(c("GSE11909","GSE50635", "GSE39088"))

#Label classes in the datasets
sleData$originalData$GSE50635 &lt;- classFunction(sleData$originalData$GSE50635, 
  column = "subject type:ch1", diseaseTerms = c("Subject RBP +", "Subject RBP -"))
sleData$originalData$GSE11909_GPL96 &lt;- classFunction(sleData$originalData$GSE11909_GPL96, 
   column = "Illness:ch1", diseaseTerms = c("SLE"))
sleData$originalData$GSE39088 &lt;- classFunction(sleData$originalData$GSE39088, 
   column= "disease state:ch1", diseaseTerms=c("SLE"))
 #Remove the GPL97 platform that was downloaded
sleData$originalData$GSE11909_GPL97 &lt;- NULL

#Run Meta-Analysis
sleMetaAnalysis &lt;- runMetaAnalysis(sleData, runLeaveOneOutAnalysis = F, maxCores = 1)

#Filter genes
sleMetaAnalysis &lt;- filterGenes(sleMetaAnalysis, isLeaveOneOut = F, 
   effectSizeThresh = 1, FDRThresh = 0.05)
####### END DATA SETUP ##########

# Run immunoStates
 lincsTools(influenzaMeta, influenzaMeta$filterResults$FDR0.05_es0_nStudies4_looaTRUE_hetero0)

## End(Not run)
</code></pre>

<hr>
<h2 id='manhattanPlot'>Generates a Manhattan plot with effect size FDR as y-axis</h2><span id='topic+manhattanPlot'></span>

<h3>Description</h3>

<p>Generates a Manhattan plot with effect size FDR as y-axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>manhattanPlot(metaObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="manhattanPlot_+3A_metaobject">metaObject</code></td>
<td>
<p>a Meta object which must have meta-analysis run</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates a Manhattan plot with effect size FDR as y-axis
</p>


<h3>Author(s)</h3>

<p>Winston A. Haynes
</p>

<hr>
<h2 id='MetaIntegrator'>
MetaIntegrator package for meta-analysis of gene expression data 
</h2><span id='topic+MetaIntegrator'></span>

<h3>Description</h3>

<p>The package comprises several analysis and plot functions to perform integrated multi-cohort analysis of gene expression data (meta-analysis). 
</p>

<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> metaIntegrator_public</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2015-02-25</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> LGPL </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>For detailed documentation of functions and use cases read: <code>vignette(MetaIntegrator)</code>.
</p>


<h3>Details</h3>

<p>The advent of the gene expression microarray has allowed for a rapid increase in gene expression studies. There is now a wealth of publicly available gene expression data available for re-analysis. An obvious next step to increase statistical power in detecting changes in gene expression associated with some condition is to aggregate data from multiple studies. 
</p>
<p>The MetaIntegrator package will perform a DerSimonian &amp; Laird random-effects meta-analysis for each gene (not probeset) between all target studies between cases and controls; it also performs a Fischer's sum-of-logs method on the same data, and requires that a gene is significant by both methods. The resulting p-values are False discovery rate (FDR) corrected to q-values, and will evaluate the hypothesis of whether each gene is differentially expressed between cases and controls across all studies included in the analysis.
</p>
<p>The resulting list of genes with significantly different expression between cases and controls can be used for multiple purposes, such as 
(1) a new diagnostic or prognostic test for the disease of interest, 
(2) a better understanding of the underlying biology, 
(3) identification of therapeutic targets, and multiple other applications. 
</p>
<p>Our lab has already used these methods in a wide variety of diseases, including organ transplant reject, lung cancer, neurodegenerative disease, and sepsis (Khatri et al., J Exp Med 2013; Chen et al, Cancer Res 2014; Li et al., Acta Neur Comm 2014; Sweeney et al, Sci Trans Med 2015).
</p>


<h3>Author(s)</h3>

<p>Winston A. Haynes, Francesco Vallania, Aurelie Tomczak, Timothy E. Sweeney, Erika Bongen, Purvesh Khatri
</p>
<p>Maintainer: Winston A. Haynes &lt;hayneswa@stanford.edu&gt; 
</p>


<h3>References</h3>


<p>Sweeney et al., Science Translational Medicine, 2015
</p>
<p>Khatri P et al. J Exp. Med. 2013
</p>


<h3>See Also</h3>

<p>vignette(MetaIntegrator)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#Run a meta analysis. 
#   maxCores is set to 1 for package guideline compliance. 
#		For personal purposes, leave parameter un-set.
runMetaAnalysis(tinyMetaObject, maxCores=1)

#### a standard meta-analysis would follow this work flow: ####

# make input metaObjects from individual GEO datasetObjects
metaObject = list()
metaObject$originalData &lt;- tinyMetaObject$originalData
# make test datasetObject
datasetObject1 &lt;- tinyMetaObject$originalData$Whole.Blood.Study.1

# run the meta-analysis
metaObject &lt;- runMetaAnalysis(metaObject, maxCores=1)

# select significant genes (default parameter)
metaObject &lt;- filterGenes(metaObject)

# print a meta-analysis result summary for selected genes
summarizeFilterResults(metaObject, getMostRecentFilter(metaObject))

# use selected genes to generate a violin plot 
violinPlot(metaObject$filterResults$FDR0.05_es0_nStudies1_looaTRUE_hetero0, datasetObject1,
					labelColumn = 'group')

# use selected genes to generate a ROC plot 
rocPlot(metaObject$filterResults$FDR0.05_es0_nStudies1_looaTRUE_hetero0, datasetObject1)

# generate a forest plot for a gene of interest with forestPlot(metaObject, geneName)
forestPlot(metaObject, "Gene27")

## End(Not run)
</code></pre>

<hr>
<h2 id='multiplePRCPlot'>Generate a plot with multiple PRC curves</h2><span id='topic+multiplePRCPlot'></span>

<h3>Description</h3>

<p>for each dataset in the metaObject, prcPlot will return a ggplot of a Precision-Recall curve (and return the AUPRC) that describes how well a gene signature
(as defined in a <code>filterObject</code>) classifies groups in a dataset (in the form of a <code>datasetObject</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multiplePRCPlot(metaObject, filterObject, title = NULL,
  legend.names = NULL, curveColors = NULL, size = 22)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiplePRCPlot_+3A_metaobject">metaObject</code></td>
<td>
<p>a metaObject which must have <code>metaObject$originalData</code> populated with a list of <code>datasetObjects</code> that will be used for discovery</p>
</td></tr>
<tr><td><code id="multiplePRCPlot_+3A_filterobject">filterObject</code></td>
<td>
<p>a metaFilter object containing the signature genes that will be used for calculating the score</p>
</td></tr>
<tr><td><code id="multiplePRCPlot_+3A_title">title</code></td>
<td>
<p>title of the plot</p>
</td></tr>
<tr><td><code id="multiplePRCPlot_+3A_legend.names">legend.names</code></td>
<td>
<p>the name listed for each dataset in the legend (default: the <code>datasetObject$formattedName</code> for each dataset)</p>
</td></tr>
<tr><td><code id="multiplePRCPlot_+3A_curvecolors">curveColors</code></td>
<td>
<p><em>Graphical:</em> vector of colors for the PRC curves</p>
</td></tr>
<tr><td><code id="multiplePRCPlot_+3A_size">size</code></td>
<td>
<p>use this to easily increase or decrease the size of all the text in the plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each PRC plot evaluates the ability of a given gene set to separate two classes. As opposed to ROC curves, PRC curves are more sensitive to class imbalances.
The gene set is evaluated as a Z-score of the difference in means between the positive genes and the negative genes (see calculateScore).
</p>


<h3>Value</h3>

<p>Returns a ggplot PRC plot for all datasets
</p>


<h3>Author(s)</h3>

<p>Aditya M. Rao, Andrew B. Liu
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prcPlot">prcPlot</a></code>, <code><a href="#topic+multipleROCPlot">multipleROCPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>multiplePRCPlot(tinyMetaObject, filterObject = 
   tinyMetaObject$filterResults$pValueFDR0.05_es0_nStudies1_looaTRUE_hetero0)
</code></pre>

<hr>
<h2 id='multipleROCPlot'>Generate a plot with multiple ROC curves</h2><span id='topic+multipleROCPlot'></span>

<h3>Description</h3>

<p>Generate a plot with multiple ROC curves
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multipleROCPlot(metaObject, filterObject, title = "title", size = 16)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multipleROCPlot_+3A_metaobject">metaObject</code></td>
<td>
<p>a Meta object which must have the $originalData populated</p>
</td></tr>
<tr><td><code id="multipleROCPlot_+3A_filterobject">filterObject</code></td>
<td>
<p>a MetaFilter object containing the signature genes that will be used for calculating the score</p>
</td></tr>
<tr><td><code id="multipleROCPlot_+3A_title">title</code></td>
<td>
<p>title of the plot</p>
</td></tr>
<tr><td><code id="multipleROCPlot_+3A_size">size</code></td>
<td>
<p>use this to easily increase or decrease the size of all the text in the plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates an ROC plot for all datasets
</p>


<h3>Author(s)</h3>

<p>Aditya M. Rao, Andrew B. Liu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>multipleROCPlot(tinyMetaObject, filterObject = 
   tinyMetaObject$filterResults$pValueFDR0.05_es0_nStudies1_looaTRUE_hetero0)
</code></pre>

<hr>
<h2 id='pooledROCPlot'>Generate a plot with a pooled ROC curve</h2><span id='topic+pooledROCPlot'></span>

<h3>Description</h3>

<p>Given a <code>metaObject</code> with <code>$originalData</code> populated, this function calculates and
plots a &quot;pooled&quot; ROC curve that represents the average of all the individual ROC
curves. This version of the function is for use with MetaIntegrator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pooledROCPlot(metaObject, filterObject, points = 1000,
  weighting = TRUE, title = NULL, size = 14, rounding = 3,
  smoothed = FALSE, auc1.thresh = 0.99, bootReps = 1000,
  minPoints = 5, numCores = 1, method = "random")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pooledROCPlot_+3A_metaobject">metaObject</code></td>
<td>
<p>a metaObject which must have <code>metaObject$originalData</code> populated with a list of <code>datasetObjects</code> that will be used for discovery</p>
</td></tr>
<tr><td><code id="pooledROCPlot_+3A_filterobject">filterObject</code></td>
<td>
<p>a metaFilter object containing the signature genes that will be used for calculating the score</p>
</td></tr>
<tr><td><code id="pooledROCPlot_+3A_points">points</code></td>
<td>
<p>number of points to simulate for the approximated ROC curves during the linear interpolation (default: 1000)</p>
</td></tr>
<tr><td><code id="pooledROCPlot_+3A_weighting">weighting</code></td>
<td>
<p>when calculating the mean AUC, if <code>weighting</code>=TRUE then the weighted mean AUC is calculated (default: TRUE)</p>
</td></tr>
<tr><td><code id="pooledROCPlot_+3A_title">title</code></td>
<td>
<p>title of the plot</p>
</td></tr>
<tr><td><code id="pooledROCPlot_+3A_size">size</code></td>
<td>
<p>size of the text/legend/etc (default: 14)</p>
</td></tr>
<tr><td><code id="pooledROCPlot_+3A_rounding">rounding</code></td>
<td>
<p>how many digits to round the AUC and CI to (default: 3)</p>
</td></tr>
<tr><td><code id="pooledROCPlot_+3A_smoothed">smoothed</code></td>
<td>
<p>if TRUE, then a smoothed ROC curve is estimated using a modified version of the Kester and Buntinx Method</p>
</td></tr>
<tr><td><code id="pooledROCPlot_+3A_auc1.thresh">auc1.thresh</code></td>
<td>
<p>(if <code>smoothed</code>=TRUE) if the AUC of a dataset is above this threshold, then it is treated as if the AUC were 1 (default: 0.99)</p>
</td></tr>
<tr><td><code id="pooledROCPlot_+3A_bootreps">bootReps</code></td>
<td>
<p>(if <code>smoothed</code>=TRUE) number of bootstrap iterations (default: 1000)</p>
</td></tr>
<tr><td><code id="pooledROCPlot_+3A_minpoints">minPoints</code></td>
<td>
<p>(if <code>smoothed</code>=TRUE) minimum number of points required for bootstrap to be used (default: 5)</p>
</td></tr>
<tr><td><code id="pooledROCPlot_+3A_numcores">numCores</code></td>
<td>
<p>(if <code>smoothed</code>=TRUE) number of CPUs to use if parallel computing is desired (default: 1)</p>
</td></tr>
<tr><td><code id="pooledROCPlot_+3A_method">method</code></td>
<td>
<p>(if <code>smoothed</code>=TRUE) method used to compute summary meta-statistics (default: &quot;random&quot;)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To make sure the input is correctly formatted, the input <code>metaObject</code> should be checked with
<code>checkDataObject(metaObject, "Meta", "Pre-Analysis")</code> before starting the meta-analysis.
</p>
<p>By default, this average ROC curve is calculated by first using linear
interpolation to create approximated versions of each given ROC curve that all
have the same set of FPR values. A pooled ROC curve is then calculated by
taking the weighted mean of the corresponding TPR values (weighting corresponds
to the number of samples in each dataset). This pooled curve is represented as
a black curve. In addition, the weighted standard deviation is calculated for
each TPR, which is represented by a grey area on the plot. The pooled AUC is
calculated by using the trapezoid method on the pooled ROC curve, and the 95%
confidence interval of the pooled AUC is calculated using the pooled standard
error of the individual ROC curves.
</p>
<p>If <code>smoothed</code>=TRUE, then a smoothed version of the pooled ROC curve will be
plotted instead, with the surrounding gray area representing the weighted
standard deviation of the pooled ROC curve. The statistics for this smoothed
curve are based on the Kester and Buntinx Method, from (Kester and Buntinx,
<em>Med Decis Making</em>, 2000). Methods have been added by Tim Sweeney (2015) for better
estimates in cases with low numbers of tpr/fpr values. Methods have also been
added by Aditya Rao (2018) to predict the curve's alpha parameter for a given
beta parameter and AUC, as well as to calculate the weighted standard deviation
of the given ROC curves.
</p>


<h3>Value</h3>

<p>Generates a plot with each individual ROC curve as well as the pooled ROC curve
</p>


<h3>Author(s)</h3>

<p>Aditya M. Rao (with help from Hayley Warsinske and Francesco Vallania, original idea from Madeleine Scott, and some code adapted from Tim Sweeney)
</p>


<h3>References</h3>

<p>Kester and Buntinx, <em>Med Decis Making</em>, 2000
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summaryROCPlot">summaryROCPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pooledROCPlot(tinyMetaObject, filterObject = 
   tinyMetaObject$filterResults$pValueFDR0.05_es0_nStudies1_looaTRUE_hetero0)
</code></pre>

<hr>
<h2 id='prcPlot'>Plot the PRC Curve for a Dataset</h2><span id='topic+prcPlot'></span>

<h3>Description</h3>

<p>prcPlot will plot a Precision-Recall curve (and return the AUPRC) that describes how well a gene signature (as defined in a <code>filterObject</code>) classifies groups in a dataset (in the form of a <code>datasetObject</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prcPlot(filterObject, datasetObject, title = datasetObject$formattedName,
  subtitle = NULL, textSize = NULL, rounding = 3,
  curveColors = "red", legend = TRUE, PRC.lty = 1, PRC.lwd = 1,
  backgroundColor = "gray93", grid.marks = 0.1, grid.color = "white",
  grid.lty = 1, grid.lwd = 0.9, legend.lty = 0, cex.main = 1,
  cex.subtitle = 0.9)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prcPlot_+3A_filterobject">filterObject</code></td>
<td>
<p>a metaFilter object containing the signature genes that will be used for calculating the score</p>
</td></tr>
<tr><td><code id="prcPlot_+3A_datasetobject">datasetObject</code></td>
<td>
<p>a Dataset object for group comparison in the PRC plot. (At least, must have a <code>$expr</code> of probe-level data, <code>$keys</code> of probe:gene mappings, and <code>$class</code> of two-class labels.)</p>
</td></tr>
<tr><td><code id="prcPlot_+3A_title">title</code></td>
<td>
<p>title of the plot (default: <code>datasetObject$formattedName</code>)</p>
</td></tr>
<tr><td><code id="prcPlot_+3A_subtitle">subtitle</code></td>
<td>
<p>subtitle of the figure</p>
</td></tr>
<tr><td><code id="prcPlot_+3A_textsize">textSize</code></td>
<td>
<p>use this to easily increase or decrease the size of all the text in the plot</p>
</td></tr>
<tr><td><code id="prcPlot_+3A_rounding">rounding</code></td>
<td>
<p>how many digits to round the AUPRC and CI to (default: 3)</p>
</td></tr>
<tr><td><code id="prcPlot_+3A_curvecolors">curveColors</code></td>
<td>
<p><em>Graphical:</em> the color for the PRC curves (default: &quot;red&quot;)</p>
</td></tr>
<tr><td><code id="prcPlot_+3A_legend">legend</code></td>
<td>
<p><em>Graphical:</em> if TRUE, a legend will be included</p>
</td></tr>
<tr><td><code id="prcPlot_+3A_prc.lty">PRC.lty</code></td>
<td>
<p><em>Graphical:</em> PRC curve line type</p>
</td></tr>
<tr><td><code id="prcPlot_+3A_prc.lwd">PRC.lwd</code></td>
<td>
<p><em>Graphical:</em> PRC curve line width</p>
</td></tr>
<tr><td><code id="prcPlot_+3A_backgroundcolor">backgroundColor</code></td>
<td>
<p><em>Graphical:</em> background color of the plot</p>
</td></tr>
<tr><td><code id="prcPlot_+3A_grid.marks">grid.marks</code></td>
<td>
<p><em>Graphical:</em> increment between grid lines</p>
</td></tr>
<tr><td><code id="prcPlot_+3A_grid.color">grid.color</code></td>
<td>
<p><em>Graphical:</em> grid line color</p>
</td></tr>
<tr><td><code id="prcPlot_+3A_grid.lty">grid.lty</code></td>
<td>
<p><em>Graphical:</em> grid line type</p>
</td></tr>
<tr><td><code id="prcPlot_+3A_grid.lwd">grid.lwd</code></td>
<td>
<p><em>Graphical:</em> grid line width</p>
</td></tr>
<tr><td><code id="prcPlot_+3A_legend.lty">legend.lty</code></td>
<td>
<p><em>Graphical:</em> legend style (0 is no box, 1 is boxed legend)</p>
</td></tr>
<tr><td><code id="prcPlot_+3A_cex.main">cex.main</code></td>
<td>
<p><em>Graphical:</em> title size</p>
</td></tr>
<tr><td><code id="prcPlot_+3A_cex.subtitle">cex.subtitle</code></td>
<td>
<p><em>Graphical:</em> subtitle size</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Evaluates the ability of a given gene set to separate two classes. As opposed to ROC curves, PRC curves are more sensitive to class imbalances.
The gene set is evaluated as a Z-score of the difference in means between the positive genes and the negative genes (see calculateScore).
</p>


<h3>Value</h3>

<p>Returns a standard PRC plot, plus AUPRC with 95% CI (calculated with the trapezoid method).
</p>


<h3>Author(s)</h3>

<p>Aditya M. Rao, Jiaying Toh
</p>


<h3>See Also</h3>

<p><code><a href="#topic+multiplePRCPlot">multiplePRCPlot</a></code>, <code><a href="#topic+rocPlot">rocPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prcPlot(tinyMetaObject$filterResults[[1]], tinyMetaObject$originalData[[1]])
</code></pre>

<hr>
<h2 id='predvalPlot'>Plot positive and negative predictive values across different prevalences</h2><span id='topic+predvalPlot'></span>

<h3>Description</h3>

<p>Positive and negative predictive values (PPV and NPV) are two diagnostic statistics that change depending on the prevalence, so if you don't have a discrete prevalence to work with
this function can create a plot that shows the positive and negative predictive values across all possible prevalences (as long as you have already calculated the sensitivity and specificity).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>predvalPlot(sens, spec, nsteps=1000, title=NULL, rounding=2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predvalPlot_+3A_sens">sens</code></td>
<td>
<p>the sensitivity of the prediction</p>
</td></tr>
<tr><td><code id="predvalPlot_+3A_spec">spec</code></td>
<td>
<p>the specificity of the prediction</p>
</td></tr>
<tr><td><code id="predvalPlot_+3A_nsteps">nsteps</code></td>
<td>
<p>the number of steps between prevalence 0% and 100% (i.e. the number of steps in the X-axis) (default: 1000)</p>
</td></tr>
<tr><td><code id="predvalPlot_+3A_title">title</code></td>
<td>
<p>title of the plot (if left blank, it will just indicate the input sensitivity and specificity)</p>
</td></tr>
<tr><td><code id="predvalPlot_+3A_rounding">rounding</code></td>
<td>
<p>number of significant digits for displaying the sensitivity, specificity, PPV, and NPV (default: 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Plotly plot of predictive values vs. prevalence
</p>


<h3>Author(s)</h3>

<p>Lara Murphy, Aditya M. Rao
</p>


<h3>Examples</h3>

<pre><code class='language-R'>predvalPlot(sens = 0.9, spec = 0.8)
</code></pre>

<hr>
<h2 id='regressionPlot'>Generate a plot which draws a regression line between the Meta Score and a continuous variable phenotype.</h2><span id='topic+regressionPlot'></span>

<h3>Description</h3>

<p>Generate a plot which draws a regression line between the Meta Score and a continuous variable phenotype.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regressionPlot(filterObject, datasetObject,
  continuousVariableColumn = "continuous",
  formattedVariableName = "Continuous Variable", corMethod = "pearson",
  correlationCorner = "bottomRight")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regressionPlot_+3A_filterobject">filterObject</code></td>
<td>
<p>a MetaFilter object containing the signature genes that will be used for the z-score calculation</p>
</td></tr>
<tr><td><code id="regressionPlot_+3A_datasetobject">datasetObject</code></td>
<td>
<p>a Dataset object (typically independent validation dataset) for comparison in a regression plot</p>
</td></tr>
<tr><td><code id="regressionPlot_+3A_continuousvariablecolumn">continuousVariableColumn</code></td>
<td>
<p>the label of the column in $pheno that specifies the continuous variable to compare (default: 'continuousVariableColumn')</p>
</td></tr>
<tr><td><code id="regressionPlot_+3A_formattedvariablename">formattedVariableName</code></td>
<td>
<p>label which will be used on the x-axis on the plot</p>
</td></tr>
<tr><td><code id="regressionPlot_+3A_cormethod">corMethod</code></td>
<td>
<p>method which will be passed to cor.test</p>
</td></tr>
<tr><td><code id="regressionPlot_+3A_correlationcorner">correlationCorner</code></td>
<td>
<p>one of topLeft, topRight, bottomLeft, bottomRight (default: bottomRight)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a regression plot as ggplot2 plot object
</p>


<h3>Author(s)</h3>

<p>Winston A. Haynes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>regressionPlot(tinyMetaObject$filterResults[[1]], 
               tinyMetaObject$originalData$Whole.Blood.Study.1,
               continuousVariableColumn="age",
               formattedVariableName="Age")
</code></pre>

<hr>
<h2 id='rocPlot'>Plot ROC Curve for a Dataset</h2><span id='topic+rocPlot'></span>

<h3>Description</h3>

<p>rocPlot will plot an ROC curve (and return the AUC) that describes how well a gene signature (as defined in a <code>filterObject</code>) classifies groups in a dataset (in the form of a <code>datasetObject</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rocPlot(filterObject, datasetObject, title = datasetObject$formattedName)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rocPlot_+3A_filterobject">filterObject</code></td>
<td>
<p>a MetaFilter object containing the signature genes that will be used for calculation of the ROC plot.</p>
</td></tr>
<tr><td><code id="rocPlot_+3A_datasetobject">datasetObject</code></td>
<td>
<p>a Dataset object for group comparison in the ROC plot. (At least, must have a <code>$expr</code> of probe-level data, <code>$keys</code> of probe:gene mappings, and <code>$class</code> of two-class labels.)</p>
</td></tr>
<tr><td><code id="rocPlot_+3A_title">title</code></td>
<td>
<p>Title for the ROC plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Evaluates the ability of a given gene set to separate two classes. The gene set is evaluated as a Z-score of the difference in means between the positive genes and the negative genes (see calculateScore). Returns a standard ROC plot, plus AUC with 95% CI (calculated according to Hanley method).
</p>


<h3>Value</h3>

<p>Returns a ggplot2 plot object
</p>


<h3>Author(s)</h3>

<p>Timothy E. Sweeney
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calculateScore">calculateScore</a></code>, <code><a href="#topic+calculateROC">calculateROC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rocPlot(tinyMetaObject$filterResults[[1]], tinyMetaObject$originalData[[1]])
</code></pre>

<hr>
<h2 id='runMetaAnalysis'>Run the meta-analysis algorithm</h2><span id='topic+runMetaAnalysis'></span>

<h3>Description</h3>

<p>Given a <code>metaObject</code> with <code>$originalData</code> populated this function will run the meta-analysis algorithm.      
It returns a modified version of the <code>metaObject</code> with the meta-analysis results written into <code>metaObject$metaAnalysis</code> and the results of the leave-one-out analysis into <code>metaObject$leaveOneOutAnalysis</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runMetaAnalysis(metaObject, runLeaveOneOutAnalysis= TRUE, maxCores=Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runMetaAnalysis_+3A_metaobject">metaObject</code></td>
<td>
<p>a metaObject which must have <code>metaObject$originalData</code> populated with a list of <code>datasetObjects</code> that will be used for discovery</p>
</td></tr>
<tr><td><code id="runMetaAnalysis_+3A_runleaveoneoutanalysis">runLeaveOneOutAnalysis</code></td>
<td>
<p>TRUE to run leave one out analysis, FALSE otherwise (default: TRUE)</p>
</td></tr>
<tr><td><code id="runMetaAnalysis_+3A_maxcores">maxCores</code></td>
<td>
<p>maximum number of cores to use during analysis (default: Inf)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To make sure the input is correctly formatted, the input <code>metaObject</code> should be checked with <code>checkDataObject(metaObject, "Meta", "Pre-Analysis")</code> before starting the meta-analysis.
</p>


<h3>Value</h3>

<p>modified version of the <code>metaObject</code> with <code>$metaAnalysis</code> and <code>$leaveOneOutAnalysis</code> populated
</p>


<h3>Author(s)</h3>

<p>Francesco Vallania, Aditya M. Rao
</p>


<h3>See Also</h3>

<p><code><a href="#topic+checkDataObject">checkDataObject</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Run a meta analysis. 
#		maxCores is set to 1 for package guideline compliance. 
#		For personal purposes, leave parameter un-set.
runMetaAnalysis(tinyMetaObject, maxCores=1)
</code></pre>

<hr>
<h2 id='subsetOriginalData'>Subset samples for a particular dataset</h2><span id='topic+subsetOriginalData'></span>

<h3>Description</h3>

<p>Subset samples for a particular dataset
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetOriginalData(datasetObject, keepMe)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetOriginalData_+3A_datasetobject">datasetObject</code></td>
<td>
<p>the Dataset object to subset</p>
</td></tr>
<tr><td><code id="subsetOriginalData_+3A_keepme">keepMe</code></td>
<td>
<p>either a binary vector for whether each sample should be 
in the subset or a list of names of samples to be in the subset</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Subsets all relevant slots within the Dataset object to include only the 
desired samples.
</p>


<h3>Value</h3>

<p>returns a Dataset object that has been subsetted to the desired samples
</p>


<h3>Author(s)</h3>

<p>Winston A. Haynes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>subsetObject &lt;- subsetOriginalData(tinyMetaObject$originalData$Whole.Blood.Study.1, 
   keepMe= c("Sample 1", "Sample 13", "Sample 43"))
</code></pre>

<hr>
<h2 id='summarizeFilterResults'>Summarize the filtered analysis results</h2><span id='topic+summarizeFilterResults'></span>

<h3>Description</h3>

<p>Given a  <code>metaObject</code> and the name of the <code>filterObject</code> of interest, this function will print a summary style message about genes that passed the filtering step using the function <code>filterGenes()</code> and return a <code>dataFrame</code> that contains the <code>$pooledResults</code> information for each gene which passed the filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarizeFilterResults(metaObject, metaFilterLabel)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarizeFilterResults_+3A_metaobject">metaObject</code></td>
<td>
<p>the metaObject that contains the <code>filterObject</code> of interest</p>
</td></tr>
<tr><td><code id="summarizeFilterResults_+3A_metafilterlabel">metaFilterLabel</code></td>
<td>
<p>the name of a <code>filterObject</code> generated with the function <code>filterGenes()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame, which contains <code>$pooledResults</code> information for each gene which passed the filter
</p>


<h3>Author(s)</h3>

<p>Francesco Vallania
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterGenes">filterGenes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># filter genes with default settings 
#		false discovery rate cutoff of 5 percent and WITH leave-one-out analysis
testMetaObject &lt;- filterGenes(tinyMetaObject)
summarizeFilterResults(testMetaObject, getMostRecentFilter(testMetaObject))
</code></pre>

<hr>
<h2 id='summaryROCCalc'>Calculate the summaryROC statistics</h2><span id='topic+summaryROCCalc'></span>

<h3>Description</h3>

<p>Calculate the summaryROC statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryROCCalc(metaObject, filterObject, bootstrapReps = 500)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryROCCalc_+3A_metaobject">metaObject</code></td>
<td>
<p>a Meta object which must have the $originalData populated</p>
</td></tr>
<tr><td><code id="summaryROCCalc_+3A_filterobject">filterObject</code></td>
<td>
<p>a MetaFilter object containing the signature genes that will be used for calculating the score</p>
</td></tr>
<tr><td><code id="summaryROCCalc_+3A_bootstrapreps">bootstrapReps</code></td>
<td>
<p>number of bootstrap simulations to run for confidence interval on summary ROC</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary AUC statistics
</p>


<h3>Author(s)</h3>

<p>Timothy E. Sweeney
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
summaryROCCalc(tinyMetaObject, filterObject = 
   tinyMetaObject$filterResults$pValueFDR0.05_es0_nStudies1_looaTRUE_hetero0)

## End(Not run)
</code></pre>

<hr>
<h2 id='summaryROCPlot'>Generate a plot with a summary ROC curve</h2><span id='topic+summaryROCPlot'></span>

<h3>Description</h3>

<p>Generate a plot with a summary ROC curve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summaryROCPlot(metaObject, filterObject, bootstrapReps = 500,
  orderByAUC = TRUE, alphaBetaPlots = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summaryROCPlot_+3A_metaobject">metaObject</code></td>
<td>
<p>a Meta object which must have the $originalData populated</p>
</td></tr>
<tr><td><code id="summaryROCPlot_+3A_filterobject">filterObject</code></td>
<td>
<p>a MetaFilter object containing the signature genes that will be used for calculating the score</p>
</td></tr>
<tr><td><code id="summaryROCPlot_+3A_bootstrapreps">bootstrapReps</code></td>
<td>
<p>number of bootstrap simulations to run for confidence interval on summary ROC</p>
</td></tr>
<tr><td><code id="summaryROCPlot_+3A_orderbyauc">orderByAUC</code></td>
<td>
<p>if TRUE, then order legend by summary AUC. Otherwise, use default ordering.</p>
</td></tr>
<tr><td><code id="summaryROCPlot_+3A_alphabetaplots">alphaBetaPlots</code></td>
<td>
<p>if TRUE, then draw forest plots of alpha and beta. If false, suppress plotting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Generates a ROC plot for all datasets
</p>


<h3>Author(s)</h3>

<p>Timothy E. Sweeney
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
summaryROCPlot(tinyMetaObject,filterObject = 
   tinyMetaObject$filterResults$pValueFDR0.05_es0_nStudies1_looaTRUE_hetero0)

## End(Not run)
</code></pre>

<hr>
<h2 id='tinyMetaObject'>
A Tiny MetaObject
</h2><span id='topic+tinyMetaObject'></span>

<h3>Description</h3>

<p>This is a minimal working example of a MetaObject. This object is primarily used for example function calls and visualizations
</p>


<h3>Author(s)</h3>

<p>Winston A. Haynes
</p>

<hr>
<h2 id='ucsc_genbank_table'>
UCSC genbank table cache
</h2><span id='topic+ucsc_genbank_table'></span>

<h3>Description</h3>

<p>Cached data to prevent cumbersome database connections.
</p>

<hr>
<h2 id='ucsc_refseq_table'>
UCSC refseq table cache
</h2><span id='topic+ucsc_refseq_table'></span>

<h3>Description</h3>

<p>Cached data to prevent cumbersome database connections.
</p>

<hr>
<h2 id='violinPlot'>Compare groups within a single dataset in a violin plot</h2><span id='topic+violinPlot'></span>

<h3>Description</h3>

<p>Given a <code>filterObject</code> and a <code>datasetObject</code> this function will use the selected genes of the <code>filterObject</code> to calculate and compare the z-scores of the groups (e.g. cases vs. controls) from the <code>datasetObject</code> by generating a violin plot. A violin plot is similar to a box plot, except the width of each violin is proportional to the density of points. <code>violinPlot()</code> is commonly used to validate a gene signature in an independent dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>violinPlot(filterObject, datasetObject, labelColumn = "label",
  comparisonMethod = "wilcox.test", pairwiseComparisons = TRUE,
  autoLineBreak = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="violinPlot_+3A_filterobject">filterObject</code></td>
<td>
<p>a MetaFilter object containing the signature genes that will be used for the z-score calculation</p>
</td></tr>
<tr><td><code id="violinPlot_+3A_datasetobject">datasetObject</code></td>
<td>
<p>a Dataset object (typically independent validation dataset) for group comparison in a violin plot</p>
</td></tr>
<tr><td><code id="violinPlot_+3A_labelcolumn">labelColumn</code></td>
<td>
<p>the label of the column in <code>$pheno</code> that specifies the groups to compare, typically case or control (default: 'label')</p>
</td></tr>
<tr><td><code id="violinPlot_+3A_comparisonmethod">comparisonMethod</code></td>
<td>
<p>statistical test that will be used (default=&quot;wilcox.test&quot;). Other options include &quot;t.test&quot;.</p>
</td></tr>
<tr><td><code id="violinPlot_+3A_pairwisecomparisons">pairwiseComparisons</code></td>
<td>
<p>if TRUE, perform pairwise statistical comparisons against the first factor level. If FALSE, perform global statistical comparisons (default: TRUE).</p>
</td></tr>
<tr><td><code id="violinPlot_+3A_autolinebreak">autoLineBreak</code></td>
<td>
<p>if TRUE, insert line breaks into labels on plots. If FALSE, don't insert line breaks (default: TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The z-score is based off of the geometric mean of expression. As such, negative expression values are not allowed. A dataset is thus always scaled by its minimum value + 1, such that the lowest value = 1. Any individual NANs or NAs are also set to 1. If a dataset does not have any information on a given gene, the entire gene is simply left out of the score.
</p>


<h3>Value</h3>

<p>Returns a violin plot as ggplot2 plot object
</p>


<h3>Author(s)</h3>

<p>Winston A. Haynes
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filterGenes">filterGenes</a></code>,  <code><a href="#topic+runMetaAnalysis">runMetaAnalysis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>violinPlot(tinyMetaObject$filterResults$pValueFDR0.05_es0_nStudies1_looaTRUE_hetero0, 
   tinyMetaObject$originalData$Whole.Blood.Study.1, 
     labelColumn="group")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
