<!DOCTYPE html><html><head><title>Help for package flowr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {flowr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check'><p>Check consistency of flowdef and flowmat</p></a></li>
<li><a href='#check_args'><p>Assert none of the arguments of a function are null.</p></a></li>
<li><a href='#create_jobs_mat'><p>create_jobs_mat</p></a></li>
<li><a href='#error'><p>Error Handler</p></a></li>
<li><a href='#fetch'><p>Two generic functions to search for pipelines and configuration files.</p></a></li>
<li><a href='#flow-class'><p>Describing the flow class</p></a></li>
<li><a href='#flowopts'><p>Default options/params used in flowr and ngsflows</p></a></li>
<li><a href='#generate_flow_code'><p>generate_flow_code</p></a></li>
<li><a href='#get_resources'><p>Extract resources used by each job of a flow</p>
get_resources currently this only works on LSF</a></li>
<li><a href='#get_resources_lsf'><p>get_resources_lsf</p></a></li>
<li><a href='#get_unique_id'><p>get_unique_id</p></a></li>
<li><a href='#get_wds'><p>Get all the (sub)directories in a folder</p></a></li>
<li><a href='#job'><p>Describing details of the job object</p></a></li>
<li><a href='#kill'><p>Kill all jobs submitted to the computing platform, for one or multiple flows</p></a></li>
<li><a href='#plot_flow'><p>Plot a clean and scalable flowchart describing the (work)flow</p></a></li>
<li><a href='#queue-class'><p>A <code>queue</code> object defines details regarding how a job is submitted</p></a></li>
<li><a href='#replace_slots'><p>replace slots in a S4 object</p></a></li>
<li><a href='#rerun'><p>Re-run a pipeline in case of hardware or software failures.</p></a></li>
<li><a href='#run'><p>Run automated Pipelines</p></a></li>
<li><a href='#run_pipe_v2'><p>Run automated Pipelines</p></a></li>
<li><a href='#setup'><p>Setup and initialize flowr</p></a></li>
<li><a href='#status'><p>Monitor status of flow(s)</p></a></li>
<li><a href='#submit_flow'><p>Submit a flow to the cluster</p></a></li>
<li><a href='#submit_job'><p>Submit a step of a flow</p></a></li>
<li><a href='#submit_run'><p>Submit several flow objects, limit the max running concurrently</p></a></li>
<li><a href='#test_queue'><p>test_queue</p></a></li>
<li><a href='#to_df.status'><p>to_df.status</p></a></li>
<li><a href='#to_flow'><p>Create flow objects</p></a></li>
<li><a href='#to_flowdef'><p>Flow Definition defines how to stitch steps into a (work)flow.</p></a></li>
<li><a href='#to_flowdet'><p>Create a flow's submission detail file</p></a></li>
<li><a href='#to_flowmat'><p>Create a flowmat using a list a commands.</p></a></li>
<li><a href='#verbose'><p>Verbose levels, defining verboseness of messages</p></a></li>
<li><a href='#whisker_render'><p>Wrapper around whisker.render with some additional checks</p></a></li>
<li><a href='#write_flow_details'><p>Write files describing this flow</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Streamlining Design and Deployment of Complex Workflows</td>
</tr>
<tr>
<td>Description:</td>
<td>This framework allows you to design and implement complex
    pipelines, and deploy them on your institution's computing cluster. This has
    been built keeping in mind the needs of bioinformatics workflows. However, it is
    easily extendable to any field where a series of steps (shell commands) are to
    be executed in a (work)flow.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.11</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3), methods, params (&ge; 0.7), utils</td>
</tr>
<tr>
<td>Imports:</td>
<td>diagram, whisker, tools, readr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>reshape2, knitr, testthat, funr, rmarkdown</td>
</tr>
<tr>
<td>Enhances:</td>
<td>ggplot2, openxlsx, pacman, cowplot</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/flow-r/flowr">https://github.com/flow-r/flowr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/flow-r/flowr/issues">https://github.com/flow-r/flowr/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-03-02 21:43:35 UTC; sahilseth</td>
</tr>
<tr>
<td>Author:</td>
<td>Sahil Seth [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sahil Seth &lt;me@sahilseth.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-03-02 22:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='check'>Check consistency of flowdef and flowmat</h2><span id='topic+check'></span><span id='topic+check.flowmat'></span><span id='topic+check.flowdef'></span>

<h3>Description</h3>

<p>Check consistency of flowdef and flowmat, using various rules.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check(x, ...)

## S3 method for class 'flowmat'
check(x, ...)

## S3 method for class 'flowdef'
check(x, verbose = opts_flow$get("verbose"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_+3A_x">x</code></td>
<td>
<p>a flowdef or flowmat object</p>
</td></tr>
<tr><td><code id="check_+3A_...">...</code></td>
<td>
<p>Passed onto either <code>check.flowdef</code> OR <code>check.flowmat</code> functions</p>
</td></tr>
<tr><td><code id="check_+3A_verbose">verbose</code></td>
<td>
<p>A numeric value indicating the amount of messages to produce.
Values are integers varying from 0, 1, 2, 3, .... Please refer to the <a href="#topic+verbose">verbose</a> page for more details.
<code>opts_flow$get("verbose")</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>A typical output from flowdef</strong> with verbose level: 2
</p>
<pre>
checking if required columns are present...
checking if resources columns are present...
checking if dependency column has valid names...
checking if submission column has valid names...
checking for missing rows in def...
checking for extra rows in def...
checking submission and dependency types...
jobname	prev.sub_type --&gt; dep_type --&gt; sub_type: relationship
1: aln1_a	none --&gt; none --&gt; scatter 
2: aln2_a	scatter --&gt; none --&gt; scatter 
3: sampe_a	scatter --&gt; serial --&gt; scatter rel: complex one:one
4: fixrg_a	scatter --&gt; serial --&gt; scatter rel: complex one:one
5: merge_a	scatter --&gt; gather --&gt; serial rel: many:one
6: markdup_a	serial --&gt; serial --&gt; serial rel: simple one:one
7: target_a	serial --&gt; serial --&gt; serial rel: simple one:one
8: realign_a	serial --&gt; burst --&gt; scatter rel: one:many
9: baserecalib_a	scatter --&gt; serial --&gt; scatter rel: complex one:one
10: printreads_a	scatter --&gt; serial --&gt; scatter rel: complex one:one
</pre>

<hr>
<h2 id='check_args'>Assert none of the arguments of a function are null.</h2><span id='topic+check_args'></span>

<h3>Description</h3>

<p>Checks all the arguments in the parent function and makes sure that none of them
are NULL
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_args(ignore, select)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_args_+3A_ignore">ignore</code></td>
<td>
<p>optionally ignore a few variables for checking.</p>
</td></tr>
<tr><td><code id="check_args_+3A_select">select</code></td>
<td>
<p>optionally only check a few variables of the function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has now been moved to params package.
</p>

<hr>
<h2 id='create_jobs_mat'>create_jobs_mat</h2><span id='topic+create_jobs_mat'></span>

<h3>Description</h3>

<p>create_jobs_mat
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_jobs_mat(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_jobs_mat_+3A_x">x</code></td>
<td>
<p>a <a href="#topic+flow">flow</a> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This create a table similar to flowdef, except it has
jobids and previous jobids instead of only names.
This helps in creating the diagram for the flow.
Currently the only way to create a diagram is from a flow object,
by calling the function plot_flow.
</p>
<p>In future plot_flow may be able to accept a flowdef only.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
create_jobs_mat(x = x)
## End(Not run)
</code></pre>

<hr>
<h2 id='error'>Error Handler</h2><span id='topic+error'></span>

<h3>Description</h3>

<p>function to handle all error descriptions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>error(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="error_+3A_x">x</code></td>
<td>
<p>this is a string(s) with short error summary</p>
</td></tr>
</table>

<hr>
<h2 id='fetch'>Two generic functions to search for pipelines and configuration files.</h2><span id='topic+fetch'></span><span id='topic+fetch_pipes'></span><span id='topic+fetch_conf'></span>

<h3>Description</h3>

<p>These functions help in searching for specific files in the user's space.
</p>
<p><code>fetch_pipes()</code>: Fetches pipelines in the following places, in this specific order:
</p>

<ul>
<li> <p><strong>user's folder</strong>: <code>~/flowr/pipelines</code>
</p>
</li>
<li> <p><strong>current wd</strong>: <code>./</code>
</p>
</li></ul>

<p><strong>NOTE:</strong> If same pipeline is available in multiple places; intuitively, one from the later
folder would be selected. As such, giving priority to user's home, and current working 
directories.
</p>
<p>&lt;br&gt;
<code>fetch_conf()</code>: Fetches configuration files in ALL of the following places:
</p>

<ul>
<li> <p><strong>package</strong>: <code>conf</code> folders in flowr and ngsflows packages.
</p>
</li>
<li> <p><strong>user's folder</strong>: <code>~/flowr/conf</code> folder.
</p>
</li>
<li> <p><strong>current wd</strong>: <code>./</code>
</p>
</li></ul>

<p><strong>NOTE:</strong>
This function would greedily return all matching conf files. One would load all of them 
in the order returned by this function. If the same variable is
repeated in multiple files, value from later files would replace those formerly defined.
Thus ( as explained above ), giving priority to options defined in user's home and current working directories.
</p>
<p>By default flowr loads, <code>flowr.conf</code> and <code>ngsflows.conf</code>. 
See the details sections, for more explanation on this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetch(x, places, urls, verbose = opts_flow$get("verbose"))

fetch_pipes(
  x,
  places,
  last_only = FALSE,
  urls = opts_flow$get("flowr_pipe_urls"),
  silent = FALSE,
  verbose = opts_flow$get("verbose"),
  ask = TRUE
)

fetch_conf(x = "flowr.conf", places, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fetch_+3A_x">x</code></td>
<td>
<p>name of the file to search for (without extension). 
By default <a href="#topic+fetch_pipes">fetch_pipes</a> and <a href="#topic+fetch_conf">fetch_conf</a> search for files ending with 
<code>.R</code> and <code>.conf</code> respectively.</p>
</td></tr>
<tr><td><code id="fetch_+3A_places">places</code></td>
<td>
<p>places (paths) to look for files matching the name. Defaults are already defined in the function.</p>
</td></tr>
<tr><td><code id="fetch_+3A_urls">urls</code></td>
<td>
<p>urls to look for, works well for pipelines [not implemented yet]</p>
</td></tr>
<tr><td><code id="fetch_+3A_verbose">verbose</code></td>
<td>
<p>A numeric value indicating the amount of messages to produce.
Values are integers varying from 0, 1, 2, 3, .... Please refer to the <a href="#topic+verbose">verbose</a> page for more details.
<code>opts_flow$get("verbose")</code></p>
</td></tr>
<tr><td><code id="fetch_+3A_last_only">last_only</code></td>
<td>
<p>fetch_pipes():. If multiple pipelines match the pattern, return the last one. [TRUE]</p>
</td></tr>
<tr><td><code id="fetch_+3A_silent">silent</code></td>
<td>
<p>fetch_pipes(): logical, be silent even if no such pipeline is available. [FALSE]</p>
</td></tr>
<tr><td><code id="fetch_+3A_ask">ask</code></td>
<td>
<p>ask before downloading or copying. [not implemented]</p>
</td></tr>
<tr><td><code id="fetch_+3A_...">...</code></td>
<td>
<p>[not implemented]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For example flowr has a variable <code>flow_run_path</code> where it puts all the execution logs etc.
The default value is picked up from the internal <strong>flowr.conf</strong> file.
To redefine this value, one could create a new file called <strong>~/flowr/conf/flowr.conf</strong> and 
add a line:
</p>
<p><code>flow_run_path TAB my_awesome_path</code>, where <code>TAB</code> is a tab character, since these are tab 
separated files.
</p>
<p>Also, at any time you can run, <a href="#topic+opts_flow+24load">opts_flow$load</a>; to load custom options.
</p>


<h3>See Also</h3>

<p><a href="#topic+flowopts">flowopts</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## let us find a default conf file
conf = fetch_conf("flowr.conf");conf
## load this
opts_flow$load(conf)

## this returns a list, which prints pretty
pip = fetch_pipes("sleep_pipe")
pip$name
pip$pipe
pip$def

</code></pre>

<hr>
<h2 id='flow-class'>Describing the flow class</h2><span id='topic+flow-class'></span><span id='topic+flow'></span>

<h3>Description</h3>

<p>Internal function (used by <a href="#topic+to_flow">to_flow</a>), which aids in creating a flow object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flow(
  jobs = list(new("job")),
  name = "newflow",
  desc = "my_super_flow",
  mode = c("scheduler", "local"),
  flow_run_path = opts_flow$get("flow_run_path"),
  trigger_path = "",
  flow_path = "",
  version = "0.0",
  status = "created",
  module_cmds = opts_flow$get("module_cmds"),
  execute = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flow-class_+3A_jobs">jobs</code></td>
<td>
<p><code>list</code>: A list of jobs to be included in this flow</p>
</td></tr>
<tr><td><code id="flow-class_+3A_name">name</code></td>
<td>
<p><code>character</code>: Name of the flow. ['newflow']</p>
</td></tr>
<tr><td><code id="flow-class_+3A_desc">desc</code></td>
<td>
<p><code>character</code> Description of the flow, used to uniquely identify a 
flow instance. ['my_super_flow']</p>
</td></tr>
<tr><td><code id="flow-class_+3A_mode">mode</code></td>
<td>
<p><code>character</code> Mode of submission of the flow (depreciated). ['scheduler']</p>
</td></tr>
<tr><td><code id="flow-class_+3A_flow_run_path">flow_run_path</code></td>
<td>
<p>The base path of all the flows you would submit. [~/flows]</p>
</td></tr>
<tr><td><code id="flow-class_+3A_trigger_path">trigger_path</code></td>
<td>
<p><code>character</code> [<code>~/flows/trigger</code>].</p>
</td></tr>
<tr><td><code id="flow-class_+3A_flow_path">flow_path</code></td>
<td>
<p><code>character</code>: A unique path identifying a flow instance, populated by <a href="#topic+submit_flow">submit_flow</a>.</p>
</td></tr>
<tr><td><code id="flow-class_+3A_version">version</code></td>
<td>
<p>version of flowr used to create and execute this flow.</p>
</td></tr>
<tr><td><code id="flow-class_+3A_status">status</code></td>
<td>
<p><code>character</code>: Status of the flow.</p>
</td></tr>
<tr><td><code id="flow-class_+3A_module_cmds">module_cmds</code></td>
<td>
<p>[advanced use] a character vector of cmds which will be pre-pended to all script of this pipeline. 
Could be cmds like <code>`module load mytool1;module load mytool2`</code></p>
</td></tr>
<tr><td><code id="flow-class_+3A_execute">execute</code></td>
<td>
<p>execution status of flow object. [FALSE]</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>cmds = rep("sleep 5", 10)
qobj &lt;- queue(platform='torque')
## run the 10 commands in parallel
jobj1 &lt;- job(q_obj=qobj, cmd = cmds, submission_type = "scatter", name = "job1")

## run the 10 commands sequentially, but WAIT for the previous job to complete
## Many-To-One
jobj2 &lt;- job(q_obj=qobj, cmd = cmds, submission_type = "serial",
 dependency_type = "gather", previous_job = "job1", name = "job2")

## As soon as first job on 'job1' is complete
## One-To-One
jobj3 &lt;- job(q_obj=qobj, cmd = cmds, submission_type = "scatter",
 dependency_type = "serial", previous_job = "job1", name = "job3")

fobj &lt;- flow(jobs = list(jobj1, jobj2, jobj3))

## plot the flow
plot_flow(fobj)
## Not run: 
## dry run, only create the structure without submitting jobs
submit_flow(fobj)

## execute the jobs: ONLY works on computing cluster, would fail otherwise
submit_flow(fobj, execute = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='flowopts'>Default options/params used in flowr and ngsflows</h2><span id='topic+flowopts'></span><span id='topic+opts_flow'></span><span id='topic+set_opts'></span><span id='topic+get_opts'></span><span id='topic+load_opts'></span><span id='topic+opts_flow+24set'></span><span id='topic+opts_flow+24get'></span><span id='topic+opts_flow+24load'></span>

<h3>Description</h3>

<p>There are three helper functions which attempt to manage parameters used by flowr and ngsflows:
</p>

<ul>
<li> <p><a href="params.html#topic+get_opts">get_opts</a> OR <code>opts_flow\$get()</code>: show all default options
</p>
</li>
<li> <p><a href="params.html#topic+set_opts">set_opts</a> OR <code>opts_flow\$set()</code>: set default options
</p>
</li>
<li> <p><a href="params.html#topic+load_opts">load_opts</a> OR <code>opts_flow\$load()</code>: load options specified in a tab separated text file
</p>
</li></ul>

<p>For more details regarding these functions refer to <a href="http://sahilseth.com/params/">params</a> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flowopts

get_opts(...)
set_opts(...)
load_opts(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flowopts_+3A_...">...</code></td>
<td>

<ul>
<li><p> get: names of options to fetch
</p>
</li>
<li><p> set: a set of options in a name=value format separated by commas
</p>
</li></ul>
</td></tr>
</table>


<h3>Format</h3>

<p><code>opts_flow</code>
</p>
<p>An object of class <code>list</code> of length 5.
</p>


<h3>Details</h3>

<p>By default flowr loads, <code>~/flowr/conf/flowr.conf</code> and <code>~/flowr/conf/ngsflows.conf</code>
</p>
<p>Below is a list of default flowr options, retrieved via
</p>
<p><code>opts_flow$get()</code>:
</p>
<pre>
|name              |value                    |
|:-----------------|:------------------------|
|default_regex     |(.*)                     |
|flow_base_path    |~/flowr                  |
|flow_conf_path    |~/flowr/conf             |
|flow_parse_lsf    |.*(\&lt;[0-9]*\&gt;).*         |
|flow_parse_moab   |(.*)                     |
|flow_parse_sge    |(.*)                     |
|flow_parse_slurm  |(.*)                     |
|flow_parse_torque |(.?)\..*                 |
|flow_pipe_paths   |~/flowr/pipelines        |
|flow_pipe_urls    |~/flowr/pipelines        |
|flow_platform     |local                    |
|flow_run_path     |~/flowr/runs             |
|my_conf_path      |~/flowr/conf             |
|my_dir            |path/to/a/folder         |
|my_path           |~/flowr                  |
|my_tool_exe       |/usr/bin/ls              |
|time_format       |%a %b %e %H:%M:%S CDT %Y |
|verbose           |FALSE                    |
</pre>


<h3>See Also</h3>

<p><a href="#topic+fetch">fetch</a> <a href="params.html#topic+params">params</a> <a href="params.html#topic+read_sheet">read_sheet</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Set options: opts_flow$set()
opts = opts_flow$set(flow_run_path = "~/mypath")
## OR if you would like to supply a long list of options:
opts = opts_flow$set(.dots = list(flow_run_path = "~/mypath"))

## load options from a configuration file: opts_flow$load()
conffile = fetch_conf("flowr.conf")
opts_flow$load(conffile)

## Fetch options: get_opts()
opts_flow$get("flow_run_path")
opts_flow$get()

</code></pre>

<hr>
<h2 id='generate_flow_code'>generate_flow_code</h2><span id='topic+generate_flow_code'></span>

<h3>Description</h3>

<p>generate_flow_code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_flow_code(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_flow_code_+3A_x">x</code></td>
<td>
<p>flow object</p>
</td></tr>
<tr><td><code id="generate_flow_code_+3A_...">...</code></td>
<td>
<p>currently ignored</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
generate_flow_code(x = x)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_resources'>Extract resources used by each job of a flow
get_resources currently this only works on LSF</h2><span id='topic+get_resources'></span>

<h3>Description</h3>

<p>Extract resources used by each job of a flow
get_resources currently this only works on LSF
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_resources(x, odir, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_resources_+3A_x">x</code></td>
<td>
<p>A character vector of length 1. This may be a parent level folder with directories with multiple flow runs.</p>
</td></tr>
<tr><td><code id="get_resources_+3A_odir">odir</code></td>
<td>
<p>Output directory to save the results</p>
</td></tr>
<tr><td><code id="get_resources_+3A_...">...</code></td>
<td>
<p>other arguments sent to <a href="#topic+get_resources_lsf">get_resources_lsf</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>x</code> is a parent level folder, 
then resources are summarized for all its child folders.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_resources(x = x, odir = ~/tmp)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_resources_lsf'>get_resources_lsf</h2><span id='topic+get_resources_lsf'></span>

<h3>Description</h3>

<p>get_resources_lsf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_resources_lsf(
  wd,
  cores = 4,
  pattern = "out$",
  plot = FALSE,
  verbose = opts_flow$get("verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_resources_lsf_+3A_wd">wd</code></td>
<td>
<p>Path to a flow working directory</p>
</td></tr>
<tr><td><code id="get_resources_lsf_+3A_cores">cores</code></td>
<td>
<p>Number of cores to use. [Numeric]</p>
</td></tr>
<tr><td><code id="get_resources_lsf_+3A_pattern">pattern</code></td>
<td>
<p>Pattern to use to get lsf stdout files. Defaults to <code>out$</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_resources_lsf(wd = wd, cores = 4, pattern = out\$)

## End(Not run)
</code></pre>

<hr>
<h2 id='get_unique_id'>get_unique_id</h2><span id='topic+get_unique_id'></span>

<h3>Description</h3>

<p>get_unique_id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_unique_id(prefix = "id", suffix = "", random_length = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_unique_id_+3A_prefix">prefix</code></td>
<td>
<p>Default <code>id</code>. Character string to be added in the front.</p>
</td></tr>
<tr><td><code id="get_unique_id_+3A_suffix">suffix</code></td>
<td>
<p>Default &rdquo;. Character string to be added in the end.</p>
</td></tr>
<tr><td><code id="get_unique_id_+3A_random_length">random_length</code></td>
<td>
<p>Integer, defaults to 8. In our opinion 8 serves well, providing 'uniqueness' and not being much of a eyesore.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
get_unique_id(base = id, random_length = 8)
## End(Not run)
</code></pre>

<hr>
<h2 id='get_wds'>Get all the (sub)directories in a folder</h2><span id='topic+get_wds'></span>

<h3>Description</h3>

<p>Get all the (sub)directories in a folder
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_wds(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_wds_+3A_x">x</code></td>
<td>
<p>path to a folder</p>
</td></tr>
</table>

<hr>
<h2 id='job'>Describing details of the job object</h2><span id='topic+job'></span>

<h3>Description</h3>

<p>Internal function (used by to_flow), which aids in creating a job object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>job(
  cmds = "",
  name = "myjob",
  q_obj = new("queue"),
  previous_job = "",
  cpu = 1,
  memory,
  walltime,
  submission_type = c("scatter", "serial"),
  dependency_type = c("none", "gather", "serial", "burst"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="job_+3A_cmds">cmds</code></td>
<td>
<p>the commands to run</p>
</td></tr>
<tr><td><code id="job_+3A_name">name</code></td>
<td>
<p>name of the job</p>
</td></tr>
<tr><td><code id="job_+3A_q_obj">q_obj</code></td>
<td>
<p>queue object</p>
</td></tr>
<tr><td><code id="job_+3A_previous_job">previous_job</code></td>
<td>
<p>character vector of previous job. If this is the first job, one can leave this empty, NA, NULL, '.', or &rdquo;. In future this could specify multiple previous jobs.</p>
</td></tr>
<tr><td><code id="job_+3A_cpu">cpu</code></td>
<td>
<p>no of cpu's reserved</p>
</td></tr>
<tr><td><code id="job_+3A_memory">memory</code></td>
<td>
<p>The amount of memory reserved. Units depend on the platform used to process jobs</p>
</td></tr>
<tr><td><code id="job_+3A_walltime">walltime</code></td>
<td>
<p>The amount of time reserved for this job. Format is unique to a platform. Typically it looks like 12:00 (12 hours reserved, say in LSF), in Torque etc. we often see measuring in seconds: 12:00:00</p>
</td></tr>
<tr><td><code id="job_+3A_submission_type">submission_type</code></td>
<td>
<p>submission type: A character with values: scatter, serial. Scatter means all the 'cmds' would be run in parallel as separate jobs. Serial, they would combined into a single job and run one-by-one.</p>
</td></tr>
<tr><td><code id="job_+3A_dependency_type">dependency_type</code></td>
<td>
<p>dependency type. One of none, gather, serial, burst. If previous_job is specified, then this would not be 'none'. [Required]</p>
</td></tr>
<tr><td><code id="job_+3A_...">...</code></td>
<td>
<p>other passed onto object creation. Example: memory, walltime, cpu</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>qobj &lt;- queue(platform="torque")

## torque job with 1 CPU running command 'sleep 2'
jobj &lt;- job(q_obj=qobj, cmd = "sleep 2", cpu=1)

## multiple commands
cmds = rep("sleep 5", 10)

## run the 10 commands in parallel
jobj1 &lt;- job(q_obj=qobj, cmd = cmds, submission_type = "scatter", name = "job1")

## run the 10 commands sequentially, but WAIT for the previous job to complete
jobj2 &lt;- job(q_obj=qobj, cmd = cmds, submission_type = "serial",
   dependency_type = "gather", previous_job = "job1")

fobj &lt;- flow(jobs = list(jobj1, jobj2))

## plot the flow
plot_flow(fobj)
## Not run: 
## dry run, only create the structure without submitting jobs
submit_flow(fobj)

## execute the jobs: ONLY works on computing cluster, would fail otherwise
submit_flow(fobj, execute = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='kill'>Kill all jobs submitted to the computing platform, for one or multiple flows</h2><span id='topic+kill'></span><span id='topic+kill.character'></span><span id='topic+kill.flow'></span>

<h3>Description</h3>

<p>NOTE:
</p>
<p><strong>This requires files which are created at the end of the <a href="#topic+submit_flow">submit_flow</a> command</strong>.
</p>
<p>Even if you want to kill the flow, its best to let submit_flow do its job, when done simply use <code>kill(flow_wd)</code>. 
If submit_flow is interrupted, files like flow_details.rds etc are not created, thus flowr looses the association 
of jobs with flow instance and cannot monitor, kill or re-run the flow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kill(x, ...)

## S3 method for class 'character'
kill(x, force = FALSE, ...)

## S3 method for class 'flow'
kill(
  x,
  kill_cmd,
  verbose = opts_flow$get("verbose"),
  jobid_col = "job_sub_id",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kill_+3A_x">x</code></td>
<td>
<p>either path to flow wd or object of class <a href="#topic+flow">flow</a></p>
</td></tr>
<tr><td><code id="kill_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="kill_+3A_force">force</code></td>
<td>
<p>You need to set force=TRUE, to kill multiple flows. This makes sure multiple flows are NOT killed by accident.</p>
</td></tr>
<tr><td><code id="kill_+3A_kill_cmd">kill_cmd</code></td>
<td>
<p>The command used to kill. flowr tries to guess this commands, as defined in the detect_kill_cmd(). Supplying
it here; for custom platforms.</p>
</td></tr>
<tr><td><code id="kill_+3A_verbose">verbose</code></td>
<td>
<p>A numeric value indicating the amount of messages to produce.
Values are integers varying from 0, 1, 2, 3, .... Please refer to the <a href="#topic+verbose">verbose</a> page for more details.
<code>opts_flow$get("verbose")</code></p>
</td></tr>
<tr><td><code id="kill_+3A_jobid_col">jobid_col</code></td>
<td>
<p>Advanced use. The column name in 'flow_details.txt' file used to fetch jobids to kill</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

## example for terminal
## flowr kill_flow x=path_to_flow_directory
## In case path matches multiple folders, flowr asks before killing
kill(x='fastq_haplotyper*')
 Flowr: streamlining workflows
 found multiple wds:
 /fastq_haplotyper-MS132-20150825-16-24-04-0Lv1PbpI
 /fastq_haplotyper-MS132-20150825-17-47-52-5vFIkrMD
 Really kill all of them ? kill again with force=TRUE

## submitting again with force=TRUE will kill them:
kill(x='fastq_haplotyper*', force = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot_flow'>Plot a clean and scalable flowchart describing the (work)flow</h2><span id='topic+plot_flow'></span><span id='topic+plot_flow.list'></span><span id='topic+plot_flow.flow'></span><span id='topic+plot'></span><span id='topic+plot_flow.character'></span><span id='topic+plot_flow.flowdef'></span><span id='topic+plot.flowdef'></span><span id='topic+plot.flow'></span>

<h3>Description</h3>

<p>Plot a flowchart using a flow object or flowdef
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_flow(x, ...)

## S3 method for class 'flow'
plot_flow(x, ...)

## S3 method for class 'list'
plot_flow(x, ...)

## S3 method for class 'character'
plot_flow(x, ...)

## S3 method for class 'flowdef'
plot_flow(x, detailed = TRUE, type = c("1", "2"), pdf = FALSE, pdffile, ...)

## S3 method for class 'flowdef'
plot(x, detailed = TRUE, type = c("1", "2"), pdf = FALSE, pdffile, ...)

## S3 method for class 'flow'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_flow_+3A_x">x</code></td>
<td>
<p>Object of class <code>flow</code>, or a list of flow objects or a flowdef</p>
</td></tr>
<tr><td><code id="plot_flow_+3A_...">...</code></td>
<td>
<p>experimental and only for advanced use.</p>
</td></tr>
<tr><td><code id="plot_flow_+3A_detailed">detailed</code></td>
<td>
<p>include submission and dependency types in the plot [TRUE]</p>
</td></tr>
<tr><td><code id="plot_flow_+3A_type">type</code></td>
<td>
<p>1 is original, and 2 is a ellipse with less details [1]</p>
</td></tr>
<tr><td><code id="plot_flow_+3A_pdf">pdf</code></td>
<td>
<p>create a pdf instead of plotting interactively [FALSE]</p>
</td></tr>
<tr><td><code id="plot_flow_+3A_pdffile">pdffile</code></td>
<td>
<p>output file name for the pdf file. [<code>flow_path/flow_details.pdf</code>]</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>qobj = queue(type="lsf")
cmds = rep("sleep 5", 10)
jobj1 &lt;- job(q_obj=qobj, cmd = cmds, submission_type = "scatter", name = "job1")
jobj2 &lt;- job(q_obj=qobj, name = "job2", cmd = cmds, submission_type = "scatter",
             dependency_type = "serial", previous_job = "job1")
fobj &lt;- flow(jobs = list(jobj1, jobj2))
plot_flow(fobj)

### Gather: many to one relationship
jobj1 &lt;- job(q_obj=qobj, cmd = cmds, submission_type = "scatter", name = "job1")
jobj2 &lt;- job(q_obj=qobj, name = "job2", cmd = cmds, submission_type = "scatter",
             dependency_type = "gather", previous_job = "job1")
fobj &lt;- flow(jobs = list(jobj1, jobj2))
plot_flow(fobj)

### Burst: one to many relationship
jobj1 &lt;- job(q_obj=qobj, cmd = cmds, submission_type = "serial", name = "job1")
jobj2 &lt;- job(q_obj=qobj, name = "job2", cmd = cmds, submission_type = "scatter",
             dependency_type = "burst", previous_job = "job1")
fobj &lt;- flow(jobs = list(jobj1, jobj2))
plot_flow(fobj)

</code></pre>

<hr>
<h2 id='queue-class'>A <code>queue</code> object defines details regarding how a job is submitted</h2><span id='topic+queue-class'></span><span id='topic+queue'></span>

<h3>Description</h3>

<p>Internal function (used by <a href="#topic+to_flow">to_flow</a>), to define the format used to submit a job.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>queue(
  object,
  platform = c("local", "lsf", "torque", "sge", "moab", "test", "slurm"),
  format = "",
  queue = "long",
  walltime,
  memory,
  cpu = 1,
  extra_opts = "",
  submit_exe,
  nodes = "1",
  jobname = "name",
  email = Sys.getenv("USER"),
  dependency = list(),
  server = "localhost",
  verbose = FALSE,
  cwd = "",
  stderr = "",
  stdout = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="queue-class_+3A_object">object</code></td>
<td>
<p>this is not used currently, ignore.</p>
</td></tr>
<tr><td><code id="queue-class_+3A_platform">platform</code></td>
<td>
<p>Required and important. Currently supported values are 'lsf' and 'torque'. [Used by class job]</p>
</td></tr>
<tr><td><code id="queue-class_+3A_format">format</code></td>
<td>
<p>[advanced use] We have a default format for the final command line string generated for 'lsf' and 'torque'.</p>
</td></tr>
<tr><td><code id="queue-class_+3A_queue">queue</code></td>
<td>
<p>the type of queue your group usually uses
'bsub' etc.</p>
</td></tr>
<tr><td><code id="queue-class_+3A_walltime">walltime</code></td>
<td>
<p>max walltime of a job.</p>
</td></tr>
<tr><td><code id="queue-class_+3A_memory">memory</code></td>
<td>
<p>The amount of memory reserved. Units depend on the platform used to process jobs</p>
</td></tr>
<tr><td><code id="queue-class_+3A_cpu">cpu</code></td>
<td>
<p>number of cpus you would like to reserve [Used by class job]</p>
</td></tr>
<tr><td><code id="queue-class_+3A_extra_opts">extra_opts</code></td>
<td>
<p>[advanced use] Extra options to be supplied while create the job submission string.</p>
</td></tr>
<tr><td><code id="queue-class_+3A_submit_exe">submit_exe</code></td>
<td>
<p>[advanced use] Already defined by 'platform'. The exact command used to submit jobs to the cluster example 'qsub'</p>
</td></tr>
<tr><td><code id="queue-class_+3A_nodes">nodes</code></td>
<td>
<p>[advanced use] number of nodes you would like to request. Or in case of torque name of the nodes.<em>optional</em> [Used by class job]</p>
</td></tr>
<tr><td><code id="queue-class_+3A_jobname">jobname</code></td>
<td>
<p>[debug use] name of this job in the computing cluster</p>
</td></tr>
<tr><td><code id="queue-class_+3A_email">email</code></td>
<td>
<p>[advanced use] Defaults to system user, you may put you own email though may get tons of them.</p>
</td></tr>
<tr><td><code id="queue-class_+3A_dependency">dependency</code></td>
<td>
<p>[debug use] a list of jobs to complete before starting this one</p>
</td></tr>
<tr><td><code id="queue-class_+3A_server">server</code></td>
<td>
<p>[not used] This is not implemented currently. This would specify the head node of the computing cluster. At this time submission needs to be done on the head node of the cluster where flow is to be submitted</p>
</td></tr>
<tr><td><code id="queue-class_+3A_verbose">verbose</code></td>
<td>
<p>[logical] TRUE/FALSE</p>
</td></tr>
<tr><td><code id="queue-class_+3A_cwd">cwd</code></td>
<td>
<p>[debug use] Ignore</p>
</td></tr>
<tr><td><code id="queue-class_+3A_stderr">stderr</code></td>
<td>
<p>[debug use] Ignore</p>
</td></tr>
<tr><td><code id="queue-class_+3A_stdout">stdout</code></td>
<td>
<p>[debug use] Ignore</p>
</td></tr>
<tr><td><code id="queue-class_+3A_...">...</code></td>
<td>
<p>other passed onto object creation. Example: memory, walltime, cpu</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Resources</strong>:
Can be defined **once** using a <a href="#topic+queue">queue</a> object and recycled to all the jobs in a flow. If resources (like memory, cpu, walltime, queue) are supplied at the
job level they overwrite the one supplied in <a href="#topic+queue">queue</a>
Nodes: can be supplied to extend a job across multiple nodes. This is purely experimental and not supported.
</p>
<p><strong>Server</strong>:
This a hook which may be implemented in future.
</p>
<p><strong>Submission script</strong>
The 'platform' variable defines the format, and submit_exe; however these two are available for someone to create a custom submission command.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qobj &lt;- queue(platform='lsf')
</code></pre>

<hr>
<h2 id='replace_slots'>replace slots in a S4 object</h2><span id='topic+replace_slots'></span>

<h3>Description</h3>

<p>replace slots in a S4 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>replace_slots(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="replace_slots_+3A_object">object</code></td>
<td>
<p>a S4 object</p>
</td></tr>
<tr><td><code id="replace_slots_+3A_...">...</code></td>
<td>
<p>set of slot names to be replaced. This needs to be a named vector</p>
</td></tr>
</table>

<hr>
<h2 id='rerun'>Re-run a pipeline in case of hardware or software failures.</h2><span id='topic+rerun'></span><span id='topic+rerun.character'></span><span id='topic+rerun.flow'></span>

<h3>Description</h3>


<ul>
<li> <p><strong>hardware</strong> no change required, simple rerun: <code>rerun(x=flow_wd)</code>
</p>
</li>
<li> <p><strong>software</strong> either a change to flowmat or flowdef has been made: <code>rerun(x=flow_wd, mat = new_flowmat, def = new_flowdef)</code>
</p>
</li></ul>

<p><strong>NOTE:</strong>
</p>
<p><em>flow_wd</em>: flow working directory, same input as used for <a href="#topic+status">status</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rerun(x, ...)

## S3 method for class 'character'
rerun(x, ...)

## S3 method for class 'flow'
rerun(
  x,
  mat,
  def,
  start_from,
  samplename,
  execute = TRUE,
  kill = TRUE,
  select,
  ignore,
  verbose = opts_flow$get("verbose"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rerun_+3A_x">x</code></td>
<td>
<p>flow working directory</p>
</td></tr>
<tr><td><code id="rerun_+3A_...">...</code></td>
<td>
<p>passed onto to_flow</p>
</td></tr>
<tr><td><code id="rerun_+3A_mat">mat</code></td>
<td>
<p>(optional) flowmat fetched from previous submission if missing. For more information regarding the format refer to <a href="#topic+to_flowmat">to_flowmat</a></p>
</td></tr>
<tr><td><code id="rerun_+3A_def">def</code></td>
<td>
<p>(optional) flowdef fetched from previous submission if missing.  For more information regarding the format refer to <a href="#topic+to_flowdef">to_flowdef</a></p>
</td></tr>
<tr><td><code id="rerun_+3A_start_from">start_from</code></td>
<td>
<p>(required) which job to start from, this is a job name.</p>
</td></tr>
<tr><td><code id="rerun_+3A_samplename">samplename</code></td>
<td>
<p>(optional) If flowmat contains multiple samples, provide the samplename, 
corresponding to the flow working directory provided.</p>
</td></tr>
<tr><td><code id="rerun_+3A_execute">execute</code></td>
<td>
<p>[logical] whether to execute or not</p>
</td></tr>
<tr><td><code id="rerun_+3A_kill">kill</code></td>
<td>
<p>(optional) logical indicating whether to kill the jobs from the previous execution of flow.</p>
</td></tr>
<tr><td><code id="rerun_+3A_select">select</code></td>
<td>
<p>(optional) select a subset of jobs to rerun [character vector]</p>
</td></tr>
<tr><td><code id="rerun_+3A_ignore">ignore</code></td>
<td>
<p>(optional) ignore a subset of jobs to rerun [character vector]</p>
</td></tr>
<tr><td><code id="rerun_+3A_verbose">verbose</code></td>
<td>
<p>A numeric value indicating the amount of messages to produce.
Values are integers varying from 0, 1, 2, 3, .... Please refer to the <a href="#topic+verbose">verbose</a> page for more details.
<code>opts_flow$get("verbose")</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function fetches details regarding the previous execution from the flow working directory (flow_wd). 
</p>
<p>It reads the <a href="#topic+flow">flow</a> object from the flow_details.rds file, and extracts flowdef and flowmat from it 
using <a href="#topic+to_flowmat">to_flowmat</a> and <a href="#topic+to_flowdef">to_flowdef</a> functions.
</p>
<p><strong>Using new flowmat OR flowdef for re-run</strong>:
</p>
<p>Optionally, if either of flowmat or flowdef are supplied; supplied ones are used instead of those
extracted from previous submission.
</p>
<p>This functions efficiently updates job details of the latest submission into the previous file; thus information
regarding previous job ids and their status is not lost.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

# 
rerun(wd = wd, fobj = fobj, execute = TRUE, kill = TRUE)


## End(Not run)
</code></pre>

<hr>
<h2 id='run'>Run automated Pipelines</h2><span id='topic+run'></span><span id='topic+run_flow'></span><span id='topic+run_pipe'></span>

<h3>Description</h3>

<p>Run complete pipelines, by wrapping several steps into one 
convenient function.
</p>
<p>NOTE: please use flowr version 0.9.8.9010 or higher.
</p>
<p>In summary, this function performs the following steps:
</p>

<ul>
<li><p> the argument <code>x</code> defines the name of the pipeline. 
Say, for example <code>sleep_pipe</code>.
</p>
</li>
<li> <p><a href="#topic+fetch_pipes">fetch_pipes</a>: finds the pipeline definition 
(<code>sleep_pipe.R</code>, <code>sleep_pipe.def</code> and
<code>sleep_pipe.conf</code> files)
</p>
</li>
<li> <p><code>sleep_pipe(...)</code>: Create all the required commands 
(<code>flowmat</code>)
</p>
</li>
<li> <p><a href="#topic+to_flow">to_flow</a>: Use <code>flowmat</code> and 
<code>sleep_pipe.def</code> to create a flow object.
</p>
</li>
<li> <p><a href="#topic+submit_flow">submit_flow</a>: Submit the flow to the cluster.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>run(
  x,
  platform,
  def,
  conf,
  wd = opts_flow$get("flow_run_path"),
  flow_run_path = wd,
  rerun_wd,
  start_from,
  execute = FALSE,
  ...
)

run_pipe(
  x,
  platform,
  def,
  conf,
  wd = opts_flow$get("flow_run_path"),
  flow_run_path = wd,
  rerun_wd,
  start_from,
  execute = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_+3A_x">x</code></td>
<td>
<p>name of the pipeline to run. This is a function called to create a flow_mat.</p>
</td></tr>
<tr><td><code id="run_+3A_platform">platform</code></td>
<td>
<p>what platform to use, overrides flowdef</p>
</td></tr>
<tr><td><code id="run_+3A_def">def</code></td>
<td>
<p>flow definition</p>
</td></tr>
<tr><td><code id="run_+3A_conf">conf</code></td>
<td>
<p>a tab-delimited configuration file with path to tools and default parameters. See <a href="#topic+fetch_pipes">fetch_pipes</a>.</p>
</td></tr>
<tr><td><code id="run_+3A_wd">wd</code></td>
<td>
<p>an alias to flow_run_path</p>
</td></tr>
<tr><td><code id="run_+3A_flow_run_path">flow_run_path</code></td>
<td>
<p>passed onto to_flow. Default it picked up from flowr.conf. Typically this is ~/flowr/runs</p>
</td></tr>
<tr><td><code id="run_+3A_rerun_wd">rerun_wd</code></td>
<td>
<p>if you need to re-run, supply the previous working dir</p>
</td></tr>
<tr><td><code id="run_+3A_start_from">start_from</code></td>
<td>
<p>the step to start a rerun from. Intuitively, this is ignored in a fresh run and only used in re-running a pipeline.</p>
</td></tr>
<tr><td><code id="run_+3A_execute">execute</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="run_+3A_...">...</code></td>
<td>
<p>passed onto the pipeline function as specified in x</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

## Run a short pipeline (dry run)
run("sleep_pipe")

## Run a short pipeline on the local machine
run("sleep_pipe", platform = "local", execute = TRUE)

## Run a short pipeline on the a torque cluster (qsub)
run("sleep_pipe", platform = "torque", execute = TRUE)

## Run a short pipeline on the a MOAB cluster (msub)
run("sleep_pipe", platform = "moab", execute = TRUE)

## Run a short pipeline on the a IBM (LSF) cluster (bsub)
run("sleep_pipe", platform = "lsf", execute = TRUE)

## Run a short pipeline on the a MOAB cluster (msub)
run("sleep_pipe", platform = "moab", execute = TRUE)

## change parameters of the pipeline
## All extra parameters are passed on to the function function.
run("sleep_pipe", platform = "lsf", execute = TRUE, x = 5)


## End(Not run)
</code></pre>

<hr>
<h2 id='run_pipe_v2'>Run automated Pipelines</h2><span id='topic+run_pipe_v2'></span>

<h3>Description</h3>

<p>Run complete pipelines, by wrapping several steps into one 
convenient function.
</p>
<p>NOTE: please use flowr version 0.9.8.9010 or higher.
</p>
<p>In summary, this function performs the following steps:
</p>

<ul>
<li><p> the argument <code>x</code> defines the name of the pipeline. 
Say, for example <code>sleep_pipe</code>.
</p>
</li>
<li> <p><a href="#topic+fetch_pipes">fetch_pipes</a>: finds the pipeline definition 
(<code>sleep_pipe.R</code>, <code>sleep_pipe.def</code> and
<code>sleep_pipe.conf</code> files)
</p>
</li>
<li> <p><code>sleep_pipe(...)</code>: Create all the required commands 
(<code>flowmat</code>)
</p>
</li>
<li> <p><a href="#topic+to_flow">to_flow</a>: Use <code>flowmat</code> and 
<code>sleep_pipe.def</code> to create a flow object.
</p>
</li>
<li> <p><a href="#topic+submit_flow">submit_flow</a>: Submit the flow to the cluster.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>run_pipe_v2(
  pipe_func,
  pipe_src,
  flow_def,
  flow_conf,
  flowname,
  platform,
  flow_run_path = opts_flow$get("flow_run_path"),
  rerun_wd,
  start_from,
  execute = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="run_pipe_v2_+3A_pipe_func">pipe_func</code></td>
<td>
<p>name of the pipeline function in 'pipe_src'</p>
</td></tr>
<tr><td><code id="run_pipe_v2_+3A_pipe_src">pipe_src</code></td>
<td>
<p>path to pipeline script</p>
</td></tr>
<tr><td><code id="run_pipe_v2_+3A_flow_def">flow_def</code></td>
<td>
<p>flow definition file</p>
</td></tr>
<tr><td><code id="run_pipe_v2_+3A_flow_conf">flow_conf</code></td>
<td>
<p>flow conf file with various parameters used by the flow</p>
</td></tr>
<tr><td><code id="run_pipe_v2_+3A_flowname">flowname</code></td>
<td>
<p>name for the flow for submission.</p>
</td></tr>
<tr><td><code id="run_pipe_v2_+3A_platform">platform</code></td>
<td>
<p>what platform to use, overrides flowdef</p>
</td></tr>
<tr><td><code id="run_pipe_v2_+3A_flow_run_path">flow_run_path</code></td>
<td>
<p>passed onto to_flow. Default it picked up from flowr.conf. Typically this is ~/flowr/runs</p>
</td></tr>
<tr><td><code id="run_pipe_v2_+3A_rerun_wd">rerun_wd</code></td>
<td>
<p>if you need to re-run, supply the previous working dir</p>
</td></tr>
<tr><td><code id="run_pipe_v2_+3A_start_from">start_from</code></td>
<td>
<p>the step to start a rerun from. Intuitively, this is ignored in a fresh run and only used in re-running a pipeline.</p>
</td></tr>
<tr><td><code id="run_pipe_v2_+3A_execute">execute</code></td>
<td>
<p>TRUE/FALSE</p>
</td></tr>
<tr><td><code id="run_pipe_v2_+3A_...">...</code></td>
<td>
<p>passed onto the pipeline function as specified in x</p>
</td></tr>
</table>

<hr>
<h2 id='setup'>Setup and initialize flowr</h2><span id='topic+setup'></span>

<h3>Description</h3>

<p>This functions creates a directory structure in user's home directory. 
Additionally it creates a shortcut to the <code>flowr</code> helper script in <code>~/bin</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setup(
  bin = "~/bin",
  flow_base_path = opts_flow$get("flow_base_path"),
  flow_run_path = opts_flow$get("flow_run_path"),
  flow_conf_path = opts_flow$get("flow_conf_path"),
  flow_pipe_path = opts_flow$get("flow_pipe_paths")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setup_+3A_bin">bin</code></td>
<td>
<p>path to bin folder</p>
</td></tr>
<tr><td><code id="setup_+3A_flow_base_path">flow_base_path</code></td>
<td>
<p>The base of flowr configuration and execution folders.</p>
</td></tr>
<tr><td><code id="setup_+3A_flow_run_path">flow_run_path</code></td>
<td>
<p>base path to be used for execution of this flow. 
flowr would create a new time-stamped folder in this base path and 
use it for logs, scripts etc. 
The default is retrieved using <code>opts_flow$get("flow_run_path")</code>.</p>
</td></tr>
<tr><td><code id="setup_+3A_flow_conf_path">flow_conf_path</code></td>
<td>
<p>Flowr configuration folder, used by <a href="#topic+fetch_conf">fetch_conf</a>.</p>
</td></tr>
<tr><td><code id="setup_+3A_flow_pipe_path">flow_pipe_path</code></td>
<td>
<p>Folder with all pipelines, used by <a href="#topic+fetch_pipes">fetch_pipes</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Will add more to this, to identify cluster and aid in other things.
</p>

<hr>
<h2 id='status'>Monitor status of flow(s)</h2><span id='topic+status'></span><span id='topic+get_status'></span><span id='topic+get_status.flow'></span><span id='topic+get_status.character'></span><span id='topic+get_status.data.frame'></span>

<h3>Description</h3>

<p>Summarize status of a flow OR multiple flows OR a high-level summary of all flows in a folder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>status(
  x,
  use_cache = FALSE,
  verbose = opts_flow$get("verbose"),
  out_format = "markdown",
  ...
)

get_status(x, ...)

## S3 method for class 'flow'
get_status(x, verbose, use_cache, out_format, ...)

## S3 method for class 'character'
get_status(x, verbose, use_cache, out_format, ...)

## S3 method for class 'data.frame'
get_status(x, verbose, use_cache, progress = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="status_+3A_x">x</code></td>
<td>
<p>path to the flow root folder or a parent folder to summarize several flows.</p>
</td></tr>
<tr><td><code id="status_+3A_use_cache">use_cache</code></td>
<td>
<p>This skips checking status of jobs which have already been completed a
and assumes no new jobs were submitted in the flow(s) being monitored. [FALSE]</p>
</td></tr>
<tr><td><code id="status_+3A_verbose">verbose</code></td>
<td>
<p>A numeric value indicating the amount of messages to produce.
Values are integers varying from 0, 1, 2, 3, .... Please refer to the <a href="#topic+verbose">verbose</a> page for more details.
<code>opts_flow$get("verbose")</code></p>
</td></tr>
<tr><td><code id="status_+3A_out_format">out_format</code></td>
<td>
<p>passed onto knitr:::kable. supports: markdown, rst, html... [markdown]</p>
</td></tr>
<tr><td><code id="status_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="status_+3A_progress">progress</code></td>
<td>
<p>Whether or not to show a progress bar, when fetching/reading files [TRUE]</p>
</td></tr>
</table>


<h3>Details</h3>

<p>basename(x) is used in a wild card search.
</p>

<ul>
<li><p> Get status of all the flows: 
(all flows with 'sleep_pipe' in their name are checked and their status is shown)
&lt;br&gt;
<code>flowr status x=~/flowr/runs/sleep_pipe*</code>
</p>
</li>
<li><p> Provide a high level summary of ALL flows in a folder:
&lt;br&gt;
<code>flowr status x=~/flowr/runs</code>
</p>
</li></ul>

<p>Use <strong>use_cache</strong>=TRUE to speed up checking the status. 
This assumes that no new jobs have been submitted and skips (re-)checking status of 
completed jobs.
</p>
<p>Once all the jobs have been submitted to the cluster you may always use <code>use_cache=TRUE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
status(x = "~/flowr/runs/sleep_pipe*")
## an example for running from terminal
flowr status x=path_to_flow_directory

## End(Not run)
</code></pre>

<hr>
<h2 id='submit_flow'>Submit a flow to the cluster</h2><span id='topic+submit_flow'></span><span id='topic+submit_flow.list'></span><span id='topic+submit_flow.flow'></span>

<h3>Description</h3>

<p>Submit a flow to the cluster or perform a dry-run to check and debug issues.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>submit_flow(x, verbose = opts_flow$get("verbose"), ...)

## S3 method for class 'list'
submit_flow(x, verbose = opts_flow$get("verbose"), ...)

## S3 method for class 'flow'
submit_flow(
  x,
  verbose = opts_flow$get("verbose"),
  execute = FALSE,
  uuid,
  plot = TRUE,
  dump = TRUE,
  .start_jid = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="submit_flow_+3A_x">x</code></td>
<td>
<p>a <code>object</code> of class <code>flow</code>.</p>
</td></tr>
<tr><td><code id="submit_flow_+3A_verbose">verbose</code></td>
<td>
<p>logical.</p>
</td></tr>
<tr><td><code id="submit_flow_+3A_...">...</code></td>
<td>
<p>Advanced use. Any additional parameters are passed on to <a href="#topic+submit_job">submit_job</a> function.</p>
</td></tr>
<tr><td><code id="submit_flow_+3A_execute">execute</code></td>
<td>
<p><code>logical</code> whether or not to submit the jobs</p>
</td></tr>
<tr><td><code id="submit_flow_+3A_uuid">uuid</code></td>
<td>
<p><code>character</code> Advanced use. This is the final path used for flow execution.
Especially useful in case of re-running a flow.</p>
</td></tr>
<tr><td><code id="submit_flow_+3A_plot">plot</code></td>
<td>
<p><code>logical</code> whether to make a pdf flow plot (saves it in the flow working directory).</p>
</td></tr>
<tr><td><code id="submit_flow_+3A_dump">dump</code></td>
<td>
<p>dump all the flow details to the flow path</p>
</td></tr>
<tr><td><code id="submit_flow_+3A_.start_jid">.start_jid</code></td>
<td>
<p>Job to start this submission from. Advanced use, should be 1 by default.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE:
Even if you want to kill the flow, its best to let submit_flow do its job, when done simply use <code>kill(flow_wd)</code>. 
If submit_flow is interrupted, files like flow_details.rds etc are not created, thus flowr looses the association 
of jobs with flow instance and cannot monitor, kill or re-run the flow.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
submit_flow(fobj = fobj, ... = ...)
## End(Not run)
</code></pre>

<hr>
<h2 id='submit_job'>Submit a step of a flow</h2><span id='topic+submit_job'></span>

<h3>Description</h3>

<p>Internal function (used by submit_flow), which submit a single step of a flow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>submit_job(jobj, fobj, job_id, execute = FALSE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="submit_job_+3A_jobj">jobj</code></td>
<td>
<p>Object of calls <a href="#topic+job">job</a></p>
</td></tr>
<tr><td><code id="submit_job_+3A_fobj">fobj</code></td>
<td>
<p>Object of calls <a href="#topic+flow">flow</a></p>
</td></tr>
<tr><td><code id="submit_job_+3A_job_id">job_id</code></td>
<td>
<p>job id</p>
</td></tr>
<tr><td><code id="submit_job_+3A_execute">execute</code></td>
<td>
<p>A <code>logical</code> vector suggesting whether to submit this job</p>
</td></tr>
<tr><td><code id="submit_job_+3A_verbose">verbose</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="submit_job_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
submit_job(jobj = jobj, fobj = fobj, execute = FALSE,
verbose = TRUE, wd = wd, job_id = job_id)

## End(Not run)
</code></pre>

<hr>
<h2 id='submit_run'>Submit several flow objects, limit the max running concurrently</h2><span id='topic+submit_run'></span>

<h3>Description</h3>

<p>Submit several flow objects, limit the max running concurrently
</p>


<h3>Usage</h3>

<pre><code class='language-R'>submit_run(x, wd, max_processing = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="submit_run_+3A_x">x</code></td>
<td>
<p>a list of flow objects</p>
</td></tr>
<tr><td><code id="submit_run_+3A_wd">wd</code></td>
<td>
<p>a folder to monitor (flow_run_path)</p>
</td></tr>
<tr><td><code id="submit_run_+3A_max_processing">max_processing</code></td>
<td>
<p>max number of flow which may be processed concurrently</p>
</td></tr>
</table>

<hr>
<h2 id='test_queue'>test_queue</h2><span id='topic+test_queue'></span>

<h3>Description</h3>

<p>This function attempts to test the submission of a job to the queue.
We would first submit one single job, then submit another with a dependency to see if configuration works. 
This would create a folder in home called 'flows'.
</p>
<p>[Depreciated]: This function has been superseded by <code>run("sleep_pipe", platform = "lsf", execute=TRUE)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_queue(q_obj, verbose = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_queue_+3A_q_obj">q_obj</code></td>
<td>
<p>queue object</p>
</td></tr>
<tr><td><code id="test_queue_+3A_verbose">verbose</code></td>
<td>
<p>toggle</p>
</td></tr>
<tr><td><code id="test_queue_+3A_...">...</code></td>
<td>
<p>These params are passed onto <code>queue</code>. <code>?queue</code>, for more information</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
test_queue(q_obj = q_obj, ... = ...)
## End(Not run)
</code></pre>

<hr>
<h2 id='to_df.status'>to_df.status</h2><span id='topic+to_df.status'></span>

<h3>Description</h3>

<p>convert the status to a df. To be called from R
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_df.status(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_df.status_+3A_x">x</code></td>
<td>
<p>folder with multiple runs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame with status per dir.
</p>

<hr>
<h2 id='to_flow'>Create flow objects</h2><span id='topic+to_flow'></span><span id='topic+flowr'></span><span id='topic+is.flow'></span><span id='topic+to_flow.character'></span><span id='topic+to_flow.flowmat'></span><span id='topic+to_flow.data.frame'></span><span id='topic+to_flow.list'></span>

<h3>Description</h3>

<p>Use a set of shell commands (flow mat) and flow definition to create <a href="#topic+flow">flow</a> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_flow(x, ...)

is.flow(x)

## S3 method for class 'character'
to_flow(x, def, grp_col, jobname_col, cmd_col, ...)

## S3 method for class 'flowmat'
to_flow(
  x,
  def,
  flowname,
  grp_col,
  jobname_col,
  cmd_col,
  submit = FALSE,
  execute = FALSE,
  containerize = TRUE,
  platform,
  flow_run_path,
  qobj,
  verbose = opts_flow$get("verbose"),
  ...
)

## S3 method for class 'data.frame'
to_flow(x, ...)

## S3 method for class 'list'
to_flow(
  x,
  def,
  flowname,
  flow_run_path,
  desc,
  qobj,
  module_cmds = opts_flow$get("module_cmds"),
  verbose = opts_flow$get("verbose"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_flow_+3A_x">x</code></td>
<td>
<p>this can either to a filename, a data.frame or a list. 
In case it is a file name, it should be a tsv file representing a flow_mat. See <a href="#topic+to_flowmat">to_flowmat</a> for details</p>
</td></tr>
<tr><td><code id="to_flow_+3A_...">...</code></td>
<td>
<p>Supplied to specific functions like <a href="#topic+to_flow.data.frame">to_flow.data.frame</a></p>
</td></tr>
<tr><td><code id="to_flow_+3A_def">def</code></td>
<td>
<p>a flow definition. Basically a table with resource requirements and mapping of the jobs in this flow.
See <a href="#topic+to_flowdef">to_flowdef</a> for details on the format.</p>
</td></tr>
<tr><td><code id="to_flow_+3A_grp_col">grp_col</code></td>
<td>
<p>name of the grouping column in the supplied flow_mat.
See <a href="#topic+to_flow">to_flow</a> for details. Default value is [samplename].</p>
</td></tr>
<tr><td><code id="to_flow_+3A_jobname_col">jobname_col</code></td>
<td>
<p>name of the job name column in flow_mat. Default value is [jobname].</p>
</td></tr>
<tr><td><code id="to_flow_+3A_cmd_col">cmd_col</code></td>
<td>
<p>name of the command column name in flow_mat. Default value is [cmd].</p>
</td></tr>
<tr><td><code id="to_flow_+3A_flowname">flowname</code></td>
<td>
<p>name of the flow, this is used as part of the execution foldername.
A good simple identifier, which does not support any special characters. 
Names may use characters (a-z) and numbers (0-9), using underscore (_) as a word separator.
Default value is  [flowname].</p>
</td></tr>
<tr><td><code id="to_flow_+3A_submit">submit</code></td>
<td>
<p>after creating a flow object, should flowr 
also use <a href="#topic+submit_flow">submit_flow</a> to perform a dry-run OR real submission.
See below for details. Default value is [FALSE]</p>
</td></tr>
<tr><td><code id="to_flow_+3A_execute">execute</code></td>
<td>
<p>when calling <a href="#topic+submit_flow">submit_flow</a>, 
should flowr execute the flow or perform a dry-run. See below for details. Default value is [FALSE].</p>
</td></tr>
<tr><td><code id="to_flow_+3A_containerize">containerize</code></td>
<td>
<p>if the flowmat has multiple samples, 
flowr creates a creates a new date-stamped folder, and includes all
flows in this batch inside it. 
This is keeps the logs clean, and containerizes each batch.
To disable this behavior set this to FALSE, default is [TRUE].</p>
</td></tr>
<tr><td><code id="to_flow_+3A_platform">platform</code></td>
<td>
<p>a specifying the platform to use, possible values are local, lsf, torque, moab, sge and slurm
This over-rides the platform column in the flowdef. (optional)</p>
</td></tr>
<tr><td><code id="to_flow_+3A_flow_run_path">flow_run_path</code></td>
<td>
<p>base path to be used for execution of this flow. 
flowr would create a new time-stamped folder in this base path and 
use it for logs, scripts etc. 
The default is retrieved using <code>opts_flow$get("flow_run_path")</code>.</p>
</td></tr>
<tr><td><code id="to_flow_+3A_qobj">qobj</code></td>
<td>
<p>Depreciated, modify cluster templates as explained on 
<a href="http://flow-r.github.io/flowr/install.html#hpcc_support_overview">flow-r.github.io/flowr</a>.
An object of class <a href="#topic+queue">queue</a>.</p>
</td></tr>
<tr><td><code id="to_flow_+3A_verbose">verbose</code></td>
<td>
<p>A numeric value indicating the amount of messages to produce.
Values are integers varying from 0, 1, 2, 3, .... Please refer to the <a href="#topic+verbose">verbose</a> page for more details.
<code>opts_flow$get("verbose")</code></p>
</td></tr>
<tr><td><code id="to_flow_+3A_desc">desc</code></td>
<td>
<p>Advanced Use. final flow name.</p>
</td></tr>
<tr><td><code id="to_flow_+3A_module_cmds">module_cmds</code></td>
<td>
<p>A character vector of additional commands, which will be prepended to each script of the flow. 
Default is retrieved using <code>opts_flow$get("module_cmds")</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter x can be a path to a flow_mat, or a data.frame (as read by read_sheet).
This is a minimum three column table with columns: samplename, jobname and cmd.
See <a href="#topic+to_flowmat">to_flowmat</a> for details.
</p>


<h3>Value</h3>

<p>Returns a flow object. If execute=TRUE, fobj is rich with information about where and how
the flow was executed. It would include details like jobids, path to exact scripts run etc.
To use kill_flow, to kill all the jobs one would need a rich flow object, with job ids present.
</p>
<p><strong>Behaviour:</strong>
What goes in, and what to expect in return?
</p>

<ul>
<li><p> submit=FALSE &amp; execute=FALSE: Create and return a flow object
</p>
</li>
<li><p> submit=TRUE &amp; execute=FALSE: dry-run, Create a flow object then, create a structured execution folder with all the commands
</p>
</li>
<li><p> submit=TRUE, execute=TRUE: Do all of the above and then, submit to cluster
</p>
</li></ul>




<h3>See Also</h3>

<p><a href="#topic+to_flowmat">to_flowmat</a>, <a href="#topic+to_flowdef">to_flowdef</a>, <a href="#topic+to_flowdet">to_flowdet</a>, <a href="#topic+flowopts">flowopts</a> and <a href="#topic+submit_flow">submit_flow</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Use this link for a few elaborate examples:
## http://flow-r.github.io/flowr/flowr/tutorial.html#define_modules

ex = file.path(system.file(package = "flowr"), "pipelines")
flowmat = as.flowmat(file.path(ex, "sleep_pipe.tsv"))
flowdef = as.flowdef(file.path(ex, "sleep_pipe.def"))
fobj = to_flow(x = flowmat, def = flowdef, flowname = "sleep_pipe", platform = "lsf")


## create a vector of shell commands
cmds = c("sleep 1", "sleep 2")
## create a named list
lst = list("sleep" = cmds)
## create a flowmat
flowmat = to_flowmat(lst, samplename = "samp")

## Use flowmat to create a skeleton flowdef
flowdef = to_flowdef(flowmat)

## use both (flowmat and flowdef) to create a flow
fobj = to_flow(flowmat, flowdef)

## submit the flow to the cluster (execute=TRUE) or do a dry-run (execute=FALSE)
## Not run: 
fobj2 = submit_flow(fobj, execute=FALSE)
fobj3 = submit_flow(fobj, execute=TRUE)

## Get the status or kill all the jobs
status(fobj3)
kill(fobj3)

## End(Not run)


</code></pre>

<hr>
<h2 id='to_flowdef'>Flow Definition defines how to stitch steps into a (work)flow.</h2><span id='topic+to_flowdef'></span><span id='topic+flowdef'></span><span id='topic+definition'></span><span id='topic+to_flowdef.flowmat'></span><span id='topic+to_flowdef.flow'></span><span id='topic+to_flowdef.character'></span><span id='topic+as.flowdef'></span><span id='topic+is.flowdef'></span>

<h3>Description</h3>

<p>This function enables creation of a skeleton flow definition with several default values, using a 
flowmat.
To customize the flowdef, one may supply parameters such as sub_type and dep_type upfront.
As such, these params must be of the same length as number of unique jobs using in the flowmat.
</p>

<p>Each row in this table refers to one step of the pipeline. 
It describes the resources used by the step and also its relationship with other steps, 
especially, the step immediately prior to it.
 &lt;br&gt;&lt;br&gt;
</p>
<p><strong>Submission types:</strong> 
<em>This refers to the sub_type column in flow definition.</em>&lt;br&gt;
</p>
<p>Consider an example with three steps A, B and C. 
A has 10 commands from A1 to A10, similarly B has 10 commands B1 through B10 and 
C has a single command, C1.
Consider another step D (with D1-D3), which comes after C.
</p>
<p>step (number of sub-processes)
A (10)   &mdash;-&gt; B (10)  &mdash;&ndash;&gt; C (1) &mdash;&ndash;&gt; D (3)
</p>

<ul>
<li> <p><code>scatter</code>: submit all commands as parallel, independent jobs. 
</p>
<p><em>Submit A1 through A10 as independent jobs</em>
</p>
</li>
<li> <p><code>serial</code>: run these commands sequentially one after the other. 
</p>
<p>- <em>Wrap A1 through A10, into a single job.</em>
</p>
</li></ul>

<p><strong>Dependency types</strong>
</p>
<p><em>This refers to the dep_type column in flow definition.</em>
</p>

<ul>
<li> <p><code>none</code>: independent job.
</p>
<ul>
<li> <p><em>Initial step A has no dependency</em></p>
</li></ul>

</li>
<li> <p><code>serial</code>: <em>one to one</em> relationship with previous job. 
</p>
 <ul>
<li> <p><em>B1 can start as soon as A1 completes, and B2 starts just after A2 and so on.</em></p>
</li></ul>

</li>
<li> <p><code>gather</code>: <em>many to one</em>, wait for <strong>all</strong> commands in the previous job to finish then start the  current step. 
</p>
<ul>
<li> <p><em>All jobs of B (1-10), need to complete before C1 starts</em></p>
</li></ul>

</li>
<li> <p><code>burst</code>: <em>one to many</em> wait for the previous step which has one job and start processing all cmds in the current step. 
</p>
<p>- <em>D1 to D3 are started as soon as C1 finishes.</em>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>to_flowdef(x, ...)

## S3 method for class 'flowmat'
to_flowdef(
  x,
  sub_type,
  dep_type,
  prev_jobs,
  queue = "short",
  platform = "torque",
  memory_reserved = "2000",
  cpu_reserved = "1",
  nodes = "1",
  walltime = "1:00",
  guess = FALSE,
  verbose = opts_flow$get("verbose"),
  ...
)

## S3 method for class 'flow'
to_flowdef(x, ...)

## S3 method for class 'character'
to_flowdef(x, ...)

as.flowdef(x, ...)

is.flowdef(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_flowdef_+3A_x">x</code></td>
<td>
<p>can a path to a flowmat, flowmat or flow object.</p>
</td></tr>
<tr><td><code id="to_flowdef_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="to_flowdef_+3A_sub_type">sub_type</code></td>
<td>
<p>submission type, one of: scatter, serial. Character, of length one or same as the number of jobnames</p>
</td></tr>
<tr><td><code id="to_flowdef_+3A_dep_type">dep_type</code></td>
<td>
<p>dependency type, one of: gather, serial or burst. Character, of length one or same as the number of jobnames</p>
</td></tr>
<tr><td><code id="to_flowdef_+3A_prev_jobs">prev_jobs</code></td>
<td>
<p>previous job name</p>
</td></tr>
<tr><td><code id="to_flowdef_+3A_queue">queue</code></td>
<td>
<p>Cluster queue to be used</p>
</td></tr>
<tr><td><code id="to_flowdef_+3A_platform">platform</code></td>
<td>
<p>platform of the cluster: lsf, sge, moab, torque, slurm etc.</p>
</td></tr>
<tr><td><code id="to_flowdef_+3A_memory_reserved">memory_reserved</code></td>
<td>
<p>amount of memory required.</p>
</td></tr>
<tr><td><code id="to_flowdef_+3A_cpu_reserved">cpu_reserved</code></td>
<td>
<p>number of cpu's required. [1]</p>
</td></tr>
<tr><td><code id="to_flowdef_+3A_nodes">nodes</code></td>
<td>
<p>if you tool can use multiple nodes, you may reserve multiple nodes for it. [1]</p>
</td></tr>
<tr><td><code id="to_flowdef_+3A_walltime">walltime</code></td>
<td>
<p>amount of walltime required</p>
</td></tr>
<tr><td><code id="to_flowdef_+3A_guess">guess</code></td>
<td>
<p>should the function, guess submission and dependency types. See details.</p>
</td></tr>
<tr><td><code id="to_flowdef_+3A_verbose">verbose</code></td>
<td>
<p>A numeric value indicating the amount of messages to produce.
Values are integers varying from 0, 1, 2, 3, .... Please refer to the <a href="#topic+verbose">verbose</a> page for more details.
<code>opts_flow$get("verbose")</code></p>
</td></tr>
</table>


<h3>Format</h3>

<p>This is a tab separated file, with a minimum of 4 columns:&lt;br&gt;
</p>
<p><em>required columns</em>:&lt;br&gt;
</p>

<ul>
<li><p><code>jobname</code>: Name of the step
</p>
</li>
<li><p><code>sub_type</code>: Short for submission type, 
refers to, how should multiple commands of this step be submitted. Possible values are 'serial' or 'scatter'. 
</p>
</li>
<li><p><code>prev_jobs</code>: Short for previous job, this would be the jobname of the previous job. 
This can be NA/./none if this is a independent/initial step, and no previous step is required for this to start. 
Additionally, one may use comma(s) to define multiple previous jobs (A,B).
</p>
</li>
<li><p><code>dep_type</code>: Short for dependency type, 
refers to the relationship of this job with the one defined in 'prev_jobs'. 
This can take values 'none', 'gather', 'serial' or 'burst'.
</p>
</li></ul>

<p><em>resource columns</em> (recommended):&lt;br&gt;
</p>
<p>Additionally, one may customize resource requirements used by each step.
The format used varies and depends to the computing platform. Thus its best to refer to 
your institutions guide to specify these.
</p>

<ul>
<li><p><code>cpu_reserved</code> integer, specifying number of cores to reserve [1]
</p>
</li>
<li><p><code>memory_reserved</code> Usually in KB [2000]
</p>
</li>
<li><p><code>nodes</code> number of server nodes to reserve, most tools can only use multiple cores on
a <strong>single</strong> node [1]
</p>
</li>
<li><p><code>walltime</code> maximum time allowed for a step, usually in a HH:MM or HH:MM:SS format. [1:00]
</p>
</li>
<li><p><code>queue</code> the queue to use for job submission [short]
</p>
</li></ul>



<h3>Details</h3>

<p><strong>NOTE:</strong> Guessing is an experimental feature, please check the definition carefully. 
it is provided to help but not replace your best judgement. &lt;br&gt;
</p>
<p>Optionally, one may provide the previous jobs and flowr can try guessing the appropriate 
submission and dependency types. If there are multiple commands, default is submitting them as 
scatter, else as serial. Further, if previous job has multiple commands and current job has single;
its assumed that all of the previous need to complete, suggesting a gather type dependency.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see ?to_flow for more examples

# read in a tsv; check and confirm format
ex = file.path(system.file(package = "flowr"), "pipelines")

# read in a flowdef from file
flowdef = as.flowdef(file.path(ex, "sleep_pipe.def"))

# check if this a flowdef
is.flowdef(flowdef)

# use a flowmat, to create a sample flowdef
flowmat = as.flowmat(file.path(ex, "sleep_pipe.tsv"))
to_flowdef(flowmat)

# change the platform
to_flowdef(flowmat, platform = "lsf")

# change the queue name
def = to_flowdef(flowmat, 
 platform = "lsf", 
 queue = "long")
plot_flow(def)

# guess submission and dependency types
def2 = to_flowdef(flowmat, 
 platform = "lsf", 
 queue = "long", 
 guess = TRUE)
plot_flow(def2)



</code></pre>

<hr>
<h2 id='to_flowdet'>Create a flow's submission detail file</h2><span id='topic+to_flowdet'></span><span id='topic+to_flowdet.rootdir'></span><span id='topic+to_flowdet.character'></span><span id='topic+to_flowdet.flow'></span>

<h3>Description</h3>

<p>Create a file describing details regarding jobs ids, submission scripts etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_flowdet(x, ...)

## S3 method for class 'rootdir'
to_flowdet(x, ...)

## S3 method for class 'character'
to_flowdet(x, ...)

## S3 method for class 'flow'
to_flowdet(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_flowdet_+3A_x">x</code></td>
<td>
<p>this is a wd</p>
</td></tr>
<tr><td><code id="to_flowdet_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The path provided should contain a flow_details.rds file (which is used to extract all the information). 
</p>
<p>Incase a parent folder with multiple flows is provided information regarding jobids is omitted.
</p>
<p>if x is char. assumed a path, check if flow object exists in it and read it.
If there is no flow object, try using a simpler function
</p>

<hr>
<h2 id='to_flowmat'>Create a flowmat using a list a commands.</h2><span id='topic+to_flowmat'></span><span id='topic+to_flowmat.list'></span><span id='topic+to_flowmat.data.frame'></span><span id='topic+to_flowmat.flow'></span><span id='topic+as.flowmat'></span><span id='topic+is.flowmat'></span>

<h3>Description</h3>

<p>Create a flowmat (data.frame) using a <strong>named</strong> list a commands.
</p>
<p>as.flowmat(): reads a file and checks for required columns. If x is data.frame checks for required columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>to_flowmat(x, ...)

## S3 method for class 'list'
to_flowmat(x, samplename, ...)

## S3 method for class 'data.frame'
to_flowmat(x, ...)

## S3 method for class 'flow'
to_flowmat(x, ...)

as.flowmat(x, grp_col, jobname_col, cmd_col, ...)

is.flowmat(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="to_flowmat_+3A_x">x</code></td>
<td>
<p>a named list, where name corresponds to the jobname and value is a vector of commands to run.</p>
</td></tr>
<tr><td><code id="to_flowmat_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="to_flowmat_+3A_samplename">samplename</code></td>
<td>
<p>character of length 1 or that of nrow(x) ['samplename']</p>
</td></tr>
<tr><td><code id="to_flowmat_+3A_grp_col">grp_col</code></td>
<td>
<p>column used for grouping, default samplename.</p>
</td></tr>
<tr><td><code id="to_flowmat_+3A_jobname_col">jobname_col</code></td>
<td>
<p>column specifying jobname, default jobname</p>
</td></tr>
<tr><td><code id="to_flowmat_+3A_cmd_col">cmd_col</code></td>
<td>
<p>column specifying commands to run, default cmd</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Use this link for a few examples:
# http://flow-r.github.io/flowr/tutorial.html#define_modules

# create a flow mat, starting with a list of commands.
cmd_sleep = c("sleep 1", "sleep 2")
cmd_echo = c("echo 'hello'", "echo 'hello'")

# create a named list
lst = list("sleep" = cmd_sleep, "echo" = cmd_echo)
flowmat = to_flowmat(lst, samplename = "samp")



# read in a tsv; check and confirm format
ex = file.path(system.file(package = "flowr"), "pipelines")

flowmat = as.flowmat(file.path(ex, "sleep_pipe.tsv"))

# if your column names are different than defaults, explicitly specify them.
flowmat = as.flowmat(file.path(ex, "sleep_pipe.tsv"), jobname_col = "jobname")

# check if a object is a flowmat
is.flowmat(flowmat)



# create a flowdef, from this flowmat
flowdef = to_flowdef(flowmat)

# create a flow object using flowmat and flowdef
fobj = to_flow(flowmat, flowdef)

# extract a flowmat from a flow (here the samplename also contains the name of the flow)
flowmat2 = to_flowmat(fobj)



## submit the flow to the cluster (execute=TRUE) or do a dry-run (execute=FALSE)
## Not run: 
fobj2 = submit_flow(fobj, execute=FALSE)
fobj3 = submit_flow(fobj, execute=TRUE)

## Get the status or kill all the jobs
status(fobj3)
kill(fobj3)

## End(Not run)



</code></pre>

<hr>
<h2 id='verbose'>Verbose levels, defining verboseness of messages</h2><span id='topic+verbose'></span>

<h3>Description</h3>

<p>There are several levels of verboseness one can choose from.
</p>
<p><strong>levels:</strong>
</p>

<ul>
<li><p> level 0 is almost silent, producing only necessary messages 
</p>
</li>
<li><p> level 1 is good for most purposes, where as, 
</p>
</li>
<li><p> level 2 is good when developing a new pipeline.
</p>
</li>
<li><p> level 3 is good for debugging, especially when getting un-expected results.
</p>
</li></ul>

<p>One can set the level of verboseness using <code>opts_flow$set(verbose=2)</code>, which 
will be used across flowr and ngsflows packages. Additionally one may set this value in 
the configurations files: <code>~/flowr/conf/flowr.conf</code> OR <code>~/flowr/conf/ngsflows.conf</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>verbose
</code></pre>


<h3>Format</h3>

<p>An object of class <code>NULL</code> of length 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fl = system.file("pipelines/abcd.def", package = "flowr")
def = as.flowdef(fl, verbose = 0)
# def seems to be a file, reading it...
def = as.flowdef(fl, verbose = 1)
# def seems to be a file, reading it...
# checking if required columns are present...
# checking if resources columns are present...
# checking if dependency column has valid names...
# checking if submission column has valid names...
# checking for missing rows in def...
# checking for extra rows in def...
# checking submission and dependency types...
def = as.flowdef(fl, verbose = 2)
# def seems to be a file, reading it...
# checking if required columns are present...
# checking if resources columns are present...
# checking if dependency column has valid names...
# checking if submission column has valid names...
# checking for missing rows in def...
# checking for extra rows in def...
# checking submission and dependency types...
# jobname	prev.sub_type --&gt; dep_type --&gt; sub_type: relationship
# 	1: A	none --&gt; none --&gt; scatter 
# 	2: B	scatter --&gt; serial --&gt; scatter rel: complex one:one
# 	3: C	scatter --&gt; gather --&gt; serial rel: many:one
# 	4: D	serial --&gt; burst --&gt; scatter rel: one:many
</code></pre>

<hr>
<h2 id='whisker_render'>Wrapper around whisker.render with some additional checks</h2><span id='topic+whisker_render'></span>

<h3>Description</h3>

<p>Internal function (used by submit_job), which creates a submission script using 
platform specific templates.
</p>
<p>This is a wrapper around <a href="whisker.html#topic+whisker.render">whisker.render</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>whisker_render(template, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="whisker_render_+3A_template">template</code></td>
<td>
<p>template used</p>
</td></tr>
<tr><td><code id="whisker_render_+3A_data">data</code></td>
<td>
<p>a list with variables to be used to fill in the template.</p>
</td></tr>
</table>

<hr>
<h2 id='write_flow_details'>Write files describing this flow</h2><span id='topic+write_flow_details'></span>

<h3>Description</h3>

<p>Write files describing this flow
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_flow_details(x, fobj, summ, flow_det, flow_mat, flow_def, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_flow_details_+3A_x">x</code></td>
<td>
<p>path to write to</p>
</td></tr>
<tr><td><code id="write_flow_details_+3A_fobj">fobj</code></td>
<td>
<p>flow object</p>
</td></tr>
<tr><td><code id="write_flow_details_+3A_summ">summ</code></td>
<td>
<p>a status summary.</p>
</td></tr>
<tr><td><code id="write_flow_details_+3A_flow_det">flow_det</code></td>
<td>
<p>a flow details data.frame</p>
</td></tr>
<tr><td><code id="write_flow_details_+3A_flow_mat">flow_mat</code></td>
<td>
<p>flow matrix (of commands)</p>
</td></tr>
<tr><td><code id="write_flow_details_+3A_flow_def">flow_def</code></td>
<td>
<p>flow definiion</p>
</td></tr>
<tr><td><code id="write_flow_details_+3A_plot">plot</code></td>
<td>
<p>logical, plot or not</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
