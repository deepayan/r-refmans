<!DOCTYPE html><html lang="en-US"><head><title>Help for package hdflex</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hdflex}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hdflex'><p>hdflex: High-Dimensional Density Forecasts</p></a></li>
<li><a href='#dsc'><p>Generate dynamic subset forecast combinations</p></a></li>
<li><a href='#inflation_data'><p>Quarterly U.S. Inflation Dataset (Total CPI)</p></a></li>
<li><a href='#stsc'><p>Signal-Transformed-Subset-Combination (STSC)</p></a></li>
<li><a href='#summary.dsc_obj'><p>Summary for 'dsc' object</p></a></li>
<li><a href='#summary.stsc_obj'><p>Summary for 'stsc' object</p></a></li>
<li><a href='#tvc'><p>Compute density forecasts using univariate time-varying coefficient (TV-C) models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>High-Dimensional Aggregate Density Forecasts</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sven Lehmann &lt;sven.lehmann@uni-rostock.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a forecasting method that efficiently maps vast
    numbers of (scalar-valued) signals into an aggregate density forecast
    in a time-varying and computationally fast manner. The method proceeds
    in two steps: First, it transforms a predictive signal into a density
    forecast and, second, it combines the resulting candidate density
    forecasts into an ultimate aggregate density forecast. For a detailed
    explanation of the method, please refer to Adaemmer et al. (2023)
    &lt;<a href="https://doi.org/10.2139%2Fssrn.4342487">doi:10.2139/ssrn.4342487</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/lehmasve/hdflex">https://github.com/lehmasve/hdflex</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/lehmasve/hdflex/issues">https://github.com/lehmasve/hdflex/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 2.3.1), ggplot2 (&ge; 3.5.1), parallel, Rcpp,
reshape2 (&ge; 1.4.4), stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.2.1), cowplot (&ge; 1.1.3)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo, RcppThread</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-10 21:34:16 UTC; slehmann</td>
</tr>
<tr>
<td>Author:</td>
<td>Sven Lehmann [aut, cre, cph],
  Philipp Adämmer [aut],
  Rainer Schüssler [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-10 22:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='hdflex'>hdflex: High-Dimensional Density Forecasts</h2><span id='topic+hdflex'></span><span id='topic+hdflex-package'></span>

<h3>Description</h3>

<p>hdflex contains the forecasting algorithm STSC
developed by Adämmer, Lehmann and Schüssler (2023) <a href="doi:10.2139/ssrn.4342487">doi:10.2139/ssrn.4342487</a>.
STSC is a novel time series forecasting method designed to handle very large
sets of predictive signals, many of which are irrelevant or have only
short-lived predictive power.
Please cite the paper when using the package.
</p>


<h3>Author(s)</h3>

<p>Philipp Adämmer, Sven Lehmann, Rainer Schüssler
</p>

<hr>
<h2 id='dsc'>Generate dynamic subset forecast combinations</h2><span id='topic+dsc'></span>

<h3>Description</h3>

<p>The <code>dsc()</code> function generates
dynamic forecast combinations from a set of
candidate density forecasts. For each period,
it selects and combines a subset of predictive densities
with the highest ranks regarding local predictive accuracy.
The identities of the candidate forecasting models and
the subset sizes used for building the aggregate predictive density
may vary over time based on the data.
If only one candidate forecast is picked,
the approach temporarily collapses to pure model selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsc(
  y,
  point_forecasts,
  variance_forecasts,
  gamma_grid,
  psi_grid,
  delta,
  burn_in,
  burn_in_dsc,
  metric,
  equal_weight,
  incl,
  portfolio_params = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dsc_+3A_y">y</code></td>
<td>
<p>A matrix of dimension <code>T * 1</code> or numeric vector of length <code>T</code>
containing the observations of the target variable.</p>
</td></tr>
<tr><td><code id="dsc_+3A_point_forecasts">point_forecasts</code></td>
<td>
<p>A matrix with <code>T</code> rows containing
the first moments of (conditionally) normal distributed
predictive densities in each column.</p>
</td></tr>
<tr><td><code id="dsc_+3A_variance_forecasts">variance_forecasts</code></td>
<td>
<p>A matrix with <code>T</code> rows containing
the second moments of (conditionally) normal distributed
predictive densities in each column.</p>
</td></tr>
<tr><td><code id="dsc_+3A_gamma_grid">gamma_grid</code></td>
<td>
<p>A numeric vector containing potential discount factors
between 0 and 1 to exponentially down-weight the past predictive performance
of the candidate forecasting models. The values of this tuning parameter
are chosen in a procedure that amounts to leave-one-out cross-validation,
taking into account the time series structure of the data.
For details, <em>see Adaemmer et al. (2023)</em>.</p>
</td></tr>
<tr><td><code id="dsc_+3A_psi_grid">psi_grid</code></td>
<td>
<p>An integer vector that controls
the (possible) sizes of the subsets. The values of this tuning parameter
are chosen in a procedure that amounts to leave-one-out cross-validation,
taking taking into account the time series structure of the data.
For details, <em>see Adaemmer et al. (2023)</em>.</p>
</td></tr>
<tr><td><code id="dsc_+3A_delta">delta</code></td>
<td>
<p>A numeric value between 0 and 1 denoting the discount factor
applied to down-weight the past predictive performance of the
aggregate predictive densities.</p>
</td></tr>
<tr><td><code id="dsc_+3A_burn_in">burn_in</code></td>
<td>
<p>An integer value <code style="white-space: pre;">&#8288;&gt;= 1&#8288;</code> that denotes the number of
observations used to 'initialize' the rankings.
After 'burn_in' observations, the rankings for both,
the candidate forecasting models and aggregate predictive densities
are reset. <code>burn_in = 1</code> means no burn-in period is applied.</p>
</td></tr>
<tr><td><code id="dsc_+3A_burn_in_dsc">burn_in_dsc</code></td>
<td>
<p>An integer value <code style="white-space: pre;">&#8288;&gt;= 1&#8288;</code> that denotes the number of
observations used to 'initialize' the rankings.
After 'burn_in_dsc' observations, only the ranking of the
aggregate predictive densities is reset.
<code>burn_in_dsc = 1</code> means no burn-in period is applied.</p>
</td></tr>
<tr><td><code id="dsc_+3A_metric">metric</code></td>
<td>
<p>An integer from the set <code style="white-space: pre;">&#8288;1, 2, 3, 4, 5&#8288;</code> representing
the metric used to rank the candidate forecasting models (TV-C models)
and subset combinations based on their predictive performance.
The default value is <code>metric = 5</code> which ranks them according to the
sum of (discounted) Continuous-Ranked-Probability-Scores (CRPS).
<code>metric = 1</code> uses discounted Predictive Log-Likelihoods,
<code>metric = 2</code> uses discounted Squared-Errors,
<code>metric = 3</code> uses discounted Absolute-Errors,
<code>metric = 4</code> uses discounted Compounded-Returns
(in this case the target variable y has to be a time series of
financial returns).</p>
</td></tr>
<tr><td><code id="dsc_+3A_equal_weight">equal_weight</code></td>
<td>
<p>A boolean that denotes whether equal weights are used to
combine the candidate forecasts within a subset. If <code>FALSE</code>, the weights are
calculated applying the softmax function on the ranking scores of
the candidate forecasting models. The method proposed in
Adaemmer et al. (2023) uses equal weights to combine the
candidate forecasting models.</p>
</td></tr>
<tr><td><code id="dsc_+3A_incl">incl</code></td>
<td>
<p>An optional integer vector that denotes signals that
must be included in the subset combinations. For example, <code>incl = c(1, 3)</code>
includes all candidate forecasting models generated by
the first and third signals. If <code>NULL</code>, no signal is forced to be included.</p>
</td></tr>
<tr><td><code id="dsc_+3A_portfolio_params">portfolio_params</code></td>
<td>
<p>A numeric vector of length 3
containing the following elements:
</p>

<dl>
<dt>risk_aversion</dt><dd>
<p>A non-negative double representing the investor's
risk aversion. Higher values indicate more risk-averse behavior.
</p>
</dd>
<dt>min_weight</dt><dd>
<p>A double specifying the minimum weight allocated to the market.
A non-negative lower bound effectively rules out short sales.
</p>
</dd>
<dt>max_weight</dt><dd>
<p>A double specifying the maximum weight allocated to the market.
For example, a value of 2 allows for a maximum leverage ratio of two.
</p>
</dd>
</dl>

<p>This parameter is only required if <code>metric = 4</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt>Forecasts</dt><dd><p>A list containing:
</p>

<dl>
<dt>Realization</dt><dd>
<p>A vector with the actual values of the target variable.
</p>
</dd>
<dt>Point_Forecasts</dt><dd>
<p>A vector with the first moments of the aggregate predictive densities
of the DSC model.
</p>
</dd>
<dt>Variance_Prediction</dt><dd>
<p>A vector with the second moments of the aggregate predictive densities
of the DSC model.
</p>
</dd>
</dl>

</dd>
<dt>Tuning_Parameters</dt><dd><p>A list containing:
</p>

<dl>
<dt>Gamma</dt><dd>
<p>A vector containing the selected values for the tuning parameter gamma.
</p>
</dd>
<dt>Psi</dt><dd>
<p>A vector containing the selected values for the tuning parameter psi.
</p>
</dd>
<dt>CFM</dt><dd>
<p>A matrix containing the selected candidate forecasting models.
</p>
</dd>
</dl>

</dd>
<dt>Model</dt><dd><p>A list containing:
</p>

<dl>
<dt>Gamma_grid</dt><dd><p>The grid of gamma values used in the model.</p>
</dd>
<dt>Psi_grid</dt><dd><p>The grid of psi values used in the model.</p>
</dd>
<dt>Delta</dt><dd><p>The delta value used in the model.</p>
</dd>
<dt>Burn_in</dt><dd><p>The burn-in period used in the model.</p>
</dd>
<dt>Burn_in_dsc</dt><dd><p>The burn-in period used in the model.</p>
</dd>
<dt>Metric</dt><dd><p>The ranking metric used in the model.</p>
</dd>
<dt>Equal_weight</dt><dd><p>A boolean indicating if equal weighting was used.</p>
</dd>
<dt>Incl</dt><dd><p>Additional included parameters.</p>
</dd>
</dl>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Philipp Adämmer, Sven Lehmann, Rainer Schüssler
</p>


<h3>References</h3>

<p>Beckmann, J., Koop, G., Korobilis, D., and Schüssler, R. A. (2020)
&quot;Exchange rate predictability and dynamic bayesian learning.&quot;
<em>Journal of Applied Econometrics</em>, 35 (4): 410–421.
</p>
<p>Dangl, T. and Halling, M. (2012)
&quot;Predictive regressions with time-varying coefficients.&quot;
<em>Journal of Financial Economics</em>, 106 (1): 157–181.
</p>
<p>Del Negro, M., Hasegawa, R. B., and Schorfheide, F. (2016)
&quot;Dynamic prediction pools:
An investigation of financial frictions and forecasting performance.&quot;
<em>Journal of Econometrics</em>, 192 (2): 391–405.
</p>
<p>Koop, G. and Korobilis, D. (2012)
&quot;Forecasting inflation using dynamic model averaging.&quot;
<em>International Economic Review</em>, 53 (3): 867–886.
</p>
<p>Koop, G. and Korobilis, D. (2023)
&quot;Bayesian dynamic variable selection in high dimensions.&quot;
<em>International Economic Review</em>.
</p>
<p>Raftery, A. E., Kárn'y, M., and Ettler, P. (2010)
&quot;Online prediction under model uncertainty via dynamic model averaging:
Application to a cold rolling mill.&quot;
<em>Technometrics</em>, 52 (1): 52–66.
</p>
<p>West, M. and Harrison, J. (1997)
&quot;Bayesian forecasting and dynamic models&quot;
<em>Springer</em>, 2nd edn.
</p>


<h3>See Also</h3>

<p><a href="https://github.com/lehmasve/hdflex#readme">https://github.com/lehmasve/hdflex#readme</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# See example for tvc().


</code></pre>

<hr>
<h2 id='inflation_data'>Quarterly U.S. Inflation Dataset (Total CPI)</h2><span id='topic+inflation_data'></span>

<h3>Description</h3>

<p>A high-dimensional dataset created by <em>Koop and Korobilis (2023)</em>
that integrates predictive signals from various macroeconomic and financial sources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inflation_data
</code></pre>


<h3>Format</h3>

<p>A <a href="base.html#topic+matrix">matrix</a> with 245 quarterly observations (rows) and 462 signals (columns):
</p>

<dl>
<dt>Column 1</dt><dd><p>Transformed target variable: Total CPI (CPIAUCSL)</p>
</dd>
<dt>Columns 2-3</dt><dd><p>First and second lag of the target variable</p>
</dd>
<dt>Columns 4-442</dt><dd><p>Lagged and transformed signals from the sources listed above</p>
</dd>
<dt>Columns 443-462</dt><dd><p>External point forecasts available from 1976-Q1 to 2021-Q4
for quarterly Total CPI (CPIAUCSL), including:
</p>

<dl>
<dt>First 12 forecasts</dt><dd><p>Generated using regression trees,
ridge regressions, and elastic nets
over expanding and rolling windows</p>
</dd>
<dt>Remaining 8 forecasts</dt><dd><p>Based on models discussed in Koop and Korobilis (2023)
such as Gaussian process regressions (GPR_FAC5),
Unobserved Component Stochastic Volatility (UCSV),
and Variational Bayes Dynamic Variable Selection (VBDVS_X)</p>
</dd>
</dl>

</dd>
</dl>



<h3>Details</h3>

<p>The dataset includes data from the following sources:
</p>

<ul>
<li> <p><strong>FRED-QD dataset</strong> (McCracken and Ng, 2020)
</p>
</li>
<li> <p><strong>Portfolio data</strong> (Jurado et al., 2015)
</p>
</li>
<li> <p><strong>Stock market predictors</strong> (Welch and Goyal, 2008)
</p>
</li>
<li> <p><strong>University of Michigan consumer surveys</strong>
</p>
</li>
<li> <p><strong>World Bank’s Pink Sheet commodity prices</strong>
</p>
</li>
<li> <p><strong>Key macroeconomic indicators</strong> from the Federal Reserve Economic Data for Canada, Germany, Japan, and the United Kingdom
</p>
</li></ul>

<p>The dataset is pre-processed for one-step-ahead forecasts and includes external point forecasts.
It spans from 1960-Q3 to 2021-Q4.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.1111/iere.12623">doi:10.1111/iere.12623</a>
</p>


<h3>References</h3>

<p>Jurado, K., Ludvigson, S. C., and Ng, S. (2015) &quot;Measuring uncertainty.&quot; <em>American Economic Review</em>, 105 (3): 1177–1216.
</p>
<p>Koop, G. and Korobilis, D. (2023) &quot;Bayesian dynamic variable selection in high dimensions.&quot; <em>International Economic Review</em>.
</p>
<p>McCracken, M., and S. Ng (2020) “FRED-QD: A Quarterly Database for Macroeconomic Research” <em>National Bureau of Economic Research</em>, Working Paper 26872.
</p>
<p>Welch, I. and Goyal, A. (2008) &quot;A comprehensive look at the empirical performance of equity premium prediction.&quot; <em>The Review of Financial Studies</em>, 21 (4): 1455–1508.
</p>

<hr>
<h2 id='stsc'>Signal-Transformed-Subset-Combination (STSC)</h2><span id='topic+stsc'></span>

<h3>Description</h3>

<p><code>stsc()</code> is a time series forecasting method designed to handle
vast sets of predictive signals, many of which may be irrelevant or
short-lived. This method transforms heterogeneous scalar-valued signals into
candidate density forecasts via time-varying coefficient models (TV-C),
and subsequently, combines them into an ultimate aggregate density forecast
via dynamic subset combinations (DSC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsc(
  y,
  X,
  Ext_F,
  init,
  lambda_grid,
  kappa_grid,
  bias,
  gamma_grid,
  psi_grid,
  delta,
  burn_in,
  burn_in_dsc,
  metric,
  equal_weight,
  incl,
  parallel = FALSE,
  n_threads = parallel::detectCores() - 2,
  portfolio_params = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stsc_+3A_y">y</code></td>
<td>
<p>A matrix of dimension <code>T * 1</code> or numeric vector of length <code>T</code>
containing the observations of the target variable.</p>
</td></tr>
<tr><td><code id="stsc_+3A_x">X</code></td>
<td>
<p>A matrix with <code>T</code> rows containing the lagged 'P-signals'
in each column. Use <code>NULL</code> if no (external) 'P-signal' is to be included.</p>
</td></tr>
<tr><td><code id="stsc_+3A_ext_f">Ext_F</code></td>
<td>
<p>A matrix with <code>T</code> rows containing the (external) 'F-signals'
in each column. For 'F-Signals', the slope of the TV-C models is fixed to 1.
Use <code>NULL</code> if no (external) 'F-signal' is to be included.</p>
</td></tr>
<tr><td><code id="stsc_+3A_init">init</code></td>
<td>
<p>An integer that denotes the number of observations used
to initialize the observational variance and the coefficients' variance
in the TV-C models.</p>
</td></tr>
<tr><td><code id="stsc_+3A_lambda_grid">lambda_grid</code></td>
<td>
<p>A numeric vector which takes values between 0 and 1
denoting the discount factor(s) that control the dynamics of the time-varying
coefficients. Each signal in combination with each value of
lambda provides a separate candidate forecast.
Constant coefficients are nested for the case <code>lambda = 1</code>.</p>
</td></tr>
<tr><td><code id="stsc_+3A_kappa_grid">kappa_grid</code></td>
<td>
<p>A numeric vector which takes values between 0 and 1
to accommodate time-varying volatility in the TV-C models.
The observational variance is estimated via
Exponentially Weighted Moving Average and kappa denotes the underlying
decay factor. Constant variance is nested for the case <code>kappa = 1</code>.
Each signal in combination with each value of
kappa provides a separate candidate density forecast.
For the values of kappa, we follow the recommendation
of RiskMetrics (Reuters, 1996).</p>
</td></tr>
<tr><td><code id="stsc_+3A_bias">bias</code></td>
<td>
<p>A boolean to indicate whether the TV-C-models
allow for a bias correction to F-signals.
<code>TRUE</code> allows for a time-varying intercept, and <code>FALSE</code> sets (and fixes)
the intercept to 0.</p>
</td></tr>
<tr><td><code id="stsc_+3A_gamma_grid">gamma_grid</code></td>
<td>
<p>A numeric vector containing potential discount factors
between 0 and 1 to exponentially down-weight the past predictive performance
of the candidate forecasting models. The values of this tuning parameter
are chosen in a procedure that amounts to leave-one-out cross-validation,
taking into account the time series structure of the data.
For details, <em>see Adaemmer et al. (2023)</em>.</p>
</td></tr>
<tr><td><code id="stsc_+3A_psi_grid">psi_grid</code></td>
<td>
<p>An integer vector that controls
the (possible) sizes of the subsets. The values of this tuning parameter
are chosen in a procedure that amounts to leave-one-out cross-validation,
taking taking into account the time series structure of the data.
For details, <em>see Adaemmer et al. (2023)</em>.</p>
</td></tr>
<tr><td><code id="stsc_+3A_delta">delta</code></td>
<td>
<p>A numeric value between 0 and 1 denoting the discount factor
applied to down-weight the past predictive performance of the
aggregate predictive densities.</p>
</td></tr>
<tr><td><code id="stsc_+3A_burn_in">burn_in</code></td>
<td>
<p>An integer value <code style="white-space: pre;">&#8288;&gt;= 1&#8288;</code> that denotes the number of
observations used to 'initialize' the rankings.
After 'burn_in' observations, the rankings for both,
the candidate forecasting models and aggregate predictive densities
are reset. <code>burn_in = 1</code> means no burn-in period is applied.</p>
</td></tr>
<tr><td><code id="stsc_+3A_burn_in_dsc">burn_in_dsc</code></td>
<td>
<p>An integer value <code style="white-space: pre;">&#8288;&gt;= 1&#8288;</code> that denotes the number of
observations used to 'initialize' the rankings.
After 'burn_in_dsc' observations, only the ranking of the
aggregate predictive densities is reset.
<code>burn_in_dsc = 1</code> means no burn-in period is applied.</p>
</td></tr>
<tr><td><code id="stsc_+3A_metric">metric</code></td>
<td>
<p>An integer from the set <code style="white-space: pre;">&#8288;1, 2, 3, 4, 5&#8288;</code> representing
the metric used to rank the candidate forecasting models (TV-C models)
and subset combinations based on their predictive performance.
The default value is <code>metric = 5</code> which ranks them according to the
sum of (discounted) Continuous-Ranked-Probability-Scores (CRPS).
<code>metric = 1</code> uses discounted Predictive Log-Likelihoods,
<code>metric = 2</code> uses discounted Squared-Errors,
<code>metric = 3</code> uses discounted Absolute-Errors,
<code>metric = 4</code> uses discounted Compounded-Returns
(in this case the target variable y has to be a time series of
financial returns).</p>
</td></tr>
<tr><td><code id="stsc_+3A_equal_weight">equal_weight</code></td>
<td>
<p>A boolean that denotes whether equal weights are used to
combine the candidate forecasts within a subset. If <code>FALSE</code>, the weights are
calculated applying the softmax function on the ranking scores of
the candidate forecasting models. The method proposed in
Adaemmer et al. (2023) uses equal weights to combine the
candidate forecasting models.</p>
</td></tr>
<tr><td><code id="stsc_+3A_incl">incl</code></td>
<td>
<p>An optional integer vector that denotes signals that
must be included in the subset combinations. For example, <code>incl = c(1, 3)</code>
includes all candidate forecasting models generated by
the first and third signals. If <code>NULL</code>, no signal is forced to be included.</p>
</td></tr>
<tr><td><code id="stsc_+3A_parallel">parallel</code></td>
<td>
<p>A boolean indicating whether the function should
be parallelized.</p>
</td></tr>
<tr><td><code id="stsc_+3A_n_threads">n_threads</code></td>
<td>
<p>An integer that denotes the number of cores used
for parallelization. Only necessary if <code>parallel = TRUE</code>.</p>
</td></tr>
<tr><td><code id="stsc_+3A_portfolio_params">portfolio_params</code></td>
<td>
<p>A numeric vector of length 3
containing the following elements:
</p>

<dl>
<dt>risk_aversion</dt><dd>
<p>A non-negative double representing the investor's
risk aversion. Higher values indicate more risk-averse behavior.
</p>
</dd>
<dt>min_weight</dt><dd>
<p>A double specifying the minimum weight allocated to the market.
A non-negative lower bound effectively rules out short sales.
</p>
</dd>
<dt>max_weight</dt><dd>
<p>A double specifying the maximum weight allocated to the market.
For example, a value of 2 allows for a maximum leverage ratio of two.
</p>
</dd>
</dl>

<p>This parameter is only required if <code>metric = 4</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt>Forecasts</dt><dd><p>A list containing:
</p>

<dl>
<dt>Realization</dt><dd>
<p>A vector with the actual values of the target variable.
</p>
</dd>
<dt>Point_Forecast</dt><dd>
<p>A vector with the first moments of the aggregate predictive densities
of the STSC model.
</p>
</dd>
<dt>Variance_Prediction</dt><dd>
<p>A vector with the second moments of the aggregate predictive densities
of the STSC model.
</p>
</dd>
</dl>

</dd>
<dt>Tuning_Parameters</dt><dd><p>A list containing:
</p>

<dl>
<dt>Gamma</dt><dd>
<p>A vector containing the selected values for the tuning parameter gamma.</p>
</dd>
<dt>Psi</dt><dd>
<p>A vector containing the selected values for the tuning parameter psi.</p>
</dd>
<dt>Signals</dt><dd>
<p>A matrix containing the selected signals.</p>
</dd>
<dt>Lambda</dt><dd>
<p>A matrix containing the selected values for the tuning parameter lambda.</p>
</dd>
<dt>Kappa</dt><dd>
<p>A matrix containing the selected values for the tuning parameter kappa.</p>
</dd>
</dl>

</dd>
<dt>Model</dt><dd><p>A list containing:
</p>

<dl>
<dt>Lambda_grid</dt><dd><p>The grid of lambda values used in the model.</p>
</dd>
<dt>Kappa_grid</dt><dd><p>The grid of kappa values used in the model.</p>
</dd>
<dt>Gamma_grid</dt><dd><p>The grid of gamma values used in the model.</p>
</dd>
<dt>Psi_grid</dt><dd><p>The grid of psi values used in the model.</p>
</dd>
<dt>Delta</dt><dd><p>The delta value used in the model.</p>
</dd>
<dt>Init</dt><dd><p>The init value used in the model.</p>
</dd>
<dt>Burn_in</dt><dd><p>The burn-in period used in the model.</p>
</dd>
<dt>Burn_in_dsc</dt><dd><p>The burn-in period used in the model.</p>
</dd>
<dt>metric</dt><dd><p>The ranking metric used in the model.</p>
</dd>
<dt>Equal_weight</dt><dd><p>A boolean indicating if equal weighting was used.</p>
</dd>
<dt>Bias</dt><dd><p>A boolean indicating if bias correction was applied.</p>
</dd>
<dt>Incl</dt><dd><p>Additional included parameters.</p>
</dd>
</dl>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Philipp Adämmer, Sven Lehmann, Rainer Schüssler
</p>


<h3>References</h3>

<p>Beckmann, J., Koop, G., Korobilis, D., and Schüssler, R. A. (2020)
&quot;Exchange rate predictability and dynamic bayesian learning.&quot;
<em>Journal of Applied Econometrics</em>, 35 (4): 410–421.
</p>
<p>Dangl, T. and Halling, M. (2012)
&quot;Predictive regressions with time-varying coefficients.&quot;
<em>Journal of Financial Economics</em>, 106 (1): 157–181.
</p>
<p>Del Negro, M., Hasegawa, R. B., and Schorfheide, F. (2016)
&quot;Dynamic prediction pools:
An investigation of financial frictions and forecasting performance.&quot;
<em>Journal of Econometrics</em>, 192 (2): 391–405.
</p>
<p>Koop, G. and Korobilis, D. (2012)
&quot;Forecasting inflation using dynamic model averaging.&quot;
<em>International Economic Review</em>, 53 (3): 867–886.
</p>
<p>Koop, G. and Korobilis, D. (2023)
&quot;Bayesian dynamic variable selection in high dimensions.&quot;
<em>International Economic Review</em>.
</p>
<p>Raftery, A. E., Kárn'y, M., and Ettler, P. (2010)
&quot;Online prediction under model uncertainty via dynamic model averaging:
Application to a cold rolling mill.&quot;
<em>Technometrics</em>, 52 (1): 52–66.
</p>
<p>West, M. and Harrison, J. (1997)
&quot;Bayesian forecasting and dynamic models&quot;
<em>Springer</em>, 2nd edn.
</p>


<h3>See Also</h3>

<p><a href="https://github.com/lehmasve/hdflex#readme">https://github.com/lehmasve/hdflex#readme</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

   #########################################################
   ######### Forecasting quarterly U.S. inflation ##########
   #### Please see Koop &amp; Korobilis (2023) for further  ####
   #### details regarding the data &amp; external forecasts ####
   #########################################################

   # Load Package
   library("hdflex")
   library("ggplot2")
   library("cowplot")

   ########## Get Data ##########
   # Load Package Data
   inflation_data &lt;- inflation_data

   # Set Target Variable
   y &lt;- inflation_data[,  1]

   # Set 'P-Signals'
   X &lt;- inflation_data[, 2:442]

   # Set 'F-Signals'
   Ext_F &lt;- inflation_data[, 443:462]

   # Get Dates and Number of Observations
   tdates &lt;- rownames(inflation_data)
   tlength &lt;- length(tdates)

   # First complete observation (no missing values)
   first_complete &lt;- which(complete.cases(inflation_data))[1]

   ########## Rolling AR2-Benchmark ##########
   # Set up matrix for predictions
   benchmark &lt;- matrix(NA, nrow = tlength,
                       ncol = 1, dimnames = list(tdates, "AR2"))

   # Set Window-Size (15 years of quarterly data)
   window_size &lt;- 15 * 4

   # Time Sequence
   t_seq &lt;- seq(window_size, tlength - 1)

   # Loop with rolling window
   for (t in t_seq) {

     # Split Data for Training Train Data
     x_train &lt;- cbind(int = 1, X[(t - window_size + 1):t, 1:2])
     y_train &lt;- y[(t - window_size + 1):t]

     # Split Data for Prediction
     x_pred &lt;- cbind(int = 1, X[t + 1, 1:2, drop = FALSE])

     # Fit AR-Model
     model_ar &lt;- .lm.fit(x_train, y_train)

     # Predict and store in benchmark matrix
     benchmark[t + 1, ] &lt;- x_pred %*% model_ar$coefficients
   }

   ########## STSC ##########
   # Set TV-C-Parameter
   init &lt;- 5 * 4
   lambda_grid &lt;- c(0.90, 0.95, 1.00)
   kappa_grid &lt;- c(0.94, 0.96, 0.98)
   bias &lt;- TRUE

   # Set DSC-Parameter
   gamma_grid &lt;- c(0.40, 0.50, 0.60, 0.70, 0.80, 0.90,
                   0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99, 1.00)
   n_tvc &lt;- (ncol(X) + ncol(Ext_F)) * length(lambda_grid) * length(kappa_grid)
   psi_grid &lt;- c(1:100, sapply(1:4, function(i) floor(i * n_tvc / 4)))
   delta &lt;- 0.95
   burn_in &lt;- first_complete + init / 2
   burn_in_dsc &lt;- 1
   metric &lt;- 5
   equal_weight &lt;- TRUE
   incl &lt;- NULL
   parallel &lt;- FALSE
   n_threads &lt;- NULL

   # Apply STSC-Function
   results &lt;- hdflex::stsc(y,
                           X,
                           Ext_F,
                           init,
                           lambda_grid,
                           kappa_grid,
                           bias,
                           gamma_grid,
                           psi_grid,
                           delta,
                           burn_in,
                           burn_in_dsc,
                           metric,
                           equal_weight,
                           incl,
                           parallel,
                           n_threads,
                           NULL)

   ########## Evaluation ##########
   # Define Evaluation Period (OOS-Period)
   eval_period &lt;- which(tdates &gt;= "1991-04-01" &amp; tdates &lt;= "2021-12-01")

   # Get Evaluation Summary for STSC
   eval_results &lt;- summary(obj = results, eval_period = eval_period)

   # Calculate (Mean-)Squared-Errors for AR2-Benchmark
   se_ar2 &lt;- (y[eval_period] - benchmark[eval_period, 1])^2
   mse_ar2 &lt;- mean(se_ar2)

   # Create CSSED-Plot
   cssed &lt;- cumsum(se_ar2 - eval_results$MSE[[2]])
   plot_cssed &lt;- ggplot(
     data = data.frame(eval_period, cssed),
     aes(x = eval_period, y = cssed)
     ) +
     geom_line() +
     ylim(-0.0008, 0.0008) +
     ggtitle("Cumulative Squared Error Differences") +
     xlab("Time Index") +
     ylab("CSSED") +
     geom_hline(yintercept = 0, linetype = "dashed", color = "darkgray") +
     theme_minimal(base_size = 15) +
     theme(
       panel.grid.major = element_blank(),
       panel.grid.minor = element_blank(),
       panel.border = element_rect(colour = "black", fill = NA),
       axis.ticks = element_line(colour = "black"),
       plot.title = element_text(hjust = 0.5)
     )

   # Show Plots
   options(repr.plot.width = 15, repr.plot.height = 15)
   plots_list &lt;- eval_results$Plots
   plots_list &lt;- c(list(plot_cssed), plots_list)
   cowplot::plot_grid(plotlist = plots_list,
                      ncol = 2,
                      nrow = 3,
                      align = "hv")

   # Relative MSE
   print(paste("Relative MSE:", round(eval_results$MSE[[1]] / mse_ar2, 4)))
 
</code></pre>

<hr>
<h2 id='summary.dsc_obj'>Summary for 'dsc' object</h2><span id='topic+summary.dsc_obj'></span>

<h3>Description</h3>

<p>This function plots the evolution of the tuning parameters for a 'dsc' object and returns basic performance metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dsc_obj'
summary(object, eval_period = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.dsc_obj_+3A_object">object</code></td>
<td>
<p>An object of type 'dsc'.</p>
</td></tr>
<tr><td><code id="summary.dsc_obj_+3A_eval_period">eval_period</code></td>
<td>
<p>(Optional) A vector of indices to specify the evaluation period. Defaults to the entire period after burn-in.</p>
</td></tr>
<tr><td><code id="summary.dsc_obj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be consistent with the S3 print() function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt>MSE</dt><dd><p>A list with the mean squared error (MSE) and squared errors (SE).</p>
</dd>
<dt>ACRPS</dt><dd><p>A list with the average continuous ranked probability score (ACRPS) and CRPS values.</p>
</dd>
<dt>APLL</dt><dd><p>A list with the average predictive log-likelihood (APLL) and predictive log-likelihood (PLL) values.</p>
</dd>
<dt>Plots</dt><dd><p>A list of ggplot objects for visualizing the tuning parameters and selected CFMs.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gneiting, T., Raftery, A. E., Westveld, A. H., and Goldman, T. (2005):
Calibrated Probabilistic Forecasting Using Ensemble Model Output Statistics and Minimum CRPS Estimation.
<em>Monthly Weather Review</em>, 133: 1098–1118.
</p>
<p>Jordan, A., Krueger, F., and Lerch, S. (2019):
&quot;Evaluating Probabilistic Forecasts with scoringRules.&quot;
<em>Journal of Statistical Software</em>, 90(12): 1-37.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# See example for tvc().


</code></pre>

<hr>
<h2 id='summary.stsc_obj'>Summary for 'stsc' object</h2><span id='topic+summary.stsc_obj'></span>

<h3>Description</h3>

<p>This function plots the evolution of the tuning parameters for an 'stsc' object and returns basic performance metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stsc_obj'
summary(object, eval_period = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.stsc_obj_+3A_object">object</code></td>
<td>
<p>An object of type 'stsc'.</p>
</td></tr>
<tr><td><code id="summary.stsc_obj_+3A_eval_period">eval_period</code></td>
<td>
<p>(Optional) A vector of indices to specify the evaluation period. Defaults to the entire period after burn-in.</p>
</td></tr>
<tr><td><code id="summary.stsc_obj_+3A_...">...</code></td>
<td>
<p>Additional arguments to be consistent with the S3 print() function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt>MSE</dt><dd><p>A list with the mean squared error (MSE) and squared errors (SE).</p>
</dd>
<dt>ACRPS</dt><dd><p>A list with the average continuous ranked probability score (ACRPS) and CRPS values.</p>
</dd>
<dt>APLL</dt><dd><p>A list with the average predictive log-likelihood (APLL) and predictive log-likelihood (PLL) values.</p>
</dd>
<dt>Plots</dt><dd><p>A list of ggplot objects for visualizing the tuning parameters and selected signals.</p>
</dd>
</dl>



<h3>References</h3>

<p>Gneiting, T., Raftery, A. E., Westveld, A. H., and Goldman, T. (2005):
Calibrated Probabilistic Forecasting Using Ensemble Model Output Statistics and Minimum CRPS Estimation.
<em>Monthly Weather Review</em>, 133: 1098–1118.
</p>
<p>Jordan, A., Krueger, F., and Lerch, S. (2019):
&quot;Evaluating Probabilistic Forecasts with scoringRules.&quot;
<em>Journal of Statistical Software</em>, 90(12): 1-37.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# See example for stsc().


</code></pre>

<hr>
<h2 id='tvc'>Compute density forecasts using univariate time-varying coefficient (TV-C) models</h2><span id='topic+tvc'></span>

<h3>Description</h3>

<p>The <code>tvc()</code> function generates density forecasts
based on univariate time-varying coefficient models in state-space form.
Each forecasting model includes an intercept and one predictive signal,
which can either be a 'P-signal' or 'F-signal'.
All models are estimated independently and both
estimation and forecasting are carried out recursively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvc(y, X, Ext_F, init, lambda_grid, kappa_grid, bias)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tvc_+3A_y">y</code></td>
<td>
<p>A matrix of dimension <code>T * 1</code> or numeric vector of length <code>T</code>
containing the observations of the target variable.</p>
</td></tr>
<tr><td><code id="tvc_+3A_x">X</code></td>
<td>
<p>A matrix with <code>T</code> rows containing the lagged 'P-signals'
in each column. Use <code>NULL</code> if no (external) 'P-signal' is to be included.</p>
</td></tr>
<tr><td><code id="tvc_+3A_ext_f">Ext_F</code></td>
<td>
<p>A matrix with <code>T</code> rows containing the (external) 'F-signals'
in each column. For 'F-Signals', the slope of the TV-C models is fixed to 1.
Use <code>NULL</code> if no (external) 'F-signal' is to be included.</p>
</td></tr>
<tr><td><code id="tvc_+3A_init">init</code></td>
<td>
<p>An integer that denotes the number of observations used
to initialize the observational variance and the coefficients' variance
in the TV-C models.</p>
</td></tr>
<tr><td><code id="tvc_+3A_lambda_grid">lambda_grid</code></td>
<td>
<p>A numeric vector which takes values between 0 and 1
denoting the discount factor(s) that control the dynamics of the time-varying
coefficients. Each signal in combination with each value of
lambda provides a separate candidate forecast.
Constant coefficients are nested for the case <code>lambda = 1</code>.</p>
</td></tr>
<tr><td><code id="tvc_+3A_kappa_grid">kappa_grid</code></td>
<td>
<p>A numeric vector which takes values between 0 and 1
to accommodate time-varying volatility in the TV-C models.
The observational variance is estimated via
Exponentially Weighted Moving Average and kappa denotes the underlying
decay factor. Constant variance is nested for the case <code>kappa = 1</code>.
Each signal in combination with each value of
kappa provides a separate candidate density forecast.
For the values of kappa, we follow the recommendation
of RiskMetrics (Reuters, 1996).</p>
</td></tr>
<tr><td><code id="tvc_+3A_bias">bias</code></td>
<td>
<p>A boolean to indicate whether the TV-C-models
allow for a bias correction to F-signals.
<code>TRUE</code> allows for a time-varying intercept, and <code>FALSE</code> sets (and fixes)
the intercept to 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<dl>
<dt>Forecasts</dt><dd><p>A list containing:
</p>

<dl>
<dt>Realization: </dt><dd>
<p>A vector with the actual values of the target variable.
</p>
</dd>
<dt>Point_Forecasts: </dt><dd>
<p>A vector with the first moments of the predictive densities.
</p>
</dd>
<dt>Variance_Forecasts: </dt><dd>
<p>A vector with the second moments of the predictive densities.
</p>
</dd>
</dl>

</dd>
<dt>Model</dt><dd><p>A list containing:
</p>

<dl>
<dt>Lambda_grid</dt><dd>
<p>The grid of lambda values used in the model.
</p>
</dd>
<dt>
Kappa_grid</dt><dd><p>The grid of kappa values used in the model.
</p>
</dd>
<dt>Init</dt><dd>
<p>The init value used in the model.
</p>
</dd>
<dt>Bias</dt><dd>
<p>A boolean indicating if bias correct was applied to F-signals.
</p>
</dd>
</dl>

</dd>
</dl>



<h3>Author(s)</h3>

<p>Philipp Adämmer, Sven Lehmann, Rainer Schüssler
</p>


<h3>References</h3>

<p>Beckmann, J., Koop, G., Korobilis, D., and Schüssler, R. A. (2020)
&quot;Exchange rate predictability and dynamic bayesian learning.&quot;
<em>Journal of Applied Econometrics</em>, 35 (4): 410–421.
</p>
<p>Dangl, T. and Halling, M. (2012)
&quot;Predictive regressions with time-varying coefficients.&quot;
<em>Journal of Financial Economics</em>, 106 (1): 157–181.
</p>
<p>Del Negro, M., Hasegawa, R. B., and Schorfheide, F. (2016)
&quot;Dynamic prediction pools:
An investigation of financial frictions and forecasting performance.&quot;
<em>Journal of Econometrics</em>, 192 (2): 391–405.
</p>
<p>Koop, G. and Korobilis, D. (2012)
&quot;Forecasting inflation using dynamic model averaging.&quot;
<em>International Economic Review</em>, 53 (3): 867–886.
</p>
<p>Koop, G. and Korobilis, D. (2023)
&quot;Bayesian dynamic variable selection in high dimensions.&quot;
<em>International Economic Review</em>.
</p>
<p>Raftery, A. E., Kárn'y, M., and Ettler, P. (2010)
&quot;Online prediction under model uncertainty via dynamic model averaging:
Application to a cold rolling mill.&quot;
<em>Technometrics</em>, 52 (1): 52–66.
</p>
<p>West, M. and Harrison, J. (1997)
&quot;Bayesian forecasting and dynamic models&quot;
<em>Springer</em>, 2nd edn.
</p>


<h3>See Also</h3>

<p><a href="https://github.com/lehmasve/hdflex#readme">https://github.com/lehmasve/hdflex#readme</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

   #########################################################
   ######### Forecasting quarterly U.S. inflation ##########
   #### Please see Koop &amp; Korobilis (2023) for further  ####
   #### details regarding the data &amp; external forecasts ####
   #########################################################

   # Load Package
   library("hdflex")
   library("ggplot2")
   library("cowplot")

   ########## Get Data ##########
   # Load Package Data
   inflation_data &lt;- inflation_data

   # Set Target Variable
   y &lt;- inflation_data[,  1]

   # Set 'P-Signals'
   X &lt;- inflation_data[, 2:442]

   # Set 'F-Signals'
   Ext_F &lt;- inflation_data[, 443:462]

   # Get Dates and Number of Observations
   tdates &lt;- rownames(inflation_data)
   tlength &lt;- length(tdates)

   # First complete observation (no missing values)
   first_complete &lt;- which(complete.cases(inflation_data))[1]

   ########## Rolling AR2-Benchmark ##########
   # Set up matrix for predictions
   benchmark &lt;- matrix(NA, nrow = tlength,
                       ncol = 1, dimnames = list(tdates, "AR2"))

   # Set Window-Size (15 years of quarterly data)
   window_size &lt;- 15 * 4

   # Time Sequence
   t_seq &lt;- seq(window_size, tlength - 1)

   # Loop with rolling window
   for (t in t_seq) {

     # Split Data for Training Train Data
     x_train &lt;- cbind(int = 1, X[(t - window_size + 1):t, 1:2])
     y_train &lt;- y[(t - window_size + 1):t]

     # Split Data for Prediction
     x_pred &lt;- cbind(int = 1, X[t + 1, 1:2, drop = FALSE])

     # Fit AR-Model
     model_ar &lt;- .lm.fit(x_train, y_train)

     # Predict and store in benchmark matrix
     benchmark[t + 1, ] &lt;- x_pred %*% model_ar$coefficients
   }

   ########## STSC ##########
   ### Part 1: TVC-Function
   # Set TV-C-Parameter
   init &lt;- 5 * 4
   lambda_grid &lt;- c(0.90, 0.95, 1.00)
   kappa_grid &lt;- c(0.94, 0.96, 0.98)
   bias &lt;- TRUE

   # Apply TVC-Function
   tvc_results &lt;- hdflex::tvc(y,
                              X,
                              Ext_F,
                              init,
                              lambda_grid,
                              kappa_grid,
                              bias)

   # Assign TVC-Results
   forecast_tvc &lt;- tvc_results$Forecasts$Point_Forecasts
   variance_tvc &lt;- tvc_results$Forecasts$Variance_Forecasts

   # First complete forecast period (no missing values)
   sub_period &lt;- seq(which(complete.cases(forecast_tvc))[1], tlength)

   ### Part 2: DSC-Function
   # Set DSC-Parameter
   gamma_grid &lt;- c(0.40, 0.50, 0.60, 0.70, 0.80, 0.90,
                   0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99, 1.00)
   psi_grid &lt;- c(1:100, sapply(1:4, function(i) floor(i * ncol(forecast_tvc) / 4)))
   delta &lt;- 0.95
   burn_in_tvc &lt;- (init / 2) + 1
   burn_in_dsc &lt;- 1
   metric &lt;- 5
   equal_weight &lt;- TRUE
   incl &lt;- NULL

   # Apply DSC-Function
   dsc_results &lt;- hdflex::dsc(y[sub_period],
                              forecast_tvc[sub_period, , drop = FALSE],
                              variance_tvc[sub_period, , drop = FALSE],
                              gamma_grid,
                              psi_grid,
                              delta,
                              burn_in_tvc,
                              burn_in_dsc,
                              metric,
                              equal_weight,
                              incl,
                              NULL)

   # Assign DSC-Results
   pred_stsc &lt;- dsc_results$Forecasts$Point_Forecasts
   var_stsc &lt;- dsc_results$Forecasts$Variance_Forecasts

   ########## Evaluation ##########
   # Define Evaluation Period (OOS-Period)
   eval_period &lt;- which(tdates[sub_period] &gt;= "1991-04-01" &amp; tdates[sub_period] &lt;= "2021-12-01")

   # Get Evaluation Summary for STSC
   eval_results &lt;- summary(obj = dsc_results, eval_period = eval_period)

   # Calculate (Mean-)Squared-Errors for AR2-Benchmark
   oos_y &lt;- y[sub_period][eval_period]
   oos_benchmark &lt;- benchmark[sub_period[eval_period], , drop = FALSE]
   se_ar2 &lt;- (oos_y - oos_benchmark)^2
   mse_ar2 &lt;- mean(se_ar2)

   # Create Cumulative Squared Error Differences (CSSED) Plot
   cssed &lt;- cumsum(se_ar2 - eval_results$MSE[[2]])
   plot_cssed &lt;- ggplot(
     data.frame(eval_period, cssed),
     aes(x = eval_period, y = cssed)
   ) +
     geom_line() +
     ylim(-0.0008, 0.0008) +
     ggtitle("Cumulative Squared Error Differences") +
     xlab("Time Index") +
     ylab("CSSED") +
     geom_hline(yintercept = 0, linetype = "dashed", color = "darkgray") +
     theme_minimal(base_size = 15) +
     theme(
       panel.grid.major = element_blank(),
       panel.grid.minor = element_blank(),
       panel.border = element_rect(colour = "black", fill = NA),
       axis.ticks = element_line(colour = "black"),
       plot.title = element_text(hjust = 0.5)
     )

   # Show Plots
   options(repr.plot.width = 15, repr.plot.height = 15)
   plots_list &lt;- eval_results$Plots
   plots_list &lt;- c(list(plot_cssed), plots_list)
   cowplot::plot_grid(plotlist = plots_list,
                      ncol = 2,
                      nrow = 3,
                      align = "hv")

   # Relative MSE
   print(paste("Relative MSE:", round(eval_results$MSE[[1]] / mse_ar2, 4)))
 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
