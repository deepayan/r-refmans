<!DOCTYPE html><html><head><title>Help for package hdflex</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hdflex}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#hdflex'><p>hdflex: High-Dimensional Density Forecasts</p></a></li>
<li><a href='#benchmark_ar2'><p>AR(2) benchmark forecasts for quarterly U.S. inflation</p></a></li>
<li><a href='#dsc'><p>Generate dynamic subset forecast combinations</p></a></li>
<li><a href='#inflation_data'><p>Dataset to estimate quarterly U.S. inflation</p></a></li>
<li><a href='#stsc'><p>Signal-Transform-Subset-Combination (STSC)</p></a></li>
<li><a href='#summary_stsc'><p>Statistical summary of the STSC-results</p></a></li>
<li><a href='#tvc'><p>Compute density forecasts based on univariate time-varying</p>
coefficient (TV-C) models in state-space form</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>High-Dimensional Aggregate Density Forecasts</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sven Lehmann &lt;sven.lehmann@uni-rostock.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a forecasting method that maps vast numbers of
    (scalar-valued) signals of any type into an aggregate density forecast
    in a time-varying and computationally fast manner. The method proceeds
    in two steps: First, it transforms a predictive signal into a density
    forecast. Second, it combines the generated candidate density
    forecasts into an ultimate density forecast. The methods are explained
    in detail in Adaemmer et al. (2023) &lt;<a href="https://doi.org/10.2139%2Fssrn.4342487">doi:10.2139/ssrn.4342487</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>checkmate (&ge; 2.3.1), dplyr (&ge; 1.1.4), parallel (&ge; 4.3.0),
Rcpp, roll (&ge; 1.1.6), stats (&ge; 4.3.0), stringr (&ge; 1.5.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.2.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-29 14:45:33 UTC; slehmann</td>
</tr>
<tr>
<td>Author:</td>
<td>Sven Lehmann [aut, cre, cph],
  Philipp Adämmer [aut],
  Rainer Schüssler [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-29 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='hdflex'>hdflex: High-Dimensional Density Forecasts</h2><span id='topic+hdflex'></span><span id='topic+hdflex-package'></span>

<h3>Description</h3>

<p>hdflex contains the forecasting algorithm STSC
developed by Adämmer, Lehmann and Schüssler (2023) &lt;doi:10.2139/ssrn.4342487&gt;.
STSC is a novel time series forecasting method designed to handle very large
sets of predictive signals, many of which are irrelevant or have only
short-lived predictive power.
Please cite the paper when using the package.
</p>


<h3>Author(s)</h3>

<p>Philipp Adämmer, Sven Lehmann, Rainer Schüssler
</p>

<hr>
<h2 id='benchmark_ar2'>AR(2) benchmark forecasts for quarterly U.S. inflation</h2><span id='topic+benchmark_ar2'></span>

<h3>Description</h3>

<p>Out-of-sample one-step-ahead AR(2) benchmark forecasts for the period
from 1991-Q2 to 2021-Q4. The AR(2) models are estimated with OLS and intercept.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>benchmark_ar2
</code></pre>


<h3>Format</h3>

<p>A <a href="base.html#topic+matrix">matrix</a> with 123 quarterly observations (rows) and 4 benchmarks (columns):
</p>

<dl>
<dt>GDPCTPI</dt><dd><p>OOS-AR2-benchmark forecast for quarterly GDP deflator (GDPCTPI).</p>
</dd>
<dt>PCECTPI</dt><dd><p>OOS-AR2-benchmark forecast for quarterly PCE deflator (PCECTPI).</p>
</dd>
<dt>CPIAUCSL</dt><dd><p>OOS-AR2-benchmark forecast for quarterly Total CPI (CPIAUCSL).</p>
</dd>
<dt>CPILFESL</dt><dd><p>OOS-AR2-benchmark forecast for quarterly Core CPI (CPILFESL).</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://doi.org/10.1111/iere.12623&gt;
</p>


<h3>References</h3>

<p>Koop, G. and Korobilis, D. (2023) &quot;Bayesian dynamic variable selection in high dimensions.&quot;
<em>International Economic Review</em>.
</p>

<hr>
<h2 id='dsc'>Generate dynamic subset forecast combinations</h2><span id='topic+dsc'></span>

<h3>Description</h3>

<p>'dsc()' can be used to generate forecast combinations
from a set of candidate density forecasts. For each period,
'dsc()' selects a subset of predictive densities with highest ranks
regarding (local) predictive accuracy.
Both the identities of the candidate forecasts
that are used for building the combined forecast and
the subset sizes may vary over time based on the data.
If only one candidate forecast is picked, the approach (temporarily)
collapses to pure model selection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsc(gamma_grid, psi_grid, y, mu_mat, var_mat, delta, n_cores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dsc_+3A_gamma_grid">gamma_grid</code></td>
<td>
<p>A numerical vector that contains discount factors
to exponentially down-weight the past predictive performance
of the candidate forecasts.</p>
</td></tr>
<tr><td><code id="dsc_+3A_psi_grid">psi_grid</code></td>
<td>
<p>An integer vector that controls
the (possible) sizes of the active subsets.</p>
</td></tr>
<tr><td><code id="dsc_+3A_y">y</code></td>
<td>
<p>A matrix of dimension 'T * 1' or numeric vector of length 'T'
containing the observations of the target variable.</p>
</td></tr>
<tr><td><code id="dsc_+3A_mu_mat">mu_mat</code></td>
<td>
<p>A matrix with 'T' rows containing
the first moment of each predictive density in each column.</p>
</td></tr>
<tr><td><code id="dsc_+3A_var_mat">var_mat</code></td>
<td>
<p>A matrix with 'T' rows containing
the second moment of each predictive density in each column.</p>
</td></tr>
<tr><td><code id="dsc_+3A_delta">delta</code></td>
<td>
<p>A numeric value denoting the discount factor used
to down-weight the past predictive performance of the subset combinations.</p>
</td></tr>
<tr><td><code id="dsc_+3A_n_cores">n_cores</code></td>
<td>
<p>An integer that denotes the number of CPU-cores
used for the computational estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains:
* (1) a vector with the first moments (point forecasts) of the STSC-Model,
* (2) a vector with the the second moments (variance) of the STSC-Model,
* (3) a vector that contains the selected values for gamma,
* (4) a vector that contains the selected values for psi and
* (5) a matrix that indicates the selected signals for every point in time.
</p>


<h3>Author(s)</h3>

<p>Philipp Adämmer, Sven Lehmann, Rainer Schüssler
</p>


<h3>References</h3>

<p>Beckmann, J., Koop, G., Korobilis, D., and Schüssler, R. A. (2020) &quot;Exchange rate predictability and dynamic bayesian learning.&quot;
<em>Journal of Applied Econometrics</em>, 35 (4): 410–421.
</p>
<p>Koop, G. and Korobilis, D. (2012) &quot;Forecasting inflation using dynamic model averaging.&quot;
<em>International Economic Review</em>, 53 (3): 867–886.
</p>
<p>Koop, G. and Korobilis, D. (2023) &quot;Bayesian dynamic variable selection in high dimensions.&quot;
<em>International Economic Review</em>.
</p>
<p>Raftery, A. E., Kárn'y, M., and Ettler, P. (2010) &quot;Online prediction under model uncertainty via dynamic model averaging: Application to a cold rolling mill.&quot;
<em>Technometrics</em>, 52 (1): 52–66.
</p>
<p>Del Negro, M., Hasegawa, R. B., and Schorfheide, F. (2016) &quot;Dynamic prediction pools: An investigation of financial frictions and forecasting performance.&quot;
<em>Journal of Econometrics</em>, 192 (2): 391–405.
</p>
<p>West, M. and Harrison, J. (1997) &quot;Bayesian forecasting and dynamic models&quot;
<em>Springer</em>, 2nd edn.
</p>


<h3>See Also</h3>

<p><a href="https://github.com/lehmasve/hdflex#readme">https://github.com/lehmasve/hdflex#readme</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# See example for tvc().


</code></pre>

<hr>
<h2 id='inflation_data'>Dataset to estimate quarterly U.S. inflation</h2><span id='topic+inflation_data'></span>

<h3>Description</h3>

<p>A novel, high-dimensional dataset built by Koop and Korobilis (2023)
that merges predictive signals from several mainstream aggregate
macroeconomic and financial datasets. The dataset includes
the FRED-QD dataset of McCracken and Ng (2020),
augment with portfolio data used in Jurado et al. (2015),
stock market predictors from Welch and Goyal (2008),
survey data from University of Michigan consumer surveys,
commodity prices from the World Bank’s Pink Sheet database,
and key macroeconomic indicators from the Federal Reserve Economic Data
for four economies (Canada, Germany, Japan, United Kingdom).
The data is already pre-processed to perform one-step-ahead forecasts
and augmented with (external) point forecasts from Koop &amp; Korobilis (2023).
The dataset spans the period 1960-Q3 to 2021-Q4.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inflation_data
</code></pre>


<h3>Format</h3>

<p>A <a href="base.html#topic+matrix">matrix</a> with 245 quarterly observations (rows) and 516 variables (columns).
</p>

<dl>
<dt>Column 1:4</dt><dd><p>Transformed target variables:
GDP deflator (GDPCTPI), PCE deflator (PCECTPI),
Total CPI (CPIAUCSL), Core CPI (CPILFESL)</p>
</dd>
<dt>Column 5:8</dt><dd><p>First lag of the target variables</p>
</dd>
<dt>Column 9:12</dt><dd><p>Second lag of the target variables</p>
</dd>
<dt>Column 13:16</dt><dd><p>All four (lagged) price series transformed with second differences of logarithms</p>
</dd>
<dt>Column 17:452</dt><dd><p>All remaining (lagged and transformed) signals from the
FRED-QD dataset of McCracken and Ng (2020),
portfolio data used in Jurado et al. (2015),
stock market predictors from Welch and Goyal (2008),
survey data from University of Michigan consumer surveys,
commodity prices from the World Bank’s Pink Sheet database,
and key macroeconomic indicators from the Federal Reserve Economic Data
for Canada, Germany, Japan &amp; United Kingdom. </p>
</dd>
<dt>Column 453:468</dt><dd><p>External point forecasts for quarterly GDP deflator (GDPCTPI)
generated by the MatLab Code from Koop and Korobilis (2023).
The forecasts were generated out-of-sample from 1976-Q1 to 2021-Q4.</p>
</dd>
<dt>Column 469:484</dt><dd><p>External point forecasts for quarterly PCE deflator (PCECTPI)
generated by the MatLab Code from Koop and Korobilis (2023).
The forecasts were generated out-of-sample from 1976-Q1 to 2021-Q4.</p>
</dd>
<dt>Column 485:500</dt><dd><p>External point forecasts for quarterly Total CPI (CPIAUCSL)
generated by the MatLab Code from Koop and Korobilis (2023).
The forecasts were generated out-of-sample from 1976-Q1 to 2021-Q4.</p>
</dd>
<dt>Column 501:516</dt><dd><p>External point forecasts for quarterly Core CPI (CPILFESL)
generated by the MatLab Code from Koop and Korobilis (2023).
The forecasts were generated out-of-sample from 1976-Q1 to 2021-Q4.</p>
</dd>
</dl>



<h3>Source</h3>

<p>&lt;https://doi.org/10.1111/iere.12623&gt;
</p>


<h3>References</h3>

<p>Jurado, K., Ludvigson, S. C., and Ng, S. (2015) &quot;Measuring uncertainty.&quot;
<em>American Economic Review</em>, 105 (3): 1177–1216.
</p>
<p>Koop, G. and Korobilis, D. (2023) &quot;Bayesian dynamic variable selection in high dimensions.&quot;
<em>International Economic Review</em>.
</p>
<p>McCracken, M., and S. Ng (2020) “FRED-QD: A Quarterly Database for Macroeconomic Research”
<em>National Bureau of Economic Research</em>, Working Paper 26872.
</p>
<p>Welch, I. and Goyal, A. (2008) &quot;A comprehensive look at the empirical performance of equity premium prediction.&quot;
<em>The Review of Financial Studies</em>, 21 (4): 1455–1508.
</p>

<hr>
<h2 id='stsc'>Signal-Transform-Subset-Combination (STSC)</h2><span id='topic+stsc'></span>

<h3>Description</h3>

<p>'stsc()' is a time series forecasting method designed to handle
vast sets of predictive signals, many of which are irrelevant or short-lived.
The method transforms heterogeneous scalar-valued signals into
candidate density forecasts via time-varying coefficient models (TV-C),
and subsequently, combines them into a final density forecast
via dynamic subset combination (DSC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stsc(
  y,
  X,
  Ext_F,
  sample_length,
  lambda_grid,
  kappa_grid,
  burn_in_tvc,
  gamma_grid,
  psi_grid,
  delta,
  burn_in_dsc,
  method,
  equal_weight,
  risk_aversion = NULL,
  min_weight = NULL,
  max_weight = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stsc_+3A_y">y</code></td>
<td>
<p>A matrix of dimension 'T * 1' or numeric vector of length 'T'
containing the observations of the target variable.</p>
</td></tr>
<tr><td><code id="stsc_+3A_x">X</code></td>
<td>
<p>A matrix with 'T' rows containing
the lagged 'simple' signals in each column.
Use NULL if no 'simple' signal shall be included.</p>
</td></tr>
<tr><td><code id="stsc_+3A_ext_f">Ext_F</code></td>
<td>
<p>A matrix with 'T' rows containing
point forecasts of y in each column.
Use NULL if no point forecasts shall be included.</p>
</td></tr>
<tr><td><code id="stsc_+3A_sample_length">sample_length</code></td>
<td>
<p>An integer that denotes the number of observations used
to initialize the observational variance and the coefficients' variance
in the TV-C models.</p>
</td></tr>
<tr><td><code id="stsc_+3A_lambda_grid">lambda_grid</code></td>
<td>
<p>A numeric vector with values between 0 and 1 denoting the
discount factor(s) that control the dynamics of the time-varying
coefficients. Each signal in combination with each value of
lambda provides a separate candidate forecast.
Constant coefficients are nested for the case 'lambda = 1'.</p>
</td></tr>
<tr><td><code id="stsc_+3A_kappa_grid">kappa_grid</code></td>
<td>
<p>A numeric vector between 0 and 1 to accommodate
time-varying volatility in the TV-C models. The observational variance
is estimated via Exponentially Weighted Moving Average.
Constant variance is nested for the case 'kappa = 1'.
Each signal in combination with each value of
kappa provides a separate forecast.</p>
</td></tr>
<tr><td><code id="stsc_+3A_burn_in_tvc">burn_in_tvc</code></td>
<td>
<p>An integer value '&gt;= 1' that denotes the number of
observations used to 'initialize' the TV-C models.
After 'burn_in_tvc' observations the generated sum of discounted
predictive log-likelihoods (DPLLs) of each Candidate Model (TV-C model)
and Subset Combination (combination of gamma and psi) is resetted.
'burn_in_tvc = 1' means no burn-in period is applied.</p>
</td></tr>
<tr><td><code id="stsc_+3A_gamma_grid">gamma_grid</code></td>
<td>
<p>A numerical vector that contains discount factors
between 0 and 1 to exponentially down-weight the past predictive performance
of the candidate forecasts.</p>
</td></tr>
<tr><td><code id="stsc_+3A_psi_grid">psi_grid</code></td>
<td>
<p>An integer vector that controls
the (possible) sizes of the active subsets.</p>
</td></tr>
<tr><td><code id="stsc_+3A_delta">delta</code></td>
<td>
<p>A numeric value between 0 and 1 denoting the discount factor
used to down-weight the past predictive performance of the
subset combinations.</p>
</td></tr>
<tr><td><code id="stsc_+3A_burn_in_dsc">burn_in_dsc</code></td>
<td>
<p>An integer value '&gt;= 1' that denotes the number of
observations used to 'initialize' the Dynamic Subset Combinations.
After 'burn_in_dsc' observations the generated sum of discounted
predictive log-likelihoods (DPLLs) of each Subset Combination
(combination of gamma and psi) is resetted.
'burn_in_dsc = 1' means no burn-in period is applied.</p>
</td></tr>
<tr><td><code id="stsc_+3A_method">method</code></td>
<td>
<p>An integer of the set '1, 2, 3, 4' that denotes
the method used to rank the Candidate Models (TV-C models)
and Subset Combinations according to their performance.
Default is 'method = 1' which ranks according to their
generated sum of discounted predictive log-likelihoods (DPLLs).
'method = 2' uses Squared-Error (SE) instead of DPLLs.
'method = 3' uses Absolute-Error (AE) and
'method = 4' uses Compounded-Returns
(in this case the target variable y has to be a time series of
financial returns).</p>
</td></tr>
<tr><td><code id="stsc_+3A_equal_weight">equal_weight</code></td>
<td>
<p>A boolean that denotes whether equal weights are used to
combine the candidate forecasts within a subset. If 'FALSE', the weights are
calculated using the softmax-function on the predictive log-scores of
the candidate models. The method proposed in Adaemmer et al (2023) uses
equal weights to combine the candidate forecasts.</p>
</td></tr>
<tr><td><code id="stsc_+3A_risk_aversion">risk_aversion</code></td>
<td>
<p>A double '&gt;= 0' that denotes the risk aversion
of an investor. A higher value indicates a risk avoiding behaviour.</p>
</td></tr>
<tr><td><code id="stsc_+3A_min_weight">min_weight</code></td>
<td>
<p>A double that denotes the lower bound
for the weight placed on the market.
A non-negative value rules out short sales.</p>
</td></tr>
<tr><td><code id="stsc_+3A_max_weight">max_weight</code></td>
<td>
<p>A double that denotes the upper bound
for the weight placed on the market.
A value of e.g. 2 allows for a maximum leverage ratio of two.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains:
* (1) a vector with the first moments (point forecasts) of the STSC-Model,
* (2) a vector with the second moments (variance) of the STSC-Model,
* (3) a vector that contains the selected values for gamma,
* (4) a vector that contains the selected values for psi and
* (5) a matrix that indicates the selected signals for every point in time.
</p>


<h3>Author(s)</h3>

<p>Philipp Adämmer, Sven Lehmann, Rainer Schüssler
</p>


<h3>References</h3>

<p>Beckmann, J., Koop, G., Korobilis, D., and Schüssler, R. A. (2020) &quot;Exchange rate predictability and dynamic bayesian learning.&quot;
<em>Journal of Applied Econometrics</em>, 35 (4): 410–421.
</p>
<p>Dangl, T. and Halling, M. (2012) &quot;Predictive regressions with time-varying coefficients.&quot;
<em>Journal of Financial Economics</em>, 106 (1): 157–181.
</p>
<p>Del Negro, M., Hasegawa, R. B., and Schorfheide, F. (2016) &quot;Dynamic prediction pools: An investigation of financial frictions and forecasting performance.&quot;
<em>Journal of Econometrics</em>, 192 (2): 391–405.
</p>
<p>Koop, G. and Korobilis, D. (2012) &quot;Forecasting inflation using dynamic model averaging.&quot;
<em>International Economic Review</em>, 53 (3): 867–886.
</p>
<p>Koop, G. and Korobilis, D. (2023) &quot;Bayesian dynamic variable selection in high dimensions.&quot;
<em>International Economic Review</em>.
</p>
<p>Raftery, A. E., Kárn'y, M., and Ettler, P. (2010) &quot;Online prediction under model uncertainty via dynamic model averaging: Application to a cold rolling mill.&quot;
<em>Technometrics</em>, 52 (1): 52–66.
</p>
<p>West, M. and Harrison, J. (1997) &quot;Bayesian forecasting and dynamic models&quot;
<em>Springer</em>, 2nd edn.
</p>


<h3>See Also</h3>

<p><a href="https://github.com/lehmasve/hdflex#readme">https://github.com/lehmasve/hdflex#readme</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

   #########################################################
   ######### Forecasting quarterly U.S. inflation ##########
   #### Please see Koop &amp; Korobilis (2023) for further  ####
   #### details regarding the data &amp; external forecasts ####
   #########################################################

   # Packages
   library("hdflex")

   ########## Get Data ##########
   # Load Data
   inflation_data   &lt;-  inflation_data
   benchmark_ar2    &lt;-  benchmark_ar2

   # Set Index for Target Variable
   i  &lt;-  1   # (1 -&gt; GDPCTPI; 2 -&gt; PCECTPI; 3 -&gt; CPIAUCSL; 4 -&gt; CPILFESL)

   # Subset Data (keep only data relevant for target variable i)
   dataset  &lt;-  inflation_data[, c(1+(i-1),                          # Target Variable
                                   5+(i-1),                          # Lag 1
                                   9+(i-1),                          # Lag 2
                                   (13:16)[-i],                      # Remaining Price Series
                                   17:452,                           # Exogenous Predictor Variables
                                   seq(453+(i-1)*16,468+(i-1)*16))]  # Ext. Point Forecasts

   ########## STSC ##########
   # Set Target Variable
   y  &lt;-  dataset[,  1, drop = FALSE]

   # Set 'Simple' Signals
   X  &lt;-  dataset[, 2:442, drop = FALSE]

   # Set External Point Forecasts (Koop &amp; Korobilis 2023)
   Ext_F  &lt;-  dataset[, 443:458, drop = FALSE]

   # Set Dates
   dates  &lt;-  rownames(dataset)

   # Set TV-C-Parameter
   sample_length  &lt;-  4 * 5
   lambda_grid    &lt;-  c(0.90, 0.95, 1)
   kappa_grid     &lt;-  0.98

   # Set DSC-Parameter
   gamma_grid  &lt;-  c(0.40, 0.50, 0.60, 0.70, 0.80, 0.90,
                     0.91, 0.92, 0.93, 0.94, 0.95, 0.96,
                     0.97, 0.98, 0.99, 1.00)
   psi_grid    &lt;-  c(1:100)
   delta       &lt;-  0.95

   # Apply STSC-Function
   results  &lt;-  hdflex::stsc(y,
                             X,
                             Ext_F,
                             sample_length,
                             lambda_grid,
                             kappa_grid,
                             burn_in_tvc = 79,
                             gamma_grid,
                             psi_grid,
                             delta,
                             burn_in_dsc = 1,
                             method = 1,
                             equal_weight = TRUE,
                             risk_aversion = NULL,
                             min_weight = NULL,
                             max_weight = NULL)

   # Assign DSC-Results
   forecast_stsc    &lt;-  results[[1]]
   variance_stsc    &lt;-  results[[2]]
   chosen_gamma     &lt;-  results[[3]]
   chosen_psi       &lt;-  results[[4]]
   chosen_signals   &lt;-  results[[5]]

   # Define Evaluation Period
   eval_date_start      &lt;-  "1991-01-01"
   eval_date_end        &lt;-  "2021-12-31"
   eval_period_idx      &lt;-  which(dates &gt; eval_date_start &amp; dates &lt;= eval_date_end)

   # Trim Objects
   oos_y                &lt;-  y[eval_period_idx, ]
   oos_forecast_stsc    &lt;-  forecast_stsc[eval_period_idx]
   oos_variance_stsc    &lt;-  variance_stsc[eval_period_idx]
   oos_chosen_gamma     &lt;-  chosen_gamma[eval_period_idx]
   oos_chosen_psi       &lt;-  chosen_psi[eval_period_idx]
   oos_chosen_signals   &lt;-  chosen_signals[eval_period_idx, , drop = FALSE]
   oos_dates            &lt;-  dates[eval_period_idx]

   # Add Dates
   names(oos_forecast_stsc)     &lt;-  oos_dates
   names(oos_variance_stsc)     &lt;-  oos_dates
   names(oos_chosen_gamma)      &lt;-  oos_dates
   names(oos_chosen_psi)        &lt;-  oos_dates
   rownames(oos_chosen_signals) &lt;-  oos_dates

   ### Part 2: Evaluation ###
   # Apply Summary-Function
   summary_results  &lt;-  summary_stsc(oos_y,
                                     benchmark_ar2[, i],
                                     oos_forecast_stsc)

   # Assign Summary-Results
   cssed  &lt;-  summary_results[[3]]
   mse    &lt;-  summary_results[[4]]

   ########## Results ##########
   # Relative MSE
   print(paste("Relative MSE:", round(mse[[1]] / mse[[2]], 4)))

   # Plot CSSED
   plot(x    = as.Date(oos_dates),
        y    = cssed,
        ylim = c(-0.0008, 0.0008),
        main = "Cumulated squared error differences",
        type = "l",
        lwd  = 1.5,
        xlab = "Date",
        ylab = "CSSED") + abline(h = 0, lty = 2, col = "darkgray")

   # Plot Predictive Signals
   vec  &lt;-  seq_len(dim(oos_chosen_signals)[2])
   mat  &lt;-  oos_chosen_signals %*% diag(vec)
   mat[mat == 0]  &lt;- NA
   matplot(x    = as.Date(oos_dates),
           y    = mat,
           cex  = 0.4,
           pch  = 20,
           type = "p",
           main = "Evolution of selected signal(s)",
           xlab = "Date",
           ylab = "Predictive Signal")

   # Plot Psi
   plot(x    = as.Date(oos_dates),
        y    = oos_chosen_psi,
        ylim = c(1, 100),
        main = "Evolution of the subset size",
        type = "p",
        cex  = 0.75,
        pch  = 20,
        xlab = "Date",
        ylab = "Psi")
 
</code></pre>

<hr>
<h2 id='summary_stsc'>Statistical summary of the STSC-results</h2><span id='topic+summary_stsc'></span>

<h3>Description</h3>

<p>'summary_stsc()' returns a statistical summary
of the results from dsc(). It provides statistical measures
such as Clark-West-Statistic, OOS-R2, Mean-Squared-Error and
Cumulated Sum of Squared-Error-Differences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_stsc(oos_y, oos_benchmark, oos_forecast_stsc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_stsc_+3A_oos_y">oos_y</code></td>
<td>
<p>A matrix of dimension 'T * 1' or numeric vector of length 'T'
containing the out-of-sample observations of the target variable.</p>
</td></tr>
<tr><td><code id="summary_stsc_+3A_oos_benchmark">oos_benchmark</code></td>
<td>
<p>A matrix of dimension 'T * 1' or
numeric vector of length 'T' containing the
out-of-sample forecasts of an arbitrary benchmark
(i.e. prevailing historical mean).</p>
</td></tr>
<tr><td><code id="summary_stsc_+3A_oos_forecast_stsc">oos_forecast_stsc</code></td>
<td>
<p>A matrix of dimension 'T * 1'
or numeric vector of length 'T' containing the
out-of-sample forecasts of dsc().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List that contains:
* (1) the Clark-West-Statistic,
* (2) the Out-of-Sample R2,
* (3) a vector with the CSSED between the STSC-Forecast and the benchmark and
* (4) a list with the MSE of the STSC-Model and the benchmark.
</p>


<h3>Author(s)</h3>

<p>Philipp Adämmer, Sven Lehmann, Rainer Schüssler
</p>


<h3>References</h3>

<p>Clark, T. E. and West, K. D. (2007) &quot;Approximately normal tests for equal predictive accuracy in nested models.&quot;
<em>Journal of Econometrics</em>, 138 (1): 291–311.
</p>


<h3>See Also</h3>

<p><a href="https://github.com/lehmasve/hdflex#readme">https://github.com/lehmasve/hdflex#readme</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# See example for tvc().


</code></pre>

<hr>
<h2 id='tvc'>Compute density forecasts based on univariate time-varying
coefficient (TV-C) models in state-space form</h2><span id='topic+tvc'></span>

<h3>Description</h3>

<p>'tvc()' can be used to generate density forecasts based on
univariate time-varying coefficient models. In each forecasting model,
we include an intercept and one predictive signal. The predictive signal
either represents the value of a 'simple' signal
or the the value of an external point forecast.
All models are estimated independently from each other and
estimation and forecasting are carried out recursively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tvc(y, X, Ext_F, lambda_grid, kappa_grid, init_length, n_cores)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tvc_+3A_y">y</code></td>
<td>
<p>A matrix of dimension 'T * 1' or numeric vector of length 'T'
containing the observations of the target variable.</p>
</td></tr>
<tr><td><code id="tvc_+3A_x">X</code></td>
<td>
<p>A matrix with 'T' rows containing
the lagged 'simple' signals in each column.
Use NULL if no 'simple' signal shall be included.</p>
</td></tr>
<tr><td><code id="tvc_+3A_ext_f">Ext_F</code></td>
<td>
<p>A matrix with 'T' rows containing
point forecasts of y in each column.
Use NULL if no point forecasts shall be included.</p>
</td></tr>
<tr><td><code id="tvc_+3A_lambda_grid">lambda_grid</code></td>
<td>
<p>A numeric vector denoting the discount factor(s)
that control the dynamics of the coefficients.
Each signal in combination with each value of
lambda provides a separate candidate forecast.
Constant coefficients are nested for the case 'lambda = 1'.</p>
</td></tr>
<tr><td><code id="tvc_+3A_kappa_grid">kappa_grid</code></td>
<td>
<p>A numeric vector to accommodate time-varying volatility.
The observational variance is estimated via
Exponentially Weighted Moving Average.
Constant variance is nested for the case 'kappa = 1'.
Each signal in combination with each value of
kappa provides a separate forecast.</p>
</td></tr>
<tr><td><code id="tvc_+3A_init_length">init_length</code></td>
<td>
<p>An integer that denotes the number of observations used
to initialize the observational variance and the coefficients' variance.</p>
</td></tr>
<tr><td><code id="tvc_+3A_n_cores">n_cores</code></td>
<td>
<p>An integer that denotes the number of CPU-cores used
for the computation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list that contains:
</p>
<p>* (1) a matrix with the first moments (point forecasts)
of the conditionally normal predictive distributions and
</p>
<p>* (2) a matrix with the second moments (variance)
of the conditionally normal predictive distributions.
</p>


<h3>Author(s)</h3>

<p>Philipp Adämmer, Sven Lehmann, Rainer Schüssler
</p>


<h3>References</h3>

<p>Beckmann, J., Koop, G., Korobilis, D., and Schüssler, R. A. (2020) &quot;Exchange rate predictability and dynamic bayesian learning.&quot;
<em>Journal of Applied Econometrics</em>, 35 (4): 410–421.
</p>
<p>Dangl, T. and Halling, M. (2012) &quot;Predictive regressions with time-varying coefficients.&quot;
<em>Journal of Financial Economics</em>, 106 (1): 157–181.
</p>
<p>Koop, G. and Korobilis, D. (2012) &quot;Forecasting inflation using dynamic model averaging.&quot;
<em>International Economic Review</em>, 53 (3): 867–886.
</p>
<p>Koop, G. and Korobilis, D. (2023) &quot;Bayesian dynamic variable selection in high dimensions.&quot;
<em>International Economic Review</em>.
</p>
<p>Raftery, A. E., Kárn'y, M., and Ettler, P. (2010) &quot;Online prediction under model uncertainty via dynamic model averaging: Application to a cold rolling mill.&quot;
<em>Technometrics</em>, 52 (1): 52–66.
</p>
<p>West, M. and Harrison, J. (1997) &quot;Bayesian forecasting and dynamic models&quot;
<em>Springer</em>, 2nd edn.
</p>


<h3>See Also</h3>

<p><a href="https://github.com/lehmasve/hdflex#readme">https://github.com/lehmasve/hdflex#readme</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

   #########################################################
   ######### Forecasting quarterly U.S. inflation ##########
   #### Please see Koop &amp; Korobilis (2023) for further  ####
   #### details regarding the data &amp; external forecasts ####
   #########################################################

   # Packages
   library("hdflex")

   ########## Get Data ##########
   # Load Data
   inflation_data   &lt;-  inflation_data
   benchmark_ar2    &lt;-  benchmark_ar2

   # Set Index for Target Variable
   i  &lt;-  1   # (1 -&gt; GDPCTPI; 2 -&gt; PCECTPI; 3 -&gt; CPIAUCSL; 4 -&gt; CPILFESL)

   # Subset Data (keep only data relevant for target variable i)
   dataset  &lt;-  inflation_data[, c(1+(i-1),                          # Target Variable
                                   5+(i-1),                          # Lag 1
                                   9+(i-1),                          # Lag 2
                                   (13:16)[-i],                      # Remaining Price Series
                                   17:452,                           # Exogenous Predictor Variables
                                   seq(453+(i-1)*16,468+(i-1)*16))]  # Ext. Point Forecasts

   ########## STSC ##########
   ### Part 1: TV-C Model ###
   # Set Target Variable
   y  &lt;-  dataset[,  1, drop = FALSE]

   # Set 'Simple' Signals
   X  &lt;-  dataset[, 2:442, drop = FALSE]

   # Set External Point Forecasts (Koop &amp; Korobilis 2023)
   Ext_F  &lt;-  dataset[, 443:458, drop = FALSE]

   # Set TV-C-Parameter
   sample_length  &lt;-  4 * 5
   lambda_grid    &lt;-  c(0.90, 0.95, 1)
   kappa_grid     &lt;-  0.98
   n_cores        &lt;-  1

   # Apply TV-C-Function
   results  &lt;-  hdflex::tvc(y,
                            X,
                            Ext_F,
                            lambda_grid,
                            kappa_grid,
                            sample_length,
                            n_cores)

   # Assign TV-C-Results
   forecast_tvc      &lt;-  results[[1]]
   variance_tvc      &lt;-  results[[2]]

   # Define Burn-In Period
   sample_period_idx  &lt;-  80:nrow(dataset)
   sub_forecast_tvc   &lt;-  forecast_tvc[sample_period_idx, , drop = FALSE]
   sub_variance_tvc   &lt;-  variance_tvc[sample_period_idx, , drop = FALSE]
   sub_y              &lt;-  y[sample_period_idx, , drop = FALSE]
   sub_dates          &lt;-  rownames(dataset)[sample_period_idx]

   ### Part 2: Dynamic Subset Combination ###
   # Set DSC-Parameter
   nr_mods     &lt;-  ncol(sub_forecast_tvc)
   gamma_grid  &lt;-  c(0.40, 0.50, 0.60, 0.70, 0.80, 0.90,
                     0.91, 0.92, 0.93, 0.94, 0.95, 0.96, 0.97, 0.98, 0.99, 1.00)
   psi_grid    &lt;-  c(1:100)
   delta       &lt;-  0.95
   n_cores     &lt;-  1

   # Apply DSC-Function
   results  &lt;-  hdflex::dsc(gamma_grid,
                            psi_grid,
                            sub_y,
                            sub_forecast_tvc,
                            sub_variance_tvc,
                            delta,
                            n_cores)

   # Assign DSC-Results
   sub_forecast_stsc    &lt;-  results[[1]]
   sub_variance_stsc    &lt;-  results[[2]]
   sub_chosen_gamma     &lt;-  results[[3]]
   sub_chosen_psi       &lt;-  results[[4]]
   sub_chosen_signals   &lt;-  results[[5]]

   # Define Evaluation Period
   eval_date_start      &lt;-  "1991-01-01"
   eval_date_end        &lt;-  "2021-12-31"
   eval_period_idx      &lt;-  which(sub_dates &gt; eval_date_start &amp; sub_dates &lt;= eval_date_end)

   # Trim Objects
   oos_y                &lt;-  sub_y[eval_period_idx, ]
   oos_forecast_stsc    &lt;-  sub_forecast_stsc[eval_period_idx]
   oos_variance_stsc    &lt;-  sub_variance_stsc[eval_period_idx]
   oos_chosen_gamma     &lt;-  sub_chosen_gamma[eval_period_idx]
   oos_chosen_psi       &lt;-  sub_chosen_psi[eval_period_idx]
   oos_chosen_signals   &lt;-  sub_chosen_signals[eval_period_idx, , drop = FALSE]
   oos_dates            &lt;-  sub_dates[eval_period_idx]

   # Add Dates
   names(oos_forecast_stsc)     &lt;-  oos_dates
   names(oos_variance_stsc)     &lt;-  oos_dates
   names(oos_chosen_gamma)      &lt;-  oos_dates
   names(oos_chosen_psi)        &lt;-  oos_dates
   rownames(oos_chosen_signals) &lt;-  oos_dates

   ### Part 3: Evaluation ###
   # Apply Summary-Function
   summary_results  &lt;-  summary_stsc(oos_y,
                                     benchmark_ar2[, i],
                                     oos_forecast_stsc)
   # Assign Summary-Results
   cssed  &lt;-  summary_results[[3]]
   mse    &lt;-  summary_results[[4]]

   ########## Results ##########
   # Relative MSE
   print(paste("Relative MSE:", round(mse[[1]] / mse[[2]], 4)))

   # Plot CSSED
   plot(x    = as.Date(oos_dates),
        y    = cssed,
        ylim = c(-0.0008, 0.0008),
        main = "Cumulated squared error differences",
        type = "l",
        lwd  = 1.5,
        xlab = "Date",
        ylab = "CSSED") + abline(h = 0, lty = 2, col = "darkgray")

   # Plot Predictive Signals
   vec  &lt;-  seq_len(dim(oos_chosen_signals)[2])
   mat  &lt;-  oos_chosen_signals %*% diag(vec)
   mat[mat == 0]  &lt;- NA
   matplot(x    = as.Date(oos_dates),
           y    = mat,
           cex  = 0.4,
           pch  = 20,
           type = "p",
           main = "Evolution of selected signal(s)",
           xlab = "Date",
           ylab = "Predictive Signal")

   # Plot Psi
   plot(x    = as.Date(oos_dates),
        y    = oos_chosen_psi,
        ylim = c(1, 100),
        main = "Evolution of the subset size",
        type = "p",
        cex  = 0.75,
        pch  = 20,
        xlab = "Date",
        ylab = "Psi")
 
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
