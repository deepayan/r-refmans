<!DOCTYPE html><html><head><title>Help for package chessboard</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {chessboard}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#chessboard-package'><p>chessboard: Create Network Connections Based on Chess Moves</p></a></li>
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#append_edge_lists'><p>Append several edge lists</p></a></li>
<li><a href='#append_matrix'><p>Combine several connectivity matrices</p></a></li>
<li><a href='#bishop'><p>Find neighbors according to bishop movement</p></a></li>
<li><a href='#bishop_left'><p>Find neighbors according to bishop left movement</p></a></li>
<li><a href='#bishop_right'><p>Find neighbors according to bishop right movement</p></a></li>
<li><a href='#connectivity_matrix'><p>Create a connectivity matrix from an edge list</p></a></li>
<li><a href='#create_edge_list'><p>Create an edge list</p></a></li>
<li><a href='#create_node_labels'><p>Create unique node labels</p></a></li>
<li><a href='#distance_euclidean'><p>Compute the pairwise Euclidean distance</p></a></li>
<li><a href='#edges_to_sf'><p>Convert edge list to spatial object</p></a></li>
<li><a href='#edges_weights_matrix'><p>Create an edges weights matrix</p></a></li>
<li><a href='#edges_weights_vector'><p>Create an edges weights vector</p></a></li>
<li><a href='#fool'><p>Find neighbors according to fool movement</p></a></li>
<li><a href='#geom_edges'><p>Link neighbors by arrow on a chessboard</p></a></li>
<li><a href='#geom_neighbors'><p>Highlight neighbors on a chessboard</p></a></li>
<li><a href='#geom_node'><p>Highlight a node on a chessboard</p></a></li>
<li><a href='#get_node_list'><p>Get the list of nodes</p></a></li>
<li><a href='#gg_chessboard'><p>Plot a sampling as a chessboard</p></a></li>
<li><a href='#gg_matrix'><p>Plot a connectivity or a nodes-by-edges matrix</p></a></li>
<li><a href='#knight'><p>Find neighbors according to knight movement</p></a></li>
<li><a href='#knight_left'><p>Find neighbors according to knight left movement</p></a></li>
<li><a href='#knight_right'><p>Find neighbors according to knight right movement</p></a></li>
<li><a href='#matrix_to_edge_list'><p>Convert an connectivity matrix to an edge list</p></a></li>
<li><a href='#nodes_by_edges_matrix'><p>Create a nodes-by-edges matrix</p></a></li>
<li><a href='#pawn'><p>Find neighbors according to pawn movement</p></a></li>
<li><a href='#queen'><p>Find neighbors according to queen movement</p></a></li>
<li><a href='#rook'><p>Find neighbors according to rook movement</p></a></li>
<li><a href='#spatial_weights_matrix'><p>Create a spatial weights matrix</p></a></li>
<li><a href='#wizard'><p>Find neighbors according to wizard movement</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Create Network Connections Based on Chess Moves</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides functions to work with directed (asymmetric) and 
    undirected (symmetric) spatial networks. It makes the creation of 
    connectivity matrices easier, i.e. a binary matrix of dimension n x n, where 
    n is the number of nodes (sampling units) indicating the presence (1) or  
    the absence (0) of an edge (link) between pairs of nodes. Different network
    objects can be produced by 'chessboard': node list, neighbor list, edge 
    list, connectivity matrix. It can also produce objects that will be used 
    later in Moran's Eigenvector Maps (Dray et al. (2006) &lt;<a href="https://doi.org/10.1016%2Fj.ecolmodel.2006.02.015">doi:10.1016/j.ecolmodel.2006.02.015</a>&gt;)
    and Asymetric Eigenvector Maps (Blanchet et al. (2008) &lt;<a href="https://doi.org/10.1016%2Fj.ecolmodel.2008.04.001">doi:10.1016/j.ecolmodel.2008.04.001</a>&gt;), 
    methods available in the package 'adespatial' (Dray et al. (2023) 
    <a href="https://CRAN.R-project.org/package=adespatial">https://CRAN.R-project.org/package=adespatial</a>). This work is part of the 
    FRB-CESAB working group Bridge 
    <a href="https://www.fondationbiodiversite.fr/en/the-frb-in-action/programs-and-projects/le-cesab/bridge/">https://www.fondationbiodiversite.fr/en/the-frb-in-action/programs-and-projects/le-cesab/bridge/</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/frbcesab/chessboard">https://github.com/frbcesab/chessboard</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/frbcesab/chessboard/issues">https://github.com/frbcesab/chessboard/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, ggplot2, magrittr, rlang, sf, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, igraph, patchwork, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-13 18:10:41 UTC; Nicolas</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicolas Casajus <a href="https://orcid.org/0000-0002-5537-5294"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Erica Rievrs Borges
    <a href="https://orcid.org/0000-0001-7751-6265"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Eric Tabacchi <a href="https://orcid.org/0000-0001-7729-4439"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Guillaume Fried <a href="https://orcid.org/0000-0002-3653-195X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Nicolas Mouquet <a href="https://orcid.org/0000-0003-1840-6984"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicolas Casajus &lt;nicolas.casajus@fondationbiodiversite.fr&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-14 08:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='chessboard-package'>chessboard: Create Network Connections Based on Chess Moves</h2><span id='topic+chessboard'></span><span id='topic+chessboard-package'></span>

<h3>Description</h3>

<p>Provides functions to work with directed (asymmetric) and undirected (symmetric) spatial networks. It makes the creation of connectivity matrices easier, i.e. a binary matrix of dimension n x n, where n is the number of nodes (sampling units) indicating the presence (1) or the absence (0) of an edge (link) between pairs of nodes. Different network objects can be produced by 'chessboard': node list, neighbor list, edge list, connectivity matrix. It can also produce objects that will be used later in Moran's Eigenvector Maps (Dray et al. (2006) <a href="https://doi.org/10.1016/j.ecolmodel.2006.02.015">doi:10.1016/j.ecolmodel.2006.02.015</a>) and Asymetric Eigenvector Maps (Blanchet et al. (2008) <a href="https://doi.org/10.1016/j.ecolmodel.2008.04.001">doi:10.1016/j.ecolmodel.2008.04.001</a>), methods available in the package 'adespatial' (Dray et al. (2023) <a href="https://CRAN.R-project.org/package=adespatial">https://CRAN.R-project.org/package=adespatial</a>). This work is part of the FRB-CESAB working group Bridge <a href="https://www.fondationbiodiversite.fr/en/the-frb-in-action/programs-and-projects/le-cesab/bridge/">https://www.fondationbiodiversite.fr/en/the-frb-in-action/programs-and-projects/le-cesab/bridge/</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nicolas Casajus <a href="mailto:nicolas.casajus@fondationbiodiversite.fr">nicolas.casajus@fondationbiodiversite.fr</a> (<a href="https://orcid.org/0000-0002-5537-5294">ORCID</a>) [copyright holder]
</p>
<p>Authors:
</p>

<ul>
<li><p> Erica Rievrs Borges <a href="mailto:erica.rievrs@fondationbiodiversite.fr">erica.rievrs@fondationbiodiversite.fr</a> (<a href="https://orcid.org/0000-0001-7751-6265">ORCID</a>)
</p>
</li>
<li><p> Eric Tabacchi <a href="mailto:eric.tabacchi@univ-tlse3.fr">eric.tabacchi@univ-tlse3.fr</a> (<a href="https://orcid.org/0000-0001-7729-4439">ORCID</a>)
</p>
</li>
<li><p> Guillaume Fried <a href="mailto:guillaume.fried@anses.fr">guillaume.fried@anses.fr</a> (<a href="https://orcid.org/0000-0002-3653-195X">ORCID</a>)
</p>
</li>
<li><p> Nicolas Mouquet <a href="mailto:nicolas.mouquet@cnrs.fr">nicolas.mouquet@cnrs.fr</a> (<a href="https://orcid.org/0000-0003-1840-6984">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/frbcesab/chessboard">https://github.com/frbcesab/chessboard</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/frbcesab/chessboard/issues">https://github.com/frbcesab/chessboard/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='append_edge_lists'>Append several edge lists</h2><span id='topic+append_edge_lists'></span>

<h3>Description</h3>

<p>Appends several edge lists created by <code><a href="#topic+create_edge_list">create_edge_list()</a></code>. Merged edges
will be ordered and duplicates will be removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_edge_lists(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_edge_lists_+3A_...">...</code></td>
<td>
<p>one or several edge lists <code>data.frame</code>. Outputs of the function
<code><a href="#topic+create_edge_list">create_edge_list()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with <code>n</code> rows (where <code>n</code> is the total number of edges)
and the following two columns:
</p>

<ul>
<li> <p><code>from</code>: the node label of one of the two endpoints of the edge
</p>
</li>
<li> <p><code>to</code>: the node label of the other endpoint of the edge
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling (only) ----
sites_infos &lt;- expand.grid("transect" = 1:3, "quadrat" = 1:5)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

edges_1 &lt;- create_edge_list(nodes, method = "pawn", directed = TRUE)
edges_2 &lt;- create_edge_list(nodes, method = "bishop", directed = TRUE)

edges &lt;- append_edge_lists(edges_1, edges_2)
</code></pre>

<hr>
<h2 id='append_matrix'>Combine several connectivity matrices</h2><span id='topic+append_matrix'></span>

<h3>Description</h3>

<p>Combines different connectivity matrices by row names and column names by
performing a 2-dimensional full join. Missing edges are filled with <code>0</code>
(default) or <code>NA</code> (argument <code>na_to_zero</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_matrix(..., na_to_zero = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_matrix_+3A_...">...</code></td>
<td>
<p>one or several <code>matrix</code> objects created by
<code><a href="#topic+connectivity_matrix">connectivity_matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="append_matrix_+3A_na_to_zero">na_to_zero</code></td>
<td>
<p>a <code>logical</code> value. If <code>TRUE</code> (default) missing edges are
coded as <code>0</code>. Otherwise they will be coded as <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A connectivity matrix of dimensions <code style="white-space: pre;">&#8288;n x n&#8288;</code>, where <code>n</code> is the total
number of unique nodes across all provided matrices.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat1 &lt;- matrix(rep(1, 9), nrow = 3)
colnames(mat1) &lt;- c("A", "B", "C")
rownames(mat1) &lt;- c("A", "B", "C")
mat1

mat2 &lt;- matrix(rep(1, 9), nrow = 3)
colnames(mat2) &lt;- c("D", "E", "F")
rownames(mat2) &lt;- c("D", "E", "F")
mat2

mat3 &lt;- matrix(rep(1, 9), nrow = 3)
colnames(mat3) &lt;- c("F", "G", "H")
rownames(mat3) &lt;- c("F", "G", "H")
mat3

append_matrix(mat1, mat2, mat3)

append_matrix(mat1, mat2, mat3, na_to_zero = FALSE)
</code></pre>

<hr>
<h2 id='bishop'>Find neighbors according to bishop movement</h2><span id='topic+bishop'></span>

<h3>Description</h3>

<p>For one node (argument <code>focus</code>), finds neighbors among a list of nodes
according to the bishop movement.
This movement is derived from the chess game. The bishop can move along the
two diagonals.
</p>
<p>The detection of neighbors using this method can only work with
two-dimensional sampling (both <strong>transects</strong> and <strong>quadrats</strong>).
For sampling of type <strong>transects-only</strong> or <strong>quadrats-only</strong>,
please use the functions <code><a href="#topic+fool">fool()</a></code> or <code><a href="#topic+pawn">pawn()</a></code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bishop(
  nodes,
  focus,
  degree = 1,
  directed = FALSE,
  reverse = FALSE,
  self = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bishop_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> with (at least) the following three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. Must be the output of the function
<code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
<tr><td><code id="bishop_+3A_focus">focus</code></td>
<td>
<p>an <code>character</code> of length 1. The node label for which the
neighbors must be found. Must exist in the <code>nodes</code> object.</p>
</td></tr>
<tr><td><code id="bishop_+3A_degree">degree</code></td>
<td>
<p>an <code>integer</code> of length 1. The maximum number of neighbors to
search for.</p>
</td></tr>
<tr><td><code id="bishop_+3A_directed">directed</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>FALSE</code> (default), search for
neighbors in all directions (undirected network). Otherwise, the network
will be considered as directed according to the orientations of the
network. The default orientation follows the order of node labels in
both axes.</p>
</td></tr>
<tr><td><code id="bishop_+3A_reverse">reverse</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, change the default
orientation of the network. This argument is ignored if <code>directed = FALSE</code>.
See examples for further detail.</p>
</td></tr>
<tr><td><code id="bishop_+3A_self">self</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, a node can be its own
neighbor. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is internally called by <code><a href="#topic+create_edge_list">create_edge_list()</a></code> but it can be
directly used to 1) understand the neighbors detection method, and 2) to
check detected neighbors for one particular node (<code>focus</code>).
</p>


<h3>Value</h3>

<p>A subset of the <code>nodes</code> (<code>data.frame</code>) where each row is a neighbor
of the focal node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling (only) ----
sites_infos &lt;- expand.grid("transect" = 1:9, "quadrat" = 1:9)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

focus     &lt;- "5-5"

# Default settings ----
neighbors &lt;- bishop(nodes, focus)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)

# Higher degree of neighborhood ----
neighbors &lt;- bishop(nodes, focus, degree = 3)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (default orientation) ----
neighbors &lt;- bishop(nodes, focus, degree = 3, directed = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (reverse orientation) ----
neighbors &lt;- bishop(nodes, focus, degree = 3, directed = TRUE, 
                    reverse = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
</code></pre>

<hr>
<h2 id='bishop_left'>Find neighbors according to bishop left movement</h2><span id='topic+bishop_left'></span>

<h3>Description</h3>

<p>For one node (argument <code>focus</code>), finds neighbors among a list of nodes
according to the bishop left movement.
This movement is derived from the <code><a href="#topic+bishop">bishop()</a></code> method and can only move along
the bottom-right to top-left diagonal.
</p>
<p>The detection of neighbors using this method can only work with
two-dimensional sampling (both <strong>transects</strong> and <strong>quadrats</strong>).
For sampling of type <strong>transects-only</strong> or <strong>quadrats-only</strong>,
please use the functions <code><a href="#topic+fool">fool()</a></code> or <code><a href="#topic+pawn">pawn()</a></code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bishop_left(
  nodes,
  focus,
  degree = 1,
  directed = FALSE,
  reverse = FALSE,
  self = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bishop_left_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> with (at least) the following three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. Must be the output of the function
<code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
<tr><td><code id="bishop_left_+3A_focus">focus</code></td>
<td>
<p>an <code>character</code> of length 1. The node label for which the
neighbors must be found. Must exist in the <code>nodes</code> object.</p>
</td></tr>
<tr><td><code id="bishop_left_+3A_degree">degree</code></td>
<td>
<p>an <code>integer</code> of length 1. The maximum number of neighbors to
search for.</p>
</td></tr>
<tr><td><code id="bishop_left_+3A_directed">directed</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>FALSE</code> (default), search for
neighbors in all directions (undirected network). Otherwise, the network
will be considered as directed according to the orientations of the
network. The default orientation follows the order of node labels in
both axes.</p>
</td></tr>
<tr><td><code id="bishop_left_+3A_reverse">reverse</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, change the default
orientation of the network. This argument is ignored if <code>directed = FALSE</code>.
See examples for further detail.</p>
</td></tr>
<tr><td><code id="bishop_left_+3A_self">self</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, a node can be its own
neighbor. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is internally called by <code><a href="#topic+create_edge_list">create_edge_list()</a></code> but it can be
directly used to 1) understand the neighbors detection method, and 2) to
check detected neighbors for one particular node (<code>focus</code>).
</p>


<h3>Value</h3>

<p>A subset of the <code>nodes</code> (<code>data.frame</code>) where each row is a neighbor
of the focal node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling (only) ----
sites_infos &lt;- expand.grid("transect" = 1:9, "quadrat" = 1:9)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

focus     &lt;- "5-5"

# Default settings ----
neighbors &lt;- bishop_left(nodes, focus)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)

# Higher degree of neighborhood ----
neighbors &lt;- bishop_left(nodes, focus, degree = 3)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (default orientation) ----
neighbors &lt;- bishop_left(nodes, focus, degree = 3, directed = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (reverse orientation) ----
neighbors &lt;- bishop_left(nodes, focus, degree = 3, directed = TRUE, 
                         reverse = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
</code></pre>

<hr>
<h2 id='bishop_right'>Find neighbors according to bishop right movement</h2><span id='topic+bishop_right'></span>

<h3>Description</h3>

<p>For one node (argument <code>focus</code>), finds neighbors among a list of nodes
according to the bishop right movement.
This movement is derived from the <code><a href="#topic+bishop">bishop()</a></code> method and can only move along
the bottom-left to top-right diagonal.
</p>
<p>The detection of neighbors using this method can only work with
two-dimensional sampling (both <strong>transects</strong> and <strong>quadrats</strong>).
For sampling of type <strong>transects-only</strong> or <strong>quadrats-only</strong>,
please use the functions <code><a href="#topic+fool">fool()</a></code> or <code><a href="#topic+pawn">pawn()</a></code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bishop_right(
  nodes,
  focus,
  degree = 1,
  directed = FALSE,
  reverse = FALSE,
  self = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bishop_right_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> with (at least) the following three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. Must be the output of the function
<code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
<tr><td><code id="bishop_right_+3A_focus">focus</code></td>
<td>
<p>an <code>character</code> of length 1. The node label for which the
neighbors must be found. Must exist in the <code>nodes</code> object.</p>
</td></tr>
<tr><td><code id="bishop_right_+3A_degree">degree</code></td>
<td>
<p>an <code>integer</code> of length 1. The maximum number of neighbors to
search for.</p>
</td></tr>
<tr><td><code id="bishop_right_+3A_directed">directed</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>FALSE</code> (default), search for
neighbors in all directions (undirected network). Otherwise, the network
will be considered as directed according to the orientations of the
network. The default orientation follows the order of node labels in
both axes.</p>
</td></tr>
<tr><td><code id="bishop_right_+3A_reverse">reverse</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, change the default
orientation of the network. This argument is ignored if <code>directed = FALSE</code>.
See examples for further detail.</p>
</td></tr>
<tr><td><code id="bishop_right_+3A_self">self</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, a node can be its own
neighbor. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is internally called by <code><a href="#topic+create_edge_list">create_edge_list()</a></code> but it can be
directly used to 1) understand the neighbors detection method, and 2) to
check detected neighbors for one particular node (<code>focus</code>).
</p>


<h3>Value</h3>

<p>A subset of the <code>nodes</code> (<code>data.frame</code>) where each row is a neighbor
of the focal node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling (only) ----
sites_infos &lt;- expand.grid("transect" = 1:9, "quadrat" = 1:9)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

focus     &lt;- "5-5"

# Default settings ----
neighbors &lt;- bishop_right(nodes, focus)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)

# Higher degree of neighborhood ----
neighbors &lt;- bishop_right(nodes, focus, degree = 3)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (default orientation) ----
neighbors &lt;- bishop_right(nodes, focus, degree = 3, directed = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (reverse orientation) ----
neighbors &lt;- bishop_right(nodes, focus, degree = 3, directed = TRUE, 
                          reverse = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
</code></pre>

<hr>
<h2 id='connectivity_matrix'>Create a connectivity matrix from an edge list</h2><span id='topic+connectivity_matrix'></span>

<h3>Description</h3>

<p>Converts an edge list to an connectivity matrix (also known as adjacency
matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connectivity_matrix(
  edges,
  lower = TRUE,
  upper = TRUE,
  diag = TRUE,
  na_to_zero = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="connectivity_matrix_+3A_edges">edges</code></td>
<td>
<p>a <code>data.frame</code> with the following two columns: <code>from</code> (the
first node of the edge) and <code>to</code> (the second node of the edge). The output
of the functions <code><a href="#topic+create_edge_list">create_edge_list()</a></code> or <code><a href="#topic+append_edge_lists">append_edge_lists()</a></code>.</p>
</td></tr>
<tr><td><code id="connectivity_matrix_+3A_lower">lower</code></td>
<td>
<p>a <code>logical</code> value. If <code>TRUE</code> (default), keep values in the
lower triangle of the matrix. Otherwise they will be replaced by <code>NA</code>
(or <code>0</code>).</p>
</td></tr>
<tr><td><code id="connectivity_matrix_+3A_upper">upper</code></td>
<td>
<p>a <code>logical</code> value. If <code>TRUE</code> (default), keep values in the
upper triangle of the matrix. Otherwise they will be replaced by <code>NA</code>
(or <code>0</code>).</p>
</td></tr>
<tr><td><code id="connectivity_matrix_+3A_diag">diag</code></td>
<td>
<p>a <code>logical</code> value. If <code>TRUE</code> (default), keep values in the
diagonal of the matrix. Otherwise they will be replaced by <code>NA</code>
(or <code>0</code>).</p>
</td></tr>
<tr><td><code id="connectivity_matrix_+3A_na_to_zero">na_to_zero</code></td>
<td>
<p>a <code>logical</code> value. If <code>TRUE</code> (default), missing edges are
coded as <code>0</code>. Otherwise they will be coded as <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A connectivity matrix of dimensions <code style="white-space: pre;">&#8288;n x n&#8288;</code>, where <code>n</code> is the number
of nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import Adour sites ----
path_to_file &lt;- system.file("extdata", "adour_survey_sampling.csv", 
                            package = "chessboard")
adour_sites  &lt;- read.csv(path_to_file)

# Select first location ----
adour_sites &lt;- adour_sites[adour_sites$"location" == 1, ]

# Create node labels ----
adour_nodes &lt;- create_node_labels(data     = adour_sites, 
                                  location = "location", 
                                  transect = "transect", 
                                  quadrat = "quadrat")

# Find edges with 1 degree of neighborhood (pawn method) ----
adour_edges &lt;- create_edge_list(adour_nodes, method = "pawn", 
                                directed = TRUE)

# Get connectivity matrix ----
connectivity_matrix(adour_edges)

# Get connectivity matrix ----
connectivity_matrix(adour_edges, na_to_zero = FALSE)
</code></pre>

<hr>
<h2 id='create_edge_list'>Create an edge list</h2><span id='topic+create_edge_list'></span>

<h3>Description</h3>

<p>Creates a list of edges (links) between nodes (sampling units) based on the
detection of neighbors and according to three neighborhood rules:
</p>

<ol>
<li> <p><strong>Degree of neighborhood</strong> (argument <code>degree</code>): the number of adjacent
nodes that will be used to create <strong>direct</strong> edges. If <code>degree = 1</code>,
only nodes directly adjacent to the focal node will be considered as
neighbors.
</p>
</li>
<li> <p><strong>Orientation of neighborhood</strong> (argument <code>method</code>): can neighbors be
detecting horizontally and/or vertically and/or diagonally? The package
<code>chessboard</code> implements all possible orientations derived from the chess
game.
</p>
</li>
<li> <p><strong>Direction of neighborhood</strong> (arguments <code>directed</code> and <code>reverse</code>): does
the sampling design has a direction? If so (<code>directed = TRUE</code>), the network
will be considered as <strong>directed</strong> and the direction will follow the order
of node labels in both axes (except if <code>reverse = TRUE</code>).
</p>
</li></ol>

<p>It's important to note that, even the package <code>chessboard</code> is designed to
deal with spatial networks, this function does not explicitly use spatial
coordinates to detect neighbors. Instead it uses the <strong>node labels</strong>. The
function <code><a href="#topic+create_node_labels">create_node_labels()</a></code> must be used before this function to create
node labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_edge_list(
  nodes,
  method,
  degree = 1,
  directed = FALSE,
  reverse = FALSE,
  self = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_edge_list_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> with (at least) the following three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. Must be the output of the function
<code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
<tr><td><code id="create_edge_list_+3A_method">method</code></td>
<td>
<p>a <code>character</code> of length 1. The method used to detect neighbors.
One among <code>'pawn'</code>, <code>'fool'</code>, <code>'rook'</code>, <code>'bishop'</code>, <code>'bishop_left'</code>,
<code>'bishop_right'</code>, <code>'knight'</code>, <code>'knight_left'</code>, <code>'knight_right'</code>,
<code>'queen'</code>, <code>'wizard'</code>. For further information, see the functions of the
same name (i.e. <code><a href="#topic+pawn">pawn()</a></code>, <code><a href="#topic+rook">rook()</a></code>, etc.).</p>
</td></tr>
<tr><td><code id="create_edge_list_+3A_degree">degree</code></td>
<td>
<p>an <code>integer</code> of length 1. The maximum number of neighbors to
search for.</p>
</td></tr>
<tr><td><code id="create_edge_list_+3A_directed">directed</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>FALSE</code> (default), search for
neighbors in all directions (undirected network). Otherwise, the network
will be considered as directed according to the orientations of the
network. The default orientation follows the order of node labels in
both axes.</p>
</td></tr>
<tr><td><code id="create_edge_list_+3A_reverse">reverse</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, change the default
orientation of the network. This argument is ignored if <code>directed = FALSE</code>.
See examples for further detail.</p>
</td></tr>
<tr><td><code id="create_edge_list_+3A_self">self</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, a node can be its own
neighbor. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with <code>n</code> rows (where <code>n</code> is the number of edges) and
the following two columns:
</p>

<ul>
<li> <p><code>from</code>: the node label of one of the two endpoints of the edge
</p>
</li>
<li> <p><code>to</code>: the node label of the other endpoint of the edge
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling (only) ----
sites_infos &lt;- expand.grid("transect" = 1:3, "quadrat" = 1:5)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

edges &lt;- create_edge_list(nodes, method = "pawn", directed = TRUE)
edges

edges &lt;- create_edge_list(nodes, method = "bishop", directed = TRUE)
edges
</code></pre>

<hr>
<h2 id='create_node_labels'>Create unique node labels</h2><span id='topic+create_node_labels'></span>

<h3>Description</h3>

<p>Creates unique node (sampling units) labels in directed (or undirected)
spatial (or not) networks.
</p>
<p>It's important to note that, even the package <code>chessboard</code> is designed to
deal with spatial networks, it does not explicitly use spatial coordinates.
Every functions of the package will use the <strong>node labels</strong>.
</p>
<p>To work, the package <code>chessboard</code> requires that the sampling has two
dimensions:
one from bottom to top (called <strong>quadrats</strong>), and one from left to right
(called <strong>transects</strong>). If the sampling has been conducted along one single
dimension (<strong>transects</strong> or <strong>quadrats</strong>), this function will create a
fictitious label for the missing dimension.
In other words, the package <code>chessboard</code> can work with sampling designs such
as regular grids (two dimensions), transects (one dimension), and quadrats
(one dimension).
</p>
<p>In addition, the package can also deal with multiple locations. In that
case, users will need to use the argument <code>location</code>.
</p>
<p>The node labels will be of the form: <code>1-2</code>, where <code>1</code> is the identifier of
the transect (created by the function if missing), and <code>2</code>, the identifier
of the quadrat (created by the function if missing).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_node_labels(data, location, transect, quadrat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_node_labels_+3A_data">data</code></td>
<td>
<p>a <code>data.frame</code> with at least one column, <code>'transect'</code> or
<code>'quadrat'</code>. If only one column is provided and <code>transect</code> or <code>quadrat</code>
is <code>NULL</code>, the network will be considered as one-dimensional. If <code>data</code>
contains both <code>'transect'</code> and <code>'quadrat'</code> columns, the network will be
considered as two-dimensional. The <code>data.frame</code> can contain additional
columns.</p>
</td></tr>
<tr><td><code id="create_node_labels_+3A_location">location</code></td>
<td>
<p>a <code>character</code> of length 1. The name of the column that
contains location identifiers. If missing (or <code>NULL</code>), a unique location
identifier will be created and named <code>1</code> (for the purpose of the package
only). This argument is optional if the sampling ha been conducted at one
location, but required if the survey is structured in multiple locations.</p>
</td></tr>
<tr><td><code id="create_node_labels_+3A_transect">transect</code></td>
<td>
<p>a <code>character</code> of length 1. The name of the column that
contains transect identifiers. If missing (or <code>NULL</code>), a unique transect
identifier will be created and named <code>1</code> (for the purpose of the package
only). If missing, the network will be considered as one-dimensional.</p>
</td></tr>
<tr><td><code id="create_node_labels_+3A_quadrat">quadrat</code></td>
<td>
<p>a <code>character</code> of length 1. The name of the column that
contains quadrat identifiers. If missing (or <code>NULL</code>), a unique quadrat
identifier will be created and named <code>1</code> (for the purpose of the package
only). If missing, the network will be considered as one-dimensional.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with at least the four following columns:
</p>

<ul>
<li> <p><code>node</code>, the node label
</p>
</li>
<li> <p><code>location</code>, the identifier of the location
</p>
</li>
<li> <p><code>transect</code>, the identifier of the transect
</p>
</li>
<li> <p><code>quadrat</code>, the identifier of the quadrat
Other columns present in the original dataset will also be added.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling ----
sites_infos &lt;- expand.grid("transect" = 1:3, "quadrat" = 1:5)
sites_infos

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")
nodes

gg_chessboard(nodes)

# One-dimensional sampling (only transects) ----
transects_only &lt;- data.frame("transect" = 1:5)

nodes &lt;- create_node_labels(transects_only,
                            transect = "transect")
nodes

gg_chessboard(nodes)

# One-dimensional sampling (only quadrats) ----
quadrats_only &lt;- data.frame("quadrat" = 1:5)

nodes &lt;- create_node_labels(quadrats_only,
                            quadrat = "quadrat")
nodes

gg_chessboard(nodes)
</code></pre>

<hr>
<h2 id='distance_euclidean'>Compute the pairwise Euclidean distance</h2><span id='topic+distance_euclidean'></span>

<h3>Description</h3>

<p>Computes the Euclidean distance between two nodes using the function
<code><a href="sf.html#topic+geos_measures">sf::st_distance()</a></code>. If the CRS is not a Cartesian system, the Great Circle
distance will be used instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_euclidean(sites, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_euclidean_+3A_sites">sites</code></td>
<td>
<p>an <code>sf</code> object of type <code>POINT</code>. A spatial object
containing coordinates of sites. Note that the first column must be the
node label created by the function <code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
<tr><td><code id="distance_euclidean_+3A_...">...</code></td>
<td>
<p>other argument to pass to <code><a href="sf.html#topic+geos_measures">sf::st_distance()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A three-column <code>data.frame</code> with:
</p>

<ul>
<li> <p><code>from</code>, the first node
</p>
</li>
<li> <p><code>to</code>, the second node
</p>
</li>
<li> <p><code>weight</code>, the Euclidean distance between the two nodes
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Import Adour sites ----
path_to_file &lt;- system.file("extdata", "adour_survey_sampling.csv", 
                            package = "chessboard")
adour_sites &lt;- read.csv(path_to_file)

# Select the 15 first sites ----
adour_sites &lt;- adour_sites[1:15, ]

# Create node labels ----
adour_sites &lt;- create_node_labels(adour_sites, 
                                  location = "location", 
                                  transect = "transect", 
                                  quadrat  = "quadrat")

# Convert sites to sf object (POINTS) ----
adour_sites &lt;- sf::st_as_sf(adour_sites, coords = c("longitude", "latitude"),
                            crs = "epsg:2154")

# Compute distances between pairs of sites ----
weights &lt;- distance_euclidean(adour_sites)

head(weights)
</code></pre>

<hr>
<h2 id='edges_to_sf'>Convert edge list to spatial object</h2><span id='topic+edges_to_sf'></span>

<h3>Description</h3>

<p>Converts an edge list to an <code>sf</code> spatial object of type <code>LINESTRING</code> with
one row per edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges_to_sf(edges, sites)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_to_sf_+3A_edges">edges</code></td>
<td>
<p>a <code>data.frame</code> with the following two columns: <code>from</code> (the
first node of the edge) and <code>to</code> (the second node of the edge). The output
of the functions <code><a href="#topic+create_edge_list">create_edge_list()</a></code> or <code><a href="#topic+append_edge_lists">append_edge_lists()</a></code>.</p>
</td></tr>
<tr><td><code id="edges_to_sf_+3A_sites">sites</code></td>
<td>
<p>an <code>sf</code> object of type <code>POINT</code>. A spatial object with
coordinates of sites (nodes). Note that the <strong>first column</strong> must be the
node labels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>sf</code> spatial object of type <code>LINESTRING</code> where the number of rows
correspond to the number of edges.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import Adour sites ----
path_to_file &lt;- system.file("extdata", "adour_survey_sampling.csv", 
                            package = "chessboard")
adour_sites  &lt;- read.csv(path_to_file)

# Select first location ----
adour_sites &lt;- adour_sites[adour_sites$"location" == 1, ]

# Create node labels ----
adour_nodes &lt;- create_node_labels(data     = adour_sites, 
                                  location = "location", 
                                  transect = "transect", 
                                  quadrat = "quadrat")

# Find edges with 1 degree of neighborhood (pawn method) ----
adour_edges &lt;- create_edge_list(adour_nodes, method = "pawn", 
                                directed = TRUE)

# Convert sites to spatial POINT ----
adour_sites_sf &lt;- sf::st_as_sf(adour_nodes, coords = 5:6, crs = "epsg:2154")

# Convert edges to spatial LINESTRING ----
edges_sf &lt;- edges_to_sf(adour_edges, adour_sites_sf)
head(edges_sf)

# Visualization ----
plot(sf::st_geometry(adour_sites_sf), pch = 19)
plot(sf::st_geometry(edges_sf), add = TRUE)


# Find edges with 1 degree of neighborhood (pawn and bishop methods) ----
adour_edges_1 &lt;- create_edge_list(adour_nodes, method = "pawn", 
                                  directed = TRUE)
adour_edges_2 &lt;- create_edge_list(adour_nodes, method = "bishop", 
                                  directed = TRUE)

# Append edges ----
adour_edges &lt;- append_edge_lists(adour_edges_1, adour_edges_2)

# Convert sites to spatial POINT ----
adour_sites_sf &lt;- sf::st_as_sf(adour_nodes, coords = 5:6, crs = "epsg:2154")

# Convert edges to spatial LINESTRING ----
edges_sf &lt;- edges_to_sf(adour_edges, adour_sites_sf)
head(edges_sf)

# Visualization ----
plot(sf::st_geometry(adour_sites_sf), pch = 19)
plot(sf::st_geometry(edges_sf), add = TRUE)
</code></pre>

<hr>
<h2 id='edges_weights_matrix'>Create an edges weights matrix</h2><span id='topic+edges_weights_matrix'></span>

<h3>Description</h3>

<p>Creates an edges weights matrix from the output of <code><a href="#topic+distance_euclidean">distance_euclidean()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges_weights_matrix(distances, lower = TRUE, upper = TRUE, diag = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_weights_matrix_+3A_distances">distances</code></td>
<td>
<p>a <code>data.frame</code> with the following three columns: <code>from</code>
(the first node of the edge), <code>to</code> (the second node of the edge), and
<code>weight</code> (the weight of the edge between the two nodes, e.g. a distance).</p>
</td></tr>
<tr><td><code id="edges_weights_matrix_+3A_lower">lower</code></td>
<td>
<p>a <code>logical</code> value. If <code>TRUE</code> (default), keep values in the lower
triangle of the matrix. Otherwise they will be replaced by <code>NA</code>.</p>
</td></tr>
<tr><td><code id="edges_weights_matrix_+3A_upper">upper</code></td>
<td>
<p>a <code>logical</code> value. If <code>TRUE</code> (default), keep values in the upper
triangle of the matrix. Otherwise they will be replaced by <code>NA</code>.</p>
</td></tr>
<tr><td><code id="edges_weights_matrix_+3A_diag">diag</code></td>
<td>
<p>a <code>logical</code> value. If <code>TRUE</code> (default), keep values in the
diagonal of the matrix. Otherwise they will be replaced by <code>NA</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edges weights <code>matrix</code> of dimensions <code style="white-space: pre;">&#8288;n x n&#8288;</code>, where <code>n</code> is the
number of nodes (sites).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import Adour sites ----
path_to_file &lt;- system.file("extdata", "adour_survey_sampling.csv", 
                            package = "chessboard")
adour_sites &lt;- read.csv(path_to_file)

# Select the 15 first sites ----
adour_sites &lt;- adour_sites[1:15, ]

# Create node labels ----
adour_sites &lt;- create_node_labels(adour_sites, 
                                  location = "location", 
                                  transect = "transect", 
                                  quadrat  = "quadrat")

# Convert sites to sf object (POINTS) ----
adour_sites_sf &lt;- sf::st_as_sf(adour_sites, 
                               coords = c("longitude", "latitude"),
                               crs = "epsg:2154")

# Compute distances between pairs of sites along the Adour river ----
adour_dists &lt;- distance_euclidean(adour_sites_sf)

# Create Edges weights matrix ----
edges_weights_matrix(adour_dists)

# Create Edges weights matrix (with options) ----
edges_weights_matrix(adour_dists, lower = FALSE)
edges_weights_matrix(adour_dists, upper = FALSE)
edges_weights_matrix(adour_dists, diag = FALSE)
</code></pre>

<hr>
<h2 id='edges_weights_vector'>Create an edges weights vector</h2><span id='topic+edges_weights_vector'></span>

<h3>Description</h3>

<p>Creates an edges weights vector that can be used in <code>aem()</code> of the package
<code>adespatial</code>. Resulting edges weights equal to 0 will be replaced by
<code style="white-space: pre;">&#8288;4 x max(w)&#8288;</code>, where <code>max(w)</code> is the maximal weight in the matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>edges_weights_vector(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="edges_weights_vector_+3A_x">x</code></td>
<td>
<p>a <code>list</code> of length 2. The nodes_by_edges matrix returned by
<code>nodes_by_edges_matrix()</code> (or <code>aem.build.binary()</code> of the package
<code>adespatial</code>).</p>
</td></tr>
<tr><td><code id="edges_weights_vector_+3A_y">y</code></td>
<td>
<p>a <code>data.frame</code> with the following three columns: <code>from</code>
(the first node of the edge), <code>to</code> (the second node of the edge), and
<code>weight</code> (the weight of the edge between the two nodes, e.g. a distance).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edges weights <code>vector</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import Adour sites ----
path_to_file &lt;- system.file("extdata", "adour_survey_sampling.csv", 
                            package = "chessboard")
adour_sites &lt;- read.csv(path_to_file)

# Select the 15 first sites ----
adour_sites &lt;- adour_sites[1:15, ]

# Create node labels ----
adour_sites &lt;- create_node_labels(adour_sites, 
                                  location = "location", 
                                  transect = "transect", 
                                  quadrat  = "quadrat")

# Convert sites to sf object (POINTS) ----
adour_sites_sf &lt;- sf::st_as_sf(adour_sites, 
                               coords = c("longitude", "latitude"),
                               crs = "epsg:2154")

# Create edges based on the pawn move (directed network) ----
adour_edges &lt;- create_edge_list(adour_sites, method = "pawn", 
                                directed = TRUE)

# Create nodes-by-edges matrix ----
adour_matrix &lt;- nodes_by_edges_matrix(adour_edges)

# Compute Euclidean distances between pairs of sites ----
adour_dists &lt;- distance_euclidean(adour_sites_sf)

# Create Edges weights vector ----
edges_weights_vector(adour_matrix, adour_dists)
</code></pre>

<hr>
<h2 id='fool'>Find neighbors according to fool movement</h2><span id='topic+fool'></span>

<h3>Description</h3>

<p>For one node (argument <code>focus</code>), finds neighbors among a list of nodes
according to the fool movement.
This movement is derived from the chess game. The fool can only move
horizontally, i.e. through a <strong>quadrat</strong>.
</p>
<p>The detection of neighbors using the fool method can work with
two-dimensional sampling (both <strong>transects</strong> and <strong>quadrats</strong>) and
one-dimensional sampling of type <strong>transects-only</strong>.
For sampling of type <strong>quadrats-only</strong>, please use the function <code><a href="#topic+pawn">pawn()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fool(nodes, focus, degree = 1, directed = FALSE, reverse = FALSE, self = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fool_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> with (at least) the following three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. Must be the output of the function
<code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
<tr><td><code id="fool_+3A_focus">focus</code></td>
<td>
<p>an <code>character</code> of length 1. The node label for which the
neighbors must be found. Must exist in the <code>nodes</code> object.</p>
</td></tr>
<tr><td><code id="fool_+3A_degree">degree</code></td>
<td>
<p>an <code>integer</code> of length 1. The maximum number of neighbors to
search for.</p>
</td></tr>
<tr><td><code id="fool_+3A_directed">directed</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>FALSE</code> (default), search for
neighbors in all directions (undirected network). Otherwise, the network
will be considered as directed according to the orientations of the
network. The default orientation follows the order of node labels in
both axes.</p>
</td></tr>
<tr><td><code id="fool_+3A_reverse">reverse</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, change the default
orientation of the network. This argument is ignored if <code>directed = FALSE</code>.
See examples for further detail.</p>
</td></tr>
<tr><td><code id="fool_+3A_self">self</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, a node can be its own
neighbor. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is internally called by <code><a href="#topic+create_edge_list">create_edge_list()</a></code> but it can be
directly used to 1) understand the neighbors detection method, and 2) to
check detected neighbors for one particular node (<code>focus</code>).
</p>


<h3>Value</h3>

<p>A subset of the <code>nodes</code> (<code>data.frame</code>) where each row is a neighbor
of the focal node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling (only) ----
sites_infos &lt;- expand.grid("transect" = 1:9, "quadrat" = 1:9)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

focus     &lt;- "5-5"

# Default settings ----
neighbors &lt;- fool(nodes, focus)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)

# Higher degree of neighborhood ----
neighbors &lt;- fool(nodes, focus, degree = 3)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (default orientation) ----
neighbors &lt;- fool(nodes, focus, degree = 3, directed = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (reverse orientation) ----
neighbors &lt;- fool(nodes, focus, degree = 3, directed = TRUE, reverse = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
</code></pre>

<hr>
<h2 id='geom_edges'>Link neighbors by arrow on a chessboard</h2><span id='topic+geom_edges'></span>

<h3>Description</h3>

<p>Links neighbors (cells) on a chessboard plotted with <code><a href="#topic+gg_chessboard">gg_chessboard()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_edges(nodes, focus, neighbors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_edges_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> with (at least) the following three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. Must be the output if the function
<code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_edges_+3A_focus">focus</code></td>
<td>
<p>an <code>character</code> of length 1. The node label to be emphasized on
the chessboard. Must exist in the <code>nodes</code> object.</p>
</td></tr>
<tr><td><code id="geom_edges_+3A_neighbors">neighbors</code></td>
<td>
<p>a <code>data.frame</code> with the following at least three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. See <code><a href="#topic+pawn">pawn()</a></code>, <code><a href="#topic+fool">fool()</a></code>, etc. for
further information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>geom_segment</code> that must be added to a <code>ggplot2</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

sites_infos &lt;- expand.grid("transect" = 1:9, "quadrat" = 1:9)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

focus &lt;- "5-5"

neighbors &lt;- wizard(nodes, focus = focus, degree = 4, directed = FALSE, 
                    reverse = TRUE)

gg_chessboard(nodes) +
  geom_neighbors(nodes, neighbors) +
  geom_edges(nodes, focus, neighbors) +
  geom_node(nodes, focus)
</code></pre>

<hr>
<h2 id='geom_neighbors'>Highlight neighbors on a chessboard</h2><span id='topic+geom_neighbors'></span>

<h3>Description</h3>

<p>Highlights neighbors (cells) on a chessboard plotted with <code><a href="#topic+gg_chessboard">gg_chessboard()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_neighbors(nodes, neighbors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_neighbors_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> with (at least) the following three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. Must be the output if the function
<code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_neighbors_+3A_neighbors">neighbors</code></td>
<td>
<p>a <code>data.frame</code> with the following at least three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. See <code><a href="#topic+pawn">pawn()</a></code>, <code><a href="#topic+fool">fool()</a></code>, etc. for
further information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>geom_point</code> that must be added to a <code>ggplot2</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling ----
sites_infos &lt;- expand.grid("transect" = 1:3, "quadrat" = 1:5)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

neighbors &lt;- pawn(nodes, focus = "2-3")

gg_chessboard(nodes) +
  geom_node(nodes, "2-3") +
  geom_neighbors(nodes, neighbors)
</code></pre>

<hr>
<h2 id='geom_node'>Highlight a node on a chessboard</h2><span id='topic+geom_node'></span>

<h3>Description</h3>

<p>Highlights a node (cell) on a chessboard plotted with <code><a href="#topic+gg_chessboard">gg_chessboard()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_node(nodes, focus)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_node_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> with (at least) the following three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. Must be the output if the function
<code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
<tr><td><code id="geom_node_+3A_focus">focus</code></td>
<td>
<p>an <code>character</code> of length 1. The node label to be emphasized on
the chessboard. Must exist in the <code>nodes</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two <code>geom_point</code> that must be added to a <code>ggplot2</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling ----
sites_infos &lt;- expand.grid("transect" = 1:3, "quadrat" = 1:5)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

gg_chessboard(nodes) +
  geom_node(nodes, "2-3")

# One-dimensional sampling (only transects) ----
sites_infos &lt;- data.frame("transect" = 1:5)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect")

gg_chessboard(nodes) +
  geom_node(nodes, "3-1")
</code></pre>

<hr>
<h2 id='get_node_list'>Get the list of nodes</h2><span id='topic+get_node_list'></span>

<h3>Description</h3>

<p>Retrieves the node list by selecting and ordering the column <code>node</code> of the
output of the function <code><a href="#topic+create_node_labels">create_node_labels()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_node_list(nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_node_list_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> with (at least) the following three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. Must be the output of the function
<code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of node labels.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling (only) ----
sites_infos &lt;- expand.grid("transect" = 1:3, "quadrat" = 1:5)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")
get_node_list(nodes)
</code></pre>

<hr>
<h2 id='gg_chessboard'>Plot a sampling as a chessboard</h2><span id='topic+gg_chessboard'></span>

<h3>Description</h3>

<p>Plots a sampling as a chessboard of dimensions <code>t</code> x <code>q</code>, with
<code>t</code>, the number of transects, and
<code>q</code>, the number of quadrats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_chessboard(nodes, xlab = "Transect", ylab = "Quadrat")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_chessboard_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> with (at least) the following three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. Must be the output if the function
<code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
<tr><td><code id="gg_chessboard_+3A_xlab">xlab</code></td>
<td>
<p>a <code>character</code> of length 1. The title of the top axis.
Default is <code>'Transect'</code>.</p>
</td></tr>
<tr><td><code id="gg_chessboard_+3A_ylab">ylab</code></td>
<td>
<p>a <code>character</code> of length 1. The title of the left axis.
Default is <code>'Quadrat'</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling ----
sites_infos &lt;- expand.grid("transect" = 1:3, "quadrat" = 1:5)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

gg_chessboard(nodes)

# One-dimensional sampling (only transects) ----
sites_infos &lt;- data.frame("transect" = 1:5)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect")

gg_chessboard(nodes)

# One-dimensional sampling (only quadrats) ----
sites_infos &lt;- data.frame("quadrat" = 1:5)

nodes &lt;- create_node_labels(data    = sites_infos, 
                            quadrat = "quadrat")

gg_chessboard(nodes)
</code></pre>

<hr>
<h2 id='gg_matrix'>Plot a connectivity or a nodes-by-edges matrix</h2><span id='topic+gg_matrix'></span>

<h3>Description</h3>

<p>Plots an connectivity or a nodes-by-edges matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gg_matrix(x, title)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gg_matrix_+3A_x">x</code></td>
<td>
<p>a <code>matrix</code> object. An adjacency or nodes-by-edges matrix.</p>
</td></tr>
<tr><td><code id="gg_matrix_+3A_title">title</code></td>
<td>
<p>a <code>character</code> of length 1. The caption of the figure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot2</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Import Adour sites ----
path_to_file &lt;- system.file("extdata", "adour_survey_sampling.csv", 
                            package = "chessboard")
adour_sites  &lt;- read.csv(path_to_file)

# Select first location ----
#adour_sites &lt;- adour_sites[adour_sites$"location" == 1, ]

# Create node labels ----
adour_nodes &lt;- create_node_labels(data     = adour_sites, 
                                  location = "location", 
                                  transect = "transect", 
                                  quadrat = "quadrat")

# Find edges with 1 degree of neighborhood (queen method) ----
adour_edges &lt;- create_edge_list(adour_nodes, method = "queen", 
                                directed = FALSE)

# Get connectivity matrix ----
adour_con_matrix &lt;- connectivity_matrix(adour_edges)

# Visualize matrix ----
gg_matrix(adour_con_matrix, title = "Connectivity matrix") +
  ggplot2::theme(axis.text = ggplot2::element_text(size = 6))
</code></pre>

<hr>
<h2 id='knight'>Find neighbors according to knight movement</h2><span id='topic+knight'></span>

<h3>Description</h3>

<p>For one node (argument <code>focus</code>), finds neighbors among a list of nodes
according to the knight movement.
This movement is derived from the chess game. The knight is the difference
between the <code><a href="#topic+wizard">wizard()</a></code> and the <code><a href="#topic+queen">queen()</a></code>.
</p>
<p>The detection of neighbors using this method can only work with
two-dimensional sampling (both <strong>transects</strong> and <strong>quadrats</strong>).
For sampling of type <strong>transects-only</strong> or <strong>quadrats-only</strong>,
please use the functions <code><a href="#topic+fool">fool()</a></code> or <code><a href="#topic+pawn">pawn()</a></code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knight(
  nodes,
  focus,
  degree = 1,
  directed = FALSE,
  reverse = FALSE,
  self = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knight_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> with (at least) the following three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. Must be the output of the function
<code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
<tr><td><code id="knight_+3A_focus">focus</code></td>
<td>
<p>an <code>character</code> of length 1. The node label for which the
neighbors must be found. Must exist in the <code>nodes</code> object.</p>
</td></tr>
<tr><td><code id="knight_+3A_degree">degree</code></td>
<td>
<p>an <code>integer</code> of length 1. The maximum number of neighbors to
search for.</p>
</td></tr>
<tr><td><code id="knight_+3A_directed">directed</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>FALSE</code> (default), search for
neighbors in all directions (undirected network). Otherwise, the network
will be considered as directed according to the orientations of the
network. The default orientation follows the order of node labels in
both axes.</p>
</td></tr>
<tr><td><code id="knight_+3A_reverse">reverse</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, change the default
orientation of the network. This argument is ignored if <code>directed = FALSE</code>.
See examples for further detail.</p>
</td></tr>
<tr><td><code id="knight_+3A_self">self</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, a node can be its own
neighbor. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is internally called by <code><a href="#topic+create_edge_list">create_edge_list()</a></code> but it can be
directly used to 1) understand the neighbors detection method, and 2) to
check detected neighbors for one particular node (<code>focus</code>).
</p>


<h3>Value</h3>

<p>A subset of the <code>nodes</code> (<code>data.frame</code>) where each row is a neighbor
of the focal node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling (only) ----
sites_infos &lt;- expand.grid("transect" = 1:9, "quadrat" = 1:9)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

focus     &lt;- "5-5"

# Default settings ----
neighbors &lt;- knight(nodes, focus, degree = 2)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)

# Higher degree of neighborhood ----
neighbors &lt;- knight(nodes, focus, degree = 3)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (default orientation) ----
neighbors &lt;- knight(nodes, focus, degree = 3, directed = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (reverse orientation) ----
neighbors &lt;- knight(nodes, focus, degree = 3, directed = TRUE, 
                    reverse = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
</code></pre>

<hr>
<h2 id='knight_left'>Find neighbors according to knight left movement</h2><span id='topic+knight_left'></span>

<h3>Description</h3>

<p>For one node (argument <code>focus</code>), finds neighbors among a list of nodes
according to the knight left movement.
This movement is derived from the <code><a href="#topic+knight">knight()</a></code> method.
</p>
<p>The detection of neighbors using this method can only work with
two-dimensional sampling (both <strong>transects</strong> and <strong>quadrats</strong>).
For sampling of type <strong>transects-only</strong> or <strong>quadrats-only</strong>,
please use the functions <code><a href="#topic+fool">fool()</a></code> or <code><a href="#topic+pawn">pawn()</a></code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knight_left(
  nodes,
  focus,
  degree = 1,
  directed = FALSE,
  reverse = FALSE,
  self = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knight_left_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> with (at least) the following three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. Must be the output of the function
<code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
<tr><td><code id="knight_left_+3A_focus">focus</code></td>
<td>
<p>an <code>character</code> of length 1. The node label for which the
neighbors must be found. Must exist in the <code>nodes</code> object.</p>
</td></tr>
<tr><td><code id="knight_left_+3A_degree">degree</code></td>
<td>
<p>an <code>integer</code> of length 1. The maximum number of neighbors to
search for.</p>
</td></tr>
<tr><td><code id="knight_left_+3A_directed">directed</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>FALSE</code> (default), search for
neighbors in all directions (undirected network). Otherwise, the network
will be considered as directed according to the orientations of the
network. The default orientation follows the order of node labels in
both axes.</p>
</td></tr>
<tr><td><code id="knight_left_+3A_reverse">reverse</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, change the default
orientation of the network. This argument is ignored if <code>directed = FALSE</code>.
See examples for further detail.</p>
</td></tr>
<tr><td><code id="knight_left_+3A_self">self</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, a node can be its own
neighbor. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is internally called by <code><a href="#topic+create_edge_list">create_edge_list()</a></code> but it can be
directly used to 1) understand the neighbors detection method, and 2) to
check detected neighbors for one particular node (<code>focus</code>).
</p>


<h3>Value</h3>

<p>A subset of the <code>nodes</code> (<code>data.frame</code>) where each row is a neighbor
of the focal node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling (only) ----
sites_infos &lt;- expand.grid("transect" = 1:9, "quadrat" = 1:9)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

focus     &lt;- "5-5"

# Default settings ----
neighbors &lt;- knight_left(nodes, focus, degree = 2)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)

# Higher degree of neighborhood ----
neighbors &lt;- knight_left(nodes, focus, degree = 3)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (default orientation) ----
neighbors &lt;- knight_left(nodes, focus, degree = 3, directed = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (reverse orientation) ----
neighbors &lt;- knight_left(nodes, focus, degree = 3, directed = TRUE, 
                         reverse = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
</code></pre>

<hr>
<h2 id='knight_right'>Find neighbors according to knight right movement</h2><span id='topic+knight_right'></span>

<h3>Description</h3>

<p>For one node (argument <code>focus</code>), finds neighbors among a list of nodes
according to the knight right movement.
This movement is derived from the <code><a href="#topic+knight">knight()</a></code> method.
</p>
<p>The detection of neighbors using this method can only work with
two-dimensional sampling (both <strong>transects</strong> and <strong>quadrats</strong>).
For sampling of type <strong>transects-only</strong> or <strong>quadrats-only</strong>,
please use the functions <code><a href="#topic+fool">fool()</a></code> or <code><a href="#topic+pawn">pawn()</a></code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knight_right(
  nodes,
  focus,
  degree = 1,
  directed = FALSE,
  reverse = FALSE,
  self = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knight_right_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> with (at least) the following three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. Must be the output of the function
<code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
<tr><td><code id="knight_right_+3A_focus">focus</code></td>
<td>
<p>an <code>character</code> of length 1. The node label for which the
neighbors must be found. Must exist in the <code>nodes</code> object.</p>
</td></tr>
<tr><td><code id="knight_right_+3A_degree">degree</code></td>
<td>
<p>an <code>integer</code> of length 1. The maximum number of neighbors to
search for.</p>
</td></tr>
<tr><td><code id="knight_right_+3A_directed">directed</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>FALSE</code> (default), search for
neighbors in all directions (undirected network). Otherwise, the network
will be considered as directed according to the orientations of the
network. The default orientation follows the order of node labels in
both axes.</p>
</td></tr>
<tr><td><code id="knight_right_+3A_reverse">reverse</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, change the default
orientation of the network. This argument is ignored if <code>directed = FALSE</code>.
See examples for further detail.</p>
</td></tr>
<tr><td><code id="knight_right_+3A_self">self</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, a node can be its own
neighbor. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is internally called by <code><a href="#topic+create_edge_list">create_edge_list()</a></code> but it can be
directly used to 1) understand the neighbors detection method, and 2) to
check detected neighbors for one particular node (<code>focus</code>).
</p>


<h3>Value</h3>

<p>A subset of the <code>nodes</code> (<code>data.frame</code>) where each row is a neighbor
of the focal node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling (only) ----
sites_infos &lt;- expand.grid("transect" = 1:9, "quadrat" = 1:9)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

focus     &lt;- "5-5"

# Default settings ----
neighbors &lt;- knight_right(nodes, focus, degree = 2)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)

# Higher degree of neighborhood ----
neighbors &lt;- knight_right(nodes, focus, degree = 3)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (default orientation) ----
neighbors &lt;- knight_right(nodes, focus, degree = 3, directed = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (reverse orientation) ----
neighbors &lt;- knight_right(nodes, focus, degree = 3, directed = TRUE, 
                          reverse = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
</code></pre>

<hr>
<h2 id='matrix_to_edge_list'>Convert an connectivity matrix to an edge list</h2><span id='topic+matrix_to_edge_list'></span>

<h3>Description</h3>

<p>Converts a connectivity matrix to an edge list. This function allows to
create the same edge list as the one obtained with <code><a href="#topic+create_edge_list">create_edge_list()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_to_edge_list(x, all = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_to_edge_list_+3A_x">x</code></td>
<td>
<p>a <code>matrix</code> object. The connectivity matrix to be converted in an
edge list.</p>
</td></tr>
<tr><td><code id="matrix_to_edge_list_+3A_all">all</code></td>
<td>
<p>a <code>logical</code> value. If <code>FALSE</code> (default), removes missing edges.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with two (or three) columns:
</p>

<ul>
<li> <p><code>from</code>: label of one of the two nodes of the edge
</p>
</li>
<li> <p><code>to</code>: label of the other node of the edge
</p>
</li>
<li> <p><code>edge</code>: 0 (no edge) or 1 (edge). This column is returned only if
<code>all = TRUE</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling ----
sites_infos &lt;- expand.grid("transect" = 1:3, "quadrat" = 1:5)
sites_infos

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

edges &lt;- create_edge_list(nodes, method = "pawn", directed = TRUE)

conn_matrix &lt;- connectivity_matrix(edges)

# Convert back to edge list ----
new_edges &lt;- matrix_to_edge_list(conn_matrix)
new_edges

# Check ----
identical(edges, new_edges)
</code></pre>

<hr>
<h2 id='nodes_by_edges_matrix'>Create a nodes-by-edges matrix</h2><span id='topic+nodes_by_edges_matrix'></span>

<h3>Description</h3>

<p>Creates a nodes-by-edges matrix that will be used by <code>aem()</code> of the package
<code>adespatial</code>. This function creates the same output as <code>aem.build.binary()</code>
of the package <code>adespatial</code> but works in a different way: it's only based on
node labels (not on coordinates). Also, this function adds labels to nodes
and edges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nodes_by_edges_matrix(edges)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nodes_by_edges_matrix_+3A_edges">edges</code></td>
<td>
<p>a <code>data.frame</code> with the following two columns: <code>from</code> (the
first node of the edge) and <code>to</code> (the second node of the edge).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements:
</p>

<ul>
<li> <p><code>se.mat</code>: the nodes-by-edges matrix of dimensions <code style="white-space: pre;">&#8288;n x k&#8288;</code>, where <code>n</code> is
the number of nodes and <code>k</code> the number of edges (including the edge
between the fictitious origin and the first site);
</p>
</li>
<li> <p><code>edges</code>: a <code>data.frame</code> of edge list.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling ----
sites_infos &lt;- expand.grid("transect" = 1:3, "quadrat" = 1:5)
sites_infos

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

edges &lt;- create_edge_list(nodes, method = "pawn", directed = TRUE)

# Create nodes-by-edges matrix ----
nodes_by_edges_matrix(edges)
</code></pre>

<hr>
<h2 id='pawn'>Find neighbors according to pawn movement</h2><span id='topic+pawn'></span>

<h3>Description</h3>

<p>For one node (argument <code>focus</code>), finds neighbors among a list of nodes
according to the fool movement.
This movement is orthogonal to the <code><a href="#topic+fool">fool()</a></code> function. The pawn can only move
vertically, i.e. through a <strong>transect</strong>.
</p>
<p>The detection of neighbors using the fool method can work with
two-dimensional sampling (both <strong>transects</strong> and <strong>quadrats</strong>) and
one-dimensional sampling of type <strong>quadrats-only</strong>.
For sampling of type <strong>transects-only</strong>, please use the function <code><a href="#topic+fool">fool()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pawn(nodes, focus, degree = 1, directed = FALSE, reverse = FALSE, self = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pawn_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> with (at least) the following three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. Must be the output of the function
<code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
<tr><td><code id="pawn_+3A_focus">focus</code></td>
<td>
<p>an <code>character</code> of length 1. The node label for which the
neighbors must be found. Must exist in the <code>nodes</code> object.</p>
</td></tr>
<tr><td><code id="pawn_+3A_degree">degree</code></td>
<td>
<p>an <code>integer</code> of length 1. The maximum number of neighbors to
search for.</p>
</td></tr>
<tr><td><code id="pawn_+3A_directed">directed</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>FALSE</code> (default), search for
neighbors in all directions (undirected network). Otherwise, the network
will be considered as directed according to the orientations of the
network. The default orientation follows the order of node labels in
both axes.</p>
</td></tr>
<tr><td><code id="pawn_+3A_reverse">reverse</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, change the default
orientation of the network. This argument is ignored if <code>directed = FALSE</code>.
See examples for further detail.</p>
</td></tr>
<tr><td><code id="pawn_+3A_self">self</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, a node can be its own
neighbor. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is internally called by <code><a href="#topic+create_edge_list">create_edge_list()</a></code> but it can be
directly used to 1) understand the neighbors detection method, and 2) to
check detected neighbors for one particular node (<code>focus</code>).
</p>


<h3>Value</h3>

<p>A subset of the <code>nodes</code> (<code>data.frame</code>) where each row is a neighbor
of the focal node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling (only) ----
sites_infos &lt;- expand.grid("transect" = 1:9, "quadrat" = 1:9)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

focus     &lt;- "5-5"

# Default settings ----
neighbors &lt;- pawn(nodes, focus)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)

# Higher degree of neighborhood ----
neighbors &lt;- pawn(nodes, focus, degree = 3)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (default orientation) ----
neighbors &lt;- pawn(nodes, focus, degree = 3, directed = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (reverse orientation) ----
neighbors &lt;- pawn(nodes, focus, degree = 3, directed = TRUE, reverse = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
</code></pre>

<hr>
<h2 id='queen'>Find neighbors according to queen movement</h2><span id='topic+queen'></span>

<h3>Description</h3>

<p>For one node (argument <code>focus</code>), finds neighbors among a list of nodes
according to the queen movement.
This movement is derived from the chess game. The queen is a combination of
the <code><a href="#topic+bishop">bishop()</a></code> and the <code><a href="#topic+rook">rook()</a></code> and can find neighbors horizontally,
vertically, and diagonally.
</p>
<p>The detection of neighbors using this method can only work with
two-dimensional sampling (both <strong>transects</strong> and <strong>quadrats</strong>).
For sampling of type <strong>transects-only</strong> or <strong>quadrats-only</strong>,
please use the functions <code><a href="#topic+fool">fool()</a></code> or <code><a href="#topic+pawn">pawn()</a></code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>queen(
  nodes,
  focus,
  degree = 1,
  directed = FALSE,
  reverse = FALSE,
  self = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="queen_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> with (at least) the following three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. Must be the output of the function
<code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
<tr><td><code id="queen_+3A_focus">focus</code></td>
<td>
<p>an <code>character</code> of length 1. The node label for which the
neighbors must be found. Must exist in the <code>nodes</code> object.</p>
</td></tr>
<tr><td><code id="queen_+3A_degree">degree</code></td>
<td>
<p>an <code>integer</code> of length 1. The maximum number of neighbors to
search for.</p>
</td></tr>
<tr><td><code id="queen_+3A_directed">directed</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>FALSE</code> (default), search for
neighbors in all directions (undirected network). Otherwise, the network
will be considered as directed according to the orientations of the
network. The default orientation follows the order of node labels in
both axes.</p>
</td></tr>
<tr><td><code id="queen_+3A_reverse">reverse</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, change the default
orientation of the network. This argument is ignored if <code>directed = FALSE</code>.
See examples for further detail.</p>
</td></tr>
<tr><td><code id="queen_+3A_self">self</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, a node can be its own
neighbor. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is internally called by <code><a href="#topic+create_edge_list">create_edge_list()</a></code> but it can be
directly used to 1) understand the neighbors detection method, and 2) to
check detected neighbors for one particular node (<code>focus</code>).
</p>


<h3>Value</h3>

<p>A subset of the <code>nodes</code> (<code>data.frame</code>) where each row is a neighbor
of the focal node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling (only) ----
sites_infos &lt;- expand.grid("transect" = 1:9, "quadrat" = 1:9)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

focus     &lt;- "5-5"

# Default settings ----
neighbors &lt;- queen(nodes, focus)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)

# Higher degree of neighborhood ----
neighbors &lt;- queen(nodes, focus, degree = 3)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (default orientation) ----
neighbors &lt;- queen(nodes, focus, degree = 3, directed = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (reverse orientation) ----
neighbors &lt;- queen(nodes, focus, degree = 3, directed = TRUE, reverse = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
</code></pre>

<hr>
<h2 id='rook'>Find neighbors according to rook movement</h2><span id='topic+rook'></span>

<h3>Description</h3>

<p>For one node (argument <code>focus</code>), finds neighbors among a list of nodes
according to the rook movement.
This movement is derived from the chess game. The rook can move horizontally
and vertically. It's a combination of the <code><a href="#topic+pawn">pawn()</a></code> and the <code><a href="#topic+fool">fool()</a></code>
functions.
</p>
<p>The detection of neighbors using this method can only work with
two-dimensional sampling (both <strong>transects</strong> and <strong>quadrats</strong>).
For sampling of type <strong>transects-only</strong> or <strong>quadrats-only</strong>,
please use the functions <code><a href="#topic+fool">fool()</a></code> or <code><a href="#topic+pawn">pawn()</a></code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rook(nodes, focus, degree = 1, directed = FALSE, reverse = FALSE, self = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rook_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> with (at least) the following three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. Must be the output of the function
<code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
<tr><td><code id="rook_+3A_focus">focus</code></td>
<td>
<p>an <code>character</code> of length 1. The node label for which the
neighbors must be found. Must exist in the <code>nodes</code> object.</p>
</td></tr>
<tr><td><code id="rook_+3A_degree">degree</code></td>
<td>
<p>an <code>integer</code> of length 1. The maximum number of neighbors to
search for.</p>
</td></tr>
<tr><td><code id="rook_+3A_directed">directed</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>FALSE</code> (default), search for
neighbors in all directions (undirected network). Otherwise, the network
will be considered as directed according to the orientations of the
network. The default orientation follows the order of node labels in
both axes.</p>
</td></tr>
<tr><td><code id="rook_+3A_reverse">reverse</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, change the default
orientation of the network. This argument is ignored if <code>directed = FALSE</code>.
See examples for further detail.</p>
</td></tr>
<tr><td><code id="rook_+3A_self">self</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, a node can be its own
neighbor. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is internally called by <code><a href="#topic+create_edge_list">create_edge_list()</a></code> but it can be
directly used to 1) understand the neighbors detection method, and 2) to
check detected neighbors for one particular node (<code>focus</code>).
</p>


<h3>Value</h3>

<p>A subset of the <code>nodes</code> (<code>data.frame</code>) where each row is a neighbor
of the focal node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling (only) ----
sites_infos &lt;- expand.grid("transect" = 1:9, "quadrat" = 1:9)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

focus     &lt;- "5-5"

# Default settings ----
neighbors &lt;- rook(nodes, focus)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)

# Higher degree of neighborhood ----
neighbors &lt;- rook(nodes, focus, degree = 3)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (default orientation) ----
neighbors &lt;- rook(nodes, focus, degree = 3, directed = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (reverse orientation) ----
neighbors &lt;- rook(nodes, focus, degree = 3, directed = TRUE, reverse = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
</code></pre>

<hr>
<h2 id='spatial_weights_matrix'>Create a spatial weights matrix</h2><span id='topic+spatial_weights_matrix'></span>

<h3>Description</h3>

<p>Creates a spatial weights matrix by multiplying an adjacency (connectivity)
matrix (see <code><a href="#topic+connectivity_matrix">connectivity_matrix()</a></code>) and an edges weights matrix (see
<code><a href="#topic+edges_weights_matrix">edges_weights_matrix()</a></code>). Resulting spatial weights equal to 0 will be
replaced by <code style="white-space: pre;">&#8288;4 x max(w)&#8288;</code>, where <code>max(w)</code> is the maximal weight in the
matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_weights_matrix(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_weights_matrix_+3A_x">x</code></td>
<td>
<p>an adjacency <code>matrix</code> of dimensions <code style="white-space: pre;">&#8288;n x n&#8288;</code>, where <code>n</code> is the
number of nodes (sites). The output of <code><a href="#topic+connectivity_matrix">connectivity_matrix()</a></code>.</p>
</td></tr>
<tr><td><code id="spatial_weights_matrix_+3A_y">y</code></td>
<td>
<p>an edges weight <code>matrix</code> of dimensions <code style="white-space: pre;">&#8288;n x n&#8288;</code>, where <code>n</code> is the
number of nodes (sites). The output of <code><a href="#topic+edges_weights_matrix">edges_weights_matrix()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spatial weights <code>matrix</code> of dimensions <code style="white-space: pre;">&#8288;n x n&#8288;</code>, where <code>n</code> is the
number of nodes (sites).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Import Adour sites ----
path_to_file &lt;- system.file("extdata", "adour_survey_sampling.csv", 
                            package = "chessboard")
adour_sites &lt;- read.csv(path_to_file)

# Select the 15 first sites ----
adour_sites &lt;- adour_sites[1:15, ]

# Create node labels ----
adour_sites &lt;- create_node_labels(adour_sites, 
                                  location = "location", 
                                  transect = "transect", 
                                  quadrat  = "quadrat")

# Create edges based on the pawn move (directed network) ----
adour_edges &lt;- create_edge_list(adour_sites, method = "pawn", 
                                directed = TRUE)

# Get connectivity matrix ----
adour_adjacency &lt;- connectivity_matrix(adour_edges)

# Convert sites to sf object (POINTS) ----
adour_sites_sf &lt;- sf::st_as_sf(adour_sites, 
                               coords = c("longitude", "latitude"),
                               crs = "epsg:2154")

# Compute distances between pairs of sites along the Adour river ----
adour_dists &lt;- distance_euclidean(adour_sites_sf)

# Create Edges weights matrix ----
adour_weights &lt;- edges_weights_matrix(adour_dists)

# Create Spatial weights matrix ----
spatial_weights_matrix(adour_adjacency, adour_weights)
</code></pre>

<hr>
<h2 id='wizard'>Find neighbors according to wizard movement</h2><span id='topic+wizard'></span>

<h3>Description</h3>

<p>For one node (argument <code>focus</code>), finds neighbors among a list of nodes
according to the wizard movement.
This movement is a combination of the <code><a href="#topic+queen">queen()</a></code> and the <code><a href="#topic+knight">knight()</a></code> pieces
from the chess game and can move in all directions.
</p>
<p>The detection of neighbors using this method can only work with
two-dimensional sampling (both <strong>transects</strong> and <strong>quadrats</strong>).
For sampling of type <strong>transects-only</strong> or <strong>quadrats-only</strong>,
please use the functions <code><a href="#topic+fool">fool()</a></code> or <code><a href="#topic+pawn">pawn()</a></code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wizard(
  nodes,
  focus,
  degree = 1,
  directed = FALSE,
  reverse = FALSE,
  self = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="wizard_+3A_nodes">nodes</code></td>
<td>
<p>a <code>data.frame</code> with (at least) the following three columns:
<code>node</code>, <code>transect</code>, and <code>quadrats</code>. Must be the output of the function
<code><a href="#topic+create_node_labels">create_node_labels()</a></code>.</p>
</td></tr>
<tr><td><code id="wizard_+3A_focus">focus</code></td>
<td>
<p>an <code>character</code> of length 1. The node label for which the
neighbors must be found. Must exist in the <code>nodes</code> object.</p>
</td></tr>
<tr><td><code id="wizard_+3A_degree">degree</code></td>
<td>
<p>an <code>integer</code> of length 1. The maximum number of neighbors to
search for.</p>
</td></tr>
<tr><td><code id="wizard_+3A_directed">directed</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>FALSE</code> (default), search for
neighbors in all directions (undirected network). Otherwise, the network
will be considered as directed according to the orientations of the
network. The default orientation follows the order of node labels in
both axes.</p>
</td></tr>
<tr><td><code id="wizard_+3A_reverse">reverse</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, change the default
orientation of the network. This argument is ignored if <code>directed = FALSE</code>.
See examples for further detail.</p>
</td></tr>
<tr><td><code id="wizard_+3A_self">self</code></td>
<td>
<p>a <code>logical</code> of length 1. If <code>TRUE</code>, a node can be its own
neighbor. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is internally called by <code><a href="#topic+create_edge_list">create_edge_list()</a></code> but it can be
directly used to 1) understand the neighbors detection method, and 2) to
check detected neighbors for one particular node (<code>focus</code>).
</p>


<h3>Value</h3>

<p>A subset of the <code>nodes</code> (<code>data.frame</code>) where each row is a neighbor
of the focal node.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("chessboard")

# Two-dimensional sampling (only) ----
sites_infos &lt;- expand.grid("transect" = 1:9, "quadrat" = 1:9)

nodes &lt;- create_node_labels(data     = sites_infos, 
                            transect = "transect", 
                            quadrat  = "quadrat")

focus     &lt;- "5-5"

# Default settings ----
neighbors &lt;- wizard(nodes, focus)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)

# Higher degree of neighborhood ----
neighbors &lt;- wizard(nodes, focus, degree = 3)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (default orientation) ----
neighbors &lt;- wizard(nodes, focus, degree = 3, directed = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
  
# Directed (reverse orientation) ----
neighbors &lt;- wizard(nodes, focus, degree = 3, directed = TRUE, 
                    reverse = TRUE)
gg_chessboard(nodes) +
  geom_node(nodes, focus) +
  geom_neighbors(nodes, neighbors)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
