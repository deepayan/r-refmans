<!DOCTYPE html><html lang="en"><head><title>Help for package xegaBNF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {xegaBNF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#booleanGrammar'><p>A constant function which returns the BNF (Backus-Naur Form)</p>
of a context-free grammar for the XOR problem.</a></li>
<li><a href='#compileBNF'><p>Compile a  BNF (Backus-Naur Form) of a context-free grammar.</p></a></li>
<li><a href='#compileShortPT'><p>Produces a production table with non-recursive productions only.</p></a></li>
<li><a href='#derive'><p>Derives the identifier list which expands the non-terminal identifier.</p></a></li>
<li><a href='#id2symb'><p>Convert a numeric identifier to a symbol.</p></a></li>
<li><a href='#isNonTerminal'><p>Is the numeric identifier a non-terminal symbol?</p></a></li>
<li><a href='#isTerminal'><p>Is the numeric identifier a terminal symbol?</p></a></li>
<li><a href='#makeProductionTable'><p>Produces a production table.</p></a></li>
<li><a href='#makeRule'><p>Transforms a single BNF rule into a production table.</p></a></li>
<li><a href='#makeStartSymbol'><p>Extracts the numerical identifier of the start symbol of the grammar.</p></a></li>
<li><a href='#makeSymbolTable'><p>Build a symbol table from a character string which contains a BNF.</p></a></li>
<li><a href='#newBNF'><p>Convert grammar file into a constant function.</p></a></li>
<li><a href='#readBNF'><p>Read text file.</p></a></li>
<li><a href='#rules'><p>Returns all indices of rules applicable for a non-terminal identifier.</p></a></li>
<li><a href='#symb2id'><p>Convert a symbol to a numeric identifier.</p></a></li>
<li><a href='#writeBNF'><p>Write BNF into text file.</p></a></li>
<li><a href='#xegaBNF'><p>Package xegaBNF</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Compile a Backus-Naur Form Specification into an R Grammar
Object</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Translates a BNF (Backus-Naur Form) specification of a 
             context-free language into an R grammar object
             which consists of the start symbol, the symbol table, 
             the production table, and a short production table.
             The short production table is non-recursive. 
             The grammar object contains the file name from 
             which it was generated (without a path).
             In addition, it provides functions to determine the type 
             of a symbol (isTerminal() and isNonterminal()) and functions
             to access the production table (rules() and derives()).
             For the BNF specification, see Backus, John et al. (1962)
             "Revised Report on the Algorithmic Language ALGOL 60".
             (ALGOL60 standards page <a href="http://www.algol60.org/2standards.htm">http://www.algol60.org/2standards.htm</a>,
              html-edition <a href="https://www.masswerk.at/algol60/report.htm">https://www.masswerk.at/algol60/report.htm</a>)
             The grammar compiler is based on the APL2 implementation in 
             Geyer-Schulz, Andreas (1997, ISBN:978-3-7908-0830-X).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td>&lt;<a href="https://github.com/ageyerschulz/xegaBNF&amp;gt;">https://github.com/ageyerschulz/xegaBNF&gt;</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-04 14:39:48 UTC; dj2333</td>
</tr>
<tr>
<td>Author:</td>
<td>Andreas Geyer-Schulz
    <a href="https://orcid.org/0009-0000-5237-3579"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andreas Geyer-Schulz &lt;Andreas.Geyer-Schulz@kit.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 20:50:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='booleanGrammar'>A constant function which returns the BNF (Backus-Naur Form) 
of a context-free grammar for the XOR problem.</h2><span id='topic+booleanGrammar'></span>

<h3>Description</h3>

<p>A constant function which returns the BNF (Backus-Naur Form) 
of a context-free grammar for the XOR problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>booleanGrammar()
</code></pre>


<h3>Value</h3>

<p>A named list with $filename and  $BNF, 
the grammar of a boolean grammar with two variables and
the boolean functions AND, OR, and NOT.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>booleanGrammar()
</code></pre>

<hr>
<h2 id='compileBNF'>Compile a  BNF (Backus-Naur Form) of a context-free grammar.</h2><span id='topic+compileBNF'></span>

<h3>Description</h3>

<p><code>compileBNF</code> produces a context-free grammar  
from its specification in Backus-Naur form (BNF).   
Warning: No error checking is implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compileBNF(g, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compileBNF_+3A_g">g</code></td>
<td>
<p>A character string with a BNF.</p>
</td></tr>
<tr><td><code id="compileBNF_+3A_verbose">verbose</code></td>
<td>
<p>Boolean. TRUE: Show progress. Default: FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A grammar consists of the symbol table <code>ST</code>, the production
table <code>PT</code>, the start symbol <code>Start</code>, 
and the short production
table <code>SPT</code>.
</p>
<p>The function performs the following steps:
</p>

<ol>
<li><p> Make the symbol table. See <code><a href="#topic+makeSymbolTable">makeSymbolTable</a></code>.
</p>
</li>
<li><p> Make the production table. See <code><a href="#topic+makeProductionTable">makeProductionTable</a></code>.
</p>
</li>
<li><p> Extract the start symbol. See <code><a href="#topic+makeStartSymbol">makeStartSymbol</a></code>.
</p>
</li>
<li><p> Compile a short production table. See <code><a href="#topic+compileShortPT">compileShortPT</a></code>.
</p>
</li>
<li><p> Return the grammar.</p>
</li></ol>



<h3>Value</h3>

<p>A grammar object (list) with the attributes 
</p>

<ul>
<li> <p><code>name</code> (the filename of the grammar),
</p>
</li>
<li> <p><code>ST</code> (symbol table), 
</p>
</li>
<li> <p><code>PT</code> (production table), 
</p>
</li>
<li> <p><code>Start</code> (the start symbol of the grammar), and
</p>
</li>
<li> <p><code>SPT</code> (the short production table).
</p>
</li></ul>



<h3>References</h3>

<p>Geyer-Schulz, Andreas (1997):
<em>Fuzzy Rule-Based Expert Systems and Genetic Machine Learning</em>,
Physica, Heidelberg. (ISBN:978-3-7908-0830-X)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
g$ST
g$PT
g$Start
g$SPT
</code></pre>

<hr>
<h2 id='compileShortPT'>Produces a production table with non-recursive productions only.</h2><span id='topic+compileShortPT'></span>

<h3>Description</h3>

<p><code>compileShortPT()</code> produces a &ldquo;short&rdquo; production table 
from a context-free grammar. The short production table does not
contain recursive production rules.  
Warning: No error checking implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compileShortPT(G)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compileShortPT_+3A_g">G</code></td>
<td>
<p>A grammar with symbol table <code>ST</code>, 
production table <code>PT</code>, 
and start symbol <code>Start</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>compileShortPT()</code> starts with production rules whose 
right-hand side contains only terminals. 
It incrementally builds up the new PT until at least one
production rule sequence from a non-terminal to a terminal symbol.
</p>
<p>The short production rule provides for each non-terminal 
symbol a minimal finite derivation into terminals. 
Instead
of the full production table, it is used
for generating depth-bounded derivation trees.
</p>


<h3>Value</h3>

<p>A (short) production table is a named list with 2 columns.
The first column
(the left-hand side <code>LHS</code>) is a vector
of non-terminal identifiers. 
The second column
(the right-hand side <code>RHS</code>) is a 
vector of vectors of numerical identifiers. 
<code>LHS[i]</code> derives into <code>RHS[i]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
compileShortPT(g)

</code></pre>

<hr>
<h2 id='derive'>Derives the identifier list which expands the non-terminal identifier.</h2><span id='topic+derive'></span>

<h3>Description</h3>

<p><code>derives()</code> returns the identifier list which expands 
a non-terminal identifier.
Warning: No error checking implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive(RuleIndex, RHS)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="derive_+3A_ruleindex">RuleIndex</code></td>
<td>
<p>An index (integer) in the production table.</p>
</td></tr>
<tr><td><code id="derive_+3A_rhs">RHS</code></td>
<td>
<p>The right-hand side of the production table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of numerical identifiers.
</p>


<h3>See Also</h3>

<p>Other Utility Functions: 
<code><a href="#topic+id2symb">id2symb</a>()</code>,
<code><a href="#topic+isNonTerminal">isNonTerminal</a>()</code>,
<code><a href="#topic+isTerminal">isTerminal</a>()</code>,
<code><a href="#topic+rules">rules</a>()</code>,
<code><a href="#topic+symb2id">symb2id</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-booleanGrammar()$BNF
ST&lt;-makeSymbolTable(a)
PT&lt;-makeProductionTable(a,ST)
derive(1, PT$RHS)
derive(2, PT$RHS)
derive(3, PT$RHS)
derive(5, PT$RHS)

</code></pre>

<hr>
<h2 id='id2symb'>Convert a numeric identifier to a symbol.</h2><span id='topic+id2symb'></span>

<h3>Description</h3>

<p><code>id2symb()</code> converts a numeric id to a symbol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id2symb(Id, ST)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="id2symb_+3A_id">Id</code></td>
<td>
<p>A numeric identifier (integer).</p>
</td></tr>
<tr><td><code id="id2symb_+3A_st">ST</code></td>
<td>
<p>A symbol table.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p>  A symbol string if the identifier exists or 
</p>
</li>
<li><p>  an empty character string (<code>character(0)</code>) 
if the identifier 
does not exist.</p>
</li></ul>



<h3>See Also</h3>

<p>Other Utility Functions: 
<code><a href="#topic+derive">derive</a>()</code>,
<code><a href="#topic+isNonTerminal">isNonTerminal</a>()</code>,
<code><a href="#topic+isTerminal">isTerminal</a>()</code>,
<code><a href="#topic+rules">rules</a>()</code>,
<code><a href="#topic+symb2id">symb2id</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
id2symb(1, g$ST)
id2symb(2, g$ST)
id2symb(5, g$ST)
id2symb(12, g$ST)
id2symb(15, g$ST)
identical(id2symb(15, g$ST), character(0))

</code></pre>

<hr>
<h2 id='isNonTerminal'>Is the numeric identifier a non-terminal symbol?</h2><span id='topic+isNonTerminal'></span>

<h3>Description</h3>

<p><code>isNonTerminal()</code> tests if the numeric identifier 
is a non-terminal symbol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isNonTerminal(Id, ST)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isNonTerminal_+3A_id">Id</code></td>
<td>
<p>A numeric identifier (integer).</p>
</td></tr>
<tr><td><code id="isNonTerminal_+3A_st">ST</code></td>
<td>
<p>A symbol table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>isNonTerminal()</code> is one of the most frequently used 
functions of a grammar-based genetic programming algorithm.
Careful coding pays off! 
Do not index the symbol table as a matrix 
(e.g. <code>ST[2,2]</code>), because this is really slow!
</p>


<h3>Value</h3>

 
<ul>
<li> <p><code>TRUE</code> if the numeric identifier is a terminal symbol.
</p>
</li>
<li> <p><code>FALSE</code> if the numeric identifier is a non-terminal symbol.
</p>
</li>
<li> <p><code>NA</code> if the symbol does not exist.</p>
</li></ul>



<h3>See Also</h3>

<p>Other Utility Functions: 
<code><a href="#topic+derive">derive</a>()</code>,
<code><a href="#topic+id2symb">id2symb</a>()</code>,
<code><a href="#topic+isTerminal">isTerminal</a>()</code>,
<code><a href="#topic+rules">rules</a>()</code>,
<code><a href="#topic+symb2id">symb2id</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
isNonTerminal(1, g$ST)
isNonTerminal(2, g$ST)
isNonTerminal(5, g$ST)
isNonTerminal(12, g$ST)
isNonTerminal(15, g$ST)
identical(isNonTerminal(15, g$ST), NA)

</code></pre>

<hr>
<h2 id='isTerminal'>Is the numeric identifier a terminal symbol?</h2><span id='topic+isTerminal'></span>

<h3>Description</h3>

<p><code>isTerminal()</code> tests if the numeric identifier 
is a terminal symbol.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isTerminal(Id, ST)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isTerminal_+3A_id">Id</code></td>
<td>
<p>A numeric identifier (integer).</p>
</td></tr>
<tr><td><code id="isTerminal_+3A_st">ST</code></td>
<td>
<p>A symbol table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>isTerminal()</code> is one of the most frequently used 
functions of a grammar-based genetic programming algorithm.
Careful coding pays off! 
Do not index the symbol table as a matrix 
(e.g. <code>ST[2,2]</code>), because this is really slow!
</p>


<h3>Value</h3>

 
<ul>
<li> <p><code>TRUE</code> if the numeric identifier is a terminal symbol.
</p>
</li>
<li> <p><code>FALSE</code> if the numeric identifier is a non-terminal symbol.
</p>
</li>
<li> <p><code>NA</code> if the symbol does not exist.</p>
</li></ul>



<h3>See Also</h3>

<p>Other Utility Functions: 
<code><a href="#topic+derive">derive</a>()</code>,
<code><a href="#topic+id2symb">id2symb</a>()</code>,
<code><a href="#topic+isNonTerminal">isNonTerminal</a>()</code>,
<code><a href="#topic+rules">rules</a>()</code>,
<code><a href="#topic+symb2id">symb2id</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
isTerminal(1, g$ST)
isTerminal(2, g$ST)
isTerminal(5, g$ST)
isTerminal(12, g$ST)
isTerminal(15, g$ST)
identical(isTerminal(15, g$ST), NA)

</code></pre>

<hr>
<h2 id='makeProductionTable'>Produces a production table.</h2><span id='topic+makeProductionTable'></span>

<h3>Description</h3>

<p><code>makeProductionTable()</code> produces a production table 
from a specification of a BNF.   
Warning: No error checking implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeProductionTable(BNF, ST)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeProductionTable_+3A_bnf">BNF</code></td>
<td>
<p>A character string with the BNF.</p>
</td></tr>
<tr><td><code id="makeProductionTable_+3A_st">ST</code></td>
<td>
<p>A symbol table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A production table is a named list with elements 
<code>$LHS</code> and <code>$RHS</code>:  
</p>

<ul>
<li><p> The left-hand side <code>LHS</code>
of non-terminal identifiers. 
</p>
</li>
<li><p> The right-hand side <code>RHS</code> is represented as a 
vector of vectors of numerical identifiers. 
</p>
</li></ul>

<p>The non-terminal identifier <code>LHS[i]</code> derives into <code>RHS[i]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-booleanGrammar()$BNF
ST&lt;-makeSymbolTable(a)
makeProductionTable(a,ST)

</code></pre>

<hr>
<h2 id='makeRule'>Transforms a single BNF rule into a production table.</h2><span id='topic+makeRule'></span>

<h3>Description</h3>

<p><code>makeRule()</code> transforms a single BNF rule
into a production table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeRule(Rule, ST)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeRule_+3A_rule">Rule</code></td>
<td>
<p>A rule.</p>
</td></tr>
<tr><td><code id="makeRule_+3A_st">ST</code></td>
<td>
<p>A symbol table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Because a single BNF rule can provide a set of substitutions, 
more than one line in a production table may result.
The number of substitutions corresponds to the number of lines 
in the production table.
</p>


<h3>Value</h3>

<p>A named list with 2 elements, namely <code>$LHS</code> and <code>$RHS</code>. 
The left-hand side <code>$LHS</code> is 
a vector of non-terminal identifiers
and the right-hand side <code>$RHS</code> is a vector of vectors
of numerical identifiers. 
The list represents the substitution of <code>$LHS[i]</code> 
by the identifier list <code>$RHS[[i]]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>c&lt;-booleanGrammar()$BNF
ST&lt;-makeSymbolTable(c)
c&lt;-booleanGrammar()$BNF 
b&lt;-strsplit(c,";")[[1]]
a&lt;-b[2:4]
a&lt;-gsub(pattern=";",replacement="", paste(a[1], a[2], a[3], sep=""))
makeRule(a, ST)

</code></pre>

<hr>
<h2 id='makeStartSymbol'>Extracts the numerical identifier of the start symbol of the grammar.</h2><span id='topic+makeStartSymbol'></span>

<h3>Description</h3>

<p><code>makeStartSymbol()</code> returns 
the start symbol's numerical identifier 
from a specification of a context-free grammar in BNF.   
Warning: No error checking implemented.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeStartSymbol(BNF, ST)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeStartSymbol_+3A_bnf">BNF</code></td>
<td>
<p>A character string with the BNF.</p>
</td></tr>
<tr><td><code id="makeStartSymbol_+3A_st">ST</code></td>
<td>
<p>A symbol table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The numerical identifier of the start symbol of the BNF.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-booleanGrammar()$BNF
ST&lt;-makeSymbolTable(a)
makeStartSymbol(a,ST)

</code></pre>

<hr>
<h2 id='makeSymbolTable'>Build a symbol table from a character string which contains a BNF.</h2><span id='topic+makeSymbolTable'></span>

<h3>Description</h3>

<p><code>makeSymbolTable()</code> extracts all terminal 
and non-terminal symbols from a BNF
and builds a data frame with the columns 
Symbols (string), NonTerminal (0 or 1), and SymbolId (int).
The symbol &quot;NotExpanded&quot; is added which codes
depth violations of a derivation tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeSymbolTable(BNF)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="makeSymbolTable_+3A_bnf">BNF</code></td>
<td>
<p>A character string with the BNF.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the columns 
<code>Symbols</code>, <code>NonTerminal</code>, and <code>SymbolID</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>makeSymbolTable(booleanGrammar()$BNF)

</code></pre>

<hr>
<h2 id='newBNF'>Convert grammar file into a constant function.</h2><span id='topic+newBNF'></span>

<h3>Description</h3>

<p><code>newBNF()</code> reads a text file and 
returns a constant function which returns
the BNF as a character string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newBNF(filename, eol = "\n")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newBNF_+3A_filename">filename</code></td>
<td>
<p>A file name.</p>
</td></tr>
<tr><td><code id="newBNF_+3A_eol">eol</code></td>
<td>
<p>End-of-line symbol(s). Default: <code>"\n"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The purpose of this function is to include examples
of grammars in packages.
</p>


<h3>Value</h3>

<p>Returns a constant function which returns a BNF.
</p>


<h3>See Also</h3>

<p>Other File I/O: 
<code><a href="#topic+readBNF">readBNF</a>()</code>,
<code><a href="#topic+writeBNF">writeBNF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-booleanGrammar()
fn&lt;-tempfile()
writeBNF(g, fn)
g1&lt;-newBNF(fn)
unlink(fn)
</code></pre>

<hr>
<h2 id='readBNF'>Read text file.</h2><span id='topic+readBNF'></span>

<h3>Description</h3>

<p><code>readBNF()</code> reads a text file and 
returns a character string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readBNF(filename, eol = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readBNF_+3A_filename">filename</code></td>
<td>
<p>A file name.</p>
</td></tr>
<tr><td><code id="readBNF_+3A_eol">eol</code></td>
<td>
<p>End-of-line symbol(s). Default: &quot;&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list with
</p>

<ul>
<li><p> $filename  the filename.
</p>
</li>
<li><p> $BNF a character string with the newline symbol \n.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other File I/O: 
<code><a href="#topic+newBNF">newBNF</a>()</code>,
<code><a href="#topic+writeBNF">writeBNF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-booleanGrammar()
fn&lt;-tempfile()
writeBNF(g, fn)
g1&lt;-readBNF(fn)
unlink(fn)
</code></pre>

<hr>
<h2 id='rules'>Returns all indices of rules applicable for a non-terminal identifier.</h2><span id='topic+rules'></span>

<h3>Description</h3>

<p><code>rules()</code> finds 
all applicable production rules
for a non-terminal identifier.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rules(Id, LHS)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rules_+3A_id">Id</code></td>
<td>
<p>A numerical identifier.</p>
</td></tr>
<tr><td><code id="rules_+3A_lhs">LHS</code></td>
<td>
<p>The left-hand side of a production table.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> A vector of indices of all applicable rules 
in the production table or
</p>
</li>
<li><p> an empty integer (<code>integer(0)</code>), 
if the numerical identifier is not found 
in the left-hand side of the production table.</p>
</li></ul>



<h3>See Also</h3>

<p>Other Utility Functions: 
<code><a href="#topic+derive">derive</a>()</code>,
<code><a href="#topic+id2symb">id2symb</a>()</code>,
<code><a href="#topic+isNonTerminal">isNonTerminal</a>()</code>,
<code><a href="#topic+isTerminal">isTerminal</a>()</code>,
<code><a href="#topic+symb2id">symb2id</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a&lt;-booleanGrammar()$BNF
ST&lt;-makeSymbolTable(a)
PT&lt;-makeProductionTable(a,ST)
rules(5, PT$LHS)
rules(8, PT$LHS)
rules(9, PT$LHS)
rules(1, PT$LHS)

</code></pre>

<hr>
<h2 id='symb2id'>Convert a symbol to a numeric identifier.</h2><span id='topic+symb2id'></span>

<h3>Description</h3>

<p><code>symb2id()</code> converts a symbol to a numeric id.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>symb2id(sym, ST)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="symb2id_+3A_sym">sym</code></td>
<td>
<p>A character string with the symbol, e.g. &lt;fe&gt; or &quot;NOT&quot;.</p>
</td></tr>
<tr><td><code id="symb2id_+3A_st">ST</code></td>
<td>
<p>A symbol table.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> A positive integer if the symbol exists or  
</p>
</li>
<li><p> an empty integer (<code>integer(0)</code>) 
if the symbol does not exist.</p>
</li></ul>



<h3>See Also</h3>

<p>Other Utility Functions: 
<code><a href="#topic+derive">derive</a>()</code>,
<code><a href="#topic+id2symb">id2symb</a>()</code>,
<code><a href="#topic+isNonTerminal">isNonTerminal</a>()</code>,
<code><a href="#topic+isTerminal">isTerminal</a>()</code>,
<code><a href="#topic+rules">rules</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-compileBNF(booleanGrammar())
symb2id("&lt;fe&gt;", g$ST)
symb2id("NOT", g$ST)
symb2id("&lt;fe", g$ST)
symb2id("NO", g$ST)
identical(symb2id("NO", g$ST), integer(0))

</code></pre>

<hr>
<h2 id='writeBNF'>Write BNF into text file.</h2><span id='topic+writeBNF'></span>

<h3>Description</h3>

<p><code>writeBNF()</code> writes a character string into a textfile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeBNF(g, fn = NULL, eol = "\n")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeBNF_+3A_g">g</code></td>
<td>
<p>A named list with $filename and  $BNF as a character string.</p>
</td></tr>
<tr><td><code id="writeBNF_+3A_fn">fn</code></td>
<td>
<p>A file name. Default: NULL.</p>
</td></tr>
<tr><td><code id="writeBNF_+3A_eol">eol</code></td>
<td>
<p>End-of-line symbol(s). Default: <code>"\n"</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The user writes the BNF to a text file which he edits.
The newline symbols are inserted after each substitution variant 
and after each production rule to improve the readability 
of the grammar by the user.
</p>


<h3>Value</h3>

<p>Invisible NULL.
</p>


<h3>See Also</h3>

<p>Other File I/O: 
<code><a href="#topic+newBNF">newBNF</a>()</code>,
<code><a href="#topic+readBNF">readBNF</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g&lt;-booleanGrammar()
fn&lt;-tempfile()
writeBNF(g, fn)
g1&lt;-readBNF(fn, eol="\n")
unlink(fn)
</code></pre>

<hr>
<h2 id='xegaBNF'>Package xegaBNF</h2><span id='topic+xegaBNF'></span>

<h3>Description</h3>

<p><code>xegaBNF</code> implements a grammar compiler for context-free languages
specified in BNF and a few utility functions. 
The grammar compiler 
generates a grammar object. 
This object used by the package
<code>xegaDerivationTrees</code>, as well as for grammar-based genetic 
programming (<code>xegaGpGene</code>) and grammatical evolution 
(<code>xegaGeGene</code>.
</p>


<h3>BNF (Backus-Naur Form)</h3>

<p>Grammars of context-free languages are represented 
in Backus-Naur Form (BNF). See e.g. Backus et al. (1962).
</p>
<p>The BNF is a meta-language for specifying the syntax of context-free 
languages. The BNF provides 
</p>

<ol>
<li><p> non-terminal symbols,
</p>
</li>
<li><p> terminal symbols, and
</p>
</li>
<li><p> meta-symbols of the BNF. 
</p>
</li></ol>

<p>A non-terminal symbol has the following form:
<code>&lt;pattern&gt;</code>, where pattern is an arbitrary sequence of letters, numbers, 
and symbols.  
</p>
<p>A terminal symbol has the following form:
<code>"pattern"</code>, where pattern is an arbitrary sequence of letters, numbers, 
and symbols. 
</p>
<p>The BNF has three meta symbols, namely <code>::=</code>, <code>|</code>, and <code>;</code> 
which are used for the specification of production (substitution) rules. 
<code>::=</code> separates the left-hand side of the rule from the right-hand
side of the rule. <code>;</code> indicates the end of a production rule.
<code>|</code> separates the symbol sequences of a compound production rule. 
A production rule has the following form:
</p>
<p><code>LHS ::= RHS;</code>
</p>
<p>where <code>LHS</code> is a single non-terminal symbol and 
<code>RHS</code> is either a simple symbol sequence or a compound symbol 
sequence.
</p>
<p>A production rule with a simple symbol sequence 
specifies the substitution of 
the non-terminal symbol on the <code>LHS</code> by the symbol sequence of 
the <code>RHS</code>. 
</p>
<p>A production rule with a compound symbol sequence 
specifies the substitution of 
the non-terminal symbol on the <code>LHS</code> by one of the symbol sequences of 
the <code>RHS</code>.
</p>


<h3>Editing BNFs</h3>

<p>The BNF may be stored in ASCII text files and edited with standard editors.
</p>


<h3>The Internal Representation of a Grammar Object</h3>

<p>A grammar object is represented as a named list:
</p>

<ul>
<li><p> $name contains the filename of the BNF.
</p>
</li>
<li><p> $ST   the symbol table.
</p>
</li>
<li><p> $PT   the production table.
</p>
</li>
<li><p> $Start the start symbol of the grammar.
</p>
</li>
<li><p> $SPT  a short production table without recursive rules. 
</p>
</li></ul>



<h3>The Compilation Process</h3>

<p>The main steps of the compilation process are:
</p>

<ol>
<li><p> Store the filename.
</p>
</li>
<li><p> Make the symbol table. See <code><a href="#topic+makeSymbolTable">makeSymbolTable</a></code>.
</p>
</li>
<li><p> Make the production table. See <code><a href="#topic+makeProductionTable">makeProductionTable</a></code>.
</p>
</li>
<li><p> Extract the start symbol. See <code><a href="#topic+makeStartSymbol">makeStartSymbol</a></code>.
</p>
</li>
<li><p> Compile a short production table. See <code><a href="#topic+compileShortPT">compileShortPT</a></code>.
</p>
</li>
<li><p> Return the grammar.</p>
</li></ol>



<h3>The User-Interface of the Compiler</h3>

<p><code>compileBNF(g)</code> where <code>g</code> is a character string with a BNF.
</p>


<h3>Utility Functions for xegaX-Packages</h3>

 
<ul>
<li><p> isTerminal, isNonTerminal: For testing the symbol type of 
identifiers in a grammar object.
</p>
</li>
<li><p> rules, derives: For choosing rules and for substitutions.
</p>
</li></ul>



<h3>The Architecture of the xegaX-Packages</h3>

<p>The xegaX-packages are a family of R-packages which implement 
eXtended Evolutionary and Genetic Algorithms (xega).  
The architecture has 3 layers, 
namely the user interface layer,
the population layer, and the gene layer: 
</p>

<ul>
<li>
<p>The user interface layer (package <code>xega</code>) 
provides a function call interface and configuration support
for several algorithms: genetic algorithms (sga), 
permutation-based genetic algorithms (sgPerm), 
derivation-free algorithms as e.g. differential evolution (sgde), 
grammar-based genetic programming (sgp) and grammatical evolution
(sge). 
</p>
</li>
<li>
<p>The population layer (package <code>xegaPopulation</code>) contains
population related functionality as well as support for 
population statistics dependent adaptive mechanisms and parallelization.
</p>
</li>
<li> 
<p>The gene layer is split into a representation-independent and 
a representation-dependent part:
</p>

<ol>
<li> 
<p>The representation indendent part (package <code>xegaSelectGene</code>)
is responsible for variants of selection operators, evaluation 
strategies for genes, as well as profiling and timing capabilities.        
</p>
</li>
<li> 
<p>The representation dependent part consists of the following packages: 
</p>

<ul>
<li> <p><code>xegaGaGene</code> for binary coded genetic algorithms.
</p>
</li>
<li> <p><code>xegaPermGene</code> for permutation-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaDfGene</code> for derivation free algorithms as e.g. 
differential evolution.
</p>
</li>
<li> <p><code>xegaGpGene</code> for grammar-based genetic algorithms.
</p>
</li>
<li> <p><code>xegaGeGene</code> for grammatical evolution algorithms.
</p>
</li></ul>

<p>The packages <code>xegaDerivationTrees</code> and <code>xegaBNF</code> support
the last two packages:
</p>

<ul>
<li> <p><code>xegaBNF</code> essentially provides a grammar compiler.
</p>
</li>
<li> <p><code>xegaDerivationTrees</code> implements an abstract data type for derivation trees.
</p>
</li></ul>

</li></ol>
</li></ul>



<h3>Copyright</h3>

<p>(c) 2023 Andreas Geyer-Schulz
</p>


<h3>License</h3>

<p>MIT
</p>


<h3>URL</h3>

<p>&lt;https://github.com/ageyerschulz/xegaBNF&gt;
</p>


<h3>Installation</h3>

<p>From CRAN by <code>install.packages('xegaBNF')</code>
</p>


<h3>Author(s)</h3>

<p>Andreas Geyer-Schulz
</p>


<h3>References</h3>

<p>Backus, J. W., Bauer, F. L., Green, J., Katz, C., McCarthy, J., 
Naur, Peter, Perlis, A. J., Ruthishauser, H.,  and Samelson, K.
(1962)
Revised Report on the Algorithmic Language ALGOL 60, IFIP, Rome.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
