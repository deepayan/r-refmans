<!DOCTYPE html><html><head><title>Help for package dfms</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dfms}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.VAR'><p>(Fast) Barebones Vector-Autoregression</p></a></li>
<li><a href='#ainv'><p>Armadillo's Inverse Functions</p></a></li>
<li><a href='#as.data.frame.dfm'><p>Extract Factor Estimates in a Data Frame</p></a></li>
<li><a href='#BM14_Models'><p>Euro Area Macroeconomic Data from Banbura and Modugno 2014</p></a></li>
<li><a href='#DFM'><p>Estimate a Dynamic Factor Model</p></a></li>
<li><a href='#em_converged'><p>Convergence Test for EM-Algorithm</p></a></li>
<li><a href='#FIS'><p>(Fast) Fixed-Interval Smoother (Kalman Smoother)</p></a></li>
<li><a href='#ICr'><p>Information Criteria to Determine the Number of Factors (r)</p></a></li>
<li><a href='#plot.dfm'><p>Plot DFM</p></a></li>
<li><a href='#predict.dfm'><p>DFM Forecasts</p></a></li>
<li><a href='#residuals.dfm'><p>DFM Residuals and Fitted Values</p></a></li>
<li><a href='#SKF'><p>(Fast) Stationary Kalman Filter</p></a></li>
<li><a href='#SKFS'><p>(Fast) Stationary Kalman Filter and Smoother</p></a></li>
<li><a href='#summary.dfm'><p>DFM Summary Methods</p></a></li>
<li><a href='#tsnarmimp'><p>Remove and Impute Missing Values in a Multivariate Time Series</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Title:</td>
<td>Dynamic Factor Models</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient estimation of Dynamic Factor Models using the Expectation Maximization (EM) algorithm 
  or Two-Step (2S) estimation, supporting datasets with missing data. The estimation options follow advances in the 
  econometric literature: either running the Kalman Filter and Smoother once with initial values from PCA - 
  2S estimation as in Doz, Giannone and Reichlin (2011) &lt;<a href="https://doi.org/10.1016%2Fj.jeconom.2011.02.012">doi:10.1016/j.jeconom.2011.02.012</a>&gt; - or via iterated 
  Kalman Filtering and Smoothing until EM convergence - following Doz, Giannone and Reichlin (2012) 
  &lt;<a href="https://doi.org/10.1162%2FREST_a_00225">doi:10.1162/REST_a_00225</a>&gt; - or using the adapted EM algorithm of Banbura and Modugno (2014) &lt;<a href="https://doi.org/10.1002%2Fjae.2306">doi:10.1002/jae.2306</a>&gt;, 
  allowing arbitrary patterns of missing data. The implementation makes heavy use of the 'Armadillo' 'C++' library and 
  the 'collapse' package, providing for particularly speedy estimation. A comprehensive set of methods supports 
  interpretation and visualization of the model as well as forecasting. Information criteria to choose the number 
  of factors are also provided - following Bai and Ng (2002) &lt;<a href="https://doi.org/10.1111%2F1468-0262.00273">doi:10.1111/1468-0262.00273</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://sebkrantz.github.io/dfms/">https://sebkrantz.github.io/dfms/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/SebKrantz/dfms/issues">https://github.com/SebKrantz/dfms/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1), collapse (&ge; 1.8.0)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>xts, vars, magrittr, testthat (&ge; 3.0.0), knitr, rmarkdown,
covr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-01 08:52:17 UTC; sebastiankrantz</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastian Krantz [aut, cre],
  Rytis Bagdziunas [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastian Krantz &lt;sebastian.krantz@graduateinstitute.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-04-03 11:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.VAR'>(Fast) Barebones Vector-Autoregression</h2><span id='topic+.VAR'></span>

<h3>Description</h3>

<p>Quickly estimate a VAR(p) model using Armadillo's inverse function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.VAR(x, p = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".VAR_+3A_x">x</code></td>
<td>
<p>data numeric matrix with time series in columns - without missing values.</p>
</td></tr>
<tr><td><code id=".VAR_+3A_p">p</code></td>
<td>
<p>positive integer. The lag order of the VAR.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing matrices <code>Y = x[-(1:p), ]</code>, <code>X</code> which contains lags 1 - p of <code>x</code> combined column-wise,
<code>A</code> which is the <code class="reqn">np \times n</code> transition matrix, where n is the number of series in <code>x</code>, and the VAR residual matrix <code>res = Y - X %*% A</code>.
</p>
<p>A list with the following elements:
</p>
<table>
<tr><td><code>Y</code></td>
<td>
<p><code>x[-(1:p), ]</code>. </p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>lags 1 - p of <code>x</code> combined column-wise. </p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p><code class="reqn">np \times n</code> transition matrix, where n is the number of series in <code>x</code>. </p>
</td></tr>
<tr><td><code>res</code></td>
<td>
<p>VAR residual matrix: <code>Y - X %*% A</code>. </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>var = .VAR(diff(EuStockMarkets), 3)
str(var)
var$A
rm(var)

</code></pre>

<hr>
<h2 id='ainv'>Armadillo's Inverse Functions</h2><span id='topic+ainv'></span><span id='topic+apinv'></span>

<h3>Description</h3>

<p>Matrix inverse and pseudo-inverse by the Armadillo C++ library.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ainv(x)

apinv(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ainv_+3A_x">x</code></td>
<td>
<p>a numeric matrix, must be square for <code>ainv</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix-inverse or pseudo-inverse.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ainv(crossprod(diff(EuStockMarkets)))

</code></pre>

<hr>
<h2 id='as.data.frame.dfm'>Extract Factor Estimates in a Data Frame</h2><span id='topic+as.data.frame.dfm'></span>

<h3>Description</h3>

<p>Extract Factor Estimates in a Data Frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfm'
as.data.frame(
  x,
  ...,
  method = "all",
  pivot = c("long", "wide.factor", "wide.method", "wide", "t.wide"),
  time = seq_row(x$F_pca),
  stringsAsFactors = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.dfm_+3A_x">x</code></td>
<td>
<p>an object class 'dfm'.</p>
</td></tr>
<tr><td><code id="as.data.frame.dfm_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="as.data.frame.dfm_+3A_method">method</code></td>
<td>
<p>character. The factor estimates to use: any of <code>"qml"</code>, <code>"2s"</code>, <code>"pca"</code> (multiple can be supplied) or <code>"all"</code> for all estimates.</p>
</td></tr>
<tr><td><code id="as.data.frame.dfm_+3A_pivot">pivot</code></td>
<td>
<p>character. The orientation of the frame: <code>"long"</code>, <code>"wide.factor"</code> or <code>"wide.method"</code>, <code>"wide"</code> or <code>"t.wide"</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.dfm_+3A_time">time</code></td>
<td>
<p>a vector identifying the time dimension, or <code>NULL</code> to omit a time variable.</p>
</td></tr>
<tr><td><code id="as.data.frame.dfm_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>make factors from method and factor identifiers. Same as option to <code><a href="base.html#topic+as.data.frame.table">as.data.frame.table</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of factor estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(xts)
# Fit DFM with 3 factors and 3 lags in the transition equation
mod = DFM(diff(BM14_M), r = 3, p = 3)

# Taking a single estimate:
print(head(as.data.frame(mod, method = "qml")))
print(head(as.data.frame(mod, method = "qml", pivot = "wide")))

# Adding a proper time variable
time = index(BM14_M)[-1L]
print(head(as.data.frame(mod, method = "qml", time = time)))

# All estimates: different pivoting methods
for (pv in c("long", "wide.factor", "wide.method", "wide", "t.wide")) {
   cat("\npivot = ", pv, "\n")
   print(head(as.data.frame(mod, pivot = pv, time = time), 3))
}


</code></pre>

<hr>
<h2 id='BM14_Models'>Euro Area Macroeconomic Data from Banbura and Modugno 2014</h2><span id='topic+BM14_Models'></span><span id='topic+BM14_M'></span><span id='topic+BM14_Q'></span>

<h3>Description</h3>

<p>A data extract from BM 2014 replication files. Some proprietary series (mostly PMI's) are excluded. The dataset <code>BM14_Models</code> provides information about all series
and their inclusion in the 'small', 'medium' and 'large' sized dynamic factor models estimated by BM 2014. The actual data is contained in <em>xts</em> format in <code>BM14_M</code> for monthly data and <code>BM14_Q</code> for quarterly data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BM14_Models
BM14_M
BM14_Q
</code></pre>


<h3>Format</h3>

<p><code>BM14_Models</code> is a data frame with 101 obs. (series) and 8 columns:
</p>

<dl>
<dt>series</dt><dd><p>BM14 series code (converted to snake case for R)</p>
</dd>
<dt>label</dt><dd><p>BM14 series label</p>
</dd>
<dt>code</dt><dd><p>original series code from data source</p>
</dd>
<dt>freq</dt><dd><p>series frequency</p>
</dd>
<dt>log_trans</dt><dd><p>logical indicating whether the series was transformed by the natural log before differencing. Note that all data are provided in untransformed levels, and all data was (log-)differenced by BM14 before estimation.</p>
</dd>
<dt>small</dt><dd><p>logical indicating series included in the 'small' model of BM14. Proprietary series are excluded.</p>
</dd>
<dt>medium</dt><dd><p>logical indicating series included in the 'medium' model of BM14. Proprietary series are excluded.</p>
</dd>
<dt>large</dt><dd><p>logical indicating series included in the 'large' model of BM14. This comprises all series, thus the variable is redundant but included for completeness. Proprietary series are excluded.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Banbura, M., &amp; Modugno, M. (2014). Maximum likelihood estimation of factor models on datasets with arbitrary pattern of missing data. <em>Journal of Applied Econometrics, 29</em>(1), 133-160.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
library(xts)

# Constructing the database for the large model
BM14 = merge(BM14_M, BM14_Q)
BM14[, BM14_Models$log_trans] %&lt;&gt;% log()
BM14[, BM14_Models$freq == "M"] %&lt;&gt;% diff()
BM14[, BM14_Models$freq == "Q"] %&lt;&gt;% diff(3)

# Small Model Database
head(BM14[, BM14_Models$small])

# Medium-Sized Model Database
head(BM14[, BM14_Models$medium])

</code></pre>

<hr>
<h2 id='DFM'>Estimate a Dynamic Factor Model</h2><span id='topic+DFM'></span>

<h3>Description</h3>

<p>Efficient estimation of a Dynamic Factor Model via the EM Algorithm - on stationary data
with time-invariant system matrices and classical assumptions, while permitting missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DFM(
  X,
  r,
  p = 1L,
  ...,
  idio.ar1 = FALSE,
  rQ = c("none", "diagonal", "identity"),
  rR = c("diagonal", "identity", "none"),
  em.method = c("auto", "DGR", "BM", "none"),
  min.iter = 25L,
  max.iter = 100L,
  tol = 1e-04,
  pos.corr = TRUE,
  check.increased = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DFM_+3A_x">X</code></td>
<td>
<p>a <code>T x n</code> numeric data matrix or frame of stationary time series. May contain missing values.</p>
</td></tr>
<tr><td><code id="DFM_+3A_r">r</code></td>
<td>
<p>integer. number of factors.</p>
</td></tr>
<tr><td><code id="DFM_+3A_p">p</code></td>
<td>
<p>integer. number of lags in factor VAR.</p>
</td></tr>
<tr><td><code id="DFM_+3A_...">...</code></td>
<td>
<p>(optional) arguments to <code><a href="#topic+tsnarmimp">tsnarmimp</a></code>.</p>
</td></tr>
<tr><td><code id="DFM_+3A_idio.ar1">idio.ar1</code></td>
<td>
<p>logical. Model observation errors as AR(1) processes: <code class="reqn">e_t = \rho e_{t-1} + v_t</code>. <em>Note</em> that this substantially increases computation time, and is generaly not needed if <code>n</code> is large (&gt;30). See theoretical vignette for details.</p>
</td></tr>
<tr><td><code id="DFM_+3A_rq">rQ</code></td>
<td>
<p>character. restrictions on the state (transition) covariance matrix (Q).</p>
</td></tr>
<tr><td><code id="DFM_+3A_rr">rR</code></td>
<td>
<p>character. restrictions on the observation (measurement) covariance matrix (R).</p>
</td></tr>
<tr><td><code id="DFM_+3A_em.method">em.method</code></td>
<td>
<p>character. The implementation of the Expectation Maximization Algorithm used. The options are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>"auto"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Automatic selection: <code>"BM"</code> if <code>anyNA(X)</code>, else <code>"DGR"</code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"DGR"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> The classical EM implementation of Doz, Giannone and Reichlin (2012). This implementation is efficient and quite robust, missing values are removed on a casewise basis in the Kalman Filter and Smoother, but not explicitly accounted for in EM iterations. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"BM"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> The modified EM algorithm of Banbura and Modugno (2014) which also accounts for missing data in the EM iterations. Optimal for datasets with systematically missing data e.g. datasets with ragged edges or series at different frequencies.  </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"none"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> Performs no EM iterations and just returns the Two-Step estimates from running the data through the Kalman Filter and Smoother once as in
Doz, Giannone and Reichlin (2011) (the Kalman Filter is Initialized with system matrices obtained from a regression and VAR on PCA factor estimates).
This yields significant performance gains over the iterative methods. Final system matrices are estimated by running a regression and a VAR on the smoothed factors.  </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="DFM_+3A_min.iter">min.iter</code></td>
<td>
<p>integer. Minimum number of EM iterations (to ensure a convergence path).</p>
</td></tr>
<tr><td><code id="DFM_+3A_max.iter">max.iter</code></td>
<td>
<p>integer. Maximum number of EM iterations.</p>
</td></tr>
<tr><td><code id="DFM_+3A_tol">tol</code></td>
<td>
<p>numeric. EM convergence tolerance.</p>
</td></tr>
<tr><td><code id="DFM_+3A_pos.corr">pos.corr</code></td>
<td>
<p>logical. Increase the likelihood that factors correlate positively with the data, by scaling the eigenvectors such that the principal components (used to initialize the Kalman Filter) co-vary positively with the row-means of the standardized data.</p>
</td></tr>
<tr><td><code id="DFM_+3A_check.increased">check.increased</code></td>
<td>
<p>logical. Check if likelihood has increased. Passed to <code><a href="#topic+em_converged">em_converged</a></code>. If <code>TRUE</code>, the algorithm only terminates if convergence was reached with decreasing likelihood.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function efficiently estimates a Dynamic Factor Model with the following classical assumptions:
</p>

<ol>
<li><p> Linearity
</p>
</li>
<li><p> Idiosynchratic measurement (observation) errors (<em>R</em> is diagonal)
</p>
</li>
<li><p> No direct relationship between series and lagged factors (<em>ceteris paribus</em> contemporaneous factors)
</p>
</li>
<li><p> No relationship between lagged error terms in the either measurement or transition equation (no serial correlation), unless explicitly modeled as AR(1) processes using <code>idio.ar1 = TRUE</code>.
</p>
</li></ol>

<p>Factors are allowed to evolve in a <code class="reqn">VAR(p)</code> process, and data is internally standardized (scaled and centered) before estimation (removing the need of intercept terms).
By assumptions 1-4, this translates into the following dynamic form:
</p>
<p style="text-align: center;"><code class="reqn">\textbf{x}_t = \textbf{C}_0 \textbf{f}_t + \textbf{e}_t \ \sim\  N(\textbf{0}, \textbf{R})</code>
</p>

<p style="text-align: center;"><code class="reqn">\textbf{f}_t = \sum_{j=1}^p \textbf{A}_j \textbf{f}_{t-j} + \textbf{u}_t \ \sim\  N(\textbf{0}, \textbf{Q}_0)</code>
</p>

<p>where the first equation is called the measurement or observation equation and the second equation is called transition, state or process equation, and
</p>

<table>
<tr>
 <td style="text-align: left;">
<code class="reqn">n</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> number of series in <code class="reqn">\textbf{x}_t</code> (<code class="reqn">r</code> and <code class="reqn">p</code> as the arguments to <code>DFM</code>).</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\textbf{x}_t</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code class="reqn">n \times 1</code> vector of observed series at time <code class="reqn">t</code>: <code class="reqn">(x_{1t}, \dots, x_{nt})'</code>. Some observations can be missing.  </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\textbf{f}_t</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code class="reqn">r \times 1</code> vector of factors at time <code class="reqn">t</code>: <code class="reqn">(f_{1t}, \dots, f_{rt})'</code>.</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\textbf{C}_0</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code class="reqn">n \times r</code> measurement (observation) matrix.</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\textbf{A}_j</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code class="reqn">r \times r</code> state transition matrix at lag <code class="reqn">j</code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\textbf{Q}_0</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code class="reqn">r \times r</code> state covariance matrix.</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\textbf{R}</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code class="reqn">n \times n</code> measurement (observation) covariance matrix. It is diagonal by assumption 2 that <code class="reqn">E[\textbf{x}_{it}|\textbf{x}_{-i,t},\textbf{x}_{i,t-1}, \dots, \textbf{f}_t, \textbf{f}_{t-1}, \dots] = \textbf{Cf}_t \forall i</code>.</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>This model can be estimated using a classical form of the Kalman Filter and the Expectation Maximization (EM) algorithm, after transforming it to State-Space (stacked, VAR(1)) form:
</p>
<p style="text-align: center;"><code class="reqn">\textbf{x}_t = \textbf{C} \textbf{F}_t + \textbf{e}_t \ \sim\  N(\textbf{0}, \textbf{R})</code>
</p>

<p style="text-align: center;"><code class="reqn">\textbf{F}_t = \textbf{A F}_{t-1} + \textbf{u}_t \ \sim\  N(\textbf{0}, \textbf{Q})</code>
</p>

<p>where
</p>

<table>
<tr>
 <td style="text-align: left;">
<code class="reqn">n</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> number of series in <code class="reqn">\textbf{x}_t</code> (<code class="reqn">r</code> and <code class="reqn">p</code> as the arguments to <code>DFM</code>).</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\textbf{x}_t</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code class="reqn">n \times 1</code> vector of observed series at time <code class="reqn">t</code>: <code class="reqn">(x_{1t}, \dots, x_{nt})'</code>. Some observations can be missing.  </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\textbf{F}_t</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code class="reqn">rp \times 1</code> vector of stacked factors at time <code class="reqn">t</code>: <code class="reqn">(f_{1t}, \dots, f_{rt}, f_{1,t-1}, \dots, f_{r,t-1}, \dots, f_{1,t-p}, \dots, f_{r,t-p})'</code>.</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\textbf{C}</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code class="reqn">n \times rp</code> observation matrix. Only the first <code class="reqn">n \times r</code> terms are non-zero, by assumption 3 that <code class="reqn">E[\textbf{x}_t|\textbf{F}_t] = E[\textbf{x}_t|\textbf{f}_t]</code> (no relationship of observed series with lagged factors given contemporaneous factors).</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\textbf{A}</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> stacked <code class="reqn">rp \times rp</code> state transition matrix consisting of 3 parts: the top <code class="reqn">r \times rp</code> part provides the dynamic relationships captured by <code class="reqn">(\textbf{A}_1, \dots, \textbf{A}_p)</code> in the dynamic form, the terms <code>A[(r+1):rp, 1:(rp-r)]</code> constitute an <code class="reqn">(rp-r) \times (rp-r)</code> identity matrix mapping all lagged factors to their known values at times t. The remaining part <code>A[(rp-r+1):rp, (rp-r+1):rp]</code> is an <code class="reqn">r \times r</code> matrix of zeros. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\textbf{Q}</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code class="reqn">rp \times rp</code> state covariance matrix. The top <code class="reqn">r \times r</code> part gives the contemporaneous relationships, the rest are zeros by assumption 4.</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code class="reqn">\textbf{R}</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> <code class="reqn">n \times n</code> observation covariance matrix. It is diagonal by assumption 2 and identical to <code class="reqn">\textbf{R}</code> as stated in the dynamic form.</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>A list-like object of class 'dfm' with the following elements:
</p>
<table>
<tr><td><code>X_imp</code></td>
<td>
<p><code class="reqn">T \times n</code> matrix with the imputed and standardized (scaled and centered) data - with attributes attached allowing reconstruction of the original data:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>"stats"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> is a <code class="reqn">n \times 5</code> matrix of summary statistics of class <code>"qsu"</code> (see <code><a href="collapse.html#topic+qsu">qsu</a></code>).</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"missing"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> is a <code class="reqn">T \times n</code> logical matrix indicating missing or infinite values in the original data (which are imputed in <code>X_imp</code>).</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"attributes"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> contains the <code><a href="base.html#topic+attributes">attributes</a></code> of the original data input.</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"is.list"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> is a logical value indicating whether the original data input was a list / data frame. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;"> </td>
</tr>

</table>

</td></tr>
<tr><td><code>eigen</code></td>
<td>
<p><code>eigen(cov(X_imp))</code>. </p>
</td></tr>
<tr><td><code>F_pca</code></td>
<td>
<p><code class="reqn">T \times r</code> matrix of principal component factor estimates - <code>X_imp %*% eigen$vectors</code>. </p>
</td></tr>
<tr><td><code>P_0</code></td>
<td>
<p><code class="reqn">r \times r</code> initial factor covariance matrix estimate based on PCA results. </p>
</td></tr>
<tr><td><code>F_2s</code></td>
<td>
<p><code class="reqn">T \times r</code> matrix two-step factor estimates as in Doz, Giannone and Reichlin (2011) - obtained from running the data through the Kalman Filter and Smoother once, where the Filter is initialized with results from PCA. </p>
</td></tr>
<tr><td><code>P_2s</code></td>
<td>
<p><code class="reqn">r \times r \times T</code> covariance matrices of two-step factor estimates. </p>
</td></tr>
<tr><td><code>F_qml</code></td>
<td>
<p><code class="reqn">T \times r</code> matrix of quasi-maximum likelihood factor estimates - obtained by iteratively Kalman Filtering and Smoothing the factor estimates until EM convergence. </p>
</td></tr>
<tr><td><code>P_qml</code></td>
<td>
<p><code class="reqn">r \times r \times T</code> covariance matrices of QML factor estimates. </p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p><code class="reqn">r \times rp</code> factor transition matrix.</p>
</td></tr>
<tr><td><code>C</code></td>
<td>
<p><code class="reqn">n \times r</code> observation matrix.</p>
</td></tr>
<tr><td><code>Q</code></td>
<td>
<p><code class="reqn">r \times r</code> state (error) covariance matrix.</p>
</td></tr>
<tr><td><code>R</code></td>
<td>
<p><code class="reqn">n \times n</code> observation (error) covariance matrix.</p>
</td></tr>
<tr><td><code>e</code></td>
<td>
<p><code class="reqn">T \times n</code> estimates of observation errors <code class="reqn">\textbf{e}_t</code>. Only available if <code>idio.ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>
<p><code class="reqn">n \times 1</code> estimates of AR(1) coefficients (<code class="reqn">\rho</code>) in observation errors: <code class="reqn">e_t = \rho e_{t-1} + v_t</code>. Only available if <code>idio.ar1 = TRUE</code>.</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>vector of log-likelihoods - one for each EM iteration. The final value corresponds to the log-likelihood of the reported model.</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>The numeric convergence tolerance used.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>single logical valued indicating whether the EM algorithm converged (within <code>max.iter</code> iterations subject to <code>tol</code>).</p>
</td></tr>
<tr><td><code>anyNA</code></td>
<td>
<p>single logical valued indicating whether there were any (internal) missing values in the data (determined after removal of rows with too many missing values). If <code>FALSE</code>, <code>X_imp</code> is simply the original data in matrix form, and does not have the <code>"missing"</code> attribute attached.</p>
</td></tr>
<tr><td><code>rm.rows</code></td>
<td>
<p>vector of any cases (rows) that were removed beforehand (subject to <code>max.missing</code> and <code>na.rm.method</code>). If no cases were removed the slot is <code>NULL</code>. </p>
</td></tr>
<tr><td><code>em.method</code></td>
<td>
<p>The EM method used.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>call object obtained from <code>match.call()</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Doz, C., Giannone, D., &amp; Reichlin, L. (2011). A two-step estimator for large approximate dynamic factor models based on Kalman filtering. <em>Journal of Econometrics, 164</em>(1), 188-205.
</p>
<p>Doz, C., Giannone, D., &amp; Reichlin, L. (2012). A quasi-maximum likelihood approach for large, approximate dynamic factor models. <em>Review of Economics and Statistics, 94</em>(4), 1014-1024.
</p>
<p>Banbura, M., &amp; Modugno, M. (2014). Maximum likelihood estimation of factor models on datasets with arbitrary pattern of missing data. <em>Journal of Applied Econometrics, 29</em>(1), 133-160.
</p>
<p>Stock, J. H., &amp; Watson, M. W. (2016). Dynamic Factor Models, Factor-Augmented Vector Autoregressions, and Structural Vector Autoregressions in Macroeconomics. <em>Handbook of Macroeconomics, 2</em>, 415–525. https://doi.org/10.1016/bs.hesmac.2016.04.002
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(magrittr)
library(xts)
library(vars)

# BM14 Replication Data. Constructing the database:
BM14 = merge(BM14_M, BM14_Q)
BM14[, BM14_Models$log_trans] %&lt;&gt;% log()
BM14[, BM14_Models$freq == "M"] %&lt;&gt;% diff()
BM14[, BM14_Models$freq == "Q"] %&lt;&gt;% diff(3)


### Small Model ---------------------------------------

# IC for number of factors
IC_small = ICr(BM14[, BM14_Models$small], max.r = 5)
plot(IC_small)
screeplot(IC_small)

# I take 2 factors. Now number of lags
VARselect(IC_small$F_pca[, 1:2])

# Estimating the model with 2 factors and 3 lags
dfm_small = DFM(BM14[, BM14_Models$small], 2, 3)

# Inspecting the model
summary(dfm_small)
plot(dfm_small)  # Factors and data
plot(dfm_small, method = "all", type = "individual") # Factor estimates
plot(dfm_small, type = "residual") # Residuals from factor predictions

# 10 periods ahead forecast
plot(predict(dfm_small), xlim = c(300, 370))


### Medium-Sized Model ---------------------------------

# IC for number of factors
IC_medium = ICr(BM14[, BM14_Models$medium])
plot(IC_medium)
screeplot(IC_medium)

# I take 3 factors. Now number of lags
VARselect(IC_medium$F_pca[, 1:3])

# Estimating the model with 3 factors and 3 lags
dfm_medium = DFM(BM14[, BM14_Models$medium], 3, 3)

# Inspecting the model
summary(dfm_medium)
plot(dfm_medium)  # Factors and data
plot(dfm_medium, method = "all", type = "individual") # Factor estimates
plot(dfm_medium, type = "residual") # Residuals from factor predictions

# 10 periods ahead forecast
plot(predict(dfm_medium), xlim = c(300, 370))


### Large Model ---------------------------------

# IC for number of factors
IC_large = ICr(BM14)
plot(IC_large)
screeplot(IC_large)

# I take 6 factors. Now number of lags
VARselect(IC_large$F_pca[, 1:6])

# Estimating the model with 6 factors and 3 lags
dfm_large = DFM(BM14, 6, 3)

# Inspecting the model
summary(dfm_large)
plot(dfm_large)  # Factors and data
# plot(dfm_large, method = "all", type = "individual") # Factor estimates
plot(dfm_large, type = "residual") # Residuals from factor predictions

# 10 periods ahead forecast
plot(predict(dfm_large), xlim = c(300, 370))

</code></pre>

<hr>
<h2 id='em_converged'>Convergence Test for EM-Algorithm</h2><span id='topic+em_converged'></span>

<h3>Description</h3>

<p>Convergence Test for EM-Algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>em_converged(loglik, previous_loglik, tol = 1e-04, check.increased = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="em_converged_+3A_loglik">loglik</code></td>
<td>
<p>numeric. Current value of the log-likelihood function.</p>
</td></tr>
<tr><td><code id="em_converged_+3A_previous_loglik">previous_loglik</code></td>
<td>
<p>numeric. Value of the log-likelihood function at the previous iteration.</p>
</td></tr>
<tr><td><code id="em_converged_+3A_tol">tol</code></td>
<td>
<p>numerical. The tolerance of the test. If |LL(t) - LL(t-1)| / avg &lt; tol, where avg = (|LL(t)| + |LL(t-1)|)/2, then algorithm has converged.</p>
</td></tr>
<tr><td><code id="em_converged_+3A_check.increased">check.increased</code></td>
<td>
<p>logical. Check if likelihood has increased.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical statement indicating whether EM algorithm has converged. if <code>check.increased = TRUE</code>, a vector with 2 elements indicating the convergence status and whether the likelihood has decreased.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>em_converged(1001, 1000)
em_converged(10001, 10000)
em_converged(10001, 10000, check = TRUE)
em_converged(10000, 10001, check = TRUE)
</code></pre>

<hr>
<h2 id='FIS'>(Fast) Fixed-Interval Smoother (Kalman Smoother)</h2><span id='topic+FIS'></span>

<h3>Description</h3>

<p>(Fast) Fixed-Interval Smoother (Kalman Smoother)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FIS(A, F, F_pred, P, P_pred, F_0 = NULL, P_0 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FIS_+3A_a">A</code></td>
<td>
<p>transition matrix (<code class="reqn">rp \times rp</code>).</p>
</td></tr>
<tr><td><code id="FIS_+3A_f">F</code></td>
<td>
<p>state estimates (<code class="reqn">T \times rp</code>).</p>
</td></tr>
<tr><td><code id="FIS_+3A_f_pred">F_pred</code></td>
<td>
<p>state predicted estimates (<code class="reqn">T \times rp</code>).</p>
</td></tr>
<tr><td><code id="FIS_+3A_p">P</code></td>
<td>
<p>variance estimates (<code class="reqn">rp \times rp \times T</code>).</p>
</td></tr>
<tr><td><code id="FIS_+3A_p_pred">P_pred</code></td>
<td>
<p>predicted variance estimates (<code class="reqn">rp \times rp \times T</code>).</p>
</td></tr>
<tr><td><code id="FIS_+3A_f_0">F_0</code></td>
<td>
<p>initial state vector (<code class="reqn">rp \times 1</code>) or empty (<code>NULL</code>).</p>
</td></tr>
<tr><td><code id="FIS_+3A_p_0">P_0</code></td>
<td>
<p>initial state covariance (<code class="reqn">rp \times rp</code>) or empty (<code>NULL</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Kalman Smoother is given by:
</p>
<p style="text-align: center;"><code class="reqn">\textbf{J}_t = \textbf{P}_t \textbf{A} + inv(\textbf{P}^{pred}_{t+1})</code>
</p>

<p style="text-align: center;"><code class="reqn">\textbf{F}^{smooth}_t = \textbf{F}_t + \textbf{J}_t (\textbf{F}^{smooth}_{t+1} - \textbf{F}^{pred}_{t+1})</code>
</p>

<p style="text-align: center;"><code class="reqn">\textbf{P}^{smooth}_t = \textbf{P}_t + \textbf{J}_t (\textbf{P}^{smooth}_{t+1} - \textbf{P}^{pred}_{t+1}) \textbf{J}_t'</code>
</p>

<p>The initial smoothed values for period t = T are set equal to the filtered values. If <code>F_0</code> and <code>P_0</code> are supplied, the smoothed initial conditions (t = 0 values) are also calculated and returned.
For further details see any textbook on time series such as Shumway &amp; Stoffer (2017), which provide an analogous R implementation in <code>astsa::Ksmooth0</code>.
</p>


<h3>Value</h3>

<p>Smoothed state and covariance estimates, including initial (t = 0) values.
</p>
<table>
<tr><td><code>F_smooth</code></td>
<td>
<p><code class="reqn">T \times rp</code> smoothed state vectors, equal to the filtered state in period <code class="reqn">T</code>.</p>
</td></tr>
<tr><td><code>P_smooth</code></td>
<td>
<p><code class="reqn">rp \times rp \times T</code> smoothed state covariance, equal to the filtered covariance in period <code class="reqn">T</code>.</p>
</td></tr>
<tr><td><code>F_smooth_0</code></td>
<td>
<p><code class="reqn">1 \times rp</code> initial smoothed state vectors, based on <code>F_0</code>.</p>
</td></tr>
<tr><td><code>P_smooth_0</code></td>
<td>
<p><code class="reqn">rp \times rp</code> initial smoothed state covariance, based on <code>P_0</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Shumway, R. H., &amp; Stoffer, D. S. (2017). Time Series Analysis and Its Applications: With R Examples. Springer.
</p>
<p>Harvey, A. C. (1990). Forecasting, structural time series models and the Kalman filter.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SKF">SKF</a></code> <code><a href="#topic+SKFS">SKFS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?SKFS

</code></pre>

<hr>
<h2 id='ICr'>Information Criteria to Determine the Number of Factors (r)</h2><span id='topic+ICr'></span><span id='topic+print.ICr'></span><span id='topic+plot.ICr'></span><span id='topic+screeplot.ICr'></span>

<h3>Description</h3>

<p>Minimizes 3 information criteria proposed by Bai and Ng (2002) to determine the optimal number of factors r* to be used in an approximate factor model.
A Screeplot can also be computed to eyeball the number of factors in the spirit of Onatski (2010).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ICr(X, max.r = min(20, ncol(X) - 1))

## S3 method for class 'ICr'
print(x, ...)

## S3 method for class 'ICr'
plot(x, ...)

## S3 method for class 'ICr'
screeplot(x, type = "pve", show.grid = TRUE, max.r = 30, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ICr_+3A_x">X</code></td>
<td>
<p>a <code>T x n</code> numeric data matrix or frame of stationary time series.</p>
</td></tr>
<tr><td><code id="ICr_+3A_max.r">max.r</code></td>
<td>
<p>integer. The maximum number of factors for which IC should be computed (or eigenvalues to be displayed in the screeplot).</p>
</td></tr>
<tr><td><code id="ICr_+3A_x">x</code></td>
<td>
<p>an object of type 'ICr'.</p>
</td></tr>
<tr><td><code id="ICr_+3A_...">...</code></td>
<td>
<p>further arguments to <code><a href="stats.html#topic+ts.plot">ts.plot</a></code> or <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="ICr_+3A_type">type</code></td>
<td>
<p>character. Either <code>"ev"</code> (eigenvalues), <code>"pve"</code> (percent variance explained), or <code>"cum.pve"</code> (cumulative PVE). Multiple plots can be requested.</p>
</td></tr>
<tr><td><code id="ICr_+3A_show.grid">show.grid</code></td>
<td>
<p>logical. <code>TRUE</code> shows gridlines in each plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following Bai and Ng (2002) and De Valk et al. (2019), let <code class="reqn">NSSR(r)</code> be the normalized sum of squared residuals <code class="reqn">SSR(r) / (n \times T)</code> when r factors are estimated using principal components.
Then the information criteria can be written as follows:
</p>
<p style="text-align: center;"><code class="reqn">IC_{r1} = \ln(NSSR(r)) + r\left(\frac{n + T}{nT}\right) + \ln\left(\frac{nT}{n + T}\right)</code>
</p>

<p style="text-align: center;"><code class="reqn">IC_{r2} = \ln(NSSR(r)) + r\left(\frac{n + T}{nT}\right) + \ln(\min(n, T))</code>
</p>

<p style="text-align: center;"><code class="reqn">IC_{r3} = \ln(NSSR(r)) + r\left(\frac{\ln(\min(n, T))}{\min(n, T)}\right)</code>
</p>

<p>The optimal number of factors r* corresponds to the minimum IC. The three criteria are are asymptotically equivalent, but may give significantly
different results for finite samples. The penalty in <code class="reqn">IC_{r2}</code> is highest in finite samples.
</p>
<p>In the Screeplot a horizontal dashed line is shown signifying an eigenvalue of 1, or a share of variance corresponding to 1 divided by the number of eigenvalues.
</p>


<h3>Value</h3>

<p>A list of 4 elements:
</p>
<table>
<tr><td><code>F_pca</code></td>
<td>
<p><code>T x n</code> matrix of principle component factor estimates.</p>
</td></tr>
<tr><td><code>eigenvalues</code></td>
<td>
<p>the eigenvalues of the covariance matrix of <code>X</code>.</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p><code>r.max x 3</code> 'table' containing the 3 information criteria of Bai and Ng (2002), computed for all values of <code>r</code> from <code>1:r.max</code>.</p>
</td></tr>
<tr><td><code>r.star</code></td>
<td>
<p>vector of length 3 containing the number of factors (<code>r</code>) minimizing each information criterion.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>To determine the number of lags (<code>p</code>) in the factor transition equation, use the function <code>vars::VARselect</code> with r* principle components (also returned by <code>ICr</code>).
</p>


<h3>References</h3>

<p>Bai, J., Ng, S. (2002). Determining the Number of Factors in Approximate Factor Models. <em>Econometrica, 70</em>(1), 191-221. doi: <a href="https://doi.org/10.1111/1468-0262.00273">10.1111/1468-0262.00273</a>
</p>
<p>Onatski, A. (2010). Determining the number of factors from empirical distribution of eigenvalues. <em>The Review of Economics and Statistics, 92</em>(4), 1004-1016.
</p>
<p>De Valk, S., de Mattos, D., &amp; Ferreira, P. (2019). Nowcasting: An R package for predicting economic variables using dynamic factor models. <em>The R Journal, 11</em>(1), 230-244.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(xts)
library(vars)

ics = ICr(diff(BM14_M))
print(ics)
plot(ics)
screeplot(ics)

# Optimal lag-order with 6 factors chosen
VARselect(ics$F_pca[, 1:6])

</code></pre>

<hr>
<h2 id='plot.dfm'>Plot DFM</h2><span id='topic+plot.dfm'></span><span id='topic+screeplot.dfm'></span>

<h3>Description</h3>

<p>Plot DFM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfm'
plot(
  x,
  method = switch(x$em.method, none = "2s", "qml"),
  type = c("joint", "individual", "residual"),
  scale.factors = TRUE,
  ...
)

## S3 method for class 'dfm'
screeplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.dfm_+3A_x">x</code></td>
<td>
<p>an object class 'dfm'.</p>
</td></tr>
<tr><td><code id="plot.dfm_+3A_method">method</code></td>
<td>
<p>character. The factor estimates to use: one of <code>"qml"</code>, <code>"2s"</code>, <code>"pca"</code> or <code>"all"</code> to plot all estimates.</p>
</td></tr>
<tr><td><code id="plot.dfm_+3A_type">type</code></td>
<td>
<p>character. The type of plot: <code>"joint"</code>, <code>"individual"</code> or <code>"residual"</code>.</p>
</td></tr>
<tr><td><code id="plot.dfm_+3A_scale.factors">scale.factors</code></td>
<td>
<p>logical. Standardize factor estimates, this usually improves the plot since the factor estimates corresponding to the greatest PCA eigenvalues tend to have a greater variance than the data.</p>
</td></tr>
<tr><td><code id="plot.dfm_+3A_...">...</code></td>
<td>
<p>for <code>plot.dfm</code>: further arguments to <code><a href="graphics.html#topic+plot">plot</a></code>, <code><a href="stats.html#topic+ts.plot">ts.plot</a></code>, or <code><a href="graphics.html#topic+boxplot">boxplot</a></code>, depending on the <code>type</code> of plot. For <code>screeplot.dfm</code>: further arguments to <code><a href="#topic+screeplot.ICr">screeplot.ICr</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit DFM with 3 factors and 3 lags in the transition equation
mod = DFM(diff(BM14_M), r = 3, p = 3)
plot(mod)
plot(mod, type = "individual", method = "all")
plot(mod, type = "residual")


</code></pre>

<hr>
<h2 id='predict.dfm'>DFM Forecasts</h2><span id='topic+predict.dfm'></span><span id='topic+print.dfm_forecast'></span><span id='topic+plot.dfm_forecast'></span><span id='topic+as.data.frame.dfm_forecast'></span>

<h3>Description</h3>

<p>This function produces h-step ahead forecasts of both the factors and the data,
with an option to also forecast autocorrelated residuals with a univariate method and produce a combined forecast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfm'
predict(
  object,
  h = 10L,
  method = switch(object$em.method, none = "2s", "qml"),
  standardized = TRUE,
  resFUN = NULL,
  resAC = 0.1,
  ...
)

## S3 method for class 'dfm_forecast'
print(x, digits = 4L, ...)

## S3 method for class 'dfm_forecast'
plot(
  x,
  main = paste(x$h, "Period Ahead DFM Forecast"),
  xlab = "Time",
  ylab = "Standardized Data",
  factors = seq_len(ncol(x$F)),
  scale.factors = TRUE,
  factor.col = rainbow(length(factors)),
  factor.lwd = 1.5,
  fcst.lty = "dashed",
  data.col = c("grey85", "grey65"),
  legend = TRUE,
  legend.items = paste0("f", factors),
  grid = FALSE,
  vline = TRUE,
  vline.lty = "dotted",
  vline.col = "black",
  ...
)

## S3 method for class 'dfm_forecast'
as.data.frame(
  x,
  ...,
  use = c("factors", "data", "both"),
  pivot = c("long", "wide"),
  time = seq_len(nrow(x$F) + x$h),
  stringsAsFactors = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.dfm_+3A_object">object</code></td>
<td>
<p>an object of class 'dfm'.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_h">h</code></td>
<td>
<p>integer. The forecast horizon.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_method">method</code></td>
<td>
<p>character. The factor estimates to use: one of <code>"qml"</code>, <code>"2s"</code> or <code>"pca"</code>.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_standardized">standardized</code></td>
<td>
<p>logical. <code>FALSE</code> will return data forecasts on the original scale.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_resfun">resFUN</code></td>
<td>
<p>an (optional) function to compute a univariate forecast of the residuals.
The function needs to have a second argument providing the forecast horizon (<code>h</code>) and return a vector or forecasts. See Examples.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_resac">resAC</code></td>
<td>
<p>numeric. Threshold for residual autocorrelation to apply <code>resFUN</code>: only residual series where AC1 &gt; resAC will be forecasted.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_x">x</code></td>
<td>
<p>an object class 'dfm_forecast'.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_digits">digits</code></td>
<td>
<p>integer. The number of digits to print out.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_main">main</code>, <code id="predict.dfm_+3A_xlab">xlab</code>, <code id="predict.dfm_+3A_ylab">ylab</code></td>
<td>
<p>character. Graphical parameters passed to <code><a href="stats.html#topic+ts.plot">ts.plot</a></code>.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_factors">factors</code></td>
<td>
<p>integers indicating which factors to display. Setting this to <code>NA</code>, <code>NULL</code> or <code>0</code> will omit factor plots.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_scale.factors">scale.factors</code></td>
<td>
<p>logical. Standardize factor estimates, this usually improves the plot since the factor estimates corresponding to the greatest PCA eigenvalues tend to have a greater variance than the data.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_factor.col">factor.col</code>, <code id="predict.dfm_+3A_factor.lwd">factor.lwd</code></td>
<td>
<p>graphical parameters affecting the colour and line width of factor estimates plots. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_fcst.lty">fcst.lty</code></td>
<td>
<p>integer or character giving the line type of the forecasts of factors and data. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_data.col">data.col</code></td>
<td>
<p>character vector of length 2 indicating the colours of historical data and forecasts of that data. Setting this to <code>NA</code>, <code>NULL</code> or <code>""</code> will not plot data and data forecasts.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_legend">legend</code></td>
<td>
<p>logical. <code>TRUE</code> draws a legend in the top-left of the chart.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_legend.items">legend.items</code></td>
<td>
<p>character names of factors for the legend.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_grid">grid</code></td>
<td>
<p>logical. <code>TRUE</code> draws a grid on the background of the plot.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_vline">vline</code></td>
<td>
<p>logical. <code>TRUE</code> draws a vertical line deliminating historical data and forecasts.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_vline.lty">vline.lty</code>, <code id="predict.dfm_+3A_vline.col">vline.col</code></td>
<td>
<p>graphical parameters affecting the appearance of the vertical line. See <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_use">use</code></td>
<td>
<p>character. Which forecasts to use <code>"factors"</code>, <code>"data"</code> or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_pivot">pivot</code></td>
<td>
<p>character. The orientation of the frame: <code>"long"</code> or <code>"wide"</code>.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_time">time</code></td>
<td>
<p>a vector identifying the time dimension, must be of length T + h, or <code>NULL</code> to omit a time variable.</p>
</td></tr>
<tr><td><code id="predict.dfm_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical. If <code>TRUE</code> and <code>pivot = "long"</code> the 'Variable' column is created as a factor. Same as option to <code><a href="base.html#topic+as.data.frame.table">as.data.frame.table</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list-like object of class 'dfm_forecast' with the following elements:
</p>
<table>
<tr><td><code>X_fcst</code></td>
<td>
<p><code class="reqn">h \times n</code> matrix with the forecasts of the variables. </p>
</td></tr>
<tr><td><code>F_fcst</code></td>
<td>
<p><code class="reqn">h \times r</code> matrix with the factor forecasts. </p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p><code class="reqn">T \times n</code> matrix with the standardized (scaled and centered) data - with attributes attached allowing reconstruction of the original data:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>"stats"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> is a <code class="reqn">n \times 5</code> matrix of summary statistics of class <code>"qsu"</code> (see <code><a href="collapse.html#topic+qsu">qsu</a></code>). Only attached if <code>standardized = TRUE</code>. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"attributes"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> contains the <code><a href="base.html#topic+attributes">attributes</a></code> of the original data input.</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"is.list"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> is a logical value indicating whether the original data input was a list / data frame. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

</td></tr>
<tr><td><code>F</code></td>
<td>
<p><code class="reqn">T \times r</code> matrix of factor estimates. </p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the factor estimation method used.</p>
</td></tr>
<tr><td><code>anyNA</code></td>
<td>
<p>logical indicating whether <code>X</code> contains any missing values.</p>
</td></tr>
<tr><td><code>h</code></td>
<td>
<p>the forecast horizon.</p>
</td></tr>
<tr><td><code>resid.fc</code></td>
<td>
<p>logical indicating whether a univariate forecasting function was applied to the residuals.</p>
</td></tr>
<tr><td><code>resid.fc.ind</code></td>
<td>
<p>indices indicating for which variables (columns of <code>X</code>) the residuals were forecasted using the univariate function.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>call object obtained from <code>match.call()</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
library(xts)
library(collapse)

# Fit DFM with 3 factors and 3 lags in the transition equation
mod = DFM(diff(BM14_M), r = 3, p = 3)

# 15 period ahead forecast
fc = predict(mod, h = 15)
print(fc)
plot(fc, xlim = c(300, 370))

# Also forecasting autocorrelated residuals with an AR(1)
fcfun &lt;- function(x, h) predict(ar(na_rm(x)), n.ahead = h)$pred
fcar = predict(mod, resFUN = fcfun, h = 15)
plot(fcar, xlim = c(300, 370))

# Retrieving a data frame of the forecasts
head(as.data.frame(fcar, pivot = "wide")) # Factors
head(as.data.frame(fcar, use = "data"))   # Data
head(as.data.frame(fcar, use = "both"))   # Both

</code></pre>

<hr>
<h2 id='residuals.dfm'>DFM Residuals and Fitted Values</h2><span id='topic+residuals.dfm'></span><span id='topic+resid.dfm'></span><span id='topic+fitted.dfm'></span>

<h3>Description</h3>

<p>The residuals <code class="reqn">\textbf{e}_t = \textbf{x}_t - \textbf{C} \textbf{F}_t</code> or fitted values <code class="reqn">\textbf{C} \textbf{F}_t</code> of the DFM observation equation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfm'
residuals(
  object,
  method = switch(object$em.method, none = "2s", "qml"),
  orig.format = FALSE,
  standardized = FALSE,
  na.keep = TRUE,
  ...
)

## S3 method for class 'dfm'
fitted(
  object,
  method = switch(object$em.method, none = "2s", "qml"),
  orig.format = FALSE,
  standardized = FALSE,
  na.keep = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.dfm_+3A_object">object</code></td>
<td>
<p>an object of class 'dfm'.</p>
</td></tr>
<tr><td><code id="residuals.dfm_+3A_method">method</code></td>
<td>
<p>character. The factor estimates to use: one of <code>"qml"</code>, <code>"2s"</code> or <code>"pca"</code>.</p>
</td></tr>
<tr><td><code id="residuals.dfm_+3A_orig.format">orig.format</code></td>
<td>
<p>logical. <code>TRUE</code> returns residuals/fitted values in a data format similar to <code>X</code>.</p>
</td></tr>
<tr><td><code id="residuals.dfm_+3A_standardized">standardized</code></td>
<td>
<p>logical. <code>FALSE</code> will put residuals/fitted values on the original data scale.</p>
</td></tr>
<tr><td><code id="residuals.dfm_+3A_na.keep">na.keep</code></td>
<td>
<p>logical. <code>TRUE</code> inserts missing values where <code>X</code> is missing (default <code>TRUE</code> as residuals/fitted values are only defined for observed data). <code>FALSE</code> returns the raw prediction, which can be used to interpolate data based on the DFM. For residuals, <code>FALSE</code> returns the difference between the prediction and the initial imputed version of <code>X</code> use for PCA to initialize the Kalman Filter.</p>
</td></tr>
<tr><td><code id="residuals.dfm_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of DFM residuals or fitted values. If <code>orig.format = TRUE</code> the format may be different, e.g. a data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(xts)
# Fit DFM with 3 factors and 3 lags in the transition equation
mod = DFM(diff(BM14_M), r = 3, p = 3)

# Residuals
head(resid(mod))
plot(resid(mod, orig.format = TRUE)) # this is an xts object

# Fitted values
head(fitted(mod))
head(fitted(mod, orig.format = TRUE)) # this is an xts object


</code></pre>

<hr>
<h2 id='SKF'>(Fast) Stationary Kalman Filter</h2><span id='topic+SKF'></span>

<h3>Description</h3>

<p>A simple and fast C++ implementation of the Kalman Filter for stationary data with time-invariant system matrices and missing data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SKF(X, A, C, Q, R, F_0, P_0, loglik = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SKF_+3A_x">X</code></td>
<td>
<p>numeric data matrix (<code class="reqn">T \times n</code>).</p>
</td></tr>
<tr><td><code id="SKF_+3A_a">A</code></td>
<td>
<p>transition matrix (<code class="reqn">rp \times rp</code>).</p>
</td></tr>
<tr><td><code id="SKF_+3A_c">C</code></td>
<td>
<p>observation matrix (<code class="reqn">n \times rp</code>).</p>
</td></tr>
<tr><td><code id="SKF_+3A_q">Q</code></td>
<td>
<p>state covariance (<code class="reqn">rp \times rp</code>).</p>
</td></tr>
<tr><td><code id="SKF_+3A_r">R</code></td>
<td>
<p>observation covariance (<code class="reqn">n \times n</code>).</p>
</td></tr>
<tr><td><code id="SKF_+3A_f_0">F_0</code></td>
<td>
<p>initial state vector (<code class="reqn">rp \times 1</code>).</p>
</td></tr>
<tr><td><code id="SKF_+3A_p_0">P_0</code></td>
<td>
<p>initial state covariance (<code class="reqn">rp \times rp</code>).</p>
</td></tr>
<tr><td><code id="SKF_+3A_loglik">loglik</code></td>
<td>
<p>logical. Compute log-likelihood?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The underlying state space model is:
</p>
<p style="text-align: center;"><code class="reqn">\textbf{x}_t = \textbf{C} \textbf{F}_t + \textbf{e}_t \sim N(\textbf{0}, \textbf{R})</code>
</p>

<p style="text-align: center;"><code class="reqn">\textbf{F}_t = \textbf{A F}_{t-1} + \textbf{u}_t \sim N(\textbf{0}, \textbf{Q})</code>
</p>

<p>where <code class="reqn">x_t</code> is <code>X[t, ]</code>. The filter then first performs a time update (prediction)
</p>
<p style="text-align: center;"><code class="reqn">\textbf{F}_t = \textbf{A F}_{t-1}</code>
</p>

<p style="text-align: center;"><code class="reqn">\textbf{P}_t = \textbf{A P}_{t-1}\textbf{A}' + \textbf{Q}</code>
</p>

<p>where <code class="reqn">P_t = Cov(F_t)</code>. This is followed by the measurement update (filtering)
</p>
<p style="text-align: center;"><code class="reqn">\textbf{K}_t = \textbf{P}_t \textbf{C}' (\textbf{C P}_t \textbf{C}' + \textbf{R})^{-1}</code>
</p>

<p style="text-align: center;"><code class="reqn">\textbf{F}_t = \textbf{F}_t + \textbf{K}_t (\textbf{x}_t - \textbf{C F}_t)</code>
</p>

<p style="text-align: center;"><code class="reqn">\textbf{P}_t = \textbf{P}_t - \textbf{K}_t\textbf{C P}_t</code>
</p>

<p>If a row of the data is all missing the measurement update is skipped i.e. the prediction becomes the filtered value. The log-likelihood is
computed as
</p>
<p style="text-align: center;"><code class="reqn">1/2 \sum_t \log(|St|)-e_t'S_te_t-n\log(2\pi)</code>
</p>

<p>where <code class="reqn">S_t = (C P_t C' + R)^{-1}</code> and <code class="reqn">e_t = x_t - C F_t</code> is the prediction error.
</p>
<p>For further details see any textbook on time series such as Shumway &amp; Stoffer (2017), which provide an analogous R implementation in <code>astsa::Kfilter0</code>.
For another fast (C-based) implementation that also allows time-varying system matrices and non-stationary data see <code>FKF::fkf</code>.
</p>


<h3>Value</h3>

<p>Predicted and filtered state vectors and covariances.
</p>
<table>
<tr><td><code>F</code></td>
<td>
<p><code class="reqn">T \times rp</code> filtered state vectors. </p>
</td></tr>
<tr><td><code>P</code></td>
<td>
<p><code class="reqn">rp \times rp \times T</code> filtered state covariances. </p>
</td></tr>
<tr><td><code>F_pred</code></td>
<td>
<p><code class="reqn">T \times rp</code> predicted state vectors. </p>
</td></tr>
<tr><td><code>P_pred</code></td>
<td>
<p><code class="reqn">rp \times rp \times T</code> predicted state covariances. </p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>value of the log likelihood. </p>
</td></tr>
</table>


<h3>References</h3>

<p>Shumway, R. H., &amp; Stoffer, D. S. (2017). Time Series Analysis and Its Applications: With R Examples. Springer.
</p>
<p>Harvey, A. C. (1990). Forecasting, structural time series models and the Kalman filter.
</p>
<p>Hamilton, J. D. (1994). Time Series Analysis. Princeton university press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FIS">FIS</a></code> <code><a href="#topic+SKFS">SKFS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See ?SKFS

</code></pre>

<hr>
<h2 id='SKFS'>(Fast) Stationary Kalman Filter and Smoother</h2><span id='topic+SKFS'></span>

<h3>Description</h3>

<p>(Fast) Stationary Kalman Filter and Smoother
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SKFS(X, A, C, Q, R, F_0, P_0, loglik = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SKFS_+3A_x">X</code></td>
<td>
<p>numeric data matrix (<code class="reqn">T \times n</code>).</p>
</td></tr>
<tr><td><code id="SKFS_+3A_a">A</code></td>
<td>
<p>transition matrix (<code class="reqn">rp \times rp</code>).</p>
</td></tr>
<tr><td><code id="SKFS_+3A_c">C</code></td>
<td>
<p>observation matrix (<code class="reqn">n \times rp</code>).</p>
</td></tr>
<tr><td><code id="SKFS_+3A_q">Q</code></td>
<td>
<p>state covariance (<code class="reqn">rp \times rp</code>).</p>
</td></tr>
<tr><td><code id="SKFS_+3A_r">R</code></td>
<td>
<p>observation covariance (<code class="reqn">n \times n</code>).</p>
</td></tr>
<tr><td><code id="SKFS_+3A_f_0">F_0</code></td>
<td>
<p>initial state vector (<code class="reqn">rp \times 1</code>).</p>
</td></tr>
<tr><td><code id="SKFS_+3A_p_0">P_0</code></td>
<td>
<p>initial state covariance (<code class="reqn">rp \times rp</code>).</p>
</td></tr>
<tr><td><code id="SKFS_+3A_loglik">loglik</code></td>
<td>
<p>logical. Compute log-likelihood?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>All results from <code><a href="#topic+SKF">SKF</a></code> and <code><a href="#topic+FIS">FIS</a></code>, and additionally
a <code class="reqn">rp \times rp \times T</code> matrix <code>PPm_smooth</code>, which is equal to the estimate of <code class="reqn">Cov(F^smooth_t, F^smooth_{t-1} | T)</code> and needed for EM iterations.
See 'Property 6.3: The Lag-One Covariance Smoother' in Shumway &amp; Stoffer (2017).
</p>


<h3>References</h3>

<p>Shumway, R. H., &amp; Stoffer, D. S. (2017). Time Series Analysis and Its Applications: With R Examples. Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SKF">SKF</a></code> <code><a href="#topic+FIS">FIS</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(collapse)

## Two-Step factor estimates from monthly BM (2014) data
X &lt;- fscale(diff(qM(BM14_M))) # Standardizing as KF has no intercept
r &lt;- 5L # 5 Factors
p &lt;- 3L # 3 Lags
n &lt;- ncol(X)

## Initializing the Kalman Filter with PCA results
X_imp &lt;- tsnarmimp(X)                 # Imputing Data
v &lt;- eigen(cov(X_imp))$vectors[, 1:r] # PCA
F_pc &lt;- X_imp %*% v                   # Principal component factor estimates
C &lt;- cbind(v, matrix(0, n, r*p-r))    # Observation matrix
res &lt;- X - tcrossprod(F_pc, v)        # Residuals from static predictions
R &lt;- diag(fvar(res))                  # Observation residual covariance
var &lt;- .VAR(F_pc, p)                  # VAR(p)
A &lt;- rbind(t(var$A), diag(1, r*p-r, r*p))
Q &lt;- matrix(0, r*p, r*p)              # VAR residual matrix
Q[1:r, 1:r] &lt;- cov(var$res)
F_0 &lt;- var$X[1L, ]                    # Initial factor estimate and covariance
P_0 &lt;- ainv(diag((r*p)^2) - kronecker(A,A)) %*% unattrib(Q)
dim(P_0) &lt;- c(r*p, r*p)

## Run standartized data through Kalman Filter and Smoother once
kfs_res &lt;- SKFS(X, A, C, Q, R, F_0, P_0, FALSE)

## Two-step solution is state mean from the Kalman Smoother
F_kal &lt;- kfs_res$F_smooth[, 1:r, drop = FALSE]
colnames(F_kal) &lt;- paste0("f", 1:r)

## See that this is equal to the Two-Step estimate by DFM()
all.equal(F_kal, DFM(X, r, p, em.method = "none", pos.corr = FALSE)$F_2s)

## Same in two steps using SKF() and FIS()
kfs_res2 &lt;- with(SKF(X, A, C, Q, R, F_0, P_0, FALSE), FIS(A, F, F_pred, P, P_pred))
F_kal2 &lt;- kfs_res2$F_smooth[, 1:r, drop = FALSE]
colnames(F_kal2) &lt;- paste0("f", 1:r)
all.equal(F_kal, F_kal2)

rm(X, r, p, n, X_imp, v, F_pc, C, res, R, var, A, Q, F_0, P_0, kfs_res, F_kal, kfs_res2, F_kal2)

</code></pre>

<hr>
<h2 id='summary.dfm'>DFM Summary Methods</h2><span id='topic+summary.dfm'></span><span id='topic+print.dfm'></span><span id='topic+print.dfm_summary'></span>

<h3>Description</h3>

<p>Summary and print methods for class 'dfm'. <code>print.dfm</code> just prints basic model information and the factor transition matrix <code class="reqn">\textbf{A}</code>,
<code>summary.dfm</code> returns all system matrices and additional residual and goodness of fit statistics - with a print method allowing full or compact printout.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'dfm'
print(x, digits = 4L, ...)

## S3 method for class 'dfm'
summary(object, method = switch(object$em.method, none = "2s", "qml"), ...)

## S3 method for class 'dfm_summary'
print(x, digits = 4L, compact = sum(x$info["n"] &gt; 15, x$info["n"] &gt; 40), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.dfm_+3A_x">x</code>, <code id="summary.dfm_+3A_object">object</code></td>
<td>
<p>an object class 'dfm'.</p>
</td></tr>
<tr><td><code id="summary.dfm_+3A_digits">digits</code></td>
<td>
<p>integer. The number of digits to print out.</p>
</td></tr>
<tr><td><code id="summary.dfm_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="summary.dfm_+3A_method">method</code></td>
<td>
<p>character. The factor estimates to use: one of <code>"qml"</code>, <code>"2s"</code> or <code>"pca"</code>.</p>
</td></tr>
<tr><td><code id="summary.dfm_+3A_compact">compact</code></td>
<td>
<p>integer. Display a more compact printout: <code>0</code> prints everything, <code>1</code> omits the observation matrix <code class="reqn">\textbf{C}</code> and residual covariance matrix <code>cov(resid(model))</code>, and <code>2</code> omits all disaggregated information on the input data. Sensible default are chosen for different sizes of the input dataset so as to limit large printouts.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary information following a dynamic factor model estimation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod = DFM(diff(BM14_Q), 2, 3)
print(mod)
summary(mod)

</code></pre>

<hr>
<h2 id='tsnarmimp'>Remove and Impute Missing Values in a Multivariate Time Series</h2><span id='topic+tsnarmimp'></span>

<h3>Description</h3>

<p>This function imputes missing values in a stationary multivariate time series using various
methods, and removes cases with too many missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsnarmimp(
  X,
  max.missing = 0.8,
  na.rm.method = c("LE", "all"),
  na.impute = c("median.ma.spline", "median.ma", "median", "rnorm"),
  ma.terms = 3L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsnarmimp_+3A_x">X</code></td>
<td>
<p>a <code>T x n</code> numeric data matrix (incl. ts or xts objects) or data frame of stationary time series.</p>
</td></tr>
<tr><td><code id="tsnarmimp_+3A_max.missing">max.missing</code></td>
<td>
<p>numeric. Proportion of series missing for a case to be considered missing.</p>
</td></tr>
<tr><td><code id="tsnarmimp_+3A_na.rm.method">na.rm.method</code></td>
<td>
<p>character. Method to apply concerning missing cases selected through <code>max.missing</code>: <code>"LE"</code> only removes cases at the beginning or end of the sample, whereas <code>"all"</code> always removes missing cases.</p>
</td></tr>
<tr><td><code id="tsnarmimp_+3A_na.impute">na.impute</code></td>
<td>
<p>character. Method to impute missing values for the PCA estimates used to initialize the EM algorithm. Note that data are standardized (scaled and centered) beforehand. Available options are:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>"median"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> simple series-wise median imputation. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"rnorm"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> imputation with random numbers drawn from a standard normal distribution. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"median.ma"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> values are initially imputed with the median, but then a moving average is applied to smooth the estimates. </td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
<code>"median.ma.spline"</code> </td><td style="text-align: left;"></td><td style="text-align: left;"> "internal" missing values (not at the beginning or end of the sample) are imputed using a cubic spline, whereas missing values at the beginning and end are imputed with the median of the series and smoothed with a moving average.</td>
</tr>
<tr>
 <td style="text-align: left;"></td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>
</td></tr>
<tr><td><code id="tsnarmimp_+3A_ma.terms">ma.terms</code></td>
<td>
<p>the order of the (2-sided) moving average applied in <code>na.impute</code> methods <code>"median.ma"</code> and <code>"median.ma.spline"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The imputed matrix <code>X_imp</code>, with attributes:
</p>
<table>
<tr><td><code>"missing"</code></td>
<td>
<p>a missingness matrix <code>W</code> matching the dimensions of <code>X_imp</code>. </p>
</td></tr>
<tr><td><code>"rm.rows"</code></td>
<td>
<p>and a vector of indices of rows (cases) with too many missing values that were removed. </p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>library(xts)
str(tsnarmimp(BM14_M))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
