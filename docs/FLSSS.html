<!DOCTYPE html><html><head><title>Help for package FLSSS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {FLSSS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#addNumStrings'>
<p>Add numeric strings.</p></a></li>
<li><a href='#arbFLSSS'>
<p>Multidimensional exact subset sum in arbitrary precision and magnitude</p></a></li>
<li><a href='#arbFLSSSobjRun'>
<p>Run an <code>arbFLSSS</code> instance</p></a></li>
<li><a href='#auxGAPbb'>
<p>Multithreaded generalized assignment problem solver via branch and bound</p></a></li>
<li><a href='#auxGAPbbDp'>
<p>Multithreaded generalized assignment problem solver via a hybrid of branch-and-bound and dynamic programming.</p></a></li>
<li><a href='#auxGAPga'>
<p>Multithreaded generalized assignment problem solver via genetic algorithm</p></a></li>
<li><a href='#auxKnapsack01bb'>
<p>Multithreaded binary knapsack problem solver via branch and bound</p></a></li>
<li><a href='#auxKnapsack01dp'>
<p>Multithreaded binary knapsack problem solver via dynamic programming</p></a></li>
<li><a href='#decomposeArbFLSSS'>
<p>arbFLSSS decomposition</p></a></li>
<li><a href='#decomposeMflsss'>
<p>mFLSSS decomposition</p></a></li>
<li><a href='#FLSSS'>
<p>One-dimensional Subset Sum given error threshold</p></a></li>
<li><a href='#FLSSSmultiset'>
<p>Multi-Subset Sum given error threshold</p></a></li>
<li><a href='#GAP'>
<p>Generalized Assignment Problem solver</p></a></li>
<li><a href='#ksumHash'>
<p>Build k-sum accelerator</p></a></li>
<li><a href='#mFLSSSobjRun'>
<p>Run an <code>mFLSSS</code> instance</p></a></li>
<li><a href='#mFLSSSpar'>
<p>Multithreaded multidimensional Subset Sum given error thresholds</p></a></li>
<li><a href='#mFLSSSparImposeBounds'>
<p>Multithreaded multidimensional Subset Sum in bounded solution space given error thresholds</p></a></li>
<li><a href='#mFLSSSparImposeBoundsIntegerized'>
<p>An advanced version of <code>mFLSSSparImposeBounds()</code></p></a></li>
<li><a href='#mFLSSSparIntegerized'>
<p>An advanced version of <code>mFLSSSpar()</code></p></a></li>
<li><a href='#mmKnapsack'>
<p>Multithreaded multidimensional Knapsack problem solver</p></a></li>
<li><a href='#mmKnapsackIntegerized'>
<p>An advanced version of <code>mmKnapsack()</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mining Rigs for Problems in the Subset Sum Family</td>
</tr>
<tr>
<td>Version:</td>
<td>9.1.3</td>
</tr>
<tr>
<td>Author:</td>
<td>Charlie Wusuo Liu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Charlie Wusuo Liu &lt;liuwusuo@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Specialized solvers for combinatorial optimization problems in the Subset Sum family. The solvers differ from the mainstream in the options of (i) restricting subset size, (ii) bounding subset elements, (iii) mining real-value multisets with predefined subset sum errors, (iv) finding one or more subsets in limited time. A novel algorithm for mining the one-dimensional Subset Sum induced algorithms for the multi-Subset Sum and the multidimensional Subset Sum. The multi-threaded framework for the latter offers exact algorithms to the multidimensional Knapsack and the Generalized Assignment problems. Historical updates include (a) renewed implementation of the multi-Subset Sum, multidimensional Knapsack and Generalized Assignment solvers; (b) availability of bounding solution space in the multidimensional Subset Sum; (c) fundamental data structure and architectural changes for enhanced cache locality and better chance of SIMD vectorization; (d) option of mapping floating-point instance to compressed 64-bit integer instance with user-controlled precision loss, which could yield substantial speedup due to the dimension reduction and efficient compressed integer arithmetic via bit-manipulations; (e) distributed computing infrastructure for multidimensional subset sum; (f) arbitrary-precision zero-margin-of-error multidimensional Subset Sum accelerated by a simplified Bloom filter. The package contains a copy of xxHash from <a href="https://github.com/Cyan4973/xxHash">https://github.com/Cyan4973/xxHash</a>. Package vignette (&lt;<a href="https://arxiv.org/abs/1612.04484v3">arXiv:1612.04484v3</a>&gt;) detailed a few historical updates. Functions prefixed with 'aux' (auxiliary) are independent implementations of published algorithms for solving optimization problems less relevant to Subset Sum.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.13), RcppParallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-23 20:58:10 UTC; i56087</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-23 21:40:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='addNumStrings'>
Add numeric strings.
</h2><span id='topic+addNumStrings'></span>

<h3>Description</h3>

<p>A test function for adding numeric strings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addNumStrings(s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addNumStrings_+3A_s">s</code></td>
<td>

<p>A vector of numeric strings.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric string.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>addNumStrings(c("1.2345345", "-0.34534", "3.1415900"))
</code></pre>

<hr>
<h2 id='arbFLSSS'>
Multidimensional exact subset sum in arbitrary precision and magnitude
</h2><span id='topic+arbFLSSS'></span>

<h3>Description</h3>

<p>Given a multidimensional set and a subset size, find one or more subsets whose elements sum up to a given target.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arbFLSSS(
  len,
  V,
  target,
  givenKsumTable,
  solutionNeed = 1L,
  maxCore = 7L,
  tlimit = 60,
  approxNinstance = 1000L,
  ksumK = 4L,
  ksumTableSizeScaler = 30L,
  verbose = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arbFLSSS_+3A_len">len</code></td>
<td>

<p>An integer as the subset size. <code>1 &lt;= len &lt;= nrow(V)</code>.
</p>
</td></tr>
<tr><td><code id="arbFLSSS_+3A_v">V</code></td>
<td>

<p>A string matrix as the superset. Rows are elements.
</p>
</td></tr>
<tr><td><code id="arbFLSSS_+3A_target">target</code></td>
<td>

<p>A string vector as the target subset sum. <code>length(target) == ncol(V)</code>.
</p>
</td></tr>
<tr><td><code id="arbFLSSS_+3A_givenksumtable">givenKsumTable</code></td>
<td>

<p>Either <code>NULL</code> or the return value from <code>ksumHash()</code>. See argument <code>ksumK</code> for the preliminaries. If <code>NULL</code>, the function will compute and hash k-sums depending on <code>ksumK</code> before mining the subsets. Otherwise it will use <code>givenKsumTable</code> as the lookup table and ignore arguments <code>ksumK</code> and <code>ksumTableSizeScaler</code>.
</p>
</td></tr>
<tr><td><code id="arbFLSSS_+3A_solutionneed">solutionNeed</code></td>
<td>

<p>An integer. How many solutions are wanted. Default <code>solutionNeed = 1</code>.
</p>
</td></tr>
<tr><td><code id="arbFLSSS_+3A_maxcore">maxCore</code></td>
<td>

<p>An integer as the maximum threads to invoke. Better not exceed the number of logical processors on the platform. Default <code>maxCore = 7</code>.
</p>
</td></tr>
<tr><td><code id="arbFLSSS_+3A_tlimit">tlimit</code></td>
<td>

<p>A numeric value as the time limit (seconds). Default <code>tlimit = 60</code>.
</p>
</td></tr>
<tr><td><code id="arbFLSSS_+3A_approxninstance">approxNinstance</code></td>
<td>

<p>An integer. The problem will be decomposed into about <code>approxNinstance</code> subproblems solved independently by the threads. Default <code>approxNinstance = 1000</code>. <code>approxNinstance</code> is better to be much higher than argument <code>maxCore</code> since time costs of the subproblems are unknown and probably vary greatly.
</p>
</td></tr>
<tr><td><code id="arbFLSSS_+3A_ksumk">ksumK</code></td>
<td>

<p>An integer. If <code>ksumK &lt; 3</code>, no k-sum accelerator will be built. For example, if <code>ksumK = 5</code>, then the sums of all combinations of 3 elements (3-sums), the sums of all combinations of 4 elements (4-sums), and the sums of all combinations of 5 elements (5-sums) in <code>V</code>, are pre-computed and hashed into a Bloom filter variant. This filter thus contains 3 lookup tables responding to the 3-sums, 4-sums and 5-sums. During the main course of mining, if any set is reduced to one of size 3, 4, or 5, the set's associated target sum will be hashed and looked up in the filter. Not existing would imply the target sum is unreachable and the set can be discredited immediately. This typically generates massive speedup. For <code>ksumK &lt; 3</code>, such filtering is not meaningful and thus not performed. A high <code>ksumK</code> coupled with a large superset <code>V</code> however is prone to memory overflow or extremely time consuming. <code>ksumK</code> will be upper-bounded by subset size <code>len</code> internally. Default <code>ksumK = 4</code>.
</p>
</td></tr>
<tr><td><code id="arbFLSSS_+3A_ksumtablesizescaler">ksumTableSizeScaler</code></td>
<td>

<p>An integer for determining size of the k-sum lookup table in the filter described above. For example, a set of size 21 has 1330 3-element subsets. If <code>ksumTableSizeScaler = 10</code>, then around 13300 bits will be allocated for the 3-sum lookup table. The exact number of bits is 14033 + 7, where 14033 is the lowest element greater than 13300 in a prime array defined in GCC's STL of hashing policy, and 7 is to make up the last byte. Default  <code>ksumTableSizeScaler = 30</code>. Higher <code>ksumTableSizeScaler</code> means lower chance of hash collision, thus higher efficiency.
</p>
</td></tr>
<tr><td><code id="arbFLSSS_+3A_verbose">verbose</code></td>
<td>

<p>A boolean value. <code>TRUE</code> prints the computing progress. Default <code>TRUE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>New users might want to check out <code>FLSSS()</code> or <code>mFLSSSpar()</code> first.
</p>
<p>String matrix <code>V</code> is maximally compressed into an integer set of size <code>nrow(V)</code>. Dimensionality of the set will be printed given <code>verbose = TRUE</code>. Each set element is a huge integer comprising many 64-bit buffers. Addition and subtraction of the huge integers call <code>mpn_add_n()</code> and <code>mpn_sub_n()</code> from the GNU Multiple Precision Arithmetic Library (GMP) if the system has it, otherwise they are performed by customized algorithms.
</p>
<p>After the initial problem is decomposed, the smaller problems can collectively offer a pair of index lower and upper bounds. The k-subsets outside the bounds are not necessarily considered for building the k-sum accelerator.
</p>
<p>See comparisons between this function and <code>FLSSS()</code>, <code>mFLSSSpar()</code> in Examples.
</p>


<h3>Value</h3>

<p>A list of index vectors as solutions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
N = 200L # Superset size.
len = 20L # Subset size.
V = sapply(1:N, function(i) # Generate a set where every "number" has at most
  # 100 digits.
{
  a = 0:9
  left = sample(a, size = sample(50, 1), replace = TRUE)
  right = sample(a, size = sample(50, 1), replace = TRUE)
  x = paste0(paste0(left, collapse = ""), ".", paste0(right, collapse = ""))
  if (runif(1) &lt; 0.5) x = paste0("-", x) # Randomly add a negative sign.
  x
})
str(V)


sol = sample(N, len) # Make a solution.
target = FLSSS::addNumStrings(V[sol]) # An unexposed helper function.


system.time({
  rst = FLSSS::arbFLSSS(
    len, V = as.matrix(V), target, solutionNeed = 1, maxCore = 2,
    tlimit = 10, ksumK = 0, verbose = TRUE)
})


# Validation.
all(unlist(lapply(rst, function(x) FLSSS:::addNumStrings(V[x]))) == target)




# ==============================================================================
# Mine in a multidimensional set.
# ==============================================================================
set.seed(2)
d = 4L # Set dimension.
N = 50L # Set size.
len = 10L # Subset size.
roundN = 4L # For rounding the numeric values before conversion to strings.


V = matrix(round(runif(N * d, -1, 1), roundN), nrow = N) # Make superset.
optionSave = options()
options(scipen = 999) # Ensure numeric-to-string conversion does not
# produce strings like "2e-3".
Vstr = matrix(as.character(V), nrow = N)


sol = sample(N, len) # Make a solution.
target = round(colSums(V[sol, ]), roundN) # Target subset sum.
targetStr = as.character(target)


system.time({
  rst = FLSSS::arbFLSSS(
    len = len, V = Vstr, target, givenKsumTable = NULL, tlimit = 60,
    solutionNeed = 1e9, maxCore = 2, ksumK = 4, verbose = TRUE)
})


# Validation.
all(unlist(lapply(rst, function(x)
{
  apply(Vstr, 2, function(u) FLSSS:::addNumStrings(u[x]))
})) == targetStr)




# # ============================================================================
# # Compare arbFLSSS() and FLSSS(). Example takes more than 2 seconds. The 
# # section has some analysis of the algorithms.
# # ============================================================================
# set.seed(3)
# N = 100L # Superset size.
# len = 20L # Subset size.
# roundN = 5L # For rounding the numeric values.
# V = sort(round(100000 * runif(N, -1, 1), roundN)) # Create superset.
# sol = sort(sample(N, len)) # Make a solution.
# target = round(sum(V[sol]), roundN)
# error = 3e-6 # Effectively demands the target sum to be exactly matched
# # since roundN = 5.
# 
# 
# system.time({
#   FLSSSrst = FLSSS::FLSSS(
#     len, V, target, ME = error, solutionNeed = 2, tlimit = 60)
# })
# # It may seem counter-intuitive that this takes much longer than the instance
# # with N = 1000 and len = 200L --- the 1st example in the help page of
# # FLSSS(). Note the time cost is closely related to the "rarity" of
# # solutions. A larger superset or subset could mean more element combinations
# # that can sum into the given range, thus more solutions and easier to mine.
# 
# 
# # Validate the results.
# all(abs(unlist(lapply(FLSSSrst, function(x) sum(V[x]))) - target) &lt;= error)
# 
# 
# options(scipen = 999)
# Vstr = as.matrix(as.character(V))
# targetStr = as.character(target)
# # Use 1 thread for a fair comparison with FLSSS() since the latter is
# # single-threaded. Use no k-sum accelerator.
# system.time({
#   arbFLSSSrst = FLSSS::arbFLSSS(
#     len, V = Vstr, target = targetStr, solutionNeed = 2, maxCore = 1,
#     ksumK = 0, verbose = TRUE, approxNinstance = 1000, tlimit = 60)
# })
# # Timing is higher than FLSSS() because arbFLSSS()'s objective
# # is not just solving unidimensional problem.
# 
# 
# # Validation.
# all(abs(unlist(lapply(arbFLSSSrst, function(x) sum(V[x]))) - target) &lt;= error)
# 
# 
# # Use 4-sum accelerator. Massive speedup.
# system.time({
#   arbFLSSSrst = FLSSS::arbFLSSS(
#     len, Vstr, targetStr, solutionNeed = 2, maxCore = 1, ksumK = 4,
#     verbose = FALSE, approxNinstance = 1000, tlimit = 60)
# })
# 
# 
# # Validation.
# all(abs(unlist(lapply(arbFLSSSrst, function(x) sum(V[x]))) - target) &lt;= error)




# # ============================================================================
# # Compare arbFLSSS() and mFLSSSpar(). Example takes more than 2 seconds. The
# # section contains some analysis of the algorithms.
# # ============================================================================
# set.seed(4)
# d = 5L # Set dimension.
# N = 60L # Set size.
# len = 10L # Subset size.
# roundN = 2L # For rounding the numeric values before conversion to strings.
# 
# 
# V = matrix(round(runif(N * d, -1e5, 1e5), roundN), nrow = N) # Make superset.
# sol = sample(N, len) # Make a solution.
# target = round(colSums(V[sol, ]), roundN) # Target subset sum.
# error = rep(2e-3, d) # Effectively demands the target sum to be exactly
# # matched since roundN = 2.
# 
# 
# system.time({
#   mFLSSSparRst = FLSSS::mFLSSSpar(
#     maxCore = 7, len = len, mV = V, mTarget = target, mME = error,
#     avgThreadLoad = 20, solutionNeed = 1, tlimit = 60)
# })
# 
# 
# # Validation.
# all(unlist(lapply(mFLSSSparRst, function(x)
#   abs(colSums(V[x, , drop = FALSE]) - target) &lt;= error)))
# 
# 
# options(scipen = 999) # Ensure numeric =&gt; string conversion does not
# # produce strings like 2e-3.
# Vstr = matrix(as.character(V), nrow = N) # String version of V.
# targetStr = as.character(target)
# 
# 
# # Use no k-sum accelerator.
# system.time({
#   arbFLSSSrst = FLSSS::arbFLSSS(
#     len = len, V = Vstr, target = targetStr, givenKsumTable = NULL,
#     tlimit = 60, solutionNeed = 1, maxCore = 7, ksumK = 0, verbose = TRUE)
# })
# 
# 
# # Validation.
# all(unlist(lapply(arbFLSSSrst, function(x)
#   abs(colSums(V[x, , drop = FALSE]) - target) &lt;= error)))
# 
# 
# # Use 5-sum accelerator. Massive speedup.
# system.time({
#   arbFLSSSrst = FLSSS::arbFLSSS(
#     len = len, V = Vstr, target = targetStr, givenKsumTable = NULL,
#     tlimit = 60, solutionNeed = 1, maxCore = 7, ksumK = 5, verbose = TRUE)
# })


options(optionSave)
</code></pre>

<hr>
<h2 id='arbFLSSSobjRun'>
Run an <code>arbFLSSS</code> instance
</h2><span id='topic+arbFLSSSobjRun'></span>

<h3>Description</h3>

<p>Run an <code>arbFLSSS</code> instance decomposed from <code>decomposeArbFLSSS()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arbFLSSSobjRun(
  X,
  solutionNeed = 1L,
  tlimit = 60,
  maxCore = 7L,
  ksumK = 0L,
  ksumTableSizeScaler = 30L,
  verbose = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="arbFLSSSobjRun_+3A_x">X</code></td>
<td>

<p>An <code>arbFLSSS</code> object from <code>decomposeArbFLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="arbFLSSSobjRun_+3A_solutionneed">solutionNeed</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="arbFLSSSobjRun_+3A_tlimit">tlimit</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="arbFLSSSobjRun_+3A_maxcore">maxCore</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>. Mining subsets is single-threaded, but if <code>X</code> has no k-sum accelerator, users have the option of computing one on the fly, which is multithreaded. Will be ignored if <code>X</code> already has a k-sum accelerator.
</p>
</td></tr>
<tr><td><code id="arbFLSSSobjRun_+3A_ksumk">ksumK</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>. Will be ignored if <code>X</code> already has a k-sum accelerator.
</p>
</td></tr>
<tr><td><code id="arbFLSSSobjRun_+3A_ksumtablesizescaler">ksumTableSizeScaler</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>. Will be ignored if <code>X</code> already has a k-sum accelerator.
</p>
</td></tr>
<tr><td><code id="arbFLSSSobjRun_+3A_verbose">verbose</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>. Will be ignored if <code>X</code> already has a k-sum accelerator.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rationale follows <code>mFLSSSobjRun()</code>. The pair <code>decomposeArbFLSSS()</code> and <code>arbFLSSSobjRun()</code> makes up the distributed computing counterpart of <code>arbFLSSS()</code>.
</p>


<h3>Value</h3>

<p>Has the same return from <code>arbFLSSS()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
d = 5L # Set dimension.
N = 30L # Set size.
len = 10L # Subset size.
roundN = 2L # For rounding the numeric values before conversion to strings.


V = matrix(round(runif(N * d, -1e5, 1e5), roundN), nrow = N) # Make superset.
sol = sample(N, len) # Make a solution.
target = round(colSums(V[sol, ]), roundN) # Target subset sum.


optionSave = options()
options(scipen = 999) # Ensure numeric =&gt; string conversion does not
# produce strings like 2e-3.
Vstr = matrix(as.character(V), nrow = N) # String version of V.
targetStr = as.character(target)


system.time({
  theDecomposed = FLSSS::decomposeArbFLSSS(
    len = len, V = Vstr, target = targetStr, approxNinstance = 1000,
    maxCore = 2, ksumTable = NULL, ksumK = 4, verbose = TRUE)
})


# Run the objects sequentially.
rst = unlist(lapply(theDecomposed$arbFLSSSobjects, function(x)
{
  FLSSS::arbFLSSSobjRun(x, solutionNeed = 1e9, tlimit = 5, verbose = FALSE)
}), recursive = FALSE)
str(rst)


options(optionSave)
</code></pre>

<hr>
<h2 id='auxGAPbb'>
Multithreaded generalized assignment problem solver via branch and bound
</h2><span id='topic+auxGAPbb'></span>

<h3>Description</h3>

<p>Multithreaded exact solver for the generalized assignment problem via decomposition to binary knapsack problems (branch), and Lagrangian relaxation (bound).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auxGAPbb(
  cost,
  profitOrLoss,
  budget,
  maxCore = 7,
  tlimit = 60,
  ub = "MT",
  greedyBranching = TRUE,
  optim = "max",
  multhreadOn = "nodes",
  threadLoad = 32
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auxGAPbb_+3A_cost">cost</code></td>
<td>

<p>A numeric matrix. Dimensionality = N(agents) <code>x</code> N(tasks).
</p>
</td></tr>
<tr><td><code id="auxGAPbb_+3A_profitorloss">profitOrLoss</code></td>
<td>

<p>A numeric matrix of the same dimensionality of <code>cost</code>. Profit for maximum GAP. Loss for minimum GAP.
</p>
</td></tr>
<tr><td><code id="auxGAPbb_+3A_budget">budget</code></td>
<td>

<p>A numeric vector. Size = N(agents).
</p>
</td></tr>
<tr><td><code id="auxGAPbb_+3A_maxcore">maxCore</code></td>
<td>

<p>Maximal threads to invoke. No greater than the number of logical CPUs on machine.
</p>
</td></tr>
<tr><td><code id="auxGAPbb_+3A_tlimit">tlimit</code></td>
<td>

<p>Return the best exsisting solution in <code>tlimit</code> seconds.
</p>
</td></tr>
<tr><td><code id="auxGAPbb_+3A_ub">ub</code></td>
<td>

<p>Upper bound function. &quot;MT&quot; or &quot;HS&quot;. See <code>auxKnapsack01bb()</code>.
</p>
</td></tr>
<tr><td><code id="auxGAPbb_+3A_greedybranching">greedyBranching</code></td>
<td>

<p>If <code>TRUE</code>, branch and bound in a greedy manner. See Details.
</p>
</td></tr>
<tr><td><code id="auxGAPbb_+3A_optim">optim</code></td>
<td>

<p>A string. <code>optim = "max"</code> (<code>"min"</code>) solves the maximum (minimum) GAP.
</p>
</td></tr>
<tr><td><code id="auxGAPbb_+3A_multhreadon">multhreadOn</code></td>
<td>

<p>A string. The default <code>multhreadOn = "nodes"</code> multithreads over branching nodes. Internally, a single-threaded miner runs at first and stops once there are no less than <code>maxCore</code> <code>*</code> <code>threadLoad</code> latent trees stored in stack. The miner realizes those branches and distribute them to threads. Threads work on the subproblems sequentially and update the optimum supervised by a light mutex lock.
</p>
<p>Other values of <code>multhreadOn</code> assign threads to knapsack problems at each branching node, which is a historical remain and should always be avoided. It has overwhelming overheads because knapsack problems at those nodes are typically trivial.
</p>
</td></tr>
<tr><td><code id="auxGAPbb_+3A_threadload">threadLoad</code></td>
<td>

<p>An integer. Each thread is loaded with <code>threadLoad</code> sub-problems on average.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A popular library of GAP instances can be found here: https://github.com/WhateverLiu/gapInstances.
</p>
<p>This algorithm is based on a foundational paper by Ross and Soland (1975) and is carefully engineered towards speed. Implementation highlights include (i) decomposition for multithreading; (ii) a new branching method (<code>greedyBranching</code>) that pushes all candidate branching variables at each node into stack instead of pushing only those that have the highest desirabilities and would not affect the subsequent branching after being pushed; (iii) the return of current best solutions in time; (iv) the capability of taking real costs and profits. <code>greedyBranching</code> may considerably lower the number of nodes having the same series of knapsack problems to solve, thus accelerate the convergence speed.
</p>


<h3>Value</h3>

<p>A list of 5:
</p>
<table>
<tr><td><code>totalProfitOrLoss</code></td>
<td>
<p>Total profit or loss generated from the assignment.</p>
</td></tr>
<tr><td><code>agentCost</code></td>
<td>
<p>A numeric vector of total costs for each agent.</p>
</td></tr>
<tr><td><code>assignment</code></td>
<td>
<p>An integer vector. <code>assignment[i]</code> indexes the agent assigned to the <code>i</code>th task.</p>
</td></tr>
<tr><td><code>nodes</code></td>
<td>
<p>The number of branching nodes generated in mining.</p>
</td></tr>
<tr><td><code>bkpSolved</code></td>
<td>
<p>The number of binary knapsack problems solved in mining.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The C++ implementation is fully independent and borrows no code from any commercial or open source.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># =============================================================================
# Data source: http://people.brunel.ac.uk/~mastjjb/jeb/orlib/gapinfo.html,
# gap1 c515-1, 5 agents 15 tasks. Parsed instances from the library can be
# found here: https://github.com/WhateverLiu/gapInstances
# =============================================================================
profit = c(17,21,22,18,24,15,20,18,19,18,16,22,24,24,16,23,16,21,16,17,16,19,
           25,18,21,17,15,25,17,24,16,20,16,25,24,16,17,19,19,18,20,16,17,21,
           24,19,19,22,22,20,16,19,17,21,19,25,23,25,25,25,18,19,15,15,21,25,
           16,16,23,15,22,17,19,22,24)
profit = t(matrix(profit, ncol = 5))
cost = c(8,15,14,23,8,16,8,25,9,17,25,15,10,8,24,15,7,23,22,11,11,12,10,17,16,
         7,16,10,18,22,21,20,6,22,24,10,24,9,21,14,11,14,11,19,16,20,11,8,14,
         9,5,6,19,19,7,6,6,13,9,18,8,13,13,13,10,20,25,16,16,17,10,10,5,12,23)
cost = t(matrix(cost, ncol = 5))
budget = c(36, 34, 38, 27, 33)


sol = FLSSS::auxGAPbb(cost, profit, budget, maxCore = 2, tlimit = 4,
                       ub = "MT", greedyBranching = TRUE, optim = "max")




# =============================================================================
# Data source: http://support.sas.com/documentation/cdl/en/ormpug/65554/HTML
# /default/viewer.htm#ormpug_decomp_examples02.htm, an example made by SAS
# corporation. 24 tasks assigned to 8 agents.
# =============================================================================
cost = t(matrix(c(
  8,18,22,5,11,11,22,11,17,22,11,20,13,13,7,22,15,22,24,8,8,24,18,8,24,14,11,
  15,24,8,10,15,19,25,6,13,10,25,19,24,13,12,5,18,10,24,8,5,22,22,21,22,13,
  16,21,5,25,13,12,9,24,6,22,24,11,21,11,14,12,10,20,6,13,8,19,12,19,18,10,21,
  5,9,11,9,22,8,12,13,9,25,19,24,22,6,19,14,25,16,13,5,11,8,7,8,25,20,24,20,11,
  6,10,10,6,22,10,10,13,21,5,19,19,19,5,11,22,24,18,11,6,13,24,24,22,6,22,5,14,
  6,16,11,6,8,18,10,24,10,9,10,6,15,7,13,20,8,7,9,24,9,21,9,11,19,10,5,23,20,5,
  21,6,9,9,5,12,10,16,15,19,18,20,18,16,21,11,12,22,16,21,25,7,14,16,10),
  ncol = 8))
profit = t(matrix(c(
  25,23,20,16,19,22,20,16,15,22,15,21,20,23,20,22,19,25,25,24,21,17,23,17,16,
  19,22,22,19,23,17,24,15,24,18,19,20,24,25,25,19,24,18,21,16,25,15,20,20,18,
  23,23,23,17,19,16,24,24,17,23,19,22,23,25,23,18,19,24,20,17,23,23,16,16,15,23,
  15,15,25,22,17,20,19,16,17,17,20,17,17,18,16,18,15,25,22,17,17,23,21,20,24,22,
  25,17,22,20,16,22,21,23,24,15,22,25,18,19,19,17,22,23,24,21,23,17,21,19,19,17,
  18,24,15,15,17,18,15,24,19,21,23,24,17,20,16,21,18,21,22,23,22,15,18,15,21,22,
  15,23,21,25,25,23,20,16,25,17,15,15,18,16,19,24,18,17,21,18,24,25,18,23,21,15,
  24,23,18,18,23,23,16,20,20,19,25,21), ncol = 8))
budget = c(36, 35, 38, 34, 32, 34, 31, 34)


# Intel CPU i7-4770 3.4GHz, g++ '-Ofast', 64-bit Windows 7:
system.time({sol = FLSSS::auxGAPbb(
  cost, profit, budget, maxCore = 2, tlimit = 4, ub = "MT",
  greedyBranching = FALSE, optim = "max")})
# user  system elapsed
# 0.02    0.00    0.01
# The elapsed time is about 1% of that reported by the SAS proc with 8
# threads, although its hardware configuration is unknown.


system.time({sol2 = FLSSS::auxGAPbb(
  cost, profit, budget, maxCore = 2, tlimit = 4, ub = "MT",
  greedyBranching = TRUE, optim = "max")})
sol[c("nodes", "bkpSolved")]  # 4526, 14671, can be different.
sol2[c("nodes", "bkpSolved")] # 4517, 13115, can be different.
# Greedy branching may lower the numbers of branching nodes and
# knapsack problems to solve.




# =============================================================================
# Play random numbers.
# =============================================================================
set.seed(22) # A nontrivial instance searched via changing random seeds.
             # RNG in R 3.5.1 for Windows.
Nagent = 20L; Ntask = 200L
cost = matrix(runif(Nagent * Ntask, 1e3, 1e6), nrow = Nagent)
profit = matrix(abs(rnorm(Nagent * Ntask, 1e6, 1e6)) + 1000, nrow = Nagent)
budget = apply(cost, 1, function(x) runif(1, min(x), sum(x) / 2))


# Intel CPU i7-4770 3.4GHz, g++ '-Ofast', 64-bit Windows 7.
system.time({sol1 = FLSSS::auxGAPbb(
  cost, profit, budget,
  maxCore = 1, multhreadOn = "KPs",
  tlimit = 3600, ub = "MT", greedyBranching = TRUE, optim = "max")})
# user  system elapsed
# 9.17    0.00    9.19


# Multithread knapsack problems at each branching node.
# This does not accelerate the speed at all because threading overheads
# are overwhelming.
system.time({sol2 = FLSSS::auxGAPbb(
  cost, profit, budget,
  maxCore = 7, multhreadOn = "KPs",
  tlimit = 3600, ub = "MT", greedyBranching = TRUE, optim = "max")})
# user   system elapsed
# 39.02    5.24   11.12


# Multithread nodes.
system.time({sol3 = FLSSS::auxGAPbb(
  cost, profit, budget,
  maxCore = 7, multhreadOn = "nodes", threadLoad = 32L,
  tlimit = 3600, ub = "MT", greedyBranching = TRUE, optim = "max")})
#  user  system elapsed
# 14.62    0.00    2.13

</code></pre>

<hr>
<h2 id='auxGAPbbDp'>
Multithreaded generalized assignment problem solver via a hybrid of branch-and-bound and dynamic programming.
</h2><span id='topic+auxGAPbbDp'></span>

<h3>Description</h3>

<p>Multithreaded exact solver for the generalized assignment problem via decomposition to binary knapsack problems (branch), and Lagrangian relaxation (bound). Knapsack problems are solved via dynamic programming.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auxGAPbbDp(
  cost,
  profitOrLoss,
  budget,
  maxCore = 7L,
  tlimit = 60,
  greedyBranching = TRUE,
  optim = "max",
  multhreadOn = "nodes",
  threadLoad = 32
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auxGAPbbDp_+3A_cost">cost</code></td>
<td>

<p>An integer matrix. Dimensionality = N(agents) <code>x</code> N(tasks).
</p>
</td></tr>
<tr><td><code id="auxGAPbbDp_+3A_profitorloss">profitOrLoss</code></td>
<td>

<p>A numeric matrix of the same dimensionality of <code>cost</code>. Profit for maximum GAP. Loss for minimum GAP.
</p>
</td></tr>
<tr><td><code id="auxGAPbbDp_+3A_budget">budget</code></td>
<td>

<p>An integer vector. Size = N(agents).
</p>
</td></tr>
<tr><td><code id="auxGAPbbDp_+3A_maxcore">maxCore</code></td>
<td>

<p>Maximal threads to invoke. No greater than the number of logical CPUs on machine.
</p>
</td></tr>
<tr><td><code id="auxGAPbbDp_+3A_tlimit">tlimit</code></td>
<td>

<p>Return the best exsisting solution in <code>tlimit</code> seconds.
</p>
</td></tr>
<tr><td><code id="auxGAPbbDp_+3A_greedybranching">greedyBranching</code></td>
<td>

<p>See <code>greedyBranching</code> in <code>auxGAPbb()</code>.
</p>
</td></tr>
<tr><td><code id="auxGAPbbDp_+3A_optim">optim</code></td>
<td>

<p>A string. <code>optim = "max"</code> (<code>"min"</code>) solves the maximum (minimum) GAP.
</p>
</td></tr>
<tr><td><code id="auxGAPbbDp_+3A_multhreadon">multhreadOn</code></td>
<td>

<p>See <code>multhreadOn</code> in <code>auxGAPbb()</code>.
</p>
</td></tr>
<tr><td><code id="auxGAPbbDp_+3A_threadload">threadLoad</code></td>
<td>

<p>See <code>threadLoad</code> in <code>auxGAPbb()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For instances with integral <code>cost</code> and <code>budget</code> of small magnitudes, knapsack problems from the decomposition could be solved faster via dynamic programming than branch and bound. See <code>auxKnapsack01dp()</code>. Implementation highlights include (i) only <code>maxCore</code> many lookup matrices exist in memory; (ii) a lookup matrix is recycled if it is sufficiently large to support solving the current knapsack problem, so as to minimize potential contentious memory allocations in multithreading. These management rules for economical memories propagate through all package functions. See more details in <code>auxGAPbb()</code>.
</p>


<h3>Value</h3>

<p>See Value of <code>auxGAPbb()</code>.
</p>


<h3>Note</h3>

<p><code>cost</code> and <code>budget</code> are integers. The C++ implementation is fully independent and borrows no code from any commercial or open source.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># =============================================================================
# Data source: http://support.sas.com/documentation/cdl/en/ormpug/65554/HTML
# /default/viewer.htm#ormpug_decomp_examples02.htm, an example made by SAS
# corporation. 24 tasks assigned to 8 agents.
# =============================================================================
cost = t(matrix(as.integer(c(
  8,18,22,5,11,11,22,11,17,22,11,20,13,13,7,22,15,22,24,8,8,24,18,8,24,14,11,
  15,24,8,10,15,19,25,6,13,10,25,19,24,13,12,5,18,10,24,8,5,22,22,21,22,13,
  16,21,5,25,13,12,9,24,6,22,24,11,21,11,14,12,10,20,6,13,8,19,12,19,18,10,21,
  5,9,11,9,22,8,12,13,9,25,19,24,22,6,19,14,25,16,13,5,11,8,7,8,25,20,24,20,11,
  6,10,10,6,22,10,10,13,21,5,19,19,19,5,11,22,24,18,11,6,13,24,24,22,6,22,5,14,
  6,16,11,6,8,18,10,24,10,9,10,6,15,7,13,20,8,7,9,24,9,21,9,11,19,10,5,23,20,5,
  21,6,9,9,5,12,10,16,15,19,18,20,18,16,21,11,12,22,16,21,25,7,14,16,10)),
  ncol = 8))
profit = t(matrix(c(
  25,23,20,16,19,22,20,16,15,22,15,21,20,23,20,22,19,25,25,24,21,17,23,17,16,
  19,22,22,19,23,17,24,15,24,18,19,20,24,25,25,19,24,18,21,16,25,15,20,20,18,
  23,23,23,17,19,16,24,24,17,23,19,22,23,25,23,18,19,24,20,17,23,23,16,16,15,23,
  15,15,25,22,17,20,19,16,17,17,20,17,17,18,16,18,15,25,22,17,17,23,21,20,24,22,
  25,17,22,20,16,22,21,23,24,15,22,25,18,19,19,17,22,23,24,21,23,17,21,19,19,17,
  18,24,15,15,17,18,15,24,19,21,23,24,17,20,16,21,18,21,22,23,22,15,18,15,21,22,
  15,23,21,25,25,23,20,16,25,17,15,15,18,16,19,24,18,17,21,18,24,25,18,23,21,15,
  24,23,18,18,23,23,16,20,20,19,25,21), ncol = 8))
budget = as.integer(c(36, 35, 38, 34, 32, 34, 31, 34))


system.time({sol = FLSSS::auxGAPbbDp(
  cost, profit, budget,
  maxCore = 2, tlimit = 4, greedyBranching = TRUE, optim = "max")})
sol[c("nodes", "bkpSolved")] # 2630, 8102




set.seed(8) # A nontrivial instance searched via changing random seeds.
            # RNG in R 3.5.1 for Windows.
Nagent = 20L; Ntask = 200L
cost = matrix(as.integer(runif(Nagent * Ntask, 1, 50)), nrow = Nagent)
budget = as.integer(apply(cost, 1, function(x) runif(1, min(x), sum(x) / 2)))
profit = matrix(abs(rnorm(Nagent * Ntask, 1e6, 1e6)) + 1000, nrow = Nagent)


# Intel CPU i7-4770 3.4GHz, g++ '-Ofast', 64-bit Windows 7.
system.time({sol1 = FLSSS::auxGAPbb(
  cost, profit, budget,
  maxCore = 7, multhreadOn = "nodes",
  tlimit = 3600, greedyBranching = TRUE, optim = "max")})
# user  system elapsed
# 14.43    0.00    2.11


system.time({sol2 = FLSSS::auxGAPbbDp(
  cost, profit, budget,
  maxCore = 7, multhreadOn = "nodes",
  tlimit = 3600, greedyBranching = TRUE, optim = "max")})
# user  system elapsed
# 5.77    0.00    0.87
# Dynamic programming for solving knapsack problems could be faster
# for integral costs and budgets of small magnitudes.

</code></pre>

<hr>
<h2 id='auxGAPga'>
Multithreaded generalized assignment problem solver via genetic algorithm
</h2><span id='topic+auxGAPga'></span>

<h3>Description</h3>

<p>A genetic algorithm with local heuristics for GAP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auxGAPga(
  cost,
  profitOrLoss,
  budget,
  trials,
  populationSize,
  generations,
  randomSeed = NULL,
  maxCore = 7,
  optim = "max"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auxGAPga_+3A_cost">cost</code></td>
<td>

<p>A numeric matrix. Dimensionality = N(agents) <code>x</code> N(tasks).
</p>
</td></tr>
<tr><td><code id="auxGAPga_+3A_profitorloss">profitOrLoss</code></td>
<td>

<p>A numeric matrix of the same dimensionality of <code>cost</code>. Profit for maximum GAP. Loss for minimum GAP.
</p>
</td></tr>
<tr><td><code id="auxGAPga_+3A_budget">budget</code></td>
<td>

<p>A numeric vector. Size = N(agents).
</p>
</td></tr>
<tr><td><code id="auxGAPga_+3A_trials">trials</code></td>
<td>

<p>An integer. Number of trials, aka the number of population sets.
</p>
</td></tr>
<tr><td><code id="auxGAPga_+3A_populationsize">populationSize</code></td>
<td>

<p>An integer. Size of each population.
</p>
</td></tr>
<tr><td><code id="auxGAPga_+3A_generations">generations</code></td>
<td>

<p>An integer. As reproduction iterates, if there have been <code>generations</code> many children produced and accepted in population but no update on the current optimum, function quits.
</p>
</td></tr>
<tr><td><code id="auxGAPga_+3A_randomseed">randomSeed</code></td>
<td>

<p>An integer or <code>NULL</code>. <code>randomSeed</code> seeds the random number generator in R, generates <code>trials</code> many integers to seed the <code>mt19937_64</code> (Mersenne Twister) engine for each trial.
</p>
</td></tr>
<tr><td><code id="auxGAPga_+3A_maxcore">maxCore</code></td>
<td>

<p>Maximal threads to invoke. No greater than the number of logical CPUs on machine. The algorithm multithreads over trials.
</p>
</td></tr>
<tr><td><code id="auxGAPga_+3A_optim">optim</code></td>
<td>

<p>A string. <code>optim = "max"</code> (<code>"min"</code>) solves the maximum (minimum) GAP.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm is based on a foundational paper by Chu and Beasley (1997) and is carefully engineered towards speed. Besides the standard cross-over and mutation operations, the algorithm applies two local heuristics for educating the new borns. The first is to randomly pick a task from each overloaded agent and reassign the task to the next budget-sufficient agent &mdash; if there is any. The second is to raise the total profit by reassigning another agent for each task &mdash; if the reassignment would not result in overload. The algorithm outperforms most peer metaheuristics such as variants of simulated annealing and tabu search (Osman), and is highly effective for large and hard instances.
</p>


<h3>Value</h3>

<p>A list of 4:
</p>
<table>
<tr><td><code>totalProfitOrLoss</code></td>
<td>
<p>Total profit or loss generated from the assignment. Negative infinity if no solution found.</p>
</td></tr>
<tr><td><code>agentCost</code></td>
<td>
<p>A numeric vector of total costs for each agent. Empty if no solution found.</p>
</td></tr>
<tr><td><code>assignment</code></td>
<td>
<p>An integer vector. <code>assignment[i]</code> indexes the agent assigned to the <code>i</code>th task. Empty if no solution found.</p>
</td></tr>
<tr><td><code>populationInfo</code></td>
<td>
<p>A list of 3:</p>
</td></tr>
<tr><td><code>allGenes</code></td>
<td>
<p>An N(task) <code>x</code> (<code>populationSize x trials</code>) integer matrix recording genes in all population sets upon completion. Each column represents a gene, namely a tentative assignment.</p>
</td></tr>
<tr><td><code>allBudgetExceedance</code></td>
<td>
<p>A numeric vector of the size of <code>populationSize x trials</code>. <code>allBudgetExceedance[i]</code> equals the total budget exceedance of tentative assignment <code>allGenes[, i]</code>.</p>
</td></tr>
<tr><td><code>allProfitOrLoss</code></td>
<td>
<p>A numeric vector of the size of <code>allBudgetExceedance</code>. <code>allProfitOrLoss[i]</code> equals the total profit or loss of tentative assignment <code>allGenes[, i]</code>.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The C++ implementation is fully independent and borrows no code from any commercial or open source.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># =============================================================================
# A trivial instance
# =============================================================================
profit = c(17,21,22,18,24,15,20,18,19,18,16,22,24,24,16,23,16,21,16,17,16,19,
           25,18,21,17,15,25,17,24,16,20,16,25,24,16,17,19,19,18,20,16,17,21,
           24,19,19,22,22,20,16,19,17,21,19,25,23,25,25,25,18,19,15,15,21,25,
           16,16,23,15,22,17,19,22,24)
profit = t(matrix(profit, ncol = 5))
cost = c(8,15,14,23,8,16,8,25,9,17,25,15,10,8,24,15,7,23,22,11,11,12,10,17,16,
         7,16,10,18,22,21,20,6,22,24,10,24,9,21,14,11,14,11,19,16,20,11,8,14,
         9,5,6,19,19,7,6,6,13,9,18,8,13,13,13,10,20,25,16,16,17,10,10,5,12,23)
cost = t(matrix(cost, ncol = 5))
budget = c(36, 34, 38, 27, 33)


Nagent = 5L; Ntask = 15L
rst = FLSSS::auxGAPga(
  cost, profit, budget, trials = 2, populationSize = 100, generations = 10000,
  randomSeed = 42, maxCore = 2, optim = "max")


# =============================================================================
# A relatively hard instance.
# =============================================================================
# Download gapInstances.Rdata from
# https://github.com/WhateverLiu/gapInstances. Load it in R.
if (FALSE)
{
  cost = gapC[[3]]$cost
  loss = gapC[[3]]$loss
  budget = gapC[[3]]$budget
  # Intel CPU i7-4770 3.4GHz, g++ '-Ofast', 64-bit Windows 7.
  system.time({rst = FLSSS::auxGAPga(
    cost, loss, budget, trials = 7, randomSeed = 42, populationSize = 100, 
    generations = 500000, optim = "min", maxCore = 7)})
  rst$totalProfitOrLoss # 1416
  #  user  system elapsed
  # 69.24    0.17   11.61
  # The known optimum equals 1402 as the total loss.
}
</code></pre>

<hr>
<h2 id='auxKnapsack01bb'>
Multithreaded binary knapsack problem solver via branch and bound
</h2><span id='topic+auxKnapsack01bb'></span>

<h3>Description</h3>

<p>Given items' weights and values, concurrently solve 0-1 knapsack problems to optimality via branch and bound for multiple knapsacks of different capacities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auxKnapsack01bb(
  weight,
  value,
  caps,
  itemNcaps = integer(0),
  maxCore = 7L,
  tlimit = 60,
  ub = "MT",
  simplify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auxKnapsack01bb_+3A_weight">weight</code></td>
<td>

<p>A numeric vector.
</p>
</td></tr>
<tr><td><code id="auxKnapsack01bb_+3A_value">value</code></td>
<td>

<p>A numeric vector. The size equals that of <code>weight</code>.
</p>
</td></tr>
<tr><td><code id="auxKnapsack01bb_+3A_caps">caps</code></td>
<td>

<p>A numeric vector of knapsack capacities.
</p>
</td></tr>
<tr><td><code id="auxKnapsack01bb_+3A_itemncaps">itemNcaps</code></td>
<td>

<p>An integer vector of upper bounds on the number of selected items. <code>itemNcaps[i]</code> corresponds to instance <code>caps[i]</code>. Empty <code>itemNcaps</code> implies no size restriction.
</p>
</td></tr>
<tr><td><code id="auxKnapsack01bb_+3A_maxcore">maxCore</code></td>
<td>

<p>Maximal threads to invoke. No greater than the number of logical CPUs on machine.
</p>
</td></tr>
<tr><td><code id="auxKnapsack01bb_+3A_tlimit">tlimit</code></td>
<td>

<p>Return the best exsisting solution in <code>tlimit</code> seconds.
</p>
</td></tr>
<tr><td><code id="auxKnapsack01bb_+3A_ub">ub</code></td>
<td>

<p>Upper bound function.
</p>
</td></tr>
<tr><td><code id="auxKnapsack01bb_+3A_simplify">simplify</code></td>
<td>

<p>If <code>length(caps) == 1</code>, simplify the output.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm takes the Horowitz-Sahni (1974) and the Martello-Toth (1977) upper bound functions and is carefully engineered towards speed. Implementation highlights include (i) an extra option of upper bounding the number of selected items, which only adds trivial overhead; (ii) the return of existing best solutions in time; (iii) the capability of taking numeric weights and values.</p>


<h3>Value</h3>

<p>A list of 2:
</p>
<p><code>maxValue</code>: a numeric vector. <code>maxValue[i]</code> equals the sum of values of items selected for capacity <code>caps[i]</code>.
</p>
<p><code>selection</code>: a list of integer vectors. <code>selection[i]</code> indexes the items selected for capacity <code>caps[i]</code>.
</p>


<h3>Note</h3>

<p>The function is not to solve the 0-1 multiple knapsack problem. The C++ implementation is fully independent and borrows no code from any open or commercial source.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
weight = runif(100, min = 1e3, max = 1e6)
value = weight ^ 0.5 * 100 # Higher correlation between item weights and values
                           # typically implies a harder knapsack problem.
caps = runif(10, min(weight), sum(weight))
rst = FLSSS::auxKnapsack01bb(weight, value, caps, maxCore = 2, tlimit = 2)
str(rst)
</code></pre>

<hr>
<h2 id='auxKnapsack01dp'>
Multithreaded binary knapsack problem solver via dynamic programming
</h2><span id='topic+auxKnapsack01dp'></span>

<h3>Description</h3>

<p>Given items' weights and values, concurrently solve 0-1 knapsack problems to optimality via dynamic programming for multiple knapsacks of different capacities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auxKnapsack01dp(
  weight,
  value,
  caps,
  maxCore = 7L,
  tlimit = 60,
  simplify = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auxKnapsack01dp_+3A_weight">weight</code></td>
<td>

<p>An integer vector.
</p>
</td></tr>
<tr><td><code id="auxKnapsack01dp_+3A_value">value</code></td>
<td>

<p>A numeric vector. The size equals that of <code>weight</code>.
</p>
</td></tr>
<tr><td><code id="auxKnapsack01dp_+3A_caps">caps</code></td>
<td>

<p>An integer vector of knapsack capacities.
</p>
</td></tr>
<tr><td><code id="auxKnapsack01dp_+3A_maxcore">maxCore</code></td>
<td>

<p>Maximal threads to invoke. No greater than the number of logical CPUs on machine.
</p>
</td></tr>
<tr><td><code id="auxKnapsack01dp_+3A_tlimit">tlimit</code></td>
<td>

<p>Return the best exsisting solution in <code>tlimit</code> seconds.
</p>
</td></tr>
<tr><td><code id="auxKnapsack01dp_+3A_simplify">simplify</code></td>
<td>

<p>If <code>length(caps) == 1</code>, simplify the output.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Implementation highlights include (i) lookup matrix is only of space complexity O(N * [max(C) - min(W)]), where N = the number of items, max(C) = maximal knapsack capacity, min(W) = minimum item weight; (ii) threads read and write the same lookup matrix and thus accelerate each other; (iii) the return of existing best solutions in time.
</p>


<h3>Value</h3>

<p>A list of 3:
</p>
<p><code>maxValue</code>: a numeric vector. <code>maxValue[i]</code> equals the sum of values of items selected for capacity <code>caps[i]</code>.
</p>
<p><code>selection</code>: a list of integer vectors. <code>selection[i]</code> indexes the items selected for capacity <code>caps[i]</code>.
</p>
<p><code>lookupTable</code>: a numeric matrix.
</p>


<h3>Note</h3>

<p>The function is not to solve the 0-1 multiple knapsack problem.
<code>weight</code> and <code>caps</code> are integers.
Be cautioned that dynamic programming is not suitable for problems with weights or capacities of high magnitudes due to its space complexity. Otherwise it could outperform branch-and-bound especially for large instances with highly correlated item weights and values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples with CPU (user + system) or elapsed time &gt; 5s
#                 user system elapsed
# auxKnapsack01dp 6.53      0    3.33
# CRAN complains about computing time. Wrap it.
if (FALSE)
{
  set.seed(42)
  weight = sample(10L : 100L, 600L, replace = TRUE) # Dynamic programming
  # solution requires integer
  # weights.
  value = weight ^ 0.5 * 100 # Higher correlation between item weights and values
  # typically implies a harder knapsack problem.
  caps = as.integer(runif(10, min(weight), 600L))
  system.time({rstDp = FLSSS::auxKnapsack01dp(
    weight, value, caps, maxCore = 2, tlimit = 4)})
  system.time({rstBb = FLSSS::auxKnapsack01bb(
    weight, value, caps, maxCore = 2, tlimit = 4)})
  # Dynamic programming can be faster than branch-and-bound for integer weights
  # and capacity of small magnitudes.  
}
</code></pre>

<hr>
<h2 id='decomposeArbFLSSS'>
arbFLSSS decomposition
</h2><span id='topic+decomposeArbFLSSS'></span>

<h3>Description</h3>

<p>Decompose an <code>arbFLSSS</code> instance into sub-problems for distributed computing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomposeArbFLSSS(
  len,
  V,
  target,
  approxNinstance = 1000L,
  maxCore = 7L,
  ksumTable = NULL,
  ksumK = 4L,
  ksumTableSizeScaler = 30L,
  verbose = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomposeArbFLSSS_+3A_len">len</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="decomposeArbFLSSS_+3A_v">V</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="decomposeArbFLSSS_+3A_target">target</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="decomposeArbFLSSS_+3A_approxninstance">approxNinstance</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="decomposeArbFLSSS_+3A_maxcore">maxCore</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>. The decomposition is single-threaded, but building the k-sum accelerator is multithreaded.
</p>
</td></tr>
<tr><td><code id="decomposeArbFLSSS_+3A_ksumtable">ksumTable</code></td>
<td>

<p>Either <code>NULL</code> or the return value from <code>ksumHash()</code>. <code>ksumTable</code> is not necessary for the decomposition. The function merely store a reference to it in every arbFLSSS object.
</p>
</td></tr>
<tr><td><code id="decomposeArbFLSSS_+3A_ksumk">ksumK</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>. If <code>ksumK &gt;= 3</code> and <code>ksumTable == NULL</code>, the function will build a k-sum accelerator and store a reference in every arbFLSSS object.
</p>
</td></tr>
<tr><td><code id="decomposeArbFLSSS_+3A_ksumtablesizescaler">ksumTableSizeScaler</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="decomposeArbFLSSS_+3A_verbose">verbose</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rationale follows <code>decomposeMflsss()</code>. The pair <code>decomposeArbFLSSS()</code> and <code>arbFLSSSobjRun()</code> makes up the distributed computing counterpart of <code>arbFLSSS()</code>.
</p>


<h3>Value</h3>

<p>A list of two:
</p>
<p><code>$arbFLSSSobjects</code>: a list. Each element is an <code>arbFLSSS</code> object that would be supplied to <code>arbFLSSSobjRun()</code>.
</p>
<p><code>$solutionsFound</code>: a list. Solutions found during decomposition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
d = 5L # Set dimension.
N = 60L # Set size.
len = 10L # Subset size.
roundN = 2L # For rounding the numeric values before conversion to strings.


V = matrix(round(runif(N * d, -1e5, 1e5), roundN), nrow = N) # Make superset.
sol = sample(N, len) # Make a solution.
target = round(colSums(V[sol, ]), roundN) # Target subset sum.


optionSave = options()
options(scipen = 999) # Ensure numeric =&gt; string conversion does not
# produce strings like 2e-3.
Vstr = matrix(as.character(V), nrow = N) # String version of V.
targetStr = as.character(target)


system.time({
  theDecomposed = FLSSS::decomposeArbFLSSS(
    len = len, V = Vstr, target = targetStr, approxNinstance = 1000,
    maxCore = 2, ksumTable = NULL, ksumK = 4, verbose = TRUE)
})


# Check if any solution has been found during decomposition.
str(theDecomposed$solutionsFound)


# Check the first arbFLSSS object.
str(theDecomposed$arbFLSSSobjects[[1]])


options(optionSave)
</code></pre>

<hr>
<h2 id='decomposeMflsss'>
mFLSSS decomposition
</h2><span id='topic+decomposeMflsss'></span>

<h3>Description</h3>

<p>Decompose an <code>mFLSSS</code> instance into sub-problems for distributed computing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decomposeMflsss(
  len,
  mV,
  mTarget,
  mME,
  solutionNeed = 1L,
  dl = ncol(mV),
  du = ncol(mV),
  useBiSrchInFB = FALSE,
  approxNinstance = 50000L
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decomposeMflsss_+3A_len">len</code></td>
<td>

<p>See the same argument in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="decomposeMflsss_+3A_mv">mV</code></td>
<td>

<p>See the same argument in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="decomposeMflsss_+3A_mtarget">mTarget</code></td>
<td>

<p>See the same argument in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="decomposeMflsss_+3A_mme">mME</code></td>
<td>

<p>See the same argument in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="decomposeMflsss_+3A_solutionneed">solutionNeed</code></td>
<td>

<p>See the same argument in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="decomposeMflsss_+3A_dl">dl</code></td>
<td>

<p>See the same argument in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="decomposeMflsss_+3A_du">du</code></td>
<td>

<p>See the same argument in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="decomposeMflsss_+3A_usebisrchinfb">useBiSrchInFB</code></td>
<td>

<p>See the same argument in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="decomposeMflsss_+3A_approxninstance">approxNinstance</code></td>
<td>

<p>Approximately how many instances should the problem be decomposed into.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function and <code>mFLSSSobjRun()</code> constitute a multi-process counterpart of <code>mFLSSSpar()</code>. It decomposes a multidimensional subset sum problem into numerous independent instances that can be submitted to any computing resource of CPU threads, on each of which <code>mFLSSSobjRun()</code> receives and solves the instance.
</p>
<p>For example, if 1000 threads are available, either on a computing cluster or on a few hundred laptops, one could (i) decompose the problem of interest into 100000 instances using <code>decomposeMflsss()</code>, (ii) transmit each instance to any available thread and calls <code>mFLSSSobjRun()</code> on the instance, (iii) collect the results from all threads. It is strongly recommended to decompose the initial problem into much more instances than the threads, provided that an automatic queueing system exists, so there would be less chance of having idling threads during computation &mdash; if the number of instances equals the number of threads, some threads may finish earlier than others due to the heterogeneous nature of the instances, thus the computing waste.
</p>
<p>The pair <code>decomposeMflsss()</code> and <code>mFLSSSobjRun()</code> is designed for exploiting distributed resource to solve large and hard multidimensional subset sum instances.
</p>


<h3>Value</h3>

<p>A list of two:
</p>
<p><code>$mflsssObjects</code>: a list. Each element is an <code>mFLSSS</code> object that would be supplied to <code>mFLSSSobjRun()</code>.
</p>
<p><code>$solutionsFound</code>: a list. Solutions found during decomposition.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N = 30L # Superset size.
len = 6L # Subset size.
dimen = 5L # Dimension.
set.seed(8120)
v = matrix(runif(N * dimen) * 1000, nrow = N) # Superset.
sol = sample(N, len)
target = colSums(v[sol, ]) # Target sum.
ME = target * 0.03 # Error threshold.
approxNinstance = 1000


validate = function(len, v, target, ME, result)
{
  all(unlist(lapply(result, function(x)
    all(abs(colSums(v[x, ]) - target) &lt;= ME))))
}


decompedFlsss = FLSSS::decomposeMflsss(
  len = len, mV = v, mTarget = target, mME = ME, solutionNeed = 1e6,
  approxNinstance = approxNinstance)


str(decompedFlsss$solutionsFound) # See if the agent already found
# some solutions and validate them.
if(length(decompedFlsss$solutionsFound) &gt; 0)
  print(validate(len, v, target, ME, decompedFlsss$solutionsFound))


length(decompedFlsss$mflsssObjects) # Number of independent small jobs.
someOtherSolutions = FLSSS::mFLSSSobjRun(
  decompedFlsss$mflsssObjects[[620]], tlimit = 3, solutionNeed = 1e6)


if(length(someOtherSolutions) &gt; 0) # Validate solutions.
{
  print(someOtherSolutions)
  print(validate(len, v, target, ME, someOtherSolutions))
}
</code></pre>

<hr>
<h2 id='FLSSS'>
One-dimensional Subset Sum given error threshold
</h2><span id='topic+FLSSS'></span>

<h3>Description</h3>

<p>Given subset size <code>len</code>, sorted superset <code>v</code>, subset sum <code>target</code> and error <code>ME</code>, find at least <code>solutionNeed</code> index (integer) vector(s) <code>x</code>, such that <code>target - ME &lt;= sum(v[x]) &lt;= target + ME</code>. To mine subsets that sum in a given range, set <code>target</code> to the midpoint and <code>ME</code> to half of the range width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLSSS(
  len,
  v,
  target,
  ME,
  solutionNeed = 1L,
  LB = 1L : len,
  UB = (length(v) - len + 1L) : length(v),
  viaConjugate = FALSE,
  tlimit = 60,
  useBiSrchInFB = FALSE,
  NfractionDigits = Inf
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FLSSS_+3A_len">len</code></td>
<td>

<p>An integer as the subset size: <code>0 &lt;= len &lt; length(v)</code>. If <code>len == 0</code>, <code>FLSSS()</code> mines subets without size restriction. <code>len &lt;- 0</code> would be most likely slower than looping <code>len</code> over <code>1 : (length(v) - 1)</code>. See Details.
</p>
</td></tr>
<tr><td><code id="FLSSS_+3A_v">v</code></td>
<td>

<p>A sorted numeric vector, the superset. <code>v</code> can be negative and nonunique.
</p>
</td></tr>
<tr><td><code id="FLSSS_+3A_target">target</code></td>
<td>

<p>A numeric value, the subset sum target.
</p>
</td></tr>
<tr><td><code id="FLSSS_+3A_me">ME</code></td>
<td>

<p>A positive numeric value, the error threshold.
</p>
</td></tr>
<tr><td><code id="FLSSS_+3A_solutionneed">solutionNeed</code></td>
<td>

<p>An integer, the least number of solutions wanted. If the function returns fewer solutions, either <code>tlimit</code> is up or less than <code>solutionNeed</code> solutions exist. The function may also return more than <code>solutionNeed</code> solutions.
</p>
</td></tr>
<tr><td><code id="FLSSS_+3A_lb">LB</code></td>
<td>

<p>An integer vector of size <code>len</code> as the lower bounds of the solution space: for any solution <code>x</code>, <code>LB[i] &lt;= x[i]</code>. Custom <code>LB</code> should be no less than <code>1L : len</code> element-wisely. Every element in <code>v</code> should be within the range enclosed by <code>LB</code> and <code>UB</code>.
</p>
</td></tr>
<tr><td><code id="FLSSS_+3A_ub">UB</code></td>
<td>

<p>An integer vector of size <code>len</code> as the upper bounds of the solution space: for any solution <code>x</code>, <code>x[i] &lt;= UB[i]</code>. Custom <code>UB</code> should be no greater than <code>(length(v)</code> <code>-</code> <code>len</code> <code>+</code> <code>1L</code> <code>)</code> <code>:</code> <code>length(v)</code> element-wisely. Every element in <code>v</code> should be within the range enclosed by <code>LB</code> and <code>UB</code>.
</p>
</td></tr>
<tr><td><code id="FLSSS_+3A_viaconjugate">viaConjugate</code></td>
<td>

<p>A boolean value. If <code>TRUE</code>, <code>FLSSS()</code> mines susbets of size <code>length(v) - len</code> that sum to <code>sum(v)</code> <code>- target</code> with the same <code>ME</code>. Let <code>x</code> be the integer vector indexing a qualified subset. <code>FLSSS()</code> returns <code>(1L : length(v))[-x]</code>. Simulations show that <code>FLSSS()</code> often finds the first qualified conjugate subset faster if <code>len</code> is much less than <code>length(v) / 2</code>.
</p>
</td></tr>
<tr><td><code id="FLSSS_+3A_tlimit">tlimit</code></td>
<td>

<p>A numeric value. Enforce function to return in <code>tlimit</code> seconds.
</p>
</td></tr>
<tr><td><code id="FLSSS_+3A_usebisrchinfb">useBiSrchInFB</code></td>
<td>

<p>A boolean value. If <code>TRUE</code>, the function performs binary search for index bounds in the auxiliary triangle matrix of continuous sequence sums. This argument is mainly for research. Simulations show binary search has no major advantage over linear search due to caching mechanisms. The advantage may be pronounced if <code>length(v)</code> is substantial ( &gt; 10000) while <code>len</code> is small ( &lt; 5).
</p>
</td></tr>
<tr><td><code id="FLSSS_+3A_nfractiondigits">NfractionDigits</code></td>
<td>

<p>An integer, the maximum number of fractional digits of all elements in <code>v</code>. Internally, <code>v</code>, <code>target</code> and <code>ME</code> are multiplied by <code>10 ^ NfractionDigits</code>, and then converted as integer values before mining. The default <code>Inf</code> prevents such conversion. The goal is eliminate
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>len == 0</code>, <code>FLSSS()</code> would (1) reset <code>len</code> to <code>length(v)</code>, (2) pad <code>len</code> zeros at the beginning of <code>v</code> and sort <code>v</code>, (3) search for size-<code>len</code> subsets, and (4) for an index vector that represents a subset, erases elements pointing to zeros in <code>v</code>. See the <a href="https://arxiv.org/abs/1612.04484">package documentation</a> for more details.
</p>


<h3>Value</h3>

<p>A list of index vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># =====================================================================================
# Example I: play random numbers.
# =====================================================================================
# rm(list = ls()); gc()
subsetSize = 200L
supersetSize = 1000L
superset = 10000 * sort(rnorm(supersetSize) ^ 3 + 2 * runif(supersetSize) ^ 2 +
           3 * rgamma(supersetSize, 5, 1) + 4)
subsetSum = runif(1, sum(superset[1L : subsetSize]), sum(superset[(supersetSize -
            subsetSize + 1L) : supersetSize]))
subsetSumError = 1e-3


# Mine 3 subsets
rst1 = FLSSS::FLSSS(len = subsetSize, v = superset, target = subsetSum,
                    ME = subsetSumError, solutionNeed = 3, tlimit = 4)


# Mine 3 subsets via solving the conjugate problem
rst2 = FLSSS::FLSSS(len = subsetSize, v = superset, target = subsetSum,
                    ME = subsetSumError, solutionNeed = 3, tlimit = 4,
                    viaConjugate = TRUE)


# Verify uniqueness
cat("rst1 number of solutions =",
    length(unique(lapply(rst1, function(x) sort(x)))), "\n")
cat("rst2 number of solutions =",
    length(unique(lapply(rst2, function(x) sort(x)))), "\n")


# Verify solutions
if(length(rst1) &gt; 0)
  all(unlist(lapply(rst1, function(x)
    abs(sum(superset[x]) - subsetSum) &lt;= subsetSumError)))
if(length(rst2) &gt; 0)
  all(unlist(lapply(rst2, function(x)
    abs(sum(superset[x]) - subsetSum) &lt;= subsetSumError)))


# Mine 3 subsets in bounded solution space.
# Make up the lower and upper bounds for the solution space:
tmp = sort(sample(1L : supersetSize, subsetSize))
tmp2 = sort(sample(1L : supersetSize, subsetSize))
lowerBounds = pmin(tmp, tmp2)
upperBounds = pmax(tmp, tmp2)
rm(tmp, tmp2)


# 'FLSSS()' does not work if there are elements not under the hood of
# lowerBounds + upperBounds. Exclude those elements:
remainIndex = unique(unlist(apply(cbind(lowerBounds, upperBounds), 1,
  function(x) x[1] : x[2])))
lowerBounds = match(lowerBounds, remainIndex)
upperBounds = match(upperBounds, remainIndex)
superset = superset[remainIndex]


# Plant a subset sum:
solution = integer(subsetSize)
solution[1] = sample(lowerBounds[1] : upperBounds[1], 1)
for(i in 2L : subsetSize)
{
  l = max(lowerBounds[i], solution[i - 1] + 1L)
  u = upperBounds[i]
  if(l == u) solution[i] = u
  else solution[i] = sample(l : u, 1)
}
subsetSum = sum(superset[solution])
subsetSumError = abs(subsetSum) * 0.01 # relative error within 1%
rm(solution)


rst3 = FLSSS::FLSSS(len = subsetSize, v = superset, target = subsetSum,
                    ME = subsetSumError, solutionNeed = 2, tlimit = 4,
                    LB = lowerBounds, UB = upperBounds, viaConjugate = TRUE)


print(length(rst3))


# Verify solutions
if(length(rst3) &gt; 0)
  cat(all(unlist(lapply(rst3, function(x)
    abs(sum(superset[x]) - subsetSum) &lt;= subsetSumError))), "\n")




# =====================================================================================
# Example II: mine a real-world dataset.
# =====================================================================================
# rm(list = ls()); gc()
superset = c(
  -1119924501, -793412295, -496234747,  -213654767,   16818148,   26267601,   26557292,
     27340260,   28343800,   32036573,    32847411,   34570996,   34574989,   43633028,
     44003100,   47724096,   51905122,    52691025,   53600924,   56874435,   58207678,
     60225777,   60639161,   60888288,    60890325,   61742932,   63780621,   63786876,
     65167464,   66224357,   67198760,    69366452,   71163068,   72338751,   72960793,
     73197629,   76148392,   77779087,    78308432,   81196763,   82741805,   85315243,
     86446883,   87820032,   89819002,    90604146,   93761290,   97920291,   98315039,
    310120088, -441403864, -548143111,  -645883459, -149110919,  305170449, -248934805,
  -1108320430, -527806318, -192539936, -1005074405, -101557770, -156782742, -285384687,
   -418917176,   80346546, -273215446,  -552291568,   86824498,  -95392618, -707778486)
superset = sort(superset)
subsetSum = 139254953
subsetSumError = 0.1


# Find a subset of size 10.
subsetSize = 10L
rst = FLSSS::FLSSS(len = subsetSize, v = superset, target = subsetSum,
                   ME = subsetSumError, solutionNeed = 1, tlimit = 4)
# Verify:
all(unlist(lapply(rst, function(x)
  abs(sum(superset[x]) - subsetSum) &lt;= subsetSumError)))


# Find a subset without size specification.
rst = FLSSS::FLSSS(len = 0, v = superset, target = subsetSum,
                   ME = subsetSumError, solutionNeed = 1, tlimit = 4)
# Verify:
all(unlist(lapply(rst, function(x)
  abs(sum(superset[x]) - subsetSum) &lt;= subsetSumError)))


# Find a subset via looping subset size over 2L : (length(v)).
for(len in 2L : length(superset))
{
  rst = FLSSS::FLSSS(len = subsetSize, v = superset, target = subsetSum,
                     ME = subsetSumError, solutionNeed = 1, tlimit = 4)
  if(length(rst) &gt; 0) break
}
# Verify:
all(unlist(lapply(rst, function(x)
  abs(sum(superset[x]) - subsetSum) &lt;= subsetSumError)))


# Find as many qualified susbets as possible in 2 seconds
rst = FLSSS::FLSSS(len = subsetSize, v = superset, target = subsetSum,
                   ME = subsetSumError, solutionNeed = 999999L, tlimit = 2)
cat("Number of solutions =", length(rst), "\n")


# Verify:
all(unlist(lapply(rst, function(x)
  abs(sum(superset[x]) - subsetSum) &lt;= subsetSumError)))




# =====================================================================================
# Example III: solve a special knapsack problem.
# Given the knapsack's capacity, the number of catagories, the number of items in each
# catagory, select the least number of items to fulfill at least 95% of the knapsack's
# capacity.
# =====================================================================================
# rm(list = ls()); gc()
capacity = 361
catagories = LETTERS[1L : 10L] # A, B, ..., J, 10 catagories
catagoryMasses = round(runif(length(catagories)) * 20 + 1)
catagoryItems = sample(1L : 20L, length(catagories))


itemLabel = unlist(mapply(function(x, i) rep(i, x), catagoryItems, catagories))
itemMasses = unlist(mapply(function(x, i) rep(x, i), catagoryMasses, catagoryItems))
vorder = order(itemMasses)
itemLabel = itemLabel[vorder]


superset = itemMasses[vorder]
rate = 0.95
subsetSum = (capacity * rate + capacity) / 2
subsetSumError = capacity - subsetSum
for(subsetSize in 1L : length(itemMasses))
{
  rst = FLSSS::FLSSS(len = subsetSize, v = superset, target = subsetSum,
                     ME = subsetSumError, solutionNeed = 1, tlimit = 4)
  if(length(rst) &gt; 0) break
}


# There may exist no qualified subsets. One can lower 'rate' until a solution
# shows up.
if(length(rst) == 0L)
{
  cat("No solutions. Please lower rate and rerun.\n")
} else
{
  cat("A solution:\n")
  print(table(itemLabel[rst[[1]]]))
}


# rm(list = ls()); gc()
</code></pre>

<hr>
<h2 id='FLSSSmultiset'>
Multi-Subset Sum given error threshold
</h2><span id='topic+FLSSSmultiset'></span>

<h3>Description</h3>

<p>Find a subet of a given size for each of multiple supersets such that all the subsets sum in a given range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FLSSSmultiset(
  len,
  buckets,
  target,
  ME,
  solutionNeed = 1L,
  tlimit = 60,
  useBiSrchInFB = FALSE,
  NfractionDigits = Inf
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FLSSSmultiset_+3A_len">len</code></td>
<td>

<p>A positive integer vector as the subset sizes for the supersets.
</p>
</td></tr>
<tr><td><code id="FLSSSmultiset_+3A_buckets">buckets</code></td>
<td>

<p>A list of the supersets. <code>buckets[[i]]</code> is an unsorted numeric vector of size <code>len[i]</code>.
</p>
</td></tr>
<tr><td><code id="FLSSSmultiset_+3A_target">target</code></td>
<td>

<p>See <code>target</code> in <code>FLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="FLSSSmultiset_+3A_me">ME</code></td>
<td>

<p>See <code>ME</code> in <code>FLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="FLSSSmultiset_+3A_solutionneed">solutionNeed</code></td>
<td>

<p>See <code>solutionNeed</code> in <code>FLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="FLSSSmultiset_+3A_tlimit">tlimit</code></td>
<td>

<p>See <code>tlimit</code> in <code>FLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="FLSSSmultiset_+3A_usebisrchinfb">useBiSrchInFB</code></td>
<td>

<p>See <code>useBiSrchInFB</code> in <code>FLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="FLSSSmultiset_+3A_nfractiondigits">NfractionDigits</code></td>
<td>

<p>An integer, the maximum number of fractional digits of all elements in <code>v</code>. Internally, <code>v</code>, <code>target</code> and <code>ME</code> are multiplied by <code>10 ^ NfractionDigits</code>, and then converted as integer values before mining. The default <code>Inf</code> prevents such conversion.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of solutions. Each solution is a list of index vectors. Assume <code>X</code> is a solution. <code>X[[i]]</code> indexes the subset of superset <code>buckets[[i]]</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># # rm(list = ls()); gc()
Nsupersets = 30L
supersetSizes = sample(5L : 20L, Nsupersets, replace = TRUE)
subsetSizes = sapply(supersetSizes, function(x) sample(1L : x, 1))


# Create supersets at random:
supersets = lapply(supersetSizes, function(n)
{
  1000 * (rnorm(n) ^ 3 + 2 * runif(n) ^ 2 + 3 * rgamma(n, 5, 1) + 4)
})
str(supersets) # see the structure


# Give a subset sum
solution = mapply(function(n, l) sample(1L : n, l), supersetSizes, subsetSizes)
str(solution) # See structure
subsetsSum = sum(mapply(function(x, s) sum(x[s]), supersets, solution, SIMPLIFY = TRUE))
subsetsSumError = abs(subsetsSum) * 1e-7 # relative error within 0.00001%
rm(solution)


# Mine subsets:
rst = FLSSS::FLSSSmultiset(len = subsetSizes, buckets = supersets, target = subsetsSum,
                           ME = subsetsSumError, solutionNeed = 3, tlimit = 4)
cat("Number of solutions =", length(rst), "\n")


# Verify:
ver = all(unlist(lapply(rst, function(sol)
{
  S = sum(unlist(mapply(function(x, y) sum(x[y]), supersets, sol)))
  abs(S - subsetsSum) &lt;= subsetsSumError
})))
cat("All subsets are qualified:", ver)
</code></pre>

<hr>
<h2 id='GAP'>
Generalized Assignment Problem solver
</h2><span id='topic+GAP'></span>

<h3>Description</h3>

<p>Given a number of agents and a number of tasks. An agent can finish a task with certain cost and profit. An agent also has a budget. Assign tasks to agents such that each agent costs no more than its budget while the total profit is maximized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GAP(
  maxCore = 7L,
  agentsCosts,
  agentsProfits,
  agentsBudgets,
  heuristic = FALSE,
  tlimit = 60,
  threadLoad = 8L,
  verbose = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAP_+3A_maxcore">maxCore</code></td>
<td>

<p>Maximal threads to invoke. Ideally <code>maxCore</code> should not surpass the total logical processors on machine.
</p>
</td></tr>
<tr><td><code id="GAP_+3A_agentscosts">agentsCosts</code></td>
<td>

<p>A numeric matrix. <code>agentsCosts[i, j]</code> is the cost for agent <code>i</code> to finish task <code>j</code>.
</p>
</td></tr>
<tr><td><code id="GAP_+3A_agentsprofits">agentsProfits</code></td>
<td>

<p>A numeric matrix. <code>agentsProfits[i, j]</code> is the profit from agent <code>i</code> finishing task <code>j</code>.
</p>
</td></tr>
<tr><td><code id="GAP_+3A_agentsbudgets">agentsBudgets</code></td>
<td>

<p>A numeric vector. <code>agentsBudgets[i]</code> is agent <code>i</code>'s budget.
</p>
</td></tr>
<tr><td><code id="GAP_+3A_heuristic">heuristic</code></td>
<td>

<p>A boolean value. If <code>TRUE</code>, the function returns once it has found a solution whose sum of ranks of the profits becomes no less than that of the optimal. See <code>heuristic</code> in <code>mmKnapsack()</code>.
</p>
</td></tr>
<tr><td><code id="GAP_+3A_tlimit">tlimit</code></td>
<td>

<p>A numeric value. Enforce function to return in <code>tlimit</code> seconds.
</p>
</td></tr>
<tr><td><code id="GAP_+3A_threadload">threadLoad</code></td>
<td>

<p>See <code>avgThreadLoad</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="GAP_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code>, function prints progress.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of size nine.
</p>
<table>
<tr><td><code>assignedAgents</code></td>
<td>
<p>is a 2-column data frame, the mining result. The 1st column is task indexes. The 2nd column is agent indexes.</p>
</td></tr>
<tr><td><code>assignmentProfit</code></td>
<td>
<p>is the profit resulted from such assignment.</p>
</td></tr>
<tr><td><code>assignmentCosts</code></td>
<td>
<p>is a numeric vector. <code>Value$assignmentCosts[i]</code> is the cost of agent <code>i</code>.</p>
</td></tr>
<tr><td><code>agentsBudgets</code></td>
<td>
<p>is a numeric vector. <code>Value$agentsBudgets[i]</code> shows the budget of agent <code>i</code>.</p>
</td></tr>
<tr><td><code>unconstrainedMaxProfit</code></td>
<td>
<p>is the would-be maximal profit if agents had infinite budgets.</p>
</td></tr>
<tr><td><code>FLSSSsolution</code></td>
<td>
<p>is the solution from mining the corresponding multidimensional Subset Sum problem.</p>
</td></tr>
<tr><td><code>FLSSSvec</code></td>
<td>
<p>is the multidimensional vector (a matrix) going into the multidimensional Subset Sum miner.</p>
</td></tr>
<tr><td><code>MAXmat</code></td>
<td>
<p>is the subset sum targets' upper bounds going into the multidimensional Subset Sum miner.</p>
</td></tr>
<tr><td><code>foreShadowFLSSSvec</code></td>
<td>
<p>is the multidimensional vector before comonotonization.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># =====================================================================================
# Play random numbers
# =====================================================================================
# rm(list = ls()); gc()
agents = 5L
tasks = 12L
costs = t(as.data.frame(lapply(1L : agents, function(x) runif(tasks) * 1000)))
budgets = apply(costs, 1, function(x) runif(1, min(x), sum(x)))
profits = t(as.data.frame(lapply(1L : agents, function(x)
  abs(rnorm(tasks) + runif(1, 0, 4)) * 10000)))


# A dirty function for examining the result's integrity. The function takes in
# the task-agent assignment, the profit or cost matrix M, and calculates the cost
# or profit generated by each agent. 'assignment' is a 2-column data
# frame, first column task, second column agent.
agentCostsOrProfits &lt;- function(assignment, M)
{
  n = ncol(M) * nrow(M)
  M2 = matrix(numeric(n), ncol = tasks)
  for(i in 1L : nrow(assignment))
  {
    x = as.integer(assignment[i, ])
    M2[x[2], x[1]] = M[x[2], x[1]]
  }
  apply(M2, 1, function(x) sum(x))
}


dimnames(costs) = NULL
dimnames(profits) = NULL
names(budgets) = NULL


rst = FLSSS::GAP(maxCore = 7L, agentsCosts = costs, agentsProfits = profits,
                 agentsBudgets = budgets, heuristic = FALSE, tlimit = 60,
                 threadLoad = 8L, verbose = TRUE)
# Function also saves the assignment costs and profits
rst$assignedAgents
rst$assignmentProfit
rst$assignmentCosts


# Examine rst$assignmentCosts
if(sum(rst$assignedAgents) &gt; 0) # all zeros mean the function has not found a solution.
  agentCostsOrProfits(rst$assignedAgents, costs)
# Should equal rst$assignmentCosts and not surpass budgets


# Examine rst$assignmentProfits
if(sum(rst$assignedAgents) &gt; 0)
  sum(agentCostsOrProfits(rst$assignedAgents, profits))
# Should equal rst$assignmentProfit





# =====================================================================================
# Test case P03 from
# https://people.sc.fsu.edu/~jburkardt/datasets/generalized_assignment/
# =====================================================================================
agents = 3L
tasks = 8L
profits = t(matrix(c(
27, 12, 12, 16, 24, 31, 41, 13,
14,  5, 37,  9, 36, 25,  1, 34,
34, 34, 20,  9, 19, 19,  3, 34), ncol = agents))
costs = t(matrix(c(
21, 13,  9,  5,  7, 15,  5, 24,
20,  8, 18, 25,  6,  6,  9,  6,
16, 16, 18, 24, 11, 11, 16, 18), ncol = agents))
budgets = c(26, 25, 34)


rst = FLSSS::GAP(maxCore = 2L, agentsCosts = costs, agentsProfits = profits,
                 agentsBudgets = budgets, heuristic = FALSE, tlimit = 2,
                 threadLoad = 8L, verbose = TRUE)
agentCostsOrProfits(rst$assignedAgents, costs)
# Should equal rst$assignmentCosts and not surpass budgets


knownOptSolution = as.integer(c(3, 3, 1, 1, 2, 2, 1, 2))
knownOptSolution = data.frame(task = 1L : tasks, agent = knownOptSolution)


# Total profit from knownOptSolution:
sum(agentCostsOrProfits(knownOptSolution, profits))
# Total profit from FLSSS::GAP():
rst$assignmentProfit
</code></pre>

<hr>
<h2 id='ksumHash'>
Build k-sum accelerator
</h2><span id='topic+ksumHash'></span>

<h3>Description</h3>

<p>Compute k-sum lookup tables given a set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ksumHash(
  ksumK,
  V,
  ksumTableSizeScaler = 30L,
  target = NULL,
  len = 0L,
  approxNinstance = 1000L,
  verbose = TRUE,
  maxCore = 7L
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ksumHash_+3A_ksumk">ksumK</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="ksumHash_+3A_v">V</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="ksumHash_+3A_ksumtablesizescaler">ksumTableSizeScaler</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="ksumHash_+3A_target">target</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>. If <code>target != NULL</code>, the function will (i) decompose the <code>arbFLSSS</code> instance of (<code>len</code>, <code>target</code>, <code>V</code>) into about <code>approxNinstance</code> subproblems, (ii) from these subproblems infer the lower and upper index bounds for the k-subsets, and then (iii) compute &amp; hash k-sums to build the accelerator. If <code>target = NULL</code>, no bounds will be imposed on the k-subsets and the accelerator built can be used for any subset sum instance.
</p>
</td></tr>
<tr><td><code id="ksumHash_+3A_len">len</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>. Will be ignored if <code>target == NULL</code>.
</p>
</td></tr>
<tr><td><code id="ksumHash_+3A_approxninstance">approxNinstance</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="ksumHash_+3A_verbose">verbose</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="ksumHash_+3A_maxcore">maxCore</code></td>
<td>

<p>See the same argument in <code>arbFLSSS()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>k-sums are hashed using Yann Collet's xxHash that is the fastest among all non-cryptographic hash algorithms by 202204. See the benchmark &lt;https://github.com/Cyan4973/xxHash&gt;.
</p>


<h3>Value</h3>

<p>Either an empty list (happens when, e.g. <code>ksumK &lt; 3</code>), or a list of lists. The first list would be the 3-sum lookup table, and the last would be the <code>ksumK</code>-sum lookup table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
d = 5L # Set dimension.
N = 30L # Set size.
len = 10L # Subset size.
roundN = 2L # For rounding the numeric values before conversion to strings.


V = matrix(round(runif(N * d, -1e5, 1e5), roundN), nrow = N) # Make superset.
sol = sample(N, len) # Make a solution.
target = round(colSums(V[sol, ]), roundN) # Target subset sum.


optionSave = options()
options(scipen = 999) # Ensure numeric =&gt; string conversion does not
# produce strings like 2e-3.
Vstr = matrix(as.character(V), nrow = N) # String version of V.
targetStr = as.character(target)


system.time({
  theDecomposed = FLSSS::decomposeArbFLSSS(
    len = len, V = Vstr, target = targetStr, approxNinstance = 1000,
    maxCore = 2, ksumTable = NULL, ksumK = 4, verbose = TRUE)
})


# Run the objects sequentially.
rst = unlist(lapply(theDecomposed$arbFLSSSobjects, function(x)
{
  FLSSS::arbFLSSSobjRun(x, solutionNeed = 1e9, tlimit = 5, verbose = FALSE)
}), recursive = FALSE)
str(rst)


options(optionSave)
</code></pre>

<hr>
<h2 id='mFLSSSobjRun'>
Run an <code>mFLSSS</code> instance
</h2><span id='topic+mFLSSSobjRun'></span>

<h3>Description</h3>

<p>Run a multidimensional subset sum instance decomposed from <code>decomposeMflsss()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mFLSSSobjRun(
  mflsssObj,
  solutionNeed = 1,
  tlimit = 60
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mFLSSSobjRun_+3A_mflsssobj">mflsssObj</code></td>
<td>

<p>An <code>mFLSSS</code> object.
</p>
</td></tr>
<tr><td><code id="mFLSSSobjRun_+3A_solutionneed">solutionNeed</code></td>
<td>

<p>See the same argument in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSobjRun_+3A_tlimit">tlimit</code></td>
<td>

<p>See the same argument in <code>mFLSSSpar()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the details about <code>decomposeMflsss()</code>.
</p>


<h3>Value</h3>

<p>See the value of <code>mFLSSSpar()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># See the example for decomposeMflsss().
</code></pre>

<hr>
<h2 id='mFLSSSpar'>
Multithreaded multidimensional Subset Sum given error thresholds
</h2><span id='topic+mFLSSSpar'></span>

<h3>Description</h3>

<p>The multidimensional version of <code>FLSSS()</code>. See <code>decomposeMflsss()</code> for the multi-process version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mFLSSSpar(
  maxCore = 7L,
  len,
  mV,
  mTarget,
  mME,
  solutionNeed = 1L,
  tlimit = 60,
  dl = ncol(mV),
  du = ncol(mV),
  useBiSrchInFB = FALSE,
  avgThreadLoad = 8L
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mFLSSSpar_+3A_maxcore">maxCore</code></td>
<td>

<p>Maximal threads to invoke. Ideally <code>maxCore</code> should not surpass the total logical processors on machine.
</p>
</td></tr>
<tr><td><code id="mFLSSSpar_+3A_len">len</code></td>
<td>

<p>An integer as the subset size. See <code>len</code> in <code>FLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSpar_+3A_mv">mV</code></td>
<td>

<p>A data frame or a matrix as the multidimensional set, columns as dimensions.
</p>
</td></tr>
<tr><td><code id="mFLSSSpar_+3A_mtarget">mTarget</code></td>
<td>

<p>A numeric vector of size <code>ncol(mV)</code> as the subset sum.
</p>
</td></tr>
<tr><td><code id="mFLSSSpar_+3A_mme">mME</code></td>
<td>

<p>A numeric vector of size <code>ncol(mV)</code> as the subset sum error thresholds.
</p>
</td></tr>
<tr><td><code id="mFLSSSpar_+3A_solutionneed">solutionNeed</code></td>
<td>

<p>See <code>solutionNeed</code> in <code>FLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSpar_+3A_tlimit">tlimit</code></td>
<td>

<p>See <code>tlimit</code> in <code>FLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSpar_+3A_dl">dl</code></td>
<td>

<p>An integer no greater than <code>ncol(mV)</code>. Let <code>sol</code> be the index vector of a solution. Let <code>dls &lt;- 1L : dl</code>. The following is true:
</p>
<p><code>colSums(mV[sol, dls]) &gt;= mTarget[dls] - mME[dls]</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSpar_+3A_du">du</code></td>
<td>

<p>An integer no greater than <code>ncol(mV)</code>. Let <code>sol</code> be the index vector of a solution. Let <code>dus &lt;- (ncol(mV) - du + 1) : ncol(mV)</code>. The following is true:
</p>
<p><code>colSums(mV[sol, dus]) &lt;= mTarget[dus] + mME[dus]</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSpar_+3A_usebisrchinfb">useBiSrchInFB</code></td>
<td>

<p>See <code>useBiSrchInFB</code> in <code>FLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSpar_+3A_avgthreadload">avgThreadLoad</code></td>
<td>

<p>If <code>mV</code> is comonotonic, <code>mFLSSSpar()</code> warms up with a breadth-first search and then spawns at least <code>B</code> branches for parallelization. <code>B</code> equals the first power-of-two integer no less than <code>avgThreadLoad</code> <code>* maxCore</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of index vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rm(list = ls()); gc()
subsetSize = 7L
supersetSize = 60L
dimension = 5L # dimensionality


# Create a supertset at random:
N = supersetSize * dimension
superset = matrix(1000 * (rnorm(N) ^ 3 + 2 * runif(N) ^ 2 +
  3 * rgamma(N, 5, 1) + 4), ncol = dimension)
rm(N)


# Plant a subset sum:
solution = sample(1L : supersetSize, subsetSize)
subsetSum = colSums(superset[solution, ])
subsetSumError = abs(subsetSum) * 0.01 # relative error within 1%
rm(solution)


# Mine subsets, dimensions fully bounded
rst = FLSSS::mFLSSSpar(maxCore = 2, len = subsetSize, mV = superset,
                       mTarget = subsetSum, mME = subsetSumError,
                       solutionNeed = 2, dl = ncol(superset), du = ncol(superset),
                       tlimit = 2, useBiSrchInFB = FALSE, avgThreadLoad = 8L)


# Verify:
cat("Number of solutions = ", length(rst), "\n")
if(length(rst) &gt; 0)
{
  cat("Solutions unique: ")
  cat(length(unique(lapply(rst, function(x) sort(x)))) == length(rst), "\n")
  cat("Solutions correct: ")
  cat(all(unlist(lapply(rst, function(x)
    abs(colSums(superset[x, ]) - subsetSum) &lt;= subsetSumError))), "\n")
} else
{
  cat("No solutions exist or timer ended too soon.\n")
}




# Mine subsets, the first 3 dimensions lower bounded,
# the last 4 dimension upper bounded
rst = FLSSS::mFLSSSpar(maxCore = 2, len = subsetSize, mV = superset,
                       mTarget = subsetSum, mME = subsetSumError,
                       solutionNeed = 2, dl = 3L, du = 4L,
                       tlimit = 2, useBiSrchInFB = FALSE, avgThreadLoad = 8L)


# Verify:
cat("Number of solutions = ", length(rst), "\n")
if(length(rst) &gt; 0)
{
  cat("Solutions unique: ")
  cat(length(unique(lapply(rst, function(x) sort(x)))) == length(rst), "\n")
  cat("Solutions correct: ")
  cat(all(unlist(lapply(rst, function(x)
  {
    lowerBoundedDim = 1L : 3L
    lowerBounded = all(colSums(superset[x, lowerBoundedDim]) &gt;=
      subsetSum[lowerBoundedDim] - subsetSumError[lowerBoundedDim])


    upperBoundedDim = (ncol(superset) - 3L) : ncol(superset)
    upperBounded = all(colSums(superset[x, upperBoundedDim]) &lt;=
      subsetSum[upperBoundedDim] + subsetSumError[upperBoundedDim])


    lowerBounded &amp; upperBounded
  }))), "\n")
} else
{
  cat("No solutions exist or timer ended too soon.\n")
}
</code></pre>

<hr>
<h2 id='mFLSSSparImposeBounds'>
Multithreaded multidimensional Subset Sum in bounded solution space given error thresholds</h2><span id='topic+mFLSSSparImposeBounds'></span>

<h3>Description</h3>

<p>For comparison, function <code>mFLSSSpar()</code> puts no bounds on the solution space so it sorts <code>mV</code> internally in a special order for mining accerlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mFLSSSparImposeBounds(
  maxCore = 7L,
  len,
  mV,
  mTarget,
  mME,
  LB = 1L : len,
  UB = (nrow(mV) - len + 1L) : nrow(mV),
  solutionNeed = 1L,
  tlimit = 60,
  dl = ncol(mV),
  du = ncol(mV),
  targetsOrder = NULL,
  useBiSrchInFB = FALSE,
  avgThreadLoad = 8L
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mFLSSSparImposeBounds_+3A_maxcore">maxCore</code></td>
<td>

<p>See <code>maxCore</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBounds_+3A_len">len</code></td>
<td>

<p>See <code>len</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBounds_+3A_mv">mV</code></td>
<td>

<p>See <code>mV</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBounds_+3A_mtarget">mTarget</code></td>
<td>

<p>See <code>mTarget</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBounds_+3A_mme">mME</code></td>
<td>

<p>See <code>mME</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBounds_+3A_lb">LB</code></td>
<td>

<p>See <code>LB</code> in <code>FLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBounds_+3A_ub">UB</code></td>
<td>

<p>See <code>UB</code> in <code>FLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBounds_+3A_solutionneed">solutionNeed</code></td>
<td>

<p>See <code>solutionNeed</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBounds_+3A_tlimit">tlimit</code></td>
<td>

<p>See <code>tlimit</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBounds_+3A_dl">dl</code></td>
<td>

<p>See <code>dl</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBounds_+3A_du">du</code></td>
<td>

<p>See <code>du</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBounds_+3A_targetsorder">targetsOrder</code></td>
<td>

<p>This argument is mainly for research and unrecommended for use. Depending on the structure of <code>mV</code>, <code>mFLSSSpar()</code> or <br /><code>mFLSSSparImposeBounds()</code> would break the mining task into a collection of no more than <code>len * (nrow(mV) - len) + 1</code> independent subtasks. Threads work on these subtasks, sequentially coordinated by an atomic counter [1]. Different subtasks have different probabilities of yielding a qualified subset, thus the order of subtasks matters to the mining speed. <code>targetsOrder</code> is an index vector of size <code>len</code> <code>*</code> <code>(nrow(mV)</code> <code>-</code> <code>len)</code> <code>+</code> <code>1</code> for ordering the subtasks. <code>targetsOrder &lt;- NULL</code> makes a special order, and is implicitly the choice in <code>mFLSSSpar()</code>. This order is empirically optimal based on simulations. See the <a href="https://arxiv.org/abs/1612.04484">package documentation</a> for details.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBounds_+3A_usebisrchinfb">useBiSrchInFB</code></td>
<td>

<p>See <code>useBiSrchInFB</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBounds_+3A_avgthreadload">avgThreadLoad</code></td>
<td>

<p>See <code>avgThreadLoad</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of index vectors.
</p>


<h3>References</h3>

<p>[1] Atomic template class in Intel TBB. An atomic counter is used to coordinate heterogeneous subtasks to avoid idle threads. The atomic operation overhead is negligible compared to the time cost of the lightest subtask.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># rm(list = ls()); gc()
subsetSize = 7L
supersetSize = 60L
dimension = 5L # dimensionality


# Create a supertset at random:
N = supersetSize * dimension
superset = matrix(1000 * (rnorm(N) ^ 3 + 2 * runif(N) ^ 2 +
                  3 * rgamma(N, 5, 1) + 4), ncol = dimension)
rm(N)


# Make up the lower and upper bounds for the solution space:
tmp = sort(sample(1L : supersetSize, subsetSize))
tmp2 = sort(sample(1L : supersetSize, subsetSize))
lowerBounds = pmin(tmp, tmp2)
upperBounds = pmax(tmp, tmp2)
rm(tmp, tmp2)


# Exclude elements not covered by 'lowerBounds' and 'upperBounds':
remainIndex = unique(unlist(apply(cbind(lowerBounds, upperBounds), 1,
                                  function(x) x[1] : x[2])))
lowerBounds = match(lowerBounds, remainIndex)
upperBounds = match(upperBounds, remainIndex)
superset = superset[remainIndex, ]


# Plant a subset sum:
solution = apply(rbind(lowerBounds, upperBounds), 2, function(x)
  sample(x[1] : x[2], 1))
subsetSum = colSums(superset[solution, ])
subsetSumError = abs(subsetSum) * 0.01 # relative error within 1%
rm(solution)


rst = FLSSS::mFLSSSparImposeBounds(
  maxCore = 2L, len = subsetSize, mV = superset, mTarget = subsetSum,
  mME = subsetSumError, LB = lowerBounds, UB = upperBounds,
  solutionNeed = 1, tlimit = 2, dl = ncol(superset), du = ncol(superset),
  targetsOrder = NULL, useBiSrchInFB = FALSE, avgThreadLoad = 8L)


# Verify:
cat("Number of solutions = ", length(rst), "\n")
if(length(rst) &gt; 0)
{
  cat("Solutions unique: ")
  cat(length(unique(lapply(rst, function(x) sort(x)))) == length(rst), "\n")
  cat("Solution in bounded space: ")
  cat(all(unlist(lapply(rst, function(x)
    sort(x) &lt;= upperBounds &amp; sort(x) &gt;= lowerBounds))), "\n")
  cat("Solutions correct: ")
  cat(all(unlist(lapply(rst, function(x)
    abs(colSums(superset[x, ]) - subsetSum) &lt;= subsetSumError))), "\n")
} else
{
  cat("No solutions exist or timer ended too soon.\n")
}

</code></pre>

<hr>
<h2 id='mFLSSSparImposeBoundsIntegerized'>
An advanced version of <code>mFLSSSparImposeBounds()</code>
</h2><span id='topic+mFLSSSparImposeBoundsIntegerized'></span>

<h3>Description</h3>

<p>See the description of <code>mFLSSSparIntegerized()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mFLSSSparImposeBoundsIntegerized(
  maxCore = 7L,
  len,
  mV,
  mTarget,
  mME,
  LB = 1L:len,
  UB = (nrow(mV) - len + 1L) : nrow(mV),
  solutionNeed = 1L,
  precisionLevel = integer(ncol(mV)),
  returnBeforeMining = FALSE,
  tlimit = 60,
  dl = ncol(mV),
  du = ncol(mV),
  targetsOrder = NULL,
  useBiSrchInFB = FALSE,
  avgThreadLoad = 8L,
  verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mFLSSSparImposeBoundsIntegerized_+3A_maxcore">maxCore</code></td>
<td>

<p>See <code>maxCore</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBoundsIntegerized_+3A_len">len</code></td>
<td>

<p>See <code>len</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBoundsIntegerized_+3A_mv">mV</code></td>
<td>

<p>See <code>mV</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBoundsIntegerized_+3A_mtarget">mTarget</code></td>
<td>

<p>See <code>mTarget</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBoundsIntegerized_+3A_mme">mME</code></td>
<td>

<p>See <code>mME</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBoundsIntegerized_+3A_lb">LB</code></td>
<td>

<p>See <code>LB</code> in <code>FLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBoundsIntegerized_+3A_ub">UB</code></td>
<td>

<p>See <code>UB</code> in <code>FLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBoundsIntegerized_+3A_solutionneed">solutionNeed</code></td>
<td>

<p>See <code>solutionNeed</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBoundsIntegerized_+3A_precisionlevel">precisionLevel</code></td>
<td>

<p>See <code>precisionLevel</code> in <code>mFLSSSparIntegerized()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBoundsIntegerized_+3A_returnbeforemining">returnBeforeMining</code></td>
<td>

<p>See <code>returnBeforeMining</code> in <code>mFLSSSparIntegerized()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBoundsIntegerized_+3A_tlimit">tlimit</code></td>
<td>

<p>See <code>tlimit</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBoundsIntegerized_+3A_dl">dl</code></td>
<td>

<p>See <code>dl</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBoundsIntegerized_+3A_du">du</code></td>
<td>

<p>See <code>dl</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBoundsIntegerized_+3A_targetsorder">targetsOrder</code></td>
<td>

<p>See <code>targetsOrder</code> in <code>mFLSSSparImposeBounds()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBoundsIntegerized_+3A_usebisrchinfb">useBiSrchInFB</code></td>
<td>

<p>See <code>useBiSrchInFB</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBoundsIntegerized_+3A_avgthreadload">avgThreadLoad</code></td>
<td>

<p>See <code>avgThreadLoad</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparImposeBoundsIntegerized_+3A_verbose">verbose</code></td>
<td>

<p>If TRUE, prints mining progress.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code>Value</code> in <code>mFLSSSparIntegerized()</code>.
</p>


<h3>Note</h3>

<p>32-bit architecture unsupported.</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(.Machine$sizeof.pointer == 8L){
# =====================================================================================
# 64-bit architecture required.
# =====================================================================================
# rm(list = ls()); gc()
subsetSize = 7L
supersetSize = 60L
dimension = 5L # dimensionality


# Create a superset at random:
N = supersetSize * dimension
superset = matrix(1000 * (rnorm(N) ^ 3 + 2 * runif(N) ^ 2 +
                  3 * rgamma(N, 5, 1) + 4), ncol = dimension)
rm(N)


# Make up the lower and upper bounds for the solution space:
tmp = sort(sample(1L : supersetSize, subsetSize))
tmp2 = sort(sample(1L : supersetSize, subsetSize))
lowerBounds = pmin(tmp, tmp2)
upperBounds = pmax(tmp, tmp2)
rm(tmp, tmp2)


# 'mFLSSSparImposeBoundsIntegerized()' does not work if there are elements not
# under the hood of 'lowerBounds' + 'upperBounds'. Exclude these elements first:
remainIndex = unique(unlist(
  apply(cbind(lowerBounds, upperBounds), 1, function(x) x[1] : x[2])))
lowerBounds = match(lowerBounds, remainIndex)
upperBounds = match(upperBounds, remainIndex)
superset = superset[remainIndex, ]


# Plant a subset sum:
solution = integer(subsetSize)
solution[1] = sample(lowerBounds[1] : upperBounds[1], 1)
for(i in 2L : subsetSize)
{
  l = max(lowerBounds[i], solution[i - 1] + 1L)
  u = upperBounds[i]
  if(l == u) solution[i] = u
  else solution[i] = sample(l : u, 1)
}
subsetSum = colSums(superset[solution, ])
subsetSumError = abs(subsetSum) * 0.01 # relative error within 1%
rm(solution)


system.time({rst = FLSSS::mFLSSSparImposeBoundsIntegerized(
  maxCore = 2L, len = subsetSize, mV = superset, mTarget = subsetSum,
  mME = subsetSumError, LB = lowerBounds, UB = upperBounds,
  solutionNeed = 1, tlimit = 3, dl = ncol(superset), du = ncol(superset),
  targetsOrder = NULL, useBiSrchInFB = FALSE, avgThreadLoad = 8L)})


# Compare the time cost of 'mFLSSSparImposeBoundsIntegerized()' and
# 'mFLSSSparImposeBounds()'. The speed advantage of 'mFLSSSparIntegerized()'
# may not be pronounced for toy examples.
system.time(FLSSS::mFLSSSparImposeBounds(
  maxCore = 2L, len = subsetSize, mV = superset, mTarget = subsetSum,
  mME = subsetSumError, LB = lowerBounds, UB = upperBounds,
  solutionNeed = 1, tlimit = 2, dl = ncol(superset), du = ncol(superset),
  targetsOrder = NULL, useBiSrchInFB = FALSE, avgThreadLoad = 8L))


# Verify:
cat("Number of solutions = ", length(rst$solution), "\n")
if(length(rst$solution) &gt; 0)
{
  cat("Solutions unique: ")
  cat(length(unique(lapply(rst$solution, function(x)
    sort(x)))) == length(rst$solution), "\n")
  cat("Solution in bounded space: ")
  cat(all(unlist(lapply(rst$solution, function(x)
    sort(x) &lt;= upperBounds &amp; sort(x) &gt;= lowerBounds))), "\n")


  cat("Solutions correct regarding integerized data: ")
  cat(all(unlist(lapply(rst$solution, function(x)
    abs(colSums(rst$INT$mV[x, ]) - rst$INT$mTarget) &lt;= rst$INT$mME))), "\n")


  cat("Solutions correct regarding original data: ")
  boolean = all(unlist(lapply(rst$solution, function(x)
    abs(colSums(superset[x, ]) - subsetSum) &lt;= subsetSumError)))
  cat(boolean, "\n")
  if(!boolean)
  {
    cat("The given error threshold relative to subset sum:\n")
    givenRelaErr = round(abs(subsetSumError / subsetSum), 5)
    cat(givenRelaErr, "\n")


    cat("Solution subset sum relative error:\n")
    tmp = lapply(rst$solution, function(x)
    {
      err = round(abs(colSums(superset[x, ]) / subsetSum -1), 5)
      for(i in 1L : length(err))
      {
        if(givenRelaErr[i] &lt; err[i]) message(paste0(err[i], " "), appendLF = FALSE)
        else cat(err[i], "")
      }
      cat("\n")
    })
    cat("Integerization caused the errors. Future versions of")
    cat("'mFLSSSparIntegerized()' would have a parameter of precision level.\n")
  }
} else
{
  cat("No solutions exist or timer ended too soon.\n")
}

# =====================================================================================
# =====================================================================================
}
</code></pre>

<hr>
<h2 id='mFLSSSparIntegerized'>
An advanced version of <code>mFLSSSpar()</code>
</h2><span id='topic+mFLSSSparIntegerized'></span>

<h3>Description</h3>

<p>This function maps a real-value multidimensional Subset Sum problem to the integer domain with minimal precision loss. Those integers are further compressed in 64-bit buffers for dimension reduction and SWAR (SIMD within a register) that could lead to substantial acceleration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mFLSSSparIntegerized(
  maxCore = 7L,
  len,
  mV,
  mTarget,
  mME,
  solutionNeed = 1L,
  precisionLevel = integer(ncol(mV)),
  returnBeforeMining = FALSE,
  tlimit = 60,
  dl = ncol(mV),
  du = ncol(mV),
  useBiSrchInFB = FALSE,
  avgThreadLoad = 8L,
  verbose = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mFLSSSparIntegerized_+3A_maxcore">maxCore</code></td>
<td>

<p>See <code>maxCore</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparIntegerized_+3A_len">len</code></td>
<td>

<p>See <code>len</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparIntegerized_+3A_mv">mV</code></td>
<td>

<p>See <code>mV</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparIntegerized_+3A_mtarget">mTarget</code></td>
<td>

<p>See <code>mTarget</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparIntegerized_+3A_mme">mME</code></td>
<td>

<p>See <code>mME</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparIntegerized_+3A_solutionneed">solutionNeed</code></td>
<td>

<p>See <code>solutionNeed</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparIntegerized_+3A_precisionlevel">precisionLevel</code></td>
<td>

<p>An integer vector of size equal to the dimensionality of <code>mV</code>. This argument controls the precision of real-to-integer conversion.
</p>
<p>If <code>precisionLevel[i] = 0</code>, <code>mV[,i]</code> is shifted, scaled and rounded to the nearest integers such that the maximum becomes no less than <code>nrow(mV) * 8</code>.
</p>
<p>If <code>precisionLevel[i] &gt; 0</code>, e.g. <code>precisionLevel[i] = 1000</code>, <code>mV[,i]</code> is shifted, scaled and rounded to the nearest integers such that the maximum becomes no less than 1000.
</p>
<p>If <code>precisionLevel[i] = -1</code>, <code>mV[,i]</code> is shifted, scaled and rounded to the nearest integers such that ranks of elements stay the same.
</p>
<p>The shift operator contributes no precision loss. It only lowers the number of bits used for storing integers.
</p>
</td></tr>
<tr><td><code id="mFLSSSparIntegerized_+3A_returnbeforemining">returnBeforeMining</code></td>
<td>

<p>A boolean value. If <code>TRUE</code>, function returns the integerized <code>mV</code>, <code>mTarget</code> and <code>mME</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparIntegerized_+3A_tlimit">tlimit</code></td>
<td>

<p>See <code>tlimit</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparIntegerized_+3A_dl">dl</code></td>
<td>

<p>See <code>dl</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparIntegerized_+3A_du">du</code></td>
<td>

<p>See <code>du</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparIntegerized_+3A_usebisrchinfb">useBiSrchInFB</code></td>
<td>

<p>See <code>useBiSrchInFB</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparIntegerized_+3A_avgthreadload">avgThreadLoad</code></td>
<td>

<p>See <code>avgThreadLoad</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mFLSSSparIntegerized_+3A_verbose">verbose</code></td>
<td>

<p>If TRUE, prints mining progress.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two.
</p>
<table>
<tr><td><code>Value$solution</code></td>
<td>
<p>is a list of solution index vectors.</p>
</td></tr>
<tr><td><code>Value$INT</code></td>
<td>
<p>is a list of three.</p>
</td></tr>
<tr><td><code>Value$INT$mV</code></td>
<td>
<p>is the integerized superset.</p>
</td></tr>
<tr><td><code>Value$INT$mTarget</code></td>
<td>
<p>is the integerized subset sum.</p>
</td></tr>
<tr><td><code>Value$INT$mME</code></td>
<td>
<p>is the integerized subset sum error threshold.</p>
</td></tr>
<tr><td><code>Value$INT$compressedDim</code></td>
<td>
<p>is the dimensionality after integerization.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>32-bit architecture unsupported.</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(.Machine$sizeof.pointer == 8L){
# =====================================================================================
# 64-bit architecture required.
# =====================================================================================
# rm(list = ls()); gc()
subsetSize = 7L
supersetSize = 60L
dimension = 5L # dimensionality


# Create a supertset at random:
N = supersetSize * dimension
superset = matrix(1000 * (rnorm(N) ^ 3 + 2 * runif(N) ^ 2 + 3 * rgamma(N, 5, 1) + 4),
                  ncol = dimension)
rm(N)


# Plant a subset sum:
solution = sample(1L : supersetSize, subsetSize)
subsetSum = colSums(superset[solution, ])
subsetSumError = abs(subsetSum) * 0.01 # relative error within 1%
rm(solution)


# Mine subsets, dimensions fully bounded
system.time({rst = FLSSS::mFLSSSparIntegerized(
  maxCore = 2, len = subsetSize, mV = superset, mTarget = subsetSum,
  mME = subsetSumError, solutionNeed = 2, dl = ncol(superset),
  du = ncol(superset), tlimit = 2, useBiSrchInFB = FALSE, avgThreadLoad = 8L)})


# Compare the time cost of 'mFLSSSparIntegerized()' and 'mFLSSSpar()'. The
# speed advantage of 'mFLSSSparIntegerized()' may not be pronounced for toy
# examples.
system.time(FLSSS::mFLSSSpar(
  maxCore = 2, len = subsetSize, mV = superset, mTarget = subsetSum,
  mME = subsetSumError, solutionNeed = 2, dl = ncol(superset),
  du = ncol(superset), tlimit = 2, useBiSrchInFB = FALSE, avgThreadLoad = 8L))


# Verify:
cat("Number of solutions = ", length(rst$solution), "\n")
if(length(rst$solution) &gt; 0)
{
  cat("Solutions unique: ")
  cat(length(unique(lapply(rst$solution, function(x)
    sort(x)))) == length(rst$solution), "\n")


  cat("Solutions correct regarding integerized data: ")
  cat(all(unlist(lapply(rst$solution, function(x)
    abs(colSums(rst$INT$mV[x, ]) - rst$INT$mTarget) &lt;= rst$INT$mME))), "\n")


  cat("Solutions correct regarding original data: ")
  boolean = all(unlist(lapply(rst$solution, function(x)
    abs(colSums(superset[x, ]) - subsetSum) &lt;= subsetSumError)))
  cat(boolean, "\n")
  if(!boolean)
  {
    cat("The given error threshold relative to subset sum:\n")
    givenRelaErr = round(abs(subsetSumError / subsetSum), 5)
    cat(givenRelaErr, "\n")


    cat("Solution subset sum relative error:\n")
    tmp = lapply(rst$solution, function(x)
    {
      err = round(abs(colSums(superset[x, ]) / subsetSum -1), 5)
      for(i in 1L : length(err))
      {
        if(givenRelaErr[i] &lt; err[i]) message(paste0(err[i], " "), appendLF = FALSE)
        else cat(err[i], "")
      }
      cat("\n")
    })
    cat("Integerization caused the errors. Future versions of")
    cat("'mFLSSSparIntegerized()' would have a parameter of precision level.\n")
  }
} else
{
  cat("No solutions exist or time ended too soon.\n")
}


# Mine subsets, the first 3 dimensions lower bounded,
# the last 4 dimension upper bounded
rst = FLSSS::mFLSSSparIntegerized(
  maxCore = 2, len = subsetSize, mV = superset, mTarget = subsetSum,
  mME = subsetSumError, solutionNeed = 2, dl = 3L, du = 4L, tlimit = 2,
  useBiSrchInFB = FALSE, avgThreadLoad = 8L)


# Verify:
cat("Number of solutions = ", length(rst$solution), "\n")
if(length(rst$solution) &gt; 0)
{
  cat("Solutions unique: ")
  cat(length(unique(lapply(rst$solution, function(x)
    sort(x)))) == length(rst$solution), "\n")


  cat("Solutions correct regarding integerized data: ")
  cat(all(unlist(lapply(rst$solution, function(x)
  {
    lowerBoundedDim = 1L : 3L
    lowerBounded = all(colSums(rst$INT$mV[x, lowerBoundedDim]) &gt;=
      rst$INT$mTarget[lowerBoundedDim] - rst$INT$mME[lowerBoundedDim])


    upperBoundedDim = (ncol(rst$INT$mV) - 3L) : ncol(rst$INT$mV)
    upperBounded = all(colSums(rst$INT$mV[x, upperBoundedDim]) &lt;=
      rst$INT$mTarget[upperBoundedDim] + rst$INT$mME[upperBoundedDim])


    lowerBounded &amp; upperBounded
  }))), "\n")
} else
{
  cat("No solutions exist or timer ended too soon.\n")
}
# =====================================================================================
# =====================================================================================
}
</code></pre>

<hr>
<h2 id='mmKnapsack'>
Multithreaded multidimensional Knapsack problem solver
</h2><span id='topic+mmKnapsack'></span>

<h3>Description</h3>

<p>Given a set of items characterized by a profit attribute and multiple cost attributes, <code>mmKnapsack()</code> seeks a subset that maximizes the total profit while the subset sum in each cost dimension is upper bounded. The function applies to the 0-1 Knapsack problem. For the bounded or unbounded Knapsack problem, one can replicate items as needed and turn the problem into 0-1 Knapsack. Profits and costs should be nonnegative. Negative values in data can be neutralized by shifting and scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmKnapsack(
  maxCore = 7L,
  len,
  itemsProfits,
  itemsCosts,
  capacities,
  heuristic = FALSE,
  tlimit = 60,
  useBiSrchInFB = FALSE,
  threadLoad = 8L,
  verbose = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmKnapsack_+3A_maxcore">maxCore</code></td>
<td>

<p>Maximal threads to invoke. Ideally <code>maxCore</code> should not surpass the total logical processors on machine.
</p>
</td></tr>
<tr><td><code id="mmKnapsack_+3A_len">len</code></td>
<td>

<p>An integer as the subset size. See <code>len</code> in <code>FLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="mmKnapsack_+3A_itemsprofits">itemsProfits</code></td>
<td>

<p>A nonnegative numeric vector of size equal to the number of items.
</p>
</td></tr>
<tr><td><code id="mmKnapsack_+3A_itemscosts">itemsCosts</code></td>
<td>

<p>A nonnegative numeric matrix. Number of rows equals number of items. Number of columns equals number of cost dimensions.
</p>
</td></tr>
<tr><td><code id="mmKnapsack_+3A_capacities">capacities</code></td>
<td>

<p>A numeric vector of size equal to the number of cost dimensions. <code>capacities[i]</code> upper-bounds the total cost in <code>itemsCosts[, i]</code>.
</p>
</td></tr>
<tr><td><code id="mmKnapsack_+3A_heuristic">heuristic</code></td>
<td>

<p>A boolean value. If <code>TRUE</code>, the function returns once it has found a solution whose sum of ranks of the profits is no less than that of the optimal. See Examples.
</p>
</td></tr>
<tr><td><code id="mmKnapsack_+3A_tlimit">tlimit</code></td>
<td>

<p>A numeric value. Enforce function to return in <code>tlimit</code> seconds.
</p>
</td></tr>
<tr><td><code id="mmKnapsack_+3A_usebisrchinfb">useBiSrchInFB</code></td>
<td>

<p>See <code>useBiSrchInFB</code> in <code>FLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="mmKnapsack_+3A_threadload">threadLoad</code></td>
<td>

<p>See <code>avgThreadLoad</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mmKnapsack_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code>, function prints progress.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If no solution, an empty list, otherwise a list of five:
</p>
<table>
<tr><td><code>solution</code></td>
<td>
<p> The optimal solution.</p>
</td></tr>
<tr><td><code>selectionCosts</code></td>
<td>
<p> Solution costs.</p>
</td></tr>
<tr><td><code>budgets</code></td>
<td>
<p> Knapsack capacities.</p>
</td></tr>
<tr><td><code>selectionProfit</code></td>
<td>
<p> Solution total profit.</p>
</td></tr>
<tr><td><code>unconstrainedMaxProfit</code></td>
<td>
<p> Maximal profit given infinite budgets.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># =====================================================================================
# Play random numbers
# =====================================================================================
# rm(list = ls()); gc()
subsetSize = 6
supersetSize = 60
NcostsAttr = 4


  # Make up costs for each item.
  costs = abs(6 * (rnorm(supersetSize * NcostsAttr) ^ 3 +
                     2 * runif(supersetSize * NcostsAttr) ^ 2 +
                     3 * rgamma(supersetSize * NcostsAttr, 5, 1) + 4))
  costs = matrix(costs, ncol = NcostsAttr)


  # Make up cost limits.
  budgets = apply(costs, 2, function(x)
  {
    x = sort(x)
    Min = sum(x[1L : subsetSize])
    Max = sum(x[(supersetSize - subsetSize + 1L) : supersetSize])
    runif(1, Min, Max)
  })


  # Make up item profits.
  gains = rnorm(supersetSize) ^ 2 * 10000 + 100


  rst1 = FLSSS::mmKnapsack(
    maxCore = 2L, len = subsetSize, itemsProfits = gains, itemsCosts = costs,
    capacities = budgets, heuristic = FALSE, tlimit = 60, useBiSrchInFB = FALSE,
    threadLoad = 4L, verbose = TRUE)


  # Let 'x' be the solution given 'heuristic = TRUE'. The sum of ranks of the
  # profits subsetted by 'x' would be no less than that of the optimal solution.
  rst2 = FLSSS::mmKnapsack(
    maxCore = 2L, len = subsetSize, itemsProfits = gains, itemsCosts = costs,
    capacities = budgets, heuristic = TRUE, tlimit = 60, useBiSrchInFB = FALSE,
    threadLoad = 4L, verbose = TRUE)


  # Exam difference in total profits given by the heuristic and the optimal:
  cat(length(rst1$solution)); cat(length(rst2$solution)) # See if solution exists.
  if(length(rst1$solution) &gt; 0 &amp; length(rst2$solution) &gt; 0)
    sum(gains[rst2$solution]) / sum(gains[rst1$solution])





# =====================================================================================
# Test case P08 from
# https://people.sc.fsu.edu/~jburkardt/datasets/knapsack_01/knapsack_01.html
# =====================================================================================
# rm(list = ls()); gc()
costs = matrix(c(382745, 799601, 909247, 729069, 467902,  44328,  34610, 698150,
                 823460, 903959, 853665, 551830, 610856, 670702, 488960, 951111,
                 323046, 446298, 931161,  31385, 496951, 264724, 224916, 169684),
               ncol = 1)


gains = c( 825594, 1677009, 1676628, 1523970,  943972,   97426,  69666, 1296457,
           1679693, 1902996, 1844992, 1049289, 1252836, 1319836, 953277, 2067538,
           675367,  853655, 1826027,   65731,  901489,  577243, 466257,  369261)


budgets = 6404180


# 'mmKnapsack()' is designed for the multidimensional Knapsack and may not
# be ideal for one-dimensional 0-1 Knapsack regarding computing speed.
# 'len = 0' causes substantial deceleration. Looping 'len' over possible
# values is recommended if 'len' is ungiven.
rst1 = FLSSS::mmKnapsack(
  maxCore = 2L, len = 12L, itemsProfits = gains, itemsCosts = costs,
  capacities = budgets, heuristic = FALSE, tlimit = 2, threadLoad = 4L,
  verbose = TRUE)
rst1 = sort(rst1$solution)


cat("Correct solution:\n1 2 4 5 6 10 11 13 16 22 23 24\nFLSSS solution =\n")
cat(rst1, "\n")




# =====================================================================================
# Test case P07 from
# https://people.sc.fsu.edu/~jburkardt/datasets/knapsack_01/knapsack_01.html
# =====================================================================================
costs = matrix(c(70, 73, 77, 80, 82, 87, 90, 94, 98, 106, 110, 113, 115, 118, 120),
               ncol = 1)


gains = c(135, 139, 149, 150, 156, 163, 173, 184, 192, 201, 210, 214, 221, 229, 240)


budgets = 750


rst2 = FLSSS::mmKnapsack(
  maxCore = 2L, len = 8L, itemsProfits = gains, itemsCosts = costs,
  capacities = budgets, heuristic = FALSE, tlimit = 2,
  threadLoad = 4L, verbose = TRUE)
rst2 = sort(rst2$solution)


cat("Correct solution:\n1 3 5 7 8 9 14 15\nFLSSS solution =\n")
cat(rst2, "\n")
</code></pre>

<hr>
<h2 id='mmKnapsackIntegerized'>
An advanced version of <code>mmKnapsack()</code>
</h2><span id='topic+mmKnapsackIntegerized'></span>

<h3>Description</h3>

<p>See the description of <code>mFLSSSparIntegerized()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mmKnapsackIntegerized(
  maxCore = 7L,
  len,
  itemsProfits,
  itemsCosts,
  capacities,
  heuristic = FALSE,
  precisionLevel = integer(length(capacities)),
  returnBeforeMining = FALSE,
  tlimit = 60,
  useBiSrchInFB = FALSE,
  threadLoad = 8L,
  verbose = TRUE
  )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mmKnapsackIntegerized_+3A_maxcore">maxCore</code></td>
<td>

<p>See <code>maxCore</code> in <code>mmKnapsack()</code>.
</p>
</td></tr>
<tr><td><code id="mmKnapsackIntegerized_+3A_len">len</code></td>
<td>

<p>See <code>len</code> in <code>mmKnapsack()</code>.
</p>
</td></tr>
<tr><td><code id="mmKnapsackIntegerized_+3A_itemsprofits">itemsProfits</code></td>
<td>

<p>See <code>itemsProfits</code> in <code>mmKnapsack()</code>.
</p>
</td></tr>
<tr><td><code id="mmKnapsackIntegerized_+3A_itemscosts">itemsCosts</code></td>
<td>

<p>See <code>itemsCosts</code> in <code>mmKnapsack()</code>.
</p>
</td></tr>
<tr><td><code id="mmKnapsackIntegerized_+3A_capacities">capacities</code></td>
<td>

<p>See <code>capacities</code> in <code>mmKnapsack()</code>.
</p>
</td></tr>
<tr><td><code id="mmKnapsackIntegerized_+3A_heuristic">heuristic</code></td>
<td>

<p>See <code>heuristic</code> in <code>mmKnapsack()</code>.
</p>
</td></tr>
<tr><td><code id="mmKnapsackIntegerized_+3A_precisionlevel">precisionLevel</code></td>
<td>

<p>See <code>precisionLevel</code> in <code>mFLSSSparIntegerized()</code>.
</p>
</td></tr>
<tr><td><code id="mmKnapsackIntegerized_+3A_returnbeforemining">returnBeforeMining</code></td>
<td>

<p>See <code>returnBeforeMining</code> in <code>mFLSSSparIntegerized()</code>.
</p>
</td></tr>
<tr><td><code id="mmKnapsackIntegerized_+3A_tlimit">tlimit</code></td>
<td>

<p>See <code>tlimit</code> in <code>mmKnapsack()</code>.
</p>
</td></tr>
<tr><td><code id="mmKnapsackIntegerized_+3A_usebisrchinfb">useBiSrchInFB</code></td>
<td>

<p>See <code>useBiSrchInFB</code> in <code>FLSSS()</code>.
</p>
</td></tr>
<tr><td><code id="mmKnapsackIntegerized_+3A_threadload">threadLoad</code></td>
<td>

<p>See <code>avgThreadLoad</code> in <code>mFLSSSpar()</code>.
</p>
</td></tr>
<tr><td><code id="mmKnapsackIntegerized_+3A_verbose">verbose</code></td>
<td>

<p>If <code>TRUE</code>, function prints progress.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of six:
</p>
<table>
<tr><td><code>solution</code></td>
<td>
<p> The optimal solution.</p>
</td></tr>
<tr><td><code>selectionCosts</code></td>
<td>
<p> Solution costs.</p>
</td></tr>
<tr><td><code>budgets</code></td>
<td>
<p> Knapsack capacities.</p>
</td></tr>
<tr><td><code>selectionProfit</code></td>
<td>
<p> Solution total profit.</p>
</td></tr>
<tr><td><code>unconstrainedMaxProfit</code></td>
<td>
<p> Maximal profit given infinite budgets.</p>
</td></tr>
<tr><td><code>INT</code></td>
<td>
<p> A list of four:</p>
</td></tr>
<tr><td><code>INT$mV</code></td>
<td>
<p> The integerized superset.</p>
</td></tr>
<tr><td><code>INT$mTarget</code></td>
<td>
<p> The integerized subset sum.</p>
</td></tr>
<tr><td><code>INT$mME</code></td>
<td>
<p> The integerized subset sum error threshold.</p>
</td></tr>
<tr><td><code>INT$compressedDim</code></td>
<td>
<p> The dimensionality after integerization.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>32-bit architecture unsupported.</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(.Machine$sizeof.pointer == 8L){
# =====================================================================================
# 64-bit architecture required.
# =====================================================================================
# =====================================================================================
# Play random numbers
# =====================================================================================
# rm(list = ls()); gc()
subsetSize = 6
supersetSize = 60
NcostsAttr = 4


# Make up costs for each item.
costs = abs(6 * (rnorm(supersetSize * NcostsAttr) ^ 3 +
  2 * runif(supersetSize * NcostsAttr) ^ 2 +
  3 * rgamma(supersetSize * NcostsAttr, 5, 1) + 4))
costs = matrix(costs, ncol = NcostsAttr)


# Make up cost limits.
budgets = apply(costs, 2, function(x)
{
  x = sort(x)
  Min = sum(x[1L : subsetSize])
  Max = sum(x[(supersetSize - subsetSize + 1L) : supersetSize])
  runif(1, Min, Max)
})


# Make up item profits.
gains = rnorm(supersetSize) ^ 2 * 10000 + 100


rst1 = FLSSS::mmKnapsackIntegerized(
  maxCore = 2L, len = subsetSize, itemsProfits = gains, itemsCosts = costs,
  capacities = budgets, heuristic = FALSE, tlimit = 2, useBiSrchInFB = FALSE,
  threadLoad = 4L, verbose = TRUE)


# Examine if 'mmKnapsackIntegerized()' gives the same solution as 'mmKnapsack()'.
rst2 = FLSSS::mmKnapsack(
  maxCore = 2L, len = subsetSize, itemsProfits = gains, itemsCosts = costs,
  capacities = budgets, heuristic = FALSE, tlimit = 2, useBiSrchInFB = FALSE,
  threadLoad = 4L, verbose = TRUE)
# Possible differences in solutions are due to real-integer conversion




# Let 'x' be the solution given 'heuristic = T'. The sum of ranks of the
# profits subsetted by 'x' would be no less than that of the optimal solution.
rst3 = FLSSS::mmKnapsackIntegerized(
  maxCore = 2L, len = subsetSize, itemsProfits = gains, itemsCosts = costs,
  capacities = budgets, heuristic = TRUE, tlimit = 2, useBiSrchInFB = FALSE,
  threadLoad = 4L, verbose = TRUE)


# Exam difference in total profits given by the heuristic and the optimal:
if(length(rst3$solution) &gt; 0 &amp; length(rst1$solution) &gt; 0)
  sum(gains[rst3$solution]) / sum(gains[rst1$solution])





# =====================================================================================
# Test case P08 from
# https://people.sc.fsu.edu/~jburkardt/datasets/knapsack_01/knapsack_01.html
# =====================================================================================
costs = matrix(c(382745, 799601, 909247, 729069, 467902,  44328,  34610, 698150,
                 823460, 903959, 853665, 551830, 610856, 670702, 488960, 951111,
                 323046, 446298, 931161,  31385, 496951, 264724, 224916, 169684),
               ncol = 1)


gains = c( 825594, 1677009, 1676628, 1523970,  943972,   97426,  69666, 1296457,
          1679693, 1902996, 1844992, 1049289, 1252836, 1319836, 953277, 2067538,
           675367,  853655, 1826027,   65731,  901489,  577243, 466257,  369261)


budgets = 6404180


# 'mmKnapsackIntegerized()' is designed for the multidimensional Knapsack
# and may not be ideal for one-dimensional 0-1 Knapsack regarding computing speed.
# 'len = 0' would cause severe deceleration. Looping 'len' over possible
# values is recommended if 'len' is ungiven.
rst = FLSSS::mmKnapsackIntegerized(
  maxCore = 2L, len = 12L, itemsProfits = gains, itemsCosts = costs,
  capacities = budgets, heuristic = FALSE, tlimit = 2, threadLoad = 4L, verbose = TRUE)
rst = sort(rst$solution)


cat("Correct solution:\n1 2 4 5 6 10 11 13 16 22 23 24\nFLSSS solution =\n")
cat(rst, "\n")
# The difference is due to rounding errors in real-integer conversion. The default
# 'precisionLevel' shifts, scales and rounds 'itemCosts' such that its
# maximal element is no less than 8 times the number of items.


# Increase the precision level
rst = FLSSS::mmKnapsackIntegerized(
  maxCore = 2L, len = 12L, itemsProfits = gains, itemsCosts = costs,
  capacities = budgets, heuristic = FALSE, precisionLevel = rep(500L, 1),
  tlimit = 2, threadLoad = 4L, verbose = TRUE)
# 'precisionLevel = 500' shifts, scales and rounds 'itemCosts' such that its
# maximal element is no less than 500.
rst = sort(rst$solution)
cat("Correct solution:\n1 2 4 5 6 10 11 13 16 22 23 24\nFLSSS solution =\n")
cat(rst, "\n")
}
# =====================================================================================
# =====================================================================================
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
