<!DOCTYPE html><html><head><title>Help for package GE</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GE}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AMSD'><p>Additive-Mean-Variance Utility Function and Additive-Mean-Standard-Deviation Utility Function</p></a></li>
<li><a href='#AMSDP'><p>Additive-Mean-Standard-Deviation Portfolio Utility Function</p></a></li>
<li><a href='#apply_expand.grid'><p>Applying a Function to All Combinations of the Supplied Vectors</p></a></li>
<li><a href='#CARA'><p>Constant Absolute Risk Aversion (CARA) Utility Function</p></a></li>
<li><a href='#CES'><p>CES Function</p></a></li>
<li><a href='#CESAK_dc'><p>Demand coefficients of the CESAK Production Function</p></a></li>
<li><a href='#CRRA'><p>Constant Relative Risk Aversion (CRRA) Utility Function</p></a></li>
<li><a href='#DCES'><p>Displaced CES Utility Function and Displaced CES Demand Function</p></a></li>
<li><a href='#demand_coefficient'><p>Compute Demand Coefficients of an Agent with a Demand Structural Tree</p></a></li>
<li><a href='#demCreditPolicy'><p>A Disequilibrium Model with Credit</p></a></li>
<li><a href='#demInsufficientEffectiveDemand_3_3'><p>A Disequilibrium Model Illustrating Insufficient Effective Demand (Supply-demand Structural Mismatch)</p></a></li>
<li><a href='#ge_tidy'><p>Tidy a General Equilibrium</p></a></li>
<li><a href='#gem_2_2'><p>Some Simple 2-by-2 General Equilibrium Models</p></a></li>
<li><a href='#gem_3_2'><p>Some Simple 3-by-2 General Equilibrium Models</p></a></li>
<li><a href='#gem_3_3'><p>Some Simple 3-by-3 General Equilibrium Models</p></a></li>
<li><a href='#gem_3_4'><p>Some Simple 3-by-4 General Equilibrium Models</p></a></li>
<li><a href='#gem_4_4'><p>Some Simple 4-by-4 General Equilibrium Models</p></a></li>
<li><a href='#gemAssetExchange_MatthewEffect_2_2'><p>An Example Illustrating the Matthew Effect of Asset Exchange</p></a></li>
<li><a href='#gemAssetPricing_CUF'><p>Compute Asset Market Equilibria with Commodity Utility Functions for Some Simple Cases</p></a></li>
<li><a href='#gemAssetPricing_PUF'><p>Compute Asset Market Equilibria with Portfolio Utility Functions for Some Simple Cases</p></a></li>
<li><a href='#gemAssetPricingExample'><p>Some Examples of Asset Pricing</p></a></li>
<li><a href='#gemBalancedGrowthPath'><p>Some Examples of Balanced Growth Paths</p></a></li>
<li><a href='#gemCanonicalDynamicMacroeconomic_3_2'><p>A Canonical Dynamic Macroeconomic General Equilibrium Model (see Torres, 2016)</p></a></li>
<li><a href='#gemCanonicalDynamicMacroeconomic_4_3'><p>A Canonical Dynamic Macroeconomic General Equilibrium Model (see Torres, 2016)</p></a></li>
<li><a href='#gemCanonicalDynamicMacroeconomic_Sequential_3_2'><p>A Canonical Dynamic Macroeconomic General Equilibrium Model in Sequential Form (see Torres, 2016)</p></a></li>
<li><a href='#gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3'><p>A Canonical Dynamic Macroeconomic General Equilibrium Model in Sequential Form under the Wage Postpayment Assumption (see Torres, 2016)</p></a></li>
<li><a href='#gemCanonicalDynamicMacroeconomic_TimeCircle_2_2'><p>A Canonical Dynamic Macroeconomic General Equilibrium Model in Time-circle Form (see Torres, 2016)</p></a></li>
<li><a href='#gemCanonicalDynamicMacroeconomic_Timeline_2_2'><p>A Canonical Dynamic Macroeconomic General Equilibrium Model in Timeline Form (see Torres, 2016)</p></a></li>
<li><a href='#gemCapitalAccumulation'><p>Some Examples of Spot Market Clearing Paths with Capital Accumulation</p></a></li>
<li><a href='#gemCESAK_Timeline_2_2'><p>Some Timeline Equilibrium Models with CESAK Production Function</p></a></li>
<li><a href='#gemCoffeeProblem_3_3'><p>Coffee Problem: Some Examples of Equilibrium and Disequilibrium Pure Exchange Economies</p></a></li>
<li><a href='#gemConstantGrowthPath_TechnologyProgress_3_3'><p>Constant Growth Paths with Technology Progress</p></a></li>
<li><a href='#gemDCES_5_3'><p>A Model with a Displaced CES Utility Function</p></a></li>
<li><a href='#gemDualLinearProgramming'><p>General Equilibrium Models and Linear Programming Problems (see Winston, 2003)</p></a></li>
<li><a href='#gemEquityShare_3_3'><p>A General Equilibrium Model with Equity Shares</p></a></li>
<li><a href='#gemEquityShare_Bond_4_4'><p>A General Equilibrium Model with Equity Shares and Bond</p></a></li>
<li><a href='#gemExogenousPrice'><p>Some Examples with Exogenous Price (Price Control)</p></a></li>
<li><a href='#gemExogenousPrice_EndogenousLaborSupply_3_3'><p>An Example of Price Regulation and Endogenous Labor Supply (Example 9.5 of Li, 2019)</p></a></li>
<li><a href='#gemExogenousUtilityLevel_EndogenousLaborSupply_3_3'><p>Some Examples with Exogenous Utility Level and Endogenous Labor Supply</p></a></li>
<li><a href='#gemExternality_Negative'><p>Some Examples Illustrating Negative Externality</p></a></li>
<li><a href='#gemExternality_Positive'><p>Some Examples Illustrating Positive Externality</p></a></li>
<li><a href='#gemFirmAsConsumer'><p>Some Examples of Treating Firms as Consumer-Type Agents</p></a></li>
<li><a href='#gemHeterogeneousFirms_2_3'><p>Instantaneous equilibrium paths with Heterogeneous Firms</p></a></li>
<li><a href='#gemInformation_ProductQuality'><p>An Example Illustrating Product Quality Information</p></a></li>
<li><a href='#gemInputOutputTable_2_2'><p>A General Equilibrium Model based on a 2×2 (Unbalanced) Input-Output Table</p></a></li>
<li><a href='#gemInputOutputTable_2_7_2'><p>A Two-Country General Equilibrium Model</p></a></li>
<li><a href='#gemInputOutputTable_2_7_4'><p>A Two-Country General Equilibrium Model</p></a></li>
<li><a href='#gemInputOutputTable_2_8_4'><p>A Two-Country General Equilibrium Model with Money</p></a></li>
<li><a href='#gemInputOutputTable_5_4'><p>A General Equilibrium Model based on a 5×4 Input-Output Table (see Zhang Xin, 2017, Table 8.6.1)</p></a></li>
<li><a href='#gemInputOutputTable_5_5'><p>General Equilibrium Models based on a 5×5 Input-Output Table (see Zhang Xin, 2017, Table 3.2.1)</p></a></li>
<li><a href='#gemInputOutputTable_7_4'><p>A General Equilibrium Model based on a 7×4 (Standard) Input-Output Table</p></a></li>
<li><a href='#gemInputOutputTable_8_8'><p>A General Equilibrium Model based on an 8×8 Input-Output Table</p></a></li>
<li><a href='#gemInputOutputTable_easy_5_4'><p>An Easy General Equilibrium Model based on a 5×4 Input-Output Table (see Zhang Xin, 2017, Table 8.6.1)</p></a></li>
<li><a href='#gemInputOutputTable_Leontief_3_3'><p>A Leontief-type General Equilibrium Model based on a 3×3 Input-Output Table</p></a></li>
<li><a href='#gemInputOutputTable_SCES_3_3'><p>A SCES-type General Equilibrium Model based on an Input-Output Table.</p></a></li>
<li><a href='#gemInstantaneousEquilibriumPath_StickyDecisions'><p>Some Examples of Instantaneous Equilibrium Paths with Sticky Decisions</p></a></li>
<li><a href='#gemIntertemporal_1_2'><p>An Example of a 1-by-2 Intertemporal Equilibrium Model</p></a></li>
<li><a href='#gemIntertemporal_2_2'><p>Some Examples of a 2-by-2 Intertemporal Equilibrium Model</p></a></li>
<li><a href='#gemIntertemporal_3_3'><p>Some Examples of Intertemporal Models with One Consumer and Two Types of Firms</p></a></li>
<li><a href='#gemIntertemporal_3_4'><p>An Intertemporal Model with Two Consumers and Two Types of Firms</p></a></li>
<li><a href='#gemIntertemporal_4_4'><p>An Intertemporal Model with Land, Two Consumers and Two Types of Firms</p></a></li>
<li><a href='#gemIntertemporal_5_5'><p>Some Intertemporal (Timeline and Time-circle) Models with Land, Two Consumers, and Three Types of Firms</p></a></li>
<li><a href='#gemIntertemporal_AdValoremClaim'><p>Some Intertemporal Models with Ad Valorem Claim</p></a></li>
<li><a href='#gemIntertemporal_Bank_1_2'><p>Some Examples of an Intertemporal Model with a Consumer and a Type of Bank</p></a></li>
<li><a href='#gemIntertemporal_Bank_1_3'><p>Some Examples of an Intertemporal Model with Two Consumers and a Type of Bank</p></a></li>
<li><a href='#gemIntertemporal_Dividend'><p>The Identical Steady-state Equilibrium: Four Models Illustrating Dividend</p></a></li>
<li><a href='#gemIntertemporal_Dividend_TechnologicalProgress'><p>The Identical Steady-state Equilibrium: Four Models Illustrating Dividend and Technological Progress</p></a></li>
<li><a href='#gemIntertemporal_EndogenousEquilibriumInterestRate'><p>An Example Illustrating Endogenous Equilibrium Interest Rates in a (Timeline) Transitional Equilibrium Path</p></a></li>
<li><a href='#gemIntertemporal_EndogenousEquilibriumInterestRate_ForeignExchangeRate'><p>An Example Illustrating Endogenous Equilibrium Interest Rates and Foreign Exchange Rates in a Two-country (Timeline) Transitional Equilibrium Path</p></a></li>
<li><a href='#gemIntertemporal_EndogenousEquilibriumInterestRate_MoneyVelocity'><p>An Example Illustrating Endogenous Equilibrium Interest Rates and the Velocity of Money in a (Timeline) Transitional Equilibrium Path</p></a></li>
<li><a href='#gemIntertemporal_Money_Dividend_Example7.5.1'><p>The Identical Steady-state Equilibrium: Three Models with Money and Dividend</p></a></li>
<li><a href='#gemIntertemporal_PublicFirm'><p>Some Examples of Intertemporal (Timeline) Models with Production and Public Firms</p></a></li>
<li><a href='#gemIntertemporal_TimeCircle_2_2'><p>Some Examples of a 2-by-2 Time Circle Equilibrium Model</p></a></li>
<li><a href='#gemIntertemporal_TimeCircle_3_3'><p>A Time Circle Model with One Consumer and Two Types of Firms</p></a></li>
<li><a href='#gemIntertemporal_TimeCircle_3_4'><p>A Time Circle Model with Two Consumers and Two Types of Firms</p></a></li>
<li><a href='#gemIntertemporal_TimeCircle_Bank_1_2'><p>Some Examples of a Time Circle Model with a Consumer and a Type of Bank</p></a></li>
<li><a href='#gemIntertemporal_TimeCircle_Stochastic_2_2'><p>Some 2-by-2 Time Circle Models with Uncertainty</p></a></li>
<li><a href='#gemIntertemporalStochastic_Bank_ThreePeriods'><p>An Intertemporal Stochastic Model with a Consumer and Some Banks</p></a></li>
<li><a href='#gemIntertemporalStochastic_Bank_TwoPeriods'><p>An Intertemporal Stochastic Model with a Consumer and a Bank</p></a></li>
<li><a href='#gemIntertemporalStochastic_ThreePeriods_2_2'><p>A Three-Period Intertemporal Stochastic Equilibrium Model with a Consumer and a Type of Firm</p></a></li>
<li><a href='#gemIntertemporalStochastic_TwoPeriods'><p>Some Examples of a Two-Period Intertemporal Stochastic Equilibrium Model</p></a></li>
<li><a href='#gemLand_Labor'><p>Some Examples of Spot Market Clearing Paths Involving Land and Labor</p></a></li>
<li><a href='#gemLand_Labor_Capital_4_3'><p>Some Examples of Spot Market Clearing Paths Involving Land, Labor and Capital</p></a></li>
<li><a href='#gemMarketClearingPath_2_2'><p>Some Examples of Spot Market Clearing Paths</p></a></li>
<li><a href='#gemMoney_3_2'><p>A General Equilibrium Model with Money</p></a></li>
<li><a href='#gemMoney_3_3'><p>Some 3-by-3 General Equilibrium Models with Money and Exogenous Interest Rate</p></a></li>
<li><a href='#gemNonexcludability'><p>Some Examples Illustrating Non-excludability</p></a></li>
<li><a href='#gemNonrivalry_Congestiblity'><p>Some Examples Illustrating Congestible Non-rival Goods</p></a></li>
<li><a href='#gemNonrivalry_Uncongestiblity'><p>Some Examples Illustrating Uncongestible Non-rival Goods</p></a></li>
<li><a href='#gemOLG_Basic'><p>Some Examples of Basic (Timeline) OLG Models with Production</p></a></li>
<li><a href='#gemOLG_Land_4_3'><p>An Overlapping Generations Model with Land</p></a></li>
<li><a href='#gemOLG_PrivateFirm'><p>Overlapping Generations Models with Private Firm</p></a></li>
<li><a href='#gemOLG_PublicFirm'><p>Some Examples of (Timeline) OLG Models with Production and Public Firms</p></a></li>
<li><a href='#gemOLG_PureExchange'><p>The Basic Overlapping Generations Pure Exchange Model (see Samuelson, 1958)</p></a></li>
<li><a href='#gemOLG_PureExchange_Bank'><p>Overlapping Generations Pure Exchange Models with Bank</p></a></li>
<li><a href='#gemOLG_StochasticSequential_3_3'><p>A 3-by-3 OLG Stochastic Sequential General Equilibrium Model</p></a></li>
<li><a href='#gemOLG_TimeCircle'><p>Time-Circle Models (Closed Loop Overlapping Generations Models)</p></a></li>
<li><a href='#gemOLGF_OneFirm'><p>Overlapping Generations Financial Sequential Models with One Firm</p></a></li>
<li><a href='#gemOLGF_PureExchange'><p>Overlapping Generations Financial Sequential Models for Pure Exchange Economies</p></a></li>
<li><a href='#gemOLGF_TwoFirms'><p>Overlapping Generations Financial Sequential Models with Two Firms</p></a></li>
<li><a href='#gemOpenEconomy_4_4'><p>A 4-by-4 Open Economy with Bond</p></a></li>
<li><a href='#gemOpenEconomy_6_6'><p>A 6-by-6 Open Economy with Bond</p></a></li>
<li><a href='#gemPersistentTechnologicalProgress'><p>Some Examples of Spot Market Clearing Paths with Persistent Technological Progress</p></a></li>
<li><a href='#gemPureExchange'><p>Some Simple Pure Exchange Equilibrium Models</p></a></li>
<li><a href='#gemQuasilinearPureExchange_2_2'><p>A Pure Exchange Economy with a Quasilinear Utility Function</p></a></li>
<li><a href='#gemResearchDevelopmentIntensity'><p>Some Examples of Spot Market Clearing Paths Illustrating Research and Development Intensity</p></a></li>
<li><a href='#gemRobinson_3_2'><p>A Robinson Crusoe Economy</p></a></li>
<li><a href='#gemShortTermInvestment_2_3'><p>Some Examples Illustrating Short-Term Investment</p></a></li>
<li><a href='#gemSkill'><p>Some General Equilibrium Models with Skill (i.e. Human Capital)</p></a></li>
<li><a href='#gemstEndogenousLaborSupply_2_2'><p>A General Equilibrium Model with Endogenous Labor Supply</p></a></li>
<li><a href='#gemstEndogenousProductionFunction_2_2'><p>A General Equilibrium Model with Endogenous Production Function</p></a></li>
<li><a href='#gemstEndogenousUtilityFunction'><p>Some General Equilibrium Models with Endogenous Utility Function</p></a></li>
<li><a href='#gemStickyDecisionPath_2_2'><p>An Example Illustrating the Sticky-Decision Path and Business Cycles</p></a></li>
<li><a href='#gemStickyPricePath_2_2'><p>Some Examples Illustrating the Sticky-Price Path and Business Cycles</p></a></li>
<li><a href='#gemstStructuralMultipleEquilibria_2_2'><p>Structural Multiple Equilibria and Structural Transition Policy</p></a></li>
<li><a href='#gemTax_3_3'><p>Some General Equilibrium Models with Tax</p></a></li>
<li><a href='#gemTax_4_4'><p>Some General Equilibrium Models with Endogenous Tax Rates</p></a></li>
<li><a href='#gemTax_5_4'><p>A General Equilibrium Model with Tax (see Cardenete et al., 2012).</p></a></li>
<li><a href='#gemTax_5_5'><p>A General Equilibrium Model with Tax</p></a></li>
<li><a href='#gemTax_QuasilinearPreference_4_4'><p>A General Equilibrium Model with Tax and Quasilinear Utility Functions.</p></a></li>
<li><a href='#gemTax_VAT_IncomeTax_5_4'><p>A General Equilibrium Model with Value-added Tax and Income Tax</p></a></li>
<li><a href='#gemTechnologyProgress_PopulationGrowth'><p>Some General Equilibrium Models with Technology Progress and Population Growth</p></a></li>
<li><a href='#gemTemporaryEquilibriumPath'><p>Some Examples of Temporary Equilibrium Paths</p></a></li>
<li><a href='#gemTwoCountry_Bond_7_4'><p>An Example of Two-Country Economy with Bond</p></a></li>
<li><a href='#gemTwoCountry_RealExchangeRateIndex_7_4'><p>Calculating Real Exchange Rate Index</p></a></li>
<li><a href='#gemTwoCountry_Tariff_9_5'><p>An Example of Two-Country Economy with Tariff</p></a></li>
<li><a href='#gemTwoCountryForeignExchangeRate_6_6'><p>Example 7.6 (Foreign Exchange Rate) in Li (2019)</p></a></li>
<li><a href='#gemTwoCountryPureExchange'><p>Some Examples of Two-Country Pure Exchange Economy</p></a></li>
<li><a href='#gemTwoCountryPureExchange_Bond'><p>Some Examples of Two-Country Pure Exchange Economy with Bond</p></a></li>
<li><a href='#gemTwoIndustries_4_3'><p>A 4-by-3 Economy with Two Industries</p></a></li>
<li><a href='#growth_rate'><p>Compute the Growth Rate</p></a></li>
<li><a href='#iterate'><p>Iteration Function</p></a></li>
<li><a href='#makeCountercyclicalProductTax'><p>Make a Countercyclical Product Tax Policy Function</p></a></li>
<li><a href='#makePolicyHeadAdjustment'><p>Make a Policy of Head Adjustment for a Timeline Model</p></a></li>
<li><a href='#makePolicyHeadTailAdjustment'><p>Make a Policy of Head and/or Tail Adjustment for a Timeline Model</p></a></li>
<li><a href='#makePolicyIncomeTax'><p>Make a Policy of Income Tax</p></a></li>
<li><a href='#makePolicyMeanValue'><p>Make a Mean Value Policy Function</p></a></li>
<li><a href='#makePolicyStickyPrice'><p>Make a Policy of Sticky Price</p></a></li>
<li><a href='#makePolicySupply'><p>Make a Policy of Supply</p></a></li>
<li><a href='#makePolicyTailAdjustment'><p>Make a Policy of Tail Adjustment for a Timeline Model</p></a></li>
<li><a href='#makePolicyTechnologyChange'><p>Make a Policy of Technology Change</p></a></li>
<li><a href='#marginal_utility'><p>Marginal Utility</p></a></li>
<li><a href='#matrix_add_by_name'><p>Add Matrices by Names of Columns and Rows</p></a></li>
<li><a href='#matrix_aggregate'><p>Aggregate Some Rows and Columns of a Matrix</p></a></li>
<li><a href='#matrix_to_dstl'><p>Convert a Matrix into a Demand Structural Tree List</p></a></li>
<li><a href='#MDCES_demand'><p>Modified Displaced CES Demand Function</p></a></li>
<li><a href='#node_insert'><p>Insert Nodes into a Tree</p></a></li>
<li><a href='#node_new'><p>Create a Tree</p></a></li>
<li><a href='#node_plot'><p>Plot a Tree and Show the Type Attribute</p></a></li>
<li><a href='#node_print'><p>Print a Tree and Its Fields</p></a></li>
<li><a href='#node_prune'><p>Prune Nodes off a Tree by Names</p></a></li>
<li><a href='#node_replace'><p>Replace a Node of a Tree</p></a></li>
<li><a href='#node_set'><p>Create a Tree or Set Attributes for a Node</p></a></li>
<li><a href='#output'><p>Compute the Utility of a Consumer or the Output of a Firm by the Demand Structural Tree</p></a></li>
<li><a href='#policyMarketClearingPrice'><p>Market-Clearing-Price Policy Function</p></a></li>
<li><a href='#policyMeanValue'><p>Mean Value Policy Function</p></a></li>
<li><a href='#QL_demand'><p>Quasilinear Demand Functions</p></a></li>
<li><a href='#rate_to_beta'><p>Conversion between a Rate Vector and a Beta Vector</p></a></li>
<li><a href='#ratio_adjust'><p>Ratio Adjustment</p></a></li>
<li><a href='#SCES'><p>Standard CES Function</p></a></li>
<li><a href='#SCES_A'><p>Standard CES Demand Coefficient Matrix</p></a></li>
<li><a href='#sdm_dstl'><p>Structural Dynamic Model (alias Structural Growth Model) with a Demand Structure Tree List</p></a></li>
<li><a href='#sdm2'><p>Structural Dynamic Model (alias Structural Growth Model) Version 2</p></a></li>
<li><a href='#sserr'><p>Compute the Return Rate in the Steady State Equilibrium</p></a></li>
<li><a href='#structural_function'><p>Structural Function</p></a></li>
<li><a href='#var.p'><p>Population Variance and Population Standard Deviation</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>General Equilibrium Modeling</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.5</td>
</tr>
<tr>
<td>Author:</td>
<td>LI Wu &lt;liwu@staff.shu.edu.cn&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>LI Wu &lt;liwu.shu@qq.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>CGE, data.tree</td>
</tr>
<tr>
<td>Imports:</td>
<td>DiagrammeR</td>
</tr>
<tr>
<td>Description:</td>
<td>Some tools for developing general equilibrium models and some general equilibrium models. These models can be used for teaching economic theory and are built by the methods of new structural economics (see <a href="https://www.nse.pku.edu.cn/">https://www.nse.pku.edu.cn/</a> and LI Wu, 2019, ISBN: 9787521804225, General Equilibrium and Structural Dynamics: Perspectives of New Structural Economics. Beijing: Economic Science Press). The model form and mathematical methods can be traced back to J. von Neumann (1945, A Model of General Economic Equilibrium. The Review of Economic Studies, 13. pp. 1-9), J. G. Kemeny, O. Morgenstern and G. L. Thompson (1956, A Generalization of the von Neumann Model of an Expanding Economy, Econometrica, 24, pp. 115-135) et al. By the way, J. G. Kemeny is a co-inventor of the computer language BASIC.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-05 12:16:35 UTC; 86189</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-05 16:10:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='AMSD'>Additive-Mean-Variance Utility Function and Additive-Mean-Standard-Deviation Utility Function</h2><span id='topic+AMSD'></span><span id='topic+AMV'></span>

<h3>Description</h3>

<p>Compute the utility function mean(x) - (gamma * sd.p(x))^theta / theta or
weighted.mean(x, wt) - (gamma * sd.p(x, wt))^theta / theta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AMSD(x, gamma = 1, wt = NULL, theta = 1)

AMV(x, gamma = 1, wt = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AMSD_+3A_x">x</code></td>
<td>
<p>a numeric n-vector.</p>
</td></tr>
<tr><td><code id="AMSD_+3A_gamma">gamma</code></td>
<td>
<p>a non-negative scalar representing the risk aversion coefficient with a default value of 1.</p>
</td></tr>
<tr><td><code id="AMSD_+3A_wt">wt</code></td>
<td>
<p>a numeric n-vector of weights (or probability).
If wt is NULL, all elements of x are given the same weight.</p>
</td></tr>
<tr><td><code id="AMSD_+3A_theta">theta</code></td>
<td>
<p>a non-negative scalar with a default value of 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar indicating the utility level.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>AMSD</code>: Computes the utility function mean(x) - (gamma * sd.p(x))^theta / theta or
weighted.mean(x, wt) - (gamma * sd.p(x, wt))^theta / theta. When theta == 2, it is the additive mean-variance utility function (i.e.
the function AMV).
When theta == 1 (the default value), it is the additive mean and standard deviation utility function.
</p>
</li>
<li> <p><code>AMV</code>: Compute the additive mean-variance utility function mean(x) - 0.5 * gamma * var.p(x) or
weighted.mean(x, wt) - 0.5 * gamma * var.p(x, wt).
</p>
</li></ul>


<h3>References</h3>

<p>Nakamura, Yutaka (2015). Mean-Variance Utility. Journal of Economic Theory, 160: 536-556.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
AMSD(1:2, gamma = 0.05)
AMSD(1:2, gamma = 1, theta = 2)

marginal_utility(
  c(1, 1.001),
  c(0, 1), function(x) AMSD(x, gamma = 0.5)
)
marginal_utility(
  c(1.001, 1),
  c(0, 1), function(x) AMSD(x, gamma = 0.5)
)


</code></pre>

<hr>
<h2 id='AMSDP'>Additive-Mean-Standard-Deviation Portfolio Utility Function</h2><span id='topic+AMSDP'></span>

<h3>Description</h3>

<p>Compute the utility function x %*% mp - gamma^theta * (t(x) %*% Cov %*% x)^(0.5 * theta) / theta for a portfolio x.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AMSDP(x, mp, Cov, gamma = 1, theta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AMSDP_+3A_x">x</code></td>
<td>
<p>a numeric n-vector representing a portfolio.</p>
</td></tr>
<tr><td><code id="AMSDP_+3A_mp">mp</code></td>
<td>
<p>a numeric n-vector representing the mean payoff of each of the n assets.</p>
</td></tr>
<tr><td><code id="AMSDP_+3A_cov">Cov</code></td>
<td>
<p>the n-by-n covariance matrix of the payoff vectors of n assets.</p>
</td></tr>
<tr><td><code id="AMSDP_+3A_gamma">gamma</code></td>
<td>
<p>a non-negative scalar representing the risk aversion coefficient with a default value of 1.</p>
</td></tr>
<tr><td><code id="AMSDP_+3A_theta">theta</code></td>
<td>
<p>a non-negative scalar with a default value of 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar indicating the utility level.
</p>


<h3>References</h3>

<p>Danthine, J. P., Donaldson, J. (2005, ISBN: 9780123693808) Intermediate Financial Theory. Elsevier Academic Press.
</p>
<p>Nakamura, Yutaka (2015) Mean-Variance Utility. Journal of Economic Theory, 160: 536-556.
</p>
<p>Sharpe, William F (2008, ISBN: 9780691138503) Investors and Markets: Portfolio Choices, Asset Prices, and Investment Advice. Princeton University Press.
</p>
<p>Xu Gao (2018, ISBN: 9787300258232) Twenty-five Lectures on Financial Economics. Beijing: China Renmin University Press. (In Chinese)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AMSD">AMSD</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
UAP &lt;- matrix(c(
  0, 1, 1,
  0, 2, 1,
  1, 1, 1,
  1, 2, 1,
  2, 0, 1
), nrow = 5, byrow = TRUE)

portfolio &lt;- c(1.977, 1.183, 3.820)

AMSDP(portfolio, colMeans(UAP),
  cov.wt(UAP, method = "ML")$cov,
  gamma = 1, theta = 1
)

AMSD(UAP %*% portfolio, gamma = 1, theta = 1)

</code></pre>

<hr>
<h2 id='apply_expand.grid'>Applying a Function to All Combinations of the Supplied Vectors</h2><span id='topic+apply_expand.grid'></span>

<h3>Description</h3>

<p>A wrapper of the functions apply and expand.grid.
Returns a data frame of values obtained by applying a function
to all combinations of the supplied vectors.
Firstly, the function expand.grid will be used for the supplied vectors in ... and
we will get a data frame containing one row for each combination of the supplied vectors.
Then the function will be applied to each row of the data frame.
The values of the data frame will also be included in the returned data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_expand.grid(FUN, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_expand.grid_+3A_fun">FUN</code></td>
<td>
<p>the function to be applied. The argument is a numeric vector.</p>
</td></tr>
<tr><td><code id="apply_expand.grid_+3A_...">...</code></td>
<td>
<p>numeric vectors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
apply_expand.grid(prod, a = 1:9, b = 1:9)

####
f &lt;- function(x) c(r1 = sum(x), r2 = unname(x["b"] - x["a"]))
apply_expand.grid(f, a = c(1, 2), b = c(3, 4))

####
f &lt;- function(x) list(list(sum(x)), prod(x))
apply_expand.grid(f, a = c(1, 2), b = c(3, 4))

####
f &lt;- function(x) {
  result &lt;- SCES_A(alpha = 1, Beta = c(0.5, 0.5), p = c(x["p1"], 1), es = x["es"])
  names(result) &lt;- c("dc1", "dc2")
  result
}

apply_expand.grid(f, p1 = seq(0.1, 10, 0.1), es = c(0.3, 0.5, 1))


</code></pre>

<hr>
<h2 id='CARA'>Constant Absolute Risk Aversion (CARA) Utility Function</h2><span id='topic+CARA'></span>

<h3>Description</h3>

<p>Compute the value and the certainty equivalent of the CARA utility function, i.e. -exp(-gamma*x). In general equilibrium analysis, the CARA utility function has an interval scale like temperature.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CARA(x, gamma, prob = rep(1/length(x), length(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CARA_+3A_x">x</code></td>
<td>
<p>a payoff k-vector.</p>
</td></tr>
<tr><td><code id="CARA_+3A_gamma">gamma</code></td>
<td>
<p>the Arrow-Pratt measure of absolute risk aversion.</p>
</td></tr>
<tr><td><code id="CARA_+3A_prob">prob</code></td>
<td>
<p>a probability k-vector. By default, the states are assumed to
occur with equal probability.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<ul>
<li><p> u: the utility level.
</p>
</li>
<li><p> CE: the certainty equivalent.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>mu &lt;- 5 # mu &lt;- 8
a &lt;- 1
x &lt;- c(mu - a, mu + a)
gamma &lt;- 0.8
mu - CARA(x, gamma)$CE

####
gamma &lt;- 0.8
mu &lt;- 2
sigma &lt;- 2
x &lt;- seq(mu - 5 * sigma, mu + 5 * sigma, length.out = 10000)
# two CE calculation methods for random variables of normal distribution
CARA(x, gamma, dnorm(x, mean = mu, sd = sigma))
mu - gamma * sigma^2 / 2
</code></pre>

<hr>
<h2 id='CES'>CES Function</h2><span id='topic+CES'></span>

<h3>Description</h3>

<p>CES function, e.g. alpha * (beta1 * (x1 / theta1)^sigma + beta2 * (x2 / theta2)^sigma)^(1 / sigma).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CES(sigma = 1 - 1/es, alpha, beta, x, theta = rep(1, length(beta)), es = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CES_+3A_sigma">sigma</code></td>
<td>
<p>a scalar not greater than one.</p>
</td></tr>
<tr><td><code id="CES_+3A_alpha">alpha</code></td>
<td>
<p>a nonnegative scalar.</p>
</td></tr>
<tr><td><code id="CES_+3A_beta">beta</code></td>
<td>
<p>a nonnegative n-vector.</p>
</td></tr>
<tr><td><code id="CES_+3A_x">x</code></td>
<td>
<p>a nonnegative n-vector consisting of the inputs.</p>
</td></tr>
<tr><td><code id="CES_+3A_theta">theta</code></td>
<td>
<p>the all-ones n-vector (default) or a positive n-vector.</p>
</td></tr>
<tr><td><code id="CES_+3A_es">es</code></td>
<td>
<p>the elasticity of substitution. If es is not NA, the value of sigma (i.e. 1 - 1 / es) will be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar indicating the output or utility level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
CES(0.5, 1, c(0.4, 0.6), c(1, 1), c(0.4, 0.6))
CES(0.5, 1, c(0.4, 0.6), c(1, 2))


</code></pre>

<hr>
<h2 id='CESAK_dc'>Demand coefficients of the CESAK Production Function</h2><span id='topic+CESAK_dc'></span>

<h3>Description</h3>

<p>Computing the demand coefficients of the CESAK production function
alpha * (betaK * x1^((es - 1) / es) + (1 - betaK) * x2^((es - 1) / es))^(es / (es - 1)) + alphaK * x1.
When es==1, the CESAK production function becomes the CDAK production function alpha * x1^betaK * x2^(1 - betaK) + alphaK * x1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CESAK_dc(alpha, betaK, alphaK, p, es = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CESAK_dc_+3A_alpha">alpha</code></td>
<td>
<p>a positive scalar.</p>
</td></tr>
<tr><td><code id="CESAK_dc_+3A_betak">betaK</code></td>
<td>
<p>a scalar between 0 and 1.</p>
</td></tr>
<tr><td><code id="CESAK_dc_+3A_alphak">alphaK</code></td>
<td>
<p>a nonnegative scalar.</p>
</td></tr>
<tr><td><code id="CESAK_dc_+3A_p">p</code></td>
<td>
<p>a 2-vector indicating the prices.</p>
</td></tr>
<tr><td><code id="CESAK_dc_+3A_es">es</code></td>
<td>
<p>a nonnegative scalar specifying the elasticity of substitution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-vector indicating the demand coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
CESAK_dc(alpha = 1, betaK = 0.35, alphaK = 1 - 0.06, p = c(10, 1))
CESAK_dc(alpha = 1, betaK = 0.35, alphaK = 1 - 0.06, p = c(1, 10))
CESAK_dc(alpha = 1, betaK = 0.35, alphaK = 2, p = c(1, 1))

CESAK_dc(alpha = 1, betaK = 0.35, alphaK = 1 - 0.06, p = c(1, 1), es = 0.5)
CESAK_dc(alpha = 1, betaK = 0.35, alphaK = 0.1, p = c(1, 10), es = 0.5)
CESAK_dc(alpha = 1, betaK = 0.35, alphaK = 1.5, p = c(1, 10), es = 0.5)


</code></pre>

<hr>
<h2 id='CRRA'>Constant Relative Risk Aversion (CRRA) Utility Function</h2><span id='topic+CRRA'></span>

<h3>Description</h3>

<p>Compute the value and the certainty equivalent of the CRRA utility function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CRRA(x, gamma, prob = rep(1/length(x), length(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CRRA_+3A_x">x</code></td>
<td>
<p>a payoff k-vector.</p>
</td></tr>
<tr><td><code id="CRRA_+3A_gamma">gamma</code></td>
<td>
<p>the relative risk aversion coefficient.</p>
</td></tr>
<tr><td><code id="CRRA_+3A_prob">prob</code></td>
<td>
<p>a probability k-vector. By default, the states are assumed to
occur with equal probability.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following components:
</p>

<ul>
<li><p> u: the utility level.
</p>
</li>
<li><p> CE: the certainty equivalent.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>csv &lt;- 0.05 # coefficient of standard deviation
mu &lt;- 90 # mu &lt;- 100
sigma &lt;- mu * csv
x &lt;- seq(mu - 5 * sigma, mu + 5 * sigma, length.out = 10000)
pd &lt;- dnorm(x, mean = mu, sd = sigma)
gamma &lt;- 0.8
# the ratio of risk premium to expected return (i.e. the relative risk premium).
(mu - CRRA(x, gamma, pd)$CE) / mu

####
df &lt;- apply_expand.grid(
  function(arg) {
    CRRA(arg["x"], arg["gamma"])$u
  },
  x = seq(0.5, 3, 0.1),
  gamma = c(0.5, 1, 2, 3)
)
coplot(result ~ x | as.factor(gamma), data = df)
</code></pre>

<hr>
<h2 id='DCES'>Displaced CES Utility Function and Displaced CES Demand Function</h2><span id='topic+DCES'></span><span id='topic+DCES_demand'></span><span id='topic+DCES_compensated_demand'></span><span id='topic+DCES_indirect'></span>

<h3>Description</h3>

<p>The displaced CES utility function and the displaced CES demand function (Fullerton, 1989).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DCES(es, beta, xi, x)

DCES_demand(es, beta, xi, w, p)

DCES_compensated_demand(es, beta, xi, u, p)

DCES_indirect(es, beta, xi, w, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DCES_+3A_es">es</code></td>
<td>
<p>a scalar indicating the elasticity of substitution.</p>
</td></tr>
<tr><td><code id="DCES_+3A_beta">beta</code></td>
<td>
<p>an n-vector consisting of the marginal expenditure share coefficients.
The sum of all components of beta should be 1.</p>
</td></tr>
<tr><td><code id="DCES_+3A_xi">xi</code></td>
<td>
<p>an n-vector or a scalar. If xi is a scalar, it will be recycled to an n-vector.
Each element of xi parameterizes whether the particular good is a necessity for the household (Acemoglu, 2009, page 152).
For example, xi[i] &gt; 0 may mean that the household needs to consume at least a certain amount of good i to survive.</p>
</td></tr>
<tr><td><code id="DCES_+3A_x">x</code></td>
<td>
<p>an n-vector consisting of the inputs.</p>
</td></tr>
<tr><td><code id="DCES_+3A_w">w</code></td>
<td>
<p>a scalar indicating the income.</p>
</td></tr>
<tr><td><code id="DCES_+3A_p">p</code></td>
<td>
<p>an n-vector indicating the prices.</p>
</td></tr>
<tr><td><code id="DCES_+3A_u">u</code></td>
<td>
<p>a scalar indicating the utility level.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return values of these functions are as follows: <br />
DCES: A scalar indicating the utility level. <br />
DCES_demand: An n-vector indicating the demands. <br />
DCES_compensated_demand: An n-vector indicating the compensated demands. <br />
DCES_indirect: A scalar indicating the utility level.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>DCES</code>: Compute the displaced CES utility function (Fullerton, 1989),
e.g. (beta1 ^ (1 / es) * (x1 - xi1) ^ (1 - 1 / es) +
beta2 ^ (1 / es) * (x2 - xi2) ^ (1 - 1 / es)) ^ (es / (es - 1)
wherein beta1 + beta2 == 1.
</p>
<p>When es==1, the DCES utility function becomes the Stone-Geary utility function.
</p>
</li>
<li> <p><code>DCES_demand</code>: The displaced CES demand function (Fullerton, 1989).
</p>
</li>
<li> <p><code>DCES_compensated_demand</code>: The displaced CES compensated demand function (Fullerton, 1989).
</p>
</li>
<li> <p><code>DCES_indirect</code>: The displaced CES indirect utility function (Fullerton, 1989).
</p>
</li></ul>


<h3>References</h3>

<p>Acemoglu, D. (2009, ISBN: 9780691132921) Introduction to Modern Economic Growth. Princeton University Press.
</p>
<p>Fullerton, D. (1989) Notes on Displaced CES Functional Forms. Available at: https://works.bepress.com/don_fullerton/39/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
es &lt;- 0.99
beta &lt;- prop.table(1:5)
xi &lt;- 0
w &lt;- 500
p &lt;- 2:6

x &lt;- DCES_demand(
  es = es,
  beta = beta,
  xi = xi,
  w = w,
  p = p
)

DCES_demand(
  es = es,
  beta = prop.table(0:4),
  xi = 5:1,
  w = w,
  p = p
)

u &lt;- DCES(
  es = es,
  beta = beta,
  xi = xi,
  x = x
)

SCES(
  es = es,
  alpha = 1,
  beta = beta,
  x = x
)

DCES_compensated_demand(
  es = es,
  beta = beta,
  xi = xi,
  u = u,
  p = p
)

DCES_compensated_demand(
  es = es,
  beta = beta,
  xi = seq(10, 50, 10),
  u = u,
  p = p
)

#### A 2-by-2 general equilibrium model
#### with a DCES utility function.
ge &lt;- sdm2(
  A = function(state) {
    a.consumer &lt;- DCES_demand(
      es = 2, beta = c(0.2, 0.8), xi = c(1000, 500),
      w = state$w[1], p = state$p
    )
    a.firm &lt;- c(1.1, 0)
    cbind(a.consumer, a.firm)
  },
  B = diag(c(0, 1)),
  S0Exg = matrix(c(
    3500, NA,
    NA, NA
  ), 2, 2, TRUE),
  names.commodity = c("corn", "iron"),
  names.agent = c("consumer", "firm"),
  numeraire = "corn"
)

ge$p
ge$z
ge$A
ge$D

#### a 2-by-2 pure exchange economy
sdm2(
  A = function(state) {
    a1 &lt;- CD_A(1, rbind(1 / 3, 2 / 3), state$p)
    a2 &lt;- DCES_demand(
      es = 1, beta = c(0.4, 0.6), xi = c(0.1, 0.2),
      w = state$w[2], p = state$p
    )
    cbind(a1, a2)
  },
  B = matrix(0, 2, 2),
  S0Exg = matrix(c(
    3, 4,
    7, 0
  ), 2, 2, TRUE),
  names.commodity = c("fish", "banana"),
  names.agent = c("Annie", "Ben"),
  numeraire = "banana"
)

#### A 3-by-3 general equilibrium model
#### with a DCES utility function.
lab &lt;- 1 # the amount of labor supplied by each laborer
n.laborer &lt;- 100 # the number of laborers
ge &lt;- sdm2(
  A = function(state) {
    a.firm.corn &lt;- CD_A(alpha = 1, Beta = c(0, 0.5, 0.5), state$p)
    a.firm.iron &lt;- CD_A(alpha = 5, Beta = c(0, 0.5, 0.5), state$p)
    a.laborer &lt;- DCES_demand(
      es = 0, beta = c(0, 1, 0), xi = c(0.1, 0, 0),
      w = state$w[3] / n.laborer, p = state$p
    )

    cbind(a.firm.corn, a.firm.iron, a.laborer)
  },
  B = matrix(c(
    1, 0, 0,
    0, 1, 0,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, NA, NA,
    NA, NA, lab * n.laborer
  ), 3, 3, TRUE),
  names.commodity = c("corn", "iron", "lab"),
  names.agent = c("firm.corn", "firm.iron", "laborer"),
  numeraire = "lab",
  priceAdjustmentVelocity = 0.1
)

ge$z
ge$A
ge$D


</code></pre>

<hr>
<h2 id='demand_coefficient'>Compute Demand Coefficients of an Agent with a Demand Structural Tree</h2><span id='topic+demand_coefficient'></span>

<h3>Description</h3>

<p>Given a price vector, this function computes the demand coefficients of an agent with a demand structural tree.
The class of a demand structural tree is Node defined by the package data.tree.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demand_coefficient(node, p, trace = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demand_coefficient_+3A_node">node</code></td>
<td>
<p>a demand structural tree.</p>
</td></tr>
<tr><td><code id="demand_coefficient_+3A_p">p</code></td>
<td>
<p>a price vector with names of commodities.</p>
</td></tr>
<tr><td><code id="demand_coefficient_+3A_trace">trace</code></td>
<td>
<p>FALSE (default) or TRUE. If TRUE, calculation intermediate results will be recorded in nodes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Demand coefficients often indicate the quantity of various commodities needed by an economic agent in order to obtain a unit of output or utility,
and these commodities can include both real commodities and financial instruments such as tax receipts, stocks, bonds and currency.<br />
The demand for various commodities by an economic agent can be expressed by a demand structure tree.
Each non-leaf node can be regarded as the output of all its child nodes.
Each node can be regarded as an input of its parent node.
In other words, the commodity represented by each non-leaf node is a composite commodity composed of the
commodities represented by its child nodes.
Each non-leaf node usually has an attribute named type.
This attribute describes the input-output relationship between the child nodes and the parent node.
This relationship can sometimes be represented by a production function or a utility function.
The type attribute of each non-leaf node can take the following values.
</p>

<ul>
<li><p> SCES. In this case, this node also has parameters alpha, beta and es (or sigma = 1 - 1 / es).
alpha and es are scalars. beta is a vector. These parameters are parameters of a standard CES function (see <code><a href="#topic+SCES">SCES</a></code> and <code><a href="#topic+SCES_A">SCES_A</a></code>).
</p>
</li>
<li><p> CES. In this case, this node also has parameters alpha, beta, theta (optional) and es (or sigma = 1 - 1 / es) (see CGE::CES_A).
</p>
</li>
<li><p> Leontief. In this case, this node also has the parameter a,
which is a vector and is the parameter of a Leontief function.
</p>
</li>
<li><p> CD. CD is Cobb-Douglas. In this case, this node also has parameters alpha and beta,
which are parameters of a Cobb-Douglas function.
</p>
</li>
<li><p> CESAK. In this case, this node also has parameters es, alpha, betaK and alphaK,
which are parameters of the CESAK function (see <code><a href="#topic+CESAK_dc">CESAK_dc</a></code>). Moreover, the first child node should represent capital goods.
</p>
</li>
<li><p> FIN. That is the financial type.
In this case, this node also has the parameter rate or beta.
If the parameter beta is not NULL, then the parameter rate will be ignored.
The parameter rate applies to all situations, while the parameter beta only applies for some special cases.
For FIN nodes, the first child node should represent for a physical commodity or a composite commodity
containing a physical commodity, and other child nodes represent for financial instruments.
The parameter beta indicates the proportion of each child node's expenditure.
The parameter rate indicates the expenditure ratios between financial-instrument-type child nodes
and the first child node.
The first element of the parameter rate indicates the amount of the first child node needed to get a unit of output.
</p>
</li>
<li><p> FUNC. That is the function type. In this case, this node also has an attribute named func.
The value of that attribute is a function which calculates the demand coefficient for the child nodes.
The argument of that function is a price vector.
The length of that price vector is equal to the number of the child nodes.
</p>
</li>
<li><p> StickyLinear or SL. That is the sticky linear type. In this case, this node also has an attribute named beta that
contains the coefficients of the linear utility or production function.
In order to avoid too drastic changes in the demand structure, the adjustment process of the demand structure has a certain stickiness when prices change.
</p>
</li></ul>



<h3>Value</h3>

<p>A vector consisting of demand coefficients.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### a Leontief-type node
dst &lt;- node_new("firm",
  type = "Leontief", a = c(0.5, 0.1),
  "wheat", "iron"
)
print(dst, "type")
node_print(dst)
plot(dst)
node_plot(dst, TRUE)

demand_coefficient(dst, p = c(wheat = 1, iron = 2)) # the same as a = c(0.5, 0.1)

#### a CD-type node
dst &lt;- node_new("firm",
  type = "CD", alpha = 1, beta = c(0.5, 0.5),
  "wheat", "iron"
)

demand_coefficient(dst, p = c(wheat = 1, iron = 2))
# the same as the following
CD_A(1, c(0.5, 0.5), c(1, 2))

#### a SCES-type node
dst &lt;- node_new("firm",
  type = "SCES",
  alpha = 2, beta = c(0.8, 0.2), es = 0.5,
  "wheat", "iron"
)

demand_coefficient(dst, p = c(wheat = 1, iron = 2))

# the same as the following
SCES_A(alpha = 2, Beta = c(0.8, 0.2), p = c(1, 2), es = 0.5)
CES_A(sigma = 1 - 1 / 0.5, alpha = 2, Beta = c(0.8, 0.2), p = c(1, 2), Theta = c(0.8, 0.2))

#### a FUNC-type node
dst &lt;- node_new("firm",
  type = "FUNC",
  func = function(p) {
    CES_A(
      sigma = -1, alpha = 2,
      Beta = c(0.8, 0.2), p,
      Theta = c(0.8, 0.2)
    )
  },
  "wheat", "iron"
)

demand_coefficient(dst, p = c(wheat = 1, iron = 2))

# the same as the following
CES_A(sigma = -1, alpha = 2, Beta = c(0.8, 0.2), p = c(1, 2), Theta = c(0.8, 0.2))

####
p &lt;- c(wheat = 1, iron = 3, labor = 2, capital = 4)
dst &lt;- node_new("firm 1",
  type = "SCES", sigma = -1, alpha = 1, beta = c(1, 1),
  "cc1", "cc2"
)
node_set(dst, "cc1",
  type = "Leontief", a = c(0.6, 0.4),
  "wheat", "iron"
)
node_set(dst, "cc2",
  type = "SCES", sigma = -1, alpha = 1, beta = c(1, 1),
  "labor", "capital"
)

node_plot(dst)
demand_coefficient(dst, p)

####
p &lt;- c(product = 1, labor = 1, money = 1)
dst &lt;- node_new("firm",
  type = "FIN", rate = c(0.75, 1 / 3),
  "cc1", "money"
) # a financial-type node
node_set(dst, "cc1",
  type = "Leontief", a = c(0.8, 0.2),
  "product", "labor"
)

node_plot(dst)
demand_coefficient(dst, p)

#### the same as above
p &lt;- c(product = 1, labor = 1, money = 1)
dst &lt;- node_new("firm",
  type = "Leontief", a = c(0.8, 0.2),
  "cc1", "cc2"
)
node_set(dst, "cc1",
  type = "FIN", rate = c(0.75, 1 / 3),
  "product", "money"
)

node_set(dst, "cc2",
  type = "FIN", rate = c(0.75, 1 / 3),
  "labor", "money"
)
node_plot(dst)
demand_coefficient(dst, p)

#### the same as above
p &lt;- c(product = 1, labor = 1, money = 1)
dst &lt;- node_new("firm",
  type = "FIN", rate = c(1, 1 / 3),
  "cc1", "money"
) # Financial-type Demand Structure
node_set(dst, "cc1",
  type = "Leontief", a = c(0.6, 0.15),
  "product", "labor"
)

node_plot(dst)
demand_coefficient(dst, p)
</code></pre>

<hr>
<h2 id='demCreditPolicy'>A Disequilibrium Model with Credit</h2><span id='topic+demCreditPolicy'></span>

<h3>Description</h3>

<p>These are some examples to illustrate that credit policies may lead to business cycles.
When the firm's profit rate is high, the laborer lends labor or labor income to the firm; when the firm's profit rate is low, the firm repays the loan with products.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demCreditPolicy(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demCreditPolicy_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.firm &lt;- node_new("output",
  type = "CD", alpha = 1.2,
  beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.consumer &lt;- node_new("utility",
  type = "Leontief", a = 1,
  "prod"
)

f &lt;- function(policy = NULL) {
  ge &lt;- sdm2(
    A = list(dst.firm, dst.consumer),
    B = matrix(c(
      1, 0,
      0, 1
    ), 2, 2, TRUE),
    S0Exg = matrix(c(
      NA, NA,
      NA, 100
    ), 2, 2, TRUE),
    names.commodity = c("prod", "lab"),
    names.agent = c("firm", "consumer"),
    ts = TRUE,
    policy = policy,
    numberOfPeriods = 200,
    maxIteration = 1,
    priceAdjustmentVelocity = 0.05
  )

  matplot(ge$ts.z, type = "o", pch = 20)
  ge
}

## no credit policy
ge &lt;- f()

## credit policy
policy.credit &lt;- function(time, state) {
  profit.rate &lt;- state$p[1] / sum(state$last.A[, 1] * state$p) - 1

  if (profit.rate &gt; 0.01) {
    state$S[2, 2] &lt;- 50
    state$S[2, 1] &lt;- 50
  } else if (profit.rate &lt; -0.01) {
    state$S[1, 2] &lt;- state$S[1, 1] * 0.5
    state$S[1, 1] &lt;- state$S[1, 1] * 0.5
  }

  state
}

de &lt;- f(policy = policy.credit)

#### an example with 3 firms.
policy.credit &lt;- function(time, state) {
  if (time &lt;= 10) {
    return(state)
  }
  profit.rate &lt;- state$p[1] / sum(state$last.A[, 1] * state$p) - 1

  if (profit.rate &gt; 0.01) {
    state$S[3, 1] &lt;- 30
    # state$S[3, 1:3] &lt;- 10
    state$S[3, 4] &lt;- 70
  } else if (profit.rate &lt; -0.01) {
    state$S[1, 4] &lt;- state$S[1, 1] * 0.3
    state$S[1, 1] &lt;- state$S[1, 1] * 0.7
  }

  state
}

f &lt;- function(policy = NULL,
              numberOfPeriods = 50) {
  ge &lt;- sdm2(
    A = function(state) {
      a.firm.prod &lt;- CD_A(alpha = 1, Beta = c(0, 0.5, 0.5, 0), state$p)
      a.firm.cap1 &lt;- c(1, 0, 0.1, 0)
      a.firm.cap2 &lt;- c(0, 0, 0.1, 1)
      a.consumer &lt;- c(1, 0, 0, 0)
      cbind(a.firm.prod, a.firm.cap1, a.firm.cap2, a.consumer)
    },
    B = matrix(c(
      1, 0, 0, 0,
      0, 0, 1, 0,
      0, 0, 0, 0,
      0, 1, 0, 0
    ), 4, 4, TRUE),
    S0Exg = {
      tmp &lt;- matrix(NA, 4, 4)
      tmp[3, 4] &lt;- 100
      tmp
    },
    names.commodity = c("prod", "cap2", "lab", "cap1"),
    names.agent = c("firm.prod", "firm.cap1", "firm.cap2", "consumer"),
    numeraire = "lab",
    maxIteration = 1,
    numberOfPeriods = numberOfPeriods,
    ts = TRUE,
    p0 = c(4.191, 4.391, 1, 4.291),
    # The equilibrium output of firm.prod is 45.64.
    z0 = c(50, 21.78, 21.78, 23.86),
    policy = policy
  )

  matplot(ge$ts.z, type = "o", pch = 20)
  ge
}

## a disequilibrium path
de &lt;- f(numberOfPeriods = 500)

## a spot market clearing path converging to equilibrium
ge &lt;- f(
  policy = policyMarketClearingPrice,
  numberOfPeriods = 40
)
ge$p
ge$z

## a spot market clearing path with persisting fluctuations
de &lt;- f(policy = list(
  policy.credit,
  policyMarketClearingPrice
))

</code></pre>

<hr>
<h2 id='demInsufficientEffectiveDemand_3_3'>A Disequilibrium Model Illustrating Insufficient Effective Demand (Supply-demand Structural Mismatch)</h2><span id='topic+demInsufficientEffectiveDemand_3_3'></span>

<h3>Description</h3>

<p>A disequilibrium model illustrating supply-demand structural mismatch and insufficient effective demand.
Assume that from the 5th period, the producer expects the sales rate of products to decline,
so he reduces investment in production and increases the demand for value storage means (such as foreign assets, gold, etc.);
the laborer expects the unemployment rate to rise, so he reduces consumption and increases the demand for value storage means.
</p>
<p>Here the supplier of value storage means is referred to as ROW (the rest of the world).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demInsufficientEffectiveDemand_3_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demInsufficientEffectiveDemand_3_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.firm &lt;- node_new("output",
  type = "FIN", rate = c(1, 0),
  "cc1", "store of value"
)
node_set(dst.firm, "cc1",
  type = "CD", alpha = 2,
  beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.laborer &lt;- node_new("util",
  type = "FIN", rate = c(1, 0),
  "cc1", "store of value"
)
node_set(dst.laborer, "cc1",
  type = "CD", alpha = 1,
  beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.ROW &lt;- node_new("util",
  type = "Leontief", a = 1,
  "lab"
)

policy.demand &lt;- function(time, A, state) {
  if (time &gt;= 5) {
    A[[1]]$rate &lt;- c(1, 0.25)
    A[[2]]$rate &lt;- c(1, 0.25)
  } else {
    A[[1]]$rate &lt;- c(1, 0)
    A[[2]]$rate &lt;- c(1, 0)
  }

  state
}

ge &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.ROW),
  B = matrix(c(
    1, 0, 0,
    0, 0, 0,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 100, NA,
    NA, NA, 100
  ), 3, 3, TRUE),
  names.commodity = c("prod", "lab", "store of value"),
  names.agent = c("firm", "laborer", "ROW"),
  ts = TRUE,
  policy = policy.demand,
  numberOfPeriods = 100,
  maxIteration = 1,
  numeraire = "prod",
  z0 = c(100, 0, 0),
  p0 = c(1, 1, 1),
  pExg = c(1, NA, 1)
)

matplot(ge$ts.z, type = "o", pch = 20)
matplot(ge$ts.p, type = "o", pch = 20)
matplot(ge$ts.q, type = "o", pch = 20)

</code></pre>

<hr>
<h2 id='ge_tidy'>Tidy a General Equilibrium</h2><span id='topic+ge_tidy'></span>

<h3>Description</h3>

<p>Add names to the matrices and vectors of a general equilibrium, and add
demand matrix, demand value matrix and supply value matrix to it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ge_tidy(ge, names.commodity, names.agent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ge_tidy_+3A_ge">ge</code></td>
<td>
<p>a general equilibrium.</p>
</td></tr>
<tr><td><code id="ge_tidy_+3A_names.commodity">names.commodity</code></td>
<td>
<p>a character vector consisting of
names of commodities.</p>
</td></tr>
<tr><td><code id="ge_tidy_+3A_names.agent">names.agent</code></td>
<td>
<p>a character vector consisting of
names of agents.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tidied general equilibrium.
</p>

<hr>
<h2 id='gem_2_2'>Some Simple 2-by-2 General Equilibrium Models</h2><span id='topic+gem_2_2'></span>

<h3>Description</h3>

<p>Some simple 2-by-2 general equilibrium models with a firm and a laborer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gem_2_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gem_2_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>http://www.econ.ucla.edu/riley/MAE/Course/SolvingForTheWE.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### a 2-by-2 general equilibrium model with a Leontief production function.
ge.Leontief &lt;- sdm2(
  A = matrix(c(
    0.5, 1,
    0.5, 0
  ), 2, 2, TRUE),
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "laborer"),
  numeraire = "prod"
)

ge.Leontief$p
ge.Leontief$z
addmargins(ge.Leontief$D, 2)
addmargins(ge.Leontief$S, 2)

## the same as above.
ge2.Leontief &lt;- sdm2(
  A = list(
    dst.firm = node_new(
      "output",
      type = "Leontief",
      a = c(0.5, 0.5),
      "prod", "lab"
    ),
    dst.consumer = node_new(
      "util",
      type = "Leontief", a = 1,
      "prod"
    )
  ),
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "laborer"),
  numeraire = "prod"
)

ge2.Leontief$p
ge2.Leontief$z
addmargins(ge2.Leontief$D, 2)
addmargins(ge2.Leontief$S, 2)

#### a 2-by-2 general equilibrium model with a CD production function.
ge.CD &lt;- sdm2(
  A = function(state) {
    ## the vector of demand coefficients of the firm
    a1 &lt;- CD_A(alpha = 2, Beta = c(0.5, 0.5), state$p)
    ## the vector of demand coefficients of the laborer
    a2 &lt;- c(1, 0)
    cbind(a1, a2)
  },
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "laborer"),
  numeraire = "prod"
)

ge.CD$p
ge.CD$z
addmargins(ge.CD$D, 2)
addmargins(ge.CD$S, 2)

## the same as above.
ge2.CD &lt;- sdm2(
  A = list(
    dst.firm = node_new(
      "output",
      type = "CD", alpha = 2, beta = c(0.5, 0.5),
      "prod", "lab"
    ),
    dst.consumer = node_new(
      "util",
      type = "Leontief", a = 1,
      "prod"
    )
  ),
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "laborer"),
  numeraire = "prod"
)

ge2.CD$p
ge2.CD$z
addmargins(ge2.CD$D, 2)
addmargins(ge2.CD$S, 2)

#### a 2-by-2 general equilibrium model with a SCES production function.
ge.SCES &lt;- sdm2(
  A = function(state) {
    a1 &lt;- SCES_A(es = 0.5, alpha = 1, Beta = c(0.5, 0.5), p = state$p)
    a2 &lt;- c(1, 0)
    cbind(a1, a2)
  },
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "laborer"),
  numeraire = "prod"
)

ge.SCES$p
ge.SCES$z
addmargins(ge.SCES$D, 2)
addmargins(ge.SCES$S, 2)

## the same as above.
ge2.SCES &lt;- sdm2(
  A = list(
    dst.firm = node_new(
      "output",
      type = "SCES",
      es = 0.5, alpha = 1, beta = c(0.5, 0.5),
      "prod", "lab"
    ),
    dst.consumer = node_new(
      "util",
      type = "Leontief", a = 1,
      "prod"
    )
  ),
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "laborer"),
  numeraire = "prod"
)

ge2.SCES$p
ge2.SCES$z
addmargins(ge2.SCES$D, 2)
addmargins(ge2.SCES$S, 2)

#### a 2-by-2 general equilibrium model with a CESAK production function.
ge.CESAK &lt;- sdm2(
  A = function(state) {
    a.firm &lt;- CESAK_dc(alpha = 2, betaK = 0.5, alphaK = 0.5, p = state$p, es = 1)
    a.consumer &lt;- c(1, 0)
    cbind(a.firm, a.consumer)
  },
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "prod"
)

ge.CESAK$p
ge.CESAK$z
addmargins(ge.CESAK$D, 2)
addmargins(ge.CESAK$S, 2)

## the same as above.
ge2.CESAK &lt;- sdm2(
  A = list(
    dst.firm = node_new(
      "output",
      type = "CESAK", es = 1,
      alpha = 2, betaK = 0.5, alphaK = 0.5,
      "prod", "lab"
    ),
    dst.consumer = node_new(
      "util",
      type = "Leontief", a = 1,
      "prod"
    )
  ),
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "prod"
)

ge2.CESAK$p
ge2.CESAK$z
addmargins(ge2.CESAK$D, 2)
addmargins(ge2.CESAK$S, 2)

#### Example 1 in the ucla reference.
ge3.SCES &lt;- sdm2(
  A = function(state) {
    a.firm &lt;- c(0, 0.25)
    a.consumer &lt;- SCES_A(es = 0.5, alpha = 1, Beta = c(0.5, 0.5), p = state$p)
    cbind(a.firm, a.consumer)
  },
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 30
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "laborer"),
  numeraire = "prod"
)

ge3.SCES$p
ge3.SCES$z
ge3.SCES$D
ge3.SCES$S

#### The laborer has some product.
ge &lt;- sdm2(
  A = function(state) {
    a.firm &lt;- c(0, 1) # c(0, 2)
    a.consumer &lt;- SCES_A(es = 0.5, alpha = 1, Beta = c(0.5, 0.5), p = state$p)
    cbind(a.firm, a.consumer)
  },
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, 50, # 500
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "laborer"),
  numeraire = "prod"
)

ge$p
ge$z
ge$D
ge$S

</code></pre>

<hr>
<h2 id='gem_3_2'>Some Simple 3-by-2 General Equilibrium Models</h2><span id='topic+gem_3_2'></span>

<h3>Description</h3>

<p>Some simple 3-by-2 general equilibrium models with a firm and a consumer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gem_3_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gem_3_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>http://www.econ.ucla.edu/riley/MAE/Course/SolvingForTheWE.pdf
</p>
<p>He Zhangyong, Song Zheng (2010, ISBN: 9787040297270) Advanced Macroeconomics. Beijing: Higher Education Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ge.CD &lt;- sdm2(
  A = function(state) {
    ## the vector of demand coefficients of the firm
    a1 &lt;- CD_A(alpha = 2, Beta = c(0, 0.5, 0.5), state$p)
    ## the vector of demand coefficients of the consumer
    a2 &lt;- c(1, 0, 0)
    cbind(a1, a2)
  },
  B = matrix(c(
    1, 0,
    0, 0,
    0, 0
  ), 3, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100,
    NA, 100
  ), 3, 2, TRUE),
  names.commodity = c("prod", "cap", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "prod"
)

ge.CD$p
ge.CD$z
ge.CD$D
ge.CD$S

#### Example 2 in the ucla reference
## By introducing a new factor of production (called land here)
## a firm with diminishing returns to scale can be converted into
## a firm with constant returns to scale.
ge2.CD &lt;- sdm2(
  A = function(state) {
    a.firm &lt;- CD_A(alpha = 6, Beta = c(0, 0.5, 0.5), state$p)
    a.consumer &lt;- CD_A(alpha = 1, Beta = c(0.2, 0.8, 0), state$p)
    cbind(a.firm, a.consumer)
  },
  B = matrix(c(
    1, 0,
    0, 0,
    0, 0
  ), 3, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 81,
    NA, 1
  ), 3, 2, TRUE),
  names.commodity = c("prod", "lab", "land"),
  names.agent = c("firm", "consumer"),
  numeraire = "prod"
)

ge2.CD$p
ge2.CD$z
ge2.CD$D
ge2.CD$S

####
ge.SCES &lt;- sdm2(
  A = function(state) {
    a1 &lt;- SCES_A(es = 0.5, alpha = 1, Beta = c(0, 0.5, 0.5), p = state$p)
    a2 &lt;- c(1, 0, 0)
    cbind(a1, a2)
  },
  B = matrix(c(
    1, 0,
    0, 0,
    0, 0
  ), 3, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100,
    NA, 100
  ), 3, 2, TRUE),
  names.commodity = c("prod", "cap", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "prod"
)

ge.SCES$p
ge.SCES$z
ge.SCES$D
ge.SCES$S

####
ge2.SCES &lt;- sdm2(
  A = function(state) {
    a1 &lt;- SCES_A(es = 0.5, alpha = 1, Beta = c(0.2, 0.4, 0.4), p = state$p)
    a2 &lt;- c(1, 0, 0)
    cbind(a1, a2)
  },
  B = matrix(c(
    1, 0,
    0, 0,
    0, 0
  ), 3, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100,
    NA, 100
  ), 3, 2, TRUE),
  names.commodity = c("prod", "cap", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "prod"
)

ge2.SCES$p
ge2.SCES$z
ge2.SCES$D
ge2.SCES$S

#### nested production function
dst.firm &lt;- node_new(
  "prod",
  type = "Leontief",
  a = c(0.2, 0.8),
  "prod", "cc1"
)
node_set(dst.firm, "cc1",
         type = "SCES",
         es = 0.5, alpha = 1, beta = c(0.5, 0.5),
         "cap", "lab"
)

dst.consumer &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "prod"
)

ge3.SCES &lt;- sdm2(
  A = list(dst.firm, dst.consumer),
  B = matrix(c(
    1, 0,
    0, 0,
    0, 0
  ), 3, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100,
    NA, 100
  ), 3, 2, TRUE),
  names.commodity = c("prod", "cap", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "prod"
)

ge3.SCES$p
ge3.SCES$z
ge3.SCES$D
ge3.SCES$S

#### a model with a quasilinear utility function (see He and Song, 2010, page 19).
alpha.firm &lt;- 2
beta.cap.firm &lt;- 0.6
beta.lab.firm &lt;- 1 - beta.cap.firm
theta.consumer &lt;- 0.8
lab.supply &lt;- 2
cap.supply &lt;- 1

ge &lt;- sdm2(
  A = function(state) {
    a1 &lt;- CD_A(alpha.firm, rbind(0, beta.lab.firm, beta.cap.firm), state$p)

    demand.lab.prod &lt;- QL_demand(
      w = state$w[2], p = state$p[2:1], # the prices of lab and prod
      alpha = 1, beta = theta.consumer, type = "CRRA"
    )
    a2 &lt;- c(demand.lab.prod[2:1], 0)
    cbind(a1, a2)
  },
  B = matrix(c(
    1, 0,
    0, 0,
    0, 0
  ), 3, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, lab.supply,
    NA, cap.supply
  ), 3, 2, TRUE),
  names.commodity = c("prod", "lab", "cap"),
  names.agent = c("firm", "consumer"),
  numeraire = "prod"
)

ge$p
ge$z
ge$D
ge$S

# the equilibrium leisure
lab.supply - (beta.lab.firm * (alpha.firm * cap.supply^beta.cap.firm)^(1 - theta.consumer))^
  (1 / (beta.cap.firm + beta.lab.firm * theta.consumer))

# the equilibrium price of labor
w &lt;- ((1 - beta.cap.firm)^(1 - beta.cap.firm) * (alpha.firm * cap.supply^beta.cap.firm))^
  (theta.consumer / (beta.cap.firm + (1 - beta.cap.firm) * theta.consumer))

# the equilibrium price of capital goods
beta.cap.firm * w^(1 / theta.consumer) / cap.supply

</code></pre>

<hr>
<h2 id='gem_3_3'>Some Simple 3-by-3 General Equilibrium Models</h2><span id='topic+gem_3_3'></span>

<h3>Description</h3>

<p>Some simple 3-by-3 general equilibrium models with two firms and a consumer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gem_3_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gem_3_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>See Also</h3>


<p><code><a href="#topic+gemCapitalAccumulation">gemCapitalAccumulation</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
####
ge &lt;- sdm2(
  A = function(state) {
    ## the vector of demand coefficients of the firm
    a.firm.corn &lt;- CD_A(alpha = 1, Beta = c(0, 0.5, 0.5), p = state$p)
    a.firm.iron &lt;- CD_A(alpha = 2, Beta = c(0, 0.5, 0.5), p = state$p)
    ## the vector of demand coefficients of the consumer
    a.consumer &lt;- CD_A(alpha = 1, Beta = c(0.5, 0.5, 0), p = state$p)
    cbind(a.firm.corn, a.firm.iron, a.consumer)
  },
  B = diag(c(1, 1), 3),
  S0Exg = {
    tmp &lt;- matrix(NA, 3, 3)
    tmp[3, 3] &lt;- 100
    tmp
  },
  names.commodity = c("corn", "iron", "lab"),
  names.agent = c("firm.corn", "firm.iron", "consumer"),
  numeraire = "lab"
)

ge$p
ge$z
ge$D
ge$S

####
ge &lt;- sdm2(
  A = function(state) {
    ## the vector of demand coefficients of the firm
    a.firm.corn &lt;-
      SCES_A(es = 1,
             alpha = 1,
             Beta = c(0, 0.5, 0.5),
             p = state$p)
    a.firm.iron &lt;-
      SCES_A(es = 1,
             alpha = 2,
             Beta = c(0, 0.5, 0.5),
             p = state$p)
    ## the vector of demand coefficients of the consumer
    a.consumer &lt;- CD_A(alpha = 1, Beta = c(0.5, 0.5, 0), p = state$p)
    cbind(a.firm.corn, a.firm.iron, a.consumer)
  },
  B = diag(c(1, 1), 3),
  S0Exg = {
    tmp &lt;- matrix(NA, 3, 3)
    tmp[3, 3] &lt;- 100
    tmp
  },
  names.commodity = c("corn", "iron", "lab"),
  names.agent = c("firm.corn", "firm.iron", "consumer"),
  numeraire = "lab"
)

ge$p
ge$z
ge$D
ge$S

#### a general equilibrium model containing a production firm
#### and a capital-goods-leasing firm
ge &lt;- sdm2(
  A = function(state) {
    a.firm1 &lt;- CD_A(alpha = 2, Beta = c(0, 0.5, 0.5), state$p)
    a.consumer &lt;- c(1, 0, 0)
    a.firm2 &lt;- c(1, 0, 0)
    cbind(a.firm1, a.consumer, a.firm2)
  },
  B = matrix(c(
    1, 0, 0.5,
    0, 0, 1,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, NA, NA,
    NA, 100,NA
  ), 3, 3, TRUE),
  names.commodity = c("prod", "cap", "lab"),
  names.agent = c("firm1", "consumer","firm2"),
  numeraire = "prod",
  priceAdjustmentVelocity = 0.05
)
ge$p
ge$z
ge$D

</code></pre>

<hr>
<h2 id='gem_3_4'>Some Simple 3-by-4 General Equilibrium Models</h2><span id='topic+gem_3_4'></span>

<h3>Description</h3>

<p>Some simple 3-by-4 general equilibrium models with two firms and two consumers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gem_3_4(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gem_3_4_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
####
ge &lt;- sdm2(
  A = function(state) {
    a.firm.corn &lt;- CD_A(alpha = 1, Beta = c(0, 0.5, 0.5), state$p)
    a.firm.iron &lt;- CD_A(alpha = 2, Beta = c(0, 0.5, 0.5), state$p)
    a.consumer1 &lt;- c(1, 0, 0)
    a.consumer2 &lt;- CD_A(alpha = 1, Beta = c(0.5, 0.5, 0), state$p)

    cbind(a.firm.corn, a.firm.iron, a.consumer1, a.consumer2)
  },
  B = diag(c(1, 1, 0), 3, 4),
  S0Exg = {
    tmp &lt;- matrix(NA, 3, 4)
    tmp[3, 3:4] &lt;- 100
    tmp
  },
  names.commodity = c("corn", "iron", "lab"),
  names.agent = c("firm.corn", "firm.iron", "consumer1", "consumer2"),
  numeraire = "lab"
)

ge$p
ge$z
ge$D
ge$S

####
ge &lt;- sdm2(
  A = function(state) {
    a.firm.corn &lt;-
      SCES_A(
        es = 1,
        alpha = 1,
        Beta = c(0, 0.5, 0.5),
        p = state$p
      )
    a.firm.iron &lt;-
      SCES_A(
        es = 1,
        alpha = 2,
        Beta = c(0, 0.5, 0.5),
        p = state$p
      )
    a.consumer1 &lt;- c(1, 0, 0)
    a.consumer2 &lt;- CD_A(alpha = 1, Beta = c(0.5, 0.5, 0), state$p)

    cbind(a.firm.corn, a.firm.iron, a.consumer1, a.consumer2)
  },
  B = diag(c(1, 1, 0), 3, 4),
  S0Exg = {
    tmp &lt;- matrix(NA, 3, 4)
    tmp[3, 3:4] &lt;- 100
    tmp
  },
  names.commodity = c("corn", "iron", "lab"),
  names.agent = c("firm.corn", "firm.iron", "consumer1", "consumer2"),
  numeraire = "lab"
)

ge$p
ge$z
ge$D
ge$S

#### an example at
## https://web.stanford.edu/~jdlevin/Econ%20202/General%20Equilibrium.pdf
ge &lt;- sdm2(
  A = function(state) {
    a.firm.1 &lt;- c(0, 1, 0)
    a.firm.2 &lt;- c(0, 0, 1)
    a.consumer1 &lt;- CD_A(alpha = 1, Beta = c(1 / 3, 1 / 3, 1 / 3), state$p)
    a.consumer2 &lt;- CD_A(alpha = 1, Beta = c(1 / 3, 1 / 3, 1 / 3), state$p)

    cbind(a.firm.1, a.firm.2, a.consumer1, a.consumer2)
  },
  B = matrix(c(
    2, 0, 0, 0,
    0, 1, 0, 0,
    0.5, 0, 0, 0
  ), 3, 4, TRUE),
  S0Exg = matrix(c(
    NA, NA, 1, 2,
    NA, NA, 2, 2,
    NA, NA, 3, 2
  ), 3, 4, TRUE),
  names.agent = c("firm1", "firm2", "consumer1", "consumer2"),
  numeraire = 3
)

ge$p
ge$z
ge$D
ge$S

</code></pre>

<hr>
<h2 id='gem_4_4'>Some Simple 4-by-4 General Equilibrium Models</h2><span id='topic+gem_4_4'></span>

<h3>Description</h3>

<p>Some simple 4-by-4 general equilibrium models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gem_4_4(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gem_4_4_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### A general equilibrium model containing a capital good with service-life
# wear-and-tear. The new product can be used as a capital good with a service
# life of two periods, and the used old capital good is the old product.
ge &lt;- sdm2(
  A = function(state) {
    a.firm1 &lt;- CD_A(alpha = 2, Beta = c(0, 0.5, 0.5, 0), state$p)
    a.consumer &lt;- c(1, 0, 0, 0)
    a.firm2 &lt;- c(1, 0, 0, 0)
    a.firm3 &lt;- c(0, 0, 0, 1)
    cbind(a.firm1, a.consumer, a.firm2, a.firm3)
  },
  B = matrix(c(
    1, 0, 0, 0,
    0, 0, 1, 1,
    0, 0, 0, 0,
    0, 0, 1, 0
  ), 4, 4, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA,
    NA, NA, NA, NA,
    NA, 100, NA, NA,
    NA, NA, NA, NA
  ), 4, 4, TRUE),
  names.commodity = c("prod.new", "cap", "lab", "prod.old"),
  names.agent = c("firm1", "consumer", "firm2", "firm3"),
  numeraire = "prod.new",
  priceAdjustmentVelocity = 0.05
)

ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)

#### the Shoven-Whalley model at
## https://lexjansen.com/nesug/nesug03/st/st002.pdf
ge &lt;- sdm2(
  A = function(state) {
    a.firm.corn &lt;- CES_A(sigma = 1 - 1 / 2, alpha = 1.5, Beta = c(0, 0, 0.4, 0.6), state$p)
    a.firm.iron &lt;- CES_A(sigma = 1 - 1 / 0.5, alpha = 2, Beta = c(0, 0, 0.3, 0.7), state$p)
    a.consumer1 &lt;- SCES_A(alpha = 1, Beta = c(0.5, 0.5, 0, 0), es = 1.5, p = state$p)
    a.consumer2 &lt;- SCES_A(alpha = 1, Beta = c(0.3, 0.7, 0, 0), es = 0.75, p = state$p)

    cbind(a.firm.corn, a.firm.iron, a.consumer1, a.consumer2)
  },
  B = diag(c(1, 1, 0, 0), 4, 4),
  S0Exg = {
    tmp &lt;- matrix(NA, 4, 4)
    tmp[3, 3] &lt;- 25
    tmp[4, 4] &lt;- 60
    tmp
  },
  names.commodity = c("corn", "iron", "cap", "lab"),
  names.agent = c("firm.corn", "firm.iron", "consumer1", "consumer2"),
  numeraire = "lab"
)

ge$p
ge$z
ge$D
ge$S

#### an n-by-n general equilibrium model with Cobb-Douglas functions.
f &lt;- function(n, policy = NULL, z0 = rep(100 * n, n), numberOfPeriods = 30,
              Beta = matrix(1 / n, n, n), n.firm = n - 1) {
  ge &lt;- sdm2(
    A = function(state) {
      CD_A(alpha = rep(n, n), Beta = Beta, p = state$p)
    },
    B = {
      tmp &lt;- diag(n)
      tmp[, (n.firm + 1):n] &lt;- 0
      tmp
    },
    S0Exg = {
      tmp &lt;- matrix(NA, n, n)
      for (k in (n.firm + 1):n) tmp[k, k] &lt;- 100 * n
      tmp
    },
    numeraire = n,
    policy = policy,
    z0 = z0,
    maxIteration = 1,
    numberOfPeriods = numberOfPeriods,
    names.agent = c(paste0("firm", 1:n.firm), paste0("consumer", 1:(n - n.firm))),
    ts = TRUE
  )
  print(ge$z)
  print(ge$p)
  invisible(ge)
}

n &lt;- 4
f(n, n.firm = n - 2)
## a spot market clearing path (alias instantaneous equilibrium path)
ge &lt;- f(n, policy = policyMarketClearingPrice, z0 = runif(n, 10 * n, 100 * n), n.firm = n - 2)
matplot(ge$ts.z, type = "b", pch = 20)
matplot(ge$ts.p, type = "b", pch = 20)

</code></pre>

<hr>
<h2 id='gemAssetExchange_MatthewEffect_2_2'>An Example Illustrating the Matthew Effect of Asset Exchange</h2><span id='topic+gemAssetExchange_MatthewEffect_2_2'></span>

<h3>Description</h3>

<p>This is an example that illustrates the Matthew effect of asset exchange,
wherein the wealth gap between two traders widens after the exchange process.
Initially, these traders had a relatively small wealth (i.e. expected average payoff) gap.
However, the exchange leads to an expansion of the wealth gap.
This outcome can be attributed to the fact that a trader's risk aversion coefficient is affected by his level of wealth.
When traders have less wealth their risk aversion coefficient is higher.
Consequently, a trader with less wealth tends to acquire more low-risk, low-average-payoff assets through trading.
As a result, the expected average payoff of a trader with less wealth may decrease after the exchange.
Conversely, a trader with more wealth may hold more high-risk, high-average-payoff assets after trading.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemAssetExchange_MatthewEffect_2_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemAssetExchange_MatthewEffect_2_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gemAssetPricing_PUF">gemAssetPricing_PUF</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### Matthew effect
asset1 &lt;- c(40, 200)
asset2 &lt;- c(100, 100)

# unit asset payoff matrix.
UAP &lt;- cbind(asset1, asset2)

S &lt;- matrix(c(
  0.49, 0.51,
  0.49, 0.51
), 2, 2, TRUE)

ge &lt;- sdm2(
  A = function(state) {
    Portfolio &lt;- state$last.A %*% dg(state$last.z)

    Payoff &lt;- UAP %*% Portfolio
    payoff.average &lt;- colMeans(Payoff)

    # the risk aversion coefficients.
    rac &lt;- ifelse(payoff.average &gt; mean(UAP) * 1.02, 0.5, 1)
    rac &lt;- ifelse(payoff.average &lt; mean(UAP) / 1.02, 2, rac)

    uf1 &lt;- function(portfolio) {
      payoff &lt;- UAP %*% portfolio
      CES(alpha = 1, beta = c(0.5, 0.5), x = payoff, es = 1 / rac[1])
    }

    uf2 &lt;- function(portfolio) {
      payoff &lt;- UAP %*% portfolio
      CES(alpha = 1, beta = c(0.5, 0.5), x = payoff, es = 1 / rac[2])
    }

    VMU &lt;- marginal_utility(Portfolio, diag(2), list(uf1, uf2), state$p)
    VMU &lt;- pmax(VMU, 1e-10)

    Ratio &lt;- sweep(VMU, 2, colMeans(VMU), "/")
    A &lt;- state$last.A * ratio_adjust(Ratio, coef = 0.1, method = "linear")

    prop.table(A, 2)
  },
  B = matrix(0, 2, 2),
  S0Exg = S,
  names.commodity = c("asset1", "asset2"),
  numeraire = 2,
  maxIteration = 1,
  numberOfPeriods = 1000,
  policy = makePolicyMeanValue(50),
  ts = TRUE
)

matplot(ge$ts.p, type = "l")
ge$p
ge$z
ge$D

(Payoff.S &lt;- UAP %*% S)
colMeans(Payoff.S)

(Payoff.D &lt;- UAP %*% ge$D)
colMeans(Payoff.D)

## Calculate the equilibrium under the fixed risk aversion coefficients.
rac &lt;- c(2, 0.5)

uf &lt;- list()
uf[[1]] &lt;- function(portfolio) {
  payoff &lt;- UAP %*% portfolio
  CES(alpha = 1, beta = c(0.5, 0.5), x = payoff, es = 1 / rac[1])
}

uf[[2]] &lt;- function(portfolio) {
  payoff &lt;- UAP %*% portfolio
  CES(alpha = 1, beta = c(0.5, 0.5), x = payoff, es = 1 / rac[2])
}

ge &lt;- gemAssetPricing_PUF(
  S = S,
  uf = uf,
  policy = makePolicyMeanValue(50)
)

ge$p
addmargins(ge$D, 2)
addmargins(ge$S, 2)
ge$VMU

(Payoff &lt;- UAP %*% ge$D)
colMeans(Payoff)

</code></pre>

<hr>
<h2 id='gemAssetPricing_CUF'>Compute Asset Market Equilibria with Commodity Utility Functions for Some Simple Cases</h2><span id='topic+gemAssetPricing_CUF'></span>

<h3>Description</h3>

<p>Compute the equilibrium of an asset market by the function sdm2 and by computing marginal utility of assets (see Sharpe, 2008).
The argument of the utility function used in the calculation is the commodity vector (i.e. payoff vector).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemAssetPricing_CUF(
  S = diag(2),
  UAP = diag(nrow(S)),
  uf = NULL,
  muf = NULL,
  ratio_adjust_coef = 0.05,
  numeraire = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemAssetPricing_CUF_+3A_s">S</code></td>
<td>
<p>an n-by-m supply matrix of assets.</p>
</td></tr>
<tr><td><code id="gemAssetPricing_CUF_+3A_uap">UAP</code></td>
<td>
<p>a unit asset payoff k-by-n matrix.</p>
</td></tr>
<tr><td><code id="gemAssetPricing_CUF_+3A_uf">uf</code></td>
<td>
<p>a utility function or a utility function list.</p>
</td></tr>
<tr><td><code id="gemAssetPricing_CUF_+3A_muf">muf</code></td>
<td>
<p>a marginal utility function or a marginal utility function list.</p>
</td></tr>
<tr><td><code id="gemAssetPricing_CUF_+3A_ratio_adjust_coef">ratio_adjust_coef</code></td>
<td>
<p>a scalar indicating the adjustment velocity of demand structure.</p>
</td></tr>
<tr><td><code id="gemAssetPricing_CUF_+3A_numeraire">numeraire</code></td>
<td>
<p>the index of the numeraire commodity.</p>
</td></tr>
<tr><td><code id="gemAssetPricing_CUF_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A general equilibrium containing a value marginal utility matrix (VMU).
</p>


<h3>References</h3>

<p>Danthine, J. P., Donaldson, J. (2005, ISBN: 9780123693808) Intermediate Financial Theory. Elsevier Academic Press.
</p>
<p>Sharpe, William F. (2008, ISBN: 9780691138503) Investors and Markets: Portfolio Choices, Asset Prices, and Investment Advice. Princeton University Press.
</p>
<p>Wang Jiang (2006, ISBN: 9787300073477) Financial Economics. Beijing: China Renmin University Press. (In Chinese)
</p>
<p>Xu Gao (2018, ISBN: 9787300258232) Twenty-five Lectures on Financial Economics. Beijing: China Renmin University Press. (In Chinese)
</p>
<p>https://web.stanford.edu/~wfsharpe/apsim/index.html
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gemAssetPricingExample">gemAssetPricingExample</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gemAssetPricing_CUF(muf = function(x) 1 / x)

gemAssetPricing_CUF(
  S = cbind(c(1, 0), c(0, 2)),
  muf = function(x) 1 / x
)

gemAssetPricing_CUF(
  UAP = cbind(c(1, 0), c(0, 2)),
  muf = function(x) 1 / x
)

#### an example of Danthine and Donaldson (2005, section 8.3).
ge &lt;- gemAssetPricing_CUF(
  S = matrix(c(
    10, 5,
    1, 4,
    2, 6
  ), 3, 2, TRUE),
  uf = function(x) 0.5 * x[1] + 0.9 * (1 / 3 * log(x[2]) + 2 / 3 * log(x[3]))
)

ge$p

#### an example of Sharpe (2008, chapter 2, case 1)
asset1 &lt;- c(1, 0, 0, 0, 0)
asset2 &lt;- c(0, 1, 1, 1, 1)
asset3 &lt;- c(0, 5, 3, 8, 4) - 3 * asset2
asset4 &lt;- c(0, 3, 5, 4, 8) - 3 * asset2
# unit asset payoff matrix
UAP &lt;- cbind(asset1, asset2, asset3, asset4)

prob &lt;- c(0.15, 0.25, 0.25, 0.35)
wt &lt;- prop.table(c(1, 0.96 * prob)) # weights

geSharpe1 &lt;- gemAssetPricing_CUF(
  S = matrix(c(
    49, 49,
    30, 30,
    10, 0,
    0, 10
  ), 4, 2, TRUE),
  UAP = UAP,
  uf = list(
    function(x) CES(alpha = 1, beta = wt, x = x, es = 1 / 1.5),
    function(x) CES(alpha = 1, beta = wt, x = x, es = 1 / 2.5)
  )
)
geSharpe1$p
geSharpe1$p[3:4] + 3 * geSharpe1$p[2]

## an example of Sharpe (2008, chapter 3, case 2)
geSharpe2 &lt;- gemAssetPricing_CUF(
  S = matrix(c(
    49, 49, 98, 98,
    30, 30, 60, 60,
    10, 0, 20, 0,
    0, 10, 0, 20
  ), 4, 4, TRUE),
  UAP = UAP,
  uf = list(
    function(x) CES(alpha = 1, beta = wt, x = x, es = 1 / 1.5),
    function(x) CES(alpha = 1, beta = wt, x = x, es = 1 / 2.5),
    function(x) CES(alpha = 1, beta = wt, x = x, es = 1 / 1.5),
    function(x) CES(alpha = 1, beta = wt, x = x, es = 1 / 2.5)
  )
)

geSharpe2$p
geSharpe2$p[3:4] + 3 * geSharpe2$p[2]
geSharpe2$D

## an example of Sharpe (2008, chapter 3, case 3)
geSharpe3 &lt;- gemAssetPricing_CUF(UAP,
  uf = function(x) (x - x^2 / 400) %*% wt,
  S = matrix(c(
    49, 98,
    30, 60,
    5, 10,
    5, 10
  ), 4, 2, TRUE)
)
geSharpe3$p
geSharpe3$p[3:4] + 3 * geSharpe3$p[2]

# the same as above
geSharpe3b &lt;- gemAssetPricing_CUF(
  S = matrix(c(
    49, 98,
    30, 60,
    5, 10,
    5, 10
  ), 4, 2, TRUE),
  UAP = UAP,
  muf = function(x) (1 - x / 200) * wt
)

geSharpe3b$p
geSharpe3b$p[3:4] + 3 * geSharpe3b$p[2]

## an example of Sharpe (2008, chapter 3, case 4)
geSharpe4 &lt;- gemAssetPricing_CUF(
  S = matrix(c(
    49, 98,
    30, 60,
    5, 10,
    5, 10
  ), 4, 2, TRUE),
  UAP,
  muf = function(x) abs((x - 20)^(-1)) * wt,
  maxIteration = 100,
  numberOfPeriods = 300,
  ts = TRUE
)

geSharpe4$p
geSharpe4$p[3:4] + 3 * geSharpe4$p[2]

## an example of Sharpe (2008, chapter 6, case 14)
prob1 &lt;- c(0.15, 0.26, 0.31, 0.28)
wt1 &lt;- prop.table(c(1, 0.96 * prob1))
prob2 &lt;- c(0.08, 0.23, 0.28, 0.41)
wt2 &lt;- prop.table(c(1, 0.96 * prob2))

uf1 &lt;- function(x) CES(alpha = 1, beta = wt1, x = x, es = 1 / 1.5)
uf2 &lt;- function(x) CES(alpha = 1, beta = wt2, x = x, es = 1 / 2.5)
geSharpe14 &lt;- gemAssetPricing_CUF(
  S = matrix(c(
    49, 49,
    30, 30,
    10, 0,
    0, 10
  ), 4, 2, TRUE),
  UAP = UAP,
  uf = list(uf1,uf2)
)

geSharpe14$D
geSharpe14$p
geSharpe14$p[3:4] + 3 * geSharpe14$p[2]
mu &lt;- marginal_utility(geSharpe14$Payoff, diag(5),uf=list(uf1,uf2))
mu[,1]/mu[1,1]
mu[,2]/mu[1,2]

#### an example of Wang (2006, example 10.1, P146)
geWang &lt;- gemAssetPricing_CUF(
  S = matrix(c(
    1, 0,
    0, 2,
    0, 1
  ), 3, 2, TRUE),
  muf = list(
    function(x) 1 / x * c(0.5, 0.25, 0.25),
    function(x) 1 / sqrt(x) * c(0.5, 0.25, 0.25)
  )
)

geWang$p # c(1, (1 + sqrt(17)) / 16)

# the same as above
geWang.b &lt;- gemAssetPricing_CUF(
  S = matrix(c(
    1, 0,
    0, 2,
    0, 1
  ), 3, 2, TRUE),
  uf = list(
    function(x) log(x) %*% c(0.5, 0.25, 0.25),
    function(x) 2 * sqrt(x) %*% c(0.5, 0.25, 0.25)
  )
)

geWang.b$p

#### an example of Xu (2018, section 10.4, P151)
wt &lt;- c(1, 0.5, 0.5)
ge &lt;- gemAssetPricing_CUF(
  S = matrix(c(
    1, 0,
    0, 0.5,
    0, 2
  ), 3, 2, TRUE),
  uf = list(
    function(x) CRRA(x, gamma = 1, prob = wt)$u,
    function(x) CRRA(x, gamma = 0.5, prob = wt)$u
  )
)

ge$p # c(1, (1 + sqrt(5)) / 4, (1 + sqrt(17)) / 16)

#### an example of incomplete market
ge &lt;- gemAssetPricing_CUF(
  UAP = cbind(c(1, 1), c(2, 1)),
  uf = list(
    function(x) sum(log(x)) / 2,
    function(x) sum(sqrt(x))
  ),
  ratio_adjust_coef = 0.1,
  priceAdjustmentVelocity = 0.05,
  policy = makePolicyMeanValue(span = 100),
  maxIteration = 1,
  numberOfPeriods = 2000,
)

ge$p

## the same as above
ge.b &lt;- gemAssetPricing_CUF(
  UAP = cbind(c(1, 1), c(2, 1)),
  muf = list(
    function(x) 1 / x * c(0.5, 0.5),
    function(x) 1 / sqrt(x) * c(0.5, 0.5)
  ),
  ratio_adjust_coef = 0.1,
  priceAdjustmentVelocity = 0.05,
  policy = makePolicyMeanValue(span = 100),
  maxIteration = 1,
  numberOfPeriods = 2000,
  ts = TRUE
)

ge.b$p
matplot(ge.b$ts.p, type = "l")

#### an example with outside position.
asset1 &lt;- c(1, 0, 0)
asset2 &lt;- c(0, 1, 1)

# unit (asset) payoff matrix
UAP &lt;- cbind(asset1, asset2)
wt &lt;- c(0.5, 0.25, 0.25) # weights

uf1 &lt;- function(x) prod((x + c(0, 0, 2))^wt)
uf2 &lt;- function(x) prod(x^wt)

ge &lt;- gemAssetPricing_CUF(
  S = matrix(c(
    1, 1,
    0, 2
  ), 2, 2, TRUE),
  UAP = UAP,
  uf = list(uf1, uf2),
  numeraire = 1
)

ge$p
ge$z
uf1(ge$Payoff[,1])
uf2(ge$Payoff[,2])


</code></pre>

<hr>
<h2 id='gemAssetPricing_PUF'>Compute Asset Market Equilibria with Portfolio Utility Functions for Some Simple Cases</h2><span id='topic+gemAssetPricing_PUF'></span>

<h3>Description</h3>

<p>Compute the equilibrium of an asset market by the function sdm2 and by computing marginal utility of assets.
The argument of the utility function used in the calculation is the asset vector (i.e. portfolio).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemAssetPricing_PUF(S, uf, numeraire = nrow(S), ratio_adjust_coef = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemAssetPricing_PUF_+3A_s">S</code></td>
<td>
<p>an n-by-m supply matrix of assets.</p>
</td></tr>
<tr><td><code id="gemAssetPricing_PUF_+3A_uf">uf</code></td>
<td>
<p>a portfolio utility function or a list of m portfolio utility functions.</p>
</td></tr>
<tr><td><code id="gemAssetPricing_PUF_+3A_numeraire">numeraire</code></td>
<td>
<p>the index of the numeraire commodity.</p>
</td></tr>
<tr><td><code id="gemAssetPricing_PUF_+3A_ratio_adjust_coef">ratio_adjust_coef</code></td>
<td>
<p>a scalar indicating the adjustment velocity of demand structure.</p>
</td></tr>
<tr><td><code id="gemAssetPricing_PUF_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A general equilibrium containing a value marginal utility matrix (VMU).
</p>


<h3>References</h3>

<p>Danthine, J. P., Donaldson, J. (2005, ISBN: 9780123693808) Intermediate Financial Theory. Elsevier Academic Press.
</p>
<p>Sharpe, William F. (2008, ISBN: 9780691138503) Investors and Markets: Portfolio Choices, Asset Prices, and Investment Advice. Princeton University Press.
</p>
<p>https://web.stanford.edu/~wfsharpe/apsim/index.html
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gemAssetPricing_CUF">gemAssetPricing_CUF</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an example of Danthine and Donaldson (2005, section 8.3).
ge &lt;- gemAssetPricing_PUF(
  S = matrix(c(
    10, 5,
    1, 4,
    2, 6
  ), 3, 2, TRUE),
  uf = function(x) 0.5 * x[1] + 0.9 * (1 / 3 * log(x[2]) + 2 / 3 * log(x[3])),
  maxIteration = 1,
  numberOfPeriods = 500,
  ts = TRUE
)
matplot(ge$ts.p, type = "l")
ge$p

#### an example of Sharpe (2008, chapter 2, case 1)
asset1 &lt;- c(1, 0, 0, 0, 0)
asset2 &lt;- c(0, 1, 1, 1, 1)
asset3 &lt;- c(0, 5, 3, 8, 4) - 3 * asset2
asset4 &lt;- c(0, 3, 5, 4, 8) - 3 * asset2
# the unit asset payoff matrix
UAP &lt;- cbind(asset1, asset2, asset3, asset4)

prob &lt;- c(0.15, 0.25, 0.25, 0.35)
wt &lt;- prop.table(c(1, 0.96 * prob)) # weights

ge &lt;- gemAssetPricing_PUF(
  S = matrix(c(
    49, 49,
    30, 30,
    10, 0,
    0, 10
  ), 4, 2, TRUE),
  uf = list(
    function(portfolio) CES(alpha = 1, beta = wt, x = UAP %*% portfolio, es = 1 / 1.5),
    function(portfolio) CES(alpha = 1, beta = wt, x = UAP %*% portfolio, es = 1 / 2.5)
  ),
  maxIteration = 1,
  numberOfPeriods = 1000,
  numeraire = 1,
  ts = TRUE
)
matplot(ge$ts.p, type = "l")
ge$p
ge$p[3:4] + 3 * ge$p[2]

#### a 3-by-2 example of asset pricing with two heterogeneous agents who
## have different beliefs and predict different payoff vectors.
## the predicted payoff vectors of agent 1 on the two assets.
asset1.1 &lt;- c(1, 2, 2, 0)
asset2.1 &lt;- c(2, 2, 0, 2)

## the predicted payoff vectors of agent 2 on the two assets.
asset1.2 &lt;- c(1, 0, 2, 0)
asset2.2 &lt;- c(2, 1, 0, 2)

asset3 &lt;- c(1, 1, 1, 1)

## the unit asset payoff matrix of agent 1.
UAP1 &lt;- cbind(asset1.1, asset2.1, asset3)

## the unit asset payoff matrix of agent 2.
UAP2 &lt;- cbind(asset1.2, asset2.2, asset3)

mp1 &lt;- colMeans(UAP1)
Cov1 &lt;- cov.wt(UAP1, method = "ML")$cov

mp2 &lt;- colMeans(UAP2)
Cov2 &lt;- cov.wt(UAP2, method = "ML")$cov

ge &lt;- gemAssetPricing_PUF(
  S = matrix(c(
    1, 5,
    2, 5,
    3, 5
  ), 3, 2, TRUE),
  uf = list(
    # the utility function of agent 1.
    function(x) AMSDP(x, mp1, Cov1, gamma = 0.2, theta = 2),
    function(x) AMSDP(x, mp2, Cov2) # the utility function of agent 2
  ),
  maxIteration = 1,
  numberOfPeriods = 1000,
  ts = TRUE
)
matplot(ge$ts.p, type = "l")
ge$p
ge$VMU

#### another 3-by-2 example.
asset1.1 &lt;- c(0, 0, 1, 1, 2)
asset2.1 &lt;- c(1, 2, 1, 2, 0)
asset3.1 &lt;- c(1, 1, 1, 1, 1)

asset1.2 &lt;- c(0, 0, 1, 2)
asset2.2 &lt;- c(1, 2, 2, 1)
asset3.2 &lt;- c(1, 1, 1, 1)

## the unit asset payoff matrix of agent 1.
UAP1 &lt;- cbind(asset1.1, asset2.1, asset3.1)

## the unit asset payoff matrix of agent 2.
UAP2 &lt;- cbind(asset1.2, asset2.2, asset3.2)

mp1 &lt;- colMeans(UAP1)
Cov1 &lt;- cov.wt(UAP1, method = "ML")$cov

mp2 &lt;- colMeans(UAP2)
Cov2 &lt;- cov.wt(UAP2, method = "ML")$cov

ge &lt;- gemAssetPricing_PUF(
  S = matrix(c(
    1, 5,
    2, 5,
    3, 5
  ), 3, 2, TRUE),
  uf = list(
    function(x) AMSDP(x, mp1, Cov1), # the utility function of agent 1.
    function(x) AMSDP(x, mp2, Cov2) # the utility function of agent 2.
  ),
  maxIteration = 1,
  numberOfPeriods = 3000,
  ts = TRUE
)

ge$p
ge$D

#### a 5-by-3 example.
set.seed(1)
n &lt;- 5 # the number of asset types
m &lt;- 3 # the number of agents
Supply &lt;- matrix(runif(n * m, 10, 100), n, m)

# the risk aversion coefficients of agents.
gamma &lt;- runif(m, 0.25, 1)

# the predicted mean payoffs, which may be gross return rates, price indices or prices.
PMP &lt;- matrix(runif(n * m, min = 0.8, max = 1.5), n, m)

# the predicted standard deviations of payoffs.
PSD &lt;- matrix(runif(n * m, min = 0.01, max = 0.2), n, m)
PSD[n, ] &lt;- 0

# Suppose the predicted payoff correlation matrices of agents are the same.
Cor &lt;- cor(matrix(runif(2 * n^2), 2 * n, n))
Cor[, n] &lt;- Cor[n, ] &lt;- 0
Cor[n, n] &lt;- 1

# the list of utility functions.
lst.uf &lt;- list()

make.uf &lt;- function(mp, Cov, gamma) {
  force(mp)
  force(Cov)
  force(gamma)
  function(x) {
    AMSDP(x, mp = mp, Cov = Cov, gamma = gamma, theta = 1)
  }
}

for (k in 1:m) {
  sigma &lt;- PSD[, k]
  if (is.matrix(Cor)) {
    Cov &lt;- dg(sigma) %*% Cor %*% dg(sigma)
  } else {
    Cov &lt;- dg(sigma) %*% Cor[[k]] %*% dg(sigma)
  }

  lst.uf[[k]] &lt;- make.uf(mp = PMP[, k], Cov = Cov, gamma = gamma[k])
}

ge &lt;- gemAssetPricing_PUF(
  S = Supply, uf = lst.uf,
  priceAdjustmentVelocity = 0.05,
  policy = makePolicyMeanValue(100),
  ts = TRUE,
  tolCond = 1e-04
)

ge$p
round(addmargins(ge$D, 2), 3)
round(addmargins(ge$S, 2), 3)
ge$VMU

#### a 3-by-2 example.
asset1 &lt;- c(1, 0, 0)
asset2 &lt;- c(0, 0, 2)
asset3 &lt;- c(0, 1, 1)

# the unit asset payoff matrix.
UAP &lt;- cbind(asset1, asset2, asset3)
wt &lt;- c(0.5, 0.25, 0.25) # weights

uf &lt;- function(portfolio) {
  payoff &lt;- UAP %*% portfolio
  prod(payoff^wt)
}

ge &lt;- gemAssetPricing_PUF(
  matrix(c(
    1, 1,
    1, 0,
    0, 2
  ), 3, 2, TRUE),
  uf = uf,
  numeraire = 1
)

ge$p
ge$z
ge$A
addmargins(ge$D, 2)
addmargins(UAP %*% ge$D, 2)
ge$VMU

## a price-control stationary state.
pcss &lt;- gemAssetPricing_PUF(
  matrix(c(
    1, 1,
    1, 0,
    0, 2
  ), 3, 2, TRUE),
  uf = uf,
  numeraire = 1,
  pExg = c(1, 2, 1),
  maxIteration = 1,
  numberOfPeriods = 300,
  ts = TRUE
)

matplot(pcss$ts.q, type = "l")
tail(pcss$ts.q, 3)
addmargins(round(pcss$D, 4), 2)
pcss$VMU

#### a 2-by-2 example with outside position.
asset1 &lt;- c(1, 0, 0)
asset2 &lt;- c(0, 1, 1)

# the unit asset payoff matrix
UAP &lt;- cbind(asset1, asset2)
wt &lt;- c(0.5, 0.25, 0.25) # weights

uf1 &lt;- function(portfolio) prod((UAP %*% portfolio + c(0, 0, 2))^wt)
uf2 &lt;- function(portfolio) prod((UAP %*% portfolio)^wt)

ge &lt;- gemAssetPricing_PUF(
  S = matrix(c(
    1, 1,
    0, 2
  ), 2, 2, TRUE),
  uf = list(uf1, uf2),
  numeraire = 1
)

ge$p
ge$z
uf1(ge$D[,1])
uf2(ge$D[,2])

</code></pre>

<hr>
<h2 id='gemAssetPricingExample'>Some Examples of Asset Pricing</h2><span id='topic+gemAssetPricingExample'></span>

<h3>Description</h3>

<p>These examples illustrate how to find the equilibrium of an asset market by the function sdm2 and by computing marginal utility of assets (see Sharpe, 2008).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemAssetPricingExample(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemAssetPricingExample_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A general equilibrium.
</p>


<h3>References</h3>

<p>Danthine, J. P., Donaldson, J. (2005, ISBN: 9780123693808) Intermediate Financial Theory. Elsevier Academic Press.
</p>
<p>Sharpe, William F. (2008, ISBN: 9780691138503) Investors and Markets: Portfolio Choices, Asset Prices, and Investment Advice. Princeton University Press.
</p>
<p>Xu Gao (2018, ISBN: 9787300258232) Twenty-five Lectures on Financial Economics. Beijing: China Renmin University Press. (In Chinese)
</p>
<p>https://web.stanford.edu/~wfsharpe/apsim/index.html
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gemAssetPricing_CUF">gemAssetPricing_CUF</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an example of Danthine and Donaldson (2005, section 8.3).
uf &lt;- function(x) 0.5 * x[1] + 0.9 * (1 / 3 * log(x[2]) + 2 / 3 * log(x[3]))

ge &lt;- sdm2(
  A = function(state) {
    VMU &lt;- marginal_utility(state$last.A %*% dg(state$last.z), diag(3), uf, state$p)
    Ratio &lt;- sweep(VMU, 2, colMeans(VMU), "/")

    A &lt;- state$last.A * Ratio
    prop.table(A, 2)
  },
  B = matrix(0, 3, 2),
  S0Exg = matrix(c(
    10, 5,
    1, 4,
    2, 6
  ), 3, 2, TRUE),
  names.commodity = c("asset1", "asset2", "asset3"),
  names.agent = c("agt1", "agt2"),
  numeraire = "asset1",
  ts = TRUE
)

ge$p

#### an example of Sharpe (2008, chapter 2)
asset1 &lt;- c(1, 0, 0, 0, 0)
asset2 &lt;- c(0, 1, 1, 1, 1)
asset3 &lt;- c(0, 5, 3, 8, 4) - 3 * asset2
asset4 &lt;- c(0, 3, 5, 4, 8) - 3 * asset2
# unit asset payoff matrix
UAP &lt;- cbind(asset1, asset2, asset3, asset4)

prob &lt;- c(0.15, 0.25, 0.25, 0.35)
wt &lt;- prop.table(c(1, 0.96 * prob)) # weights

gamma.agt1 &lt;- 1.5
gamma.agt2 &lt;- 2.5

ge &lt;- sdm2(
  A = function(state) {
    Payoff &lt;- UAP %*% (state$last.A %*% dg(state$last.z))

    VMU &lt;- marginal_utility(Payoff, UAP, list(
      function(x) CES(alpha = 1, beta = wt, x = x, es = 1 / gamma.agt1),
      function(x) CES(alpha = 1, beta = wt, x = x, es = 1 / gamma.agt2)
    ), price = state$p)
    Ratio &lt;- sweep(VMU, 2, colMeans(VMU), "/")

    A &lt;- state$last.A * ratio_adjust(Ratio, coef = 0.05, method = "linear")

    A &lt;- prop.table(A, 2)
  },
  B = matrix(0, 4, 2),
  S0Exg = matrix(c(
    49, 49,
    30, 30,
    10, 0,
    0, 10
  ), 4, 2, TRUE),
  names.commodity = c("asset1", "asset2", "asset3", "asset4"),
  names.agent = c("agt1", "agt2"),
  numeraire = "asset1"
)

ge$p
ge$p[3:4] + 3 * ge$p[2]

#### an example of Xu (2018, section 10.4, P151)
asset1 &lt;- c(1, 0, 0)
asset2 &lt;- c(0, 1, 0)
asset3 &lt;- c(0, 0, 1)
prob &lt;- c(0.5, 0.5)
wt &lt;- c(1, prob)
UAP &lt;- cbind(asset1, asset2, asset3)

gamma.agt1 &lt;- 1
gamma.agt2 &lt;- 0.5

ge &lt;- sdm2(
  A = function(state) {
    Payoff &lt;- UAP %*% (state$last.A %*% dg(state$last.z))

    VMU &lt;- marginal_utility(Payoff, UAP, list(
      # Here CRRA(...)$u, CRRA(...)$CE and CES functions are interexchangeable.
      function(x) CRRA(x, gamma = gamma.agt1, p = wt)$u,
      function(x) CES(alpha = 1, beta = wt, x = x, es = 1 / gamma.agt2)
    ), state$p)
    Ratio &lt;- sweep(VMU, 2, colMeans(VMU), "/")

    A &lt;- state$last.A * Ratio
    prop.table(A, 2)
  },
  B = matrix(0, 3, 2),
  S0Exg = matrix(c(
    1, 0,
    0, 0.5,
    0, 2
  ), 3, 2, TRUE),
  names.commodity = c("asset1", "asset2", "asset3"),
  names.agent = c("agt1", "agt2"),
  numeraire = "asset1",
  maxIteration = 1,
  ts = TRUE
)

ge$p #c(1, (1 + sqrt(5)) / 4, (1 + sqrt(17)) / 16)

## the same as above.
dst.agt1 &lt;- node_new("util",
  type = "CD", alpha = 1, beta = c(0.5, 0.25, 0.25),
  "asset1", "asset2", "asset3"
)

dst.agt2 &lt;- node_new("util",
  type = "CES", alpha = 1, beta = c(2, 1, 1), sigma = 0.5,
  "asset1", "asset2", "asset3"
)

ge &lt;- sdm2(
  A = list(dst.agt1, dst.agt2),
  B = matrix(0, 3, 2),
  S0Exg = matrix(c(
    1, 0,
    0, 0.5,
    0, 2
  ), 3, 2, TRUE),
  names.commodity = c("asset1", "asset2", "asset3"),
  names.agent = c("agt1", "agt2"),
  numeraire = "asset1",
  maxIteration = 1,
  ts = TRUE
)

ge$p

#### an example with production.
asset1 &lt;- c(1, 0, 0, 0, 0, 0)
asset2 &lt;- c(0, 1, 0, 0, 0, 0)
asset3 &lt;- c(0, 0, 1, 3, 1, 2)
asset4 &lt;- c(0, 0, 4, 2, 6, 2)
asset5 &lt;- c(0, 0, 1, 0, 2, 0)

# unit asset payoff matrix
UAP &lt;- cbind(asset1, asset2, asset3, asset4, asset5)

muf1 &lt;- function(x) 1 / x
muf2 &lt;- function(x) 1 / x * c(0.4, 0.1, 0.2, 0.05, 0.2, 0.05)

ge &lt;- sdm2(
  A = function(state) {
    Payoff &lt;- UAP %*% (state$last.A[, 1:2] %*% dg(state$last.z[1:2]))

    VMU &lt;- marginal_utility(Payoff, UAP, muf = list(muf1, muf2), price = state$p)
    Ratio &lt;- sweep(VMU, 2, colMeans(VMU), "/")

    A &lt;- state$last.A[, 1:2] * ratio_adjust(Ratio, coef = 0.15, method = "linear")
    A &lt;- prop.table(A, 2)

    a.firm &lt;- CD_A(alpha = 4, Beta = c(0.5, 0.5, 0, 0, 0), state$p)
    A &lt;- cbind(A, a.firm)
  },
  B = matrix(c(
    0, 0, 0,
    0, 0, 0,
    0, 0, 0,
    0, 0, 0,
    0, 0, 1
  ), 5, 3, TRUE),
  S0Exg = matrix(c(
    1, 1, NA,
    1, 2, NA,
    1, NA, NA,
    NA, 1, NA,
    NA, NA, NA
  ), 5, 3, TRUE),
  names.commodity = c("asset1", "asset2", "asset3", "asset4", "asset5"),
  names.agent = c("consumer1", "consumer2", "firm"),
  numeraire = "asset1"
)

ge$p
ge$z

#### an example with demand structure trees.
asset1 &lt;- c(1, 0, 0, 0, 0)
asset2 &lt;- c(0, 1, 3, 1, 2)
asset3 &lt;- c(0, 2, 1, 3, 1)

# the asset unit payoff matrix.
UAP &lt;- cbind(asset1, asset2, asset3)

dst.consumer1 &lt;- node_new("util",
                          type = "CES", es = 0.5, alpha = 1, beta = c(0.5, 0.5),
                          "x1", "u2"
)
node_set(dst.consumer1, "u2",
         type = "CES", es = 0.8, alpha = 1, beta = c(0.6, 0.4),
         "u2.1", "u2.2"
)
node_set(dst.consumer1, "u2.1",
         type = "CES", es = 1, alpha = 1, beta = c(0.8, 0.2),
         "x2", "x3"
)
node_set(dst.consumer1, "u2.2",
         type = "CES", es = 1, alpha = 1, beta = c(0.8, 0.2),
         "x4", "x5"
)

dst.consumer2 &lt;- node_new("util",
                          type = "CES", es = 0.5, alpha = 1, beta = c(0.5, 0.5),
                          "x1", "u2"
)
node_set(dst.consumer2, "u2",
         type = "CES", es = 0.8, alpha = 1, beta = c(0.6, 0.4),
         "u2.1", "u2.2"
)
node_set(dst.consumer2, "u2.1",
         type = "CES", es = 1, alpha = 1, beta = c(0.2, 0.8),
         "x2", "x3"
)
node_set(dst.consumer2, "u2.2",
         type = "CES", es = 1, alpha = 1, beta = c(0.2, 0.8),
         "x4", "x5"
)

uf1 &lt;- function(x) {
  names(x) &lt;- paste0("x", seq_along(x))
  output(dst.consumer1, x)
}

uf2 &lt;- function(x) {
  names(x) &lt;- paste0("x", seq_along(x))
  output(dst.consumer2, x)
}

ge &lt;- gemAssetPricing_CUF(
  S = matrix(c(
    3, 3,
    1, 0,
    0, 2
  ), 3, 2, TRUE),
  UAP = UAP,
  uf = list(uf1, uf2)
)

ge$p
ge$z

</code></pre>

<hr>
<h2 id='gemBalancedGrowthPath'>Some Examples of Balanced Growth Paths</h2><span id='topic+gemBalancedGrowthPath'></span>

<h3>Description</h3>

<p>Some examples of spot market clearing paths (alias instantaneous equilibrium paths) which converge to balanced growth paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemBalancedGrowthPath(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemBalancedGrowthPath_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an example with a firm and a laborer
dst.firm &lt;- node_new(
  "prod",
  type = "CD", alpha = 5, beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.consumer &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "prod"
)

dstl &lt;- list(dst.firm, dst.consumer)

ge &lt;- sdm2(
  A = dstl,
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 1
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "lab",
  z0 = c(1, 1),
  ts = TRUE,
  policy = policyMarketClearingPrice,
  numberOfPeriods = 40,
  maxIteration = 1,
  GRExg = 0.03
)

matplot(ge$ts.z, type = "o", pch = 20)
matplot(growth_rate(ge$ts.z), type = "o", pch = 20)

#### an example with two firms and a laborer
dst.firm.corn &lt;- node_new(
  "corn",
  type = "CD", alpha = 1, beta = c(0.5, 0.5),
  "iron", "lab"
)

dst.firm.iron &lt;- node_new(
  "iron",
  type = "CD", alpha = 5, beta = c(0.5, 0.5),
  "iron", "lab"
)

dst.consumer &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "corn"
)

ge &lt;- sdm2(
  A = list(dst.firm.corn, dst.firm.iron, dst.consumer),
  B = matrix(c(
    1, 0, 0,
    0, 1, 0,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, NA, NA,
    NA, NA, 100
  ), 3, 3, TRUE),
  names.commodity = c("corn", "iron", "lab"),
  names.agent = c("firm.corn", "firm.iron", "consumer"),
  numeraire = "lab",
  ts = TRUE,
  policy = policyMarketClearingPrice,
  numberOfPeriods = 30,
  maxIteration = 1,
  GRExg = 0.03
)

matplot(ge$ts.z, type = "o", pch = 20)
matplot(growth_rate(ge$ts.z), type = "o", pch = 20)

#### another example with two firms and a laborer
dst.manu &lt;- node_new("manu",
                     type = "SCES", es = 1, alpha = 1,
                     beta = c(0.6, 0.4),
                     "manu", "lab"
)

dst.serv &lt;- node_new("serv",
                     type = "SCES", es = 1, alpha = 1,
                     beta = c(0.4, 0.6),
                     "manu", "lab"
)

dst.consumer &lt;- node_new("util",
                         type = "SCES", es = 1, alpha = 1,
                         beta = c(0.4, 0.6),
                         "manu", "serv"
)

dstl &lt;- list(dst.manu, dst.serv, dst.consumer)

S0Exg &lt;- matrix(NA, 3, 3)
S0Exg[3, 3] &lt;- 100

ge &lt;- sdm2(
  A = dstl,
  B = matrix(c(
    1, 0, 0,
    0, 1, 0,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = S0Exg,
  names.commodity = c("manu", "serv", "lab"),
  names.agent = c("manu", "serv", "consumer"),
  numeraire = c("manu"),
  ts = TRUE,
  policy = list(
    function(time, state) {
      if (time &gt;= 5) {
        state$S[3, 3] &lt;- 100 * 1.03^(time - 4)
      }
      state
    },
    policyMarketClearingPrice
  ),
  numberOfPeriods = 20,
  maxIteration = 1,
  z0 = c(160, 60, 100),
  p0 = c(1, 1, 1)
)

ge$p
ge$D
ge$S

matplot(ge$ts.z, type = "o", pch = 20)
matplot(growth_rate(ge$ts.z), type = "o", pch = 20)

</code></pre>

<hr>
<h2 id='gemCanonicalDynamicMacroeconomic_3_2'>A Canonical Dynamic Macroeconomic General Equilibrium Model (see Torres, 2016)</h2><span id='topic+gemCanonicalDynamicMacroeconomic_3_2'></span>

<h3>Description</h3>

<p>A canonical dynamic macroeconomic general equilibrium model (see Torres, 2016, Table 2.1 and 2.2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemCanonicalDynamicMacroeconomic_3_2(
  discount.factor = 0.97,
  depreciation.rate = 0.06,
  beta.prod.firm = 0.35,
  beta.prod.consumer = 0.4,
  policy.supply = NULL,
  policy.technology = NULL,
  policy.price = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_3_2_+3A_discount.factor">discount.factor</code></td>
<td>
<p>the intertemporal discount factor.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_3_2_+3A_depreciation.rate">depreciation.rate</code></td>
<td>
<p>the physical depreciation rate of capital stock.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_3_2_+3A_beta.prod.firm">beta.prod.firm</code></td>
<td>
<p>the share parameter of the product in the Cobb-Douglas production function.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_3_2_+3A_beta.prod.consumer">beta.prod.consumer</code></td>
<td>
<p>the share parameter of the product in the Cobb-Douglas period utility function.
This parameter represents the individual's preferences regarding consumption-leisure decisions.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_3_2_+3A_policy.supply">policy.supply</code></td>
<td>
<p>a policy function or a policy function list which adjusts the supplies.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_3_2_+3A_policy.technology">policy.technology</code></td>
<td>
<p>a policy function or a policy function list which adjusts the technology.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_3_2_+3A_policy.price">policy.price</code></td>
<td>
<p>a policy function or a policy function list which adjusts the prices.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_3_2_+3A_...">...</code></td>
<td>
<p>arguments to be to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A general equilibrium model with 3 commodities (i.e. product, labor and equity shares)
and 2 agents (i.e. a firm and a consumer). Labor is the numeraire.
</p>


<h3>Value</h3>

<p>A general equilibrium (see <code><a href="#topic+sdm2">sdm2</a></code>).
</p>


<h3>References</h3>

<p>Torres, Jose L. (2016, ISBN: 9781622730452) Introduction to Dynamic Macroeconomic General Equilibrium Models (Second Edition). Vernon Press.
</p>
<p>Li Xiangyang (2018, ISBN: 9787302497745) Dynamic Stochastic General Equilibrium (DSGE) Model: Theory, Methodology, and Dynare Practice. Tsinghua University Press. (In Chinese)
</p>


<h3>See Also</h3>

<p>The spot market clearing path (alias instantaneous equilibrium path) can be computed with the function <code><a href="#topic+policyMarketClearingPrice">policyMarketClearingPrice</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gemCanonicalDynamicMacroeconomic_3_2()

#### a spot market clearing path (alias instantaneous equilibrium path)
ge &lt;- gemCanonicalDynamicMacroeconomic_3_2(
  policy.price = policyMarketClearingPrice,
  ts = TRUE,
  maxIteration = 1,
  numberOfPeriods = 100,
  z0 = c(50, 100)
)

par(mfrow = c(1, 2))
matplot(ge$ts.z, type = "o", pch = 20)
matplot(ge$ts.p, type = "o", pch = 20)

#### technology change in a market-clearing path
policyTechnologyChange &lt;- function(time, A) {
  alpha &lt;- 1.2 # The original value is 1.
  time.win &lt;- c(50, 50)
  discount.factor &lt;- 0.97
  depreciation.rate &lt;- 0.06
  beta.prod.firm  &lt;- 0.35
  return.rate &lt;- 1 / discount.factor - 1

  if (time &gt;= time.win[1] &amp;&amp; time &lt;= time.win[2]) {
    A[[1]]$func &lt;- function(p) {
      result &lt;- CD_A(
        alpha, rbind(beta.prod.firm , 1 - beta.prod.firm , 0),
        c(p[1] * (return.rate + depreciation.rate), p[2:3])
      )
      result[3] &lt;- p[1] * result[1] * return.rate / p[3]
      result
    }
  }
}

ge &lt;- gemCanonicalDynamicMacroeconomic_3_2(
  policy.technology = policyTechnologyChange,
  policy.price = policyMarketClearingPrice,
  ts = TRUE,
  maxIteration = 1,
  numberOfPeriods = 100,
  z0 = c(50, 100)
)

par(mfrow = c(1, 2))
matplot(ge$ts.z, type = "o", pch = 20)
matplot(ge$ts.p, type = "o", pch = 20)

#### an example on page 46 of Li Xiangyang (2018)
ge &lt;- gemCanonicalDynamicMacroeconomic_3_2(
  discount.factor = 0.99,
  depreciation.rate = 0.025,
  beta.prod.firm  = 0.36,
  beta.prod.consumer = 1
)

</code></pre>

<hr>
<h2 id='gemCanonicalDynamicMacroeconomic_4_3'>A Canonical Dynamic Macroeconomic General Equilibrium Model (see Torres, 2016)</h2><span id='topic+gemCanonicalDynamicMacroeconomic_4_3'></span>

<h3>Description</h3>

<p>A canonical dynamic macroeconomic general equilibrium model (see Torres, 2016, Table 2.1 and 2.2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemCanonicalDynamicMacroeconomic_4_3(
  discount.factor = 0.97,
  depreciation.rate = 0.06,
  beta.prod.firm = 0.35,
  beta.prod.consumer = 0.4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_4_3_+3A_discount.factor">discount.factor</code></td>
<td>
<p>the intertemporal discount factor.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_4_3_+3A_depreciation.rate">depreciation.rate</code></td>
<td>
<p>the physical depreciation rate of capital stock.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_4_3_+3A_beta.prod.firm">beta.prod.firm</code></td>
<td>
<p>the share parameter of the product in the Cobb-Douglas production function of the production firm.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_4_3_+3A_beta.prod.consumer">beta.prod.consumer</code></td>
<td>
<p>the share parameter of the product in the Cobb-Douglas period utility function of the consumer.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_4_3_+3A_...">...</code></td>
<td>
<p>arguments to be to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A general equilibrium model with 4 commodities (i.e. product, labor, capital and equity shares)
and 3 agents (i.e. a production firm, a consumer and a capital-leasing firm).
</p>


<h3>Value</h3>

<p>A general equilibrium (see <code><a href="#topic+sdm2">sdm2</a></code>)
</p>


<h3>References</h3>

<p>Torres, Jose L. (2016, ISBN: 9781622730452) Introduction to Dynamic Macroeconomic General Equilibrium Models (Second Edition). Vernon Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### a spot market clearing path that converges to the steady-state equilibrium
ge &lt;- gemCanonicalDynamicMacroeconomic_4_3(
  numberOfPeriods = 100,
  policy = policyMarketClearingPrice
)

matplot(ge$ts.z, type = "o", pch = 20)
matplot(ge$ts.p, type = "o", pch = 20)

## population growth: a spot market clearing path
## that converges to a balanced growth path
ge &lt;- gemCanonicalDynamicMacroeconomic_4_3(
  numberOfPeriods = 100,
  GRExg = 0.01,
  policy = policyMarketClearingPrice
)

matplot((ge$ts.p), type = "l")
matplot((ge$ts.z), type = "l")
matplot(growth_rate(ge$ts.z), type = "l")

#### a disequilibrium path and the steady-state equilibrium
ge &lt;- gemCanonicalDynamicMacroeconomic_4_3(
  numberOfPeriods = 5000,
  priceAdjustmentVelocity = 0.03,
)

ge$p
ge$z
matplot(ge$ts.z, type = "l")
node_plot(ge$dstl[[3]], param = TRUE)

## a small disturbance to the product supply
ge &lt;- gemCanonicalDynamicMacroeconomic_4_3(
  numberOfPeriods = 4000,
  priceAdjustmentVelocity = 0.03,
  policy = function(time, state) {
    if (time == 1500) {
      state$S[1, 1] &lt;- state$S[1, 1] * 0.999
    }
    state
  }
)

#### business cycles
de &lt;- gemCanonicalDynamicMacroeconomic_4_3(
  numberOfPeriods = 1000,
  priceAdjustmentVelocity = 0.15
)

## A tax rate policy is implemented from the 600th period to stabilize the economy.
ge &lt;- gemCanonicalDynamicMacroeconomic_4_3(
  numberOfPeriods = 1500,
  priceAdjustmentVelocity = 0.15,
  policy = Example9.10.policy.tax
)

matplot(ge$ts.z, type = "l")
plot(ge$policy.data, type = "l") # tax rates

#### a spot market-clearing path with a productivity shock
nPeriod &lt;- 100 # the number of periods of the spot market clearing path
set.seed(1)
alpha.shock &lt;- rep(1, nPeriod)
alpha.shock[11] &lt;- exp(0.01)
for (t in 12:nPeriod) {
  alpha.shock[t] &lt;- exp(0.95 * log(alpha.shock[t - 1]))
}
plot(alpha.shock)

ge &lt;- gemCanonicalDynamicMacroeconomic_4_3(
  numberOfPeriods = nPeriod,
  p0 = c(1, 1.34312, 0.09093, 0.08865),
  z0 = c(74.47, 61.20, 286.65),
  policy = list(
    function(time, A) {
      A[[1]]$alpha &lt;- alpha.shock[time]
    },
    policyMarketClearingPrice
  )
)

matplot(ge$ts.z[, 1], type = "o", pch = 20)


</code></pre>

<hr>
<h2 id='gemCanonicalDynamicMacroeconomic_Sequential_3_2'>A Canonical Dynamic Macroeconomic General Equilibrium Model in Sequential Form (see Torres, 2016)</h2><span id='topic+gemCanonicalDynamicMacroeconomic_Sequential_3_2'></span>

<h3>Description</h3>

<p>A canonical dynamic macroeconomic general equilibrium model in sequential form (see Torres, 2016, Table 2.1 and 2.2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemCanonicalDynamicMacroeconomic_Sequential_3_2(
  alpha.firm = 1,
  es.prod.lab.firm = 1,
  beta.prod.firm = 0.35,
  depreciation.rate = 0.06,
  eis = 1,
  Gamma.beta = 0.97,
  es.prod.lab.consumer = 1,
  beta.prod.consumer = 0.4,
  gr = 0,
  wage.payment = "post",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_3_2_+3A_alpha.firm">alpha.firm</code></td>
<td>
<p>a positive scalar, indicating the efficiency parameter of the firm.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_3_2_+3A_es.prod.lab.firm">es.prod.lab.firm</code></td>
<td>
<p>the elasticity of substitution between product and labor in the production function of firm 1.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_3_2_+3A_beta.prod.firm">beta.prod.firm</code></td>
<td>
<p>the share parameter of the product in the production function.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_3_2_+3A_depreciation.rate">depreciation.rate</code></td>
<td>
<p>the physical depreciation rate of capital stock.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_3_2_+3A_eis">eis</code></td>
<td>
<p>the elasticity of intertemporal substitution of the consumer.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_3_2_+3A_gamma.beta">Gamma.beta</code></td>
<td>
<p>the subjective discount factor of the consumer.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_3_2_+3A_es.prod.lab.consumer">es.prod.lab.consumer</code></td>
<td>
<p>the elasticity of substitution between product and labor in the CES-type period utility function of the consumer.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_3_2_+3A_beta.prod.consumer">beta.prod.consumer</code></td>
<td>
<p>the share parameter of the product in the period utility function.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_3_2_+3A_gr">gr</code></td>
<td>
<p>the growth rate of the labor supply.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_3_2_+3A_wage.payment">wage.payment</code></td>
<td>
<p>a character string specifying the wage payment method, must be one of &quot;pre&quot; or &quot;post&quot;.
See the note below.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_3_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A general equilibrium (see <code><a href="#topic+sdm2">sdm2</a></code>).
</p>


<h3>Note</h3>

<p>In the timeline model and the time-circle model, we refer to the labor provided in period t as labor t,
and the product produced by using labor t as product t+1.
When the consumer's period utility function simultaneously includes labor (or leisure) and product,
we can choose from one of two assumptions: it can be assumed that the period utility function of the consumer in period $t$
includes labor $t$ and product $t$, or it can be assumed that it includes labor $t$ and product $t+1$.
These two assumptions are respectively referred to as the wage prepayment assumption and the wage postpayment assumption.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gemCanonicalDynamicMacroeconomic_Timeline_2_2">gemCanonicalDynamicMacroeconomic_Timeline_2_2</a></code>,<br />
<code><a href="#topic+gemCanonicalDynamicMacroeconomic_TimeCircle_2_2">gemCanonicalDynamicMacroeconomic_TimeCircle_2_2</a></code>,<br />
<code><a href="#topic+gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3">gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### Take the wage postpayment assumption.
ge &lt;- gemCanonicalDynamicMacroeconomic_Sequential_3_2()
ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)

#### Take the wage prepayment assumption.
ge &lt;- gemCanonicalDynamicMacroeconomic_Sequential_3_2(wage.payment  = "pre")
ge$p
ge$z
ge$D
ge$S

#### Take the wage prepayment assumption.
ge &lt;- gemCanonicalDynamicMacroeconomic_Sequential_3_2(
  es.prod.lab.firm = 0.8,
  eis = 0.8, es.prod.lab.consumer = 0.8, gr = 0.03,
  wage.payment  = "pre"
)
ge$p
ge$z
ge$D
ge$S

#### an example of steady-state equilibrium at
# http://gecon.r-forge.r-project.org/models/rbc.pdf
ge &lt;- gemCanonicalDynamicMacroeconomic_Sequential_3_2(
  beta.prod.firm = 0.36,
  depreciation.rate = 0.025,
  Gamma.beta = 0.99,
  eis = 0.5,
  beta.prod.consumer = 0.3,
)

ge$p / ge$p[1]
addmargins(ge$D, 2)
addmargins(ge$S, 2)

</code></pre>

<hr>
<h2 id='gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3'>A Canonical Dynamic Macroeconomic General Equilibrium Model in Sequential Form under the Wage Postpayment Assumption (see Torres, 2016)</h2><span id='topic+gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3'></span>

<h3>Description</h3>

<p>A canonical dynamic macroeconomic general equilibrium model in sequential form
under the wage postpayment assumption (see Torres, 2016, Table 2.1 and 2.2).
In this model, there are two firms and one consumer.
Under the wage postpayment assumption, the consumer actually consumes a kind of labor (that is, leisure)
and the products produced by this labor at the same time.
Firm 1 is a regular production firm.
Firm 2 can store labor from one period to the next period for consumption by the consumer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3(
  alpha.firm = 1,
  es.prod.lab.firm = 1,
  beta.prod.firm = 0.35,
  depreciation.rate = 0.06,
  eis = 1,
  Gamma.beta = 0.97,
  es.prod.lab.consumer = 1,
  beta.prod.consumer = 0.4,
  gr = 0,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3_+3A_alpha.firm">alpha.firm</code></td>
<td>
<p>a positive scalar, indicating the efficiency parameter of firm 1.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3_+3A_es.prod.lab.firm">es.prod.lab.firm</code></td>
<td>
<p>the elasticity of substitution between product and labor in the production function of firm 1.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3_+3A_beta.prod.firm">beta.prod.firm</code></td>
<td>
<p>the share parameter of the product in the production function of firm 1.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3_+3A_depreciation.rate">depreciation.rate</code></td>
<td>
<p>the physical depreciation rate of capital stock of firm 1.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3_+3A_eis">eis</code></td>
<td>
<p>the elasticity of intertemporal substitution of the consumer.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3_+3A_gamma.beta">Gamma.beta</code></td>
<td>
<p>the subjective discount factor of the consumer.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3_+3A_es.prod.lab.consumer">es.prod.lab.consumer</code></td>
<td>
<p>the elasticity of substitution between product and labor in the CES-type period utility function of the consumer.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3_+3A_beta.prod.consumer">beta.prod.consumer</code></td>
<td>
<p>the share parameter of the product in the period utility function.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3_+3A_gr">gr</code></td>
<td>
<p>the growth rate of the labor supply.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A general equilibrium (see <code><a href="#topic+sdm2">sdm2</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gemCanonicalDynamicMacroeconomic_Timeline_2_2">gemCanonicalDynamicMacroeconomic_Timeline_2_2</a></code>,<br />
<code><a href="#topic+gemCanonicalDynamicMacroeconomic_TimeCircle_2_2">gemCanonicalDynamicMacroeconomic_TimeCircle_2_2</a></code>,<br />
<code><a href="#topic+gemCanonicalDynamicMacroeconomic_Sequential_3_2">gemCanonicalDynamicMacroeconomic_Sequential_3_2</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3()

####
eis &lt;- 0.8
Gamma.beta &lt;- 0.97
gr &lt;- 0.03
ge &lt;- gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3(
  es.prod.lab.firm = 0.8,
  eis = eis, Gamma.beta = Gamma.beta, es.prod.lab.consumer = 0.8,
  gr = gr
)

ge$p
ge$p[1] * (sserr(eis = eis, Gamma.beta = Gamma.beta, gr = gr, prepaid = TRUE) + 1)
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)
ge$S[1, 1] * (1 + gr)


</code></pre>

<hr>
<h2 id='gemCanonicalDynamicMacroeconomic_TimeCircle_2_2'>A Canonical Dynamic Macroeconomic General Equilibrium Model in Time-circle Form (see Torres, 2016)</h2><span id='topic+gemCanonicalDynamicMacroeconomic_TimeCircle_2_2'></span>

<h3>Description</h3>

<p>A canonical dynamic macroeconomic general equilibrium model in time-circle form (see Torres, 2016, Table 2.1 and 2.2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemCanonicalDynamicMacroeconomic_TimeCircle_2_2(
  alpha.firm = rep(1, 3),
  es.prod.lab.firm = 1,
  beta.prod.firm = 0.35,
  depreciation.rate = 0.06,
  eis = 1,
  Gamma.beta = 0.97,
  beta.prod.consumer = 0.4,
  es.prod.lab.consumer = 1,
  gr = 0,
  wage.payment = "post",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_TimeCircle_2_2_+3A_alpha.firm">alpha.firm</code></td>
<td>
<p>a positive vector, indicating the efficiency parameters of the firm for each economic period.
The number of economic periods will be set to length(alpha.firm) .</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_TimeCircle_2_2_+3A_es.prod.lab.firm">es.prod.lab.firm</code></td>
<td>
<p>the elasticity of substitution between product and labor in the production function of the firm.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_TimeCircle_2_2_+3A_beta.prod.firm">beta.prod.firm</code></td>
<td>
<p>the share parameter of the product in the production function.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_TimeCircle_2_2_+3A_depreciation.rate">depreciation.rate</code></td>
<td>
<p>the physical depreciation rate of capital stock.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_TimeCircle_2_2_+3A_eis">eis</code></td>
<td>
<p>the elasticity of intertemporal substitution of the consumer.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_TimeCircle_2_2_+3A_gamma.beta">Gamma.beta</code></td>
<td>
<p>the subjective discount factor of the consumer.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_TimeCircle_2_2_+3A_beta.prod.consumer">beta.prod.consumer</code></td>
<td>
<p>the share parameter of the product in the period utility function.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_TimeCircle_2_2_+3A_es.prod.lab.consumer">es.prod.lab.consumer</code></td>
<td>
<p>the elasticity of substitution between product and labor in the CES-type period utility function of the consumer.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_TimeCircle_2_2_+3A_gr">gr</code></td>
<td>
<p>the growth rate of the labor supply.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_TimeCircle_2_2_+3A_wage.payment">wage.payment</code></td>
<td>
<p>a character string specifying the wage payment method, must be one of &quot;pre&quot; or &quot;post&quot;.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_TimeCircle_2_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A general equilibrium (see <code><a href="#topic+sdm2">sdm2</a></code>).
</p>


<h3>References</h3>

<p>Torres, Jose L. (2016, ISBN: 9781622730452) Introduction to Dynamic Macroeconomic General Equilibrium Models (Second Edition). Vernon Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gemCanonicalDynamicMacroeconomic_Timeline_2_2">gemCanonicalDynamicMacroeconomic_Timeline_2_2</a></code>,<br />
<code><a href="#topic+gemCanonicalDynamicMacroeconomic_Sequential_3_2">gemCanonicalDynamicMacroeconomic_Sequential_3_2</a></code>,<br />
<code><a href="#topic+gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3">gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### Take the wage postpayment assumption.
ge &lt;- gemCanonicalDynamicMacroeconomic_TimeCircle_2_2()
np &lt;- 3
eis &lt;- 1
Gamma.beta &lt;- 0.97
gr &lt;- 0
ge$p
growth_rate(ge$p[1:np])
1 / (1 + sserr(eis = eis, Gamma.beta = Gamma.beta, gr = gr)) - 1
ge$z
growth_rate(ge$z[1:np])
ge$D
ge$S

##  Take the wage postpayment assumption.
eis &lt;- 0.8
Gamma.beta &lt;- 0.97
gr &lt;- 0.03
ge &lt;- gemCanonicalDynamicMacroeconomic_TimeCircle_2_2(
  es.prod.lab.firm = 0.8,
  eis = eis, Gamma.beta = Gamma.beta, es.prod.lab.consumer = 0.8,
  gr = gr
)

ge$p
growth_rate(ge$p[1:np])
1 / (1 + sserr(eis = eis, Gamma.beta = Gamma.beta, gr = gr)) - 1
ge$z
growth_rate(ge$z[1:np])
ge$D
ge$S

#### an anticipated technology shock.
## Warning: Running the program below takes about 4 minutes.
# np &lt;- 120
# alpha.firm &lt;- rep(1, np)
# alpha.firm[40] &lt;- 1.05
# ge &lt;- gemCanonicalDynamicMacroeconomic_TimeCircle_2_2(alpha.firm = alpha.firm)

## The steady state product supply is 343.92.
## the (economic) time series of product supply
# plot(ge$z[1:np] / 343.92 - 1, type = "o", pch = 20)
## The steady state product consumption is 57.27.
## the (economic) time series of product consumption
# plot(ge$D[2:np, np + 1] / 57.27 - 1, type = "o", pch = 20)

#### Take the wage prepayment assumption.
ge &lt;- gemCanonicalDynamicMacroeconomic_TimeCircle_2_2(wage.payment = "pre")
np &lt;- 3
eis &lt;- 1
Gamma.beta &lt;- 0.97
gr &lt;- 0
ge$p
growth_rate(ge$p[1:np])
1 / (1 + sserr(eis = eis, Gamma.beta = Gamma.beta, gr = gr)) - 1
ge$z
growth_rate(ge$z[1:np])
ge$D
ge$S

##  Take the wage prepayment assumption.
eis &lt;- 0.8
Gamma.beta &lt;- 0.97
gr &lt;- 0.03

ge &lt;- gemCanonicalDynamicMacroeconomic_TimeCircle_2_2(
  es.prod.lab.firm = 0.8,
  eis = eis, es.prod.lab.consumer = 0.8,
  Gamma.beta = Gamma.beta, gr = gr,
  wage.payment = "pre"
)

ge$p
growth_rate(ge$p[1:np])
1 / (1 + sserr(eis = eis, Gamma.beta = Gamma.beta, gr = gr)) - 1
ge$z
growth_rate(ge$z[1:np])
ge$D
ge$S

</code></pre>

<hr>
<h2 id='gemCanonicalDynamicMacroeconomic_Timeline_2_2'>A Canonical Dynamic Macroeconomic General Equilibrium Model in Timeline Form (see Torres, 2016)</h2><span id='topic+gemCanonicalDynamicMacroeconomic_Timeline_2_2'></span>

<h3>Description</h3>

<p>A canonical dynamic macroeconomic general equilibrium model in timeline form (see Torres, 2016, Table 2.1 and 2.2).
The firm has a CESAK production function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemCanonicalDynamicMacroeconomic_Timeline_2_2(
  alpha.firm = rep(1, 4),
  es.prod.lab.firm = 1,
  beta.prod.firm = 0.35,
  depreciation.rate = 0.06,
  eis = 1,
  Gamma.beta = 0.97,
  beta.prod.consumer = 0.4,
  es.prod.lab.consumer = 1,
  gr = 0,
  initial.product.supply = 200,
  head.tail.adjustment = "both",
  wage.payment = "post",
  beta.consumer = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Timeline_2_2_+3A_alpha.firm">alpha.firm</code></td>
<td>
<p>a positive vector, indicating the efficiency parameters of the firm for each economic period.
The number of economic periods will be set to length(alpha.firm) + 1.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Timeline_2_2_+3A_es.prod.lab.firm">es.prod.lab.firm</code></td>
<td>
<p>the elasticity of substitution between product and labor in the production function of the firm.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Timeline_2_2_+3A_beta.prod.firm">beta.prod.firm</code></td>
<td>
<p>the share parameter of the product in the production function.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Timeline_2_2_+3A_depreciation.rate">depreciation.rate</code></td>
<td>
<p>the physical depreciation rate of capital stock.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Timeline_2_2_+3A_eis">eis</code></td>
<td>
<p>a positive scalar indicating the elasticity of intertemporal substitution of the consumer.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Timeline_2_2_+3A_gamma.beta">Gamma.beta</code></td>
<td>
<p>the subjective discount factor of the consumer.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Timeline_2_2_+3A_beta.prod.consumer">beta.prod.consumer</code></td>
<td>
<p>the share parameter of the product in the period utility function.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Timeline_2_2_+3A_es.prod.lab.consumer">es.prod.lab.consumer</code></td>
<td>
<p>the elasticity of substitution between product and labor in the CES-type period utility function of the consumer.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Timeline_2_2_+3A_gr">gr</code></td>
<td>
<p>the growth rate of the labor supply.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Timeline_2_2_+3A_initial.product.supply">initial.product.supply</code></td>
<td>
<p>the initial product supply.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Timeline_2_2_+3A_head.tail.adjustment">head.tail.adjustment</code></td>
<td>
<p>a character string specifying the type of the head-tail-adjustment policy, must be one of &quot;both&quot; (default), &quot;head&quot;, &quot;tail&quot; or &quot;none&quot;.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Timeline_2_2_+3A_wage.payment">wage.payment</code></td>
<td>
<p>a character string specifying the wage payment method, must be one of &quot;pre&quot; or &quot;post&quot;.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Timeline_2_2_+3A_beta.consumer">beta.consumer</code></td>
<td>
<p>NULL (the default) or a positive vector containing length(alpha.firm) + 1 elements specifying the consumer's intertemporal share parameter.
If beta.consumer is not NULL, Gamma.beta will be ignored.</p>
</td></tr>
<tr><td><code id="gemCanonicalDynamicMacroeconomic_Timeline_2_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Torres, Jose L. (2016, ISBN: 9781622730452) Introduction to Dynamic Macroeconomic General Equilibrium Models (Second Edition). Vernon Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gemCanonicalDynamicMacroeconomic_TimeCircle_2_2">gemCanonicalDynamicMacroeconomic_TimeCircle_2_2</a></code>,<br />
<code><a href="#topic+gemCanonicalDynamicMacroeconomic_Sequential_3_2">gemCanonicalDynamicMacroeconomic_Sequential_3_2</a></code>,<br />
<code><a href="#topic+gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3">gemCanonicalDynamicMacroeconomic_Sequential_WagePostpayment_4_3</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### Take the wage postpayment assumption.
ge &lt;- gemCanonicalDynamicMacroeconomic_Timeline_2_2()
np &lt;- 5
eis &lt;- 1
Gamma.beta &lt;- 0.97
gr &lt;- 0
ge$p
ge$p[1:(np - 1)] / ge$p[2:np] - 1
ge$p[(np + 1):(2 * np - 2)] / ge$p[(np + 2):(2 * np - 1)] - 1
sserr(eis = eis, Gamma.beta = Gamma.beta, gr = gr) # the steady-state equilibrium return rate
ge$z
ge$D
node_plot(ge$dst.consumer, TRUE)

#### Take the wage postpayment assumption.
eis &lt;- 0.8
Gamma.beta &lt;- 0.97
gr &lt;- 0.03
ge &lt;- gemCanonicalDynamicMacroeconomic_Timeline_2_2(
  es.prod.lab.firm = 0.8,
  eis = eis, Gamma.beta = Gamma.beta, es.prod.lab.consumer = 0.8,
  gr = gr
)

np &lt;- 5
ge$p
growth_rate(ge$p[1:np])
1 / (1 + sserr(eis = eis, Gamma.beta = Gamma.beta, gr = gr)) - 1
ge$z
growth_rate(ge$z[1:(np - 1)])
ge$D
ge$S

##### a fully anticipated technology shock.
## Warning: Running the program below takes several minutes.
# np &lt;- 120
# alpha.firm &lt;- rep(1, np - 1)
# alpha.firm[40] &lt;- 1.05
# ge &lt;- gemCanonicalDynamicMacroeconomic_Timeline_2_2(alpha.firm = alpha.firm)
#
## The steady state product supply is 343.92.
## the (economic) time series of product supply.
# plot(ge$z[1:(np - 1)] / 343.92 - 1, type = "o", pch = 20)
## The steady state product consumption is 57.27.
## the (economic) time series of product consumption.
# plot(ge$D[2:(np - 1), np] / 57.27 - 1, type = "o", pch = 20)
# plot(growth_rate(ge$p[1:(np)]), type = "o", pch = 20)
# plot(growth_rate(ge$p[(np + 1):(2 * np)]), type = "o", pch = 20)
#
##### an unanticipated technology shock.
# np &lt;- 50
# alpha.firm &lt;- rep(1, np - 1)
# alpha.firm[1] &lt;- 1.05
# ge &lt;- gemCanonicalDynamicMacroeconomic_Timeline_2_2(
#   alpha.firm = alpha.firm,
#   initial.product.supply = 286.6341, # the steady state value
#   head.tail.adjustment = "tail"
# )
#
## The steady state product supply is 343.92.
## the (economic) time series of product supply.
# plot(ge$z[1:(np - 1)] / 343.92 - 1, type = "o", pch = 20)
## The steady state product consumption is 57.27.
## the (economic) time series of product consumption.
# plot(ge$D[2:(np - 1), np] / 57.27 - 1, type = "o", pch = 20)
# plot(growth_rate(ge$p[1:(np)]), type = "o", pch = 20)
# plot(growth_rate(ge$p[(np + 1):(2 * np)]), type = "o", pch = 20)
#
### a technology shock anticipated several periods in advance.
# np &lt;- 50
# alpha.firm &lt;- rep(1, np - 1)
# alpha.firm[5] &lt;- 1.05
# ge5 &lt;- gemCanonicalDynamicMacroeconomic_Timeline_2_2(
#   alpha.firm = alpha.firm,
#   initial.product.supply = 286.6341, # the steady state value
#   head.tail.adjustment = "tail"
# )
#
## The steady state product supply is 343.92.
## the (economic) time series of product supply
# plot(ge5$z[1:(np - 1)] / 343.92 - 1, type = "o", pch = 20)
## The steady state product consumption is 57.27.
## the (economic) time series of product consumption
# plot(ge5$D[2:(np - 1), np] / 57.27 - 1, type = "o", pch = 20)
# plot(growth_rate(ge5$p[1:(np)]), type = "o", pch = 20)
# plot(growth_rate(ge5$p[(np + 1):(2 * np)]), type = "o", pch = 20)
#
# alpha.firm &lt;- rep(1, np - 1)
# alpha.firm[10] &lt;- 1.05
# ge10 &lt;- gemCanonicalDynamicMacroeconomic_Timeline_2_2(
#   alpha.firm = alpha.firm,
#   initial.product.supply = 286.6341, # the steady state value
#   head.tail.adjustment = "tail"
# )
# plot(ge$z[1:(np - 1)] / 343.92 - 1, type = "o", pch = 20, ylim = c(-0.005, 0.017))
# lines(ge5$z[1:(np - 1)] / 343.92 - 1, type = "o", pch = 21)
# lines(ge10$z[1:(np - 1)] / 343.92 - 1, type = "o", pch = 22)

##### an unanticipated technology shock.
## Warning: Running the program below takes several minutes.
# np &lt;- 100
# alpha.firm &lt;- exp(0.01)
# for (t in 2:(np - 1)) {
#   alpha.firm[t] &lt;- exp(0.9 * log(alpha.firm[t - 1]))
# }
# plot(alpha.firm)
#
# ge &lt;- gemCanonicalDynamicMacroeconomic_Timeline_2_2(
#   alpha.firm = alpha.firm,
#   initial.product.supply = 286.6341, # the steady state value
#   head.tail.adjustment = "tail"
# )
#
## The steady state product supply is 343.92.
## the (economic) time series of product supply
# plot(ge$z[1:(np - 1)] / 343.92 - 1, type = "o", pch = 20)
## The steady state product consumption is 57.27.
## the (economic) time series of product consumption
# plot(ge$D[2:(np - 1), np] / 57.27 - 1, type = "o", pch = 20)
# plot(growth_rate(ge$p[1:(np)]), type = "o", pch = 20)
# plot(growth_rate(ge$p[(np + 1):(2 * np)]), type = "o", pch = 20)

#### Take the wage prepayment assumption.
ge &lt;- gemCanonicalDynamicMacroeconomic_Timeline_2_2(wage.payment = "pre")
np &lt;- 5
eis &lt;- 1
Gamma.beta &lt;- 0.97
gr &lt;- 0
ge$p
ge$p[1:(np - 1)] / ge$p[2:np] - 1
ge$p[(np + 1):(2 * np - 2)] / ge$p[(np + 2):(2 * np - 1)] - 1
sserr(eis = eis, Gamma.beta = Gamma.beta, gr = gr) # the steady-state equilibrium return rate
ge$z
ge$D
node_plot(ge$dst.consumer, TRUE)

#### Take the wage prepayment assumption.
np &lt;- 5
eis &lt;- 0.8
Gamma.beta &lt;- 0.97
gr &lt;- 0.03
ge &lt;- gemCanonicalDynamicMacroeconomic_Timeline_2_2(
  es.prod.lab.firm = 0.8,
  eis = eis, Gamma.beta = Gamma.beta, es.prod.lab.consumer = 0.8,
  gr = gr,
  wage.payment = "pre"
)

ge$p
growth_rate(ge$p[1:np])
1 / (1 + sserr(eis = eis, Gamma.beta = Gamma.beta, gr = gr)) - 1
ge$z
growth_rate(ge$z[1:(np - 1)])
ge$D
ge$S


</code></pre>

<hr>
<h2 id='gemCapitalAccumulation'>Some Examples of Spot Market Clearing Paths with Capital Accumulation</h2><span id='topic+gemCapitalAccumulation'></span>

<h3>Description</h3>

<p>Some examples of spot market clearing paths (alias instantaneous equilibrium paths) with capital accumulation.
The economy contains a production firm, a capital-leasing firm and a consumer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemCapitalAccumulation(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemCapitalAccumulation_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>See Also</h3>


<p><code><a href="#topic+gemPersistentTechnologicalProgress">gemPersistentTechnologicalProgress</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### a 3-by-3 example
dst.firm1 &lt;- node_new(
  "prod",
  type = "CD", alpha = 2, beta = c(0.5, 0.5),
  "cap", "cc1"
)
node_set(dst.firm1, "cc1",
  type = "Leontief", a = 1,
  "lab"
)

dst.consumer &lt;- dst.firm2 &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "prod"
)

dstl &lt;- list(dst.firm1, dst.consumer, dst.firm2)

B &lt;- matrix(c(
  1, 0, 0.5,
  0, 0, 1,
  0, 0, 0
), 3, 3, TRUE)

S0Exg &lt;- matrix(c(
  NA, NA, NA,
  NA, NA, NA,
  NA, 100, NA
), 3, 3, TRUE)

ge &lt;- sdm2(
  A = dstl,
  B = B,
  S0Exg = S0Exg,
  names.commodity = c("prod", "cap", "lab"),
  names.agent = c("firm1", "laborer", "firm2"),
  numeraire = "prod",
  z0 = c(100, 0, 50),
  policy = policyMarketClearingPrice,
  maxIteration = 1,
  numberOfPeriods = 30,
  ts = TRUE
)

matplot((ge$ts.z), type = "o", pch = 20)
matplot((ge$ts.p), type = "o", pch = 20)

## a MCP with labor supply change
ge &lt;- sdm2(
  A = dstl,
  B = B,
  S0Exg = S0Exg,
  names.commodity = c("prod", "cap", "lab"),
  names.agent = c("firm1", "laborer", "firm2"),
  numeraire = "prod",
  z0 = c(400, 200, 400),
  policy = list(
    function(time, state) {
      if (time &gt;= 5) state$S[3, 2] &lt;- 150
      state
    },
    policyMarketClearingPrice
  ),
  maxIteration = 1,
  numberOfPeriods = 30,
  ts = TRUE
)

matplot((ge$ts.z), type = "o", pch = 20)
matplot((ge$ts.p), type = "o", pch = 20)

## a MCP with transitory technological progress
ge &lt;- sdm2(
  A = dstl,
  B = B,
  S0Exg = S0Exg,
  names.commodity = c("prod", "cap", "lab"),
  names.agent = c("firm1", "laborer", "firm2"),
  numeraire = "prod",
  z0 = c(400, 200, 400),
  policy = list(
    function(time, A) {
      if (time == 5) {
        A[[1]]$alpha &lt;- 3
      } else {
        A[[1]]$alpha &lt;- 2
      }
    },
    policyMarketClearingPrice
  ),
  maxIteration = 1,
  numberOfPeriods = 30,
  ts = TRUE
)

matplot((ge$ts.z), type = "o", pch = 20)
matplot((ge$ts.p), type = "o", pch = 20)

## a MCP with permanent technological progress
ge &lt;- sdm2(
  A = dstl,
  B = B,
  S0Exg = S0Exg,
  names.commodity = c("prod", "cap", "lab"),
  names.agent = c("firm1", "laborer", "firm2"),
  numeraire = "prod",
  z0 = c(400, 200, 400),
  policy = list(
    function(time, A) {
      if (time &gt;= 5) {
        A[[1]]$alpha &lt;- 3
      } else {
        A[[1]]$alpha &lt;- 2
      }
    },
    policyMarketClearingPrice
  ),
  maxIteration = 1,
  numberOfPeriods = 30,
  ts = TRUE
)

matplot((ge$ts.z), type = "o", pch = 20)
matplot((ge$ts.p), type = "o", pch = 20)

#### A 4-by-4 example wherein the capital goods
#### have a useful life of two periods.
ge &lt;- sdm2(
  A = function(state) {
    a.firm1 &lt;- CD_A(alpha = 2, Beta = c(0, 0.5, 0.5, 0), state$p)
    a.consumer &lt;- c(1, 0, 0, 0)
    a.firm2 &lt;- c(1, 0, 0, 0)
    a.firm3 &lt;- c(0, 0, 0, 1)
    cbind(a.firm1, a.consumer, a.firm2, a.firm3)
  },
  B = matrix(c(
    1, 0, 0, 0,
    0, 0, 1, 1,
    0, 0, 0, 0,
    0, 0, 1, 0
  ), 4, 4, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA,
    NA, NA, NA, NA,
    NA, 100, NA, NA,
    NA, NA, NA, NA
  ), 4, 4, TRUE),
  names.commodity = c("prod", "cap", "lab", "prod.used"),
  names.agent = c("firm1", "consumer", "firm2", "firm3"),
  numeraire = "prod",
  policy = policyMarketClearingPrice,
  z0 = c(100, 100, 100, 100),
  ts = TRUE,
  numberOfPeriods = 30,
  maxIteration = 1
)

matplot(ge$ts.z, type = "o", pch = 20)

</code></pre>

<hr>
<h2 id='gemCESAK_Timeline_2_2'>Some Timeline Equilibrium Models with CESAK Production Function</h2><span id='topic+gemCESAK_Timeline_2_2'></span>

<h3>Description</h3>

<p>Some timeline general equilibrium models with CESAK production function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemCESAK_Timeline_2_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemCESAK_Timeline_2_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
np &lt;- 5
gr &lt;- 0
initial.product.supply &lt;- 20
beta.prod.firm &lt;- 0.35
eis &lt;- 1
Gamma.beta &lt;- 0.97
gr &lt;- 0.05
alphaK &lt;- 1.05

S0Exg &lt;- matrix(NA, 2 * np - 1, np)
S0Exg[(np + 1):(2 * np - 1), np] &lt;- 100 * (1 + gr)^(0:(np - 2))
S0Exg[1, np] &lt;- initial.product.supply

B &lt;- matrix(0, 2 * np - 1, np)
B[2:np, 1:(np - 1)] &lt;- diag(np - 1)

dstl.firm &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm[[k]] &lt;- node_new("output",
                             type = "CESAK", es = 1,
                             alpha = 0.1, betaK = beta.prod.firm, alphaK = alphaK,
                             paste0("prod", k), paste0("lab", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "CES", es = eis,
  alpha = 1, beta = prop.table(Gamma.beta^(1:np)),
  paste0("prod", 1:np)
)

ge &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = c(paste0("prod", 1:np), paste0("lab", 1:(np - 1))),
  names.agent = c(paste0("firm", 1:(np - 1)), "consumer"),
  numeraire = "lab1",
  priceAdjustmentVelocity = 0.03
)

growth_rate(ge$p[1:np])
growth_rate(ge$z[1:np])
ge$D

#### a AK model
np &lt;- 5
initial.product.supply &lt;- 20
eis &lt;- 1
Gamma.beta &lt;- 1
alphaK &lt;- 1.25

S0Exg &lt;- matrix(NA, np, np)
S0Exg[1, np] &lt;- initial.product.supply

B &lt;- matrix(0, np, np)
B[2:np, 1:(np - 1)] &lt;- diag(np - 1)

dstl.firm &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm[[k]] &lt;- node_new("output",
                             type = "Leontief", a = 1 / alphaK,
                             paste0("prod", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "CES", es = eis,
  alpha = 1, beta = prop.table(Gamma.beta^(1:np)),
  paste0("prod", 1:np)
)

ge &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = paste0("prod", 1:np),
  names.agent = c(paste0("firm", 1:(np - 1)), "consumer"),
  numeraire = "prod1",
  priceAdjustmentVelocity = 0.03,
  policy = makePolicyMeanValue(50),
)

growth_rate(ge$p)
growth_rate(ge$z[1:(np - 1)])
ge$D

## Simplify the production function in the model above.
dstl.firm &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm[[k]] &lt;- node_new("output",
                             type = "Leontief", a = 1 / alphaK^(k),
                             "prod1"
  )
}

ge2 &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = paste0("prod", 1:np),
  names.agent = c(paste0("firm", 1:(np - 1)), "consumer"),
  numeraire = "prod1",
  priceAdjustmentVelocity = 0.03,
  policy = makePolicyMeanValue(50),
)

growth_rate(ge2$p)
growth_rate(ge2$z[1:(np - 1)])
ge2$D

</code></pre>

<hr>
<h2 id='gemCoffeeProblem_3_3'>Coffee Problem: Some Examples of Equilibrium and Disequilibrium Pure Exchange Economies</h2><span id='topic+gemCoffeeProblem_3_3'></span>

<h3>Description</h3>

<p>Some examples of equilibrium and disequilibrium pure exchange economies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemCoffeeProblem_3_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemCoffeeProblem_3_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bapat, R. B., Raghavan, T. E. S. (1997, ISBN: 9780521571678) Nonnegative Matrices and Applications. Cambridge University Press.
</p>
<p>LI Wu (2019, ISBN: 9787521804225) General Equilibrium and Structural Dynamics: Perspectives of New Structural Economics. Beijing: Economic Science Press. (In Chinese)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### the equilibrium coffee problem (Bapat, Raghavan, 1997, example 7.1; Li, 2019, example 8.1)
ge &lt;- sdm2(
  A = matrix(c(
    0.05, 0.05, 0.1,
    0.1, 0, 0.1,
    0, 0.15, 0.05
  ), 3, 3, TRUE),
  B = matrix(0, 3, 3),
  S0Exg = diag(3),
  names.commodity = c("coffee powder", "milk", "sugar"),
  names.agent = c("consumer1", "consumer2", "consumer3"),
  numeraire = "sugar"
)

ge$p

#### the disequilibrium coffee problem with exogenous prices (Li, 2019, example 8.3).
## Computing the price-control stationary state.
pcss &lt;- sdm2(
  A = matrix(c(
    0.05, 0.05, 0.1,
    0.1, 0, 0.1,
    0, 0.15, 0.05
  ), 3, 3, TRUE),
  B = matrix(0, 3, 3),
  S0Exg = diag(3),
  names.commodity = c("coffee powder", "milk", "sugar"),
  names.agent = c("consumer1", "consumer2", "consumer3"),
  pExg = c(1, 1, 1),
  maxIteration = 1,
  numberOfPeriods = 50,
  ts = TRUE
)

pcss$z
addmargins(pcss$D, 2)
addmargins(pcss$S, 2)

matplot(pcss$ts.z, type = "o", pch = 20)
matplot(pcss$ts.q, type = "o", pch = 20)

</code></pre>

<hr>
<h2 id='gemConstantGrowthPath_TechnologyProgress_3_3'>Constant Growth Paths with Technology Progress</h2><span id='topic+gemConstantGrowthPath_TechnologyProgress_3_3'></span>

<h3>Description</h3>

<p>This is an example of a spot market clearing path (alias instantaneous equilibrium path) converging to a constant growth path.
In a constant growth path, the supply of each commodity grows at a constant rate.
The balanced growth path is a special case of the constant growth path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemConstantGrowthPath_TechnologyProgress_3_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemConstantGrowthPath_TechnologyProgress_3_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.firm1 &lt;- node_new(
  "output",
  type = "CD", alpha = 1, beta = c(0.35, 0.65),
  "prod1", "lab"
)

dst.firm2 &lt;- node_new(
  "output",
  type = "CD", alpha = 1, beta = c(0.4, 0.6),
  "prod1", "lab"
)

dst.consumer &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "prod2"
)

ge &lt;- sdm2(
  A = list(dst.firm1, dst.firm2, dst.consumer),
  B = matrix(c(
    1, 0, 0,
    0, 1, 0,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, NA, NA,
    NA, NA, 1
  ), 3, 3, TRUE),
  names.commodity = c("prod1", "prod2", "lab"),
  names.agent = c("firm1", "firm2", "consumer"),
  numeraire = "lab",
  z0 = c(0.2, 0.2, 1),
  ts = TRUE,
  policy = list(
    function(time, A, state) {
      A[[1]]$alpha &lt;- exp(time * 0.01)
      A[[2]]$alpha &lt;- exp(time * 0.01)
      state$S[3, 3] &lt;- exp(time * 0.01)
      state
    },
    policyMarketClearingPrice
  ),
  numberOfPeriods = 20,
  maxIteration = 1
)

matplot(ge$ts.z, type = "l")
matplot(log(ge$ts.z[, 1:2]), type = "l")
matplot(growth_rate(ge$ts.z[, 1:2], log = TRUE), type = "o", pch = 20)
matplot(growth_rate(ge$ts.p[, 1:2], log = TRUE), type = "o", pch = 20)

</code></pre>

<hr>
<h2 id='gemDCES_5_3'>A Model with a Displaced CES Utility Function</h2><span id='topic+gemDCES_5_3'></span>

<h3>Description</h3>

<p>A model with a displaced CES utility function (Zhang, 2008, page 134; Li, 2019, example 3.12, page 130).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemDCES_5_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemDCES_5_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>LI Wu (2019, ISBN: 9787521804225) General Equilibrium and Structural Dynamics: Perspectives of New Structural Economics. Beijing: Economic Science Press. (In Chinese)
</p>
<p>Zhang Jinshui (2008, ISBN: 9787040224818) Mathematical Economics. Beijing: Higher Education Press. (In Chinese)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ge &lt;- sdm2(
  A = function(state) {
    a.firm1 &lt;- CD_A(alpha = 1, Beta = c(0, 0, 0.5, 0.5, 0), state$p)
    a.firm2 &lt;- CD_A(alpha = 2, Beta = c(0, 0, 0.5, 0, 0.5), state$p)
    a.consumer &lt;- DCES_demand(
      es = 1,
      beta = c(1 / 3, 1 / 3, 1 / 3, 0, 0),
      xi = c(0, 0, 0.4, 0, 0),
      w = state$w[3] / 10^4,
      p = state$p
    )
    cbind(a.firm1, a.firm2, a.consumer)
  },
  B = matrix(c(
    1, 0, 0,
    0, 1, 0,
    0, 0, 0,
    0, 0, 0,
    0, 0, 0
  ), 5, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, NA, NA,
    NA, NA, 10000,
    NA, NA, 1,
    NA, NA, 1
  ), 5, 3, TRUE),
  names.commodity = c("prod1", "prod2", "lab", "land1", "land2"),
  names.agent = c("firm1", "firm2", "consumer"),
  numeraire = "lab"
)

ge$p
ge$z

</code></pre>

<hr>
<h2 id='gemDualLinearProgramming'>General Equilibrium Models and Linear Programming Problems (see Winston, 2003)</h2><span id='topic+gemDualLinearProgramming'></span>

<h3>Description</h3>

<p>Some examples illustrating the relationship between general equilibrium problems and (dual) linear programming problems.
Some linear programming problems can be transformed into general equilibrium problems and vice versa.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemDualLinearProgramming(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemDualLinearProgramming_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function CGE::sdm.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These examples are similar and let us explain briefly the first example (Winston, 2003).<br />
The Dakota Furniture Company manufactures desks, tables, and chairs.
The manufacture of each type of furniture requires lumber and two types of skilled labor: finishing and carpentry.
The amount of each resource needed to make each type of furniture is as follows: <br />
desk: (8, 4, 2)<br />
table: (6, 2, 1.5)<br />
chair: (1, 1.5, 0.5)<br />
Currently, 48 board feet of lumber, 20 finishing hours, and 8 carpentry hours are available.
A desk sells for $60, a table for $30, and a chair for $20.
Because the available resources have already been purchased, Dakota wants to maximize total revenue.
This problem can be solved by the linear programming method.<br />
Now let us regard the problem above as a general equilibrium problem.
The Dakota Furniture Company can be regarded as a consumer who obtains 1 unit of utility from 1 dollar and owns lumber and two types of skilled labor.
There are four commodities (i.e. dollar, lumber and two types of skilled labor) and four agents (i.e. a desk producer, a table producer, a chair producer and the consumer Dakota) in this problem.
We need to compute the equilibrium activity levels and the equilibrium prices,
which are also the solutions of the (dual) linear programming problems (i.e. the utility-maximizing problem of the consumer and the cost-minimizing problem of the producers).
</p>


<h3>Value</h3>

<p>A general equilibrium.
</p>


<h3>Note</h3>

<p>Below is a simplified form of the von Neumann general equilibrium model (von Neumann, 1945; Kemeny, Morgenstern, Thompson, 1956):
</p>
<p style="text-align: center;"><code class="reqn">\mathbf p^{T}\mathbf{A}  \geq \rho \mathbf p^{T}\mathbf{B} </code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{Az} \leq \rho \mathbf  {Bz}</code>
</p>

<p>The above model can be extended to the following general equilibrium model, namely the structural equilibrium model (Li, 2019, section 3.4):
</p>
<p style="text-align: center;"><code class="reqn">\mathbf p^{T}\mathbf{A(p,u,z)}  \geq \rho \mathbf p^{T}\mathbf{B(p,u,z)} </code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf{A(p,u,z)z} \leq \rho \mathbf  {B(p,u,z)z} </code>
</p>

<p>We explain the structural equilibrium model as follows:<br />
(i) The vectors <code class="reqn">\mathbf p</code> and <code class="reqn">\mathbf z</code> reflect the prices of various commodities and the activity levels of various economic agents, respectively.<br />
(ii) The vector <code class="reqn">\mathbf u</code> reflects the utility levels of various consumers.
In this model, the matrices <code class="reqn">\mathbf A</code> and  <code class="reqn">\mathbf B</code> are functions of prices, utilities, and activity levels.<br />
(iii) When describing a static general equilibrium and a steady-state equilibrium without intertemporal decisions,
the structural equilibrium model usually does not explicitly include time, while when describing an intertemporal general equilibrium,
variables such as prices and activity levels explicitly include time, that is, they are labeled with time.<br />
(iv) In a time-independent model, <code class="reqn">\rho</code> is the discount factor <code class="reqn">\frac{1}{1+\gamma}</code> corresponding to the steady-state growth rate <code class="reqn">\gamma</code>.
In a time-dependent model, <code class="reqn">\rho</code> is usually equal to 1.<br />
(v) The unit demand matrix <code class="reqn">\mathbf{A(p,u,z)}</code>, the unit supply matrix <code class="reqn">\mathbf {B(p,u,z)}</code> and the activity level vector <code class="reqn">\mathbf z</code> in the structural equilibrium model are different from the input coefficient matrix A, the output coefficient matrix B and the purchase level vector z in the structural dynamic model.
The input coefficient matrix A is equivalent to the unit demand matrix with utility levels equal to 1.
The output coefficient matrix B, unlike the unit supply matrix, does not contain the exogenous supplies.
In the structural equilibrium model, the elements corresponding to consumers in <code class="reqn">\mathbf z</code> usually reflect the number of consumers,
while in the structural dynamic model, they usually reflect the utility levels. <br />
</p>
<p>Now consider the following linear programming problem:
</p>
<p style="text-align: center;"><code class="reqn">\max \quad \mathbf b^T\mathbf z \quad \text{s.t.} \quad \mathbf{Az\le e},\quad \mathbf{z \ge 0} </code>
</p>

<p>The dual linear programming problem is
</p>
<p style="text-align: center;"><code class="reqn">\min \quad \mathbf p^T\mathbf e \quad \text{s.t.} \quad \mathbf p^T \mathbf{A\ge b},\quad \mathbf{p \ge 0} </code>
</p>

<p>In the example of Winston (2003), we have <code class="reqn">\mathbf e=(48,20,8)^T</code>, <code class="reqn">\mathbf b=(60,30,20)^T</code> and
</p>
<p style="text-align: center;"><code class="reqn">
  \mathbf A=\left[\begin{matrix}
               8  &amp;6&amp;  1\\
               4&amp; 2&amp; 1.5 \\
               2&amp; 1.5&amp; 0.5\\
               \end{matrix}\right]
</code>
</p>

<p>The corresponding structural equilibrium model is
</p>
<p style="text-align: center;"><code class="reqn">\mathbf p^{T}\mathbf A(u) \geq \mathbf p^{T}\mathbf B</code>
</p>

<p style="text-align: center;"><code class="reqn">\mathbf A(u) \mathbf z \leq \mathbf  {Bz} </code>
</p>

<p>wherein <code class="reqn">\mathbf p=(1,p_2,p_3,p_4)^T</code>, <code class="reqn">\mathbf z=(z_1,z_2,z_3,1)^T</code>,
</p>
<p style="text-align: center;"><code class="reqn">
  \mathbf A(u)=\left[\begin{matrix}
               0&amp; 0&amp; 0&amp; u\\
               8  &amp;6&amp;  1&amp;0 \\
               4&amp; 2&amp; 1.5&amp;0 \\
               2&amp; 1.5&amp; 0.5&amp;0\\
               \end{matrix}\right]
</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">
  \mathbf B=\left[\begin{matrix}
            60&amp; 30&amp; 20&amp; 0\\
            0 &amp; 0&amp;  0&amp;48 \\
            0 &amp; 0&amp;  0&amp;20 \\
            0 &amp; 0&amp;  0&amp;8\\
            \end{matrix}\right]
</code>
</p>

<p>The following results are obtained by solving the above structural equilibrium model:
</p>
<p style="text-align: center;"><code class="reqn">\mathbf p^*=(1, 0, 10, 10)^T, \quad \mathbf z^*=(2, 0, 8, 1)^T, \quad u^*=280</code>
</p>



<h3>References</h3>

<p>Kemeny, J. G., O. Morgenstern and G. L. Thompson (1956) A Generalization of the von Neumann Model of an Expanding Economy, Econometrica, 24, pp. 115-135.
</p>
<p>LI Wu (2019, ISBN: 9787521804225) General Equilibrium and Structural Dynamics: Perspectives of New Structural Economics. Beijing: Economic Science Press. (In Chinese)
</p>
<p>von Neumann, J. (1945) A Model of General Economic Equilibrium. The Review of Economic Studies, 13. pp. 1-9.
</p>
<p>Winston, Wayne L. (2003, ISBN: 9780534380588) Operations Research: Applications and Algorithms. Cengage Learning.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### the Dakota example of Winston (2003, section 6.3, 6.6 and 6.8)
A &lt;- matrix(c(
  0, 0, 0, 1,
  8, 6, 1, 0,
  4, 2, 1.5, 0,
  2, 1.5, 0.5, 0
), 4, 4, TRUE)
B &lt;- matrix(c(
  60, 30, 20, 0,
  0, 0, 0, 0,
  0, 0, 0, 0,
  0, 0, 0, 0
), 4, 4, TRUE)
S0Exg &lt;- {
  S0Exg &lt;- matrix(NA, 4, 4)
  S0Exg[2:4, 4] &lt;- c(48, 20, 8)
  S0Exg
}

## Compute the equilibrium by the function CGE::sdm.
ge &lt;- CGE::sdm(A = A, B = B, S0Exg = S0Exg)

ge$p / ge$p[1]
ge$z

## Compute the equilibrium by the function sdm2.
## The function policyMeanValue is used to accelerate convergence.
ge &lt;- sdm2(
  A = A, B = B, S0Exg = S0Exg,
  policy = policyMeanValue,
  names.commodity = c("dollar", "lumber", "lab1", "lab2"),
  names.agent = c("desk producer", "table producer", "chair producer", "consumer"),
  numeraire = "dollar"
)

ge$z
ge$p

#### an example at http://web.mit.edu/15.053/www/AMP-Chapter-04.pdf.
A &lt;- matrix(c(
  0, 0, 0, 1,
  0.5, 2, 1, 0,
  1, 2, 4, 0
), 3, 4, TRUE)
B &lt;- matrix(c(
  6, 14, 13, 0,
  0, 0, 0, 0,
  0, 0, 0, 0
), 3, 4, TRUE)
S0Exg &lt;- {
  S0Exg &lt;- matrix(NA, 3, 4)
  S0Exg[2:3, 4] &lt;- c(24, 60)
  S0Exg
}

ge &lt;- CGE::sdm(
  A = A, B = B, S0Exg = S0Exg
)

ge$z
ge$p / ge$p[1]

#### an example at https://web.stanford.edu/~ashishg/msande111/notes/chapter4.pdf.
A &lt;- matrix(c(
  0, 0, 1,
  4.44, 0, 0,
  0, 6.67, 0,
  4, 2.86, 0,
  3, 6, 0
), 5, 3, TRUE)
B &lt;- matrix(c(
  3, 2.5, 0,
  0, 0, 0,
  0, 0, 0,
  0, 0, 0,
  0, 0, 0
), 5, 3, TRUE)
S0Exg &lt;- {
  S0Exg &lt;- matrix(NA, 5, 3)
  S0Exg[2:5, 3] &lt;- 100
  S0Exg
}

ge &lt;- CGE::sdm(
  A = A, B = B, S0Exg = S0Exg
)

ge$z
ge$p / ge$p[1]

#### an example at https://utw11041.utweb.utexas.edu/ORMM/supplements/methods/lpmethod/S3_dual.pdf.
A &lt;- matrix(c(
  0, 0, 1,
  0, 1, 0,
  1, 3, 0,
  1, 0, 0
), 4, 3, TRUE)
B &lt;- matrix(c(
  2, 3, 0,
  1, 0, 0,
  0, 0, 0,
  0, 0, 0
), 4, 3, TRUE)
S0Exg &lt;- {
  S0Exg &lt;- matrix(NA, 4, 3)
  S0Exg[2:4, 3] &lt;- c(5, 35, 20)
  S0Exg
}

ge &lt;- CGE::sdm(
  A = A, B = B, S0Exg = S0Exg
)

ge$z
ge$p / ge$p[1]

#### the Giapetto example of Winston (2003, section 3.1)
A &lt;- matrix(c(
  0, 0, 1,
  2, 1, 0,
  1, 1, 0,
  1, 0, 0
), 4, 3, TRUE)
B &lt;- matrix(c(
  27 - 10 - 14, 21 - 9 - 10, 0,
  0, 0, 0,
  0, 0, 0,
  0, 0, 0
), 4, 3, TRUE)
S0Exg &lt;- {
  S0Exg &lt;- matrix(NA, 4, 3)
  S0Exg[2:4, 3] &lt;- c(100, 80, 40)
  S0Exg
}

ge &lt;- sdm2(
  A = A, B = B, S0Exg = S0Exg,
  policy = policyMeanValue,
  numeraire = 1
)

ge$z
ge$p

#### the Dorian example (a minimization problem) of Winston (2003, section 3.2)
A &lt;- matrix(c(
  0, 0, 1,
  7, 2, 0,
  2, 12, 0
), 3, 3, TRUE)
B &lt;- matrix(c(
  28, 24, 0,
  0, 0, 0,
  0, 0, 0
), 3, 3, TRUE)
S0Exg &lt;- {
  S0Exg &lt;- matrix(NA, 3, 3)
  S0Exg[2:3, 3] &lt;- c(50, 100)
  S0Exg
}

ge &lt;- sdm2(
  A = A, B = B, S0Exg = S0Exg,
  policy = policyMeanValue,
  numeraire = 1
)

ge$p
ge$z

#### the diet example (a minimization problem) of Winston (2003, section 3.4)
A &lt;- matrix(c(
  0, 0, 0, 0, 1,
  400, 3, 2, 2, 0,
  200, 2, 2, 4, 0,
  150, 0, 4, 1, 0,
  500, 0, 4, 5, 0
), 5, 5, TRUE)
B &lt;- matrix(c(
  500, 6, 10, 8, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0,
  0, 0, 0, 0, 0
), 5, 5, TRUE)
S0Exg &lt;- {
  S0Exg &lt;- matrix(NA, 5, 5)
  S0Exg[2:5, 5] &lt;- c(50, 20, 30, 80)
  S0Exg
}

ge &lt;- sdm2(
  A = A, B = B, S0Exg = S0Exg,
  policy = policyMeanValue,
  numeraire = 1
)

ge$p
ge$z

#### An example of Elizabeth Stapel (Linear Programming: Introduction. Purplemath.
## Available from https://www.purplemath.com/modules/linprog.htm):
## Find the maximal value of 3x + 4y subject to the following constraints:
## x + 2y &lt;= 14, 3x - y &gt;= 0, x - y &lt;= 2, x &gt;= 0, y &gt;= 0

A &lt;- matrix(c(
  0, 0, 1,
  1, 2, 0,
  0, 1, 0,
  1, 0, 0
), 4, 3, TRUE)
B &lt;- matrix(c(
  3, 4, 0,
  0, 0, 0,
  3, 0, 0,
  0, 1, 0
), 4, 3, TRUE)
S0Exg &lt;- {
  S0Exg &lt;- matrix(NA, 4, 3)
  S0Exg[2:4, 3] &lt;- c(14, 0, 2)
  S0Exg
}

ge &lt;- sdm2(
  A = A, B = B, S0Exg = S0Exg,
  policy = policyMeanValue,
  priceAdjustmentVelocity = 0.03,
  numeraire = 1
)

ge$z
ge$p

</code></pre>

<hr>
<h2 id='gemEquityShare_3_3'>A General Equilibrium Model with Equity Shares</h2><span id='topic+gemEquityShare_3_3'></span>

<h3>Description</h3>

<p>A general equilibrium model with equity shares and dividend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemEquityShare_3_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemEquityShare_3_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.firm &lt;- node_new("output",
                     type = "FIN",
                     rate = c(1, dividend.rate = 0.25),
                     "cc1", "equity.share"
)
node_set(dst.firm, "cc1",
         type = "CD",
         alpha = 2, beta = c(0.5, 0.5),
         "prod", "lab"
)

dst.laborer &lt;- node_new("util",
                        type = "Leontief",  a = 1,
                        "prod"
)

dst.shareholder &lt;- Clone(dst.laborer)

ge &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.shareholder),
  B = diag(c(1, 0, 0)),
  S0Exg = {
    S0Exg &lt;- matrix(NA, 3, 3)
    S0Exg[2, 2] &lt;- S0Exg[3, 3] &lt;- 100
    S0Exg
  },
  names.commodity = c("prod", "lab", "equity.share"),
  names.agent = c("firm", "laborer", "shareholder"),
  numeraire = "prod"
)

ge$p # The third component is the dividend per unit of share.
ge$DV
ge$SV

## Set the growth rate to 0.03.
ge &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.shareholder),
  B = diag(c(1, 0, 0)),
  S0Exg = {
    S0Exg &lt;- matrix(NA, 3, 3)
    S0Exg[2, 2] &lt;- S0Exg[3, 3] &lt;- 100
    S0Exg
  },
  names.commodity = c("prod", "lab", "equity.share"),
  names.agent = c("firm", "laborer", "shareholder"),
  numeraire = "prod",
  GRExg = 0.03
)

ge$z
ge$p

#### an equivalent intertemporal model.
gr &lt;- 0.03 # the growth rate of the labor supply
Gamma.beta &lt;- 0.8 # the subjective discount factor
np &lt;- 5 # the number of economic periods
y1 &lt;- 100 # the initial product supply

n &lt;- 2 * np - 1 # the number of commodity kinds
m &lt;- np # the number of agent kinds

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:(np - 1)))
names.agent &lt;- c(paste0("firm", 1:(np - 1)), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:(np - 1)), "consumer"] &lt;- 100 * (1 + gr)^(0:(np - 2))
S0Exg["prod1", "consumer"] &lt;- y1

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}

dstl.firm &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "CD",
    alpha = 2, beta = c(0.5, 0.5),
    paste0("prod", k), paste0("lab", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "CES", es = 1,
  alpha = 1,  beta = prop.table(Gamma.beta^(1:np)),
  paste0("prod", 1:np)
)

ge &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "prod1",
  policy = makePolicyHeadTailAdjustment(gr = gr, np = np)
)

ge$z
growth_rate(ge$z[1:4])
ge$p[6:9] / ge$p[1:4]
addmargins(ge$D, 2)
addmargins(ge$S, 2)

</code></pre>

<hr>
<h2 id='gemEquityShare_Bond_4_4'>A General Equilibrium Model with Equity Shares and Bond</h2><span id='topic+gemEquityShare_Bond_4_4'></span>

<h3>Description</h3>

<p>A general equilibrium model with equity shares and bond.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemEquityShare_Bond_4_4(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemEquityShare_Bond_4_4_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.firm &lt;- node_new("output",
                     type = "FIN",
                     rate = c(1, dividend.rate = 0.15, bond.yield.rate = 0.1),
                     "cc1", "equity.share", "bond"
)
node_set(dst.firm, "cc1",
         type = "CD",
         alpha = 2, beta = c(0.5, 0.5),
         "prod", "lab"
)

dst.laborer &lt;- dst.shareholder &lt;- dst.bondholder &lt;-
  node_new("util",
           type = "Leontief",  a = 1,
           "prod"
  )

ge &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.shareholder, dst.bondholder),
  B = diag(c(1, 0, 0, 0)),
  S0Exg = {
    S0Exg &lt;- matrix(NA, 4, 4)
    S0Exg[2, 2] &lt;- S0Exg[3, 3] &lt;-
      S0Exg[4, 4] &lt;- 100
    S0Exg
  },
  names.commodity = c("prod", "lab", "equity.share", "bond"),
  names.agent = c("firm", "laborer", "shareholder", "bondholder"),
  numeraire = "prod"
)

ge$p
ge$DV
ge$SV

</code></pre>

<hr>
<h2 id='gemExogenousPrice'>Some Examples with Exogenous Price (Price Control)</h2><span id='topic+gemExogenousPrice'></span>

<h3>Description</h3>

<p>Some examples with exogenous price (i.e. price control, price regulation).
When a price control policy is imposed in a structural dynamic model,
the economy may converge to a steady state where the market does not clear.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemExogenousPrice(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemExogenousPrice_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>LI Wu (2019, ISBN: 9787521804225) General Equilibrium and Structural Dynamics: Perspectives of New Structural Economics. Beijing: Economic Science Press. (In Chinese)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gemExogenousPrice_EndogenousLaborSupply_3_3">gemExogenousPrice_EndogenousLaborSupply_3_3</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.firm &lt;- node_new("output",
  type = "CD", alpha = 5,
  beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.consumer &lt;- node_new("utility",
  type = "CD", alpha = 1,
  beta = c(0.5, 0.5),
  "prod", "lab"
)

f &lt;- function(pExg = NULL, policy = NULL) {
  pcss &lt;- sdm2(
    A = list(dst.firm, dst.consumer),
    B = diag(c(1, 0)),
    S0Exg = {
      S0Exg &lt;- matrix(NA, 2, 2)
      S0Exg[2, 2] &lt;- 100
      S0Exg
    },
    names.commodity = c("prod", "lab"),
    names.agent = c("firm", "consumer"),
    numeraire = "lab",
    maxIteration = 1,
    numberOfPeriods = 100,
    p0 = c(0.16, 1),
    ts = TRUE,
    pExg = pExg,
    policy = policy
  )

  print(pcss$p)
  print(pcss$z)
  par(mfrow = c(1, 2))
  matplot(pcss$ts.p, type = "l")
  matplot(pcss$ts.z, type = "l")
  invisible(pcss)
}

## No price control policy.
f()

## Set the market prices to the steady-state equilibrium prices from the beginning.
## The labor market keeps oversupplied.
result &lt;- f(pExg = c(0.16, 1))
matplot(result$ts.q, type = "l") # sale rates

## the same as above
f(policy = function(state) {
  state$p &lt;- c(0.16, 1)
  state
})

## The price control policy is implemented from the 10th period.
f(policy = function(time, state) {
  if (time &gt;= 10) state$p &lt;- c(0.16, 1)
  state
})

## The price control policy is implemented from the 30th period.
f(policy = function(time, state) {
  if (time &gt;= 30) state$p &lt;- c(0.16, 1)
  state
})

## price ceil
f(policy = function(time, state) {
  if (time &gt;= 30) {
    state$p &lt;- state$p / state$p[2]
    if (state$p[1] &gt; 0.15) state$p[1] &lt;- 0.15
  }
  state
})

##
pcss &lt;- f(policy = function(time, state) {
  if (time &gt;= 30) state$p &lt;- c(0.17, 1)
  state
})

tail(pcss$ts.q)

#### another 2-by-2 example.
f &lt;- function(GRExg = 0, pExg = c(2, 1)) {
  pcss &lt;- sdm(
    A = matrix(c(
      0, 1,
      1, 0
    ), 2, 2, TRUE),
    B = matrix(c(
      1, 0,
      0, 0
    ), 2, 2, TRUE),
    S0Exg = matrix(c(
      NA, NA,
      NA, 100
    ), 2, 2, TRUE),
    GRExg = GRExg,
    pExg = pExg,
    maxIteration = 1,
    numberOfPeriods = 300,
    depreciationCoef = 0,
    z0 = c(100, 0),
    ts = TRUE
  )
  matplot(pcss$ts.z, type = "l")
  print("pcss$z:")
  pcss$z
  print("tail(pcss$ts.q, 3)")
  print(tail(pcss$ts.q, 3))
  invisible(pcss)
}

f()
f(GRExg = 0.01)
f(pExg = c(1, 2))

#### Example 9.5 in Li (2019).
f &lt;- function(GRExg = 0, pExg = c(1, NA, 0.625)) {
  pcss &lt;- sdm(
    A = function(state) {
      alpha &lt;- rbind(1, 1, 1)
      Beta &lt;- matrix(c(
        0, 1, 1,
        0.5, 0, 0,
        0.5, 0, 0
      ), 3, 3, TRUE)
      CD_A(alpha, Beta, state$p)
    },
    B = diag(c(1, 0, 0)),
    S0Exg = matrix(c(
      NA, NA, NA,
      NA, 100, NA,
      NA, NA, 100
    ), 3, 3, TRUE),
    GRExg = GRExg,
    pExg = pExg,
    maxIteration = 1,
    numberOfPeriods = 300,
    depreciationCoef = 0,
    z0 = c(100, 0, 0),
    ts = TRUE
  )
  matplot(pcss$ts.z, type = "l")
  print("pcss$z:")
  pcss$z
  print("tail(pcss$ts.q, 3)")
  print(tail(pcss$ts.q, 3))
  invisible(pcss)
}

f()
f(GRExg = 0.01)
f(pExg = c(1, 0.25, 0.25))
f(pExg = c(1, 0.2, 0.25))

</code></pre>

<hr>
<h2 id='gemExogenousPrice_EndogenousLaborSupply_3_3'>An Example of Price Regulation and Endogenous Labor Supply (Example 9.5 of Li, 2019)</h2><span id='topic+gemExogenousPrice_EndogenousLaborSupply_3_3'></span>

<h3>Description</h3>

<p>This is an example of price regulation and endogenous labor supply.
See CGE::Example9.5.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemExogenousPrice_EndogenousLaborSupply_3_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemExogenousPrice_EndogenousLaborSupply_3_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gemExogenousPrice">gemExogenousPrice</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## the exogenous labor price with product as numeraire.
p.labor &lt;- 0.625

dst.firm &lt;- node_new("output",
  type = "CD",
  alpha = 1,  beta = c(0.5, 0.5),
  "land", "lab"
)

dst.landowner &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "prod"
)

dst.laborer &lt;- Clone(dst.landowner)

ge &lt;- sdm2(
  A = list(
    dst.firm,
    dst.landowner,
    dst.laborer
  ),
  B = diag(3),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 100, NA,
    NA, NA, 100
  ), 3, 3, TRUE),
  GRExg = 0,
  names.commodity = c("prod", "land", "lab"),
  names.agent = c("firm", "landowner", "laborer"),
  maxIteration = 1,
  numberOfPeriods = 200,
  depreciationCoef = 0,
  numeraire = "prod",
  ts = TRUE,
  policy = function(time, state, state.history) {
    if (time &gt; 1) {
      ratio &lt;- state$p[3] / state$p[1] / p.labor
      last.labor.supply &lt;- state.history$S[3, 3, time - 1]
      state$S[3, 3] &lt;- last.labor.supply * ratio
    }

    state
  }
)

matplot(ge$ts.p, type = "l")
tail(ge$ts.S[3, 3, ])
plot(ge$ts.S[3, 3, ], type = "l")

</code></pre>

<hr>
<h2 id='gemExogenousUtilityLevel_EndogenousLaborSupply_3_3'>Some Examples with Exogenous Utility Level and Endogenous Labor Supply</h2><span id='topic+gemExogenousUtilityLevel_EndogenousLaborSupply_3_3'></span>

<h3>Description</h3>

<p>Some examples with exogenous utility level and endogenous labor supply.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemExogenousUtilityLevel_EndogenousLaborSupply_3_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemExogenousUtilityLevel_EndogenousLaborSupply_3_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## a spot market clearing path (alias instantaneous equilibrium path)
utility.level.laborer &lt;- 0.625

dst.firm &lt;- node_new("output",
  type = "CD",
  alpha = 1,
  beta = c(0.5, 0.5),
  "land", "lab"
)

dst.landowner &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "prod"
)

dst.laborer &lt;- Clone(dst.landowner)

dstl &lt;- list(dst.firm, dst.landowner, dst.laborer)

ge &lt;- sdm2(
  A = dstl,
  B = diag(c(1, 0, 0)),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 100, NA,
    NA, NA, 100
  ), 3, 3, TRUE),
  GRExg = 0,
  names.commodity = c("prod", "land", "lab"),
  names.agent = c("firm", "landowner", "laborer"),
  maxIteration = 1,
  numberOfPeriods = 30,
  numeraire = "prod",
  ts = TRUE,
  policy = list(
    function(time, state, state.history) {
      if (time &gt; 1) {
        last.labor.supply &lt;- state.history$S[3, 3, time - 1]

        ratio &lt;- state$last.z[3] / last.labor.supply / utility.level.laborer
        state$S[3, 3] &lt;- last.labor.supply * ratio
      }
      state
    },
    policyMarketClearingPrice
  )
)

matplot(ge$ts.p, type = "l")
plot(ge$ts.S[3, 3, ], type = "l")
ge$S


## Regard the laborer as a firm.
dstl[[3]] &lt;- node_new(
  "lab",
  type = "Leontief", a = utility.level.laborer,
  "prod"
)

ge &lt;- sdm2(
  A = dstl,
  B = diag(c(1, 0, 1)),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 100, NA,
    NA, NA, NA
  ), 3, 3, TRUE),
  names.commodity = c("prod", "land", "lab"),
  names.agent = c("firm", "landowner", "laborer"),
  maxIteration = 1,
  numberOfPeriods = 30,
  numeraire = "prod",
  ts = TRUE,
  policy = policyMarketClearingPrice
)

matplot(ge$ts.p, type = "l")
plot(ge$ts.S[3, 3, ], type = "l")
ge$p
ge$S

</code></pre>

<hr>
<h2 id='gemExternality_Negative'>Some Examples Illustrating Negative Externality</h2><span id='topic+gemExternality_Negative'></span>

<h3>Description</h3>

<p>Some examples illustrating negative externality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemExternality_Negative(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemExternality_Negative_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### negative externality of consumption to consumption
# Here the distortion means that an agent
# will use environmental resources for free.
dst.consumer1.distorted &lt;- node_new("util",
  type = "CD",
  alpha = 1, beta = c(0.5, 0.5),
  "lab", "land"
)

dst.consumer1 &lt;- node_new("util",
  type = "CD",
  alpha = 1, beta = c(0.5, 0.5),
  "lab", "cc1"
)
node_set(dst.consumer1, "cc1",
  type = "Leontief",
  a = c(1, 1),
  "land", "env"
)

dst.consumer2 &lt;- node_new(
  "util",
  type = "CD",
  alpha = 1, beta = c(0.4, 0.4, 0.2),
  "lab", "land", "env"
)

ge.externality &lt;- sdm2(
  A = list(dst.consumer1.distorted, dst.consumer2),
  B = matrix(0, 3, 2),
  S0Exg = matrix(c(
    50, 0,
    0, 50,
    0, 0
  ), 3, 2, TRUE),
  names.commodity = c("lab", "land", "env"),
  names.agent = c("consumer1.distorted", "consumer2"),
  numeraire = "lab",
  policy = function(state) {
    last.D &lt;- state$last.A %*% dg(state$last.z)
    state$S[3, 2] &lt;- 100 - last.D[2, 1]
    state
  }
)

ge.externality$p
ge.externality$z
addmargins(ge.externality$D, 2)
addmargins(ge.externality$S, 2)

ge &lt;- sdm2(
  A = list(dst.consumer1, dst.consumer2),
  B = matrix(0, 3, 2),
  S0Exg = matrix(c(
    50, 0,
    0, 50,
    13, 87
  ), 3, 2, TRUE),
  names.commodity = c("lab", "land", "env"),
  names.agent = c("consumer1", "consumer2"),
  numeraire = "lab"
)

ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)

## A corrective tax is imposed on distorted consumer 1.
# 54% of tax revenue is allocated to distorted consumers 1, 46% to consumers 2.
dst.consumer1.distorted.taxed &lt;- node_new("util",
                                          type = "CD",
                                          alpha = 1, beta = c(0.5, 0.5),
                                          "lab", "cc1"
)
node_set(dst.consumer1.distorted.taxed, "cc1",
         type = "FIN", rate = c(1, ge$DV[3, 1] / ge$DV[2, 1]),
         "land", "tax"
)

ge.corrective.tax &lt;- sdm2(
  A = list(dst.consumer1.distorted.taxed, dst.consumer2),
  B = matrix(0, 4, 2),
  S0Exg = matrix(c(
    50, 0,
    0, 50,
    0, 0,
    54, 46
  ), 4, 2, TRUE),
  names.commodity = c("lab", "land", "env", "tax"),
  names.agent = c("consumer1.distorted", "consumer2"),
  numeraire = "lab",
  policy = function(state) {
    last.D &lt;- state$last.A %*% dg(state$last.z)
    state$S[3, 2] &lt;- 100 - last.D[2, 1]
    state
  }
)

ge.corrective.tax$z
addmargins(ge.corrective.tax$D, 2)
addmargins(ge.corrective.tax$S, 2)

## negative externality of production to consumption
dst.firm1.distorted &lt;- dst.consumer1.distorted
dst.firm1 &lt;- dst.consumer1

dst.consumer1.Leontief &lt;- node_new(
  "util",
  type = "Leontief",
  a = 1,
  "prod1"
)

ge.externality &lt;- sdm2(
  A = list(dst.firm1.distorted, dst.consumer1.Leontief, dst.consumer2),
  B = diag(c(1, 0, 0), 4, 3),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 50, NA,
    NA, NA, 50,
    NA, NA, NA
  ), 4, 3, TRUE),
  names.commodity = c("prod1", "lab", "land", "env"),
  names.agent = c("firm1", "consumer1.Leontief", "consumer2"),
  numeraire = "lab",
  policy = function(state) {
    last.D &lt;- state$last.A %*% dg(state$last.z)
    state$S[4, 3] &lt;- 100 - last.D[3, 1]
    state
  }
)

ge.externality$p
ge.externality$z
addmargins(ge.externality$D, 2)
addmargins(ge.externality$S, 2)

ge &lt;- sdm2(
  A = list(dst.firm1, dst.consumer1.Leontief, dst.consumer2),
  B = diag(c(1, 0, 0), 4, 3),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 50, NA,
    NA, NA, 50,
    NA, 13, 87
  ), 4, 3, TRUE),
  names.commodity = c("prod1", "lab", "land", "env"),
  names.agent = c("firm1", "consumer1.Leontief", "consumer2"),
  numeraire = "lab"
)

ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)

#### negative externality of consumption to production and consumption
dst.firm2 &lt;- dst.consumer2
dst.consumer2.Leontief &lt;- node_new(
  "util",
  type = "Leontief",
  a = 1,
  "prod2"
)

ge.externality &lt;- sdm2(
  A = list(dst.firm2, dst.consumer1.distorted, dst.consumer2.Leontief),
  B = diag(c(1, 0, 0), 4, 3),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 50, NA,
    NA, NA, 50,
    NA, NA, NA
  ), 4, 3, TRUE),
  names.commodity = c("prod2", "lab", "land", "env"),
  names.agent = c("firm2", "consumer1", "consumer2.Leontief"),
  numeraire = "lab",
  policy = function(state) {
    last.D &lt;- state$last.A %*% dg(state$last.z)
    state$S[4, 3] &lt;- 100 - last.D[3, 2]
    state
  }
)

ge.externality$p
ge.externality$z
addmargins(ge.externality$D, 2)
addmargins(ge.externality$S, 2)

ge &lt;- sdm2(
  A = list(dst.firm2, dst.consumer1, dst.consumer2.Leontief),
  B = diag(c(1, 0, 0), 4, 3),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 50, NA,
    NA, NA, 50,
    NA, 13, 87
  ), 4, 3, TRUE),
  names.commodity = c("prod2", "lab", "land", "env"),
  names.agent = c("firm2", "consumer1", "consumer2.Leontief"),
  numeraire = "lab"
)

ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)

## negative externality of production to production and consumption
ge.externality &lt;- sdm2(
  A = list(dst.firm1.distorted, dst.firm2, dst.consumer1.Leontief, dst.consumer2.Leontief),
  B = diag(c(1, 1, 0, 0), 5, 4),
  S0Exg = matrix(c(
    NA, NA, NA, NA,
    NA, NA, NA, NA,
    NA, NA, 50, NA,
    NA, NA, NA, 50,
    NA, NA, NA, NA
  ), 5, 4, TRUE),
  names.commodity = c("prod1", "prod2", "lab", "land", "env"),
  names.agent = c("firm1", "firm2", "consumer1.Leontief", "consumer2.Leontief"),
  numeraire = "lab",
  policy = function(state) {
    last.D &lt;- state$last.A %*% dg(state$last.z)
    state$S[5, 4] &lt;- 100 - last.D[4, 1]
    state
  }
)

ge.externality$p
ge.externality$z
addmargins(ge.externality$D, 2)
addmargins(ge.externality$S, 2)

ge &lt;- sdm2(
  A = list(dst.firm1, dst.firm2, dst.consumer1.Leontief, dst.consumer2.Leontief),
  B = diag(c(1, 1, 0, 0), 5, 4),
  S0Exg = matrix(c(
    NA, NA, NA, NA,
    NA, NA, NA, NA,
    NA, NA, 50, NA,
    NA, NA, NA, 50,
    NA, NA, 13, 87
  ), 5, 4, TRUE),
  names.commodity = c("prod1", "prod2", "lab", "land", "env"),
  names.agent = c("firm1", "firm2", "consumer1.Leontief", "consumer2.Leontief"),
  numeraire = "lab"
)

ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)

## negative externality of consumption to production
dst.firm2.distorted &lt;- node_new(
  "util",
  type = "CD",
  alpha = 1, beta = c(0.5, 0.5),
  "lab", "land"
)

ge.externality &lt;- sdm2(
  A = list(dst.firm2.distorted, dst.consumer1.distorted, dst.consumer2.Leontief),
  B = diag(c(1, 0, 0)),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 50, NA,
    NA, NA, 50
  ), 3, 3, TRUE),
  names.commodity = c("prod2", "lab", "land"),
  names.agent = c("firm2.distorted", "consumer1", "consumer2.Leontief"),
  numeraire = "lab",
  policy = function(A, state) {
    last.D &lt;- state$last.A %*% dg(state$last.z)
    state$S[1, 1] &lt;- (100 - last.D[3, 2])^0.2 * state$S[1, 1]^0.8
    state
  }
)

ge.externality$p
ge.externality$z
addmargins(ge.externality$D, 2)
addmargins(ge.externality$S, 2)

</code></pre>

<hr>
<h2 id='gemExternality_Positive'>Some Examples Illustrating Positive Externality</h2><span id='topic+gemExternality_Positive'></span>

<h3>Description</h3>

<p>Some examples illustrating positive externality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemExternality_Positive(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemExternality_Positive_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### positive externality of consumption to consumption
dst.consumer1 &lt;- node_new("util",
  type = "Leontief", a = 1,
  "lab"
)

dst.consumer2 &lt;- node_new(
  "util",
  type = "CD",
  alpha = 1, beta = c(0.2, 0.8), # c(0.8, 0.2),
  "lab", "byproduct"
)

ge.externality &lt;- sdm2(
  A = list(dst.consumer1, dst.consumer2),
  B = matrix(0, 2, 2),
  S0Exg = matrix(c(
    50, 50,
    0, 0
  ), 2, 2, TRUE),
  names.commodity = c("lab", "byproduct"),
  names.agent = c("consumer1", "consumer2"),
  numeraire = "lab",
  policy = function(state) {
    state$S[2, 2] &lt;- state$last.z[1]
    state
  }
)

ge.externality$p
ge.externality$z
addmargins(ge.externality$D, 2)
addmargins(ge.externality$S, 2)

ge &lt;- sdm2(
  A = list(dst.consumer1, dst.consumer2),
  B = matrix(0, 2, 2),
  S0Exg = matrix(c(
    50, 50,
    0, 0
  ), 2, 2, TRUE),
  names.commodity = c("lab", "byproduct"),
  names.agent = c("consumer1", "consumer2"),
  numeraire = "lab",
  policy = function(state) {
    state$S[2, 1] &lt;- state$last.z[1]
    state
  }
)

ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)

## positive externality of production to consumption
dst.firm1 &lt;- node_new("prod1",
  type = "Leontief", a = 1,
  "lab"
)

dst.consumer3 &lt;- node_new("util",
  type = "Leontief", a = 1,
  "prod1"
)

dst.consumer2 &lt;- node_new(
  "util",
  type = "CD",
  alpha = 1, beta = c(0.2, 0.8),
  "lab", "byproduct"
)

ge.externality &lt;- sdm2(
  A = list(dst.firm1, dst.consumer3, dst.consumer2),
  B = matrix(c(
    1, 0, 0,
    0, 0, 0,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 50, 50,
    NA, NA, NA
  ), 3, 3, TRUE),
  names.commodity = c("prod1", "lab", "byproduct"),
  names.agent = c("firm1", "consumer3", "consumer2"),
  numeraire = "lab",
  policy = function(state) {
    state$S[3, 3] &lt;- state$last.z[1]
    state
  }
)

ge.externality$p
ge.externality$z
addmargins(ge.externality$D, 2)
addmargins(ge.externality$S, 2)

ge &lt;- sdm2(
  A = list(dst.firm1, dst.consumer3, dst.consumer2),
  B = matrix(c(
    1, 0, 0,
    0, 0, 0,
    1, 0, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 50, 50,
    NA, NA, NA
  ), 3, 3, TRUE),
  names.commodity = c("prod1", "lab", "byproduct"),
  names.agent = c("firm1", "consumer3", "consumer2"),
  numeraire = "lab"
)

ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)

## positive externality of consumption to production
dst.consumer1 &lt;- node_new("util",
  type = "Leontief", a = 1,
  "lab"
)

dst.firm2.distorted &lt;- node_new(
  "prod2",
  type = "Leontief", a = 1,
  "lab"
)

dst.consumer2.Leontief &lt;- node_new("util",
  type = "Leontief", a = 1,
  "prod2"
)

ge.externality &lt;- sdm2(
  A = list(dst.firm2.distorted, dst.consumer1, dst.consumer2.Leontief),
  B = matrix(c(
    1, 0, 0,
    0, 0, 0
  ), 2, 3, TRUE),
  S0Exg = matrix(c(
    0, 0, 0,
    0, 50, 50
  ), 2, 3, TRUE),
  names.commodity = c("prod2", "lab"),
  names.agent = c("firm2.distorted", "consumer1", "dst.consumer2.Leontief"),
  numeraire = "lab",
  policy = function(state) {
    state$S[1, 1] &lt;- state$last.z[1]^0.2 * state$last.z[2]^0.8
    state
  }
)

ge.externality$p
ge.externality$z
addmargins(ge.externality$D, 2)
addmargins(ge.externality$S, 2)

</code></pre>

<hr>
<h2 id='gemFirmAsConsumer'>Some Examples of Treating Firms as Consumer-Type Agents</h2><span id='topic+gemFirmAsConsumer'></span>

<h3>Description</h3>

<p>Some examples of equilibrium models wherein firms are treated as
consumer-type agents instead of producer-type agents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemFirmAsConsumer(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemFirmAsConsumer_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>See Also</h3>


<p><code><a href="#topic+gemIntertemporal_2_2">gemIntertemporal_2_2</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an intertemporal model with firm
## (see gemIntertemporal_2_2)
np &lt;- 3 # the number of economic periods

S0Exg &lt;- matrix(c(
  0, 0, 150,
  1000, 0, 0,
  0, 1000, 0,
  0, 0, 100,
  0, 0, 100
), 5, 3, TRUE)

B &lt;- matrix(0, 5, 3, TRUE)

dst.firm1 &lt;- node_new("util",
  type = "StickyLinear",
  beta = c(1, 1),
  "prod2", "cc1"
)
node_set(dst.firm1, "cc1",
  type = "CD",
  alpha = 2, beta = c(0.5, 0.5),
  "prod1", "lab1"
)

dst.firm2 &lt;- node_new("util",
  type = "StickyLinear",
  beta = c(1, 1),
  "prod3", "cc1"
)
node_set(dst.firm2, "cc1",
  type = "CD",
  alpha = 2, beta = c(0.5, 0.5),
  "prod2", "lab2"
)

dst.consumer &lt;- node_new(
  "util",
  type = "CD",
  alpha = 1, beta = prop.table(rep(1, np)),
  paste0("prod", 1:np)
)

ge &lt;- sdm2(
  A = list(dst.firm1, dst.firm2, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = c(paste0("prod", 1:np), paste0("lab", 1:(np - 1))),
  names.agent = c(paste0("firm", 1:(np - 1)), "consumer"),
  numeraire = "prod1",
  ts = TRUE
)

#### an intertemporal model with bank
igr &lt;- 1.1
beta.bank &lt;- c(1, 1 / igr, 1 / igr^2)

dst.bank &lt;- node_new(
  "output",
  type = "StickyLinear",
  beta = beta.bank,
  "payoff1", "payoff2", "payoff3"
)

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = c(1 / 2, 1 / 6, 1 / 3),
  "payoff1", "payoff2", "payoff3"
)

ge &lt;- sdm2(
  A = list(dst.bank, dst.consumer),
  B = matrix(0, 3, 2, TRUE),
  S0Exg = matrix(c(
    100, 0,
    100, 2,
    100, 1
  ), 3, 2, TRUE),
  names.commodity = c("payoff1", "payoff2", "payoff3"),
  names.agent = c("bank", "consumer"),
  numeraire = "payoff1"
)

#### an instantaneous sequential model
dst.firm &lt;- node_new("output",
  type = "StickyLinear",
  beta = c(1, 1),
  "prod", "cc1"
)
node_set(dst.firm, "cc1",
  type = "CD",
  alpha = 2, beta = c(0.5, 0.5),
  "cap", "lab"
)

dst.consumer &lt;- node_new("util",
  type = "Leontief",
  a = 1,
  "prod"
)

ge &lt;- sdm2(
  A = list(dst.firm, dst.consumer),
  B = matrix(0, 3, 2, TRUE),
  S0Exg = matrix(c(
    1000, 0,
    0, 50,
    0, 100
  ), 3, 2, TRUE),
  names.commodity = c("prod", "cap", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "prod"
)
ge$p
ge$z
ge$D

## the corresponding model treating a firm as a producer-type agent
ge &lt;- sdm2(
  A = function(state) {
    a1 &lt;- CD_A(alpha = 2, Beta = c(0, 0.5, 0.5), p = state$p)
    a2 &lt;- c(1, 0, 0)
    cbind(a1, a2)
  },
  B = diag(c(1, 0), 3, 2),
  S0Exg = matrix(c(
    NA, NA,
    NA, 50,
    NA, 100
  ), 3, 2, TRUE),
  names.commodity = c("prod", "cap", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "prod"
)
ge$p
ge$z
ge$D

</code></pre>

<hr>
<h2 id='gemHeterogeneousFirms_2_3'>Instantaneous equilibrium paths with Heterogeneous Firms</h2><span id='topic+gemHeterogeneousFirms_2_3'></span>

<h3>Description</h3>

<p>This is an example of instantaneous equilibrium paths with heterogeneous firms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemHeterogeneousFirms_2_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemHeterogeneousFirms_2_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.firm1 &lt;- node_new(
  "output",
  type = "CD", alpha = 1, beta = c(0.35, 0.65),
  "prod", "lab"
)

dst.firm2 &lt;- node_new(
  "output",
  type = "CD", alpha = 1.3, beta = c(0.9, 0.1),
  "prod", "lab"
)

dst.consumer &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "prod"
)

ge &lt;- sdm2(
  A = list(dst.firm1, dst.firm2, dst.consumer),
  B = matrix(c(
    1, 1, 0,
    0, 0, 0
  ), 2, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, NA, 100
  ), 2, 3, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm1", "firm2", "consumer"),
  numeraire = "lab",
  z0 = c(1, 1, 1),
  ts = TRUE,
  policy = policyMarketClearingPrice,
  numberOfPeriods = 200,
  maxIteration = 1
)

matplot(ge$ts.z, type = "l")

</code></pre>

<hr>
<h2 id='gemInformation_ProductQuality'>An Example Illustrating Product Quality Information</h2><span id='topic+gemInformation_ProductQuality'></span>

<h3>Description</h3>

<p>An examples illustrating product quality information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemInformation_ProductQuality(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemInformation_ProductQuality_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.firm.normal &lt;- node_new("normal prod",
  type = "Leontief", a = 1,
  "lab"
)

dst.firm.inferior &lt;- node_new("inferior prod",
  type = "Leontief", a = 0.5,
  "lab"
)

dst.quasifirm &lt;- node_new("normal prod",
  type = "Leontief", a = 1,
  # a = 1 means that consumers cannot distinguish between normal and inferior products.
  # In this case, the calculated consumer utility is nominal.
  # The real utility of the consumer is lower than the nominal utility.
  # a = 10 is the opposite.
  "inferior prod"
)

dst.consumer &lt;- node_new("util",
  type = "CD",
  alpha = 1, beta = c(0.5, 0.5),
  "lab", "normal prod"
)

ge &lt;- sdm2(
  A = list(dst.firm.normal, dst.firm.inferior, dst.quasifirm, dst.consumer),
  B = matrix(c(
    1, 0, 1, 0,
    0, 1, 0, 0,
    0, 0, 0, 0
  ), 3, 4, TRUE),
  S0Exg = matrix(c(
    NA, NA,  NA, NA,
    NA, NA,  NA, NA,
    NA, NA,  NA, 100
  ), 3, 4, TRUE),
  names.commodity = c("normal prod", "inferior prod", "lab"),
  names.agent = c("normal firm", "inferior firm", "quasifirm", "consumer"),
  numeraire = "lab",
  maxIteration = 1,
  numberOfPeriods = 800
)

ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)

</code></pre>

<hr>
<h2 id='gemInputOutputTable_2_2'>A General Equilibrium Model based on a 2×2 (Unbalanced) Input-Output Table</h2><span id='topic+gemInputOutputTable_2_2'></span>

<h3>Description</h3>

<p>A general equilibrium model based on a 2×2 (unbalanced) input-output table (unit: yuan).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemInputOutputTable_2_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemInputOutputTable_2_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
names.commodity &lt;- c("prod", "lab")
names.agent &lt;- c("firm", "laborer")

IT &lt;- matrix(c(
  40, 40,
  40, 60
), 2, 2, TRUE)

OT &lt;- matrix(c(
  100, 0,
  0, 100
), 2, 2, TRUE)

dimnames(IT) &lt;- dimnames(OT) &lt;- list(names.commodity, names.agent)

addmargins(IT)
addmargins(OT)

#### the model
dst.firm &lt;- node_new(
  "prod",
  type = "SCES",
  es = 1,
  alpha = 1.25, # 100 / (40 + 40)
  beta = prop.table(c(40, 40)),
  "prod", "lab"
)

dst.consumer &lt;- node_new(
  "util",
  type = "SCES",
  es = 1, alpha = 1,
  beta = prop.table(c(40, 60)),
  "prod", "lab"
)

dstl &lt;- list(dst.firm, dst.consumer)

ge.benchmark &lt;- sdm2(
  A = dstl,
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "lab"
)

ge.benchmark$p
ge.benchmark$D
ge.benchmark$S

addmargins(ge.benchmark$DV)
addmargins(ge.benchmark$SV)

## the same as above
ge &lt;- sdm2(
  A = function(state) {
    a.firm &lt;- SCES_A(es = 1, alpha = 1.25, Beta = prop.table(c(40, 40)), p = state$p)
    a.consumer &lt;- SCES_A(es = 1, alpha = 1.25, Beta = prop.table(c(40, 60)), p = state$p)
    cbind(a.firm, a.consumer)
  },
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "lab"
)

## technology progress
dstl[[1]]$alpha &lt;- 2.5

ge.TP &lt;- sdm2(
  A = dstl,
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "lab"
)

ge.TP$p
ge.TP$D
ge.TP$S

addmargins(ge.TP$DV)
addmargins(ge.TP$SV)

</code></pre>

<hr>
<h2 id='gemInputOutputTable_2_7_2'>A Two-Country General Equilibrium Model</h2><span id='topic+gemInputOutputTable_2_7_2'></span>

<h3>Description</h3>

<p>A two-country general equilibrium model.
This general equilibrium model is based on a two-country (i.e. CHN and ROW) input-output table consisting of an input part and an output part.
Each country contains 2 sectors and 7 commodities (or subjects).
The 2 sectors are firm and household.
The 7 commodities (or subjects) are product, labor, capital goods, bond, tax, dividend, tariff.
Hence the input-output table has 14 rows and 4 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemInputOutputTable_2_7_2(
  IT,
  OT,
  es.DIProduct.firm.CHN = 3,
  es.DIProduct.firm.ROW = 3,
  es.laborCapital.firm.CHN = 0.75,
  es.laborCapital.firm.ROW = 0.75,
  es.household.CHN = 3,
  es.household.ROW = 3,
  return.dstl = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemInputOutputTable_2_7_2_+3A_it">IT</code></td>
<td>
<p>the input part of the input-output table.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_2_+3A_ot">OT</code></td>
<td>
<p>the output part of the input-output table.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_2_+3A_es.diproduct.firm.chn">es.DIProduct.firm.CHN</code></td>
<td>
<p>the elasticity of substitution between
domestic product and imported product used by the production sector of CHN.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_2_+3A_es.diproduct.firm.row">es.DIProduct.firm.ROW</code></td>
<td>
<p>the elasticity of substitution between
domestic product and imported product used by the production sector of ROW.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_2_+3A_es.laborcapital.firm.chn">es.laborCapital.firm.CHN</code></td>
<td>
<p>the elasticity of substitution between
labor and capital goods used by the production sector of CHN.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_2_+3A_es.laborcapital.firm.row">es.laborCapital.firm.ROW</code></td>
<td>
<p>the elasticity of substitution between
labor and capital goods used by the production sector of ROW.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_2_+3A_es.household.chn">es.household.CHN</code></td>
<td>
<p>the elasticity of substitution between
domestic product and imported product used by the consumption sector of CHN.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_2_+3A_es.household.row">es.household.ROW</code></td>
<td>
<p>the elasticity of substitution between
domestic product and imported product used by the consumption sector of ROW.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_2_+3A_return.dstl">return.dstl</code></td>
<td>
<p>If TRUE, the demand structure tree will be returned.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_2_+3A_...">...</code></td>
<td>
<p>arguments to be transferred to the function <code><a href="#topic+sdm2">sdm2</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A general equilibrium, which usually is a list with the following elements:
</p>

<ul>
<li><p> p - the price vector with CHN labor as numeraire.
</p>
</li>
<li><p> dstl - the demand structure tree list of sectors if return.dstl == TRUE.
</p>
</li>
<li><p> ... - some elements returned by the function <code><a href="#topic+sdm2">sdm2</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
IT &lt;- matrix(c(
  142, 84, 13, 4.1,
  47, 0, 0, 0,
  13, 0, 0, 0,
  0, 0, 0, 3.4,
  9.3, 0, 0, 0,
  22, 0, 0, 0,
  0.15, 0.091, 0, 0,
  10, 6, 381, 451,
  0, 0, 252, 0,
  0, 0, 81, 0,
  0, 4.9, 0, 0,
  0, 0, 26, 0,
  0, 0, 92, 0,
  0, 0, 1.9, 0.59
), 14, 4, TRUE)

OT &lt;- matrix(c(
  244, 0, 0, 0,
  0, 47, 0, 0,
  0, 13, 0, 0,
  0, 3.4, 0, 0,
  0, 9.3, 0, 0,
  0, 22, 0, 0,
  0, 0.24, 0, 0,
  0, 0, 849, 0,
  0, 0, 0, 252,
  0, 0, 0, 81,
  0, 0, 0, 4.9,
  0, 0, 0, 26,
  0, 0, 0, 92,
  0, 0, 0, 2.5
), 14, 4, TRUE)

dimnames(IT) &lt;- dimnames(OT) &lt;- list(
  c(
    "product.CHN", "labor.CHN", "capital.CHN", "bond.CHN",
    "tax.CHN", "dividend.CHN", "tariff.CHN",
    "product.ROW", "labor.ROW", "capital.ROW", "bond.ROW",
    "tax.ROW", "dividend.ROW", "tariff.ROW"
  ),
  c(
    "firm.CHN", "household.CHN",
    "firm.ROW", "household.ROW"
  )
)

ge &lt;- gemInputOutputTable_2_7_2(IT, OT, return.dstl = TRUE)
ge$p
ge$z
node_plot(ge$dstl[[1]])
ge$dstl[[1]]$a

## tariff rate change in CHN
dstl &lt;- lapply(ge$dstl, Clone)
tmp &lt;- node_set(dstl[[1]], "cc1.1")
tmp$beta[2] &lt;- tmp$beta[2] * 10

ge.TRC &lt;- sdm2(
  A = dstl, B = ge$B, S0Exg = ge$S0Exg,
  names.commodity = rownames(ge$B),
  names.agent = colnames(ge$B),
  numeraire = "labor.CHN"
)

ge.TRC$p
ge.TRC$z
#### technology progress in CHN
OT.TP &lt;- OT
OT.TP["product.CHN", "firm.CHN"] &lt;- OT["product.CHN", "firm.CHN"] * 1.2

ge.TP &lt;- gemInputOutputTable_2_7_2(IT, OT.TP, return.dstl = TRUE)
ge.TP$p
ge.TP$z
ge.TP$dstl[[1]]$a

#### capital accumulation in CHN
OT.CA &lt;- OT
OT.CA["capital.CHN", "household.CHN"] &lt;- OT["capital.CHN", "household.CHN"] * 2

ge.CA &lt;- gemInputOutputTable_2_7_2(IT, OT.CA)
ge.CA$p
ge.CA$z

#### labor supply change in CHN
OT.LSC &lt;- OT
OT.LSC["labor.CHN", "household.CHN"] &lt;- OT["labor.CHN", "household.CHN"] * 0.5

ge.LSC &lt;- gemInputOutputTable_2_7_2(IT, OT.LSC)
ge.LSC$p
ge.LSC$z


</code></pre>

<hr>
<h2 id='gemInputOutputTable_2_7_4'>A Two-Country General Equilibrium Model</h2><span id='topic+gemInputOutputTable_2_7_4'></span>

<h3>Description</h3>

<p>A two-country general equilibrium model.
This general equilibrium model is based on a two-country (i.e. CHN and ROW) input-output table consisting of an input part and an output part.
Each country contains 4 sectors and 7 commodities (or subjects).
The 4 sectors are production, consumption, investment and foreign trade.
The 7 commodities (or subjects) are product, labor, capital goods, bond, tax, dividend, imported product.
Hence the input-output table has 14 rows and 8 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemInputOutputTable_2_7_4(
  IT,
  OT,
  es.DIProduct.production.CHN = 3,
  es.DIProduct.production.ROW = 3,
  es.laborCapital.production.CHN = 0.75,
  es.laborCapital.production.ROW = 0.75,
  es.consumption.CHN = 3,
  es.consumption.ROW = 3,
  es.investment.CHN = 3,
  es.investment.ROW = 3,
  return.dstl = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemInputOutputTable_2_7_4_+3A_it">IT</code></td>
<td>
<p>the input part of the input-output table.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_4_+3A_ot">OT</code></td>
<td>
<p>the output part of the input-output table.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_4_+3A_es.diproduct.production.chn">es.DIProduct.production.CHN</code></td>
<td>
<p>the elasticity of substitution between
domestic product and imported product used by the production sector of CHN.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_4_+3A_es.diproduct.production.row">es.DIProduct.production.ROW</code></td>
<td>
<p>the elasticity of substitution between
domestic product and imported product used by the production sector of ROW.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_4_+3A_es.laborcapital.production.chn">es.laborCapital.production.CHN</code></td>
<td>
<p>the elasticity of substitution between
labor and capital goods used by the production sector of CHN.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_4_+3A_es.laborcapital.production.row">es.laborCapital.production.ROW</code></td>
<td>
<p>the elasticity of substitution between
labor and capital goods used by the production sector of ROW.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_4_+3A_es.consumption.chn">es.consumption.CHN</code></td>
<td>
<p>the elasticity of substitution between
domestic product and imported product used by the consumption sector of CHN.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_4_+3A_es.consumption.row">es.consumption.ROW</code></td>
<td>
<p>the elasticity of substitution between
domestic product and imported product used by the consumption sector of ROW.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_4_+3A_es.investment.chn">es.investment.CHN</code></td>
<td>
<p>the elasticity of substitution between
domestic product and imported product used by the investment sector of CHN.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_4_+3A_es.investment.row">es.investment.ROW</code></td>
<td>
<p>the elasticity of substitution between
domestic product and imported product used by the investment sector of ROW.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_4_+3A_return.dstl">return.dstl</code></td>
<td>
<p>If TRUE, the demand structure tree will be returned.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_7_4_+3A_...">...</code></td>
<td>
<p>arguments to be transferred to the function <code><a href="#topic+sdm2">sdm2</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A general equilibrium, which usually is a list with the following elements:
</p>

<ul>
<li><p> p - the price vector with CHN labor as numeraire.
</p>
</li>
<li><p> dstl - the demand structure tree list of sectors if return.dstl == TRUE.
</p>
</li>
<li><p> ... - some elements returned by the function <code><a href="#topic+sdm2">sdm2</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
IT &lt;- matrix(c(
  30, 12, 9, 0, 0, 0, 0, 13,
  15, 0, 0, 0, 0, 0, 0, 0,
  2, 0, 0, 0, 0, 0, 0, 0,
  0, 9, 0, 0, 0, 2, 0, 0,
  3, 0, 0, 1, 0, 0, 0, 0,
  6, 0, 0, 0, 0, 0, 0, 0,
  8, 3, 3, 0, 0, 0, 0, 0,
  0, 0, 0, 13, 150, 316, 258, 0,
  0, 0, 0, 0, 288, 0, 0, 0,
  0, 0, 0, 0, 92, 0, 0, 0,
  0, 2, 0, 0, 0, 269, 0, 0,
  0, 0, 0, 0, 35, 0, 0, 1,
  0, 0, 0, 0, 172, 0, 0, 0,
  0, 0, 0, 0, 1, 5, 13, 0
), 14, 8, TRUE)

OT &lt;- matrix(c(
  64, 0, 0, 0, 0, 0, 0, 0,
  0, 15, 0, 0, 0, 0, 0, 0,
  0, 2, 0, 0, 0, 0, 0, 0,
  0, 0, 11, 0, 0, 0, 0, 0,
  0, 3, 0, 0, 0, 0, 0, 0,
  0, 6, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 13, 0, 0, 0, 0,
  0, 0, 0, 0, 738, 0, 0, 0,
  0, 0, 0, 0, 0, 288, 0, 0,
  0, 0, 0, 0, 0, 92, 0, 0,
  0, 0, 0, 0, 0, 0, 271, 0,
  0, 0, 0, 0, 0, 36, 0, 0,
  0, 0, 0, 0, 0, 172, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 14
), 14, 8, TRUE)

dimnames(IT) &lt;- dimnames(OT) &lt;- list(
  c(
    "product.CHN", "labor.CHN", "capital.CHN", "bond.CHN",
    "tax.CHN", "dividend.CHN", "imported.product.CHN",
    "product.ROW", "labor.ROW", "capital.ROW", "bond.ROW",
    "tax.ROW", "dividend.ROW", "imported.product.ROW"
  ),
  c(
    "production.CHN", "consumption.CHN", "investment.CHN", "foreign.trade.CHN",
    "production.ROW", "consumption.ROW", "investment.ROW", "foreign.trade.ROW"
  )
)

ge &lt;- gemInputOutputTable_2_7_4(IT, OT, return.dstl = TRUE)
ge$p
ge$z
node_plot(ge$dstl[[1]])
ge$dstl[[1]]$a

#### technology progress in CHN
OT.TP &lt;- OT
OT.TP["product.CHN", "production.CHN"] &lt;- OT["product.CHN", "production.CHN"] * 1.2

ge.TP &lt;- gemInputOutputTable_2_7_4(IT, OT.TP, return.dstl = TRUE)
ge.TP$p
ge.TP$z
ge.TP$dstl[[1]]$a

#### capital accumulation in CHN
OT.CA &lt;- OT
OT.CA["capital.CHN", "consumption.CHN"] &lt;- OT["capital.CHN", "consumption.CHN"] * 2

ge.CA &lt;- gemInputOutputTable_2_7_4(IT, OT.CA)
ge.CA$p
ge.CA$z

#### labor supply change in CHN
OT.LSC &lt;- OT
OT.LSC["labor.CHN", "consumption.CHN"] &lt;- OT["labor.CHN", "consumption.CHN"] * 0.5

ge.LSC &lt;- gemInputOutputTable_2_7_4(IT, OT.LSC)
ge.LSC$p
ge.LSC$z

#### tariff rate change in CHN
IT.TRC &lt;- IT
IT.TRC["tax.CHN","foreign.trade.CHN"] &lt;- IT.TRC["tax.CHN","foreign.trade.CHN"] * 1.2
ge.TRC &lt;- gemInputOutputTable_2_7_4(IT.TRC, OT)
ge.TRC$p
ge.TRC$z


</code></pre>

<hr>
<h2 id='gemInputOutputTable_2_8_4'>A Two-Country General Equilibrium Model with Money</h2><span id='topic+gemInputOutputTable_2_8_4'></span>

<h3>Description</h3>

<p>A two-country general equilibrium model with money.
This general equilibrium model is based on a two-country (i.e. CHN and ROW) input-output table.
Each country contains four sectors and eight commodities (or subjects).
The four sectors are production, consumption, investment and foreign trade.
The eight commodities (or subjects) are product, labor, capital goods, bond, tax, dividend, imported product and money interest.
Hence the input-output table has 16 rows and 8 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemInputOutputTable_2_8_4(
  IT,
  product.output.CHN = sum(IT[, "production.CHN"]),
  product.output.ROW = sum(IT[, "production.ROW"]),
  labor.supply.CHN = sum(IT["labor.CHN", ]),
  labor.supply.ROW = sum(IT["labor.ROW", ]),
  capital.supply.CHN = sum(IT["capital.CHN", ]),
  capital.supply.ROW = sum(IT["capital.ROW", ]),
  money.interest.supply.CHN = 5,
  money.interest.supply.ROW = 30,
  es.DIProduct.production.CHN = 0.5,
  es.DIProduct.production.ROW = 0.5,
  es.laborCapital.production.CHN = 0.75,
  es.laborCapital.production.ROW = 0.75,
  es.consumption.CHN = 0.5,
  es.consumption.ROW = 0.5,
  es.investment.CHN = 0.9,
  es.investment.ROW = 0.9,
  interest.rate.CHN = NA,
  interest.rate.ROW = NA,
  return.dstl = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_it">IT</code></td>
<td>
<p>the input part of the input-output table (unit: trillion yuan).</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_product.output.chn">product.output.CHN</code></td>
<td>
<p>the product output of the production sector of CHN.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_product.output.row">product.output.ROW</code></td>
<td>
<p>the product output of the production sector of ROW.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_labor.supply.chn">labor.supply.CHN</code></td>
<td>
<p>the labor supply of CHN.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_labor.supply.row">labor.supply.ROW</code></td>
<td>
<p>the labor supply of ROW.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_capital.supply.chn">capital.supply.CHN</code></td>
<td>
<p>the capital supply of CHN.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_capital.supply.row">capital.supply.ROW</code></td>
<td>
<p>the capital supply of ROW.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_money.interest.supply.chn">money.interest.supply.CHN</code></td>
<td>
<p>the money interest supply of CHN,
that is, the exogenous money supply multiplied by the exogenous interest rate.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_money.interest.supply.row">money.interest.supply.ROW</code></td>
<td>
<p>the money interest supply of ROW.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_es.diproduct.production.chn">es.DIProduct.production.CHN</code></td>
<td>
<p>the elasticity of substitution between
domestic product and imported product used by the production sector of CHN.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_es.diproduct.production.row">es.DIProduct.production.ROW</code></td>
<td>
<p>the elasticity of substitution between
domestic product and imported product used by the production sector of ROW.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_es.laborcapital.production.chn">es.laborCapital.production.CHN</code></td>
<td>
<p>the elasticity of substitution between
labor and capital goods used by the production sector of CHN.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_es.laborcapital.production.row">es.laborCapital.production.ROW</code></td>
<td>
<p>the elasticity of substitution between
labor and capital goods used by the production sector of ROW.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_es.consumption.chn">es.consumption.CHN</code></td>
<td>
<p>the elasticity of substitution between
domestic product and imported product used by the consumption sector of CHN.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_es.consumption.row">es.consumption.ROW</code></td>
<td>
<p>the elasticity of substitution between
domestic product and imported product used by the consumption sector of ROW.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_es.investment.chn">es.investment.CHN</code></td>
<td>
<p>the elasticity of substitution between
domestic product and imported product used by the investment sector of CHN.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_es.investment.row">es.investment.ROW</code></td>
<td>
<p>the elasticity of substitution between
domestic product and imported product used by the investment sector of ROW.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_interest.rate.chn">interest.rate.CHN</code></td>
<td>
<p>the interest rate of CHN.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_interest.rate.row">interest.rate.ROW</code></td>
<td>
<p>the interest rate of ROW.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_return.dstl">return.dstl</code></td>
<td>
<p>If TRUE, the demand structure tree will be returned.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_2_8_4_+3A_...">...</code></td>
<td>
<p>arguments to be transferred to the function <code><a href="#topic+sdm2">sdm2</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If interest.rate.CHN is NA or interest.rate.CHN is NA, they are assumed to be equal.
And in this case, the exchange rate is determined by the ratio of the interest of unit currency of the two countries.
In this model, the ratio of a sector's monetary interest expenditure to its transaction value may not be equal to the interest rate
because the ratio is not only affected by the interest rate,
but also by the sector's currency circulation velocity and other factors.
</p>


<h3>Value</h3>

<p>A general equilibrium, which usually is a list with the following elements:
</p>

<ul>
<li><p> p - the price vector with CHN labor as numeraire, wherein
the price of a currency is the interest per unit of currency.
</p>
</li>
<li><p> D - the demand matrix, also called the input table. Wherein the benchmark prices are used.
</p>
</li>
<li><p> DV - the demand value matrix, also called the value input table. Wherein the current price is used.
</p>
</li>
<li><p> SV - the supply value matrix, also called the value output table. Wherein the current price is used.
</p>
</li>
<li><p> eri.CHN - the exchange rate index of CHN currency.
</p>
</li>
<li><p> eri.ROW - the exchange rate index of ROW currency.
</p>
</li>
<li><p> p.money - the price vector with CHN money as numeraire
if both interest.rate.CHN and interest.rate.CHN are not NA.
</p>
</li>
<li><p> dstl - the demand structure tree list of sectors if return.dstl == TRUE.
</p>
</li>
<li><p> ... - some elements returned by the function <code><a href="#topic+sdm2">sdm2</a></code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
ITExample &lt;- matrix(0, 16, 8, dimnames = list(
  c(
    "product.CHN", "labor.CHN", "capital.CHN", "bond.CHN",
    "tax.CHN", "dividend.CHN", "imported.product.CHN", "money.interest.CHN",
    "product.ROW", "labor.ROW", "capital.ROW", "bond.ROW",
    "tax.ROW", "dividend.ROW", "imported.product.ROW", "money.interest.ROW"
  ),
  c(
    "production.CHN", "consumption.CHN", "investment.CHN", "foreign.trade.CHN",
    "production.ROW", "consumption.ROW", "investment.ROW", "foreign.trade.ROW"
  )
))

production.CHN &lt;- c(
  product.CHN = 140, labor.CHN = 40, capital.CHN = 10,
  tax.CHN = 10, dividend.CHN = 20, imported.product.CHN = 5, money.interest.CHN = 5
)
production.ROW &lt;- c(
  product.ROW = 840, labor.ROW = 240, capital.ROW = 60,
  tax.ROW = 60, dividend.ROW = 120, imported.product.ROW = 6, money.interest.ROW = 30
)

consumption.CHN &lt;- c(
  product.CHN = 40, bond.CHN = 30, imported.product.CHN = 5, money.interest.CHN = 2
)

consumption.ROW &lt;- c(
  product.ROW = 240, bond.ROW = 180, imported.product.ROW = 6, money.interest.ROW = 12
)

investment.CHN &lt;- c(
  product.CHN = 30,
  imported.product.CHN = 4, money.interest.CHN = 1,
  bond.ROW = 1,
  money.interest.ROW = 0.02
)

investment.ROW &lt;- c(
  bond.CHN = 1,
  money.interest.CHN = 0.02,
  product.ROW = 180,
  imported.product.ROW = 4, money.interest.ROW = 6
)


foreign.trade.CHN &lt;- c(
  product.ROW = 13,
  tax.CHN = 0.65,
  money.interest.ROW = 0.26
)

foreign.trade.ROW &lt;- c(
  product.CHN = 15,
  tax.ROW = 0.75,
  money.interest.CHN = 0.3
)

ITExample &lt;- matrix_add_by_name(
  ITExample, production.CHN, consumption.CHN, investment.CHN, foreign.trade.CHN,
  production.ROW, consumption.ROW, investment.ROW, foreign.trade.ROW
)

ge &lt;- gemInputOutputTable_2_8_4(
  IT = ITExample,
  return.dstl = TRUE
)
ge$eri.CHN
ge$p
node_plot(ge$dstl[[4]], TRUE)

ge2 &lt;- gemInputOutputTable_2_8_4(
  IT = ge$DV,
  money.interest.supply.CHN = sum(ge$DV["money.interest.CHN", ]),
  money.interest.supply.ROW = sum(ge$DV["money.interest.ROW", ]),
  return.dstl = TRUE
)
ge2$eri.CHN
ge2$p


#### technology progress in CHN
ITTmp &lt;- ITExample
ITTmp["labor.CHN", "production.CHN"] &lt;- ITTmp["labor.CHN", "production.CHN"] * 0.8
geTmp &lt;- gemInputOutputTable_2_8_4(
  IT = ITTmp,
  product.output.CHN = sum(ITExample[, "production.CHN"]),
  return.dstl = TRUE
)
geTmp$eri.CHN


#### increased demand for imported product in CHN
ITTmp &lt;- ITExample
ITTmp["imported.product.CHN", "production.CHN"] &lt;-
  ITTmp["imported.product.CHN", "production.CHN"] * 1.2
geTmp &lt;- gemInputOutputTable_2_8_4(
  IT = ITTmp,
  return.dstl = TRUE
)
geTmp$eri.CHN


#### capital accumulation in CHN
geTmp &lt;- gemInputOutputTable_2_8_4(
  IT = ITExample,
  capital.supply.CHN = sum(ITExample["capital.CHN", ]) * 1.2,
  return.dstl = TRUE
)
geTmp$eri.CHN

##
geTmp &lt;- gemInputOutputTable_2_8_4(
  IT = ITExample,
  capital.supply.CHN = sum(ITExample["capital.CHN", ]) * 1.2,
  es.DIProduct.production.CHN = 0.3,
  return.dstl = TRUE
)
geTmp$eri.CHN


</code></pre>

<hr>
<h2 id='gemInputOutputTable_5_4'>A General Equilibrium Model based on a 5×4 Input-Output Table (see Zhang Xin, 2017, Table 8.6.1)</h2><span id='topic+gemInputOutputTable_5_4'></span>

<h3>Description</h3>

<p>This is a general equilibrium model based on a 5×4 input-output table (see Zhang Xin, 2017, Table 8.6.1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemInputOutputTable_5_4(
  dstl,
  supply.labor = 850,
  supply.capital = 770,
  names.commodity = c("agri", "manu", "serv", "lab", "cap"),
  names.agent = c("agri", "manu", "serv", "hh")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemInputOutputTable_5_4_+3A_dstl">dstl</code></td>
<td>
<p>a demand structure tree list.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_5_4_+3A_supply.labor">supply.labor</code></td>
<td>
<p>the supply of labor.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_5_4_+3A_supply.capital">supply.capital</code></td>
<td>
<p>the supply of capital.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_5_4_+3A_names.commodity">names.commodity</code></td>
<td>
<p>names of commodities.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_5_4_+3A_names.agent">names.agent</code></td>
<td>
<p>names of agents.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a 5×4 input-output table (e.g., see Zhang Xin, 2017, Table 8.6.1), this model calculates
the corresponding general equilibrium.
This input-output table contains 3 production sectors and one household.
The household consumes products and supplies labor and capital.
</p>


<h3>Value</h3>

<p>A general equilibrium which is a list with the following elements:
</p>

<ul>
<li><p> D - the demand matrix, also called the input table. Wherein the benchmark prices are used.
</p>
</li>
<li><p> DV - the demand value matrix, also called the value input table. Wherein the current price is used.
</p>
</li>
<li><p> SV - the supply value matrix, also called the value output table. Wherein the current price is used.
</p>
</li>
<li><p> ... - some elements returned by the CGE::sdm function
</p>
</li></ul>



<h3>References</h3>

<p>Zhang Xin (2017, ISBN: 9787543227637) Principles of Computable General Equilibrium Modeling and Programming (Second Edition). Shanghai: Gezhi Press. (In Chinese)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
es.agri &lt;- 0.2 # the elasticity of substitution
es.manu &lt;- 0.3
es.serv &lt;- 0.1

es.VA.agri &lt;- 0.25
es.VA.manu &lt;- 0.5
es.VA.serv &lt;- 0.8

d.agri &lt;- c(260, 345, 400, 200, 160)
d.manu &lt;- c(320, 390, 365, 250, 400)
d.serv &lt;- c(150, 390, 320, 400, 210)
d.hh &lt;- c(635, 600, 385, 0, 0)
# d.hh &lt;- c(635, 600, 100, 0, 0)

IT &lt;- cbind(d.agri, d.manu, d.serv, d.hh)
OT &lt;- matrix(c(
  1365, 0, 0, 0,
  0, 1725, 0, 0,
  0, 0, 1470, 0,
  0, 0, 0, 850,
  0, 0, 0, 770
), 5, 4, TRUE)

dimnames(IT) &lt;- dimnames(OT) &lt;-
  list(
    c("agri", "manu", "serv", "lab", "cap"),
    c("agri", "manu", "serv", "hh")
  )

addmargins(IT)
addmargins(OT)

dst.agri &lt;- node_new("sector.agri",
                     type = "SCES", es = es.agri,
                     alpha = 1,
                     beta = prop.table(
                       c(sum(d.agri[1:3]), sum(d.agri[4:5]))
                     ),
                     "cc1.agri", "cc2.agri"
)
node_set(dst.agri, "cc1.agri",
         type = "Leontief",
         a = prop.table(d.agri[1:3]),
         "agri", "manu", "serv"
)
node_set(dst.agri, "cc2.agri",
         type = "SCES", es = es.VA.agri,
         alpha = 1,
         beta = prop.table(d.agri[4:5]),
         "lab", "cap"
)


dst.manu &lt;- node_new("sector.manu",
                     type = "SCES", es = es.manu,
                     alpha = 1,
                     beta = prop.table(
                       c(sum(d.manu[1:3]), sum(d.manu[4:5]))
                     ),
                     "cc1.manu", "cc2.manu"
)
node_set(dst.manu, "cc1.manu",
         type = "Leontief",
         a = prop.table(d.manu[1:3]),
         "agri", "manu", "serv"
)
node_set(dst.manu, "cc2.manu",
         type = "SCES", es = es.VA.manu,
         alpha = 1,
         beta = prop.table(d.manu[4:5]),
         "lab", "cap"
)

dst.serv &lt;- node_new("sector.serv",
                     type = "SCES", es = es.serv,
                     alpha = 1,
                     beta = prop.table(
                       c(sum(d.serv[1:3]), sum(d.serv[4:5]))
                     ),
                     "cc1.serv", "cc2.serv"
)
node_set(dst.serv, "cc1.serv",
         type = "Leontief",
         a = prop.table(d.serv[1:3]),
         "agri", "manu", "serv"
)
node_set(dst.serv, "cc2.serv",
         type = "SCES", es = es.VA.serv,
         alpha = 1,
         beta = prop.table(d.serv[4:5]),
         "lab", "cap"
)

##
dst.hh &lt;- node_new("sector.hh",
                   type = "SCES", es = 0.5,
                   alpha = 1,
                   beta = prop.table(d.hh[1:3]),
                   "agri", "manu", "serv"
)

dstl &lt;- list(dst.agri, dst.manu, dst.serv, dst.hh)

ge &lt;- gemInputOutputTable_5_4(dstl)

#### labor supply increase
geLSI &lt;- gemInputOutputTable_5_4(dstl, supply.labor = 850 * 1.08)
geLSI$p
geLSI$z / ge$z

## capital supply change
ge.CSC &lt;- sdm2(
  A = dstl,
  B = matrix(c(
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1,
    0, 0, 0, 1
  ), 5, 4, TRUE),
  S0Exg = {
    tmp &lt;- matrix(NA, 5, 4)
    tmp[4, 4] &lt;- 850
    tmp[5, 4] &lt;- 770
    tmp
  },
  names.commodity = c("agri", "manu", "serv", "lab", "cap"),
  names.agent = c("agri", "manu", "serv", "hh"),
  numeraire = "lab",
  ts = TRUE,
  numberOfPeriods = 100,
  maxIteration = 1,
  z0 = c(1365, 1725, 1470, 1620),
  p0 = rep(1, 5),
  policy = function(time, state) {
    if (time &gt;= 5) {
      state$S[5, 4] &lt;- 880
    }
    state
  }
)

matplot(ge.CSC$ts.p, type = "l")
matplot(ge.CSC$ts.z, type = "l")

## economic fluctuation: a sticky-price path
de &lt;- sdm2(
  A = dstl,
  B = matrix(c(
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 1,
    0, 0, 0, 1
  ), 5, 4, TRUE),
  S0Exg = {
    tmp &lt;- matrix(NA, 5, 4)
    tmp[4, 4] &lt;- 850
    tmp[5, 4] &lt;- 770
    tmp
  },
  names.commodity = c("agri", "manu", "serv", "lab", "cap"),
  names.agent = c("agri", "manu", "serv", "hh"),
  numeraire = "lab",
  ts = TRUE,
  numberOfPeriods = 50,
  maxIteration = 1,
  z0 = c(1365, 1725, 1470, 1620),
  p0 = rep(1, 5),
  policy = list(
    function(time, state) {
      if (time &gt;= 5) {
        state$S[5, 4] &lt;- 880
      }
      state
    },
    makePolicyStickyPrice(0.5)
  ),
  priceAdjustmentVelocity = 0
)

matplot(de$ts.p, type = "o", pch = 20)
matplot(de$ts.z, type = "o", pch = 20)

</code></pre>

<hr>
<h2 id='gemInputOutputTable_5_5'>General Equilibrium Models based on a 5×5 Input-Output Table (see Zhang Xin, 2017, Table 3.2.1)</h2><span id='topic+gemInputOutputTable_5_5'></span>

<h3>Description</h3>

<p>Some general equilibrium models based on a 5×5 input-output table (see Zhang Xin, 2017, Table 3.2.1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemInputOutputTable_5_5(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemInputOutputTable_5_5_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Zhang Xin (2017, ISBN: 9787543227637) Principles of Computable General Equilibrium Modeling and Programming (Second Edition). Shanghai: Gezhi Press. (In Chinese)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
names.commodity &lt;- c("agri", "manu", "serv", "lab", "cap")
names.agent &lt;- c("agri", "manu", "serv", "consumer", "investor")

IT &lt;- matrix(c(
  200, 300, 150, 280, 70,
  80, 400, 250, 550, 320,
  30, 420, 240, 350, 110,
  500, 250, 330, 0, 0,
  190, 230, 180, 0, 0
), 5, 5, TRUE)

OT &lt;- matrix(c(
  1000, 0, 0, 0, 0,
  0, 1600, 0, 0, 0,
  0, 0, 1150, 0, 0,
  0, 0, 0, 758.5714, 321.4286,
  0, 0, 0, 421.4286, 178.5714
), 5, 5, TRUE)

dimnames(IT) &lt;- dimnames(OT) &lt;- list(names.commodity, names.agent)

addmargins(IT)
addmargins(OT)

#### a model with non-nested production functions (demand structure trees)
dst.agri &lt;- node_new("output",
  type = "SCES", es = 1, alpha = 1,
  beta = prop.table(c(200, 80, 30, 500, 190)),
  "agri", "manu", "serv", "lab", "cap"
)

dst.manu &lt;- node_new("output",
  type = "SCES", es = 1, alpha = 1,
  beta = prop.table(c(300, 400, 420, 250, 230)),
  "agri", "manu", "serv", "lab", "cap"
)

dst.serv &lt;- node_new("output",
  type = "SCES", es = 1, alpha = 1,
  beta = prop.table(c(150, 250, 240, 330, 180)),
  "agri", "manu", "serv", "lab", "cap"
)

dst.consumer &lt;- node_new("util",
  type = "SCES", es = 0.5, alpha = 1,
  beta = prop.table(c(280, 550, 350)),
  "agri", "manu", "serv"
)

dst.investor &lt;- node_new("util",
  type = "SCES", es = 0.5, alpha = 1,
  beta = prop.table(c(70, 320, 110)),
  "agri", "manu", "serv"
)

ge1.benchmark &lt;- sdm2(list(dst.agri, dst.manu, dst.serv, dst.consumer, dst.investor),
  B = matrix(c(
    1, 0, 0, 0, 0,
    0, 1, 0, 0, 0,
    0, 0, 1, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0
  ), 5, 5, TRUE),
  S0Exg = {
    S0Exg &lt;- matrix(NA, 5, 5)
    S0Exg[4:5, 4] &lt;- c(1080, 600) * (1180 / (1180 + 500))
    S0Exg[4:5, 5] &lt;- c(1080, 600) * (500 / (1180 + 500))
    S0Exg
  },
  names.commodity = c("agri", "manu", "serv", "lab", "cap"),
  names.agent = c("agri", "manu", "serv", "consumer", "investor"),
  numeraire = c("lab")
)

addmargins(ge1.benchmark$D)
addmargins(ge1.benchmark$S)

#### a model with nested production functions (demand structure trees)
dst.agri &lt;- node_new("output",
  type = "SCES", es = 0, alpha = 1,
  beta = prop.table(c(200 + 80 + 30, 500 + 190)),
  "cc.II", "cc.VA"
)
node_set(dst.agri, "cc.II",
  type = "SCES", es = 0, alpha = 1,
  beta = prop.table(c(200, 80, 30)),
  "agri", "manu", "serv"
)
node_set(dst.agri, "cc.VA",
  type = "SCES", es = 0.5, alpha = 1,
  beta = prop.table(c(500, 190)),
  "lab", "cap"
)

dst.manu &lt;- node_new("output",
  type = "SCES", es = 0, alpha = 1,
  beta = prop.table(c(300 + 400 + 420, 250 + 230)),
  "cc.II", "cc.VA"
)
node_set(dst.manu, "cc.II",
  type = "SCES", es = 0, alpha = 1,
  beta = prop.table(c(300, 400, 420)),
  "agri", "manu", "serv"
)
node_set(dst.manu, "cc.VA",
  type = "SCES", es = 0.5, alpha = 1,
  beta = prop.table(c(250, 230)),
  "lab", "cap"
)

dst.serv &lt;- node_new("output",
  type = "SCES", es = 0, alpha = 1,
  beta = prop.table(c(150 + 250 + 240, 330 + 180)),
  "cc.II", "cc.VA"
)
node_set(dst.serv, "cc.II",
  type = "SCES", es = 0, alpha = 1,
  beta = prop.table(c(150, 250, 240)),
  "agri", "manu", "serv"
)
node_set(dst.serv, "cc.VA",
  type = "SCES", es = 0.5, alpha = 1,
  beta = prop.table(c(330, 180)),
  "lab", "cap"
)

dst.consumer &lt;- node_new("util",
  type = "SCES", es = 0.5, alpha = 1,
  beta = prop.table(c(280, 550, 350)),
  "agri", "manu", "serv"
)

dst.investor &lt;- node_new("util",
  type = "SCES", es = 0.5, alpha = 1,
  beta = prop.table(c(70, 320, 110)),
  "agri", "manu", "serv"
)

ge2.benchmark &lt;- sdm2(list(dst.agri, dst.manu, dst.serv, dst.consumer, dst.investor),
  B = matrix(c(
    1, 0, 0, 0, 0,
    0, 1, 0, 0, 0,
    0, 0, 1, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0
  ), 5, 5, TRUE),
  S0Exg = {
    S0Exg &lt;- matrix(NA, 5, 5)
    S0Exg[4:5, 4] &lt;- c(1080, 600) * (1180 / (1180 + 500))
    S0Exg[4:5, 5] &lt;- c(1080, 600) * (500 / (1180 + 500))
    S0Exg
  },
  names.commodity = c("agri", "manu", "serv", "lab", "cap"),
  names.agent = c("agri", "manu", "serv", "consumer", "investor"),
  numeraire = c("lab")
)

addmargins(ge2.benchmark$D)
addmargins(ge2.benchmark$S)

</code></pre>

<hr>
<h2 id='gemInputOutputTable_7_4'>A General Equilibrium Model based on a 7×4 (Standard) Input-Output Table</h2><span id='topic+gemInputOutputTable_7_4'></span>

<h3>Description</h3>

<p>This is a general equilibrium model based on a 7×4 standard input-output table.
There is no negative number in this standard input-output table,
and both the input and output parts are 7×4 matrices.
The standard input-output table consists of input and output parts with the same dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemInputOutputTable_7_4(
  IT,
  OT,
  es.agri = 0,
  es.manu = 0,
  es.serv = 0,
  es.hh = 0,
  es.VA.agri = 0.25,
  es.VA.manu = 0.5,
  es.VA.serv = 0.8,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemInputOutputTable_7_4_+3A_it">IT</code></td>
<td>
<p>the input part of the input-output table in the base period (unit: trillion yuan).</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_7_4_+3A_ot">OT</code></td>
<td>
<p>the output part of the input-output table in the base period (unit: trillion yuan).</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_7_4_+3A_es.agri">es.agri</code>, <code id="gemInputOutputTable_7_4_+3A_es.manu">es.manu</code>, <code id="gemInputOutputTable_7_4_+3A_es.serv">es.serv</code></td>
<td>
<p>the elasticity of substitution between the intermediate input
and the value-added input of the agriculture sector, manufacturing sector and service sector.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_7_4_+3A_es.hh">es.hh</code></td>
<td>
<p>the elasticity of substitution among products consumed by the household sector.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_7_4_+3A_es.va.agri">es.VA.agri</code>, <code id="gemInputOutputTable_7_4_+3A_es.va.manu">es.VA.manu</code>, <code id="gemInputOutputTable_7_4_+3A_es.va.serv">es.VA.serv</code></td>
<td>
<p>the elasticity of substitution between labor input and capital input
of the agriculture sector, manufacturing sector and service sector.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_7_4_+3A_...">...</code></td>
<td>
<p>arguments to be transferred to the function sdm of the package CGE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a 7×4 input-output table, this model calculates
the corresponding general equilibrium.
This input-output table contains 3 production sectors and 1 household.
The household consumes products and supplies labor, capital, stock and tax receipt.
Generally speaking, the value of the elasticity of substitution in this model should be between 0 and 1.
</p>


<h3>Value</h3>

<p>A general equilibrium, which is a list with the following elements:
</p>

<ul>
<li><p> p - the price vector with labor as numeraire.
</p>
</li>
<li><p> D - the demand matrix, also called the input table. Wherein the benchmark prices are used.
</p>
</li>
<li><p> DV - the demand value matrix, also called the value input table. Wherein the current price is used.
</p>
</li>
<li><p> SV - the supply value matrix, also called the value output table. Wherein the current price is used.
</p>
</li>
<li><p> value.added - the value-added of the three production sectors.
</p>
</li>
<li><p> dstl - the demand structure tree list of sectors.
</p>
</li>
<li><p> ... - some elements returned by the sdm2 function.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
IT2017 &lt;- matrix(c(
  1.47, 6.47, 0.57, 2.51,
  2.18, 76.32, 12.83, 44.20,
  0.82, 19.47, 23.33, 35.61,
  6.53, 13.92, 21.88, 0,
  0.23, 4.05, 6.76, 0,
  0, 6.43, 3.40, 0,
  0.13, 8.87, 10.46, 0
), 7, 4, TRUE)

OT2017 &lt;- matrix(c(
  11.02, 0, 0, 0,
  0, 135.53, 0, 0,
  0, 0, 79.23, 0,
  0, 0, 0, 42.33,
  0, 0, 0, 11.04,
  0.34, 0, 0, 9.49,
  0, 0, 0, 19.46
), 7, 4, TRUE)

rownames(IT2017) &lt;- rownames(OT2017) &lt;-
  c("agri", "manu", "serv", "lab", "cap", "tax", "dividend")
colnames(IT2017) &lt;- colnames(OT2017) &lt;-
  c("sector.agri", "sector.manu", "sector.serv", "sector.hh")

ge &lt;- gemInputOutputTable_7_4(
  IT = IT2017,
  OT = OT2017
)

#### labor supply reduction
OTLSR &lt;- OT2017
OTLSR["lab", "sector.hh"] &lt;- OTLSR["lab", "sector.hh"] * 0.9
geLSR &lt;- gemInputOutputTable_7_4(
  IT = IT2017,
  OT = OTLSR
)

geLSR$z / ge$z
geLSR$p / ge$p

#### capital accumulation
OTCA &lt;- OT2017
OTCA["cap", "sector.hh"] &lt;- OTCA["cap", "sector.hh"] * 1.1
geCA &lt;- gemInputOutputTable_7_4(
  IT = IT2017,
  OT = OTCA
)

geCA$z / ge$z
geCA$p / ge$p

#### technology progress
IT.TP &lt;- IT2017
IT.TP ["lab", "sector.manu"] &lt;-
  IT.TP ["lab", "sector.manu"] * 0.9

geTP &lt;- gemInputOutputTable_7_4(
  IT = IT.TP,
  OT = OT2017
)

geTP$z / ge$z
geTP$p / ge$p

##
IT.TP2 &lt;- IT.TP
IT.TP2 ["cap", "sector.manu"] &lt;-
  IT.TP2["cap", "sector.manu"] * 1.02
geTP2 &lt;- gemInputOutputTable_7_4(
  IT = IT.TP2,
  OT = OT2017
)

geTP2$z / ge$z
geTP2$p / ge$p

##
IT.TP3 &lt;- IT2017
IT.TP3 ["lab", "sector.manu"] &lt;-
  IT.TP3 ["lab", "sector.manu"] * 0.9
IT.TP3 ["lab", "sector.agri"] &lt;-
  IT.TP3 ["lab", "sector.agri"] * 0.8

geTP3 &lt;- gemInputOutputTable_7_4(
  IT = IT.TP3,
  OT = OT2017
)

geTP3$value.added / ge$value.added
prop.table(geTP3$value.added) - prop.table(ge$value.added)

#### demand structure change
IT.DSC &lt;- IT2017
IT.DSC["serv", "sector.hh"] &lt;- IT.DSC ["serv", "sector.hh"] * 1.2

geDSC &lt;- gemInputOutputTable_7_4(
  IT = IT.DSC,
  OT = OT2017
)

geDSC$z[1:3] / ge$z[1:3]
geDSC$p / ge$p

#### tax change
OT.TC &lt;- OT2017
OT.TC["tax", "sector.agri"] &lt;- OT.TC["tax", "sector.agri"] * 2

geTC &lt;- gemInputOutputTable_7_4(
  IT = IT2017,
  OT = OT.TC
)

geTC$z / ge$z
geTC$p / ge$p

##
IT.TC2 &lt;- IT2017
IT.TC2["tax", "sector.manu"] &lt;- IT.TC2["tax", "sector.manu"] * 0.8

geTC2 &lt;- gemInputOutputTable_7_4(
  IT = IT.TC2,
  OT = OT2017
)

geTC2$z / ge$z
geTC2$p / ge$p


</code></pre>

<hr>
<h2 id='gemInputOutputTable_8_8'>A General Equilibrium Model based on an 8×8 Input-Output Table</h2><span id='topic+gemInputOutputTable_8_8'></span>

<h3>Description</h3>

<p>This is a general equilibrium model based on a 8×8 input-output table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemInputOutputTable_8_8(
  IT,
  OT,
  es.agri = 0,
  es.manu = 0,
  es.serv = 0,
  es.CI = 0,
  es.FT = 0,
  es.VA.agri = 0.25,
  es.VA.manu = 0.5,
  es.VA.serv = 0.8,
  es.prodDM = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemInputOutputTable_8_8_+3A_it">IT</code></td>
<td>
<p>the input part of the input-output table in the base period (unit: trillion yuan).</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_8_8_+3A_ot">OT</code></td>
<td>
<p>the output part of the input-output table in the base period (unit: trillion yuan).</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_8_8_+3A_es.agri">es.agri</code>, <code id="gemInputOutputTable_8_8_+3A_es.manu">es.manu</code>, <code id="gemInputOutputTable_8_8_+3A_es.serv">es.serv</code></td>
<td>
<p>the elasticity of substitution between the intermediate input
and the value-added input of the agriculture sector, manufacturing sector and service sector.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_8_8_+3A_es.ci">es.CI</code></td>
<td>
<p>the elasticity of substitution among products used by the CI sector.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_8_8_+3A_es.ft">es.FT</code></td>
<td>
<p>the elasticity of substitution among exported products.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_8_8_+3A_es.va.agri">es.VA.agri</code>, <code id="gemInputOutputTable_8_8_+3A_es.va.manu">es.VA.manu</code>, <code id="gemInputOutputTable_8_8_+3A_es.va.serv">es.VA.serv</code></td>
<td>
<p>the elasticity of substitution between labor input and capital input
of the agriculture sector, manufacturing sector and service sector.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_8_8_+3A_es.proddm">es.prodDM</code></td>
<td>
<p>the elasticity of substitution between domestic product and imported product.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_8_8_+3A_...">...</code></td>
<td>
<p>arguments to be transferred to the function sdm of the package CGE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an 8×8 input-output table, this model calculates
the corresponding general equilibrium.
This input-output table contains 3 production sectors, 1 consumption and (temporarily unproductive) investment sector (CI sector), 1 foreign trade sector importing agriculture goods,
1 foreign trade sector importing manufacturing goods, 1 foreign trade sector importing service, 1 foreign trade sector importing bond.
There are 8 kinds of commodities (or subjects) in the table, i.e. agriculture product,
manufacturing product, service, labor, capital goods, tax, dividend and bond of ROW (i.e. the rest of the world).
The CI sector uses products and supplies labor, capital, stock and tax receipt.
Generally speaking, the value of the elasticity of substitution in this model should be between 0 and 1.
</p>


<h3>Value</h3>

<p>A general equilibrium, which is a list with the following elements:
</p>

<ul>
<li><p> p - the price vector with labor as numeraire.
</p>
</li>
<li><p> D - the demand matrix, also called the input table. Wherein the benchmark prices are used.
</p>
</li>
<li><p> DV - the demand value matrix, also called the value input table. Wherein the current price is used.
</p>
</li>
<li><p> SV - the supply value matrix, also called the value output table. Wherein the current price is used.
</p>
</li>
<li><p> value.added - the value-added of the three production sectors.
</p>
</li>
<li><p> dstl - the demand structure tree list of sectors.
</p>
</li>
<li><p> ... - some elements returned by the CGE::sdm function
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
IT17 &lt;- matrix(c(
  1.47, 6.47, 0.57, 2.99, 0.12 * 0.60 / (0.60 + 12.10 + 2.23 + 1.45),
  0.12 * 12.10 / (0.60 + 12.10 + 2.23 + 1.45),
  0.12 * 2.23 / (0.60 + 12.10 + 2.23 + 1.45),
  0.12 * 1.45 / (0.60 + 12.10 + 2.23 + 1.45),

  2.18, 76.32, 12.83, 43, 13.30 * 0.60 / (0.60 + 12.10 + 2.23 + 1.45),
  13.30 * 12.10 / (0.60 + 12.10 + 2.23 + 1.45),
  13.30 * 2.23 / (0.60 + 12.10 + 2.23 + 1.45),
  13.30 * 1.45 / (0.60 + 12.10 + 2.23 + 1.45),


  0.82, 19.47, 23.33, 34.88, 2.96 * 0.60 / (0.60 + 12.10 + 2.23 + 1.45),
  2.96 * 12.10 / (0.60 + 12.10 + 2.23 + 1.45),
  2.96 * 2.23 / (0.60 + 12.10 + 2.23 + 1.45),
  2.96 * 1.45 / (0.60 + 12.10 + 2.23 + 1.45),

  6.53, 13.92, 21.88, 0, 0, 0, 0, 0,
  0.23, 4.05, 6.76, 0, 0, 0, 0, 0,
  0, 6.43, 3.40, 0, 0, 0, 0, 0,
  0.13, 8.87, 10.46, 0, 0, 0, 0, 0,
  0, 0, 0, 1.45, 0, 0, 0, 0
), 8, 8, TRUE)

OT17 &lt;- matrix(c(
  11.02, 0, 0, 0, 0.60, 0, 0, 0,
  0, 135.53, 0, 0, 0, 12.10, 0, 0,
  0, 0, 79.23, 0, 0, 0, 2.23, 0,
  0, 0, 0, 42.33, 0, 0, 0, 0,
  0, 0, 0, 11.04, 0, 0, 0, 0,
  0.34, 0, 0, 9.49, 0, 0, 0, 0,
  0, 0, 0, 19.46, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 1.45
), 8, 8, TRUE)

rownames(IT17) &lt;- rownames(OT17) &lt;-
  c("agri", "manu", "serv", "lab", "cap", "tax", "dividend", "bond.ROW")
colnames(IT17) &lt;- colnames(OT17) &lt;- c(
  "sector.agri", "sector.manu", "sector.serv", "sector.CI",
  "sector.FT.agri", "sector.FT.manu", "sector.FT.serv", "sector.FT.bond.ROW"
)

# the benchmark equilibrium.
ge &lt;- gemInputOutputTable_8_8(
  IT = IT17,
  OT = OT17
)

#### technology progress.
IT.TP &lt;- IT17
IT.TP ["lab", "sector.manu"] &lt;-
  IT.TP ["lab", "sector.manu"] * 0.9

geTP &lt;- gemInputOutputTable_8_8(
  IT = IT.TP,
  OT = OT17
)

geTP$z / ge$z
geTP$p / ge$p
geTP$value.added
prop.table(geTP$value.added) - prop.table(ge$value.added)

#### capital accumulation.
OT.CA &lt;- OT17
OT.CA["cap", "sector.CI"] &lt;- OT.CA["cap", "sector.CI"] * 1.1
geCA &lt;- gemInputOutputTable_8_8(
  IT = IT17,
  OT = OT.CA
)

geCA$z / ge$z
geCA$p / ge$p
geCA$p
geCA$value.added
prop.table(geCA$value.added) - prop.table(ge$value.added)

#### tax change.
OT.TC &lt;- OT17
OT.TC["tax", "sector.agri"] &lt;- OT.TC["tax", "sector.agri"] * 2

geTC &lt;- gemInputOutputTable_8_8(
  IT = IT17,
  OT = OT.TC
)

geTC$z / ge$z
geTC$p / ge$p

##
IT.TC2 &lt;- IT17
IT.TC2["tax", "sector.manu"] &lt;- IT.TC2["tax", "sector.manu"] * 0.8

geTC2 &lt;- gemInputOutputTable_8_8(
  IT = IT.TC2,
  OT = OT17
)

geTC2$z / ge$z
geTC2$p / ge$p

</code></pre>

<hr>
<h2 id='gemInputOutputTable_easy_5_4'>An Easy General Equilibrium Model based on a 5×4 Input-Output Table (see Zhang Xin, 2017, Table 8.6.1)</h2><span id='topic+gemInputOutputTable_easy_5_4'></span>

<h3>Description</h3>

<p>This is a general equilibrium model based on a 5×4 input-output table (see Zhang Xin, 2017, Table 8.6.1).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemInputOutputTable_easy_5_4(
  IT = cbind(sector.agri = c(agri = 260, manu = 345, serv = 400, lab = 200, cap = 160),
    sector.manu = c(agri = 320, manu = 390, serv = 365, lab = 250, cap = 400),
    sector.serv = c(agri = 150, manu = 390, serv = 320, lab = 400, cap = 210), sector.hh
    = c(agri = 635, manu = 600, serv = 385, lab = 0, cap = 0)),
  supply.labor = 850,
  supply.capital = 770,
  es.agri = 0.2,
  es.manu = 0.3,
  es.serv = 0.1,
  es.VA.agri = 0.25,
  es.VA.manu = 0.5,
  es.VA.serv = 0.8
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemInputOutputTable_easy_5_4_+3A_it">IT</code></td>
<td>
<p>the input and consumption part of the input-output table.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_easy_5_4_+3A_supply.labor">supply.labor</code></td>
<td>
<p>the supply of labor.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_easy_5_4_+3A_supply.capital">supply.capital</code></td>
<td>
<p>the supply of capital.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_easy_5_4_+3A_es.agri">es.agri</code>, <code id="gemInputOutputTable_easy_5_4_+3A_es.manu">es.manu</code>, <code id="gemInputOutputTable_easy_5_4_+3A_es.serv">es.serv</code></td>
<td>
<p>the elasticity of substitution between the intermediate input
and the value-added input of the agriculture sector, manufacturing sector and service sector.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_easy_5_4_+3A_es.va.agri">es.VA.agri</code>, <code id="gemInputOutputTable_easy_5_4_+3A_es.va.manu">es.VA.manu</code>, <code id="gemInputOutputTable_easy_5_4_+3A_es.va.serv">es.VA.serv</code></td>
<td>
<p>the elasticity of substitution between labor input and capital input
of the agriculture sector, manufacturing sector and service sector.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given a 5×4 input-output table (e.g., see Zhang Xin, 2017, Table 8.6.1), this model calculates
the corresponding general equilibrium.
This input-output table contains 3 production sectors and one household.
The household consumes products and supplies labor and capital.
</p>


<h3>Value</h3>

<p>A general equilibrium, which is a list with the following elements:
</p>

<ul>
<li><p> p - the price vector with labor as numeraire.
</p>
</li>
<li><p> D - the demand matrix, also called the input table. Wherein the benchmark prices are used.
</p>
</li>
<li><p> DV - the demand value matrix, also called the value input table. Wherein the current price is used.
</p>
</li>
<li><p> SV - the supply value matrix, also called the value output table. Wherein the current price is used.
</p>
</li>
<li><p> ... - some elements returned by the CGE::sdm function
</p>
</li></ul>



<h3>References</h3>

<p>Zhang Xin (2017, ISBN: 9787543227637) Principles of Computable General Equilibrium Modeling and Programming (Second Edition). Shanghai: Gezhi Press. (In Chinese)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sector.agri &lt;- c(260, 345, 400, 200, 160)
sector.manu &lt;- c(320, 390, 365, 250, 400)
sector.serv &lt;- c(150, 390, 320, 400, 210)
sector.hh &lt;- c(635, 600, 100, 0, 0)

IT &lt;- cbind(sector.agri, sector.manu, sector.serv, sector.hh)
rownames(IT) &lt;- c("agri", "manu", "serv", "lab", "cap")

ge &lt;- gemInputOutputTable_easy_5_4(IT)

####
ge &lt;- gemInputOutputTable_easy_5_4(supply.capital = 1870)
prop.table(ge$z[1:3])
</code></pre>

<hr>
<h2 id='gemInputOutputTable_Leontief_3_3'>A Leontief-type General Equilibrium Model based on a 3×3 Input-Output Table</h2><span id='topic+gemInputOutputTable_Leontief_3_3'></span>

<h3>Description</h3>

<p>Given a 3×3 input-output table (e.g., see Zhang Xin, 2017, Table 2.2.2), this model can be
used to calculate the corresponding equilibrium.
This input-output table contains two firms and one household.
The household consumes products and supplies labor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemInputOutputTable_Leontief_3_3(
  input = matrix(c(200, 300, 100, 150, 320, 530, 250, 380, 0), 3, 3, TRUE),
  output = c(600, 1000, 630)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemInputOutputTable_Leontief_3_3_+3A_input">input</code></td>
<td>
<p>the input matrix in the base period.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_Leontief_3_3_+3A_output">output</code></td>
<td>
<p>a vector consisting of the product outputs and labor supply in the base period.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A general equilibrium, which is a list with the following elements:
</p>

<ul>
<li><p> p - the price vector with labor as numeraire.
</p>
</li>
<li><p> D - the demand matrix, also called the input table. Wherein the benchmark prices are used.
</p>
</li>
<li><p> DV - the demand value matrix, also called the value input table. Wherein the current price is used.
</p>
</li>
<li><p> SV - the supply value matrix, also called the value output table. Wherein the current price is used.
</p>
</li>
<li><p> ... - some elements returned by the CGE::sdm function
</p>
</li></ul>



<h3>References</h3>

<p>Zhang Xin. (2017, ISBN: 9787543227637). Principles of Computable General Equilibrium Modeling and Programming (Second Edition). Shanghai: Gezhi Press. (In Chinese)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 75
gemInputOutputTable_Leontief_3_3(
  input = matrix(c(
    200, 300, 100,
    x, 320, 530,
    250, 380, 0
  ), 3, 3, TRUE),
  output = c(600, 1000, 630)
)
</code></pre>

<hr>
<h2 id='gemInputOutputTable_SCES_3_3'>A SCES-type General Equilibrium Model based on an Input-Output Table.</h2><span id='topic+gemInputOutputTable_SCES_3_3'></span>

<h3>Description</h3>

<p>Given a 3×3 input-output table (e.g., see Zhang Xin, 2017, Table 2.2.2), this model can be
used to calculate the corresponding equilibrium.
This input-output table contains two firms and one household.
The household consumes products and supplies labor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemInputOutputTable_SCES_3_3(
  input = matrix(c(200, 300, 100, 150, 320, 530, 250, 380, 0), 3, 3, TRUE),
  output = c(600, 1000, 630),
  es = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemInputOutputTable_SCES_3_3_+3A_input">input</code></td>
<td>
<p>the input matrix in the base period.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_SCES_3_3_+3A_output">output</code></td>
<td>
<p>a vector consisting of the product outputs and labor supply in the base period.</p>
</td></tr>
<tr><td><code id="gemInputOutputTable_SCES_3_3_+3A_es">es</code></td>
<td>
<p>a scalar, which is the elasticity of substitution between the
inputs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A general equilibrium, which is a list with the following elements:
</p>

<ul>
<li><p> p - the price vector with labor as numeraire.
</p>
</li>
<li><p> D - the demand matrix, also called the input table. Wherein the benchmark prices are used.
</p>
</li>
<li><p> DV - the demand value matrix, also called the value input table. Wherein the current price is used.
</p>
</li>
<li><p> SV - the supply value matrix, also called the value output table. Wherein the current price is used.
</p>
</li>
<li><p> ... - some elements returned by the CGE::sdm function
</p>
</li></ul>



<h3>References</h3>

<p>Zhang Xin. (2017, ISBN: 9787543227637). Principles of Computable General Equilibrium Modeling and Programming (Second Edition). Shanghai: Gezhi Press. (In Chinese)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 75
gemInputOutputTable_SCES_3_3(
  input = matrix(c(
    200, 300, 100,
    x, 320, 530,
    250, 380, 0
  ), 3, 3, TRUE),
  output = c(600, 1000, 630),
  es = 0.5
)
</code></pre>

<hr>
<h2 id='gemInstantaneousEquilibriumPath_StickyDecisions'>Some Examples of Instantaneous Equilibrium Paths with Sticky Decisions</h2><span id='topic+gemInstantaneousEquilibriumPath_StickyDecisions'></span>

<h3>Description</h3>

<p>Some examples of instantaneous equilibrium paths with sticky decisions of a firm, that is,
the firm sluggishly adjusts its technology in response to price changes.
</p>
<p>Under the assumption of (complete) rationality, economic agents will make decisions that are most beneficial to them based on the information they have.
If the information does not change, then the decision will not change.
However, under the assumption of bounded rationality, the decisions made by economic agents may not be optimal.
They may follow some simple rules-of-thumb, and might adjust their previous decisions sluggishly according to the changes in information,
even though they have the capability to adjust flexibly,
so that the new decisions are better than the old ones under the new information.
Hence the current decision is not necessarily the optimal decision.
Even if the information does not change, it is still possible for agents to make further improvements to this decision in the next period.
It can also be said that in this case, the decision maker's decision is sticky, that is, it only makes limited improvements to the previous decision based on new information,
rather than directly adjusting to the optimal decision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemInstantaneousEquilibriumPath_StickyDecisions(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemInstantaneousEquilibriumPath_StickyDecisions_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>See Also</h3>


<p><code><a href="#topic+policyMarketClearingPrice">policyMarketClearingPrice</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- function(stickiness.firm = 0) {
  dst.firm &lt;- node_new("output",
    type = "Leontief", a = c(1 - stickiness.firm, stickiness.firm),
    "cc1", "cc2"
  )
  node_set(dst.firm, "cc1",
    type = "CD", alpha = 5,
    beta = c(0.5, 0.5),
    "prod", "lab"
  )
  node_set(dst.firm, "cc2",
    type = "CD", alpha = 5,
    beta = c(0.5, 0.5),
    "prod", "lab"
  )

  dst.consumer &lt;- node_new("utility",
    type = "CD", alpha = 1,
    beta = c(0.5, 0.5),
    "prod", "lab"
  )

  ge &lt;- sdm2(
    A = list(dst.firm, dst.consumer),
    B = diag(c(1, 0)),
    S0Exg = {
      S0Exg &lt;- matrix(NA, 2, 2)
      S0Exg[2, 2] &lt;- 100
      S0Exg
    },
    names.commodity = c("prod", "lab"),
    names.agent = c("firm", "consumer"),
    numeraire = "lab",
    maxIteration = 1,
    numberOfPeriods = 20,
    policy = list(
      function(time, A, state) {
        if (time &gt; 1) {
          node_set(A[[1]], "cc2",
            type = "Leontief", a = state$last.A[, 1]
          )
        }
      },
      policyMarketClearingPrice
    ),
    ts = TRUE
  )

  print(ge$p)
  print(ge$z)
  par(mfrow = c(1, 2))
  matplot(ge$ts.p, type = "l")
  matplot(ge$ts.z, type = "l")
}

f()
f(stickiness.firm = 0.8)


</code></pre>

<hr>
<h2 id='gemIntertemporal_1_2'>An Example of a 1-by-2 Intertemporal Equilibrium Model</h2><span id='topic+gemIntertemporal_1_2'></span>

<h3>Description</h3>

<p>An example of an intertemporal equilibrium model with one type of commodity (i.e., product) and
two types of agents (i.e., a firm with an AK production function and a consumer).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_1_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_1_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
eis &lt;- 0.5 # the elasticity of intertemporal substitution of the consumer
Gamma.beta &lt;- 0.97 # the subjective discount factor of the consumer
alphaK &lt;- 1.1 # the parameter of the AK production function

np &lt;- 5 # the number of economic periods

n &lt;- np # the number of commodity kinds
m &lt;- np # the number of agent kinds

names.commodity &lt;- paste0("prod", 1:np)
names.agent &lt;- c(paste0("firm", 1:(np - 1)), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("prod", 1:np), "consumer"] &lt;- 100

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}

dstl.firm &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "Leontief",
    a = 1 / alphaK,
    paste0("prod", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "CES", es = eis,
  alpha = 1, beta = prop.table(Gamma.beta^(1:np)),
  paste0("prod", 1:np)
)

ge &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "prod1"
)

ge$p
ge$z
ge$D
ge$S
growth_rate(ge$D[, m])
(Gamma.beta * alphaK)^eis - 1

</code></pre>

<hr>
<h2 id='gemIntertemporal_2_2'>Some Examples of a 2-by-2 Intertemporal Equilibrium Model</h2><span id='topic+gemIntertemporal_2_2'></span>

<h3>Description</h3>

<p>Some examples of an intertemporal equilibrium model with two types of commodities and
two types of agents.
</p>
<p>In these examples, there is an np-period-lived consumer maximizing intertemporal utility,
and there is a type of firm which produces from period 1 to np-1.
There are two types of commodities, i.e. product and labor.
Assume the consumer has some product in the first period.
That is, the product supply in the first period is an exogenous variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_2_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_2_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an example with a Cobb-Douglas intertemporal utility function
np &lt;- 5 # the number of economic periods
y1 &lt;- 150 # the initial product supply

n &lt;- 2 * np - 1 # the number of commodity kinds
m &lt;- np # the number of agent kinds

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:(np - 1)))
names.agent &lt;- c(paste0("firm", 1:(np - 1)), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:(np - 1)), "consumer"] &lt;- 100
S0Exg["prod1", "consumer"] &lt;- y1

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}

dstl.firm &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "CD",
    alpha = 2, beta = c(0.5, 0.5),
    paste0("prod", k), paste0("lab", k)
  )
}

dst.consumer.CD &lt;- node_new(
  "util",
  type = "CD",
  alpha = 1, beta = prop.table(rep(1, np)),
  paste0("prod", 1:np)
)

f &lt;- function(dstl) {
  sdm2(
    A = dstl,
    B = B,
    S0Exg = S0Exg,
    names.commodity = names.commodity,
    names.agent = names.agent,
    numeraire = "prod1",
    ts = TRUE
  )
}

ge &lt;- f(c(dstl.firm, dst.consumer.CD))

ge$p
ge$z
ge$D
ge$S
ge$DV
ge$SV

## an example with a Leontief intertemporal utility function
dst.consumer.Leontief &lt;- node_new(
  "util",
  type = "Leontief",
  a = rep(1, np),
  paste0("prod", 1:np)
)

ge2 &lt;- f(c(dstl.firm, dst.consumer.Leontief))

ge2$p
ge2$z
ge2$D
ge2$S
ge2$DV
ge2$SV

## Assume that the consumer has a CES (i.e. CRRA) intertemporal utility function.
# eis is the elasticity of intertemporal substitution.
# Gamma.beta is the subjective discount factor.
f2 &lt;- function(eis = 1, Gamma.beta = 1, head.tail.adjustment = "none") {
  dst.consumer &lt;- node_new(
    "util",
    type = "CES", es = eis,
    alpha = 1, beta = prop.table(Gamma.beta^(1:np)),
    paste0("prod", 1:np)
  )

  ge &lt;- sdm2(
    A = c(dstl.firm, dst.consumer),
    B = B,
    S0Exg = S0Exg,
    names.commodity = names.commodity,
    names.agent = names.agent,
    numeraire = "prod1",
    ts = TRUE,
    policy = makePolicyHeadTailAdjustment(head.tail.adjustment, np = np)
  )

  list(
    p = ge$p, z = ge$z,
    D = addmargins(ge$D, 2), S = addmargins(ge$S, 2),
    DV = addmargins(ge$DV), SV = addmargins(ge$SV)
  )
}

f2(Gamma.beta = 0.9)
f2(Gamma.beta = 0.9, head.tail.adjustment = "both") # the steady state in the worldsheet
f2(Gamma.beta = 1.25, head.tail.adjustment = "both") # the steady state in the worldsheet
f2(eis = 2, Gamma.beta = 0.9)

</code></pre>

<hr>
<h2 id='gemIntertemporal_3_3'>Some Examples of Intertemporal Models with One Consumer and Two Types of Firms</h2><span id='topic+gemIntertemporal_3_3'></span>

<h3>Description</h3>

<p>Some examples of intertemporal models with one consumer and two types of firms.
There are three types of commodities (i.e. corn, iron and labor).
The consumer may consume corn and iron in each period, and may have a nested intertemporal utility function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_3_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_3_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Zen Xiangjin (1995, ISBN: 7030046560). Basics of Economic Cybernetics. Beijing: Science Press. (In Chinese)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an example with a nested intertemporal utility function
np &lt;- 5 # the number of economic periods

n &lt;- 3 * np - 1 # the number of commodity kinds
m &lt;- 2 * (np - 1) + 1 # the number of agent kinds

names.commodity &lt;- c(
  paste0("corn", 1:np),
  paste0("iron", 1:np),
  paste0("lab", 1:(np - 1))
)
names.agent &lt;- c(
  paste0("firm.corn", 1:(np - 1)),
  paste0("firm.iron", 1:(np - 1)),
  "consumer"
)

## the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:(np - 1)), "consumer"] &lt;- 100
S0Exg["corn1", "consumer"] &lt;- 25
S0Exg["iron1", "consumer"] &lt;- 100

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("corn", k + 1), paste0("firm.corn", k)] &lt;-
    B[paste0("iron", k + 1), paste0("firm.iron", k)] &lt;- 1
}

dstl.firm.corn &lt;- dstl.firm.iron &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm.corn[[k]] &lt;- node_new(
    "prod",
    type = "CD", alpha = 1, beta = c(0.5, 0.5),
    paste0("iron", k), paste0("lab", k)
  )

  dstl.firm.iron[[k]] &lt;- node_new(
    "prod",
    type = "CD", alpha = 2, beta = c(0.5, 0.5),
    paste0("iron", k), paste0("lab", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1,
  beta = prop.table(rep(1, np)),
  paste0("cc", 1:np)
)
for (k in 1:np) {
  node_set(
    dst.consumer,
    paste0("cc", k),
    type = "CD", alpha = 1, beta = c(0.5, 0.5),
    paste0("corn", k), paste0("iron", k)
  )
}

ge &lt;- sdm2(
  A = c(dstl.firm.corn, dstl.firm.iron, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "lab1",
  ts = TRUE
)

ge$p
ge$z
ge$D
ge$S
ge$DV
ge$SV

#### an example with a non-nested intertemporal utility function
np &lt;- 3 # the number of economic periods

## There are np types of corn, np-1 types of iron and np-1 types of labor.
## There are np-1 corn firms, np-2 iron firms and one consumer.
n &lt;- 3 * np - 2
m &lt;- 2 * np - 2

names.commodity &lt;- c(
  paste0("corn", 1:np),
  paste0("iron", 1:(np - 1)),
  paste0("lab", 1:(np - 1))
)
names.agent &lt;- c(
  paste0("firm.corn", 1:(np - 1)),
  paste0("firm.iron", 1:(np - 2)),
  "consumer"
)

## the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:(np - 1)), "consumer"] &lt;- 100
S0Exg["corn1", "consumer"] &lt;- 25
S0Exg["iron1", "consumer"] &lt;- 100

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("corn", k + 1), paste0("firm.corn", k)] &lt;- 1
}
for (k in 1:(np - 2)) {
  B[paste0("iron", k + 1), paste0("firm.iron", k)] &lt;- 1
}

dstl.firm.corn &lt;- dstl.firm.iron &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm.corn[[k]] &lt;- node_new(
    "prod",
    type = "CD", alpha = 1, beta = c(0.5, 0.5),
    paste0("iron", k), paste0("lab", k)
  )
}

for (k in seq_along(np:(2 * np - 3))) {
  dstl.firm.iron[[k]] &lt;- node_new(
    "prod",
    type = "CD", alpha = 2, beta = c(0.5, 0.5),
    paste0("iron", k), paste0("lab", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = prop.table(rep(1, np)),
  paste0("corn", 1:np)
)

ge &lt;- sdm2(
  A = c(dstl.firm.corn, dstl.firm.iron, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "lab1",
  ts = TRUE
)

ge$p
ge$z
ge$D
ge$S
ge$DV
ge$SV

#### an example of Zeng (1995, page 227)
ic1 &lt;- 1 / 10 # input coefficient
ic2 &lt;- 1 / 7
dc1 &lt;- 2 / 3 # depreciation coefficient
dc2 &lt;- 9 / 10

ge &lt;- sdm2(
  A = {
    # corn, iron1, iron2, iron3, iron4
    a1.1 &lt;- c(0, ic1, 0, 0, 0)
    a1.2 &lt;- c(0, ic2, 0, 0, 0)
    a2.1 &lt;- c(0, 0, ic1, 0, 0)
    a2.2 &lt;- c(0, 0, ic2, 0, 0)
    a3.1 &lt;- c(0, 0, 0, ic1, 0)
    a3.2 &lt;- c(0, 0, 0, ic2, 0)
    a4.1 &lt;- c(0, 0, 0, 0, ic1)
    a4.2 &lt;- c(0, 0, 0, 0, ic2)

    a.consumer &lt;- c(1, 0, 0, 0, 0)

    cbind(a1.1, a1.2, a2.1, a2.2, a3.1, a3.2, a4.1, a4.2, a.consumer)
  },
  B = {
    b1.1 &lt;- c(1, 0, ic1 * dc1, 0, 0)
    b1.2 &lt;- c(1, 0, ic2 * dc2, 0, 0)
    b2.1 &lt;- c(1, 0, 0, ic1 * dc1, 0)
    b2.2 &lt;- c(1, 0, 0, ic2 * dc2, 0)
    b3.1 &lt;- c(1, 0, 0, 0, ic1 * dc1)
    b3.2 &lt;- c(1, 0, 0, 0, ic2 * dc2)
    b4.1 &lt;- c(1, 0, 0, 0, 0)
    b4.2 &lt;- c(1, 0, 0, 0, 0)
    b.consumer &lt;- c(0, 0, 0, 0, 0)

    cbind(b1.1, b1.2, b2.1, b2.2, b3.1, b3.2, b4.1, b4.2, b.consumer)
  },
  S0Exg = {
    tmp &lt;- matrix(NA, 5, 9)
    tmp[2, 9] &lt;- 100
    tmp
  },
  names.commodity = c("corn", paste0("iron", 1:4)),
  names.agent = c(paste0("firm", 1:8), "consumer"),
  numeraire = "corn",
  policy = makePolicyMeanValue(30),
  priceAdjustmentVelocity = 0.05,
  maxIteration = 1,
  numberOfPeriods = 1000,
  ts = TRUE
)

matplot(ge$ts.z, type = "l")

ge$p
ge$z
ge$D
ge$S

</code></pre>

<hr>
<h2 id='gemIntertemporal_3_4'>An Intertemporal Model with Two Consumers and Two Types of Firms</h2><span id='topic+gemIntertemporal_3_4'></span>

<h3>Description</h3>

<p>An intertemporal (timeline) model with two consumers and two types of firms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_3_4(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_3_4_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an example with Cobb-Douglas production functions and intertemporal utility functions.
np &lt;- 5 # the number of economic periods

n &lt;- 3 * np - 1 # the number of commodity kinds
m &lt;- 2 * (np - 1) + 2 # the number of agent kinds

names.commodity &lt;- c(
  paste0("corn", 1:np),
  paste0("iron", 1:np),
  paste0("lab", 1:(np - 1))
)
names.agent &lt;- c(
  paste0("firm.corn", 1:(np - 1)),
  paste0("firm.iron", 1:(np - 1)),
  "consumer1", "consumer2"
)

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:(np - 1)), c("consumer1", "consumer2")] &lt;- 100
S0Exg["corn1", c("consumer1", "consumer2")] &lt;- 25
S0Exg["iron1", c("consumer1", "consumer2")] &lt;- 100

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("corn", k + 1), paste0("firm.corn", k)] &lt;-
    B[paste0("iron", k + 1), paste0("firm.iron", k)] &lt;- 1
}

dstl.firm.corn &lt;- dstl.firm.iron &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm.corn[[k]] &lt;- node_new(
    "prod",
    type = "CD", alpha = 1, beta = c(0.5, 0.5),
    paste0("iron", k), paste0("lab", k)
  )

  dstl.firm.iron[[k]] &lt;- node_new(
    "prod",
    type = "CD", alpha = 2, beta = c(0.5, 0.5),
    paste0("iron", k), paste0("lab", k)
  )
}

dst.consumer1 &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = prop.table(rep(1, np)),
  paste0("corn", 1:np)
)

dst.consumer2 &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = prop.table(rep(1, np)),
  paste0("cc", 1:np)
)
for (k in 1:np) {
  node_set(
    dst.consumer2,
    paste0("cc", k),
    type = "CD", alpha = 1, beta = c(0.5, 0.5),
    paste0("corn", k), paste0("iron", k)
  )
}

ge &lt;- sdm2(
  A = c(dstl.firm.corn, dstl.firm.iron, dst.consumer1, dst.consumer2),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "lab1",
  ts = TRUE
)

ge$p
ge$z
ge$D
ge$S
ge$DV
ge$SV

</code></pre>

<hr>
<h2 id='gemIntertemporal_4_4'>An Intertemporal Model with Land, Two Consumers and Two Types of Firms</h2><span id='topic+gemIntertemporal_4_4'></span>

<h3>Description</h3>

<p>An (intertemporal) timeline model with two consumers (i.e. a laborer and a landowner) and two types of firms
(i.e. wheat producers and iron producers).
There are four commodities in the model, namely wheat, iron, labor and land.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_4_4(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_4_4_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
np &lt;- 15 # the number of economic periods
alpha.firm.wheat &lt;- rep(5, np - 1)
alpha.firm.iron &lt;- rep(5, np - 1)

Gamma.beta &lt;- 0.97 # 1, 1.03 # the subjective discount factor of consumers
eis &lt;- 0.5 # the elasticity of intertemporal substitution  of consumers
y1.wheat &lt;- 100 # 126, 129.96
y1.iron &lt;- 30 # 40.59, 43.47

gr &lt;- 0 # the growth rate in the steady state equilibrium

last.beta.laborer &lt;- 0
last.beta.landowner &lt;- 0

names.commodity &lt;- c(
  paste0("wheat", 1:np),
  paste0("iron", 1:np),
  paste0("lab", 1:(np - 1)),
  paste0("land", 1:(np - 1))
)

names.agent &lt;- c(
  paste0("firm", 1:(np - 1), ".wheat"), paste0("firm", 1:(np - 1), ".iron"),
  "laborer", "landowner"
)

f &lt;- function(policy = NULL) {
  n &lt;- length(names.commodity) # the number of commodity kinds
  m &lt;- length(names.agent) # the number of agent kinds

  # the exogenous supply matrix.
  S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
  S0Exg["wheat1", "laborer"] &lt;- y1.wheat
  S0Exg["iron1", "landowner"] &lt;- y1.iron
  S0Exg[paste0("lab", 1:(np - 1)), "laborer"] &lt;- 100 * (1 + gr)^(0:(np - 2)) # the supply of labor
  S0Exg[paste0("land", 1:(np - 1)), "landowner"] &lt;- 100 * (1 + gr)^(0:(np - 2)) # the supply of land

  # the output coefficient matrix.
  B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
  for (k in 1:(np - 1)) {
    B[paste0("wheat", k + 1), paste0("firm", k, ".wheat")] &lt;- 1
    B[paste0("iron", k + 1), paste0("firm", k, ".iron")] &lt;- 1
  }

  dstl.firm.wheat &lt;- dstl.firm.iron &lt;- list()
  for (k in 1:(np - 1)) {
    dstl.firm.wheat[[k]] &lt;- node_new(
      "prod",
      type = "CES", es = 0.8,
      alpha = alpha.firm.wheat[k], beta = c(0.2, 0.4, 0.4),
      paste0("iron", k), paste0("lab", k), paste0("land", k)
    )

    dstl.firm.iron[[k]] &lt;- node_new(
      "prod",
      type = "CES", es = 0.8,
      alpha = alpha.firm.iron[k], beta = c(0.4, 0.4, 0.2),
      paste0("iron", k), paste0("lab", k), paste0("land", k)
    )
  }

  tmp.beta &lt;- Gamma.beta^(1:(np - 1))
  tmp.beta &lt;- tmp.beta / tmp.beta[np - 1]
  tmp.beta &lt;- c(tmp.beta, last.beta.laborer)
  dst.laborer &lt;- node_new(
    "util",
    type = "CES", es = eis,
    alpha = 1, beta = prop.table(tmp.beta),
    paste0("cc", 1:(np - 1)), paste0("wheat", np)
  )
  for (k in 1:(np - 1)) {
    node_set(dst.laborer, paste0("cc", k),
             type = "CES", es = 1,
             alpha = 1, beta = c(0.4, 0.4, 0.2),
             paste0("wheat", k), paste0("lab", k), paste0("land", k)
    )
  }

  tmp.beta &lt;- Gamma.beta^(1:(np - 1))
  tmp.beta &lt;- tmp.beta / tmp.beta[np - 1]
  tmp.beta &lt;- c(tmp.beta, last.beta.landowner)
  dst.landowner &lt;- node_new(
    "util",
    type = "CES", es = eis,
    alpha = 1, beta = prop.table(tmp.beta),
    paste0("cc", 1:(np - 1)), paste0("iron", np)
  )
  for (k in 1:(np - 1)) {
    node_set(dst.landowner, paste0("cc", k),
             type = "CES", es = 1,
             alpha = 1, beta = c(0.2, 0.4, 0.4),
             paste0("wheat", k), paste0("lab", k), paste0("land", k)
    )
  }
  ge &lt;- sdm2(
    A = c(dstl.firm.wheat, dstl.firm.iron, Clone(dst.laborer), Clone(dst.landowner)),
    B = B,
    S0Exg = S0Exg,
    names.commodity = names.commodity,
    names.agent = names.agent,
    numeraire = "lab1",
    policy = policy,
    ts = TRUE,
    maxIteration = 1,
    numberOfPeriods = 1000,
    priceAdjustmentVelocity = 0.05
  )

  plot(ge$z[1:(np - 1)],
       type = "o", pch = 20, ylab = "production level",
       xlab = "time", ylim = range(ge$z[1:(2 * np - 2)])
  )
  lines(ge$z[np:(2 * np - 2)], type = "o", pch = 21)
  legend("bottom", c("wheat", "iron"), pch = 20:21)

  invisible(ge)
}

ge &lt;- f()
plot(2:(np - 1), ge$z[1:(np - 2)],
     type = "o", pch = 20, ylab = "production output",
     xlab = "time", ylim = range(ge$z[1:(2 * np - 2)])
)
lines(2:(np - 1), ge$z[np:(2 * np - 3)], type = "o", pch = 21)
legend("bottom", c("wheat", "iron"), pch = 20:21)

## Compute the steady-state equilibrium based on head and tail adjustments.
policyHeadAdjustment &lt;- makePolicyHeadAdjustment(
  ind = rbind(
    c(
      which(names.commodity == "wheat1"), which(names.agent == "laborer"),
      which(names.commodity == "wheat2"), which(names.agent == "firm1.wheat")
    ),
    c(
      which(names.commodity == "iron1"), which(names.agent == "landowner"),
      which(names.commodity == "iron2"), which(names.agent == "firm1.iron")
    )
  ),
  gr = gr
)
policyTailAdjustment &lt;- makePolicyTailAdjustment(
  ind = rbind(
    c(which(names.agent == paste0("firm", np - 1, ".wheat")), which(names.agent == "laborer")),
    c(which(names.agent == paste0("firm", np - 1, ".iron")), which(names.agent == "landowner"))
  ),
  gr = gr
)

f(list(policyHeadAdjustment, policyTailAdjustment))$z

## the corresponding sequential model with the same steady-state equilibrium.
dividend.rate &lt;- sserr(eis, Gamma.beta, prepaid = TRUE)

dst.firm.wheat &lt;- node_new("prod",
                           type = "FIN", rate = c(1, dividend.rate),
                           "cc1", "equity.share.wheat"
)
node_set(dst.firm.wheat, "cc1",
         type = "CES", es = 0.8,
         alpha = 5, beta = c(0.2, 0.4, 0.4),
         "iron", "lab", "land"
)

dst.firm.iron &lt;- node_new("prod",
                          type = "FIN", rate = c(1, dividend.rate),
                          "cc1", "equity.share.iron"
)
node_set(dst.firm.iron, "cc1",
         type = "CES", es = 0.8,
         alpha = 5, beta = c(0.4, 0.4, 0.2),
         "iron", "lab", "land"
)

dst.laborer &lt;- node_new("util",
                        type = "CES", es = 1,
                        alpha = 1, beta = c(0.4, 0.4, 0.2),
                        "wheat", "lab", "land"
)

dst.landowner &lt;- node_new("util",
                          type = "CES", es = 1,
                          alpha = 1, beta = c(0.2, 0.4, 0.4),
                          "wheat", "lab", "land"
)

ge &lt;- sdm2(
  A = list(dst.firm.wheat, dst.firm.iron, dst.laborer, dst.landowner),
  B = matrix(c(
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
  ), 6, 4, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA,
    NA, NA, NA, NA,
    NA, NA, 100, NA,
    NA, NA, NA, 100,
    NA, NA, 100, NA,
    NA, NA, NA, 100
  ), 6, 4, TRUE),
  names.commodity = c(
    "wheat", "iron", "lab", "land",
    "equity.share.wheat", "equity.share.iron"
  ),
  names.agent = c("firm.wheat", "firm.iron", "laborer", "landowner"),
  numeraire = "lab"
)

ge$p
ge$z
ge$D
ge$S

# f(policyTailAdjustment)

## an anticipated technological shock
# np &lt;- 50 # the number of economic periods
# alpha.firm.wheat &lt;- rep(5, np - 1)
# alpha.firm.iron &lt;- rep(5, np - 1)
# alpha.firm.iron[25] &lt;- 10
# names.commodity &lt;- c(
#   paste0("wheat", 1:np),
#   paste0("iron", 1:np),
#   paste0("lab", 1:(np - 1)),
#   paste0("land", 1:(np - 1))
# )
# names.agent &lt;- c(
#   paste0("firm", 1:(np - 1), ".wheat"), paste0("firm", 1:(np - 1), ".iron"),
#   "laborer", "landowner"
# )
#
# ge &lt;- f()
# plot(2:(np - 1), ge$z[1:(np - 2)],
#      type = "o", pch = 20, ylab = "production output",
#      xlab = "time", ylim = range(ge$z[1:(2 * np - 2)])
# )
# lines(2:(np - 1), ge$z[np:(2 * np - 3)], type = "o", pch = 21)
# legend("bottom", c("wheat", "iron"), pch = 20:21)
# grid()

# #### a structural transformation path
# np &lt;- 50
# tax.rate &lt;- 0.1 # the tax rate imposed on income from land and labor income.
# tax.time &lt;- 1 # tax.time &lt;- 20
#
# alpha.firm.wheat &lt;- rep(5, np - 1)
# # Suppose the tax rate is high enough so that the iron
# # producer's efficiency coefficient immediately rises to 10.
# alpha.firm.iron &lt;- c()
# for (k in 1:(np - 1)) {
#   alpha.firm.iron[k] &lt;- ifelse(k &lt;= tax.time, 5, 10)
# }
#
# Gamma.beta &lt;- 0.97 # 1, 1.03 # the subjective discount factor of consumers
# eis &lt;- 0.5 # the elasticity of intertemporal substitution  of consumers
# y1.wheat &lt;- 100
# y1.iron &lt;- 30
# last.beta.laborer &lt;- 0
# last.beta.landowner &lt;- 0
#
# names.commodity &lt;- c(
#   paste0("wheat", 1:np),
#   paste0("iron", 1:np),
#   paste0("lab", 1:(np - 1)),
#   paste0("land", 1:(np - 1))
# )
# names.agent &lt;- c(
#   paste0("firm", 1:(np - 1), ".wheat"), paste0("firm", 1:(np - 1), ".iron"),
#   "laborer", "landowner"
# )
#
# n &lt;- length(names.commodity) # the number of commodity kinds
# m &lt;- length(names.agent) # the number of agent kinds
#
# # the exogenous supply matrix.
# S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
# S0Exg["wheat1", "laborer"] &lt;- y1.wheat
# S0Exg["iron1", "landowner"] &lt;- y1.iron
# S0Exg[paste0("lab", 1:(np - 1)), "laborer"] &lt;- 100 # the supply of labor
# S0Exg[paste0("land", 1:(np - 1)), "landowner"] &lt;- 100 # the supply of land
#
# S0Exg[paste0("lab", tax.time), paste0("firm", tax.time, ".iron")] &lt;-
#   S0Exg[paste0("lab", tax.time), "laborer"] * tax.rate
# S0Exg[paste0("land", tax.time), paste0("firm", tax.time, ".iron")] &lt;-
#   S0Exg[paste0("land", tax.time), "landowner"] * tax.rate
#
# S0Exg[paste0("lab", tax.time), "laborer"] &lt;-
#   S0Exg[paste0("lab", tax.time), "laborer"] * (1 - tax.rate)
# S0Exg[paste0("land", tax.time), "landowner"] &lt;-
#   S0Exg[paste0("land", tax.time), "landowner"] * (1 - tax.rate)
#
# # the output coefficient matrix.
# B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
# for (k in 1:(np - 1)) {
#   B[paste0("wheat", k + 1), paste0("firm", k, ".wheat")] &lt;- 1
#   B[paste0("iron", k + 1), paste0("firm", k, ".iron")] &lt;- 1
# }
#
# dstl.firm.wheat &lt;- dstl.firm.iron &lt;- list()
# for (k in 1:(np - 1)) {
#   dstl.firm.wheat[[k]] &lt;- node_new(
#     "prod",
#     type = "CES", es = 0.8,
#     alpha = alpha.firm.wheat[k], beta = c(0.2, 0.4, 0.4),
#     paste0("iron", k), paste0("lab", k), paste0("land", k)
#   )
#
#   dstl.firm.iron[[k]] &lt;- node_new(
#     "prod",
#     type = "CES", es = 0.8,
#     alpha = alpha.firm.iron[k], beta = c(0.4, 0.4, 0.2),
#     paste0("iron", k), paste0("lab", k), paste0("land", k)
#   )
# }
#
# tmp.beta &lt;- Gamma.beta^(1:(np - 1))
# tmp.beta &lt;- tmp.beta / tmp.beta[np - 1]
# tmp.beta &lt;- c(tmp.beta, last.beta.laborer)
# dst.laborer &lt;- node_new(
#   "util",
#   type = "CES", es = eis,
#   alpha = 1, beta = prop.table(tmp.beta),
#   paste0("cc", 1:(np - 1)), paste0("wheat", np)
# )
# for (k in 1:(np - 1)) {
#   node_set(dst.laborer, paste0("cc", k),
#            type = "CES", es = 1,
#            alpha = 1, beta = c(0.4, 0.4, 0.2),
#            paste0("wheat", k), paste0("lab", k), paste0("land", k)
#   )
# }
#
# tmp.beta &lt;- Gamma.beta^(1:(np - 1))
# tmp.beta &lt;- tmp.beta / tmp.beta[np - 1]
# tmp.beta &lt;- c(tmp.beta, last.beta.landowner)
# dst.landowner &lt;- node_new(
#   "util",
#   type = "CES", es = eis,
#   alpha = 1, beta = prop.table(tmp.beta),
#   paste0("cc", 1:(np - 1)), paste0("iron", np)
# )
# for (k in 1:(np - 1)) {
#   node_set(dst.landowner, paste0("cc", k),
#            type = "CES", es = 1,
#            alpha = 1, beta = c(0.2, 0.4, 0.4),
#            paste0("wheat", k), paste0("lab", k), paste0("land", k)
#   )
# }
# ge &lt;- sdm2(
#   A = c(dstl.firm.wheat, dstl.firm.iron, Clone(dst.laborer), Clone(dst.landowner)),
#   B = B,
#   S0Exg = S0Exg,
#   names.commodity = names.commodity,
#   names.agent = names.agent,
#   numeraire = "lab1",
#   ts = TRUE,
#   maxIteration = 1,
#   numberOfPeriods = 1000,
#   priceAdjustmentVelocity = 0.05
# )
#
# plot(2:(np - 1), ge$z[1:(np - 2)],
#      type = "o", pch = 20, ylab = "production output",
#      xlab = "time", ylim = range(ge$z[1:(2 * np - 2)])
# )
# lines(2:(np - 1), ge$z[np:(2 * np - 3)], type = "o", pch = 21)
# legend("bottom", c("wheat", "iron"), pch = 20:21)

</code></pre>

<hr>
<h2 id='gemIntertemporal_5_5'>Some Intertemporal (Timeline and Time-circle) Models with Land, Two Consumers, and Three Types of Firms</h2><span id='topic+gemIntertemporal_5_5'></span>

<h3>Description</h3>

<p>Some intertemporal (timeline and time-circle) models with two consumers (i.e. a laborer and a landowner) and three types of firms
(i.e. wheat producers, iron producers and iron leaser).
Here the iron leasing firm is actually a quasi-firm, which does not require primary factors such as labor and land in its production process.
There are four commodities in the model, namely wheat, iron, iron leased out as a capital good, labor and land.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_5_5(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_5_5_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### a timeline model.
np &lt;- 15 # the number of economic periods
gr &lt;- 0 # the growth rate in the steady state equilibrium
eis &lt;- 1 # the elasticity of intertemporal substitution  of consumers
Gamma.beta &lt;- 0.97 # the subjective discount factor of consumers
last.beta.laborer &lt;- 0
last.beta.landowner &lt;- 0
depreciation.rate &lt;- 0.06

alpha.firm.wheat &lt;- rep(5, np - 1)
alpha.firm.iron &lt;- rep(5, np - 1)

y1.wheat &lt;- 200
y1.iron &lt;- 100

names.commodity &lt;- c(
  paste0("wheat", 1:np),
  paste0("iron", 1:np),
  paste0("cap", 1:(np - 1)),
  paste0("lab", 1:(np - 1)),
  paste0("land", 1:(np - 1))
)
names.agent &lt;- c(
  paste0("firm.wheat", 1:(np - 1)), paste0("firm.iron", 1:(np - 1)),
  paste0("quasifirm.cap", 1:(np - 1)), # a quasifirm
  "laborer", "landowner"
)

n &lt;- length(names.commodity) # the number of commodity kinds, i.e. 5 * np - 3
m &lt;- length(names.agent) # the number of agent kinds, i.e. 3 * np - 1

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg["wheat1", "laborer"] &lt;- y1.wheat
S0Exg["iron1", "landowner"] &lt;- y1.iron
S0Exg[paste0("lab", 1:(np - 1)), "laborer"] &lt;- 100 * (1 + gr)^(0:(np - 2)) # the supply of labor
S0Exg[paste0("land", 1:(np - 1)), "landowner"] &lt;- 100 * (1 + gr)^(0:(np - 2)) # the supply of land

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("wheat", k + 1), paste0("firm.wheat", k)] &lt;- 1
  B[paste0("iron", k + 1), paste0("firm.iron", k)] &lt;- 1
  B[paste0("cap", k), paste0("quasifirm.cap", k)] &lt;- 1
  B[paste0("iron", k + 1), paste0("quasifirm.cap", k)] &lt;- 1 - depreciation.rate
}

dstl.firm.wheat &lt;- dstl.firm.iron &lt;- dstl.quasifirm.cap &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm.wheat[[k]] &lt;- node_new(
    "prod",
    type = "CES", es = 1,
    alpha = alpha.firm.wheat[k], beta = c(0.2, 0.4, 0.4),
    paste0("cap", k), paste0("lab", k), paste0("land", k)
  )

  dstl.firm.iron[[k]] &lt;- node_new(
    "prod",
    type = "CES", es = 1,
    alpha = alpha.firm.iron[k], beta = c(0.4, 0.4, 0.2),
    paste0("cap", k), paste0("lab", k), paste0("land", k)
  )

  dstl.quasifirm.cap[[k]] &lt;- node_new(
    "output",
    type = "Leontief", a = 1,
    paste0("iron", k)
  )
}

tmp.beta &lt;- Gamma.beta^(1:(np - 1))
tmp.beta &lt;- tmp.beta / tmp.beta[np - 1]
tmp.beta &lt;- c(tmp.beta, last.beta.laborer)
dst.laborer &lt;- node_new(
  "util",
  type = "CES", es = eis,
  alpha = 1, beta = prop.table(tmp.beta),
  paste0("cc", 1:(np - 1)), paste0("wheat", np)
)
for (k in 1:(np - 1)) {
  node_set(dst.laborer, paste0("cc", k),
    type = "CES", es = 1,
    alpha = 1, beta = c(0.4, 0.4, 0.2),
    paste0("wheat", k), paste0("lab", k), paste0("land", k)
  )
}

tmp.beta &lt;- Gamma.beta^(1:(np - 1))
tmp.beta &lt;- tmp.beta / tmp.beta[np - 1]
tmp.beta &lt;- c(tmp.beta, last.beta.landowner)
dst.landowner &lt;- node_new(
  "util",
  type = "CES", es = eis,
  alpha = 1, beta = prop.table(tmp.beta),
  paste0("cc", 1:(np - 1)), paste0("iron", np)
)
for (k in 1:(np - 1)) {
  node_set(dst.landowner, paste0("cc", k),
    type = "CES", es = 1,
    alpha = 1, beta = c(0.2, 0.4, 0.4),
    paste0("wheat", k), paste0("lab", k), paste0("land", k)
  )
}

ge &lt;- sdm2(
  A = c(
    dstl.firm.wheat, dstl.firm.iron, dstl.quasifirm.cap,
    dst.laborer, dst.landowner
  ),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "lab1",
  policy = makePolicyMeanValue(50),
  ts = TRUE,
  priceAdjustmentVelocity = 0.03
)

ge$p
ge$z
plot(ge$z[2 * (np - 1) + (1:(np - 1))], type = "b", pch = 20)
lines(1:(np - 1), ge$z[1:(np - 1)], type = "b", pch = 21)
lines(1:(np - 1), ge$z[np - 1 + (1:(np - 1))], type = "b", pch = 22)
legend("topleft", c("cap","wheat", "iron"), pch = 20:22)

#### a time-circle model.
np &lt;- 5 # the number of economic periods
gr &lt;- 0.03 # the growth rate in the steady state equilibrium
eis &lt;- 0.5 # the elasticity of intertemporal substitution  of consumers
Gamma.beta &lt;- 0.97 # the subjective discount factor of consumers
es.firm &lt;- 1
depreciation.rate &lt;- 0.06
zeta &lt;- (1 + gr)^np # the ratio of repayments to loans
yield.rate &lt;- sserr(eis = eis, Gamma.beta = Gamma.beta, gr = gr, prepaid = TRUE)
captial.share.laborer &lt;- 0.7795
captial.share.landowner &lt;- 1 - captial.share.laborer

alpha.firm.wheat &lt;- rep(5, np)
alpha.firm.iron &lt;- rep(5, np)

names.commodity &lt;- c(
  paste0("wheat", 1:np),
  paste0("iron", 1:np),
  paste0("cap", 1:np),
  paste0("lab", 1:np),
  paste0("land", 1:np),
  "claim"
)
names.agent &lt;- c(
  paste0("firm.wheat", 1:np), paste0("firm.iron", 1:np),
  paste0("quasifirm.cap", 1:np), # a quasifirm
  "laborer", "landowner"
)
n &lt;- length(names.commodity) # the number of commodity kinds
m &lt;- length(names.agent) # the number of agent kinds

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:np), "laborer"] &lt;- 100 * (1 + gr)^(0:(np - 1)) # the supply of labor
S0Exg[paste0("land", 1:np), "landowner"] &lt;- 100 * (1 + gr)^(0:(np - 1)) # the supply of land
S0Exg["claim", "laborer"] &lt;- 100 * captial.share.laborer
S0Exg["claim", "landowner"] &lt;- 100 * captial.share.landowner

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("wheat", k + 1), paste0("firm.wheat", k)] &lt;- 1
  B[paste0("iron", k + 1), paste0("firm.iron", k)] &lt;- 1
  B[paste0("cap", k), paste0("quasifirm.cap", k)] &lt;- 1
  B[paste0("iron", k + 1), paste0("quasifirm.cap", k)] &lt;- 1 - depreciation.rate
}
B[paste0("wheat", 1), paste0("firm.wheat", np)] &lt;- 1 / zeta
B[paste0("iron", 1), paste0("firm.iron", np)] &lt;- 1 / zeta
B[paste0("cap", np), paste0("quasifirm.cap", np)] &lt;- 1
B[paste0("iron", 1), paste0("quasifirm.cap", np)] &lt;- (1 - depreciation.rate) / zeta

dstl.firm.wheat &lt;- dstl.firm.iron &lt;- dstl.quasifirm.cap &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm.wheat[[k]] &lt;- node_new(
    "prod",
    type = "CES", es = es.firm,
    alpha = alpha.firm.wheat[k], beta = c(0.2, 0.4, 0.4),
    paste0("cap", k), paste0("lab", k), paste0("land", k)
  )

  dstl.firm.iron[[k]] &lt;- node_new(
    "prod",
    type = "CES", es = es.firm,
    alpha = alpha.firm.iron[k], beta = c(0.4, 0.4, 0.2),
    paste0("cap", k), paste0("lab", k), paste0("land", k)
  )

  dstl.quasifirm.cap[[k]] &lt;- node_new(
    "output",
    type = "Leontief", a = 1,
    paste0("iron", k)
  )
}

dstl.firm.wheat[[np]] &lt;- node_new(
  "prod",
  type = "FIN", rate = c(1, (1 + yield.rate)^np - 1),
  "cc1", "claim"
)
node_set(dstl.firm.wheat[[np]], "cc1",
         type = "CES", es = es.firm,
         alpha = alpha.firm.wheat[k], beta = c(0.2, 0.4, 0.4),
         paste0("cap", np), paste0("lab", np), paste0("land", np)
)

dstl.firm.iron[[np]] &lt;- node_new(
  "prod",
  type = "FIN", rate = c(1, (1 + yield.rate)^np - 1),
  "cc1", "claim"
)
node_set(dstl.firm.iron[[np]], "cc1",
         type = "CES", es = es.firm,
         alpha = alpha.firm.wheat[k], beta = c(0.4, 0.4, 0.2),
         paste0("cap", np), paste0("lab", np), paste0("land", np)
)

return.rate &lt;- sserr(eis = eis, Gamma.beta = Gamma.beta, gr = gr)
fund.occupancy.rate &lt;- (1 - depreciation.rate) / (1 + return.rate)
# The prepaid rent rate (i.e. the prepaid-rent-to-price ratio) of
# the capital good is equal to 1 minus fund.occupancy.rate.

dstl.quasifirm.cap[[np]] &lt;- node_new(
  "prod",
  type = "FIN", rate = c(1, ((1 + yield.rate)^np - 1) * fund.occupancy.rate),
  "cc1", "claim"
)
node_set(dstl.quasifirm.cap[[np]], "cc1",
         type = "Leontief", a = 1,
         paste0("iron", np)
)

dst.laborer &lt;- node_new(
  "util",
  type = "CES", es = eis,
  alpha = 1, beta = prop.table(Gamma.beta^(1:np)),
  paste0("cc", 1:np)
)
for (k in 1:np) {
  node_set(dst.laborer, paste0("cc", k),
           type = "CES", es = 1,
           alpha = 1, beta = c(0.4, 0.4, 0.2),
           paste0("wheat", k), paste0("lab", k), paste0("land", k)
  )
}

dst.landowner &lt;- node_new(
  "util",
  type = "CES", es = eis,
  alpha = 1, beta = prop.table(Gamma.beta^(1:np)),
  paste0("cc", 1:np)
)
for (k in 1:np) {
  node_set(dst.landowner, paste0("cc", k),
           type = "CES", es = 1,
           alpha = 1, beta = c(0.2, 0.4, 0.4),
           paste0("wheat", k), paste0("lab", k), paste0("land", k)
  )
}

ge.tc &lt;- sdm2(
  A = c(
    dstl.firm.wheat, dstl.firm.iron, dstl.quasifirm.cap,
    dst.laborer, dst.landowner
  ),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "lab1",
  numberOfPeriods = 1000,
  priceAdjustmentVelocity = 0.03
)

ge.tc$p
growth_rate(ge.tc$p)
ge.tc$z
growth_rate(ge.tc$z)

## the corresponding sequential model with the same steady-state equilibrium.
dst.firm.wheat &lt;- node_new("prod",
                           type = "FIN", rate = c(1, yield.rate),
                           "cc1", "equity.share.wheat"
)
node_set(dst.firm.wheat, "cc1",
         type = "CES", es = es.firm,
         alpha = 5, beta = c(0.2, 0.4, 0.4),
         "cap", "lab", "land"
)

dst.firm.iron &lt;- node_new("prod",
                          type = "FIN", rate = c(1, yield.rate),
                          "cc1", "equity.share.iron"
)
node_set(dst.firm.iron, "cc1",
         type = "CES", es = es.firm,
         alpha = 5, beta = c(0.4, 0.4, 0.2),
         "cap", "lab", "land"
)

dst.quasifirm.cap &lt;- node_new("prod",
                              type = "FIN", rate = c(1, yield.rate * fund.occupancy.rate),
                              "cc1", "equity.share.cap"
)
node_set(dst.quasifirm.cap, "cc1",
         type = "Leontief", a = 1,
         "iron"
)

dst.laborer &lt;- node_new("util",
                        type = "CES", es = 1,
                        alpha = 1, beta = c(0.4, 0.4, 0.2),
                        "wheat", "lab", "land"
)

dst.landowner &lt;- node_new("util",
                          type = "CES", es = 1,
                          alpha = 1, beta = c(0.2, 0.4, 0.4),
                          "wheat", "lab", "land"
)

ge.seq &lt;- sdm2(
  A = list(
    dst.firm.wheat, dst.firm.iron, dst.quasifirm.cap,
    dst.laborer, dst.landowner
  ),
  B = matrix(c(
    1, 0, 0, 0, 0,
    0, 1, 1 - depreciation.rate, 0, 0,
    0, 0, 1 + gr, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0
  ), 8, 5, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA,
    NA, NA, NA, 100, NA,
    NA, NA, NA, NA, 100,
    NA, NA, NA, 100 * captial.share.laborer, 100 * captial.share.landowner,
    NA, NA, NA, 100 * captial.share.laborer, 100 * captial.share.landowner,
    NA, NA, NA, 100 * captial.share.laborer, 100 * captial.share.landowner
  ), 8, 5, TRUE),
  names.commodity = c(
    "wheat", "iron", "cap", "lab", "land",
           "equity.share.wheat", "equity.share.iron", "equity.share.cap"
  ),
  names.agent = c("firm.wheat", "firm.iron", "quasifirm.cap", "laborer", "landowner"),
  numeraire = "lab",
  numberOfPeriods = 2000,
  priceAdjustmentVelocity = 0.03,
  GRExg = gr
)

ge.seq$p
ge.seq$z
ge.tc$z

</code></pre>

<hr>
<h2 id='gemIntertemporal_AdValoremClaim'>Some Intertemporal Models with Ad Valorem Claim</h2><span id='topic+gemIntertemporal_AdValoremClaim'></span>

<h3>Description</h3>

<p>Some intertemporal models with ad valorem claim.
Ad valorem claims may be equities, bonds, ad valorem taxation rights (ad valorem tax receipt), fiat money etc,
which can be treated in the same way in models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_AdValoremClaim(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_AdValoremClaim_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### a model with tax.
np &lt;- 5 # the number of economic periods
gr.lab &lt;- 0.03 # the growth rate of the labor supply
tax.rate &lt;- 0.25

n &lt;- 2 * np + 1 # the number of commodity kinds
m &lt;- np + 1 # the number of agent kinds

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:np), "tax receipt")
names.agent &lt;- c(paste0("firm", 1:(np - 1)), "laborer", "government")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:np), "laborer"] &lt;- 100 * (1 + gr.lab)^(0:(np - 1)) # the labor supply
S0Exg["prod1", "laborer"] &lt;- 10 # the product supply in the first period
S0Exg["tax receipt", "government"] &lt;- np * 100 # the supply of tax receipt (i.e. ad valorem claim)

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}

dstl.firm &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "FIN", rate = c(1, tax.rate),
    "cc1", "tax receipt"
  )
  node_set(dstl.firm[[k]], "cc1",
           type = "CD",
           alpha = 1, beta = c(0.5, 0.5),
           paste0("prod", k), paste0("lab", k)
  )
}

dst.laborer &lt;- node_new(
  "util",
  type = "FIN", rate = c(1, tax.rate),
  "cc1", "tax receipt"
)
node_set(dst.laborer, "cc1",
         type = "CES", es = 0.5,
         alpha = 1, beta = rep(1 / np, np),
         paste0("cc1.", 1:np)
)
for (k in 1:np) {
  node_set(dst.laborer, paste0("cc1.", k),
           type = "CD", alpha = 1, beta = c(0.5, 0.5),
           paste0("prod", k), paste0("lab", k)
  )
}

dst.government &lt;- node_new(
  "util",
  type = "CD",
  alpha = 1, beta = rep(1 / np, np),
  paste0("cc1.", 1:np)
)
for (k in 1:np) {
  node_set(dst.government, paste0("cc1.", k),
           type = "CD", alpha = 1, beta = c(0.5, 0.5),
           paste0("prod", k), paste0("lab", k)
  )
}
node_plot(dst.government, TRUE)

ge &lt;- sdm2(
  A = c(dstl.firm, dst.laborer, dst.government),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "prod1",
  # policy = makePolicyHeadTailAdjustment(gr = gr.lab, np = np)
)

ge$D
ge$z
ge$DV

#### a pure exchange model with money.
np &lt;- 3 # the number of economic periods
gr.lab &lt;- 0.03 # the growth rate of the labor supply
eis &lt;- 0.8 # the elasticity of intertemporal substitution
Gamma.beta &lt;- 0.8 # the subjective discount factor
interest.rate &lt;- sserr(eis, Gamma.beta, gr.lab, prepaid = TRUE) # 0.2593

dst.laborer &lt;- node_new(
  "util",
  type = "CES", es = eis,
  alpha = 1, beta = Gamma.beta^(0:(np - 1)),
  paste0("cc", 1:np)
)

for (k in 1:np) {
  node_set(dst.laborer, paste0("cc", k),
    type = "FIN",
    rate = c(1, interest.rate),
    paste0("lab", k), paste0("money", k)
  )
}

node_plot(dst.laborer, TRUE)

dst.moneyOwner &lt;- Clone(dst.laborer)

ge &lt;- sdm2(
  A = list(dst.laborer, dst.moneyOwner),
  B = matrix(0, 2 * np, 2),
  S0Exg = {
    tmp &lt;- matrix(0, 2 * np, 2)
    tmp[1:np, 1] &lt;- 100 * (1 + gr.lab)^(0:(np - 1))
    tmp[(np + 1):(2 * np), 2] &lt;- 200
    tmp
  },
  names.commodity = c(paste0("lab", 1:np), paste0("money", 1:np)),
  names.agent = c("laborer", "moneyOwner"),
  numeraire = c(money1 = interest.rate)
)

ge$p
growth_rate(ge$p[1:3]) + 1
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)

## In the following program, the periods to which
## the money belongs are not distinguished.
dst.laborer &lt;- node_new(
  "util",
  type = "FIN",
  rate = c(1, interest.rate),
  "cc1", "money"
)
node_set(dst.laborer, "cc1",
  type = "CES", es = eis,
  alpha = 1, beta = Gamma.beta^(0:(np - 1)),
  paste0("lab", 1:np)
)

dst.moneyOwner &lt;- Clone(dst.laborer)

ge &lt;- sdm2(
  A = list(dst.laborer, dst.moneyOwner),
  B = matrix(0, np + 1, 2),
  S0Exg = {
    tmp &lt;- matrix(0, np + 1, 2)
    tmp[1:np, 1] &lt;- 100 * (1 + gr.lab)^(0:(np - 1))
    tmp[np + 1, 2] &lt;- 100
    tmp
  },
  names.commodity = c(paste0("lab", 1:np), "money"),
  names.agent = c("laborer", "moneyOwner"),
  numeraire = c(money = interest.rate)
)

ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)

#### a two-period model with production and money.
interest.rate1 &lt;- 0.25
interest.rate2 &lt;- 0.1

dst.firm &lt;- node_new(
  "prod",
  type = "FIN",
  rate = c(1, interest.rate1),
  "cc1", "money1"
)
node_set(dst.firm, "cc1",
  type = "CES",
  es = 1, alpha = 2, beta = c(0.5, 0.5),
  "prod1", "lab1"
)

dst.laborer &lt;- node_new(
  "util",
  type = "CES",
  es = 0.5, alpha = 1, beta = c(2 / 3, 1 / 3),
  "cc1", "cc2"
)
node_set(dst.laborer, "cc1",
  type = "FIN",
  rate = c(1, interest.rate1),
  "prod1", "money1"
)

node_set(dst.laborer, "cc2",
  type = "FIN",
  rate = c(1, interest.rate2),
  "prod2", "money2"
)

dst.moneyOwner &lt;- Clone(dst.laborer)

ge &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.moneyOwner),
  B = matrix(c(
    0, 0, 0,
    0, 0, 0,
    0, 0, 0,
    1, 0, 0,
    0, 0, 0
  ), 5, 3, TRUE),
  S0Exg = matrix(c(
    NA, 200, NA,
    NA, 100, NA,
    NA, NA, 100,
    NA, NA, NA,
    NA, NA, 100
  ), 5, 3, TRUE),
  names.commodity = c("prod1", "lab1", "money1", "prod2", "money2"),
  names.agent = c("firm", "laborer", "moneyOwner"),
  numeraire = c(money1 = interest.rate1)
)

ge$p
ge$DV

</code></pre>

<hr>
<h2 id='gemIntertemporal_Bank_1_2'>Some Examples of an Intertemporal Model with a Consumer and a Type of Bank</h2><span id='topic+gemIntertemporal_Bank_1_2'></span>

<h3>Description</h3>

<p>Some examples of an intertemporal model with a consumer and a type of bank.
These models can be used to solve some intertemporal savings problems.
Below is an example.
</p>
<p>A np-period-lived consumer has some payoff (or cash, exhaustible resource etc.) in each period.
In each period the consumer can use payoff for consumption or save payoff into bank.
The interest rate is given.
The consumer has a SCES intertemporal utility function and attempts to maximize intertemporal utility by saving.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_Bank_1_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_Bank_1_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an example with a 5-period-lived consumer
np &lt;- 5 # the number of economic periods

interest.rate &lt;- 0.1

n &lt;- np # the number of commodity kinds
m &lt;- np # the number of agent kinds

names.commodity &lt;- paste0("payoff", 1:np)
names.agent &lt;- c(paste0("bank", 1:(np - 1)), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("payoff", 1:np), "consumer"] &lt;- 100 / (np:1)

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("payoff", k + 1), paste0("bank", k)] &lt;- 1
}

dstl.bank &lt;- list()
for (k in 1:(np - 1)) {
  dstl.bank[[k]] &lt;- node_new("output",
                             type = "Leontief", a = 1 / (1 + interest.rate),
                             paste0("payoff", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "SCES", es = 1, alpha = 1, beta = prop.table(1:np),
  paste0("payoff", 1:np)
)

ge &lt;- sdm2(
  A = c(dstl.bank, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "payoff1",
  policy = makePolicyMeanValue(30),
  ts = TRUE
)

ge$p
ge$z
ge$D
ge$S
ge$DV
ge$SV
growth_rate(ge$p)

##
dst.consumer$es &lt;- 0
dst.consumer$beta &lt;- rep(1 / np, np)
S0Exg[paste0("payoff", 1:np), "consumer"] &lt;- 100 / (1:np)
ge &lt;- sdm2(
  A = c(dstl.bank, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "payoff1",
  policy = makePolicyMeanValue(30),
  ts = TRUE
)

ge$p
ge$z
ge$D
ge$S
ge$DV
ge$SV

</code></pre>

<hr>
<h2 id='gemIntertemporal_Bank_1_3'>Some Examples of an Intertemporal Model with Two Consumers and a Type of Bank</h2><span id='topic+gemIntertemporal_Bank_1_3'></span>

<h3>Description</h3>

<p>Some examples of an intertemporal model with two consumers and a type of bank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_Bank_1_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_Bank_1_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>See Also</h3>


<p><code><a href="#topic+gemIntertemporal_Bank_1_2">gemIntertemporal_Bank_1_2</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an example with a 5-period-lived consumer
np &lt;- 5 # the number of economic periods
interest.rate &lt;- 0.1

n &lt;- np # the number of commodity kinds
m &lt;- np + 1 # the number of agent kinds

names.commodity &lt;- paste0("payoff", 1:np)
names.agent &lt;- c(paste0("bank", 1:(np - 1)), "consumer1", "consumer2")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("payoff", 1:np), "consumer1"] &lt;- 100 / (np:1)
S0Exg[paste0("payoff", 1:np), "consumer2"] &lt;- 100 / (1:np)

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("payoff", k + 1), paste0("bank", k)] &lt;- 1
}

dstl.bank &lt;- list()
for (k in 1:(np - 1)) {
  dstl.bank[[k]] &lt;- node_new(
    "output",
    type = "Leontief", a = 1 / (1 + interest.rate),
    paste0("payoff", k)
  )
}

dst.consumer1 &lt;- node_new(
  "util",
  type = "SCES",
  es = 1, alpha = 1, beta = prop.table(1:np),
  paste0("payoff", 1:np)
)

dst.consumer2 &lt;- node_new(
  "util",
  type = "SCES",
  es = 1, alpha = 1, beta = prop.table(np:1),
  paste0("payoff", 1:np)
)

ge &lt;- sdm2(
  A = c(dstl.bank, dst.consumer1, dst.consumer2),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "payoff1",
  policy = makePolicyMeanValue(30),
  ts = TRUE
)

ge$p
ge$z
ge$D
ge$S
ge$DV
ge$SV
growth_rate(ge$p)

##
dst.consumer1$es &lt;- 0
dst.consumer1$beta &lt;- rep(1 / np, np)

ge &lt;- sdm2(
  A = c(dstl.bank, dst.consumer1, dst.consumer2),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "payoff1",
  policy = makePolicyMeanValue(30),
  ts = TRUE
)

ge$p
ge$z
ge$D
ge$S
ge$DV
ge$SV
growth_rate(ge$p)

</code></pre>

<hr>
<h2 id='gemIntertemporal_Dividend'>The Identical Steady-state Equilibrium: Four Models Illustrating Dividend</h2><span id='topic+gemIntertemporal_Dividend'></span>

<h3>Description</h3>

<p>Four models are presented to illustrate dividend, which have the same steady-state equilibrium.
</p>
<p>These models are as follows:
(1) a real timeline model with head-tail adjustment;
(2) a financial timeline model with dividend and head-tail adjustment;
(3) a financial sequential model with dividend;
(4) a financial time-circle model with dividend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_Dividend(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_Dividend_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### (1) a real timeline model with head-tail adjustment.
eis &lt;- 0.8 # the elasticity of intertemporal substitution
Gamma.beta &lt;- 0.8 # the subjective discount factor
gr &lt;- 0.03 # the growth rate
np &lt;- 5 # the number of economic periods

n &lt;- 2 * np - 1 # the number of commodity kinds
m &lt;- np # the number of agent kinds

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:(np - 1)))
names.agent &lt;- c(paste0("firm", 1:(np - 1)), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:(np - 1)), "consumer"] &lt;- 100 * (1 + gr)^(0:(np - 2))
S0Exg["prod1", "consumer"] &lt;- 140 # the product supply in the first period, which will be adjusted.

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}

dstl.firm &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "CD",
    alpha = 2, beta = c(0.5, 0.5),
    paste0("prod", k), paste0("lab", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "CES", es = eis,
  alpha = 1, beta = prop.table(Gamma.beta^(1:np)),
  paste0("prod", 1:np)
)

ge.tl &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "prod1",
  policy = makePolicyHeadTailAdjustment(gr = gr, np = np)
)

sserr(eis, Gamma.beta, gr) # the steady-state equilibrium return rate, 0.2970
ge.tl$p[1:(np - 1)] / ge.tl$p[2:np] - 1
ge.tl$z

## (2) a financial timeline model with dividend and head-tail adjustment.
yield.rate &lt;- sserr(
  eis = eis, Gamma.beta = Gamma.beta,
  gr = gr, prepaid = TRUE
) # the prepaid steady-state equilibrium return rate, 0.2593

n &lt;- 2 * np # the number of commodity kinds
m &lt;- np # the number of agent kinds

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:(np - 1)), "claim")
names.agent &lt;- c(paste0("firm", 1:(np - 1)), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:(np - 1)), "consumer"] &lt;- 100 * (1 + gr)^(0:(np - 2))
S0Exg["claim", "consumer"] &lt;- 100
S0Exg["prod1", "consumer"] &lt;- 140 # the product supply in the first period, which will be adjusted.

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}

dstl.firm &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "FIN", rate = c(1, yield.rate),
    "cc1", "claim"
  )
  node_set(dstl.firm[[k]], "cc1",
           type = "CD", alpha = 2, beta = c(0.5, 0.5),
           paste0("prod", k), paste0("lab", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "CES", es = 1,
  alpha = 1, beta = prop.table(rep(1, np)), # prop.table(Gamma.beta^(1:np)),
  paste0("prod", 1:np)
)

ge.ftl &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "prod1",
  policy = makePolicyHeadTailAdjustment(gr = gr, np = np)
)

ge.ftl$z

## (3) a financial sequential model with dividend.
dst.firm &lt;- node_new("output",
                     type = "FIN",
                     rate = c(1, dividend.rate = yield.rate),
                     "cc1", "equity.share"
)
node_set(dst.firm, "cc1",
         type = "CD",
         alpha = 2, beta = c(0.5, 0.5),
         "prod", "lab"
)

dst.laborer &lt;- node_new("util",
                        type = "Leontief", a = 1,
                        "prod"
)

dst.shareholder &lt;- Clone(dst.laborer)

ge.fs &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.shareholder),
  B = diag(c(1, 0, 0)),
  S0Exg = {
    S0Exg &lt;- matrix(NA, 3, 3)
    S0Exg[2, 2] &lt;- S0Exg[3, 3] &lt;- 100
    S0Exg
  },
  names.commodity = c("prod", "lab", "equity.share"),
  names.agent = c("firm", "laborer", "shareholder"),
  numeraire = "prod",
  GRExg = gr
)

ge.fs$z

# a steady-state path.
ge2.fs &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.shareholder),
  B = diag(c(1, 0, 0)),
  S0Exg = {
    S0Exg &lt;- matrix(NA, 3, 3)
    S0Exg[2, 2] &lt;- S0Exg[3, 3] &lt;- 100
    S0Exg
  },
  names.commodity = c("prod", "lab", "equity.share"),
  names.agent = c("firm", "laborer", "shareholder"),
  numeraire = "prod",
  GRExg = gr,
  maxIteration = 1,
  numberOfPeriods = 20,
  z0 = ge.fs$z,
  policy = policyMarketClearingPrice,
  ts = TRUE
)

ge2.fs$ts.z[, 1]
growth_rate(ge2.fs$ts.z[, 1])

## (4) a financial time-circle model with dividend.
np &lt;- 5
zeta &lt;- (1 + gr)^np # the ratio of repayments to loans

n &lt;- 2 * np + 1 # the number of commodity kinds
m &lt;- np + 1 # the number of agent kinds

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:np), "claim")
names.agent &lt;- c(paste0("firm", 1:np), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:np), "consumer"] &lt;- 100 * (1 + gr)^(0:(np - 1))
S0Exg["claim", "consumer"] &lt;- 100

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}
B["prod1", paste0("firm", np)] &lt;- 1 / zeta

dstl.firm &lt;- list()
for (k in 1:np) {
  dstl.firm[[k]] &lt;- node_new("output",
                             type = "FIN", rate = c(1, yield.rate),
                             "cc1", "claim"
  )
  node_set(dstl.firm[[k]], "cc1",
           type = "CD", alpha = 2,
           beta = c(0.5, 0.5),
           paste0("lab", k), paste0("prod", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "CES", es = 1,
  alpha = 1, beta = prop.table(rep(1, np)),
  paste0("prod", 1:np)
)

ge.ftc &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "prod1",
  ts = TRUE
)

ge.ftc$z

##
ge.tc &lt;- gemCanonicalDynamicMacroeconomic_TimeCircle_2_2(
  alpha.firm = rep(2, 5),
  es.prod.lab.firm = 1,
  beta.prod.firm = 0.5,
  depreciation.rate = 1,
  eis = 0.8,
  Gamma.beta = 0.8,
  beta.prod.consumer = 1,
  es.prod.lab.consumer = 1,
  gr = 0.03,
  wage.payment = "pre"
)

ge.tc$z

</code></pre>

<hr>
<h2 id='gemIntertemporal_Dividend_TechnologicalProgress'>The Identical Steady-state Equilibrium: Four Models Illustrating Dividend and Technological Progress</h2><span id='topic+gemIntertemporal_Dividend_TechnologicalProgress'></span>

<h3>Description</h3>

<p>Four models with labor-saving technological progress are presented to illustrate dividend, which have the same steady-state equilibrium.
</p>
<p>These models are as follows:
(1) a real timeline model with head-tail adjustment;
(2) a financial timeline model with dividend and head-tail adjustment;
(3) a financial sequential model with dividend;
(4) a financial time-circle model with dividend.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_Dividend_TechnologicalProgress(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_Dividend_TechnologicalProgress_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gemIntertemporal_Dividend">gemIntertemporal_Dividend</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### (1) a real timeline model with head-tail adjustment.
eis &lt;- 0.8 # the elasticity of intertemporal substitution
Gamma.beta &lt;- 0.8 # the subjective discount factor
gr.tech &lt;- 0.02 # the technological progress rate
gr.lab &lt;- 0.03 # the growth rate of labor supply
gr &lt;- (1 + gr.lab) * (1 + gr.tech) - 1 # the growth rate
np &lt;- 4 # the number of economic periods

n &lt;- 2 * np - 1 # the number of commodity kinds
m &lt;- np # the number of agent kinds

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:(np - 1)))
names.agent &lt;- c(paste0("firm", 1:(np - 1)), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:(np - 1)), "consumer"] &lt;- 100 * (1 + gr.lab)^(0:(np - 2))
S0Exg["prod1", "consumer"] &lt;- 140 # the product supply in the first period, which will be adjusted.

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}

dstl.firm &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "CD",
    alpha = 2, beta = c(0.5, 0.5),
    paste0("prod", k), "cc1"
  )
  node_set(dstl.firm[[k]], "cc1",
           type = "Leontief", a = 1 / (1 + gr.tech)^(k - 1),
           paste0("lab", k)
  )
}

node_plot(dstl.firm[[np - 1]], TRUE)

dst.consumer &lt;- node_new(
  "util",
  type = "CES", es = eis,
  alpha = 1, beta = prop.table(Gamma.beta^(1:np)),
  paste0("prod", 1:np)
)

ge &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "prod1",
  policy = makePolicyHeadTailAdjustment(gr = gr, np = np)
)

sserr(eis, Gamma.beta, gr) # the steady-state equilibrium return rate
ge$p[1:(np - 1)] / ge$p[2:np] - 1 # the steady-state equilibrium return rate
ge$z
growth_rate(ge$z)

## (2) a financial timeline model with dividend and head-tail adjustment.
yield.rate &lt;- sserr(eis, Gamma.beta, gr, prepaid = TRUE)

n &lt;- 2 * np # the number of commodity kinds
m &lt;- np # the number of agent kinds

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:(np - 1)), "claim")
names.agent &lt;- c(paste0("firm", 1:(np - 1)), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:(np - 1)), "consumer"] &lt;- 100 * (1 + gr.lab)^(0:(np - 2))
S0Exg["claim", "consumer"] &lt;- 100
S0Exg["prod1", "consumer"] &lt;- 140 # the product supply in the first period, which will be adjusted.

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}

dstl.firm &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "FIN", rate = c(1, yield.rate),
    "cc1", "claim"
  )
  node_set(dstl.firm[[k]], "cc1",
           type = "CD", alpha = 2, beta = c(0.5, 0.5),
           paste0("prod", k), "cc1.1"
  )
  node_set(dstl.firm[[k]], "cc1.1",
           type = "Leontief", a = 1 / (1 + gr.tech)^(k - 1),
           paste0("lab", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "CES", es = 1,
  alpha = 1, beta = prop.table(rep(1, np)), # prop.table(Gamma.beta^(1:np)),
  paste0("prod", 1:np)
)

ge &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "prod1",
  policy = makePolicyHeadTailAdjustment(gr = gr, np = np)
)

ge$z

## (3) a financial sequential model with dividend.
dst.firm &lt;- node_new("output",
                     type = "FIN",
                     rate = c(1, dividend.rate = yield.rate),
                     "cc1", "equity.share"
)
node_set(dst.firm, "cc1",
         type = "CD",
         alpha = 2, beta = c(0.5, 0.5),
         "prod", "cc1.1"
)
node_set(dst.firm, "cc1.1",
         type = "Leontief", a = 1,
         "lab"
)

node_plot(dst.firm, TRUE)

dst.laborer &lt;- node_new("util",
                        type = "Leontief", a = 1,
                        "prod"
)

dst.shareholder &lt;- Clone(dst.laborer)

ge &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.shareholder),
  B = diag(c(1, 0, 0)),
  S0Exg = {
    S0Exg &lt;- matrix(NA, 3, 3)
    S0Exg[2, 2] &lt;- 100 / (1 + gr.lab)
    S0Exg[3, 3] &lt;- 100
    S0Exg
  },
  names.commodity = c("prod", "lab", "equity.share"),
  names.agent = c("firm", "laborer", "shareholder"),
  numeraire = "equity.share",
  maxIteration = 1,
  numberOfPeriods = 20,
  z0 = c(143.1811, 0, 0),
  policy = list(policy.technology &lt;- function(time, A, state) {
    node_set(A[[1]], "cc1.1",
             a = 1 / (1 + gr.tech)^(time - 1)
    )
    state$S[2, 2] &lt;- 100 * (1 + gr.lab)^(time - 1)

    state
  }, policyMarketClearingPrice),
  ts = TRUE
)

ge$ts.z[, 1]
growth_rate(ge$ts.z[, 1])

## (4) a financial time-circle model with dividend.
zeta &lt;- (1 + gr)^np # the ratio of repayments to loans

n &lt;- 2 * np + 1 # the number of commodity kinds
m &lt;- np + 1 # the number of agent kinds

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:np), "claim")
names.agent &lt;- c(paste0("firm", 1:np), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:np), "consumer"] &lt;- 100 * (1 + gr.lab)^(0:(np - 1))
S0Exg["claim", "consumer"] &lt;- 100

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}
B["prod1", paste0("firm", np)] &lt;- 1 / zeta

dstl.firm &lt;- list()
for (k in 1:np) {
  dstl.firm[[k]] &lt;- node_new("output",
                             type = "FIN", rate = c(1, yield.rate),
                             "cc1", "claim"
  )
  node_set(dstl.firm[[k]], "cc1",
           type = "CD", alpha = 2,
           beta = c(0.5, 0.5),
           paste0("prod", k), "cc1.1"
  )
  node_set(dstl.firm[[k]], "cc1.1",
           type = "Leontief", a = 1 / (1 + gr.tech)^(k - 1),
           paste0("lab", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "CES", es = 1,
  alpha = 1, beta = prop.table(rep(1, np)),
  paste0("prod", 1:np)
)

ge &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "prod1",
  ts = TRUE
)

ge$z
growth_rate(ge$z[1:np])

</code></pre>

<hr>
<h2 id='gemIntertemporal_EndogenousEquilibriumInterestRate'>An Example Illustrating Endogenous Equilibrium Interest Rates in a (Timeline) Transitional Equilibrium Path</h2><span id='topic+gemIntertemporal_EndogenousEquilibriumInterestRate'></span>

<h3>Description</h3>

<p>This example illustrates (endogenous) equilibrium primitive interest rates in a transitional equilibrium path,
which is an intertemporal path distinct from a steady-state equilibrium.
Assume that the velocity of money is equal to one, that is, money circulates once per period.
</p>
<p>The interest rate calculated here is adjusted from the nominal interest rate based on the growth rate of the money supply,
which is equal to the nominal interest rate when the money stock remains unchanged.
We refer to this kind of interest rate as the primitive interest rate,
which usually differs from the real interest rate obtained by adjusting the nominal rate based on the inflation rate.
</p>
<p>There are three types of economic agents in the model: firms, a laborer, and a money owner.
Suppose the laborer and the money owner need to use money to buy products, and firms need to use money to buy products and labor.
Formally, the money owner borrows money from himself and pays interest to himself.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_EndogenousEquilibriumInterestRate(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_EndogenousEquilibriumInterestRate_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
eis &lt;- 0.8 # the elasticity of intertemporal substitution
Gamma.beta &lt;- 0.8 # the subjective discount factor
gr &lt;- 0 # the steady-state growth rate
np &lt;- 20 # the number of economic periods

f &lt;- function(ir = rep(0.25, np - 1), return.ge = FALSE,
              y1 = 10, # the product supply in the first period
              alpha.firm = rep(2, np - 1) # the efficiency parameters of firms
) {
  n &lt;- 2 * np # the number of commodity kinds
  m &lt;- np + 1 # the number of agent kinds

  names.commodity &lt;- c(
    paste0("prod", 1:np),
    paste0("lab", 1:(np - 1)),
    "money"
  )
  names.agent &lt;- c(
    paste0("firm", 1:(np - 1)),
    "laborer", "moneyOwner"
  )

  # the exogenous supply matrix.
  S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
  S0Exg[paste0("lab", 1:(np - 1)), "laborer"] &lt;- 100 * (1 + gr)^(0:(np - 2))
  S0Exg["money", "moneyOwner"] &lt;- 100
  S0Exg["prod1", "laborer"] &lt;- y1

  # the output coefficient matrix.
  B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
  for (k in 1:(np - 1)) {
    B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
  }

  dstl.firm &lt;- list()
  for (k in 1:(np - 1)) {
    dstl.firm[[k]] &lt;- node_new(
      "prod",
      type = "FIN", rate = c(1, ir[k]),
      "cc1", "money"
    )
    node_set(dstl.firm[[k]], "cc1",
             type = "CD", alpha = alpha.firm[k], beta = c(0.5, 0.5),
             paste0("prod", k), paste0("lab", k)
    )
  }

  dst.laborer &lt;- node_new(
    "util",
    type = "CES", es = eis,
    alpha = 1, beta = prop.table(Gamma.beta^(1:np)),
    paste0("cc", 1:(np - 1)), paste0("prod", np)
  )

  for (k in 1:(np - 1)) {
    node_set(dst.laborer, paste0("cc", k),
             type = "FIN", rate = c(1, ir[k]),
             paste0("prod", k), "money"
    )
  }

  dst.moneyOwner &lt;- node_new(
    "util",
    type = "CES", es = eis,
    alpha = 1, beta = prop.table(Gamma.beta^(1:(np - 1))),
    paste0("cc", 1:(np - 1))
  )
  for (k in 1:(np - 1)) {
    node_set(dst.moneyOwner, paste0("cc", k),
             type = "FIN", rate = c(1, ir[k]),
             paste0("prod", k), "money"
    )
  }

  ge &lt;- sdm2(
    A = c(dstl.firm, dst.laborer, dst.moneyOwner),
    B = B,
    S0Exg = S0Exg,
    names.commodity = names.commodity,
    names.agent = names.agent,
    numeraire = "prod1",
    policy = makePolicyHeadTailAdjustment(gr = gr, np = np, type = c("tail"))
  )

  tmp &lt;- rowSums(ge$SV)
  ts.exchange.value &lt;- tmp[paste0("prod", 1:(np - 1))] + tmp[paste0("lab", 1:(np - 1))]
  ir.new &lt;- ts.exchange.value[1:(np - 2)] / ts.exchange.value[2:(np - 1)] - 1
  ir.new &lt;- pmax(1e-6, ir.new)
  ir.new[np - 1] &lt;- ir.new[np - 2]

  ir &lt;- c(ir * ratio_adjust(ir.new / ir, 0.3))
  cat("ir: ", ir, "\n")

  if (return.ge) {
    ge$ts.exchange.value &lt;- ts.exchange.value
    return(ge)
  } else {
    return(ir)
  }
}

## Calculate equilibrium interest rates.
## Warning: Running the program below takes about several minutes.
# mat.ir &lt;- iterate(rep(0.1, np - 1), f, tol = 1e-4)
# sserr(eis, Gamma.beta, gr, prepaid = TRUE)

## Below are the calculated equilibrium interest rates.
ir &lt;- rep(0.25, np - 1)
ir[1:14] &lt;- c(0.4301, 0.3443, 0.3007, 0.2776, 0.2652, 0.2584, 0.2546,
  0.2526, 0.2514, 0.2508, 0.2504, 0.2502, 0.2501, 0.2501)

ge &lt;- f(ir, TRUE)

plot(ge$z[1:(np - 1)], type = "o")
ge$ts.exchange.value[1:(np - 2)] / ge$ts.exchange.value[2:(np - 1)] - 1
ir

## Calculate the growth rate of the money supply and the equilibrium nominal
## interest rate when the current price of the product remains constant.
price.money &lt;- 1 / c(1, cumprod(ir + 1))
currentPrice.prod &lt;- ge$p[1:np] / price.money
gr.moneySupply &lt;- unname(growth_rate(1 / currentPrice.prod))
(ir + 1) * (gr.moneySupply[2:np] + 1) - 1

## the corresponding sequential model with the same steady-state equilibrium.
np &lt;- 5
ge.ss &lt;- f(return.ge = TRUE, y1 = 128)

dividend.rate &lt;- ir &lt;- sserr(eis, Gamma.beta, prepaid = TRUE)

dst.firm &lt;- node_new("prod",
                     type = "FIN", rate = c(1, ir, (1 + ir) * dividend.rate),
                     "cc1", "money", "equity.share"
)
node_set(dst.firm, "cc1",
         type = "CD",
         alpha = 2, beta = c(0.5, 0.5),
         "prod", "lab"
)

dst.laborer &lt;- node_new("util",
                        type = "FIN", rate = c(1, ir),
                        "prod", "money"
)

dst.moneyOwner &lt;- node_new("util",
                           type = "FIN", rate = c(1, ir),
                           "prod", "money"
)

ge2 &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.moneyOwner),
  B = matrix(c(
    1, 0, 0,
    0, 0, 0,
    0, 0, 0,
    0, 0, 0
  ), 4, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 100, NA,
    NA, NA, 100,
    NA, 100, NA
  ), 4, 3, TRUE),
  names.commodity = c(
    "prod", "lab", "money", "equity.share"
  ),
  names.agent = c("firm", "laborer", "moneyOwner"),
  numeraire = "prod"
)

ge2$p
ge.ss$z[np - 1]
ge2$z
ge.ss$D[paste0("prod", np - 1), c("laborer", "moneyOwner")]
ge2$D

## a technology shock.
## Warning: Running the program below takes about several minutes.
# np &lt;- 50
# f2 &lt;- function(x) {
#  f(
#     ir = x, return.ge = FALSE,
#     y1 = 128, alpha.firm = {
#       tmp &lt;- rep(2, np - 1)
#       tmp[25] &lt;- 1.8
#       tmp
#     }
#   )
# }
#
# mat.ir &lt;- iterate(rep(0.25, np - 1), f2, tol = 1e-4)
# tail(mat.ir, 1) # the equilibrium interest rates

## Calculate equilibrium interest rates.
## Warning: Running the program below takes about several minutes.
# np &lt;- 20
# gr &lt;- 0.03
# mat.ir &lt;- iterate(rep(0.1, np - 1), f, tol = 1e-4)
# sserr(eis, Gamma.beta, gr, prepaid = TRUE)

</code></pre>

<hr>
<h2 id='gemIntertemporal_EndogenousEquilibriumInterestRate_ForeignExchangeRate'>An Example Illustrating Endogenous Equilibrium Interest Rates and Foreign Exchange Rates in a Two-country (Timeline) Transitional Equilibrium Path</h2><span id='topic+gemIntertemporal_EndogenousEquilibriumInterestRate_ForeignExchangeRate'></span>

<h3>Description</h3>

<p>This example illustrates (endogenous) equilibrium primitive interest rates and foreign exchange rates in a two-country transitional equilibrium path.
Assume that the velocity of money is equal to one, that is, money circulates once per period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_EndogenousEquilibriumInterestRate_ForeignExchangeRate(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_EndogenousEquilibriumInterestRate_ForeignExchangeRate_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gemIntertemporal_EndogenousEquilibriumInterestRate">gemIntertemporal_EndogenousEquilibriumInterestRate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
eis &lt;- 0.8 # the elasticity of intertemporal substitution
Gamma.beta &lt;- 10 / 11 # the subjective discount factor
gr &lt;- 0 # the steady-state growth rate
money1.supply &lt;- 600
money2.supply &lt;- 100
np &lt;- 20 # the number of economic periods

sserr(eis, Gamma.beta, gr, prepaid = TRUE)

f &lt;- function(ir = rep(0.1, 2 * np - 2), return.ge = FALSE,
              y1.wheat = 10, # 49.24 #49.79 the wheat supply in the first period
              y1.iron = 5 # 41.32 #45.45 the iron supply in the first period
) {
  ir1 &lt;- head(ir, np - 1)
  ir2 &lt;- tail(ir, np - 1)

  n &lt;- 2 * np + 2 * (np - 1) + 2 # the number of commodity kinds
  m &lt;- 2 * (np - 1) + 4 # the number of agent kinds

  names.commodity &lt;- c(
    paste0("wheat", 1:np),
    paste0("lab1.", 1:(np - 1)),
    "money1",
    paste0("iron", 1:np),
    paste0("lab2.", 1:(np - 1)),
    "money2"
  )

  names.agent &lt;- c(
    paste0("firm.wheat", 1:(np - 1)),
    "laborer1", "moneyOwner1",
    paste0("firm.iron", 1:(np - 1)),
    "laborer2", "moneyOwner2"
  )

  # the exogenous supply matrix.
  S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
  S0Exg[paste0("lab1.", 1:(np - 1)), "laborer1"] &lt;- 100 * (1 + gr)^(0:(np - 2))
  S0Exg["money1", "moneyOwner1"] &lt;- money1.supply
  S0Exg["wheat1", "laborer1"] &lt;- y1.wheat

  S0Exg[paste0("lab2.", 1:(np - 1)), "laborer2"] &lt;- 100 * (1 + gr)^(0:(np - 2))
  S0Exg["money2", "moneyOwner2"] &lt;- money2.supply
  S0Exg["iron1", "laborer2"] &lt;- y1.iron

  # the output coefficient matrix.
  B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
  for (k in 1:(np - 1)) {
    B[paste0("wheat", k + 1), paste0("firm.wheat", k)] &lt;- 1
    B[paste0("iron", k + 1), paste0("firm.iron", k)] &lt;- 1
  }

  dstl.firm.wheat &lt;- dstl.firm.iron &lt;- list()
  for (k in 1:(np - 1)) {
    dstl.firm.wheat[[k]] &lt;- node_new(
      "prod",
      type = "FIN", rate = c(1, ir1[k]),
      "cc1", "money1"
    )
    node_set(dstl.firm.wheat[[k]], "cc1",
      type = "CD", alpha = 1, beta = c(0.5, 0.5),
      paste0("iron", k), paste0("lab1.", k)
    )

    dstl.firm.iron[[k]] &lt;- node_new(
      "prod",
      type = "FIN", rate = c(1, ir2[k]),
      "cc1", "money2"
    )
    node_set(dstl.firm.iron[[k]], "cc1",
      type = "CD", alpha = 1, beta = c(0.5, 0.5),
      paste0("iron", k), paste0("lab2.", k)
    )
  }

  dst.laborer1 &lt;- node_new(
    "util",
    type = "CES", es = eis,
    alpha = 1, beta = prop.table(Gamma.beta^(1:np)),
    paste0("cc", 1:(np - 1)), paste0("wheat", np)
  )
  for (k in 1:(np - 1)) {
    node_set(dst.laborer1, paste0("cc", k),
      type = "FIN", rate = c(1, ir1[k]),
      paste0("wheat", k), "money1"
    )
  }

  dst.moneyOwner1 &lt;- node_new(
    "util",
    type = "CES", es = eis,
    alpha = 1, beta = prop.table(Gamma.beta^(1:(np - 1))),
    paste0("cc", 1:(np - 1))
  )
  for (k in 1:(np - 1)) {
    node_set(dst.moneyOwner1, paste0("cc", k),
      type = "FIN", rate = c(1, ir1[k]),
      paste0("wheat", k), "money1"
    )
  }

  dst.laborer2 &lt;- node_new(
    "util",
    type = "CES", es = eis,
    alpha = 1, beta = prop.table(Gamma.beta^(1:np)),
    paste0("cc", 1:(np - 1)), paste0("iron", np)
  )

  for (k in 1:(np - 1)) {
    node_set(dst.laborer2, paste0("cc", k),
      type = "FIN", rate = c(1, ir2[k]),
      paste0("wheat", k), "money2"
    )
  }

  dst.moneyOwner2 &lt;- node_new(
    "util",
    type = "CES", es = eis,
    alpha = 1, beta = prop.table(Gamma.beta^(1:(np - 1))),
    paste0("cc", 1:(np - 1))
  )
  for (k in 1:(np - 1)) {
    node_set(dst.moneyOwner2, paste0("cc", k),
      type = "FIN", rate = c(1, ir2[k]),
      paste0("wheat", k), "money2"
    )
  }

  ge &lt;- sdm2(
    A = c(
      dstl.firm.wheat, dst.laborer1, dst.moneyOwner1,
      dstl.firm.iron, dst.laborer2, dst.moneyOwner2
    ),
    B = B,
    S0Exg = S0Exg,
    names.commodity = names.commodity,
    names.agent = names.agent,
    numeraire = "wheat1",
    policy = makePolicyTailAdjustment(
      ind = rbind(
        c(np - 1, np),
        c(2 * np, 2 * (np - 1) + 3)
      ),
      gr = gr
    )
  )

  tmp &lt;- rowSums(ge$SV)

  ts1.exchange.value &lt;- tmp[paste0("wheat", 1:(np - 1))] + tmp[paste0("lab1.", 1:(np - 1))]
  ir1.new &lt;- ts1.exchange.value[1:(np - 2)] / ts1.exchange.value[2:(np - 1)] - 1
  ir1.new &lt;- pmax(1e-6, ir1.new)
  ir1.new[np - 1] &lt;- ir1.new[np - 2]

  ir1 &lt;- c(ir1 * ratio_adjust(ir1.new / ir1, 0.3))
  cat("ir1: ", ir1, "\n")


  ts2.exchange.value &lt;- tmp[paste0("iron", 1:(np - 1))] + tmp[paste0("lab2.", 1:(np - 1))]
  ir2.new &lt;- ts2.exchange.value[1:(np - 2)] / ts2.exchange.value[2:(np - 1)] - 1
  ir2.new &lt;- pmax(1e-6, ir2.new)
  ir2.new[np - 1] &lt;- ir2.new[np - 2]

  ir2 &lt;- c(ir2 * ratio_adjust(ir2.new / ir2, 0.3))
  cat("ir2: ", ir2, "\n")

  if (return.ge) {
    ge$ts1.exchange.value &lt;- unname(ts1.exchange.value)
    ge$ts2.exchange.value &lt;- unname(ts2.exchange.value)
    ge$ts.forex &lt;- unname((ge$ts2.exchange.value / money2.supply) /
      (ge$ts1.exchange.value / money1.supply))
    return(ge)
  } else {
    return(c(ir1, ir2))
  }
}

## Calculate equilibrium interest rates.
## Warning: Running the program below takes about several minutes.
# mat.ir &lt;- iterate(rep(0.1, 2*np - 2), f, tol = 1e-4)
# sserr(eis, Gamma.beta, gr, prepaid = TRUE)

## Below are the calculated equilibrium interest rates.
ir1 &lt;- c(
  0.2218, 0.1888, 0.1455, 0.1228, 0.1115, 0.1058, 0.1029, 0.1015, 0.1008,
  0.1004, 0.1002, 0.1001, 0.1001, 0.1000, 0.1000, 0.1000, 0.1000, 0.1000, 0.1000
)
ir2 &lt;- c(
  0.1292, 0.1080, 0.1037, 0.1019, 0.1010, 0.1005, 0.1003, 0.1001, 0.1001,
  0.1000, 0.1000, 0.1000, 0.1000, 0.1000, 0.1000, 0.1000, 0.1000, 0.1000, 0.1000
)

ge &lt;- f(c(ir1, ir2), return.ge = TRUE)
plot(ge$z[1:(np - 1)], type = "o", ylab = "wheat output")
ge$ts.forex

## the corresponding sequential model with the same steady-state equilibrium.
np &lt;- 5
ge.ss &lt;- f(return.ge = TRUE, y1.wheat = 49.24, y1.iron = 41.32)

ir &lt;- dividend.rate &lt;- 0.1

dst.firm.wheat &lt;- node_new("output",
  type = "FIN", rate = c(1, ir, (1 + ir) * dividend.rate),
  "cc1", "money1", "equity.share.wheat"
)
node_set(dst.firm.wheat, "cc1",
  type = "CD", alpha = 1,
  beta = c(0.5, 0.5),
  "iron", "lab1"
)

dst.firm.iron &lt;- node_new("output",
  type = "FIN", rate = c(1, ir, (1 + ir) * dividend.rate),
  "cc1", "money2", "equity.share.iron"
)
node_set(dst.firm.iron, "cc1",
  type = "CD", alpha = 1,
  beta = c(0.5, 0.5),
  "iron", "lab2"
)

dst.laborer1 &lt;- node_new("util",
  type = "FIN", rate = c(1, interest.rate = 0.1),
  "cc1", "money1"
)
node_set(dst.laborer1, "cc1",
  type = "Leontief", a = 1,
  "wheat"
)

dst.moneyOwner1 &lt;- Clone(dst.laborer1)

dst.laborer2 &lt;- Clone(dst.laborer1)
node_replace(dst.laborer2, "money1", "money2")

dst.moneyOwner2 &lt;- Clone(dst.laborer2)

ge &lt;- sdm2(
  A = list(
    dst.firm.wheat, dst.laborer1, dst.moneyOwner1,
    dst.firm.iron, dst.laborer2, dst.moneyOwner2
  ),
  B = matrix(c(
    1, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 0, 0,
    0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0
  ), 8, 6, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA, NA, NA,
    NA, 100, NA, NA, NA, NA,
    NA, NA, 600, NA, NA, NA,
    NA, 100, NA, NA, NA, NA,
    NA, NA, NA, NA, NA, NA,
    NA, NA, NA, NA, 100, NA,
    NA, NA, NA, NA, NA, 100,
    NA, NA, NA, NA, 100, NA
  ), 8, 6, TRUE),
  names.commodity = c(
    "wheat", "lab1", "money1", "equity.share.wheat",
    "iron", "lab2", "money2", "equity.share.iron"
  ),
  names.agent = c(
    "firm1", "laborer1", "moneyOwner1",
    "firm2", "laborer2", "moneyOwner2"
  ),
  numeraire = c("money1" = 0.1) # interest.rate
)

ge.ss$ts.forex
ge$p["money2"] / ge$p["money1"] # the foreign exchange rate

## Calculate equilibrium interest rates.
## Warning: Running the program below takes about several minutes.
# np &lt;- 20
# gr &lt;- 0.03
# mat.ir &lt;- iterate(rep(0.1, 2*np - 2), f, tol = 1e-4)
# sserr(eis, Gamma.beta, gr, prepaid = TRUE)

## a steady-state equilibrium with an exogenous interest rate 0.1.
## The endogenous equilibrium interest rate and dividend rate are 0.
## See also CGE::Example7.6.
eis &lt;- 1 # the elasticity of intertemporal substitution
Gamma.beta &lt;- 1 # the subjective discount factor
gr &lt;- 0 # the steady-state growth rate
money1.supply &lt;- 600
money2.supply &lt;- 100
np &lt;- 20 # the number of economic periods

np &lt;- 5
ge.ss &lt;- f(return.ge = TRUE, y1.wheat = 49.79, y1.iron = 45.45)
ge.ss$z
ge.ss$ts.forex

</code></pre>

<hr>
<h2 id='gemIntertemporal_EndogenousEquilibriumInterestRate_MoneyVelocity'>An Example Illustrating Endogenous Equilibrium Interest Rates and the Velocity of Money in a (Timeline) Transitional Equilibrium Path</h2><span id='topic+gemIntertemporal_EndogenousEquilibriumInterestRate_MoneyVelocity'></span>

<h3>Description</h3>

<p>This example illustrates (endogenous) equilibrium primitive interest rates and the velocity of money in a transitional equilibrium path.
The (primitive) interest rate here can be divided into two types, namely the interest rate in the case of lump-sum interest payment and the interest rate in the case of installment interest payment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_EndogenousEquilibriumInterestRate_MoneyVelocity(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_EndogenousEquilibriumInterestRate_MoneyVelocity_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gemIntertemporal_EndogenousEquilibriumInterestRate">gemIntertemporal_EndogenousEquilibriumInterestRate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
vm &lt;- 4 # the velocity of money
eis &lt;- 0.8 # the elasticity of intertemporal substitution
Gamma.beta &lt;- 0.8 # the subjective discount factor
gr &lt;- 0 # the steady-state growth rate
np &lt;- 20 # the number of economic periods

f &lt;- function(ir.installment = rep(0.25, np - 1), return.ge = FALSE,
              y1 = 10, # the product supply in the first period
              alpha.firm = rep(2, np - 1) # the efficiency parameters of firms
) {
  n &lt;- 2 * np # the number of commodity kinds
  m &lt;- np + 1 # the number of agent kinds

  names.commodity &lt;- c(
    paste0("prod", 1:np),
    paste0("lab", 1:(np - 1)),
    "money"
  )
  names.agent &lt;- c(
    paste0("firm", 1:(np - 1)),
    "laborer", "moneyOwner"
  )

  # the exogenous supply matrix.
  S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
  S0Exg[paste0("lab", 1:(np - 1)), "laborer"] &lt;- 100 * (1 + gr)^(0:(np - 2))
  S0Exg["money", "moneyOwner"] &lt;- 100
  S0Exg["prod1", "laborer"] &lt;- y1

  # the output coefficient matrix.
  B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
  for (k in 1:(np - 1)) {
    B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
  }

  dstl.firm &lt;- list()
  for (k in 1:(np - 1)) {
    dstl.firm[[k]] &lt;- node_new(
      "prod",
      type = "FIN", rate = c(1, ir.installment[k] / vm),
      "cc1", "money"
    )
    node_set(dstl.firm[[k]], "cc1",
      type = "CD", alpha = alpha.firm[k], beta = c(0.5, 0.5),
      paste0("prod", k), paste0("lab", k)
    )
  }

  dst.laborer &lt;- node_new(
    "util",
    type = "CES", es = eis,
    alpha = 1, beta = prop.table(Gamma.beta^(1:np)),
    paste0("cc", 1:(np - 1)), paste0("prod", np)
  )

  for (k in 1:(np - 1)) {
    node_set(dst.laborer, paste0("cc", k),
      type = "FIN", rate = c(1, ir.installment[k] / vm),
      paste0("prod", k), "money"
    )
  }

  dst.moneyOwner &lt;- node_new(
    "util",
    type = "CES", es = eis,
    alpha = 1, beta = prop.table(Gamma.beta^(1:(np - 1))),
    paste0("cc", 1:(np - 1))
  )
  for (k in 1:(np - 1)) {
    node_set(dst.moneyOwner, paste0("cc", k),
      type = "FIN", rate = c(1, ir.installment[k] / vm),
      paste0("prod", k), "money"
    )
  }

  ge &lt;- sdm2(
    A = c(dstl.firm, dst.laborer, dst.moneyOwner),
    B = B,
    S0Exg = S0Exg,
    names.commodity = names.commodity,
    names.agent = names.agent,
    numeraire = "prod1",
    policy = makePolicyHeadTailAdjustment(gr = gr, np = np, type = c("tail"))
  )

  tmp &lt;- rowSums(ge$SV)
  ts.exchange.value &lt;- tmp[paste0("prod", 1:(np - 1))] + tmp[paste0("lab", 1:(np - 1))]
  # The lump-sum interest rate equals the yield rate of money.
  ir.lumpsum &lt;- ts.exchange.value[1:(np - 2)] / ts.exchange.value[2:(np - 1)] - 1
  ir.lumpsum &lt;- pmax(1e-6, ir.lumpsum)
  ir.lumpsum[np - 1] &lt;- ir.lumpsum[np - 2]
  ir.installment.new &lt;- 1 / (1 / ir.lumpsum + 1 - 1 / vm)

  ir.installment &lt;- c(ir.installment * ratio_adjust(ir.installment.new / ir.installment, 0.3))
  cat("ir.installment: ", ir.installment, "\n")

  if (return.ge) {
    ge$ts.exchange.value &lt;- ts.exchange.value
    return(ge)
  } else {
    return(ir.installment)
  }
}

## Calculate equilibrium installment interest rates.
## Warning: Running the program below takes about several minutes.
## mat.ir.installment &lt;- iterate(rep(0.1, np - 1), f, tol = 1e-4)
## # the lump-sum interest rate in the steady-state equilibrium.
## ir.lumpsum.steadyState &lt;- sserr(eis, Gamma.beta, gr, prepaid = TRUE)
## # the installment interest rate in the steady-state equilibrium.
## 1 / (1 / ir.lumpsum.steadyState + 1 - 1 / vm)

## Below are the calculated equilibrium installment interest rates.
(ir.installment &lt;- c(
  0.3723, 0.2981, 0.2580, 0.2363, 0.2245, 0.2181, 0.2147,
  0.2128, 0.2118, 0.2112, 0.2109, 0.2107, 0.2106, 0.2106,
  0.2106, 0.2105, 0.2105, 0.2106, 0.2106
))

ge &lt;- f(ir.installment, TRUE)

plot(ge$z[1:(np - 1)], type = "o")

# The yield rate is the interest rate for a lump-sum payment.
(ir.lumpsum &lt;- ge$ts.exchange.value[1:(np - 2)] / ge$ts.exchange.value[2:(np - 1)] - 1)
1 / (1 / ir.lumpsum + 1 - 1 / vm) # consistent with the installment interest rates
# consistent with the lump-sum interest rates.
ir.installment / (1 + ir.installment / vm - ir.installment)

## Calculate the growth rate of the money supply and the equilibrium nominal
## lump-sum interest rates when the current price of the product remains constant.
price.money &lt;- 1 / c(1, cumprod(ir.installment + 1))
currentPrice.prod &lt;- ge$p[1:np] / price.money
gr.moneySupply &lt;- unname(growth_rate(1 / currentPrice.prod))
# the equilibrium nominal lump-sum interest rates
(1 + ir.lumpsum) * (gr.moneySupply[2:(np - 1)] + 1) - 1
(1 + ir.installment / (1 + ir.installment / vm - ir.installment)) * (gr.moneySupply[2:np] + 1) - 1

## the corresponding sequential model with the same steady-state equilibrium.
dividend.rate &lt;- sserr(eis, Gamma.beta, prepaid = TRUE)
ir.installment &lt;- 1 / (1 / dividend.rate + 1 - 1 / vm)

np &lt;- 5
ge.ss &lt;- f(ir.installment = rep(ir.installment, np - 1), return.ge = TRUE, y1 = 152)

dst.firm &lt;- node_new("prod",
  type = "FIN", rate = c(1, ir.installment / vm, (1 + ir.installment / vm) * dividend.rate),
  "cc1", "money", "equity.share"
)
node_set(dst.firm, "cc1",
  type = "CD",
  alpha = 2, beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.laborer &lt;- node_new("util",
  type = "FIN", rate = c(1, ir.installment / vm),
  "prod", "money"
)

dst.moneyOwner &lt;- node_new("util",
  type = "FIN", rate = c(1, ir.installment / vm),
  "prod", "money"
)

ge2 &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.moneyOwner),
  B = matrix(c(
    1, 0, 0,
    0, 0, 0,
    0, 0, 0,
    0, 0, 0
  ), 4, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 100, NA,
    NA, NA, 100,
    NA, 100, NA
  ), 4, 3, TRUE),
  names.commodity = c(
    "prod", "lab", "money", "equity.share"
  ),
  names.agent = c("firm", "laborer", "moneyOwner"),
  numeraire = "prod"
)

ge2$p
ge.ss$z[np - 1]
ge2$z
ge.ss$D[paste0("prod", np - 1), c("laborer", "moneyOwner")]
ge2$D

</code></pre>

<hr>
<h2 id='gemIntertemporal_Money_Dividend_Example7.5.1'>The Identical Steady-state Equilibrium: Three Models with Money and Dividend</h2><span id='topic+gemIntertemporal_Money_Dividend_Example7.5.1'></span>

<h3>Description</h3>

<p>Three steady-state-identical models with money and dividend as follows:
(1) a sequential model (Li, 2019, example 7.5);
(2) a time-circle model;
(3) a timeline model with head-tail adjustment.
</p>
<p>Stocks, fiat currencies, bonds, and taxes, etc. can be collectively referred to as ad valorem claims.
Sometimes we do not need to differentiate between these financial instruments when modeling.
Furthermore, sometimes we do not need to consider which period these financial instruments belong to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_Money_Dividend_Example7.5.1(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_Money_Dividend_Example7.5.1_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>LI Wu (2019, ISBN: 9787521804225) General Equilibrium and Structural Dynamics: Perspectives of New Structural Economics. Beijing: Economic Science Press. (In Chinese)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### (1) a sequential model. See the first part of example 7.5 in Li (2019).
dividend.rate &lt;- 0.25
ir &lt;- 0.25 # the interest rate.

dst.firm &lt;- node_new(
  "output",
  type = "FIN", rate = c(1, dividend.rate),
  "cc1", "dividend"
)
node_set(dst.firm, "cc1",
         type = "FIN", rate = c(1, ir),
         "cc1.1", "money"
)
node_set(dst.firm, "cc1.1",
         type = "CD", alpha = 1, beta = c(0.5, 0.5),
         "prod", "lab"
)

dst.consumer &lt;- node_new(
  "util",
  type = "FIN", rate = c(1, ir),
  "cc1", "money"
)
node_set(dst.consumer, "cc1",
         type = "CD", alpha = 1, beta = c(0.5, 0.5),
         "prod", "lab"
)

ge.seq &lt;- sdm2(
  A = list(
    dst.firm, dst.consumer, dst.consumer, dst.consumer
  ),
  B = diag(c(1, 0, 0, 0)),
  S0Exg = {
    tmp &lt;- matrix(NA, 4, 4)
    tmp[2, 2] &lt;- tmp[3, 3] &lt;- tmp[4, 4] &lt;- 100
    tmp
  },
  names.commodity = c("prod", "lab", "money", "dividend"),
  names.agent = c("firm", "laborer", "moneyOwner", "shareholder"),
  numeraire = "prod",
  GRExg = 0.1,
  z0 = c(9.30909, 0, 0, 0),
  policy = policyMarketClearingPrice,
  maxIteration = 1,
  numberOfPeriods = 20,
  ts = TRUE
)

matplot(ge.seq$ts.z, type = "o", pch = 20)
ge.seq$D
ge.seq$S
ge.seq$ts.z[,1]
growth_rate(ge.seq$ts.z[,1])

#### (2) a time-circle model.
np &lt;- 5 # the number of economic periods
gr &lt;- 0.1 # the growth rate.
dividend.rate &lt;- 0.25
ir &lt;- 0.25
zeta &lt;- (1 + gr)^np # the ratio of repayments to loans

n &lt;- 2 * np + 1 # the number of commodity kinds
m &lt;- np + 1 # the number of agent kinds

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:np), "claim")
names.agent &lt;- c(paste0("firm", 1:np), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:np), "consumer"] &lt;- 100 * (1 + gr)^(0:(np - 1)) # the labor supply.
S0Exg["claim", "consumer"] &lt;- np * 100 # the ad valorem claim supply.

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}
B["prod1", paste0("firm", np)] &lt;- 1 / zeta

dstl.firm &lt;- list()
for (k in 1:np) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "FIN", rate = c(1, (1 + ir) * (1 + dividend.rate) - 1),
    "cc1", "claim"
  )
  node_set(dstl.firm[[k]], "cc1",
           type = "CD", alpha = 1, beta = c(0.5, 0.5),
           paste0("prod", k), paste0("lab", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "FIN", rate = c(1, ir),
  "cc1", "claim"
)
node_set(dst.consumer, "cc1",
         # type = "CES", es = 1,
         type = "CD",
         alpha = 1, beta = rep(1 / np, np),
         paste0("cc1.", 1:np)
)
for (k in 1:np) {
  node_set(dst.consumer, paste0("cc1.", k),
           type = "CD", alpha = 1, beta = c(0.5, 0.5),
           paste0("prod", k), paste0("lab", k)
  )
}
node_plot(dst.consumer, TRUE)

ge.tc &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "prod1"
)

ge.tc$D
ge.tc$z

#### (3) a timeline model with head-tail adjustment.
np &lt;- 5 # the number of economic periods
gr &lt;- 0.1
dividend.rate &lt;- 0.25
ir &lt;- 0.25

n &lt;- 2 * np + 1 # the number of commodity kinds
m &lt;- np # the number of agent kinds

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:np), "claim")
names.agent &lt;- c(paste0("firm", 1:(np - 1)), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:np), "consumer"] &lt;- 100 * (1 + gr)^(0:(np - 1))
S0Exg["claim", "consumer"] &lt;- np * 100
S0Exg["prod1", "consumer"] &lt;- 10 # the product supply in the first period, which will be adjusted.

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}

dstl.firm &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "FIN", rate = c(1, (1 + ir) * (1 + dividend.rate) - 1),
    "cc1", "claim"
  )
  node_set(dstl.firm[[k]], "cc1",
           type = "CD", alpha = 1, beta = c(0.5, 0.5),
           paste0("prod", k), paste0("lab", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "FIN", rate = c(1, ir),
  "cc1", "claim"
)
node_set(dst.consumer, "cc1",
         type = "CD",
         alpha = 1, beta = rep(1 / np, np),
         paste0("cc1.", 1:np)
)
for (k in 1:np) {
  node_set(dst.consumer, paste0("cc1.", k),
           type = "CD", alpha = 1, beta = c(0.5, 0.5),
           paste0("prod", k), paste0("lab", k)
  )
}

ge.tl &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "prod1",
  policy = makePolicyHeadTailAdjustment(gr = gr, np = np)
)

node_plot(dst.consumer, TRUE)
ge.tl$D
ge.tl$z

</code></pre>

<hr>
<h2 id='gemIntertemporal_PublicFirm'>Some Examples of Intertemporal (Timeline) Models with Production and Public Firms</h2><span id='topic+gemIntertemporal_PublicFirm'></span>

<h3>Description</h3>

<p>Some examples of intertemporal (timeline) models with production and public firms.
A public producer is akin to a consumer with an infinite lifespan. The public producer owns the products it manufactures.
In each period, it exchanges the products it has produced for the inputs required for production.
In intertemporal models, a public producer can be treated as multiple public firms that each only produces for a single period.
Each public firm hands over its products to the public firm of the next period, which in turn uses these products for trading.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_PublicFirm(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_PublicFirm_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
np &lt;- 15 # the number of economic periods, firms.
gr &lt;- 0  # the growth rate of the labor supply
eis &lt;- 0.5 # the elasticity of intertemporal substitution
Gamma.beta &lt;- 0.9 # the subjective discount factor
y1 &lt;- 100 # the initial product supply

n &lt;- 2 * np # the number of commodity kinds
m &lt;- np + 1 # the number of agent kinds

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:np))
names.agent &lt;- c(paste0("firm", 1:np), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
# the supply of labor.
S0Exg[paste0("lab", 1:np), "consumer"] &lt;- 100 * (1 + gr)^(0:(np - 1))
S0Exg["prod1", "firm1"] &lt;- y1

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}

dstl.firm &lt;- list()
for (k in 1:np) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "CD", alpha = 2, beta = c(0.5, 0.5),
    paste0("lab", k), paste0("prod", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "CES", es = eis,
  alpha = 1, beta = prop.table(Gamma.beta^(1:np)),
  paste0("prod", 1:np)
)

policy.PublicFirm &lt;- function(state) {
  for (k in 1:(np - 1)) {
    state$S[k + 1, k + 1] &lt;- state$S[k + 1, k]
    state$S[k + 1, k] &lt;- 0
  }
  state
}

ge &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "prod1",
  policy=policy.PublicFirm
)

ge$p
ge$z[1:15]

#### the sequential form of the above model.
dst.firm &lt;- node_new(
  "prod",
  type = "CD", alpha = 2, beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.consumer &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "prod"
)

dstl &lt;- list(dst.firm, dst.consumer)

ge.seq &lt;- sdm2(
  A = dstl,
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "lab",
  z0 = c(100, 1),
  ts = TRUE,
  policy = policyMarketClearingPrice,
  numberOfPeriods = 20,
  maxIteration = 1
)

growth_rate(ge$p[paste0("prod", 1:np)]) + 1
growth_rate(ge$p[paste0("lab", 1:np)]) + 1
1 / (1 + sserr(eis, Gamma.beta, gr))
ge.seq$ts.z[, 1]

</code></pre>

<hr>
<h2 id='gemIntertemporal_TimeCircle_2_2'>Some Examples of a 2-by-2 Time Circle Equilibrium Model</h2><span id='topic+gemIntertemporal_TimeCircle_2_2'></span>

<h3>Description</h3>

<p>Some examples of a 2-by-2 (intertemporal) time circle equilibrium model.
In a time circle model, the economy borrows some resources from the outside in the beginning,
and will repay it after the economy ends.
</p>
<p>In these examples, there is an np-period-lived consumer maximizing intertemporal utility,
and there is a type of firm which produces from period 1 to np.
There are two commodities, i.e. product and labor.
Suppose the firm can borrow some product from outside in the first period and return them in the (np+1)-th period.
And the supply of product in the first period can be regarded as the output of the firm in the (np+1)-th period.
Hence the product supply in the first period is an endogenous variable.
Suppose that the amount returned is zeta times the amount borrowed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_TimeCircle_2_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_TimeCircle_2_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>See Also</h3>


<p><code><a href="#topic+gemOLG_TimeCircle">gemOLG_TimeCircle</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an example with a Cobb-Douglas intertemporal utility function
np &lt;- 5 # the number of economic periods, firms.
gr &lt;- 0 # the growth rate of the labor supply
zeta &lt;- 1.25 # the ratio of repayments to loans
# zeta &lt;- (1 + gr)^np
Gamma.beta &lt;- 1 # the subjective discount factor

n &lt;- 2 * np # the number of commodity kinds
m &lt;- np + 1 # the number of agent kinds

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:np))
names.agent &lt;- c(paste0("firm", 1:np), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:np), "consumer"] &lt;- 100 * (1 + gr)^(0:(np - 1)) # the supply of labor

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}
B["prod1", paste0("firm", np)] &lt;- 1 / zeta

dstl.firm &lt;- list()
for (k in 1:np) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "CD", alpha = 2, beta = c(0.5, 0.5),
    paste0("lab", k), paste0("prod", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = prop.table(Gamma.beta^(1:np)),
  paste0("prod", 1:np)
)

ge &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "prod1",
  ts = TRUE
)

ge$p
ge$z
ge$D
ge$S
ge$DV
ge$SV

## an example with a Leontief intertemporal utility function
dst.consumer &lt;- node_new(
  "util",
  type = "Leontief", a = rep(1, np),
  paste0("prod", 1:np)
)

ge2 &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "lab1",
  ts = TRUE
)

ge2$p
ge2$z
ge2$D
ge2$S
ge2$DV
ge2$SV

## Use a mean-value policy function to accelerate convergence.
ge3 &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = c(paste0("prod", 1:np), paste0("lab", 1:np)),
  names.agent = c(paste0("firm", 1:np), "consumer"),
  numeraire = "lab1",
  ts = TRUE,
  policy = makePolicyMeanValue(30)
)

#### an example with a linear intertemporal utility function (e.g. beta1 * x1 + beta2 * x2)
## The demand structure of the consumer will be adjusted sluggishly to accelerate convergence.
np &lt;- 5 # the number of economic periods, firms.
rho &lt;- 0.9 # the subjective discount factor

beta.consumer &lt;- rep(rho^(0:(np - 1)))
zeta &lt;- (1 / rho)^np

n &lt;- 2 * np # the number of commodity kinds
m &lt;- np + 1 # the number of agent kinds

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:np))
names.agent &lt;- c(paste0("firm", 1:np), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:np), "consumer"] &lt;- 100 # the supply of labor

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}
B["prod1", paste0("firm", np)] &lt;- 1 / zeta

dstl.firm &lt;- list()
for (k in 1:np) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "CD", alpha = 2, beta = c(0.5, 0.5),
    paste0("lab", k), paste0("prod", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "FUNC",
  last.a = rep(1, np),
  func = function(p) {
    value.marginal.utility &lt;- beta.consumer / p
    ratio &lt;- value.marginal.utility / mean(value.marginal.utility)
    a &lt;- dst.consumer$last.a
    a &lt;- prop.table(a * ratio_adjust(ratio, 0.15))
    dst.consumer$last.a &lt;- a
    a
  },
  paste0("prod", 1:np)
)

ge &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "lab1",
  ts = TRUE,
  priceAdjustmentVelocity = 0.1
)

ge$p
ge$z
ge$D
ge$S
growth_rate(ge$p[1:np])
growth_rate(ge$p[(np + 1):(2 * np)])

</code></pre>

<hr>
<h2 id='gemIntertemporal_TimeCircle_3_3'>A Time Circle Model with One Consumer and Two Types of Firms</h2><span id='topic+gemIntertemporal_TimeCircle_3_3'></span>

<h3>Description</h3>

<p>An (intertemporal) time circle model with one consumer and two types of firms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_TimeCircle_3_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_TimeCircle_3_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an example with a Cobb-Douglas intertemporal utility function
np &lt;- 5 # the number of economic periods, firms.
zeta &lt;- 1.25 # the ratio of repayments to loans

n &lt;- 3 * np # the number of commodity kinds
m &lt;- 2 * np + 1 # the number of agent kinds

names.commodity &lt;- c(
  paste0("corn", 1:np),
  paste0("iron", 1:np),
  paste0("lab", 1:np)
)
names.agent &lt;- c(
  paste0("firm.corn", 1:np),
  paste0("firm.iron", 1:np),
  "consumer"
)

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:np), "consumer"] &lt;- 100 # the supply of labor

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("corn", k + 1), paste0("firm.corn", k)] &lt;- 1
  B[paste0("iron", k + 1), paste0("firm.iron", k)] &lt;- 1
}
B["corn1", paste0("firm.corn", np)] &lt;- 1 / zeta
B["iron1", paste0("firm.iron", np)] &lt;- 1 / zeta

dstl.firm.corn &lt;- dstl.firm.iron &lt;- list()
for (k in 1:np) {
  dstl.firm.corn[[k]] &lt;- node_new(
    "prod",
    type = "CD",
    alpha = 1, beta = c(0.5, 0.5),
    paste0("iron", k), paste0("lab", k)
  )

  dstl.firm.iron[[k]] &lt;- node_new(
    "prod",
    type = "CD",
    alpha = 2, beta = c(0.5, 0.5),
    paste0("iron", k), paste0("lab", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1,
  beta = prop.table(rep(1, np)),
  paste0("corn", 1:np)
)

ge &lt;- sdm2(
  A = c(dstl.firm.corn, dstl.firm.iron, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "lab1",
  ts = TRUE
)

ge$p
ge$z
ge$D
ge$S
ge$DV
ge$SV

</code></pre>

<hr>
<h2 id='gemIntertemporal_TimeCircle_3_4'>A Time Circle Model with Two Consumers and Two Types of Firms</h2><span id='topic+gemIntertemporal_TimeCircle_3_4'></span>

<h3>Description</h3>

<p>An (intertemporal) time circle model with two consumers and two types of firms.
There are three commodities in the model, namely wheat, iron, and labor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_TimeCircle_3_4(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_TimeCircle_3_4_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an example with a Cobb-Douglas intertemporal utility function
np &lt;- 5 # the number of economic periods, firms.
zeta &lt;- 1.25 # the ratio of repayments to loans

n &lt;- 3 * np # the number of commodity kinds
m &lt;- 2 * np + 2 # the number of agent kinds

names.commodity &lt;- c(
  paste0("wheat", 1:np),
  paste0("iron", 1:np),
  paste0("lab", 1:np)
)
names.agent &lt;- c(
  paste0("firm.wheat", 1:np), paste0("firm.iron", 1:np),
  "consumer1", "consumer2"
)

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:np), c("consumer1", "consumer2")] &lt;- 100 # the supply of labor

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("wheat", k + 1), paste0("firm.wheat", k)] &lt;- 1
  B[paste0("iron", k + 1), paste0("firm.iron", k)] &lt;- 1
}
B["wheat1", paste0("firm.wheat", np)] &lt;- 1 / zeta
B["iron1", paste0("firm.iron", np)] &lt;- 1 / zeta

dstl.firm.wheat &lt;- dstl.firm.iron &lt;- list()
for (k in 1:np) {
  dstl.firm.wheat[[k]] &lt;- node_new(
    "prod",
    type = "CD", alpha = 1, beta = c(0.5, 0.5),
    paste0("iron", k), paste0("lab", k)
  )

  dstl.firm.iron[[k]] &lt;- node_new(
    "prod",
    type = "CD", alpha = 2, beta = c(0.5, 0.5),
    paste0("iron", k), paste0("lab", k)
  )
}

dst.consumer1 &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = prop.table(rep(1, np)),
  paste0("wheat", 1:np)
)

dst.consumer2 &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = prop.table(rep(1, np)),
  paste0("cc", 1:np)
)
for (k in 1:np) {
  node_set(
    dst.consumer2, paste0("cc", k),
    type = "CD", alpha = 1, beta = c(0.5, 0.5),
    paste0("wheat", k), paste0("iron", k)
  )
}

ge &lt;- sdm2(
  A = c(dstl.firm.wheat, dstl.firm.iron, dst.consumer1, dst.consumer2),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "lab1",
  ts = TRUE
)

ge$p
ge$z
ge$D
ge$S
ge$DV
ge$SV

</code></pre>

<hr>
<h2 id='gemIntertemporal_TimeCircle_Bank_1_2'>Some Examples of a Time Circle Model with a Consumer and a Type of Bank</h2><span id='topic+gemIntertemporal_TimeCircle_Bank_1_2'></span>

<h3>Description</h3>

<p>Some examples of a time circle model with a consumer and a type of bank.
These models can be used to solve some intertemporal savings problems.
</p>
<p>In these example, an np-period-lived consumer gets some payoff (or cash, exhaustible resource etc.) in each period.
In each period the consumer can use payoff for consumption, save payoff into bank or get a loan from the bank.
The interest rate is given.
The consumer has a CES intertemporal utility function and attempts to maximize intertemporal utility by saving and borrowing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_TimeCircle_Bank_1_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_TimeCircle_Bank_1_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an example with a 5-period-lived consumer (see Zhang, 2008, section 1.3)
np &lt;- 5 # the number of economic periods
interest.rate &lt;- 0.1
zeta &lt;- (1 + interest.rate)^np # the ratio of repayments to loans

n &lt;- np # the number of commodity kinds
m &lt;- np + 1 # the number of agent kinds

names.commodity &lt;- paste0("payoff", 1:np)
names.agent &lt;- c(paste0("bank", 1:np), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("payoff", 1:np), "consumer"] &lt;- 100 / (1:np)

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("payoff", k + 1), paste0("bank", k)] &lt;- 1
}
B["payoff1", paste0("bank", np)] &lt;- 1 / zeta

dstl.bank &lt;- list()
for (k in 1:np) {
  dstl.bank[[k]] &lt;- node_new(
    "output",
    type = "Leontief", a = 1 / (1 + interest.rate),
    paste0("payoff", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "CES", es = 0.5, alpha = 1, beta = prop.table(1:np),
  paste0("payoff", 1:np)
)

ge &lt;- sdm2(
  A = c(dstl.bank, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "payoff1",
  ts = TRUE,
  policy = makePolicyMeanValue(30)
)

ge$p
ge$z
ge$D
ge$S
ge$DV
ge$SV
growth_rate(ge$p)

####
dst.consumer$es &lt;- 0

ge &lt;- sdm2(
  A = c(dstl.bank, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "payoff1",
  ts = TRUE,
  policy = makePolicyMeanValue(30)
)

ge$p
ge$z
ge$D
ge$S
ge$DV
ge$SV
growth_rate(ge$p)

</code></pre>

<hr>
<h2 id='gemIntertemporal_TimeCircle_Stochastic_2_2'>Some 2-by-2 Time Circle Models with Uncertainty</h2><span id='topic+gemIntertemporal_TimeCircle_Stochastic_2_2'></span>

<h3>Description</h3>

<p>Some time circle models with uncertainty.
In these models, there is a consumer who will live for two periods and has a von Neumann-Morgenstern expected utility function.
There is one natural state in the first period,
and two natural states in the second period.
In the economy, there are two types of commodities: product and labor.
In the first period, the economy can borrow a certain amount of product from an external source,
such as a bank, and repay it after the economic operation is complete.
The amount of product to be repaid is zeta times the amount borrowed. zeta is an exogenous variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporal_TimeCircle_Stochastic_2_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporal_TimeCircle_Stochastic_2_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### Assume that the consumer supplies labor only in the first period,
## and the firm produces only in the first period.
zeta &lt;- 1.25 # the ratio of repayments to loans
dst.firm &lt;- node_new(
  "prod2",
  type = "CD", alpha = 1,
  beta = c(0.5, 0.5),
  "prod1", "lab1"
)

dst.bank &lt;- node_new(
  "prod1",
  type = "Leontief",
  a = c(1, 1) * zeta,
  "prod2.1", "prod2.2"
)

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1,
  beta = c(0.5, 0.25, 0.25),
  "prod1", "prod2.1", "prod2.2"
)

ge &lt;- sdm2(
  A = c(dst.firm, dst.bank, dst.consumer),
  B = matrix(c(
    0, 1, 0,
    2, 0, 0,
    1, 0, 0,
    0, 0, 0
  ), 4, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, NA, NA,
    NA, NA, NA,
    NA, NA, 100
  ), 4, 3, TRUE),
  names.commodity = c("prod1", "prod2.1", "prod2.2", "lab1"),
  names.agent = c("firm", "bank", "consumer"),
  numeraire = "lab1",
  policy = makePolicyMeanValue(30),
  ts = TRUE
)

ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)

#### Assume that the consumer supplies labor in both periods and
## firms produce in both periods.
zeta &lt;- 1.25 # the ratio of repayments to loans
dst.firm1 &lt;- node_new(
  "prod2",
  type = "CD", alpha = 2,
  beta = c(0.5, 0.5),
  "lab1", "prod1"
)

dst.firm2.1 &lt;- node_new(
  "prod3.1",
  type = "CD", alpha = 2,
  beta = c(0.5, 0.5),
  "lab2.1", "prod2.1"
)

dst.firm2.2 &lt;- node_new(
  "prod3.2",
  type = "CD", alpha = 1,
  beta = c(0.5, 0.5),
  "lab2.2", "prod2.2"
)

dst.bank &lt;- node_new(
  "prod1",
  type = "Leontief",
  a = c(1, 1) * zeta,
  "prod3.1", "prod3.2"
)

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1,
  beta = c(1 / 3, 1 / 3, 1 / 3),
  "prod1", "prod2.1", "prod2.2"
)

ge &lt;- sdm2(
  A = c(
    dst.firm1, dst.firm2.1, dst.firm2.2,
    dst.bank, dst.consumer
  ),
  B = matrix(c(
    0, 0, 0, 1, 0,
    1, 0, 0, 0, 0,
    1, 0, 0, 0, 0,
    0, 1, 0, 0, 0,
    0, 0, 1, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0
  ), 8, 5, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA,
    NA, NA, NA, NA, 100,
    NA, NA, NA, NA, 100,
    NA, NA, NA, NA, 100
  ), 8, 5, TRUE),
  names.commodity = c(
    "prod1", "prod2.1", "prod2.2",
    "prod3.1", "prod3.2",
    "lab1", "lab2.1", "lab2.2"
  ),
  names.agent = c(
    "firm1", "firm2.1", "firm2.2",
    "bank", "consumer"
  ),
  numeraire = "lab1",
  policy = makePolicyMeanValue(30),
  ts = TRUE
)

ge$p
ge$z
ge$D
ge$S
ge$DV
ge$SV

</code></pre>

<hr>
<h2 id='gemIntertemporalStochastic_Bank_ThreePeriods'>An Intertemporal Stochastic Model with a Consumer and Some Banks</h2><span id='topic+gemIntertemporalStochastic_Bank_ThreePeriods'></span>

<h3>Description</h3>

<p>An intertemporal stochastic model with a consumer and some banks.
In the model the consumer will live for three periods.
There is one natural state in the first period,
and two natural states in the second and third period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporalStochastic_Bank_ThreePeriods(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporalStochastic_Bank_ThreePeriods_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.bank1a &lt;- node_new(
  "payoff2.1&amp;2.2",
  type = "Leontief", a = 1,
  "payoff1"
)

dst.bank1b &lt;- node_new(
  "payoff3.1&amp;3.2",
  type = "Leontief", a = 1,
  "payoff1"
)

dst.bank2.1 &lt;- node_new(
  "payoff3.1",
  type = "Leontief", a = 1,
  "payoff2.1"
)

dst.bank2.2 &lt;- node_new(
  "payoff3.2",
  type = "Leontief", a = 1,
  "payoff2.2"
)

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = c(1/3, 1/6, 1/6, 1/6, 1/6),
  "payoff1", "payoff2.1", "payoff2.2", "payoff3.1", "payoff3.2"
)

ge &lt;- sdm2(
  A = list(dst.bank1a, dst.bank1b,dst.bank2.1,dst.bank2.2,dst.consumer),
  B = matrix(c(
    0,   0,0, 0,0,
    1.1, 0,0, 0,0,
    1.1, 0,0, 0, 0,
    0,   1.5, 1.1, 0,0,
    0,   1.5, 0, 1.1,0
  ), 5, 5, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA, 1,
    NA, NA, NA, NA, 1,
    NA, NA, NA, NA, 0,
    NA, NA, NA, NA, 0,
    NA, NA, NA, NA, 0
  ), 5, 5, TRUE),
  names.commodity = c("payoff1", "payoff2.1", "payoff2.2", "payoff3.1", "payoff3.2"),
  names.agent = c("bank1a","bank1b","bank2.1","bank2.2", "consumer"),
  numeraire = "payoff1"
)

ge$p
round(ge$D, 4)
round(ge$S, 4)

#### the general equilibrium in the first natural state in period 2
dst.bank2.1 &lt;- node_new(
  "payoff3.1",
  type = "Leontief", a = 1,
  "payoff2.1"
)

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = c(0.5, 0.5),
  "payoff2.1", "payoff3.1"
)

ge2.1 &lt;- sdm2(
  A = list(dst.bank2.1,
           dst.consumer),
  B = matrix(c(
    0,   0,
    1.1, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, 1.3084,
    NA, 0.4599
  ), 2, 2, TRUE),
  names.commodity = c("payoff2.1", "payoff3.1"),
  names.agent = c("bank2.1", "consumer"),
  numeraire = "payoff2.1"
)

ge2.1$p
round(ge2.1$D, 4)
round(ge2.1$S, 4)

## the general equilibrium in an unanticipated natural state in period 2
ge2.3 &lt;- sdm2(
  A = list(dst.bank2.1,
           dst.consumer),
  B = matrix(c(
    0,   0,
    1.1, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, 0.4,
    NA, 0.4599
  ), 2, 2, TRUE),
  names.commodity = c("payoff2.1", "payoff3.1"),
  names.agent = c("bank2.1", "consumer"),
  numeraire = "payoff2.1"
)

ge2.3$p
round(ge2.3$D, 4)
round(ge2.3$S, 4)

</code></pre>

<hr>
<h2 id='gemIntertemporalStochastic_Bank_TwoPeriods'>An Intertemporal Stochastic Model with a Consumer and a Bank</h2><span id='topic+gemIntertemporalStochastic_Bank_TwoPeriods'></span>

<h3>Description</h3>

<p>An intertemporal stochastic model with a consumer and a bank.
In the model the consumer will live for two periods.
There is one natural state in the first period,
and two natural states in the second period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporalStochastic_Bank_TwoPeriods(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporalStochastic_Bank_TwoPeriods_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### a savings bank
Ra &lt;- 1.2 # the interest rate coefficient in the first natural state in the future
Rb &lt;- 1.1 # the interest rate coefficient in the second natural state in the future

dst.bank &lt;- node_new(
  "output",
  type = "Leontief", a = 1,
  "payoff1"
)

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = c(1 / 2, 1 / 6, 1 / 3),
  "payoff1", "payoff2", "payoff3"
)

ge &lt;- sdm2(
  A = list(dst.bank, dst.consumer),
  B = matrix(c(
    0, 0,
    Ra, 0,
    Rb, 0
  ), 3, 2, TRUE),
  S0Exg = matrix(c(
    NA, 1,
    NA, 0,
    NA, 2
  ), 3, 2, TRUE),
  names.commodity = c("payoff1", "payoff2", "payoff3"),
  names.agent = c("bank", "consumer"),
  numeraire = "payoff1",
)

ge$p
addmargins(ge$D, 2)
addmargins(ge$S, 2)

#### a credit bank
Ra &lt;- 1.2
Rb &lt;- 1.1

dst.bank &lt;- node_new(
  "payoff1",
  type = "Leontief", a = c(Ra, Rb),
  "payoff2", "payoff3"
)

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = c(1 / 2, 1 / 6, 1 / 3),
  "payoff1", "payoff2", "payoff3"
)

ge &lt;- sdm2(
  A = list(dst.bank, dst.consumer),
  B = matrix(c(
    1, 0,
    0, 0,
    0, 0
  ), 3, 2, TRUE),
  S0Exg = matrix(c(
    NA, 0,
    NA, 1,
    NA, 2
  ), 3, 2, TRUE),
  names.commodity = c("payoff1", "payoff2", "payoff3"),
  names.agent = c("bank", "consumer"),
  numeraire = "payoff1"
)

ge$p
addmargins(ge$D, 2)
addmargins(ge$S, 2)

</code></pre>

<hr>
<h2 id='gemIntertemporalStochastic_ThreePeriods_2_2'>A Three-Period Intertemporal Stochastic Equilibrium Model with a Consumer and a Type of Firm</h2><span id='topic+gemIntertemporalStochastic_ThreePeriods_2_2'></span>

<h3>Description</h3>

<p>An intertemporal stochastic equilibrium model of three periods with a consumer and a type of firm.
The consumer will live for three periods and has a von Neumann-Morgenstern expected utility function.
There is one natural state in the first period, two natural states in the second period and
two natural states in the third period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporalStochastic_ThreePeriods_2_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporalStochastic_ThreePeriods_2_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.firm1 &lt;- node_new(
  "prod2",
  type = "CD", alpha = 2,
  beta = c(0.5, 0.5),
  "lab1", "prod1"
)

dst.firm2.1 &lt;- node_new(
  "prod3.1",
  type = "CD", alpha = 2,
  beta = c(0.5, 0.5),
  "prod2.1", "lab2.1"
)

dst.firm2.2 &lt;- node_new(
  "prod3.2",
  type = "CD", alpha = 1,
  beta = c(0.4, 0.6),
  "prod2.2", "lab2.2"
)

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1,
  beta = rep(1 / 5, 5),
  "prod1", "prod2.1", "prod2.2",
  "prod3.1", "prod3.2"
)

ge &lt;- sdm2(
  A = c(
    dst.firm1, dst.firm2.1, dst.firm2.2,
    dst.consumer
  ),
  B = matrix(c(
    0, 0, 0, 0,
    1, 0, 0, 0,
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
  ), 8, 4, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, 50,
    NA, NA, NA, NA,
    NA, NA, NA, NA,
    NA, NA, NA, NA,
    NA, NA, NA, NA,
    NA, NA, NA, 100,
    NA, NA, NA, 100,
    NA, NA, NA, 100
  ), 8, 4, TRUE),
  names.commodity = c(
    "prod1", "prod2.1", "prod2.2",
    "prod3.1", "prod3.2",
    "lab1", "lab2.1", "lab2.2"
  ),
  names.agent = c(
    "firm1", "firm2.1", "firm2.2",
    "consumer"
  ),
  numeraire = "lab1",
  policy = makePolicyMeanValue(30),
  ts = TRUE
)

ge$p
ge$z
ge$D
ge$S
ge$DV
ge$SV

</code></pre>

<hr>
<h2 id='gemIntertemporalStochastic_TwoPeriods'>Some Examples of a Two-Period Intertemporal Stochastic Equilibrium Model</h2><span id='topic+gemIntertemporalStochastic_TwoPeriods'></span>

<h3>Description</h3>

<p>Some examples of a two-period intertemporal equilibrium model with two types of commodities (i.e. product and labor)
and one firm.
In the second period there are two states of nature, in which the firm has different productivity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemIntertemporalStochastic_TwoPeriods(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemIntertemporalStochastic_TwoPeriods_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an examples with a consumer and a firm.
alpha1 &lt;- 1
alpha2 &lt;- 2

supply.lab &lt;- 100
supply.prod1 &lt;- 30

dst.firm &lt;- node_new(
  "prod2",
  type = "CD",
  alpha = 1, beta = c(0.5, 0.5),
  "prod1", "lab1"
)

dst.consumer &lt;- node_new(
  "util",
  type = "CD",
  alpha = 1, beta = c(0.5, 0.25, 0.25),
  "prod1", "prod2.1", "prod2.2"
)

ge &lt;- sdm2(
  A = c(dst.firm, dst.consumer),
  B = matrix(c(
    0, 0,
    0, 0,
    alpha1, 0,
    alpha2, 0
  ), 4, 2, TRUE),
  S0Exg = matrix(c(
    NA, supply.prod1,
    NA, supply.lab,
    NA, NA,
    NA, NA
  ), 4, 2, TRUE),
  names.commodity = c("prod1", "lab1", "prod2.1", "prod2.2"),
  names.agent = c("firm", "consumer"),
  numeraire = "prod1"
)

ge$p
ge$z
ge$D
ge$S
ge$DV
ge$SV

#### an examples with two types of consumer and a firm.
dst.firm &lt;- node_new(
  "prod2",
  type = "CD",
  alpha = 1, beta = c(0.5, 0.5),
  "prod1", "lab1"
)

dst.consumer1 &lt;- node_new(
  "util",
  type = "CD",
  alpha = 1, beta = c(0.5, 0.4, 0.1),
  "prod1", "prod2.1", "prod2.2"
)

dst.consumer2 &lt;- node_new(
  "util",
  type = "CD",
  alpha = 1, beta = c(0.5, 0.25, 0.25),
  "prod1", "prod2.1", "prod2.2"
)

ge &lt;- sdm2(
  A = c(dst.firm, dst.consumer1, dst.consumer2),
  B = matrix(c(
    0, 0, 0,
    0, 0, 0,
    1, 0, 0,
    2, 0, 0
  ), 4, 3, TRUE),
  S0Exg = matrix(c(
    NA, 30, 30,
    NA, 100, 100,
    NA, NA, NA,
    NA, NA, NA
  ), 4, 3, TRUE),
  names.commodity = c("prod1", "lab1", "prod2.1", "prod2.2"),
  names.agent = c("firm", "consumer1", "consumer2"),
  numeraire = "prod1"
)

ge$p
ge$z
ge$D
ge$S
ge$DV
ge$SV

</code></pre>

<hr>
<h2 id='gemLand_Labor'>Some Examples of Spot Market Clearing Paths Involving Land and Labor</h2><span id='topic+gemLand_Labor'></span>

<h3>Description</h3>

<p>Some examples of spot market clearing paths (alias instantaneous equilibrium paths) involving land and labor.
The labor supply may increase from the fifth period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemLand_Labor(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemLand_Labor_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### a 3-by-3 economy
f &lt;- function(GRLabor = 0,
              es.land.labor = 1) {
  dst.firm &lt;- node_new("output",
                       type = "SCES",
                       es = es.land.labor, alpha = 1,
                       beta = c(0.5, 0.5),
                       "land", "lab"
  )

  dst.landowner &lt;- node_new(
    "util",
    type = "Leontief", a = 1,
    "prod"
  )

  dst.laborer &lt;- Clone(dst.landowner)

  dstl &lt;- list(dst.firm, dst.landowner, dst.laborer)

  ge &lt;- sdm2(
    A = dstl,
    B = diag(c(1, 0, 0)),
    S0Exg = matrix(c(
      NA, NA, NA,
      NA, 100, NA,
      NA, NA, 100
    ), 3, 3, TRUE),
    names.commodity = c("prod", "land", "lab"),
    names.agent = c("firm", "landowner", "laborer"),
    maxIteration = 1,
    numberOfPeriods = 30,
    numeraire = "lab",
    ts = TRUE,
    policy = list(
      function(time, state) {
        if (time &gt;= 5) {
          state$S[3, 3] &lt;- 100 * (1 + GRLabor)^(time - 4)
        }
        state
      },
      policyMarketClearingPrice
    ),
    z0 = c(200, 100, 100),
    p0 = c(1, 1, 1)
  )

  par(mfrow = c(1, 2))
  matplot(growth_rate(ge$ts.p), type = "o", pch = 20)
  matplot(growth_rate(ge$ts.z), type = "o", pch = 20)

  ge
}

ge &lt;- f()
ge$p
ge$z


f(GRLabor = 0.03)
f(GRLabor = -0.03)
f(GRLabor = 0.03, es.land.labor = 0.5)
f(GRLabor = 0.03, es.land.labor = 1.5)

#### a 4-by-3 economy
GRLabor &lt;- 0.03

dst.agri &lt;- node_new("agri",
                     type = "SCES", es = 0.5, alpha = 1,
                     beta = c(0.75, 0.25),
                     "land", "lab"
)

dst.manu &lt;- node_new("manu",
                     type = "SCES", es = 0.5, alpha = 1,
                     beta = c(0.25, 0.75),
                     "land", "lab"
)

dst.consumer &lt;- node_new("util",
                         type = "SCES", es = 0.5, alpha = 1,
                         beta = c(0.5, 0.5),
                         "agri", "manu"
)

dstl &lt;- list(dst.agri, dst.manu, dst.consumer)

ge &lt;- sdm2(
  A = dstl,
  B = matrix(c(
    1, 0, 0,
    0, 1, 0,
    0, 0, 0,
    0, 0, 0
  ), 4, 3, TRUE),
  S0Exg = {
    S0Exg &lt;- matrix(NA, 4, 3)
    S0Exg[3:4, 3] &lt;- 100
    S0Exg
  },
  names.commodity = c("agri", "manu", "land", "lab"),
  names.agent = c("agri", "manu", "consumer"),
  numeraire = c("manu"),
  ts = TRUE,
  policy = list(
    function(time, state) {
      if (time &gt;= 5) {
        state$S[4, 3] &lt;- 100 * (1 + GRLabor)^(time - 4)
      }
      state
    },
    policyMarketClearingPrice
  ),
  numberOfPeriods = 40,
  maxIteration = 1,
  z0 = c(100, 100, 200),
  p0 = c(1, 1, 1, 1)
)

matplot(ge$ts.z, type = "o", pch = 20)
matplot(growth_rate(ge$ts.z), type = "o", pch = 20)
matplot(growth_rate(ge$ts.p), type = "o", pch = 20)

</code></pre>

<hr>
<h2 id='gemLand_Labor_Capital_4_3'>Some Examples of Spot Market Clearing Paths Involving Land, Labor and Capital</h2><span id='topic+gemLand_Labor_Capital_4_3'></span>

<h3>Description</h3>

<p>Some examples of spot market clearing paths (alias instantaneous equilibrium paths) involving land, labor and capital.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemLand_Labor_Capital_4_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemLand_Labor_Capital_4_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
depreciation.rate &lt;- 0.05

dst.firm.production &lt;- node_new("prod",
  type = "CD",
  alpha = 1, beta = c(0.4, 0.4, 0.2),
  "lab", "cap", "land"
)

dst.firm.capital.leasing &lt;- node_new("cap",
  type = "Leontief", a = 1,
  "prod"
)

dst.consumer &lt;- node_new("util",
  type = "CD",
  alpha = 1, beta = c(0.5, 0.5),
  "prod", "lab"
)

dstl &lt;- list(dst.firm.production, dst.consumer, dst.firm.capital.leasing)
f &lt;- function(policy = policyMarketClearingPrice,
              p0 = c(1, 1, 1, 1),
              z0 = c(10, 10, 10),
              numberOfPeriods = 100) {
  sdm2(
    A = dstl,
    B = matrix(c(
      1, 0, 1 - depreciation.rate,
      0, 0, 0,
      0, 0, 1,
      0, 0, 0
    ), 4, 3, TRUE),
    S0Exg = {
      S0Exg &lt;- matrix(NA, 4, 3)
      S0Exg[2, 2] &lt;- S0Exg[4, 2] &lt;- 1
      S0Exg
    },
    names.commodity = c("prod", "lab", "cap", "land"),
    names.agent = c("firm.production", "consumer", "firm.capital.leasing"),
    numeraire = "prod",
    maxIteration = 1,
    numberOfPeriods = numberOfPeriods,
    p0 = p0,
    z0 = z0,
    policy = policy,
    ts = TRUE
  )
}

ge1 &lt;- f()
ge1$p
ge1$DV
ge1$SV
matplot(ge1$ts.z, type = "l")

## a spot market clearing path with population growth
policy.population.growth &lt;- function(time, state) {
  if (time &gt;= 5) {
    state$S[2, 2] &lt;- 1.01^(time - 4)
  }
  state
}

ge2 &lt;- f(
  policy = list(
    policy.population.growth,
    policyMarketClearingPrice
  ),
  p0 = ge1$p, z0 = ge1$z,
  numberOfPeriods = 30
)
matplot(ge2$ts.z, type = "o", pch = 40)
matplot(growth_rate(ge2$ts.z), type = "o", pch = 20)

## a spot market clearing path with technology progress
policy.technology.progress &lt;- function(time, A) {
  if (time &gt;= 5) {
    A[[1]]$alpha &lt;- 1.02^(time - 4)
  }
}

ge3 &lt;- f(
  policy = list(
    policy.technology.progress,
    policyMarketClearingPrice
  ),
  p0 = ge1$p, z0 = ge1$z,
  numberOfPeriods = 30
)

matplot(ge3$ts.z, type = "o", pch = 20)
matplot(growth_rate(ge3$ts.z), type = "o", pch = 20)

## a spot market clearing path with population growth and technology progress
ge4 &lt;- f(
  policy = list(
    policy.population.growth,
    policy.technology.progress,
    policyMarketClearingPrice
  ),
  p0 = ge1$p, z0 = ge1$z,
  numberOfPeriods = 30
)

matplot(ge4$ts.z, type = "o", pch = 20)
matplot(growth_rate(ge4$ts.z), type = "o", pch = 20)

</code></pre>

<hr>
<h2 id='gemMarketClearingPath_2_2'>Some Examples of Spot Market Clearing Paths</h2><span id='topic+gemMarketClearingPath_2_2'></span>

<h3>Description</h3>

<p>Some examples of zero-dividend spot market clearing paths (alias instantaneous equilibrium paths) containing a firm and a laborer (consumer).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemMarketClearingPath_2_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemMarketClearingPath_2_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## the benchmark equilibrium
dst.firm &lt;- node_new(
  "prod",
  type = "CD", alpha = 5, beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.consumer &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "prod"
)

dstl &lt;- list(dst.firm, dst.consumer)

f &lt;- function(policy = NULL) {
  sdm2(
    A = dstl,
    B = matrix(c(
      1, 0,
      0, 0
    ), 2, 2, TRUE),
    S0Exg = matrix(c(
      NA, NA,
      NA, 1
    ), 2, 2, TRUE),
    names.commodity = c("prod", "lab"),
    names.agent = c("firm", "consumer"),
    numeraire = "lab",
    z0 = c(1, 1),
    ts = TRUE,
    policy = policy,
    numberOfPeriods = 40,
    maxIteration = 1
  )
}

ge &lt;- f(policy = policyMarketClearingPrice)
matplot(ge$ts.S[1, 1, ], type = "o", pch = 20)
matplot(ge$ts.z, type = "o", pch = 20)

## labor supply change
ge.LSC &lt;- f(policy = list(
  function(time, state) {
    if (time &gt;= 21) state$S[2, 2] &lt;- state$S[2, 2] * 2
    state
  },
  policyMarketClearingPrice
))

matplot(ge.LSC$ts.z, type = "o", pch = 20)

## technology progress
ge.TP &lt;- f(policy = list(
  makePolicyTechnologyChange(
    adjumentment.ratio = 2,
    agent = "firm",
    time.win = c(21, 21)
  ),
  policyMarketClearingPrice
))

matplot(ge.TP$ts.z, type = "o", pch = 20)

## the same as above
ge.TP2 &lt;- f(policy = list(
  function(time, A) {
    if (time &gt;= 21) {
      A[[1]]$alpha &lt;- 10
    } else {
      A[[1]]$alpha &lt;- 5
    }
  },
  policyMarketClearingPrice
))

matplot(ge.TP2$ts.z, type = "o", pch = 20)

#### A timeline model, the equilibrium of which is the same as the benchmark equilibrium.
# In this model, in terms of form, firms are treated as consumer-type agents rather than
# producer-type agents. Firms hold products. The utility level of each firm determines
# the quantity of the product that the firm owns in the subsequent economic period.
np &lt;- 5 # the number of economic periods
y1 &lt;- 1 # the initial product supply
eis &lt;- 1 # elasticity of intertemporal substitution
Gamma.beta &lt;- 1 # the subjective discount factor

n &lt;- 2 * np # the number of commodity kinds
m &lt;- np + 1 # the number of agent kinds

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:np))
names.agent &lt;- c(paste0("firm", 1:np), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:np), "consumer"] &lt;- 1
for (k in 1:np) {
  S0Exg[paste0("prod", k), paste0("firm", k)] &lt;- y1
}

dstl.firm &lt;- list()
for (k in 1:np) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "CD",
    alpha = 5, beta = c(0.5, 0.5),
    paste0("prod", k), paste0("lab", k)
  )
}

dst.consumer.CD &lt;- node_new(
  "util",
  type = "CD",
  alpha = 1, beta = prop.table(rep(1, np)),
  paste0("prod", 1:np)
)

dst.consumer &lt;- node_new(
  "util",
  type = "CES", es = eis,
  alpha = 1, beta = prop.table(Gamma.beta^(1:np)),
  paste0("prod", 1:np)
)

ge.timeline &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = matrix(0, n, m),
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "prod1",
  ts = TRUE,
  policy = function(time, state) {
    names(state$last.z) &lt;- state$names.agent
    dimnames(state$S) &lt;- list(names.commodity, names.agent)

    for (k in 2:np) {
      state$S[paste0("prod", k), paste0("firm", k)] &lt;- state$last.z[paste0("firm", k - 1)]
    }

    return(state)
  }
)

head(ge.timeline$p, np) / tail(ge.timeline$p, np)
ge$ts.p[1:5, 1] # the same as above

ge.timeline$z[1:np]
ge$ts.z[1:np, 1] # the same as above

ge.timeline$D
ge.timeline$S

</code></pre>

<hr>
<h2 id='gemMoney_3_2'>A General Equilibrium Model with Money</h2><span id='topic+gemMoney_3_2'></span>

<h3>Description</h3>

<p>A general equilibrium model with money as a medium of exchange and a means of payment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemMoney_3_2(
  dstl,
  supply.labor = 100,
  supply.money = 300,
  names.commodity = c("product", "labor", "money"),
  names.agent = c("firm", "household"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemMoney_3_2_+3A_dstl">dstl</code></td>
<td>
<p>the demand structure tree list.</p>
</td></tr>
<tr><td><code id="gemMoney_3_2_+3A_supply.labor">supply.labor</code></td>
<td>
<p>the supply of labor.</p>
</td></tr>
<tr><td><code id="gemMoney_3_2_+3A_supply.money">supply.money</code></td>
<td>
<p>the supply of money.</p>
</td></tr>
<tr><td><code id="gemMoney_3_2_+3A_names.commodity">names.commodity</code></td>
<td>
<p>names of commodities.</p>
</td></tr>
<tr><td><code id="gemMoney_3_2_+3A_names.agent">names.agent</code></td>
<td>
<p>names of agents.</p>
</td></tr>
<tr><td><code id="gemMoney_3_2_+3A_...">...</code></td>
<td>
<p>arguments to be to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A general equilibrium model with 3 commodities (i.e. product, labor,
and money) and 2 agents (i.e. a firm and a household).
To produce, the firm needs product, labor and money.
The household only consumes the product. But money is also needed to buy the product.
The household supplies labor and money. <br />
</p>
<p>In the calculation results, the price of the currency is the interest per unit of currency (i.e., the rental price).
It should be noted that the unit of currency can be arbitrarily selected.
For example, a unit of currency may be two dollars or ten dollars.
The rental price divided by the interest rate is the asset price of 1 unit of the currency.
</p>


<h3>Value</h3>

<p>A general equilibrium (see <code><a href="#topic+sdm2">sdm2</a></code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Leontief-type firm
interest.rate &lt;- 0.25
vm &lt;- 1 # the velocity of money

dst.Leontief.firm &lt;- node_new("output",
  type = "FIN", rate = c(1, interest.rate / vm),
  "cc1", "money"
)
node_set(dst.Leontief.firm, "cc1",
  type = "Leontief", a = c(0.6, 0.2),
  "product", "labor"
)

dst.household &lt;- node_new("utility",
  type = "FIN", rate = c(1, interest.rate / vm),
  "product", "money"
)

dstl.Leontief &lt;- list(dst.Leontief.firm, dst.household)

ge.Leontief &lt;- gemMoney_3_2(dstl.Leontief)
ge.Leontief$p

## SCES-type firm
dst.SCES.firm &lt;- Clone(dst.Leontief.firm)
node_set(dst.SCES.firm, "cc1",
  type = "SCES", alpha = 1, beta = c(0.6, 0.2),
  es = 0 # es is the elasticity of substitution.
)

node_plot(dst.SCES.firm, TRUE)

dstl.SCES &lt;- list(dst.SCES.firm, dst.household)

ge.SCES &lt;- gemMoney_3_2(dstl.SCES)
ge.SCES$p
p.money &lt;- ge.SCES$p
p.money["money"] &lt;- p.money["money"] / interest.rate
p.money &lt;- p.money / p.money["money"] # prices in terms of the asset price of the currency
p.money

## The price of money is the interest rate.
## The other prices are in terms of the asset price of the currency.
gemMoney_3_2(dstl.SCES,
             numeraire = c("money" = interest.rate)
)

</code></pre>

<hr>
<h2 id='gemMoney_3_3'>Some 3-by-3 General Equilibrium Models with Money and Exogenous Interest Rate</h2><span id='topic+gemMoney_3_3'></span>

<h3>Description</h3>

<p>Some 3-by-3 general equilibrium models with money as a medium of exchange and a means of payment.
Here, the interest rate is an exogenous variable.
</p>
<p>In these examples, the price of money refers to its rental price, which is the interest amount generated per unit of money.
The value of a unit of currency (i.e., its selling price or asset price) is its rental price divided by the interest rate.
When the rental price of money equals the interest rate, the value of the currency equals 1, which implies that money is used as the numeraire (i.e. the unit of account).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemMoney_3_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemMoney_3_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>LI Wu (2019, ISBN: 9787521804225) General Equilibrium and Structural Dynamics: Perspectives of New Structural Economics. Beijing: Economic Science Press. (In Chinese)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### a monetary pure exchange model
interest.rate &lt;- 0.25
vm &lt;- 1 # the velocity of money

dst.consumer1 &lt;- node_new("util",
                          type = "CD",
                          alpha = 1, beta = c(0.5, 0.5),
                          "cc1", "wheat"
)
node_set(dst.consumer1, "cc1",
         type = "FIN", rate = c(1, interest.rate / vm),
         "iron", "money"
)

dst.consumer2 &lt;- node_new("util",
                          type = "CD",
                          alpha = 1, beta = c(0.5, 0.5),
                          "cc1", "iron"
)
node_set(dst.consumer2, "cc1",
         type = "FIN", rate = c(1, interest.rate / vm),
         "wheat", "money"
)

dst.consumer3 &lt;- node_new("util",
                          type = "FIN", rate = c(1, interest.rate / vm),
                          "cc1", "money"
)
node_set(dst.consumer3, "cc1",
         type = "CD",
         alpha = 1, beta = c(0.5, 0.5),
         "wheat", "iron"
)

ge &lt;- sdm2(
  A = list(dst.consumer1, dst.consumer2, dst.consumer3),
  B = matrix(0, 3, 3),
  S0Exg = matrix(c(
    100, 0, 0,
    0, 100, 0,
    0, 0, 100
  ), 3, 3, TRUE),
  names.commodity = c("wheat", "iron", "money"),
  names.agent = c("consumer1", "consumer2", "consumer3"),
  numeraire = c(money = interest.rate)
)
ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$DV)
addmargins(ge$SV)

## Here are a few examples of calculating demand coefficients.
node_plot(dst.consumer1, TRUE)

# In the following example, the rental price of money is 0.25,
# which equals the interest rate of the money,
# thus it is known that the value of one unit of money is 1.
demand_coefficient(dst.consumer1, p = c(wheat = 1, iron = 1, money = 0.25))

demand_coefficient(dst.consumer1, p = c(wheat = 1, iron = 2, money = 0.25))

# In the following example,  the rental price of money is 0.5,
# and the value of one unit of money is 0.5/0.25=2.
demand_coefficient(dst.consumer1, p = c(wheat = 1, iron = 2, money = 0.5))

#### a monetary model with production
interest.rate &lt;- 0.25
vm &lt;- 1 # the velocity of money

dst.firm &lt;- node_new("prod",
                     type = "FIN", rate = c(1, interest.rate / vm),
                     "cc1", "money"
)
node_set(dst.firm, "cc1",
         type = "CD", alpha = 2, beta = c(0.5, 0.5),
         "prod", "lab"
)

dst.laborer &lt;- dst.moneyOwner &lt;-
  node_new("util",
           type = "FIN", rate = c(1, interest.rate / vm),
           "prod", "money"
  )

ge &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.moneyOwner),
  B = diag(c(1, 0, 0)),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 100, NA,
    NA, NA, 100
  ), 3, 3, TRUE),
  names.commodity = c("prod", "lab", "money"),
  names.agent = c("firm", "laborer", "moneyOwner"),
  numeraire = "prod"
)

ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)
addmargins(ge$DV)
addmargins(ge$SV)

## Take money as numeraire, that is, let the asset price of money equal to 1,
## and let the interest per unit of money equal to the exogenous interest rate.
ge2 &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.moneyOwner),
  B = diag(c(1, 0, 0)),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 100, NA,
    NA, NA, 100
  ), 3, 3, TRUE),
  names.commodity = c("prod", "lab", "money"),
  names.agent = c("firm", "laborer", "moneyOwner"),
  numeraire = c(money = interest.rate)
)

ge2$p
ge2$z
addmargins(ge2$D, 2)
addmargins(ge2$S, 2)
addmargins(ge2$DV)
addmargins(ge2$SV)

#### another model (Li, 2019, example 7.2)
interest.rate &lt;- 0.25
vm &lt;- 1 # the velocity of money

dst &lt;- node_new("demand",
                type = "FIN", rate = c(1, interest.rate / vm),
                "cc1", "money"
)
node_set(dst, "cc1",
         type = "CD", alpha = 1, beta = c(0.5, 0.5),
         "prod", "lab"
)

ge &lt;- sdm2(
  A = list(dst, dst, dst),
  B = diag(c(1, 0, 0)),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 100, NA,
    NA, NA, 100
  ), 3, 3, TRUE),
  names.commodity = c("prod", "lab", "money"),
  names.agent = c("firm", "laborer", "money.lender"),
  numeraire = c(money = interest.rate)
)

ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)
addmargins(ge$DV)
addmargins(ge$SV)

</code></pre>

<hr>
<h2 id='gemNonexcludability'>Some Examples Illustrating Non-excludability</h2><span id='topic+gemNonexcludability'></span>

<h3>Description</h3>

<p>Some examples illustrating non-rival goods with non-excludability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemNonexcludability(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemNonexcludability_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><cite><a href="#topic+gemNonrivalry_Uncongestiblity">gemNonrivalry_Uncongestiblity</a></cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.firm0 &lt;- node_new(
  "non-rival services",
  type = "Leontief", a = 1,
  "labor"
)

dst.consumer1 &lt;- node_new(
  "util",
  type = "SCES", es = 1, # es = 0
  alpha = 1, beta = c(0.75, 0.25),
  "serv1", "labor"
)

dst.consumer2 &lt;- node_new(
  "util",
  type = "SCES", es = 1, # es = 0
  alpha = 1, beta = c(0.5, 0.5),
  "serv2", "labor"
)

f.CD &lt;- function(policy = NULL) {
  ge &lt;- sdm2(
    A = list(dst.firm0, dst.consumer1, dst.consumer2),
    B = matrix(c(
      1, 0, 0,
      1, 0, 0,
      0, 0, 0
    ), 3, 3, TRUE),
    S0Exg = matrix(c(
      NA, NA, NA,
      NA, NA, NA,
      NA, 60, 60
    ), 3, 3, TRUE),
    names.commodity = c("serv1", "serv2", "labor"),
    names.agent = c("firm", "consumer1", "consumer2"),
    numeraire = "labor",
    policy = policy
  )

  cat("ge$p:\n")
  print(round(ge$p, 5))
  cat("ge$z:\n")
  print(round(ge$z, 5))
  cat("ge$D:\n")
  print(addmargins(round(ge$D, 5), 2))
  cat("ge$S:\n")
  print(addmargins(round(ge$S, 5), 2))
}

f.CD()

# Suppose consumer 2 is a free rider.
policy.nonexcludability &lt;- function(state) {
  state$S[2, 3] &lt;- state$S[2, 1]
  state$S[2, 1] &lt;- 0
  state
}
f.CD(policy.nonexcludability)

## Assume that both consumers have the same linear utility
# function x1 + 1.25 * x2, wherein x1 is the quantity
# of service and x2 is the quantity of labor.

dst.firm1 &lt;- node_new(
  "serv1",
  type = "Leontief", a = 0.8,
  "labor"
)

dst.firm2 &lt;- node_new(
  "serv2",
  type = "Leontief", a = 0.8,
  "labor"
)

dst.consumer1 &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "serv1"
)

dst.consumer2 &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "serv2"
)

f.linear &lt;- function(policy = NULL) {
  ge &lt;- sdm2(
    A = list(
      dst.firm0, dst.consumer1, dst.consumer2,
      dst.firm1, dst.firm2
    ),
    B = matrix(c(
      1, 0, 0, 1, 0,
      1, 0, 0, 0, 1,
      0, 0, 0, 0, 0
    ), 3, 5, TRUE),
    S0Exg = matrix(c(
      NA, NA, NA, NA, NA,
      NA, NA, NA, NA, NA,
      NA, 60, 60, NA, NA
    ), 3, 5, TRUE),
    names.commodity = c("serv1", "serv2", "labor"),
    names.agent = c("firm.public", "consumer1", "consumer2", "firm1", "firm2"),
    numeraire = "labor",
    policy = policy
  )

  cat("ge$p:\n")
  print(round(ge$p, 5))
  cat("ge$z:\n")
  print(round(ge$z, 5))
  cat("ge$D:\n")
  print(addmargins(round(ge$D, 5), 2))
  cat("ge$S:\n")
  print(addmargins(round(ge$S, 5), 2))
}

f.linear()

# Suppose consumer 2 is a free rider.
f.linear(policy.nonexcludability)

</code></pre>

<hr>
<h2 id='gemNonrivalry_Congestiblity'>Some Examples Illustrating Congestible Non-rival Goods</h2><span id='topic+gemNonrivalry_Congestiblity'></span>

<h3>Description</h3>

<p>Some examples illustrating congestible non-rival goods (or services).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemNonrivalry_Congestiblity(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemNonrivalry_Congestiblity_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>See Also</h3>


<p><code><a href="#topic+gemNonrivalry_Uncongestiblity">gemNonrivalry_Uncongestiblity</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The firm supplies non-rival services.
dst.firm &lt;- node_new(
  "non-rival services",
  type = "Leontief", a = 1,
  "labor"
)

dst.consumer1 &lt;- node_new(
  "util",
  type = "SCES", es = 1, # es = 0
  alpha = 1, beta = c(0.75, 0.25),
  "serv1", "labor"
)

dst.consumer2 &lt;- node_new(
  "util",
  type = "SCES", es = 1, # es = 0
  alpha = 1, beta = c(0.5, 0.5),
  "serv2", "labor"
)

dst.consumer3 &lt;- node_new(
  "util",
  type = "SCES", es = 1,
  alpha = 1, beta = c(0.1, 0.9),
  "serv3", "labor"
)

efficient.coef &lt;- 0.6 # 0.8, 0.7

ge &lt;- sdm2(
  A = list(
    dst.firm, dst.firm, dst.firm, dst.firm,
    dst.consumer1, dst.consumer2, dst.consumer3
  ),
  B = matrix(c(
    1, 1, 0, efficient.coef, 0, 0, 0,
    1, 0, 1, efficient.coef, 0, 0, 0,
    0, 1, 1, efficient.coef, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0
  ), 4, 7, TRUE),
  S0Exg = {
    tmp &lt;- matrix(NA, 4, 7)
    tmp[4, 5:7] &lt;- 100
    tmp
  },
  names.commodity = c(paste0("serv", 1:3), "labor"),
  names.agent = c(paste0("firm", 1:4), paste0("consumer", 1:3)),
  numeraire = "labor"
)

ge$p
round(ge$z, 5)
round(ge$D, 5)
round(ge$S, 5)

##
efficient.coef &lt;- 0.2

ge &lt;- sdm2(
  A = list(
    dst.firm, dst.firm, dst.firm,
    dst.consumer1, dst.consumer2, dst.consumer3
  ),
  B = matrix(c(
    1, efficient.coef, 0, 0, 0, 0,
    1, efficient.coef, 0, 0, 0, 0,
    0, efficient.coef, 0.5, 0, 0, 0,
    0, 0, 0, 0, 0, 0
  ), 4, 6, TRUE),
  S0Exg = {
    tmp &lt;- matrix(NA, 4, 6)
    tmp[4, 4:6] &lt;- 100
    tmp
  },
  names.commodity = c(paste0("serv", 1:3), "labor"),
  names.agent = c(paste0("firm", 1:3), paste0("consumer", 1:3)),
  numeraire = "labor"
)

ge$p
round(ge$z, 5)
round(ge$D, 5)
round(ge$S, 5)

## congested land services.
efficient.coef &lt;- 0.6 # 0.8, 0.7

dst.firm &lt;- node_new(
  "non-rival services",
  type = "Leontief", a = 1,
  "land"
)

ge &lt;- sdm2(
  A = list(
    dst.firm, dst.firm, dst.firm, dst.firm,
    dst.consumer1, dst.consumer2, dst.consumer3
  ),
  B = matrix(c(
    1, 1, 0, efficient.coef, 0, 0, 0,
    1, 0, 1, efficient.coef, 0, 0, 0,
    0, 1, 1, efficient.coef, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0
  ), 5, 7, TRUE),
  S0Exg = {
    tmp &lt;- matrix(NA, 5, 7)
    tmp[4, 5:7] &lt;- 55
    tmp[5, 5:7] &lt;- 45
    tmp
  },
  names.commodity = c(paste0("serv", 1:3), "labor", "land"),
  names.agent = c(paste0("firm", 1:4), paste0("consumer", 1:3)),
  numeraire = "labor"
)

ge$p
round(ge$z, 5)
round(ge$D, 5)
round(ge$S, 5)

##
efficient.coef &lt;- 0.2

ge &lt;- sdm2(
  A = list(
    dst.firm, dst.firm, dst.firm,
    dst.consumer1, dst.consumer2, dst.consumer3
  ),
  B = matrix(c(
    1, efficient.coef, 0, 0, 0, 0,
    1, efficient.coef, 0, 0, 0, 0,
    0, efficient.coef, 0.5, 0, 0, 0,
    0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0
  ), 5, 6, TRUE),
  S0Exg = {
    tmp &lt;- matrix(NA, 5, 6)
    tmp[4, 4:6] &lt;- 55
    tmp[5, 4:6] &lt;- 45
    tmp
  },
  names.commodity = c(paste0("serv", 1:3), "labor", "land"),
  names.agent = c(paste0("firm", 1:3), paste0("consumer", 1:3)),
  numeraire = "labor"
)

ge$p
round(ge$z, 5)
round(ge$D, 5)
round(ge$S, 5)

</code></pre>

<hr>
<h2 id='gemNonrivalry_Uncongestiblity'>Some Examples Illustrating Uncongestible Non-rival Goods</h2><span id='topic+gemNonrivalry_Uncongestiblity'></span>

<h3>Description</h3>

<p>Some examples illustrating (uncongestible) non-rival goods (or services), Lindahl prices and the uniform price.
In general equilibrium models, non-rival services can be regarded as personalized services,
which are joint products of a production process (see Mas-Colell, Whinston, and Green, 1995, section 16.G).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemNonrivalry_Uncongestiblity(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemNonrivalry_Uncongestiblity_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Mas-Colell, Andreu and Whinston, Michael Dennis and Green, Jerry R. (1995, ISBN: 0195073401) Microeconomic Theory. Oxford University Press (New York).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## The firm supplies non-rival services.
dst.firm &lt;- node_new(
  "non-rival services",
  type = "Leontief", a = 1,
  "labor"
)

dst.consumer1 &lt;- node_new(
  "util",
  type = "SCES", es = 1, # es = 0
  alpha = 1, beta = c(0.75, 0.25),
  "serv1", "labor"
)

dst.consumer2 &lt;- node_new(
  "util",
  type = "SCES", es = 1, # es = 0
  alpha = 1, beta = c(0.5, 0.5),
  "serv2", "labor"
)

ge &lt;- sdm2(
  A = list(dst.firm, dst.consumer1, dst.consumer2),
  B = matrix(c(
    1, 0, 0,
    1, 0, 0,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, NA, NA,
    NA, 60, 60
  ), 3, 3, TRUE),
  names.commodity = c("serv1", "serv2", "labor"),
  names.agent = c("firm", "consumer1", "consumer2"),
  numeraire = "labor"
)

ge$p # Lindahl prices
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)
addmargins(ge$DV)

## Computing the uniform price of the non-rival services
## by transfer payment between consumers.
ge &lt;- sdm2(
  A = list(dst.firm, dst.consumer1, dst.consumer2),
  B = matrix(c(
    1, 0, 0,
    1, 0, 0,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, NA, NA,
    NA, 60, 60
  ), 3, 3, TRUE),
  names.commodity = c("serv1", "serv2", "labor"),
  names.agent = c("firm", "consumer1", "consumer2"),
  numeraire = "labor",
  policy = function(A, state) {
    # A[[1]]$last.s is the previous labor supply of consumer1.
    if (is.null(A[[1]]$last.s)) A[[1]]$last.s &lt;- 60

    p &lt;- state$p / state$p[3]
    last.DV &lt;- dg(p) %*% state$last.A %*% dg(state$last.z)
    transfer.payment &lt;- last.DV[1, 2] - mean(c(last.DV[1, 2], last.DV[2, 3]))

    A[[1]]$last.s &lt;- state$S[3, 2] &lt;- A[[1]]$last.s *
      ratio_adjust((60 + transfer.payment) / A[[1]]$last.s, 0.2)
    state$S[3, 3] &lt;- 120 - state$S[3, 2]

    state
  }
)

# Taking transfer payment into account, the uniform price of the non-rival services is 0.5.
ge$p
addmargins(ge$D, 2)
addmargins(ge$S, 2)
addmargins(ge$DV)

ge2 &lt;- sdm2(
  A = list(dst.firm, dst.consumer1, dst.consumer2),
  B = matrix(c(
    1, 0, 0,
    1, 0, 0,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, NA, NA,
    NA, 80, 40
  ), 3, 3, TRUE),
  names.commodity = c("serv1", "serv2", "labor"),
  names.agent = c("firm", "consumer1", "consumer2"),
  numeraire = "labor"
)

ge2$p
addmargins(ge2$D, 2)
addmargins(ge2$S, 2)
addmargins(ge2$DV)

## Calculate a stationary state with price regulation.
## Both services have the same price and service 2 is oversupplied.
pcss &lt;- sdm2(
  A = list(dst.firm, dst.consumer1, dst.consumer2),
  B = matrix(c(
    1, 0, 0,
    1, 0, 0,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, NA, NA,
    NA, 60, 60
  ), 3, 3, TRUE),
  names.commodity = c("serv1", "serv2", "labor"),
  names.agent = c("firm", "consumer1", "consumer2"),
  numeraire = "labor",
  policy = function(state) {
    state$p[2] &lt;- state$p[1]
    state
  },
  maxIteration = 1,
  numberOfPeriods = 200,
  depreciationCoef = 0,
  ts = TRUE
)

pcss$p
addmargins(pcss$D, 2)
addmargins(pcss$S, 2)
matplot(pcss$ts.q, type = "l")
matplot(pcss$ts.z, type = "l")
matplot(pcss$ts.p, type = "l")

##
pcss &lt;- sdm2(
  A = list(dst.firm, dst.consumer1, dst.consumer2),
  B = matrix(c(
    1, 0, 0,
    1, 0, 0,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, NA, NA,
    NA, 50, 50
  ), 3, 3, TRUE),
  names.commodity = c("serv1", "serv2", "labor"),
  names.agent = c("firm", "consumer1", "consumer2"),
  numeraire = "labor",
  policy = list(
    function(state) {
      state$p[1:2] &lt;- sum(state$p[1:2] * c(0.8, 0.2))
      state
    },
    makePolicyMeanValue()
  ),
  maxIteration = 1,
  numberOfPeriods = 1000,
  ts = TRUE
)

pcss$p
addmargins(pcss$D, 2)
addmargins(pcss$S, 2)
addmargins(pcss$DV)
addmargins(pcss$SV)
matplot(pcss$ts.q, type = "l")
matplot(pcss$ts.z, type = "l")
matplot(pcss$ts.p, type = "l")

</code></pre>

<hr>
<h2 id='gemOLG_Basic'>Some Examples of Basic (Timeline) OLG Models with Production</h2><span id='topic+gemOLG_Basic'></span>

<h3>Description</h3>

<p>Some examples of basic (timeline) OLG models with production.
In these models there are two types of commodities (i.e., labor and product) and two types of economic agents (i.e., laborers and firms).
Laborers (i.e., consumers) live for two or three periods.
These models can be easily extended to include more types of commodities, consumers and firms, and to allow consumers to live for more periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemOLG_Basic(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemOLG_Basic_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## When beta.consumer[1]==0, beta.consumer[2:3]&gt;0, labor.first[1]&gt;0, labor.first[2:3]==0,
## this model is actually the Diamond model. However, the division of periods is
## slightly different from the Diamond model.
ng &lt;- 15 # the number of generations
alpha.firm &lt;- 2 # the efficient parameter of firms
beta.prod.firm &lt;- 0.4 # the product (i.e. capital) share parameter of firms
beta.consumer &lt;- c(0, 0.8, 0.2) # the share parameter of consumers
gr.laborer &lt;- 0.03 # the population growth rate
labor.first &lt;- c(100, 0, 0) # the labor supply of the first generation
labor.last &lt;- 100 * (1 + gr.laborer)^((ng - 1):ng) # the labor supply of the last generation
y1 &lt;- 8 # the initial product supply

f &lt;- function() {
  names.commodity &lt;- c(paste0("prod", 1:(ng + 2)), paste0("lab", 1:(ng + 1)))
  names.agent &lt;- c(paste0("firm", 1:(ng + 1)), paste0("consumer", 1:ng))

  n &lt;- length(names.commodity) # the number of commodity kinds
  m &lt;- length(names.agent) # the number of agent kinds

  # the exogenous supply matrix.
  S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
  for (k in 1:(ng - 1)) {
    S0Exg[paste0("lab", k:(k + 2)), paste0("consumer", k)] &lt;- labor.first * (1 + gr.laborer)^(k - 1)
  }
  S0Exg[paste0("lab", ng:(ng + 1)), paste0("consumer", ng)] &lt;- labor.last
  S0Exg["prod1", "consumer1"] &lt;- y1

  B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
  for (k in 1:(ng + 1)) {
    B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
  }

  dstl.consumer &lt;- list()
  for (k in 1:ng) {
    dstl.consumer[[k]] &lt;- node_new(
      "util",
      type = "CD", alpha = 1,
      beta = beta.consumer,
      paste0("prod", k:(k + 2))
    )
  }


  dstl.firm &lt;- list()
  for (k in 1:(ng + 1)) {
    dstl.firm[[k]] &lt;- node_new(
      "prod",
      type = "CD", alpha = alpha.firm,
      beta = c(beta.prod.firm, 1 - beta.prod.firm),
      paste0("prod", k), paste0("lab", k)
    )
  }

  ge &lt;- sdm2(
    A = c(dstl.firm, dstl.consumer),
    B = B,
    S0Exg = S0Exg,
    names.commodity = names.commodity,
    names.agent = names.agent,
    numeraire = "lab1",
    priceAdjustmentVelocity = 0.05
  )

  cat("ge$p:\n")
  print(ge$p)
  cat("ge$z:\n")
  print(ge$z)
  invisible(ge)
}

ge &lt;- f()

# the growth rates of prices
growth_rate(ge$p[paste0("prod", 1:ng)]) + 1
growth_rate(ge$p[paste0("lab", 1:ng)]) + 1
# the steady-state growth rate of prices in the Diamond model
beta.consumer[3] * (1 - beta.prod.firm) / beta.prod.firm / (1 + gr.laborer)

# the output-labor ratios
ge$z[paste0("firm", 1:ng)] / rowSums(ge$S)[paste0("lab", 1:ng)]
# the steady-state output-labor ratio in the Diamond model
alpha.firm^(1 / (1 - beta.prod.firm)) * (beta.consumer[3] * (1 - beta.prod.firm) /
                                           (1 + gr.laborer))^(beta.prod.firm / (1 - beta.prod.firm))

# the captial-labor ratios
rowSums(ge$D[paste0("prod", 1:ng), paste0("firm", 1:ng)]) /
  rowSums(ge$S[paste0("lab", 1:ng), paste0("consumer", 1:ng)])
# the steady-state captial-labor ratio in the Diamond model
alpha.firm^(1 / (1 - beta.prod.firm)) * (beta.consumer[3] * (1 - beta.prod.firm)
                                         / (1 + gr.laborer))^(1 / (1 - beta.prod.firm))

##
ng &lt;- 15
alpha.firm &lt;- 2
beta.prod.firm &lt;- 0.5
beta.consumer &lt;- c(1, 1, 1) / 3
labor.first &lt;- c(50, 50, 0)
labor.last &lt;- c(50, 50)
y1 &lt;- 8
gr.laborer &lt;- 0
f()

#### Assume that consumers live for two periods and consume labor (i.e., leisure).
ng &lt;- 10 # the number of generations
alpha.firm &lt;- 2 # the efficient parameter of firms
beta.prod.firm &lt;- 0.5 # the product (i.e. capital) share parameter of firms
beta.consumer &lt;- prop.table(c(
  lab1 = 1, lab2 = 1,
  prod1 = 1, prod2 = 1
)) # the share parameter of consumers
labor &lt;- c(100, 0) # the labor supply of each generation
y1 &lt;- 8 # the initial product supply

names.commodity &lt;- c(paste0("lab", 1:(ng + 1)), paste0("prod", 1:(ng + 1)))
names.agent &lt;- c(paste0("consumer", 1:ng), paste0("firm", 1:ng))

n &lt;- length(names.commodity) # the number of commodity kinds
m &lt;- length(names.agent) # the number of agent kinds

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:ng) {
  S0Exg[paste0("lab", k:(k + 1)), paste0("consumer", k)] &lt;- labor
}
if (labor[2] == 0) S0Exg[paste0("lab", ng + 1), paste0("consumer", ng)] &lt;- labor[1]
S0Exg["prod1", "consumer1"] &lt;- y1


B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:ng) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}

dstl.consumer &lt;- list()
for (k in 1:ng) {
  dstl.consumer[[k]] &lt;- node_new(
    "util",
    type = "CD", alpha = 1,
    beta = beta.consumer, # prop.table(c(1e-5,1e-5,0.5,0.5)),
    paste0("lab", k:(k + 1)), paste0("prod", k:(k + 1))
  )
}

# Assume that consumers live for three periods.
# dstl.consumer &lt;- list()
# for (k in 1:(ng - 1)) {
#   dstl.consumer[[k]] &lt;- node_new(
#     "util",
#     type = "CD", alpha = 1,
#     beta = rep(1 / 6, 6),
#     paste0("lab", k:(k + 2)), paste0("prod", k:(k + 2))
#   )
# }
#
# dstl.consumer[[ng]] &lt;- node_new(
#   "util",
#   type = "CD", alpha = 1,
#   beta = rep(1 / 4, 4),
#   paste0("lab", ng:(ng + 1)), paste0("prod", ng:(ng + 1))
# )

dstl.firm &lt;- list()
for (k in 1:ng) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "CD", alpha = alpha.firm,
    beta = c(1 - beta.prod.firm, beta.prod.firm),
    paste0("lab", k), paste0("prod", k)
  )
}

ge &lt;- sdm2(
  A = c(dstl.consumer, dstl.firm),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "lab1"
)

ge$z
growth_rate(ge$p[paste0("prod", 1:ng)]) + 1
growth_rate(ge$p[paste0("lab", 1:ng)]) + 1
ge$p[paste0("prod", 1:ng)] / ge$p[paste0("lab", 1:ng)]

</code></pre>

<hr>
<h2 id='gemOLG_Land_4_3'>An Overlapping Generations Model with Land</h2><span id='topic+gemOLG_Land_4_3'></span>

<h3>Description</h3>

<p>Some examples of an overlapping generations model with land.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemOLG_Land_4_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemOLG_Land_4_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In this model, consumers live for two periods. Age2 owns a unit of land and age1 owns a unit of labor.
Here the land use rights and land ownership are regarded as two commodities.
Age2 gets land rent by selling land use rights to the firm.
Then land ownership is sold to age1. Age1 saves by purchasing land ownership.
</p>
<p>Here, the ratio of land rent to wage (denoted as xi) is determined by the production function.
No matter what the saving rate of age1 is, and at what price the land ownership is transferred to age1,
the consumption ratio of age2 and age1 will not be less than xi.
</p>
<p>When the consumer's intertemporal utility function is min(c1, c2),
the intertemporal substitution elasticity is 0,
and each consumer desires the same amount of consumption in the two periods.
It can also be assumed that the consumer's intertemporal substitution elasticity is close to 0 rather than exactly zero.
</p>
<p>If xi&gt;1, then this economy will inevitably have efficiency loss (dynamic inefficiency).
In this case, in order to achieve the optimal allocation, not only age2 should give land to age1 for free,
but age2 also needs to distribute part of the land rent to age1.
However, age2 has no incentive to do so.
</p>


<h3>References</h3>

<p>Rhee, Changyong (1991) Dynamic Inefficiency in an Economy with Land. Review of Economic Studies. 58(4), pp:791-797.
</p>


<h3>See Also</h3>


<p><code><a href="#topic+gemOLG_PureExchange">gemOLG_PureExchange</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
saving.rate &lt;- 0.001
ratio.saving.consumption &lt;- saving.rate / (1 - saving.rate)

dst.firm &lt;- node_new(
  "prod",
  type = "CD", alpha = 5,
  beta = c(1 / 6, 2 / 6, 3 / 6),
  "lab", "prod", "land.use.rights"
)

dst.age1 &lt;- node_new(
  "util",
  type = "FIN",
  rate = c(1, ratio.saving.consumption),
  "prod", "land.ownership"
)

dst.age2 &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "prod"
)

ge &lt;- sdm2(
  A = list(
    dst.firm, dst.age1, dst.age2
  ),
  B = matrix(c(
    1, 0, 0,
    0, 0, 0,
    0, 0, 0,
    0, 0, 0
  ), 4, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 1, NA,
    NA, NA, 1,
    NA, NA, 1
  ), 4, 3, TRUE),
  names.commodity = c("prod", "lab", "land.use.rights", "land.ownership"),
  names.agent = c("firm", "age1", "age2"),
  numeraire = "lab"
)

ge$p
ge$D
ge$DV
ge$S
ge$SV

## Change the saving-consumption ratio.
dst.age1$rate &lt;- c(1, ratio.saving.consumption = 99)

ge &lt;- sdm2(
  A = list(
    dst.firm, dst.age1, dst.age2
  ),
  B = matrix(c(
    1, 0, 0,
    0, 0, 0,
    0, 0, 0,
    0, 0, 0
  ), 4, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 1, NA,
    NA, NA, 1,
    NA, NA, 1
  ), 4, 3, TRUE),
  names.commodity = c("prod", "lab", "land.use.rights", "land.ownership"),
  names.agent = c("firm", "age1", "age2"),
  numeraire = "lab"
)

ge$p
ge$D
ge$DV
ge$S
ge$SV

</code></pre>

<hr>
<h2 id='gemOLG_PrivateFirm'>Overlapping Generations Models with Private Firm</h2><span id='topic+gemOLG_PrivateFirm'></span>

<h3>Description</h3>

<p>Some examples of overlapping generations models with private firm.
A public (i.e. publicly held) firm exists permanently and operates independently.
If a public firm ownership transfers between generations, this transfer will be done through
the exchange of shares.
In contrast, here a private firm is established by a consumer and only runs before she retires.
</p>
<p>In the first example, there are some two-period-lived consumers and a private firm.
Suppose age1 has a unit of labor and age2 has not.
In each period age1 establishes a private firm and the firm gets some labor as investment from age1
and will sell it in the market to buy some inputs for production.
In the next period, age2 (i.e. age1 in the previous period) gets the output of the firm.
Age2 consumes product and labor (i.e. service). Hence age1 and the firm can sell labor to age2
and buy product from age2.
</p>
<p>In the second example with three-period-lived consumers, there are two private firms (i.e. firm1 and firm2).
In each period age1 establishes a new firm1 and age2 establishes a new firm2.
Firm1 gets some labor as investment from age1 and firm2 gets some product and labor as investment from age2.
The output of firm1 belongs to age2 in the next period and the output of firm2 belongs to age3 in the next period.
In each period age2 (i.e. age1 in the previous period) takes away the output of firm1 and
age3 (i.e. age2 in the previous period) takes away the output of firm2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemOLG_PrivateFirm(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemOLG_PrivateFirm_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Acemoglu, D. (2009, ISBN: 9780691132921) Introduction to Modern Economic Growth. Princeton University Press.
</p>


<h3>See Also</h3>


<p><code><a href="#topic+gemOLGF_PureExchange">gemOLGF_PureExchange</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an example with a private firm and two-period-lived consumers
saving.rate &lt;- 0.5
beta.consumer &lt;-  c(1 / 2, 1 / 2) # c(9 / 10, 1 / 10)

dst.firm &lt;- node_new(
  "prod",
  type = "CD", alpha = 5,
  beta = c(2 / 3, 1 / 3),
  "prod", "lab"
)

dst.age1 &lt;- node_new(
  "util",
  type = "CD", alpha = 1,
  beta = beta.consumer,
  "prod", "lab"
)

dst.age2 &lt;- Clone(dst.age1)

ge &lt;- sdm2(
  A = list(
    dst.firm, dst.age1, dst.age2
  ),
  B = matrix(c(
    1, 0, 0,
    0, 0, 0
  ), 2, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 1, NA
  ), 2, 3, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "age1", "age2"),
  numeraire = "lab",
  policy = function(time, state) {
    if (time &gt; 1) {
      supply.prod &lt;- state$S[1, 1]
      supply.lab &lt;- state$S[2, 2]
      state$S &lt;- 0 * state$S
      state$S[1, 3] &lt;- supply.prod # age2 supplies prod.
      state$S[2, 1] &lt;- saving.rate * supply.lab # The firm gets investment from age1.
      state$S[2, 2] &lt;- (1 - saving.rate) * supply.lab
    }
    state
  }
)

ge$p
addmargins(ge$D, 2)
addmargins(ge$S, 2)
addmargins(ge$DV)
addmargins(ge$SV)

#### an example with two private firm and three-period-lived consumers
saving.rate.age1 &lt;- 1 / 3
saving.rate.age2 &lt;- 0.95

dst.firm1 &lt;- dst.firm2 &lt;- node_new(
  "prod",
  type = "CD", alpha = 5,
  beta = c(2 / 3, 1 / 3),
  "prod", "lab"
)

dst.age1 &lt;- dst.age2 &lt;- dst.age3 &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "prod"
)

ge &lt;- sdm2(
  A = list(
    dst.firm1, dst.firm2, dst.age1, dst.age2, dst.age3
  ),
  B = matrix(c(
    1, 1, 0, 0, 0,
    0, 0, 0, 0, 0
  ), 2, 5, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA, NA,
    NA, NA, 1, 1, NA
  ), 2, 5, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm1", "firm2", "age1", "age2", "age3"),
  numeraire = "lab",
  policy = function(time, state) {
    if (time &gt; 1) {
      state$S[1, 5] &lt;- state$S[1, 2] # Age3 takes away the output of firm2.
      state$S[1, 2] &lt;- 0

      # Age2 takes away the output of firm1.
      prod.age2 &lt;- state$S[1, 1]
      state$S[1, 1] &lt;- 0
      # Age2 establishes a new firm2.
      lab.age2 &lt;- state$S[2, 4]
      state$S[2, 2] &lt;- lab.age2 * saving.rate.age2 # Firm2 sells labor.
      state$S[1, 2] &lt;- prod.age2 * saving.rate.age2 # Firm2 sells product.

      state$S[2, 4] &lt;- lab.age2 * (1 - saving.rate.age2) # Age2 sells labor.
      state$S[1, 4] &lt;- prod.age2 * (1 - saving.rate.age2) # Age2 sells product.

      # Age1 establishes a new firm1.
      state$S[2, 1] &lt;- state$S[2, 3] * saving.rate.age1 # Firm1 sells labor.
      state$S[2, 3] &lt;- state$S[2, 3] * (1 - saving.rate.age1) # Age1 sells labor.
    }
    state
  }
)

ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)
addmargins(ge$DV)
addmargins(ge$SV)

</code></pre>

<hr>
<h2 id='gemOLG_PublicFirm'>Some Examples of (Timeline) OLG Models with Production and Public Firms</h2><span id='topic+gemOLG_PublicFirm'></span>

<h3>Description</h3>

<p>Some examples of (timeline) OLG models with production and public firms (see <cite><a href="#topic+gemIntertemporal_PublicFirm">gemIntertemporal_PublicFirm</a></cite>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemOLG_PublicFirm(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemOLG_PublicFirm_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><cite><a href="#topic+gemIntertemporal_PublicFirm">gemIntertemporal_PublicFirm</a></cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ng &lt;- 8 # the number of generations
alpha.firm &lt;- 2 # the efficient parameter of firms
beta.prod.firm &lt;- 0.5 # the product (i.e. capital) share parameter of firms
beta.consumer &lt;- c(1 / 3, 1 / 3, 1 / 3) # the share parameter of consumers
gr.laborer &lt;- 0 # the population growth rate
labor.first &lt;- c(50, 50, 0) # the labor supply of the first generation
# the labor supply of the last generation.
labor.last &lt;- 50 * (1 + gr.laborer)^((ng - 1):(ng + 1))
y1 &lt;- 100 # the initial product supply

policy.PublicFirm &lt;- function(state) {
  for (k in 1:(ng + 1)) {
    state$S[k + 1, k + 1] &lt;- state$S[k + 1, k]
    state$S[k + 1, k] &lt;- 0
  }
  state
}

f &lt;- function(policy = policy.PublicFirm) {
  names.commodity &lt;- c(paste0("prod", 1:(ng + 2)), paste0("lab", 1:(ng + 2)))
  names.agent &lt;- c(paste0("firm", 1:(ng + 2)), paste0("consumer", 1:ng))

  n &lt;- length(names.commodity) # the number of commodity kinds
  m &lt;- length(names.agent) # the number of agent kinds

  # the exogenous supply matrix.
  S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
  for (k in 1:(ng - 1)) {
    S0Exg[paste0("lab", k:(k + 2)), paste0("consumer", k)] &lt;-
      labor.first * (1 + gr.laborer)^(k - 1)
  }
  S0Exg[paste0("lab", ng:(ng + 2)), paste0("consumer", ng)] &lt;- labor.last
  S0Exg["prod1", "firm1"] &lt;- y1

  B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
  for (k in 1:(ng + 1)) {
    B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
  }

  dstl.consumer &lt;- list()
  for (k in 1:ng) {
    dstl.consumer[[k]] &lt;- node_new(
      "util",
      type = "CD", alpha = 1,
      beta = beta.consumer,
      paste0("prod", k:(k + 2))
    )
  }

  dstl.firm &lt;- list()
  for (k in 1:(ng + 2)) {
    dstl.firm[[k]] &lt;- node_new(
      "prod",
      type = "CD", alpha = alpha.firm,
      beta = c(beta.prod.firm, 1 - beta.prod.firm),
      paste0("prod", k), paste0("lab", k)
    )
  }

  ge &lt;- sdm2(
    A = c(dstl.firm, dstl.consumer),
    B = B,
    S0Exg = S0Exg,
    names.commodity = names.commodity,
    names.agent = names.agent,
    numeraire = "lab1",
    priceAdjustmentVelocity = 0.05,
    policy = policy
  )

  cat("ge$p:\n")
  print(ge$p)
  cat("ge$z:\n")
  print(ge$z)
  invisible(ge)
}

ge &lt;- f()

# the growth rates of prices
growth_rate(ge$p[paste0("prod", 1:ng)]) + 1
growth_rate(ge$p[paste0("lab", 1:ng)]) + 1

##
labor.first &lt;- c(100 / 3, 100 / 3, 100 / 3) # the labor supply of the first generation
ge &lt;- f()

##
tax.rate &lt;- 0.1
policy.PublicFirm.Tax &lt;- function(state) {
  for (k in 1:(ng + 1)) {
    state$S[k + 1, k + 1] &lt;- state$S[k + 1, k] * (1 - tax.rate)
    state$S[k + 1, k + ng] &lt;- state$S[k + 1, k] * tax.rate
    state$S[k + 1, k] &lt;- 0
  }
  state
}

ge &lt;- f(policy.PublicFirm.Tax)

##
beta.consumer &lt;- c(1 / 2, 1 / 2, 0) # the share parameter of consumers
labor.first &lt;- c(90, 10, 0) # the labor supply of the first generation
ge &lt;- f()

</code></pre>

<hr>
<h2 id='gemOLG_PureExchange'>The Basic Overlapping Generations Pure Exchange Model (see Samuelson, 1958)</h2><span id='topic+gemOLG_PureExchange'></span>

<h3>Description</h3>

<p>This is the basic overlapping generations pure exchange model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemOLG_PureExchange(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemOLG_PureExchange_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As Samuelson (1958) wrote, break each life up into thirds.
Agents get 50 units of payoff in period 1 and 50 units in period 2; in period 3 they retire and get nothing.
Suppose there are three agents in each period, namely age1, age2 and age3.
In the next period, the present age1 will become age2, the present age2 will become age3,
the present age3 will disappear and a new age1 will appear.
Let c1, c2 and c3 denote the consumption of an agent in each period.
Suppose the utility function is (c1 * c2 * c3)^(1 / 3), which is actually the same as log(c1) + log(c2) + log(c3).
In each period, age1 and age2 will exchange their payoffs of the present period and the next period.
Age2 will sell some present payoff and buy some future payoff as pension, and for age1, it's the opposite.
Age3 simply receives the pension and need not take part in the exchange.
Hence only two agents participate in the pure exchange economy.
In the exchange process, the utility function of age1 is c1^(1 / 3) * x2^(2 / 3), wherein x2 is the revenue of the next period,
and the utility function of age2 is c2^(1 / 2) * c3^(1 / 2).
</p>


<h3>Note</h3>

<p>We can also suppose only age2 gets payoff and age1 does not.
</p>


<h3>References</h3>

<p>Samuelson, P. A. (1958) An Exact Consumption-Loan Model of Interest with or without the Social Contrivance of Money. Journal of Political Economy, vol. 66(6): 467-482.
</p>


<h3>See Also</h3>


<p><code><a href="#topic+gemOLG_TimeCircle">gemOLG_TimeCircle</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### the basic overlapping generations (inefficient) exchange model in sequential form.
dst.age1 &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = c(1 / 3, 2 / 3),
  "payoff1", "payoff2"
)

dst.age2 &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = c(1 / 2, 1 / 2),
  "payoff1", "payoff2"
)

policy.supply &lt;- function(time, state) {
  pension &lt;- (state$last.A[, 2] * state$last.z[2])[2]
  if (time &gt; 1) state$S[1, 2] &lt;- 50 - pension
  state
}

ge &lt;- sdm2(
  A = list(dst.age1, dst.age2),
  B = matrix(0, 2, 2),
  S0Exg = matrix(c(
    50, 50,
    50, 0
  ), 2, 2, TRUE),
  names.commodity = c("payoff1", "payoff2"),
  names.agent = c("age1", "age2"),
  numeraire = "payoff1",
  policy = list(policy.supply, policyMarketClearingPrice),
  maxIteration = 1,
  numberOfPeriods = 20,
  ts = TRUE
)

ge$p # c(1, 3 / 2 + sqrt(13) / 2)
ge$ts.p
ge$S
ge$D
ge$DV

#### the basic overlapping generations exchange model in timeline form.
m &lt;- 15 # the number of generations
n &lt;- m + 1 # the number of commodity kinds

names.commodity &lt;- paste0("payoff", 1:n)
names.agent &lt;- paste0("gen", 1:m)

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:m) {
  S0Exg[k:(k + 1), k] &lt;- 50
}

dstl.consumer &lt;- list()
for (k in 1:(m - 1)) {
  dstl.consumer[[k]] &lt;- node_new(
    "util",
    type = "CD", alpha = 1,
    beta = rep(1 / 3, 3),
    paste0("payoff", k:(k + 2))
  )
}

dstl.consumer[[m]] &lt;- node_new(
  "util",
  type = "CD", alpha = 1,
  beta = c(0.5, 0.5),
  paste0("payoff", m:(m + 1))
)

ge &lt;- sdm2(
  A = dstl.consumer,
  B = matrix(0, n, m),
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "payoff1"
)

round(addmargins(ge$D, 2), 2)
round(addmargins(ge$S, 2), 2)
growth_rate(ge$p) + 1 # 3 / 2 + sqrt(13) / 2

#### Assume that in the timeline model, each consumer lives for four periods or more.
nl &lt;- 4 # the number of life periods
payoff &lt;- c(rep(100 / (nl - 1), nl - 1), 1e-10) # the lifetime payoffs
m &lt;- 20 # the number of generations
n &lt;- m + nl - 1 # the number of commodity kinds

names.commodity &lt;- paste0("payoff", 1:n)
names.agent &lt;- paste0("gen", 1:m)

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:m) {
  S0Exg[k:(k + nl - 1), k] &lt;- payoff
}

dstl.consumer &lt;- list()
for (k in 1:m) {
  dstl.consumer[[k]] &lt;- node_new(
    "util",
    type = "CD", alpha = 1,
    beta = rep(1 / nl, nl),
    paste0("payoff", k:(k + nl - 1))
  )
}

ge &lt;- sdm2(
  A = dstl.consumer,
  B = matrix(0, n, m),
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "payoff1"
)

round(addmargins(ge$D, 2), 2)
round(addmargins(ge$S, 2), 2)
growth_rate(ge$p) + 1

</code></pre>

<hr>
<h2 id='gemOLG_PureExchange_Bank'>Overlapping Generations Pure Exchange Models with Bank</h2><span id='topic+gemOLG_PureExchange_Bank'></span>

<h3>Description</h3>

<p>Some examples of overlapping generations pure exchange models with bank.
Under a pay-as-you-go system, banks may only redistribute payoffs among consumers in each period.
This is, in each period a bank can get a part of payoff of age1 and pay it to age2 immediately.
From the consumer's point of view, the bank converts the current period's payoff into the next period's payoff.
Each consumer only transacts with the bank, and she can assume that there are no other consumers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemOLG_PureExchange_Bank(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemOLG_PureExchange_Bank_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>See Also</h3>


<p><code><a href="#topic+gemOLG_PureExchange">gemOLG_PureExchange</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an example with a two-period-lived consumer
dst.bank &lt;- node_new(
  "payoff2",
  type = "Leontief", a = 1,
  "payoff1"
)

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = c(1 / 2, 1 / 2),
  "payoff1", "payoff2"
)

ge &lt;- sdm2(
  A = list(dst.bank, dst.consumer),
  B = matrix(c(
    0, 0,
    1, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, 100,
    NA, NA
  ), 2, 2, TRUE),
  names.commodity = c("payoff1", "payoff2"),
  names.agent = c("bank", "consumer"),
  numeraire = "payoff1"
)

ge$p
ge$D
ge$S

#### an example with a three-period-lived consumer.
dst.bank1 &lt;- node_new(
  "payoff2",
  type = "Leontief", a = 1,
  "payoff1"
)

dst.bank2 &lt;- node_new(
  "payoff3",
  type = "Leontief", a = 1,
  "payoff2"
)

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = c(1 / 3, 1 / 3, 1 / 3),
  "payoff1", "payoff2", "payoff3"
)

ge &lt;- sdm2(
  A = list(dst.bank1, dst.bank2, dst.consumer),
  B = matrix(c(
    0, 0, 0,
    1, 0, 0,
    0, 1, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, 50,
    NA, NA, 50,
    NA, NA, NA
  ), 3, 3, TRUE),
  names.commodity = c("payoff1", "payoff2", "payoff3"),
  names.agent = c("bank1", "bank2", "consumer"),
  numeraire = "payoff1"
)

ge$p
ge$S
ge$D

## Assume that banks can earn interest through foreign investment.
dst.bank1$a &lt;- 0.8
dst.bank2$a &lt;- 0.8
ge &lt;- sdm2(
  A = list(dst.bank1, dst.bank2, dst.consumer),
  B = matrix(c(
    0, 0, 0,
    1, 0, 0,
    0, 1, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, 50,
    NA, NA, 50,
    NA, NA, NA
  ), 3, 3, TRUE),
  names.commodity = c("payoff1", "payoff2", "payoff3"),
  names.agent = c("bank1", "bank2", "consumer"),
  numeraire = "payoff1"
)

ge$p
ge$S
ge$D
ge$DV


</code></pre>

<hr>
<h2 id='gemOLG_StochasticSequential_3_3'>A 3-by-3 OLG Stochastic Sequential General Equilibrium Model</h2><span id='topic+gemOLG_StochasticSequential_3_3'></span>

<h3>Description</h3>

<p>A 3-by-3 OLG stochastic sequential general equilibrium model.
There are two-period lived consumers and a type of firm. There are three types of commodities, i.e. product, labor and security (i.e. paper asset, store of value).
</p>
<p>In each period there are a young (i.e. age1), an old (i.e. age2) and a firm.
The young supplies a unit of labor and the old supplies a unit of security.
</p>
<p>Consumers only consume products. The young buys the security to save.
</p>
<p>The firm inputs labor to produce the product.
Productivity is random.
The amount of labor required to produce 1 unit of product is equal to 0.1 or 0.2,
both of which occur with equal probability.
</p>
<p>All labor is used in production.
Therefore, it can be known that the product output in each period
(that is, the product supply in the next period) is equal to 10 or 5,
that is to say, there are two natural states with equal probability of occurrence in each period: good state and bad state.
The states are denoted as a and b, respectively.
There are then four cases of natural states experienced by a consumer in two periods: aa, bb, ab and ba.
</p>
<p>Take the product as numeraire.
The ratio of the security price in the latter period to the previous period of the two periods is the gross rate of return.
The gross rates of return on the savings of the young in the four cases is denoted as Raa, Rbb, Rab and Rba, respectively.
</p>
<p>The utility function of the young is -0.5*x1^-1 - 0.25*x2^-1 - 0.25*x3^-1,
where x1, x2 and x3 are the (expected) consumption in the current period and the next two natural states, respectively.
It can be seen that the intertemporal substitution elasticity and the inter-natural-state substitution elasticity in the utility function are both 0.5,
that is, the relative risk aversion coefficient is 2.
</p>
<p>In each period, the young determines the saving rate based on the expected gross rates of return on the security and the utility function.
</p>
<p>In each period the young adopts the following anticipation method for the gross rate of return of the savings: First, determine the two types of gross rates of return (Raa, Rab or Rbb, Rba) that need to be predicted according to the current state. Both interest rates are then forecasted using the adaptive expectation method.
</p>
<p>A spot market clearing path (alias instantaneous equilibrium path) and a disequilibrium path will be calculated below.
The spot market clearing path will converge to the stochastic equilibrium consisting of two equilibrium states, and the disequilibrium paths not.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemOLG_StochasticSequential_3_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemOLG_StochasticSequential_3_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# a function to find the optimal saving rate given the expected gross rates of return.
osr &lt;- function(Ra, Rb, es = 0.5, beta = c(0.5, 0.25, 0.25)) {
  sigma &lt;- 1 - 1 / es
  ((beta[2] * Ra^sigma / beta[1] + beta[3] * Rb^sigma / beta[1])^-es + 1)^-1
}

dst.firm &lt;- node_new(
  "prod",
  type = "Leontief", a = 0.2,
  "lab"
)

dst.age1 &lt;-
  node_new("util",
    type = "FIN", rate = c(1, 1),
    "prod", "secy",
    last.price = c(1, 1, 1),
    last.output = 10,
    Raa = 1, Rbb = 1, Rab = 1, Rba = 1,
    REbb = 1, REba = 1, REab = 1, REaa = 1,
    sr.ts.1 = vector(),
    sr.ts.2 = vector()
  )

dst.age2 &lt;-
  node_new("util",
    type = "Leontief", a = 1,
    "prod"
  )

policyStochasticTechnology &lt;- function(time, A) {
  A[[1]]$a &lt;- sample(c(0.1, 0.2), 1)
}

policySaving &lt;- function(time, A, state) {
  output &lt;- state$S[1, 1]

  lambda &lt;- 0.9

  if (output &lt; 8) {
    A[[2]]$REba &lt;- lambda * tail(A[[2]]$Rba, 1) + (1 - lambda) * A[[2]]$REba
    A[[2]]$REbb &lt;- lambda * tail(A[[2]]$Rbb, 1) + (1 - lambda) * A[[2]]$REbb

    saving.rate &lt;- osr(A[[2]]$REba, A[[2]]$REbb)
    A[[2]]$sr.ts.1 &lt;- c(A[[2]]$sr.ts.1, saving.rate)
  }

  if (output &gt;= 8) {
    A[[2]]$REaa &lt;- lambda * tail(A[[2]]$Raa, 1) + (1 - lambda) * A[[2]]$REaa
    A[[2]]$REab &lt;- lambda * tail(A[[2]]$Rab, 1) + (1 - lambda) * A[[2]]$REab

    saving.rate &lt;- osr(A[[2]]$REaa, A[[2]]$REab)
    A[[2]]$sr.ts.2 &lt;- c(A[[2]]$sr.ts.2, saving.rate)
  }

  A[[2]]$rate &lt;- c(1, saving.rate / (1 - saving.rate))
}


policyRecord &lt;- function(time, A, state) {
  last.p &lt;- A[[2]]$last.price
  p &lt;- state$p / state$p[1]

  last.output &lt;- A[[2]]$last.output
  output &lt;- A[[2]]$last.output &lt;- state$S[1, 1]

  if ((last.output &lt; 8) &amp;&amp; (output &lt; 8)) A[[2]]$Rbb &lt;- c(A[[2]]$Rbb, p[3] / last.p[3])
  if ((last.output &lt; 8) &amp;&amp; (output &gt;= 8)) A[[2]]$Rba &lt;- c(A[[2]]$Rba, p[3] / last.p[3])
  if ((last.output &gt;= 8) &amp;&amp; (output &lt; 8)) A[[2]]$Rab &lt;- c(A[[2]]$Rab, p[3] / last.p[3])
  if ((last.output &gt;= 8) &amp;&amp; (output &gt;= 8)) A[[2]]$Raa &lt;- c(A[[2]]$Raa, p[3] / last.p[3])

  A[[2]]$last.price &lt;- p
}

dstl &lt;- list(dst.firm, dst.age1, dst.age2)

B &lt;- matrix(c(
  1, 0, 0,
  0, 0, 0,
  0, 0, 0
), 3, 3, TRUE)

S0Exg &lt;- matrix(c(
  NA, NA, NA,
  NA, 1, NA,
  NA, NA, 1
), 3, 3, TRUE)

## a spot market clearing path.
set.seed(1)
ge &lt;- sdm2(
  A = dstl, B = B, S0Exg = S0Exg,
  names.commodity = c("prod", "lab", "secy"),
  names.agent = c("firm", "age1", "age2"),
  numeraire = "prod",
  policy = list(
    policyStochasticTechnology,
    policySaving,
    policyMarketClearingPrice,
    policyRecord
  ),
  z0 = c(5, 1, 1),
  maxIteration = 1,
  numberOfPeriods = 40,
  ts = TRUE
)

matplot(ge$ts.z, type = "o", pch = 20)
matplot(ge$ts.p, type = "o", pch = 20)

## a disequilibrium path.
set.seed(1)
de &lt;- sdm2(
  A = dstl, B = B, S0Exg = S0Exg,
  names.commodity = c("prod", "lab", "secy"),
  names.agent = c("firm", "age1", "age2"),
  numeraire = "prod",
  policy = list(
    policyStochasticTechnology,
    policySaving,
    policyRecord
  ),
  maxIteration = 1,
  numberOfPeriods = 400,
  ts = TRUE
)

matplot(de$ts.z, type = "o", pch = 20)
matplot(de$ts.p, type = "o", pch = 20)

## an equilibrium model for solving the optimal saving
# rate based on the expected gross rates of return.
Ra &lt;- 1
Rb &lt;- 0.4

ge &lt;- sdm2(
  A = function(state) {
    a.bank &lt;- c(1, 0, 0)
    a.consumer &lt;- CES_A(
      sigma = (1 - 1 / 0.5), alpha = 1,
      Beta = c(0.5, 0.25, 0.25), p = state$p
    )
    cbind(a.bank, a.consumer)
  },
  B = matrix(c(
    0, 0,
    Ra, 0,
    Rb, 0
  ), 3, 2, TRUE),
  S0Exg = matrix(c(
    NA, 1,
    NA, 0,
    NA, 0
  ), 3, 2, TRUE),
  names.commodity = c("payoff1", "payoff2", "payoff3"),
  names.agent = c("bank", "consumer"),
  numeraire = "payoff1",
)

ge$p
addmargins(ge$D, 2)
addmargins(ge$S, 2)

ge$z[1]
osr(Ra, Rb)

## a pure exchange model.
dst.age1 &lt;- node_new("util",
  type = "FIN", rate = c(1, 1),
  "payoff", "secy",
  last.price = c(1, 1),
  last.payoff = 1,
  Rbb = 1, Rba = 1, Rab = 1, Raa = 1,
  REbb = 1, REba = 1, REab = 1, REaa = 1,
  sr.ts.1 = vector(),
  sr.ts.2 = vector()
)

dst.age2 &lt;- node_new("util",
  type = "Leontief", a = 1,
  "payoff"
)

policyStochasticSupply &lt;- function(state) {
  state$S[1, 1] &lt;- sample(c(5, 10), 1)
  state
}

policySaving &lt;- function(time, A, state) {
  payoff &lt;- state$S[1, 1]

  lambda &lt;- 0.9
  if (time &gt;= 5) {
    if (payoff == 5) {
      A[[1]]$REba &lt;- lambda * tail(A[[1]]$Rba, 1) + (1 - lambda) * A[[1]]$REba
      A[[1]]$REbb &lt;- lambda * tail(A[[1]]$Rbb, 1) + (1 - lambda) * A[[1]]$REbb

      saving.rate &lt;- osr(A[[1]]$REba, A[[1]]$REbb)
      A[[1]]$sr.ts.1 &lt;- c(A[[1]]$sr.ts.1, saving.rate)
    }

    if (payoff == 10) {
      A[[1]]$REaa &lt;- lambda * tail(A[[1]]$Raa, 1) + (1 - lambda) * A[[1]]$REaa
      A[[1]]$REab &lt;- lambda * tail(A[[1]]$Rab, 1) + (1 - lambda) * A[[1]]$REab

      saving.rate &lt;- osr(A[[1]]$REaa, A[[1]]$REab)
      A[[1]]$sr.ts.2 &lt;- c(A[[1]]$sr.ts.2, saving.rate)
    }

    A[[1]]$rate &lt;- c(1, saving.rate / (1 - saving.rate))
  }
}

policyRecord &lt;- function(time, A, state) {
  last.p &lt;- A[[1]]$last.price
  p &lt;- state$p / state$p[1]

  last.payoff &lt;- A[[1]]$last.payoff
  payoff &lt;- state$S[1, 1]

  if ((last.payoff == 5) &amp;&amp; (payoff == 5)) A[[1]]$Rbb &lt;- c(A[[1]]$Rbb, p[2] / last.p[2])
  if ((last.payoff == 5) &amp;&amp; (payoff == 10)) A[[1]]$Rba &lt;- c(A[[1]]$Rba, p[2] / last.p[2])
  if ((last.payoff == 10) &amp;&amp; (payoff == 5)) A[[1]]$Rab &lt;- c(A[[1]]$Rab, p[2] / last.p[2])
  if ((last.payoff == 10) &amp;&amp; (payoff == 10)) A[[1]]$Raa &lt;- c(A[[1]]$Raa, p[2] / last.p[2])


  A[[1]]$last.price &lt;- p
  A[[1]]$last.payoff &lt;- state$S[1, 1]
}

set.seed(1)
ge &lt;- sdm2(
  A = list(dst.age1, dst.age2),
  B = matrix(0, 2, 2),
  S0Exg = matrix(c(
    1, NA,
    NA, 1
  ), 2, 2, TRUE),
  names.commodity = c("payoff", "secy"),
  names.agent = c("age1", "age2"),
  numeraire = "payoff",
  policy = list(
    policyStochasticSupply,
    policySaving,
    policyMarketClearingPrice,
    policyRecord
  ),
  maxIteration = 1,
  numberOfPeriods = 40,
  ts = TRUE
)

matplot(ge$ts.z, type = "o", pch = 20)
matplot(ge$ts.p, type = "o", pch = 20)
dst.age1$last.payoff
dst.age1$last.price
dst.age1$Rbb

</code></pre>

<hr>
<h2 id='gemOLG_TimeCircle'>Time-Circle Models (Closed Loop Overlapping Generations Models)</h2><span id='topic+gemOLG_TimeCircle'></span>

<h3>Description</h3>

<p>Some examples of time-circle models, which usually contain overlapping generations.
When we connect together the head and tail of time of a dynamic model, we get a time-circle model which
treats time as a circle of finite length instead of a straight line of infinite length.
The (discounted) output of the final period will enter the utility function and the production function
of the first period, which implies the influence mechanism of the past on the present is
just like the influence mechanism of the present on the future.
A time-circle OLG model may be called a reincarnation model.
</p>
<p>In a time-circle model, time can be thought of as having no beginning and no end.
And we can assume all souls meet in a single market (see Shell, 1971),
or there are implicit financial instruments that facilitate transactions between adjacent generations.
</p>
<p>As in the Arrow–Debreu approach, in the following examples with production, we assume that firms operate independently and are not owned by consumers.
That is, there is no explicit property of firms as the firms do not make pure profit at equilibrium (constant return to scale)
(see de la Croix and Michel, 2002, page 292).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemOLG_TimeCircle(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemOLG_TimeCircle_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>de la Croix, David and Philippe Michel (2002, ISBN: 9780521001151) A Theory of Economic Growth: Dynamics and Policy in Overlapping Generations. Cambridge University Press.
</p>
<p>Diamond, Peter (1965) National Debt in a Neoclassical Growth Model. American Economic Review. 55 (5): 1126-1150.
</p>
<p>Samuelson, P. A. (1958) An Exact Consumption-Loan Model of Interest with or without the Social Contrivance of Money. Journal of Political Economy, vol. 66(6): 467-482.
</p>
<p>Shell, Karl (1971) Notes on the Economics of Infinity. Journal of Political Economy. 79 (5): 1002–1011.
</p>


<h3>See Also</h3>


<p><code><a href="#topic+gemOLG_PureExchange">gemOLG_PureExchange</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### a time-circle pure exchange economy with two-period-lived consumers.
# In this example, each agent sells some payoff to the previous
# generation and buys some payoff from the next generation.

# Here np can tend to infinity.
np &lt;- 4 # the number of economic periods, commodity kinds and generations

names.commodity &lt;- c(paste0("payoff", 1:np))
names.agent &lt;- paste0("gen", 1:np)

index.comm &lt;- c(1:np, 1)
payoff &lt;- c(100, 0) # the payoffs of lifetime
# the exogenous supply matrix.
S0Exg &lt;- matrix(0, np, np, dimnames = list(names.commodity, names.agent))
for (k in 1:np) {
  S0Exg[index.comm[k:(k + 1)], k] &lt;- payoff
}

# Suppose each consumer has a utility function log(c1) + log(c2).
beta.consumer &lt;- c(0.5, 0.5)
index.comm &lt;- c(1:np, 1)
dstl.consumer &lt;- list()
for (k in 1:np) {
  dstl.consumer[[k]] &lt;- node_new(
    "util",
    type = "CD", alpha = 1,
    beta = beta.consumer,
    paste0("payoff", index.comm[k]), paste0("payoff", index.comm[k + 1])
  )
}

ge &lt;- sdm2(
  A = dstl.consumer,
  B = matrix(0, np, np),
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "payoff1"
)

ge$p
ge$D
ge$S

## Introduce population growth into the above pure exchange economy.
GRExg &lt;- 0.03 # the population growth rate

S0Exg &lt;- S0Exg %*% diag((1 + GRExg)^(0:(np - 1)))
S0Exg[1, np] &lt;- S0Exg[1, np] * (1 + GRExg)^-np

dstl.consumer[[np]] &lt;- node_new(
  "util",
  type = "CD", alpha = 1,
  beta = beta.consumer,
  paste0("payoff", np), "cc1"
)
node_set(dstl.consumer[[np]],
  "cc1",
  type = "Leontief", a = (1 + GRExg)^(-np), # a discounting factor
  "payoff1"
)

ge2 &lt;- sdm2(
  A = dstl.consumer,
  B = matrix(0, np, np),
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "payoff1"
)

ge2$p
ge2$D
ge2$DV
ge2$S

#### a time-circle pure exchange economy with three-period-lived consumers
# Suppose each consumer has a utility function log(c1) + log(c2) + log(c3).
# See gemOLG_PureExchange.
np &lt;- 5 # the number of economic periods, commodity kinds and generations

names.commodity &lt;- c(paste0("payoff", 1:np))
names.agent &lt;- paste0("gen", 1:np)

index.comm &lt;- c(1:np, 1:2)
payoff &lt;- c(50, 50, 0) # the payoffs of lifetime
# the exogenous supply matrix.
S0Exg &lt;- matrix(0, np, np, dimnames = list(names.commodity, names.agent))
for (k in 1:np) {
  S0Exg[index.comm[k:(k + 2)], k] &lt;- payoff
}

dstl.consumer &lt;- list()
for (k in 1:np) {
  dstl.consumer[[k]] &lt;- node_new(
    "util",
    type = "CD", alpha = 1,
    beta = rep(1 / 3, 3),
    paste0("payoff", index.comm[k:(k + 2)])
  )
}

ge &lt;- sdm2(
  A = dstl.consumer,
  B = matrix(0, np, np),
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "payoff1"
)

ge$p
ge$D

## Introduce population growth into the above pure exchange economy.
GRExg &lt;- 0.03 # the population growth rate
df &lt;- (1 + GRExg)^-np # a discounting factor

# the exogenous supply matrix.
S0Exg &lt;- matrix(0, np, np, dimnames = list(names.commodity, names.agent))
for (k in 1:np) {
  S0Exg[paste0("payoff", index.comm[k:(k + 2)]), paste0("gen", k)] &lt;-
    payoff * (1 + GRExg)^(k - 1)
}
S0Exg[paste0("payoff", 1:2), paste0("gen", np)] &lt;-
  S0Exg[paste0("payoff", 1:2), paste0("gen", np)] * df
S0Exg[paste0("payoff", 1), paste0("gen", np - 1)] &lt;-
  S0Exg[paste0("payoff", 1), paste0("gen", np - 1)] * df

dstl.consumer[[np - 1]] &lt;- node_new(
  "util",
  type = "CD", alpha = 1,
  beta = rep(1 / 3, 3),
  paste0("payoff", (np - 1):(np + 1))
)
node_set(dstl.consumer[[np - 1]], paste0("payoff", np + 1),
  type = "Leontief", a = df,
  "payoff1"
)

dstl.consumer[[np]] &lt;- node_new(
  "util",
  type = "CD", alpha = 1,
  beta = rep(1 / 3, 3),
  paste0("payoff", np:(np + 2))
)
node_set(dstl.consumer[[np]], paste0("payoff", np + 1),
  type = "Leontief", a = df,
  "payoff1"
)
node_set(dstl.consumer[[np]], paste0("payoff", np + 2),
  type = "Leontief", a = df,
  "payoff2"
)

ge2 &lt;- sdm2(
  A = dstl.consumer,
  B = matrix(0, np, np),
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "payoff1"
)

ge2$p
growth_rate(ge2$p) + 1 # 1 / (1 + GRExg)
ge2$D
ge2$DV

#### a time-circle model with production and two-period-lived consumers
# Suppose each consumer has a utility function log(c1) + log(c2).
np &lt;- 5 # the number of economic periods, consumers and firms.
names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:np))
names.agent &lt;- c(paste0("firm", 1:np), paste0("consumer", 1:np))

index.comm &lt;- c(1:np, 1)
labor.supply &lt;- c(100, 0) # the labor supply of lifetime
# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, 2 * np, 2 * np, dimnames = list(names.commodity, names.agent))
for (k in 1:np) {
  S0Exg[paste0("lab", index.comm[k:(k + 1)]), paste0("consumer", k)] &lt;- labor.supply
}

B &lt;- matrix(0, 2 * np, 2 * np, dimnames = list(names.commodity, names.agent))
for (k in 1:np) {
  B[paste0("prod", index.comm[k + 1]), paste0("firm", k)] &lt;- 1
}

dstl.firm &lt;- list()
for (k in 1:np) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "CD", alpha = 5,
    beta = c(1 / 3, 2 / 3),
    paste0("lab", k), paste0("prod", k)
  )
}

dstl.consumer &lt;- list()
for (k in 1:np) {
  dstl.consumer[[k]] &lt;- node_new(
    "util",
    type = "CD", alpha = 1,
    beta = c(1 / 2, 1 / 2),
    paste0("prod", index.comm[k:(k + 1)])
  )
}

ge &lt;- sdm2(
  A = c(dstl.firm, dstl.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "lab1"
)

ge$p
ge$D

## Introduce population growth into the above economy.
GRExg &lt;- 0.03 # the population growth rate
df &lt;- (1 + GRExg)^-np # a discounting factor

for (k in 1:np) {
  S0Exg[paste0("lab", index.comm[k:(k + 1)]), paste0("consumer", k)] &lt;-
    labor.supply * (1 + GRExg)^(k - 1)
}

B[1, np] &lt;- df

dstl.consumer[[np]] &lt;- node_new(
  "util",
  type = "CD", alpha = 1,
  beta = c(1 / 2, 1 / 2),
  paste0("prod", np), "cc1"
)
node_set(dstl.consumer[[np]], "cc1",
  type = "Leontief", a = df,
  "prod1"
)

ge2 &lt;- sdm2(
  A = c(dstl.firm, dstl.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "lab1",
  policy = makePolicyMeanValue(30),
  maxIteration = 1,
  numberOfPeriods = 600,
  ts = TRUE
)

ge2$p
growth_rate(ge2$p[1:np]) + 1 # 1 / (1 + GRExg)
growth_rate(ge2$p[(np + 1):(2 * np)]) + 1 # 1 / (1 + GRExg)
ge2$D
ge2$DV

#### a time-circle model with production and one-period-lived consumers.
# These consumers also can be regarded as infinite-lived agents maximizing
# their per period utility subject to their disposable income per period.
np &lt;- 5 # the number of economic periods, consumers and firms.
GRExg &lt;- 0.03 # the population growth rate
# df &lt;- (1 + GRExg)^-np # a discounting factor
df &lt;- 0.5

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:np))
names.agent &lt;- c(paste0("firm", 1:np), paste0("consumer", 1:np))

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, 2 * np, 2 * np, dimnames = list(names.commodity, names.agent))
for (k in 1:np) {
  S0Exg[paste0("lab", k), paste0("consumer", k)] &lt;- 100 * (1 + GRExg)^(k - 1)
}

B &lt;- matrix(0, 2 * np, 2 * np, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", index.comm[k + 1]), paste0("firm", k)] &lt;- 1
}
B["prod1", paste0("firm", np)] &lt;- df

beta.firm &lt;- c(1 / 3, 2 / 3)
beta.consumer &lt;- c(1 / 2, 1 / 2)

dstl.firm &lt;- list()
for (k in 1:np) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "CD", alpha = 5,
    beta = beta.firm,
    paste0("lab", k), paste0("prod", k)
  )
}

dstl.consumer &lt;- list()
for (k in 1:np) {
  dstl.consumer[[k]] &lt;- node_new(
    "util",
    type = "CD", alpha = 1,
    beta = beta.consumer,
    paste0("lab", k), paste0("prod", k)
  )
}

ge &lt;- sdm2(
  A = c(dstl.firm, dstl.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "lab1",
  policy = makePolicyMeanValue(30),
  maxIteration = 1,
  numberOfPeriods = 600,
  ts = TRUE
)

ge$p
growth_rate(ge$p[1:np]) + 1 # 1 / (1 + GRExg)
growth_rate(ge$p[(np + 1):(2 * np)]) + 1 # 1 / (1 + GRExg)
ge$D

## the sequential form of the above model.
dst.firm &lt;- node_new(
  "prod",
  type = "CD", alpha = 5,
  beta = beta.firm,
  "lab", "prod"
)

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1,
  beta = beta.consumer,
  "lab", "prod"
)

ge2 &lt;- sdm2(
  A = list(
    dst.firm,
    dst.consumer
  ),
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100 / (1 + GRExg)
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "lab",
  z0 = c(ge$S[1, np], 0),
  GRExg = GRExg,
  policy = policyMarketClearingPrice,
  maxIteration = 1,
  numberOfPeriods = 20,
  ts = TRUE
)

ge2$p
ge2$D
ge2$ts.z[, 1]
ge$z

#### a time-circle OLG model with production and three-period-lived consumers.
np &lt;- 6 # the number of economic periods, consumers and firms
gr.laborer &lt;- 0.03 # the population growth rate
df &lt;- (1 + gr.laborer)^-np # a discounting factor
alpha.firm &lt;- 2 # the efficient parameter of firms
beta.prod.firm &lt;- 0.4 # the product (i.e. capital) share parameter of firms
beta.consumer &lt;- c(0, 0.8, 0.2) # the share parameter of consumers
labor.supply &lt;- c(100, 0, 0) # the labor supply of lifetime

f &lt;- function() {
  names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:np))
  names.agent &lt;- c(paste0("firm", 1:np), paste0("consumer", 1:np))

  index.comm &lt;- c(1:np, 1:2)

  # the exogenous supply matrix.
  S0Exg &lt;- matrix(NA, 2 * np, 2 * np, dimnames = list(names.commodity, names.agent))
  for (k in 1:np) {
    S0Exg[paste0("lab", index.comm[k:(k + 2)]), paste0("consumer", k)] &lt;-
      labor.supply * (1 + gr.laborer)^(k - 1)
  }
  S0Exg[paste0("lab", 1:2), paste0("consumer", np)] &lt;-
    S0Exg[paste0("lab", 1:2), paste0("consumer", np)] * df
  S0Exg[paste0("lab", 1), paste0("consumer", np - 1)] &lt;-
    S0Exg[paste0("lab", 1), paste0("consumer", np - 1)] * df

  B &lt;- matrix(0, 2 * np, 2 * np, dimnames = list(names.commodity, names.agent))
  for (k in 1:np) {
    B[paste0("prod", index.comm[k + 1]), paste0("firm", k)] &lt;- 1
  }
  B["prod1", paste0("firm", np)] &lt;- df


  dstl.firm &lt;- list()
  for (k in 1:np) {
    dstl.firm[[k]] &lt;- node_new(
      "prod",
      type = "CD", alpha = alpha.firm,
      beta = c(beta.prod.firm, 1 - beta.prod.firm),
      paste0("prod", k), paste0("lab", k)
    )
  }

  dstl.consumer &lt;- list()
  for (k in 1:np) {
    dstl.consumer[[k]] &lt;- node_new(
      "util",
      type = "CD", alpha = 1,
      beta = beta.consumer,
      paste0("prod", k:(k + 2))
    )
  }

  node_set(dstl.consumer[[np - 1]], paste0("prod", np + 1),
           type = "Leontief", a = df,
           "prod1"
  )

  node_set(dstl.consumer[[np]], paste0("prod", np + 1),
           type = "Leontief", a = df,
           "prod1"
  )
  node_set(dstl.consumer[[np]], paste0("prod", np + 2),
           type = "Leontief", a = df,
           "prod2"
  )

  ge &lt;- sdm2(
    A = c(dstl.firm, dstl.consumer),
    B = B,
    S0Exg = S0Exg,
    names.commodity = names.commodity,
    names.agent = names.agent,
    numeraire = "lab1"
  )
  invisible(ge)
}

ge &lt;- f()
growth_rate(ge$p[1:np]) + 1 # 1 / (1 + gr.laborer)
growth_rate(ge$p[(np + 1):(2 * np)]) + 1 # 1 / (1 + gr.laborer)
ge$D
ge$DV

##
beta.consumer &lt;- c(1 / 3, 1 / 3, 1 / 3) # the share parameter of consumers
labor.supply &lt;- c(50, 50, 0) # the labor supply of lifetime
ge &lt;- f()
ge$D
ge$DV

##
gr.laborer &lt;- 0
df &lt;- (1 + gr.laborer)^-np
beta.prod.firm &lt;- 0.5
ge &lt;- f()
ge$z

</code></pre>

<hr>
<h2 id='gemOLGF_OneFirm'>Overlapping Generations Financial Sequential Models with One Firm</h2><span id='topic+gemOLGF_OneFirm'></span>

<h3>Description</h3>

<p>Some examples of overlapping generations financial sequential models with one firm.
</p>
<p>When there is a population growth, we will take the security-split assumption (see <code><a href="#topic+gemOLGF_PureExchange">gemOLGF_PureExchange</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemOLGF_OneFirm(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemOLGF_OneFirm_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Samuelson, P. A. (1958) An Exact Consumption-Loan Model of Interest with or without the Social Contrivance of Money. Journal of Political Economy, vol. 66(6): 467-482.
</p>
<p>de la Croix, David and Philippe Michel (2002, ISBN: 9780521001151) A Theory of Economic Growth: Dynamics and Policy in Overlapping Generations. Cambridge University Press.
</p>


<h3>See Also</h3>


<p><code><a href="#topic+gemOLG_PureExchange">gemOLG_PureExchange</a></code>
<code><a href="#topic+gemOLG_TimeCircle">gemOLG_TimeCircle</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an OLGF economy with a firm and two-period-lived consumers
beta.firm &lt;- c(1 / 3, 2 / 3)
# the population growth rate
GRExg &lt;- 0.03
saving.rate &lt;- 0.5
ratio.saving.consumption &lt;- saving.rate / (1 - saving.rate)

dst.firm &lt;- node_new(
  "prod",
  type = "CD", alpha = 5,
  beta = beta.firm,
  "lab", "prod"
)

dst.age1 &lt;- node_new(
  "util",
  type = "FIN",
  rate = c(1, ratio.saving.consumption),
  "prod", "secy" # security, the financial instrument
)

dst.age2 &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "prod"
)

ge &lt;- sdm2(
  A = list(
    dst.firm, dst.age1, dst.age2
  ),
  B = matrix(c(
    1, 0, 0,
    0, 0, 0,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 1, NA,
    NA, NA, 1
  ), 3, 3, TRUE),
  names.commodity = c("prod", "lab", "secy"),
  names.agent = c("firm", "age1", "age2"),
  numeraire = "lab",
  GRExg = GRExg,
  maxIteration = 1,
  ts = TRUE
)

ge$p
matplot(ge$ts.p, type = "l")
matplot(growth_rate(ge$ts.z), type = "l") # GRExg
addmargins(ge$D, 2) # the demand matrix of the current period
addmargins(ge$S, 2) # the supply matrix of the current period
addmargins(ge$S * (1 + GRExg), 2) # the supply matrix of the next period
addmargins(ge$DV)
addmargins(ge$SV)

## Suppose consumers consume product and labor (i.e. service) and
## age1 and age2 may have different instantaneous utility functions.
dst.age1 &lt;- node_new(
  "util",
  type = "FIN",
  rate = c(1, ratio.saving.consumption),
  "cc1", "secy" # security, the financial instrument
)
node_set(dst.age1,  "cc1",
  type = "Leontief",
  a = c(0.5, 0.5),
  "prod", "lab"
)
node_plot(dst.age1)

dst.age2 &lt;- node_new("util",
  type = "Leontief",
  a = c(0.2, 0.8),
  "prod", "lab"
)

ge &lt;- sdm2(
  A = list(
    dst.firm, dst.age1, dst.age2
  ),
  B = matrix(c(
    1, 0, 0,
    0, 0, 0,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 1, NA,
    NA, NA, 1
  ), 3, 3, TRUE),
  names.commodity = c("prod", "lab", "secy"),
  names.agent = c("firm", "age1", "age2"),
  numeraire = "lab",
  GRExg = GRExg,
  priceAdjustmentVelocity = 0.05
)

ge$p
addmargins(ge$D, 2)
addmargins(ge$S, 2)
addmargins(ge$DV)
addmargins(ge$SV)

## Aggregate the above consumers into one infinite-lived consumer,
## who always spends the same amount on cc1 and cc2.
dst.consumer &lt;- node_new("util",
                         type = "CD", alpha = 1,
                         beta = c(0.5, 0.5),
                         "cc1", "cc2"
)
node_set(dst.consumer, "cc1",
         type = "Leontief",
         a = c(0.5, 0.5),
         "prod", "lab"
)
node_set(dst.consumer,  "cc2",
         type = "Leontief",
         a = c(0.2, 0.8),
         "prod", "lab"
)

ge &lt;- sdm2(
  A = list(
    dst.firm, dst.consumer
  ),
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 1
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "lab",
  GRExg = GRExg,
  priceAdjustmentVelocity = 0.05
)

ge$p
addmargins(ge$D, 2)
addmargins(ge$S, 2)
addmargins(ge$DV)
addmargins(ge$SV)

#### an OLGF economy with a firm and two-period-lived consumers
## Suppose each consumer has a Leontief-type utility function min(c1, c2/a).
beta.firm &lt;- c(1 / 3, 2 / 3)
# the population growth rate, the equilibrium interest rate and profit rate
GRExg &lt;- 0.03
rho &lt;- 1 / (1 + GRExg)
a &lt;- 0.9

dst.firm &lt;- node_new(
  "prod",
  type = "CD", alpha = 5,
  beta = beta.firm,
  "lab", "prod"
)

dst.age1 &lt;- node_new(
  "util",
  type = "FIN",
  rate = c(1, ratio.saving.consumption = a * rho),
  "prod", "secy" # security, the financial instrument
)

dst.age2 &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "prod"
)

ge &lt;- sdm2(
  A = list(
    dst.firm, dst.age1, dst.age2
  ),
  B = matrix(c(
    1, 0, 0,
    0, 0, 0,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 1, NA,
    NA, NA, 1
  ), 3, 3, TRUE),
  names.commodity = c("prod", "lab", "secy"),
  names.agent = c("firm", "age1", "age2"),
  numeraire = "lab",
  GRExg = GRExg,
  maxIteration = 1,
  ts = TRUE
)

ge$p
matplot(ge$ts.p, type = "l")
matplot(growth_rate(ge$ts.z), type = "l") # GRExg
addmargins(ge$D, 2)
addmargins(ge$S, 2)
addmargins(ge$DV)
addmargins(ge$SV)

## the corresponding time-cycle model
n &lt;- 5 # the number of periods, consumers and firms.
S &lt;- matrix(NA, 2 * n, 2 * n)

S.lab.consumer &lt;- diag((1 + GRExg)^(0:(n - 1)), n)
S[(n + 1):(2 * n), (n + 1):(2 * n)] &lt;- S.lab.consumer

B &lt;- matrix(0, 2 * n, 2 * n)
B[1:n, 1:n] &lt;- diag(n)[, c(2:n, 1)]
B[1, n] &lt;- rho^n

dstl.firm &lt;- list()
for (k in 1:n) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "CD", alpha = 5,
    beta = beta.firm,
    paste0("lab", k), paste0("prod", k)
  )
}

dstl.consumer &lt;- list()
for (k in 1:(n - 1)) {
  dstl.consumer[[k]] &lt;- node_new(
    "util",
    type = "FIN",
    rate = c(1, ratio.saving.consumption = a * rho),
    paste0("prod", k), paste0("prod", k + 1)
  )
}

dstl.consumer[[n]] &lt;- node_new(
  "util",
  type = "FIN",
  rate = c(1, ratio.saving.consumption = a * rho),
  paste0("prod", n), "cc1"
)
node_set(dstl.consumer[[n]], "cc1",
         type = "Leontief", a = rho^n, # a discounting factor
         "prod1"
)

ge2 &lt;- sdm2(
  A = c(dstl.firm, dstl.consumer),
  B = B,
  S0Exg = S,
  names.commodity = c(paste0("prod", 1:n), paste0("lab", 1:n)),
  names.agent = c(paste0("firm", 1:n), paste0("consumer", 1:n)),
  numeraire = "lab1",
  policy = makePolicyMeanValue(30),
  maxIteration = 1,
  numberOfPeriods = 600,
  ts = TRUE
)

ge2$p
growth_rate(ge2$p[1:n]) + 1 # rho
growth_rate(ge2$p[(n + 1):(2 * n)]) + 1 # rho
ge2$D


</code></pre>

<hr>
<h2 id='gemOLGF_PureExchange'>Overlapping Generations Financial Sequential Models for Pure Exchange Economies</h2><span id='topic+gemOLGF_PureExchange'></span>

<h3>Description</h3>

<p>Some examples of overlapping generations sequential models with financial instrument for pure exchange economies.
</p>
<p>In these examples, there is a financial instrument (namely security) which serves as saving means and can be regarded as money, the shares of a firm, etc.
Consumers use this security for saving, and this is the only use of the security.
As Samuelson (1958) wrote, society by using money (i.e. security) will go from the non-optimal configuration
to the optimal configuration.
</p>
<p>Here financial demand structure trees are used, which contain financial nodes.
A financial demand structure tree reflects the demand structure of a consumer
who has a demand for financial instruments.
Although CD-type nodes can be used instead of financial-type nodes in the consumer's demand structure tree,
the use of financial-type nodes will make the demand structure tree easier to understand.
</p>
<p>When there is a population growth, we will take the security-split assumption.
That is, assume that in each period the security will be split just like share split,
and the growth rate of the quantity of the security is equal to the growth rate of the population.
Obviously, this assumption will not affect the calculation results essentially.
And with this assumption, the equilibrium price vector can keep constant in each period, and
the nominal rates of profit and interest will equal the real rates of profit and interest (i.e. the population growth rate).
In contrast, in the time circle model the nominal rates of profit and interest equal zero and the real rates of profit and interest
equal the population growth rate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemOLGF_PureExchange(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemOLGF_PureExchange_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>As can be seen from the first example below, in a pure exchange economy with two-period-lived consumers,
if age1 (i.e. young) has one unit of labor and age2 (i.e. old) does not,
then the optimal allocation can be obtained by introducing securities.
Here it is assumed that each consumer consumes one unit of labor in total.
</p>
<p>However, if age2 (i.e. adult) has one unit of labor and age1 (i.e. child) does not,
we cannot get the optimal allocation by introducing securities.
So we need the family system.
</p>


<h3>See Also</h3>


<p><code><a href="#topic+gemOLG_PureExchange">gemOLG_PureExchange</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an OLGF pure exchange economy with two-period-lived consumers.
## Suppose each consumer has one unit of labor in her first period
## and she has a C-D intertemporal utility function
## (1 - beta) * log(c1) + beta * log(c2) and a constant saving rate beta.
beta &lt;- 0.5
ratio.saving.consumption &lt;- beta / (1 - beta)

dst.age1 &lt;- node_new(
  "util",
  type = "FIN",
  rate = c(1, ratio.saving.consumption),
  "lab", "secy" # security, the financial instrument
)

dst.age2 &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "lab"
)

ge &lt;- sdm2(
  A = list(
    dst.age1, dst.age2
  ),
  B = matrix(0, 2, 2, TRUE),
  S0Exg = matrix(c(
    100, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("lab", "secy"),
  names.agent = c("age1", "age2"),
  numeraire = "secy"
)

ge$p
ge$D
ge$DV
ge$S

#### the population growth and demographic dividend.
## Suppose each consumer has a SCES intertemporal utility function.
gr.lab &lt;- 0.03 # the growth rate of population and labor supply

# share parameters of the SCES function
beta2 &lt;- 0.4
beta1 &lt;- 1 - beta2
es &lt;- 0.5 # the elasticity of substitution in the SCES function

dst.age1 &lt;- node_new(
  "util",
  type = "FIN",
  rate = c(1, ratio.saving.consumption = 0.1),
  "lab", "secy", # security, the financial instrument
  p.lab.last = 1,
  p.lab.ratio.predicted.last = 1,
  ts.saving.rate = numeric(0)
)

dst.age2 &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "lab"
)

ge &lt;- sdm2(
  A = list(
    dst.age1, dst.age2
  ),
  B = matrix(0, 2, 2, TRUE),
  S0Exg = matrix(c(
    100, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("lab", "secy"),
  names.agent = c("age1", "age2"),
  numeraire = "secy",
  policy = list(function(time, A, state) {
    state$S[1, 1] &lt;- 100 * (1 + gr.lab)^time
    p.lab.current &lt;- state$p[1] / state$p[2]

    lambda &lt;- 0.6
    p.lab.ratio.predicted &lt;- p.lab.current / A[[1]]$p.lab.last * lambda +
      A[[1]]$p.lab.ratio.predicted.last * (1 - lambda)
    A[[1]]$p.lab.last &lt;- p.lab.current
    A[[1]]$p.lab.ratio.predicted.last &lt;- p.lab.ratio.predicted

    ratio.saving.consumption &lt;- beta2 / beta1 * (p.lab.ratio.predicted)^(1 - es)
    A[[1]]$rate &lt;- c(1, ratio.saving.consumption)
    A[[1]]$ts.saving.rate &lt;- c(A[[1]]$ts.saving.rate, ratio.saving.consumption /
                                 (1 + ratio.saving.consumption))

    state
  }, policyMarketClearingPrice),
  maxIteration = 1,
  numberOfPeriods = 50,
  ts = TRUE
)

matplot(growth_rate(ge$ts.p), type = "o", pch = 20)
matplot(growth_rate(ge$ts.z), type = "o", pch = 20)
ge$p
dst.age1$rate[2] # beta2 / beta1 * (1 + gr.lab)^(es - 1)
dst.age1$p.lab.ratio.predicted.last

plot(dst.age1$ts.saving.rate, type = "o", pch = 20)
tail(dst.age1$ts.saving.rate,1) # beta2 / (beta2 + beta1 * (1 + gr.lab)^(1 - es))

#### the basic overlapping generations (inefficient) exchange model.
## Here the lab2 is regarded as a financial instrument (saving instrument).
## See gemOLG_PureExchange.
dst.age1 &lt;- node_new(
  "util",
  type = "FIN",
  rate = c(1, ratio.totalSaving.consumption = 2),
  "lab1", "lab2"
)

dst.age2 &lt;- node_new(
  "util",
  type = "FIN",
  rate = c(1, ratio.saving.consumption = 1),
  "lab1", "lab2"
)

ge &lt;- sdm2(
  A = list(dst.age1, dst.age2),
  B = matrix(0, 2, 2),
  S0Exg = matrix(c(
    50, 50,
    50, 0
  ), 2, 2, TRUE),
  names.commodity = c("lab1", "lab2"),
  names.agent = c("age1", "age2"),
  numeraire = "lab1",
  policy = function(time, state) {
    pension &lt;- (state$last.A[, 2] * state$last.z[2])[2]
    if (time &gt; 1) state$S[1, 2] &lt;- 1 - pension
    state
  }
)

ge$p
ge$S
ge$D
ge$DV

#### the basic financial overlapping generations exchange model (see Samuelson, 1958).
## Suppose each consumer has a utility function log(c1) + log(c2) + log(c3).
GRExg &lt;- 0.03 # the population growth rate
rho &lt;- 1 / (1 + GRExg)

dst.age1 &lt;- node_new(
  "util",
  type = "FIN",
  rate = {
    saving.rate &lt;- (2 - rho) / 3
    c(1, ratio.saving.consumption = saving.rate / (1 - saving.rate))
  },
  "lab", "secy"
)

dst.age2 &lt;- node_new(
  "util",
  type = "FIN",
  rate = c(1, ratio.saving.consumption = 1),
  "lab", "secy"
)

dst.age3 &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "lab"
)

ge &lt;- sdm2(
  A = list(dst.age1, dst.age2, dst.age3),
  B = matrix(0, 2, 3),
  S0Exg = matrix(c(
    1 + GRExg, 1, 0,
    0, 0.5, 0.5
  ), 2, 3, TRUE),
  names.commodity = c("lab", "secy"),
  names.agent = c("age1", "age2", "age3"),
  numeraire = "lab",
  policy = function(time, state) {
    # Assume that unsold security will be void.
    last.Demand &lt;- state$last.A %*% dg(state$last.z)
    secy.holding &lt;- prop.table(last.Demand[2, ])
    if (time &gt; 1) {
      state$S[2, 2:3] &lt;- secy.holding[1:2]
    }
    state
  }
)

ge$p
ge$S
ge$D

#### a pure exchange economy with three-period-lived consumers.
## Suppose each consumer has a Leontief-type utility function min(c1, c2, c3).
GRExg &lt;- 0.03 # the population growth rate
igr &lt;- 1 + GRExg

dst.age1 &lt;- node_new(
  "util",
  type = "FIN",
  rate = {
    saving.rate &lt;- 1 / (1 + igr + igr^2)
    c(1, ratio.saving.consumption = saving.rate / (1 - saving.rate))
  },
  "lab", "secy"
)

dst.age2 &lt;- node_new(
  "util",
  type = "FIN",
  rate = {
    saving.rate &lt;- 1 / (1 + igr)
    c(1, ratio.saving.consumption = saving.rate / (1 - saving.rate))
  },
  "lab", "secy"
)

dst.age3 &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "lab"
)

ge &lt;- sdm2(
  A = list(dst.age1, dst.age2, dst.age3),
  B = matrix(0, 2, 3),
  S0Exg = matrix(c(
    1 + GRExg, 1, 0,
    0, 0.5, 0.5
  ), 2, 3, TRUE),
  names.commodity = c("lab", "secy"),
  names.agent = c("age1", "age2", "age3"),
  numeraire = "lab",
  policy = function(time, state) {
    # Assume that unsold security will be void.
    last.Demand &lt;- state$last.A %*% dg(state$last.z)
    secy.holding &lt;- prop.table(last.Demand[2, ])
    if (time &gt; 1) {
      state$S[2, 2:3] &lt;- secy.holding[1:2]
    }
    state
  }
)

ge$p
ge$S
ge$D

## Assume that the unsold security of age3 will be void.
## The calculation results are the same as above.
ge &lt;- sdm2(
  A = list(dst.age1, dst.age2, dst.age3),
  B = matrix(0, 2, 3),
  S0Exg = matrix(c(
    1 + GRExg, 1, 0,
    0, 0.5, 0.5
  ), 2, 3, TRUE),
  names.commodity = c("lab", "secy"),
  names.agent = c("age1", "age2", "age3"),
  numeraire = "lab",
  policy = function(time, state, state.history) {
    secy.unsold &lt;- state.history$S[2, , time - 1] * (1 - state.history$q[time - 1, 2])
    last.Demand &lt;- state$last.A %*% dg(state$last.z)
    secy.purchased &lt;- last.Demand[2, ]

    if (time &gt; 1) {
      # Assume that the unsold security of age3 will be void.
      state$S[2, 2:3] &lt;- prop.table(secy.purchased[1:2] + secy.unsold[1:2])
    }
    state
  },
  maxIteration = 1
)

ge$p
ge$S
ge$D


</code></pre>

<hr>
<h2 id='gemOLGF_TwoFirms'>Overlapping Generations Financial Sequential Models with Two Firms</h2><span id='topic+gemOLGF_TwoFirms'></span>

<h3>Description</h3>

<p>Some examples of overlapping generations financial sequential models with two firms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemOLGF_TwoFirms(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemOLGF_TwoFirms_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>See Also</h3>


<p><code><a href="#topic+gemOLGF_PureExchange">gemOLGF_PureExchange</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an example with two-period-lived consumers
dst.firm.corn &lt;- node_new(
  "corn",
  type = "CD", alpha = 5,
  beta = c(1 / 2, 1 / 2),
  "iron", "lab"
)

dst.firm.iron &lt;- node_new(
  "iron",
  type = "CD", alpha = 5,
  beta = c(1 / 2, 1 / 2),
  "iron", "lab"
)

dst.age1 &lt;- node_new(
  "util",
  type = "FIN",
  rate = c(1, ratio.saving.consumption = 1),
  "corn", "secy" # security, the financial instrument
)

dst.age2 &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "corn"
)

ge &lt;- sdm2(
  A = list(
    dst.firm.corn, dst.firm.iron, dst.age1, dst.age2
  ),
  B = matrix(c(
    1, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
  ), 4, 4, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA,
    NA, NA, NA, NA,
    NA, NA, 1, NA,
    NA, NA, NA, 1
  ), 4, 4, TRUE),
  names.commodity = c("corn", "iron", "lab", "secy"),
  names.agent = c("firm.corn", "firm.iron", "age1", "age2"),
  numeraire = "lab"
)

ge$p
ge$D
ge$DV
ge$S

## an example with three-period-lived consumers
dst.age1$rate &lt;- c(1, ratio.saving.consumption = 1 / 2)

dst.age3 &lt;- Clone(dst.age2)

dst.age2 &lt;- Clone(dst.age1)
dst.age2$rate &lt;- c(1, ratio.saving.consumption = 1)

ge &lt;- sdm2(
  A = list(
    dst.firm.corn, dst.firm.iron, dst.age1, dst.age2, dst.age3
  ),
  B = matrix(c(
    1, 0, 0, 0, 0,
    0, 1, 0, 0, 0,
    0, 0, 0, 0, 0,
    0, 0, 0, 0, 0
  ), 4, 5, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA,
    NA, NA, 1, 1, NA,
    NA, NA, NA, 1, 1
  ), 4, 5, TRUE),
  names.commodity = c("corn", "iron", "lab", "secy"),
  names.agent = c("firm.corn", "firm.iron", "age1", "age2", "age3"),
  numeraire = "lab",
  policy = function(time, state) {
    # Assume that unsold security will be void.
    last.Demand &lt;- state$last.A %*% dg(state$last.z)
    secy.holding &lt;- prop.table(last.Demand[4, ])
    if (time &gt; 1) {
      state$S[4, 4:5] &lt;- secy.holding[3:4]
    }
    state
  }
)

ge$p
ge$D
ge$DV
ge$S

</code></pre>

<hr>
<h2 id='gemOpenEconomy_4_4'>A 4-by-4 Open Economy with Bond</h2><span id='topic+gemOpenEconomy_4_4'></span>

<h3>Description</h3>

<p>Some examples of a 4-by-4 open economy with bond.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemOpenEconomy_4_4(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemOpenEconomy_4_4_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an open economy with foreign bond (bond.ROW)
dst.firm &lt;- node_new(
  "output",
  type = "SCES", alpha = 1, beta = c(0.5, 0.5), es = 1,
  "prod.CHN", "lab.CHN"
)

dst.consumer &lt;- node_new(
  "util",
  type = "FIN", beta = c(0.8, 0.2),
  "cc1", "bond.ROW"
)
node_set(dst.consumer, "cc1",
         type = "SCES", alpha = 1, beta = c(0.5, 0.5), es = 1,
         "prod.CHN", "prod.ROW"
)

dst.FT &lt;- node_new(
  "prod.ROW",
  type = "SCES", alpha = 1, beta = c(2/3, 1/3), es = 1,
  "prod.CHN", "lab.CHN"
)

dst.ROW &lt;- node_new(
  "util",
  type = "SCES", alpha = 1, beta = c(2/3, 1/3), es = 1,
  "prod.CHN", "lab.CHN"
)

ge.open &lt;- sdm2(
  A = list(dst.firm, dst.consumer, dst.FT, dst.ROW),
  B = matrix(c(
    1, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 0
  ), 4, 4, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA,
    NA, 300, NA, NA,
    NA, NA, NA, NA,
    NA, NA, NA, 60
  ), 4, 4, TRUE),
  names.commodity = c("prod.CHN", "lab.CHN", "prod.ROW", "bond.ROW"),
  names.agent = c("firm", "consumer", "FT", "ROW"),
  numeraire = "lab.CHN"
)

ge.open$p
addmargins(ge.open$D, 2)
addmargins(ge.open$S, 2)

## a corresponding two-country model
dst.firm.CHN &lt;- node_new(
  "output",
  type = "SCES", alpha = 1, beta = c(0.5, 0.5), es = 1,
  "prod.CHN", "lab.CHN"
)

dst.consumer.CHN &lt;- node_new(
  "util",
  type = "FIN", beta = c(0.8, 0.2),
  "cc1", "bond.ROW"
)
node_set(dst.consumer.CHN, "cc1",
         type = "SCES", alpha = 1, beta = c(0.5, 0.5), es = 1,
         "prod.CHN", "prod.ROW"
)

dst.firm.ROW &lt;- node_new(
  "prod.ROW",
  type = "SCES", alpha = 1, beta = c(0.25, 0.25, 0.5), es = 1,
  "prod.CHN", "prod.ROW", "lab.ROW"
)

dst.consumer.ROW &lt;- node_new(
  "util",
  type = "SCES", alpha = 1, beta = c(0.25, 0.25, 0.25, 0.25), es = 1,
  "prod.CHN", "prod.ROW", "lab.CHN", "lab.ROW"
)

ge.TC &lt;- sdm2(
  A = list(dst.firm.CHN, dst.consumer.CHN, dst.firm.ROW, dst.consumer.ROW),
  B = matrix(c(
    1, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 0,
    0, 0, 0, 0
  ), 5, 4, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA,
    NA, 300, NA, NA,
    NA, NA, NA, NA,
    NA, NA, NA, 180,
    NA, NA, NA, 60
  ), 5, 4, TRUE),
  names.commodity = c("prod.CHN", "lab.CHN", "prod.ROW", "lab.ROW", "bond.ROW"),
  names.agent = c("firm.CHN", "consumer.CHN", "firm.ROW", "consumer.ROW"),
  numeraire = "lab.CHN"
)

ge.TC$p
addmargins(ge.TC$D, 2)
addmargins(ge.TC$S, 2)

#### an open economy with domestic bond (bond.CHN)
dst.firm &lt;- node_new(
  "output",
  type = "CD", alpha = 5, beta = c(0.5, 0.5),
  "prod.CHN", "lab.CHN"
)

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = c(0.5, 0.5),
  "prod.CHN", "prod.ROW"
)

dst.FT &lt;- node_new(
  "prod.ROW",
  type = "Leontief", a = 2,
  "prod.CHN"
)

dst.ROW &lt;- node_new(
  "prod.ROW",
  type = "Leontief", a = 1,
  "bond.CHN"
)

ge &lt;- sdm2(
  A = list(dst.firm, dst.consumer, dst.FT, dst.ROW),
  B = matrix(c(
    1, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 1, 1,
    0, 0, 0, 0
  ), 4, 4, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA,
    NA, 1, NA, NA,
    NA, NA, NA, NA,
    NA, 0.2, NA, NA
  ), 4, 4, TRUE),
  names.commodity = c("prod.CHN", "lab.CHN", "prod.ROW", "bond.CHN"),
  names.agent = c("firm", "consumer", "FT", "ROW"),
  numeraire = "lab.CHN"
)

ge$p
addmargins(ge$D, 2)
addmargins(ge$S, 2)

</code></pre>

<hr>
<h2 id='gemOpenEconomy_6_6'>A 6-by-6 Open Economy with Bond</h2><span id='topic+gemOpenEconomy_6_6'></span>

<h3>Description</h3>

<p>Some examples of a 6-by-6 open economy with bond.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemOpenEconomy_6_6(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemOpenEconomy_6_6_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an open economy with foreign bond (bond.ROW)
dst.firm1 &lt;- node_new(
  "prod1.CHN",
  type = "SCES", es=1, alpha = 1, beta = c(0.4, 0.4, 0.2),
  "prod2.CHN", "prod2.ROW", "lab.CHN"
)

dst.firm2 &lt;- node_new(
  "prod2.CHN",
  type = "SCES", es=1, alpha = 1, beta = c(0.4, 0.4, 0.2),
  "prod2.CHN", "prod2.ROW", "lab.CHN"
)

dst.consumer &lt;- node_new(
  "util",
  type = "FIN", beta = c(0.8, 0.2),
  "cc1", "bond.ROW"
)
node_set(dst.consumer, "cc1",
         type = "SCES", es=1, alpha = 1, beta = c(0.5, 0.5),
         "prod1.CHN", "prod1.ROW"
)

dst.FT1 &lt;- node_new(
  "prod1.ROW",
  type = "SCES", es=1, alpha = 1, beta = c(0.5, 0.5),
  "prod1.CHN", "prod2.CHN"
)

dst.FT2 &lt;- node_new(
  "prod2.ROW",
  type = "SCES", es=1, alpha = 1, beta = c(0.5, 0.5),
  "prod1.CHN", "prod2.CHN"
)

dst.Bond &lt;- node_new(
  "util",
  type = "SCES", es=1, alpha = 1, beta = c(0.5, 0.5),
  "prod1.CHN", "prod2.CHN"
)

ge &lt;- sdm2(
  A = list(dst.firm1, dst.firm2, dst.consumer, dst.FT1, dst.FT2, dst.Bond),
  B = matrix(c(
    1, 0, 0, 0, 0, 0,
    0, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 0, 0,
    0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 0
  ), 6, 6, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA, NA,
    NA, NA, 100, NA, NA, NA,
    NA, NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA, 20
  ), 6, 6, TRUE),
  names.commodity = c(
    "prod1.CHN", "prod2.CHN", "lab.CHN",
    "prod1.ROW", "prod2.ROW", "bond.ROW"
  ),
  names.agent = c("firm1", "firm2", "consumer", "FT1", "FT2", "Bond"),
  numeraire = "lab.CHN"
)

ge$D
ge$p
ge$z

## Suppose the domestic consumer owns some foreign product by borrowing.
ge &lt;- sdm2(
  A = list(dst.firm1, dst.firm2, dst.consumer, dst.FT1, dst.FT2, dst.Bond),
  B = matrix(c(
    1, 0, 0, 0, 0, 0,
    0, 1, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0,
    0, 0, 0, 1, 0, 0,
    0, 0, 0, 0, 1, 0,
    0, 0, 0, 0, 0, 0
  ), 6, 6, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA, NA,
    NA, NA, 100, NA, NA, NA,
    NA, NA, 10, NA, NA, NA,
    NA, NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA, 20
  ), 6, 6, TRUE),
  names.commodity = c(
    "prod1.CHN", "prod2.CHN", "lab.CHN",
    "prod1.ROW", "prod2.ROW", "bond.ROW"
  ),
  names.agent = c("firm1", "firm2", "consumer", "FT1", "FT2", "Bond"),
  numeraire = "lab.CHN"
)

ge$D
ge$p
ge$z

</code></pre>

<hr>
<h2 id='gemPersistentTechnologicalProgress'>Some Examples of Spot Market Clearing Paths with Persistent Technological Progress</h2><span id='topic+gemPersistentTechnologicalProgress'></span>

<h3>Description</h3>

<p>Some examples of spot market clearing paths (alias instantaneous equilibrium paths) with persistent technological progress.
From the fifth period, technological progress occurs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemPersistentTechnologicalProgress(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemPersistentTechnologicalProgress_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>See Also</h3>


<p><code><a href="#topic+gemCapitalAccumulation">gemCapitalAccumulation</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### a 2-by-2 example with labor-saving technological progress
tpr &lt;- 0.03 # technological progress rate

dst.firm &lt;- node_new(
  "prod",
  type = "SCES",
  es = 0.5, alpha = 1,
  beta = c(0.5, 0.5),
  "prod", "cc1"
)
node_set(dst.firm, "cc1",
         type = "Leontief", a = 1,
         "lab"
)

dst.consumer &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "prod"
)

dstl &lt;- list(dst.firm, dst.consumer)

ge &lt;- sdm2(
  A = dstl,
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "prod",
  ts = TRUE,
  policy = list(
    function(time, A) {
      if (time &gt;= 5) {
        node_set(A[[1]], "cc1",
                 a = (1 + tpr)^-(time - 4)
        )
      }
    },
    policyMarketClearingPrice
  ),
  numberOfPeriods = 40,
  maxIteration = 1,
  z0 = c(200, 100),
  p0 = c(1, 1)
)

matplot(growth_rate(ge$ts.z), type = "o", pch = 20)
matplot(growth_rate(ge$ts.p), type = "o", pch = 20)

#### a 3-by-3 example with labor-saving technological progress
tpr &lt;- 0.03 # technological progress rate

dst.manu &lt;- node_new("manu",
                     type = "SCES", es = 0.5, alpha = 1,
                     beta = c(0.6, 0.4),
                     "manu", "cc1"
)
node_set(dst.manu, "cc1",
         type = "Leontief", a = 1,
         "lab"
)

dst.serv &lt;- node_new("serv",
                     type = "SCES", es = 0.5, alpha = 1,
                     beta = c(0.4, 0.6),
                     "manu", "lab"
)

dst.consumer &lt;- node_new("util",
                         type = "SCES", es = 0.5, alpha = 1,
                         beta = c(0.4, 0.6),
                         "manu", "serv"
)

dstl &lt;- list(dst.manu, dst.serv, dst.consumer)

ge &lt;- sdm2(
  A = dstl,
  B = matrix(c(
    1, 0, 0,
    0, 1, 0,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = {
    S0Exg &lt;- matrix(NA, 3, 3)
    S0Exg[3, 3] &lt;- 100
    S0Exg
  },
  names.commodity = c("manu", "serv", "lab"),
  names.agent = c("manu", "serv", "consumer"),
  numeraire = c("manu"),
  ts = TRUE,
  policy = list(
    function(time, A) {
      if (time &gt;= 5) {
        node_set(A[[1]], "cc1",
                 a = (1 + tpr)^-(time - 4)
        )
      }
    },
    policyMarketClearingPrice
  ),
  numberOfPeriods = 40,
  maxIteration = 1,
  z0 = c(160, 60, 100),
  p0 = c(1, 1, 1)
)

matplot(ge$ts.z, type = "o", pch = 20)
matplot(growth_rate(ge$ts.z), type = "o", pch = 20)
matplot(growth_rate(ge$ts.p), type = "o", pch = 20)

#### a 3-by-3 example with labor-saving technological
#### progress and capital accumulation
dst.firm1 &lt;- node_new(
  "prod",
  type = "CD",
  alpha = 2, beta = c(0.5, 0.5),
  "cap", "cc1"
)
node_set(dst.firm1, "cc1",
         type="Leontief", a=1,
         "lab")

dst.consumer &lt;- dst.firm2 &lt;- node_new(
  "util",
  type = "Leontief",
  a= 1,
  "prod"
)

ge &lt;- sdm2(
  A = list(dst.firm1, dst.consumer, dst.firm2),
  B = matrix(c(
    1, 0, 0.5,
    0, 0, 1,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, NA, NA,
    NA, 100,NA
  ), 3, 3, TRUE),
  names.commodity = c("prod", "cap", "lab"),
  names.agent = c("firm1", "laborer","firm2"),
  numeraire = "prod",
  z0=c(400,200,400),
  policy = list(
    function(time, A) {
      if (time &gt;= 5) {
        node_set(A[[1]],"cc1", a = (1 + 0.03)^-(time - 4))
      }
    },
    policyMarketClearingPrice
  ),
  maxIteration = 1,
  numberOfPeriods = 30,
  ts=TRUE
)

matplot(growth_rate(ge$ts.z), type="l")

</code></pre>

<hr>
<h2 id='gemPureExchange'>Some Simple Pure Exchange Equilibrium Models</h2><span id='topic+gemPureExchange'></span>

<h3>Description</h3>

<p>Some simple pure exchange general equilibrium models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemPureExchange(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemPureExchange_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.consumer1 &lt;- dst.consumer2 &lt;- node_new("util",
  type = "CD", alpha = 1, beta = c(0.5, 0.25, 0.25),
  "payoff1", "payoff2", "payoff3"
)

ge &lt;- sdm2(
  A = list(dst.consumer1, dst.consumer2),
  B = matrix(0, 3, 2),
  S0Exg = matrix(c(
    1, 1,
    0, 2,
    2, 2
  ), 3, 2, TRUE),
  names.commodity = c("payoff1", "payoff2", "payoff3"),
  names.agent = c("consumer1", "consumer2"),
  numeraire = "payoff1"
)

ge$p
ge$D

##
dst.consumer2 &lt;- node_new("util",
  type = "CD", alpha = 1, beta = c(0.5, 0.1, 0.4),
  "payoff1", "payoff2", "payoff3"
)

ge &lt;- sdm2(
  A = list(dst.consumer1, dst.consumer2),
  B = matrix(0, 3, 2),
  S0Exg = matrix(c(
    1, 1,
    0, 2,
    2, 2
  ), 3, 2, TRUE),
  names.commodity = c("payoff1", "payoff2", "payoff3"),
  names.agent = c("consumer1", "consumer2"),
  numeraire = "payoff1"
)

ge$p
ge$D

####
dst.consumer1 &lt;- node_new("util",
  type = "CD", alpha = 1,
  beta = c(0.5, 0.5),
  "cc1", "cc2"
)
node_set(dst.consumer1, "cc2",
  type = "CD", alpha = 1,
  beta = c(0.2, 0.8),
  "cc2.1", "cc2.2"
)
node_set(dst.consumer1, "cc1",
  type = "Leontief",
  a = c(0.5, 0.5),
  "corn1", "iron1"
)

node_set(dst.consumer1, "cc2.1",
  type = "Leontief", a = c(0.5, 0.5),
  "corn2.1", "iron2.1"
)
node_set(dst.consumer1, "cc2.2",
  type = "Leontief", a = c(0.5, 0.5),
  "corn2.2", "iron2.2"
)

dst.consumer2 &lt;- node_new("util",
  type = "CD", alpha = 1,
  beta = prop.table(c(
    0.5 * c(1, 1),
    0.5 * 0.2 * c(1, 1), 0.5 * 0.8 * c(1, 1)
  )),
  "corn1", "iron1", "corn2.1",
  "iron2.1", "corn2.2", "iron2.2"
)

node_plot(dst.consumer1, TRUE)

ge &lt;- sdm2(
  A = list(dst.consumer1, dst.consumer2),
  B = matrix(0, 6, 2),
  S0Exg = matrix(c(
    2, 2,
    2, 2,
    3, 2,
    1, 2,
    1, 2,
    3, 2
  ), 6, 2, TRUE),
  names.commodity = c(
    "corn1", "iron1", "corn2.1",
    "iron2.1", "corn2.2", "iron2.2"
  ),
  names.agent = c("consumer1", "consumer2"),
  numeraire = "corn1"
)

ge$D
ge$DV

</code></pre>

<hr>
<h2 id='gemQuasilinearPureExchange_2_2'>A Pure Exchange Economy with a Quasilinear Utility Function</h2><span id='topic+gemQuasilinearPureExchange_2_2'></span>

<h3>Description</h3>

<p>An example of a pure exchange economy with a quasilinear utility function (Karaivanov, see the reference).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemQuasilinearPureExchange_2_2(
  A,
  Endowment = matrix(c(3, 4, 7, 0), 2, 2, TRUE),
  policy = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemQuasilinearPureExchange_2_2_+3A_a">A</code></td>
<td>
<p>a demand structure tree list, a demand coefficient 2-by-2 matrix (alias demand structure matrix)
or a function A(state) which returns a 2-by-2 matrix (see <code><a href="#topic+sdm2">sdm2</a></code>).</p>
</td></tr>
<tr><td><code id="gemQuasilinearPureExchange_2_2_+3A_endowment">Endowment</code></td>
<td>
<p>a 2-by-2 matrix.</p>
</td></tr>
<tr><td><code id="gemQuasilinearPureExchange_2_2_+3A_policy">policy</code></td>
<td>
<p>a policy function (see <code><a href="#topic+sdm2">sdm2</a></code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose there are only two goods (bananas and fish) and 2 consumers (Annie and Ben) in an exchange economy.
Annie has a utility function x_1^(1/3) * x_2^(2/3) where x_1 is the amount of fish she eats and x_2 is the amount of
bananas she eats.
Annie has an endowment of 3 kilos of fish and 7 bananas.
Ben has a utility function x_1 + 1.5 * log(x_2) and endowments of 4 kilos of fish and 0 bananas.
Assume the price of bananas is 1.
See the reference for more details.
</p>


<h3>Value</h3>

<p>A general equilibrium.
</p>


<h3>References</h3>

<p>http://www.sfu.ca/~akaraiva/CE_example.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
demand_consumer2 &lt;- function(w, p) {
  QL_demand(w = w, p = p, alpha = 1.5, type = "log")
}

A &lt;- function(state) {
  a1 &lt;- CD_A(1, rbind(1 / 3, 2 / 3), state$p)
  a2 &lt;- demand_consumer2(state$w[2], state$p)
  cbind(a1, a2)
}

ge.mat &lt;- gemQuasilinearPureExchange_2_2(A = A)
ge.mat

## Use a dstl and a policy function to compute the general equilibrium above.
dst.consumer1 &lt;- node_new("util",
                          type = "CD", alpha = 1, beta = c(1 / 3, 2 / 3),
                          "fish", "banana"
)
dst.consumer2 &lt;- node_new("util",
                          type = "Leontief", a = c(1, 1),
                          "fish", "banana"
)

dstl &lt;- list(dst.consumer1, dst.consumer2)

policy.quasilinear &lt;- function(A, state) {
  wealth &lt;- t(state$p) %*% state$S
  A[[2]]$a &lt;- demand_consumer2(wealth[2], state$p)
}

ge.dstl &lt;- gemQuasilinearPureExchange_2_2(
  A = dstl,
  policy = policy.quasilinear
)
ge.dstl

#### Another example. Now Ben has a utility function x_1 + sqrt(x_2).
demand_consumer2 &lt;- function(w, p) {
  QL_demand(w = w, p = p, alpha = 1, beta = 0.5, type = "power")
}

A &lt;- function(state) {
  a1 &lt;- CD_A(1, rbind(1 / 3, 2 / 3), state$p)
  a2 &lt;- demand_consumer2(state$w[2], state$p)
  cbind(a1, a2)
}

ge.2_2 &lt;- gemQuasilinearPureExchange_2_2(A = A)
ge.2_2

## another computation method for the economy above
A &lt;- function(state) {
  a1 &lt;- CD_A(1, rbind(1 / 3, 2 / 3, 0, 0), state$p)
  a2 &lt;- c(0, 0, 1, 0)
  a3 &lt;- c(1, 0, 0, 0) # firm 1
  a4 &lt;- CD_A(1, rbind(0, 1 / 2, 0, 1 / 2), state$p) # firm 2
  cbind(a1, a2, a3, a4)
}

ge.4_4 &lt;- sdm2(
  A = A,
  B = {
    B &lt;- matrix(0, 4, 4)
    B[3, 3] &lt;- 1
    B[3, 4] &lt;- 1
    B
  },
  S0Exg = {
    S0Exg &lt;- matrix(NA, 4, 4)
    S0Exg[1:2, 1] &lt;- c(3, 7)
    S0Exg[1:2, 2] &lt;- c(4, 0)
    S0Exg[4, 1:2] &lt;- c(0, 1)
    S0Exg
  },
  names.commodity = c("fish", "banana", "util2", "land"),
  names.agent = c("Annie", "Ben", "firm1", "firm2"),
  numeraire = "banana"
)
ge.4_4

#### another example
n.fish.demander &lt;- 21
wealth &lt;- 20 # the wealth (or income) of each fish demander
fish.supply &lt;- 12
aggregare.demand &lt;- function(p) {
  result &lt;- 0
  for (alpha in seq(5, 15, length.out = n.fish.demander)) {
    result &lt;- result + QL_demand(w = wealth, p = p, alpha = alpha, beta = 1, type = "min")
  }
  result
}

ge &lt;- sdm2(
  A = function(state) {
    a1 &lt;- aggregare.demand(state$p / state$p[1])
    a2 &lt;- c(1, 0)
    cbind(a1, a2)
  },
  B = matrix(0, 2, 2),
  S0Exg = matrix(c(
    n.fish.demander * wealth, 0,
    0, fish.supply
  ), 2, 2, TRUE),
  names.commodity = c("gold", "fish"),
  names.agent = c("fish.demander", "fish.supplier"),
  numeraire = "gold",
  p0 = c(1, 1) # p0 = c(1, 9.25)
)

ge$p
ge$z
ge$D
ge$S

aggregare.demand.fish &lt;- c()
p2.set &lt;- seq(0, 16, 0.01)
for (p2 in p2.set) {
  aggregare.demand.fish &lt;- c(
    aggregare.demand.fish,
    aggregare.demand(c(1, p2))[2]
  )
}

plot(aggregare.demand.fish,
     p2.set,
     xlab = "demand for fish", ylab = "price of fish", pch = 20
)
abline(v = fish.supply)
grid()
points(ge$D[2, 1], ge$p[2], pch = 8, col = "red")

</code></pre>

<hr>
<h2 id='gemResearchDevelopmentIntensity'>Some Examples of Spot Market Clearing Paths Illustrating Research and Development Intensity</h2><span id='topic+gemResearchDevelopmentIntensity'></span>

<h3>Description</h3>

<p>Some examples of spot market clearing paths (alias instantaneous equilibrium paths) illustrating R&amp;D intensity.
R&amp;D intensity of a firm is the ratio of expenditures by the firm on R&amp;D to the firm's sales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemResearchDevelopmentIntensity(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemResearchDevelopmentIntensity_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first example contains two kinds of commodities (namely product and labor) and three economic agents
(namely a firm, a R&amp;D center of the firm and a laborer).
Since the R&amp;D center does not produce products, the R&amp;D center is regarded as a consumer-type agent in the model.
The utility level of the R&amp;D center (that is, the R&amp;D level) will affect the technological progress rate of the firm.
In the model, the firm allocates part of its output to the R&amp;D centers for sale according to a given R&amp;D intensity,
which is equivalent to allocating part of the firm's sales revenue to the R&amp;D center.
At first, the economy is set in steady-state equilibrium without R&amp;D activity. R&amp;D activities begin in the fifth period.
</p>


<h3>Value</h3>

<p>A spot market clearing path.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### a 2-by-3 example.
RDIntensity &lt;- 0.3
RDEffectivenessCoefficient &lt;- 0.001

dst.firm &lt;- node_new(
  "prod",
  type = "CD",
  alpha = 2, beta = c(0.5, 0.5),
  "prod", "cc1"
)
node_set(dst.firm, "cc1",
  type = "Leontief", a = 1,
  "lab"
)

dst.RDCenter &lt;- node_new(
  "util",
  type = "CD",
  alpha = 1, beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.laborer &lt;- node_new(
  "util",
  type = "Leontief",
  a = 1,
  "prod"
)

# a function calculating the rate of technological progress according to the level of R&amp;D.
f.TPR &lt;- function(RDLevel) RDEffectivenessCoefficient * RDLevel

f &lt;- function() {
  sdm2(
    A = list(dst.firm, dst.RDCenter, dst.laborer),
    B = matrix(c(
      1, 0, 0,
      0, 0, 0
    ), 2, 3, TRUE),
    S0Exg = matrix(c(
      NA, NA, NA,
      NA, NA, 100
    ), 2, 3, TRUE),
    names.commodity = c("prod", "lab"),
    names.agent = c("firm", "RDCenter", "laborer"),
    numeraire = "prod",
    z0 = c(200, 0, 100),
    policy = list(
      function(time, A, state) {
        if (time &gt;= 5) {
          state$S[1, 2] &lt;- state$S[1, 1] * RDIntensity
          state$S[1, 1] &lt;- state$S[1, 1] * (1 - RDIntensity)
          last.a &lt;- node_set(A[[1]], "cc1")$a
          last.RDLevel &lt;- state$last.z[2]
          technology.progress.rate &lt;- f.TPR(last.RDLevel)
          node_set(A[[1]], "cc1", a = last.a / (1 + technology.progress.rate))
        }

        state
      },
      policyMarketClearingPrice
    ),
    maxIteration = 1,
    numberOfPeriods = 50,
    ts = TRUE
  )
}

ge &lt;- f()
matplot((ge$ts.z), type = "o", pch = 20)
ge$z

## change the R&amp;D intensity.
node_set(dst.firm, "cc1", a = 1)
RDIntensity &lt;- 0.8
ge &lt;- f()
matplot((ge$ts.z), type = "o", pch = 20)
ge$z

## random rate of technological progress.
set.seed(1)
RDIntensity &lt;- 0.3
node_set(dst.firm, "cc1", a = 1)
f.TPR &lt;- function(RDLevel) max(0, rnorm(1, RDEffectivenessCoefficient * RDLevel,
  sqrt(RDEffectivenessCoefficient * RDLevel)))
ge &lt;- f()
matplot((ge$ts.z), type = "o", pch = 20)
ge$z

## two firms with different R&amp;D intensity.
node_set(dst.firm, "cc1", a = 1)
RDIntensity1 &lt;- 0.1
RDIntensity2 &lt;- 0.05
RDEffectivenessCoefficient &lt;- 0.002

dst.firm2 &lt;- Clone(dst.firm)
dst.RDCenter2 &lt;- Clone(dst.RDCenter)
ge &lt;- sdm2(
  A = list(dst.firm, dst.RDCenter, dst.laborer, dst.firm2, dst.RDCenter2),
  B = matrix(c(
    1, 0, 0, 1, 0,
    0, 0, 0, 0, 0
  ), 2, 5, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA, NA,
    NA, NA, 200, NA, NA
  ), 2, 5, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm1", "RDCenter1", "laborer", "firm2", "RDCenter2"),
  numeraire = "prod",
  z0 = c(200, 0, 200, 200, 0),
  policy = list(
    function(time, A, state) {
      if (time &gt;= 5) {
        state$S[1, 2] &lt;- state$S[1, 1] * RDIntensity1
        state$S[1, 1] &lt;- state$S[1, 1] * (1 - RDIntensity1)
        last.a1 &lt;- node_set(A[[1]], "cc1")$a
        last.RDLevel1 &lt;- state$last.z[2]
        technology.progress.rate1 &lt;- RDEffectivenessCoefficient * last.RDLevel1
        node_set(A[[1]], "cc1", a = last.a1 / (1 + technology.progress.rate1))

        state$S[1, 5] &lt;- state$S[1, 4] * RDIntensity2
        state$S[1, 4] &lt;- state$S[1, 4] * (1 - RDIntensity2)
        last.a2 &lt;- node_set(A[[4]], "cc1")$a
        last.RDLevel2 &lt;- state$last.z[5]
        technology.progress.rate2 &lt;- RDEffectivenessCoefficient * last.RDLevel2
        node_set(A[[4]], "cc1", a = last.a2 / (1 + technology.progress.rate2))
      }

      state
    },
    policyMarketClearingPrice
  ),
  maxIteration = 1,
  numberOfPeriods = 50,
  ts = TRUE
)

matplot((ge$ts.z), type = "o", pch = 20)
ge$z

## Assume that the R&amp;D center is owned by the government and
## receives revenue through taxation on firms.
## The technologies developed by the R&amp;D center are public goods.
node_set(dst.firm, "cc1", a = 1)
RDIntensity &lt;- 0.1
RDEffectivenessCoefficient &lt;- 0.002

dst.firm2 &lt;- Clone(dst.firm)

ge &lt;- sdm2(
  A = list(dst.firm, dst.RDCenter, dst.laborer, dst.firm2),
  B = matrix(c(
    1, 0, 0, 1,
    0, 0, 0, 0
  ), 2, 4, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA,
    NA, NA, 200, NA
  ), 2, 4, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm1", "RDCenter", "laborer", "firm2"),
  numeraire = "prod",
  z0 = c(200, 0, 200, 200),
  policy = list(
    function(time, A, state) {
      if (time &gt;= 5) {
        last.RDLevel &lt;- state$last.z[2]
        technology.progress.rate &lt;- RDEffectivenessCoefficient * last.RDLevel

        state$S[1, 2] &lt;- (state$S[1, 1] + state$S[1, 4]) * RDIntensity
        state$S[1, 1] &lt;- state$S[1, 1] * (1 - RDIntensity)
        state$S[1, 4] &lt;- state$S[1, 4] * (1 - RDIntensity)
        last.a1 &lt;- node_set(A[[1]], "cc1")$a
        node_set(A[[1]], "cc1", a = last.a1 / (1 + technology.progress.rate))

        last.a2 &lt;- node_set(A[[4]], "cc1")$a
        node_set(A[[4]], "cc1", a = last.a2 / (1 + technology.progress.rate))
      }

      state
    },
    policyMarketClearingPrice
  ),
  maxIteration = 1,
  numberOfPeriods = 30,
  ts = TRUE
)

matplot((ge$ts.z), type = "o", pch = 20)
ge$z

</code></pre>

<hr>
<h2 id='gemRobinson_3_2'>A Robinson Crusoe Economy</h2><span id='topic+gemRobinson_3_2'></span>

<h3>Description</h3>

<p>Compute the general equilibrium of a Robinson Crusoe economy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemRobinson_3_2(dstl, endowment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemRobinson_3_2_+3A_dstl">dstl</code></td>
<td>
<p>the demand structure tree list.</p>
</td></tr>
<tr><td><code id="gemRobinson_3_2_+3A_endowment">endowment</code></td>
<td>
<p>the endowment 3-vector.
The endowment of the product is a non-negative number.
The endowments of labor and land are positive numbers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A general equilibrium model with 3 commodities (i.e. product, labor,
and land) and 2 agents (i.e. a firm and a consumer). The numeraire is labor.
</p>


<h3>Value</h3>

<p>A general equilibrium.
</p>


<h3>References</h3>

<p>http://essentialmicroeconomics.com/ChapterY5/SlideChapter5-1.pdf
</p>
<p>http://homepage.ntu.edu.tw/~josephw/MicroTheory_Lecture_11a_RobinsonCrusoeEconomy.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### a general equilibrium model with 2 basic commodities (i.e. labor and land)
#### and 1 agent (see the first reference)
dst.Robinson &lt;- node_new("util",
  type = "CD", alpha = 1, beta = c(0.5, 0.5),
  "prod", "lab"
)
node_set(dst.Robinson, "prod",
  type = "CD", alpha = 8, beta = c(0.5, 0.5),
  "lab", "land"
)

node_plot(dst.Robinson)

ge &lt;- sdm2(
  A = list(dst.Robinson),
  names.commodity = c("lab", "land"),
  names.agent = c("Robinson"),
  B = matrix(0, 2, 1),
  S0Exg = matrix(c(
    12,
    1
  ), 2, 1, TRUE),
  numeraire = "lab"
)
ge


## the same economy as above
dst.Robinson &lt;- node_new("util",
  type = "CD", alpha = 1, beta = c(0.5, 0.5),
  "prod", "lab"
)
dst.firm &lt;- node_new("output",
  type = "CD", alpha = 8, beta = c(0.5, 0.5),
  "lab", "land"
)

dstl &lt;- list(dst.firm, dst.Robinson)

ge &lt;- gemRobinson_3_2(dstl, endowment = c(0, 12, 1))
ge

## another example (see the second reference)
dst.firm$alpha &lt;- 1

ge &lt;- gemRobinson_3_2(dstl, endowment = c(3, 144, 1))
ge

#### a Robinson Crusoe economy with labor and two types of land
dst.Robinson &lt;- node_new("util",
  type = "CD", alpha = 1, beta = c(0.5, 0.5),
  "prod1", "prod2"
)
node_set(dst.Robinson, "prod1",
  type = "CD", alpha = 1, beta = c(0.2, 0.8),
  "lab", "land1"
)
node_set(dst.Robinson, "prod2",
  type = "CD", alpha = 1, beta = c(0.8, 0.2),
  "lab", "land2"
)
node_plot(dst.Robinson)

dstl &lt;- list(dst.Robinson)

ge.3_1 &lt;- sdm2(dstl,
  names.commodity = c("lab", "land1", "land2"),
  names.agent = c("Robinson"),
  B = matrix(0, 3, 1),
  S0Exg = matrix(c(
    100,
    100,
    100
  ), 3, 1, TRUE),
  numeraire = "lab"
)
ge.3_1

#### the same economy as above
ge.5_3 &lt;- sdm2(
  A = list(
    dst.firm1 = node_new("output",
                         type = "CD", alpha = 1, beta = c(0.2, 0.8),
                         "lab", "land1"
    ),
    dst.firm2 = node_new("output",
                         type = "CD", alpha = 1, beta = c(0.8, 0.2),
                         "lab", "land2"
    ),
    dst.Robinson = node_new("util",
                            type = "CD", alpha = 1, beta = c(0.5, 0.5),
                            "prod1", "prod2"
    )
  ),
  names.commodity = c("prod1", "prod2", "lab", "land1", "land2"),
  names.agent = c("firm1", "firm2", "Robinson"),
  B = {
    B &lt;- matrix(0, 5, 3)
    B[1, 1] &lt;- B[2, 2] &lt;- 1
    B
  },
  S0Exg = {
    S0Exg &lt;- matrix(NA, 5, 3)
    S0Exg[3:5, 3] &lt;- 100
    S0Exg
  },
  numeraire = "lab"
)
ge.5_3


</code></pre>

<hr>
<h2 id='gemShortTermInvestment_2_3'>Some Examples Illustrating Short-Term Investment</h2><span id='topic+gemShortTermInvestment_2_3'></span>

<h3>Description</h3>

<p>Some examples illustrating short-term investment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemShortTermInvestment_2_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemShortTermInvestment_2_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an example with an exogenous investment rate
investment.rate &lt;- 0.2
dst.firm &lt;- node_new("output",
  type = "CD",
  alpha = 2, beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.laborer &lt;- node_new("laborer.util",
  type = "CD",
  alpha = 1, beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.investor &lt;- node_new("investor.util",
  type = "Leontief",
  a = 1,
  "prod"
)

dstl &lt;- list(dst.firm, dst.laborer, dst.investor)

ge &lt;- sdm2(
  A = dstl,
  B = diag(c(1, 0), 2, 3),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 100 * (1 - investment.rate), 100 * investment.rate
  ), 2, 3, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "laborer", "investor"),
  numeraire = "prod"
)

addmargins(ge$D, 2)

## an example with an exogenous investment level
dst.investor$current.investment.rate &lt;- 0.5
investment.level &lt;- 20

ge &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.investor),
  B = diag(c(1, 0), 2, 3),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 100, 0
  ), 2, 3, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "laborer", "investor"),
  numeraire = "prod",
  policy = function(time, A, state) {
    A[[3]]$current.investment.rate &lt;- A[[3]]$current.investment.rate *
      (investment.level / state$last.z[3])
    state$S[2, 2] &lt;- 100 * (1 - A[[3]]$current.investment.rate)
    state$S[2, 3] &lt;- 100 * A[[3]]$current.investment.rate
    state
  }
)

addmargins(ge$D, 2)

</code></pre>

<hr>
<h2 id='gemSkill'>Some General Equilibrium Models with Skill (i.e. Human Capital)</h2><span id='topic+gemSkill'></span>

<h3>Description</h3>

<p>Some general equilibrium models with skill (i.e. human capital).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemSkill(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemSkill_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
depreciation.rate &lt;- 0.05 # the depreciation rate of skill
skill.density &lt;- 10
relative.efficiency.coef &lt;- 2
efficiency.coef &lt;- skill.density * relative.efficiency.coef

dst.efficiency.unit &lt;- node_new("efficiency unit",
  type = "Leontief",
  a =  1 / efficiency.coef,
  "complex labor"
)

dst.firm &lt;- node_new(
  "product",
  type = "SCES", alpha = 1,
  beta = c(0.4, 0.6), es = 0.5,
  "product", "labor"
)
node_set(dst.firm, "labor",
  type = "SCES", alpha = 1,
  beta = c(0.5, 0.5), es = 1.5,
  "simple labor", dst.efficiency.unit
)

dst.school &lt;- node_new(
  "skill",
  type = "Leontief",
  a = c(0.1, 1, 0.1),
  "product", "simple labor", dst.efficiency.unit
)

dst.complex.laborer &lt;- node_new(
  "complex labor",
  type = "Leontief", a = c(skill.density, 1),
  "skill", "simple labor"
)

dst.simple.laborer &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "product"
)

ge &lt;- sdm2(
  A = list(dst.firm, dst.school, dst.complex.laborer, dst.simple.laborer),
  B = matrix(c(
    1, 0, 0, 0,
    0, 1, skill.density * (1 - depreciation.rate), 0,
    0, 0, 1, 0,
    0, 0, 0, 0
  ), 4, 4, TRUE),
  S0Exg = {
    tmp &lt;- matrix(NA, 4, 4)
    tmp[4, 4] &lt;- 100
    tmp
  },
  names.commodity = c("product", "skill", "complex labor", "simple labor"),
  names.agent = c("firm", "school", "complex laborer", "simple laborer"),
  numeraire = "simple labor",
  policy = makePolicyMeanValue(50),
  priceAdjustmentVelocity = 0.05,
  maxIteration = 1,
  numberOfPeriods = 1000,
  ts = TRUE
)

ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)
matplot(ge$ts.p, type = "l")

#### Assumed that the amount of education and training purchased by laborers is
## determined primarily by their preferences rather than their investment motives.
depreciation.rate &lt;- 0.05
skill.density &lt;- 10
relative.efficiency.coef &lt;- 2
efficiency.coef &lt;- skill.density * relative.efficiency.coef

dst.efficiency.unit &lt;- node_new("efficiency unit",
  type = "Leontief",
  a = c(skill.density / efficiency.coef, 1 / efficiency.coef),
  "skill service", "simple labor"
)

dst.firm &lt;- node_new(
  "product",
  type = "SCES", alpha = 1,
  beta = c(0.4, 0.6), es = 0.5,
  "product", "labor"
)
node_set(dst.firm, "labor",
  type = "SCES", alpha = 1,
  beta = c(0.5, 0.5), es = 1.5,
  "simple labor", dst.efficiency.unit
)

dst.school &lt;- node_new(
  "skill",
  type = "Leontief",
  a = c(0.1, 1, 0.1),
  "product", "simple labor", dst.efficiency.unit
)

dst.laborer &lt;- node_new(
  "util",
  type = "CD", alpha = 1,
  beta = c(0.7887, 0.2113),
  # beta &lt;- c(0.9, 0.1),
  # beta &lt;- c(0.6, 0.4),
  "product", "skill",
  skill.stock = 0
)

ge &lt;- sdm2(
  A = list(dst.firm, dst.school, dst.laborer),
  B = matrix(c(
    1, 0, 0,
    0, 1, 0,
    0, 0, 0,
    0, 0, 0
  ), 4, 3, TRUE),
  S0Exg = {
    tmp &lt;- matrix(NA, 4, 3)
    tmp[4, 3] &lt;- 100
    tmp
  },
  names.commodity = c("product", "skill", "skill service", "simple labor"),
  names.agent = c("firm", "school", "laborer"),
  numeraire = "simple labor",
  policy = function(A, state) {
    last.D &lt;- state$last.A %*% dg(state$last.z)
    new.skill &lt;- last.D[2, 3]
    state$S[3, 3] &lt;- A[[3]]$skill.stock &lt;-
      A[[3]]$skill.stock * (1 - depreciation.rate) + new.skill
    state
  },
  priceAdjustmentVelocity = 0.05,
  maxIteration = 1,
  numberOfPeriods = 1000,
  ts = TRUE
)

ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)
matplot(log(ge$ts.p), type = "l")

</code></pre>

<hr>
<h2 id='gemstEndogenousLaborSupply_2_2'>A General Equilibrium Model with Endogenous Labor Supply</h2><span id='topic+gemstEndogenousLaborSupply_2_2'></span>

<h3>Description</h3>

<p>This is an example of the spot market clearing path (alias instantaneous equilibrium path) with endogenous labor supply.
Assume that as the level of utility increases, laborer will purchase or receive more education and training,
resulting in an increase in human capital, which can be regarded as an increase in labor supply.
That is to say, the utility level as an endogenous variable will affect the supply of labor.
Therefore, labor supply becomes an endogenous variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemstEndogenousLaborSupply_2_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemstEndogenousLaborSupply_2_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- function(z0 = c(20, 1)) {
  ge &lt;- sdm2(
    A = function(state) {
      a.firm &lt;- CD_A(alpha = 5, Beta = c(0.5, 0.5), p = state$p)
      a.consumer &lt;- c(1, 0)
      cbind(a.firm, a.consumer)
    },
    B = matrix(c(
      1, 0,
      0, 0
    ), 2, 2, TRUE),
    S0Exg = matrix(c(
      NA, NA,
      NA, 1
    ), 2, 2, TRUE),
    names.commodity = c("prod", "lab"),
    names.agent = c("firm", "consumer"),
    numeraire = "lab",
    z0 = z0,
    ts = TRUE,
    policy = list(
      function(state) {
        state$S[2, 2] &lt;- structural_function(state$last.z[2], c(6.5, 7), 1, 2)
        state
      },
      policyMarketClearingPrice
    ),
    numberOfPeriods = 20,
    maxIteration = 1
  )
  matplot(ge$ts.z, type = "o", pch = 20)
  print(ge$z)
  print(ge$S)
}

f()

f(c(10,1))

</code></pre>

<hr>
<h2 id='gemstEndogenousProductionFunction_2_2'>A General Equilibrium Model with Endogenous Production Function</h2><span id='topic+gemstEndogenousProductionFunction_2_2'></span>

<h3>Description</h3>

<p>This is an example of the spot market clearing path (alias instantaneous equilibrium path) with an endogenous production function.
The parameter of the production function will change with the output level.
</p>
<p>To deal with locally or globally increasing returns to scale, we can simply use an endogenous CES-type production function instead of a production function with a more complex form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemstEndogenousProductionFunction_2_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemstEndogenousProductionFunction_2_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.firm &lt;- node_new(
  "output",
  type = "CD", alpha = 5, beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.consumer &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "prod"
)

ge &lt;- sdm2(
  A = list(dst.firm, dst.consumer),
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 1
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "lab",
  z0 = c(1, 1),
  p0 = c(1, 1),
  ts = TRUE,
  policy = list(
    function(A, state) {
      A[[1]]$alpha &lt;- 5 * state$last.z[1]^0.1
    },
    policyMarketClearingPrice
  ),
  numberOfPeriods = 40,
  maxIteration = 1
)

matplot(ge$ts.z, type = "o", pch = 20)

</code></pre>

<hr>
<h2 id='gemstEndogenousUtilityFunction'>Some General Equilibrium Models with Endogenous Utility Function</h2><span id='topic+gemstEndogenousUtilityFunction'></span>

<h3>Description</h3>

<p>Some examples of the spot market clearing path (alias instantaneous equilibrium path) with an endogenous utility function.
The parameters of the utility function will change with the utility level.
</p>
<p>To deal with non-homothetic preferences, we can simply use an endogenous CES-type utility function instead of a utility function with a more complex form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemstEndogenousUtilityFunction(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemstEndogenousUtilityFunction_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### a 2-by-2 example
dst.firm &lt;- node_new(
  "output",
  type = "CD", alpha = 5, beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = c(0.5, 0.5),
  "prod", "lab"
)

ge &lt;- sdm2(
  A = list(dst.firm, dst.consumer),
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 1
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "lab",
  z0 = c(0.01, 1),
  p0 = c(1, 1),
  ts = TRUE,
  policy = list(
    function(A, state) {
      util &lt;- state$last.z[2]
      beta2 &lt;- 0.95 * plogis(util, location = 2, scale = 2)
      A[[2]]$beta &lt;- c(1 - beta2, beta2)
    },
    policyMarketClearingPrice
  ),
  numberOfPeriods = 20,
  maxIteration = 1
)

matplot(ge$ts.z, type = "o", pch = 20)
ge$z
dst.consumer$beta

#### a 3-by-3 example with 100 laborers
#### Assume that each laborer desires to consume one unit of
#### corn per period, regardless of her level of utility.
dst.firm.corn &lt;- node_new(
  "corn",
  type = "CD", alpha = 1, beta = c(0.5, 0.5),
  "iron", "lab"
)

dst.firm.iron &lt;- node_new(
  "iron",
  type = "CD", alpha = 5, beta = c(0.5, 0.5),
  "iron", "lab"
)

dst.consumer &lt;- node_new(
  "util",
  type = "Leontief",
  a = c(0.5, 0.5),
  "corn", "iron"
)

ge &lt;- sdm2(
  A = list(dst.firm.corn, dst.firm.iron, dst.consumer),
  B = matrix(c(
    1, 0, 0,
    0, 1, 0,
    0, 0, 0
  ), 3, 3, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, NA, NA,
    NA, NA, 100
  ), 3, 3, TRUE),
  names.commodity = c("corn", "iron", "lab"),
  names.agent = c("firm.corn", "firm.iron", "consumer"),
  numeraire = "lab",
  ts = TRUE,
  policy = list(
    function(A, state) {
      last.util &lt;- state$last.z[3] / 100 # the previous utility level of each laborer
      a1 &lt;- min(1 / last.util, 1)
      A[[3]]$a &lt;- c(a1, 1 - a1)
    },
    policyMarketClearingPrice
  ),
  numberOfPeriods = 40,
  maxIteration = 1
)

matplot(ge$ts.z, type = "o", pch = 20)
ge$z
ge$A
ge$D

#### a 4-by-4 example with 100 homogeneous laborers
dst.agri &lt;- node_new(
  "output",
  type = "SCES",
  es = 0.5, alpha = 2, beta = c(0.2, 0.8),
  "manu", "lab"
)

dst.manu &lt;- node_new(
  "output",
  type = "SCES",
  es = 0.5, alpha = 3, beta = c(0.6, 0.4),
  "manu", "lab"
)

dst.serv &lt;- node_new(
  "output",
  type = "SCES",
  es = 0.5, alpha = 2, beta = c(0.4, 0.6),
  "manu", "lab"
)

dst.consumer &lt;- node_new(
  "util",
  type = "CD", alpha = 1, beta = c(0.6, 0.3, 0.1),
  "agri", "manu", "serv"
)

ge &lt;- sdm2(
  A = list(dst.agri, dst.manu, dst.serv, dst.consumer),
  B = diag(c(1, 1, 1, 0)),
  S0Exg = {
    tmp &lt;- matrix(NA, 4, 4)
    tmp[4, 4] &lt;- 100
    tmp
  },
  names.commodity = c("agri", "manu", "serv", "lab"),
  names.agent = c("agri", "manu", "serv", "consumer"),
  numeraire = "lab",
  z0 = c(1, 1, 1, 0),
  ts = TRUE,
  policy = list(
    function(A, state) {
      util &lt;- state$last.z[4] / 100
      beta1 &lt;- structural_function(util, c(1, 6), 0.6, 0.1)
      beta3 &lt;- structural_function(util, c(1, 6), 0.1, 0.5)
      beta2 &lt;- 1 - beta1 - beta3
      A[[4]]$beta &lt;- c(beta1, beta2, beta3)
    },
    policyMarketClearingPrice
  ),
  numberOfPeriods = 20,
  maxIteration = 1
)

matplot(ge$ts.z, type = "o", pch = 20)
ge$z
dst.consumer$beta


</code></pre>

<hr>
<h2 id='gemStickyDecisionPath_2_2'>An Example Illustrating the Sticky-Decision Path and Business Cycles</h2><span id='topic+gemStickyDecisionPath_2_2'></span>

<h3>Description</h3>

<p>This is an 2-by-2 example that illustrates the sticky-decision path and business cycles.
Assume that the consumer has a linear utility function x1 + 0.8 * x2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemStickyDecisionPath_2_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemStickyDecisionPath_2_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
stickiness &lt;- 0.1 # 0.5
ge &lt;- sdm2(
  A = function(state) {
    a.firm &lt;- CD_A(alpha = 2, Beta = c(0.5, 0.5), state$p)
    if (1.25 * state$p[2] &lt; state$p[1]) {
      a.consumer &lt;- c(0, 1)
    } else {
      a.consumer &lt;- c(1, 0)
    }

    a.consumer &lt;- state$last.A[, 2] * stickiness + a.consumer * (1 - stickiness)
    cbind(a.firm, a.consumer)
  },
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "laborer"),
  numeraire = "prod",
  z0 = c(80, 100),
  maxIteration = 1,
  numberOfPeriods = 100,
  ts = TRUE
)

matplot(ge$ts.z, type = "o", pch = 20)

</code></pre>

<hr>
<h2 id='gemStickyPricePath_2_2'>Some Examples Illustrating the Sticky-Price Path and Business Cycles</h2><span id='topic+gemStickyPricePath_2_2'></span>

<h3>Description</h3>

<p>These are some examples that illustrate the sticky-price path and business cycles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemStickyPricePath_2_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemStickyPricePath_2_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
stickiness &lt;- 0.7

dst.firm &lt;- node_new(
  "output",
  type = "CD", alpha = 2, beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.consumer &lt;- node_new(
  "util",
  type = "Leontief", a = 1,
  "prod"
)

ge &lt;- sdm2(
  A = list(dst.firm, dst.consumer),
  B = matrix(c(
    1, 0,
    0, 1
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "lab",
  z0 = c(100, 100),
  p0 = c(1, 1),
  ts = TRUE,
  policy = list(
    makePolicyTechnologyChange(
      adjumentment.ratio = 2,
      agent = "firm",
      time.win = c(30, 30)
    ),
    makePolicyStickyPrice(stickiness = stickiness)
  ),
  priceAdjustmentVelocity = 0,
  numberOfPeriods = 60,
  maxIteration = 1
)

matplot(ge$ts.z, type = "b", pch = 20)

#### another example.
## When the stickiness is 0, there will be business cycles.
stickiness &lt;- 0.5

dst.firm &lt;- node_new(
  "output",
  type = "Leontief", a = 0.2,
  "lab"
)

dst.consumer &lt;- node_new(
  "util",
  type = "CES", es = 0.3, alpha = 1, beta = c(0.5, 0.5),
  "prod", "lab"
)

ge &lt;- sdm2(
  A = list(dst.firm, dst.consumer),
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "lab",
  z0 = c(100, 100),
  p0 = c(1, 1),
  ts = TRUE,
  policy = makePolicyStickyPrice(stickiness	= stickiness),
  priceAdjustmentVelocity = 0,
  numberOfPeriods = 40,
  maxIteration = 1
)

matplot(ge$ts.z, type = "b", pch = 20)

</code></pre>

<hr>
<h2 id='gemstStructuralMultipleEquilibria_2_2'>Structural Multiple Equilibria and Structural Transition Policy</h2><span id='topic+gemstStructuralMultipleEquilibria_2_2'></span>

<h3>Description</h3>

<p>Some examples of structural multiple equilibria and structural transition policy.
In these examples it is assumed that the firm has a structural production function (see Li, Fu, 2020), e.g.
</p>
<p>structural_function(last.output, c(0.3, 0.4), 1, 2) * x1^0.35 * x2^0.65
</p>
<p>wherein last.output is the output of the firm in the previous period.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemstStructuralMultipleEquilibria_2_2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemstStructuralMultipleEquilibria_2_2_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Li Wu, Fu Caihui (2020) A Simulation Study on the Economic Structure Transition Policy. Journal of Shanghai University (Social Sciences). 37(2), pp: 33-45. (In Chinese)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.firm &lt;- node_new("output",
  type = "CD", alpha = 1,
  beta = c(0.35, 0.65),
  "prod", "lab"
)

dst.consumer &lt;- node_new("utility",
  type = "CD", alpha = 1,
  beta = c(0.4, 0.6),
  "prod", "lab"
)

policy.technology &lt;- function(time, state, A) {
  # state$last.z[1] is the previous output.
  A[[1]]$alpha &lt;- structural_function(state$last.z[1], c(0.3, 0.4), 1, 2)
}

policy.tax &lt;- function(time, state) {
  if ((time &gt;= 15) &amp;&amp; state$last.z[1] &lt; 0.4) {
    state$S[2, 2] &lt;- 0.8
    state$S[2, 1] &lt;- 0.2
  } else {
    state$S[2, 2] &lt;- 1
    state$S[2, 1] &lt;- 0
  }

  state
}

f &lt;- function(z0 = c(0.1, 1),
              policy = list(
                policy.technology,
                policyMarketClearingPrice
              )) {
  ge &lt;- sdm2(
    A = list(dst.firm, dst.consumer),
    B = matrix(c(
      1, 0,
      0, 0
    ), 2, 2, TRUE),
    S0Exg = matrix(c(
      NA, NA,
      NA, 1
    ), 2, 2, TRUE),
    names.commodity = c("prod", "lab"),
    names.agent = c("firm", "consumer"),
    numeraire = "lab",
    z0 = z0,
    p0 = c(1, 1),
    maxIteration = 1,
    numberOfPeriods = 30,
    policy = policy,
    ts = TRUE
  )

  matplot(ge$ts.z, type = "o", pch = 20)
  invisible(ge)
}

geLow &lt;- f()
geLow$z

geHigh &lt;- f(z0 = c(0.5, 1))
geHigh$z

f(policy = list(
  policy.technology,
  policy.tax,
  policyMarketClearingPrice
))

#### structural transition: disequilibrium path and
## a spot market clearing path (alias instantaneous equilibrium path)
dst.firm &lt;- node_new("output",
  type = "CD", alpha = 5,
  beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.consumer &lt;- node_new("utility",
  type = "Leontief", a = 1,
  "prod"
)

policy.technology &lt;- function(time, state, A) {
  # state$last.z[1] is last output.
  A[[1]]$alpha &lt;- structural_function(state$last.z[1], c(15, 20), 5, 15)
  return(NULL)
}

policy.tax &lt;- function(time, state) {
  if ((time &gt;= 100) &amp;&amp; (time &lt;= 109)) {
    state$S[2, 2] &lt;- 0.6
    state$S[2, 1] &lt;- 0.4
  } else {
    state$S[2, 2] &lt;- 1
    state$S[2, 1] &lt;- 0
  }

  state
}

f &lt;- function(z0 = c(1, 1),
              p0 = c(1, 1),
              policy = policy.technology) {
  ge &lt;- sdm2(
    A = list(dst.firm, dst.consumer),
    B = matrix(c(
      1, 0,
      0, 1
    ), 2, 2, TRUE),
    S0Exg = matrix(c(
      NA, NA,
      NA, 1
    ), 2, 2, TRUE),
    names.commodity = c("prod", "lab"),
    names.agent = c("firm", "consumer"),
    numeraire = "lab",
    z0 = z0,
    p0 = p0,
    maxIteration = 1,
    numberOfPeriods = 200,
    policy = policy,
    priceAdjustmentVelocity = 0.4,
    ts = TRUE
  )

  matplot(ge$ts.z, type = "l", pch = 20)
  invisible(ge)
}

geLow &lt;- f()
geLow$z

geHigh &lt;- f(z0 = c(18, 1), p0 = c(1, 9))
geHigh$z

## structural transition: a disequilibrium path
f(policy = list(
  policy.technology,
  policy.tax
))$z


## structural transition: a spot market clearing path
f(policy = list(
  policy.technology,
  policy.tax,
  policyMarketClearingPrice
))$z

## structural transition through foreign aid
policy.foreign_aid &lt;- function(time, state) {
  if ((time &gt;= 100) &amp;&amp; (time &lt;= 109)) {
    state$S[2, 2] &lt;- 3
  } else {
    state$S[2, 2] &lt;- 1
  }

  state
}

f(policy = list(
  function(time, state, A) { # technology policy
    # state$last.z[1] is last output.
    A[[1]]$alpha &lt;- structural_function(state$last.z[1], c(30, 35), 5, 15)
  },
  policy.foreign_aid
))

#### another example
dst.firm &lt;- node_new("prod",
  type = "CD", alpha = 2,
  beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.consumer &lt;- node_new("util",
  type = "Leontief", a = 1,
  "prod"
)

policy.technology &lt;- function(time, state, A) {
  # state$last.z[1] is the previous output.
  A[[1]]$alpha &lt;- structural_function(state$last.z[1], c(220, 250), 2, 4)
}

policy.tax &lt;- function(time, state) {
  if ((time &gt;= 15) &amp;&amp; state$last.z[1] &lt; 240) {
    state$S[2, 2] &lt;- 80
    state$S[2, 1] &lt;- 20
  } else {
    state$S[2, 2] &lt;- 100
    state$S[2, 1] &lt;- 0
  }

  state
}

ge &lt;- sdm2(
  A = list(dst.firm, dst.consumer),
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "lab",
  z0 = c(100, 100),
  maxIteration = 1,
  numberOfPeriods = 30,
  policy = list(
    policy.technology,
    policy.tax,
    policyMarketClearingPrice
  ),
  ts = TRUE
)

matplot(ge$ts.z, type = "b", pch = 20)

</code></pre>

<hr>
<h2 id='gemTax_3_3'>Some General Equilibrium Models with Tax</h2><span id='topic+gemTax_3_3'></span>

<h3>Description</h3>

<p>Some general equilibrium models with tax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemTax_3_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemTax_3_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>LI Wu (2019, ISBN: 9787521804225) General Equilibrium and Structural Dynamics: Perspectives of New Structural Economics. Beijing: Economic Science Press. (In Chinese)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### turnover tax.
dst.firm &lt;- node_new("prod",
                     type = "FIN",
                     rate = c(1, tax.rate = 0.25),
                     "cc1", "tax"
)
node_set(dst.firm, "cc1",
         type = "CD",
         alpha = 2, beta = c(0.5, 0.5),
         "prod", "lab"
)

dst.laborer &lt;- dst.government &lt;-
  node_new("util",
    type = "Leontief",
    a = 1,
    "prod"
  )

ge.TT &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.government),
  B = diag(c(1, 0, 0)),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 100, NA,
    NA, NA, 100
  ), 3, 3, TRUE),
  names.commodity = c("prod", "lab", "tax"),
  names.agent = c("firm", "laborer", "government"),
  numeraire = "prod"
)

ge.TT$p
ge.TT$z
ge.TT$D
ge.TT$S

#### product tax.
dst.taxed.prod &lt;- node_new("taxed.prod",
                           type = "FIN",
                           rate = c(1, tax.rate = 0.25),
                           "prod", "tax"
)

dst.firm &lt;- node_new("prod",
                     type = "CD",
                     alpha = 2, beta = c(0.5, 0.5),
                     dst.taxed.prod, "lab"
)

dst.laborer &lt;- dst.government &lt;-
  node_new("util",
    type = "Leontief",
    a = 1,
    dst.taxed.prod
  )

ge.PT &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.government),
  B = diag(c(1, 0, 0)),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 100, NA,
    NA, NA, 100
  ), 3, 3, TRUE),
  names.commodity = c("prod", "lab", "tax"),
  names.agent = c("firm", "laborer", "government"),
  numeraire = "prod"
)

ge.PT$p
ge.PT$z
ge.PT$D
ge.PT$S

#### consumption tax.
dst.firm &lt;- node_new("output",
                     type = "CD", alpha = 2,
                     beta = c(0.5, 0.5),
                     "prod", "lab"
)

dst.laborer &lt;- node_new("util",
                        type = "FIN",
                        rate = c(1, consumption.tax.rate = 1/3),
                        "prod", "tax"
)

dst.government &lt;- node_new("utility",
                           type = "Leontief",
                           a = 1,
                           "prod"
)

ge.CT &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.government),
  B = diag(c(1, 0, 0)),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 100, NA,
    NA, NA, 100
  ), 3, 3, TRUE),
  names.commodity = c("prod", "lab", "tax"),
  names.agent = c("firm", "laborer", "government"),
  numeraire = "prod"
)

ge.CT$p
ge.CT$z
ge.CT$D
ge.CT$S

#### value added tax.
dst.firm &lt;- node_new("output",
  type = "CD", alpha = 2,
  beta = c(0.5, 0.5),
  "prod", "taxed.lab"
)
node_set(dst.firm, "taxed.lab",
  type = "FIN",
  rate = c(1, vat.rate = 1/3),
  "lab", "tax"
)

dst.laborer &lt;- dst.government &lt;-
  node_new("util",
    type = "Leontief",
    a = 1,
    "prod"
  )

ge.VAT &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.government),
  B = diag(c(1, 0, 0)),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 100, NA,
    NA, NA, 100
  ), 3, 3, TRUE),
  names.commodity = c("prod", "lab", "tax"),
  names.agent = c("firm", "laborer", "government"),
  numeraire = "prod"
)

ge.VAT$p
ge.VAT$z
ge.VAT$D
ge.VAT$S

#### income tax.
income.tax.rate &lt;- 1 / 4

dst.firm &lt;- node_new("output",
                     type = "CD",
                     alpha = 2, beta = c(0.5, 0.5),
                     "prod", "lab"
)

dst.laborer &lt;- dst.government &lt;-
  node_new("util",
    type = "Leontief",
    a = 1,
    "prod"
  )

ge.IT &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.government),
  B &lt;- diag(c(1, 0), 2, 3),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 100 * (1 - income.tax.rate), 100 * income.tax.rate
  ), 2, 3, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "laborer", "government"),
  numeraire = "prod"
)

ge.IT$p
ge.IT$z
ge.IT$D
ge.IT$S

#### turnover tax (Li, 2019, example 4.11).
dst.firm &lt;- node_new("output",
                     type = "FIN",
                     rate = c(1, turnover.tax.rate = 1),
                     "cc1", "tax"
)
node_set(dst.firm, "cc1",
         type = "CD",
         alpha = 1, beta = c(0.5, 0.5),
         "prod", "lab"
)

dst.laborer1 &lt;- node_new("util",
                          type = "CD",
                          alpha = 1, beta = c(0.5, 0.5),
                          "prod", "lab"
)

dst.laborer2 &lt;- node_new("utility",
                          type = "Leontief",
                          a = 1,
                          "prod"
)

ge.TT2 &lt;- sdm2(
  A = list(dst.firm, dst.laborer1, dst.laborer2),
  B = diag(c(1, 0, 0)),
  S0Exg = matrix(c(
    NA, NA, NA,
    NA, 100, NA,
    NA, NA, 100
  ), 3, 3, TRUE),
  names.commodity = c("prod", "lab", "tax"),
  names.agent = c("firm", "laborer1", "laborer2"),
  numeraire = "lab"
)

ge.TT2$p
ge.TT2$z

#### commodity tax in a pure exchange economy.
tax.rate &lt;- 0.25
es.consumer1 &lt;- 0.5
es.consumer2 &lt;- 2

dst.consumer1 &lt;- node_new("util",
                          type = "SCES", es = es.consumer1,
                          alpha = 1, beta = c(0.5, 0.5),
                          "comm1", "comm2"
)

dst.consumer2 &lt;- node_new("util",
                          type = "SCES", es = es.consumer2,
                          alpha = 1, beta = c(0.5, 0.5),
                          "taxed.comm1", "comm2"
)
node_set(dst.consumer2, "taxed.comm1",
         type = "FIN",
         rate = c(1, tax.rate = tax.rate),
         "comm1", "tax"
)

dst.gov &lt;- node_new("util",
                    type = "SCES", es = 0,
                    alpha = 1, beta = c(0.5, 0.5),
                    "comm1", "comm2"
)

ge.CT &lt;- sdm2(
  A = list(dst.consumer1, dst.consumer2, dst.gov),
  B = matrix(0, 3, 3),
  S0Exg = matrix(c(
    100, NA, NA,
    NA, 100, NA,
    NA, NA, 100
  ), 3, 3, TRUE),
  names.commodity = c("comm1", "comm2", "tax"),
  names.agent = c("consumer1", "consumer2", "gov"),
  numeraire = "comm1"
)

ge.CT$p
ge.CT$z
ge.CT$D

</code></pre>

<hr>
<h2 id='gemTax_4_4'>Some General Equilibrium Models with Endogenous Tax Rates</h2><span id='topic+gemTax_4_4'></span>

<h3>Description</h3>

<p>Some general equilibrium models with endogenous tax rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemTax_4_4(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemTax_4_4_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
ge &lt;- sdm2(
  A = function(state) {
    a.firm &lt;- CD_A(alpha = 2, Beta = c(0.5, 0.5, 0, 0), state$p)
    a.laborer &lt;- CD_A(alpha = 1, Beta = c(0.75, 0.25, 0, 0), state$p)
    a.government &lt;- c(1, 0, 0, 0)
    a.planner &lt;- c(0, 0, 2, 1)
    cbind(a.firm, a.laborer, a.government, a.planner)
  },
  B = matrix(c(
    1, 0, 0, 0,
    0, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 1, 0
  ), 4, 4, TRUE),
  S0Exg = matrix(c(
    NA, NA, NA, NA,
    NA, NA, NA, 100,
    NA, NA, NA, NA,
    NA, NA, NA, NA
  ), 4, 4, TRUE),
  names.commodity = c("prod", "lab", "util1", "util2"),
  names.agent = c("firm", "laborer", "government", "planner"),
  numeraire = "prod"
)

ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)
addmargins(ge$DV)
addmargins(ge$SV)

#### an equivalent 2-by-2 model.
dst.firm &lt;- node_new("output",
  type = "CD",
  alpha = 2, beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.planner &lt;- node_new("util",
  type = "Leontief",
  a = c(2, 1),
  "util1", "util2"
)

node_set(dst.planner, "util1",
  type = "CD",
  alpha = 1, beta = c(0.75, 0.25),
  "prod", "lab"
)
node_set(dst.planner, "util2",
  type = "Leontief",
  a = 1,
  "prod"
)

ge &lt;- sdm2(
  A = list(dst.firm, dst.planner),
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 100
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "planner"),
  numeraire = "prod"
)

ge$p
ge$z
addmargins(ge$D, 2)
addmargins(ge$S, 2)
addmargins(ge$DV)
addmargins(ge$SV)

</code></pre>

<hr>
<h2 id='gemTax_5_4'>A General Equilibrium Model with Tax (see Cardenete et al., 2012).</h2><span id='topic+gemTax_5_4'></span>

<h3>Description</h3>

<p>A general equilibrium model with tax (see chapter 4, Cardenete et al., 2012),
wherein there are 5 commodities (i.e. product 1, product 2, labor, capital goods,
and tax receipt) and 4 agents (i.e. 2 firms and 2 consumers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemTax_5_4(
  dstl,
  names.commodity = c("prod1", "prod2", "lab", "cap", "tax"),
  names.agent = c("taxed.firm1", "taxed.firm2", "consumer1", "consumer2"),
  delta = 1,
  supply.lab.consumer1 = 30,
  supply.cap.consumer1 = 20,
  supply.lab.consumer2 = 20,
  supply.cap.consumer2 = 5,
  policy.tax = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemTax_5_4_+3A_dstl">dstl</code></td>
<td>
<p>the demand structure tree list.</p>
</td></tr>
<tr><td><code id="gemTax_5_4_+3A_names.commodity">names.commodity</code></td>
<td>
<p>names of commodities.</p>
</td></tr>
<tr><td><code id="gemTax_5_4_+3A_names.agent">names.agent</code></td>
<td>
<p>names of agents.</p>
</td></tr>
<tr><td><code id="gemTax_5_4_+3A_delta">delta</code></td>
<td>
<p>the proportion of tax revenue allocated to consumer 1.
1-delta is the proportion of tax revenue allocated to consumer 2.</p>
</td></tr>
<tr><td><code id="gemTax_5_4_+3A_supply.lab.consumer1">supply.lab.consumer1</code></td>
<td>
<p>the labor supply of consumer 1.</p>
</td></tr>
<tr><td><code id="gemTax_5_4_+3A_supply.cap.consumer1">supply.cap.consumer1</code></td>
<td>
<p>the capital supply of consumer 1.</p>
</td></tr>
<tr><td><code id="gemTax_5_4_+3A_supply.lab.consumer2">supply.lab.consumer2</code></td>
<td>
<p>the labor supply of consumer 2.</p>
</td></tr>
<tr><td><code id="gemTax_5_4_+3A_supply.cap.consumer2">supply.cap.consumer2</code></td>
<td>
<p>the capital supply of consumer 2.</p>
</td></tr>
<tr><td><code id="gemTax_5_4_+3A_policy.tax">policy.tax</code></td>
<td>
<p>a tax policy function (see <code><a href="#topic+sdm2">sdm2</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A general equilibrium (see <code><a href="#topic+sdm2">sdm2</a></code>), wherein labor is the numeraire.
</p>


<h3>References</h3>

<p>Manuel Alejandro Cardenete, Ana-Isabel Guerra, Ferran Sancho (2012, ISBN: 9783642247453) Applied General Equilibrium: An Introduction. Springer-Verlag Berlin Heidelberg.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.consumer1 &lt;- node_new("utility",
  type = "CD",
  alpha = 1,
  beta = c(0.3, 0.7),
  "prod1", "prod2"
)

dst.consumer2 &lt;- Clone(dst.consumer1)
dst.consumer2$beta &lt;- c(0.6, 0.4)

dst.firm1 &lt;- node_new("output",
  type = "Leontief",
  a = c(0.5, 0.2, 0.3),
  "VA", "prod1", "prod2"
)
node_set(dst.firm1, "VA",
  type = "CD",
  alpha = 0.8^-0.8 * 0.2^-0.2,
  beta = c(0.8, 0.2),
  "lab", "cap"
)

dst.firm2 &lt;- Clone(dst.firm1)
node_set(dst.firm2, "output",
  a = c(0.25, 0.5, 0.25)
)
node_set(dst.firm2, "VA",
  alpha = 0.4^-0.4 * 0.6^-0.6,
  beta = c(0.4, 0.6)
)

## no taxation
dstl &lt;- list(dst.firm1, dst.firm2, dst.consumer1, dst.consumer2)
ge &lt;- gemTax_5_4(dstl, delta = 1)

## ad valorem output tax (see Table 4.1)
output.tax.rate &lt;- 0.1
dst.taxed.firm1 &lt;- node_new("taxed.output",
  type = "FIN", rate = c(1, output.tax.rate),
  dst.firm1, "tax"
)
node_plot(dst.taxed.firm1)

dst.taxed.firm2 &lt;- node_new("taxed.output",
  type = "FIN", rate = c(1, output.tax.rate),
  dst.firm2, "tax"
)
node_plot(dst.taxed.firm2)

dstl &lt;- list(dst.taxed.firm1, dst.taxed.firm2, dst.consumer1, dst.consumer2)

ge.output.tax1 &lt;- gemTax_5_4(dstl, delta = 1)
ge.output.tax2 &lt;- gemTax_5_4(dstl, delta = 0.5)
ge.output.tax3 &lt;- gemTax_5_4(dstl, delta = 0)

## labor tax (see Table 4.3)
lab.tax.rate &lt;- 0.1

dst.taxed.lab &lt;- node_new("taxed.lab",
  type = "FIN",
  rate = c(1, lab.tax.rate),
  "lab",
  "tax"
)

dst.labor.taxed.firm1 &lt;- Clone(dst.firm1)
node_prune(dst.labor.taxed.firm1, "lab", "cap")
node_set(
  dst.labor.taxed.firm1, "VA",
  dst.taxed.lab,
  "cap"
)

dst.labor.taxed.firm2 &lt;- Clone(dst.labor.taxed.firm1)
node_set(dst.labor.taxed.firm2, "output",
  a = c(0.25, 0.5, 0.25)
)
node_set(dst.labor.taxed.firm2, "VA",
  alpha = 0.4^-0.4 * 0.6^-0.6,
  beta = c(0.4, 0.6)
)

dstl.labor.tax &lt;- list(dst.labor.taxed.firm1, dst.labor.taxed.firm2, dst.consumer1, dst.consumer2)

ge.lab.tax &lt;- gemTax_5_4(dstl.labor.tax, delta = 0.5)

ge.lab.tax$p
ge.lab.tax$z / ge$z - 1

## income tax (see Table 4.3)
income.tax.rate &lt;- 0.2
consumption.tax.rate &lt;- income.tax.rate / (1 - income.tax.rate)
dst.taxed.consumer1 &lt;- node_new("taxed.utility",
  type = "FIN",
  rate = c(1, consumption.tax.rate),
  dst.consumer1,
  "tax"
)

dst.taxed.consumer2 &lt;- node_new("taxed.utility",
  type = "FIN",
  rate = c(1, consumption.tax.rate),
  dst.consumer2,
  "tax"
)

dstl &lt;- list(dst.firm1, dst.firm2, dst.taxed.consumer1, dst.taxed.consumer2)

ge.income.tax &lt;- gemTax_5_4(dstl, delta = 0.5)
ge.income.tax$z / ge$z - 1

## labor tax (see Table 4.3)
lab.tax.rate &lt;- 0.3742
node_set(dst.labor.taxed.firm1, "taxed.lab",
  rate = c(1, lab.tax.rate)
)
node_set(dst.labor.taxed.firm2, "taxed.lab",
  rate = c(1, lab.tax.rate)
)

ge.lab.tax &lt;- gemTax_5_4(list(
  dst.labor.taxed.firm1,
  dst.labor.taxed.firm2,
  dst.consumer1,
  dst.consumer2
), delta = 0.5)
ge.lab.tax$z / ge$z - 1

## variable labor tax rate
policy.var.tax.rate &lt;- function(time, A, state) {
  current.tax.rate &lt;- NA
  if (time &gt;= 200) {
    tax.amount &lt;- (state$p / state$p[3])[5]
    adjustment.ratio &lt;- ratio_adjust(tax.amount / 18.7132504, coef = 0.1)
    last.tax.rate &lt;- node_set(A[[1]], "taxed.lab")$rate[2]
    current.tax.rate &lt;- last.tax.rate / adjustment.ratio
  } else {
    current.tax.rate &lt;- 0.1
  }
  node_set(A[[1]], "taxed.lab", rate = c(1, current.tax.rate))
  node_set(A[[2]], "taxed.lab", rate = c(1, current.tax.rate))

  state$current.policy.data &lt;- c(time, current.tax.rate)
  state
}

ge.var.lab.tax &lt;- gemTax_5_4(dstl.labor.tax, policy = policy.var.tax.rate)
matplot(ge.var.lab.tax$ts.z, type = "l")
matplot(ge.var.lab.tax$ts.p / ge.var.lab.tax$p[3], type = "l")
plot(ge.var.lab.tax$policy.data[, 1], ge.var.lab.tax$policy.data[, 2],
  ylab = "labor tax rate"
)
ge.var.lab.tax$p / ge.var.lab.tax$p[3]


</code></pre>

<hr>
<h2 id='gemTax_5_5'>A General Equilibrium Model with Tax</h2><span id='topic+gemTax_5_5'></span>

<h3>Description</h3>

<p>A general equilibrium model with tax.
The model contains 5 types of commodities (i.e. prod1, prod2, labor, capital and tax payment receipts)
and 5 agents (i.e. firm1, firm2, laborer, capital owner and government).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemTax_5_5(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemTax_5_5_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
tax.rate.cap1 &lt;- 0.25
tax.rate.lab1 &lt;- 0.25

tax.rate.cap2 &lt;- 0.25
tax.rate.lab2 &lt;- 0.25

es.prod &lt;- 0.5
es.cap.lab &lt;- 0.5

beta.firm1 &lt;- c(0.2, 0.8)
beta.firm2 &lt;- c(0.8, 0.2)

beta.laborer &lt;- c(0.5, 0.5)
beta.capitalOwner &lt;- c(0.5, 0.5)
beta.government &lt;- c(0.8, 0.2)

dst.firm1 &lt;- node_new("prod",
  type = "SCES",
  alpha = 1, beta = beta.firm1, es = es.cap.lab,
  "cc1", "cc2"
)
node_set(dst.firm1, "cc1",
  type = "FIN",
  rate = c(1, tax.rate = tax.rate.lab1),
  "lab", "tax"
)
node_set(dst.firm1, "cc2",
  type = "FIN",
  rate = c(1, tax.rate = tax.rate.cap1),
  "cap", "tax"
)

node_plot(dst.firm1, TRUE)

dst.firm2 &lt;- node_new("prod",
  type = "SCES",
  alpha = 1, beta = beta.firm2, es = es.cap.lab,
  "cc1", "cc2"
)
node_set(dst.firm2, "cc1",
  type = "FIN",
  rate = c(1, tax.rate = tax.rate.lab2),
  "lab", "tax"
)
node_set(dst.firm2, "cc2",
  type = "FIN",
  rate = c(1, tax.rate = tax.rate.cap2),
  "cap", "tax"
)

dst.laborer &lt;- node_new("util",
  type = "SCES",
  alpha = 1, beta = beta.laborer, es = es.prod,
  "prod1", "prod2"
)

dst.capitalOwner &lt;- node_new("util",
  type = "SCES",
  alpha = 1, beta = beta.capitalOwner, es = es.prod,
  "prod1", "prod2"
)

dst.government &lt;- node_new("util",
  type = "SCES",
  alpha = 1, beta = beta.government, es = es.prod,
  "prod1", "prod2"
)

ge &lt;- sdm2(
  A = list(dst.firm1, dst.firm2, dst.laborer, dst.capitalOwner, dst.government),
  B = diag(c(1, 1, 0, 0, 0)),
  S0Exg = matrix(c(
    NA, NA, NA, NA, NA,
    NA, NA, NA, NA, NA,
    NA, NA, 100, NA, NA,
    NA, NA, NA, 100, NA,
    NA, NA, NA, NA, 100
  ), 5, 5, TRUE),
  names.commodity = c("prod1", "prod2", "lab", "cap", "tax"),
  names.agent = c("firm1", "firm2", "laborer", "capitalOwner", "government"),
  numeraire = "lab"
)

ge$p
ge$z
ge$D
ge$S
addmargins(ge$DV)
addmargins(ge$SV)

</code></pre>

<hr>
<h2 id='gemTax_QuasilinearPreference_4_4'>A General Equilibrium Model with Tax and Quasilinear Utility Functions.</h2><span id='topic+gemTax_QuasilinearPreference_4_4'></span>

<h3>Description</h3>

<p>This model is essentially a pure exchange economy.
The model contains 4 types of commodities (i.e. corn, iron, taxed iron and tax payment receipts) and 4 agents (i.e. consumer 1, consumer 2, a firm and the government).
Consumer 1 has corn and the utility function is x1 + beta1 * (alpha1 * x3 - 0.5 * x3^2) wherein x1 is corn and x3 is taxed iron.
Consumer 2 has iron and the utility function is x1 + beta2 * (alpha2 * x2 - 0.5 * x2^2) wherein x1 is corn and x2 is iron.
Consumer 1 (i.e. the iron demander) wants to buy iron from consumer 2 (i.e. the iron supplier) and the government will tax the transaction.
The firm (i.e. a tax agency) inputs iron and tax payment receipts (similar to tax stamp) to output taxed iron,
and due to government taxation requirements consumer 1 have to buy taxed iron from the firm and consumer 2 have to sell iron through the firm.
Government has tax payment receipts and the utility function is x1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemTax_QuasilinearPreference_4_4(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemTax_QuasilinearPreference_4_4_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
tax.rate &lt;- 1

beta1 &lt;- 0.05
alpha1 &lt;- 3 / beta1 + 60

iron.endowment &lt;- 100
beta2 &lt;- 0.05
alpha2 &lt;- iron.endowment - 60 + (3 / beta2)

ge &lt;- sdm2(
  A = function(state) {
    a1 &lt;- QL_demand(
      w = state$w[1],
      p = c(state$p[1], state$p[3]),
      alpha = alpha1, beta = beta1,
      type = "quadratic2"
    )
    a1 &lt;- c(a1[1], 0, a1[2], 0)

    a2 &lt;- QL_demand(
      w = state$w[2],
      p = state$p[1:2],
      alpha = alpha2, beta = beta2,
      type = "quadratic2"
    )
    a2 &lt;- c(a2, 0, 0)

    a.firm &lt;- c(0, 1, 0, tax.rate * state$p[2] / state$p[4])

    a.gov &lt;- c(1, 0, 0, 0)

    cbind(a1, a2, a.firm, a.gov)
  },
  B = matrix(c(
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 1, 0,
    0, 0, 0, 0
  ), 4, 4, TRUE),
  S0Exg = matrix(c(
    1000, NA, NA, NA,
    NA, iron.endowment, NA, NA,
    NA, NA, NA, NA,
    NA, NA, NA, 1
  ), 4, 4, TRUE),
  names.commodity = c("corn", "iron", "taxed.iron", "tax"),
  names.agent = c("consumer1", "consumer2", "firm", "gov"),
  numeraire = "corn",
  priceAdjustmentVelocity = 0.05
)

ge$p
ge$D
ge$S
addmargins(ge$DV)
addmargins(ge$SV)

ge.x &lt;- ge$D[3, 1]
ge.pl &lt;- ge$p[2]
ge.ph &lt;- ge$p[3]
plot(function(x) (alpha1 - x) * beta1, 0, alpha1,
  xlim = c(0, 100), ylim = c(0, 6), xlab = "iron", ylab = "price"
)
curve((alpha2 - iron.endowment + x) * beta2, 0,
  alpha1,
  add = TRUE
)
grid()
points(ge.x, ge.ph, col = "red", pch = 20) # pch=8
points(ge.x, ge.pl, col = "red", pch = 20)

polygon(c(0, ge.x, ge.x, 0), c(ge.ph, ge.ph, ge.pl, ge.pl))
segments(0, 3, x1 = 60, y1 = 3, col = "red")
text(c(0, ge.x, ge.x, 0) + 3, c(
  ge.ph + 0.3, ge.ph + 0.3,
  ge.pl - 0.3, ge.pl - 0.3
), c("A", "B", "C", "D"))
text(c(3, ge.x + 3, 60), 3.3, c("E", "F", "G"))

u.consumer1 &lt;- function(x) x[1] + beta1 * (alpha1 * x[2] - 0.5 * x[2]^2)
u.consumer2 &lt;- function(x) x[1] + beta2 * (alpha2 * x[2] - 0.5 * x[2]^2)

u.consumer1(ge$D[c(1, 3), 1]) + u.consumer2(ge$D[c(1:2), 2]) + ge$z[4]
# The value above is 1430 when the tax rate is 0.

</code></pre>

<hr>
<h2 id='gemTax_VAT_IncomeTax_5_4'>A General Equilibrium Model with Value-added Tax and Income Tax</h2><span id='topic+gemTax_VAT_IncomeTax_5_4'></span>

<h3>Description</h3>

<p>A general equilibrium model with value-added tax and income tax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemTax_VAT_IncomeTax_5_4(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemTax_VAT_IncomeTax_5_4_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
vat.rate &lt;- 0.2 # value-added tax rate
income.tax.rate &lt;- 0.2

dst.manu &lt;- node_new("output",
                     type = "FIN",
                     rate = c(5 / 6, vat.rate),
                     "cc1", "vat"
)
node_set(dst.manu, "cc1",
         type = "SCES",
         es = 0.5, alpha = 1,
         beta = c(0.25, 0.75),
         "lab", "cap"
)

dst.serv &lt;- node_new("output",
                     type = "FIN",
                     rate = c(5 / 6, vat.rate),
                     "cc1", "vat"
)
node_set(dst.serv, "cc1",
         type = "SCES",
         es = 0.5, alpha = 1,
         beta = c(0.75, 0.25),
         "lab", "cap"
)

dst.household &lt;- node_new("util",
                          type = "SCES",
                          es = 0.5, alpha = 1,
                          beta = c(0.2, 0.8),
                          "manu", "serv"
)

dst.government &lt;- node_new("util",
                           type = "SCES",
                           es = 0.5, alpha = 1,
                           beta = c(0.5, 0.5),
                           "manu", "serv"
)

dstl &lt;- list(dst.manu, dst.serv, dst.household, dst.government)

ge &lt;- sdm2(
  A = dstl,
  B = diag(c(1, 1, 0, 0), 5, 4),
  S0Exg = matrix(c(
    NA, NA, NA, NA,
    NA, NA, NA, NA,
    NA, NA, 360 * (1 - income.tax.rate), 360 * income.tax.rate,
    NA, NA, 240 * (1 - income.tax.rate), 240 * income.tax.rate,
    NA, NA, NA, 120
  ), 5, 4, TRUE),
  names.commodity = c("manu", "serv", "lab", "cap", "vat"),
  names.agent = c("manu", "serv", "household", "government"),
  numeraire = "lab"
)

ge$p
ge$z
addmargins(ge$DV)
addmargins(ge$SV)

## VAT rate reduction
dst.manu$rate &lt;- dst.serv$rate &lt;- c(5 / 6, vat.rate = 0.1)

ge.new &lt;- sdm2(
  A = dstl,
  B = diag(c(1, 1, 0, 0), 5, 4),
  S0Exg = matrix(c(
    NA, NA, NA, NA,
    NA, NA, NA, NA,
    NA, NA, 360 * (1 - income.tax.rate), 360 * income.tax.rate,
    NA, NA, 240 * (1 - income.tax.rate), 240 * income.tax.rate,
    NA, NA, NA, 120
  ), 5, 4, TRUE),
  names.commodity = c("manu", "serv", "lab", "cap", "vat"),
  names.agent = c("manu", "serv", "household", "government"),
  numeraire = "lab"
)

ge.new$p
ge.new$z
addmargins(ge.new$DV)
addmargins(ge.new$SV)

</code></pre>

<hr>
<h2 id='gemTechnologyProgress_PopulationGrowth'>Some General Equilibrium Models with Technology Progress and Population Growth</h2><span id='topic+gemTechnologyProgress_PopulationGrowth'></span>

<h3>Description</h3>

<p>Some examples illustrating technology Progress and population growth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemTechnologyProgress_PopulationGrowth(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemTechnologyProgress_PopulationGrowth_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
#### a financial sequential model
gr.e &lt;- 0.03 # the population growth rate
tpr &lt;- 0.02 # the rate of technological progress
gr &lt;- (1 + gr.e) * (1 + tpr) - 1
eis &lt;- 0.8 # the elasticity of intertemporal substitution
Gamma.beta &lt;- 0.8 # the subjective discount factor
yield.rate &lt;- (1 + gr)^(1 / eis - 1) / Gamma.beta - 1 # the dividend rate
y1 &lt;- 143.18115 # the initial product supply

dst.firm &lt;- node_new("output",
  type = "FIN",
  rate = c(1, dividend.rate = yield.rate),
  "cc1", "equity.share"
)
node_set(dst.firm, "cc1",
  type = "CD",
  alpha = 2, beta = c(0.5, 0.5),
  "prod", "cc1.1"
)
node_set(dst.firm, "cc1.1",
  type = "Leontief", a = 1,
  "lab"
)

dst.laborer &lt;- node_new("util",
  type = "Leontief", a = 1,
  "prod"
)

dst.shareholder &lt;- Clone(dst.laborer)

ge &lt;- sdm2(
  A = list(dst.firm, dst.laborer, dst.shareholder),
  B = diag(c(1, 0, 0)),
  S0Exg = {
    S0Exg &lt;- matrix(NA, 3, 3)
    S0Exg[2, 2] &lt;- S0Exg[3, 3] &lt;- 100 / (1 + gr.e)
    S0Exg
  },
  names.commodity = c("prod", "lab", "equity.share"),
  names.agent = c("firm", "laborer", "shareholder"),
  numeraire = "prod",
  maxIteration = 1,
  numberOfPeriods = 20,
  policy = list(function(time, A) {
    node_set(A[[1]], "cc1.1", a = 1 / (1 + tpr)^(time - 1))
  }, policyMarketClearingPrice),
  z0 = c(y1, 0, 0),
  GRExg = gr.e,
  ts = TRUE
)

matplot(growth_rate(ge$ts.p), type = "l")
matplot(growth_rate(ge$ts.z), type = "l")
ge$ts.z

## a timeline model
np &lt;- 5 # the number of economic periods.

n &lt;- 2 * np - 1 # the number of commodity kinds
m &lt;- np # the number of agent kinds

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:(np - 1)))
names.agent &lt;- c(paste0("firm", 1:(np - 1)), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:(np - 1)), "consumer"] &lt;- 100 * (1 + gr.e)^(0:(np - 2))
S0Exg["prod1", "consumer"] &lt;- y1

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}

dstl.firm &lt;- list()
for (k in 1:(np - 1)) {
  dstl.firm[[k]] &lt;- node_new(
    "prod",
    type = "CD",
    alpha = 2, beta = c(0.5, 0.5),
    paste0("prod", k), "cc1"
  )
  node_set(dstl.firm[[k]], "cc1",
           type = "Leontief", a = 1 / ((1 + tpr)^(k - 1)),
           paste0("lab", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "CES",
  alpha = 1, beta = prop.table(Gamma.beta^(1:np)), es = eis,
  paste0("prod", 1:np)
)

ge &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "prod1",
  maxIteration = 1,
  numberOfPeriods = 40,
  ts = TRUE,
  policy = list(
    makePolicyTailAdjustment(ind = c(np - 1, np), gr = gr),
    policyMarketClearingPrice
  )
)

ge$z
ge$D
ge$S
ge$p[1:3] / ge$p[2:4] - 1 # the steady-state equilibrium return rate
sserr(eis = eis, Gamma.beta = Gamma.beta, gr = gr) # the steady-state equilibrium return rate

## a financial time-circle model
zeta &lt;- (1 + gr)^np # the ratio of repayments to loans

n &lt;- 2 * np + 1 # the number of commodity kinds
m &lt;- np + 1 # the number of agent kinds

names.commodity &lt;- c(paste0("prod", 1:np), paste0("lab", 1:np), "claim")
names.agent &lt;- c(paste0("firm", 1:np), "consumer")

# the exogenous supply matrix.
S0Exg &lt;- matrix(NA, n, m, dimnames = list(names.commodity, names.agent))
S0Exg[paste0("lab", 1:np), "consumer"] &lt;- 100 * (1 + gr.e)^(0:(np - 1))
S0Exg["claim", "consumer"] &lt;- 100

# the output coefficient matrix.
B &lt;- matrix(0, n, m, dimnames = list(names.commodity, names.agent))
for (k in 1:(np - 1)) {
  B[paste0("prod", k + 1), paste0("firm", k)] &lt;- 1
}
B["prod1", paste0("firm", np)] &lt;- 1 / zeta

dstl.firm &lt;- list()
for (k in 1:np) {
  dstl.firm[[k]] &lt;- node_new("output",
                             type = "FIN", rate = c(1, yield.rate),
                             "cc1", "claim"
  )
  node_set(dstl.firm[[k]], "cc1",
           type = "CD", alpha = 2,
           beta = c(0.5, 0.5),
           paste0("prod", k), "cc1.1"
  )
  node_set(dstl.firm[[k]], "cc1.1",
           type = "Leontief", a = 1 / ((1 + tpr)^(k - 1)),
           paste0("lab", k)
  )
}

dst.consumer &lt;- node_new(
  "util",
  type = "CES", es = 1,
  alpha = 1, beta = prop.table(rep(1, np)),
  paste0("prod", 1:np)
)

ge &lt;- sdm2(
  A = c(dstl.firm, dst.consumer),
  B = B,
  S0Exg = S0Exg,
  names.commodity = names.commodity,
  names.agent = names.agent,
  numeraire = "prod1",
  ts = TRUE
)

ge$z
growth_rate(ge$z)
ge$D
ge$S

</code></pre>

<hr>
<h2 id='gemTemporaryEquilibriumPath'>Some Examples of Temporary Equilibrium Paths</h2><span id='topic+gemTemporaryEquilibriumPath'></span>

<h3>Description</h3>

<p>Some examples of temporary equilibrium paths.
The temporary equilibrium path consists of a series of temporary equilibria.
Each temporary equilibrium achieves market clearing, and these markets may include futures markets in addition to spot markets.
An instantaneous equilibrium path is a temporary equilibrium path that only includes spot markets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemTemporaryEquilibriumPath(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemTemporaryEquilibriumPath_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Grandmont, J.M. (1977). Temporary General Equilibrium Theory. Econometrica 45, 535-572.
</p>


<h3>See Also</h3>


<p><code><a href="#topic+policyMarketClearingPrice">policyMarketClearingPrice</a></code>

</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### A pure exchange economy.
## Consumers 1 and 2 each supply 50 units of payoff each period.
## Consumers have limited foresight into the future and always expect
## that the supply of consumer 1 will be 50 and the supply of
## consumer 2 will be 40 in the next period.
dst.consumer1 &lt;- node_new("util",
  type = "SCES", es = 2,
  alpha = 1, beta = c(0.5, 0.5),
  "payoff1", "payoff2"
)

dst.consumer2 &lt;- node_new("util",
  type = "SCES", es = 1,
  alpha = 1, beta = c(0.5, 0.5),
  "payoff1", "payoff2"
)

result &lt;- list()
for (time in 1:20) {
  if (time == 1) {
    S0Exg &lt;- matrix(c(
      50, 50,
      50, 40
    ), 2, 2, TRUE)
  } else {
    S0Exg &lt;- rbind(ge$D[2, ] + c(0, 10), c(50, 40))
  }

  ge &lt;- sdm2(
    A = list(dst.consumer1, dst.consumer2),
    B = matrix(0, 2, 2),
    S0Exg = S0Exg,
    names.commodity = c("payoff1", "payoff2"),
    names.agent = c("consumer1", "consumer2"),
    numeraire = "payoff1"
  )

  result[[time]] &lt;- ge
}

sapply(result, \(x) x$p)
sapply(result, \(x) x$z)
# lapply(result, \(x) x$D)
# lapply(result, \(x) x$S)

#### An economy with production.
dst.consumer &lt;- node_new("util",
  type = "CD",
  alpha = 1,
  beta = c(1 / 3, 2 / 3), # beta = c(1/2, 1/2)
  "prod1", "prod2"
)

dst.firm &lt;- node_new("prod2",
  type = "CD", alpha = 2, beta = c(0.5, 0.5),
  "prod1", "lab"
)

result &lt;- list()
for (time in 1:20) {
  if (time == 1) {
    S0Exg &lt;- matrix(c(
      10, 0,
      0, NA,
      100, 0
    ), 3, 2, TRUE)
  } else {
    S0Exg &lt;- matrix(c(
      ge$D[2, 1], 0,
      0, NA,
      100, 0
    ), 3, 2, TRUE)
  }

  ge &lt;- sdm2(
    A = list(dst.consumer, dst.firm),
    B = matrix(c(
      0, 0,
      0, 1,
      0, 0
    ), 3, 2, TRUE),
    S0Exg = S0Exg,
    names.commodity = c("prod1", "prod2", "lab"),
    names.agent = c("consumer", "firm"),
    numeraire = "prod1"
  )

  result[[time]] &lt;- ge
}


sapply(result, \(x) x$p)
sapply(result, \(x) x$z)
# lapply(result, \(x) x$D)
# lapply(result, \(x) x$S)

##
result &lt;- list()
last.output &lt;- 10
for (time in 1:30) {
  if (time == 1) {
    S0Exg &lt;- matrix(c(
      10, 0,
      0, last.output,
      100, 0
    ), 3, 2, TRUE)
  } else {
    S0Exg &lt;- rbind(
      c(ge$D[2, 1], max(ge$z[2] - last.output, 0)),
      c(0, last.output),
      c(100, 0)
    )

    last.output &lt;- ge$z[2]
  }

  ge &lt;- sdm2(
    A = list(dst.consumer, dst.firm),
    B = matrix(c(
      0, 0,
      0, 1,
      0, 0
    ), 3, 2, TRUE),
    # B = matrix(0, 3, 2),
    S0Exg = S0Exg,
    names.commodity = c("prod1", "prod2", "lab"),
    names.agent = c("consumer", "firm"),
    numeraire = "prod1"
  )

  result[[time]] &lt;- ge
}
sapply(result, \(x) x$p)
sapply(result, \(x) x$z)
# lapply(result, \(x) x$D)
# lapply(result, \(x) x$S)

</code></pre>

<hr>
<h2 id='gemTwoCountry_Bond_7_4'>An Example of Two-Country Economy with Bond</h2><span id='topic+gemTwoCountry_Bond_7_4'></span>

<h3>Description</h3>

<p>A general equilibrium example of two-country economy with bond.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemTwoCountry_Bond_7_4(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemTwoCountry_Bond_7_4_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A general equilibrium.
</p>


<h3>See Also</h3>

<p><cite><a href="#topic+gemTwoCountry_Tariff_9_5">gemTwoCountry_Tariff_9_5</a></cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
es.DFProd &lt;- 0.8 # the substitution elasticity between domestic and foreign products
es.CL &lt;- 0.8 # the substitution elasticity between capital and labor

dst.firm.CHN &lt;- node_new("output",
  type = "SCES", alpha = 1, beta = c(0.78, 0.22), es = es.CL,
  "lab.CHN", "cap.CHN"
)

dst.household.CHN &lt;- node_new("util",
  type = "FIN", rate = c(1,  outbound.investment.rate = 0.028),
  "cc1", "bond.ROW"
)
node_set(dst.household.CHN, "cc1",
  type = "SCES", alpha = 1, beta = c(0.93, 0.07), es = es.DFProd,
  "prod.CHN", "prod.ROW"
)

node_plot(dst.household.CHN)

dst.firm.ROW &lt;- node_new("output",
  type = "SCES", alpha = 1, beta = c(0.75, 0.25), es = es.CL,
  "lab.ROW", "cap.ROW"
)

dst.household.ROW &lt;- node_new("util",
  type = "SCES", alpha = 1, beta = c(0.02, 0.98), es = es.DFProd,
  "prod.CHN", "prod.ROW"
)

dstl &lt;- list(dst.firm.CHN, dst.household.CHN, dst.firm.ROW, dst.household.ROW)

ge &lt;- sdm2(dstl,
  names.commodity = c(
    "prod.CHN", "lab.CHN", "cap.CHN",
    "prod.ROW", "lab.ROW", "cap.ROW", "bond.ROW"
  ),
  names.agent = c(
    "firm.CHN", "household.CHN",
    "firm.ROW", "household.ROW"
  ),
  B = {
    tmp &lt;- matrix(0, 7, 4, TRUE)
    tmp[1, 1] &lt;- tmp[4, 3] &lt;- 1
    tmp
  },
  S0Exg = {
    tmp &lt;- matrix(NA, 7, 4, TRUE)
    tmp[2, 2] &lt;- 53 # the supply of lab.CHN
    tmp[3, 2] &lt;- 15 # the supply of cap.CHN
    tmp[5, 4] &lt;- 240 # the supply of lab.ROW
    tmp[6, 4] &lt;- 77 # the supply of cap.ROW
    tmp[7, 4] &lt;- 2 # the supply of bond.ROW
    tmp
  },
  numeraire = "lab.CHN"
)

ge$p
ge$z

# Determine the parameters in the
# example based on an input-output table.
IT &lt;- matrix(c(
  0, 61.44, 0, 6.498,
  53, 0, 0, 0,
  14.94, 0, 0, 0,
  0, 4.647, 0, 320,
  0, 0, 242.9, 0,
  0, 0, 81.74, 0,
  0, 1.85, 0, 0
), 7, 4, TRUE)

OT &lt;- matrix(c(
  67.94, 0, 0, 0,
  0, 53, 0, 0,
  0, 14.94, 0, 0,
  0, 0, 324.64, 0,
  0, 0, 0, 242.9,
  0, 0, 0, 81.74,
  0, 0, 0, 1.85
), 7, 4, TRUE)

dimnames(IT) &lt;- dimnames(OT) &lt;- list(
  c("prod.CHN", "lab.CHN", "cap.CHN", "prod.ROW", "lab.ROW", "cap.ROW", "bond.ROW"),
  c("firm.CHN", "household.CHN", "firm.ROW", "household.ROW")
)

es.DFProd &lt;- 0.8 # the substitution elasticity between domestic and foreign products
es.CL &lt;- 0.8 # the substitution elasticity between capital and labor

dst.firm.CHN &lt;- node_new("output",
                         type = "SCES",
                         alpha = OT["prod.CHN", "firm.CHN"] /
                           sum(IT[c("lab.CHN", "cap.CHN"), "firm.CHN"]),
                         beta = prop.table(IT[c("lab.CHN", "cap.CHN"), "firm.CHN"]),
                         es = es.CL,
                         "lab.CHN", "cap.CHN"
)

# the amount of outbound investment corresponding to
# each unit of composite commodity 1 used by household.
outbound.investment.rate &lt;- IT["bond.ROW", "household.CHN"] /
  sum(IT[c("prod.CHN", "prod.ROW"), "household.CHN"])

dst.household.CHN &lt;- node_new("util",
                             type = "FIN",
                             rate = c(1, outbound.investment.rate),
                             "cc1", "bond.ROW"
)

node_set(dst.household.CHN, "cc1",
         type = "SCES", alpha = 1,
         beta = prop.table(IT[c("prod.CHN", "prod.ROW"), "household.CHN"]),
         es = es.DFProd,
         "prod.CHN", "prod.ROW"
)

dst.firm.ROW &lt;- node_new("output",
                         type = "SCES", alpha = 1,
                         beta = prop.table(IT[c("lab.ROW", "cap.ROW"), "firm.ROW"]),
                         es = es.CL,
                         "lab.ROW", "cap.ROW"
)

dst.household.ROW &lt;- node_new("util",
                             type = "SCES", alpha = 1,
                             beta = prop.table(IT[c("prod.CHN", "prod.ROW"), "household.ROW"]),
                             es = es.DFProd,
                             "prod.CHN", "prod.ROW"
)

dstl &lt;- list(dst.firm.CHN, dst.household.CHN, dst.firm.ROW, dst.household.ROW)

ge &lt;- sdm2(dstl,
  names.commodity = c(
    "prod.CHN", "lab.CHN", "cap.CHN",
    "prod.ROW", "lab.ROW", "cap.ROW", "bond.ROW"
  ),
  names.agent = c(
    "firm.CHN", "household.CHN",
    "firm.ROW", "household.ROW"
  ),
  B = {
    tmp &lt;- matrix(0, 7, 4, TRUE)
    tmp[1, 1] &lt;- tmp[4, 3] &lt;- 1
    tmp
  },
  S0Exg = {
    tmp &lt;- matrix(NA, 7, 4, TRUE)
    tmp[2, 2] &lt;- OT["lab.CHN", "household.CHN"]
    tmp[3, 2] &lt;- OT["cap.CHN", "household.CHN"]
    tmp[5, 4] &lt;- OT["lab.ROW", "household.ROW"]
    tmp[6, 4] &lt;- OT["cap.ROW", "household.ROW"]
    tmp[7, 4] &lt;- OT["bond.ROW", "household.ROW"]
    tmp
  },
  numeraire = "lab.CHN"
)

ge$p
ge$z

</code></pre>

<hr>
<h2 id='gemTwoCountry_RealExchangeRateIndex_7_4'>Calculating Real Exchange Rate Index</h2><span id='topic+gemTwoCountry_RealExchangeRateIndex_7_4'></span>

<h3>Description</h3>

<p>Some examples of calculating the real exchange rate index in a two-country economy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemTwoCountry_RealExchangeRateIndex_7_4(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemTwoCountry_RealExchangeRateIndex_7_4_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real exchange rate index.
</p>


<h3>See Also</h3>

<p><cite><a href="#topic+gemTwoCountry_Bond_7_4">gemTwoCountry_Bond_7_4</a></cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# es.DFProd is the substitution elasticity between domestic and foreign products.
makeDstl &lt;- function(es.DFProd = 0.5,
                     alpha.firm.CHN = 1,
                     beta.household.CHN = c(0.75, 0.25),
                     outbound.investment.rate = 0.25) {
  es.CL &lt;- 0.8 # substitution elasticity between capital and labor

  dst.firm.CHN &lt;- node_new("output",
    type = "SCES", alpha = alpha.firm.CHN, beta = c(0.75, 0.25), es = es.CL,
    "lab.CHN", "cap.CHN"
  )

  dst.household.CHN &lt;- node_new("util",
    type = "FIN", rate = c(1, outbound.investment.rate),
    "cc1", "bond.ROW"
  ) # 0.1 is the amount of foreign investment corresponding to
  # each unit of cc1 (i.e. composite commodity 1).

  node_set(dst.household.CHN, "cc1",
    type = "SCES", alpha = 1, beta = beta.household.CHN, es = es.DFProd,
    "prod.CHN", "prod.ROW"
  )

  node_plot(dst.household.CHN)

  dst.firm.ROW &lt;- node_new("output",
    type = "SCES", alpha = 1, beta = c(0.5, 0.5), es = es.CL,
    "lab.ROW", "cap.ROW"
  )

  dst.household.ROW &lt;- node_new("util",
    type = "SCES", alpha = 1, beta = c(0.05, 0.95), es = es.DFProd,
    "prod.CHN", "prod.ROW"
  )

  list(dst.firm.CHN, dst.household.CHN, dst.firm.ROW, dst.household.ROW)
}

dstl &lt;- makeDstl()

SExg &lt;- {
  tmp &lt;- matrix(NA, 7, 4, TRUE)
  tmp[2, 2] &lt;- 30 # the supply of lab.CHN
  tmp[3, 2] &lt;- 10 # the supply of cap.CHN
  tmp[5, 4] &lt;- 156 # the supply of lab.ROW
  tmp[6, 4] &lt;- 156 # the supply of cap.ROW
  tmp[7, 4] &lt;- 8 # the supply of bond.ROW
  tmp
}

f &lt;- function(A = dstl,
              S0Exg = SExg) {
  sdm2(
    A = A,
    names.commodity = c(
      "prod.CHN", "lab.CHN", "cap.CHN",
      "prod.ROW", "lab.ROW", "cap.ROW", "bond.ROW"
    ),
    names.agent = c(
      "firm.CHN", "household.CHN",
      "firm.ROW", "household.ROW"
    ),
    B = {
      tmp &lt;- matrix(0, 7, 4, TRUE)
      tmp[1, 1] &lt;- tmp[4, 3] &lt;- 1
      tmp
    },
    S0Exg = S0Exg,
    numeraire = "lab.CHN"
  )
}

ge.benchmark &lt;- f()

## real exchange rate index
reri &lt;- function(ge.new, ge.benchmark) {
  weight.CHN &lt;- rowSums(ge.benchmark$SV)[c("prod.CHN", "lab.CHN", "cap.CHN")]
  weight.ROW &lt;- rowSums(ge.benchmark$SV)[c("prod.ROW", "lab.ROW", "cap.ROW")]

  weighted.mean(ge.new$p[c("prod.ROW", "lab.ROW", "cap.ROW")], weight.ROW) /
    weighted.mean(ge.new$p[c("prod.CHN", "lab.CHN", "cap.CHN")], weight.CHN)
}


## technology progress in CHN
reri(f(A = makeDstl(es.DFProd = 5, alpha.firm.CHN = 2)), ge.benchmark)
reri(f(A = makeDstl(es.DFProd = 0.5, alpha.firm.CHN = 2)), ge.benchmark)

## labor supply change in CHN
SExg.LSC &lt;- SExg
SExg.LSC[2, 2] &lt;- SExg.LSC[2, 2] * 2

reri(f(A = makeDstl(es.DFProd = 5), S0Exg = SExg.LSC), ge.benchmark)

reri(f(S0Exg = SExg.LSC), ge.benchmark)

## capital accumulation in CHN
SExg.CA &lt;- SExg
SExg.CA[3, 2] &lt;- SExg.CA[3, 2] * 3

reri(f(A = makeDstl(es.DFProd = 5), S0Exg = SExg.CA), ge.benchmark)

reri(f(S0Exg = SExg.CA), ge.benchmark)

## preference change in China
reri(f(A = makeDstl(es.DFProd = 5, beta.household.CHN = c(0.5, 0.5))), ge.benchmark)
reri(f(A = makeDstl(beta.household.CHN = c(0.5, 0.5))), ge.benchmark)

## outbound-investment-rate change in China
reri(f(A = makeDstl(es.DFProd = 5, outbound.investment.rate = 0.1)), ge.benchmark)
reri(f(A = makeDstl(outbound.investment.rate = 0.1)), ge.benchmark)

</code></pre>

<hr>
<h2 id='gemTwoCountry_Tariff_9_5'>An Example of Two-Country Economy with Tariff</h2><span id='topic+gemTwoCountry_Tariff_9_5'></span>

<h3>Description</h3>

<p>A general equilibrium example of two-country economy with tariff.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemTwoCountry_Tariff_9_5(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemTwoCountry_Tariff_9_5_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A general equilibrium.
</p>


<h3>See Also</h3>

<p><cite><a href="#topic+gemTwoCountry_Bond_7_4">gemTwoCountry_Bond_7_4</a></cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
es.DFProd &lt;- 0.8 # substitution elasticity between domestic and foreign products
es.CL &lt;- 0.8 # substitution elasticity between capital and labor

dst.firm.CHN &lt;- node_new("output",
  type = "SCES", alpha = 1, beta = c(0.78, 0.22), es = es.CL,
  "lab.CHN", "cap.CHN"
)

dst.household.CHN &lt;- node_new("util",
  type = "FIN", rate = c(1, outbound.investment.rate = 0.028),
  "cc1", "bond.ROW"
)

node_set(dst.household.CHN, "cc1",
  type = "SCES", alpha = 1, beta = c(0.93, 0.07), es = es.DFProd,
  "prod.CHN", "imported.prod.CHN"
)

node_plot(dst.household.CHN)

dst.foreign.trade.CHN &lt;- node_new("imported.product",
  type = "FIN",
  rate = c(1, 0.016),
  "prod.ROW", "tariff.CHN"
)

dst.firm.ROW &lt;- node_new("output",
  type = "SCES", alpha = 1, beta = c(0.75, 0.25), es = es.CL,
  "lab.ROW", "cap.ROW"
)

dst.household.ROW &lt;- node_new("util",
  type = "SCES", alpha = 1, beta = c(0.02, 0.98), es = es.DFProd,
  "prod.CHN", "prod.ROW"
)

dstl &lt;- list(
  dst.firm.CHN, dst.household.CHN, dst.foreign.trade.CHN,
  dst.firm.ROW, dst.household.ROW
)

ge &lt;- sdm2(dstl,
  names.commodity = c(
    "prod.CHN", "lab.CHN", "cap.CHN", "imported.prod.CHN", "tariff.CHN",
    "prod.ROW", "lab.ROW", "cap.ROW", "bond.ROW"
  ),
  names.agent = c(
    "firm.CHN", "household.CHN", "foreign.trade.CHN",
    "firm.ROW", "household.ROW"
  ),
  B = {
    tmp &lt;- matrix(0, 9, 5, TRUE)
    tmp[1, 1] &lt;- tmp[6, 4] &lt;- 1
    tmp[4, 3] &lt;- 1
    tmp
  },
  S0Exg = {
    tmp &lt;- matrix(NA, 9, 5, TRUE)
    tmp[2, 2] &lt;- 53 # the supply of lab.CHN
    tmp[3, 2] &lt;- 15 # the supply of cap.CHN
    tmp[5, 2] &lt;- 0.29 # the supply of tariff.CHN
    tmp[7, 5] &lt;- 240 # the supply of lab.ROW
    tmp[8, 5] &lt;- 77 # the supply of cap.ROW
    tmp[9, 5] &lt;- 2 # the supply of bond.ROW
    tmp
  },
  numeraire = "lab.CHN"
)

ge$p
ge$z

</code></pre>

<hr>
<h2 id='gemTwoCountryForeignExchangeRate_6_6'>Example 7.6 (Foreign Exchange Rate) in Li (2019)</h2><span id='topic+gemTwoCountryForeignExchangeRate_6_6'></span>

<h3>Description</h3>

<p>This is Example 7.6 in Li (2019), which illustrates foreign exchange rates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemTwoCountryForeignExchangeRate_6_6(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemTwoCountryForeignExchangeRate_6_6_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.firm1 &lt;- node_new("output",
  type = "FIN", rate = c(1, interest.rate = 0.1),
  "cc1", "money1"
)
node_set(dst.firm1, "cc1",
  type = "CD", alpha = 1,
  beta = c(0.5, 0.5),
  "iron", "lab1"
)

dst.firm2 &lt;- Clone(dst.firm1)
node_replace(dst.firm2, "money1", "money2")
node_replace(dst.firm2, "lab1", "lab2")
node_plot(dst.firm2)

dst.laborer1 &lt;- node_new("util",
  type = "FIN", rate = c(1, interest.rate = 0.1),
  "cc1", "money1"
)
node_set(dst.laborer1, "cc1",
  type = "Leontief", a = 1,
  "wheat"
)

dst.moneyOwner1 &lt;- Clone(dst.laborer1)

dst.laborer2 &lt;- Clone(dst.laborer1)
node_replace(dst.laborer2, "money1", "money2")

dst.moneyOwner2 &lt;- Clone(dst.laborer2)

ge &lt;- sdm2(
  A = list(
    dst.firm1, dst.laborer1, dst.moneyOwner1,
    dst.firm2, dst.laborer2, dst.moneyOwner2
  ),
  B = diag(c(1, 0, 0, 1, 0, 0)),
  S0Exg = {
    tmp &lt;- matrix(NA, 6, 6)
    tmp[2, 2] &lt;- 100
    tmp[3, 3] &lt;- 600
    tmp[5, 5] &lt;- 100
    tmp[6, 6] &lt;- 100
    tmp
  },
  names.commodity = c(
    "wheat", "lab1", "money1",
    "iron", "lab2", "money2"
  ),
  names.agent = c(
    "firm1", "laborer1", "moneyOwner1",
    "firm2", "laborer2", "moneyOwner2"
  ),
  numeraire = c("money1" = 0.1) # interest.rate
)

ge$p[6] / ge$p[3] # foreign exchange rate


</code></pre>

<hr>
<h2 id='gemTwoCountryPureExchange'>Some Examples of Two-Country Pure Exchange Economy</h2><span id='topic+gemTwoCountryPureExchange'></span>

<h3>Description</h3>

<p>Some general equilibrium examples of two-country pure exchange economy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemTwoCountryPureExchange(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemTwoCountryPureExchange_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A general equilibrium.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
es.DFProd &lt;- 0.8 # substitution elasticity between domestic and foreign products
technology.level.CHN &lt;- 0.9

dst.CHN &lt;- node_new("util",
  type = "SCES", alpha = 1, beta = c(0.5, 0.5), es = es.DFProd,
  "prod.CHN", "prod.USA"
)
node_set(dst.CHN, "prod.CHN",
  type = "Leontief", a = 1 / technology.level.CHN,
  "lab.CHN"
)
node_set(dst.CHN, "prod.USA",
  type = "Leontief", a = 1,
  "lab.USA"
)
node_plot(dst.CHN)

dst.USA &lt;- Clone(dst.CHN)

dstl &lt;- list(dst.CHN, dst.USA)

ge &lt;- sdm2(dstl,
  names.commodity = c("lab.CHN", "lab.USA"),
  names.agent = c("CHN", "USA"),
  B = matrix(0, 2, 2, TRUE),
  S0Exg = matrix(c(
    100, 0,
    0, 100
  ), 2, 2, TRUE),
  numeraire = "lab.CHN"
)
ge$p[2]
# the same as above
technology.level.CHN^(1 / es.DFProd - 1)

## supply change
geSC &lt;- sdm2(dstl,
  names.commodity = c("lab.CHN", "lab.USA"),
  names.agent = c("CHN", "USA"),
  B = matrix(0, 2, 2, TRUE),
  S0Exg = matrix(c(
    200, 0,
    0, 100
  ), 2, 2, TRUE),
  numeraire = "lab.CHN"
)
geSC$p[2]

## preference change
dst.CHN$beta &lt;- c(0.6, 0.4)
gePC &lt;- sdm2(dstl,
  names.commodity = c("lab.CHN", "lab.USA"),
  names.agent = c("CHN", "USA"),
  B = matrix(0, 2, 2, TRUE),
  S0Exg = matrix(c(
    100, 0,
    0, 100
  ), 2, 2, TRUE),
  numeraire = "lab.CHN"
)

gePC$p[2]

#### Add currencies to the example above.
interest.rate &lt;- 1e-4
es.DFProd &lt;- 0.8
technology.level.CHN &lt;- 0.9

prod_money.CHN &lt;- node_new("prod_money.CHN",
  type = "FIN", rate = c(1, interest.rate),
  "prod.CHN", "money.CHN"
)
node_set(prod_money.CHN, "prod.CHN",
  type = "Leontief", a = 1 / technology.level.CHN,
  "lab.CHN"
)

prod_money.USA &lt;- node_new("prod_money.USA",
  type = "FIN", rate = c(1, interest.rate),
  "prod.USA", "money.USA"
)
node_set(prod_money.USA, "prod.USA",
  type = "Leontief", a = 1,
  "lab.USA"
)

dst.CHN &lt;- node_new("util",
  type = "SCES", alpha = 1, beta = c(0.5, 0.5), es = es.DFProd,
  prod_money.CHN, prod_money.USA
)

dst.USA &lt;- Clone(dst.CHN)

dstl &lt;- list(dst.CHN, dst.USA)

ge &lt;- sdm2(dstl,
  names.commodity = c(
    "lab.CHN", "money.CHN",
    "lab.USA", "money.USA"
  ),
  names.agent = c("CHN", "USA"),
  B = matrix(0, 4, 2, TRUE),
  S0Exg = matrix(c(
    100, 0,
    100, 0,
    0, 100,
    0, 100
  ), 4, 2, TRUE),
  numeraire = c("money.CHN" = interest.rate)
)

ge$p["money.USA"] / ge$p["money.CHN"] # the exchange rate

#### supply change
geSC &lt;- sdm2(dstl,
  names.commodity = c(
    "lab.CHN", "money.CHN",
    "lab.USA", "money.USA"
  ),
  names.agent = c("CHN", "USA"),
  B = matrix(0, 4, 2, TRUE),
  S0Exg = matrix(c(
    200, 0,
    100, 0,
    0, 100,
    0, 100
  ), 4, 2, TRUE),
  numeraire = c("money.CHN" = interest.rate)
)
geSC$p["money.USA"] / geSC$p["money.CHN"]

## preference change
dst.CHN$beta &lt;- c(0.6, 0.4)
gePC &lt;- sdm2(dstl,
  names.commodity = c(
    "lab.CHN", "money.CHN",
    "lab.USA", "money.USA"
  ),
  names.agent = c("CHN", "USA"),
  B = matrix(0, 4, 2, TRUE),
  S0Exg = matrix(c(
    100, 0,
    100, 0,
    0, 100,
    0, 100
  ), 4, 2, TRUE),
  numeraire = c("money.CHN" = interest.rate)
)

gePC$p["money.USA"] / gePC$p["money.CHN"]

#### the exchange rate under a high substitution elasticity
#### between domestic and foreign products.
interest.rate &lt;- 1e-4
es.DFProd &lt;- 3
technology.level.CHN &lt;- 0.9

prod_money.CHN &lt;- node_new("prod_money.CHN",
  type = "FIN", rate = c(1, interest.rate),
  "prod.CHN", "money.CHN"
)
node_set(prod_money.CHN, "prod.CHN",
  type = "Leontief", a = 1 / technology.level.CHN,
  "lab.CHN"
)

prod_money.USA &lt;- node_new("prod_money.USA",
  type = "FIN", rate = c(1, interest.rate),
  "prod.USA", "money.USA"
)
node_set(prod_money.USA, "prod.USA",
  type = "Leontief", a = 1,
  "lab.USA"
)

dst.CHN &lt;- node_new("util",
  type = "SCES", alpha = 1, beta = c(0.5, 0.5), es = es.DFProd,
  prod_money.CHN, prod_money.USA
)

dst.USA &lt;- Clone(dst.CHN)

dstl &lt;- list(dst.CHN, dst.USA)

ge &lt;- sdm2(dstl,
  names.commodity = c(
    "lab.CHN", "money.CHN",
    "lab.USA", "money.USA"
  ),
  names.agent = c("CHN", "USA"),
  B = matrix(0, 4, 2, TRUE),
  S0Exg = matrix(c(
    100, 0,
    100, 0,
    0, 100,
    0, 100
  ), 4, 2, TRUE),
  numeraire = c("money.CHN" = interest.rate)
)

ge$p["money.USA"] / ge$p["money.CHN"] # the exchange rate

## supply change and high substitution elasticity
geSC &lt;- sdm2(dstl,
  names.commodity = c(
    "lab.CHN", "money.CHN",
    "lab.USA", "money.USA"
  ),
  names.agent = c("CHN", "USA"),
  B = matrix(0, 4, 2, TRUE),
  S0Exg = matrix(c(
    200, 0,
    100, 0,
    0, 100,
    0, 100
  ), 4, 2, TRUE),
  numeraire = c("money.CHN" = interest.rate)
)
geSC$p["money.USA"] / geSC$p["money.CHN"]


</code></pre>

<hr>
<h2 id='gemTwoCountryPureExchange_Bond'>Some Examples of Two-Country Pure Exchange Economy with Bond</h2><span id='topic+gemTwoCountryPureExchange_Bond'></span>

<h3>Description</h3>

<p>Some general equilibrium examples of two-country pure exchange economy with bond.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemTwoCountryPureExchange_Bond(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemTwoCountryPureExchange_Bond_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A general equilibrium.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
es.DFProd &lt;- 0.8 # substitution elasticity between domestic and foreign products
technology.level.CHN &lt;- 1
# the amount of outbound investment corresponding to each unit of consumption
outbound.investment.rate &lt;- 0.1

dst.consumption &lt;- node_new("consumption",
  type = "SCES", alpha = 1, beta = c(0.5, 0.5), es = es.DFProd,
  "prod.CHN", "prod.USA"
)
node_set(dst.consumption, "prod.CHN",
  type = "Leontief", a = 1 / technology.level.CHN,
  "lab.CHN"
)
node_set(dst.consumption, "prod.USA",
  type = "Leontief", a = 1,
  "lab.USA"
)
dst.CHN &lt;- node_new("CHN",
  type = "FIN", rate = c(1, outbound.investment.rate),
  dst.consumption, "bond.USA"
)
node_plot(dst.CHN)

dst.USA &lt;- Clone(dst.consumption)

dstl &lt;- list(dst.CHN, dst.USA)

ge &lt;- sdm2(dstl,
  names.commodity = c("lab.CHN", "lab.USA", "bond.USA"),
  names.agent = c("CHN", "USA"),
  B = matrix(0, 3, 2, TRUE),
  S0Exg = matrix(c(
    100, 0,
    0, 100,
    0, 100
  ), 3, 2, TRUE),
  numeraire = "lab.CHN"
)
ge$p[2]

#### Add currencies to the example above.
es.DFProd &lt;- 0.8
technology.level.CHN &lt;- 1
outbound.investment.rate &lt;- 0.1
interest.rate &lt;- 1e-4

prod_money.CHN &lt;- node_new("prod_money.CHN",
  type = "FIN", rate = c(1, interest.rate),
  "prod.CHN", "money.CHN"
)
node_set(prod_money.CHN, "prod.CHN",
  type = "Leontief", a = 1 / technology.level.CHN,
  "lab.CHN"
)

prod_money.USA &lt;- node_new("prod_money.USA",
  type = "FIN", rate = c(1, interest.rate),
  "prod.USA", "money.USA"
)
node_set(prod_money.USA, "prod.USA",
  type = "Leontief", a = 1,
  "lab.USA"
)

dst.CHN &lt;- node_new("CHN",
  type = "FIN",
  rate = c(
    1, outbound.investment.rate,
    outbound.investment.rate * interest.rate
  ),
  "consumption", "bond.USA", "money.USA"
)
node_set(dst.CHN, "consumption",
  type = "SCES", alpha = 1, beta = c(0.5, 0.5), es = es.DFProd,
  prod_money.CHN, prod_money.USA
)

node_plot(dst.CHN)

dst.USA &lt;- Clone(node_set(dst.CHN, "consumption"))
node_plot(dst.USA)

dstl &lt;- list(dst.CHN, dst.USA)

ge &lt;- sdm2(dstl,
  names.commodity = c(
    "lab.CHN", "money.CHN",
    "lab.USA", "money.USA",
    "bond.USA"
  ),
  names.agent = c("CHN", "USA"),
  B = matrix(0, 5, 2, TRUE),
  S0Exg = matrix(c(
    100, 0,
    100, 0,
    0, 100,
    0, 100,
    0, 100
  ), 5, 2, TRUE),
  numeraire = c("money.CHN" = interest.rate)
)

ge$p["money.USA"] / ge$p["money.CHN"] # the exchange rate

</code></pre>

<hr>
<h2 id='gemTwoIndustries_4_3'>A 4-by-3 Economy with Two Industries</h2><span id='topic+gemTwoIndustries_4_3'></span>

<h3>Description</h3>

<p>A 4-by-3 economy with two industries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gemTwoIndustries_4_3(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gemTwoIndustries_4_3_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ju, Jiandong, Justin Yifu Lin, Qing Liu, Kang Shi (2020) Structural Changes and the Real Exchange Rate Dynamics. Journal of International Money and Finance, Vol. 107, pp: 102192.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.manu &lt;- node_new("output",
  type = "SCES", es = 1,
  alpha = 1, beta = c(0.2, 0.8),
  "lab", "cap"
)

dst.serv &lt;- node_new("output",
  type = "SCES", es = 1,
  alpha = 1, beta = c(0.8, 0.2),
  "lab", "cap"
)

dst.consumer &lt;- node_new("util",
  type = "SCES", es = 1,
  alpha = 1, beta = c(0.5, 0.5),
  "manu", "serv"
)

dstl &lt;- list(dst.manu, dst.serv, dst.consumer)

S0Exg &lt;- matrix(c(
  NA, NA, NA,
  NA, NA, NA,
  NA, NA, 100,
  NA, NA, 100
), 4, 3, TRUE)

f &lt;- function(dstl, S0Exg) {
  sdm2(
    A = dstl,
    B = matrix(c(
      1, 0, 0,
      0, 1, 0,
      0, 0, 0,
      0, 0, 0
    ), 4, 3, TRUE),
    S0Exg = S0Exg,
    names.commodity = c("manu", "serv", "lab", "cap"),
    names.agent = c("manu", "serv", "consumer"),
    numeraire = c("manu")
  )
}

ge &lt;- f(dstl = dstl, S0Exg = S0Exg)

ge$D
ge$p

##
dstl2 &lt;- lapply(dstl, Clone)
dstl2[[1]]$alpha &lt;- 2

ge &lt;- f(dstl = dstl2, S0Exg = S0Exg)
ge$D
ge$p

##
S0Exg2 &lt;- S0Exg
S0Exg2[3, 3] &lt;- 200 # labor supply
ge &lt;- f(dstl = dstl, S0Exg = S0Exg2)
ge$D
ge$p

##
S0Exg3 &lt;- S0Exg
S0Exg3[4, 3] &lt;- 200 # capital supply
ge &lt;- f(dstl = dstl, S0Exg = S0Exg3)
ge$D
ge$p

##
dstl3 &lt;- lapply(dstl, Clone)
dstl3[[3]]$beta &lt;- c(0.2, 0.8)
ge &lt;- f(dstl = dstl3, S0Exg = S0Exg)
ge$D
ge$p

## exogenous wage rate
S0Exg4 &lt;- S0Exg
S0Exg4[3, 3] &lt;- 300 # labor supply

# Compute the price-control stationary state.
pcss &lt;- sdm2(
  A = dstl2,
  B = matrix(c(
    1, 0, 0,
    0, 1, 0,
    0, 0, 0,
    0, 0, 0
  ), 4, 3, TRUE),
  S0Exg = S0Exg4,
  names.commodity = c("manu", "serv", "lab", "cap"),
  names.agent = c("manu", "serv", "consumer"),
  numeraire = c("manu"),
  pExg = c(1, NA, 1, NA),
  maxIteration = 1,
  ts = TRUE
)

matplot(pcss$ts.z, type = "l")
matplot(pcss$ts.q, type = "l")
tail(pcss$ts.q)
pcss$p

</code></pre>

<hr>
<h2 id='growth_rate'>Compute the Growth Rate</h2><span id='topic+growth_rate'></span>

<h3>Description</h3>

<p>Compute the growth rates for a vector or each column of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth_rate(x, log = FALSE, first.na = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth_rate_+3A_x">x</code></td>
<td>
<p>a vector or a matrix.</p>
</td></tr>
<tr><td><code id="growth_rate_+3A_log">log</code></td>
<td>
<p>If log==TRUE, the logarithmic growth rate will be computed.</p>
</td></tr>
<tr><td><code id="growth_rate_+3A_first.na">first.na</code></td>
<td>
<p>If first.na==FALSE, the result doesn't contain the first NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector or a matrix consisting of growth rates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- matrix(1:8, 4, 2)
growth_rate(x)


</code></pre>

<hr>
<h2 id='iterate'>Iteration Function</h2><span id='topic+iterate'></span>

<h3>Description</h3>

<p>Iteration function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iterate(x, f, times = 100, tol = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iterate_+3A_x">x</code></td>
<td>
<p>the initial state vector.
If x has a name attribute, the names will be used to label the output matrix.</p>
</td></tr>
<tr><td><code id="iterate_+3A_f">f</code></td>
<td>
<p>a user-supplied function that computes the values of the next time.</p>
</td></tr>
<tr><td><code id="iterate_+3A_times">times</code></td>
<td>
<p>the iteration times.</p>
</td></tr>
<tr><td><code id="iterate_+3A_tol">tol</code></td>
<td>
<p>the tolerance for stopping calculation. If the canberra distance of the last two
state vectors is less than tol the calculation will stop.</p>
</td></tr>
<tr><td><code id="iterate_+3A_...">...</code></td>
<td>
<p>optional arguments passed to the f function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix consisting of state vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- c(1, 2)
f &lt;- function(x, a) prop.table(c(sum(x), a * prod(x)^(1 / 2)))
iterate(x, f, 100, a = 3)
iterate(x, f, 100, tol = 1e-5, a = 3)

#### Heron's method for finding square roots
x &lt;- 1
f &lt;- function(x, n) (x + n / x) / 2
iterate(x, f, 10, n = 5)

#### Find a root of the equation x^3-x-1==0.
x &lt;- 1.5
f &lt;- function(x) (x + 1)^(1 / 3)
iterate(x, f, 10)

####
x &lt;- c(1, 2, 3)
f &lt;- function(x) {
  n &lt;- length(x)
  sigma &lt;- seq(-1, 1, length.out = n)
  result &lt;- rep(NA, n)
  for (k in 1:n) result[k] &lt;- CES(sigma[k], 1, rep(1 / n, n), x, rep(1 / n, n))
  prop.table(result)
}
iterate(x, f, 100)

</code></pre>

<hr>
<h2 id='makeCountercyclicalProductTax'>Make a Countercyclical Product Tax Policy Function</h2><span id='topic+makeCountercyclicalProductTax'></span>

<h3>Description</h3>

<p>This function returns a countercyclical product tax policy function to accelerate convergence when calculating general equilibrium.
In some cases this tax policy with variable tax rates can stabilize the economy (see Li, 2019, section 9.4.5.4) .
When a firm's output is higher than the average output in previous periods, a tax is imposed on the firm to reduce the output of the product.
Tax revenue will be used for implicit public spending.
The way of taxation is to directly deduct a part of the supply of the firm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeCountercyclicalProductTax(agent = 1, time.win = c(100, Inf), span = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeCountercyclicalProductTax_+3A_agent">agent</code></td>
<td>
<p>a vector specifying the indices or names of firms to be taxed.</p>
</td></tr>
<tr><td><code id="makeCountercyclicalProductTax_+3A_time.win">time.win</code></td>
<td>
<p>the time window vector, i.e. a 2-vector specifying the start time and end time of policy implementation.</p>
</td></tr>
<tr><td><code id="makeCountercyclicalProductTax_+3A_span">span</code></td>
<td>
<p>a positive integer which indicates the number of periods when calculating the average output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A countercyclical product tax policy function.
</p>


<h3>See Also</h3>

<p>CGE::Example9.10.policy.tax
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ge &lt;- gemCanonicalDynamicMacroeconomic_4_3(
  numberOfPeriods = 1000
)

ge &lt;- gemCanonicalDynamicMacroeconomic_4_3(
  numberOfPeriods = 1000,
  policy = makeCountercyclicalProductTax(time.win = c(500, Inf))
)

</code></pre>

<hr>
<h2 id='makePolicyHeadAdjustment'>Make a Policy of Head Adjustment for a Timeline Model</h2><span id='topic+makePolicyHeadAdjustment'></span>

<h3>Description</h3>

<p>Make a policy of head adjustment for a timeline model.
Head adjustment refers to the adjustment of the initial product supply to a steady-state value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePolicyHeadAdjustment(ind, gr = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePolicyHeadAdjustment_+3A_ind">ind</code></td>
<td>
<p>a 4-column matrix or a numeric 4-vector that will be converted into a 4-column matrix.
In each row of the matrix, the first element corresponds to the index number of a type of product supplied in the first period,
the second element corresponds to the index number of its supplier,
the third element corresponds to the index number of the type of product supplied in the second period,
and the fourth element corresponds corresponds to the index number of its supplier.
</p>
<p>Head adjustments are usually made simultaneously with tail adjustments to compute the steady-state equilibrium path.
There is usually no need to make head adjustments alone.</p>
</td></tr>
<tr><td><code id="makePolicyHeadAdjustment_+3A_gr">gr</code></td>
<td>
<p>the growth rate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A policy, which is often used as an argument of the function sdm2.
</p>


<h3>See Also</h3>


<p><code><a href="#topic+makePolicyHeadTailAdjustment">makePolicyHeadTailAdjustment</a></code>;
<code><a href="#topic+makePolicyTailAdjustment">makePolicyTailAdjustment</a></code>

</p>

<hr>
<h2 id='makePolicyHeadTailAdjustment'>Make a Policy of Head and/or Tail Adjustment for a Timeline Model</h2><span id='topic+makePolicyHeadTailAdjustment'></span>

<h3>Description</h3>

<p>Make a policy of head and/or tail adjustment for a timeline model.
A timeline model is an intertemporal non-sequential model that includes production and a given initial product supply.
Head adjustment refers to the adjustment of the initial product supply to a steady-state value.
Similarly, tail adjustment refers to the adjustment of the share coefficient of the last period of the consumer in the timeline model in order to let the model run in a steady-state equilibrium path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePolicyHeadTailAdjustment(
  type = c("both", "tail", "head", "none"),
  gr = 0,
  np
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePolicyHeadTailAdjustment_+3A_type">type</code></td>
<td>
<p>a character string specifying the type of the policy, must be one of &quot;both&quot; (default), &quot;head&quot;, &quot;tail&quot; or &quot;none&quot;.
If type==&quot;none&quot;, NULL will be returned.</p>
</td></tr>
<tr><td><code id="makePolicyHeadTailAdjustment_+3A_gr">gr</code></td>
<td>
<p>the growth rate.</p>
</td></tr>
<tr><td><code id="makePolicyHeadTailAdjustment_+3A_np">np</code></td>
<td>
<p>the number of economic periods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A policy, which is often used as an argument of the function sdm2.
</p>


<h3>Note</h3>

<p>The statement policy = makePolicyHeadTailAdjustment(gr = gr, np = np) is equivalent to
policy = list( makePolicyHeadAdjustment(ind = c(1, np, 2, 1), gr = gr), makePolicyTailAdjustment(ind = c(np - 1, np), gr = gr) ).
</p>


<h3>See Also</h3>


<p><code><a href="#topic+gemIntertemporal_Dividend">gemIntertemporal_Dividend</a></code>;
<code><a href="#topic+gemIntertemporal_Money_Dividend_Example7.5.1">gemIntertemporal_Money_Dividend_Example7.5.1</a></code>

</p>

<hr>
<h2 id='makePolicyIncomeTax'>Make a Policy of Income Tax</h2><span id='topic+makePolicyIncomeTax'></span>

<h3>Description</h3>

<p>This function returns a policy function that redistributes the supplies of economic agents,
and the effect is equivalent to the collection of income tax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePolicyIncomeTax(agent, tax.rate, redistribution, time.win = c(1, Inf))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePolicyIncomeTax_+3A_agent">agent</code></td>
<td>
<p>a vector specifying the indices or names of taxed agents.</p>
</td></tr>
<tr><td><code id="makePolicyIncomeTax_+3A_tax.rate">tax.rate</code></td>
<td>
<p>a vector specifying the income tax rates for agents, which has the same length with the argument agent.</p>
</td></tr>
<tr><td><code id="makePolicyIncomeTax_+3A_redistribution">redistribution</code></td>
<td>
<p>a vector specifying the proportions of tax revenue received by agents, which has the same length with the argument agent.</p>
</td></tr>
<tr><td><code id="makePolicyIncomeTax_+3A_time.win">time.win</code></td>
<td>
<p>the time window vector, i.e. a 2-vector specifying the start time and end time of policy implementation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A policy function, which is often used as an argument of the function sdm2.
</p>


<h3>References</h3>

<p>Manuel Alejandro Cardenete, Ana-Isabel Guerra, Ferran Sancho (2012, ISBN: 9783642247453) Applied General Equilibrium: An Introduction. Springer-Verlag Berlin Heidelberg.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gemTax_5_4">gemTax_5_4</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## an exmaple of income tax (see Cardenete et al., 2012, Table 4.3)
dst.consumer1 &lt;- node_new("utility",
                          type = "CD",
                          alpha = 1,
                          beta = c(0.3, 0.7),
                          "prod1", "prod2"
)

dst.consumer2 &lt;- Clone(dst.consumer1)
dst.consumer2$beta &lt;- c(0.6, 0.4)

dst.firm1 &lt;- node_new("output",
                      type = "Leontief",
                      a = c(0.5, 0.2, 0.3),
                      "VA", "prod1", "prod2"
)
node_set(dst.firm1, "VA",
         type = "CD",
         alpha = 0.8^-0.8 * 0.2^-0.2,
         beta = c(0.8, 0.2),
         "lab", "cap"
)

dst.firm2 &lt;- Clone(dst.firm1)
node_set(dst.firm2, "output",
         a = c(0.25, 0.5, 0.25)
)
node_set(dst.firm2, "VA",
         alpha = 0.4^-0.4 * 0.6^-0.6,
         beta = c(0.4, 0.6)
)
dstl &lt;- list(dst.firm1, dst.firm2, dst.consumer1, dst.consumer2)
ge &lt;- sdm2(dstl,
  names.commodity = c("prod1", "prod2", "lab", "cap"),
  names.agent = c("firm1", "firm2", "consumer1", "consumer2"),
  numeraire = "lab",
  B = {
    tmp &lt;- matrix(0, 4, 4)
    tmp[1, 1] &lt;- 1
    tmp[2, 2] &lt;- 1
    tmp
  },
  S0Exg = {
    tmp &lt;- matrix(NA, 4, 4)
    tmp[3:4, 3] &lt;- c(30, 20)
    tmp[3:4, 4] &lt;- c(20, 5)
    tmp
  },
  maxIteration = 1,
  policy = makePolicyIncomeTax(
    agent = c(3, 4),
    tax.rate = c(0.2, 0.2),
    redistribution = c(0.5, 0.5)
  )
)


</code></pre>

<hr>
<h2 id='makePolicyMeanValue'>Make a Mean Value Policy Function</h2><span id='topic+makePolicyMeanValue'></span>

<h3>Description</h3>

<p>This function returns a mean value policy function with a given span to accelerate convergence when calculating general equilibrium.
We can observe the number of periods included in the economic cycle of the time series, and then set the number of periods as the parameter (i.e. span) of this function.
See <code><a href="#topic+policyMeanValue">policyMeanValue</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePolicyMeanValue(span = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePolicyMeanValue_+3A_span">span</code></td>
<td>
<p>a positive integer. When the time index is an integer multiple of span,
the mean value policy sets the current prices and supplies to the averages of the previous span-1 periods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A mean value policy function.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+policyMeanValue">policyMeanValue</a></code>
<code><a href="#topic+gemDualLinearProgramming">gemDualLinearProgramming</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## See the function gemDualLinearProgramming.
A &lt;- matrix(c(
  0, 0, 0, 1,
  8, 6, 1, 0,
  4, 2, 1.5, 0,
  2, 1.5, 0.5, 0
), 4, 4, TRUE)
B &lt;- matrix(c(
  60, 30, 20, 0,
  0, 0, 0, 0,
  0, 0, 0, 0,
  0, 0, 0, 0
), 4, 4, TRUE)
S0Exg &lt;- {
  S0Exg &lt;- matrix(NA, 4, 4)
  S0Exg[2:4, 4] &lt;- c(48, 20, 8)
  S0Exg
}

ge &lt;- sdm2(
  A = A, B = B, S0Exg = S0Exg,
  maxIteration = 1,
  numberOfPeriods = 1000,
  ts = TRUE
)
matplot(ge$ts.q, type = "l")

ge2 &lt;- sdm2(
  A = A, B = B, S0Exg = S0Exg,
  maxIteration = 1,
  numberOfPeriods = 1000,
  ts = TRUE,
  policy = makePolicyMeanValue(150)
)
matplot(ge2$ts.q, type = "l")

</code></pre>

<hr>
<h2 id='makePolicyStickyPrice'>Make a Policy of Sticky Price</h2><span id='topic+makePolicyStickyPrice'></span>

<h3>Description</h3>

<p>Given a stickiness value and a time window vector, this function returns a policy function that
sets the current prices equal to the weighted mean of the market-clearing prices and the current prices during this time window.
When the stickiness value is 0, the prices will be set to the market-clearing prices.
When the stickiness value is 1, the current prices will keep unchanged.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePolicyStickyPrice(stickiness = 0.5, time.win = c(1, Inf), tolCond = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePolicyStickyPrice_+3A_stickiness">stickiness</code></td>
<td>
<p>a stickiness value between 0 and 1.</p>
</td></tr>
<tr><td><code id="makePolicyStickyPrice_+3A_time.win">time.win</code></td>
<td>
<p>the time window vector, i.e. a 2-vector specifying the start time and end time of policy implementation.</p>
</td></tr>
<tr><td><code id="makePolicyStickyPrice_+3A_tolcond">tolCond</code></td>
<td>
<p>the tolerance condition for computing the market-clearing price vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A policy function, which is often used as an argument of the function sdm2.
</p>


<h3>Note</h3>

<p>Three major price adjustment methods can be used in the structural dynamic model.
The corresponding three kinds of prices are exploratory prices (the default case), market clearing prices, and sticky prices.
The exploratory prices are computed based on the prices and sales rates of the previous period.
In economic reality, the market clearing prices are unknown, so exploratory prices are more realistic.
</p>
<p>When the stickiness value is positive and the priceAdjustmentVelocity parameter in sdm2 is set to 0
(indicating that current prices remain unchanged from the previous period), implementing the sticky-price policy results in
current prices that are the weighted average of the market-clearing prices and the prices from the previous period.
Typically, this function should be utilized in this manner.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdm2">sdm2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
InitialEndowments &lt;- {
  tmp &lt;- matrix(0, 3, 2)
  tmp[1, 1] &lt;- 0.01
  tmp[2, 2] &lt;- tmp[3, 2] &lt;- 1
  tmp
}

ge &lt;- gemCanonicalDynamicMacroeconomic_3_2(
  priceAdjustmentVelocity = 0,
  policy.supply = makePolicySupply(InitialEndowments),
  policy.price = makePolicyStickyPrice(stickiness = 0.5),
  ts = TRUE,
  maxIteration = 1,
  numberOfPeriods = 50
)

par(mfrow = c(1, 2))
matplot(ge$ts.z, type = "o", pch = 20)
matplot(ge$ts.p, type = "o", pch = 20)


</code></pre>

<hr>
<h2 id='makePolicySupply'>Make a Policy of Supply</h2><span id='topic+makePolicySupply'></span>

<h3>Description</h3>

<p>Given a supply matrix and a time window vector, this function returns a policy function that sets the supply during this time window.
By default, the time window of this function is c(1, 1), which means that this function will set the initial supply.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePolicySupply(S, time.win = c(1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePolicySupply_+3A_s">S</code></td>
<td>
<p>a supply matrix.</p>
</td></tr>
<tr><td><code id="makePolicySupply_+3A_time.win">time.win</code></td>
<td>
<p>the time window vector, i.e. a 2-vector specifying the start time and end time of policy implementation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A policy function, which is often used as an argument of the function sdm2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdm2">sdm2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
InitialEndowments &lt;- {
  tmp &lt;- matrix(0, 3, 2)
  tmp[1, 1] &lt;- 0.01
  tmp[2, 2] &lt;- tmp[3, 2] &lt;- 1
  tmp
}

ge &lt;- gemCanonicalDynamicMacroeconomic_3_2(
  policy.supply = makePolicySupply(InitialEndowments),
  policy.price = policyMarketClearingPrice,
  ts = TRUE,
  maxIteration = 1,
  numberOfPeriods = 50
)

par(mfrow = c(1, 2))
matplot(ge$ts.z, type = "o", pch = 20)
matplot(ge$ts.p, type = "o", pch = 20)


</code></pre>

<hr>
<h2 id='makePolicyTailAdjustment'>Make a Policy of Tail Adjustment for a Timeline Model</h2><span id='topic+makePolicyTailAdjustment'></span>

<h3>Description</h3>

<p>Make a policy of tail adjustment for a timeline model.
Tail adjustment refers to the adjustment of the share coefficient of the last period of the consumer in the timeline model in order to let the model run in a steady-state equilibrium path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePolicyTailAdjustment(ind, gr = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePolicyTailAdjustment_+3A_ind">ind</code></td>
<td>
<p>a 2-column matrix or a numeric 2-vector that will be converted into a 2-column matrix.
In each row of the matrix, the first element corresponds to the index number of the last activity level of producing the product,
and the second element corresponds to the index number of a consumer who demands the product in the final period.</p>
</td></tr>
<tr><td><code id="makePolicyTailAdjustment_+3A_gr">gr</code></td>
<td>
<p>the growth rate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A policy, which is often used as an argument of the function sdm2.
</p>


<h3>See Also</h3>


<p><code><a href="#topic+makePolicyHeadTailAdjustment">makePolicyHeadTailAdjustment</a></code>;
<code><a href="#topic+makePolicyHeadAdjustment">makePolicyHeadAdjustment</a></code>

</p>

<hr>
<h2 id='makePolicyTechnologyChange'>Make a Policy of Technology Change</h2><span id='topic+makePolicyTechnologyChange'></span>

<h3>Description</h3>

<p>This function returns a policy function that changes the attributes alpha and a of the demand structure trees of agents specified.
An attribute alpha is usually a parameter of a CES or CD function.
An attribute a is usually a parameter of a Leontief function.
For demand structure trees that do not contain these two attributes, this function has no effect.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makePolicyTechnologyChange(
  adjumentment.ratio = 1.1,
  agent = 1,
  time.win = c(20, 20)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makePolicyTechnologyChange_+3A_adjumentment.ratio">adjumentment.ratio</code></td>
<td>
<p>a scalar. The attributes alpha will be multiplied by adjumentment.ratio.
The attributes a will be divided by adjumentment.ratio.</p>
</td></tr>
<tr><td><code id="makePolicyTechnologyChange_+3A_agent">agent</code></td>
<td>
<p>a vector specifying the indices or names of agents.</p>
</td></tr>
<tr><td><code id="makePolicyTechnologyChange_+3A_time.win">time.win</code></td>
<td>
<p>the time window vector, i.e. a 2-vector specifying the start time and end time of policy implementation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A policy function, which is often used as an argument of the function sdm2.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdm2">sdm2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.firm &lt;- node_new("output",
  type = "CD", alpha = 1, beta = c(0.5, 0.5),
  "prod", "lab"
)

dst.consumer &lt;- node_new("utility",
  type = "Leontief", a = 1, "prod"
)

B &lt;- matrix(c(
  1, 0,
  0, 0
), 2, 2, TRUE)
S0Exg &lt;- matrix(c(
  NA, NA,
  NA, 100
), 2, 2, TRUE)

ge &lt;- sdm2(
  A = list(dst.firm, dst.consumer), B = B, S0Exg = S0Exg,
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  priceAdjustmentVelocity = 0,
  policy = list(
    makePolicyTechnologyChange(agent = "firm"),
    makePolicyStickyPrice(stickiness = 0, time.win = c(1, 20)),
    makePolicyStickyPrice(stickiness = 0.9, time.win = c(20, Inf))
  ),
  ts = TRUE,
  maxIteration = 1,
  numberOfPeriods = 40
)

par(mfrow = c(1, 2))
matplot(ge$ts.z, type = "o", pch = 20)
matplot(ge$ts.p, type = "o", pch = 20)


</code></pre>

<hr>
<h2 id='marginal_utility'>Marginal Utility</h2><span id='topic+marginal_utility'></span>

<h3>Description</h3>

<p>If the argument price is null, this function computes the (delta) marginal utility.
By default, delta is set to 1e-10.
Otherwise this function computes the (delta) value marginal utility.
For a utility function U(x), two vector x, y and a scalar price, the marginal utility is (U(x + delta * y) - U(x)) / delta, and
the value marginal utility is (U(x + delta * y / price) - U(x)) / delta.
For a marginal utility function M(x), three vector x, y, wt and a scalar price, the marginal utility is sum(M(x) * y * wt), and
the value marginal utility is sum(M(x) * y * wt / price).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marginal_utility(x, y, uf, price = NULL, delta = 1e-10, muf = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marginal_utility_+3A_x">x</code></td>
<td>
<p>a numeric k-by-m matrix or a numeric vector (i.e. a k-by-1 matrix).</p>
</td></tr>
<tr><td><code id="marginal_utility_+3A_y">y</code></td>
<td>
<p>a numeric k-by-n matrix or a numeric vector (i.e. a k-by-1 matrix).</p>
</td></tr>
<tr><td><code id="marginal_utility_+3A_uf">uf</code></td>
<td>
<p>a utility function or a list consisting of m utility functions.</p>
</td></tr>
<tr><td><code id="marginal_utility_+3A_price">price</code></td>
<td>
<p>NULL or a numeric n-vector consisting of prices of each column of y.</p>
</td></tr>
<tr><td><code id="marginal_utility_+3A_delta">delta</code></td>
<td>
<p>a scalar.</p>
</td></tr>
<tr><td><code id="marginal_utility_+3A_muf">muf</code></td>
<td>
<p>a marginal utility function or a list consisting of m marginal utility functions.
A marginal utility function is the gradient of a utility function.
When the components in the marginal utility vector are the same, a marginal utility function may calculate only one of the components.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An n-by-m marginal utility matrix. Its (i,j)-th element corresponds to the i-th column of y and the j-th column of x.
</p>


<h3>References</h3>

<p>Sharpe, William F. (2008, ISBN: 9780691138503) Investors and Markets: Portfolio Choices, Asset Prices, and Investment Advice. Princeton University Press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>marginal_utility(1:2, cbind(1:2, 1:1), AMV)
marginal_utility(1:2, cbind(1:2, 1:1), AMV, delta = 100)
marginal_utility(cbind(1:2, 3:4), cbind(1:2, 1:1), AMV)
marginal_utility(
  cbind(1:2, 3:4), cbind(1:2, 1:1),
  list(AMV, function(x) AMV(x, gamma = 0.5))
)

####
wt &lt;- 1:2
uf &lt;- function(x) (x - x^2 / 400) %*% wt
muf &lt;- function(x) (1 - 1 / 200 * x) * wt
marginal_utility(1:2, cbind(1:2, 1:1), uf)
marginal_utility(1:2, cbind(1:2, 1:1), muf = muf)

####
marginal_utility(
  1:2, cbind(1:2, 1:1),
  function(x, gamma = 1, p = rep(1, length(x))) CRRA(x, gamma, p)$CE
)
marginal_utility(1:2, cbind(1:2, 1:1), function(x) sqrt(prod(x)))

gamma &lt;- 0.8
wt &lt;- c(0.25, 0.75)
marginal_utility(
  1:2, cbind(1:2, 1:1),
  function(x) CRRA(x, gamma = gamma, prob = wt)$CE
)
## the same as above. CRRA and CES utility funcitons are essentially the same.
es &lt;- 1 / gamma
beta &lt;- wt^es
marginal_utility(
  1:2, cbind(1:2, 1:1),
  function(x) CES(x = x, sigma = 1 - 1 / es, alpha = 1, beta = wt)
)

prop.table(marginal_utility(
  1:2, cbind(1:2, 1:1),
  function(x) CRRA(x, gamma = gamma, prob = wt)$CE
))
prop.table(marginal_utility(
  1:2, cbind(1:2, 1:1),
  function(x) CRRA(x, gamma = gamma, prob = wt)$u
))
</code></pre>

<hr>
<h2 id='matrix_add_by_name'>Add Matrices by Names of Columns and Rows</h2><span id='topic+matrix_add_by_name'></span>

<h3>Description</h3>

<p>Add together some matrices by names of columns and rows.
Those matrices may have distinct sizes. All matrices should not have column names and row names other than those of the first matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_add_by_name(M, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_add_by_name_+3A_m">M</code></td>
<td>
<p>a matrix with column names and row names.</p>
</td></tr>
<tr><td><code id="matrix_add_by_name_+3A_...">...</code></td>
<td>
<p>some matrices with column names and row names which constitute subsets of those of M.
If there is a vector, it will be converted to a matrix of one column and the column will be named after the vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matirx.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- matrix(0, 5, 5)
colnames(M) &lt;- paste("c", 1:5, sep = "")
rownames(M) &lt;- paste("r", 1:5, sep = "")

M2 &lt;- matrix(1:9, 3, 3)
colnames(M2) &lt;- c("c2", "c3", "c5")
rownames(M2) &lt;- c("r1", "r2", "r4")

matrix_add_by_name(M, M2)

c1 &lt;- c(r1 = 1, r3 = 2)
matrix_add_by_name(M, c1)
matrix_add_by_name(M, c1, M2)
</code></pre>

<hr>
<h2 id='matrix_aggregate'>Aggregate Some Rows and Columns of a Matrix</h2><span id='topic+matrix_aggregate'></span>

<h3>Description</h3>

<p>Aggregate some rows and columns of a matrix to obtain a matrix with smaller dimensions.
This function can be used for aggregating some rows and columns of an input-output table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_aggregate(
  M,
  row.index = NULL,
  col.index = NULL,
  row.name = NULL,
  col.name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_aggregate_+3A_m">M</code></td>
<td>
<p>a numeric matrix without NA.</p>
</td></tr>
<tr><td><code id="matrix_aggregate_+3A_row.index">row.index</code></td>
<td>
<p>a numeric vector or a list of numeric vectors indicating the index numbers of rows to be aggregated.
The default value is is NULL.</p>
</td></tr>
<tr><td><code id="matrix_aggregate_+3A_col.index">col.index</code></td>
<td>
<p>a numeric vector or a list of numeric vectors indicating the index numbers of columns to be aggregated.
The default value is is NULL.</p>
</td></tr>
<tr><td><code id="matrix_aggregate_+3A_row.name">row.name</code></td>
<td>
<p>a character vector or a list of character vectors indicating the names of rows to be aggregated.
The default value is NULL.
If row.index or col.index is not NULL, row.name and col.name will be ignored.</p>
</td></tr>
<tr><td><code id="matrix_aggregate_+3A_col.name">col.name</code></td>
<td>
<p>a character vector or a list of character vectors indicating the names of columns to be aggregated.
The default value is NULL.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
M &lt;- matrix(1:16,4,4,TRUE)
colnames(M) &lt;- paste0("c",1:4)
rownames(M) &lt;- paste0("r",1:4)
addmargins(M)

M2 &lt;- matrix_aggregate(M, list(c(1,3),c(2, 4)), 2:3)
addmargins(M2)

M3 &lt;- matrix_aggregate(M, row.name = list(c("r1","r3"),c("r2","r4")), col.name = c("c2","c3"))
addmargins(M3)

</code></pre>

<hr>
<h2 id='matrix_to_dstl'>Convert a Matrix into a Demand Structural Tree List</h2><span id='topic+matrix_to_dstl'></span>

<h3>Description</h3>

<p>Convert a demand coefficient matrix into a demand structural tree list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matrix_to_dstl(
  x,
  names.commodity = paste("comm", 1:nrow(x), sep = ""),
  names.agent = paste("agt", 1:ncol(x), sep = "")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matrix_to_dstl_+3A_x">x</code></td>
<td>
<p>a matrix.</p>
</td></tr>
<tr><td><code id="matrix_to_dstl_+3A_names.commodity">names.commodity</code></td>
<td>
<p>names of commodities.
They will be the names of leaf nodes of each demand structural tree.</p>
</td></tr>
<tr><td><code id="matrix_to_dstl_+3A_names.agent">names.agent</code></td>
<td>
<p>names of agents.
They will be the names of root nodes of those demand structural trees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A demand structural tree list.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
A &lt;- matrix(c(
  0, 0, 0, 1,
  8, 6, 1, 0,
  4, 2, 1.5, 0,
  2, 1.5, 0.5, 0
), 4, 4, TRUE)

dstl &lt;- matrix_to_dstl(A)
node_print(dstl[[1]])


</code></pre>

<hr>
<h2 id='MDCES_demand'>Modified Displaced CES Demand Function</h2><span id='topic+MDCES_demand'></span>

<h3>Description</h3>

<p>Compute the modified displaced CES demand function.
Firstly, the (unmodified) DCES demand vector and the (unmodified) utility level are computed under the given income and prices.
Secondly, the modified beta and es are computed under the unmodified utility level.
Finally, the DCES demand vector (namely the modified DCES demand vector) and the utility level
(namely the modified DCES utility) are computed under the modified beta, the modified es, the given income and prices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MDCES_demand(es, beta, xi, w, p, betaMod = NULL, esMod = NULL, detail = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MDCES_demand_+3A_es">es</code></td>
<td>
<p>the elasticity of substitution.</p>
</td></tr>
<tr><td><code id="MDCES_demand_+3A_beta">beta</code></td>
<td>
<p>an n-vector consisting of the marginal expenditure share coefficients (Fullerton, 1989).</p>
</td></tr>
<tr><td><code id="MDCES_demand_+3A_xi">xi</code></td>
<td>
<p>an n-vector. Each element of xi parameterizes whether
the particular good is a necessity for the household (Acemoglu, 2009, page 152).
For example, xi[i] &gt; 0 may mean that the household needs to consume at least a certain amount of good i to survive.</p>
</td></tr>
<tr><td><code id="MDCES_demand_+3A_w">w</code></td>
<td>
<p>a scalar indicating the income.</p>
</td></tr>
<tr><td><code id="MDCES_demand_+3A_p">p</code></td>
<td>
<p>an n-vector indicating the prices.</p>
</td></tr>
<tr><td><code id="MDCES_demand_+3A_betamod">betaMod</code></td>
<td>
<p>a function with the unmodified utility level u.unmod as the argument.</p>
</td></tr>
<tr><td><code id="MDCES_demand_+3A_esmod">esMod</code></td>
<td>
<p>a function with the unmodified utility level u.unmod as the argument.</p>
</td></tr>
<tr><td><code id="MDCES_demand_+3A_detail">detail</code></td>
<td>
<p>If detail==FALSE, the modified demand vector is returned.
If detail==TRUE, the returned vector consists of the modified demand vector,
the modified utility, the modified es, the modified beta, the unmodified utility and
the unmodified demand vector.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Acemoglu, D. (2009, ISBN: 9780691132921) Introduction to Modern Economic Growth. Princeton University Press.
</p>
<p>Fullerton, D. (1989) Notes on Displaced CES Functional Forms. Available at: https://works.bepress.com/don_fullerton/39/
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
MDCES_demand(
  es = 1.7, beta = c(0.9, 0.1), xi = c(12, 48),
  w = 24, p = c(1, 1 / 400),
  betaMod = function(u.unmod) {
    beta2 &lt;- min(0.1, 10 / u.unmod)
    c(1 - beta2, beta2)
  },
  detail = TRUE
)

#### An example of computing the daily
#### labor supply at various wage rates.
result &lt;- c()

for (real.wage in 4:400) {
  x &lt;- MDCES_demand(
    es = 1.7, beta = c(0.9, 0.1),
    xi = c(12, 48), w = 24,
    p = c(1, 1 / real.wage),
    betaMod = function(u.unmod) {
      beta2 &lt;- min(0.1, 10 / u.unmod)
      c(1 - beta2, beta2)
    },
    detail = TRUE
  )

  lab.supply &lt;- unname(24 - x[1])
  result &lt;- rbind(
    result,
    c(real.wage, lab.supply, x)
  )
}

plot(result[, 1:2],
  type = "o", pch = 20,
  xlab = "hourly real wage",
  ylab = "daily labor supply"
)

#### A 2-by-2 general equilibrium model
#### with a MDCES demand function
ge &lt;- sdm2(
  A = function(state) {
    a.firm &lt;- CD_A(alpha = 5, Beta = c(0.5, 0.5), state$p)
    a.consumer &lt;-
      MDCES_demand(
        es = 1, beta = c(0.5, 0.5), xi = c(0, 0), w = state$w[2], p = state$p,
        betaMod = function(u.unmod) {
          beta2 &lt;- 0.95 * plogis(u.unmod, location = 2, scale = 2)
          c(1 - beta2, beta2)
        }
      )
    cbind(a.firm, a.consumer)
  },
  B = matrix(c(
    1, 0,
    0, 0
  ), 2, 2, TRUE),
  S0Exg = matrix(c(
    NA, NA,
    NA, 1
  ), 2, 2, TRUE),
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  numeraire = "lab"
)

ge$z
ge$D
MDCES_demand(
  es = 1, beta = c(0.5, 0.5), xi = c(0, 0),
  w = 1, p = ge$p,
  betaMod = function(u.unmod) {
    beta2 &lt;- 0.95 * plogis(u.unmod, location = 2, scale = 2)
    c(1 - beta2, beta2)
  }
)

</code></pre>

<hr>
<h2 id='node_insert'>Insert Nodes into a Tree</h2><span id='topic+node_insert'></span>

<h3>Description</h3>

<p>Scan the tree and insert nodes before the first non-root node having the name specified. <br />
This function is based on the package data.tree and has side-effects.
It modifies the tree given by the argument (see the package data.tree).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_insert(tree, node.name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_insert_+3A_tree">tree</code></td>
<td>
<p>a tree (i.e. a Node object).</p>
</td></tr>
<tr><td><code id="node_insert_+3A_node.name">node.name</code></td>
<td>
<p>a character string specifying the name of a node. Some nodes will be inserted before it.</p>
</td></tr>
<tr><td><code id="node_insert_+3A_...">...</code></td>
<td>
<p>some Node objects or character strings.
A character string will be treated as the name of a new node to be created. Those nodes will be inserted into the tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the parent node of those new nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.firm &lt;- node_new(
  "output",
  "prod1",  "prod2"
)
plot(dst.firm)

dst.VA &lt;- node_new(
  "VA",
  "lab",  "cap"
)

node_insert(
  dst.firm, "prod1",
  dst.VA, "prod3"
)
node_set(
  dst.firm, "output",
  "prod4"
)
plot(dst.firm)

</code></pre>

<hr>
<h2 id='node_new'>Create a Tree</h2><span id='topic+node_new'></span>

<h3>Description</h3>

<p>Create a tree by the <code><a href="#topic+node_set">node_set</a></code> function and the package data.tree.
</p>
<p>As the package data.tree says:
</p>
<p>&quot;One of most important things to note about data.tree is that it exhibits reference semantics.
In a nutshell, this means that you can modify your tree along the way, without having to reassign it to a variable after each modification.
By and large, this is a rather exceptional behavior in R, where value-semantics is king most of the time.&quot;
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_new(root.name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_new_+3A_root.name">root.name</code></td>
<td>
<p>a character string specifying the name of the root node.</p>
</td></tr>
<tr><td><code id="node_new_+3A_...">...</code></td>
<td>
<p>attribute names and values (e.g. alpha=1).
The parameter name of a value will be treated as the name of an attribute.<br />
A value without a parameter name will be treated as a child node or the name of a child node.
If the class of the value is Node, it will be added as a child.
If the class of the value is character, a child node (or some child nodes) will be created with the value
as the name (or names).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tree (i.e. a Node object).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### create a tree
dst1 &lt;- node_new("firm1")
print(dst1)

## create a tree with children
dst &lt;- node_new(
  "firm",
  "lab", "cap", dst1
)
print(dst)

# the same as above
dst &lt;- node_new(
  "firm",
  c("lab", "cap"), dst1
)
print(dst)

#### create a tree with attributes
dst &lt;- node_new("firm",
  type = "CD", alpha = 1, beta = c(0.5, 0.5)
)
node_print(dst)

#### create a tree with attributes and children
dst &lt;- node_new("firm",
  type = "CD", alpha = 1, beta = c(0.5, 0.5),
  "lab", "cap"
)
node_plot(dst)
node_plot(dst, TRUE)



</code></pre>

<hr>
<h2 id='node_plot'>Plot a Tree and Show the Type Attribute</h2><span id='topic+node_plot'></span>

<h3>Description</h3>

<p>A wrapper of the function plot.Node of the packages data.tree.
If a non-leaf node has a type attribute, then the attribute will be shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_plot(node, param = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_plot_+3A_node">node</code></td>
<td>
<p>a tree (i.e. a Node object).</p>
</td></tr>
<tr><td><code id="node_plot_+3A_param">param</code></td>
<td>
<p>If TRUE, those parameters such as alpha, beta, es etc. will be shown.</p>
</td></tr>
<tr><td><code id="node_plot_+3A_...">...</code></td>
<td>
<p>arguments to be to be passed to the function plot.Node.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+demand_coefficient">demand_coefficient</a></code>
</p>

<hr>
<h2 id='node_print'>Print a Tree and Its Fields</h2><span id='topic+node_print'></span>

<h3>Description</h3>

<p>A wrapper of the function print.Node of the package data.tree.
Print a tree and its fields except the func field.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_print(node, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_print_+3A_node">node</code></td>
<td>
<p>a Node object.</p>
</td></tr>
<tr><td><code id="node_print_+3A_...">...</code></td>
<td>
<p>arguments passed to print.Node.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
dst &lt;- node_new("firm",
                type = "SCES",
                alpha = 2, beta = c(0.8, 0.2),
                es = 0.5,
                "wheat", "iron"
)

node_print(dst)

####
dst &lt;- node_new("firm",
                type = "FUNC",
                func = min,
                "wheat", "iron"
)

node_print(dst)


</code></pre>

<hr>
<h2 id='node_prune'>Prune Nodes off a Tree by Names</h2><span id='topic+node_prune'></span>

<h3>Description</h3>

<p>A wrapper of data.tree::Prunes. Prune nodes off a tree by names.
This function has side-effects, it modifies the tree given by the argument (see the package data.tree).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_prune(tree, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_prune_+3A_tree">tree</code></td>
<td>
<p>a tree (i.e. a Node object).</p>
</td></tr>
<tr><td><code id="node_prune_+3A_...">...</code></td>
<td>
<p>some character strings specifies the names of nodes to be pruned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the tree.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dst &lt;- node_new(
  "firm",
  "lab", "cap", "land"
)
node_prune(
  dst,
  "cap", "land"
)
plot(dst)

</code></pre>

<hr>
<h2 id='node_replace'>Replace a Node of a Tree</h2><span id='topic+node_replace'></span>

<h3>Description</h3>

<p>Scan the tree and replace the first non-root node having the name specified. <br />
This function is based on the package data.tree and has side-effects.
It modifies the tree given by the argument (see the package data.tree).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_replace(tree, node.name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_replace_+3A_tree">tree</code></td>
<td>
<p>a tree (i.e. a Node object).</p>
</td></tr>
<tr><td><code id="node_replace_+3A_node.name">node.name</code></td>
<td>
<p>a character string specifying the name of the node to be pruned off.</p>
</td></tr>
<tr><td><code id="node_replace_+3A_...">...</code></td>
<td>
<p>some Node objects or character strings.
A character string will be treated as the name of a new node to be created.
Those nodes will be added to the tree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the parent node of those new nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.firm &lt;- node_new(
  "output",
  "prod1", "prod2"
)
plot(dst.firm)

dst.VA &lt;- node_new(
  "VA",
  "lab", "cap"
)

node_replace(
  dst.firm, "prod2",
  dst.VA, "prod3"
)
plot(dst.firm)

node_replace(
  dst.firm, "lab",
  "labor"
)
plot(dst.firm)

node_replace(
  dst.firm, "VA",
  "prod2"
)
plot(dst.firm)


</code></pre>

<hr>
<h2 id='node_set'>Create a Tree or Set Attributes for a Node</h2><span id='topic+node_set'></span>

<h3>Description</h3>

<p>Create a tree or set attributes for a node by the package data.tree.
This function can also be used to add child nodes to a node.
This function has side-effects, it modifies the tree given by the argument (see the package data.tree).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>node_set(tree, node.name = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="node_set_+3A_tree">tree</code></td>
<td>
<p>a tree (i.e. a Node object) or a character string.
If it is a character string, a tree will be created and the string will be the name of the root.
And in this case, if you need to use the following parameters to set the attributes of the root node,
then the second parameter node.name should be set to NA.</p>
</td></tr>
<tr><td><code id="node_set_+3A_node.name">node.name</code></td>
<td>
<p>a character string, the name of a node.
If the first parameter is a tree, the value of this parameter should be the name of a node in the tree.</p>
</td></tr>
<tr><td><code id="node_set_+3A_...">...</code></td>
<td>
<p>attribute names and values (e.g. alpha=1).
The parameter name of a value will be treated as the name of an attribute.
If a value is NULL, the corresponding attribute should exist and will be deleted. <br />
</p>
<p>A value without a parameter name will be treated as a child node or the name of a child node.
If the class of the value is Node, it will be added as a child.
If the class of the value is character, a child node (or some child nodes) will be created with the value
as the name (or names).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the node.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+node_new">node_new</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### create a tree
dst1 &lt;- node_set("firm1")
print(dst1)

## create a tree with children
dst &lt;- node_set(
  "firm", NA,
  "lab", "cap", dst1
)
print(dst)

# the same as above
dst &lt;- node_set(
  "firm", NA,
  c("lab", "cap"), dst1
)
print(dst)

#### create a tree with attributes
dst &lt;- node_set("firm", NA,
  type = "CD", alpha = 1, beta = c(0.5, 0.5)
)
print(dst, "type", "alpha", "beta")

#### create a tree with attributes and children
dst &lt;- node_set("firm", NA,
  type = "CD", alpha = 1, beta = c(0.5, 0.5),
  "lab", "cap"
)
print(dst, "type", "alpha", "beta")

#### set attributes for a node
dst.firm &lt;- node_set("firm", NA, "VA")
node_set(dst.firm, "VA",
  type = "CD",
  alpha = 0.8^-0.8 * 0.2^-0.2,
  beta = c(0.8, 0.2),
  "lab",
  "cap"
)
print(dst.firm, "alpha", "beta")

## set attributes and add a child for a node
node_set(dst.firm, "VA",
  type = "SCES",
  alpha = 1,
  beta = c(0.1, 0.8, 0.1),
  es = 0,
  "land"
)
print(dst.firm, "type", "alpha", "beta", "es")

## find a node
x &lt;- node_set(dst.firm, "VA")
node_print(x)


</code></pre>

<hr>
<h2 id='output'>Compute the Utility of a Consumer or the Output of a Firm by the Demand Structural Tree</h2><span id='topic+output'></span>

<h3>Description</h3>

<p>Given a demand structural tree and an input vector,
this function computes the utility of a consumer or the output of a firm.
If the demand structural tree has a FUNC-type node,
the node should has an attribute named fun that is a function computing the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output(node, input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="output_+3A_node">node</code></td>
<td>
<p>a demand structural tree.</p>
</td></tr>
<tr><td><code id="output_+3A_input">input</code></td>
<td>
<p>an input vector with names of commodities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dst &lt;- node_new("output",
                type = "SCES", es = 0, alpha = 1, beta = c(0.5, 0.5),
                "cc1", "cc2"
)
node_set(dst, "cc1",
         type = "Leontief", a = c(0.6, 0.4),
         "wheat", "iron"
)
node_set(dst, "cc2",
         type = "SCES", sigma = -1, alpha = 1, beta = c(0.5, 0.5),
         "labor", "capital"
)

node_plot(dst, TRUE)

p &lt;- c(wheat = 1, iron = 3, labor = 2, capital = 4)
x &lt;-demand_coefficient(dst, p)
output(dst, x)

output(dst, c(wheat = 3, iron = 3, labor = 3, capital = 3))
SCES(
  es = 0, alpha = 1, beta = c(0.5, 0.5),
  x = c(
    min(3 / 0.6, 3 / 0.4),
    SCES(es = 0.5, alpha = 1, beta = c(0.5, 0.5), x = c(3, 3))
  )
)
</code></pre>

<hr>
<h2 id='policyMarketClearingPrice'>Market-Clearing-Price Policy Function</h2><span id='topic+policyMarketClearingPrice'></span>

<h3>Description</h3>

<p>This policy is to make the market clear every period.
In this case, the path of the economy is the spot market clearing path (alias instantaneous equilibrium path).
Generally, this function is passed to the function sdm2 as an argument to compute the spot market clearing path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>policyMarketClearingPrice(time, A, state, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="policyMarketClearingPrice_+3A_time">time</code></td>
<td>
<p>the current time.</p>
</td></tr>
<tr><td><code id="policyMarketClearingPrice_+3A_a">A</code></td>
<td>
<p>a demand structure tree list (i.e. dstl, see demand_coefficient), a demand coefficient n-by-m matrix (alias demand structure matrix) or a function A(state) which returns an n-by-m matrix.</p>
</td></tr>
<tr><td><code id="policyMarketClearingPrice_+3A_state">state</code></td>
<td>
<p>the current state.</p>
</td></tr>
<tr><td><code id="policyMarketClearingPrice_+3A_...">...</code></td>
<td>
<p>optional arguments to be passed to the function sdm2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of p, S and B which specify the prices, supplies and supply coefficient matrix after adjustment.
</p>


<h3>References</h3>

<p>LI Wu (2019, ISBN: 9787521804225) General Equilibrium and Structural Dynamics: Perspectives of New Structural Economics. Beijing: Economic Science Press. (In Chinese)
</p>
<p>Grandmont, J.M. (1977). Temporary General Equilibrium Theory. Econometrica 45, 535-572.
</p>


<h3>See Also</h3>

<p>CGE::iep and <code><a href="#topic+sdm2">sdm2</a></code>, <code><a href="#topic+gemTemporaryEquilibriumPath">gemTemporaryEquilibriumPath</a></code>.
The market clearing prices are the prices with a stickiness value equal to zero.
Therefore, this function can actually be replaced by <code><a href="#topic+makePolicyStickyPrice">makePolicyStickyPrice</a></code> in the calculation.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### an iep of the example (see Table 2.1 and 2.2) of the canonical dynamic
#### macroeconomic general equilibrium model in Torres (2016).
ge &lt;- gemCanonicalDynamicMacroeconomic_3_2(
  policy.price = policyMarketClearingPrice,
  ts = TRUE,
  maxIteration = 1,
  numberOfPeriods = 50,
  z0 = c(0.5, 1)
)

par(mfrow = c(1, 2))
matplot(ge$ts.z, type = "o", pch = 20)
matplot(ge$ts.p, type = "o", pch = 20)

#### the same as above
ge &lt;- gemCanonicalDynamicMacroeconomic_3_2(
  policy.price = makePolicyStickyPrice(stickiness = 0),
  ts = TRUE,
  maxIteration = 1,
  numberOfPeriods = 50,
  z0 = c(0.5, 1)
)

par(mfrow = c(1, 2))
matplot(ge$ts.z, type = "o", pch = 20)
matplot(ge$ts.p, type = "o", pch = 20)

#### TFP shock in the economy above (see Torres, 2016, section 2.8).
numberOfPeriods &lt;- 200

discount.factor &lt;- 0.97
depreciation.rate &lt;- 0.06
beta1.firm &lt;- 0.35
return.rate &lt;- 1 / discount.factor - 1

set.seed(1)
alpha.shock &lt;- rep(1, 100)
alpha.shock[101] &lt;- exp(0.01)
for (t in 102:numberOfPeriods) {
  alpha.shock[t] &lt;- exp(0.95 * log(alpha.shock[t - 1]))
}

policyTechnologyChange &lt;- function(time, A) {
  A[[1]]$func &lt;- function(p) {
    result &lt;- CD_A(
      alpha.shock[time], rbind(beta1.firm, 1 - beta1.firm, 0),
      c(p[1] * (return.rate + depreciation.rate), p[2:3])
    )
    result[3] &lt;- p[1] * result[1] * return.rate / p[3]
    result
  }
}

InitialEndowments &lt;- {
  tmp &lt;- matrix(0, 3, 2)
  tmp[1, 1] &lt;- tmp[2, 2] &lt;- tmp[3, 2] &lt;- 1
  tmp
}

ge &lt;- gemCanonicalDynamicMacroeconomic_3_2(
  policy.supply = makePolicySupply(InitialEndowments),
  policy.technology = policyTechnologyChange,
  policy.price = policyMarketClearingPrice,
  ts = TRUE,
  maxIteration = 1,
  numberOfPeriods = 200
)

c &lt;- ge$A[1, 2] * ge$ts.z[, 2] # consumption
par(mfrow = c(2, 2))
matplot(ge$ts.z, type = "l")
x &lt;- 100:140
plot(x, ge$ts.z[x, 1] / ge$ts.z[x[1], 1], type = "o", pch = 20)
plot(x, ge$ts.z[x, 2] / ge$ts.z[x[1], 2], type = "o", pch = 20)
plot(x, c[x] / c[x[1]], type = "o", pch = 20)

#### an iep of example 7.2 (a monetary economy) in Li (2019). See CGE::Example7.2.
interest.rate &lt;- 0.25
dst.firm &lt;- node_new("cc", #composite commodity
                     type = "FIN",
                     rate = c(1, interest.rate),
                     "cc1", "money"
)
node_set(dst.firm, "cc1",
         type = "CD", alpha = 1, beta = c(0.5, 0.5),
         "wheat", "labor"
)

dst.laborer &lt;- Clone(dst.firm)
dst.money.lender &lt;- Clone(dst.firm)

dstl &lt;- list(dst.firm, dst.laborer, dst.money.lender)

B &lt;- matrix(0, 3, 3)
B[1, 1] &lt;- 1

S0Exg &lt;- matrix(NA, 3, 3)
S0Exg[2, 2] &lt;- 100
S0Exg[3, 3] &lt;- 100

InitialEndowments &lt;- {
  tmp &lt;- matrix(0, 3, 3)
  tmp[1, 1] &lt;- 10
  tmp[2, 2] &lt;- tmp[3, 3] &lt;- 100
  tmp
}

ge &lt;- sdm2(
  A = dstl, B = B, S0Exg = S0Exg,
  names.commodity = c("wheat", "labor", "money"),
  names.agent = c("firm", "laborer", "money.lender"),
  numeraire = c(money = interest.rate),
  numberOfPeriods = 20,
  maxIteration = 1,
  ts = TRUE,
  policy = list(
    makePolicySupply(S = InitialEndowments),
    policyMarketClearingPrice
  )
)

par(mfrow = c(1, 2))
matplot(ge$ts.z, type = "o", pch = 20)
matplot(ge$ts.p, type = "o", pch = 20)

</code></pre>

<hr>
<h2 id='policyMeanValue'>Mean Value Policy Function</h2><span id='topic+policyMeanValue'></span>

<h3>Description</h3>

<p>When the time index is an integer multiple of 200, this policy sets the current prices and supplies to the averages of the previous 199 periods.
This policy function is mainly used as an argument of the function sdm2 in order to accelerate convergence when calculating general equilibrium.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>policyMeanValue(time, state, state.history)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="policyMeanValue_+3A_time">time</code></td>
<td>
<p>the current time.</p>
</td></tr>
<tr><td><code id="policyMeanValue_+3A_state">state</code></td>
<td>
<p>the current state.</p>
</td></tr>
<tr><td><code id="policyMeanValue_+3A_state.history">state.history</code></td>
<td>
<p>the state history, which is a list consisting of the time series of p, S, q, and z.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list consisting of p, S and B which specify the prices, supplies and supply coefficient matrix after adjustment.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+makePolicyMeanValue">makePolicyMeanValue</a></code> <code><a href="#topic+sdm2">sdm2</a></code>  <code><a href="#topic+gemDualLinearProgramming">gemDualLinearProgramming</a></code>.
</p>

<hr>
<h2 id='QL_demand'>Quasilinear Demand Functions</h2><span id='topic+QL_demand'></span>

<h3>Description</h3>

<p>Some quasilinear demand functions. The corresponding utility functions are as follows: <br />
power: x1 + alpha * x2^beta, wherein alpha&gt;0, 0&lt;beta&lt;1. <br />
log: x1 + alpha * log(x2), wherein alpha&gt;0. <br />
quadratic1: x1 + alpha * x2 - 0.5 * beta * x2^2, wherein alpha&gt;0, beta&gt;0. <br />
quadratic2: x1 + beta * (alpha * x2 - 0.5 * x2^2), wherein alpha&gt;0, beta&gt;0. <br />
min: x1 + alpha * min(x2, beta), wherein alpha&gt;0, beta&gt;0. <br />
CRRA: x1 + alpha * (x2^(1 - beta) - 1) / (1 - beta), wherein alpha&gt;0, beta&gt;0. If beta==1, the function becomes
x1 + alpha * log(x2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>QL_demand(
  w,
  p,
  alpha,
  beta,
  type = c("power", "log", "quadratic1", "quadratic2", "min", "CRRA")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="QL_demand_+3A_w">w</code></td>
<td>
<p>a scalar indicating the income.</p>
</td></tr>
<tr><td><code id="QL_demand_+3A_p">p</code></td>
<td>
<p>a 2-vector indicating the prices.</p>
</td></tr>
<tr><td><code id="QL_demand_+3A_alpha">alpha</code></td>
<td>
<p>a scalar.</p>
</td></tr>
<tr><td><code id="QL_demand_+3A_beta">beta</code></td>
<td>
<p>a scalar.</p>
</td></tr>
<tr><td><code id="QL_demand_+3A_type">type</code></td>
<td>
<p>a character string specifying the type of the function. The default type is &quot;power&quot;.
Other possible values are &quot;log&quot;, &quot;quadratic1&quot;, &quot;quadratic2&quot; and &quot;min&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 2-by-1 matrix indicating demands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
QL_demand(w = 0.5, p = c(1, 1), alpha = 1, type = "log")
QL_demand(w = 2, p = c(1, 1), alpha = 1, type = "log")

QL_demand(w = 1, p = c(1, 5), alpha = 2, beta = 0.5)


</code></pre>

<hr>
<h2 id='rate_to_beta'>Conversion between a Rate Vector and a Beta Vector</h2><span id='topic+rate_to_beta'></span><span id='topic+beta_to_rate'></span>

<h3>Description</h3>

<p>Conversion between an expenditure rate vector and a beta vector (i.e. an expenditure proportion vector).
For an economic agent, the rate vector indicates the ratios between expenditures on financial instruments and the physical commodity.
The first element of the rate vector indicates the quantity of the physical commodity needed to obtain a unit of output.
Other elements indicate the ratio of expenditures on various financial instruments to that of the physical commodity,
which may be equal to the interest rate, the tax rate, the dividend rate, etc.
The beta vector indicates the proportions of expenditures on various commodities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rate_to_beta(x)

beta_to_rate(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rate_to_beta_+3A_x">x</code></td>
<td>
<p>a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>rate_to_beta</code>: Convert a rate vector to a beta vector.
</p>
</li>
<li> <p><code>beta_to_rate</code>: Convert a beta vector to a rate vector.
When converting the beta vector into a rate vector, it will be assumed that the first element of these two vectors is the same.
</p>
</li></ul>


<h3>See Also</h3>

<p><cite><a href="#topic+demand_coefficient">demand_coefficient</a></cite>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rate_to_beta(c(1, 1 / 3, 1 / 4))
rate_to_beta(c(0.5, 1 / 3, 1 / 4))

x &lt;- beta_to_rate(c(0.7, 0.1, 0.2))
rate_to_beta(x)

</code></pre>

<hr>
<h2 id='ratio_adjust'>Ratio Adjustment</h2><span id='topic+ratio_adjust'></span>

<h3>Description</h3>

<p>Adjust ratios to new values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ratio_adjust(
  ratio,
  coef = 0.8,
  method = c("log", "left.linear", "trunc.log", "linear")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ratio_adjust_+3A_ratio">ratio</code></td>
<td>
<p>a numeric vector or a positive numeric n-by-m matrix.</p>
</td></tr>
<tr><td><code id="ratio_adjust_+3A_coef">coef</code></td>
<td>
<p>a positive number, a positive numeric vector or a positive numeric n-by-m matrix.
The smaller this value, the closer the adjusted ratio will be to one.</p>
</td></tr>
<tr><td><code id="ratio_adjust_+3A_method">method</code></td>
<td>
<p>a character string specifying the adjustment method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a positive ratio and the following methods, the return values are as follows:
</p>

<ul>
<li><p> log : coef * log(ratio) + 1, if ratio &gt;= 1; 1 / (coef * log(1 / ratio) + 1), if ratio &lt; 1.
</p>
</li>
<li><p> left.linear : 1 / (coef * (1 / ratio - 1) + 1), if ratio &gt;= 1; 1 + coef * (ratio - 1), if ratio &lt; 1.
</p>
</li>
<li><p> trunc.log : max(coef * log(ratio) + 1, 0).
</p>
</li>
<li><p> linear : coef * (ratio - 1) + 1.
</p>
</li></ul>



<h3>Value</h3>

<p>A vector or a matrix with dimensions the same as the argument ratio.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ratio_adjust(10, 0.8)
ratio_adjust(0.1, 0.8)

x &lt;- seq(0.01, 2, 0.01)
plot(x, x, type = "l")
lines(x, ratio_adjust(x, 0.8, method = "log"), col = "red")
lines(x, ratio_adjust(x, 0.8, method = "left.linear"), col = "blue")
lines(x, ratio_adjust(x, 0.8, method = "trunc.log"), col = "green")

X &lt;- replicate(3, x)
Y &lt;- ratio_adjust(X, c(0.8, 1, 1.2))
matplot(x, Y, type = "l")
</code></pre>

<hr>
<h2 id='SCES'>Standard CES Function</h2><span id='topic+SCES'></span>

<h3>Description</h3>

<p>Standard CES function, e.g. alpha * (beta1 * (x1 / beta1)^sigma + beta2 * (x2 / beta2)^sigma)^(1 / sigma)
wherein beta1 + beta2 == 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCES(sigma = 1 - 1/es, alpha, beta, x, es = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCES_+3A_sigma">sigma</code></td>
<td>
<p>the sigma coefficient.</p>
</td></tr>
<tr><td><code id="SCES_+3A_alpha">alpha</code></td>
<td>
<p>the alpha coefficient.</p>
</td></tr>
<tr><td><code id="SCES_+3A_beta">beta</code></td>
<td>
<p>a vector consisting of the beta coefficients.</p>
</td></tr>
<tr><td><code id="SCES_+3A_x">x</code></td>
<td>
<p>a vector consisting of the inputs.</p>
</td></tr>
<tr><td><code id="SCES_+3A_es">es</code></td>
<td>
<p>the elasticity of substitution. If es is not NA, the value of sigma will be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The output or utility level.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
beta &lt;- c(0.6, 0.4)
SCES(alpha = 1, beta = beta, x = beta, es = 0.5)


</code></pre>

<hr>
<h2 id='SCES_A'>Standard CES Demand Coefficient Matrix</h2><span id='topic+SCES_A'></span>

<h3>Description</h3>

<p>This function computes the standard CES demand
coefficient matrix (i.e. Theta==Beta), which is a wrapper of CES_A of CGE package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SCES_A(sigma = 1 - 1/es, alpha, Beta, p, es = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SCES_A_+3A_sigma">sigma</code></td>
<td>
<p>a numeric m-vector or m-by-1 matrix. 1/(1-sigma) is the elasticity of substitution.</p>
</td></tr>
<tr><td><code id="SCES_A_+3A_alpha">alpha</code></td>
<td>
<p>a nonnegative numeric m-vector or m-by-1 matrix.</p>
</td></tr>
<tr><td><code id="SCES_A_+3A_beta">Beta</code></td>
<td>
<p>a nonnegative numeric n-by-m matrix, where the sum of each column is equal to 1.
If a vector is provided, then it will be converted into a single-column matrix.</p>
</td></tr>
<tr><td><code id="SCES_A_+3A_p">p</code></td>
<td>
<p>a nonnegative numeric n-vector or n-by-1 matrix.</p>
</td></tr>
<tr><td><code id="SCES_A_+3A_es">es</code></td>
<td>
<p>a numeric m-vector or m-by-1 matrix of elasticity of substitution. If es is not NA, the value of sigma will be ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A demand coefficient n-by-m matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SCES_A(-1, 1, c(0.9, 0.1), c(1, 1))
SCES_A(alpha = 1, Beta = c(0.9, 0.1), p = c(1, 1), es = 0.5)
SCES_A(0, 1, c(0.9, 0.1), c(1, 1))
beta &lt;- c(0.9, 0.1)
CD_A(prod(beta^-beta), c(0.9, 0.1), c(1, 1))

####
SCES_A(0, 1, c(0.9, 0.1, 0), c(1, 1, 1))

####
input &lt;- matrix(c(
  200, 300, 100,
  150, 320, 530,
  250, 380, 0
), 3, 3, TRUE)
Beta &lt;- prop.table(input, 2)
SCES_A(sigma = rep(0, 3), alpha = c(1, 1, 1), Beta = Beta, p = c(1, 1, 1))
SCES_A(sigma = rep(-Inf, 3), alpha = c(1, 1, 1), Beta = Beta, p = c(1, 1, 1))
</code></pre>

<hr>
<h2 id='sdm_dstl'>Structural Dynamic Model (alias Structural Growth Model) with a Demand Structure Tree List</h2><span id='topic+sdm_dstl'></span>

<h3>Description</h3>

<p>This is a wrapper of the function CGE::sdm.
The parameter A of CGE::sdm is replaced with a demand structure tree list.
This function can be replaced by the more comprehensive function <code><a href="#topic+sdm2">sdm2</a></code>,
so it is not recommended.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdm_dstl(dstl, names.commodity, names.agent, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdm_dstl_+3A_dstl">dstl</code></td>
<td>
<p>a demand structure tree list.</p>
</td></tr>
<tr><td><code id="sdm_dstl_+3A_names.commodity">names.commodity</code></td>
<td>
<p>names of commodities.</p>
</td></tr>
<tr><td><code id="sdm_dstl_+3A_names.agent">names.agent</code></td>
<td>
<p>names of agents.</p>
</td></tr>
<tr><td><code id="sdm_dstl_+3A_...">...</code></td>
<td>
<p>arguments to be passed to the function CGE::sdm.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A general equilibrium, which is a list with the following elements:
</p>

<ul>
<li><p> D - the demand matrix.
</p>
</li>
<li><p> DV - the demand value matrix.
</p>
</li>
<li><p> SV - the supply value matrix.
</p>
</li>
<li><p> ... - some elements returned by the CGE::sdm function
</p>
</li></ul>



<h3>References</h3>

<p>LI Wu (2019, ISBN: 9787521804225) General Equilibrium and Structural Dynamics: Perspectives of New Structural Economics. Beijing: Economic Science Press. (In Chinese)
</p>
<p>LI Wu (2010) A Structural Growth Model and its Applications to Sraffa's System. http://www.iioa.org/conferences/18th/papers/files/104_20100729011_AStructuralGrowthModelanditsApplicationstoSraffasSstem.pdf
</p>
<p>Manuel Alejandro Cardenete, Ana-Isabel Guerra, Ferran Sancho (2012, ISBN: 9783642247453) Applied General Equilibrium: An Introduction. Springer-Verlag Berlin Heidelberg.
</p>
<p>Torres, Jose L. (2016, ISBN: 9781622730452) Introduction to Dynamic Macroeconomic General Equilibrium Models (Second Edition). Vernon Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sdm2">sdm2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### a pure exchange economy with two agents and two commodities
dst.CHN &lt;- node_new("util.CHN",
                    type = "SCES", alpha = 1, beta = c(0.8, 0.2), es = 2,
                    "lab.CHN", "lab.ROW"
)
node_plot(dst.CHN)

dst.ROW &lt;- node_new("util.ROW",
                    type = "SCES", alpha = 1, beta = c(0.05, 0.95), es = 2,
                    "lab.CHN", "lab.ROW"
)

dstl &lt;- list(dst.CHN, dst.ROW)

ge &lt;- sdm_dstl(dstl,
               names.commodity = c("lab.CHN", "lab.ROW"),
               names.agent = c("CHN", "ROW"),
               B = matrix(0, 2, 2, TRUE),
               S0Exg = matrix(c(
                 100, 0,
                 0, 600
               ), 2, 2, TRUE)
)

## supply change
geSC &lt;- sdm_dstl(dstl,
                 names.commodity = c("lab.CHN", "lab.ROW"),
                 names.agent = c("CHN", "ROW"),
                 B = matrix(0, 2, 2, TRUE),
                 S0Exg = matrix(c(
                   200, 0,
                   0, 600
                 ), 2, 2, TRUE)
)

geSC$p / ge$p

## preference change
dst.CHN$beta &lt;- c(0.9, 0.1)
gePC &lt;- sdm_dstl(dstl,
                 names.commodity = c("lab.CHN", "lab.ROW"),
                 names.agent = c("CHN", "ROW"),
                 B = matrix(0, 2, 2, TRUE),
                 S0Exg = matrix(c(
                   100, 0,
                   0, 600
                 ), 2, 2, TRUE)
)

gePC$p / ge$p


#### a pure exchange economy with two agents and four basic commodities
prod.CHN &lt;- node_new("prod.CHN",
                     type = "SCES", alpha = 1, beta = c(0.5, 0.5), es = 0.75,
                     "lab.CHN", "cap.CHN"
)

node_plot(prod.CHN)

prod.ROW &lt;- node_new("prod.ROW",
                     type = "SCES", alpha = 2, beta = c(0.4, 0.6), es = 0.75,
                     "lab.ROW", "cap.ROW"
)

dst.CHN &lt;- node_new("CHN",
                    type = "SCES", alpha = 1, beta = c(0.8, 0.2), es = 2,
                    prod.CHN, prod.ROW
)

node_plot(dst.CHN)
node_print(dst.CHN)
p &lt;- c("lab.CHN" = 1, "cap.CHN" = 1, "lab.ROW" = 1, "cap.ROW" = 1)
demand_coefficient(dst.CHN, p)


dst.ROW &lt;- node_new("ROW",
                    type = "SCES", alpha = 1, beta = c(0.05, 0.95), es = 2,
                    prod.CHN, prod.ROW
)

node_plot(dst.ROW)
node_print(dst.ROW)

dstl &lt;- list(dst.CHN, dst.ROW)

ge &lt;- sdm_dstl(dstl,
               names.commodity = c("lab.CHN", "cap.CHN", "lab.ROW", "cap.ROW"),
               names.agent = c("CHN", "ROW"),
               B = matrix(0, 4, 2, TRUE),
               S0Exg = matrix(c(
                 100, 0,
                 100, 0,
                 0, 600,
                 0, 800
               ), 4, 2, TRUE)
)


## Add currencies to the example above.
prod_money.CHN &lt;- node_new("prod_money.CHN",
                           type = "FIN", rate = c(1, 0.1), # 0.1 is the interest rate.
                           prod.CHN, "money.CHN"
)

prod_money.ROW &lt;- node_new("prod_money.ROW",
                           type = "FIN", rate = c(1, 0.1),
                           prod.ROW, "money.ROW"
)

dst.CHN &lt;- node_new("util.CHN",
                    type = "SCES", alpha = 1, beta = c(0.8, 0.2), es = 2,
                    prod_money.CHN, prod_money.ROW
)

dst.ROW &lt;- node_new("util.ROW",
                    type = "SCES", alpha = 1, beta = c(0.05, 0.95), es = 2,
                    prod_money.CHN, prod_money.ROW
)

dstl &lt;- list(dst.CHN, dst.ROW)

ge &lt;- sdm_dstl(dstl,
               names.commodity = c(
                 "lab.CHN", "cap.CHN", "money.CHN",
                 "lab.ROW", "cap.ROW", "money.ROW"
               ),
               names.agent = c("CHN", "ROW"),
               B = matrix(0, 6, 2, TRUE),
               S0Exg = matrix(c(
                 100, 0,
                 100, 0,
                 100, 0,
                 0, 600,
                 0, 800,
                 0, 100
               ), 6, 2, TRUE)
)

ge$p["money.ROW"] / ge$p["money.CHN"] # the exchange rate


#### Example 7.6 in Li (2019), which illustrates foreign exchange rates.
interest.rate.CHN &lt;- 0.1
interest.rate.ROW &lt;- 0.1

firm.CHN &lt;- node_new("output.CHN",
                     type = "FIN", rate = c(1, interest.rate.CHN),
                     "cc1.CHN", "money.CHN"
)
node_set(firm.CHN, "cc1.CHN",
         type = "CD", alpha = 1, beta = c(0.5, 0.5),
         "lab.CHN", "iron"
)

household.CHN &lt;- node_new("util",
                          type = "FIN", rate = c(1, interest.rate.CHN),
                          "wheat", "money.CHN"
)

moneylender.CHN &lt;- Clone(household.CHN)


firm.ROW &lt;- node_new("output.ROW",
                     type = "FIN", rate = c(1, interest.rate.ROW),
                     "cc1.ROW", "money.ROW"
)
node_set(firm.ROW, "cc1.ROW",
         type = "CD", alpha = 1, beta = c(0.5, 0.5),
         "iron", "lab.ROW"
)

household.ROW &lt;- node_new("util",
                          type = "FIN", rate = c(1, interest.rate.ROW),
                          "wheat", "money.ROW"
)

moneylender.ROW &lt;- Clone(household.ROW)


dstl &lt;- list(
  firm.CHN, household.CHN, moneylender.CHN,
  firm.ROW, household.ROW, moneylender.ROW
)

ge &lt;- sdm_dstl(dstl,
               names.commodity = c(
                 "wheat", "lab.CHN", "money.CHN",
                 "iron", "lab.ROW", "money.ROW"
               ),
               names.agent = c(
                 "firm.CHN", "household.CHN", "moneylender.CHN",
                 "firm.ROW", "household.ROW", "moneylender.ROW"
               ),
               B = {
                 tmp &lt;- matrix(0, 6, 6)
                 tmp[1, 1] &lt;- 1
                 tmp[4, 4] &lt;- 1
                 tmp
               },
               S0Exg = {
                 tmp &lt;- matrix(NA, 6, 6)
                 tmp[2, 2] &lt;- 100
                 tmp[3, 3] &lt;- 600
                 tmp[5, 5] &lt;- 100
                 tmp[6, 6] &lt;- 100
                 tmp
               }
)

ge$p.money &lt;- ge$p
ge$p.money["money.CHN"] &lt;- ge$p["money.CHN"] / interest.rate.CHN
ge$p.money["money.ROW"] &lt;- ge$p["money.ROW"] / interest.rate.ROW
ge$p.money &lt;- ge$p.money / ge$p.money["money.CHN"]

ge$p.money["money.ROW"] / ge$p.money["money.CHN"] # the exchange rate


#### the example (see Table 2.1 and 2.2) of the canonical dynamic
#### macroeconomic general equilibrium model in Torres (2016).
discount.factor &lt;- 0.97
return.rate &lt;- 1 / discount.factor - 1
depreciation.rate &lt;- 0.06

production.firm &lt;- node_new("output",
                            type = "CD", alpha = 1, beta = c(0.65, 0.35),
                            "labor", "capital.goods"
)

household &lt;- node_new("util",
                      type = "CD", alpha = 1, beta = c(0.4, 0.6),
                      "product", "labor"
)

leasing.firm &lt;- node_new("output",
                         type = "FIN", rate = c(1, return.rate),
                         "product", "dividend"
)

dstl &lt;- list(
  production.firm, household, leasing.firm
)

ge &lt;- sdm_dstl(dstl,
               names.commodity = c("product", "labor", "capital.goods", "dividend"),
               names.agent = c("production.firm", "household", "leasing.firm"),
               B = matrix(c(
                 1, 0, 1 - depreciation.rate,
                 0, 1, 0,
                 0, 0, 1,
                 0, 1, 0
               ), 4, 3, TRUE),
               S0Exg = {
                 tmp &lt;- matrix(NA, 4, 3)
                 tmp[2, 2] &lt;- 1
                 tmp[4, 2] &lt;- 1
                 tmp
               },
               priceAdjustmentVelocity = 0.03,
               maxIteration = 1,
               numberOfPeriods = 15000,
               ts = TRUE
)

ge$D # the demand matrix
ge$p / ge$p[1]

plot(ge$ts.z[, 1], type = "l")


#### an example of applied general equilibrium (see section 3.4, Cardenete et al., 2012).
dst.consumer1 &lt;- node_new("util",
                          type = "CD", alpha = 1, beta = c(0.3, 0.7),
                          "prod1", "prod2"
)

dst.consumer2 &lt;- node_new("util",
                          type = "CD", alpha = 1, beta = c(0.6, 0.4),
                          "prod1", "prod2"
)

dst.firm1 &lt;- node_new("output",
                      type = "Leontief", a = c(0.5, 0.2, 0.3),
                      "VA", "prod1", "prod2"
)
node_set(dst.firm1, "VA",
         type = "CD",
         alpha = 0.8^-0.8 * 0.2^-0.2, beta = c(0.8, 0.2),
         "lab", "cap"
)

dst.firm2 &lt;- Clone(dst.firm1)
dst.firm2$a &lt;- c(0.25, 0.5, 0.25)
node_set(dst.firm2, "VA",
         alpha = 0.4^-0.4 * 0.6^-0.6, beta = c(0.4, 0.6)
)

node_print(dst.firm2)

dstl &lt;- list(dst.firm1, dst.firm2, dst.consumer1, dst.consumer2)

ge &lt;- sdm_dstl(dstl,
               names.commodity = c("prod1", "prod2", "lab", "cap"),
               names.agent = c("firm1", "firm2", "consumer1", "consumer2"),
               B = {
                 tmp &lt;- matrix(0, 4, 4)
                 tmp[1, 1] &lt;- 1
                 tmp[2, 2] &lt;- 1
                 tmp
               },
               S0Exg = {
                 tmp &lt;- matrix(NA, 4, 4)
                 tmp[3, 3] &lt;- 30
                 tmp[4, 3] &lt;- 20
                 tmp[3, 4] &lt;- 20
                 tmp[4, 4] &lt;- 5
                 tmp
               }
)


</code></pre>

<hr>
<h2 id='sdm2'>Structural Dynamic Model (alias Structural Growth Model) Version 2</h2><span id='topic+sdm2'></span>

<h3>Description</h3>

<p>A new version of the sdm function in the package CGE.
Now the parameter A can be a demand structure tree list.
Hence we actually no longer need the function <code><a href="#topic+sdm_dstl">sdm_dstl</a></code>.
Some rarely used parameters in the function sdm have been deleted.
This function is the core of this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdm2(
  A,
  B,
  S0Exg = matrix(NA, nrow(B), ncol(B)),
  names.commodity = paste("comm", 1:nrow(B), sep = ""),
  names.agent = paste("agt", 1:ncol(B), sep = ""),
  p0 = matrix(1, nrow = nrow(B), ncol = 1),
  z0 = matrix(100, nrow = ncol(B), ncol = 1),
  GRExg = NA,
  pExg = NULL,
  numeraire = NULL,
  tolCond = 1e-05,
  maxIteration = 200,
  numberOfPeriods = 300,
  depreciationCoef = 0.8,
  priceAdjustmentFunction = NULL,
  priceAdjustmentVelocity = 0.15,
  trace = TRUE,
  ts = FALSE,
  policy = NULL,
  exchangeFunction = F_Z
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdm2_+3A_a">A</code></td>
<td>
<p>a demand structure tree list (i.e. dstl, see <code><a href="#topic+demand_coefficient">demand_coefficient</a></code>), a demand coefficient n-by-m matrix (alias demand structure matrix)
or a function A(state) which returns an n-by-m matrix.
n is the number of commodity types. m is the number of economic agents.
The argument state is a list consisting of time (the current time), p (the current price vector),
last.z (the output and utility vector of the previous period), w (the current wealth vector) and last.A (the demand coefficient matrix of the previous period).</p>
</td></tr>
<tr><td><code id="sdm2_+3A_b">B</code></td>
<td>
<p>an n-by-m matrix containing of the output coefficients of producers.
Each producer produces one or more commodities.
The output of each producer is equal to its activity level multiplied by the output coefficients.
Columns corresponding to consumers are usually zeros.
If the (i,j)-th element of S0Exg is not NA, the value of the (i,j)-th element of B will be useless and ignored.</p>
</td></tr>
<tr><td><code id="sdm2_+3A_s0exg">S0Exg</code></td>
<td>
<p>an initial exogenous supply n-by-m matrix.
If the (i,j)-th element of S0Exg is zero, it means there is no supply,
and NA means the exogenous part of the supply is zero
and there may be an endogenous supply part.
In most cases, this matrix contains NA values but no zeros.</p>
</td></tr>
<tr><td><code id="sdm2_+3A_names.commodity">names.commodity</code></td>
<td>
<p>names of commodities.
If the parameter A is a demand structure tree list, the values in names.commodity should be the names of those leaf nodes.</p>
</td></tr>
<tr><td><code id="sdm2_+3A_names.agent">names.agent</code></td>
<td>
<p>names of agents.</p>
</td></tr>
<tr><td><code id="sdm2_+3A_p0">p0</code></td>
<td>
<p>an initial price n-vector.</p>
</td></tr>
<tr><td><code id="sdm2_+3A_z0">z0</code></td>
<td>
<p>an m-vector consisting of the initial purchase levels (i.e. exchange levels) which indicate production levels or utility levels.</p>
</td></tr>
<tr><td><code id="sdm2_+3A_grexg">GRExg</code></td>
<td>
<p>an exogenous growth rate of the exogenous supplies in S0Exg.
If GRExg is NA and some commodities have exogenous supply, then GRExg will be set to 0.</p>
</td></tr>
<tr><td><code id="sdm2_+3A_pexg">pExg</code></td>
<td>
<p>an n-vector indicating the exogenous prices (if any).</p>
</td></tr>
<tr><td><code id="sdm2_+3A_numeraire">numeraire</code></td>
<td>
<p>the name, index or price of the numeraire commodity.
If it is a character string, then it is assumed to be the name of the numeraire commodity.
If it is a number without a name, then it is assumed to be the index of the numeraire commodity.
If it is a number with a name, e.g. c(&quot;lab&quot; = 0.5), then the name is assumed to be the name of the numeraire commodity
and the number is assumed to be the price of the numeraire commodity,
even though the price of the numeraire commodity usually is 1.</p>
</td></tr>
<tr><td><code id="sdm2_+3A_tolcond">tolCond</code></td>
<td>
<p>the relative tolerance condition.</p>
</td></tr>
<tr><td><code id="sdm2_+3A_maxiteration">maxIteration</code></td>
<td>
<p>the maximum number of (outer) iterations.
If the main purpose of running this function is to do simulation instead of calculating equilibrium, then maxIteration should be set to 1.</p>
</td></tr>
<tr><td><code id="sdm2_+3A_numberofperiods">numberOfPeriods</code></td>
<td>
<p>the period number (i.e. the number of inner iterations) in each (outer) iteration, which should not be less than 20.</p>
</td></tr>
<tr><td><code id="sdm2_+3A_depreciationcoef">depreciationCoef</code></td>
<td>
<p>the depreciation coefficient (i.e. 1 minus the depreciation rate) of the unsold products.</p>
</td></tr>
<tr><td><code id="sdm2_+3A_priceadjustmentfunction">priceAdjustmentFunction</code></td>
<td>
<p>the price adjustment function. The arguments are a price n-vector p and a sales rate n-vector q.
The return value is a price n-vector. The default price adjustment method is p * (1 - priceAdjustmentVelocity * (1 - q)).</p>
</td></tr>
<tr><td><code id="sdm2_+3A_priceadjustmentvelocity">priceAdjustmentVelocity</code></td>
<td>
<p>a scalar or an n-vector specifying the price adjustment velocity.</p>
</td></tr>
<tr><td><code id="sdm2_+3A_trace">trace</code></td>
<td>
<p>if TRUE, information is printed during the running of sdm2.</p>
</td></tr>
<tr><td><code id="sdm2_+3A_ts">ts</code></td>
<td>
<p>if TRUE, the time series of the last outer iteration are returned.</p>
</td></tr>
<tr><td><code id="sdm2_+3A_policy">policy</code></td>
<td>
<p>a policy function or a list consisting of policy functions and/or policy function lists. A policy function has the following optional parameters:
</p>

<ul>
<li><p> time - the current time.
</p>
</li>
<li><p> A - the same as the parameter A of sdm2.
When A is a demand structure tree list, it needs not be returned after it is adjusted.
</p>
</li>
<li><p> state - the current state, which is a list.
state$p is the current price vector with names.
state$S is the current supply matrix.
state$last.z is the output and utility vector of the previous period.
state$B is the current supply coefficient matrix.
state$last.A is the demand coefficient matrix of the previous period.
state$names.commodity contains the names of commodities.
state$names.agent contains the names of agents.
</p>
</li>
<li><p> state.history - the state history, which is a list consisting of the time series of p, S, q, and z.
</p>
</li></ul>

<p>The return value of the policy function other than a list will be ignored.
If the return value is a list, it should have elements p, S and B which specify the prices, supplies and supply coefficient matrix after adjustment.
A vector with the name current.policy.data can be put into the state list as well,
which will be put into the return value of the sdm2.</p>
</td></tr>
<tr><td><code id="sdm2_+3A_exchangefunction">exchangeFunction</code></td>
<td>
<p>the exchange function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In each period of the structural dynamic model, the economy runs as follows. <br />
Firstly, the new price vector emerges on the basis of the price vector and sales rates of the previous period, which indicates the current market prices. <br />
Secondly, outputs and depreciated inventories of the previous period constitute the current supplies.<br />
Thirdly, policy functions (if any) are implemented.<br />
Fourthly, the current input coefficient matrix is computed and the supplies are exchanged under market prices. The exchange vector and sales rate vector are obtained. Unsold goods constitute the inventories, which will undergo depreciation and become a portion of the supplies of the next period. The exchange vector determines the current outputs and utility levels.
</p>


<h3>Value</h3>

<p>A list usually containing the following components:
</p>

<ul>
<li><p> tolerance - the relative tolerance of the results.
</p>
</li>
<li><p> p - equilibrium prices.
</p>
</li>
<li><p> z - equilibrium purchase levels (i.e. production levels or utility levels).
</p>
</li>
<li><p> S - the equilibrium supply matrix at the initial period.
</p>
</li>
<li><p> growthRate	- the endogenous equilibrium growth rate in a pure production economy.
</p>
</li>
<li><p> A - the equilibrium demand coefficient matrix.
</p>
</li>
<li><p> B - the supply coefficient matrix.
</p>
</li>
<li><p> S0Exg - the initial exogenous supply n-by-m matrix.
</p>
</li>
<li><p> D - the demand matrix.
</p>
</li>
<li><p> DV - the demand value matrix.
</p>
</li>
<li><p> SV - the supply value matrix.
</p>
</li>
<li><p> ts.p	- the time series of prices in the last outer iteration.
</p>
</li>
<li><p> ts.z - the time series of purchase levels (i.e. production levels or utility levels) in the last outer iteration.
</p>
</li>
<li><p> ts.S - the time series of supply matrix in the last outer iteration.
</p>
</li>
<li><p> ts.q - the time series of sales rates in the last outer iteration.
</p>
</li>
<li><p> policy.data - the policy data.
</p>
</li></ul>



<h3>Note</h3>

<p>In the package CGE, the spot market clearing path (alias instantaneous equilibrium path) is computed by the function iep.
In this package, the instantaneous equilibrium path can be computed by the function sdm2 with the parameter policy equal to <code><a href="#topic+policyMarketClearingPrice">policyMarketClearingPrice</a></code>.<br />
</p>
<p>The order of implementation of various policies is critical.
When a policy list contains a supply policy, a technology (i.e. dstl) policy, a price policy (e.g. a market-clearing-price policy) and a B policy
(i.e. a policy adjusting the argument B), both the supply policy and the technology policy should be placed before the price policy,
and the B policy should be placed after the price policy.
The reason is that the calculation of the current prices may require the use of supply and technology,
while the calculation of B may require the use of the current prices.
</p>


<h3>References</h3>

<p>LI Wu (2019, ISBN: 9787521804225) General Equilibrium and Structural Dynamics: Perspectives of New Structural Economics. Beijing: Economic Science Press. (In Chinese)
</p>
<p>LI Wu (2010) A Structural Growth Model and its Applications to Sraffa's System. http://www.iioa.org/conferences/18th/papers/files/104_20100729011_AStructuralGrowthModelanditsApplicationstoSraffasSstem.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dst.firm &lt;- node_new("output",
  type = "Leontief", a = c(0.5, 1),
  "prod", "lab"
)

dst.consumer &lt;- node_new("utility",
  type = "Leontief", a = 1, "prod"
)

dstl &lt;- list(dst.firm, dst.consumer)

B &lt;- matrix(c(
  1, 0,
  0, 0
), 2, 2, TRUE)
S0Exg &lt;- matrix(c(
  NA, NA,
  NA, 100
), 2, 2, TRUE)

## variable dst and technology progress
policy.TP &lt;- function(time, state, A) {
  if (time &gt;= 200) {
    A[[1]]$a &lt;- c(0.5, 0.8)
  } else {
    A[[1]]$a &lt;- c(0.5, 1)
  }
  state
}

ge.TP &lt;- sdm2(
  A = dstl, B = B, S0Exg = S0Exg,
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  policy = policy.TP,
  ts = TRUE,
  maxIteration = 1,
  numberOfPeriods = 1000
)
matplot(ge.TP$ts.z, type = "l")
plot(ge.TP$ts.p[, 1] / ge.TP$ts.p[, 2], type = "l")

## variable supply coefficient matrix and technology progress
policy.TP &lt;- function(time, state) {
  if (time &gt;= 200) {
    state$B[1, 1] &lt;- 2
  } else {
    state$B[1, 1] &lt;- 1
  }
  state
}

ge.TP &lt;- sdm2(
  A = dstl, B = B, S0Exg = S0Exg,
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  policy = policy.TP,
  ts = TRUE,
  maxIteration = 1,
  numberOfPeriods = 1000
)
matplot(ge.TP$ts.z, type = "l")
plot(ge.TP$ts.p[, 1] / ge.TP$ts.p[, 2], type = "l")

## variable dst and disequilibrium
policy.DE &lt;- function(time, A) {
  if (time &gt;= 200) {
    A[[1]]$a[2] &lt;- A[[1]]$a[2] * 0.999
  } else {
    A[[1]]$a[2] &lt;- 1
  }
}

ge.DE &lt;- sdm2(
  A = dstl, B = B, S0Exg = S0Exg,
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  policy = policy.DE,
  ts = TRUE,
  maxIteration = 1,
  numberOfPeriods = 1000
)
matplot(ge.DE$ts.z, type = "l")
plot(ge.DE$ts.p[, 1] / ge.DE$ts.p[, 2], type = "l")


## structural equilibria and structural transition
policy.SE &lt;- function(time, state, A) {
  A[[1]]$a[2] &lt;- structural_function(state$last.z[1], c(105, 125), 1, 0.5)
}

ge.low.level &lt;- sdm2(
  A = dstl, B = B, S0Exg = S0Exg,
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  policy = policy.SE,
  ts = TRUE,
  maxIteration = 1,
  numberOfPeriods = 1000,
  z0 = c(100, 0)
)
matplot(ge.low.level$ts.z, type = "l")

ge.high.level &lt;- sdm2(
  A = dstl, B = B, S0Exg = S0Exg,
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  policy = policy.SE,
  ts = TRUE,
  maxIteration = 1,
  numberOfPeriods = 1000,
  z0 = c(150, 0)
)
matplot(ge.high.level$ts.z, type = "l")

policy.ST &lt;- function(time, state, A) {
  A[[1]]$a[2] &lt;- structural_function(state$last.z[1], c(105, 125), 1, 0.5)
  if (time &gt;= 200 &amp;&amp; time &lt;= 210) state$S[2, 2] &lt;- 125 # Introduce foreign labor.
  state
}

ge.ST &lt;- sdm2(
  A = dstl, B = B, S0Exg = S0Exg,
  names.commodity = c("prod", "lab"),
  names.agent = c("firm", "consumer"),
  policy = policy.ST,
  ts = TRUE,
  maxIteration = 1,
  numberOfPeriods = 1000,
  z0 = c(100, 0)
)
matplot(ge.ST$ts.z, type = "l")

#### economic cycles and an interest rate policy for the firm
dst.firm &lt;- node_new("cc", # composite commodity
  type = "FIN",
  rate = c(1, 0.25),
  "cc1", "money"
)
node_set(dst.firm, "cc1",
  type = "Leontief",
  a = c(0.5, 0.5),
  "wheat", "labor"
)

dst.laborer &lt;- Clone(dst.firm)
dst.money.lender &lt;- Clone(dst.firm)

dstl &lt;- list(dst.firm, dst.laborer, dst.money.lender)

policy.interest.rate &lt;- function(time, state, A, state.history) {
  upsilon &lt;- NA
  if (time &gt;= 600) {
    upsilon &lt;- state.history$z[time - 1, 1] / mean(state.history$z[(time - 50):(time - 1), 1])
    A[[1]]$rate[2] &lt;- max(0.25 + 0.5 * log(upsilon), 0)
  } else {
    A[[1]]$rate[2] &lt;- 0.25
  }

  state$current.policy.data &lt;- c(time, A[[1]]$rate[2], upsilon)
  state
}

B &lt;- matrix(0, 3, 3)
B[1, 1] &lt;- 1

S0Exg &lt;- matrix(NA, 3, 3)
S0Exg[2, 2] &lt;- 100
S0Exg[3, 3] &lt;- 100

de &lt;- sdm2(
  A = dstl, B = B, S0Exg = S0Exg,
  names.commodity = c("wheat", "labor", "money"),
  names.agent = c("firm", "laborer", "money.lender"),
  p0 = rbind(0.625, 0.375, 0.25),
  z0 = rbind(95, 0, 0),
  priceAdjustmentVelocity = 0.3,
  numberOfPeriods = 1000,
  maxIteration = 1,
  trace = FALSE,
  ts = TRUE
)
matplot(de$ts.z, type = "l")

ge.policy &lt;- sdm2(
  A = dstl, B = B, S0Exg = S0Exg,
  names.commodity = c("wheat", "labor", "money"),
  names.agent = c("firm", "laborer", "money.lender"),
  p0 = rbind(0.625, 0.375, 0.25),
  z0 = rbind(95, 0, 0),
  priceAdjustmentVelocity = 0.3,
  numberOfPeriods = 1000,
  maxIteration = 1,
  trace = FALSE,
  ts = TRUE,
  policy = policy.interest.rate
)
matplot(ge.policy$ts.z, type = "l")

#### Example 9.3 in Li (2019): fixed-ratio price adjustment method
#### and disequilibrium (business cycles) in a pure production economy
fixedRatioPriceAdjustmentFunction &lt;- function(p, q) {
  thresholdForPriceAdjustment &lt;- 0.99
  priceAdjustmentVelocity &lt;- 0.02
  result &lt;- ifelse(q &lt;= thresholdForPriceAdjustment,
    p * (1 - priceAdjustmentVelocity),
    p
  )
  return(prop.table(result))
}

de.Sraffa &lt;- sdm2(
  A = matrix(c(
    56 / 115, 6,
    12 / 575, 2 / 5
  ), 2, 2, TRUE),
  B = diag(2),
  maxIteration = 1,
  numberOfPeriods = 100,
  p0 = rbind(1 / 15, 1),
  z0 = rbind(575, 20),
  priceAdjustmentFunction = fixedRatioPriceAdjustmentFunction,
  ts = TRUE
)
matplot(growth_rate(de.Sraffa$ts.z), type = "l")


</code></pre>

<hr>
<h2 id='sserr'>Compute the Return Rate in the Steady State Equilibrium</h2><span id='topic+sserr'></span>

<h3>Description</h3>

<p>Compute the (postpaid) return rate in the steady state equilibrium.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sserr(eis, Gamma.beta, gr = 0, type = "CES", prepaid = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sserr_+3A_eis">eis</code></td>
<td>
<p>a positive scalar indicating the elasticity of intertemporal substitution in the intertemporal utility function.</p>
</td></tr>
<tr><td><code id="sserr_+3A_gamma.beta">Gamma.beta</code></td>
<td>
<p>a positive scalar indicating the subjective discount factor, which is typically no greater than 1.</p>
</td></tr>
<tr><td><code id="sserr_+3A_gr">gr</code></td>
<td>
<p>a non-negative scalar indicating the growth rate in the steady state equilibrium.</p>
</td></tr>
<tr><td><code id="sserr_+3A_type">type</code></td>
<td>
<p>a character indicating the type of the intertemporal utility function, which may be CES (i.e. CRRA) or SCES.</p>
</td></tr>
<tr><td><code id="sserr_+3A_prepaid">prepaid</code></td>
<td>
<p>a logical value. If prepaid is FALSE, the return rate is returned.
Otherwise the prepaid steady-state equilibrium return rate (i.e. the current yield rate) is returned.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
sserr(eis = 1, Gamma.beta = 0.97, gr = 0)
sserr(eis = 1, Gamma.beta = 1.25, gr = 0)
sserr(eis = 1, Gamma.beta = 0.97, gr = 0, type = "SCES")

sserr(eis = 0.5, Gamma.beta = 0.97, gr = 0)
sserr(eis = 0.5, Gamma.beta = 0.97, gr = 0, type = "SCES")


</code></pre>

<hr>
<h2 id='structural_function'>Structural Function</h2><span id='topic+structural_function'></span>

<h3>Description</h3>

<p>A structured function is a kind of kinked (piecewise) function generated by connecting two
functions through a transition region.
This function calculates the value of a structured function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>structural_function(theta, transition.interval, f1, f2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="structural_function_+3A_theta">theta</code></td>
<td>
<p>the track switching parameter, which is a scalar.</p>
</td></tr>
<tr><td><code id="structural_function_+3A_transition.interval">transition.interval</code></td>
<td>
<p>a 2-vector.</p>
</td></tr>
<tr><td><code id="structural_function_+3A_f1">f1</code></td>
<td>
<p>the first function (or a value).</p>
</td></tr>
<tr><td><code id="structural_function_+3A_f2">f2</code></td>
<td>
<p>the second function (or a value).</p>
</td></tr>
<tr><td><code id="structural_function_+3A_...">...</code></td>
<td>
<p>parameters of f1 and f2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the structural function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(1, 5, 0.1)
y &lt;- c()
for (theta in x) y &lt;- c(y, structural_function(theta, c(2, 3), log, sqrt, theta))
plot(x, y)
lines(x, log(x), col = "blue")
lines(x, sqrt(x), col = "red")

####
f &lt;- function(theta) {
  p &lt;- c(1, 1)
  structural_function(
    theta,
    c(15, 20),
    function(p) CD_A(alpha = 5, Beta = c(0.6, 0.4), p),
    function(p) CD_A(alpha = 15, Beta = c(0.3, 0.7), p),
    p
  )
}

tmp &lt;- sapply(1:25, f)
matplot(t(tmp), type = "l")
</code></pre>

<hr>
<h2 id='var.p'>Population Variance and Population Standard Deviation</h2><span id='topic+var.p'></span><span id='topic+sd.p'></span>

<h3>Description</h3>

<p>The function var.p computes a population variance. The function sd.p computes a population standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.p(x, wt = rep(1, length(x)), na.rm = FALSE)

sd.p(x, wt = rep(1, length(x)), na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var.p_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
<tr><td><code id="var.p_+3A_wt">wt</code></td>
<td>
<p>a numeric vector of weights.
By default all elements of x are given the same weight.</p>
</td></tr>
<tr><td><code id="var.p_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical value indicating whether NA values should be stripped before the computation proceeds.</p>
</td></tr>
</table>


<h3>Functions</h3>


<ul>
<li> <p><code>var.p</code>: Population variance.
</p>
</li>
<li> <p><code>sd.p</code>: Population standard deviation.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>var.p(1:6)

var.p(x = 1:5, wt = 6:10)
var.p(x = rep(1:5, 6:10))

sd.p(x = 1:5, wt = 6:10)
sd.p(x = rep(1:5, 6:10))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
