<!DOCTYPE html><html><head><title>Help for package dbd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {dbd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#aHess'>
<p>Analytic hessian.</p></a></li>
<li><a href='#db'>
<p>The db (&ldquo;discretised Beta&rdquo;) distribution.</p></a></li>
<li><a href='#dbd-internal'><p>Internal Verdis functions.</p></a></li>
<li><a href='#eow'>
<p>Set or query the value of the <code>"maxitErrorOrWarn"</code> option.</p></a></li>
<li><a href='#exactMeDb'>
<p>Exact moment estimates for the db distribution.</p></a></li>
<li><a href='#expValBb'>
<p>Expected value of a beta binomial distribution.</p></a></li>
<li><a href='#expValDb'>
<p>Expected value of a db distribution.</p></a></li>
<li><a href='#finfo'>
<p>Fisher information.</p></a></li>
<li><a href='#gof'>
<p>Goodness of fit test for db and beta binomial distributions.</p></a></li>
<li><a href='#hrsRcePred'>
<p>Horse race prediction data.</p></a></li>
<li><a href='#llPlot'>
<p>Plot the log likelihood surface for the data.</p></a></li>
<li><a href='#logLik'>
<p>Retrieve the (maximised) log likelihood from an <code>"mleDb"</code> or</p>
an <code>"mleBb"</code> object.</a></li>
<li><a href='#makeBbdpars'>
<p>Create an object of class <code>"Bbdpars"</code>.</p></a></li>
<li><a href='#makeDbdpars'>
<p>Create an object of class <code>"Dbdpars"</code>.</p></a></li>
<li><a href='#mcCovMat'>
<p>Monte Carlo estimation of a covariance matrix.</p></a></li>
<li><a href='#mleBb'>
<p>Maximum likelihood estimation of the parameters of a beta binomial</p>
distribution.</a></li>
<li><a href='#mleDb'>
<p>Maximum likelihood estimates of db parameters.</p></a></li>
<li><a href='#ndata'>
<p>Retrieve the <code>"ndata"</code> attribute of an <code>"mleDb"</code></p>
object.</a></li>
<li><a href='#nHess'>
<p>Numerical hessian calculation.</p></a></li>
<li><a href='#plot.mleBb'>
<p>Plot a maxium likelihood fit to data from a beta binomial distribution.</p></a></li>
<li><a href='#plot.mleDb'>
<p>Plot a maxium likelihood fit to data from a db distribution.</p></a></li>
<li><a href='#plotBb'>
<p>Plot a beta binomial distribution.</p></a></li>
<li><a href='#plotDb'>
<p>Plot a db distribution.</p></a></li>
<li><a href='#simulate'>
<p>Simulate data from a db or beta binomial distribution.</p></a></li>
<li><a href='#varBb'>
<p>Variance of a beta binomial distribution.</p></a></li>
<li><a href='#varDb'>
<p>Variance of a db distribution.</p></a></li>
<li><a href='#vcov.mleBb'>
<p>Retrieve the covariance matrix from an <code>"mleBb"</code> object.</p></a></li>
<li><a href='#vcov.mleDb'>
<p>Retrieve the covariance matrix from an <code>"mleDb"</code> object.</p></a></li>
<li><a href='#visRecog'>
<p>Visual recognition data.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.0-22</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-08-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Discretised Beta Distribution</td>
</tr>
<tr>
<td>Author:</td>
<td>Rolf Turner &lt;r.turner@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rolf Turner &lt;r.turner@auckland.ac.nz&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for working with a new versatile
	discrete distribution, the db ("discretised Beta")
	distribution.  This package provides density (probability),
	distribution, inverse distribution (quantile) and random
	data generation functions for the db family.  It provides
	functions to effect conveniently maximum likelihood
	estimation of parameters, and a variety of useful plotting
	functions.  It provides goodness of fit tests and functions
	to calculate the Fisher information, different estimates of
	the hessian of the log likelihood and Monte Carlo estimation
	of the covariance matrix of the maximum likelihood parameter
	estimates.  In addition it provides analogous tools for
	working with the beta-binomial distribution which has been
	proposed as a competitor to the db distribution.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>hmm.discnp, MASS, rmutil, spcadjust</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-08-19 05:10:08 UTC; rolf</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-08-19 13:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='aHess'>
Analytic hessian.
</h2><span id='topic+aHess'></span>

<h3>Description</h3>

<p>Compute the hessian of the <b>negative</b> log likelihood of
a db or beta binomial distribution from an analytic expression
for this quantity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aHess(object,x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aHess_+3A_object">object</code></td>
<td>

<p>An object of class <code>"mleDb"</code> or <code>"mleBb"</code> as
returned by the function <code><a href="#topic+mleDb">mleDb</a>()</code> or the function
<code><a href="#topic+mleBb">mleBb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="aHess_+3A_x">x</code></td>
<td>

<p>A numeric vector of observations appropriate for the model that
was fitted to produce <code>object</code>.  Needed only if <code>object</code>
is of class <code>"mleBb"</code>; the hessian for the db distribution
depends only upon the parameters and not upon the data. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is essentially the same as the <code><a href="#topic+finfo">finfo</a>()</code>
functions and differs from it only in that it is designed to
act up <code>"mleDb"</code> or <code>"mleBb"</code> objects, from which
(estimates of) the relevant parameters are extracted.
</p>


<h3>Value</h3>

<p>A two-by-two positive definite (with any luck!) numeric matrix.
Its inverse is an estimate of the covariance matrix of the
parameter estimates.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+nHess">nHess</a>()</code>
<code><a href="#topic+finfo">finfo</a>()</code>
<code><a href="#topic+mleDb">mleDb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X   &lt;- hmm.discnp::SydColDisc
X$y &lt;- as.numeric(X$y)
X   &lt;- split(X,f=with(X,interaction(locn,depth)))
x   &lt;- X[[19]]$y
fit &lt;- mleDb(x, ntop=5)
H   &lt;- aHess(fit)
print(solve(H)) # Equal to ...
print(vcov(fit))
X     &lt;- hrsRcePred
top1e &lt;- X[X$sbjType=="Expert","top1"]
fit   &lt;- mleBb(top1e,size=10)
H     &lt;- aHess(fit,x=top1e)
print(solve(H)) # Equal to ...
print(vcov(fit))
</code></pre>

<hr>
<h2 id='db'>
The db (&ldquo;discretised Beta&rdquo;) distribution.
</h2><span id='topic+dbd'></span><span id='topic+ddb'></span><span id='topic+pdb'></span><span id='topic+qdb'></span><span id='topic+rdb'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the db
distribution with parameters <code>alpha</code>, <code>beta</code> and <code>ntop</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ddb(x, alpha, beta, ntop, zeta=FALSE, log=FALSE)
pdb(x, alpha, beta, ntop, zeta=FALSE)
qdb(p, alpha, beta, ntop, zeta=FALSE)
rdb(n, alpha, beta, ntop, zeta=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="db_+3A_x">x</code></td>
<td>

<p>Numeric vector of values at which the &ldquo;density&rdquo; (probability
mass function) <code>ddb()</code> and the cumulative distribution
function <code>pdb()</code> are evaluated.  Normally these would be
integer values between <code>nbot</code> and <code>ntop</code>, but they need
not be.  Note that <code>nbot</code> is 0 if <code>zeta</code> is <code>TRUE</code>,
and is 1 if <code>zeta</code> is <code>FALSE</code>.  A result of 0 is returned
by <code>ddb()</code> for values of <code>x</code> that do not satisfy the
foregoing criterion.  A warning is issued by <code>ddb()</code> if any
of the values in <code>x</code> are non-integer.  See section <b>Note</b>
for a little more information.  Missing values (<code>NA</code>) are
allowed; the corresponding results are <code>NA</code>.
</p>
</td></tr>
<tr><td><code id="db_+3A_alpha">alpha</code></td>
<td>

<p>Positive scalar.  The first &ldquo;shape&rdquo; parameter of the
db distribution.
</p>
</td></tr>
<tr><td><code id="db_+3A_beta">beta</code></td>
<td>

<p>Positive scalar.  The second &ldquo;shape&rdquo; parameter of the
db distribution.
</p>
</td></tr>
<tr><td><code id="db_+3A_ntop">ntop</code></td>
<td>

<p>Integer scalar, strictly greater than 1.  The maximum possible
value of the db distribution.
</p>
</td></tr>
<tr><td><code id="db_+3A_zeta">zeta</code></td>
<td>

<p>Logical scalar.  Should zero origin indexing be used?
I.e. should the range of values of the distribution be taken to
be <code>{0,1,2,...,ntop}</code> rather than <code>{1,2,...,ntop}</code>?
Setting <code>zeta=TRUE</code> may be useful for example when the values
of the distribution are to be interpreted as counts.
</p>
</td></tr>
<tr><td><code id="db_+3A_log">log</code></td>
<td>

<p>Logical scalar.  Should logs of the probabilities calculated by
<code>ddb()</code> be returned, rather than the actual probabilities?
</p>
</td></tr>
<tr><td><code id="db_+3A_p">p</code></td>
<td>

<p>Vector of probablilities (i.e. values between 0 and 1).  The
corresponding quantiles of the db distribution are calculated
by <code>qdb()</code>.  Missing values (<code>NA</code>) are allowed.
</p>
</td></tr>
<tr><td><code id="db_+3A_n">n</code></td>
<td>

<p>Integer scalar.  An independent sample of size <code>n</code> from the
db distribution is generated by <code>rdb()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the predecessor of this package (<code>hse</code> versions 0.1-15
and earlier), the probability function of the distribution
was calculated as <code>dbeta(x/(ntop+1),alpha,beta)/
sum(dbeta((nbot:ntop)/(ntop+k),alpha,beta))</code> where <code>nbot</code>
and <code>k</code> were set to 1 if <code>zeta</code> was <code>FALSE</code>,
and <code>nbot</code> was set to 0 and <code>k</code> to 2 if <code>zeta</code>
was <code>TRUE</code>.
</p>
<p>However the probability function is calculated in a more
&ldquo;direct&rdquo; manner, using an exponential family representation
of this function.  The <code>Beta</code> distribution is no longer called
upon (although it still of course conceptually underlies the
distribution).
</p>
<p>The function <code>ddb()</code> is a probability mass function for
an ad hoc finite discrete distribution of <em>ordered</em> values,
with a &ldquo;reasonably flexible&rdquo; shape.
</p>
<p>The <code class="reqn">p</code>th quantile of a random variable <code class="reqn">X</code> is defined to be
the infimum <em>over the range of</em> <code class="reqn">X</code> of those values of <code class="reqn">x</code>
such that <code class="reqn">F(x) \geq p</code> where <code class="reqn">F(x)</code> is the cumulative
distribution function for <code class="reqn">X</code>.  Note that if we did not impose the
&ldquo;over the range of <code class="reqn">X</code>&rdquo; restriction, then the 0th quantile of
e.g. an exponential distribution would be <code class="reqn">-\infty</code>
(since <code class="reqn">F(x) \geq 0</code> for <em>all</em> <code class="reqn">x</code>) whereas we
actually want this quantile to be 0.
</p>
<p>Consequently <code>qdb(p,alpha,beta,ntop)</code> is equal to the
least value of <code>i</code> such that <code>pdb(i,alpha,beta,ntop)</code>
<code class="reqn">\geq</code> <code>p</code>.  The set of values of <code>i</code> to be
considered is <code>{1,2,...,ntop}</code> if <code>zeta</code> is
<code>FALSE</code> and is <code>{0,1,2,...,ntop}</code> if <code>zeta</code>
is <code>TRUE</code>.
</p>


<h3>Value</h3>


<ul>
<li><p> For <code>ddb()</code> and <code>pdb()</code> vectors of probabilities.
</p>
</li>
<li><p> For <code>qdb()</code> a vector of quantiles.
</p>
</li>
<li><p> For <code>rdb()</code> a vector of length <code>n</code>, of integers
between <code>nbot</code> and <code>ntop</code>, independently sampled
from the db distribution, where <code>nbot</code> is 1 if
<code>zeta</code> is <code>FALSE</code> and is 0 if <code>zeta</code>
is <code>TRUE</code>.
</p>
</li></ul>



<h3>Note</h3>

<p>In the predecessor of this package (<code>hse</code>, versions 0.1-14
and earlier) the density/probability function threw an error if
any values of argument <code>i</code> were not in the set of integers
<code>nbot:ntop</code>.  In accordance with a suggestion from Duncan
Murdoch this behaviour was changed so that the density/probability
function returns 0 for such values.  It also issues a warning
if any of the values are non-integer.  The criterion used
for &ldquo;non-integer&rdquo; is that <code>abs(i-round(i)) &gt;
sqrt(.Machine$double.eps)</code>.  The new behaviour is analogous to
that of other probability functions used in R, <code>dbinom()</code>
in particular.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+meDb">meDb</a>()</code>
<code><a href="#topic+mleDb">mleDb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parz &lt;- list(c(0.5,0.5),c(5,1),c(1,3),c(2,2),c(2,5))
for(i in 1:5) {
    p1 &lt;- ddb(1:15,parz[[i]][1],parz[[i]][2],15)
    names(p1) &lt;- 1:15
    eckslab &lt;- paste0("alpha=",parz[[i]][1]," beta=",parz[[i]][2])
    barplot(p1,xlab=eckslab,main="db probabilities",
            space=1.5,col="black")
    abline(h=0)
    if(i &lt; 5) readline("Go? ")
}
x &lt;- c(-1.5,-1,-0.5,0,0.5,1,1.5)
ddb(x,2.5,1,5,TRUE) # Produces 0 for all but the 4th and 6th
                     # entries of x, and issues a warning.
</code></pre>

<hr>
<h2 id='dbd-internal'>Internal Verdis functions.</h2><span id='topic+grad'></span><span id='topic+gradDb'></span><span id='topic+gradBb'></span><span id='topic+hess'></span><span id='topic+hessDb'></span><span id='topic+hessBb'></span><span id='topic+mcCovMatEngine'></span><span id='topic+meDb'></span><span id='topic+meBb'></span>

<h3>Description</h3>

<p>Internal Verdis functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grad(x, distr=c("db","betabinom"),gpar)
gradDb(x,gpar)
gradBb(x,gpar)
hess(x, distr=c("db","betabinom"),hpar)
hessDb(hpar)
hessBb(x,hpar)
mcCovMatEngine(fitz,par0,seed)
meDb(x, ntop)
meBb(x, size, warn=FALSE)
</code></pre>


<h3>Details</h3>

<p>These functions are auxiliary and are not intended to be called
by the user.
</p>

<hr>
<h2 id='eow'>
Set or query the value of the <code>"maxitErrorOrWarn"</code> option.
</h2><span id='topic+eow'></span><span id='topic+set.eow'></span><span id='topic+get.eow'></span>

<h3>Description</h3>

<p>Chooses (<code>set.eow()</code>) or queries (<code>get.eow()</code>), the
reaction to <code>maxit</code> being exceeded in <code>mleDb()</code>
or <code>mleBb()</code>.   The possible reactions are to throw
an error or to issue a warning.  The choice is effected
by calling <code>set.eow()</code> which sets the value of
<code>options()[["maxitErrorOrWarning"]]</code>.  The current choice
is revealed by <code>get.eow()</code>.  This choice is set equal to
<code>"error"</code> at startup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.eow(eow = c("error", "warn"))
get.eow()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eow_+3A_eow">eow</code></td>
<td>

<p>Character string that specifies the reaction to <code>maxit</code>
being exceeded in <code>mleDb()</code> or <code>mleBb()</code>.  May be
abbreviated.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned by <code>set.eow()</code>.  the value of
<code>"maxitErrorOrWarn"</code> in <code>options()</code>.
The function <code>get.eow()</code> returns the current value of
<code>options[["maxitErrorOrWarn"]]</code>.
</p>


<h3>Note</h3>

<p>It seems unlikely that you would want to change the option from
the value that is set at startup.  This function is provided
&ldquo;just in case&rdquo;.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mleDb">mleDb</a>()</code>
<code><a href="#topic+mleBb">mleBb</a>()</code>
<code><a href="base.html#topic+options">options</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    get.eow()    # Is "error" at startup.
    set.eow("w") # Changes the option from "error" to "warning".
    set.eow("e") # Changes it back again.
</code></pre>

<hr>
<h2 id='exactMeDb'>
Exact moment estimates for the db distribution.
</h2><span id='topic+exactMeDb'></span>

<h3>Description</h3>

<p>Attempts to calculate &ldquo;exact&rdquo; moment estimates of the
parameters of a db distribution.  This is done by minimising
the sum of squared differences between the sample mean and variance
(<code>xbar</code> and <code>s2</code>) and the theoretical mean and variance.
Calls upon <code><a href="stats.html#topic+optim">optim</a>()</code> with the <code>"BFGS"</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exactMeDb(x, ntop, zeta=FALSE, par0 = NULL, maxit = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exactMeDb_+3A_x">x</code></td>
<td>

<p>A random sample from the db distribution whose parameters are
being estimated.  Missing values are <em>allowed</em>.
</p>
</td></tr>
<tr><td><code id="exactMeDb_+3A_ntop">ntop</code></td>
<td>

<p>The <code>ntop</code> parameter of the db distribution whose parameters are
being estimated.  I.e. it is the maximum possible value of the distribution,
whose values are integers between 1 and <code>ntop</code>, or between 0 and
<code>ntop</code> if <code>zeta</code> (see below) is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="exactMeDb_+3A_zeta">zeta</code></td>
<td>

<p>See <code><a href="#topic+ddb">ddb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="exactMeDb_+3A_par0">par0</code></td>
<td>

<p>Optional starting values for the iterative estimation procedure.
A vector with entries <code>alpha</code> and <code>beta</code>.  Ideally this
vector should be named; if not it is <em>assumed</em> that the
entries are in the order <code>alpha</code>, <code>beta</code>.  If not
supplied starting values are calculated using the undocumented function
<code>meDb()</code>.
</p>
</td></tr>
<tr><td><code id="exactMeDb_+3A_maxit">maxit</code></td>
<td>

<p>Integer scalar.  The maximum number of iterations to be undertaken
by <code><a href="stats.html#topic+optim">optim</a>()</code>.  What happens if this number is exceeded
depends on the value of <code>options()[["maxitErrorOrWarning"]]</code>.
This may be <code>"error"</code> (in which case an error is thrown if
<code>maxit</code> is exceeded) or <code>"warning"</code> (in which case a
warning is issued).  The values is set equal to <code>"error"</code> at
startup.  It may be switched, from on possibility to the other,
by means of the function <code><a href="#topic+set.eow">set.eow</a>()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is really an &ldquo;intellectual curiosity&rdquo;.  The
results produced may be compared with those produced via maximum
likelihood (using <code><a href="#topic+mleDb">mleDb</a>()</code>) which in theory should
be &ldquo;better&rdquo;.  Since numerical optimisation has to be applied
to calculate the &ldquo;exact&rdquo; moment estimates, there is no
real saving in terms of computation cost.
</p>


<h3>Value</h3>

<p>An object of class <code>"exactMeDb"</code>.  Such an object consists
of a named vector with entries <code>"alpha"</code> and <code>"beta"</code>,
which are the &ldquo;exact&rdquo; moment estimates of the corresponding
parameters.  It has a number of attributes:
</p>

<ul>
<li> <p><code>"ntop"</code> The value of the <code>ntop</code> argument.
</p>
</li>
<li> <p><code>"zeta"</code> The value of the <code>zeta</code> argument.
</p>
</li>
<li> <p><code>"minSqDiff"</code> The (minimised) value of the sum of
the squared differences between the sample mean and variance
(<code>xbar</code> and <code>s2</code>) and the theoretical mean and
variance.  Ideally this minimised value should be zero.
</p>
</li>
<li> <p><code>ndata</code> The number of <em>non-missing</em> values
in the data set for which the likelihood was maximised,
i.e. <code>sum(!is.na(x))</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddb">ddb</a></code>
<code><a href="#topic+meDb">meDb</a>()</code>
<code><a href="#topic+mleDb">mleDb</a>()</code>
<code><a href="#topic+expValDb">expValDb</a>()</code>
<code><a href="#topic+varDb">varDb</a>()</code>
<code><a href="stats.html#topic+optim">optim</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x &lt;- rdb(500,3,5,2)
eMom &lt;- exactMeDb(x,ntop=2,zeta=FALSE)
eMle &lt;- mleDb(x,ntop=2)

# Get much better results using true parameter values
# as starting values; pity we can't do this in real life!
eMom &lt;- exactMeDb(x,ntop=2,zeta=FALSE,par0=c(alpha=3,beta=5))
eMle &lt;- mleDb(x,2,par0=c(alpha=3,beta=5))

# Larger ntop value
x &lt;- rdb(500,3,5,20)
eMom &lt;- exactMeDb(x,ntop=20,zeta=FALSE)
eMle &lt;- mleDb(x,ntop=20)

# Binomial, n = 10, p = 0.3.
set.seed(42)
x    &lt;- rbinom(1000,10,0.3)
eMom &lt;- exactMeDb(x,ntop=10,zeta=TRUE)
eMle &lt;- mleDb(x,ntop=10,zeta=TRUE)
p1   &lt;- dbinom(0:10,10,0.3)
p2   &lt;- dbinom(0:10,10,mean(x)/10)
p3   &lt;- table(factor(x,levels=0:10))/1000
p4   &lt;- ddb(0:10,alpha=eMom["alpha"],beta=eMom["beta"],ntop=10,zeta=TRUE)
plot(eMle,obsd=x,legPos=NULL,ylim=c(0,max(p1,p2,p3,p4)))
lines(0.2+(0:10),p1,col="orange",type="h",ylim=c(0,max(p1,p2)))
lines(0.3+(0:10),p2,col="green",type="h")
legend("topright",lty=1,col=c("red","blue","orange","green","black"),
       legend=c("dbMle","observed","true binomial","fitted binomial","dbMom"),bty="n")
</code></pre>

<hr>
<h2 id='expValBb'>
Expected value of a beta binomial distribution.
</h2><span id='topic+expValBb'></span><span id='topic+expValBb.mleBb'></span><span id='topic+expValBb.default'></span>

<h3>Description</h3>

<p>Calculate the expected value (theoretical mean) of a
random variable having a beta binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expValBb(mo,...)
## S3 method for class 'mleBb'
expValBb(mo,...)
## Default S3 method:
expValBb(mo, size, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expValBb_+3A_mo">mo</code></td>
<td>

<p>For the <code>"mleBb"</code> method this argument is an object of class
<code>"mleBb"</code> as returned by <code><a href="#topic+mleBb">mleBb</a>()</code>.  For the
default method it is a numeric scalar, between 0 and 1, playing the
role of <code>m</code> (which may be interpreted as the &ldquo;success&rdquo;
probability.  (See the help for <code>dbetabinom()</code>.)
</p>
</td></tr>
<tr><td><code id="expValBb_+3A_size">size</code></td>
<td>

<p>Integer scalar specifying the upper limit of the &ldquo;support&rdquo;
of the beta binomial distribution under consideration.  The support
is the set of integers <code>{0, 1, ..., size}</code>.  (See the help
for <code>dbetabinom()</code>.)
</p>
</td></tr>
<tr><td><code id="expValBb_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the <code>"mleBb"</code> method, the single argument should really
be called (something like) &ldquo;<code>object</code>&rdquo; and for the
default method the first argument should be called <code>m</code>.
However the argument lists must satisfy the restrictions that
&ldquo;<em>A method must have all the arguments of the generic,
including ... if the generic does.</em>&rdquo; and &ldquo;<em>A method
must have arguments in exactly the same order as the generic.</em>&rdquo;
</p>
<p>For the <code>"mleBb"</code> method, the values of <code>m</code>
and <code>size</code>
are extracted from the attributes of <code>mo</code>.
</p>
<p>The expected value of a beta binomial distribution is trivial
to calculate &ldquo;by hand&rdquo;.  These functions are provided for
convenience and to preserve parallelism with the db distribution.
</p>


<h3>Value</h3>

<p>Numeric scalar equal to the expected value of a beta binomial
distributed random variable with the given parameters.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+expValDb">expValDb</a>()</code>
<code><a href="#topic+varDb">varDb</a>()</code>
<code><a href="#topic+varBb">varBb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   expValBb(0.3,15)
   X   &lt;- hmm.discnp::Downloads
   fit &lt;- mleBb(X,size=15)
   expValBb(fit)
</code></pre>

<hr>
<h2 id='expValDb'>
Expected value of a db distribution.
</h2><span id='topic+expValDb'></span><span id='topic+expValDb.mleDb'></span><span id='topic+expValDb.default'></span>

<h3>Description</h3>

<p>Calculate the expected value (theoretical mean) of a
random variable having a db distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expValDb(ao,...)
## S3 method for class 'mleDb'
expValDb(ao,...)
## Default S3 method:
expValDb(ao, beta, ntop, zeta=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expValDb_+3A_ao">ao</code></td>
<td>

<p>For the <code>"mleDb"</code> method this argument is an object of class
<code>"mleDb"</code> as returned by <code><a href="#topic+mleDb">mleDb</a>()</code>.  For the
default method it is a numeric scalar playing the role of
<code>alpha</code> (see <code><a href="#topic+ddb">ddb</a>()</code>).
</p>
</td></tr>
<tr><td><code id="expValDb_+3A_beta">beta</code></td>
<td>

<p>See <code><a href="#topic+ddb">ddb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="expValDb_+3A_ntop">ntop</code></td>
<td>

<p>See <code><a href="#topic+ddb">ddb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="expValDb_+3A_zeta">zeta</code></td>
<td>

<p>See <code><a href="#topic+ddb">ddb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="expValDb_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the <code>"mleDb"</code> method, the single argument should really
be called (something like) &ldquo;<code>object</code>&rdquo; and for the
default method the first argument should be called <code>alpha</code>.
However the argument lists must satisfy the restrictions that
&ldquo;<em>A method must have all the arguments of the generic,
including ... if the generic does.</em>&rdquo; and &ldquo;<em>A method
must have arguments in exactly the same order as the generic.</em>&rdquo;
</p>
<p>For the <code>"mleDb"</code> method, the values of <code>alpha</code>,
<code>beta</code>, <code>ntop</code> and <code>zeta</code> (passed to <code>ddb()</code>)
are extracted from the attributes of <code>ao</code>.
</p>
<p>The expected value of a db distribution is theoretically
intractable but is readily calculable numerically as
</p>
<p style="text-align: center;"><code class="reqn">\sum x \times \Pr(X=x)</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>Numeric scalar equal to the expected value of a db distributed
random variable with the given parameters.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddb">ddb</a>()</code> <code><a href="#topic+varDb">varDb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   expValDb(3,4,15)
   X   &lt;- hmm.discnp::Downloads
   fit &lt;- mleDb(X,ntop=15,zeta=TRUE)
   expValDb(fit)
</code></pre>

<hr>
<h2 id='finfo'>
Fisher information.
</h2><span id='topic+finfo'></span>

<h3>Description</h3>

<p>Compute the Fisher information for a db distribution or
a beta binomial distribution given the parameters of that
distribution.  In the case of the db distribution a specified
number of observations must be supplied.  In the case of
the beta binomial distribution the actual observations must
be supplied.  The inverse of the Fisher information is an
estimate of the covariance matrix of the parameter estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>finfo(distr=c("db","betabinom"),alpha, beta, ntop, ndata,
      zeta = FALSE, x, m, s, size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="finfo_+3A_distr">distr</code></td>
<td>

<p>Text string specifying which distribution to consisder.
May be abbreviated (e.g. to <code>"d"</code> or <code>"b"</code>).
</p>
</td></tr>
<tr><td><code id="finfo_+3A_alpha">alpha</code></td>
<td>

<p>See <code><a href="#topic+ddb">ddb</a>()</code>.  Ignored if <code>distr</code> is <code>"betabinom"</code>.
</p>
</td></tr>
<tr><td><code id="finfo_+3A_beta">beta</code></td>
<td>

<p>See <code><a href="#topic+ddb">ddb</a>()</code>.  Ignored if <code>distr</code> is <code>"betabinom"</code>.
</p>
</td></tr>
<tr><td><code id="finfo_+3A_ntop">ntop</code></td>
<td>

<p>See <code><a href="#topic+ddb">ddb</a>()</code>.  Ignored if <code>distr</code> is <code>"betabinom"</code>.
</p>
</td></tr>
<tr><td><code id="finfo_+3A_ndata">ndata</code></td>
<td>

<p>The number of observations for which the Fisher
information is being determined.  Ignored if <code>distr</code>
is <code>"betabinom"</code>; must be supplied if <code>distr</code>
is <code>"db"</code>.
</p>
</td></tr>
<tr><td><code id="finfo_+3A_zeta">zeta</code></td>
<td>

<p>See <code><a href="#topic+ddb">ddb</a>()</code>.  Ignored if <code>distr</code> is <code>"betabinom"</code>.
</p>
</td></tr>
<tr><td><code id="finfo_+3A_x">x</code></td>
<td>

<p>A numeric vector of observations appropriate for the model
under consideration.  Ignored if <code>distr</code> is <code>"db"</code>; the
Fisher information for the db distribution depends only upon the
parameters and not upon the data.  Must be supplied if <code>distr</code>
is <code>"betabinom"</code>.
</p>
</td></tr>
<tr><td><code id="finfo_+3A_m">m</code></td>
<td>

<p>A numeric scalar, between 0 and 1, which may be interpreted
as the &ldquo;success&rdquo; probability.  (See the help for
<code>dbetabinom()</code>.) Ignored if <code>distr</code> is <code>"db"</code>.
</p>
</td></tr>
<tr><td><code id="finfo_+3A_s">s</code></td>
<td>

<p>Numeric scalar, greater than 0.  The overdispersion parameter of
the distribution. (See the help for <code>dbetabinom()</code>.) Ignored
if <code>distr</code> is <code>"db"</code>.
</p>
</td></tr>
<tr><td><code id="finfo_+3A_size">size</code></td>
<td>

<p>Integer scalar specifying the upper limit of the &ldquo;support&rdquo;
of the betabinom distribution under consideration.  The support
is the set of integers <code>{0, 1, ..., size}</code>.  (See the help
for <code>dbetabinom()</code>.) Ignored if <code>distr</code> is <code>"db"</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function differs from <code><a href="#topic+aHess">aHess</a>()</code> in that its
arguments are prescribed &ldquo;individually&rdquo; rather than being
extracted from an <code>"mleDb"</code> or <code>"mleBb"</code> object.
This allows <code>finfo()</code> to be applied to &ldquo;true&rdquo;
parameters (where these are known) rather than estimated ones.
</p>
<p>Note that if <code>distr</code> is <code>"db"</code>, the number
of observations must be supplied explicitly, whereas for
<code>aHess()</code> this number is extracted from the <code>object</code>
argument.  If <code>distr</code> is <code>"betabinom"</code> then a vector
of actual observations must be supplied.
</p>
<p>If <code>distr</code> is <code>"db"</code> then <code>finfo()</code> in effect
calculates the <em>expected</em> information, since the information
matrix does not depend on the parameters.  This is not the case
if <code>distr</code> is <code>"betabinom"</code>.  If the parameters
supplied are the maximum likelihood estimates based on the
supplied vector of observations <code>x</code>, then the value returned
by <code>finfoBb()</code> is the <em>observed</em> Fisher information.
</p>


<h3>Value</h3>

<p>A two-by-two positive definite (with any luck!) numeric matrix.
Its inverse is an estimate of the covariance matrix of the
parameter estimates.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code>link{aHess}()</code>
<code>link{nHess}()</code>
<code>link{mleDb}()</code>
<code>link{mleBb}()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(finfo(alpha=0.6,beta=0.3,ntop=5,ndat=54))
X   &lt;- hmm.discnp::SydColDisc
X$y &lt;- as.numeric(X$y)
X   &lt;- split(X,f=with(X,interaction(locn,depth)))
x   &lt;- X[[19]]$y
fit &lt;- mleDb(x, ntop=5)
alpha &lt;- fit["alpha"]
beta  &lt;- fit["beta"]
ntop  &lt;- attr(fit,"ntop")
zeta  &lt;- attr(fit,"zeta")
ndat  &lt;- ndata(fit)
print(finfo(alpha=alpha,beta=beta,ntop=ntop,ndat=ntop,zeta=zeta))
print(aHess(fit)) # Same
X     &lt;- hrsRcePred
top1e &lt;- X[X$sbjType=="Expert","top1"]
fit   &lt;- mleBb(top1e,size=10)
print(finfo(distr="b",x=top1e,m=fit["m"],s=fit["s"],
            size=10)) # Observed Fisher info.
print(aHess(fit,x=top1e)) # Same
</code></pre>

<hr>
<h2 id='gof'>
Goodness of fit test for db and beta binomial distributions.
</h2><span id='topic+gof'></span><span id='topic+gof.mleDb'></span><span id='topic+gof.mleBb'></span>

<h3>Description</h3>

<p>Either a chi-squared or a Monte Carlo test of goodness
of fit of a db distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gof(object, obsd, ...)
## S3 method for class 'mleDb'
gof(object,obsd,...,test=TRUE,MC=FALSE,seed=NULL,
                    nsim=99,maxit=1000,verb=FALSE)
## S3 method for class 'mleBb'
gof(object,obsd,...,test=TRUE,MC=FALSE,seed=NULL,
                    nsim=99,maxit=1000,verb=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gof_+3A_object">object</code></td>
<td>

<p>An object of class <code>"mleDb"</code> or <code>"mleBb"</code> as returned by the function
<code><a href="#topic+mleDb">mleDb</a>()</code> or by <code><a href="#topic+mleBb">mleBb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="gof_+3A_obsd">obsd</code></td>
<td>

<p>The data to which <code>object</code> was fitted.
</p>
</td></tr>
<tr><td><code id="gof_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
<tr><td><code id="gof_+3A_test">test</code></td>
<td>

<p>Logical scalar.  Should a hypothesis test be carried out?  If <code>test</code>
is <code>FALSE</code> then only the test statistic is returned.  This argument
is present so as to facilitate the calculations used in effecting a
Monte Carlo test, by allowing <code>gof()</code> to recursively call itself.
</p>
</td></tr>
<tr><td><code id="gof_+3A_mc">MC</code></td>
<td>

<p>Logical scalar.  Should a Monte Carlo test be used rather than a
chi squared test?
</p>
</td></tr>
<tr><td><code id="gof_+3A_seed">seed</code></td>
<td>

<p>Integer scalar.  The seed for the random number generator used
when <code>MC</code> is <code>TRUE</code>.  If not supplied, <code>seed</code> is
created by sampling one integer from <code>1:1e5</code>.  This argument
is ignored if <code>MC</code> is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="gof_+3A_nsim">nsim</code></td>
<td>

<p>The number of simulated replicates on which the Monte Carlo test is
to be based.  Ignored if <code>MC</code> is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="gof_+3A_maxit">maxit</code></td>
<td>

<p>Integer scalar.  The maximum number of iterations to be undertaken
by <code><a href="stats.html#topic+optim">optim</a>()</code> when fitting models to the simulated data.
Ignored if <code>MC</code> is <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="gof_+3A_verb">verb</code></td>
<td>

<p>Logical scalar.  Should rudimentary &ldquo;progress reports&rdquo; be
issued during the course of the simulations invoked by the Monte
Carlo test procedure?  Ignored if <code>MC</code> is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>gof()</code> is a generic function with two methods,
<code>gof.mleDb()</code> and <code>gof.mleBb()</code>.
</p>
<p>The test statistic is calculated as </p>
<p style="text-align: center;"><code class="reqn">\sum((O-E)^2/E)</code>
</p>

<p>where <code class="reqn">O</code> means &ldquo;observed&rdquo; and <code class="reqn">E</code> means &ldquo;expected&rdquo;.
If the mean of <code class="reqn">E</code> is less than 5 or if any of the entries of <code class="reqn">E</code>
is less than 1, then the chi squared test is invalid and a warning to this
effect is issued.  In this case the expected values are returned as an
attribute of the value returned by <code>gof()</code>.  The foregoing applies
of course only if a chi squared test (as opposed to a Monte Carlo test)
is being used.
</p>
<p>The degrees of freedom for the chi squared test are <code>length(E) - 3</code>.
The value 3 is equal to 2 (for the number of parameters estimated) plus
1 (for the costraint that the probabilities of the values sum to 1).
</p>
<p>If it were actually true that, under the null hypothesis, the
observed test statistic and those calculated from simulated
data are <em>exchangeable</em>, the Monte Carlo test would
be <em>exact</em>.  However the real data are distributed as
<code class="reqn">f(x,\theta)</code> whereas the simulated data
are distributed as <code class="reqn">f(x,\hat{\theta})</code>
where <code class="reqn">\hat{\theta}</code> is the estimate of
<code class="reqn">\theta</code> based on the observed data.  Consequently the
observed test statistic and simulated test statistics are
&ldquo;not quite&rdquo; exchangeable.  Nevertheless it appears that
in practice the Monte Carlo test is very close to being exact.
</p>
<p>The meaning of &ldquo;exact&rdquo; here is that if the null hypothesis
is true then, over the set of instances of collecting the data
<b>and</b> simulating the required replicates, the <code class="reqn">p</code>-value
is uniformly distributed on the set <code class="reqn">\{1/N, 2/N, \ldots,
  (N-1)/N, 1\}</code> where <code class="reqn">N</code> is equal to <code>nsim</code>.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>stat</code></td>
<td>
<p>The test statistic.</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>The p-value of the test.</p>
</td></tr>
<tr><td><code>degFree</code></td>
<td>
<p>The degrees of freedom of the chi squared test.</p>
</td></tr>
</table>
<p>The last component is present only if a chi squared test (rather
than a Monte Carlo test) is used.
</p>
<p>If a chi squared test is used and turns out to be invalid, then
the returned value has an attribute <code>"expVals"</code>, consisting
of the (problematic) expected values.
</p>
<p>If a Monte Carlo test is used the returned value has an attribute
<code>"seed"</code> which is equal to the <code>seed</code> argument or to the
random value selected to replace it if the <code>seed</code> argument was
not supplied.
</p>


<h3>Notes</h3>

<p>The Monte Carlo <code class="reqn">p</code>-value is calculated as
<code>(m+1)/(nsim+1)</code> where <code>m</code> is the number of simulated
statistics which greater than or equal to the observed statistic
(computed from the &ldquo;real&rdquo; data.
</p>
<p>The <em>smallest</em> that the Monte Carlo
<code class="reqn">p</code>-value can be is <code>1/(nsim + 1)</code>, e.g. 0.01 when
<code>nsim</code> is 99.  For &ldquo;finer distinctions&rdquo; you must use
larger values of <code>nsim</code>, such as 999 or 9999.
</p>
<p>The <code class="reqn">p</code>-value is <em>random</em>; if you repeat the test (with
the same data) you may well get a different <code class="reqn">p</code>-value.
Resist the temptation to repeat the test until you get a
<code class="reqn">p</code>-value that you like!!!  This invalidates your inference!
</p>


<h3>Remark on the Examples</h3>

<p>In the <b>Examples</b>, db and beta binomial distributions are
fitted to the <em>Parsonnet scores</em> from the <code>cardiacsurgery</code>
data set which comes from the <code>spcadjust</code> package.  It is not
completely clear what the value of <code>ntop</code> (db distribution)
or <code>size</code> (beta binomial distribution) should be.  The data
are not actually counts, and in particular they are not counts
of successes out of a given number (&ldquo;<code>size</code>&rdquo;) of trials.
In the event I chose to use the value 71, the maximium value of the
Parsonnet scores, for the value of both <code>ntop</code> and <code>size</code>.
This was the value chosen for use as <code>size</code> by Wittenberg
(2021) when he fitted a beta binomial distribution to these data.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>References</h3>

<p>Philipp Wittenberg (2021). Modeling the patient mix for
risk-adjusted CUSUM charts.  To appear in <em>Statistical
Methods in Medical Research</em>.
</p>
<p>Axel Gandy and Jan Terje Kvaloy (2013). Guaranteed
conditional performance of control charts via bootstrap
methods. <em>Scandinavian Journal of Statistics</em> <b>40</b>,
pp. 647&ndash;668.  (Reference for <code>spcadjust</code> package.)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mleDb">mleDb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- hmm.discnp::Downloads
f &lt;- mleDb(X,15,TRUE)
tst1 &lt;- gof(f,X) # Gives warning that the chi squared test is invalid.
tst2 &lt;- gof(f,X,MC=TRUE,seed=42)
# The p-value is 0.03 so we reject the adequacy of the fit at the 0.05
# significance level.  Note that the p-value that we get, when the
# random number generator seed is set equal to 42, is very similar in
# value to the p-value (0.0347) from the "invalid" chi squared test.
#
## Not run:  # Takes too long.
if(requireNamespace("spcadjust")) {
    data("cardiacsurgery", package = "spcadjust")
    xxx  &lt;- cardiacsurgery$Parsonnet
    fit1 &lt;- mleDb(xxx,ntop=71,zeta=TRUE)
    g1   &lt;- gof(fit1,obsd=xxx,MC=TRUE,verb=TRUE,seed=42)
    fit2 &lt;- mleBb(xxx,size=71)
    g2   &lt;- gof(fit2,obsd=xxx,MC=TRUE,verb=TRUE,seed=17)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='hrsRcePred'>
Horse race prediction data.
</h2><span id='topic+hrsRcePred'></span>

<h3>Description</h3>

<p>Counts of correct predictions of the outcomes of 10 harness
races made by &ldquo;experts&rdquo; and &ldquo;non-experts&rdquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hrsRcePred</code></pre>


<h3>Format</h3>

<p>A data frame with 30 observations on the following 4 variables.
</p>

<dl>
<dt><code>sbjType</code></dt><dd><p>A character vector with entries <code>"NonXpert"</code>
and <code>"Expert"</code>, which classifies the &ldquo;subjects&rdquo; (the
people making the predictions of the race outcomes).</p>
</dd>
<dt><code>subject</code></dt><dd><p>An integer vector indexing the subjects.  (Not
of any real consequence.)</p>
</dd>
<dt><code>top1</code></dt><dd><p>An integer vector giving the counts of correct predictions
of the winners of 10 harness races.</p>
</dd>
<dt><code>top3</code></dt><dd><p>An integer vector giving the counts of correct predictions
of the top three horses (&ldquo;win/place/show&rdquo; in 10 harness races.</p>
</dd>
</dl>



<h3>Details</h3>

<p>In Ceci and Liker (1986) it is stated that subjects were
classified as &ldquo;experts&rdquo; and &ldquo;nonexperts&rdquo; based on
their ability to predict post-time odds on the basis of factual
information about horses.
</p>
<p>It appears that the counts in <code>top1</code> and <code>top3</code> pertain
to the <em>same</em> 10 races, but this is not completely clear.
</p>


<h3>Source</h3>

<p>These data are taken from the paper cited in the first of the
two given in the <b>References</b> below.  They were provided
by a generous email correspondent who prefers to remain anonymous.
</p>


<h3>References</h3>

<p>Ceci, S. J. and Liker, J. K. (1986).  A day at the races: A study
of IQ, expertise, and cognitive complexity.  <em>Journal of Experimental
Psychology, General</em> <b>115</b>, pp. 255 &ndash; 266.
</p>
<p>Ceci, S. J. and Liker, J. K. (1988).  Stalking the IQ-expertise
relation: When the critics go fishing.  <em>Journal of Experimental
Psychology, General</em> <b>117</b>, pp. 96 &ndash; 100.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    X     &lt;- hrsRcePred
    top1e &lt;- X[X$sbjType=="Expert","top1"]
    top1n &lt;- X[X$sbjType=="NonXpert","top1"]
    top3e &lt;- X[X$sbjType=="Expert","top3"]
    top3n &lt;- X[X$sbjType=="NonXpert","top3"]
    dbfit1e &lt;- mleDb(top1e,ntop=10,zeta=TRUE)
    dbfit1n &lt;- mleDb(top1n,ntop=10,zeta=TRUE)
    dbfit3e &lt;- mleDb(top3e,ntop=10,zeta=TRUE)
    dbfit3n &lt;- mleDb(top3n,ntop=10,zeta=TRUE)
# Set seeds to get repeatable Monte Carlo p-values.
    ## Not run:  # Takes too long.
        print(gof(dbfit1e,obsd=top1e,MC=TRUE,maxit=5000,verb=TRUE,seed=49)$pval) # 0.02
        print(gof(dbfit1n,obsd=top1n,MC=TRUE,verb=TRUE,seed=128)$pval)           # 0.79
        print(gof(dbfit3e,obsd=top3e,MC=TRUE,verb=TRUE,seed=303)$pval)           # 0.35
        print(gof(dbfit3n,obsd=top3n,MC=TRUE,maxit=3000,verb=TRUE,seed=24)$pval) # 0.40
    
## End(Not run)
    bbfit1e &lt;- mleBb(top1e,size=10)
    bbfit1n &lt;- mleBb(top1n,size=10)
    bbfit3e &lt;- mleBb(top3e,size=10)
    bbfit3n &lt;- mleBb(top3n,size=10)
# Set seeds to get repeatable Monte Carlo p-values.
    ## Not run:  # Takes too long.
        print(gof(bbfit1e,obsd=top1e,MC=TRUE,verb=TRUE,seed=792)$pval) # 0.11
        print(gof(bbfit1n,obsd=top1n,MC=TRUE,verb=TRUE,seed=48)$pval)  # 0.64
        print(gof(bbfit3e,obsd=top3e,MC=TRUE,verb=TRUE,seed=969)$pval) # 0.62
        print(gof(bbfit3n,obsd=top3n,MC=TRUE,verb=TRUE,seed=834)$pval) # 0.75
    
## End(Not run)
# Reality check: goodness of fit tests for the fit of just plain *binomial*
# distributions to these data sets yielded Monte Carlo p-values equal to
# 0.22, 0.17, 0.32 and 0.73 respectively.  I.e. binomial fits appear to
# work just fine!
</code></pre>

<hr>
<h2 id='llPlot'>
Plot the log likelihood surface for the data.
</h2><span id='topic+llPlot'></span>

<h3>Description</h3>

<p>Plot, as a perspective plot or a contour plot, the log likelihood
surface for the data set from which parameters are being estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llPlot(x, distr=c("db","betabinom"),ntop, zeta, size, alim = NULL, blim = NULL,
       ngrid = c(100, 100), plotType = c("persp", "contour", "none"),
       theta = -30, phi = 40, ...)  </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llPlot_+3A_x">x</code></td>
<td>

<p>A vector of numeric data purportedly arising from a db or beta binomial
distribution.
</p>
</td></tr>
<tr><td><code id="llPlot_+3A_distr">distr</code></td>
<td>

<p>Character string specifying which of the two relevant distributions
(db, or beta binomial) is to be considered.
</p>
</td></tr>
<tr><td><code id="llPlot_+3A_ntop">ntop</code></td>
<td>

<p>See <code><a href="#topic+mleDb">mleDb</a>()</code> and <code><a href="#topic+ddb">ddb</a>()</code>.
Ignored if <code>distr</code> is <code>"betabinom"</code>.
</p>
</td></tr>
<tr><td><code id="llPlot_+3A_zeta">zeta</code></td>
<td>

<p>See <code><a href="#topic+mleDb">mleDb</a>()</code> and <code><a href="#topic+ddb">ddb</a>()</code>.
Ignored if <code>distr</code> is <code>"betabinom"</code>.
</p>
</td></tr>
<tr><td><code id="llPlot_+3A_size">size</code></td>
<td>

<p>Integer scalar specifying the upper limit of the &ldquo;support&rdquo;
of the beta binomial distribution under consideration.  The support
is the set of integers <code>{0, 1, ..., size}</code>. (The values
of <code>x</code> may sometimes be considered to be the number of
&ldquo;successes&rdquo; in <code>size</code> trials.  The <code>size</code>
argument is ignored if <code>distr</code> is <code>"db"</code>.
</p>
</td></tr>
<tr><td><code id="llPlot_+3A_alim">alim</code></td>
<td>

<p>Numeric vector of length 2; the range of <code>alpha</code> values
over which the surface is to be plotted.  Defaults to <code>c(0,10)</code>
if <code>distr</code> is <code>"db"</code> and to <code>c(0,1)</code> if <code>distr</code>
is <code>"betabinom"</code>.
</p>
</td></tr>
<tr><td><code id="llPlot_+3A_blim">blim</code></td>
<td>

<p>Numeric vector of length 2; the range of <code>beta</code> values over
which the surface is to be plotted.   Defaults to <code>c(0,10)</code> if
<code>distr</code> is <code>"db"</code> and to <code>c(0,100)</code> if <code>distr</code>
is <code>"betabinom"</code>.
</p>
</td></tr>
<tr><td><code id="llPlot_+3A_ngrid">ngrid</code></td>
<td>

<p>The dimensions of the grid of paramter values at
which the log likelihood is to be evaluated in order to plot
the surface.  Note that <code>ngrid</code> may be supplied as an
integer scalar, in which case it is replicated to a vector
of length 2.
</p>
</td></tr>
<tr><td><code id="llPlot_+3A_plottype">plotType</code></td>
<td>

<p>Character string specifying the nature of the plot to be
produced.  If it is <code>"none"</code> then no plot is produced.
The value returned may be plotted at a later occasion.
</p>
</td></tr>
<tr><td><code id="llPlot_+3A_theta">theta</code></td>
<td>

<p>An argument to be passed to <code><a href="graphics.html#topic+persp">persp</a>()</code>.
Ignored unless <code>plotType</code> is <code>"persp"</code>.
</p>
</td></tr>
<tr><td><code id="llPlot_+3A_phi">phi</code></td>
<td>

<p>An argument to be passed to <code>persp()</code>.
Ignored unless <code>plotType</code> is <code>"persp"</code>.
</p>
</td></tr>
<tr><td><code id="llPlot_+3A_...">...</code></td>
<td>

<p>Other arguments that may be passed to <code>persp()</code>
or to <code><a href="graphics.html#topic+contour">contour</a>()</code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function could conceivably be useful in diagnosing
problems with parameter estimation should these arise.
</p>


<h3>Value</h3>

<p>A list with entries
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>The vector of values of the first parameter (<code>alpha</code>
for <code>distr="db"</code>, <code>m</code> for <code>distr="betabinom"</code>) over
which the surface is to be plotted.  There are <code>ngrid[1]</code>
such values, ranging from <code>alim[1]</code> to <code>alim[2]</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The vector of values of the second parameter (<code>beta</code>
for <code>distr="db"</code>, <code>s</code> for <code>distr="betabinom"</code>) over
which the surface is to be plotted.  There are <code>ngrid[2]</code>
such values, ranging from <code>blim[1]</code> to <code>blim[2]</code>.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>An <code>ngrid[1] x ngrid[2]</code> numeric matrix,
specifying the surface.  the value of <code>z[i,j]</code> is
<code>ll(x[i],y[j])</code> where <code>ll()</code> is the log likelihood
function.</p>
</td></tr>
<tr><td><code>dxy</code></td>
<td>
<p>A data frame with columns named <code>"alpha"</code> and
<code>"beta"</code> for <code>distr="db"</code> or <code>"m"</code> and <code>"s"</code>
for <code>distr="betabinom"</code>, and <code>ngrid[1]*ngrid[2]</code> rows.  It
is formed by applying <code>expand.grid()</code> to the <code>x</code>
and <code>y</code> entries of this list.</p>
</td></tr>
<tr><td><code>fxy</code></td>
<td>
<p>A numeric vector of length <code>ngrid[1]*ngrid[2]</code>.
Its <code>i</code>th value is the log likelihood evaluated at
the <code>i</code>th row of <code>dxy</code>.  Its entries are the
same as the entries of <code>z</code>.</p>
</td></tr>
</table>
<p>There is obviously considerable redundancy in the returned
value.
</p>
<p>The names <code>x</code> and <code>y</code> that are used for the first two
entries of this list conform to the names of the
arguments of <code>persp()</code> and <code>contour</code>.
</p>
<p>If <code>plotType</code> is <code>"persp"</code> or <code>"contour"</code> the
value is returned invisibly.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code>link{mleDb}()</code>
<code>link{mleBb}()</code>
<code>link{persp}()</code>
<code>link{contour}()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- hmm.discnp::SydColDisc
X$y &lt;- as.numeric(X$y)
X &lt;- split(X,f=with(X,interaction(locn,depth)))
x &lt;- X[[19]]$y
srf &lt;- llPlot(x,ntop=5,zeta=FALSE,alim=c(0.5,0.7),blim=c(0.2,0.4),plotType="c")
## Not run: 
if(require(rgl)) {
   with(srf,plot3d(ab$alpha,ab$beta,fab)
# Allows dynamic rotation of the surface.
}

## End(Not run)
# Negative (!) parameters for the db distribution.
set.seed(42)
xs &lt;- rdb(100,-1,-1,5)
fit &lt;- mleDb(xs,5)
llPlot(xs,ntop=5,zeta=FALSE,alim=c(-4,2),blim=c(-4,2),plotType="c",
       main="log likelihood contours")
points(fit[1],fit[2],pch=20,col="red")
points(-1,-1,pch=20,col="blue")
legend("topright",pch=20,col=c("red","blue"),
       legend=c("estimate","true value"),bty="n")
</code></pre>

<hr>
<h2 id='logLik'>
Retrieve the (maximised) log likelihood from an <code>"mleDb"</code> or
an <code>"mleBb"</code> object.
</h2><span id='topic+logLik.mleDb'></span><span id='topic+logLik.mleBb'></span>

<h3>Description</h3>

<p>Extract the log likelihood attribute an object of class
<code>"mleDb"</code> or <code>"mleBb"</code>.  I.e. obtain the maximum log
likelihood in respect of the estimation of the parameters of a
db or beta-binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'mleDb'
logLik(object, ...)
   ## S3 method for class 'mleBb'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik_+3A_object">object</code></td>
<td>

<p>An object of class <code>"mleDb"</code> as returned by <code><a href="#topic+mleDb">mleDb</a>()</code>
or of class <code>"mleBb"</code> as returned by <code><a href="#topic+mleBb">mleBb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="logLik_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"logLik"</code>, which consists of
a numeric scalar equal to the maximum log likelihood for the parameters
of a db or beta-binomial distribution.  It has an attribute <code>"df"</code>
equal to 2.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mleDb">mleDb</a>()</code>
<code><a href="#topic+mleBb">mleBb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- hmm.discnp::SydColDisc
X$y &lt;- as.numeric(X$y)
X &lt;- split(X,f=with(X,interaction(locn,depth)))
fitz &lt;- lapply(X,function(x){mleDb(x$y,ntop=5)})
sapply(fitz,logLik)
X     &lt;- hrsRcePred
top1e &lt;- X[X$sbjType=="Expert","top1"]
fit   &lt;- mleBb(top1e,10)
logLik(fit)
</code></pre>

<hr>
<h2 id='makeBbdpars'>
Create an object of class <code>"Bbdpars"</code>.
</h2><span id='topic+makeBbdpars'></span>

<h3>Description</h3>

<p>Create an object of class <code>"Bbdpars"</code> which may be used
as an argument of the <code>simulate()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeBbdpars(m, s, size, ndata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeBbdpars_+3A_m">m</code></td>
<td>

<p>Numeric scalar between 0 and 1.  May be interpreted as a
&ldquo;success probability&rdquo;.
</p>
</td></tr>
<tr><td><code id="makeBbdpars_+3A_s">s</code></td>
<td>

<p>Numeric scalar, greater than 0.  The overdispersion parameter
of the beta binomial distribution.  Note that if overdispersion
is defined to equal the ratio of the variance of the data to
the corresponding &ldquo;binomial variance&rdquo; (i.e.
the actual variance over <code>m*(1-m)*size</code>) the overdispersion
tends to 0 as <code>s</code> tends to infinity and to <code>size</code> as
<code>s</code> tends to 0.
</p>
</td></tr>
<tr><td><code id="makeBbdpars_+3A_size">size</code></td>
<td>

<p>Integer scalar specifying the upper limit of the &ldquo;support&rdquo;
of the beta binomial distribution under consideration.  The support
is the set of integers <code>{0, 1, ..., size}</code>.
</p>
</td></tr>
<tr><td><code id="makeBbdpars_+3A_ndata">ndata</code></td>
<td>

<p>Integer vector specifying the lengths of the data sets to
be simulated.  If it is of length less than the <code>nsim</code>
argument of <code>simulate()</code> (e.g. if it is a scalar) then it is
&ldquo;recycled&rdquo; to provide a vector of length <code>nsim</code>.  If is
longer than <code>nsim</code>, then only the first <code>nsim</code> entries
are used and the others are ignored.  If the argument <code>ndata</code>
of the <code>simulate()</code> function is supplied then the <code>ndata</code>
component specified here is ignored by <code>simulate()</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"Bbdpars"</code> which is a list with components
<code>m</code>, <code>s</code>, <code>size</code> and <code>ndata</code>.  The entries
of this list are simply the corresponding function arguments.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.Bbdpars">simulate.Bbdpars</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   obj1  &lt;- makeBbdpars(m=0.35,s=0.3,size=20,ndata=500)
   obj2  &lt;- makeBbdpars(m=0.85,s=1.7,size=20,ndata=30*(1:10))
   ## Not run: 
       sdat1 &lt;- simulate(obj1,nsim=100)
       sdat2 &lt;- simulate(obj2,nsim=100)
   
## End(Not run)
   sdat3 &lt;- simulate(obj2,nsim=10)
   ## Not run: 
       sdat4 &lt;- simulate(obj2,nsim=100,ndata=100*(2:6)) # The ndata component of
                                                    # obj2 is ignored.
   
## End(Not run)
</code></pre>

<hr>
<h2 id='makeDbdpars'>
Create an object of class <code>"Dbdpars"</code>.
</h2><span id='topic+makeDbdpars'></span>

<h3>Description</h3>

<p>Create an object of class <code>"Dbdpars"</code> which may be used
as an argument of the <code>simulate()</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeDbdpars(alpha, beta, ntop, zeta, ndata)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeDbdpars_+3A_alpha">alpha</code></td>
<td>

<p>The first &ldquo;shape&rdquo; parameter of the db distribution.
</p>
</td></tr>
<tr><td><code id="makeDbdpars_+3A_beta">beta</code></td>
<td>

<p>The second &ldquo;shape&rdquo; parameter of the db distribution.
</p>
</td></tr>
<tr><td><code id="makeDbdpars_+3A_ntop">ntop</code></td>
<td>

<p>Integer scalar, strictly greater than 1.  The maximum possible
value of the db distribution.
</p>
</td></tr>
<tr><td><code id="makeDbdpars_+3A_zeta">zeta</code></td>
<td>

<p>Logical scalar.  Should zero origin indexing be used?
I.e. should the range of values of the distribution be taken to
be <code>{0,1,2,...,ntop}</code> rather than <code>{1,2,...,ntop}</code>?
Setting <code>zeta=TRUE</code> may be appropriate for example when the
values of the distribution are to be interpreted as counts.
</p>
</td></tr>
<tr><td><code id="makeDbdpars_+3A_ndata">ndata</code></td>
<td>

<p>Integer vector specifying the lengths of the data sets to
be simulated.  If it is of length less than the <code>nsim</code>
argument of <code>simulate()</code> (e.g. if it is a scalar) then it is
&ldquo;recycled&rdquo; to provide a vector of length <code>nsim</code>.  If is
longer than <code>nsim</code>, then only the first <code>nsim</code> entries
are used and the others are ignored.  If the argument <code>ndata</code>
of the <code>simulate()</code> function is supplied then the <code>ndata</code>
component specified here is ignored by <code>simulate()</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"Dbdpars"</code> which is a list with
components <code>alpha</code>, <code>beta</code>, <code>ntop</code>, <code>zeta</code>
and <code>ndata</code>.  The entries of this list are simply the
corresponding function arguments.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate.Dbdpars">simulate.Dbdpars</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   obj1  &lt;- makeDbdpars(alpha=2,beta=3,ntop=20,zeta=TRUE,ndata=500)
   obj2  &lt;- makeDbdpars(alpha=0.2,beta=0.25,ntop=20,zeta=FALSE,ndata=30*(1:10))
   sdat1 &lt;- simulate(obj1,nsim=100)
   sdat2 &lt;- simulate(obj2,nsim=100)
   sdat3 &lt;- simulate(obj2,nsim=10)
   sdat4 &lt;- simulate(obj2,nsim=100,ndata=100*(2:6)) # The ndata component of
                                                    # obj2 is ignored.
</code></pre>

<hr>
<h2 id='mcCovMat'>
Monte Carlo estimation of a covariance matrix.
</h2><span id='topic+mcCovMat'></span><span id='topic+mcCovMat.mleDb'></span><span id='topic+mcCovMat.mleBb'></span><span id='topic+mcCovMat.Dbdpars'></span><span id='topic+mcCovMat.Bbdpars'></span><span id='topic+mcCovMat.default'></span>

<h3>Description</h3>

<p>Calculate an estimate of the covariance matrix for the parameter
estimates of a db or beta binomial distribution via simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcCovMat(object, nsim = 100, seed=NULL, maxit=1000)
## S3 method for class 'mleDb'
mcCovMat(object, nsim = 100, seed=NULL, maxit=1000)
## S3 method for class 'mleBb'
mcCovMat(object, nsim = 100, seed=NULL, maxit=1000)
## S3 method for class 'Dbdpars'
mcCovMat(object, nsim = 100, seed=NULL, maxit=1000)
## S3 method for class 'Bbdpars'
mcCovMat(object, nsim = 100, seed=NULL, maxit=1000)
## Default S3 method:
mcCovMat(object, nsim = 100, seed=NULL, maxit=1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcCovMat_+3A_object">object</code></td>
<td>

<p>An object of class either <code>"mleDb"</code>, <code>"mleBb"</code>,
<code>Dbdpars</code> or <code>Bbdpars</code>.  In the first two cases such an
object would be returned by the function <code><a href="#topic+mleDb">mleDb</a>()</code> or
by <code><a href="#topic+mleBb">mleBb</a>()</code>.  In the second two cases such an object
would be returned by the function <code><a href="#topic+makeDbdpars">makeDbdpars</a>()</code>
or by <code><a href="#topic+makeBbdpars">makeBbdpars</a>()</code>.
</p>
</td></tr>
<tr><td><code id="mcCovMat_+3A_nsim">nsim</code></td>
<td>

<p>Integer scalar.  The number of simulations to be used to produce
the Monte Carlo estimate of the covariance matrix.
</p>
</td></tr>
<tr><td><code id="mcCovMat_+3A_seed">seed</code></td>
<td>

<p>Integer scalar.  The seed for the random number generator.  If not
specified it is randomly sampled from the sequence <code>1:1e5</code>.
</p>
</td></tr>
<tr><td><code id="mcCovMat_+3A_maxit">maxit</code></td>
<td>

<p>Integer scalar.  The maximum number of iterations to be undertaken
by <code><a href="stats.html#topic+optim">optim</a>()</code> when fitting models to the simulated data.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The procedure is to simulate <code>nsim</code> data sets, all of
the same size.  This will be the size of the data set to which
<code>object</code> was fitted), in the case of the <code>"mleDb"</code> and
<code>"mleBb"</code> methods, and will be the value of the <code>ndata</code>
argument supplied to the &ldquo;<code>make</code>&rdquo; function in the
case of the <code>"Dbdpars"</code> and <code>"Bbdpars"</code> methods. The
simulations are from models determined by the parameter value
contained in <code>object</code>.
</p>
<p>From each such simulated data, parameter estimates are obtained.
The covariance matrix of these latter parameter estimates
(adjusted for the fact that the true parameters are known in
a simulation) is taken to be the required covariance matrix
estimated.
</p>
<p>The default method simply throws an error.
</p>


<h3>Value</h3>

<p>A two-by-two positive definite (with any luck!) numeric matrix.
It is an estimate of the covariance matrix of the parameter estimates.
</p>
<p>It has an attribute <code>"seed"</code> which is the seed that was used
for the random number generator.  This is either the value of the
argument <code>seed</code> or (if this argument was left <code>NULL</code>) the
value that was randomly sampled from <code>1:1e5</code>.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code>link{aHess}()</code>
<code>link{nHess}()</code>
<code>link{vcov.mleDb}()</code>
<code>link{vcov.mleBb}()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X   &lt;- hmm.discnp::SydColDisc
X$y &lt;- as.numeric(X$y)
X   &lt;- split(X,f=with(X,interaction(locn,depth)))
x   &lt;- X[[19]]$y
fit &lt;- mleDb(x, ntop=5)
set.seed(42)
CM.m &lt;- mcCovMat(fit,nsim=500) # Lots of simulations!
CM.a &lt;- vcov(fit)
CM.n &lt;- solve(nHess(fit,x))
cat("Monte Carlo:\n\n")
print(CM.m)
cat("Analytic:\n\n")
print(CM.a)
cat("Numeric:\n\n")
print(CM.n)
X     &lt;- hrsRcePred
top1e &lt;- X[X$sbjType=="Expert","top1"]
fit   &lt;- mleBb(top1e,size=10)
CM.m  &lt;- mcCovMat(fit,nsim=500) # Lots of simulations!
CM.a  &lt;- vcov(fit)
CM.n  &lt;- solve(nHess(fit,top1e))
cat("Monte Carlo:\n\n")
print(CM.m)
cat("Analytic:\n\n")
print(CM.a)
cat("Numeric:\n\n")
print(CM.n)
</code></pre>

<hr>
<h2 id='mleBb'>
Maximum likelihood estimation of the parameters of a beta binomial
distribution.
</h2><span id='topic+mleBb'></span>

<h3>Description</h3>

<p>Calculates maximum likelihood estimates of the <code>m</code> and
<code>s</code> parameters of a beta binomial distribution.  Calls upon
<code><a href="stats.html#topic+optim">optim</a>()</code> with the <code>"L-BFGS-B"</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    mleBb(x, size, par0, maxit=1000, covmat=TRUE, useGinv=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mleBb_+3A_x">x</code></td>
<td>

<p>Integer vector of counts to which a beta binomial distribution
is to be fitted.  Missing values are allowed.  (These are discarded
before the data are analysed.)
</p>
</td></tr>
<tr><td><code id="mleBb_+3A_size">size</code></td>
<td>

<p>Integer scalar specifying the upper limit of the &ldquo;support&rdquo;
of the beta binomial distribution under consideration.  The support
is the set of integers <code>{0, 1, ..., size}</code>. (The values
of <code>x</code> may sometimes be considered to be the number of
&ldquo;successes&rdquo; in <code>size</code> trials.
</p>
</td></tr>
<tr><td><code id="mleBb_+3A_par0">par0</code></td>
<td>

<p>Optional starting values for the iterative estimation procedure.
A vector with entries <code>m</code> and <code>s</code>.  Ideally this vector
should be named; if not it is <em>assumed</em> that the entries
are in the order <code>m</code>, <code>s</code>.  If not supplied starting
values are calculated using <code><a href="#topic+meBb">meBb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="mleBb_+3A_maxit">maxit</code></td>
<td>

<p>Integer scalar.  The maximum number of iterations to be undertaken
by <code><a href="stats.html#topic+optim">optim</a>()</code>.  What happens if this number is exceeded
depends on the value of <code>options()[["maxitErrorOrWarning"]]</code>.
This may be <code>"error"</code> (in which case an error is thrown if
<code>maxit</code> is exceeded) or <code>"warning"</code> (in which case a
warning is issued).  The values is set equal to <code>"error"</code> at
startup.  It may be switched, from on possibility to the other,
by means of the function <code><a href="#topic+set.eow">set.eow</a>()</code>.
</p>
</td></tr>
<tr><td><code id="mleBb_+3A_covmat">covmat</code></td>
<td>

<p>Logical scalar.  Should the covariance matrix of the parameter
estimates be calculated?  In simulation studies, in which the
covariance matrix is not of interest, calculations might be
speeded up a bit by setting <code>covmat=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mleBb_+3A_useginv">useGinv</code></td>
<td>

<p>Logical scalar.  Should the <code>ginv()</code> (generalised inverse)
function from the <code>MASS</code> package be used to calculate a
surrogate covariance matrix if the hessian is numerically singular?
This is probably not advisable; the possibility of using the
generalised inverse is provided for the sake of completeness.
<em>Caveat utilitor</em>.  This argument is ignored if <code>covmat</code>
is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is provided so as to give a convenient means of
comparing the fit of a beta binomial distribution with that of
the discretised Beta (db) distribution which is the focus of
this package.
</p>


<h3>Value</h3>

<p>An object of class <code>"mleBb"</code> which is a vector of length two.
Its first entry <code>m</code> is the estimate of the (so-called) success
probability <code>m</code>; its second entry <code>s</code> is the estimate of the
overdispersion parameter <code>s</code>.  It has a number of attributes:
</p>

<ul>
<li> <p><code>"size"</code> The value of the <code>size</code> argument.
</p>
</li>
<li> <p><code>"log.like"</code> The (maximised) value of the log likelihood
of the data.
</p>
</li>
<li> <p><code>"covMat"</code> An estimate of the (<code class="reqn">2 \times 2</code>)
covariance matrix of the parameter estimates.  This is formed
as the inverse of the hessian (of the negative log likelihood)
calculated by <code><a href="#topic+aHess">aHess</a>()</code>.
</p>
</li>
<li> <p><code>ndata</code> The number of <em>non-missing</em> values
in the data set for which the likelihood was maximised,
i.e. <code>sum(!is.na(x))</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>References</h3>

<p>Bruce Swihart and Jim Lindsey (2020). rmutil: Utilities for Nonlinear
Regression and Repeated Measurements Models. R package version 1.1.4.
https://CRAN.R-project.org/package=rmutil
</p>
<p>Wikipedia, <a href="https://en.wikipedia.org/wiki/Beta-binomial_distribution">https://en.wikipedia.org/wiki/Beta-binomial_distribution</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mleDb">mleDb</a>()</code>
<code><a href="stats.html#topic+optim">optim</a>()</code>
<code><a href="#topic+aHess">aHess</a>()</code>
<code><a href="#topic+vcov.mleBb">vcov.mleBb</a>()</code>
<code><a href="#topic+hrsRcePred">hrsRcePred</a></code>
<code><a href="#topic+visRecog">visRecog</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(hmm.discnp)) {
   X &lt;- hmm.discnp::Downloads
   f &lt;- mleBb(X,15)
}
set.seed(42)
X &lt;- c(rbinom(20,10,0.3),rbinom(20,10,0.7))
f &lt;- mleBb(X,10)
g &lt;- mleDb(X,10,TRUE)
print(attr(f,"log.like"))
print(attr(g,"log.like")) # Not much difference.
dbfit5  &lt;- with(visRecog,mleDb(tot5,20,TRUE))
print(vcov(dbfit5))
# See the help for data sets "hrsRcePred" and "visRecog" for
# other examples.
</code></pre>

<hr>
<h2 id='mleDb'>
Maximum likelihood estimates of db parameters.
</h2><span id='topic+mleDb'></span>

<h3>Description</h3>

<p>Calculates maximum likelihood estimates of the <code>alpha</code> and
<code>beta</code> parameters of a db distribution.  Calls upon
<code><a href="stats.html#topic+optim">optim</a>()</code> with the <code>"BFGS"</code> method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mleDb(x, ntop, zeta=FALSE, par0=NULL, UB=10, maxit=1000,
      covmat=TRUE, useGinv=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mleDb_+3A_x">x</code></td>
<td>

<p>A random sample from the db distribution whose parameters are
being estimated.  Missing values are <em>allowed</em>.
</p>
</td></tr>
<tr><td><code id="mleDb_+3A_ntop">ntop</code></td>
<td>

<p>The <code>ntop</code> parameter of the db distribution whose parameters are
being estimated.  I.e. it is the maximum possible value of the distribution,
whose values are integers between 1 and <code>ntop</code>, or between 0 and
<code>ntop</code> if <code>zeta</code> (see below) is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="mleDb_+3A_zeta">zeta</code></td>
<td>

<p>See <code><a href="#topic+ddb">ddb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="mleDb_+3A_par0">par0</code></td>
<td>

<p>Optional starting values for the iterative estimation procedure.
A vector with entries <code>alpha</code> and <code>beta</code>.  Ideally this
vector should be named; if not it is <em>assumed</em> that the
entries are in the order <code>alpha</code>, <code>beta</code>.  If not
supplied starting values are calculated using <code><a href="#topic+meDb">meDb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="mleDb_+3A_ub">UB</code></td>
<td>

<p>Positive numeric scalar, providing an upper bound on the starting
values used by <code>mleDb()</code>.  It appears that if these starting
values are too large (it is not clear <em>how</em> large) then <code>optim()</code>
will throw an error.  This bound is ignored if <code>par0</code> is
supplied.
</p>
</td></tr>
<tr><td><code id="mleDb_+3A_maxit">maxit</code></td>
<td>

<p>Integer scalar.  The maximum number of iterations to be undertaken
by <code><a href="stats.html#topic+optim">optim</a>()</code>.  What happens if this number is exceeded
depends on the value of <code>options()[["maxitErrorOrWarning"]]</code>.
This may be <code>"error"</code> (in which case an error is thrown if
<code>maxit</code> is exceeded) or <code>"warning"</code> (in which case a
warning is issued).  The values is set equal to <code>"error"</code> at
startup.  It may be switched, from on possibility to the other,
by means of the function <code><a href="#topic+set.eow">set.eow</a>()</code>.
</p>
</td></tr>
<tr><td><code id="mleDb_+3A_covmat">covmat</code></td>
<td>

<p>Logical scalar.  Should the covariance matrix of the parameter
estimates be calculated?  In simulation studies, in which the
covariance matrix is not of interest, calculations might be
speeded up a bit by setting <code>covmat=FALSE</code>.
</p>
</td></tr>
<tr><td><code id="mleDb_+3A_useginv">useGinv</code></td>
<td>

<p>Logical scalar.  Should the <code>ginv()</code> (generalised inverse)
function from the <code>MASS</code> package be used to calculate a
surrogate covariance matrix if the hessian is numerically singular?
This is probably not advisable; the possibility of using the
generalised inverse is provided for the sake of completeness.
<em>Caveat utilitor</em>.  This argument is ignored if <code>covmat</code>
is <code>FALSE</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ntop</code> and <code>zeta</code> parameters must be supplied; they
are not formally estimated (although the choice of <code>ntop</code>
may be influenced by the data &mdash; see below).  The parameter
<code>zeta</code> has a default value, <code>FALSE</code>.
</p>
<p>If the generating mechanism from which the observed data <code>x</code>
arose has a (known) theoretical least upper bound, then <code>ntop</code>
should probably be set equal to this upper bound.  If the data
are theoretically unbounded, then <code>ntop</code> should probably
be set equal to <code>1 + max(x)</code>.  In this case <code class="reqn">\Pr(X =
  \textrm{ntop})</code> should probably be interpreted
as <code class="reqn">\Pr(X \geq \textrm{ntop})</code>.  Otherwise
<code>ntop</code> should should probably be set equal to <code>max(x)</code>.
The choice depends on circumstances and is up to the user.
</p>
<p>Missing values are removed from <code>x</code> before it is passed to
<code>optim()</code>.  (Note that <code>ddb()</code> doesn't mind missing
values but returns missing values when evaluated at them.
This in turn produces a missing value for the log likelihood.)
</p>
<p>In previous versions of this package (0.1-17 and earlier)
<code>optim()</code> was called with method <code>"L-BFGS-B"</code>.
The change was made possible by the fact that, with the new
&ldquo;direct&rdquo; version of <code><a href="#topic+ddb">ddb</a>()</code>, it is no longer
necessary to bound the parameters away from (above) zero.
</p>


<h3>Value</h3>

<p>An object of class <code>"mleDb"</code>.  Such an object consists of a
named vector with entries <code>"alpha"</code> and <code>"beta"</code>, which
are the estimates of the corresponding parameters.  It has a
number of attributes:
</p>

<ul>
<li> <p><code>"ntop"</code> The value of the <code>ntop</code> argument.
</p>
</li>
<li> <p><code>"zeta"</code> The value of the <code>zeta</code> argument.
</p>
</li>
<li> <p><code>"log.like"</code> The (maximised) value of the log likelihood
of the data.
</p>
</li>
<li> <p><code>"covMat"</code> An estimate of the (<code class="reqn">2 \times 2</code>)
covariance matrix of the parameter estimates.  This is formed
as the inverse of the hessian (of the negative log likelihood)
calculated by <code><a href="#topic+aHess">aHess</a>()</code>.
</p>
</li>
<li> <p><code>ndata</code> The number of <em>non-missing</em> values
in the data set for which the likelihood was maximised,
i.e. <code>sum(!is.na(x))</code>.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddb">ddb</a></code>
<code><a href="#topic+meDb">meDb</a>()</code>
<code><a href="stats.html#topic+optim">optim</a>()</code>
<code><a href="#topic+aHess">aHess</a>()</code>
<code><a href="#topic+vcov.mleDb">vcov.mleDb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(42)
x &lt;- rdb(500,3,5,2)
ests &lt;- mleDb(x,2)  # Bad!  Mind you, 2 is a "bad" value for ntop!
                    # Hessian is singular; covMat is NA.
# Get much better results using true parameter values
# as starting values; pity we can't do this in real life!
ests &lt;- mleDb(x,2,par0=c(alpha=3,beta=5))
x &lt;- rdb(500,3,5,20)
ests &lt;- mleDb(x,20) # Pretty good.
print(vcov(ests))

# Binomial, n = 10, p = 0.3.
set.seed(42)
x   &lt;- rbinom(1000,10,0.3)
fit &lt;- mleDb(x,10,zeta=TRUE)
print(vcov(fit))
p1  &lt;- dbinom(0:10,10,0.3)
p2  &lt;- dbinom(0:10,10,mean(x)/10)
p3  &lt;- table(factor(x,levels=0:10))/1000
plot(fit,obsd=x,legPos=NULL,ylim=c(0,max(p1,p2,p3,
     ddb(0:10,fit[1],fit[2],10,zeta=TRUE))))
lines(0.2+(0:10),p1,col="orange",type="h",ylim=c(0,max(p1,p2)))
lines(0.3+(0:10),p2,col="green",type="h")
legend("topright",lty=1,col=c("red","blue","orange","green"),
       legend=c("db","observed","true binomial","fitted binomial"),bty="n")
print(attr(fit,"log.like")) # -1778.36
print(sum(dbinom(x,10,mean(x)/10,log=TRUE))) # -1777.36
# Slightly better fit with only one estimated parameter,
# but then binomial is the true distribution, so you'd
# kind of expect a better fit.
print(sum(dbinom(x,10,0.3,log=TRUE))) # -1778.37

# Poisson mean = 5
set.seed(42)
x    &lt;- rpois(1000,5)
fit  &lt;- mleDb(x,14,zeta=TRUE) # max(x) = 13, take ntop = 1+13
print(vcov(fit))
p1   &lt;- c(dpois(0:13,5),1-ppois(13,5))
lhat &lt;- mean(x)
p2   &lt;- c(dpois(0:13,lhat),1-ppois(13,lhat))
plot(fit,obsd=x,legPos=NULL,ylim=c(0,max(p1,p2,p3,
     ddb(0:14,fit[1],fit[2],14,zeta=TRUE))))
lines(0.2+0:14,p1,col="orange",type="h")
lines(0.3+(0:14),p2,col="green",type="h")
legend("topright",lty=1,col=c("red","blue","orange","green"),
       legend=c("db","observed","true Poisson","fitted Poisson"),bty="n")
print(attr(fit,"log.like")) # -2198.594
print(sum(dpois(x,lhat,log=TRUE))) # -2197.345
# Slightly better fit with only one estimated parameter,
# but then Poisson is the true distribution, so you'd
# kind of expect a better fit.
print(sum(dpois(x,5,log=TRUE))) # -2198.089
</code></pre>

<hr>
<h2 id='ndata'>
Retrieve the <code>"ndata"</code> attribute of an <code>"mleDb"</code>
object.
</h2><span id='topic+ndata'></span>

<h3>Description</h3>

<p>Retrieve the number of (non-missing) values in the data set
to which an <code>"mleDb"</code> object was fitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ndata(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ndata_+3A_object">object</code></td>
<td>

<p>An object of class <code>"mleDb"</code> as returned by <code><a href="#topic+mleDb">mleDb</a>()</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer scalar equal to the number of (non-missing) values in
the data set to which <code>object</code> was fitted.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mleDb">mleDb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- hmm.discnp::SydColDisc
X$y &lt;- as.numeric(X$y)
X &lt;- split(X,f=with(X,interaction(locn,depth)))
fitz &lt;- lapply(X,function(x){mleDb(x$y,ntop=5)})
sapply(fitz,ndata)
</code></pre>

<hr>
<h2 id='nHess'>
Numerical hessian calculation.
</h2><span id='topic+nHess'></span>

<h3>Description</h3>

<p>Calculate an approximation to the hessian of the <b>negative</b>
log likelihood of a db or beta binomial distribution via a numerical (finite
differencing based) procedure as effected by optimHess().
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nHess(object, x, silent=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nHess_+3A_object">object</code></td>
<td>

<p>An object of class <code>"mleDb"</code> or <code>"mleBb"</code> as returned by the
function <code><a href="#topic+mleDb">mleDb</a>()</code> or <code><a href="#topic+mleBb">mleBb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="nHess_+3A_x">x</code></td>
<td>

<p>Numeric vector of non-negative integer data, presumably the
data set on the basis of which <code>object</code> was calculated.
Ignored if <code>object</code> is of class <code>"mleDb"</code>.
</p>
</td></tr>
<tr><td><code id="nHess_+3A_silent">silent</code></td>
<td>

<p>Logical scalar.  If the call to <code><a href="stats.html#topic+optimHess">optimHess</a>()</code> throws
an error, should the error message be suppressed?  (A possibly
less informative warning will be issued in any case.)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is up to the user to make sure that (when <code>object</code>
is of class <code>"mleBb"</code>) <code>object</code> and <code>x</code> are
&ldquo;mutually compatible&rdquo;, i.e. are appropriately paired up.
</p>
<p>Note that this function calculates the hessian of the
<b>negative</b> log likelihood of the distribution in question,
as <em>minimised</em> by <code>optim()</code>.  Hence its inverse
is an estimate of the covariance matrix of the parameter estimates.
(Do <em>not</em> take the negative of this hessian before inverting
it to get the desired covariance matrix!)
</p>
<p>This function is mainly present to investigate possible differences
between the numerical approximation to the hessian, which is what
<code>optim()</code> uses in its maximisation procedure, and the analytic
form of the hessian.
</p>


<h3>Value</h3>

<p>A two-by-two positive definite (with any luck!) numeric matrix.
Its inverse is an estimate of the covariance matrix of the
parameter estimates.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+aHess">aHess</a>()</code>
<code><a href="#topic+mleDb">mleDb</a>()</code>
<code><a href="#topic+mleBb">mleBb</a>()</code>
<code><a href="stats.html#topic+optim">optim</a>()</code>
<code><a href="stats.html#topic+optimHess">optimHess</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- hmm.discnp::SydColDisc
X$y &lt;- as.numeric(X$y)
X &lt;- split(X,f=with(X,interaction(locn,depth)))
x &lt;- X[[19]]$y
fit &lt;- mleDb(x, ntop=5)
H   &lt;- nHess(fit,x)
print(solve(H)) # Compare with ...
print(vcov(fit))
</code></pre>

<hr>
<h2 id='plot.mleBb'>
Plot a maxium likelihood fit to data from a beta binomial distribution.
</h2><span id='topic+plot.mleBb'></span>

<h3>Description</h3>

<p>Creates a plot of type <code>"h"</code> of the probabilities of each
possible <code>x</code> value of a beta binomial distribution where
the probabilities are calculated on the basis of parameters
estimated by the function <code>mleBb()</code>.  If <code>obsd</code>
is supplied it also superimposes/juxtaposes vertical lines
representing the observed proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mleBb'
plot(x, ..., plot = TRUE, col.fit = "red", col.obsd = "blue",
              tikx = NULL, xlim=NULL, ylim=NULL, xlab = NULL,
              ylab = NULL, obsd = NULL, incr = NULL,
              main = "", legPos = "topright")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mleBb_+3A_x">x</code></td>
<td>

<p>An object of class <code>"mleBb"</code> as returned by the function
<code><a href="#topic+mleBb">mleBb</a>()</code>
</p>
</td></tr>
<tr><td><code id="plot.mleBb_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
<tr><td><code id="plot.mleBb_+3A_plot">plot</code></td>
<td>

<p>Logical scalar; should a plot be produced (or should the function
simply return a data frame consisting of the relevant values)?
</p>
</td></tr>
<tr><td><code id="plot.mleBb_+3A_col.fit">col.fit</code></td>
<td>

<p>The colour for the (vertical) lines corresponding to the
&ldquo;fitted&rdquo; probabilities, i.e. the probabilities calculated
from the fitted parameters.
</p>
</td></tr>
<tr><td><code id="plot.mleBb_+3A_col.obsd">col.obsd</code></td>
<td>

<p>The colour for the (vertical) lines corresponding to the
&ldquo;observed&rdquo; probabilities (proportions), i.e. the
probabilities calculated by tabulating the data (from which the
parameters were estimated.  Ignored if <code>obsd</code> is not supplied.
</p>
</td></tr>
<tr><td><code id="plot.mleBb_+3A_tikx">tikx</code></td>
<td>

<p>(Optional) vector of locations of the tick marks on the <code>x</code>-axis.
</p>
</td></tr>
<tr><td><code id="plot.mleBb_+3A_xlim">xlim</code></td>
<td>
<p>A numeric vector of length 2 specifying the limits
of the <code>x</code>-axis.  Defaults to <code>c(0,size)</code> Note that
\ codesize is extracted from argument <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.mleBb_+3A_ylim">ylim</code></td>
<td>
<p>A numeric vector of length 2 specifying the limits
of the <code>y</code>-axis.  There is a &ldquo;sensible&rdquo; default.
</p>
</td></tr>
<tr><td><code id="plot.mleBb_+3A_xlab">xlab</code></td>
<td>

<p>A label for the <code class="reqn">x</code>-axis; defaults to <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.mleBb_+3A_ylab">ylab</code></td>
<td>

<p>A label for the <code class="reqn">y</code>-axis; defaults to <code>probability</code>.
</p>
</td></tr>
<tr><td><code id="plot.mleBb_+3A_obsd">obsd</code></td>
<td>

<p>The data set from which the parameters were estimated, i.e. from
which <code>x</code> was obtained.  (Optional.)
</p>
</td></tr>
<tr><td><code id="plot.mleBb_+3A_incr">incr</code></td>
<td>

<p>Numeric scalar; defaults to 0.1 if <code>size</code> (extracted from
<code>x</code>) is less than 20 and to 0.5 otherwise.  This number should
be non-zero and less than 1 in absolute value.  (One would usually
want it to be positive, but it could conceiveably be set to a
small negative value.) It gives the value of the &ldquo;increment&rdquo;
or &ldquo;shift&rdquo; that separates the vertical lines representing
the fitted probabilities and those representing the observed
proportions (calculated from <code>obsd</code>).  Ignored if <code>obsd</code>
is not supplied.
</p>
</td></tr>
<tr><td><code id="plot.mleBb_+3A_main">main</code></td>
<td>

<p>A main title for the plot; defaults to the empty string.
</p>
</td></tr>
<tr><td><code id="plot.mleBb_+3A_legpos">legPos</code></td>
<td>

<p>A list with components <code>x</code> and <code>y</code>, or a text string,
specifying the placement of the legend.  See <code><a href="graphics.html#topic+legend">legend</a>()</code>
for details.   A legend is plotted only if <code>obsd</code> is
specified, whence <code>legPos</code> is otherwise ignored.  The plotting
of a legend may be suppressed (even when <code>obsd</code> is supplied)
by setting <code>legPos=NULL</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with numeric columns <code>x</code>, <code>p</code> and
possibly <code>po</code>.  The <code>x</code> column consists of the integers
from 0 to <code>size</code>.  The <code>p</code> column consists of the
appropriate probabilities of the <code>x</code> values, calculated by
<code>dbetabinom()</code> from the <code>rmutil</code> package.  The <code>po</code>
column is present only if <code>obsd</code> is supplied and consists
of the observed proportions.  The value is returned invisibly.
A plot is produced as a side-effect if <code>plot</code> is <code>TRUE</code>.
</p>


<h3>Note</h3>

<p>This function calls <code>plotBb()</code> to do the heavy lifting.
</p>


<h3>Warning</h3>

<p>It is up to the user to make sure that the <code>obsd</code> argument,
if specified, is indeed the data set from which the object <code>x</code>
was calculated.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mleBb">mleBb</a>()</code>
<code><a href="#topic+plotBb">plotBb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   if(require(hmm.discnp)) {
      xxx &lt;- hmm.discnp::Downloads
      fit &lt;- mleBb(xxx,size=14)
      plot(fit)
      plot(fit,obsd=xxx)
      plot(fit,obsd=xxx,legPos=list(x=3,y=0.25))
      plot(fit,obsd=xxx,legPos=NULL) # No legend is plotted.
   }
   set.seed(42)
   yyy &lt;- rbinom(300,10,0.7)
   fit &lt;- mleBb(yyy,size=10)
   plot(fit,obsd=yyy,legPos="topleft")
</code></pre>

<hr>
<h2 id='plot.mleDb'>
Plot a maxium likelihood fit to data from a db distribution.
</h2><span id='topic+plot.mleDb'></span>

<h3>Description</h3>

<p>Creates a plot of type <code>"h"</code> of the probabilities of
each possible <code>x</code> value of a db distribution where
the probabilities are calculated on the basis of parameters
estimated by the function <code>mleDb()</code>.  If <code>obsd</code>
is supplied it also superimposes/juxtaposes vertical lines
representing the observed proportions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mleDb'
plot(x, ..., plot = TRUE, col.fit = "red", col.obsd = "blue",
              tikx=NULL, xlim=NULL, ylim=NULL, xlab = NULL, ylab = NULL,
              obsd = NULL, incr = NULL, main = "", legPos = "topright")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mleDb_+3A_x">x</code></td>
<td>

<p>An object of class <code>"mleDb"</code> as returned by the function
<code><a href="#topic+mleDb">mleDb</a>()</code>
</p>
</td></tr>
<tr><td><code id="plot.mleDb_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
<tr><td><code id="plot.mleDb_+3A_plot">plot</code></td>
<td>

<p>Logical scalar; should a plot be produced (or should the function
simply return a data frame consisting of the relevant values)?
</p>
</td></tr>
<tr><td><code id="plot.mleDb_+3A_col.fit">col.fit</code></td>
<td>

<p>The colour for the (vertical) lines corresponding to the
&ldquo;fitted&rdquo; probabilities, i.e. the probabilities calculated
from the fitted parameters.
</p>
</td></tr>
<tr><td><code id="plot.mleDb_+3A_col.obsd">col.obsd</code></td>
<td>

<p>The colour for the (vertical) lines corresponding to the
&ldquo;observed&rdquo; probabilities (proportions), i.e. the
probabilities calculated by tabulating the data (from which the
parameters were estimated.  Ignored if <code>obsd</code> is not supplied.
</p>
</td></tr>
<tr><td><code id="plot.mleDb_+3A_tikx">tikx</code></td>
<td>

<p>(Optional) vector of locations of the tick marks on the <code>x</code>-axis.
</p>
</td></tr>
<tr><td><code id="plot.mleDb_+3A_xlim">xlim</code></td>
<td>
<p>A numeric vector of length 2 specifying the limits
of the <code>x</code>-axis.  Defaults to <code>c(nbot,ntop)</code> where
<code>nbot</code> is 0 if <code>x[["zeta"]]</code> is <code>TRUE</code> (i.e.
zero origin indexing is uses) and is 1 otherwise.  Note that
<code>ntop</code> and <code>zeta</code> are extracted from argument <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.mleDb_+3A_ylim">ylim</code></td>
<td>
<p>A numeric vector of length 2 specifying the limits
of the <code>y</code>-axis.  There is a &ldquo;sensible&rdquo; default.
</p>
</td></tr>
<tr><td><code id="plot.mleDb_+3A_xlab">xlab</code></td>
<td>

<p>A label for the <code class="reqn">x</code>-axis; defaults to <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plot.mleDb_+3A_ylab">ylab</code></td>
<td>

<p>A label for the <code class="reqn">y</code>-axis; defaults to <code>probability</code>.
</p>
</td></tr>
<tr><td><code id="plot.mleDb_+3A_obsd">obsd</code></td>
<td>

<p>The data set from which the parameters were estimated, i.e. from
which <code>x</code> was obtained.  (Optional.)
</p>
</td></tr>
<tr><td><code id="plot.mleDb_+3A_incr">incr</code></td>
<td>

<p>Numeric scalar; defaults to 0.1 if <code>ntop</code> (extracted from
<code>x</code>) is less than 20 and to 0.5 otherwise.  This number should
be non-zero and less than 1 in absolute value.  (One would usually
want it to be positive, but it could conceiveably be set to a
small negative value.) It gives the value of the &ldquo;increment&rdquo;
or &ldquo;shift&rdquo; that separates the vertical lines representing
the fitted probabilities and those representing the observed
proportions (calculated from <code>obsd</code>).  Ignored if <code>obsd</code>
is not supplied.
</p>
</td></tr>
<tr><td><code id="plot.mleDb_+3A_main">main</code></td>
<td>

<p>A main title for the plot; defaults to the empty string.
</p>
</td></tr>
<tr><td><code id="plot.mleDb_+3A_legpos">legPos</code></td>
<td>

<p>A list with components <code>x</code> and <code>y</code>, or a text string,
specifying the placement of the legend.  See <code><a href="graphics.html#topic+legend">legend</a>()</code>
for details.   A legend is plotted only if <code>obsd</code> is
specified, whence <code>legPos</code> is otherwise ignored.  The plotting
of a legend may be suppressed (even when <code>obsd</code> is supplied)
by setting <code>legPos=NULL</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with numeric columns <code>x</code>, <code>p</code> and possibly
<code>po</code>.  The <code>x</code> column consists of the integers from
0 to <code>ntop</code> or from 1 to <code>ntop</code> depending on whether
<code>zeta</code> is <code>TRUE</code>.  The <code>p</code> column consists of
the appropriate probabilities of the <code>x</code> values, calculated
by <code>link{ddb}()</code>.  The <code>po</code> column is present only if
<code>obsd</code> is supplied and consists of the observed proportions.
The value is returned invisibly.  A plot is produced as a
side-effect if <code>plot</code> is <code>TRUE</code>.
</p>


<h3>Note</h3>

<p>This function calls <code>plotDb()</code> to do the heavy lifting.
</p>


<h3>Warning</h3>

<p>It is up to the user to make sure that the <code>obsd</code> argument,
if specified, is indeed the data set from which the object <code>x</code>
was calculated.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mleDb">mleDb</a>()</code>
<code><a href="#topic+plotDb">plotDb</a>()</code>
<code><a href="#topic+ddb">ddb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   if(require(hmm.discnp)) {
      xxx &lt;- hmm.discnp::Downloads
      fit &lt;- mleDb(xxx,ntop=14,z=TRUE)
      plot(fit)
      plot(fit,obsd=xxx)
      plot(fit,obsd=xxx,legPos=list(x=3,y=0.25))
      plot(fit,obsd=xxx,legPos=NULL) # No legend is plotted.
   }
   set.seed(42)
   yyy &lt;- rbinom(300,10,0.7)
   fit &lt;- mleDb(yyy,ntop=10,z=TRUE)
   plot(fit,obsd=yyy,legPos="topleft")
</code></pre>

<hr>
<h2 id='plotBb'>
Plot a beta binomial distribution.
</h2><span id='topic+plotBb'></span>

<h3>Description</h3>

<p>Plots the probabilities of a specified beta binomial distributon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBb(m, s, size, ..., plot = TRUE, tikx = NULL, xlim = NULL,
        ylim = NULL, xlab = NULL, ylab = NULL, main = "")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBb_+3A_m">m</code></td>
<td>

<p>Numeric scalar between 0 and 1.  May be interpreted as the
&ldquo;success probability&rdquo;.
</p>
</td></tr>
<tr><td><code id="plotBb_+3A_s">s</code></td>
<td>

<p>Numeric scalar, greater than 0.  The overdispersion parameter
of the distribution.
</p>
</td></tr>
<tr><td><code id="plotBb_+3A_size">size</code></td>
<td>

<p>Integer scalar specifying the upper limit of the &ldquo;support&rdquo;
of the beta binomial distribution under consideration.  The support
is the set of integers <code>{0, 1, ..., size}</code>. 
</p>
</td></tr>
<tr><td><code id="plotBb_+3A_...">...</code></td>
<td>

<p>Extra arguments that are passed to the <code>plot()</code> function.
</p>
</td></tr>
<tr><td><code id="plotBb_+3A_plot">plot</code></td>
<td>

<p>Logical scalar; should a plot be produced (or should the function
simply return a data frame consisting of the relevant values)?
</p>
</td></tr>
<tr><td><code id="plotBb_+3A_tikx">tikx</code></td>
<td>

<p>(Optional) vector of locations of the tick marks on the <code>x</code>-axis.
</p>
</td></tr>
<tr><td><code id="plotBb_+3A_xlim">xlim</code></td>
<td>

<p>The <code>x</code>-limits of the plot.  (See <code><a href="graphics.html#topic+plot.default">plot.default</a>()</code>.)
</p>
</td></tr>
<tr><td><code id="plotBb_+3A_ylim">ylim</code></td>
<td>

<p>The <code>y</code>-limits of the plot.  (See <code><a href="graphics.html#topic+plot.default">plot.default</a>()</code>.)
</p>
</td></tr>
<tr><td><code id="plotBb_+3A_xlab">xlab</code></td>
<td>

<p>A label for the <code>x</code>-axis. (See <code><a href="graphics.html#topic+plot.default">plot.default</a>()</code>.)
</p>
</td></tr>
<tr><td><code id="plotBb_+3A_ylab">ylab</code></td>
<td>

<p>A label for the <code>y</code>-axis. (See <code><a href="graphics.html#topic+plot.default">plot.default</a>()</code>.)
</p>
</td></tr>
<tr><td><code id="plotBb_+3A_main">main</code></td>
<td>

<p>An overall title for the plot. (See <code><a href="graphics.html#topic+plot.default">plot.default</a>()</code>;
see also <code><a href="graphics.html#topic+title">title</a>()</code>.)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with numeric columns <code>x</code> and <code>p</code>.  The
<code>x</code> column consists of the integers from 0 to <code>size</code>.
The <code>p</code> column consists of the appropriate probabilities of
the <code>x</code> values, calculated by <code>dbetabinom()</code> from the
<code>rmutil</code> package.  The value is returned invisibly.  A plot
is produced as a side-effect if <code>plot</code> is <code>TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.mleBb">plot.mleBb</a>()</code>
<code><a href="#topic+plotDb">plotDb</a>()</code>
<code><a href="#topic+plot.mleDb">plot.mleDb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotBb(0.7,3,14,main="An exempular plot")
plotBb(0.3,3,14,col="red",xlab="count",main="A communist plot")
plotBb(0.1,10,14,col="blue",main="A royal plot")
plotBb(0.5,20,14,col="green",main="An ecological plot")
plotBb(0.5,20,14,xlim=c(0,15))
plotBb(0.5,20,14,xlim=c(0,15),tikx=3*(0:5))
</code></pre>

<hr>
<h2 id='plotDb'>
Plot a db distribution.
</h2><span id='topic+plotDb'></span>

<h3>Description</h3>

<p>Plots the probabilities of a specified db distributon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDb(alpha, beta, ntop, zeta, ..., plot = TRUE, tikx = NULL, xlim = NULL,
        ylim = NULL, xlab = NULL, ylab = NULL, main = "")

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDb_+3A_alpha">alpha</code></td>
<td>

<p>See <code><a href="#topic+ddb">ddb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="plotDb_+3A_beta">beta</code></td>
<td>

<p>See <code><a href="#topic+ddb">ddb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="plotDb_+3A_ntop">ntop</code></td>
<td>

<p>See <code><a href="#topic+ddb">ddb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="plotDb_+3A_zeta">zeta</code></td>
<td>

<p>See <code><a href="#topic+ddb">ddb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="plotDb_+3A_...">...</code></td>
<td>

<p>Extra arguments that are passed to the <code>plot()</code> function.
</p>
</td></tr>
<tr><td><code id="plotDb_+3A_plot">plot</code></td>
<td>

<p>Logical scalar; should a plot be produced (or should the function
simply return a data frame consisting of the relevant values)?
</p>
</td></tr>
<tr><td><code id="plotDb_+3A_tikx">tikx</code></td>
<td>

<p>(Optional) vector of locations of the tick marks on the <code>x</code>-axis.
</p>
</td></tr>
<tr><td><code id="plotDb_+3A_xlim">xlim</code></td>
<td>

<p>The <code>x</code>-limits of the plot.  (See <code><a href="graphics.html#topic+plot.default">plot.default</a>()</code>.)
</p>
</td></tr>
<tr><td><code id="plotDb_+3A_ylim">ylim</code></td>
<td>

<p>The <code>y</code>-limits of the plot.  (See <code><a href="graphics.html#topic+plot.default">plot.default</a>()</code>.)
</p>
</td></tr>
<tr><td><code id="plotDb_+3A_xlab">xlab</code></td>
<td>

<p>A label for the <code>x</code>-axis. (See <code><a href="graphics.html#topic+plot.default">plot.default</a>()</code>.)
</p>
</td></tr>
<tr><td><code id="plotDb_+3A_ylab">ylab</code></td>
<td>

<p>A label for the <code>y</code>-axis. (See <code><a href="graphics.html#topic+plot.default">plot.default</a>()</code>.)
</p>
</td></tr>
<tr><td><code id="plotDb_+3A_main">main</code></td>
<td>

<p>An overall title for the plot. (See <code><a href="graphics.html#topic+plot.default">plot.default</a>()</code>;
see also <code><a href="graphics.html#topic+title">title</a>()</code>.)
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with numeric columns <code>x</code> and <code>p</code>. The
<code>x</code> column consists of the integers from 0 to <code>ntop</code>
or from 1 to <code>ntop</code> depending on whether <code>zeta</code>
is <code>TRUE</code>.  The <code>p</code> column consists of the
appropriate probabilities of the <code>x</code> values, calculated by
<code><a href="#topic+ddb">ddb</a>()</code>.  The value is returned invisibly.  A plot
is produced as a side-effect if <code>plot</code> is <code>TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.mleDb">plot.mleDb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotDb(2,3,14,FALSE,main="An exempular plot")
plotDb(2,3,14,TRUE,col="red",xlab="count",main="A communist plot")
plotDb(0.1,3,14,TRUE,col="blue",main="A royal plot")
plotDb(0.1,0.3,14,TRUE,col="green",main="An ecological plot")
plotDb(2,3,14,FALSE,xlim=c(0,15))
plotDb(2,3,14,FALSE,xlim=c(0,15),tikx=3*(0:5))
par(mfrow=c(2,1))
plotDb(2,2,5,FALSE,main=bquote(paste(alpha == 2,", ",beta == 2)),col="red")
plotDb(-2,-2,5,FALSE,main=bquote(paste(alpha == -2,", ",beta == -2)),col="blue")
</code></pre>

<hr>
<h2 id='simulate'>
Simulate data from a db or beta binomial distribution.
</h2><span id='topic+simulate.mleDb'></span><span id='topic+simulate.mleBb'></span><span id='topic+simulate.Dbdpars'></span><span id='topic+simulate.Bbdpars'></span>

<h3>Description</h3>

<p>Simulate one or more data sets from a db or beta binomial
distribution.  The parameters of the distribution may be
equal to those obtained from fitting the distibution to data,
using <code>mleDb()</code> or <code>mleBb()</code>.  They may also be
specified by the user via the function <code>makeDbdpars()</code>
or <code>makeBbdpars()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'mleDb'
simulate(object, nsim = 1, seed = NULL, ...,
                             ndata = NULL, drop = TRUE)
   ## S3 method for class 'mleBb'
simulate(object, nsim = 1, seed = NULL, ...,
                             ndata = NULL, drop = TRUE)
   ## S3 method for class 'Dbdpars'
simulate(object, nsim = 1, seed = NULL, ...,
                             ndata = NULL, drop = TRUE)
   ## S3 method for class 'Dbdpars'
simulate(object, nsim = 1, seed = NULL, ...,
                             ndata = NULL, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_+3A_object">object</code></td>
<td>

<p>An object of class <code>"mleDb"</code> as returned by
<code><a href="#topic+mleDb">mleDb</a>()</code>, or of class <code>"mleBb"</code> as returned by
<code><a href="#topic+mleBb">mleBb</a>()</code>, or of class <code>"Dbdpars"</code> as returned
by <code><a href="#topic+makeDbdpars">makeDbdpars</a>()</code> or of class <code>"Bbdpars"</code>
as returned by <code><a href="#topic+makeBbdpars">makeBbdpars</a>()</code>.
</p>
</td></tr>
<tr><td><code id="simulate_+3A_nsim">nsim</code></td>
<td>

<p>The number of data sets to simulate.
</p>
</td></tr>
<tr><td><code id="simulate_+3A_seed">seed</code></td>
<td>

<p>Integer vector of seeds for random number generation.  It should
be of length either 1 or <code>nsim</code>.  If it is of length less
than <code>nsim</code> then <code>set.seed(seed[1])</code> is called and
<code>seed</code> is replaced by a vector of seeds of length <code>nsim</code>
which is created by sampling from <code>1:1e5</code>.  Note that in this
case all entries but the first of <code>seed</code> are <em>ignored</em>.
If it is longer than <code>nsim</code>, then only the first <code>nsim</code>
entries are used and the others are ignored.  If <code>seed</code>
it is not supplied it is created by sampling <code>nsim</code> values
from <code>1:1e5</code>.
</p>
</td></tr>
<tr><td><code id="simulate_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
<tr><td><code id="simulate_+3A_ndata">ndata</code></td>
<td>

<p>Integer vector specifying the lengths of the data sets to
be simulated.  If it is of length less than <code>nsim</code> it is
&ldquo;recycled&rdquo; to provide a vector of length <code>nsim</code>.
If is longer than <code>nsim</code>, then only the first <code>nsim</code>
entries are used and the others are ignored.  If <code>ndata</code>
is not supplied it is taken to be equal to the <code>"ndata"</code>
attribute of <code>object</code> (i.e. the length of the data set from
which the parameters in <code>object</code> were estimated.
</p>
</td></tr>
<tr><td><code id="simulate_+3A_drop">drop</code></td>
<td>

<p>Logical scalar; if <code>TRUE</code> and if <code>nsim==1</code> then
this function simply returns the simulated data set (an
integer vector) rather than a list of length 1 whose sole
entry is that data set.  If <code>nsim&gt;1</code> then <code>drop</code>
is ignored.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The actual simulation is done by <code><a href="#topic+rdb">rdb</a>()</code> or by the
<code>rbetabinom()</code> function from the <code>rmutil</code> package.
</p>


<h3>Value</h3>

<p>A list, of length <code>nsim</code>, whose entries are integer
vectors, the length of of the <code>i</code>th entry being equal to
<code>ndata[i]</code>.  Each entry has an attribute <code>"seed"</code> which
is the random number generation seed that was used in the generation
of the data in that entry.  If <code>nsim==1</code> and if <code>drop</code> is
<code>TRUE</code>, then the value is simply an integer vector
(of length <code>ndata[1]</code>).
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+simulate">simulate</a>()</code> <code><a href="#topic+rdb">rdb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   X   &lt;- hmm.discnp::Downloads
   fit &lt;- mleDb(X,ntop=15,zeta=TRUE)
   s1  &lt;- simulate(fit)
   s2  &lt;- simulate(fit,nsim=5) # All data sets of length 267.
   s3  &lt;- simulate(fit,nsim=5,ndata=100*(2:6))
   obj &lt;- makeDbdpars(alpha=2,beta=3,ntop=20,zeta=TRUE,ndata=500)
   s4  &lt;- simulate(obj,nsim=5,seed=1:5)
</code></pre>

<hr>
<h2 id='varBb'>
Variance of a beta binomial distribution.
</h2><span id='topic+varBb'></span><span id='topic+varBb.mleBb'></span><span id='topic+varBb.default'></span>

<h3>Description</h3>

<p>Calculate the variance of a random variable having a beta binomial
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varBb(mo,...)
## S3 method for class 'mleBb'
varBb(mo,...)
## Default S3 method:
varBb(mo, s, size, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varBb_+3A_mo">mo</code></td>
<td>

<p>For the <code>"mleBb"</code> method this argument is an object of class
<code>"mleBb"</code> as returned by <code><a href="#topic+mleBb">mleBb</a>()</code>.  For the
default method it is a numeric scalar, between 0 and 1, playing the
role of <code>m</code> (which may be interpreted as the &ldquo;success&rdquo;
probability).  (See the help for <code>dbetabinom()</code>.)
</p>
</td></tr>
<tr><td><code id="varBb_+3A_s">s</code></td>
<td>

<p>Numeric scalar, greater than 0.  The overdispersion parameter
of the distribution. (See the help for <code>dbetabinom()</code>.)
</p>
</td></tr>
<tr><td><code id="varBb_+3A_size">size</code></td>
<td>

<p>Integer scalar specifying the upper limit of the &ldquo;support&rdquo;
of the beta binomial distribution under consideration.  The support
is the set of integers <code>{0, 1, ..., size}</code>.  (See the help
for <code>dbetabinom()</code>.)
</p>
</td></tr>
<tr><td><code id="varBb_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the <code>"mleBb"</code> method, the single argument should really
be called (something like) &ldquo;<code>object</code>&rdquo; and for the
default method the first argument should be called <code>m</code>.
However the argument lists must satisfy the restrictions that
&ldquo;<em>A method must have all the arguments of the generic,
including ... if the generic does.</em>&rdquo; and &ldquo;<em>A method
must have arguments in exactly the same order as the generic.</em>&rdquo;
</p>
<p>For the <code>"mleBb"</code> method, the values of <code>m</code> and <code>s</code>
are obtained from <code>mo</code>, and <code>size</code> is extracted from
the attributes of <code>mo</code>.
</p>
<p>The variance of a beta binomial distribution is readily calculable
&ldquo;by hand&rdquo;.  These functions are provided for convenience
and to preserve parallelism with the db distribution.
</p>


<h3>Value</h3>

<p>Numeric scalar equal to the variance of a beta binomial distributed
random variable with the given parameters.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+varDb">varDb</a>()</code>
<code><a href="#topic+expValDb">expValDb</a>()</code>
<code><a href="#topic+expValBb">expValBb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   varBb(0.7,0.1,15)
   varBb(0.7,400,15)
   X   &lt;- hmm.discnp::Downloads
   fit &lt;- mleBb(X,size=15)
   varBb(fit)
</code></pre>

<hr>
<h2 id='varDb'>
Variance of a db distribution.
</h2><span id='topic+varDb'></span><span id='topic+varDb.mleDb'></span><span id='topic+varDb.default'></span>

<h3>Description</h3>

<p>Calculate the variance of a random variable having a db
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varDb(ao,...)
## S3 method for class 'mleDb'
varDb(ao,...)
## Default S3 method:
varDb(ao, beta, ntop, zeta=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varDb_+3A_ao">ao</code></td>
<td>

<p>For the <code>"mleDb"</code> method this argument is an object of class
<code>"mleDb"</code> as returned by <code><a href="#topic+mleDb">mleDb</a>()</code>.  For the
default method it is a numeric scalar playing the role of
<code>alpha</code> (see <code><a href="#topic+ddb">ddb</a>()</code>).
</p>
</td></tr>
<tr><td><code id="varDb_+3A_beta">beta</code></td>
<td>

<p>See <code><a href="#topic+ddb">ddb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="varDb_+3A_ntop">ntop</code></td>
<td>

<p>See <code><a href="#topic+ddb">ddb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="varDb_+3A_zeta">zeta</code></td>
<td>

<p>See <code><a href="#topic+ddb">ddb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="varDb_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the <code>"mleDb"</code> method, the single argument should really
be called (something like) &ldquo;<code>object</code>&rdquo; and for the
default method the first argument should be called <code>alpha</code>.
However the argument lists must satisfy the restrictions that
&ldquo;<em>A method must have all the arguments of the generic,
including ... if the generic does.</em>&rdquo; and &ldquo;<em>A method
must have arguments in exactly the same order as the generic.</em>&rdquo;
</p>
<p>For the <code>"mleDb"</code> method, the values of <code>alpha</code> and
<code>beta</code> are obtained from <code>ao</code>, and <code>ntop</code>, and
<code>zeta</code> are extracted from the attributes of <code>ao</code>.
</p>
<p>The variance of a db distribution is theoretically intractable
but is readily calculable numerically as </p>
<p style="text-align: center;"><code class="reqn">\sum (x - \mu)^2
   \times \Pr(X=x)</code>
</p>
<p>, where <code class="reqn">\mu</code>
is the expected value of the given distribution.
</p>


<h3>Value</h3>

<p>Numeric scalar equal to the variance of a db distributed
random variable with the given parameters.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ddb">ddb</a>()</code> <code><a href="#topic+expValDb">expValDb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   varDb(3,4,15)
   varDb(3,4,15,TRUE)
   X   &lt;- hmm.discnp::Downloads
   fit &lt;- mleDb(X,ntop=15,zeta=TRUE)
   varDb(fit)
</code></pre>

<hr>
<h2 id='vcov.mleBb'>
Retrieve the covariance matrix from an <code>"mleBb"</code> object.
</h2><span id='topic+vcov.mleBb'></span>

<h3>Description</h3>

<p>Extract the covariance matrix attribute an object of class
<code>"mleBb"</code>.  I.e. obtain the estimated covariance matrix
of the maximum likelihood estimates of the parameters of a
beta binomial distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'mleBb'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.mleBb_+3A_object">object</code></td>
<td>

<p>An object of class <code>"mleBb"</code> as returned by <code><a href="#topic+mleBb">mleBb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="vcov.mleBb_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimated covariance matrix is the inverse of the hessian
of the negative log likelihood. (This may also be referred to
as the observed Fisher information &mdash; the Fisher information
evaluated at the maximum likelihood estimates of the parameters).
</p>


<h3>Value</h3>

<p>A two-by-two positive definite (with any luck!) numeric matrix.
It is an estimate of the covariance matrix of the parameter estimates.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcov.mleDb">vcov.mleDb</a>)</code>
<code><a href="#topic+mleBb">mleBb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X     &lt;- hrsRcePred
top1e &lt;- X[X$sbjType=="Expert","top1"]
fit   &lt;- mleBb(top1e,size=10)
vcov(fit)
</code></pre>

<hr>
<h2 id='vcov.mleDb'>
Retrieve the covariance matrix from an <code>"mleDb"</code> object.
</h2><span id='topic+vcov.mleDb'></span>

<h3>Description</h3>

<p>Extract the covariance matrix attribute an object of class
<code>"mleDb"</code>.  I.e. obtain the estimated covariance matrix
of the maximum likelihood estimates of the parameters of a
db distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   ## S3 method for class 'mleDb'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.mleDb_+3A_object">object</code></td>
<td>

<p>An object of class <code>"mleDb"</code> as returned by <code><a href="#topic+mleDb">mleDb</a>()</code>.
</p>
</td></tr>
<tr><td><code id="vcov.mleDb_+3A_...">...</code></td>
<td>

<p>Not used.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The estimated covariance matrix is the inverse of the hessian
of the negative log likelihood. (This may also be referred to
as the observed Fisher information &mdash; the Fisher information
evaluated at the maximum likelihood estimates of the parameters).
</p>


<h3>Value</h3>

<p>A two-by-two positive definite (with any luck!) numeric matrix.
It is an estimate of the covariance matrix of the parameter estimates.
</p>


<h3>Author(s)</h3>

<p>Rolf Turner
<a href="mailto:r.turner@auckland.ac.nz">r.turner@auckland.ac.nz</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+vcov.mleBb">vcov.mleBb</a>)</code>
<code><a href="#topic+mleDb">mleDb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X &lt;- hmm.discnp::SydColDisc
X$y &lt;- as.numeric(X$y)
X &lt;- split(X,f=with(X,interaction(locn,depth)))
fitz &lt;- lapply(X,function(x){mleDb(x$y,ntop=5)})
lapply(fitz,vcov)
</code></pre>

<hr>
<h2 id='visRecog'>
Visual recognition data.
</h2><span id='topic+visRecog'></span>

<h3>Description</h3>

<p>Counts of successes in visual recognition memory for large and
small binary pictures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("visRecog")</code></pre>


<h3>Format</h3>

<p>A data frame with 30 observations on the following 4 variables.
</p>

<dl>
<dt><code>deck</code></dt><dd><p>An integer vector indicating which of two
decks of cards, bearing graphic images, was used in the
given experiment.</p>
</dd>
<dt><code>subject</code></dt><dd><p>An integer vector indexing the (human)
subjects in the experiments.</p>
</dd>
<dt><code>tot5</code></dt><dd><p>An integer vector whose entries are counts
of successes when the cards used consist of a
<code class="reqn">5 \times 5</code> grid of &ldquo;facets&rdquo;.</p>
</dd>
<dt><code>tot10</code></dt><dd><p>An integer vector whose entries are counts
of successes when the cards used consist of a
<code class="reqn">10 \times 10</code> grid of &ldquo;facets&rdquo;.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Adult subjects were shown a series of cards, each bearing a
simple graphic image.  Each image resembled one face of a Rubik's
cube, formed of either a 5x5 or a 10x10 grid of facets, each facet
being either black or white.  Later, each subject was shown a
series of 20 similar cards, exactly 10 of which had been shown to
the subject previously.  The subject's task was to identify each
image as a new one, or as a previously seen one.  The response
variable <code>tot5</code> is the number of correct identifications,
out of 20, for the <code class="reqn">5 \times 5</code> cards.  Similarly the
variable <code>tot10</code> is the number of correct identifications for
the <code class="reqn">10 \times 10</code> cards.
</p>
<p>Subjects 21&ndash;30 were (deliberately) tested with a different set of
cards than subjects 1&ndash;20, to ensure that results were not a function
of the original deck of cards.  (This seems to have no actual relevance.)
</p>


<h3>Source</h3>

<p>The data are taken from the paper sited in <b>References</b> below.
They were provided by a generous email correspondent who prefers
to remain anonymous.
</p>


<h3>References</h3>

<p>Green, D. M., and Purohit, A. K. (1976).  Visual
recognition memory for large and small binary pictures. 
<em>Journal of Experimental Psycholology: Human Learning and
Memory</em> <b>2</b>, pp. 32&ndash;37.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dbfit5  &lt;- with(visRecog,mleDb(tot5,20,TRUE))
dbfit10 &lt;- with(visRecog,mleDb(tot10,20,TRUE))
set.seed(42) # To get repeatable Monte Carlo p-values.
print(gof(dbfit5,obsd=visRecog[["tot5"]],MC=TRUE)$pval)   # 0.86
print(gof(dbfit10,obsd=visRecog[["tot10"]],MC=TRUE)$pval) # 0.68
bbfit5  &lt;- with(visRecog,mleBb(tot5,20))
bbfit10 &lt;- with(visRecog,mleBb(tot10,20))
set.seed(42) # To get repeatable Monte Carlo p-values.
print(gof(bbfit5,obsd=visRecog[["tot5"]],MC=TRUE)$pval)   # 0.94
print(gof(bbfit10,obsd=visRecog[["tot10"]],MC=TRUE)$pval) # 0.70
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
