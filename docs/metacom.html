<!DOCTYPE html><html><head><title>Help for package metacom</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {metacom}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#metacom-package'><p>Pattern-based analysis of metacommunity structure</p></a></li>
<li><a href='#BoundaryClump'><p>Determines boundary clumping</p></a></li>
<li><a href='#Coherence'><p>Determines coherence</p></a></li>
<li><a href='#Imagine'><p>Plotting of site-by-species interaction matrices</p></a></li>
<li><a href='#Metacommunity'><p>Analysis of the Elements of Metacommunity Structure</p></a></li>
<li><a href='#NullMaker'><p>Null matrix creator</p></a></li>
<li><a href='#OrderMatrix'><p>Ordinates interaction matrix</p></a></li>
<li><a href='#TestMatrices'><p>Test matrices used to evaluate metacommunity functions</p></a></li>
<li><a href='#Turnover'><p>Determines species turnover</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of the 'Elements of Metacommunity Structure'</td>
</tr>
<tr>
<td>Version:</td>
<td>1.5.3</td>
</tr>
<tr>
<td>Depends:</td>
<td>vegan (&ge; 2.2-1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Tad Dallas &lt;tad.a.dallas@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to analyze coherence, boundary clumping, and turnover
    following the pattern-based metacommunity analysis of Leibold and Mikkelson
    2002  &lt;<a href="https://doi.org/10.1034%2Fj.1600-0706.2002.970210.x">doi:10.1034/j.1600-0706.2002.970210.x</a>&gt;. The package also includes 
		functions to visualize ecological networks, and to calculate modularity 
		as a replacement to boundary clumping.</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/taddallas/metacom/issues">https://github.com/taddallas/metacom/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org/package=metacom">https://cran.r-project.org/package=metacom</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-03-22 23:50:20 UTC; tad</td>
</tr>
<tr>
<td>Author:</td>
<td>Tad Dallas [aut, cre],
  Tom Pulliam [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-03-23 07:20:08 UTC</td>
</tr>
</table>
<hr>
<h2 id='metacom-package'>Pattern-based analysis of metacommunity structure</h2><span id='topic+metacom-package'></span><span id='topic+metacom'></span>

<h3>Description</h3>

<p>'metacom' provides functions for the analysis of the elements of
metacommunity structure (coherence, boundary clumping, &amp; turnover),
following the pattern-based metacommunity framework of Leibold &amp; Mikkelson
2002 and Presley et al. 2010. This package is designed to allow the user to
distinguish between several idealized patterns of metacommunity structure
(Presley et al. 2010) utilizing any number of null model algorithms for the
randomization procedure. However, these metrics can also be used in
isolation, and without ordination via reciprocal averaging, and instead,
ordering along some biological gradient.
</p>
<p>A metacommunity is a set of sites (e.g. plants in plant-pollinator networks)
associated through interactions (e.g. insect species (columns) interact with
plant species (rows) in plant-pollinator networks). The pattern-based
metacommunity concept, proposed by Leibold &amp; Mikkelson 2002 and expounded on
by Presley et al. 2010, allows for the evaluation of metacommunity structure
by using randomization techniques to discern between 10 patterns of
metacommunity structure. This is performed by ordinating site-by-species
interaction matrices and calculating three metrics; coherence, boundary
clumping &amp; turnover.
</p>
<p>The metacom package calculates these three metrics; coherence is calculated
using the function Coherence(), boundary clumping with BoundaryClump(), and
turnover (from either species or range perspective) using the Turnover()
function. These functions are consolidated in the Metacommunity() function,
which can be used to calculate all three metrics. In order to interpret the
output of these functions, it will be helpful to read Leibold &amp; Mikkelson
2002 and Presley et al. 2010, but to also read Ulrich and Gotelli 2013, as
this paper outlines the difficulty seemingly inherent with investigating
community structure. Also, these functions do not have to be used strictly
in the Leibold and Mikkelson 2002 framework.
</p>
<p>I caution the user to be aware that the creation of null matrices can be
performed to allow (or not allow) sites to be empty, or species to not exist
at any site (i.e. column sums and/or row sums are allowed to be zero). This
is controlled by the logical argument 'allow.empty' in the Metacommunity(),
NullMaker(), Coherence(), and Turnover() functions. Restricting nulls to not
allow empty rows or columns may be biologically realistic, but it also
reduces the number of unique null matrices that can be built, which will
impact computation time, making it infeasible or impossible in some
situations. These situations occur when you have a very sparse interaction
matrix, and is also influenced by null model algorithm ('method') that you
choose.
</p>
<p>The 'metacom' package is partially adapted from previous Matlab code written
by Christopher Higgins (available at
http://www.tarleton.edu/Faculty/higgins/EMS.htm) and relies on many
functions in the 'vegan' package (Oksanen et al. 2012)
</p>


<h3>Author(s)</h3>

<p>Tad Dallas
</p>


<h3>References</h3>

<p>Dallas,T. 2014. metacom: an R package for the analysis of metacommunity
structure. Ecography. DOI:10.1111/j.1600-0587.2013.00695.x
</p>
<p>Leibold, M. &amp; Mikkelson, G. (2002) Coherence, species turnover, and boundary
clumping: elements of metacommunity structure. Oikos, 97, 237-250.
</p>
<p>Leibold, M., Holyoak, M., Mouquet, N., Amarasekare, P., Chase, J., Hoopes,
M., Holt, R., Shurin, J., Law, R., Tilman, D. et al. (2004) The
metacommunity concept: a framework for multi-scale community ecology.
Ecology letters, 7, 601-613.
</p>
<p>Oksanen, J., F.G. Blanchet, R. Kindt, P. Legendre, P.R. Minchin, R.B.
O'Hara, G.L. Simpson, P. Solymos, M.H.H. Stevens and H. Wagner (2012).
vegan: Community Ecology Package. R package version 2.0-4.
http://CRAN.R-project.org/package=vegan
</p>
<p>Presley, S., Higgins, C. &amp; Willig, M. (2010) A comprehensive framework for
the evaluation of metacommunity structure. Oikos, 119, 908-917.
</p>
<p>Ulrich, W. and Gotelli, N. J. (2013) Pattern detection in null model
analysis. Oikos, 122: 2-18. doi: 10.1111/j.1600-0706.2012.20325.x
</p>
<p>Willig, M., Presley, S., Bloch, C., Castro-Arellano, I., Cisneros, L.,
Higgins, C. &amp; Klingbeil, B. (2011) Tropical metacommunities along
elevational gradients: effects of forest type and other environmental
factors. Oikos, 120, 1497-1508.
</p>

<hr>
<h2 id='BoundaryClump'>Determines boundary clumping</h2><span id='topic+BoundaryClump'></span>

<h3>Description</h3>

<p>'BoundaryClump' calculates the Morisita's Index (Morisita 1962) for
presence-absence interaction matrices, using a chi-squared test to assess
significance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BoundaryClump(comm, order = TRUE, scores = 1, binary = TRUE,
  fill = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoundaryClump_+3A_comm">comm</code></td>
<td>
<p>community data in the form of a presence absence matrix</p>
</td></tr>
<tr><td><code id="BoundaryClump_+3A_order">order</code></td>
<td>
<p>logical argument indicating whether to ordinate the interaction
matrix or not. See details.</p>
</td></tr>
<tr><td><code id="BoundaryClump_+3A_scores">scores</code></td>
<td>
<p>axis scores to ordinate matrix. 1: primary axis scores
(default) 2: secondary axis scores</p>
</td></tr>
<tr><td><code id="BoundaryClump_+3A_binary">binary</code></td>
<td>
<p>logical argument indicating whether to ordinate the community
matrix based on abundance or binary (default) data.</p>
</td></tr>
<tr><td><code id="BoundaryClump_+3A_fill">fill</code></td>
<td>
<p>should embedded absences be filled before the statistic 
is calculated? (default is TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This statistic is not based on randomization methods, so the function only
requires a presence-absence interaction matrix and two arguments regarding
the ordination of the empirical matrix.
</p>
<p>The default is the range perspective, meaning that the analyses of boundary
clumping and species turnover compare the distribution of species among
sites. If the 'community' perspective is desired, transpose the matrix
before analysis using the transpose function ('t()'). However, the author
cautions against misinterpretation of the community perspective, as the
biological meaning of turnover and boundary clumping differ between
perspectives.
</p>
<p>Boundary clumping, quantified by the Morisita's index, is a measure of the
degree to which species range boundaries overlap. This measure, and species
turnover, cannot be interpreted unless the network is significantly coherent
(see 'Coherence()').
</p>
<p>If 'order' is FALSE, the interaction matrix is not ordinated, allowing the
user to order the matrix based on site characteristics or other biologically
relevant characteristics.
</p>


<h3>Value</h3>

<p>'BoundaryClump' returns a data frame containing the calculated
Morisita's index ('index'), the corresponding p-value ('P'), and the degrees
of freedom ('df').
</p>
<p>The p-value is based on a chi-squared test comparing the Morisita's index to
a value of 1. If the Morisita's index is less than 1, a left-tailed test is
performed (less clumping than expected by chance).
</p>
<p>If the Morisita's index is greater than 1, a right-tailed test is performed
(more clumping han expected by chance)
</p>


<h3>Author(s)</h3>

<p>Tad Dallas
</p>


<h3>References</h3>

<p>Morisita, M. 1962. Id-index, a measure of dispersion of
individuals. Res. Popul. Ecol. 4, 1-7.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(TestMatrices)
intmat &lt;- TestMatrices[[1]]
bound.test &lt;- BoundaryClump(intmat, order=TRUE, scores=1, 
binary=TRUE, fill=TRUE)
bound.test
</code></pre>

<hr>
<h2 id='Coherence'>Determines coherence</h2><span id='topic+Coherence'></span>

<h3>Description</h3>

<p>This function determines the number of embedded absences in an interaction
matrix, and compares this value against null simulated matrices. Species
ranges should be coherent along the ordination axis, as this axis represents
a latent environmental gradient. A negative value of coherence (empirical
matrix has more embedded absences than null matrices) indicates a
'checkerboard' pattern (Leibold &amp; Mikkelson 2002). Nonsignificance has been
historically interpreted as being indicative of a 'random' pattern, though
this may be seen as accepting the null hypothesis, as nonsignificance cannot
be used to infer a process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Coherence(comm, method = "r1", sims = 1000, scores = 1,
  order = TRUE, orderNulls = FALSE, allowEmpty = FALSE,
  binary = TRUE, verbose = FALSE, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Coherence_+3A_comm">comm</code></td>
<td>
<p>community data in the form of a presence absence matrix</p>
</td></tr>
<tr><td><code id="Coherence_+3A_method">method</code></td>
<td>
<p>null model randomization method used by 'nullmaker'. See
details below (and the help file of fucntion 'nullmaker') for more
information.</p>
</td></tr>
<tr><td><code id="Coherence_+3A_sims">sims</code></td>
<td>
<p>number of simulated null matrices to use in analysis</p>
</td></tr>
<tr><td><code id="Coherence_+3A_scores">scores</code></td>
<td>
<p>axis scores to ordinate matrix. 1: primary axis scores
(default) 2: secondary axis scores</p>
</td></tr>
<tr><td><code id="Coherence_+3A_order">order</code></td>
<td>
<p>logical argument indicating whether to ordinate the interaction
matrix or not. See details.</p>
</td></tr>
<tr><td><code id="Coherence_+3A_ordernulls">orderNulls</code></td>
<td>
<p>logical argument indicating whether to ordinate the null 
matrices. Default is FALSE.</p>
</td></tr>
<tr><td><code id="Coherence_+3A_allowempty">allowEmpty</code></td>
<td>
<p>logical argument indicating whether to allow null
matrices to have empty rows or columns</p>
</td></tr>
<tr><td><code id="Coherence_+3A_binary">binary</code></td>
<td>
<p>logical argument indicating whether to ordinate the community
matrix based on abundance or binary (default) data.</p>
</td></tr>
<tr><td><code id="Coherence_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Prints a graphical progress bar that tracks the
creation of null matrices. Useful for conservative null models on large
and/or sparse data.</p>
</td></tr>
<tr><td><code id="Coherence_+3A_seed">seed</code></td>
<td>
<p>seed for simulating the null model. Null matrices should be repeatable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'method' is an argument handed to functions in the 'vegan' package. Leibold
&amp; Mikkelson advocated the use of equiprobable rows and columns (provided
that rows and columns had at least one entry). This method is called 'r00'.
Methods maintaining row (site) frequencies include 'r0','r1' &amp; 'r2'. The
default method argument is 'r1', which maintains the species richness of a
site (row totals) and fills species ranges (columns) based on their marginal
probabilities. Arguably the most conservative null algorithm is the fixed
row - fixed column total null, which is implemented as 'fixedfixed'. See the
help file for 'commsimulator' or Wright et al. 1998 for more information.
</p>
<p>If 'order' is FALSE, the interaction matrix is not ordinated, allowing the
user to order the matrix based on site characteristics or other biologically
relevant characteristics. The 'orderNulls' argument allows the user to ordinate 
the null matrices. While creating a more conservative test, this may negate
the null model implemented (fixed row and column sums will not be maintained)
</p>
<p>This function can either be used as a standalone, or can be used through the
'metacommunity()' function, which determines all 3 elements of metacommunity
structure (coherence, boundary clumping, &amp; turnover) (Leibold &amp; Mikkelson
2002)
</p>


<h3>Value</h3>

<p>A vector containing the number of embedded absences (embAbs), 
z-score (z), p-value (pval), mean (simulatedMean) and variance (simulatedVariance) 
of simulations, and null model randomization method (method).
</p>


<h3>Author(s)</h3>

<p>Tad Dallas
</p>


<h3>References</h3>

<p>Leibold, M.A. and G.M. Mikkelson. 2002. Coherence, species
turnover, and boundary clumping: elements of meta-community structure. Oikos
97: 237 - 250.
</p>
<p>Wright, D.H., Patterson, B.D., Mikkelson, G.M., Cutler, A. &amp; Atmar, W.
(1998). A comparative analysis of nested subset patterns of species
composition. Oecologia 113, 1-20.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#define an interaction matrix
data(TestMatrices)
intmat=TestMatrices[[7]]

#determine coherence of interaction matrix
coh.intmat &lt;- Coherence(intmat, method='r1', sims=100, 
  scores=1, order=TRUE, binary=TRUE)

#return results
coh.intmat

</code></pre>

<hr>
<h2 id='Imagine'>Plotting of site-by-species interaction matrices</h2><span id='topic+Imagine'></span>

<h3>Description</h3>

<p>'Imagine' produces an image plot, grid of small rectangles representing
species occurrences in sites, of a given interaction matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Imagine(comm, col = c(0, 1), order = TRUE, scores = 1, fill = TRUE,
  xlab = "Species", ylab = "Site", yline = 2, xline = 2,
  sitenames = rownames(comm), speciesnames = colnames(comm),
  binary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Imagine_+3A_comm">comm</code></td>
<td>
<p>community data in the form of a presence absence matrix</p>
</td></tr>
<tr><td><code id="Imagine_+3A_col">col</code></td>
<td>
<p>colors used to plot interactions. First value is the background
color (no interaction) and the second color indicates an interaction.</p>
</td></tr>
<tr><td><code id="Imagine_+3A_order">order</code></td>
<td>
<p>logical. Should the interaction matrix be ordered based on
reciprocal averaging scores before plotting?</p>
</td></tr>
<tr><td><code id="Imagine_+3A_scores">scores</code></td>
<td>
<p>axis scores to ordinate matrix. 1: primary axis scores
(default) 2: secondary axis scores</p>
</td></tr>
<tr><td><code id="Imagine_+3A_fill">fill</code></td>
<td>
<p>logical. Should species ranges be made coherent before plotting?</p>
</td></tr>
<tr><td><code id="Imagine_+3A_xlab">xlab</code></td>
<td>
<p>name of the x axis</p>
</td></tr>
<tr><td><code id="Imagine_+3A_ylab">ylab</code></td>
<td>
<p>name of the y axis</p>
</td></tr>
<tr><td><code id="Imagine_+3A_yline">yline</code></td>
<td>
<p>line that the y-axis label is plotted on.</p>
</td></tr>
<tr><td><code id="Imagine_+3A_xline">xline</code></td>
<td>
<p>line that the x-axis label is plotted on.</p>
</td></tr>
<tr><td><code id="Imagine_+3A_sitenames">sitenames</code></td>
<td>
<p>names for each row in the interaction matrix. Default is to
not plot names.</p>
</td></tr>
<tr><td><code id="Imagine_+3A_speciesnames">speciesnames</code></td>
<td>
<p>names for each site in the interaction matrix. Default
is to not plot names.</p>
</td></tr>
<tr><td><code id="Imagine_+3A_binary">binary</code></td>
<td>
<p>logical argument indicating whether to ordinate the community
matrix based on abundance or binary (default) data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces an image plot of the interaction matrix. The code is very
simple, and may need to be modified if you have long site or species names,
or wish to make it prettier than I have the ability to.
</p>


<h3>Author(s)</h3>

<p>Tad Dallas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#define an interaction matrix
data(TestMatrices)
pres3c=TestMatrices[[6]]

#plot interaction matrix
Imagine(pres3c, col=c('white','blue'), order=TRUE, fill=FALSE)

</code></pre>

<hr>
<h2 id='Metacommunity'>Analysis of the Elements of Metacommunity Structure</h2><span id='topic+Metacommunity'></span>

<h3>Description</h3>

<p>'Metacommunity' is a wrapper for the analysis of the three elements of
metacommunity structure (coherence, boundary clumping, &amp; turnover) following
the framework of Leibold &amp; Mikkelson 2002. It is important to note here that
the results of boundary clumping and turnover are only relevant if the
matrix is significantly positively coherent (i.e. empirical matrix has fewer
embedded absences than null matrices).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Metacommunity(comm, scores = 1, method = "r1",
  turnoverMethod = "EMS", sims = 1000, order = TRUE,
  orderNulls = FALSE, allowEmpty = FALSE, binary = TRUE,
  verbose = FALSE, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Metacommunity_+3A_comm">comm</code></td>
<td>
<p>community data in the form of a presence absence matrix</p>
</td></tr>
<tr><td><code id="Metacommunity_+3A_scores">scores</code></td>
<td>
<p>Axis scores to ordinate matrix. 1: primary axis scores
(default) 2: secondary axis scores. See Details.</p>
</td></tr>
<tr><td><code id="Metacommunity_+3A_method">method</code></td>
<td>
<p>null model randomization method used by 'nullmaker'. See
details.</p>
</td></tr>
<tr><td><code id="Metacommunity_+3A_turnovermethod">turnoverMethod</code></td>
<td>
<p>(default='EMS') 'EMS' option generates null matrices 
as in Leibold and Mikkelson's original framework. However, null models
that randomize occurrences &ndash; introducing embedded absences (bad), but in a
far less constrained null space (good) &ndash; can also be used</p>
</td></tr>
<tr><td><code id="Metacommunity_+3A_sims">sims</code></td>
<td>
<p>number of simulated null matrices to use in analysis</p>
</td></tr>
<tr><td><code id="Metacommunity_+3A_order">order</code></td>
<td>
<p>logical argument indicating whether to ordinate the interaction
matrix or not. Default is TRUE. See details.</p>
</td></tr>
<tr><td><code id="Metacommunity_+3A_ordernulls">orderNulls</code></td>
<td>
<p>logical argument indicating whether to ordinate the null 
matrices. Default is FALSE.</p>
</td></tr>
<tr><td><code id="Metacommunity_+3A_allowempty">allowEmpty</code></td>
<td>
<p>logical argument indicating whether to allow null
matrices to have empty rows or columns</p>
</td></tr>
<tr><td><code id="Metacommunity_+3A_binary">binary</code></td>
<td>
<p>logical argument indicating whether to ordinate the community
matrix based on abundance or binary (default) data.</p>
</td></tr>
<tr><td><code id="Metacommunity_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Prints a graphical progress bar that tracks the
creation of null matrices. Useful for conservative null models on large
and/or sparse data.</p>
</td></tr>
<tr><td><code id="Metacommunity_+3A_seed">seed</code></td>
<td>
<p>seed for simulating the null model. Null matrices should be repeatable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'method' is an argument handed to functions in the 'vegan' package. Leibold
&amp; Mikkelson advocated the use of equiprobable rows and columns (provided
that rows and columns had at least one entry). This method is called 'r00'.
Methods maintaining row (site) frequencies include 'r0','r1' &amp; 'r2'. The
default method argument is 'r1', which maintains the species richness of a
site (row totals) and fills species ranges (columns) based on their marginal
probabilities. Arguably the most conservative null algorithm is the fixed
row - fixed column total null, which can be attained using many of swap
algorithms described in the vegan package (sequential methods like 'tswap',
'swap', and non-sequential 'quasiswap' and 'backtracking'). See the help
file for 'commsim' or Wright et al. 1998 for more information.
</p>
<p>If 'order' is FALSE, the interaction matrix is not ordinated, allowing the
user to order the matrix based on site characteristics or other biologically
relevant characteristics. The 'orderNulls' argument allows the user to ordinate 
the null matrices. While creating a more conservative test, this may negate
the null model implemented (fixed row and column sums will not be maintained)
</p>


<h3>Value</h3>

<p>A list of length 4, containing;
Comm &ndash; ordinated matrix used to calculate coherence, boundary
clumping &amp; turnover
</p>
<p>Coherence &ndash;output of the Coherence() function, giving information on
the number of embedded absences and the significance relative to simulated
null matrices
</p>
<p>Turnover &ndash; output of the Turnover() function, testing the number of
species replacements relative to simulated null matrices
</p>
<p>Boundary &ndash; output of the BoundaryClump() function, which calculates the
Morisita's index, assessing significance using a chi-squared test
</p>


<h3>Note</h3>

<p>This function may take awhile to finish as a result of the creation of
null matrices. If you are running multiple interaction matrices, the code
can be parallelized using the 'snow' package.
</p>


<h3>Author(s)</h3>

<p>Tad Dallas
</p>


<h3>References</h3>

<p>Dallas,T. 2014. metacom: an R package for the analysis of
metacommunity structure. Ecography. DOI:10.1111/j.1600-0587.2013.00695.x
</p>
<p>Leibold, M.A. and G.M. Mikkelson. 2002. Coherence, species turnover, and
boundary clumping: elements of meta-community structure. Oikos 97: 237 -
250.
</p>
<p>Presley, S. J., C. L. Higgins, and M. R. Willig. 2010. A comprehensive
framework for the evaluation of metacommunity structure. Oikos 119:908-917
</p>
<p>Wright, D.H., Patterson, B.D., Mikkelson, G.M., Cutler, A. &amp; Atmar, W.
(1998). A comparative analysis of nested subset patterns of species
composition. Oecologia 113, 1-20.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#define an interaction matrix
data(TestMatrices)
intmat &lt;- TestMatrices[[7]]

#determines the elements of metacommunity structure
ems.test &lt;- Metacommunity(intmat, method='r1', sims=100, scores=1)

</code></pre>

<hr>
<h2 id='NullMaker'>Null matrix creator</h2><span id='topic+NullMaker'></span>

<h3>Description</h3>

<p>Creates null matrices based on the constraints of the null model algorithm
('method'). Also allows for null matrices with a species that occurs at no
sites, or a site without any species to be removed from the suite of
simulated null matrices. This function borrows heavily from the
commsimulator() function in the 'vegan' package, but also allows for the
fixed-fixed null model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NullMaker(comm, sims = 1000, method = "r1", ordinate = FALSE,
  scores = 1, allowEmpty = FALSE, verbose = FALSE, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NullMaker_+3A_comm">comm</code></td>
<td>
<p>community data in the form of a presence absence matrix</p>
</td></tr>
<tr><td><code id="NullMaker_+3A_sims">sims</code></td>
<td>
<p>number of simulated null matrices to use in analysis</p>
</td></tr>
<tr><td><code id="NullMaker_+3A_method">method</code></td>
<td>
<p>null model randomization method. See details below.</p>
</td></tr>
<tr><td><code id="NullMaker_+3A_ordinate">ordinate</code></td>
<td>
<p>logical. Would you like to ordinate the null matrices?
Default is FALSE.</p>
</td></tr>
<tr><td><code id="NullMaker_+3A_scores">scores</code></td>
<td>
<p>Axis scores to ordinate matrix. 1: primary axis scores
(default) 2: secondary axis scores. See Details.</p>
</td></tr>
<tr><td><code id="NullMaker_+3A_allowempty">allowEmpty</code></td>
<td>
<p>logical argument indicating whether to allow null
matrices to have empty rows or columns</p>
</td></tr>
<tr><td><code id="NullMaker_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Prints a graphical progress bar that tracks the
creation of null matrices. Useful for conservative null models on large
and/or sparse data.</p>
</td></tr>
<tr><td><code id="NullMaker_+3A_seed">seed</code></td>
<td>
<p>seed for simulating the null model. Null matrices should be repeatable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'method' is the null model algorithm used to create the null matrices. The
choice of a null algorithm is nontrivial. Leibold &amp; Mikkelson advocated the
use of equiprobable rows and columns (provided that rows and columns had at
least one entry). This method is called 'r00'. Methods maintaining row
(site) frequencies include 'r0','r1' &amp; 'r2', whereas species (column)
occurrences are preserved with fixed column methods such as 'c0'. The
default method argument is 'r1', which maintains the species richness of a
site (row totals) and fills species ranges (columns) based on their marginal
probabilities. Arguably the most conservative null algorithm is the fixed
row - fixed column total null, which can be attained using many of swap
algorithms described in the vegan package (sequential methods like 'tswap',
'swap', and non-sequential 'quasiswap' and 'backtracking'). Other
randomization methods are also available. See the help file for 'commsim',
or Wright et al. 1998 for more information.
</p>


<h3>Value</h3>

<p>rmats &ndash; A list of length(sim) containing the null matrices
</p>


<h3>Author(s)</h3>

<p>Tad Dallas and John Lefcheck
</p>


<h3>References</h3>

<p>J. Oksanen, F.G. Blanchet, R. Kindt, P. Legendre, P.R. Minchin,
R.B. O'Hara, G.L. Simpson, P. Solymos, M.H.H. Stevens and H. Wagner (2012).
vegan: Community Ecology Package. R package version 2.0-4.
http://CRAN.R-project.org/package=vegan
</p>


<h3>See Also</h3>

<p>nullmodel(), permatfull(), commsim()
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#define an interaction matrix
data(TestMatrices)
intmat &lt;- TestMatrices[[7]]

#creation of the null matrices
nulls &lt;- NullMaker(intmat, sims=100, method='r1')

</code></pre>

<hr>
<h2 id='OrderMatrix'>Ordinates interaction matrix</h2><span id='topic+OrderMatrix'></span>

<h3>Description</h3>

<p>'OrderMatrix' ordinates an interaction matrix scores derived from reciprocal
averaging (Gauch et al. 1977). These scores represent a latent environmental
gradient along which species distributions are structured.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OrderMatrix(comm, scores = 1, outputScores = FALSE, binary = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OrderMatrix_+3A_comm">comm</code></td>
<td>
<p>community data in the form of a presence absence matrix</p>
</td></tr>
<tr><td><code id="OrderMatrix_+3A_scores">scores</code></td>
<td>
<p>axis scores to ordinate matrix. 1: primary axis scores
(default) 2: secondary axis scores</p>
</td></tr>
<tr><td><code id="OrderMatrix_+3A_outputscores">outputScores</code></td>
<td>
<p>logical. Default is to return the ordinated matrix. If
'outputScores' is TRUE, the function returns the site and species scores.</p>
</td></tr>
<tr><td><code id="OrderMatrix_+3A_binary">binary</code></td>
<td>
<p>logical argument indicating whether to ordinate the community
matrix based on abundance or binary (default) data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>'OrderMatrix' returns either an ordinated matrix (outputScores =
FALSE) or the site and species scores (outputScores = TRUE) obtained from
reciprocal averaging. This function is already contained within functions
calculating coherence, species turnover &amp; boundary clumping, but may be
useful for visualizations or for hypothesis testing concerning the important
variables associated with the site or species scores.
</p>


<h3>Note</h3>

<p>'OrderMatrix', like many of these functions, relies heavily on the
'vegan' package.
</p>


<h3>Author(s)</h3>

<p>Tad Dallas
</p>


<h3>References</h3>

<p>Gauch, H.G., R.H. Whittaker, and T.R. Wentworth. 1977. A
comparative study of reciprocal averaging and other ordination techniques.
Journal of Ecology 65:157-174.
</p>
<p>Leibold, M.A. and G.M. Mikkelson. 2002. Coherence, species turnover, and
boundary clumping: elements of meta-community structure. Oikos 97: 237 -
250.
</p>
<p>Oksanen,J., F.G. Blanchet, R. Kindt, P. Legendre, P.R. Minchin, R.B. O'Hara,
G.L. Simpson, P. Solymos, M.H.H. Stevens and H. Wagner (2012). vegan:
Community Ecology Package. R package version 2.0-4.
http://CRAN.R-project.org/package=vegan
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#define an interaction matrix
data(TestMatrices)
pres3c &lt;- TestMatrices[[6]]

#obtain an ordinated interaction matrix
OrderMatrix(pres3c, scores = 1, outputScores = FALSE)

#obtain site and species scores from reciprocal averaging
OrderMatrix(pres3c, scores = 1, outputScores = TRUE)


</code></pre>

<hr>
<h2 id='TestMatrices'>Test matrices used to evaluate metacommunity functions</h2><span id='topic+TestMatrices'></span>

<h3>Description</h3>

<p>A list of 7 test matrices from two of the foundational papers on the
Elements of Metacommunity Structure analysis (Leibold &amp; Mikkelson 2002 and
Presley et al. 2010)
</p>


<h3>Format</h3>

<p>A list containing interaction matrices from Leibold &amp; Mikkelson 2002
and Presley et al. 2010:
</p>
<p>1) dim=(20 x 20) Randomly generated matrix ('rbinom(400,1,0.4)')
</p>
<p>2) dim=(10 x 10) Leibold &amp; Mikkelson 2002 Figure 1b
</p>
<p>3) dim=(10 x 10) Leibold &amp; Mikkelson 2002 Figure 2a
</p>
<p>4) dim=(10 x 10) Leibold &amp; Mikkelson 2002 Figure 2b
</p>
<p>5) dim=(15 x 10) Leibold &amp; Mikkelson 2002 Figure 3c
</p>
<p>6) dim=(20 x 20) Presley et al. Figure 3c
</p>
<p>7) dim(20 x 20) Presley et al. Figure 4a</p>


<h3>Source</h3>

<p>Leibold, M. A., &amp; Mikkelson, G. M. (2002). Coherence, species
turnover, and boundary clumping: elements of metacommunity structure. Oikos,
97(2), 237-250.
</p>
<p>Presley, S. J., C. L. Higgins, and M. R. Willig. 2010. A comprehensive
framework for the evaluation of metacommunity structure. Oikos 119:908-917
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#load list containing interaction matrices
data(TestMatrices)

length(TestMatrices)
names(TestMatrices)

#image plot of interaction matrix, using the Imagine() function
test &lt;- TestMatrices[[6]]
Imagine(test, fill=FALSE, order=TRUE)


</code></pre>

<hr>
<h2 id='Turnover'>Determines species turnover</h2><span id='topic+Turnover'></span>

<h3>Description</h3>

<p>'Turnover' is a function that assesses species turnover from the range
perspective (traditional method).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Turnover(comm, method = "EMS", sims = 1000, scores = 1,
  order = TRUE, orderNulls = FALSE, allowEmpty = FALSE,
  binary = TRUE, verbose = FALSE, seed = 1, fill = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Turnover_+3A_comm">comm</code></td>
<td>
<p>community data in the form of a presence absence matrix</p>
</td></tr>
<tr><td><code id="Turnover_+3A_method">method</code></td>
<td>
<p>null model randomization method used by 'nullmaker' or 'EMS'
to use the approach outlined in Leibold and Mikkelson 2002. See details.</p>
</td></tr>
<tr><td><code id="Turnover_+3A_sims">sims</code></td>
<td>
<p>number of simulated null matrices to use in analysis</p>
</td></tr>
<tr><td><code id="Turnover_+3A_scores">scores</code></td>
<td>
<p>axis scores to ordinate matrix. 1: primary axis scores
(default) 2: secondary axis scores</p>
</td></tr>
<tr><td><code id="Turnover_+3A_order">order</code></td>
<td>
<p>logical argument indicating whether to ordinate the interaction
matrix or not. See details.</p>
</td></tr>
<tr><td><code id="Turnover_+3A_ordernulls">orderNulls</code></td>
<td>
<p>logical argument indicating whether to ordinate the null 
matrices. Default is FALSE.</p>
</td></tr>
<tr><td><code id="Turnover_+3A_allowempty">allowEmpty</code></td>
<td>
<p>logical argument indicating whether to allow null
matrices to have empty rows or columns</p>
</td></tr>
<tr><td><code id="Turnover_+3A_binary">binary</code></td>
<td>
<p>logical argument indicating whether to ordinate the community
matrix based on abundance or binary (default) data.</p>
</td></tr>
<tr><td><code id="Turnover_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Prints a graphical progress bar that tracks the
creation of null matrices. Useful for conservative null models on large
and/or sparse data.</p>
</td></tr>
<tr><td><code id="Turnover_+3A_seed">seed</code></td>
<td>
<p>seed for simulating the null model. Null matrices should be repeatable.</p>
</td></tr>
<tr><td><code id="Turnover_+3A_fill">fill</code></td>
<td>
<p>should embedded absences be filled before the statistic 
is calculated? (default is TRUE)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the 'community' perspective is desired, simply transpose the matrix
before analysis using the transpose function ('t()'), but make sure you
understand the implications of this action, as the interpretation of the
output changes dramatically.
</p>
<p>'method' is an argument handed to functions in the 'vegan' package. Leibold
&amp; Mikkelson advocated the use of equiprobable rows and columns (provided
that rows and columns had at least one entry). This method is called 'r00'.
Methods maintaining row (site) frequencies include 'r0','r1' &amp; 'r2'. The
default method argument is 'r1', which maintains the species richness of a
site (row totals) and fills species ranges (columns) based on their marginal
probabilities. Arguably the most conservative null algorithm is the fixed
row - fixed column total null, which is implemented as 'fixedfixed'. See the
help file for 'commsimulator' or Wright et al. 1998 for more information.
</p>
<p>If 'order' is FALSE, the interaction matrix is not ordinated, allowing the
user to order the matrix based on site characteristics or other biologically
relevant characteristics. The 'orderNulls' argument allows the user to ordinate 
the null matrices. While creating a more conservative test, this may negate
the null model implemented (fixed row and column sums will not be maintained)
</p>
<p>This function can either be used as a standalone, or can be used through the
'metacommunity()' function, which determines all 3 elements of metacommunity
structure (coherence, boundary clumping, &amp; turnover) (Leibold &amp; Mikkelson
2002). The turnover metric used here is equivalent to the number of checkerboard
units community with species ranges (range perspective) filled in
</p>


<h3>Value</h3>

<p>A data.frame containing the test statistic (turnover), z-value (z), 
p-value (pval), mean (simulatedMean) and variance (simulatedVariance) of 
simulations, and randomization method (method)
</p>


<h3>Author(s)</h3>

<p>Tad Dallas
</p>


<h3>References</h3>

<p>Leibold, M.A. and G.M. Mikkelson. 2002. Coherence, species
turnover, and boundary clumping: elements of meta-community structure. Oikos
97: 237 - 250.
</p>
<p>Wright, D.H., Patterson, B.D., Mikkelson, G.M., Cutler, A. &amp; Atmar, W.
(1998). A comparative analysis of nested subset patterns of species
composition. Oecologia 113, 1-20.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#define an interaction matrix
data(TestMatrices)
intmat &lt;- TestMatrices[[3]]

#determine species turnover
turnover.intmat &lt;- Turnover(intmat, method='r1', 
   sims=100, scores=1, binary=TRUE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
