<!DOCTYPE html><html><head><title>Help for package tsmp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tsmp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#analyze'><p>Runs an appropriate workflow based on the parameters passed in.</p></a></li>
<li><a href='#as.matrixprofile'><p>Convert a TSMP object into another if possible</p></a></li>
<li><a href='#av_apply'><p>Corrects the matrix profile using an annotation vector</p></a></li>
<li><a href='#av_complexity'><p>Computes the annotation vector that favors complexity</p></a></li>
<li><a href='#av_hardlimit_artifact'><p>Computes the annotation vector that suppresses hard-limited artifacts</p></a></li>
<li><a href='#av_motion_artifact'><p>Computes the annotation vector that suppresses motion artifacts</p></a></li>
<li><a href='#av_stop_word'><p>Computes the annotation vector that suppresses stop-word motifs</p></a></li>
<li><a href='#av_zerocrossing'><p>Computes the annotation vector that favors number of zero crossing</p></a></li>
<li><a href='#compute'><p>Computes the Matrix Profile or Pan-Matrix Profile</p></a></li>
<li><a href='#discords'><p>Search for Discord</p></a></li>
<li><a href='#dist_profile'><p>Calculates the distance profile using MASS algorithms</p></a></li>
<li><a href='#fast_avg_sd'><p>Fast implementation of moving average and moving standard deviation</p></a></li>
<li><a href='#fast_movavg'><p>Fast implementation of moving average</p></a></li>
<li><a href='#fast_movsd'><p>Fast implementation of moving standard deviation</p></a></li>
<li><a href='#find_chains'><p>Find Time Series Chains</p></a></li>
<li><a href='#find_discord'><p>Search for Discord</p></a></li>
<li><a href='#find_motif'><p>Search for Motifs</p></a></li>
<li><a href='#find_snippet'><p>Time Series Snippets: A New Primitive for Time Series Data Mining</p></a></li>
<li><a href='#floss'><p>Fast Low-cost Online Semantic Segmentation (FLOSS)</p></a></li>
<li><a href='#floss_cac'><p>FLOSS - Corrected Arc Counts</p></a></li>
<li><a href='#floss_extract'><p>FLOSS - Extract Segments</p></a></li>
<li><a href='#fluss'><p>Fast Low-cost Unipotent Semantic Segmentation (FLUSS)</p></a></li>
<li><a href='#fluss_cac'><p>FLUSS - Corrected Arc Counts</p></a></li>
<li><a href='#fluss_extract'><p>FLUSS - Extract Segments</p></a></li>
<li><a href='#fluss_score'><p>FLUSS - Prediction score calculation</p></a></li>
<li><a href='#get_data'><p>Get the data included in a TSMP object, if any.</p></a></li>
<li><a href='#mass'><p>Deprecated functions in package <span class="pkg">tsmp</span>.</p></a></li>
<li><a href='#mass_pre'><p>Precomputes several values used on MASS</p></a></li>
<li><a href='#mass_pre_w'><p>Precomputes several values used on MASS</p></a></li>
<li><a href='#mass_v2'><p>Calculates the distance profile using MASS_V2 algorithm</p></a></li>
<li><a href='#mass_v3'><p>Calculates the distance profile using MASS_V3 algorithm</p></a></li>
<li><a href='#mass_weighted'><p>Calculates the distance profile using MASS_WEIGHTED algorithm</p></a></li>
<li><a href='#mass-deprecated'><p>Calculates the distance profile using MASS_V2 algorithm</p></a></li>
<li><a href='#min_mp_idx'><p>Get index of the minimum value from a matrix profile and its nearest neighbor</p></a></li>
<li><a href='#motifs'><p>Search for Motifs</p></a></li>
<li><a href='#motifs_discords_small'><p>Just a synthetic dataset for testing</p></a></li>
<li><a href='#mp_fluss_data'><p>Original data used in the FLUSS paper</p></a></li>
<li><a href='#mp_gait_data'><p>Original data used in the Time Series Chain demo</p></a></li>
<li><a href='#mp_meat_data'><p>Original data used in the Salient Subsequences demo</p></a></li>
<li><a href='#mp_test_data'><p>Original data used in the STDS demo</p></a></li>
<li><a href='#mp_toy_data'><p>Original data used in the mSTAMP demo</p></a></li>
<li><a href='#mpdist'><p>MPdist - Distance between Time Series using Matrix Profile</p></a></li>
<li><a href='#mpx'><p>Fast implementation of MP and MPI for internal purposes, without FFT</p></a></li>
<li><a href='#mstomp_par'><p>Multivariate STOMP algorithm Parallel version</p></a></li>
<li><a href='#plot'><p>Plot a TSMP object</p></a></li>
<li><a href='#plot_arcs'><p>Plot arcs between indexes of a Profile Index</p></a></li>
<li><a href='#pmp'><p>Pan-Matrix Profile</p></a></li>
<li><a href='#pmp_upper_bound'><p>Pan Matrix Profile upper bound</p></a></li>
<li><a href='#read'><p>Read TSMP object from JSON file.</p></a></li>
<li><a href='#remove_class'><p>Remove a <code>TSMP</code> class from an object</p></a></li>
<li><a href='#salient_mds'><p>Convert salient sequences into MDS space</p></a></li>
<li><a href='#salient_score'><p>Computes the F-Score of salient algorithm.</p></a></li>
<li><a href='#salient_subsequences'><p>Framework for retrieve salient subsequences from a dataset</p></a></li>
<li><a href='#scrimp'><p>Anytime univariate SCRIMP++ algorithm</p></a></li>
<li><a href='#sdts_predict'><p>Framework for Scalable Dictionary learning for Time Series (SDTS) prediction function</p></a></li>
<li><a href='#sdts_score'><p>Computes the F-Score of a SDTS prediction</p></a></li>
<li><a href='#sdts_train'><p>Framework for Scalable Dictionary learning for Time Series (SDTS) training function</p></a></li>
<li><a href='#set_data'><p>Set/changes the data included in TSMP object.</p></a></li>
<li><a href='#simple_fast'><p>Compute the join similarity for Sound data</p></a></li>
<li><a href='#stamp_par'><p>Anytime univariate STAMP algorithm Parallel version</p></a></li>
<li><a href='#stomp_par'><p>Univariate STOMP algorithm</p></a></li>
<li><a href='#stompi_update'><p>Real-time STOMP algorithm</p></a></li>
<li><a href='#tsmp'><p>Computes the Matrix Profile and Profile Index</p></a></li>
<li><a href='#valmod'><p>Variable Length Motif Discovery</p></a></li>
<li><a href='#visualize'><p>Plots an object generated from one of the algorithms. In some cases multiple plots will be generated</p></a></li>
<li><a href='#write'><p>Write a TSMP object to JSON file.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Time Series with Matrix Profile</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.15</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Francisco Bischoff &lt;fbischoff@med.up.pt&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolkit implementing the Matrix Profile concept
    that was created by CS-UCR
    <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.apache.org/licenses/LICENSE-2.0">Apache License (&ge; 2.0)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/matrix-profile-foundation/tsmp">https://github.com/matrix-profile-foundation/tsmp</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/matrix-profile-foundation/tsmp/issues">https://github.com/matrix-profile-foundation/tsmp/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>audio, checkmate, doSNOW, foreach, magrittr, parallel,
progress, Rcpp, RcppParallel (&ge; 5.0.0), RJSONIO</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, gdtools, knitr, rmarkdown, raster, spelling, testthat
(&ge; 2.1.0), vdiffr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp (&ge; 1.0.3), RcppParallel (&ge; 5.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-18 16:31:18 UTC; franz</td>
</tr>
<tr>
<td>Author:</td>
<td>Francisco Bischoff
    <a href="https://orcid.org/0000-0002-5301-8672"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Michael Yeh <a href="https://orcid.org/0000-0002-9807-2963"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [res,
    ccp, ctb],
  Diego Silva <a href="https://orcid.org/0000-0002-5184-9413"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [res,
    ccp, ctb],
  Yan Zhu <a href="https://orcid.org/0000-0002-5952-2108"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [res,
    ccp, ctb],
  Hoang Dau <a href="https://orcid.org/0000-0003-2439-5185"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [res,
    ccp, ctb],
  Michele Linardi <a href="https://orcid.org/0000-0002-3249-2068"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [res, ccp, ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-20 22:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span><span id='topic++25T+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>
<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%T&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs

lhs %T&gt;% rhs
</code></pre>

<hr>
<h2 id='analyze'>Runs an appropriate workflow based on the parameters passed in.</h2><span id='topic+analyze'></span>

<h3>Description</h3>

<p>The goal of this function is to compute all fundamental algorithms on the provided
time series data. See details for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze(
  ts,
  windows = NULL,
  query = NULL,
  sample_pct = 1,
  threshold = 0.98,
  n_jobs = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_+3A_ts">ts</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code>. The time series to analyze.</p>
</td></tr>
<tr><td><code id="analyze_+3A_windows">windows</code></td>
<td>
<p>an <code>int</code> or a <code>vector</code>. The window(s) to compute the Matrix Profile. Note that it may be an <code>int</code>
for a single matrix profile computation or a <code>vector</code> of <code>int</code> for computing the Pan-Matrix Profile.</p>
</td></tr>
<tr><td><code id="analyze_+3A_query">query</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code>. Optional The query to analyze. Note that when computing the Pan-Matrix Profile
the query is ignored!</p>
</td></tr>
<tr><td><code id="analyze_+3A_sample_pct">sample_pct</code></td>
<td>
<p>a <code>numeric</code>. A number between 0 and 1 representing how many samples to compute for
the Matrix Profile or Pan-Matrix Profile. When it is 1, the exact algorithm is used. (default is <code>1.0</code>).</p>
</td></tr>
<tr><td><code id="analyze_+3A_threshold">threshold</code></td>
<td>
<p>a <code>numeric</code>. Correlation threshold. See details.  (Default is <code>0.98</code>).</p>
</td></tr>
<tr><td><code id="analyze_+3A_n_jobs">n_jobs</code></td>
<td>
<p>an <code>int</code>. The number of cpu cores to use when computing the MatrixProfile. (default is <code>1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For now the following is computed:
</p>

<ol>
<li><p> Matrix Profile - exact or approximate based on <code>sample_pct</code> given that a single <code>windows</code> is provided. By default
is the exact algorithm;
</p>
</li>
<li><p> Top 3 Motifs;
</p>
</li>
<li><p> Top 3 Discords;
</p>
</li>
<li><p> Plot Matrix Profile, Motifs and Discords.
</p>
</li></ol>

<p>When <code>windows</code> is not provided or more than a single window is provided,
the Pan-Matrix Profile is computed:
</p>

<ol>
<li><p> Compute the upper bound when a <code>threshold</code> is provided (it is, by default);
</p>
</li>
<li><p> Compute Pan-Matrix Profile for all <code>windows</code> provided, below the upper bound, or a default range when no <code>windows</code>
is provided;
</p>
</li>
<li><p> Top Motifs;
</p>
</li>
<li><p> Top Discords;
</p>
</li>
<li><p> Plot Pan-Matrix Profile, motifs and discords.
</p>
</li></ol>



<h3>Value</h3>

<p>The appropriate Matrix Profile or Pan-Matrix Profile profile object and also plots the graphics.
</p>


<h3>References</h3>

<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other Main API: 
<code><a href="#topic+compute">compute</a>()</code>,
<code><a href="#topic+discords">discords</a>()</code>,
<code><a href="#topic+motifs">motifs</a>()</code>,
<code><a href="#topic+visualize">visualize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Matrix Profile
result &lt;- analyze(mp_toy_data$data[, 1], 80)

# Pan Matrix Profile
result &lt;- analyze(mp_toy_data$data[, 1])

</code></pre>

<hr>
<h2 id='as.matrixprofile'>Convert a TSMP object into another if possible</h2><span id='topic+as.matrixprofile'></span><span id='topic+as.multimatrixprofile'></span><span id='topic+as.pmp'></span><span id='topic+as.valmod'></span><span id='topic+as.fluss'></span><span id='topic+as.chain'></span><span id='topic+as.discord'></span><span id='topic+as.motif'></span><span id='topic+as.multimotif'></span><span id='topic+as.arccount'></span><span id='topic+as.salient'></span>

<h3>Description</h3>

<p>The base Classes are <code>MatrixProfile</code> and <code>MultiMatrixProfile</code>, but as other functions are used,
classes are pushed behind, since the last output normally is the most significant. If you want,
for example, to plot the Matrix Profile from a <code>Fluss</code> object, you may use <code>as.matrixprofile()</code>
to cast it back.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.matrixprofile(.mp)

as.multimatrixprofile(.mp)

as.pmp(.mp)

as.valmod(.mp)

as.fluss(.mp)

as.chain(.mp)

as.discord(.mp)

as.motif(.mp)

as.multimotif(.mp)

as.arccount(.mp)

as.salient(.mp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrixprofile_+3A_.mp">.mp</code></td>
<td>
<p>a TSMP object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the object with the new class, if possible.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>as.matrixprofile()</code>: Cast an object changed by another function back to <code>MatrixProfile</code>.
</p>
</li>
<li> <p><code>as.multimatrixprofile()</code>: Cast an object changed by another function back to <code>MultiMatrixProfile</code>.
</p>
</li>
<li> <p><code>as.pmp()</code>: Cast an object changed by another function back to <code>PMP</code>.
</p>
</li>
<li> <p><code>as.valmod()</code>: Cast an object changed by another function back to <code>MultiMatrixProfile</code>.
</p>
</li>
<li> <p><code>as.fluss()</code>: Cast an object changed by another function back to <code>Fluss</code>.
</p>
</li>
<li> <p><code>as.chain()</code>: Cast an object changed by another function back to <code>Chain</code>.
</p>
</li>
<li> <p><code>as.discord()</code>: Cast an object changed by another function back to <code>Discord</code>.
</p>
</li>
<li> <p><code>as.motif()</code>: Cast an object changed by another function back to <code>Motif</code>.
</p>
</li>
<li> <p><code>as.multimotif()</code>: Cast an object changed by another function back to <code>MultiMotif</code>.
</p>
</li>
<li> <p><code>as.arccount()</code>: Cast an object changed by another function back to <code>ArcCount</code>.
</p>
</li>
<li> <p><code>as.salient()</code>: Cast an object changed by another function back to <code>Salient</code>.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>
w &lt;- 50
data &lt;- mp_gait_data
mp &lt;- tsmp(data, window_size = w, exclusion_zone = 1 / 4, verbose = 0)
mp &lt;- find_motif(mp)
class(mp) # first class will be "Motif"

plot(mp) # plots a motif plot

plot(as.matrixprofile(mp)) # plots a matrix profile plot
</code></pre>

<hr>
<h2 id='av_apply'>Corrects the matrix profile using an annotation vector</h2><span id='topic+av_apply'></span>

<h3>Description</h3>

<p>This function overwrites the current Matrix Profile using the Annotation Vector. Use with caution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>av_apply(.mp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="av_apply_+3A_.mp">.mp</code></td>
<td>
<p>A Matrix Profile with an Annotation Vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input <code>.mp</code> object corrected by the embedded annotation vector.
</p>


<h3>References</h3>


<ul>
<li><p> Dau HA, Keogh E. Matrix Profile V: A Generic Technique to Incorporate Domain
Knowledge into Motif Discovery. In: Proceedings of the 23rd ACM SIGKDD International Conference
on Knowledge Discovery and Data Mining - KDD '17. New York, New York, USA: ACM Press; 2017. p.
125-34.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Annotation vectors: 
<code><a href="#topic+av_complexity">av_complexity</a>()</code>,
<code><a href="#topic+av_hardlimit_artifact">av_hardlimit_artifact</a>()</code>,
<code><a href="#topic+av_motion_artifact">av_motion_artifact</a>()</code>,
<code><a href="#topic+av_stop_word">av_stop_word</a>()</code>,
<code><a href="#topic+av_zerocrossing">av_zerocrossing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mp_test_data$train$data[1:1000]
w &lt;- 50
mp &lt;- tsmp(data, window_size = w, verbose = 0)
mp &lt;- av_complexity(mp)
av &lt;- av_apply(mp)
</code></pre>

<hr>
<h2 id='av_complexity'>Computes the annotation vector that favors complexity</h2><span id='topic+av_complexity'></span>

<h3>Description</h3>

<p>Computes the annotation vector that favors complexity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>av_complexity(.mp, data, dilution_factor = 0, apply = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="av_complexity_+3A_.mp">.mp</code></td>
<td>
<p>a Matrix Profile object.</p>
</td></tr>
<tr><td><code id="av_complexity_+3A_data">data</code></td>
<td>
<p>a <code>vector</code> or a column <code>matrix</code> of <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="av_complexity_+3A_dilution_factor">dilution_factor</code></td>
<td>
<p>a <code>numeric</code>. (Default is <code>0</code>). Larger numbers means more dilution.</p>
</td></tr>
<tr><td><code id="av_complexity_+3A_apply">apply</code></td>
<td>
<p>logical. (Default is <code>FALSE</code>). Applies the Annotation Vector over the Matrix Profile.
Use with caution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input <code>.mp</code> object with an embedded annotation vector.
</p>


<h3>References</h3>


<ul>
<li><p> Dau HA, Keogh E. Matrix Profile V: A Generic Technique to Incorporate Domain
Knowledge into Motif Discovery. In: Proceedings of the 23rd ACM SIGKDD International Conference
on Knowledge Discovery and Data Mining - KDD '17. New York, New York, USA: ACM Press; 2017. p.
125-34.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Annotation vectors: 
<code><a href="#topic+av_apply">av_apply</a>()</code>,
<code><a href="#topic+av_hardlimit_artifact">av_hardlimit_artifact</a>()</code>,
<code><a href="#topic+av_motion_artifact">av_motion_artifact</a>()</code>,
<code><a href="#topic+av_stop_word">av_stop_word</a>()</code>,
<code><a href="#topic+av_zerocrossing">av_zerocrossing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mp_test_data$train$data[1:1000]
w &lt;- 50
mp &lt;- tsmp(data, window_size = w, verbose = 0)
av &lt;- av_complexity(mp, apply = TRUE)
</code></pre>

<hr>
<h2 id='av_hardlimit_artifact'>Computes the annotation vector that suppresses hard-limited artifacts</h2><span id='topic+av_hardlimit_artifact'></span>

<h3>Description</h3>

<p>Computes the annotation vector that suppresses hard-limited artifacts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>av_hardlimit_artifact(.mp, data, apply = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="av_hardlimit_artifact_+3A_.mp">.mp</code></td>
<td>
<p>a Matrix Profile object.</p>
</td></tr>
<tr><td><code id="av_hardlimit_artifact_+3A_data">data</code></td>
<td>
<p>a <code>vector</code> or a column <code>matrix</code> of <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="av_hardlimit_artifact_+3A_apply">apply</code></td>
<td>
<p>logical. (Default is <code>FALSE</code>). Applies the Annotation Vector over the Matrix Profile.
Use with caution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input <code>.mp</code> object with an embedded annotation vector.
</p>


<h3>References</h3>


<ul>
<li><p> Dau HA, Keogh E. Matrix Profile V: A Generic Technique to Incorporate Domain
Knowledge into Motif Discovery. In: Proceedings of the 23rd ACM SIGKDD International Conference
on Knowledge Discovery and Data Mining - KDD '17. New York, New York, USA: ACM Press; 2017. p.
125-34.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Annotation vectors: 
<code><a href="#topic+av_apply">av_apply</a>()</code>,
<code><a href="#topic+av_complexity">av_complexity</a>()</code>,
<code><a href="#topic+av_motion_artifact">av_motion_artifact</a>()</code>,
<code><a href="#topic+av_stop_word">av_stop_word</a>()</code>,
<code><a href="#topic+av_zerocrossing">av_zerocrossing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mp_test_data$train$data[1:1000]
w &lt;- 50
mp &lt;- tsmp(data, window_size = w, verbose = 0)
av &lt;- av_hardlimit_artifact(mp, apply = TRUE)
</code></pre>

<hr>
<h2 id='av_motion_artifact'>Computes the annotation vector that suppresses motion artifacts</h2><span id='topic+av_motion_artifact'></span>

<h3>Description</h3>

<p>Computes the annotation vector that suppresses motion artifacts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>av_motion_artifact(.mp, data, apply = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="av_motion_artifact_+3A_.mp">.mp</code></td>
<td>
<p>a Matrix Profile object.</p>
</td></tr>
<tr><td><code id="av_motion_artifact_+3A_data">data</code></td>
<td>
<p>a <code>vector</code> or a column <code>matrix</code> of <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="av_motion_artifact_+3A_apply">apply</code></td>
<td>
<p>logical. (Default is <code>FALSE</code>). Applies the Annotation Vector over the Matrix Profile.
Use with caution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input <code>.mp</code> object with an embedded annotation vector.
</p>


<h3>References</h3>


<ul>
<li><p> Dau HA, Keogh E. Matrix Profile V: A Generic Technique to Incorporate Domain
Knowledge into Motif Discovery. In: Proceedings of the 23rd ACM SIGKDD International Conference
on Knowledge Discovery and Data Mining - KDD '17. New York, New York, USA: ACM Press; 2017. p.
125-34.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Annotation vectors: 
<code><a href="#topic+av_apply">av_apply</a>()</code>,
<code><a href="#topic+av_complexity">av_complexity</a>()</code>,
<code><a href="#topic+av_hardlimit_artifact">av_hardlimit_artifact</a>()</code>,
<code><a href="#topic+av_stop_word">av_stop_word</a>()</code>,
<code><a href="#topic+av_zerocrossing">av_zerocrossing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mp_test_data$train$data[1:1000]
w &lt;- 50
mp &lt;- tsmp(data, window_size = w, verbose = 0)
av &lt;- av_motion_artifact(mp, apply = TRUE)
</code></pre>

<hr>
<h2 id='av_stop_word'>Computes the annotation vector that suppresses stop-word motifs</h2><span id='topic+av_stop_word'></span>

<h3>Description</h3>

<p>Computes the annotation vector that suppresses stop-word motifs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>av_stop_word(
  .mp,
  data,
  stop_word_loc,
  exclusion_zone = NULL,
  threshold = 0.1,
  apply = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="av_stop_word_+3A_.mp">.mp</code></td>
<td>
<p>a Matrix Profile object.</p>
</td></tr>
<tr><td><code id="av_stop_word_+3A_data">data</code></td>
<td>
<p>a <code>vector</code> or a column <code>matrix</code> of <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="av_stop_word_+3A_stop_word_loc">stop_word_loc</code></td>
<td>
<p>an <code>int</code>. The index of stop word location.</p>
</td></tr>
<tr><td><code id="av_stop_word_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>a <code>numeric</code>. Size of the exclusion zone, based on window_size (default is
<code>NULL</code>). See details.</p>
</td></tr>
<tr><td><code id="av_stop_word_+3A_threshold">threshold</code></td>
<td>
<p>a <code>numeric</code>. (default is <code>0.1</code>).</p>
</td></tr>
<tr><td><code id="av_stop_word_+3A_apply">apply</code></td>
<td>
<p>logical. (Default is <code>FALSE</code>). Applies the Annotation Vector over the Matrix Profile.
Use with caution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is intended to be generic. However, its parameters (<code>stop_word_loc</code>,
<code>exclusion_zone</code> and <code>threshold</code>) are highly dataset dependent.
</p>


<h3>Value</h3>

<p>Returns the input <code>.mp</code> object with an embedded annotation vector.
</p>


<h3>References</h3>


<ul>
<li><p> Dau HA, Keogh E. Matrix Profile V: A Generic Technique to Incorporate Domain
Knowledge into Motif Discovery. In: Proceedings of the 23rd ACM SIGKDD International Conference
on Knowledge Discovery and Data Mining - KDD '17. New York, New York, USA: ACM Press; 2017. p.
125-34.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Annotation vectors: 
<code><a href="#topic+av_apply">av_apply</a>()</code>,
<code><a href="#topic+av_complexity">av_complexity</a>()</code>,
<code><a href="#topic+av_hardlimit_artifact">av_hardlimit_artifact</a>()</code>,
<code><a href="#topic+av_motion_artifact">av_motion_artifact</a>()</code>,
<code><a href="#topic+av_zerocrossing">av_zerocrossing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mp_test_data$train$data[1:1000]
w &lt;- 50
mp &lt;- tsmp(data, window_size = w, verbose = 0)
av &lt;- av_stop_word(mp, stop_word_loc = 150, apply = TRUE)
</code></pre>

<hr>
<h2 id='av_zerocrossing'>Computes the annotation vector that favors number of zero crossing</h2><span id='topic+av_zerocrossing'></span>

<h3>Description</h3>

<p>Computes the annotation vector that favors number of zero crossing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>av_zerocrossing(.mp, data, apply = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="av_zerocrossing_+3A_.mp">.mp</code></td>
<td>
<p>a Matrix Profile object.</p>
</td></tr>
<tr><td><code id="av_zerocrossing_+3A_data">data</code></td>
<td>
<p>a <code>vector</code> or a column <code>matrix</code> of <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="av_zerocrossing_+3A_apply">apply</code></td>
<td>
<p>logical. (Default is <code>FALSE</code>). Applies the Annotation Vector over the Matrix Profile.
Use with caution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input <code>.mp</code> object with an embedded annotation vector.
</p>


<h3>References</h3>


<ul>
<li><p> Dau HA, Keogh E. Matrix Profile V: A Generic Technique to Incorporate Domain
Knowledge into Motif Discovery. In: Proceedings of the 23rd ACM SIGKDD International Conference
on Knowledge Discovery and Data Mining - KDD '17. New York, New York, USA: ACM Press; 2017. p.
125-34.
</p>
</li></ul>



<h3>See Also</h3>

<p>Other Annotation vectors: 
<code><a href="#topic+av_apply">av_apply</a>()</code>,
<code><a href="#topic+av_complexity">av_complexity</a>()</code>,
<code><a href="#topic+av_hardlimit_artifact">av_hardlimit_artifact</a>()</code>,
<code><a href="#topic+av_motion_artifact">av_motion_artifact</a>()</code>,
<code><a href="#topic+av_stop_word">av_stop_word</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mp_test_data$train$data[1:1000]
w &lt;- 50
mp &lt;- tsmp(data, window_size = w, verbose = 0)
av &lt;- av_zerocrossing(mp, apply = TRUE)
</code></pre>

<hr>
<h2 id='compute'>Computes the Matrix Profile or Pan-Matrix Profile</h2><span id='topic+compute'></span>

<h3>Description</h3>

<p>Main API Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compute(
  ts,
  windows = NULL,
  query = NULL,
  sample_pct = 1,
  threshold = 0.98,
  n_jobs = 1L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compute_+3A_ts">ts</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code>. The time series to analyze.</p>
</td></tr>
<tr><td><code id="compute_+3A_windows">windows</code></td>
<td>
<p>an <code>int</code> or a <code>vector</code>. The window(s) to compute the Matrix Profile. Note that it may be an <code>int</code>
for a single matrix profile computation or a <code>vector</code> of <code>int</code> for computing the Pan-Matrix Profile.</p>
</td></tr>
<tr><td><code id="compute_+3A_query">query</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code>. Optional The query to analyze. Note that when computing the Pan-Matrix Profile
the query is ignored!</p>
</td></tr>
<tr><td><code id="compute_+3A_sample_pct">sample_pct</code></td>
<td>
<p>a <code>numeric</code>. A number between 0 and 1 representing how many samples to compute for
the Matrix Profile or Pan-Matrix Profile. When it is 1, the exact algorithm is used. (default is <code>1.0</code>).</p>
</td></tr>
<tr><td><code id="compute_+3A_threshold">threshold</code></td>
<td>
<p>a <code>numeric</code>. Correlation threshold. See details.  (Default is <code>0.98</code>).</p>
</td></tr>
<tr><td><code id="compute_+3A_n_jobs">n_jobs</code></td>
<td>
<p>an <code>int</code>. The number of cpu cores to use when computing the MatrixProfile. (default is <code>1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the exact or approximate Matrix Profile based on the sample percent
specified. Currently, MPX and SCRIMP++ are used for the exact and
approximate algorithms respectively. See details for more information about the arguments
combinations.
</p>
<p>When a single <code>windows</code> is given, the Matrix Profile is computed. If a <code>query</code> is provided, AB join is computed.
Otherwise the self-join is computed.
When multiple <code>windows</code> or none are given, the Pan-Matrix Profile is computed. If a <code>threshold</code> is set (it is,
by default), the upper bound will be computed and the given <code>windows</code> or a default range (when no <code>windows</code>), below
the upper bound will be computed.
</p>


<h3>Value</h3>

<p>The profile computed.
</p>


<h3>References</h3>

<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other Main API: 
<code><a href="#topic+analyze">analyze</a>()</code>,
<code><a href="#topic+discords">discords</a>()</code>,
<code><a href="#topic+motifs">motifs</a>()</code>,
<code><a href="#topic+visualize">visualize</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Matrix Profile
result &lt;- compute(mp_toy_data$data[, 1], 80)

# Pan-Matrix Profile
result &lt;- compute(mp_toy_data$data[, 1])

</code></pre>

<hr>
<h2 id='discords'>Search for Discord</h2><span id='topic+discords'></span>

<h3>Description</h3>

<p>Search for Discord
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discords(
  profile,
  exclusion_zone = profile$ez,
  k = 3L,
  neighbor_count = 10L,
  radius = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discords_+3A_profile">profile</code></td>
<td>
<p>a <code>MatrixProfile</code> or <code>PMP</code> object.</p>
</td></tr>
<tr><td><code id="discords_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>an <code>int</code>. Number of values to exclude on both sides of the motif to avoid trivial matches.
Defaults to the exclusion zone used to compute the (Pan-)Matrix Profile which is found in the profile data structure.</p>
</td></tr>
<tr><td><code id="discords_+3A_k">k</code></td>
<td>
<p>an <code>int</code>. Number of discords to find. (Default is <code>3</code>).</p>
</td></tr>
<tr><td><code id="discords_+3A_neighbor_count">neighbor_count</code></td>
<td>
<p>an <code>int</code>. Number of neighbors to find. (Default is <code>3</code>).</p>
</td></tr>
<tr><td><code id="discords_+3A_radius">radius</code></td>
<td>
<p>an <code>int</code>. Set a threshold to exclude matching neighbors with distance &gt; current
discord distance * <code>radius</code>. (Default is <code>3</code>).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other Main API: 
<code><a href="#topic+analyze">analyze</a>()</code>,
<code><a href="#topic+compute">compute</a>()</code>,
<code><a href="#topic+motifs">motifs</a>()</code>,
<code><a href="#topic+visualize">visualize</a>()</code>
</p>

<hr>
<h2 id='dist_profile'>Calculates the distance profile using MASS algorithms</h2><span id='topic+dist_profile'></span>

<h3>Description</h3>

<p>Mueen's Algorithm for Similarity Search is The Fastest Similarity Search Algorithm for Time
Series Subsequences under Euclidean Distance and Correlation Coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_profile(
  data,
  query,
  ...,
  window_size = NULL,
  method = "v3",
  index = 1,
  k = NULL,
  weight = NULL,
  paa = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_profile_+3A_data">data</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code>.</p>
</td></tr>
<tr><td><code id="dist_profile_+3A_query">query</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code>. See details.</p>
</td></tr>
<tr><td><code id="dist_profile_+3A_...">...</code></td>
<td>
<p>Precomputed values from the first iteration. If not supplied, these values will be computed.</p>
</td></tr>
<tr><td><code id="dist_profile_+3A_window_size">window_size</code></td>
<td>
<p>an <code>int</code> or <code>NULL</code>. Sliding window size. See details.</p>
</td></tr>
<tr><td><code id="dist_profile_+3A_method">method</code></td>
<td>
<p>method that will be used to calculate the distance profile. See details.</p>
</td></tr>
<tr><td><code id="dist_profile_+3A_index">index</code></td>
<td>
<p>an <code>int</code>. Index of query window. See details.</p>
</td></tr>
<tr><td><code id="dist_profile_+3A_k">k</code></td>
<td>
<p>an <code>int</code> or <code>NULL</code>. Default is <code>NULL</code>. Defines the size of batch for MASS V3. Prefer to
use a power of 2. If <code>NULL</code>, it will be set automatically.</p>
</td></tr>
<tr><td><code id="dist_profile_+3A_weight">weight</code></td>
<td>
<p>a <code>vector</code> of <code>numeric</code> or <code>NULL</code> with the same length of the <code>window_size</code>. This is
a MASS extension to weight the query.</p>
</td></tr>
<tr><td><code id="dist_profile_+3A_paa">paa</code></td>
<td>
<p>a <code>numeric</code>. Default is <code>1</code>. Factor of PAA reduction (2 == half of size). This is a
MASS extension.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has several ways to work:
</p>
<p>Case 1: You have a small sized query and the data. In this case you only have to provide the first two
parameters <code>data</code> and <code>query</code>. Internally the <code>window_size</code> will be get from the query length.
</p>
<p>Case 2: You have one or two data vectors and want to compute the join or self-similarity. In this case
you need to use the recursive solution. The parameters are <code>data</code>, <code>query</code>, <code>window_size</code> and <code>index</code>.
The first iteration don't need the <code>index</code> unless you are starting somewhere else. The <code>query</code> will be
the source of a <code>query_window</code>, starting on <code>index</code>, with length of <code>window_size</code>.
</p>
<p>The <code>method</code> defines which MASS will be used. Current supported values are: <code>v2</code>, <code>v3</code>, <code>weighted</code>.
</p>


<h3>Value</h3>

<p>Returns the <code>distance_profile</code> for the given query and the <code>last_product</code> for STOMP
algorithm and the parameters for recursive call. See details.
</p>


<h3>References</h3>


<ul>
<li><p> Abdullah Mueen, Yan Zhu, Michael Yeh, Kaveh Kamgar, Krishnamurthy Viswanathan,
Chetan Kumar Gupta and Eamonn Keogh (2015), The Fastest Similarity Search Algorithm for Time
Series Subsequences under Euclidean Distance
</p>
</li></ul>

<p>Website: <a href="https://www.cs.unm.edu/~mueen/FastestSimilaritySearch.html">https://www.cs.unm.edu/~mueen/FastestSimilaritySearch.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
w &lt;- mp_toy_data$sub_len
ref_data &lt;- mp_toy_data$data[, 1]
# minimum example, data and query
nn &lt;- dist_profile(ref_data, ref_data[1:w])
distance_profile &lt;- sqrt(nn$distance_profile)

# data and indexed query
nn &lt;- dist_profile(ref_data, ref_data, window_size = w, index = 10)
distance_profile &lt;- sqrt(nn$distance_profile)

# recursive
nn &lt;- NULL

for (i in seq_len(10)) {
  nn &lt;- dist_profile(ref_data, ref_data, nn, window_size = w, index = i)
}

# weighted
weight &lt;- c(rep(1, w / 3), rep(0.5, w / 3), rep(0.8, w / 3)) # just an example

nn &lt;- dist_profile(ref_data, ref_data,
  window_size = w, index = 1, method = "weighted",
  weight = weight
)
distance_profile &lt;- sqrt(nn$distance_profile)
</code></pre>

<hr>
<h2 id='fast_avg_sd'>Fast implementation of moving average and moving standard deviation</h2><span id='topic+fast_avg_sd'></span>

<h3>Description</h3>

<p>This function does not handle NA values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_avg_sd(data, window_size, rcpp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_avg_sd_+3A_data">data</code></td>
<td>
<p>a <code>vector</code> or a column <code>matrix</code> of <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="fast_avg_sd_+3A_window_size">window_size</code></td>
<td>
<p>moving sd window size</p>
</td></tr>
<tr><td><code id="fast_avg_sd_+3A_rcpp">rcpp</code></td>
<td>
<p>a <code>logical</code>. Uses rcpp implementation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>list</code> with <code>avg</code> and <code>sd</code> <code>vector</code>s
</p>

<hr>
<h2 id='fast_movavg'>Fast implementation of moving average</h2><span id='topic+fast_movavg'></span>

<h3>Description</h3>

<p>This function does not handle NA values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_movavg(data, window_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_movavg_+3A_data">data</code></td>
<td>
<p>a <code>vector</code> or a column <code>matrix</code> of <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="fast_movavg_+3A_window_size">window_size</code></td>
<td>
<p>moving sd window size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>vector</code> with the moving average
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_avg &lt;- fast_movavg(mp_toy_data$data[, 1], mp_toy_data$sub_len)
</code></pre>

<hr>
<h2 id='fast_movsd'>Fast implementation of moving standard deviation</h2><span id='topic+fast_movsd'></span>

<h3>Description</h3>

<p>This function does not handle NA values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fast_movsd(data, window_size, rcpp = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fast_movsd_+3A_data">data</code></td>
<td>
<p>a <code>vector</code> or a column <code>matrix</code> of <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="fast_movsd_+3A_window_size">window_size</code></td>
<td>
<p>moving sd window size</p>
</td></tr>
<tr><td><code id="fast_movsd_+3A_rcpp">rcpp</code></td>
<td>
<p>a <code>logical</code>. Uses rcpp implementation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>vector</code> with the moving standard deviation
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_sd &lt;- fast_movsd(mp_toy_data$data[, 1], mp_toy_data$sub_len)
</code></pre>

<hr>
<h2 id='find_chains'>Find Time Series Chains</h2><span id='topic+find_chains'></span>

<h3>Description</h3>

<p>Time Series Chains is a new primitive for time series data mining.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_chains(.mp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_chains_+3A_.mp">.mp</code></td>
<td>
<p>a <code>MatrixProfile</code> object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input <code>.mp</code> object with a new name <code>chain</code>. It contains: <code>chains</code>, a <code>list</code>
of chains found with more than 2 patterns and <code>best</code> with the best one.
</p>


<h3>References</h3>


<ul>
<li><p> Zhu Y, Imamura M, Nikovski D, Keogh E. Matrix Profile VII: Time Series Chains: A
New Primitive for Time Series Data Mining. Knowl Inf Syst. 2018 Jun 2;1-27.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/site/timeserieschain/">https://sites.google.com/site/timeserieschain/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- 50
data &lt;- mp_gait_data
mp &lt;- tsmp(data, window_size = w, exclusion_zone = 1 / 4, verbose = 0)
mp &lt;- find_chains(mp)
</code></pre>

<hr>
<h2 id='find_discord'>Search for Discord</h2><span id='topic+find_discord'></span><span id='topic+find_discord.MatrixProfile'></span><span id='topic+find_discord.PMP'></span>

<h3>Description</h3>

<p>Search for Discord
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_discord(.mp, ...)

## S3 method for class 'MatrixProfile'
find_discord(
  .mp,
  data,
  n_discords = 1,
  n_neighbors = 3,
  radius = 3,
  exclusion_zone = NULL,
  ...
)

## S3 method for class 'PMP'
find_discord(
  .mp,
  data,
  n_discords = 1,
  n_neighbors = 3,
  radius = 3,
  exclusion_zone = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_discord_+3A_.mp">.mp</code></td>
<td>
<p>a <code>MatrixProfile</code> object.</p>
</td></tr>
<tr><td><code id="find_discord_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to class specific function.</p>
</td></tr>
<tr><td><code id="find_discord_+3A_data">data</code></td>
<td>
<p>the data used to build the Matrix Profile, if not embedded.</p>
</td></tr>
<tr><td><code id="find_discord_+3A_n_discords">n_discords</code></td>
<td>
<p>an <code>int</code>. Number of discords to find. (Default is <code>1</code>).</p>
</td></tr>
<tr><td><code id="find_discord_+3A_n_neighbors">n_neighbors</code></td>
<td>
<p>an <code>int</code>. Number of neighbors to find. (Default is <code>3</code>).</p>
</td></tr>
<tr><td><code id="find_discord_+3A_radius">radius</code></td>
<td>
<p>an <code>int</code>. Set a threshold to exclude matching neighbors with distance &gt; current
discord distance * <code>radius</code>. (Default is <code>3</code>).</p>
</td></tr>
<tr><td><code id="find_discord_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>if a <code>number</code> will be used instead of embedded value. (Default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For class <code>MatrixProfile</code>, returns the input <code>.mp</code> object with a new name <code>discord</code>. It contains: <code>discord_idx</code>, a <code>vector</code>
of discords found
</p>
<p>For class <code>PMP</code>, returns the input <code>.mp</code> object with a new name <code>discord</code>. It contains: <code>discord_idx</code>, a <code>vector</code>
of discords found
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Single dimension data
w &lt;- 50
data &lt;- mp_gait_data
mp &lt;- tsmp(data, window_size = w, exclusion_zone = 1 / 4, verbose = 0)
mp &lt;- find_discord(mp)
pan &lt;- tsmp(mp_gait_data, window_size = 20:30, mode = "pmp")
mp &lt;- find_discord(pan)
</code></pre>

<hr>
<h2 id='find_motif'>Search for Motifs</h2><span id='topic+find_motif'></span><span id='topic+find_motif.MatrixProfile'></span><span id='topic+find_motif.MultiMatrixProfile'></span><span id='topic+find_motif.PMP'></span>

<h3>Description</h3>

<p>Search for Motifs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_motif(.mp, ...)

## S3 method for class 'MatrixProfile'
find_motif(
  .mp,
  data,
  n_motifs = 3,
  n_neighbors = 10,
  radius = 3,
  exclusion_zone = NULL,
  ...
)

## S3 method for class 'MultiMatrixProfile'
find_motif(
  .mp,
  data,
  n_motifs = 3,
  mode = c("guided", "unconstrained"),
  n_bit = 4,
  exclusion_zone = NULL,
  n_dim = NULL,
  ...
)

## S3 method for class 'PMP'
find_motif(
  .mp,
  data,
  n_motifs = 3,
  n_neighbors = 10,
  radius = 3,
  exclusion_zone = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_motif_+3A_.mp">.mp</code></td>
<td>
<p>a <code>MatrixProfile</code> or <code>MultiMatrixProfile</code> object.</p>
</td></tr>
<tr><td><code id="find_motif_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to class specific function.</p>
</td></tr>
<tr><td><code id="find_motif_+3A_data">data</code></td>
<td>
<p>the data used to build the Matrix Profile, if not embedded.</p>
</td></tr>
<tr><td><code id="find_motif_+3A_n_motifs">n_motifs</code></td>
<td>
<p>an <code>int</code>. Number of motifs to find. (Default is <code>3</code>).</p>
</td></tr>
<tr><td><code id="find_motif_+3A_n_neighbors">n_neighbors</code></td>
<td>
<p>an <code>int</code>. Number of neighbors to find. (Default is <code>10</code>).</p>
</td></tr>
<tr><td><code id="find_motif_+3A_radius">radius</code></td>
<td>
<p>an <code>int</code>. Set a threshold to exclude matching neighbors with distance &gt; current
motif distance * <code>radius</code>. (Default is <code>3</code>).</p>
</td></tr>
<tr><td><code id="find_motif_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>if a <code>number</code> will be used instead of embedded value. (Default is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="find_motif_+3A_mode">mode</code></td>
<td>
<p>a <code>string</code>. Guided or Unconstrained search. Allow partial match. (Default is <code>guided</code>).</p>
</td></tr>
<tr><td><code id="find_motif_+3A_n_bit">n_bit</code></td>
<td>
<p>an <code>int</code>. Bit size for discretization. Ignored on Guided search. (Default is <code>4</code>).</p>
</td></tr>
<tr><td><code id="find_motif_+3A_n_dim">n_dim</code></td>
<td>
<p>an <code>int</code>. Number of dimensions to use on Guided search instead of embedded value. (Default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For class <code>MatrixProfile</code>, returns the input <code>.mp</code> object with a new name <code>motif</code>. It contains: <code>motif_idx</code>, a <code>list</code>
of motif pairs found and <code>motif_neighbor</code> a <code>list</code> with respective motif's neighbors.
</p>
<p>For class <code>MultiMatrixProfile</code>, returns the input <code>.mp</code> object with a new name <code>motif</code>. It contains: <code>motif_idx</code>, a <code>vector</code>
of motifs found and <code>motif_dim</code> a <code>list</code> the dimensions where the motifs were found
</p>
<p>For class <code>PMP</code>, returns the input <code>.mp</code> object with a new name <code>motif</code>. It contains: <code>motif_idx</code>, a <code>list</code>
of motif pairs found and <code>motif_neighbor</code> a <code>list</code> with respective motif's neighbors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Single dimension data
w &lt;- 50
data &lt;- mp_gait_data
mp &lt;- tsmp(data, window_size = w, exclusion_zone = 1 / 4, verbose = 0)
mp &lt;- find_motif(mp)

# Multidimension data
w &lt;- mp_toy_data$sub_len
data &lt;- mp_toy_data$data[1:200, ]
mp &lt;- tsmp(data, window_size = w, mode = "mstomp", verbose = 0)
mp &lt;- find_motif(mp)
pan &lt;- tsmp(mp_gait_data, window_size = 20:30, mode = "pmp")
mp &lt;- find_motif(pan)
</code></pre>

<hr>
<h2 id='find_snippet'>Time Series Snippets: A New Primitive for Time Series Data Mining</h2><span id='topic+find_snippet'></span>

<h3>Description</h3>

<p>Time Series Snippets tries to solve mainly the common problem of summarization &quot;Show me some
representative/typical data&quot;. As stated by the original paper, potential uses of snippets are:
integrating summarizations of files directly into an operating, production of automatically
generated reports, for example, summarize a sleep study and also can be used to support a
host of higher-level tasks, including the comparison of massive data collections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_snippet(data, s_size, n_snippets = 2L, window_size = s_size/2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_snippet_+3A_data">data</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code>.</p>
</td></tr>
<tr><td><code id="find_snippet_+3A_s_size">s_size</code></td>
<td>
<p>an int. Size of snippet.</p>
</td></tr>
<tr><td><code id="find_snippet_+3A_n_snippets">n_snippets</code></td>
<td>
<p>an <code>int</code>. Number of snippets to find. (Default is <code>2</code>).</p>
</td></tr>
<tr><td><code id="find_snippet_+3A_window_size">window_size</code></td>
<td>
<p>an <code>int</code>. The size of the sliding window used to compare the data. Must be smaller
than <code>s_size</code>. (Default is <code>s_size / 2</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Motifs vs. snippets: While motifs reward fidelity of conservation, snippets also rewards coverage.
Informally, coverage is some measure of how much of the data is explained or represented by
a given snippet.
</p>
<p>Shapelets vs. snippets: shapelets are defined as subsequences that are maximally representative
of a class. Shapelets are supervised, snippets are unsupervised. Shapelets are generally biased
to be as short as possible. In contrast, we want snippets to be longer, to intuitively capture
the &quot;flavor&quot; of the time series.
</p>


<h3>Value</h3>

<p>Returns the snippet : a list of n_snippets snippets
fraction : fraction of each snippet
snippetidx : the location of each
snippet within time series
</p>


<h3>References</h3>


<ul>
<li><p> Imani S, Madrid F, Ding W, Crouter S, Keogh E. Matrix Profile XIII:
Time Series Snippets: A New Primitive for Time Series Data Mining. In: 2018 IEEE International
Conference on Data Mining (ICDM). 2018.
</p>
</li></ul>


<ul>
<li><p> Gharghabi S, Imani S, Bagnall A, Darvishzadeh A, Keogh E. Matrix Profile XII:
MPdist: A Novel Time Series Distance Measure to Allow Data Mining in More Challenging Scenarios.
In: 2018 IEEE International Conference on Data Mining (ICDM). 2018.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/site/snippetfinder/">https://sites.google.com/site/snippetfinder/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
snippets &lt;- find_snippet(mp_fluss_data$walkjogrun$data[1:300], 40, n_snippets = 2)

snippets &lt;- find_snippet(mp_fluss_data$walkjogrun$data, 120, n_snippets = 3)
plot(snippets)


</code></pre>

<hr>
<h2 id='floss'>Fast Low-cost Online Semantic Segmentation (FLOSS)</h2><span id='topic+floss'></span>

<h3>Description</h3>

<p>Fast Low-cost Online Semantic Segmentation (FLOSS)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>floss(
  .mp,
  new_data,
  data_window,
  threshold = 1,
  exclusion_zone = NULL,
  chunk_size = NULL,
  keep_cac = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="floss_+3A_.mp">.mp</code></td>
<td>
<p>a <code>MatrixProfile</code> object.</p>
</td></tr>
<tr><td><code id="floss_+3A_new_data">new_data</code></td>
<td>
<p>a <code>matrix</code>or <code>vector</code> of new observations.</p>
</td></tr>
<tr><td><code id="floss_+3A_data_window">data_window</code></td>
<td>
<p>an <code>int</code>. Sets the size of the buffer used to keep track of semantic changes.</p>
</td></tr>
<tr><td><code id="floss_+3A_threshold">threshold</code></td>
<td>
<p>a <code>number</code>. (Default is <code>1</code>). Set the maximum value for evaluating semantic changes.
This is data specific. It is advised to check what is 'normal' for your data.</p>
</td></tr>
<tr><td><code id="floss_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>if a <code>number</code> will be used instead of embedded value. (Default is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="floss_+3A_chunk_size">chunk_size</code></td>
<td>
<p>an <code>int</code> . (Default is <code>NULL</code>). Set the size of new data that will be added to
Floss in each iteration if <code>new_data</code> is large. If <code>NULL</code>, the size will be 50. This is not needed
if <code>new_data</code> is small, like 1 observation.</p>
</td></tr>
<tr><td><code id="floss_+3A_keep_cac">keep_cac</code></td>
<td>
<p>a <code>logical</code>. (Default is <code>TRUE</code>). If set to <code>FALSE</code>, the <code>cac_final</code> will contain
only values within <code>data_window</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input <code>.mp</code> object new names: <code>cac</code> the corrected arc count, <code>cac_final</code>the
combination of <code>cac</code> after repeated calls of <code>floss()</code>, <code>floss</code> with the location of semantic
changes and <code>floss_vals</code> with the normalized arc count value of the semantic change positions.
</p>


<h3>References</h3>


<ul>
<li><p> Gharghabi S, Ding Y, Yeh C-CM, Kamgar K, Ulanova L, Keogh E. Matrix Profile VIII:
Domain Agnostic Online Semantic Segmentation at Superhuman Performance Levels. In: 2017 IEEE
International Conference on Data Mining (ICDM). IEEE; 2017. p. 117-26.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/site/onlinesemanticsegmentation/">https://sites.google.com/site/onlinesemanticsegmentation/</a>
</p>
<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other Semantic Segmentations: 
<code><a href="#topic+floss_cac">floss_cac</a>()</code>,
<code><a href="#topic+floss_extract">floss_extract</a>()</code>,
<code><a href="#topic+fluss_cac">fluss_cac</a>()</code>,
<code><a href="#topic+fluss_extract">fluss_extract</a>()</code>,
<code><a href="#topic+fluss_score">fluss_score</a>()</code>,
<code><a href="#topic+fluss">fluss</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mp_fluss_data$tilt_abp$data[1:1000]
new_data &lt;- mp_fluss_data$tilt_abp$data[1001:1010]
new_data2 &lt;- mp_fluss_data$tilt_abp$data[1011:1020]
w &lt;- 80
mp &lt;- tsmp(data, window_size = w, verbose = 0)
data_window &lt;- 1000
mp &lt;- floss(mp, new_data, data_window)
mp &lt;- floss(mp, new_data2, data_window)
</code></pre>

<hr>
<h2 id='floss_cac'>FLOSS - Corrected Arc Counts</h2><span id='topic+floss_cac'></span>

<h3>Description</h3>

<p>Computes the arc count with edge and 'online' correction (CAC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>floss_cac(.mp, data_window, exclusion_zone = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="floss_cac_+3A_.mp">.mp</code></td>
<td>
<p>a <code>MatrixProfile</code> object.</p>
</td></tr>
<tr><td><code id="floss_cac_+3A_data_window">data_window</code></td>
<td>
<p>an <code>int</code>. Sets the size of the buffer used to keep track of semantic changes.</p>
</td></tr>
<tr><td><code id="floss_cac_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>if a <code>number</code> will be used instead of embedded value. (Default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Original paper suggest using the classic statistical-process-control heuristic to set a threshold
where a semantic change may occur in CAC. This may be useful in real-time implementation as we don't
know in advance the number of domain changes to look for. Please check original paper (1).
</p>


<h3>Value</h3>

<p>Returns the input <code>.mp</code> object a new name <code>cac</code> with the corrected arc count and <code>cac_final</code>
the combination of <code>cac</code> after repeated calls of <code>floss()</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Gharghabi S, Ding Y, Yeh C-CM, Kamgar K, Ulanova L, Keogh E. Matrix Profile VIII: Domain Agnostic Online Semantic Segmentation at Superhuman Performance Levels. In: 2017 IEEE International Conference on Data Mining (ICDM). IEEE; 2017. p. 117-26.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/site/onlinesemanticsegmentation/">https://sites.google.com/site/onlinesemanticsegmentation/</a>
</p>
<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other Semantic Segmentations: 
<code><a href="#topic+floss_extract">floss_extract</a>()</code>,
<code><a href="#topic+floss">floss</a>()</code>,
<code><a href="#topic+fluss_cac">fluss_cac</a>()</code>,
<code><a href="#topic+fluss_extract">fluss_extract</a>()</code>,
<code><a href="#topic+fluss_score">fluss_score</a>()</code>,
<code><a href="#topic+fluss">fluss</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mp_fluss_data$tilt_abp$data[1:1000]
new_data &lt;- mp_fluss_data$tilt_abp$data[1001:1010]
w &lt;- 10
mp &lt;- tsmp(data, window_size = w, verbose = 0)
data_window &lt;- 1000
mp &lt;- stompi_update(mp, new_data, data_window)
mp &lt;- floss_cac(mp, data_window)
</code></pre>

<hr>
<h2 id='floss_extract'>FLOSS - Extract Segments</h2><span id='topic+floss_extract'></span>

<h3>Description</h3>

<p>Extract candidate points of semantic changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>floss_extract(.mpac, threshold = 1, exclusion_zone = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="floss_extract_+3A_.mpac">.mpac</code></td>
<td>
<p>a TSMP object of class <code>ArcCount</code>.</p>
</td></tr>
<tr><td><code id="floss_extract_+3A_threshold">threshold</code></td>
<td>
<p>a <code>number</code>. (Default is <code>1</code>). Set the maximum value for evaluating semantic changes.
This is data specific. It is advised to check what is 'normal' for your data.</p>
</td></tr>
<tr><td><code id="floss_extract_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>if a <code>number</code> will be used instead of embedded value. (Default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input <code>.mp</code> object a new name <code>floss</code> with the location of semantic
changes and <code>floss_vals</code> with the normalized arc count value of the semantic change positions.
</p>


<h3>References</h3>


<ul>
<li><p> Gharghabi S, Ding Y, Yeh C-CM, Kamgar K, Ulanova L, Keogh E. Matrix Profile VIII:
Domain Agnostic Online Semantic Segmentation at Superhuman Performance Levels. In: 2017 IEEE
International Conference on Data Mining (ICDM). IEEE; 2017. p. 117-26.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/site/onlinesemanticsegmentation/">https://sites.google.com/site/onlinesemanticsegmentation/</a>
</p>
<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other Semantic Segmentations: 
<code><a href="#topic+floss_cac">floss_cac</a>()</code>,
<code><a href="#topic+floss">floss</a>()</code>,
<code><a href="#topic+fluss_cac">fluss_cac</a>()</code>,
<code><a href="#topic+fluss_extract">fluss_extract</a>()</code>,
<code><a href="#topic+fluss_score">fluss_score</a>()</code>,
<code><a href="#topic+fluss">fluss</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mp_fluss_data$tilt_abp$data[1:1000]
w &lt;- 10
mp &lt;- tsmp(data, window_size = w, verbose = 0)
mp &lt;- fluss_cac(mp)
mp &lt;- fluss_extract(mp, 2)
</code></pre>

<hr>
<h2 id='fluss'>Fast Low-cost Unipotent Semantic Segmentation (FLUSS)</h2><span id='topic+fluss'></span>

<h3>Description</h3>

<p>FLUSS is a Domain Agnostic Online Semantic Segmentation that uses the assumption that when few
arc are crossing a given index point, means that there is a high probability of semantic change.
This function is a wrap to <code><a href="#topic+fluss_cac">fluss_cac()</a></code> and <code><a href="#topic+fluss_extract">fluss_extract()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fluss(.mp, num_segments = 1, exclusion_zone = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fluss_+3A_.mp">.mp</code></td>
<td>
<p>a <code>MatrixProfile</code> object.</p>
</td></tr>
<tr><td><code id="fluss_+3A_num_segments">num_segments</code></td>
<td>
<p>an <code>int</code>. Number of segments to extract. Based on domain knowledge.</p>
</td></tr>
<tr><td><code id="fluss_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>if a <code>number</code> will be used instead of embedded value. (Default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input <code>.mp</code> object new names: <code>cac</code>, corrected arc count and <code>fluss</code> with
the location of semantic changes.
</p>


<h3>References</h3>


<ul>
<li><p> Gharghabi S, Ding Y, Yeh C-CM, Kamgar K, Ulanova L, Keogh E. Matrix Profile VIII:
Domain Agnostic Online Semantic Segmentation at Superhuman Performance Levels. In: 2017 IEEE
International Conference on Data Mining (ICDM). IEEE; 2017. p. 117-26.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/site/onlinesemanticsegmentation/">https://sites.google.com/site/onlinesemanticsegmentation/</a>
</p>
<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other Semantic Segmentations: 
<code><a href="#topic+floss_cac">floss_cac</a>()</code>,
<code><a href="#topic+floss_extract">floss_extract</a>()</code>,
<code><a href="#topic+floss">floss</a>()</code>,
<code><a href="#topic+fluss_cac">fluss_cac</a>()</code>,
<code><a href="#topic+fluss_extract">fluss_extract</a>()</code>,
<code><a href="#topic+fluss_score">fluss_score</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mp_fluss_data$tilt_abp$data[1:1000]
w &lt;- 10
mp &lt;- tsmp(data, window_size = w, verbose = 0)
mp &lt;- fluss(mp, 2)
</code></pre>

<hr>
<h2 id='fluss_cac'>FLUSS - Corrected Arc Counts</h2><span id='topic+fluss_cac'></span>

<h3>Description</h3>

<p>Computes the arc count with edge correction (CAC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fluss_cac(.mp, exclusion_zone = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fluss_cac_+3A_.mp">.mp</code></td>
<td>
<p>a <code>MatrixProfile</code> object.</p>
</td></tr>
<tr><td><code id="fluss_cac_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>if a <code>number</code> will be used instead of embedded value. (Default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Original paper suggest using the classic statistical-process-control heuristic to set a threshold
where a semantic change may occur in CAC. This may be useful in real-time implementation as we don't
know in advance the number of domain changes to look for. Please check original paper (1).
</p>


<h3>Value</h3>

<p>Returns the input <code>.mp</code> object a new name <code>cac</code> with the corrected arc count.
</p>


<h3>References</h3>


<ul>
<li><p> Gharghabi S, Ding Y, Yeh C-CM, Kamgar K, Ulanova L, Keogh E. Matrix Profile VIII: Domain Agnostic Online Semantic Segmentation at Superhuman Performance Levels. In: 2017 IEEE International Conference on Data Mining (ICDM). IEEE; 2017. p. 117-26.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/site/onlinesemanticsegmentation/">https://sites.google.com/site/onlinesemanticsegmentation/</a>
</p>
<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other Semantic Segmentations: 
<code><a href="#topic+floss_cac">floss_cac</a>()</code>,
<code><a href="#topic+floss_extract">floss_extract</a>()</code>,
<code><a href="#topic+floss">floss</a>()</code>,
<code><a href="#topic+fluss_extract">fluss_extract</a>()</code>,
<code><a href="#topic+fluss_score">fluss_score</a>()</code>,
<code><a href="#topic+fluss">fluss</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mp_fluss_data$tilt_abp$data[1:1000]
w &lt;- 10
mp &lt;- tsmp(data, window_size = w, verbose = 0)
mp &lt;- fluss_cac(mp)
</code></pre>

<hr>
<h2 id='fluss_extract'>FLUSS - Extract Segments</h2><span id='topic+fluss_extract'></span>

<h3>Description</h3>

<p>Extract candidate points of semantic changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fluss_extract(.mpac, num_segments = 1, exclusion_zone = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fluss_extract_+3A_.mpac">.mpac</code></td>
<td>
<p>a TSMP object of class <code>ArcCount</code>.</p>
</td></tr>
<tr><td><code id="fluss_extract_+3A_num_segments">num_segments</code></td>
<td>
<p>an <code>int</code>. Number of segments to extract. Based on domain knowledge.</p>
</td></tr>
<tr><td><code id="fluss_extract_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>if a <code>number</code> will be used instead of embedded value. (Default is <code>NULL</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input <code>.mp</code> object a new name <code>fluss</code> with the location of semantic changes.
</p>


<h3>References</h3>


<ul>
<li><p> Gharghabi S, Ding Y, Yeh C-CM, Kamgar K, Ulanova L, Keogh E. Matrix Profile VIII:
Domain Agnostic Online Semantic Segmentation at Superhuman Performance Levels. In: 2017 IEEE
International Conference on Data Mining (ICDM). IEEE; 2017. p. 117-26.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/site/onlinesemanticsegmentation/">https://sites.google.com/site/onlinesemanticsegmentation/</a>
</p>
<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other Semantic Segmentations: 
<code><a href="#topic+floss_cac">floss_cac</a>()</code>,
<code><a href="#topic+floss_extract">floss_extract</a>()</code>,
<code><a href="#topic+floss">floss</a>()</code>,
<code><a href="#topic+fluss_cac">fluss_cac</a>()</code>,
<code><a href="#topic+fluss_score">fluss_score</a>()</code>,
<code><a href="#topic+fluss">fluss</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mp_fluss_data$tilt_abp$data[1:1000]
w &lt;- 10
mp &lt;- tsmp(data, window_size = w, verbose = 0)
mp &lt;- fluss_cac(mp)
mp &lt;- fluss_extract(mp, 2)
</code></pre>

<hr>
<h2 id='fluss_score'>FLUSS - Prediction score calculation</h2><span id='topic+fluss_score'></span>

<h3>Description</h3>

<p>FLUSS - Prediction score calculation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fluss_score(gtruth, extracted, data_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fluss_score_+3A_gtruth">gtruth</code></td>
<td>
<p>an <code>int</code> or <code>vector</code> of <code>int</code> with the ground truth index of segments.</p>
</td></tr>
<tr><td><code id="fluss_score_+3A_extracted">extracted</code></td>
<td>
<p>an <code>int</code> or <code>vector</code> of <code>int</code> with the extracted indexes from <code><a href="#topic+fluss_extract">fluss_extract()</a></code>.</p>
</td></tr>
<tr><td><code id="fluss_score_+3A_data_size">data_size</code></td>
<td>
<p>an <code>int</code>. Size of original input data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the score of predicted semantic transitions compared with the ground truth.
Zero is the best, One is the worst.
</p>


<h3>References</h3>


<ul>
<li><p> Gharghabi S, Ding Y, Yeh C-CM, Kamgar K, Ulanova L, Keogh E. Matrix Profile VIII: Domain Agnostic Online Semantic Segmentation at Superhuman Performance Levels. In: 2017 IEEE International Conference on Data Mining (ICDM). IEEE; 2017. p. 117-26.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/site/onlinesemanticsegmentation/">https://sites.google.com/site/onlinesemanticsegmentation/</a>
</p>
<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other Semantic Segmentations: 
<code><a href="#topic+floss_cac">floss_cac</a>()</code>,
<code><a href="#topic+floss_extract">floss_extract</a>()</code>,
<code><a href="#topic+floss">floss</a>()</code>,
<code><a href="#topic+fluss_cac">fluss_cac</a>()</code>,
<code><a href="#topic+fluss_extract">fluss_extract</a>()</code>,
<code><a href="#topic+fluss">fluss</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- mp_fluss_data$tilt_abp$data[1:1000]
w &lt;- 10
truth &lt;- c(945, 875)
mp &lt;- tsmp(data, window_size = w, verbose = 0)
mp &lt;- fluss_cac(mp)
mp &lt;- fluss_extract(mp, 2)
score &lt;- fluss_score(truth, mp$fluss, length(data))
</code></pre>

<hr>
<h2 id='get_data'>Get the data included in a TSMP object, if any.</h2><span id='topic+get_data'></span>

<h3>Description</h3>

<p>Get the data included in a TSMP object, if any.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_data(.mp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_data_+3A_.mp">.mp</code></td>
<td>
<p>a TSMP object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the data as <code>matrix</code>. If there is more than one series, returns a <code>list</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mp &lt;- tsmp(mp_toy_data$data[1:200, 1], window_size = 30, verbose = 0)
get_data(mp)
</code></pre>

<hr>
<h2 id='mass'>Deprecated functions in package <span class="pkg">tsmp</span>.</h2><span id='topic+mass'></span><span id='topic+tsmp-deprecated'></span>

<h3>Description</h3>

<p>The functions listed below are deprecated and will be defunct in
the near future. When possible, alternative functions with similar
functionality are also mentioned. Help pages for deprecated functions are
available at <code>help("-deprecated")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mass(
  data_fft,
  query_window,
  data_size,
  window_size,
  data_mean,
  data_sd,
  query_mean,
  query_sd
)
</code></pre>


<h3><code>mass</code></h3>

<p>For <code>mass</code>, use <code><a href="#topic+dist_profile">dist_profile</a></code>. Original documentation at <code><a href="#topic+mass-deprecated">mass-deprecated</a></code>.
</p>

<hr>
<h2 id='mass_pre'>Precomputes several values used on MASS</h2><span id='topic+mass_pre'></span>

<h3>Description</h3>

<p>Precomputes several values used on MASS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mass_pre(data, query = NULL, window_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mass_pre_+3A_data">data</code></td>
<td>
<p>a <code>vector</code> or a <code>matrix</code> of <code>numeric</code>. Reference Time Series.</p>
</td></tr>
<tr><td><code id="mass_pre_+3A_query">query</code></td>
<td>
<p>a <code>vector</code> or a <code>matrix</code> of <code>numeric</code>. Query Time Series (default is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="mass_pre_+3A_window_size">window_size</code></td>
<td>
<p>an <code>int</code>. Sliding window size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>window_size</code>, <code>data_fft</code>, <code>data_size</code>, <code>data_mean</code>, <code>data_sd</code>, <code>query_mean</code> and <code>query_sd</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Abdullah Mueen, Yan Zhu, Michael Yeh, Kaveh Kamgar, Krishnamurthy Viswanathan,
Chetan Kumar Gupta and Eamonn Keogh (2015), The Fastest Similarity Search Algorithm for Time
Series Subsequences under Euclidean Distance.
</p>
</li></ul>

<p>Website: <a href="https://www.cs.unm.edu/~mueen/FastestSimilaritySearch.html">https://www.cs.unm.edu/~mueen/FastestSimilaritySearch.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mass_v2">mass_v2()</a></code>, <code><a href="#topic+mass_v3">mass_v3()</a></code> for using precomputed values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- mp_toy_data$sub_len
ref_data &lt;- mp_toy_data$data[, 1]
query_data &lt;- mp_toy_data$data[, 1]

pre &lt;- tsmp:::mass_pre(ref_data, query_data, w)

dp &lt;- list()
for (i in 1:(pre$data_size - w + 1)) {
  dp[[i]] &lt;- tsmp:::mass_v2(
    query_data[i:(i - 1 + w)], pre$window_size, pre$data_fft, pre$data_size,
    pre$data_mean, pre$data_sd, pre$query_mean[i], pre$query_sd[i]
  )
}
</code></pre>

<hr>
<h2 id='mass_pre_w'>Precomputes several values used on MASS</h2><span id='topic+mass_pre_w'></span>

<h3>Description</h3>

<p>Precomputes several values used on MASS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mass_pre_w(data, query = NULL, window_size, weight)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mass_pre_w_+3A_data">data</code></td>
<td>
<p>a <code>vector</code> or a <code>matrix</code> of <code>numeric</code>. Reference Time Series.</p>
</td></tr>
<tr><td><code id="mass_pre_w_+3A_query">query</code></td>
<td>
<p>a <code>vector</code> or a <code>matrix</code> of <code>numeric</code>. Query Time Series (default is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="mass_pre_w_+3A_window_size">window_size</code></td>
<td>
<p>an <code>int</code>. Sliding window size.</p>
</td></tr>
<tr><td><code id="mass_pre_w_+3A_weight">weight</code></td>
<td>
<p>a <code>vector</code> of <code>numeric</code> with the same length of the <code>window_size</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>window_size</code>, <code>data_fft</code>, <code>data_size</code>, <code>data_mean</code>, <code>data_sd</code>, <code>data_pre</code>, <code>weight</code>
</p>


<h3>References</h3>


<ul>
<li><p> Abdullah Mueen, Yan Zhu, Michael Yeh, Kaveh Kamgar, Krishnamurthy Viswanathan,
Chetan Kumar Gupta and Eamonn Keogh (2015), The Fastest Similarity Search Algorithm for Time
Series Subsequences under Euclidean Distance.
</p>
</li></ul>

<p>Website: <a href="https://www.cs.unm.edu/~mueen/FastestSimilaritySearch.html">https://www.cs.unm.edu/~mueen/FastestSimilaritySearch.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mass_weighted">mass_weighted()</a></code> for using precomputed values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- mp_toy_data$sub_len
ref_data &lt;- mp_toy_data$data[, 1]
query_data &lt;- mp_toy_data$data[, 1]
weight &lt;- c(
  rep(1, mp_toy_data$sub_len / 3), rep(0.5, mp_toy_data$sub_len / 3),
  rep(1, mp_toy_data$sub_len / 3)
)

pre &lt;- tsmp:::mass_pre_w(ref_data, query_data, w, weight)

dp &lt;- list()
for (i in 1:(pre$data_size - w + 1)) {
  dp[[i]] &lt;- tsmp:::mass_weighted(
    query_data[i:(i - 1 + w)], pre$window_size, pre$data_fft, pre$data_size,
    pre$data_mean, pre$data_sd, pre$data_pre, pre$weight
  )
}
</code></pre>

<hr>
<h2 id='mass_v2'>Calculates the distance profile using MASS_V2 algorithm</h2><span id='topic+mass_v2'></span>

<h3>Description</h3>

<p>Mueen's Algorithm for Similarity Search is The Fastest Similarity Search Algorithm for Time
Series Subsequences under Euclidean Distance and Correlation Coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mass_v2(
  query_window,
  window_size,
  data_fft,
  data_size,
  data_mean,
  data_sd,
  query_mean,
  query_sd,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mass_v2_+3A_query_window">query_window</code></td>
<td>
<p>a <code>vector</code> of <code>numeric</code>. Query window.</p>
</td></tr>
<tr><td><code id="mass_v2_+3A_window_size">window_size</code></td>
<td>
<p>an <code>int</code>. Sliding window size.</p>
</td></tr>
<tr><td><code id="mass_v2_+3A_data_fft">data_fft</code></td>
<td>
<p>precomputed data product.</p>
</td></tr>
<tr><td><code id="mass_v2_+3A_data_size">data_size</code></td>
<td>
<p>an <code>int</code>. The length of the reference data.</p>
</td></tr>
<tr><td><code id="mass_v2_+3A_data_mean">data_mean</code></td>
<td>
<p>precomputed data moving average.</p>
</td></tr>
<tr><td><code id="mass_v2_+3A_data_sd">data_sd</code></td>
<td>
<p>precomputed data moving standard deviation.</p>
</td></tr>
<tr><td><code id="mass_v2_+3A_query_mean">query_mean</code></td>
<td>
<p>precomputed query average.</p>
</td></tr>
<tr><td><code id="mass_v2_+3A_query_sd">query_sd</code></td>
<td>
<p>precomputed query standard deviation.</p>
</td></tr>
<tr><td><code id="mass_v2_+3A_...">...</code></td>
<td>
<p>just a placeholder to catch unused parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>distance_profile</code> for the given query and the <code>last_product</code> for STOMP
algorithm.
</p>


<h3>References</h3>


<ul>
<li><p> Abdullah Mueen, Yan Zhu, Michael Yeh, Kaveh Kamgar, Krishnamurthy Viswanathan,
Chetan Kumar Gupta and Eamonn Keogh (2015), The Fastest Similarity Search Algorithm for Time
Series Subsequences under Euclidean Distance
</p>
</li></ul>

<p>Website: <a href="https://www.cs.unm.edu/~mueen/FastestSimilaritySearch.html">https://www.cs.unm.edu/~mueen/FastestSimilaritySearch.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mass_pre">mass_pre()</a></code> to precomputation of input values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- mp_toy_data$sub_len
ref_data &lt;- mp_toy_data$data[, 1]
query_data &lt;- mp_toy_data$data[, 1]
d_size &lt;- length(ref_data)
q_size &lt;- length(query_data)

pre &lt;- tsmp:::mass_pre(ref_data, query_data, w)

dp &lt;- list()
for (i in 1:(d_size - w + 1)) {
  dp[[i]] &lt;- tsmp:::mass_v2(
    query_data[i:(i - 1 + w)], pre$window_size,
    pre$data_fft, pre$data_size, pre$data_mean, pre$data_sd,
    pre$query_mean[i], pre$query_sd[i]
  )
}
</code></pre>

<hr>
<h2 id='mass_v3'>Calculates the distance profile using MASS_V3 algorithm</h2><span id='topic+mass_v3'></span>

<h3>Description</h3>

<p>Mueen's Algorithm for Similarity Search is The Fastest Similarity Search Algorithm for Time
Series Subsequences under Euclidean Distance and Correlation Coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mass_v3(
  query_window,
  data,
  window_size,
  data_size,
  data_mean,
  data_sd,
  query_mean,
  query_sd,
  k = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mass_v3_+3A_query_window">query_window</code></td>
<td>
<p>a <code>vector</code> of <code>numeric</code>. Query window.</p>
</td></tr>
<tr><td><code id="mass_v3_+3A_data">data</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code>.</p>
</td></tr>
<tr><td><code id="mass_v3_+3A_window_size">window_size</code></td>
<td>
<p>an <code>int</code>. Sliding window size.</p>
</td></tr>
<tr><td><code id="mass_v3_+3A_data_size">data_size</code></td>
<td>
<p>an <code>int</code>. The length of the reference data.</p>
</td></tr>
<tr><td><code id="mass_v3_+3A_data_mean">data_mean</code></td>
<td>
<p>precomputed data moving average.</p>
</td></tr>
<tr><td><code id="mass_v3_+3A_data_sd">data_sd</code></td>
<td>
<p>precomputed data moving standard deviation.</p>
</td></tr>
<tr><td><code id="mass_v3_+3A_query_mean">query_mean</code></td>
<td>
<p>precomputed query average.</p>
</td></tr>
<tr><td><code id="mass_v3_+3A_query_sd">query_sd</code></td>
<td>
<p>precomputed query standard deviation.</p>
</td></tr>
<tr><td><code id="mass_v3_+3A_k">k</code></td>
<td>
<p>an <code>int</code> or <code>NULL</code>. Default is <code>NULL</code>. Defines the size of batch. Prefer to use a power of 2.</p>
</td></tr>
<tr><td><code id="mass_v3_+3A_...">...</code></td>
<td>
<p>just a placeholder to catch unused parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a piecewise version of MASS that performs better when the size of the pieces are well
aligned with the hardware.
</p>


<h3>Value</h3>

<p>Returns the <code>distance_profile</code> for the given query and the <code>last_product</code> for STOMP
algorithm.
</p>


<h3>References</h3>


<ul>
<li><p> Abdullah Mueen, Yan Zhu, Michael Yeh, Kaveh Kamgar, Krishnamurthy Viswanathan,
Chetan Kumar Gupta and Eamonn Keogh (2015), The Fastest Similarity Search Algorithm for Time
Series Subsequences under Euclidean Distance
</p>
</li></ul>

<p>Website: <a href="https://www.cs.unm.edu/~mueen/FastestSimilaritySearch.html">https://www.cs.unm.edu/~mueen/FastestSimilaritySearch.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mass_pre">mass_pre()</a></code> to precomputation of input values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- mp_toy_data$sub_len
ref_data &lt;- mp_toy_data$data[, 1]
query_data &lt;- mp_toy_data$data[, 1]
d_size &lt;- length(ref_data)
q_size &lt;- length(query_data)

pre &lt;- tsmp:::mass_pre(ref_data, query_data, w)

dp &lt;- list()
for (i in 1:(d_size - w + 1)) {
  dp[[i]] &lt;- tsmp:::mass_v3(
    query_data[i:(i - 1 + w)], ref_data,
    pre$window_size, pre$data_size, pre$data_mean, pre$data_sd,
    pre$query_mean[i], pre$query_sd[i]
  )
}
</code></pre>

<hr>
<h2 id='mass_weighted'>Calculates the distance profile using MASS_WEIGHTED algorithm</h2><span id='topic+mass_weighted'></span>

<h3>Description</h3>

<p>Mueen's Algorithm for Similarity Search is The Fastest Similarity Search Algorithm for Time
Series Subsequences under Euclidean Distance and Correlation Coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mass_weighted(
  query_window,
  window_size,
  data_fft,
  data_size,
  data_mean,
  data_sd,
  data_pre,
  weight,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mass_weighted_+3A_query_window">query_window</code></td>
<td>
<p>a <code>vector</code> of <code>numeric</code>. Query window.</p>
</td></tr>
<tr><td><code id="mass_weighted_+3A_window_size">window_size</code></td>
<td>
<p>an <code>int</code>. Sliding window size.</p>
</td></tr>
<tr><td><code id="mass_weighted_+3A_data_fft">data_fft</code></td>
<td>
<p>precomputed data product.</p>
</td></tr>
<tr><td><code id="mass_weighted_+3A_data_size">data_size</code></td>
<td>
<p>an <code>int</code>. The length of the reference data.</p>
</td></tr>
<tr><td><code id="mass_weighted_+3A_data_mean">data_mean</code></td>
<td>
<p>precomputed data moving average.</p>
</td></tr>
<tr><td><code id="mass_weighted_+3A_data_sd">data_sd</code></td>
<td>
<p>precomputed data moving standard deviation.</p>
</td></tr>
<tr><td><code id="mass_weighted_+3A_data_pre">data_pre</code></td>
<td>
<p>precomputed weighted data product.</p>
</td></tr>
<tr><td><code id="mass_weighted_+3A_weight">weight</code></td>
<td>
<p>a <code>vector</code> of <code>numeric</code> with the same length of the <code>window_size</code>.</p>
</td></tr>
<tr><td><code id="mass_weighted_+3A_...">...</code></td>
<td>
<p>just a placeholder to catch unused parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>distance_profile</code> for the given query and the <code>last_product</code> for STOMP
algorithm.
</p>


<h3>References</h3>


<ul>
<li><p> Abdullah Mueen, Yan Zhu, Michael Yeh, Kaveh Kamgar, Krishnamurthy Viswanathan,
Chetan Kumar Gupta and Eamonn Keogh (2015), The Fastest Similarity Search Algorithm for Time
Series Subsequences under Euclidean Distance
</p>
</li></ul>

<p>Website: <a href="https://www.cs.unm.edu/~mueen/FastestSimilaritySearch.html">https://www.cs.unm.edu/~mueen/FastestSimilaritySearch.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mass_pre_w">mass_pre_w()</a></code> to precomputation of input values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- mp_toy_data$sub_len
ref_data &lt;- mp_toy_data$data[, 1]
query_data &lt;- mp_toy_data$data[, 1]
weight &lt;- c(
  rep(1, mp_toy_data$sub_len / 3), rep(0.5, mp_toy_data$sub_len / 3),
  rep(1, mp_toy_data$sub_len / 3)
)

pre &lt;- tsmp:::mass_pre_w(ref_data, query_data, w, weight)

dp &lt;- list()
for (i in 1:(pre$data_size - w + 1)) {
  dp[[i]] &lt;- tsmp:::mass_weighted(
    query_data[i:(i - 1 + w)], pre$window_size, pre$data_fft, pre$data_size,
    pre$data_mean, pre$data_sd, pre$data_pre, pre$weight
  )
}
</code></pre>

<hr>
<h2 id='mass-deprecated'>Calculates the distance profile using MASS_V2 algorithm</h2><span id='topic+mass-deprecated'></span>

<h3>Description</h3>

<p>Mueen's Algorithm for Similarity Search is The Fastest Similarity Search Algorithm for Time
Series Subsequences under Euclidean Distance and Correlation Coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mass(data_fft, query_window, data_size, window_size, data_mean, data_sd,
 query_mean, query_sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mass-deprecated_+3A_data_fft">data_fft</code></td>
<td>
<p>precomputed data product.</p>
</td></tr>
<tr><td><code id="mass-deprecated_+3A_query_window">query_window</code></td>
<td>
<p>a <code>vector</code> of <code>numeric</code>. Query window.</p>
</td></tr>
<tr><td><code id="mass-deprecated_+3A_data_size">data_size</code></td>
<td>
<p>an <code>int</code>. The length of the reference data.</p>
</td></tr>
<tr><td><code id="mass-deprecated_+3A_window_size">window_size</code></td>
<td>
<p>an <code>int</code>. Sliding window size.</p>
</td></tr>
<tr><td><code id="mass-deprecated_+3A_data_mean">data_mean</code></td>
<td>
<p>precomputed data moving average.</p>
</td></tr>
<tr><td><code id="mass-deprecated_+3A_data_sd">data_sd</code></td>
<td>
<p>precomputed data moving standard deviation.</p>
</td></tr>
<tr><td><code id="mass-deprecated_+3A_query_mean">query_mean</code></td>
<td>
<p>precomputed query average.</p>
</td></tr>
<tr><td><code id="mass-deprecated_+3A_query_sd">query_sd</code></td>
<td>
<p>precomputed query standard deviation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the <code>distance_profile</code> for the given query and the <code>last_product</code> for STOMP
algorithm.
</p>


<h3>References</h3>


<ul>
<li><p> Abdullah Mueen, Yan Zhu, Michael Yeh, Kaveh Kamgar, Krishnamurthy Viswanathan,
Chetan Kumar Gupta and Eamonn Keogh (2015), The Fastest Similarity Search Algorithm for Time
Series Subsequences under Euclidean Distance
</p>
</li></ul>

<p>Website: <a href="https://www.cs.unm.edu/~mueen/FastestSimilaritySearch.html">https://www.cs.unm.edu/~mueen/FastestSimilaritySearch.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mass_pre">mass_pre()</a></code> to precomputation of input values.
</p>
<p><code><a href="#topic+tsmp-deprecated">tsmp-deprecated</a></code>
</p>

<hr>
<h2 id='min_mp_idx'>Get index of the minimum value from a matrix profile and its nearest neighbor</h2><span id='topic+min_mp_idx'></span>

<h3>Description</h3>

<p>Get index of the minimum value from a matrix profile and its nearest neighbor
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_mp_idx(.mp, n_dim = NULL, valid = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_mp_idx_+3A_.mp">.mp</code></td>
<td>
<p>a <code>MatrixProfile</code> object.</p>
</td></tr>
<tr><td><code id="min_mp_idx_+3A_n_dim">n_dim</code></td>
<td>
<p>number of dimensions of the matrix profile</p>
</td></tr>
<tr><td><code id="min_mp_idx_+3A_valid">valid</code></td>
<td>
<p>check for valid numbers</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns a <code>matrix</code> with two columns: the minimum and the nearest neighbor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- 50
data &lt;- mp_gait_data
mp &lt;- tsmp(data, window_size = w, exclusion_zone = 1 / 4, verbose = 0)
min_val &lt;- min_mp_idx(mp)
</code></pre>

<hr>
<h2 id='motifs'>Search for Motifs</h2><span id='topic+motifs'></span>

<h3>Description</h3>

<p>Search for Motifs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>motifs(
  profile,
  exclusion_zone = profile$ez,
  k = 3L,
  neighbor_count = 10L,
  radius = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="motifs_+3A_profile">profile</code></td>
<td>
<p>a <code>MatrixProfile</code> or <code>PMP</code> object.</p>
</td></tr>
<tr><td><code id="motifs_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>an <code>int</code>. Number of values to exclude on both sides of the motif to avoid trivial matches.
Defaults to the exclusion zone used to compute the (Pan-)Matrix Profile which is found in the profile data structure.</p>
</td></tr>
<tr><td><code id="motifs_+3A_k">k</code></td>
<td>
<p>an <code>int</code>. Number of motifs to find. (Default is <code>3</code>).</p>
</td></tr>
<tr><td><code id="motifs_+3A_neighbor_count">neighbor_count</code></td>
<td>
<p>an <code>int</code>. Number of neighbors to find. (Default is <code>3</code>).</p>
</td></tr>
<tr><td><code id="motifs_+3A_radius">radius</code></td>
<td>
<p>an <code>int</code>. Set a threshold to exclude matching neighbors with distance &gt; current
discord distance * <code>radius</code>. (Default is <code>3</code>).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other Main API: 
<code><a href="#topic+analyze">analyze</a>()</code>,
<code><a href="#topic+compute">compute</a>()</code>,
<code><a href="#topic+discords">discords</a>()</code>,
<code><a href="#topic+visualize">visualize</a>()</code>
</p>

<hr>
<h2 id='motifs_discords_small'>Just a synthetic dataset for testing</h2><span id='topic+motifs_discords_small'></span>

<h3>Description</h3>

<p>Just a synthetic dataset for testing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>motifs_discords_small
</code></pre>


<h3>Format</h3>

<p>A <code>vector</code> with 875 observations
</p>

<hr>
<h2 id='mp_fluss_data'>Original data used in the FLUSS paper</h2><span id='topic+mp_fluss_data'></span>

<h3>Description</h3>

<p>Contains two datasets used in FLUSS paper (1), first is TiltABP from (2), and second is
WalkJogRun from PAMAP's dataset (3)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_fluss_data
</code></pre>


<h3>Format</h3>

<p>A list containing:
</p>

<dl>
<dt>data</dt><dd><p>one column matrix with the dataset's data</p>
</dd>
<dt>gtruth</dt><dd><p>a vector with the ground truth of semantic change according to provided dataset</p>
</dd>
<dt>window</dt><dd><p>window size used in original paper</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://sites.google.com/site/onlinesemanticsegmentation/">https://sites.google.com/site/onlinesemanticsegmentation/</a>
</p>
<p><a href="http://www.cs.ucr.edu/~eamonn/time_series_data/">http://www.cs.ucr.edu/~eamonn/time_series_data/</a>
</p>


<h3>References</h3>


<ul>
<li><p> Gharghabi S, Ding Y, Yeh C-CM, Kamgar K, Ulanova L, Keogh E. Matrix Profile VIII:
Domain Agnostic Online Semantic Segmentation at Superhuman Performance Levels. In: 2017 IEEE
International Conference on Data Mining (ICDM). IEEE; 2017. p. 117-26.
</p>
</li></ul>


<ul>
<li><p> Heldt, T., Oefinger, M.B., Hoshiyama, M. and Mark, R.G., 2003, September.
Circulatory response to passive and active changes in posture. In IEEE Computers in Cardiology,
2003 (pp. 263-266).
</p>
</li></ul>


<ul>
<li><p> Reiss, A. and Stricker, D., 2012. Introducing a new benchmarked dataset for
activity monitoring. In 16th International Symposium on Wearable Computers (ISWC), 2012, pages
108-109. IEEE, 2012.
</p>
</li></ul>


<hr>
<h2 id='mp_gait_data'>Original data used in the Time Series Chain demo</h2><span id='topic+mp_gait_data'></span>

<h3>Description</h3>

<p>Original data used in the Time Series Chain demo
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_gait_data
</code></pre>


<h3>Format</h3>

<p>A <code>matrix</code> with 904 rows and 1 column with the Y data from an accelerometer
</p>


<h3>Source</h3>

<p><a href="https://sites.google.com/site/timeserieschain/">https://sites.google.com/site/timeserieschain/</a>
</p>


<h3>References</h3>


<ul>
<li><p> Zhu Y, Imamura M, Nikovski D, Keogh E. Matrix Profile VII: Time Series Chains: A
New Primitive for Time Series Data Mining. Knowl Inf Syst. 2018 Jun 2;1-27.
</p>
</li></ul>


<hr>
<h2 id='mp_meat_data'>Original data used in the Salient Subsequences demo</h2><span id='topic+mp_meat_data'></span>

<h3>Description</h3>

<p>This is the Meat dataset from UCR Archive modified for Salient discovery.
The original data is mixed with Random Walks and the algorithm must pick only the originals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_meat_data
</code></pre>


<h3>Format</h3>

<p><code>original</code> is the original dataset with 60+60 observations mixed with 120 random walks:
</p>

<dl>
<dt>data</dt><dd><p>240 time series with length of 448 each.</p>
</dd>
<dt>labels</dt><dd><p>label of each time series, <code>-666</code> means a random walk.</p>
</dd>
<dt>sub_len</dt><dd><p>size of sliding window.</p>
</dd>
</dl>

<p><code>sub</code> is the original dataset embedded in random walks:
</p>

<dl>
<dt>data</dt><dd><p>One time series with length of 107520.</p>
</dd>
<dt>labels</dt><dd><p>label of each original data.</p>
</dd>
<dt>labels_idx</dt><dd><p>starting point where the original data was placed.</p>
</dd>
<dt>sub_len</dt><dd><p>size of sliding window.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="http://www.cs.ucr.edu/~eamonn/time_series_data/">http://www.cs.ucr.edu/~eamonn/time_series_data/</a>
</p>


<h3>References</h3>


<ul>
<li><p> Yeh CCM, Van Herle H, Keogh E. Matrix profile III: The matrix profile allows
visualization of salient subsequences in massive time series. Proc - IEEE Int Conf Data Mining,
ICDM. 2017;579-88.
</p>
</li></ul>


<ul>
<li><p> Hu B, Rakthanmanon T, Hao Y, Evans S, Lonardi S, Keogh E. Discovering the Intrinsic
Cardinality and Dimensionality of Time Series Using MDL. In: 2011 IEEE 11th International
Conference on Data Mining. IEEE; 2011. p. 1086-91.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/site/salientsubs/">https://sites.google.com/site/salientsubs/</a>
</p>

<hr>
<h2 id='mp_test_data'>Original data used in the STDS demo</h2><span id='topic+mp_test_data'></span>

<h3>Description</h3>

<p>A synthetic dataset base on TRACE dataset and used as Stress Test to STDS algorithm. The TRACE
dataset used here is originally from (1), and the version distributed here is from (2)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_test_data
</code></pre>


<h3>Format</h3>

<p>A list of matrices with 215010 rows and 1 dimension:
</p>

<dl>
<dt>train$data</dt><dd><p>training data</p>
</dd>
<dt>train$label</dt><dd><p>label for training data</p>
</dd>
<dt>test$data</dt><dd><p>test data</p>
</dd>
<dt>test$label</dt><dd><p>label for test data</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://sites.google.com/view/weaklylabeled">https://sites.google.com/view/weaklylabeled</a>
</p>
<p><a href="http://www.cs.ucr.edu/~eamonn/time_series_data/">http://www.cs.ucr.edu/~eamonn/time_series_data/</a>
</p>


<h3>References</h3>


<ul>
<li><p> Roverso, D., Multivariate temporal classification by windowed wavelet decomposition
and recurrent neural networks, in 3rd ANS Int'l Topical Meeting on Nuclear Plant
Instrumentation, Control and Human-Machine Interface, vol. 20, Washington, DC, USA, 2000.
</p>
</li></ul>


<ul>
<li><p> Yeh C-CM, Kavantzas N, Keogh E. Matrix profile IV: Using Weakly Labeled Time Series
to Predict Outcomes. Proc VLDB Endow. 2017 Aug 1;10(12):1802-12.
</p>
</li></ul>


<hr>
<h2 id='mp_toy_data'>Original data used in the mSTAMP demo</h2><span id='topic+mp_toy_data'></span>

<h3>Description</h3>

<p>A synthetic dataset with embedded MOTIFs for multidimensional discovery
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mp_toy_data
</code></pre>


<h3>Format</h3>

<p>A <code>list</code> with a <code>matrix</code> with 550 rows and 3 dimensions and an <code>int</code>:
</p>

<dl>
<dt>data</dt><dd><p>data with embedded MOTIFs</p>
</dd>
<dt>sub_len</dt><dd><p>size of sliding window</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://sites.google.com/view/mstamp/">https://sites.google.com/view/mstamp/</a>
</p>


<h3>References</h3>


<ul>
<li><p> Yeh CM, Kavantzas N, Keogh E. Matrix Profile VI : Meaningful Multidimensional Motif
Discovery.
</p>
</li></ul>

<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>

<hr>
<h2 id='mpdist'>MPdist - Distance between Time Series using Matrix Profile</h2><span id='topic+mpdist'></span>

<h3>Description</h3>

<p>MPdist is a recently introduced distance measure which considers two time series to be similar
if they share many similar subsequences, regardless of the order of matching subsequences.
It was demonstrated in that MPdist is robust to spikes, warping, linear trends, dropouts,
wandering baseline and missing values, issues that are common outside of benchmark datasets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpdist(
  ref_data,
  query_data,
  window_size,
  type = c("simple", "vector"),
  thr = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpdist_+3A_ref_data">ref_data</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code>. The reference data</p>
</td></tr>
<tr><td><code id="mpdist_+3A_query_data">query_data</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code>. The query data</p>
</td></tr>
<tr><td><code id="mpdist_+3A_window_size">window_size</code></td>
<td>
<p>an int. Size of the sliding window.</p>
</td></tr>
<tr><td><code id="mpdist_+3A_type">type</code></td>
<td>
<p>the type of result. (Default is <code>simple</code>). See details.</p>
</td></tr>
<tr><td><code id="mpdist_+3A_thr">thr</code></td>
<td>
<p>threshold for MPdist. (Default is <code>0.05</code>). Don't change this unless you know what you are doing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MPdist returns the distance of two time series or a vector containing the distance
between all sliding windows. If argument <code>type</code> is set to <code>vector</code>, the vector is returned.
</p>


<h3>Value</h3>

<p>Returns the distance of two time series or a vector containing the distance
between all sliding windows.
</p>


<h3>References</h3>


<ul>
<li><p> Gharghabi S, Imani S, Bagnall A, Darvishzadeh A, Keogh E. Matrix Profile XII:
MPdist: A Novel Time Series Distance Measure to Allow Data Mining in More Challenging Scenarios.
In: 2018 IEEE International Conference on Data Mining (ICDM). 2018.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/site/mpdistinfo/">https://sites.google.com/site/mpdistinfo/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ref_data &lt;- mp_toy_data$data[, 1]
qe_data &lt;- mp_toy_data$data[, 2]
qd_data &lt;- mp_toy_data$data[150:200, 1]
w &lt;- mp_toy_data$sub_len

# distance between data of same size
deq &lt;- mpdist(ref_data, qe_data, w)

# distance between data of different sizes
ddiff &lt;- mpdist(ref_data, qd_data, w)

# distance vector between data of different sizes
ddvect &lt;- mpdist(ref_data, qd_data, w, type = "vector")
</code></pre>

<hr>
<h2 id='mpx'>Fast implementation of MP and MPI for internal purposes, without FFT</h2><span id='topic+mpx'></span>

<h3>Description</h3>

<p>Fast implementation of MP and MPI for internal purposes, without FFT
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mpx(
  data,
  window_size,
  query = NULL,
  idx = TRUE,
  dist = c("euclidean", "pearson"),
  n_workers = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mpx_+3A_data">data</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code>. The time series to analyze.</p>
</td></tr>
<tr><td><code id="mpx_+3A_window_size">window_size</code></td>
<td>
<p>window size</p>
</td></tr>
<tr><td><code id="mpx_+3A_query">query</code></td>
<td>
<p>query</p>
</td></tr>
<tr><td><code id="mpx_+3A_idx">idx</code></td>
<td>
<p>compute the profile indexes?</p>
</td></tr>
<tr><td><code id="mpx_+3A_dist">dist</code></td>
<td>
<p>distance measure, Euclidean or Pearson?</p>
</td></tr>
<tr><td><code id="mpx_+3A_n_workers">n_workers</code></td>
<td>
<p>threads for multi-threading</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns MP and MPI
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mp &lt;- mpx(mp_toy_data$data[1:200, 1], window_size = 30)

</code></pre>

<hr>
<h2 id='mstomp_par'>Multivariate STOMP algorithm Parallel version</h2><span id='topic+mstomp_par'></span><span id='topic+mstomp'></span>

<h3>Description</h3>

<p>Computes the Matrix Profile and Profile Index for Multivariate Time Series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mstomp_par(
  data,
  window_size,
  exclusion_zone = getOption("tsmp.exclusion_zone", 1/2),
  verbose = getOption("tsmp.verbose", 2),
  must_dim = NULL,
  exc_dim = NULL,
  n_workers = 2
)

mstomp(
  data,
  window_size,
  exclusion_zone = getOption("tsmp.exclusion_zone", 1/2),
  verbose = getOption("tsmp.verbose", 2),
  must_dim = NULL,
  exc_dim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mstomp_par_+3A_data">data</code></td>
<td>
<p>a <code>matrix</code> of <code>numeric</code>, where each column is a time series. Accepts <code>vector</code> (see
details), <code>list</code> and <code>data.frame</code> too.</p>
</td></tr>
<tr><td><code id="mstomp_par_+3A_window_size">window_size</code></td>
<td>
<p>an <code>int</code> with the size of the sliding window.</p>
</td></tr>
<tr><td><code id="mstomp_par_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>a <code>numeric</code>. Size of the exclusion zone, based on window size (default is
<code>1/2</code>).</p>
</td></tr>
<tr><td><code id="mstomp_par_+3A_verbose">verbose</code></td>
<td>
<p>an <code>int</code>. See details. (Default is <code>2</code>).</p>
</td></tr>
<tr><td><code id="mstomp_par_+3A_must_dim">must_dim</code></td>
<td>
<p>an <code>int</code> or <code>vector</code> of which dimensions to forcibly include (default is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="mstomp_par_+3A_exc_dim">exc_dim</code></td>
<td>
<p>an <code>int</code> or <code>vector</code> of which dimensions to exclude (default is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="mstomp_par_+3A_n_workers">n_workers</code></td>
<td>
<p>an <code>int</code>. Number of workers for parallel. (Default is <code>2</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Matrix Profile, has the potential to revolutionize time series data mining because of its
generality, versatility, simplicity and scalability. In particular it has implications for time
series motif discovery, time series joins, shapelet discovery (classification), density
estimation, semantic segmentation, visualization, rule discovery, clustering etc. The MSTOMP
computes the Matrix Profile and Profile Index for Multivariate Time Series that is meaningful for
multidimensional MOTIF discovery. It uses the STOMP algorithm that is faster than STAMP but lacks
its anytime property.
</p>
<p>Although this functions handles Multivariate Time Series, it can also be used to handle
Univariate Time Series. <code>verbose</code> changes how much information is printed by this function; <code>0</code>
means nothing, <code>1</code> means text, <code>2</code> adds the progress bar, <code>3</code> adds the finish sound.
</p>


<h3>Value</h3>

<p>Returns a <code>MultiMatrixProfile</code> object, a <code>list</code> with the matrix profile <code>mp</code>, profile index <code>pi</code>
left and right matrix profile <code>lmp</code>, <code>rmp</code> and profile index <code>lpi</code>, <code>rpi</code>, window size <code>w</code>,
number of dimensions <code>n_dim</code>, exclusion zone <code>ez</code>, must dimensions <code>must</code> and excluded dimensions <code>exc</code>.
</p>
<p>If the input has only one dimension, returns the same as <code><a href="#topic+stomp">stomp()</a></code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>mstomp_par()</code>: Parallel version.
</p>
</li>
<li> <p><code>mstomp()</code>: Single thread version.
</p>
</li></ul>


<h3>References</h3>


<ul>
<li><p> Yeh CM, Kavantzas N, Keogh E. Matrix Profile VI : Meaningful Multidimensional Motif
Discovery.
</p>
</li></ul>


<ul>
<li><p> Zhu Y, Imamura M, Nikovski D, Keogh E. Matrix Profile VII: Time Series Chains: A
New Primitive for Time Series Data Mining. Knowl Inf Syst. 2018 Jun 2;1-27.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/view/mstamp/">https://sites.google.com/view/mstamp/</a>
</p>
<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other matrix profile computations: 
<code><a href="#topic+scrimp">scrimp</a>()</code>,
<code><a href="#topic+stamp_par">stamp_par</a>()</code>,
<code><a href="#topic+stomp_par">stomp_par</a>()</code>,
<code><a href="#topic+tsmp">tsmp</a>()</code>,
<code><a href="#topic+valmod">valmod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># using all dimensions
mp &lt;- mstomp(mp_toy_data$data[1:150, ], 30, verbose = 0)

#' # using threads
mp &lt;- mstomp_par(mp_toy_data$data[1:150, ], 30, verbose = 0)

# force using dimensions 1 and 2
mp &lt;- mstomp(mp_toy_data$data[1:200, ], 30, must_dim = c(1, 2))
# exclude dimensions 2 and 3
mp2 &lt;- mstomp(mp_toy_data$data[1:200, ], 30, exc_dim = c(2, 3))


</code></pre>

<hr>
<h2 id='plot'>Plot a TSMP object</h2><span id='topic+plot'></span><span id='topic+plot.ArcCount'></span><span id='topic+plot.Valmod'></span><span id='topic+plot.MatrixProfile'></span><span id='topic+plot.MultiMatrixProfile'></span><span id='topic+plot.SimpleMatrixProfile'></span><span id='topic+plot.Fluss'></span><span id='topic+plot.Floss'></span><span id='topic+plot.Chain'></span><span id='topic+plot.Discord'></span><span id='topic+plot.Snippet'></span><span id='topic+plot.Motif'></span><span id='topic+plot.MultiMotif'></span><span id='topic+plot.Salient'></span><span id='topic+plot.PMP'></span>

<h3>Description</h3>

<p>Plot a TSMP object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ArcCount'
plot(
  x,
  data,
  type = c("data", "matrix"),
  exclusion_zone = NULL,
  edge_limit = NULL,
  threshold = stats::quantile(x$cac, 0.1),
  main = "Arcs Discover",
  xlab = "index",
  ylab = "",
  ...
)

## S3 method for class 'Valmod'
plot(
  x,
  ylab = "distance",
  xlab = "index",
  main = "Valmod Matrix Profile",
  data = FALSE,
  ...
)

## S3 method for class 'MatrixProfile'
plot(
  x,
  ylab = "distance",
  xlab = "index",
  main = "Unidimensional Matrix Profile",
  data = FALSE,
  ...
)

## S3 method for class 'MultiMatrixProfile'
plot(
  x,
  ylab = "distance",
  xlab = "index",
  main = "Multidimensional Matrix Profile",
  ...
)

## S3 method for class 'SimpleMatrixProfile'
plot(
  x,
  ylab = "distance",
  xlab = "index",
  main = "SiMPle Matrix Profile",
  data = FALSE,
  ...
)

## S3 method for class 'Fluss'
plot(
  x,
  data,
  type = c("data", "matrix"),
  main = "Fast Low-cost Unipotent Semantic Segmentation",
  xlab = "index",
  ylab = "",
  ...
)

## S3 method for class 'Floss'
plot(
  x,
  data,
  type = c("data", "matrix"),
  main = "Fast Low-cost Online Semantic Segmentation",
  xlab = "index",
  ylab = "",
  ...
)

## S3 method for class 'Chain'
plot(
  x,
  data,
  type = c("data", "matrix"),
  main = "Chain Discover",
  xlab = "index",
  ylab = "",
  ...
)

## S3 method for class 'Discord'
plot(
  x,
  data,
  type = c("data", "matrix"),
  ncol = 3,
  main = "Discord Discover",
  xlab = "index",
  ylab = "",
  ...
)

## S3 method for class 'Snippet'
plot(
  x,
  data,
  ncol = 3,
  main = "Snippet Finder",
  xlab = "index",
  ylab = "",
  ...
)

## S3 method for class 'Motif'
plot(
  x,
  data,
  type = c("data", "matrix"),
  ncol = 3,
  main = "MOTIF Discover",
  xlab = "index",
  ylab = "",
  ...
)

## S3 method for class 'MultiMotif'
plot(
  x,
  data,
  type = c("data", "matrix"),
  ncol = 3,
  main = "Multidimensional MOTIF Discover",
  xlab = "index",
  ylab = "",
  ...
)

## S3 method for class 'Salient'
plot(x, data, main = "Salient Subsections", xlab = "index", ylab = "", ...)

## S3 method for class 'PMP'
plot(
  x,
  ylab = "distance",
  xlab = "index",
  main = "Unidimensional Matrix Profile",
  data = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>a Matrix Profile</p>
</td></tr>
<tr><td><code id="plot_+3A_data">data</code></td>
<td>
<p>the data used to build the Matrix Profile, if not embedded to it.</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>&quot;data&quot; or &quot;matrix&quot;. Choose what will be plotted.</p>
</td></tr>
<tr><td><code id="plot_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>if a <code>number</code> will be used instead of Matrix Profile's. (Default is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_edge_limit">edge_limit</code></td>
<td>
<p>if a <code>number</code> will be used instead of Matrix Profile's exclusion zone. (Default is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_threshold">threshold</code></td>
<td>
<p>the maximum value to be used to plot.</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>
<p>a <code>string</code>. Main title.</p>
</td></tr>
<tr><td><code id="plot_+3A_xlab">xlab</code></td>
<td>
<p>a <code>string</code>. X label.</p>
</td></tr>
<tr><td><code id="plot_+3A_ylab">ylab</code></td>
<td>
<p>a <code>string</code>. Y label.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="#topic+plot">plot()</a></code>. See <code><a href="graphics.html#topic+par">par()</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_ncol">ncol</code></td>
<td>
<p>an <code>int</code>. Number of columns to plot Motifs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mp &lt;- tsmp(mp_toy_data$data[1:200, 1], window_size = 30, verbose = 0)
plot(mp)
</code></pre>

<hr>
<h2 id='plot_arcs'>Plot arcs between indexes of a Profile Index</h2><span id='topic+plot_arcs'></span>

<h3>Description</h3>

<p>Sometimes may be useful to see where is the nearest neighbor graphically. This is the reasoning
behind, for example, FLUSS which uses the arc count to infer a semantic change, and SiMPle which
infer that arcs connect similar segments of a music. See details for a deeper explanation how to
use this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_arcs(
  pairs,
  alpha = NULL,
  quality = 30,
  lwd = 15,
  col = c("blue", "orange"),
  main = "Arc Plot",
  ylab = "",
  xlab = "Profile Index",
  xmin = NULL,
  xmax = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_arcs_+3A_pairs">pairs</code></td>
<td>
<p>a <code>matrix</code> with 2 columns.</p>
</td></tr>
<tr><td><code id="plot_arcs_+3A_alpha">alpha</code></td>
<td>
<p>a <code>numeric</code>. (Default is <code>NULL</code>, automatic). Alpha value for lines transparency.</p>
</td></tr>
<tr><td><code id="plot_arcs_+3A_quality">quality</code></td>
<td>
<p>an <code>int</code>. (Default is <code>30</code>). Number of segments to draw the arc. Bigger value,
harder to render.</p>
</td></tr>
<tr><td><code id="plot_arcs_+3A_lwd">lwd</code></td>
<td>
<p>an <code>int</code>. (Default is <code>15</code>). Line width.</p>
</td></tr>
<tr><td><code id="plot_arcs_+3A_col">col</code></td>
<td>
<p>a <code>vector</code> of colors. (Default is <code>c("blue", "orange")</code>). Colors for right and left
arc, respectively. Accepts one color.</p>
</td></tr>
<tr><td><code id="plot_arcs_+3A_main">main</code></td>
<td>
<p>a <code>string</code>. (Default is <code>"Arc Plot"</code>). Main title.</p>
</td></tr>
<tr><td><code id="plot_arcs_+3A_ylab">ylab</code></td>
<td>
<p>a <code>string</code>. (Default is <code>""</code>). Y label.</p>
</td></tr>
<tr><td><code id="plot_arcs_+3A_xlab">xlab</code></td>
<td>
<p>a <code>string</code>. (Default is <code>"Profile Index"</code>). X label.</p>
</td></tr>
<tr><td><code id="plot_arcs_+3A_xmin">xmin</code></td>
<td>
<p>an <code>int</code>. (Default is <code>NULL</code>). Set the minimum value of x axis.</p>
</td></tr>
<tr><td><code id="plot_arcs_+3A_xmax">xmax</code></td>
<td>
<p>an <code>int</code>. (Default is <code>NULL</code>). Set the maximum value of x axis.</p>
</td></tr>
<tr><td><code id="plot_arcs_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="#topic+plot">plot()</a></code>. See <code><a href="graphics.html#topic+par">par()</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>You have two options to use this function. First you can provide just the data, and the function
will try its best to retrieve the pairs for plotting. Second, you can skip the first parameters
and just provide the <code>pairs</code>, which is a <code>matrix</code> with two columns; the first is the starting
index, the second is the end index. Two colors are used to allow you to identify the direction of
the arc. If you use the <code>rpi</code> or <code>lpi</code> as input, you will see that these profile indexes have
just one direction.
</p>
<p><code>exclusion_zone</code> is used to filter out small arcs that may be useless (e.g. you may be interested
in similarities that are far away). <code>edge_limit</code> is used to filter out spurious arcs that are
used connect the beginning and the end of the profile (e.g. silent audio). <code>threshold</code> is used to
filter indexes that have distant nearest neighbor (e.g. retrieve only the best motifs).
</p>


<h3>Value</h3>

<p>None
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot_arcs(pairs = matrix(c(5, 10, 1, 10, 20, 5), ncol = 2, byrow = TRUE))
</code></pre>

<hr>
<h2 id='pmp'>Pan-Matrix Profile</h2><span id='topic+pmp'></span>

<h3>Description</h3>

<p>Computes the Pan-Matrix Profile (PMP) for the given time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmp(
  data,
  window_sizes = seq.int(from = 10, to = length(data)/2, length.out = 20),
  plot = FALSE,
  pmp_obj = NULL,
  n_workers = 1,
  verbose = getOption("tsmp.verbose", 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmp_+3A_data">data</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code> of <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="pmp_+3A_window_sizes">window_sizes</code></td>
<td>
<p>a <code>vector</code> of the window sizes that will be evaluated. They will be rounded to the lower integer
and sorted. (Default is a sequence of 20 values from 10 to half data size).</p>
</td></tr>
<tr><td><code id="pmp_+3A_plot">plot</code></td>
<td>
<p>a <code>logical</code>. If <code>TRUE</code>, every new computation will be plotted. (Default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="pmp_+3A_pmp_obj">pmp_obj</code></td>
<td>
<p>a <code>PMP</code> object that may or not contain an upper bound value, and previous computed profiles. The function will
add new profiles, not replace. (Default is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="pmp_+3A_n_workers">n_workers</code></td>
<td>
<p>an <code>int</code>. Number of workers for parallel. (Default is <code>1</code>).</p>
</td></tr>
<tr><td><code id="pmp_+3A_verbose">verbose</code></td>
<td>
<p>an <code>int</code>. See details. (Default is <code>2</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The work closest in spirit to ours is VALMOD. The idea of VALMOD is to compute the MP for
the shortest length of interest, then use the information gleaned from it to guide a search
through longer subsequence lengths, exploiting lower bounds to prune off some calculations.
This idea works well for the first few of the longer subsequence lengths, but the lower bounds
progressively weaken, making the pruning ineffective. Thus, in the five case studies they
presented, the mean value of U/L was just 1.24. In contrast, consider that our termite example
in Fig. 15 has a U/L ratio of 240, more than two orders of magnitude larger. Thus, VALMOD is
perhaps best seen as finding motifs with some tolerance for a slightly (~25%) too short
user-specified query length, rather than a true &quot;motif-of-all-lengths&quot; algorithm. Also note
that apart from the shortest length, VALMOD only gives some information for the other lengths,
unlike pmp, which contains exact distances for all subsequences of all lengths.
</p>
<p>When just the <code>data</code> is provided, the exploration will be done using the default <code>window_sizes</code> that is a sequence
of 20 values between 10 and the half data size and the resulting object will have an <code>upper_bound</code> equals to <code>Inf</code>.
If an object is provided by the argument <code>pmp_obj</code>, this function will add more information to the resulting object,
never changing the values already computed.
<code>verbose</code> changes how much information is printed by this function; <code>0</code> means nothing, <code>1</code> means text, <code>2</code>
adds the progress bar, <code>3</code> adds the finish sound.
</p>
<p>Talk about upper bound and window sizes
</p>

<ol>
<li><p> upper_window will be set to Inf on new objects
1.1. upper_window will also be used for plot, and for discovery, it must not remove any existing data from the object
</p>
</li>
<li><p> window_sizes is used for plot, it must not remove any mp inside the object
2.1. window_sizes tells the function what mp are stored, it may be updated with as.numeric(names(pmp))
</p>
</li>
<li><p> the functions must be capable to handle the data without need to sort by window_size, but sort may be useful later(?)
</p>
</li></ol>



<h3>Value</h3>

<p>Returns a <code>PMP</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Just compute
pan &lt;- pmp(mp_gait_data)
# Compute the upper bound, than add new profiles
pan &lt;- pmp_upper_bound(mp_gait_data)
pan &lt;- pmp(mp_gait_data, pmp_obj = pan)

</code></pre>

<hr>
<h2 id='pmp_upper_bound'>Pan Matrix Profile upper bound</h2><span id='topic+pmp_upper_bound'></span>

<h3>Description</h3>

<p>Finds the upper bound for Pan Matrix Profile calculation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pmp_upper_bound(
  data,
  threshold = getOption("tsmp.pmp_ub", 0.95),
  refine_stepsize = getOption("tsmp.pmp_refine", 0.25),
  return_pmp = TRUE,
  n_workers = 1,
  verbose = getOption("tsmp.verbose", 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pmp_upper_bound_+3A_data">data</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code> of <code>numeric</code>.</p>
</td></tr>
<tr><td><code id="pmp_upper_bound_+3A_threshold">threshold</code></td>
<td>
<p>a <code>numeric</code>. Correlation threshold. See details.  (Default is <code>0.95</code>).</p>
</td></tr>
<tr><td><code id="pmp_upper_bound_+3A_refine_stepsize">refine_stepsize</code></td>
<td>
<p>a <code>numeric</code>. Step size for the last upper bound search. See details.  (Default is <code>0.25</code>).</p>
</td></tr>
<tr><td><code id="pmp_upper_bound_+3A_return_pmp">return_pmp</code></td>
<td>
<p>a <code>logical</code>. If <code>TRUE</code>, returns the computed data as a <code>PMP</code> object, if <code>FALSE</code>,
returns just the upper bound value. (Default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="pmp_upper_bound_+3A_n_workers">n_workers</code></td>
<td>
<p>an <code>int</code>. Number of workers for parallel. (Default is <code>1</code>).</p>
</td></tr>
<tr><td><code id="pmp_upper_bound_+3A_verbose">verbose</code></td>
<td>
<p>verbose an <code>int</code>. See details. (Default is <code>2</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Pan Matrix Profile may not give any further information beyond a certain window size. This function starts
computing the matrix profile for the window size of 8 and doubles it until the minimum correlation value found is
less than the <code>threshold</code>. After that, it begins to refine the upper bound using the <code>refine_stepsize</code> values, until
the <code>threshold</code> value is hit.
</p>
<p><code>verbose</code> changes how much information is printed by this function; <code>0</code> means nothing, <code>1</code> means text, <code>2</code>
adds the progress bar, <code>3</code> adds the finish sound.
</p>


<h3>Value</h3>

<p>Returns a <code>PMP</code> object with computed data, or just the upper bound value if <code>return_pmp</code> is set to <code>FALSE</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Yet to be announced
</p>
</li></ul>

<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># return the object
pan_matrix &lt;- pmp_upper_bound(mp_gait_data)

# just the upper bound
pan_ub &lt;- pmp_upper_bound(mp_gait_data, return_pmp = FALSE)
</code></pre>

<hr>
<h2 id='read'>Read TSMP object from JSON file.</h2><span id='topic+read'></span>

<h3>Description</h3>

<p>Read TSMP object from JSON file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_+3A_x">x</code></td>
<td>
<p>a <code>character</code> string with the input filename.</p>
</td></tr>
<tr><td><code id="read_+3A_...">...</code></td>
<td>
<p>other arguments to be passed forward.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>

result &lt;- compute(mp_toy_data$data[, 1], 80)

tempfile &lt;- file.path(tempdir(), "output.json")
write(result, file = tempfile)
result &lt;- read(tempfile)

</code></pre>

<hr>
<h2 id='remove_class'>Remove a <code>TSMP</code> class from an object</h2><span id='topic+remove_class'></span>

<h3>Description</h3>

<p>Remove a <code>TSMP</code> class from an object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_class(x, class)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_class_+3A_x">x</code></td>
<td>
<p>a <code>TSMP</code> object</p>
</td></tr>
<tr><td><code id="remove_class_+3A_class">class</code></td>
<td>
<p><code>character</code> string with the class name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object without the class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- 50
data &lt;- mp_gait_data
mp &lt;- tsmp(data, window_size = w, exclusion_zone = 1 / 4, verbose = 0)
mp &lt;- find_chains(mp)
# Remove the "Chain" class information
mp &lt;- remove_class(mp, "Chain")
</code></pre>

<hr>
<h2 id='salient_mds'>Convert salient sequences into MDS space</h2><span id='topic+salient_mds'></span>

<h3>Description</h3>

<p>Convert salient sequences into MDS space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>salient_mds(.mp, data, bit_idx = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="salient_mds_+3A_.mp">.mp</code></td>
<td>
<p>a Matrix Profile object.</p>
</td></tr>
<tr><td><code id="salient_mds_+3A_data">data</code></td>
<td>
<p>the data used to build the Matrix Profile, if not embedded.</p>
</td></tr>
<tr><td><code id="salient_mds_+3A_bit_idx">bit_idx</code></td>
<td>
<p>an <code>int</code>. The index of <code>n_bits</code> used for MDL discretization if more than one was
used. (Default is <code>1</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns X,Y values for plotting
</p>


<h3>References</h3>


<ul>
<li><p> Yeh CCM, Van Herle H, Keogh E. Matrix profile III: The matrix profile allows
visualization of salient subsequences in massive time series. Proc - IEEE Int Conf Data Mining,
ICDM. 2017;579-88.
</p>
</li></ul>


<ul>
<li><p> Hu B, Rakthanmanon T, Hao Y, Evans S, Lonardi S, Keogh E. Discovering the Intrinsic
Cardinality and Dimensionality of Time Series Using MDL. In: 2011 IEEE 11th International
Conference on Data Mining. IEEE; 2011. p. 1086-91.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/site/salientsubs/">https://sites.google.com/site/salientsubs/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># toy example
data &lt;- mp_toy_data$data[, 1]
mp &lt;- tsmp(data, window_size = 30, verbose = 0)
mps &lt;- salient_subsequences(mp, verbose = 0)
mds_data &lt;- salient_mds(mps)
plot(mds_data, main = "Multi dimensional scale")
</code></pre>

<hr>
<h2 id='salient_score'>Computes the F-Score of salient algorithm.</h2><span id='topic+salient_score'></span>

<h3>Description</h3>

<p>This score function is useful for testing several values of <code>n_bits</code> for MDL discretization and
checking against a known set of indexes. This increase the probability of better results on
relevant subsequence extraction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>salient_score(.mp, gtruth, verbose = getOption("tsmp.verbose", 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="salient_score_+3A_.mp">.mp</code></td>
<td>
<p>a Matrix Profile object.</p>
</td></tr>
<tr><td><code id="salient_score_+3A_gtruth">gtruth</code></td>
<td>
<p>a <code>vector</code> of <code>integers</code> with the indexes of relevant subsequences.</p>
</td></tr>
<tr><td><code id="salient_score_+3A_verbose">verbose</code></td>
<td>
<p>an <code>int</code>. (Default is <code>2</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>list</code> with <code>f_score</code>, <code>precision</code>, <code>recall</code> and <code>bits</code> used in the algorithm.
</p>


<h3>References</h3>


<ul>
<li><p> Yeh CCM, Van Herle H, Keogh E. Matrix profile III: The matrix profile allows
visualization of salient subsequences in massive time series. Proc - IEEE Int Conf Data Mining,
ICDM. 2017;579-88.
</p>
</li></ul>


<ul>
<li><p> Hu B, Rakthanmanon T, Hao Y, Evans S, Lonardi S, Keogh E. Discovering the Intrinsic
Cardinality and Dimensionality of Time Series Using MDL. In: 2011 IEEE 11th International
Conference on Data Mining. IEEE; 2011. p. 1086-91.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/site/salientsubs/">https://sites.google.com/site/salientsubs/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># toy example
data &lt;- mp_toy_data$data[, 1]
mp &lt;- tsmp(data, window_size = 30, verbose = 0)
mps &lt;- salient_subsequences(mp, n_bits = c(4, 6, 8), verbose = 0)
label_idx &lt;- seq(2, 500, by = 110) # fake data
salient_score(mps, label_idx, verbose = 0)
</code></pre>

<hr>
<h2 id='salient_subsequences'>Framework for retrieve salient subsequences from a dataset</h2><span id='topic+salient_subsequences'></span>

<h3>Description</h3>

<p>In order to allow a meaningful visualization in Multi-Dimensional Space (MDS), this function
retrieves the most relevant subsequences using Minimal Description Length (MDL) framework.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>salient_subsequences(
  .mp,
  data,
  n_bits = 8,
  n_cand = 10,
  exclusion_zone = NULL,
  verbose = getOption("tsmp.verbose", 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="salient_subsequences_+3A_.mp">.mp</code></td>
<td>
<p>a TSMP object of class <code>MatrixProfile</code>.</p>
</td></tr>
<tr><td><code id="salient_subsequences_+3A_data">data</code></td>
<td>
<p>the data used to build the Matrix Profile, if not embedded.</p>
</td></tr>
<tr><td><code id="salient_subsequences_+3A_n_bits">n_bits</code></td>
<td>
<p>an <code>int</code> or <code>vector</code> of <code>int</code>. Number of bits for MDL discretization. (Default is <code>8</code>).</p>
</td></tr>
<tr><td><code id="salient_subsequences_+3A_n_cand">n_cand</code></td>
<td>
<p>an <code>int</code>. number of candidate when picking the subsequence in each iteration.
(Default is <code>10</code>).</p>
</td></tr>
<tr><td><code id="salient_subsequences_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>if a <code>number</code> will be used instead of embedded value. (Default is <code>NULL</code>).</p>
</td></tr>
<tr><td><code id="salient_subsequences_+3A_verbose">verbose</code></td>
<td>
<p>an <code>int</code>. See details. (Default is <code>2</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>verbose</code> changes how much information is printed by this function; <code>0</code> means nothing,
<code>1</code> means text, <code>2</code> adds the progress bar, <code>3</code> adds the finish sound.
</p>


<h3>Value</h3>

<p>Returns the input <code>.mp</code> object with a new name <code>salient</code>. It contains: <code>indexes</code>, a <code>vector</code>
with the starting position of each subsequence, <code>idx_bit_size</code>, a <code>vector</code> with the associated
bitsize for each iteration and <code>bits</code> the value used as input on <code>n_bits</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Yeh CCM, Van Herle H, Keogh E. Matrix profile III: The matrix profile allows
visualization of salient subsequences in massive time series. Proc - IEEE Int Conf Data Mining,
ICDM. 2017;579-88.
</p>
</li></ul>


<ul>
<li><p> Hu B, Rakthanmanon T, Hao Y, Evans S, Lonardi S, Keogh E. Discovering the Intrinsic
Cardinality and Dimensionality of Time Series Using MDL. In: 2011 IEEE 11th International
Conference on Data Mining. IEEE; 2011. p. 1086-91.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/site/salientsubs/">https://sites.google.com/site/salientsubs/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># toy example
data &lt;- mp_toy_data$data[, 1]
mp &lt;- tsmp(data, window_size = 30, verbose = 0)
mps &lt;- salient_subsequences(mp, data, verbose = 0)

# full example
data &lt;- mp_meat_data$sub$data
w &lt;- mp_meat_data$sub$sub_len
mp &lt;- tsmp(data, window_size = w, verbose = 2, n_workers = 2)
mps &lt;- salient_subsequences(mp, data, n_bits = c(4, 6, 8), verbose = 2)


</code></pre>

<hr>
<h2 id='scrimp'>Anytime univariate SCRIMP++ algorithm</h2><span id='topic+scrimp'></span>

<h3>Description</h3>

<p>Computes the best so far Matrix Profile and Profile Index for Univariate Time Series.
DISCLAIMER: This algorithm still in development by its authors.
Join similarity, RMP and LMP not implemented yet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scrimp(
  ...,
  window_size,
  exclusion_zone = getOption("tsmp.exclusion_zone", 1/2),
  verbose = getOption("tsmp.verbose", 2),
  s_size = Inf,
  pre_scrimp = 1/4,
  pre_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scrimp_+3A_...">...</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code>.</p>
</td></tr>
<tr><td><code id="scrimp_+3A_window_size">window_size</code></td>
<td>
<p>an <code>int</code>. Size of the sliding window.</p>
</td></tr>
<tr><td><code id="scrimp_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>a <code>numeric</code>. Size of the exclusion zone, based on window size (default is
<code>1/2</code>). See details.</p>
</td></tr>
<tr><td><code id="scrimp_+3A_verbose">verbose</code></td>
<td>
<p>an <code>int</code>. See details. (Default is <code>2</code>).</p>
</td></tr>
<tr><td><code id="scrimp_+3A_s_size">s_size</code></td>
<td>
<p>a <code>numeric</code>. for anytime algorithm, represents the size (in observations) the
random calculation will occur (default is <code>Inf</code>).</p>
</td></tr>
<tr><td><code id="scrimp_+3A_pre_scrimp">pre_scrimp</code></td>
<td>
<p>a <code>numeric</code>. Set the pre-scrimp step based on <code>window_size</code>, if <code>0</code>, disables pre-scrimp.
(default is <code>1/4</code>).</p>
</td></tr>
<tr><td><code id="scrimp_+3A_pre_only">pre_only</code></td>
<td>
<p>a <code>logical</code>. Returns only the pre script data. (Default is <code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Matrix Profile, has the potential to revolutionize time series data mining because of its
generality, versatility, simplicity and scalability. In particular it has implications for time
series motif discovery, time series joins, shapelet discovery (classification), density
estimation, semantic segmentation, visualization, rule discovery, clustering etc. The anytime
SCRIMP computes the Matrix Profile and Profile Index in such manner that it can be stopped before
its complete calculation and return the best so far results allowing ultra-fast approximate
solutions. <code>verbose</code> changes how much information is printed by this function; <code>0</code> means nothing,
<code>1</code> means text, <code>2</code> adds the progress bar, <code>3</code> adds the finish sound. <code>exclusion_zone</code> is used to
avoid  trivial matches.
</p>


<h3>Value</h3>

<p>Returns a <code>MatrixProfile</code> object, a <code>list</code> with the matrix profile <code>mp</code>, profile index <code>pi</code>
left and right matrix profile <code>lmp</code>, <code>rmp</code> and profile index <code>lpi</code>, <code>rpi</code>, window size <code>w</code> and
exclusion zone <code>ez</code>.
</p>


<h3>References</h3>

<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other matrix profile computations: 
<code><a href="#topic+mstomp_par">mstomp_par</a>()</code>,
<code><a href="#topic+stamp_par">stamp_par</a>()</code>,
<code><a href="#topic+stomp_par">stomp_par</a>()</code>,
<code><a href="#topic+tsmp">tsmp</a>()</code>,
<code><a href="#topic+valmod">valmod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mp &lt;- scrimp(mp_toy_data$data[1:200, 1], window_size = 30, verbose = 0)

ref_data &lt;- mp_toy_data$data[, 1]
query_data &lt;- mp_toy_data$data[, 2]
# self similarity
mp &lt;- scrimp(ref_data, window_size = 30, s_size = round(nrow(ref_data) * 0.1))
# join similarity
mp &lt;- scrimp(ref_data, query_data, window_size = 30, s_size = round(nrow(query_data) * 0.1))


</code></pre>

<hr>
<h2 id='sdts_predict'>Framework for Scalable Dictionary learning for Time Series (SDTS) prediction function</h2><span id='topic+sdts_predict'></span>

<h3>Description</h3>

<p>This function trains a model that uses a dictionary to predict state changes. Differently from
<code><a href="#topic+fluss">fluss()</a></code>, it doesn't look for semantic changes (that may be several), but for binary states like
&quot;on&quot; or &quot;off&quot;. Think for example that a human annotator is pressing a switch any time he thinks
that the recorded data is relevant, and releases the switch when he thinks the data is noise. This
algorithm will learn the switching points (even better) and try to predict using new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdts_predict(model, data, window_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdts_predict_+3A_model">model</code></td>
<td>
<p>a model created by SDTS training function <code><a href="#topic+sdts_train">sdts_train()</a></code>.</p>
</td></tr>
<tr><td><code id="sdts_predict_+3A_data">data</code></td>
<td>
<p>a <code>vector</code> of <code>numeric</code>. Time series.</p>
</td></tr>
<tr><td><code id="sdts_predict_+3A_window_size">window_size</code></td>
<td>
<p>an <code>int</code>. The average sliding window size.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>vector</code> of <code>logical</code> with predicted annotations.
</p>


<h3>References</h3>


<ul>
<li><p> Yeh C-CM, Kavantzas N, Keogh E. Matrix profile IV: Using Weakly Labeled Time Series
to Predict Outcomes. Proc VLDB Endow. 2017 Aug 1;10(12):1802-12.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/view/weaklylabeled">https://sites.google.com/view/weaklylabeled</a>
</p>


<h3>See Also</h3>

<p>Other Scalable Dictionaries: 
<code><a href="#topic+sdts_score">sdts_score</a>()</code>,
<code><a href="#topic+sdts_train">sdts_train</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is a fast toy example and results are useless. For a complete result, run the code inside
#' Not run' section below.
w &lt;- c(110, 220)
subs &lt;- 11000:20000
tr_data &lt;- mp_test_data$train$data[subs]
tr_label &lt;- mp_test_data$train$label[subs]
te_data &lt;- mp_test_data$test$data[subs]
te_label &lt;- mp_test_data$test$label[subs]
model &lt;- sdts_train(tr_data, tr_label, w, verbose = 0)
predict &lt;- sdts_predict(model, te_data, round(mean(w)))
sdts_score(predict, te_label, 1)

windows &lt;- c(110, 220, 330)
model &lt;- sdts_train(mp_test_data$train$data, mp_test_data$train$label, windows, verbose = 0)
predict &lt;- sdts_predict(model, mp_test_data$test$data, round(mean(windows)))
sdts_score(predict, mp_test_data$test$label, 1)


</code></pre>

<hr>
<h2 id='sdts_score'>Computes the F-Score of a SDTS prediction</h2><span id='topic+sdts_score'></span>

<h3>Description</h3>

<p>Computes the F-Score of a SDTS prediction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdts_score(pred, gtruth, beta = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdts_score_+3A_pred">pred</code></td>
<td>
<p>a <code>vector</code> of <code>logical</code>. Predicted annotation from <code><a href="#topic+sdts_predict">sdts_predict()</a></code></p>
</td></tr>
<tr><td><code id="sdts_score_+3A_gtruth">gtruth</code></td>
<td>
<p>a <code>vector</code> of <code>logical</code>. Ground truth annotation.</p>
</td></tr>
<tr><td><code id="sdts_score_+3A_beta">beta</code></td>
<td>
<p>a <code>numeric</code>. See details. (default is <code>1</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>beta</code> is used to balance F-score towards recall (<code style="white-space: pre;">&#8288;&gt;1&#8288;</code>) or precision (<code style="white-space: pre;">&#8288;&lt;1&#8288;</code>).
</p>


<h3>Value</h3>

<p>Returns a <code>list</code> with <code>f_score</code>, <code>precision</code> and <code>recall</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Yeh C-CM, Kavantzas N, Keogh E. Matrix profile IV: Using Weakly Labeled Time Series
to Predict Outcomes. Proc VLDB Endow. 2017 Aug 1;10(12):1802-12.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/view/weaklylabeled">https://sites.google.com/view/weaklylabeled</a>
</p>


<h3>See Also</h3>

<p>Other Scalable Dictionaries: 
<code><a href="#topic+sdts_predict">sdts_predict</a>()</code>,
<code><a href="#topic+sdts_train">sdts_train</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is a fast toy example and results are useless. For a complete result, run the code inside
#' Not run' section below.
w &lt;- c(110, 220)
subs &lt;- 11000:20000
tr_data &lt;- mp_test_data$train$data[subs]
tr_label &lt;- mp_test_data$train$label[subs]
te_data &lt;- mp_test_data$test$data[subs]
te_label &lt;- mp_test_data$test$label[subs]
model &lt;- sdts_train(tr_data, tr_label, w, verbose = 0)
predict &lt;- sdts_predict(model, te_data, round(mean(w)))
sdts_score(predict, te_label, 1)

windows &lt;- c(110, 220, 330)
model &lt;- sdts_train(mp_test_data$train$data, mp_test_data$train$label, windows)
predict &lt;- sdts_predict(model, mp_test_data$test$data, round(mean(windows)))
sdts_score(predict, mp_test_data$test$label, 1)


</code></pre>

<hr>
<h2 id='sdts_train'>Framework for Scalable Dictionary learning for Time Series (SDTS) training function</h2><span id='topic+sdts_train'></span>

<h3>Description</h3>

<p>This function trains a model that uses a dictionary to predict state changes. Differently from
<code><a href="#topic+fluss">fluss()</a></code>, it doesn't look for semantic changes (that may be several), but for binary states like
&quot;on&quot; or &quot;off&quot;. Think for example that a human annotator is pressing a switch any time he thinks
that the recorded data is relevant, and releases the switch when he thinks the data is noise. This
algorithm will learn the switching points (even better) and try to predict using new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sdts_train(
  data,
  label,
  window_size,
  beta = 1,
  pat_max = Inf,
  parallel = FALSE,
  verbose = getOption("tsmp.verbose", 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sdts_train_+3A_data">data</code></td>
<td>
<p>a <code>vector</code> of <code>numeric</code>. Time series.</p>
</td></tr>
<tr><td><code id="sdts_train_+3A_label">label</code></td>
<td>
<p>a <code>vector</code> of <code>logical</code>. Annotations.</p>
</td></tr>
<tr><td><code id="sdts_train_+3A_window_size">window_size</code></td>
<td>
<p>an <code>int</code> or a <code>vector</code> of <code>int</code>. Sliding window sizes.</p>
</td></tr>
<tr><td><code id="sdts_train_+3A_beta">beta</code></td>
<td>
<p>a <code>numeric</code>. See details. (default is <code>1</code>).</p>
</td></tr>
<tr><td><code id="sdts_train_+3A_pat_max">pat_max</code></td>
<td>
<p>an <code>int</code>. Max number of shape features captured. (default is <code>Inf</code>).</p>
</td></tr>
<tr><td><code id="sdts_train_+3A_parallel">parallel</code></td>
<td>
<p>a <code>logical</code>. Use parallel computation inside (default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="sdts_train_+3A_verbose">verbose</code></td>
<td>
<p>an <code>int</code>. See details. (Default is <code>2</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>beta</code> is used to balance F-score towards recall (<code style="white-space: pre;">&#8288;&gt;1&#8288;</code>) or precision (<code style="white-space: pre;">&#8288;&lt;1&#8288;</code>). <code>verbose</code> changes
how much information is printed by this function; <code>0</code> means nothing, <code>1</code> means text, <code>2</code> adds the
progress bar, <code>3</code> adds the finish sound.
</p>


<h3>Value</h3>

<p>Returns a list with the learned dictionary <code>score</code> (estimated score), <code>score_hist</code>
(history of scores), <code>pattern</code> (shape features), <code>thold</code> (threshold values).
</p>


<h3>References</h3>


<ul>
<li><p> Yeh C-CM, Kavantzas N, Keogh E. Matrix profile IV: Using Weakly Labeled Time Series
to Predict Outcomes. Proc VLDB Endow. 2017 Aug 1;10(12):1802-12.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/view/weaklylabeled">https://sites.google.com/view/weaklylabeled</a>
</p>


<h3>See Also</h3>

<p>Other Scalable Dictionaries: 
<code><a href="#topic+sdts_predict">sdts_predict</a>()</code>,
<code><a href="#topic+sdts_score">sdts_score</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is a fast toy example and results are useless. For a complete result, run the code inside
#' Not run' section below.
w &lt;- c(110, 220)
subs &lt;- 11000:20000
tr_data &lt;- mp_test_data$train$data[subs]
tr_label &lt;- mp_test_data$train$label[subs]
te_data &lt;- mp_test_data$test$data[subs]
te_label &lt;- mp_test_data$test$label[subs]
model &lt;- sdts_train(tr_data, tr_label, w, verbose = 0)
predict &lt;- sdts_predict(model, te_data, round(mean(w)))
sdts_score(predict, te_label, 1)

windows &lt;- c(110, 220, 330)
model &lt;- sdts_train(mp_test_data$train$data, mp_test_data$train$label, windows)
predict &lt;- sdts_predict(model, mp_test_data$test$data, round(mean(windows)))
sdts_score(predict, mp_test_data$test$label, 1)

</code></pre>

<hr>
<h2 id='set_data'>Set/changes the data included in TSMP object.</h2><span id='topic+set_data'></span>

<h3>Description</h3>

<p>This may be useful if you want to include the data lately or remove the included data (set as <code>NULL</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_data(.mp, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_data_+3A_.mp">.mp</code></td>
<td>
<p>a TSMP object.</p>
</td></tr>
<tr><td><code id="set_data_+3A_data">data</code></td>
<td>
<p>a <code>matrix</code> (for one series) or a <code>list</code> of matrices (for two series).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns silently the original TSMP object with changed data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mp &lt;- tsmp(mp_toy_data$data[1:200, 1], window_size = 30, verbose = 0)
mp &lt;- set_data(mp, NULL)
</code></pre>

<hr>
<h2 id='simple_fast'>Compute the join similarity for Sound data</h2><span id='topic+simple_fast'></span>

<h3>Description</h3>

<p>Compute the join similarity for Sound data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simple_fast(
  ...,
  window_size,
  exclusion_zone = getOption("tsmp.exclusion_zone", 1/2),
  verbose = getOption("tsmp.verbose", 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simple_fast_+3A_...">...</code></td>
<td>
<p>a <code>matrix</code> of <code>numeric</code>, where each column is a time series. Accepts <code>list</code> and
<code>data.frame</code> too. If a second time series is supplied it will be a join matrix profile.</p>
</td></tr>
<tr><td><code id="simple_fast_+3A_window_size">window_size</code></td>
<td>
<p>an <code>int</code> with the size of the sliding window.</p>
</td></tr>
<tr><td><code id="simple_fast_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>a <code>numeric</code>. Size of the exclusion zone, based on window size (default is
<code>1/2</code>).</p>
</td></tr>
<tr><td><code id="simple_fast_+3A_verbose">verbose</code></td>
<td>
<p>an <code>int</code>. See details. (Default is <code>2</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>verbose</code> changes how much information is printed by this function; <code>0</code> means nothing, <code>1</code> means
text, <code>2</code> adds the progress bar, <code>3</code> adds the finish sound.
</p>


<h3>Value</h3>

<p>Returns a <code>SimpleMatrixProfile</code> object, a <code>list</code> with the matrix profile <code>mp</code>, profile index <code>pi</code>,
number of dimensions <code>n_dim</code>, window size <code>w</code> and exclusion zone <code>ez</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Silva D, Yeh C, Batista G, Keogh E. Simple: Assessing Music Similarity Using
Subsequences Joins. Proc 17th ISMIR Conf. 2016;23-30.
</p>
</li></ul>


<ul>
<li><p> Silva DF, Yeh C-CM, Zhu Y, Batista G, Keogh E. Fast Similarity Matrix Profile for
Music Analysis and Exploration. IEEE Trans Multimed. 2018;14(8):1-1.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/view/simple-fast">https://sites.google.com/view/simple-fast</a>
</p>
<p>Website: <a href="https://sites.google.com/site/ismir2016simple/home">https://sites.google.com/site/ismir2016simple/home</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>w &lt;- 30
data &lt;- mp_toy_data$data # 3 dimensions matrix
result &lt;- simple_fast(data, window_size = w, verbose = 0)
</code></pre>

<hr>
<h2 id='stamp_par'>Anytime univariate STAMP algorithm Parallel version</h2><span id='topic+stamp_par'></span><span id='topic+stamp'></span>

<h3>Description</h3>

<p>Computes the best so far Matrix Profile and Profile Index for Univariate Time Series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stamp_par(
  ...,
  window_size,
  exclusion_zone = getOption("tsmp.exclusion_zone", 1/2),
  verbose = getOption("tsmp.verbose", 2),
  s_size = Inf,
  n_workers = 2,
  weight = NULL
)

stamp(
  ...,
  window_size,
  exclusion_zone = getOption("tsmp.exclusion_zone", 1/2),
  verbose = getOption("tsmp.verbose", 2),
  s_size = Inf,
  weight = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stamp_par_+3A_...">...</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code>. If a second time series is supplied it will be a join matrix
profile.</p>
</td></tr>
<tr><td><code id="stamp_par_+3A_window_size">window_size</code></td>
<td>
<p>an <code>int</code>. Size of the sliding window.</p>
</td></tr>
<tr><td><code id="stamp_par_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>a <code>numeric</code>. Size of the exclusion zone, based on window size (default is
<code>1/2</code>). See details.</p>
</td></tr>
<tr><td><code id="stamp_par_+3A_verbose">verbose</code></td>
<td>
<p>an <code>int</code>. See details. (Default is <code>2</code>).</p>
</td></tr>
<tr><td><code id="stamp_par_+3A_s_size">s_size</code></td>
<td>
<p>a <code>numeric</code>. for anytime algorithm, represents the size (in observations) the
random calculation will occur (default is <code>Inf</code>).</p>
</td></tr>
<tr><td><code id="stamp_par_+3A_n_workers">n_workers</code></td>
<td>
<p>an <code>int</code>. Number of workers for parallel. (Default is <code>2</code>).</p>
</td></tr>
<tr><td><code id="stamp_par_+3A_weight">weight</code></td>
<td>
<p>a <code>vector</code> of <code>numeric</code> or <code>NULL</code> with the same length of the <code>window_size</code>. This is
a MASS extension to weight the query.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Matrix Profile, has the potential to revolutionize time series data mining because of its
generality, versatility, simplicity and scalability. In particular it has implications for time
series motif discovery, time series joins, shapelet discovery (classification), density
estimation, semantic segmentation, visualization, rule discovery, clustering etc. The anytime
STAMP computes the Matrix Profile and Profile Index in such manner that it can be stopped before
its complete calculation and return the best so far results allowing ultra-fast approximate
solutions. <code>verbose</code> changes how much information is printed by this function; <code>0</code> means nothing,
<code>1</code> means text, <code>2</code> adds the progress bar, <code>3</code> adds the finish sound. <code>exclusion_zone</code> is used to
avoid  trivial matches; if a query data is provided (join similarity), this parameter is ignored.
</p>


<h3>Value</h3>

<p>Returns a <code>MatrixProfile</code> object, a <code>list</code> with the matrix profile <code>mp</code>, profile index <code>pi</code>
left and right matrix profile <code>lmp</code>, <code>rmp</code> and profile index <code>lpi</code>, <code>rpi</code>, window size <code>w</code> and
exclusion zone <code>ez</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>stamp_par()</code>: Parallel version.
</p>
</li>
<li> <p><code>stamp()</code>: Single thread version.
</p>
</li></ul>


<h3>References</h3>


<ul>
<li><p> Yeh CCM, Zhu Y, Ulanova L, Begum N, Ding Y, Dau HA, et al. Matrix profile I: All
pairs similarity joins for time series: A unifying view that includes motifs, discords and
shapelets. Proc - IEEE Int Conf Data Mining, ICDM. 2017;1317-22.
</p>
</li></ul>


<ul>
<li><p> Zhu Y, Imamura M, Nikovski D, Keogh E. Matrix Profile VII: Time Series Chains: A
New Primitive for Time Series Data Mining. Knowl Inf Syst. 2018 Jun 2;1-27.
</p>
</li></ul>

<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other matrix profile computations: 
<code><a href="#topic+mstomp_par">mstomp_par</a>()</code>,
<code><a href="#topic+scrimp">scrimp</a>()</code>,
<code><a href="#topic+stomp_par">stomp_par</a>()</code>,
<code><a href="#topic+tsmp">tsmp</a>()</code>,
<code><a href="#topic+valmod">valmod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mp &lt;- stamp(mp_toy_data$data[1:200, 1], window_size = 30, verbose = 0)


#' # using threads
mp &lt;- stamp_par(mp_toy_data$data[1:200, 1], window_size = 30, verbose = 0)

ref_data &lt;- mp_toy_data$data[, 1]
query_data &lt;- mp_toy_data$data[, 2]
# self similarity
mp &lt;- stamp(ref_data, window_size = 30, s_size = round(nrow(ref_data) * 0.1))
# join similarity
mp &lt;- stamp(ref_data, query_data, window_size = 30, s_size = round(nrow(query_data) * 0.1))


</code></pre>

<hr>
<h2 id='stomp_par'>Univariate STOMP algorithm</h2><span id='topic+stomp_par'></span><span id='topic+stomp'></span>

<h3>Description</h3>

<p>Computes the Matrix Profile and Profile Index for Univariate Time Series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stomp_par(
  ...,
  window_size,
  exclusion_zone = getOption("tsmp.exclusion_zone", 1/2),
  verbose = getOption("tsmp.verbose", 2),
  n_workers = 2
)

stomp(
  ...,
  window_size,
  exclusion_zone = getOption("tsmp.exclusion_zone", 1/2),
  verbose = getOption("tsmp.verbose", 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stomp_par_+3A_...">...</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code>. If a second time series is supplied it will be a join matrix
profile.</p>
</td></tr>
<tr><td><code id="stomp_par_+3A_window_size">window_size</code></td>
<td>
<p>an <code>int</code>. Size of the sliding window.</p>
</td></tr>
<tr><td><code id="stomp_par_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>a <code>numeric</code>. Size of the exclusion zone, based on window size (default is
<code>1/2</code>). See details.</p>
</td></tr>
<tr><td><code id="stomp_par_+3A_verbose">verbose</code></td>
<td>
<p>an <code>int</code>. See details. (Default is <code>2</code>).</p>
</td></tr>
<tr><td><code id="stomp_par_+3A_n_workers">n_workers</code></td>
<td>
<p>an <code>int</code>. Number of workers for parallel. (Default is <code>2</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Matrix Profile, has the potential to revolutionize time series data mining because of its
generality, versatility, simplicity and scalability. In particular it has implications for time
series motif discovery, time series joins, shapelet discovery (classification), density
estimation, semantic segmentation, visualization, rule discovery, clustering etc. <code>verbose</code>
changes how much information is printed by this function; <code>0</code> means nothing, <code>1</code> means text, <code>2</code>
adds the progress bar, <code>3</code> adds the finish sound. <code>exclusion_zone</code> is used to avoid  trivial
matches; if a query data is provided (join similarity), this parameter is ignored.
</p>


<h3>Value</h3>

<p>Returns a <code>MatrixProfile</code> object, a <code>list</code> with the matrix profile <code>mp</code>, profile index <code>pi</code>
left and right matrix profile <code>lmp</code>, <code>rmp</code> and profile index <code>lpi</code>, <code>rpi</code>, window size <code>w</code> and
exclusion zone <code>ez</code>.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>stomp_par()</code>: Parallel version.
</p>
</li>
<li> <p><code>stomp()</code>: Single thread version.
</p>
</li></ul>


<h3>References</h3>


<ul>
<li><p> Zhu Y, Zimmerman Z, Senobari NS, Yeh CM, Funning G. Matrix Profile II : Exploiting
a Novel Algorithm and GPUs to Break the One Hundred Million Barrier for Time Series Motifs and
Joins. Icdm. 2016 Jan 22;54(1):739-48.
</p>
</li></ul>

<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other matrix profile computations: 
<code><a href="#topic+mstomp_par">mstomp_par</a>()</code>,
<code><a href="#topic+scrimp">scrimp</a>()</code>,
<code><a href="#topic+stamp_par">stamp_par</a>()</code>,
<code><a href="#topic+tsmp">tsmp</a>()</code>,
<code><a href="#topic+valmod">valmod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mp &lt;- stomp(mp_toy_data$data[1:200, 1], window_size = 30, verbose = 0)

#' # using threads
mp &lt;- stomp_par(mp_toy_data$data[1:400, 1], window_size = 30, verbose = 0)

ref_data &lt;- mp_toy_data$data[, 1]
query_data &lt;- mp_toy_data$data[, 2]
# self similarity
mp &lt;- stomp(ref_data, window_size = 30)
# join similarity
mp2 &lt;- stomp(ref_data, query_data, window_size = 30)

</code></pre>

<hr>
<h2 id='stompi_update'>Real-time STOMP algorithm</h2><span id='topic+stompi_update'></span>

<h3>Description</h3>

<p>Real-time STOMP algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stompi_update(.mp, new_data, history_size = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stompi_update_+3A_.mp">.mp</code></td>
<td>
<p>a TSMP object of class <code>MatrixProfile</code>.</p>
</td></tr>
<tr><td><code id="stompi_update_+3A_new_data">new_data</code></td>
<td>
<p>new data to append to original data.</p>
</td></tr>
<tr><td><code id="stompi_update_+3A_history_size">history_size</code></td>
<td>
<p>an <code>int</code> or <code>FALSE</code>. (Default is <code>FALSE</code>). Keep only this amount of data in
the object. The value is for the data, not the matrix profile. Notice that the <code>lmp</code>and <code>lpi</code> will
be inconsistent when repeatedly updating limiting the history size and thus will affect
the <code>mp</code> and <code>pi</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the input <code>.mp</code> updated with the new information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mp &lt;- tsmp(mp_toy_data$data[1:200, 1], window_size = 30, verbose = 0)
mpi &lt;- stompi_update(mp, mp_toy_data$data[201:300, 1])
mp &lt;- tsmp(mp_toy_data$data[1:300, 1], window_size = 30, verbose = 0)
all.equal(mp, mpi, check.attributes = FALSE)
</code></pre>

<hr>
<h2 id='tsmp'>Computes the Matrix Profile and Profile Index</h2><span id='topic+tsmp'></span>

<h3>Description</h3>

<p>This is a wrap function that makes easy to use all available algorithms to compute the Matrix
Profile and Profile Index for multiple purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsmp(
  ...,
  window_size,
  exclusion_zone = getOption("tsmp.exclusion_zone", 1/2),
  mode = c("stomp", "stamp", "simple", "mstomp", "scrimp", "valmod", "pmp"),
  verbose = getOption("tsmp.verbose", 2),
  n_workers = 1,
  s_size = Inf,
  must_dim = NULL,
  exc_dim = NULL,
  heap_size = 50,
  paa = 1,
  .keep_data = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsmp_+3A_...">...</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code>. If a second time series is supplied it will be a join matrix
profile (except for <code><a href="#topic+mstomp">mstomp()</a></code>).</p>
</td></tr>
<tr><td><code id="tsmp_+3A_window_size">window_size</code></td>
<td>
<p>an <code>int</code> with the size of the sliding window. Use a vector for Valmod.</p>
</td></tr>
<tr><td><code id="tsmp_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>a <code>numeric</code>. Size of the exclusion zone, based on window size (default is
<code>1/2</code>). See details.</p>
</td></tr>
<tr><td><code id="tsmp_+3A_mode">mode</code></td>
<td>
<p>the algorithm that will be used to compute the matrix profile. (Default is <code>stomp</code>).
See details.</p>
</td></tr>
<tr><td><code id="tsmp_+3A_verbose">verbose</code></td>
<td>
<p>an <code>int</code>. (Default is <code>2</code>). See details.</p>
</td></tr>
<tr><td><code id="tsmp_+3A_n_workers">n_workers</code></td>
<td>
<p>an <code>int</code>. Number of workers for parallel. (Default is <code>1</code>).</p>
</td></tr>
<tr><td><code id="tsmp_+3A_s_size">s_size</code></td>
<td>
<p>a <code>numeric</code>. for anytime algorithm, represents the size (in observations) the
random calculation will occur (default is <code>Inf</code>). See details.</p>
</td></tr>
<tr><td><code id="tsmp_+3A_must_dim">must_dim</code></td>
<td>
<p>an <code>int</code> or <code>vector</code> of which dimensions to forcibly include (default is <code>NULL</code>).
See details.</p>
</td></tr>
<tr><td><code id="tsmp_+3A_exc_dim">exc_dim</code></td>
<td>
<p>an <code>int</code> or <code>vector</code> of which dimensions to exclude (default is <code>NULL</code>). See
details.</p>
</td></tr>
<tr><td><code id="tsmp_+3A_heap_size">heap_size</code></td>
<td>
<p>an <code>int</code>. (Default is <code>50</code>). Size of the distance profile heap buffer.</p>
</td></tr>
<tr><td><code id="tsmp_+3A_paa">paa</code></td>
<td>
<p>an <code>int</code>. (Default is <code>1</code>). Factor of PAA reduction (2 == half of size)</p>
</td></tr>
<tr><td><code id="tsmp_+3A_.keep_data">.keep_data</code></td>
<td>
<p>a <code>logical</code>. (Default is <code>TRUE</code>). Keeps the data embedded to resultant object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Matrix Profile, has the potential to revolutionize time series data mining because
of its generality, versatility, simplicity and scalability. In particular it has implications
for time series motif discovery, time series joins, shapelet discovery (classification),
density estimation, semantic segmentation, visualization, rule discovery, clustering etc.
</p>
<p>The first algorithm invented was the <code><a href="#topic+stamp">stamp()</a></code> that using <code><a href="#topic+mass">mass()</a></code> as an ultra-fast Algorithm
for Similarity Search allowed to compute the Matrix Profile in reasonable time. One of its main
feature was its Anytime property which using a randomized approach could return a &quot;best-so-far&quot;
matrix that could give us the correct answer (using for example 1/10 of all iterations) almost
every time.
</p>
<p>The next algorithm was <code><a href="#topic+stomp">stomp()</a></code> that currently is the most used. Researchers noticed that the
dot products do not need to be recalculated from scratch for each subsequence. Instead, we can
reuse the values calculated for the first subsequence to make a faster calculation in the next
iterations. The idea is to make use of the intersections between the required products in
consecutive iterations. This approach reduced the time to compute the Matrix Profile to about
3% compared to <code><a href="#topic+stamp">stamp()</a></code>, but on the other hand, we lost the Anytime property.
</p>
<p>Currently there is a new algorithm that I'll not explain further here. It is called <code><a href="#topic+scrimp">scrimp()</a></code>,
and is as fast as <code><a href="#topic+stomp">stomp()</a></code>, and have the Anytime property. This algorithm is implemented in
this package, but still waiting for an article publication.
</p>
<p>Further, there is the <code><a href="#topic+mstomp">mstomp()</a></code> that computes a multidimensional Matrix Profile that allows to
meaningful MOTIF discovery in Multivariate Time Series. And <code><a href="#topic+simple_fast">simple_fast()</a></code> that also handles
Multivariate Time Series, but focused in Music Analysis and Exploration.
</p>
<p>The <code><a href="#topic+valmod">valmod()</a></code> uses a new pruning algorithm allowing a similarity search with a range of sliding
window sizes.
</p>
<p>The <code><a href="#topic+pmp">pmp()</a></code> is a new concept that creates several profiles from a range of windows.
</p>
<p>Some parameters are global across the algorithms:
</p>

<dl>
<dt>...</dt><dd><p>One or two time series (except for <code><a href="#topic+mstomp">mstomp()</a></code>). The second time series can be smaller than the first.</p>
</dd>
<dt>window_size</dt><dd><p>The sliding window.</p>
</dd>
<dt>exclusion_zone</dt><dd><p>Is used to avoid trivial matches; if a query data is provided
(join similarity), this parameter is ignored.</p>
</dd>
<dt>verbose</dt><dd><p>Changes how much information is printed by this function; <code>0</code> means nothing,
<code>1</code> means text, <code>2</code> adds the progress bar, <code>3</code> adds the finish sound.</p>
</dd>
<dt>n_workers</dt><dd><p>number of threads for parallel computing (except <code>simple_fast</code>, <code>scrimp</code> and <code>valmod</code>).
If the value is 2 or more, the '_par' version of the algorithm will be used.</p>
</dd>
</dl>

<p><code>s_size</code> is used only in Anytime algorithms: <code><a href="#topic+stamp">stamp()</a></code> and <code><a href="#topic+scrimp">scrimp()</a></code>.
<code>must_dim</code> and <code>exc_dim</code> are used only in <code><a href="#topic+mstomp">mstomp()</a></code>.
<code>heap_size</code> is used only for <code><a href="#topic+valmod">valmod()</a></code>
<code>mode</code> can be any of the following: <code>stomp</code>, <code>stamp</code>, <code>simple</code>, <code>mstomp</code>, <code>scrimp</code>, <code>valmod</code>, <code>pmp</code>.
</p>


<h3>Value</h3>

<p>Returns the matrix profile <code>mp</code> and profile index <code>pi</code>. It also returns the left and
right matrix profile <code>lmp</code>, <code>rmp</code> and profile index <code>lpi</code>, <code>rpi</code> that may be used to detect
Time Series Chains. <code><a href="#topic+mstomp">mstomp()</a></code> returns a multidimensional Matrix Profile.
</p>


<h3>References</h3>


<ul>
<li><p> Silva D, Yeh C, Batista G, Keogh E. Simple: Assessing Music Similarity Using
Subsequences Joins. Proc 17th ISMIR Conf. 2016;23-30.
</p>
</li></ul>


<ul>
<li><p> Silva DF, Yeh C-CM, Zhu Y, Batista G, Keogh E. Fast Similarity Matrix Profile for
Music Analysis and Exploration. IEEE Trans Multimed. 2018;14(8):1-1.
</p>
</li></ul>


<ul>
<li><p> Yeh CM, Kavantzas N, Keogh E. Matrix Profile VI : Meaningful Multidimensional Motif
Discovery.
</p>
</li></ul>


<ul>
<li><p> Yeh CCM, Zhu Y, Ulanova L, Begum N, Ding Y, Dau HA, et al. Matrix profile I: All
pairs similarity joins for time series: A unifying view that includes motifs, discords and
shapelets. Proc - IEEE Int Conf Data Mining, ICDM. 2017;1317-22.
</p>
</li></ul>


<ul>
<li><p> Zhu Y, Imamura M, Nikovski D, Keogh E. Matrix Profile VII: Time Series Chains: A
New Primitive for Time Series Data Mining. Knowl Inf Syst. 2018 Jun 2;1-27.
</p>
</li></ul>


<ul>
<li><p> Zhu Y, Zimmerman Z, Senobari NS, Yeh CM, Funning G. Matrix Profile II : Exploiting
a Novel Algorithm and GPUs to Break the One Hundred Million Barrier for Time Series Motifs and
Joins. Icdm. 2016 Jan 22;54(1):739-48.
</p>
</li></ul>

<p>Website: <a href="https://sites.google.com/view/simple-fast">https://sites.google.com/view/simple-fast</a>
</p>
<p>Website: <a href="https://sites.google.com/site/ismir2016simple/home">https://sites.google.com/site/ismir2016simple/home</a>
</p>
<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other matrix profile computations: 
<code><a href="#topic+mstomp_par">mstomp_par</a>()</code>,
<code><a href="#topic+scrimp">scrimp</a>()</code>,
<code><a href="#topic+stamp_par">stamp_par</a>()</code>,
<code><a href="#topic+stomp_par">stomp_par</a>()</code>,
<code><a href="#topic+valmod">valmod</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># default with [stomp()]
mp &lt;- tsmp(mp_toy_data$data[1:200, 1], window_size = 30, verbose = 0)

# Anytime STAMP
mp &lt;- tsmp(mp_toy_data$data[1:200, 1], window_size = 30, mode = "stamp", s_size = 50, verbose = 0)

# [mstomp()]
mp &lt;- tsmp(mp_toy_data$data[1:200, ], window_size = 30, mode = "mstomp", verbose = 0)

# [simple_fast()]
mp &lt;- tsmp(mp_toy_data$data[1:200, ], window_size = 30, mode = "simple", verbose = 0)

# parallel with [stomp_par()]
mp &lt;- tsmp(mp_test_data$train$data[1:1000, 1], window_size = 30, n_workers = 2, verbose = 0)

</code></pre>

<hr>
<h2 id='valmod'>Variable Length Motif Discovery</h2><span id='topic+valmod'></span>

<h3>Description</h3>

<p>Computes the Matrix Profile and Profile Index for a range of query window sizes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>valmod(
  ...,
  window_min,
  window_max,
  heap_size = 50,
  exclusion_zone = getOption("tsmp.exclusion_zone", 1/2),
  lb = TRUE,
  verbose = getOption("tsmp.verbose", 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="valmod_+3A_...">...</code></td>
<td>
<p>a <code>matrix</code> or a <code>vector</code>. If a second time series is supplied it will be a join matrix
profile.</p>
</td></tr>
<tr><td><code id="valmod_+3A_window_min">window_min</code></td>
<td>
<p>an <code>int</code>. Minimum size of the sliding window.</p>
</td></tr>
<tr><td><code id="valmod_+3A_window_max">window_max</code></td>
<td>
<p>an <code>int</code>. Maximum size of the sliding window.</p>
</td></tr>
<tr><td><code id="valmod_+3A_heap_size">heap_size</code></td>
<td>
<p>an <code>int</code>. (Default is <code>50</code>). Size of the distance profile heap buffer</p>
</td></tr>
<tr><td><code id="valmod_+3A_exclusion_zone">exclusion_zone</code></td>
<td>
<p>a <code>numeric</code>. Size of the exclusion zone, based on window size (default is
<code>1/2</code>). See details.</p>
</td></tr>
<tr><td><code id="valmod_+3A_lb">lb</code></td>
<td>
<p>a <code>logical</code>. (Default is <code>TRUE</code>). If <code>FALSE</code> all window sizes will be calculated using
STOMP instead of pruning. This is just for academic purposes.</p>
</td></tr>
<tr><td><code id="valmod_+3A_verbose">verbose</code></td>
<td>
<p>an <code>int</code>. See details. (Default is <code>2</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm uses an exact algorithm based on a novel lower bounding technique, which is
specifically designed for the motif discovery problem. <code>verbose</code> changes how much information
is printed by this function; <code>0</code> means nothing, <code>1</code> means text, <code>2</code> adds the progress bar,
<code>3</code> adds the finish sound. <code>exclusion_zone</code> is used to avoid  trivial matches; if a query data
is provided (join similarity), this parameter is ignored.
</p>
<p>Paper that implements <code>skimp()</code> suggests that window_max / window_min &gt; than 1.24 begins to
weakening pruning in <code>valmod()</code>.
</p>


<h3>Value</h3>

<p>Returns a <code>Valmod</code> object, a <code>list</code> with the matrix profile <code>mp</code>, profile index <code>pi</code>
left and right matrix profile <code>lmp</code>, <code>rmp</code> and profile index <code>lpi</code>, <code>rpi</code>, best window size <code>w</code>
for each index and exclusion zone <code>ez</code>. Additionally: <code>evolution_motif</code> the best motif distance
per window size, and non-length normalized versions of <code>mp</code>, <code>pi</code> and <code>w</code>: <code>mpnn</code>, <code>pinn</code> and <code>wnn</code>.
</p>


<h3>References</h3>


<ul>
<li><p> Linardi M, Zhu Y, Palpanas T, Keogh E. VALMOD: A Suite for Easy and Exact Detection
of Variable Length Motifs in Data Series. In: Proceedings of the 2018 International Conference
on Management of Data - SIGMOD '18. New York, New York, USA: ACM Press; 2018. p. 1757-60.
</p>
</li></ul>

<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other matrix profile computations: 
<code><a href="#topic+mstomp_par">mstomp_par</a>()</code>,
<code><a href="#topic+scrimp">scrimp</a>()</code>,
<code><a href="#topic+stamp_par">stamp_par</a>()</code>,
<code><a href="#topic+stomp_par">stomp_par</a>()</code>,
<code><a href="#topic+tsmp">tsmp</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mp &lt;- valmod(mp_toy_data$data[1:200, 1], window_min = 30, window_max = 40, verbose = 0)

ref_data &lt;- mp_toy_data$data[, 1]
query_data &lt;- mp_toy_data$data[, 2]
# self similarity
mp &lt;- valmod(ref_data, window_min = 30, window_max = 40)
# join similarity
mp &lt;- valmod(ref_data, query_data, window_min = 30, window_max = 40)


</code></pre>

<hr>
<h2 id='visualize'>Plots an object generated from one of the algorithms. In some cases multiple plots will be generated</h2><span id='topic+visualize'></span>

<h3>Description</h3>

<p>Plots an object generated from one of the algorithms. In some cases multiple plots will be generated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visualize(profile)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualize_+3A_profile">profile</code></td>
<td>
<p>a <code>MatrixProfile</code> or <code>PMP</code> object.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Website: <a href="http://www.cs.ucr.edu/~eamonn/MatrixProfile.html">http://www.cs.ucr.edu/~eamonn/MatrixProfile.html</a>
</p>


<h3>See Also</h3>

<p>Other Main API: 
<code><a href="#topic+analyze">analyze</a>()</code>,
<code><a href="#topic+compute">compute</a>()</code>,
<code><a href="#topic+discords">discords</a>()</code>,
<code><a href="#topic+motifs">motifs</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>result &lt;- compute(mp_toy_data$data[, 1], 80)
visualize(result)
</code></pre>

<hr>
<h2 id='write'>Write a TSMP object to JSON file.</h2><span id='topic+write'></span><span id='topic+write.MatrixProfile'></span><span id='topic+write.PMP'></span>

<h3>Description</h3>

<p>Write a TSMP object to JSON file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write(x, ...)

## S3 method for class 'MatrixProfile'
write(x, file, ...)

## S3 method for class 'PMP'
write(x, file, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_+3A_x">x</code></td>
<td>
<p>a <code>MatrixProfile</code> or <code>PMP</code> object. If not, the <code>base::write()</code> function will be called.</p>
</td></tr>
<tr><td><code id="write_+3A_...">...</code></td>
<td>
<p>other arguments to be passed forward.</p>
</td></tr>
<tr><td><code id="write_+3A_file">file</code></td>
<td>
<p>a <code>character</code> string with the output filename.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
result &lt;- compute(mp_toy_data$data[, 1], 80)

write(result, file = file.path(tempdir(), "output.json"))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
