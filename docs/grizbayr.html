<!DOCTYPE html><html><head><title>Help for package grizbayr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {grizbayr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calculate_multi_rev_per_session'><p>Calculate Multi Rev Per Session</p></a></li>
<li><a href='#calculate_total_cm'><p>Calculate Total CM</p></a></li>
<li><a href='#estimate_all_values'><p>Estimate All Values</p></a></li>
<li><a href='#estimate_lift'><p>Estimate Lift Distribution</p></a></li>
<li><a href='#estimate_lift_vs_baseline'><p>Estimate Lift vs Baseline</p></a></li>
<li><a href='#estimate_loss'><p>Estimate Loss</p></a></li>
<li><a href='#estimate_value_remaining'><p>Estimate Value Remaining</p></a></li>
<li><a href='#estimate_win_prob'><p>Estimate Win Probability</p></a></li>
<li><a href='#estimate_win_prob_given_posterior'><p>Estimate Win Probability Given Posterior Distribution</p></a></li>
<li><a href='#estimate_win_prob_vs_baseline'><p>Estimate Win Probability vs. Baseline</p></a></li>
<li><a href='#estimate_win_prob_vs_baseline_given_posterior'><p>Estimate Win Probability vs. Baseline Given Posterior</p></a></li>
<li><a href='#find_best_option'><p>Find Best Option</p></a></li>
<li><a href='#grizbayr-package'><p>grizbayr: Bayesian Inference for A|B and Bandit Marketing Tests</p></a></li>
<li><a href='#impute_missing_options'><p>Impute Missing Options</p></a></li>
<li><a href='#is_prior_valid'><p>Is Prior Valid</p></a></li>
<li><a href='#is_winner_max'><p>Is Winner Max</p></a></li>
<li><a href='#rdirichlet'><p>Random Dirichlet</p></a></li>
<li><a href='#sample_cm_per_click'><p>Sample CM Per Click</p></a></li>
<li><a href='#sample_conv_rate'><p>Sample Conversion Rate</p></a></li>
<li><a href='#sample_cpa'><p>Sample Cost Per Activation (CPA)</p></a></li>
<li><a href='#sample_cpc'><p>Sample Cost Per Click</p></a></li>
<li><a href='#sample_ctr'><p>Sample Click Through Rate</p></a></li>
<li><a href='#sample_from_posterior'><p>Sample From Posterior</p></a></li>
<li><a href='#sample_multi_rev_per_session'><p>Sample Multiple Revenue Per Session</p></a></li>
<li><a href='#sample_page_views_per_session'><p>Sample Page Views Per Session (Visit)</p></a></li>
<li><a href='#sample_response_rate'><p>Sample Response Rate</p></a></li>
<li><a href='#sample_rev_per_session'><p>Sample Rev Per Session</p></a></li>
<li><a href='#sample_session_duration'><p>Sample Session Duration</p></a></li>
<li><a href='#sample_total_cm'><p>Sample Total CM (Given Impression Count)</p></a></li>
<li><a href='#update_beta'><p>Update Beta</p></a></li>
<li><a href='#update_dirichlet'><p>Update Dirichlet Distribution</p></a></li>
<li><a href='#update_gamma'><p>Update Gamma</p></a></li>
<li><a href='#validate_data_values'><p>Validate Data Values</p></a></li>
<li><a href='#validate_input_column'><p>Validate Input Column</p></a></li>
<li><a href='#validate_input_df'><p>Validate Input DataFrame</p></a></li>
<li><a href='#validate_posterior_samples'><p>Validate Posterior Samples Dataframe</p></a></li>
<li><a href='#validate_priors'><p>Validate Priors</p></a></li>
<li><a href='#validate_wrt_option'><p>Validate With Respect To Option</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Inference for A|B and Bandit Marketing Tests</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.5</td>
</tr>
<tr>
<td>Author:</td>
<td>Ryan Angi</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ryan Angi &lt;angi.ryan@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Uses simple Bayesian conjugate prior update rules to calculate 
    the win probability of each option, value remaining in the test, and 
    percent lift over the baseline for various marketing objectives.
    References: 
    Fink, Daniel (1997) "A Compendium of Conjugate Priors" <a href="https://www.johndcook.com/CompendiumOfConjugatePriors.pdf">https://www.johndcook.com/CompendiumOfConjugatePriors.pdf</a>.
    Stucchio, Chris (2015) "Bayesian A/B Testing at VWO" <a href="https://vwo.com/downloads/VWO_SmartStats_technical_whitepaper.pdf">https://vwo.com/downloads/VWO_SmartStats_technical_whitepaper.pdf</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>purrr, dplyr, tidyr (&ge; 1.0.0), magrittr, tibble, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>spelling, knitr, testthat (&ge; 2.1.0), rmarkdown</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rangi513/grizbayr">https://github.com/rangi513/grizbayr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rangi513/grizbayr/issues">https://github.com/rangi513/grizbayr/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-09 16:41:06 UTC; rangi</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-09 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='calculate_multi_rev_per_session'>Calculate Multi Rev Per Session</h2><span id='topic+calculate_multi_rev_per_session'></span>

<h3>Description</h3>

<p>Calculate Multi Rev Per Session
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_multi_rev_per_session(conv_rates, inverse_rev_A, inverse_rev_B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_multi_rev_per_session_+3A_conv_rates">conv_rates</code></td>
<td>
<p>Dirichlet samples containing a tibble with columns alpha_1, alpha_2, and alpha_0</p>
</td></tr>
<tr><td><code id="calculate_multi_rev_per_session_+3A_inverse_rev_a">inverse_rev_A</code></td>
<td>
<p>Vector of inverse revenue samples from A conversion type</p>
</td></tr>
<tr><td><code id="calculate_multi_rev_per_session_+3A_inverse_rev_b">inverse_rev_B</code></td>
<td>
<p>Vector of inverse revenue samples from B conversion type</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of samples (dbl)
</p>

<hr>
<h2 id='calculate_total_cm'>Calculate Total CM</h2><span id='topic+calculate_total_cm'></span>

<h3>Description</h3>

<p>Calculate Total CM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_total_cm(rev_per_click, cost_per_click, expected_clicks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_total_cm_+3A_rev_per_click">rev_per_click</code></td>
<td>
<p>vector of rev per click samples</p>
</td></tr>
<tr><td><code id="calculate_total_cm_+3A_cost_per_click">cost_per_click</code></td>
<td>
<p>vector of cost per click (cpc) samples</p>
</td></tr>
<tr><td><code id="calculate_total_cm_+3A_expected_clicks">expected_clicks</code></td>
<td>
<p>vector of expected clicks (expected CTR * fixed impressions)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of CM estimates (dbl)
</p>

<hr>
<h2 id='estimate_all_values'>Estimate All Values</h2><span id='topic+estimate_all_values'></span>

<h3>Description</h3>

<p>Efficiently estimates all values at once so the posterior only need to be
sampled one time. This function will return as a list win probability,
value remaining, estimated percent lift with respect to the provided option,
and the win probability of the best option vs the provided option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_all_values(
  input_df,
  distribution,
  wrt_option_lift,
  priors = list(),
  wrt_option_vr = NULL,
  loss_threshold = 0.95,
  lift_threshold = 0.7,
  metric = "lift"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_all_values_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str) and various other columns
depending on the distribution type. See vignette for more details.</p>
</td></tr>
<tr><td><code id="estimate_all_values_+3A_distribution">distribution</code></td>
<td>
<p>String of the distribution name</p>
</td></tr>
<tr><td><code id="estimate_all_values_+3A_wrt_option_lift">wrt_option_lift</code></td>
<td>
<p>String: the option lift and win probability is calculated
with respect to (wrt). Required.</p>
</td></tr>
<tr><td><code id="estimate_all_values_+3A_priors">priors</code></td>
<td>
<p>Optional list of priors. Defaults will be use otherwise.</p>
</td></tr>
<tr><td><code id="estimate_all_values_+3A_wrt_option_vr">wrt_option_vr</code></td>
<td>
<p>String: the option against which loss (value remaining)
is calculated. If NULL the best option will be used. (optional)</p>
</td></tr>
<tr><td><code id="estimate_all_values_+3A_loss_threshold">loss_threshold</code></td>
<td>
<p>The confidence interval specifying what the &quot;worst case scenario&quot; should be.
Defaults to 95%. (optional)</p>
</td></tr>
<tr><td><code id="estimate_all_values_+3A_lift_threshold">lift_threshold</code></td>
<td>
<p>The confidence interval specifying how likely the lift is to be true.
Defaults to 70%. (optional)</p>
</td></tr>
<tr><td><code id="estimate_all_values_+3A_metric">metric</code></td>
<td>
<p>string the type of loss.
absolute will be the difference, on the outcome scale. 0 when best = wrt_option
lift will be the (best - wrt_option) / wrt_option, 0 when best = wrt_option
relative_risk will be the ratio best/wrt_option, 1 when best = wrt_option</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TODO: Add high density credible intervals to this output for each option.
</p>


<h3>Value</h3>

<p>A list with 4 named items: Win Probability, Value Remaining,
Lift vs Baseline, and Win Probability vs Baseline.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
input_df &lt;- data.frame(option_name = c("A", "B", "C"),
    sum_clicks = c(1000, 1000, 1000),
    sum_conversions = c(100, 120, 110), stringsAsFactors = FALSE)
estimate_all_values(input_df, distribution = "conversion_rate", wrt_option_lift = "A")

## End(Not run)

</code></pre>

<hr>
<h2 id='estimate_lift'>Estimate Lift Distribution</h2><span id='topic+estimate_lift'></span>

<h3>Description</h3>

<p>Estimates lift distribution vector from posterior samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_lift(posterior_samples, distribution, wrt_option, metric = "lift")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_lift_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>Tibble returned from sample_from_posterior with 3 columns
'option_name', 'samples', and 'sample_id'.</p>
</td></tr>
<tr><td><code id="estimate_lift_+3A_distribution">distribution</code></td>
<td>
<p>String of the distribution name</p>
</td></tr>
<tr><td><code id="estimate_lift_+3A_wrt_option">wrt_option</code></td>
<td>
<p>string the option lift is calculated with respect to (wrt). Required.</p>
</td></tr>
<tr><td><code id="estimate_lift_+3A_metric">metric</code></td>
<td>
<p>string the type of lift.
'absolute&ldquo; will be the difference, on the outcome scale. 0 when best = wrt_option
'lift&ldquo; will be the (best - wrt_option) / wrt_option, 0 when best = wrt_option
'relative_risk&ldquo; will be the ratio best/wrt_option, 1 when best = wrt_option</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, the lift distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Requires posterior_samples dataframe. See `sample_from_posterior()`
# for an example.

## Not run: 
estimate_lift(posterior_samples = posterior_samples,
              distribution = "conversion_rate",
              wrt_option = "A",
              metric = "lift")

## End(Not run)

</code></pre>

<hr>
<h2 id='estimate_lift_vs_baseline'>Estimate Lift vs Baseline</h2><span id='topic+estimate_lift_vs_baseline'></span>

<h3>Description</h3>

<p>Estimate Lift vs Baseline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_lift_vs_baseline(
  input_df,
  distribution,
  priors = list(),
  wrt_option,
  metric = "lift",
  threshold = 0.7
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_lift_vs_baseline_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str) and various other columns
depending on the distribution type. See vignette for more details.</p>
</td></tr>
<tr><td><code id="estimate_lift_vs_baseline_+3A_distribution">distribution</code></td>
<td>
<p>String of the distribution name</p>
</td></tr>
<tr><td><code id="estimate_lift_vs_baseline_+3A_priors">priors</code></td>
<td>
<p>Optional list of priors. Defaults will be use otherwise.</p>
</td></tr>
<tr><td><code id="estimate_lift_vs_baseline_+3A_wrt_option">wrt_option</code></td>
<td>
<p>string the option loss is calculated with respect to (wrt). Required.</p>
</td></tr>
<tr><td><code id="estimate_lift_vs_baseline_+3A_metric">metric</code></td>
<td>
<p>string the type of loss.
absolute will be the difference, on the outcome scale. 0 when best = wrt_option
lift will be the (best - wrt_option) / wrt_option, 0 when best = wrt_option
relative_risk will be the ratio best/wrt_option, 1 when best = wrt_option</p>
</td></tr>
<tr><td><code id="estimate_lift_vs_baseline_+3A_threshold">threshold</code></td>
<td>
<p>Lift percentage threshold between 0 and 1. (0.7
threshold is &quot;at least 70% lift&quot;). Defaults to 0.7.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value remaining at the specified threshold
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_df &lt;- tibble::tibble(option_name = c("A", "B", "C"),
    sum_clicks = c(1000, 1000, 1000),
    sum_conversions = c(100, 120, 110))
estimate_lift_vs_baseline(input_df, distribution = "conversion_rate", wrt_option = "A")

</code></pre>

<hr>
<h2 id='estimate_loss'>Estimate Loss</h2><span id='topic+estimate_loss'></span>

<h3>Description</h3>

<p>Estimate Loss
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_loss(
  posterior_samples,
  distribution,
  wrt_option = NULL,
  metric = c("absolute", "lift", "relative_risk")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_loss_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>Tibble: returned from sample_from_posterior with 3 columns
'option_name', 'samples', and 'sample_id'.</p>
</td></tr>
<tr><td><code id="estimate_loss_+3A_distribution">distribution</code></td>
<td>
<p>String: the name of the distribution</p>
</td></tr>
<tr><td><code id="estimate_loss_+3A_wrt_option">wrt_option</code></td>
<td>
<p>String: the option loss is calculated with respect to (wrt). If NULL, the best option will be chosen.</p>
</td></tr>
<tr><td><code id="estimate_loss_+3A_metric">metric</code></td>
<td>
<p>String: the type of loss.
absolute will be the difference, on the outcome scale. 0 when best = wrt_option
lift will be the (best - wrt_option) / wrt_option, 0 when best = wrt_option
relative_risk will be the ratio best/wrt_option, 1 when best = wrt_option</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric, the loss distribution
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Requires posterior_samples dataframe. See `sample_from_posterior()`
# for an example.

## Not run: 
estimate_loss(posterior_samples = posterior_samples, distribution = "conversion_rate")

## End(Not run)
</code></pre>

<hr>
<h2 id='estimate_value_remaining'>Estimate Value Remaining</h2><span id='topic+estimate_value_remaining'></span>

<h3>Description</h3>

<p>Estimates value remaining or loss (in terms of percent lift, absolute, or relative).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_value_remaining(
  input_df,
  distribution,
  priors = list(),
  wrt_option = NULL,
  metric = "lift",
  threshold = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_value_remaining_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str) and various other columns
depending on the distribution type. See vignette for more details.</p>
</td></tr>
<tr><td><code id="estimate_value_remaining_+3A_distribution">distribution</code></td>
<td>
<p>String of the distribution name</p>
</td></tr>
<tr><td><code id="estimate_value_remaining_+3A_priors">priors</code></td>
<td>
<p>Optional list of priors. Defaults will be use otherwise.</p>
</td></tr>
<tr><td><code id="estimate_value_remaining_+3A_wrt_option">wrt_option</code></td>
<td>
<p>string the option loss is calculated with respect to (wrt). If NULL, the best option will be chosen.</p>
</td></tr>
<tr><td><code id="estimate_value_remaining_+3A_metric">metric</code></td>
<td>
<p>string the type of loss.
absolute will be the difference, on the outcome scale. 0 when best = wrt_option
lift will be the (best - wrt_option) / wrt_option, 0 when best = wrt_option
relative_risk will be the ratio best/wrt_option, 1 when best = wrt_option</p>
</td></tr>
<tr><td><code id="estimate_value_remaining_+3A_threshold">threshold</code></td>
<td>
<p>The confidence interval specifying what the &quot;worst case scenario should be.
Defaults to 95%. (optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric value remaining at the specified threshold
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_df &lt;- tibble::tibble(option_name = c("A", "B", "C"),
    sum_clicks = c(1000, 1000, 1000),
    sum_conversions = c(100, 120, 110))
estimate_value_remaining(input_df, distribution = "conversion_rate")
estimate_value_remaining(input_df,
    distribution = "conversion_rate",
    threshold = 0.99)
estimate_value_remaining(input_df,
    distribution = "conversion_rate",
    wrt_option = "A",
    metric = "absolute")

</code></pre>

<hr>
<h2 id='estimate_win_prob'>Estimate Win Probability</h2><span id='topic+estimate_win_prob'></span>

<h3>Description</h3>

<p>Creates a tibble of win probabilities for each option based on the data observed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_win_prob(input_df, distribution, priors = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_win_prob_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str) and various other columns
depending on the distribution type. See vignette for more details.</p>
</td></tr>
<tr><td><code id="estimate_win_prob_+3A_distribution">distribution</code></td>
<td>
<p>String of the distribution name</p>
</td></tr>
<tr><td><code id="estimate_win_prob_+3A_priors">priors</code></td>
<td>
<p>Optional list of priors. Defaults will be use otherwise.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>tibble object with 2 columns: 'option_name'
and 'win_probability' formatted as a percent
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_df &lt;- tibble::tibble(
   option_name = c("A", "B"),
   sum_clicks = c(1000, 1000),
   sum_conversions = c(100, 120)
)
estimate_win_prob(input_df, "conversion_rate")

</code></pre>

<hr>
<h2 id='estimate_win_prob_given_posterior'>Estimate Win Probability Given Posterior Distribution</h2><span id='topic+estimate_win_prob_given_posterior'></span>

<h3>Description</h3>

<p>Estimate Win Probability Given Posterior Distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_win_prob_given_posterior(posterior_samples, winner_is_max = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_win_prob_given_posterior_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>Tibble of data in long form with 2 columns
'option_name' and 'samples'</p>
</td></tr>
<tr><td><code id="estimate_win_prob_given_posterior_+3A_winner_is_max">winner_is_max</code></td>
<td>
<p>Boolean. This should almost always be TRUE. If a larger number is better
then this should be TRUE. This should be FALSE for metrics such as CPA or CPC where a higher cost
is not necessarily better.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble of each option_name and the win probability expressed as a percentage and a decimal 'raw'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Requires posterior_samples dataframe. See `sample_from_posterior()`
# for an example.
## Not run: 
estimate_win_prob_given_posterior(posterior_samples = posterior_samples)
estimate_win_prob_given_posterior(
    posterior_samples = posterior_samples,
    winner_is_max = TRUE
)

## End(Not run)

</code></pre>

<hr>
<h2 id='estimate_win_prob_vs_baseline'>Estimate Win Probability vs. Baseline</h2><span id='topic+estimate_win_prob_vs_baseline'></span>

<h3>Description</h3>

<p>Calculates the win probability of the best option compared to a single other option
given an input_df
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_win_prob_vs_baseline(
  input_df,
  distribution,
  priors = list(),
  wrt_option
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_win_prob_vs_baseline_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str) and various other columns
depending on the distribution type. See vignette for more details.</p>
</td></tr>
<tr><td><code id="estimate_win_prob_vs_baseline_+3A_distribution">distribution</code></td>
<td>
<p>String of the distribution name</p>
</td></tr>
<tr><td><code id="estimate_win_prob_vs_baseline_+3A_priors">priors</code></td>
<td>
<p>Optional list of priors. Defaults will be use otherwise.</p>
</td></tr>
<tr><td><code id="estimate_win_prob_vs_baseline_+3A_wrt_option">wrt_option</code></td>
<td>
<p>string the option win prob is calculated with respect to (wrt). Required.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble of each option_name and the win probability expressed as a percentage and a decimal 'raw'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_df &lt;- tibble::tibble(
    option_name = c("A", "B", "C"),
    sum_clicks = c(1000, 1000, 1000),
    sum_conversions = c(100, 120, 110)
)
estimate_win_prob_vs_baseline(input_df = input_df,
    distribution = "conversion_rate",
    wrt_option = "B")

</code></pre>

<hr>
<h2 id='estimate_win_prob_vs_baseline_given_posterior'>Estimate Win Probability vs. Baseline Given Posterior</h2><span id='topic+estimate_win_prob_vs_baseline_given_posterior'></span>

<h3>Description</h3>

<p>Calculates the win probability of the best option compared to a single other option
given a posterior distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_win_prob_vs_baseline_given_posterior(
  posterior_samples,
  distribution,
  wrt_option
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_win_prob_vs_baseline_given_posterior_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>Tibble returned from sample_from_posterior with 3 columns
'option_name', 'samples', and 'sample_id'.</p>
</td></tr>
<tr><td><code id="estimate_win_prob_vs_baseline_given_posterior_+3A_distribution">distribution</code></td>
<td>
<p>String: the distribution name</p>
</td></tr>
<tr><td><code id="estimate_win_prob_vs_baseline_given_posterior_+3A_wrt_option">wrt_option</code></td>
<td>
<p>String: the option to compare against the best option.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Tibble of each option_name and the win probability expressed as a percentage and a decimal 'raw'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Requires posterior_samples dataframe. See `sample_from_posterior()`
# for an example.
## Not run: 
estimate_win_prob_vs_baseline_given_posterior(
    posterior_samples = posterior_samples,
    distribution = "conversion_rate",
    wrt_option = "A")

## End(Not run)

</code></pre>

<hr>
<h2 id='find_best_option'>Find Best Option</h2><span id='topic+find_best_option'></span>

<h3>Description</h3>

<p>Samples from posterior, calculates win probability, and selects the best option.
Note: this can be inefficient if you already have the win probability dataframe.
Only use this if that has not already been calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_best_option(posterior_samples, distribution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_best_option_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>Tibble returned from sample_from_posterior with 3 columns
'option_name', 'samples', and 'sample_id'.</p>
</td></tr>
<tr><td><code id="find_best_option_+3A_distribution">distribution</code></td>
<td>
<p>String: name of the distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String: the best option name
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Requires posterior distribution
## Not run: 
find_best_option(posterior_samples = posterior_samples, distribution = "conversion_rate")

## End(Not run)
</code></pre>

<hr>
<h2 id='grizbayr-package'>grizbayr: Bayesian Inference for A|B and Bandit Marketing Tests</h2><span id='topic+grizbayr'></span><span id='topic+grizbayr-package'></span>

<h3>Description</h3>

<p>Uses simple Bayesian conjugate prior update rules to calculate the win probability of each option, value remaining in the test, and percent lift over the baseline for various marketing objectives. References: Fink, Daniel (1997) &quot;A Compendium of Conjugate Priors&quot; <a href="https://www.johndcook.com/CompendiumOfConjugatePriors.pdf">https://www.johndcook.com/CompendiumOfConjugatePriors.pdf</a>. Stucchio, Chris (2015) &quot;Bayesian A/B Testing at VWO&quot; <a href="https://vwo.com/downloads/VWO_SmartStats_technical_whitepaper.pdf">https://vwo.com/downloads/VWO_SmartStats_technical_whitepaper.pdf</a>.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/rangi513/grizbayr">https://github.com/rangi513/grizbayr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/rangi513/grizbayr/issues">https://github.com/rangi513/grizbayr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='impute_missing_options'>Impute Missing Options</h2><span id='topic+impute_missing_options'></span>

<h3>Description</h3>

<p>When win probability is calculated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>impute_missing_options(posterior_samples, wp_raw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="impute_missing_options_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>Tibble of data in long form with 2 columns
'option_name' and 'samples'</p>
</td></tr>
<tr><td><code id="impute_missing_options_+3A_wp_raw">wp_raw</code></td>
<td>
<p>Tibble of win probabilities with the columns:
'option_name' and 'win_prob_raw'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>wp_raw table with new rows if option names were missing.
</p>

<hr>
<h2 id='is_prior_valid'>Is Prior Valid</h2><span id='topic+is_prior_valid'></span>

<h3>Description</h3>

<p>Checks if a single valid prior name is in the list of prior values and if
that prior value from the list is greater than 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_prior_valid(priors_list, valid_prior)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_prior_valid_+3A_priors_list">priors_list</code></td>
<td>
<p>A list of valid priors</p>
</td></tr>
<tr><td><code id="is_prior_valid_+3A_valid_prior">valid_prior</code></td>
<td>
<p>A character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean (TRUE/FALSE)
</p>

<hr>
<h2 id='is_winner_max'>Is Winner Max</h2><span id='topic+is_winner_max'></span>

<h3>Description</h3>

<p>Determines if the max or min function should be used for win probability.
If CPA or CPC distribution, lower is better, else higher number is better.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_winner_max(distribution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_winner_max_+3A_distribution">distribution</code></td>
<td>
<p>String: the name of the distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean TRUE/FALSE
</p>

<hr>
<h2 id='rdirichlet'>Random Dirichlet</h2><span id='topic+rdirichlet'></span>

<h3>Description</h3>

<p>Randomly samples a vector of length n from a dirichlet distribution parameterized by a vector of alphas
PDF of Gamma with scale = 1 : f(x)= 1/(Gamma(a)) x^(a-1) e^-(x)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdirichlet(n, alphas_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdirichlet_+3A_n">n</code></td>
<td>
<p>integer, the number of samples</p>
</td></tr>
<tr><td><code id="rdirichlet_+3A_alphas_list">alphas_list</code></td>
<td>
<p>Named List of Integers: parameters of the dirichlet,
interpreted as the number of success of each outcome</p>
</td></tr>
</table>


<h3>Value</h3>

<p>n x length(alphas) named tibble representing the probability of observing each outcome
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rdirichlet(100, list(a = 20, b = 15, c = 60))

</code></pre>

<hr>
<h2 id='sample_cm_per_click'>Sample CM Per Click</h2><span id='topic+sample_cm_per_click'></span>

<h3>Description</h3>

<p>Adds 4 new nested columns to the input_df: 'beta_params',
'gamma_params_rev', 'gamma_params_cost'and 'samples'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_cm_per_click(input_df, priors, n_samples = 50000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_cm_per_click_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str), sum_conversions (dbl), sum_revenue (dbl),
and sum_clicks (dbl).</p>
</td></tr>
<tr><td><code id="sample_cm_per_click_+3A_priors">priors</code></td>
<td>
<p>Optional list of priors alpha0, beta0 for Beta, k0, theta0 for Gamma Inverse Revenue,
and k01, theta01 for Gamma Cost (uses alternate priors so they can be different from Revenue).
Default <code class="reqn">Beta(1,1)</code> and <code class="reqn">Gamma(1, 250)</code> will be use otherwise.</p>
</td></tr>
<tr><td><code id="sample_cm_per_click_+3A_n_samples">n_samples</code></td>
<td>
<p>Optional integer value. Defaults to 50,000 samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'beta_params' and 'gamma_params_rev' in each row should be a
tibble of length 2 (<code class="reqn">\alpha</code> and <code class="reqn">\beta</code> parameters
and <code class="reqn">k</code> and <code class="reqn">\theta</code> parameters)
'samples' in each row should be a tibble of length 'n_samples'
</p>
<p>See update_rules vignette for a mathematical representation.
</p>
<p style="text-align: center;"><code class="reqn">CMPerClick = ConversionsPerClick * RevPerConversion - CostPerClick</code>
</p>



<h3>Value</h3>

<p>input_df with 4 new nested columns 'beta_params', 'gamma_params_rev',
'gamma_params_cost', and 'samples'
</p>

<hr>
<h2 id='sample_conv_rate'>Sample Conversion Rate</h2><span id='topic+sample_conv_rate'></span>

<h3>Description</h3>

<p>Adds 2 new nested columns to the input_df: 'beta_params' and 'samples'
'beta_params' in each row should be a tibble of length 2 (<code class="reqn">\alpha</code>
and <code class="reqn">\beta</code> parameters)
'samples' in each row should be a tibble of length 'n_samples'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_conv_rate(input_df, priors, n_samples = 50000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_conv_rate_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str),
sum_conversions (dbl), and sum_clicks (dbl).</p>
</td></tr>
<tr><td><code id="sample_conv_rate_+3A_priors">priors</code></td>
<td>
<p>Optional list of priors alpha0 and beta0.
Default <code class="reqn">Beta(1,1)</code> will be use otherwise.</p>
</td></tr>
<tr><td><code id="sample_conv_rate_+3A_n_samples">n_samples</code></td>
<td>
<p>Optional integer value. Defaults to 50,000 samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See update_rules vignette for a mathematical representation.
</p>
<p style="text-align: center;"><code class="reqn">conversion_i ~ Bernoulli(\phi)</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi ~ Beta(\alpha, \beta)</code>
</p>

<p>Conversion Rate is sampled from a Beta distribution with a Binomial likelihood
of an individual converting.
</p>


<h3>Value</h3>

<p>input_df with 2 new nested columns 'beta_params' and 'samples'
</p>

<hr>
<h2 id='sample_cpa'>Sample Cost Per Activation (CPA)</h2><span id='topic+sample_cpa'></span>

<h3>Description</h3>

<p>Adds 3 new nested columns to the input_df: 'beta_params', 'gamma_params', and 'samples'
'beta_params' and 'gamma_params' in each row should be a tibble of length 2 (<code class="reqn">\alpha</code>
and <code class="reqn">\beta</code> parameters and <code class="reqn">k</code> and <code class="reqn">\theta</code> parameters)
'samples' in each row should be a tibble of length 'n_samples'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_cpa(input_df, priors, n_samples = 50000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_cpa_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str), sum_conversions (dbl),
sum_cost (dbl), and sum_clicks (dbl).</p>
</td></tr>
<tr><td><code id="sample_cpa_+3A_priors">priors</code></td>
<td>
<p>Optional list of priors alpha0, beta0 for Beta and k0, theta0
for Gamma.
Default <code class="reqn">Beta(1,1)</code> and <code class="reqn">Gamma(1, 250)</code> will be use otherwise.</p>
</td></tr>
<tr><td><code id="sample_cpa_+3A_n_samples">n_samples</code></td>
<td>
<p>Optional integer value. Defaults to 50,000 samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See update_rules vignette for a mathematical representation.
This is a combination of a Beta-Bernoulli update and a Gamma-Exponential update.
</p>
<p style="text-align: center;"><code class="reqn">conversion_i ~ Bernoulli(\phi)</code>
</p>

<p style="text-align: center;"><code class="reqn">cpc_i ~ Exponential(\lambda)</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi ~ Beta(\alpha, \beta)</code>
</p>

<p style="text-align: center;"><code class="reqn">\lambda ~ Gamma(k, \theta)</code>
</p>

<p style="text-align: center;"><code class="reqn">cpa_i ~ 1/ (Bernoulli(\phi) * Exponential(\lambda))</code>
</p>

<p style="text-align: center;"><code class="reqn">averageCPA ~ 1/(\phi\lambda)</code>
</p>

<p>Conversion Rate is sampled from a Beta distribution with a Binomial likelihood
of an individual converting.
</p>
<p>Average CPC is sampled from a Gamma distribution with an Exponential likelihood
of an individual cost.
</p>


<h3>Value</h3>

<p>input_df with 3 new nested columns 'beta_params', 'gamma_params', and 'samples'
</p>

<hr>
<h2 id='sample_cpc'>Sample Cost Per Click</h2><span id='topic+sample_cpc'></span>

<h3>Description</h3>

<p>Adds 2 new nested columns to the input_df: 'gamma_params' and 'samples'
'gamma_params' in each row should be a tibble of length 2 (<code class="reqn">k</code>
and <code class="reqn">\theta</code> parameters)
'samples' in each row should be a tibble of length 'n_samples'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_cpc(input_df, priors, n_samples = 50000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_cpc_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str), sum_clicks (dbl), sum_cost (dbl).</p>
</td></tr>
<tr><td><code id="sample_cpc_+3A_priors">priors</code></td>
<td>
<p>Optional list of priors k0, theta0 for Gamma.
Default <code class="reqn">Gamma(1, 250)</code> will be use otherwise.</p>
</td></tr>
<tr><td><code id="sample_cpc_+3A_n_samples">n_samples</code></td>
<td>
<p>Optional integer value. Defaults to 50,000 samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See update_rules vignette for a mathematical representation.
</p>
<p style="text-align: center;"><code class="reqn">cpc_i ~ Exponential(\lambda)</code>
</p>

<p style="text-align: center;"><code class="reqn">\lambda ~ Gamma(k, \theta)</code>
</p>

<p>Average CPC is sampled from a Gamma distribution with an Exponential likelihood
of an individual cost.
</p>


<h3>Value</h3>

<p>input_df with 2 new nested columns 'gamma_params' and 'samples'
</p>

<hr>
<h2 id='sample_ctr'>Sample Click Through Rate</h2><span id='topic+sample_ctr'></span>

<h3>Description</h3>

<p>This is an alias for sample_conv_rate with 2 different input
columns. This function calculates posterior samples of
<code class="reqn">CTR = clicks/impressions</code>. Adds 2 new nested columns to
the input_df: 'beta_params' and 'samples'.
'beta_params' in each row should be a tibble of length 2 (<code class="reqn">\alpha</code>
and <code class="reqn">\beta</code> parameters)
'samples' in each row should be a tibble of length 'n_samples'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_ctr(input_df, priors, n_samples = 50000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_ctr_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str),
sum_clicks (dbl), and sum_impressions (dbl).</p>
</td></tr>
<tr><td><code id="sample_ctr_+3A_priors">priors</code></td>
<td>
<p>Optional list of priors alpha0 and beta0.
Default <code class="reqn">Beta(1,1)</code> will be use otherwise.</p>
</td></tr>
<tr><td><code id="sample_ctr_+3A_n_samples">n_samples</code></td>
<td>
<p>Optional integer value. Defaults to 50,000 samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See update_rules vignette for a mathematical representation.
</p>
<p style="text-align: center;"><code class="reqn">click_i ~ Bernoulli(\phi)</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi ~ Beta(\alpha, \beta)</code>
</p>

<p>Click Through Rate is sampled from a Beta distribution with a Binomial
likelihood of an individual Clicking
</p>


<h3>Value</h3>

<p>input_df with 2 new nested columns 'beta_params' and 'samples'
</p>

<hr>
<h2 id='sample_from_posterior'>Sample From Posterior</h2><span id='topic+sample_from_posterior'></span>

<h3>Description</h3>

<p>Selects which function to use to sample from the posterior distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_from_posterior(
  input_df,
  distribution,
  priors = list(),
  n_samples = 50000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_from_posterior_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str) and various other columns
depending on the distribution type. See vignette for more details.</p>
</td></tr>
<tr><td><code id="sample_from_posterior_+3A_distribution">distribution</code></td>
<td>
<p>String of the distribution name</p>
</td></tr>
<tr><td><code id="sample_from_posterior_+3A_priors">priors</code></td>
<td>
<p>Optional list of priors. Defaults will be use otherwise.</p>
</td></tr>
<tr><td><code id="sample_from_posterior_+3A_n_samples">n_samples</code></td>
<td>
<p>Optional integer value. Defaults to 50,000 samples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble with 2 columns: option_name (chr) and samples (dbl) [long form data].
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_df &lt;- tibble::tibble(
   option_name = c("A", "B"),
   sum_clicks = c(1000, 1000),
   sum_conversions = c(100, 120),
   sum_sessions = c(1000, 1000),
   sum_revenue = c(1000, 1500)
)
sample_from_posterior(input_df, "conversion_rate")
sample_from_posterior(input_df, "rev_per_session")

</code></pre>

<hr>
<h2 id='sample_multi_rev_per_session'>Sample Multiple Revenue Per Session</h2><span id='topic+sample_multi_rev_per_session'></span>

<h3>Description</h3>

<p>Adds 5 new nested columns to the input_df: 'dirichlet_params',
'gamma_params_A', 'gamma_params_B', and 'samples'.
This samples from multiple revenue per session distributions
at once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_multi_rev_per_session(input_df, priors, n_samples = 50000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_multi_rev_per_session_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str),
sum_conversions (dbl), sum_sessions (dbl), sum_revenue (dbl),
sum_conversion_2 (dbl), sum_sessions_2 (dbl), sum_revenue_2 (dbl).</p>
</td></tr>
<tr><td><code id="sample_multi_rev_per_session_+3A_priors">priors</code></td>
<td>
<p>Optional list of priors alpha0 and beta0.
Default <code class="reqn">Beta(1,1)</code> will be use otherwise.</p>
</td></tr>
<tr><td><code id="sample_multi_rev_per_session_+3A_n_samples">n_samples</code></td>
<td>
<p>Optional integer value. Defaults to 50,000 samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See update_rules vignette for a mathematical representation.
</p>
<p style="text-align: center;"><code class="reqn">conversion_i ~ MultiNomial(\phi_1, \phi_2, ..., \phi_k)</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi_k ~ Dirichlet(\alpha, \beta)</code>
</p>

<p>Conversion Rate is sampled from a Dirichlet distribution with a Multinomial likelihood
of an individual converting.
</p>


<h3>Value</h3>

<p>input_df with 4 new nested columns 'dirichlet_params',
'gamma_params_A', 'gamma_params_B', and 'samples'.
'samples' in each row should be a tibble of length 'n_samples'.
</p>

<hr>
<h2 id='sample_page_views_per_session'>Sample Page Views Per Session (Visit)</h2><span id='topic+sample_page_views_per_session'></span>

<h3>Description</h3>

<p>Adds 2 new nested columns to the input_df: 'gamma_params' and 'samples'
'gamma_params' in each row should be a tibble of length 2 (<code class="reqn">k</code>
and <code class="reqn">\theta</code> parameters)
'samples' in each row should be a tibble of length 'n_samples'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_page_views_per_session(input_df, priors, n_samples = 50000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_page_views_per_session_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str),
sum_sessions (dbl), and sum_page_views_per_session (dbl).</p>
</td></tr>
<tr><td><code id="sample_page_views_per_session_+3A_priors">priors</code></td>
<td>
<p>Optional list of priors k0 and theta0.
Default <code class="reqn">Gamma(1, 250)</code> will be use otherwise.
<code class="reqn">Gamma(1, 1)</code> might also be a good choice for this distribution
if you only have a few page views per session.</p>
</td></tr>
<tr><td><code id="sample_page_views_per_session_+3A_n_samples">n_samples</code></td>
<td>
<p>Optional integer value. Defaults to 50,000 samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See update_rules vignette for a mathematical representation.
</p>
<p style="text-align: center;"><code class="reqn">page_views_i ~ Poisson(\lambda)</code>
</p>

<p style="text-align: center;"><code class="reqn">\lambda ~ Gamma(k, \theta)</code>
</p>

<p>Page Views Per Visit is sampled from a Gamma distribution with a Poisson likelihood
of an individual having n page views by the end of their session.
</p>
<p>This is not always the case, so verify your data follows the shape of
an Poisson distribution before using this.
</p>


<h3>Value</h3>

<p>input_df with 2 new nested columns 'gamma_params' and 'samples'
</p>

<hr>
<h2 id='sample_response_rate'>Sample Response Rate</h2><span id='topic+sample_response_rate'></span>

<h3>Description</h3>

<p>This is an alias for sample_conv_rate with a different input column.
Adds 2 new nested columns to the input_df: 'beta_params' and 'samples'
'beta_params' in each row should be a tibble of length 2 (<code class="reqn">\alpha</code>
and <code class="reqn">\beta</code> parameters)
'samples' in each row should be a tibble of length 'n_samples'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_response_rate(input_df, priors, n_samples = 50000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_response_rate_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str),
sum_conversions (dbl), and sum_sessions (dbl).</p>
</td></tr>
<tr><td><code id="sample_response_rate_+3A_priors">priors</code></td>
<td>
<p>Optional list of priors alpha0 and beta0.
Default <code class="reqn">Beta(1,1)</code> will be use otherwise.</p>
</td></tr>
<tr><td><code id="sample_response_rate_+3A_n_samples">n_samples</code></td>
<td>
<p>Optional integer value. Defaults to 50,000 samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See update_rules vignette for a mathematical representation.
</p>
<p style="text-align: center;"><code class="reqn">conversion_i ~ Bernoulli(\phi)</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi ~ Beta(\alpha, \beta)</code>
</p>

<p>Response Rate is sampled from a Beta distribution with a Binomial likelihood
of an individual converting.
</p>


<h3>Value</h3>

<p>input_df with 2 new nested columns 'beta_params' and 'samples'
</p>

<hr>
<h2 id='sample_rev_per_session'>Sample Rev Per Session</h2><span id='topic+sample_rev_per_session'></span>

<h3>Description</h3>

<p>Adds 3 new nested columns to the input_df: 'beta_params', 'gamma_params', and 'samples'
'beta_params' and 'gamma_params' in each row should be a tibble of length 2 (<code class="reqn">\alpha</code>
and <code class="reqn">\beta</code> parameters and <code class="reqn">k</code> and <code class="reqn">\theta</code> parameters)
'samples' in each row should be a tibble of length 'n_samples'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_rev_per_session(input_df, priors, n_samples = 50000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_rev_per_session_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str),
sum_conversions (dbl), sum_revenue (dbl), and sum_clicks (dbl).</p>
</td></tr>
<tr><td><code id="sample_rev_per_session_+3A_priors">priors</code></td>
<td>
<p>Optional list of priors alpha0, beta0 for Beta
and k0, theta0 for Gamma. Default <code class="reqn">Beta(1,1)</code>
and <code class="reqn">Gamma(1, 250)</code> will be use otherwise.</p>
</td></tr>
<tr><td><code id="sample_rev_per_session_+3A_n_samples">n_samples</code></td>
<td>
<p>Optional integer value. Defaults to 50,000 samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See update_rules vignette for a mathematical representation.
</p>
<p style="text-align: center;"><code class="reqn">RevPerSession = RevPerOrder * OrdersPerClick</code>
</p>

<p>This is a combination of a Beta-Bernoulli update and a Gamma-Exponential update.
</p>
<p style="text-align: center;"><code class="reqn">conversion_i ~ Bernoulli(\phi)</code>
</p>

<p style="text-align: center;"><code class="reqn">revenue_i ~ Exponential(\lambda)</code>
</p>

<p style="text-align: center;"><code class="reqn">\phi ~ Beta(\alpha, \beta)</code>
</p>

<p style="text-align: center;"><code class="reqn">\lambda ~ Gamma(k, \theta)</code>
</p>

<p style="text-align: center;"><code class="reqn">revenue_i ~ Bernoulli(\phi) * Exponential(\lambda)^-1)</code>
</p>

<p style="text-align: center;"><code class="reqn">Rev Per Session ~ \phi / \lambda</code>
</p>

<p>Conversion Rate is sampled from a Beta distribution with a Binomial likelihood
of an individual converting.
</p>
<p>Average Rev Per Order is sampled from a Gamma distribution with an Exponential likelihood
of Revenue from an individual order.
This function makes sense to use if there is a distribution of possible revenue values
that can be produced from a single order or conversion.
</p>


<h3>Value</h3>

<p>input_df with 3 new nested columns 'beta_params', 'gamma_params', and 'samples'
</p>

<hr>
<h2 id='sample_session_duration'>Sample Session Duration</h2><span id='topic+sample_session_duration'></span>

<h3>Description</h3>

<p>Adds 2 new nested columns to the input_df: 'gamma_params' and 'samples'
'gamma_params' in each row should be a tibble of length 2 (<code class="reqn">k</code>
and <code class="reqn">\theta</code> parameters)
'samples' in each row should be a tibble of length 'n_samples'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_session_duration(input_df, priors, n_samples = 50000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_session_duration_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str),
sum_sessions (dbl), and sum_duration (dbl).</p>
</td></tr>
<tr><td><code id="sample_session_duration_+3A_priors">priors</code></td>
<td>
<p>Optional list of priors k0 and theta0.
Default <code class="reqn">Gamma(1, 250)</code> will be use otherwise.</p>
</td></tr>
<tr><td><code id="sample_session_duration_+3A_n_samples">n_samples</code></td>
<td>
<p>Optional integer value. Defaults to 50,000 samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See update_rules vignette for a mathematical representation.
</p>
<p style="text-align: center;"><code class="reqn">duration_i ~ Exponential(\lambda)</code>
</p>

<p style="text-align: center;"><code class="reqn">\lambda ~ Gamma(k, \theta)</code>
</p>

<p>Session Duration is sampled from a Gamma distribution with a Exponential likelihood
of an individual leaving the site or ending a session at time t.
</p>
<p>This is not always the case, so verify your data follows the shape of
an exponential distribution before using this.
</p>


<h3>Value</h3>

<p>input_df with 2 new nested columns 'gamma_params' and 'samples'
</p>

<hr>
<h2 id='sample_total_cm'>Sample Total CM (Given Impression Count)</h2><span id='topic+sample_total_cm'></span>

<h3>Description</h3>

<p>Adds 4 new nested columns to the input_df: 'beta_params_ctr',
'beta_params_conv','gamma_params_rev', 'gamma_params_cost'
and 'samples'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_total_cm(input_df, priors, n_samples = 50000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_total_cm_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str),
sum_conversions (dbl), sum_revenue (dbl), and sum_clicks (dbl).</p>
</td></tr>
<tr><td><code id="sample_total_cm_+3A_priors">priors</code></td>
<td>
<p>Optional list of priors alpha0, beta0 for Beta,
k0, theta0 for Gamma Inverse Revenue, and k01, theta01 for
Gamma Cost (uses alternate priors so they can be different from Revenue).
Default <code class="reqn">Beta(1,1)</code> and <code class="reqn">Gamma(1, 250)</code> will be use otherwise.</p>
</td></tr>
<tr><td><code id="sample_total_cm_+3A_n_samples">n_samples</code></td>
<td>
<p>Optional integer value. Defaults to 50,000 samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'beta_params' and 'gamma_params' in each row should be a tibble of length 2
(<code class="reqn">\alpha</code> and <code class="reqn">\beta</code> params and <code class="reqn">k</code> and <code class="reqn">\theta</code> params).
'samples' in each row should be a tibble of length 'n_samples'.
</p>
<p>One assumption in this model is that sum_impressions is not stochastic.
This assumes that Clicks are stochastically generated from a set number
of Impressions. It does not require that the number of impressions are
equal on either side. Generally this assumption holds true in marketing
tests where traffic is split 50/50 and very little variance is observed
in the number of impressions on either side.
</p>
<p>See update_rules vignette for a mathematical representation.
</p>
<p style="text-align: center;"><code class="reqn">TotalCM = Impr * ExpectedCTR * (RevPerOrder * OrdersPerClick - ExpectedCPC)</code>
</p>



<h3>Value</h3>

<p>input_df with 5 new nested columns 'beta_params_conv',
'beta_params_ctr', 'gamma_params_rev','gamma_params_cost',
and 'samples'
</p>

<hr>
<h2 id='update_beta'>Update Beta</h2><span id='topic+update_beta'></span>

<h3>Description</h3>

<p>Updates Beta Distribution with the Beta-Bernoulli
conjugate prior update rule
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_beta(alpha, beta, priors = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_beta_+3A_alpha">alpha</code></td>
<td>
<p>Double value for alpha (count of successes). Must be 0 or greater.</p>
</td></tr>
<tr><td><code id="update_beta_+3A_beta">beta</code></td>
<td>
<p>Double value for beta (count of failures). Must be 0 or greater.</p>
</td></tr>
<tr><td><code id="update_beta_+3A_priors">priors</code></td>
<td>
<p>An optional list object that contains alpha0 and
beta0. Otherwise the function with use Beta(1,1) as the prior distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A tibble object that contains 'alpha' and 'beta'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>update_beta(alpha = 1, beta = 5, priors = list(alpha0 = 2, beta0 = 2))
update_beta(alpha = 20000, beta = 50000)

</code></pre>

<hr>
<h2 id='update_dirichlet'>Update Dirichlet Distribution</h2><span id='topic+update_dirichlet'></span>

<h3>Description</h3>

<p>This function updates the Dirichlet distribution with the
Dirichlet-Multinomial conjugate prior update rule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_dirichlet(alpha_0, alpha_1, alpha_2, priors = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_dirichlet_+3A_alpha_0">alpha_0</code></td>
<td>
<p>Double value for alpha_0 (count of failures). Must be 0 or greater.</p>
</td></tr>
<tr><td><code id="update_dirichlet_+3A_alpha_1">alpha_1</code></td>
<td>
<p>Double value for alpha_1 (count of successes side 1). Must be 0 or greater.</p>
</td></tr>
<tr><td><code id="update_dirichlet_+3A_alpha_2">alpha_2</code></td>
<td>
<p>Double value for alpha_2 (count of successes side 2). Must be 0 or greater.</p>
</td></tr>
<tr><td><code id="update_dirichlet_+3A_priors">priors</code></td>
<td>
<p>An optional list object that contains alpha00, alpha01, and alpha02.
Otherwise the function with use <code class="reqn">Dirichlet(1,1,1)</code> as the prior distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>TODO: This function currently only works in 3 dimensions.
Should be extended into N dimensions in the future. Can use ... notation.
</p>


<h3>Value</h3>

<p>tibble with columns alpha_0, alpha_1, and alpha_2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>update_dirichlet(alpha_0 = 20, alpha_1 = 5, alpha_2 = 2)
sample_priors_list &lt;- list(alpha00 = 2, alpha01 = 3, alpha02 = 5)
update_dirichlet(alpha_0 = 20, alpha_1 = 5, alpha_2 = 2, priors = sample_priors_list)

</code></pre>

<hr>
<h2 id='update_gamma'>Update Gamma</h2><span id='topic+update_gamma'></span>

<h3>Description</h3>

<p>Updates Gamma Distribution with the Gamma-Exponential
conjugate prior update rule. Parameterized by <code class="reqn">k</code> and <code class="reqn">\theta</code> (not <code class="reqn">\alpha, \beta</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_gamma(k, theta, priors = list(), alternate_priors = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_gamma_+3A_k">k</code></td>
<td>
<p>Double value for <code class="reqn">k</code> (total revenue generating events). Must be 0 or greater.</p>
</td></tr>
<tr><td><code id="update_gamma_+3A_theta">theta</code></td>
<td>
<p>Double value for <code class="reqn">\theta</code> (sum of revenue). Must be 0 or greater.</p>
</td></tr>
<tr><td><code id="update_gamma_+3A_priors">priors</code></td>
<td>
<p>An optional list object that contains k0 and
theta0. Otherwise the function will use <code class="reqn">Gamma(1,250)</code> as the prior distribution.
If a second gamma distribution is used k01 and theta01 can be defined as separate priors
when alternate_priors is set to TRUE.</p>
</td></tr>
<tr><td><code id="update_gamma_+3A_alternate_priors">alternate_priors</code></td>
<td>
<p>Boolean Defaults to FALSE. Allows a user to specify alternate
prior names so the same prior isn't required when multiple gamma distributions are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object that contains 'k' and 'theta'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>update_gamma(k = 1, theta = 100, priors = list(k0 = 2, theta0 = 1000))
update_gamma(k = 10, theta = 200)

</code></pre>

<hr>
<h2 id='validate_data_values'>Validate Data Values</h2><span id='topic+validate_data_values'></span>

<h3>Description</h3>

<p>Validates data values are all greater than 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_data_values(data_values)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_data_values_+3A_data_values">data_values</code></td>
<td>
<p>List of named data values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='validate_input_column'>Validate Input Column</h2><span id='topic+validate_input_column'></span>

<h3>Description</h3>

<p>Validates the input column exists in the dataframe, is of the correct type,
and that all values are greater than or equal to 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_input_column(column_name, input_df, greater_than_zero = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_input_column_+3A_column_name">column_name</code></td>
<td>
<p>String value of the column name</p>
</td></tr>
<tr><td><code id="validate_input_column_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str) and various other columns
depending on the distribution type. See vignette for more details.</p>
</td></tr>
<tr><td><code id="validate_input_column_+3A_greater_than_zero">greater_than_zero</code></td>
<td>
<p>Boolean: Do all values in the column have to be greater than zero?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='validate_input_df'>Validate Input DataFrame</h2><span id='topic+validate_input_df'></span>

<h3>Description</h3>

<p>Validates the input dataframe has the correct type, correct required column names,
that the distribution is valid, that the column types are correct, and that the
column values are greater than or equal to 0 when they are numeric.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_input_df(input_df, distribution)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_input_df_+3A_input_df">input_df</code></td>
<td>
<p>Dataframe containing option_name (str) and various other columns
depending on the distribution type. See vignette for more details.</p>
</td></tr>
<tr><td><code id="validate_input_df_+3A_distribution">distribution</code></td>
<td>
<p>String of the distribution name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Bool TRUE if all checks pass.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>input_df &lt;- tibble::tibble(
   option_name = c("A", "B"),
   sum_clicks = c(1000, 1000),
   sum_conversions = c(100, 120)
)
validate_input_df(input_df, "conversion_rate")

</code></pre>

<hr>
<h2 id='validate_posterior_samples'>Validate Posterior Samples Dataframe</h2><span id='topic+validate_posterior_samples'></span>

<h3>Description</h3>

<p>Function fails if posterior is not shaped correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_posterior_samples(posterior_samples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_posterior_samples_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>Tibble of data in long form with 2 columns
'option_name' and 'samples'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

<hr>
<h2 id='validate_priors'>Validate Priors</h2><span id='topic+validate_priors'></span>

<h3>Description</h3>

<p>Validates list of priors against a vector of valid priors and if
the values are not valid, default priors are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_priors(priors, valid_priors, default_priors)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_priors_+3A_priors">priors</code></td>
<td>
<p>List of named priors with double values.</p>
</td></tr>
<tr><td><code id="validate_priors_+3A_valid_priors">valid_priors</code></td>
<td>
<p>A character vector of valid prior names.</p>
</td></tr>
<tr><td><code id="validate_priors_+3A_default_priors">default_priors</code></td>
<td>
<p>A list of default priors for the distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of valid priors for the distribution.
</p>

<hr>
<h2 id='validate_wrt_option'>Validate With Respect To Option</h2><span id='topic+validate_wrt_option'></span>

<h3>Description</h3>

<p>Verify that the option provided is in the poster_samples dataframe 'option_name' column.
Raises error if not TRUE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_wrt_option(wrt_option, posterior_samples)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_wrt_option_+3A_wrt_option">wrt_option</code></td>
<td>
<p>string name of the option</p>
</td></tr>
<tr><td><code id="validate_wrt_option_+3A_posterior_samples">posterior_samples</code></td>
<td>
<p>Tibble returned from sample_from_posterior with 3 columns
'option_name', 'samples', and 'sample_id'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
