<!DOCTYPE html><html><head><title>Help for package ncf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ncf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cc.offset'><p>Function to calculate the distance at which the cross-correlation peaks for Sncf objects</p></a></li>
<li><a href='#circ.cor2'><p>Circular correlation</p></a></li>
<li><a href='#cor2'><p>Utility function</p></a></li>
<li><a href='#correlog'><p>Uni- and multivariate spatial correlograms</p></a></li>
<li><a href='#correlog.nc'><p>Non-centered spatial (cross-)correlogram</p></a></li>
<li><a href='#ff.filter'><p>Fourier filter for correlation functions.</p></a></li>
<li><a href='#gather'><p>Utility function</p></a></li>
<li><a href='#gcdist'><p>Great-circle distance</p></a></li>
<li><a href='#lbm'><p>Spatio-temporal data panel of Larch Budmoth defoliation</p></a></li>
<li><a href='#lisa'><p>Local indicator of spatial association</p></a></li>
<li><a href='#lisa.nc'><p>Non-centered indicators of spatial association</p></a></li>
<li><a href='#mantel.correlog'><p>Mantel (cross-)correlograms</p></a></li>
<li><a href='#mantel.test'><p>Mantel Test</p></a></li>
<li><a href='#mSynch'><p>The mean (cross-)correlation (with bootstrapp CI) for a panel of spatiotemporal data</p></a></li>
<li><a href='#partial.mantel.test'><p>Partial Mantel test</p></a></li>
<li><a href='#plot.cc.offset'><p>Plots the cc.offset summary of the anisotropic spatial correlation-functions</p></a></li>
<li><a href='#plot.correlog'><p>Plots spatial correlograms</p></a></li>
<li><a href='#plot.lisa'><p>Plots local indicators of spatial association</p></a></li>
<li><a href='#plot.Sncf'><p>Plots nonparametric spatial correlation-functions</p></a></li>
<li><a href='#plot.Sncf.cov'><p>Plots nonparametric spatial covariance-functions</p></a></li>
<li><a href='#plot.Sncf2D'><p>Plots anisotropic spatial correlation-functions</p></a></li>
<li><a href='#plot.spline.correlog'><p>Plots a spline correlogram</p></a></li>
<li><a href='#print.mSynch'><p>Print function for mSynch objects</p></a></li>
<li><a href='#print.Sncf'><p>Print function for Sncf objects</p></a></li>
<li><a href='#print.Sncf2D'><p>Print function for Sncf2D objects</p></a></li>
<li><a href='#print.spline.correlog'><p>Print function for spline.correlog objects</p></a></li>
<li><a href='#rmvn.spa'><p>Simulate spatially correlated data</p></a></li>
<li><a href='#Sncf'><p>Nonparametric (cross-)correlation function for spatio-temporal data</p></a></li>
<li><a href='#Sncf.srf'><p>Nonparametric (Cross-)Covariance Function from stationary random fields</p></a></li>
<li><a href='#Sncf2D'><p>Anisotropic nonparametric (cross-)correlation function for spatio-temporal data</p></a></li>
<li><a href='#spatial.plot'><p>Simple wrapper around symbols to visualize spatial data</p></a></li>
<li><a href='#spline.correlog'><p>Uni- and multivariate spline correlograms</p></a></li>
<li><a href='#spline.correlog2D'><p>Anisotropic nonparametric (cross-)correlation function for univariate spatial data</p></a></li>
<li><a href='#summary.Sncf'><p>Summarizing nonparametric spatial correlation-functions</p></a></li>
<li><a href='#summary.Sncf2D'><p>Summarizing anisotropic spatial correlation-functions</p></a></li>
<li><a href='#summary.spline.correlog'><p>Summarizing spline correlograms</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.3-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-05-07</td>
</tr>
<tr>
<td>Title:</td>
<td>Spatial Covariance Functions</td>
</tr>
<tr>
<td>Author:</td>
<td>Ottar N. Bjornstad [aut, cre],
  Jun Cai [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ottar N. Bjornstad &lt;onb1@psu.edu&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.8.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Spatial (cross-)covariance and related geostatistical tools: the
        nonparametric (cross-)covariance function , the spline correlogram, the
        nonparametric phase coherence function, local indicators of spatial 
        association (LISA), (Mantel) correlogram, (Partial) Mantel test.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ento.psu.edu/directory/onb1">https://ento.psu.edu/directory/onb1</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/objornstad/ncf/issues">https://github.com/objornstad/ncf/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-05-07 15:18:38 UTC; onb1</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-05-07 15:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cc.offset'>Function to calculate the distance at which the cross-correlation peaks for Sncf objects</h2><span id='topic+cc.offset'></span>

<h3>Description</h3>

<p>Alternative summary method for class &quot;Sncf2D&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cc.offset(object, xmax = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cc.offset_+3A_object">object</code></td>
<td>
<p>an object of class &quot;Sncf2D&quot;, usually, as a result of a call to <code>Sncf2D</code> or <code>spline.correlog2D</code>.</p>
</td></tr>
<tr><td><code id="cc.offset_+3A_xmax">xmax</code></td>
<td>
<p>the maximum distance to consider (default is no upper limit).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An matrix of class &quot;cc.offset&quot; is returned with columns:
</p>
<table>
<tr><td><code>angle</code></td>
<td>
<p>the cardinal angle (in degrees).</p>
</td></tr>
<tr><td><code>distance</code></td>
<td>
<p>the distances (in the positive direction) to the mode of the (cross-) correlation function (with 95% confidence bounds).</p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>
<p>the correlation at the mode (with CI) for each of the cardinal angles.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Sncf2D">Sncf2D</a></code>, <code><a href="#topic+summary.Sncf2D">summary.Sncf2D</a></code>, <code><a href="#topic+plot.cc.offset">plot.cc.offset</a></code>
</p>

<hr>
<h2 id='circ.cor2'>Circular correlation</h2><span id='topic+circ.cor2'></span>

<h3>Description</h3>

<p>A vectorized function to calculate a correlation matrix for panels of data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ.cor2(x, y = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circ.cor2_+3A_x">x</code></td>
<td>
<p>a matrix.</p>
</td></tr>
<tr><td><code id="circ.cor2_+3A_y">y</code></td>
<td>
<p>an optional second matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values are not allowed.
</p>


<h3>Value</h3>

<p>A correlation matrix is returned.
</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 8.2, World Scientific Press, Singapore.
</p>

<hr>
<h2 id='cor2'>Utility function</h2><span id='topic+cor2'></span>

<h3>Description</h3>

<p>Called by various functions to calculate Pearson or angular correlation matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor2(x, y = NULL, circ = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor2_+3A_x">x</code></td>
<td>
<p>a matrix.</p>
</td></tr>
<tr><td><code id="cor2_+3A_y">y</code></td>
<td>
<p>an optional second matrix.</p>
</td></tr>
<tr><td><code id="cor2_+3A_circ">circ</code></td>
<td>
<p>If TRUE, the observations are assumed to be angular (in radians), and circular correlation is used. If FALSE, Pearson product moment correlations is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An auxilliary function to ease the maintenance.
</p>


<h3>Value</h3>

<p>A correlation matrix is returned.
</p>


<h3>References</h3>

<p>Jammalamadaka, S. Rao and SenGupta, A. (2001). Topics in Circular Statistics, Section 8.2, World Scientific Press, Singapore.
</p>

<hr>
<h2 id='correlog'>Uni- and multivariate spatial correlograms</h2><span id='topic+correlog'></span>

<h3>Description</h3>

<p><code>correlog</code> is the function to estimate spatial (cross-)correlograms. Either univariate or multivariate (time seres) for each site can be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlog(
  x,
  y,
  z,
  w = NULL,
  increment,
  resamp = 999,
  latlon = FALSE,
  na.rm = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlog_+3A_x">x</code></td>
<td>
<p>vector of length n representing the x coordinates (or longitude; see latlon).</p>
</td></tr>
<tr><td><code id="correlog_+3A_y">y</code></td>
<td>
<p>vector of length n representing the y coordinates (or latitude).</p>
</td></tr>
<tr><td><code id="correlog_+3A_z">z</code></td>
<td>
<p>vector of length n or matrix of dimension n x p representing p observation at each location.</p>
</td></tr>
<tr><td><code id="correlog_+3A_w">w</code></td>
<td>
<p>an optional second variable with identical dimension to z (to estimate cross-correlograms).</p>
</td></tr>
<tr><td><code id="correlog_+3A_increment">increment</code></td>
<td>
<p>increment for the uniformly distributed distance classes.</p>
</td></tr>
<tr><td><code id="correlog_+3A_resamp">resamp</code></td>
<td>
<p>the number of permutations under the null to assess level of significance.</p>
</td></tr>
<tr><td><code id="correlog_+3A_latlon">latlon</code></td>
<td>
<p>If TRUE, coordinates are latitude and longitude.</p>
</td></tr>
<tr><td><code id="correlog_+3A_na.rm">na.rm</code></td>
<td>
<p>If TRUE, NA's will be dealt with through pairwise deletion of missing values.</p>
</td></tr>
<tr><td><code id="correlog_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, the counter is suppressed during execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The spatial (cross-)correlogram and Mantel (cross-)correlogram estimates the spatial dependence at discrete distance classes. 
</p>
<p>The region-wide similarity forms the reference line (the zero-line); the x-intercept is thus the distance at which object are no more similar than that expected by-chance-alone across the region.
</p>
<p>If the data are univariate, the spatial dependence is measured by Moran's <em>I</em>. If it is multivariate, it is measured by the <em>centred</em> Mantel statistic. (Use <code><a href="#topic+correlog.nc">correlog.nc</a></code> if the non-centered multivariate correlogram is desired).
</p>
<p>Missing values are allowed &ndash; values are assumed missing at random.
</p>


<h3>Value</h3>

<p>An object of class &quot;correlog&quot; is returned, consisting of the following components: 
</p>
<table>
<tr><td><code>correlation</code></td>
<td>
<p>the value for the Moran (or Mantel) similarity.</p>
</td></tr>
<tr><td><code>mean.of.class</code></td>
<td>
<p>the actual average of the distances within each distance class.</p>
</td></tr>
<tr><td><code>nlok</code></td>
<td>
<p>the number of pairs within each distance class.</p>
</td></tr>
<tr><td><code>x.intercept</code></td>
<td>
<p>the interpolate x.intercept of Epperson (1993).</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the permutation two-sided p-value for each distance-class.</p>
</td></tr>
<tr><td><code>corr0</code></td>
<td>
<p>If a cross-correlogram is calculated, corr0 gives the empirical cross-correlation at distance zero.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ottar N. Bjornstad <a href="mailto:onb1@psu.edu">onb1@psu.edu</a>
</p>


<h3>References</h3>

<p>Bjornstad, O.N., Ims, R.A. &amp; Lambin, X. (1999) Spatial population dynamics: Analysing patterns and processes of population synchrony. Trends in Ecology and Evolution, 11, 427-431. &lt;doi:10.1016/S0169-5347(99)01677-8&gt;
</p>
<p>Bjornstad, O.N. &amp; Falck, W. (2001) Nonparametric spatial covariance functions: estimation and testing. Environmental and Ecological Statistics, 8:53-70. &lt;doi:10.1023/A:1009601932481&gt;
</p>
<p>Epperson, B.K. (1993) Recent advances in correlation studies of spatial patterns of genetic variation. Evolutionary Biology, 27, 95-155. &lt;doi:10.1007/978-1-4615-2878-4_4&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.correlog">plot.correlog</a></code>, <code><a href="#topic+spline.correlog">spline.correlog</a></code>, <code><a href="#topic+correlog.nc">correlog.nc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate some sample data
x &lt;- expand.grid(1:20, 1:5)[, 1]
y &lt;- expand.grid(1:20, 1:5)[, 2]

# z data from an exponential random field
z &lt;- cbind(
  rmvn.spa(x = x, y = y, p = 2, method = "exp"), 
  rmvn.spa(x = x, y = y, p = 2, method = "exp")
  )

# w data from a gaussian random field
w &lt;- cbind(
  rmvn.spa(x = x, y = y, p = 2, method = "gaus"), 
  rmvn.spa(x = x, y = y, p = 2, method = "gaus")
  )

# Spatial correlogram 
fit1 &lt;- correlog(x = x, y = y, z = z[, 1], increment = 2, resamp = 0) 
## Not run: plot(fit1)

# Mantel correlogram 
fit2 &lt;- correlog(x = x, y = y, z = z, increment = 2, resamp = 0) 
## Not run: plot(fit2)

# Mantel cross-correlogram 
fit3 &lt;- correlog(x = x, y = y, z = z, w = w, increment = 2, resamp = 0) 
## Not run: plot(fit3)
</code></pre>

<hr>
<h2 id='correlog.nc'>Non-centered spatial (cross-)correlogram</h2><span id='topic+correlog.nc'></span>

<h3>Description</h3>

<p><code>correlog.nc</code> is the function to estimate the non-centered (cross-)correlogram. The non-centered correlogram provides estimates of the spatial correlation for discrete distance classes. The function requires multiple observations at each location (use <code><a href="#topic+correlog">correlog</a></code> otherwise).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlog.nc(
  x,
  y,
  z,
  w = NULL,
  increment,
  resamp = 999,
  na.rm = FALSE,
  latlon = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="correlog.nc_+3A_x">x</code></td>
<td>
<p>vector of length n representing the x coordinates (or longitude; see latlon).</p>
</td></tr>
<tr><td><code id="correlog.nc_+3A_y">y</code></td>
<td>
<p>vector of length n representing the y coordinates (or latitude).</p>
</td></tr>
<tr><td><code id="correlog.nc_+3A_z">z</code></td>
<td>
<p>a matrix of dimension n x p representing p (&gt;1) observation at each location.</p>
</td></tr>
<tr><td><code id="correlog.nc_+3A_w">w</code></td>
<td>
<p>an optional second variable with identical dimension to z (to estimate cross-correlograms).</p>
</td></tr>
<tr><td><code id="correlog.nc_+3A_increment">increment</code></td>
<td>
<p>increment for the uniformly distributed distance classes.</p>
</td></tr>
<tr><td><code id="correlog.nc_+3A_resamp">resamp</code></td>
<td>
<p>the number of permutations under the null to assess level of significance.</p>
</td></tr>
<tr><td><code id="correlog.nc_+3A_na.rm">na.rm</code></td>
<td>
<p>If TRUE, NA's will be dealt with through pairwise deletion of missing values.</p>
</td></tr>
<tr><td><code id="correlog.nc_+3A_latlon">latlon</code></td>
<td>
<p>If TRUE, coordinates are latitude and longitude.</p>
</td></tr>
<tr><td><code id="correlog.nc_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, the counter is suppressed during execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The non-centered correlogram estimates spatial dependence at discrete distance  classes. The method corresponds to the modified correlogram of Koenig &amp; Knops(1998), but augmented to potentially estimate the cross-correlogram). The function requires multiple observations at each location. Missing values is allowed in the multivariate case (pairwise deletion will be used).
</p>
<p>Missing values are allowed &ndash; values are assumed missing at random.
</p>


<h3>Value</h3>

<p>An object of class &quot;correlog&quot; is returned, consisting of the following components: 
</p>
<table>
<tr><td><code>correlation</code></td>
<td>
<p>the value for the Moran (or Mantel) similarity.</p>
</td></tr>
<tr><td><code>mean.of.class</code></td>
<td>
<p>the actual average of the distances within each distance class.</p>
</td></tr>
<tr><td><code>nlok</code></td>
<td>
<p>the number of pairs within each distance class.</p>
</td></tr>
<tr><td><code>x.intercept</code></td>
<td>
<p>the interpolate x.intercept of Epperson (1993).</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the permutation p-value for each distance-class.</p>
</td></tr>
<tr><td><code>corr0</code></td>
<td>
<p>If a cross-correlogram is calculated, corr0 gives the empirical within-patch cross-correlation.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ottar N. Bjornstad <a href="mailto:onb1@psu.edu">onb1@psu.edu</a>
</p>


<h3>References</h3>

<p>Bjornstad, O.N., Ims, R.A. &amp; Lambin, X. (1999) Spatial population dynamics: Analysing patterns and processes of population synchrony. Trends in Ecology and Evolution, 11, 427-431. &lt;doi:10.1016/S0169-5347(99)01677-8&gt;
</p>
<p>Koenig, W.D. &amp; Knops, J.M.H. (1998) Testing for spatial autocorrelation in ecological studies. Ecography, 21, 423-429. &lt;doi:10.1111/j.1600-0587.1998.tb00407.x&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.correlog">plot.correlog</a></code>, <code><a href="#topic+correlog">correlog</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate some sample data
x &lt;- expand.grid(1:20, 1:5)[, 1]
y &lt;- expand.grid(1:20, 1:5)[, 2]

# z data from an exponential random field
z &lt;- cbind(
  rmvn.spa(x = x, y = y, p = 2, method = "exp"), 
  rmvn.spa(x = x, y = y, p = 2, method = "exp")
  )

# w data from a gaussian random field
w &lt;- cbind(
  rmvn.spa(x = x, y = y, p = 2, method = "gaus"), 
  rmvn.spa(x = x, y = y, p = 2, method = "gaus")
  )

# noncentered (Mantel) correlogram 
fit1 &lt;- correlog.nc(x = x, y = y, z = z, increment = 2, resamp = 499)
## Not run: plot(fit1)
</code></pre>

<hr>
<h2 id='ff.filter'>Fourier filter for correlation functions.</h2><span id='topic+ff.filter'></span>

<h3>Description</h3>

<p>Fourier filter to ensure positive semi-definite correlation functions. Called by various functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff.filter(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff.filter_+3A_x">x</code></td>
<td>
<p>a vector.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector is returned whose Fourier-transform has no non-negative coefficients.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sncf">Sncf</a></code>
</p>

<hr>
<h2 id='gather'>Utility function</h2><span id='topic+gather'></span>

<h3>Description</h3>

<p>Called by various functions to calculate various intercepts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gather(u, v, w, moran, df, xpoints, filter, fw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gather_+3A_u">u</code></td>
<td>
<p>a vector.</p>
</td></tr>
<tr><td><code id="gather_+3A_v">v</code></td>
<td>
<p>a vector.</p>
</td></tr>
<tr><td><code id="gather_+3A_w">w</code></td>
<td>
<p>a vector.</p>
</td></tr>
<tr><td><code id="gather_+3A_moran">moran</code></td>
<td>
<p>a matrix.</p>
</td></tr>
<tr><td><code id="gather_+3A_df">df</code></td>
<td>
<p>a scalar.</p>
</td></tr>
<tr><td><code id="gather_+3A_xpoints">xpoints</code></td>
<td>
<p>a vector.</p>
</td></tr>
<tr><td><code id="gather_+3A_filter">filter</code></td>
<td>
<p>a logical.</p>
</td></tr>
<tr><td><code id="gather_+3A_fw">fw</code></td>
<td>
<p>a scalar</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An auxiliary function to ease  maintenance.
</p>


<h3>Value</h3>

<p>A list is returned.
</p>

<hr>
<h2 id='gcdist'>Great-circle distance</h2><span id='topic+gcdist'></span>

<h3>Description</h3>

<p>Great-circle distance function to calculate spatial distance from lat-long data.  Called by various functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gcdist(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gcdist_+3A_x">x</code></td>
<td>
<p>vector of longitudes.</p>
</td></tr>
<tr><td><code id="gcdist_+3A_y">y</code></td>
<td>
<p>vector of latitudes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The distance in km is returned
</p>

<hr>
<h2 id='lbm'>Spatio-temporal data panel of Larch Budmoth defoliation</h2><span id='topic+lbm'></span>

<h3>Description</h3>

<p>This is the data in Bjornstad et al. (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lbm)
</code></pre>


<h3>Format</h3>

<p>A data-frame with 135 rows and 40 columns. The first two are the x- and y-coordinates (in m), the following 38 represents the defoliation in years 1961 through 1998.
</p>


<h3>References</h3>

<p>Bjornstad, O.N., Peltonen, M., Liebhold, A.M., and Baltensweiler, W. (2002) Waves of larch budmoth outbreaks in the European Alps. Science, 298, 1020-1023. &lt;doi:10.1126/science.1075182&gt;
</p>

<hr>
<h2 id='lisa'>Local indicator of spatial association</h2><span id='topic+lisa'></span>

<h3>Description</h3>

<p><code>lisa</code> is a function to estimate the local indicators of spatial association. The function assumes univariate data at each location. For multivariate data use <code><a href="#topic+lisa.nc">lisa.nc</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lisa(x, y, z, neigh, resamp = 999, latlon = FALSE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lisa_+3A_x">x</code></td>
<td>
<p>vector of length n representing the x coordinates (or latitude; see latlon).</p>
</td></tr>
<tr><td><code id="lisa_+3A_y">y</code></td>
<td>
<p>vector of length n representing the y coordinates (or longitude).</p>
</td></tr>
<tr><td><code id="lisa_+3A_z">z</code></td>
<td>
<p>vector of n representing the observation at each location.</p>
</td></tr>
<tr><td><code id="lisa_+3A_neigh">neigh</code></td>
<td>
<p>neighborhood size.</p>
</td></tr>
<tr><td><code id="lisa_+3A_resamp">resamp</code></td>
<td>
<p>number of resamples under the NULL to generate p-values</p>
</td></tr>
<tr><td><code id="lisa_+3A_latlon">latlon</code></td>
<td>
<p>If TRUE, coordinates are latitude and longitude.</p>
</td></tr>
<tr><td><code id="lisa_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, the counter is suppressed during execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the function to estimate the local indicators of spatial association modified form Anselin (1995). The statistic is the average autocorrelation within a neighborhood.
</p>


<h3>Value</h3>

<p>An object of class &quot;lisa&quot; is returned, consisting of the following components: 
</p>
<table>
<tr><td><code>correlation</code></td>
<td>
<p>the autocorrelation within the neighborhood (neigh) of each observation measured using Moran's I.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the permutation two-sided p-value for each observation.</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>the mean of the observations inside each neighborhooddistance within each neighborhood.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of observations within each neighborhood.</p>
</td></tr>
<tr><td><code>dmean</code></td>
<td>
<p>the actual mean distance within each neighborhood.</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>the original observations</p>
</td></tr>
<tr><td><code>coord</code></td>
<td>
<p>a list with the x and y coordinates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ottar N. Bjornstad <a href="mailto:onb1@psu.edu">onb1@psu.edu</a>
</p>


<h3>References</h3>

<p>Anselin, L. 1995. Local indicators of spatial association - LISA. Geographical Analysis 27:93-115. &lt;doi:10.1111/j.1538-4632.1995.tb00338.x&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.lisa">plot.lisa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate some sample data
x &lt;- expand.grid(1:20, 1:5)[, 1]
y &lt;- expand.grid(1:20, 1:5)[, 2]

# z data from an exponential random field
z &lt;- rmvn.spa(x = x, y = y, p = 2, method = "gaus")

# lisa analysis
fit1 &lt;- lisa(x = x, y = y, z = z, neigh = 3, resamp = 499)
## Not run: plot(fit1, neigh.mean=FALSE)
</code></pre>

<hr>
<h2 id='lisa.nc'>Non-centered indicators of spatial association</h2><span id='topic+lisa.nc'></span>

<h3>Description</h3>

<p><code>lisa.nc</code> is a function to estimate the (non-centred) multivariate local indicators of spatial association. The function requires multiple observations at each location. For single observations at each location use <code>lisa</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lisa.nc(
  x,
  y,
  z,
  neigh,
  na.rm = FALSE,
  resamp = 999,
  latlon = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lisa.nc_+3A_x">x</code></td>
<td>
<p>vector of length n representing the x coordinates (or latitude; see latlon).</p>
</td></tr>
<tr><td><code id="lisa.nc_+3A_y">y</code></td>
<td>
<p>vector of length n representing the y coordinates (or longitude).</p>
</td></tr>
<tr><td><code id="lisa.nc_+3A_z">z</code></td>
<td>
<p>a matrix of dimension n x p representing p (&gt;1) observation at each location.</p>
</td></tr>
<tr><td><code id="lisa.nc_+3A_neigh">neigh</code></td>
<td>
<p>neighborhood size.</p>
</td></tr>
<tr><td><code id="lisa.nc_+3A_na.rm">na.rm</code></td>
<td>
<p>If TRUE, NA's will be dealt with through pairwise deletion of missing values.</p>
</td></tr>
<tr><td><code id="lisa.nc_+3A_resamp">resamp</code></td>
<td>
<p>number of resamples under the NULL to generate p-values</p>
</td></tr>
<tr><td><code id="lisa.nc_+3A_latlon">latlon</code></td>
<td>
<p>If TRUE, coordinates are latitude and longitude.</p>
</td></tr>
<tr><td><code id="lisa.nc_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, the counter is suppressed during execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is the function to estimate the (non-centered) local indicators of spatial 
association modified form Anselin (1995). 'correlation' is the average correlation within 
a neighborhood. The function requires multiple observations at each location.
</p>
<p>Missing values are allowed &ndash; values are assumed missing at random, and pairwise complete observations will be used.
</p>


<h3>Value</h3>

<p>An object of class &quot;lisa&quot; is returned, consisting of the following components:
</p>
<table>
<tr><td><code>correlation</code></td>
<td>
<p>the mean correlation within the neighborhood (neigh).</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the permutation two-sided p-value for each distance-class.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of pairs within each neighborhood.</p>
</td></tr>
<tr><td><code>dmean</code></td>
<td>
<p>the actual mean of distance within each neighborhood.</p>
</td></tr>
<tr><td><code>coord</code></td>
<td>
<p>a list with the x and y coordinates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ottar N. Bjornstad <a href="mailto:onb1@psu.edu">onb1@psu.edu</a>
</p>


<h3>References</h3>

<p>Anselin, L. 1995. Local indicators of spatial association - LISA. Geographical Analysis 27:93-115. &lt;doi:10.1111/j.1538-4632.1995.tb00338.x&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lisa">lisa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate some sample data
x &lt;- expand.grid(1:20, 1:5)[, 1]
y &lt;- expand.grid(1:20, 1:5)[,2]

# z data from an exponential random field
z &lt;- cbind(
  rmvn.spa(x = x, y = y, p = 2, method = "exp"), 
  rmvn.spa(x = x, y = y, p = 2, method = "exp")
  )

# lisa.nc analysis
fit1 &lt;- lisa.nc(x = x, y = y, z = z, neigh = 3)
## Not run: plot(fit1)
</code></pre>

<hr>
<h2 id='mantel.correlog'>Mantel (cross-)correlograms</h2><span id='topic+mantel.correlog'></span>

<h3>Description</h3>

<p><code>mantel.correlog</code> is the function to calculate a Mantel (cross-)correlogram. The function requires two (or three) matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mantel.correlog(
  dmat,
  zmat,
  wmat = NULL,
  increment,
  resamp = 999,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mantel.correlog_+3A_dmat">dmat</code></td>
<td>
<p>a matrix representing distance.</p>
</td></tr>
<tr><td><code id="mantel.correlog_+3A_zmat">zmat</code></td>
<td>
<p>a matrix representing similarity.</p>
</td></tr>
<tr><td><code id="mantel.correlog_+3A_wmat">wmat</code></td>
<td>
<p>an optional third matrix of similarities to calculate a Mantel cross-correlograms.</p>
</td></tr>
<tr><td><code id="mantel.correlog_+3A_increment">increment</code></td>
<td>
<p>increment for the uniformly distributed distance classes.</p>
</td></tr>
<tr><td><code id="mantel.correlog_+3A_resamp">resamp</code></td>
<td>
<p>the number of permutations under the null to assess level of significance.</p>
</td></tr>
<tr><td><code id="mantel.correlog_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, the counter is suppressed during execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates Mantel (cross-)correlograms at discrete distance classes from two (or three) matrixes. The first is the matrix of distances and the second is a matrix of similarities. The optional third matrix is an additional similarity matrix to be used to calculate a Mantel cross-correlogram.  Missing values are allowed &ndash; values are assumed missing at random.
</p>


<h3>Value</h3>

<p>An object of class &quot;correlog&quot; is returned, consisting of the following components: 
</p>
<table>
<tr><td><code>correlation</code></td>
<td>
<p>the value for the Moran (or Mantel) similarity.</p>
</td></tr>
<tr><td><code>mean.of.class</code></td>
<td>
<p>the actual average of the distances within each distance class.</p>
</td></tr>
<tr><td><code>nlok</code></td>
<td>
<p>the number of pairs within each distance class.</p>
</td></tr>
<tr><td><code>x.intercept</code></td>
<td>
<p>the interpolate x.intercept of Epperson (1993).</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the permutation two-sided p-value for each distance-class.</p>
</td></tr>
<tr><td><code>corr0</code></td>
<td>
<p>If a cross-correlogram is calculated, corr0 gives the empirical cross-correlation at distance zero.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ottar N. Bjornstad <a href="mailto:onb1@psu.edu">onb1@psu.edu</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.correlog">plot.correlog</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate some sample data
x &lt;- expand.grid(1:20, 1:5)[, 1]
y &lt;- expand.grid(1:20, 1:5)[, 2]

# z data from an exponential random field
z &lt;- cbind(
  rmvn.spa(x = x, y = y, p = 2, method = "exp"), 
  rmvn.spa(x = x, y = y, p = 2, method = "exp")
  )

# w data from a gaussian random field
w &lt;- cbind(rmvn.spa(
  x = x, y = y, p = 2, method = "gaus"), 
  rmvn.spa(x = x, y = y, p = 2, method = "gaus")
  )

# Make distance and similarity matrices
zmat &lt;- cor(t(z))
wmat &lt;- cor(t(w))
dmat &lt;- sqrt(outer(x, x, "-")^2 + outer(y, y, "-")^2)

# Mantel correlogram 
fit1 &lt;- mantel.correlog(dmat = dmat, zmat = zmat, increment = 2, quiet = TRUE, 
                        resamp = 0)
## Not run: plot(fit1)

# Mantel cross-correlogram 
fit2 &lt;- mantel.correlog(dmat = dmat, zmat = zmat, wmat = wmat, increment = 2, 
                        quiet = TRUE, resamp = 0)
## Not run: plot(fit2)
</code></pre>

<hr>
<h2 id='mantel.test'>Mantel Test</h2><span id='topic+mantel.test'></span>

<h3>Description</h3>

<p>A simple function to do a permutation-based Mantel test. The data can either be two distance/similarity matrices or (x, y, z) data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mantel.test(
  M1 = NULL,
  M2 = NULL,
  x = NULL,
  y = NULL,
  z = NULL,
  resamp = 999,
  latlon = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mantel.test_+3A_m1">M1</code></td>
<td>
<p>similarity/distance matrix 1</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_m2">M2</code></td>
<td>
<p>similarity/distance matrix 2</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_x">x</code></td>
<td>
<p>vector of length n representing the x coordinates (or longitude; see latlon).</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_y">y</code></td>
<td>
<p>vector of length n representing the y coordinates (or latitude).</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_z">z</code></td>
<td>
<p>matrix of dimension n x p representing p observation at each location.</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_resamp">resamp</code></td>
<td>
<p>the number of resamples for the null distribution.</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_latlon">latlon</code></td>
<td>
<p>If TRUE, coordinates are latitude and longitude.</p>
</td></tr>
<tr><td><code id="mantel.test_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, the counter is suppressed during execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Typical usages are
</p>
<pre>
mantel.test(M1, M2, x = NULL, y = NULL, z = NULL, resamp = 999, 
            latlon = FALSE, quiet = FALSE)

mantel.test(x, y, z, M1 = NULL, M2 = NULL, resamp = 999, latlon = FALSE, 
            quiet = FALSE)
</pre>
<p>Missing values are treated through pairwise deletion.
</p>


<h3>Value</h3>

<p>An object of class &quot;Mantel&quot; is returned, consisting of a list with two components:
</p>
<table>
<tr><td><code>correlation</code></td>
<td>
<p>the value for the Mantel correlation.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the randomization-based two-sided p-value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ottar N. Bjornstad <a href="mailto:onb1@psu.edu">onb1@psu.edu</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate some sample data
x &lt;- expand.grid(1:20, 1:5)[, 1]
y &lt;- expand.grid(1:20, 1:5)[, 2]
# z data from an exponential random field
z &lt;- cbind(
  rmvn.spa(x = x, y = y, p = 2, method = "exp"), 
  rmvn.spa(x = x, y = y, p = 2, method = "exp")
  )

# the Mantel test
mantel.test(x = x, y = y, z = z[, 1], resamp = 999)
</code></pre>

<hr>
<h2 id='mSynch'>The mean (cross-)correlation (with bootstrapp CI) for a panel of spatiotemporal data</h2><span id='topic+mSynch'></span>

<h3>Description</h3>

<p><code>mSynch</code> is the function to estimate the mean (cross-)correlation in a spatiotemporal dataset as discussed in Bjornstad et al. (1999). The function requires multiple observations at each location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mSynch(x, y = NULL, resamp = 999, na.rm = FALSE, circ = FALSE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mSynch_+3A_x">x</code></td>
<td>
<p>matrix of dimension n x p representing p observation at each location (i.e. each row is a time series).</p>
</td></tr>
<tr><td><code id="mSynch_+3A_y">y</code></td>
<td>
<p>optional matrix of dimension m x p representing p observation at each location (i.e. each row is a time series). If provided, the mean cross-correlation between the two panels is computed.</p>
</td></tr>
<tr><td><code id="mSynch_+3A_resamp">resamp</code></td>
<td>
<p>the number of resamples for the bootstrap or the null distribution.</p>
</td></tr>
<tr><td><code id="mSynch_+3A_na.rm">na.rm</code></td>
<td>
<p>If TRUE, NA's will be dealt with through pairwise deletion of missing values for each pair of time series &ndash; it will dump if any one pair has less than two (temporally) overlapping observations.</p>
</td></tr>
<tr><td><code id="mSynch_+3A_circ">circ</code></td>
<td>
<p>If TRUE, the observations are assumed to be angular (in radians), and circular correlation is used.</p>
</td></tr>
<tr><td><code id="mSynch_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, the counter is suppressed during execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values are allowed &ndash; values are assumed missing at random. 
</p>
<p>The circ argument computes a circular version of the Pearson's product moment correlation (see <code><a href="#topic+cor2">cor2</a></code>).
</p>


<h3>Value</h3>

<p>An object of class &quot;mSynch&quot; is returned, consisting of a list with two components: 
</p>
<table>
<tr><td><code>real</code></td>
<td>
<p>the regional average correlation.</p>
</td></tr>
<tr><td><code>boot</code></td>
<td>
<p>a vector of bootstrap resamples.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ottar N. Bjornstad <a href="mailto:onb1@psu.edu">onb1@psu.edu</a>
</p>


<h3>References</h3>

<p>Bjornstad, O.N., Ims, R.A. &amp; Lambin, X. (1999) Spatial population dynamics: Analysing patterns and processes of population synchrony. Trends in Ecology and Evolution, 11, 427-431. &lt;doi:10.1016/S0169-5347(99)01677-8&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+print.mSynch">print.mSynch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate some sample data
x &lt;- expand.grid(1:20, 1:5)[, 1]
y &lt;- expand.grid(1:20, 1:5)[, 2]
# z data from an exponential random field
z &lt;- cbind(
  rmvn.spa(x = x, y = y, p = 2, method = "exp"), 
  rmvn.spa(x = x, y = y, p = 2, method = "exp")
  )

# mean correlation analysis
fit1 &lt;- mSynch(x = z, resamp = 500)
print(fit1)
</code></pre>

<hr>
<h2 id='partial.mantel.test'>Partial Mantel test</h2><span id='topic+partial.mantel.test'></span>

<h3>Description</h3>

<p>A simple function to calculate permutation-based partial mantel tests for three matrices, the partial mantel test is calculated to test for relationships between M1 and M2 (M3) controlling for M3 (M2). syntax and logic follows Legendre and Legendre (1998) pp 557-558.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial.mantel.test(
  M1,
  M2,
  M3,
  resamp = 999,
  method = "pearson",
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial.mantel.test_+3A_m1">M1</code></td>
<td>
<p>similarity/distance matrix 1</p>
</td></tr>
<tr><td><code id="partial.mantel.test_+3A_m2">M2</code></td>
<td>
<p>similarity/distance matrix 2</p>
</td></tr>
<tr><td><code id="partial.mantel.test_+3A_m3">M3</code></td>
<td>
<p>similarity/distance matrix 3</p>
</td></tr>
<tr><td><code id="partial.mantel.test_+3A_resamp">resamp</code></td>
<td>
<p>the number of resamples for the null distribution.</p>
</td></tr>
<tr><td><code id="partial.mantel.test_+3A_method">method</code></td>
<td>
<p>the method to be used for calculating the correlations.</p>
</td></tr>
<tr><td><code id="partial.mantel.test_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, the counter is suppressed during execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values are treated through pairwise deletion. 
</p>
<p>The method must be one of &quot;pearson&quot; (default), &quot;spearman&quot; or &quot;kendall&quot;.
</p>


<h3>Value</h3>

<p>An object of class &quot;partial.Mantel&quot; is returned, consisting of a list with two components:
</p>
<table>
<tr><td><code>MantelR</code></td>
<td>
<p>the vector of observed Mantel and partial Mantel correlations.</p>
</td></tr>
<tr><td><code>p</code></td>
<td>
<p>the vector of two-sided p-value under randomization (of M1).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ottar N. Bjornstad <a href="mailto:onb1@psu.edu">onb1@psu.edu</a>
</p>


<h3>References</h3>

<p>Legendre, P., and L. Legendre. 1998. Numerical Ecology, 2nd edition. Elsevier, Amsterdam
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mantel.test">mantel.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate some sample data and dissimilarity matrices
x &lt;- rnorm(10)
y &lt;- rnorm(10)
z &lt;- rnorm(10)
M1 &lt;- sqrt(outer(x, x, "-")^2)
M2 &lt;- sqrt(outer(y, y, "-")^2)
M3 &lt;- sqrt(outer(z, z, "-")^2)

partial.mantel.test(M1 = M1, M2 = M2, M3 = M3, resamp = 999)
</code></pre>

<hr>
<h2 id='plot.cc.offset'>Plots the cc.offset summary of the anisotropic spatial correlation-functions</h2><span id='topic+plot.cc.offset'></span>

<h3>Description</h3>

<p>plot method for class &quot;cc.offset&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cc.offset'
plot(x, dmax = NULL, inches = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cc.offset_+3A_x">x</code></td>
<td>
<p>an object of class &quot;cc.offset&quot;, usually, as a result of applying <code>cc.offset</code> to an object of class <code>Sncf2D</code>.</p>
</td></tr>
<tr><td><code id="plot.cc.offset_+3A_dmax">dmax</code></td>
<td>
<p>the maximal distance for radial plot. If NULL, the maximum distance in the data will be used.</p>
</td></tr>
<tr><td><code id="plot.cc.offset_+3A_inches">inches</code></td>
<td>
<p>the size of the symbols.If NULL, default is 0.1.</p>
</td></tr>
<tr><td><code id="plot.cc.offset_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A radial symbol plot results. The radius represents the distance to peak correlation (the mode) of the correlation function (in the positive direction). The size of the symbol represents the magnitude of the correlation at the mode for the given cardinal direction.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cc.offset">cc.offset</a></code>, <code><a href="#topic+Sncf2D">Sncf2D</a></code>, <code><a href="#topic+plot.Sncf2D">plot.Sncf2D</a></code>
</p>

<hr>
<h2 id='plot.correlog'>Plots spatial correlograms</h2><span id='topic+plot.correlog'></span>

<h3>Description</h3>

<p>&lsquo;plot&rsquo; method for class &quot;correlog&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'correlog'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.correlog_+3A_x">x</code></td>
<td>
<p>an object of class &quot;correlog&quot;, usually, as a result of a call to <code>correlog</code> or <code>correlog.nc</code>.</p>
</td></tr>
<tr><td><code id="plot.correlog_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A spatial or Mantel (cross-correlogram) is plotted. 
</p>
<p>If a permutation test was performed, values significant at a nominal (two-sided) 5%-level will be represented by filled circles and non-significant values by open circles.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+correlog">correlog</a></code>, <code><a href="#topic+correlog.nc">correlog.nc</a></code>
</p>

<hr>
<h2 id='plot.lisa'>Plots local indicators of spatial association</h2><span id='topic+plot.lisa'></span>

<h3>Description</h3>

<p>&lsquo;plot&rsquo; method for class &quot;lisa&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lisa'
plot(x, neigh.mean = FALSE, add = FALSE, inches = 0.2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.lisa_+3A_x">x</code></td>
<td>
<p>an object of class &quot;lisa&quot;, usually, as a result of a call to <code><a href="#topic+lisa">lisa</a></code>.</p>
</td></tr>
<tr><td><code id="plot.lisa_+3A_neigh.mean">neigh.mean</code></td>
<td>
<p>If TRUE, size of symbols represents average observation in each neighborhood; If FALSE, size of symbols represents the original observation</p>
</td></tr>
<tr><td><code id="plot.lisa_+3A_add">add</code></td>
<td>
<p>If TRUE, a lisa-plot will be added to a pre-existing plot.</p>
</td></tr>
<tr><td><code id="plot.lisa_+3A_inches">inches</code></td>
<td>
<p>scales the size of the symbols</p>
</td></tr>
<tr><td><code id="plot.lisa_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A bubble-plot of observations against spatial coordinates is produced. Above mean values are signified by red circles. Below mean values are signified by black squares. 
</p>
<p>If a permutation test was performed, observations for which the associated LISA statistic is significant at a nominal (two-sided) 5%-level will be represented by filled symbols and non-significant values by open symbols. Thus spatial hot-spots are represented by red filled circles and cold-spots by black filled squares.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lisa">lisa</a></code>, <code><a href="#topic+lisa.nc">lisa.nc</a></code>
</p>

<hr>
<h2 id='plot.Sncf'>Plots nonparametric spatial correlation-functions</h2><span id='topic+plot.Sncf'></span>

<h3>Description</h3>

<p>'plot' method for class &quot;Sncf&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Sncf'
plot(x, ylim = c(-1, 1), add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Sncf_+3A_x">x</code></td>
<td>
<p>an object of class &quot;Sncf&quot;, usually, as a result of a call to <code>Sncf</code> (or <code>Sncf.srf</code>).</p>
</td></tr>
<tr><td><code id="plot.Sncf_+3A_ylim">ylim</code></td>
<td>
<p>limits for the y-axis (default: -1, 1).</p>
</td></tr>
<tr><td><code id="plot.Sncf_+3A_add">add</code></td>
<td>
<p>If TRUE the plot is added on to the previous graph.</p>
</td></tr>
<tr><td><code id="plot.Sncf_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the nonparametric spatial covariance function (with CI's if bootstraps are available)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sncf">Sncf</a></code>, <code><a href="#topic+Sncf.srf">Sncf.srf</a></code>
</p>

<hr>
<h2 id='plot.Sncf.cov'>Plots nonparametric spatial covariance-functions</h2><span id='topic+plot.Sncf.cov'></span>

<h3>Description</h3>

<p>'plot' method for class &quot;Sncf.cov&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Sncf.cov'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Sncf.cov_+3A_x">x</code></td>
<td>
<p>an object of class &quot;Sncf.cov&quot;, usually, as a result of a call to <code>Sncf.srf</code> (with <code>corr</code> = FALSE).</p>
</td></tr>
<tr><td><code id="plot.Sncf.cov_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the nonparametric spatial covariance function (with CI's if bootstrapps are available)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sncf.srf">Sncf.srf</a></code>, <code><a href="#topic+plot.Sncf">plot.Sncf</a></code>
</p>

<hr>
<h2 id='plot.Sncf2D'>Plots anisotropic spatial correlation-functions</h2><span id='topic+plot.Sncf2D'></span>

<h3>Description</h3>

<p>plot method for class &quot;Sncf2D&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Sncf2D'
plot(x, xmax = 0, ylim = c(-1, 1), detail = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.Sncf2D_+3A_x">x</code></td>
<td>
<p>an object of class &quot;Sncf2D&quot;, usually, as a result of a call to <code>Sncf2D</code>.</p>
</td></tr>
<tr><td><code id="plot.Sncf2D_+3A_xmax">xmax</code></td>
<td>
<p>the maximal distance to be plotted on the x-axis. If set to zero the maximum distance in the data will be used.</p>
</td></tr>
<tr><td><code id="plot.Sncf2D_+3A_ylim">ylim</code></td>
<td>
<p>limits for the y-axis (default: -1, 1).</p>
</td></tr>
<tr><td><code id="plot.Sncf2D_+3A_detail">detail</code></td>
<td>
<p>If TRUE, a separate plot is made for each direction (including confidence envelopes; see <code><a href="#topic+plot.Sncf">plot.Sncf</a></code> for details. If FALSE, all correlation functions are superimposed on the same plot.</p>
</td></tr>
<tr><td><code id="plot.Sncf2D_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot or panel-plot results. These represents the xy-plot of distance against spatial (cross-)correlation for each cardinal direction.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sncf2D">Sncf2D</a></code>, <code><a href="#topic+plot.Sncf">plot.Sncf</a></code>
</p>

<hr>
<h2 id='plot.spline.correlog'>Plots a spline correlogram</h2><span id='topic+plot.spline.correlog'></span>

<h3>Description</h3>

<p>&lsquo;plot&rsquo; method for class &quot;spline.correlog&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spline.correlog'
plot(x, ylim = c(-1, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.spline.correlog_+3A_x">x</code></td>
<td>
<p>an object of class &quot;spline.correlog&quot;, usually, as a result of a call to <code>spline.correlog</code>.</p>
</td></tr>
<tr><td><code id="plot.spline.correlog_+3A_ylim">ylim</code></td>
<td>
<p>limits for the y-axis (default: -1, 1).</p>
</td></tr>
<tr><td><code id="plot.spline.correlog_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the spline correlogram function against distance is produced. 95% pointwise confidence (or null) envelopes are superimposed (if available).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spline.correlog">spline.correlog</a></code>, <code><a href="#topic+summary.spline.correlog">summary.spline.correlog</a></code>
</p>

<hr>
<h2 id='print.mSynch'>Print function for mSynch objects</h2><span id='topic+print.mSynch'></span>

<h3>Description</h3>

<p>&lsquo;print&rsquo; method for class &quot;mSynch&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mSynch'
print(x, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mSynch_+3A_x">x</code></td>
<td>
<p>an object of class &quot;mSynch&quot;, usually, as a result of a call to <code>mSynch</code>.</p>
</td></tr>
<tr><td><code id="print.mSynch_+3A_verbose">verbose</code></td>
<td>
<p>If TRUE, a raw listing of the object is produced. If FALSE, a summary list is produced</p>
</td></tr>
<tr><td><code id="print.mSynch_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If verbose is FALSE, a list summarizing the regional correlation is produced: 
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>the regional mean correlation.</p>
</td></tr> 
<tr><td><code>Squantile</code></td>
<td>
<p>the quantile distribution from the resampling for the regional correlation.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mSynch">mSynch</a></code>
</p>

<hr>
<h2 id='print.Sncf'>Print function for Sncf objects</h2><span id='topic+print.Sncf'></span>

<h3>Description</h3>

<p>'print' method for class &quot;Sncf&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Sncf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Sncf_+3A_x">x</code></td>
<td>
<p>an object of class &quot;Sncf&quot;, usually, as a result of a call to <code>Sncf</code> or related).</p>
</td></tr>
<tr><td><code id="print.Sncf_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function-call is printed to screen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sncf">Sncf</a></code>
</p>

<hr>
<h2 id='print.Sncf2D'>Print function for Sncf2D objects</h2><span id='topic+print.Sncf2D'></span>

<h3>Description</h3>

<p>&lsquo;print&rsquo; method for class &quot;Sncf2D&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Sncf2D'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.Sncf2D_+3A_x">x</code></td>
<td>
<p>an object of class &quot;Sncf2D&quot;, usually, as a result of a call to <code>Sncf2D</code> or <code>spline.correlog2D</code>).</p>
</td></tr>
<tr><td><code id="print.Sncf2D_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function-call is printed to screen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sncf2D">Sncf2D</a></code>
</p>

<hr>
<h2 id='print.spline.correlog'>Print function for spline.correlog objects</h2><span id='topic+print.spline.correlog'></span>

<h3>Description</h3>

<p>&lsquo;print&rsquo; method for class &quot;spline.correlog&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spline.correlog'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spline.correlog_+3A_x">x</code></td>
<td>
<p>an object of class &quot;spline.correlog&quot;, usually, as a result of a call to <code>spline.correlog</code> or related).</p>
</td></tr>
<tr><td><code id="print.spline.correlog_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function-call is printed to screen.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+spline.correlog">spline.correlog</a></code>
</p>

<hr>
<h2 id='rmvn.spa'>Simulate spatially correlated data</h2><span id='topic+rmvn.spa'></span>

<h3>Description</h3>

<p>Function to generate spatially autocorrelated random normal variates using the eigendecomposition method. Spatial covariance can follow either and exponential or Gaussian model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvn.spa(x, y, p, method = "exp", nugget = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvn.spa_+3A_x">x</code></td>
<td>
<p>vector of length n representing the x coordinates (or latitude; see latlon).</p>
</td></tr>
<tr><td><code id="rmvn.spa_+3A_y">y</code></td>
<td>
<p>vector of length n representing the y coordinates (or longitude).</p>
</td></tr>
<tr><td><code id="rmvn.spa_+3A_p">p</code></td>
<td>
<p>the range of the spatial models.</p>
</td></tr>
<tr><td><code id="rmvn.spa_+3A_method">method</code></td>
<td>
<p>correlation function &quot;exp&quot; (exponential) or &quot;gaus&quot; (gaussian). Exponential is the default.</p>
</td></tr>
<tr><td><code id="rmvn.spa_+3A_nugget">nugget</code></td>
<td>
<p>correlation at the origin (defaults to one)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A target covariance matrix A between the n units is generated by calculating the distances between the locations and thereafter evaluating the covariance function in each pairwise distance. A vector, Z, of spatially correlated normal data with the target covariance is subsequently generated using the eigendecomposition method (Ripley, 1987).
</p>


<h3>Value</h3>

<p>A vector of spatially correlated random normal variates with zero mean and unit variance is returned
</p>


<h3>Author(s)</h3>

<p>Ottar N. Bjornstad <a href="mailto:onb1@psu.edu">onb1@psu.edu</a>
</p>


<h3>References</h3>

<p>Ripley, B.D. (1987). Stochastic Simulation. Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mSynch">mSynch</a></code>
</p>

<hr>
<h2 id='Sncf'>Nonparametric (cross-)correlation function for spatio-temporal data</h2><span id='topic+Sncf'></span>

<h3>Description</h3>

<p><code>Sncf</code> is the function to estimate the nonparametric (cross-)correlation function using a smoothing spline as an equivalent kernel. The function requires multiple observations at each location (use <code><a href="#topic+spline.correlog">spline.correlog</a></code> otherwise).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sncf(
  x,
  y,
  z,
  w = NULL,
  df = NULL,
  type = "boot",
  resamp = 1000,
  npoints = 300,
  save = FALSE,
  filter = FALSE,
  fw = 0,
  max.it = 25,
  xmax = FALSE,
  na.rm = FALSE,
  latlon = FALSE,
  circ = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sncf_+3A_x">x</code></td>
<td>
<p>vector of length n representing the x coordinates (or longitude; see latlon).</p>
</td></tr>
<tr><td><code id="Sncf_+3A_y">y</code></td>
<td>
<p>vector of length n representing the y coordinates (or latitude).</p>
</td></tr>
<tr><td><code id="Sncf_+3A_z">z</code></td>
<td>
<p>matrix of dimension n x p representing p observation at each location.</p>
</td></tr>
<tr><td><code id="Sncf_+3A_w">w</code></td>
<td>
<p>an optional second matrix of dimension n x p for species 2 (to estimate the spatial cross-correlation function).</p>
</td></tr>
<tr><td><code id="Sncf_+3A_df">df</code></td>
<td>
<p>degrees of freedom for the spline. Default is sqrt(n).</p>
</td></tr>
<tr><td><code id="Sncf_+3A_type">type</code></td>
<td>
<p>takes the value &quot;boot&quot; (default) to generate a bootstrap distribution or &quot;perm&quot; to generate a null distribution for the estimator</p>
</td></tr>
<tr><td><code id="Sncf_+3A_resamp">resamp</code></td>
<td>
<p>the number of resamples for the bootstrap or the null distribution.</p>
</td></tr>
<tr><td><code id="Sncf_+3A_npoints">npoints</code></td>
<td>
<p>the number of points at which to save the value for the spline function (and confidence envelope / null distribution).</p>
</td></tr>
<tr><td><code id="Sncf_+3A_save">save</code></td>
<td>
<p>If TRUE, the whole matrix of output from the resampling is saved (a resamp x npoints dimensional matrix).</p>
</td></tr>
<tr><td><code id="Sncf_+3A_filter">filter</code></td>
<td>
<p>If TRUE, the Fourier filter method of Hall and coworkers is applied to ensure positive semi-definiteness of the estimator. (more work may be needed on this.)</p>
</td></tr>
<tr><td><code id="Sncf_+3A_fw">fw</code></td>
<td>
<p>If filter is TRUE, it may be useful to truncate the function at some distance w sets the truncation distance. when set to zero no truncation is done.</p>
</td></tr>
<tr><td><code id="Sncf_+3A_max.it">max.it</code></td>
<td>
<p>the maximum iteration for the Newton method used to estimate the intercepts.</p>
</td></tr>
<tr><td><code id="Sncf_+3A_xmax">xmax</code></td>
<td>
<p>If FALSE, the max observed in the data is used. Otherwise all distances greater than xmax is omitted.</p>
</td></tr>
<tr><td><code id="Sncf_+3A_na.rm">na.rm</code></td>
<td>
<p>If TRUE, NA's will be dealt with through pairwise deletion of missing values for each pair of time series &ndash; it will dump if any one pair has less than two (temporally) overlapping observations.</p>
</td></tr>
<tr><td><code id="Sncf_+3A_latlon">latlon</code></td>
<td>
<p>If TRUE, coordinates are latitude and longitude.</p>
</td></tr>
<tr><td><code id="Sncf_+3A_circ">circ</code></td>
<td>
<p>If TRUE, the observations are assumed to be angular (in radians), and circular correlation is used.</p>
</td></tr>
<tr><td><code id="Sncf_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, the counter is suppressed during execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Missing values are allowed &ndash; values are assumed missing at random. 
</p>
<p>The circ argument computes a circular version of the Pearson's product moment correlation (see <code><a href="#topic+cor2">cor2</a></code>). This option is to calculate the 'nonparametric phase coherence function' (Grenfell et al. 2001)
</p>


<h3>Value</h3>

<p>An object of class &quot;Sncf&quot; is returned, consisting of the following components: 
</p>
<table>
<tr><td><code>real</code></td>
<td>
<p>the list of estimates from the data.</p>
</td></tr>
<tr><td><code>$cbar</code></td>
<td>
<p>the regional average correlation.</p>
</td></tr>
<tr><td><code>$x.intercept</code></td>
<td>
<p>the lowest value at which the function is = 0. If correlation is initially negative, the distance is given as negative.</p>
</td></tr>
<tr><td><code>$e.intercept</code></td>
<td>
<p>the lowest value at which the function 1/e.</p>
</td></tr>
<tr><td><code>$y.intercept</code></td>
<td>
<p>the extrapolated value at x=0 (nugget).</p>
</td></tr>
<tr><td><code>$cbar.intercept</code></td>
<td>
<p>distance at which regional average correlation is reach.</p>
</td></tr>
<tr><td><code>$predicted$x</code></td>
<td>
<p>the x-axes for the fitted covariance function.</p>
</td></tr>
<tr><td><code>$predcited$y</code></td>
<td>
<p>the values for the covariance function.</p>
</td></tr>
<tr><td><code>boot</code></td>
<td>
<p>a list with the analogous output from the bootstrap or null distribution.</p>
</td></tr> 
<tr><td><code>$summary</code></td>
<td>
<p>gives the full vector of output for the x.intercept, y.intercept, e.intercept, cbar.intercept, cbar and a quantile summary for the resampling distribution.</p>
</td></tr>
<tr><td><code>$boot</code></td>
<td>
<p>If save=TRUE, the full raw matrices from the resampling is saved.</p>
</td></tr>
<tr><td><code>max.distance</code></td>
<td>
<p>the maximum spatial distance considered.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ottar N. Bjornstad <a href="mailto:onb1@psu.edu">onb1@psu.edu</a>
</p>


<h3>References</h3>

<p>Hall, P. and Patil, P. (1994) Properties of nonparametric estimators of autocovariance for stationary random fields. Probability Theory and Related Fields, 99:399-424. &lt;doi:10.1007/BF01199899&gt;
</p>
<p>Hall, P., Fisher, N.I. and Hoffmann, B. (1994) On the nonparametric estimation of covariance functions. Annals of Statistics, 22:2115-2134 &lt;doi:10.1214/aos/1176325774&gt;.
</p>
<p>Bjornstad, O.N. and Falck, W. (2001) Nonparametric spatial covariance functions: estimation and testing. Environmental and Ecological Statistics, 8:53-70 &lt;doi:10.1023/A:1009601932481&gt;.
</p>
<p>Bjornstad, O.N., Ims, R.A. and Lambin, X. (1999) Spatial population dynamics: Analysing patterns and processes of population synchrony. Trends in Ecology and Evolution, 11:427-431 &lt;doi:10.1016/S0169-5347(99)01677-8&gt;.
</p>
<p>Bjornstad, O. N., and J. Bascompte. (2001) Synchrony and second order spatial correlation in host-parasitoid systems. Journal of Animal Ecology 70:924-933 &lt;doi:10.1046/j.0021-8790.2001.00560.x&gt;.
</p>
<p>Grenfell, B.T., Bjornstad, O.N., &amp; Kappey, J. (2001) Travelling waves and spatial hierarchies in measles epidemics. Nature 414:716-723. &lt;doi:10.1038/414716a&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sncf2D">Sncf2D</a></code>, <code><a href="#topic+Sncf.srf">Sncf.srf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate some sample data
x &lt;- expand.grid(1:20, 1:5)[, 1]
y &lt;- expand.grid(1:20, 1:5)[, 2]
# z data from an exponential random field
z &lt;- cbind(
   rmvn.spa(x = x, y = y, p = 2, method = "exp"),
   rmvn.spa(x = x, y = y, p = 2, method = "exp")
  )
# w data from a gaussian random field
w &lt;- cbind(
  rmvn.spa(x = x, y = y, p = 2, method = "gaus"), 
  rmvn.spa(x = x, y = y, p = 2, method = "gaus")
  )
# multivariate nonparametric covariance function
fit1 &lt;- Sncf(x = x, y = y, z = z, resamp = 0)
## Not run: plot.Sncf(fit1)
summary(fit1)

# multivariate nonparametric cross-covariance function
fit2 &lt;- Sncf(x = x, y = y, z = z, w = w, resamp = 0)
## Not run: plot(fit2)
summary(fit2)
</code></pre>

<hr>
<h2 id='Sncf.srf'>Nonparametric (Cross-)Covariance Function from stationary random fields</h2><span id='topic+Sncf.srf'></span>

<h3>Description</h3>

<p><code>Sncf.srf</code> is the function to estimate the nonparametric for spatio-temporal data from fully stationary random fields (i.e. marginal expectation and variance identical for all locations; use <code><a href="#topic+Sncf">Sncf</a></code> otherwise).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sncf.srf(
  x,
  y,
  z,
  w = NULL,
  avg = NULL,
  avg2 = NULL,
  corr = TRUE,
  df = NULL,
  type = "boot",
  resamp = 0,
  npoints = 300,
  save = FALSE,
  filter = FALSE,
  fw = 0,
  max.it = 25,
  xmax = FALSE,
  jitter = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sncf.srf_+3A_x">x</code></td>
<td>
<p>vector of length n representing the x coordinates (or longitude; see latlon).</p>
</td></tr>
<tr><td><code id="Sncf.srf_+3A_y">y</code></td>
<td>
<p>vector of length n representing the y coordinates (or latitude).</p>
</td></tr>
<tr><td><code id="Sncf.srf_+3A_z">z</code></td>
<td>
<p>matrix of dimension n x p representing p observation at each location.</p>
</td></tr>
<tr><td><code id="Sncf.srf_+3A_w">w</code></td>
<td>
<p>an optional second matrix of dimension n x p for variable 2 (to estimate the spatial cross-correlation function).</p>
</td></tr>
<tr><td><code id="Sncf.srf_+3A_avg">avg</code></td>
<td>
<p>supplies the marginal expectation of the Markov random field; if TRUE, the sample mean (across the markovian field) is used.</p>
</td></tr>
<tr><td><code id="Sncf.srf_+3A_avg2">avg2</code></td>
<td>
<p>optionally supplies the marginal expectation of the Markov random field for optional variable 2; if TRUE, the sample mean is used.</p>
</td></tr>
<tr><td><code id="Sncf.srf_+3A_corr">corr</code></td>
<td>
<p>If TRUE, the covariance function is standardized by the marginal variance (across the Markovian field) to return a correlation function (alternatively the covariance function is returned).</p>
</td></tr>
<tr><td><code id="Sncf.srf_+3A_df">df</code></td>
<td>
<p>degrees of freedom for the spline. Default is sqrt(n).</p>
</td></tr>
<tr><td><code id="Sncf.srf_+3A_type">type</code></td>
<td>
<p>takes the value &quot;boot&quot; (default) to generate a bootstrap distribution or &quot;perm&quot; to generate a null distribution for the estimator</p>
</td></tr>
<tr><td><code id="Sncf.srf_+3A_resamp">resamp</code></td>
<td>
<p>the number of resamples for the bootstrap or the null distribution.</p>
</td></tr>
<tr><td><code id="Sncf.srf_+3A_npoints">npoints</code></td>
<td>
<p>the number of points at which to save the value for the spline function (and confidence envelope / null distribution).</p>
</td></tr>
<tr><td><code id="Sncf.srf_+3A_save">save</code></td>
<td>
<p>If TRUE, the whole matrix of output from the resampling is saved (an resamp x npoints dimensional matrix).</p>
</td></tr>
<tr><td><code id="Sncf.srf_+3A_filter">filter</code></td>
<td>
<p>If TRUE, the Fourier filter method of Hall and coworkers is applied to ensure positive semidefiniteness of the estimator. (more work may be needed on this.)</p>
</td></tr>
<tr><td><code id="Sncf.srf_+3A_fw">fw</code></td>
<td>
<p>If filter is TRUE, it may be useful to truncate the function at some distance w sets the truncation distance. When set to zero no truncation is done.</p>
</td></tr>
<tr><td><code id="Sncf.srf_+3A_max.it">max.it</code></td>
<td>
<p>the maximum iteration for the Newton method used to estimate the intercepts.</p>
</td></tr>
<tr><td><code id="Sncf.srf_+3A_xmax">xmax</code></td>
<td>
<p>If FALSE, the max observed in the data is used. Otherwise all distances greater than xmax is omitted.</p>
</td></tr>
<tr><td><code id="Sncf.srf_+3A_jitter">jitter</code></td>
<td>
<p>If TRUE, jitters the distance matrix, to avoid problems associated with fitting the function to data on regular grids.</p>
</td></tr>
<tr><td><code id="Sncf.srf_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, the counter is suppressed during execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>corr = F</code>, an object of class &quot;Sncf.cov&quot; is returned. Otherwise the class is &quot;Sncf&quot;.
</p>
<p><code>Sncf.srf</code> is a function to estimate the nonparametric (cross-)covariance function (as discussed in Bjornstad and Bascompte 2001) for data from a fully stationary random fields. I have found it useful to estimate the (cross-)covariance functions in synthetic data.
</p>


<h3>Value</h3>

<p>An object of class &quot;Sncf&quot; (or &quot;Sncf.cov&quot;) is returned. See <code><a href="#topic+Sncf">Sncf</a></code> for details.
</p>


<h3>Author(s)</h3>

<p>Ottar N. Bjornstad <a href="mailto:onb1@psu.edu">onb1@psu.edu</a>
</p>


<h3>References</h3>

<p>Bjornstad, O. N., and J. Bascompte. (2001) Synchrony and second order spatial correlation in host-parasitoid systems. Journal of Animal Ecology 70:924-933. &lt;doi:10.1046/j.0021-8790.2001.00560.x&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sncf">Sncf</a></code>, <code><a href="#topic+summary.Sncf">summary.Sncf</a></code>, <code><a href="#topic+plot.Sncf">plot.Sncf</a></code>, <code><a href="#topic+plot.Sncf.cov">plot.Sncf.cov</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate some sample data
x &lt;- expand.grid(1:20, 1:5)[, 1]
y &lt;- expand.grid(1:20, 1:5)[, 2]

# z data from an exponential random field
z &lt;- cbind(
  rmvn.spa(x = x, y = y, p = 2, method = "exp"), 
  rmvn.spa(x = x, y = y, p = 2, method = "exp")
  )

# w data from a gaussian random field
w &lt;- cbind(
  rmvn.spa(x = x, y = y, p = 2, method = "gaus"), 
  rmvn.spa(x = x, y = y, p = 2, method = "gaus")
  )

# multivariate nonparametric covariance function
fit1 &lt;- Sncf.srf(x = x, y = y, z = z, avg = NULL, corr = TRUE, resamp = 0) 
## Not run: plot(fit1) 
summary(fit1)

# multivariate nonparametric cross-covariance function (with known
# marginal expectation of zero for both z and w
fit2 &lt;- Sncf.srf(x = x, y = y, z = z, w = w, avg = 0, avg2 = 0, corr = FALSE, 
                 resamp = 0)
## Not run: plot(fit2) 
summary(fit2)
</code></pre>

<hr>
<h2 id='Sncf2D'>Anisotropic nonparametric (cross-)correlation function for spatio-temporal data</h2><span id='topic+Sncf2D'></span>

<h3>Description</h3>

<p><code>Sncf2D</code> is the function to estimate the anisotropic nonparametric correlation function in 8 (or arbitrary) directions (North - Southeast). Correlation functions are calculated for each different bearing. The function requires multiple observations at each location. (use <code><a href="#topic+spline.correlog2D">spline.correlog2D</a></code> otherwise).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Sncf2D(
  x,
  y,
  z,
  w = NULL,
  df = NULL,
  type = "boot",
  resamp = 1000,
  npoints = 300,
  save = FALSE,
  max.it = 25,
  xmax = FALSE,
  na.rm = FALSE,
  jitter = FALSE,
  quiet = FALSE,
  angle = c(0, 22.5, 45, 67.5, 90, 112.5, 135, 157.5)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Sncf2D_+3A_x">x</code></td>
<td>
<p>vector of length n representing the x coordinates.</p>
</td></tr>
<tr><td><code id="Sncf2D_+3A_y">y</code></td>
<td>
<p>vector of length n representing the y coordinates.</p>
</td></tr>
<tr><td><code id="Sncf2D_+3A_z">z</code></td>
<td>
<p>matrix of dimension n x p representing p observation at each location.</p>
</td></tr>
<tr><td><code id="Sncf2D_+3A_w">w</code></td>
<td>
<p>an optional second matrix of dimension n x p for variable 2 (to estimate spatial or lagged cross-correlation functions).</p>
</td></tr>
<tr><td><code id="Sncf2D_+3A_df">df</code></td>
<td>
<p>degrees of freedom for the spline. Default is sqrt(n).</p>
</td></tr>
<tr><td><code id="Sncf2D_+3A_type">type</code></td>
<td>
<p>takes the value &quot;boot&quot; (default) to generate a bootstrap distribution or &quot;perm&quot; to generate a null distribution for the estimator</p>
</td></tr>
<tr><td><code id="Sncf2D_+3A_resamp">resamp</code></td>
<td>
<p>the number of resamples for the bootstrap or the null distribution.</p>
</td></tr>
<tr><td><code id="Sncf2D_+3A_npoints">npoints</code></td>
<td>
<p>the number of points at which to save the value for the spline function (and confidence envelope / null distribution).</p>
</td></tr>
<tr><td><code id="Sncf2D_+3A_save">save</code></td>
<td>
<p>If TRUE, the whole matrix of output from the resampling is saved (an resamp x npoints dimensional matrix).</p>
</td></tr>
<tr><td><code id="Sncf2D_+3A_max.it">max.it</code></td>
<td>
<p>the maximum iteration for the Newton method used to estimate the intercepts.</p>
</td></tr>
<tr><td><code id="Sncf2D_+3A_xmax">xmax</code></td>
<td>
<p>If FALSE, the max observed in the data is used. Otherwise all distances greater than xmax is omitted.</p>
</td></tr>
<tr><td><code id="Sncf2D_+3A_na.rm">na.rm</code></td>
<td>
<p>If TRUE, NA's will be dealt with through pairwise deletion of missing values for each pair of time series &ndash; it will dump if any one pair has less than two (temporally) overlapping observations.</p>
</td></tr>
<tr><td><code id="Sncf2D_+3A_jitter">jitter</code></td>
<td>
<p>If TRUE, jitters the distance matrix, to avoid problems associated with fitting the function to data on regular grids</p>
</td></tr>
<tr><td><code id="Sncf2D_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, the counter is suppressed during execution.</p>
</td></tr>
<tr><td><code id="Sncf2D_+3A_angle">angle</code></td>
<td>
<p>specifies number of cardinal directions and angles for which to calculate correlation functions. Default are 8 directions between 0 and 180.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Correlation functions are calculated on projected distances onto the different bearings so ALL data are used for each direction. The (obsolete?) <code>oldncf2D</code> used the alternative of slicing up the data like pieces of a pie.
</p>
<p>Latitude-longitude coordinates can NOT be used.
</p>
<p>Missing values are allowed - values are assumed missing at random.
</p>
<p>I have implemented an optional argument: <code>jitter</code> if TRUE this jitters the distance matrix, to avoid some problems I've had with spline-smoothing data from regular grid-data.
</p>


<h3>Value</h3>

<p>An object of class &quot;Sncf2D&quot; is returned, consisting of a list of estimates for each cardinal direction :
</p>
<table>
<tr><td><code>real</code></td>
<td>
<p>the list of estimates from the data.</p>
</td></tr>
<tr><td><code>$cbar</code></td>
<td>
<p>the regional average correlation.</p>
</td></tr>
<tr><td><code>$x.intercept</code></td>
<td>
<p>the lowest value at which the function is = 0. If correlation is initially negative, the distance is given as negative.</p>
</td></tr>
<tr><td><code>$e.intercept</code></td>
<td>
<p>the lowest value at which the function 1/e.</p>
</td></tr>
<tr><td><code>$y.intercept</code></td>
<td>
<p>the extrapolated value at x=0 (nugget).</p>
</td></tr>
<tr><td><code>$cbar.intercept</code></td>
<td>
<p>distance at which regional average correlation is reach.</p>
</td></tr>
<tr><td><code>$predicted$x</code></td>
<td>
<p>the x-axes for the fitted covariance function.</p>
</td></tr>
<tr><td><code>$predcited$y</code></td>
<td>
<p>the values for the covariance function.</p>
</td></tr>
<tr><td><code>boot</code></td>
<td>
<p>a list with the analogous output from the bootstrap or null distribution.</p>
</td></tr> 
<tr><td><code>$summary</code></td>
<td>
<p>gives the full vector of output for the x.intercept, y.intercept, e.intercept, cbar.intercept, and the cbar and a quantile summary for the resampling distribution.</p>
</td></tr>
<tr><td><code>$boot</code></td>
<td>
<p>If save=TRUE, the full raw matrices from the resampling is saved.</p>
</td></tr>
<tr><td><code>angle</code></td>
<td>
<p>a vector with the cardinal directions.</p>
</td></tr>
<tr><td><code>max.distance</code></td>
<td>
<p>the maximum spatial distance.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The function to estimate the anisotropic nonparametric (cross-)correlation function in arbitrary directions. In particular it was developed to calculate the lagged cross-correlation function (Bjornstad et al. 2002).
</p>


<h3>Author(s)</h3>

<p>Ottar N. Bjornstad <a href="mailto:onb1@psu.edu">onb1@psu.edu</a>
</p>


<h3>References</h3>

<p>Bjornstad, O. N., M. Peltonen, A. M. Liebhold, and W. Baltensweiler. 2002. Waves of larch budmoth outbreaks in the European Alps. Science 298:1020-1023. &lt;doi:10.1126/science.1075182&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.Sncf2D">summary.Sncf2D</a></code>, <code><a href="#topic+plot.Sncf2D">plot.Sncf2D</a></code>, <code><a href="#topic+cc.offset">cc.offset</a></code> , <code><a href="#topic+Sncf">Sncf</a></code>, <code><a href="#topic+spline.correlog2D">spline.correlog2D</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate some sample data
x &lt;- expand.grid(1:20, 1:5)[, 1]
y &lt;- expand.grid(1:20, 1:5)[, 2]
# z data from an exponential random field
z &lt;- cbind(
  rmvn.spa(x = x, y = y, p = 2, method = "exp"),
  rmvn.spa(x = x, y = y, p = 2, method = "exp")
  )
# anisotorpic nonparametric covariance function at 30 and 60 degrees
fit1 &lt;- Sncf2D(x = x, y = y, z = z, resamp = 0, angle = c(30, 60))
## Not run: plot(fit1)
summary(fit1)

# What distance is the peak in correlation
cc.offset(fit1)
</code></pre>

<hr>
<h2 id='spatial.plot'>Simple wrapper around symbols to visualize spatial data</h2><span id='topic+spatial.plot'></span>

<h3>Description</h3>

<p><code>spatial.plot</code> is a quick function to visualize spatial data using bubble plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial.plot(x, y, z, ctr = TRUE, add = FALSE, inches = 0.2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial.plot_+3A_x">x</code></td>
<td>
<p>vector of length n representing the x coordinates.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_y">y</code></td>
<td>
<p>vector of length n representing the y coordinates.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_z">z</code></td>
<td>
<p>vector of n representing the observation at each location.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_ctr">ctr</code></td>
<td>
<p>If TRUE, observations will be centered before plotting (zero-sized symbols represents average observations); if FALSE, the original observations are used.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_add">add</code></td>
<td>
<p>If TRUE, a lisa-plot will be added to a pre-existing plot.</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_inches">inches</code></td>
<td>
<p>scales the size of the symbols</p>
</td></tr>
<tr><td><code id="spatial.plot_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a simple function to visualize spatial data. Positive (or above average) observations are shown by red circles, Negative (or below average) observations are shown as black squares. For hot/coldspot analysis using Local indicators of spatial association use <code><a href="#topic+lisa">lisa</a></code>.
</p>


<h3>Value</h3>

<p>A bubble-plot of the spatial data is produced.
</p>


<h3>Author(s)</h3>

<p>Ottar N. Bjornstad <a href="mailto:onb1@psu.edu">onb1@psu.edu</a>
</p>


<h3>References</h3>

<p>Ripley, B.D. (1987). Stochastic Simulation. Wiley.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lisa">lisa</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate some sample data
x &lt;- expand.grid(1:20, 1:5)[, 1]
y &lt;- expand.grid(1:20, 1:5)[, 2]

# z data from an exponential random field
z &lt;- rmvn.spa(x = x, y = y, p = 2, method = "gaus")

# plot data
## Not run: spatial.plot(x = x, y = y, z = z, ctr = FALSE)
</code></pre>

<hr>
<h2 id='spline.correlog'>Uni- and multivariate spline correlograms</h2><span id='topic+spline.correlog'></span>

<h3>Description</h3>

<p><code>spline.correlog</code> is the function to estimate the spline (cross-)correlogram from spatial data. Either univariate or multivariate (time seres) for each site can be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline.correlog(
  x,
  y,
  z,
  w = NULL,
  df = NULL,
  type = "boot",
  resamp = 1000,
  npoints = 300,
  save = FALSE,
  filter = FALSE,
  fw = 0,
  max.it = 25,
  xmax = FALSE,
  latlon = FALSE,
  na.rm = FALSE,
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline.correlog_+3A_x">x</code></td>
<td>
<p>vector of length n representing the x coordinates (or longitude; see latlon).</p>
</td></tr>
<tr><td><code id="spline.correlog_+3A_y">y</code></td>
<td>
<p>vector of length n representing the y coordinates (or latitude).</p>
</td></tr>
<tr><td><code id="spline.correlog_+3A_z">z</code></td>
<td>
<p>vector of length n or matrix of dimension n x p representing p observation at each location.</p>
</td></tr>
<tr><td><code id="spline.correlog_+3A_w">w</code></td>
<td>
<p>an optional second variable with identical dimension to z (to estimate cross-correlograms).</p>
</td></tr>
<tr><td><code id="spline.correlog_+3A_df">df</code></td>
<td>
<p>degrees of freedom for the spline. Default is sqrt(n).</p>
</td></tr>
<tr><td><code id="spline.correlog_+3A_type">type</code></td>
<td>
<p>takes the value &quot;boot&quot; (default) to generate a bootstrap distribution or &quot;perm&quot; to generate a null distribution</p>
</td></tr>
<tr><td><code id="spline.correlog_+3A_resamp">resamp</code></td>
<td>
<p>the number of resamples for the bootstrap or the null distribution.</p>
</td></tr>
<tr><td><code id="spline.correlog_+3A_npoints">npoints</code></td>
<td>
<p>the number of points at which to save the value for the spline function (and confidence envelope / null distribution).</p>
</td></tr>
<tr><td><code id="spline.correlog_+3A_save">save</code></td>
<td>
<p>If TRUE, the whole matrix of output from the resampling is saved (a resamp x npoints dimensional matrix).</p>
</td></tr>
<tr><td><code id="spline.correlog_+3A_filter">filter</code></td>
<td>
<p>If TRUE, the Fourier filter method of Hall and coworkers is applied to ensure positive semidefiniteness of the estimator.</p>
</td></tr>
<tr><td><code id="spline.correlog_+3A_fw">fw</code></td>
<td>
<p>If filter is TRUE, it may be useful to truncate the function at some distance fw sets the truncation distance. When set to zero, no truncation is done.</p>
</td></tr>
<tr><td><code id="spline.correlog_+3A_max.it">max.it</code></td>
<td>
<p>the maximum iteration for the Newton method used to estimate the intercepts.</p>
</td></tr>
<tr><td><code id="spline.correlog_+3A_xmax">xmax</code></td>
<td>
<p>If FALSE, the max observed in the data is used. Otherwise all distances greater than xmax is omitted.</p>
</td></tr>
<tr><td><code id="spline.correlog_+3A_latlon">latlon</code></td>
<td>
<p>If TRUE, coordinates are latitude and longitude.</p>
</td></tr>
<tr><td><code id="spline.correlog_+3A_na.rm">na.rm</code></td>
<td>
<p>If TRUE, NA's will be dealt with through pairwise deletion of missing values.</p>
</td></tr>
<tr><td><code id="spline.correlog_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, the counter is suppressed during execution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If observations are univariate the spline (cross-)correlogram represents the generalization of the spatial (cross-)correlogram; if observations are multivariate the spline (cross-)correlogram represents the generalization of the Mantel (cross-)correlogram.
</p>
<p>The spline (cross-)correlogram differs from the spatial correlogram (and Mantel correlogram) in that it estimated spatial dependence as a continuous functions of distance (rather than binning into distance classes). The spline correlogram differs from the nonparametric (cross-)correlation function in that the zero-correlation reference line in the former corresponds to the region-wide correlation reference line in the latter. The x-intercept in the spline correlogram is the distance at which object are no more similar than that expected by-chance-alone across the region. 
</p>
<p>Missing values are allowed &ndash; values are assumed missing at random.
</p>


<h3>Value</h3>

<p>An object of class &quot;spline.correlog&quot; is returned, consisting of the following components: 
</p>
<table>
<tr><td><code>real</code></td>
<td>
<p>the list of estimates from the data.</p>
</td></tr>
<tr><td><code>$x.intercept</code></td>
<td>
<p>the lowest value at which the function is = 0. If correlation is initially negative, the distance is given as negative.</p>
</td></tr>
<tr><td><code>$e.intercept</code></td>
<td>
<p>the lowest value at which the function 1/e.</p>
</td></tr>
<tr><td><code>$y.intercept</code></td>
<td>
<p>the extrapolated value at x=0 (nugget).</p>
</td></tr>
<tr><td><code>$predicted$x</code></td>
<td>
<p>the x-axes for the fitted covariance function.</p>
</td></tr>
<tr><td><code>$predcited$y</code></td>
<td>
<p>the values for the covariance function.</p>
</td></tr>
<tr><td><code>boot</code></td>
<td>
<p>a list with the analogous output from the bootstrap or null distribution.</p>
</td></tr> 
<tr><td><code>$summary</code></td>
<td>
<p>gives the full vector of output for the x.intercept, y.intercept, e.intercept, and a quantile summary for the resampling distribution.</p>
</td></tr>
<tr><td><code>$boot</code></td>
<td>
<p>If save=TRUE, the full raw matrices from the resampling is saved.</p>
</td></tr>
<tr><td><code>max.distance</code></td>
<td>
<p>the maximum spatial distance considered.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Ottar N. Bjornstad <a href="mailto:onb1@psu.edu">onb1@psu.edu</a>
</p>


<h3>References</h3>

<p>Bjornstad, O.N. &amp; Falck, W. (2001) Nonparametric spatial covariance functions: estimation and testing. Environmental and Ecological Statistics, 8:53-70. &lt;doi:10.1023/A:1009601932481&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summary.spline.correlog">summary.spline.correlog</a></code>, <code><a href="#topic+plot.spline.correlog">plot.spline.correlog</a></code>, <code><a href="#topic+Sncf">Sncf</a></code>, <code><a href="#topic+spline.correlog2D">spline.correlog2D</a></code>, <code><a href="#topic+correlog">correlog</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># first generate some sample data
x &lt;- expand.grid(1:20, 1:5)[, 1]
y &lt;- expand.grid(1:20, 1:5)[, 2]

# z data from an exponential random field
z &lt;- cbind(
  rmvn.spa(x = x, y = y, p = 2, method = "exp"), 
  rmvn.spa(x = x, y = y, p = 2, method = "exp")
  )

# w data from a gaussian random field
w &lt;- cbind(
  rmvn.spa(x = x, y = y, p = 2, method = "gaus"), 
  rmvn.spa(x = x, y = y, p = 2, method = "gaus")
  )

# univariate spline correlogram
fit1 &lt;- spline.correlog(x = x, y = y, z = z[, 1], resamp = 100)
## Not run: plot.spline.correlog(fit1)
summary(fit1)

# multivariate spline correlogram
fit2 &lt;- spline.correlog(x = x, y = y, z = z, resamp = 100)
## Not run: plot.spline.correlog(fit2)
summary(fit2)

# multivariate spline cross-correlogram
fit3 &lt;- spline.correlog(x = x, y = y, z = z, w = w, resamp = 100)
## Not run: plot.spline.correlog(fit3)
summary(fit3)
</code></pre>

<hr>
<h2 id='spline.correlog2D'>Anisotropic nonparametric (cross-)correlation function for univariate spatial data</h2><span id='topic+spline.correlog2D'></span>

<h3>Description</h3>

<p><code>spline.correlog2D</code> is the function to estimate the anisotropic nonparametric correlation function in 8 (or arbitrary) directions (North - Southeast) for univariate data. Correlation functions are calculated for each different bearing. The function assumes univariate observations at each location. (use <code><a href="#topic+Sncf2D">Sncf2D</a></code> otherwise).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spline.correlog2D(
  x,
  y,
  z,
  w = NULL,
  df = NULL,
  type = "boot",
  resamp = 1000,
  npoints = 300,
  save = FALSE,
  max.it = 25,
  xmax = FALSE,
  na.rm = FALSE,
  jitter = FALSE,
  quiet = FALSE,
  angle = c(0, 22.5, 45, 67.5, 90, 112.5, 135, 157.5)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spline.correlog2D_+3A_x">x</code></td>
<td>
<p>vector of length n representing the x coordinates.</p>
</td></tr>
<tr><td><code id="spline.correlog2D_+3A_y">y</code></td>
<td>
<p>vector of length n representing the y coordinates.</p>
</td></tr>
<tr><td><code id="spline.correlog2D_+3A_z">z</code></td>
<td>
<p>vector of length n representing the observation at each location.</p>
</td></tr>
<tr><td><code id="spline.correlog2D_+3A_w">w</code></td>
<td>
<p>an optional second vector of length n for variable 2 (to estimate spatial or lagged cross-correlation functions).</p>
</td></tr>
<tr><td><code id="spline.correlog2D_+3A_df">df</code></td>
<td>
<p>degrees-of-freedom for the spline. Default is sqrt(n).</p>
</td></tr>
<tr><td><code id="spline.correlog2D_+3A_type">type</code></td>
<td>
<p>takes the value &quot;boot&quot; (default) to generate a bootstrap distribution or &quot;perm&quot; to generate a null distribution for the estimator</p>
</td></tr>
<tr><td><code id="spline.correlog2D_+3A_resamp">resamp</code></td>
<td>
<p>the number of resamples for the bootstrap or the null distribution.</p>
</td></tr>
<tr><td><code id="spline.correlog2D_+3A_npoints">npoints</code></td>
<td>
<p>the number of points at which to save the value for the spline function (and confidence envelope / null distribution).</p>
</td></tr>
<tr><td><code id="spline.correlog2D_+3A_save">save</code></td>
<td>
<p>If TRUE, the whole matrix of output from the resampling is saved (an resamp x npoints dimensional matrix).</p>
</td></tr>
<tr><td><code id="spline.correlog2D_+3A_max.it">max.it</code></td>
<td>
<p>the maximum iteration for the Newton method used to estimate the intercepts.</p>
</td></tr>
<tr><td><code id="spline.correlog2D_+3A_xmax">xmax</code></td>
<td>
<p>If FALSE, the max observed in the data is used. Otherwise all distances greater than xmax is omitted.</p>
</td></tr>
<tr><td><code id="spline.correlog2D_+3A_na.rm">na.rm</code></td>
<td>
<p>If TRUE, NA's will be dealt with through pairwise deletion of missing values for each pair of time series &ndash; it will dump if any one pair has less than two (temporally) overlapping observations.</p>
</td></tr>
<tr><td><code id="spline.correlog2D_+3A_jitter">jitter</code></td>
<td>
<p>If TRUE, jitters the distance matrix to avoid problems associated with fitting the function to data on regular grids.</p>
</td></tr>
<tr><td><code id="spline.correlog2D_+3A_quiet">quiet</code></td>
<td>
<p>If TRUE, the counter is suppressed during execution.</p>
</td></tr>
<tr><td><code id="spline.correlog2D_+3A_angle">angle</code></td>
<td>
<p>specifies number of cardinal directions and angles for which to calculate correlation functions. Default are 8 directions between 0 and 180.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>see <code><a href="#topic+Sncf2D">Sncf2D</a></code>
</p>


<h3>Value</h3>

<p>An object of class &quot;Sncf2D&quot; is returned. See <code><a href="#topic+Sncf2D">Sncf2D</a></code> for details.
</p>


<h3>Note</h3>

<p>The function to estimate the UNIvariate anisotropic nonparametric (cross-)correlation function in arbitrary directions. In particular it was developed to calculate the univariate lagged cross-correlation function used in (Humston et al. 2005). Note that this 2D spline correlogram does the anisotropic analysis NOT by doing the angle-with-tolerance-wedge-style of Oden and Sokal (1986) but by projecting the the spatial coordinates of all locations on a sequence of cardinal angles (a la Sncf2D). Hence, all data points are used every time, it is only their relative distances that are changed. For example {0, 0} and {0, 10} are distance zero in the zero-degree direction but at distance 10 in the 90-degree direction.
</p>


<h3>References</h3>

<p>Oden, N.L. and Sokal, R.R. 1986. Directional autocorrelation: an extension of spatial correlograms to two dimensions. Systematic Zoology 35: 608-617. &lt;doi:10.2307/2413120&gt;
@references Humston, R., Mortensen, D. and Bjornstad, O.N. 2005. Anthropogenic forcing on the spatial dynamics of an agricultural weed: the case of the common sunflower. Journal of Applied Ecology 42: 863-872. &lt;doi:10.1111/j.1365-2664.2005.01066.x&gt;
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sncf2D">Sncf2D</a></code>
</p>

<hr>
<h2 id='summary.Sncf'>Summarizing nonparametric spatial correlation-functions</h2><span id='topic+summary.Sncf'></span>

<h3>Description</h3>

<p>'summary' method for class &quot;Sncf&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Sncf'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Sncf_+3A_object">object</code></td>
<td>
<p>an object of class &quot;Sncf&quot;, usually, as a result of a call to <code><a href="#topic+Sncf">Sncf</a></code> (or <code><a href="#topic+Sncf.srf">Sncf.srf</a></code>).</p>
</td></tr>
<tr><td><code id="summary.Sncf_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list summarizing the nonparametric (cross-)covariance function is returned. 
</p>
<table>
<tr><td><code>Regional.synch</code></td>
<td>
<p>the regional mean (cross-)correlation.</p>
</td></tr>
<tr><td><code>Squantile</code></td>
<td>
<p>the quantile distribution from the resampling for the regional correlation.</p>
</td></tr>
<tr><td><code>estimates</code></td>
<td>
<p>a vector of benchmark statistics:</p>
</td></tr>
<tr><td><code>$x</code></td>
<td>
<p>is the lowest value at which the function is = 0. If correlation is initially negative, the distance calculated appears as a negative measure.</p>
</td></tr>
<tr><td><code>$e</code></td>
<td>
<p>is the lowest value at which the function is &lt;= 1/e.</p>
</td></tr>
<tr><td><code>$y</code></td>
<td>
<p>is the extrapolated value at x=0.</p>
</td></tr> 
<tr><td><code>$cbar</code></td>
<td>
<p>is the shortest distance at which function is = regional mean correlation.</p>
</td></tr>
<tr><td><code>quantiles</code></td>
<td>
<p>a matrix summarizing the quantiles in the bootstrap (or null) distributions of the benchmark statistics.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+Sncf">Sncf</a></code>, <code><a href="#topic+plot.Sncf">plot.Sncf</a></code>
</p>

<hr>
<h2 id='summary.Sncf2D'>Summarizing anisotropic spatial correlation-functions</h2><span id='topic+summary.Sncf2D'></span>

<h3>Description</h3>

<p>Summary method for class &quot;Sncf2D&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Sncf2D'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.Sncf2D_+3A_object">object</code></td>
<td>
<p>an object of class &quot;Sncf2D&quot;, usually, as a result of a call to <code><a href="#topic+Sncf2D">Sncf2D</a></code>.</p>
</td></tr>
<tr><td><code id="summary.Sncf2D_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list summarizing the nonparametric covariance function in each cardinal direction results, each with the entires as in <code><a href="#topic+summary.Sncf">summary.Sncf</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Sncf2D">Sncf2D</a></code>, <code><a href="#topic+cc.offset">cc.offset</a></code>, <code><a href="#topic+summary.Sncf">summary.Sncf</a></code>
</p>

<hr>
<h2 id='summary.spline.correlog'>Summarizing spline correlograms</h2><span id='topic+summary.spline.correlog'></span>

<h3>Description</h3>

<p>&lsquo;summary&rsquo; method for class &quot;spline.correlog&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spline.correlog'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.spline.correlog_+3A_object">object</code></td>
<td>
<p>an object of class &quot;spline.correlog&quot;, usually, as a result of a call to <code><a href="#topic+spline.correlog">spline.correlog</a></code>.</p>
</td></tr>
<tr><td><code id="summary.spline.correlog_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list summarizing the spline correlogram is returned. 
</p>
<table>
<tr><td><code>estimates</code></td>
<td>
<p>a vector of benchmark statistics:</p>
</td></tr>
<tr><td><code>$x</code></td>
<td>
<p>is the lowest value at which the function is = 0. If correlation is initially negative, the distance calculated appears as a negative measure.</p>
</td></tr>
<tr><td><code>$e</code></td>
<td>
<p>is the lowest value at which the function is &lt;= 1/e.</p>
</td></tr>
<tr><td><code>$y</code></td>
<td>
<p>is the extrapolated value at x=0.</p>
</td></tr> 
<tr><td><code>quantiles</code></td>
<td>
<p>a matrix summarizing the quantiles in the bootstrap (or null) distributions of the benchmark statistics.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+spline.correlog">spline.correlog</a></code>, <code><a href="#topic+plot.spline.correlog">plot.spline.correlog</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
