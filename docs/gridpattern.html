<!DOCTYPE html><html><head><title>Help for package gridpattern</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gridpattern}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gridpattern-package'><p>gridpattern: 'grid' Pattern Grobs</p></a></li>
<li><a href='#alphaMaskGrob'><p>Mask grob using another grob to specify the (alpha) mask</p></a></li>
<li><a href='#clippingPathGrob'><p>Clip grob using another grob to specify the clipping path</p></a></li>
<li><a href='#grid.pattern'><p>Create patterned grobs by pattern name</p></a></li>
<li><a href='#grid.pattern_ambient'><p>Ambient patterned grobs</p></a></li>
<li><a href='#grid.pattern_circle'><p>Circle patterned grobs</p></a></li>
<li><a href='#grid.pattern_crosshatch'><p>Crosshatch patterned grobs</p></a></li>
<li><a href='#grid.pattern_fill'><p>Grobs with a simple fill pattern</p></a></li>
<li><a href='#grid.pattern_gradient'><p>Gradient patterned grobs</p></a></li>
<li><a href='#grid.pattern_image'><p>Image patterned grobs</p></a></li>
<li><a href='#grid.pattern_magick'><p>Magick patterned grobs</p></a></li>
<li><a href='#grid.pattern_none'><p>Grobs without any pattern</p></a></li>
<li><a href='#grid.pattern_pch'><p>Plotting character patterned grobs</p></a></li>
<li><a href='#grid.pattern_placeholder'><p>Placeholder image patterned grobs</p></a></li>
<li><a href='#grid.pattern_plasma'><p>Plasma patterned grobs</p></a></li>
<li><a href='#grid.pattern_polygon_tiling'><p>Polygon tiling patterned grobs</p></a></li>
<li><a href='#grid.pattern_regular_polygon'><p>Regular polygon patterned grobs</p></a></li>
<li><a href='#grid.pattern_rose'><p>Rose curve patterned grobs</p></a></li>
<li><a href='#grid.pattern_stripe'><p>Stripe patterned grobs</p></a></li>
<li><a href='#grid.pattern_text'><p>Text character patterned grobs</p></a></li>
<li><a href='#grid.pattern_wave'><p>Wave patterned grobs</p></a></li>
<li><a href='#grid.pattern_weave'><p>Weave patterned grobs</p></a></li>
<li><a href='#guess_has_R4.1_features'><p>Guess whether &quot;active&quot; graphics device supports</p>
the grid graphics features introduced in R v4.1.</a></li>
<li><a href='#mean_col'><p>Compute average color</p></a></li>
<li><a href='#pattern_hex'><p>Hex pattern matrix</p></a></li>
<li><a href='#pattern_square'><p>Square pattern matrix</p></a></li>
<li><a href='#pattern_weave'><p>Weave pattern matrix</p></a></li>
<li><a href='#patternFill'><p>Create patterned fills by pattern name</p></a></li>
<li><a href='#reset_image_cache'><p>Reset 'gridpattern' image cache</p></a></li>
<li><a href='#star_scale'><p>Compute regular star polygon scale or angles</p></a></li>
<li><a href='#update_alpha'><p>Update colour and/or pattern transparency</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>'grid' Pattern Grobs</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides 'grid' grobs that fill in a user-defined area with various patterns.  Includes enhanced versions of the geometric and image-based patterns originally contained in the 'ggpattern' package as well as original 'pch', 'polygon_tiling', 'regular_polygon', 'rose', 'text', 'wave', and 'weave' patterns plus support for custom user-defined patterns.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://trevorldavis.com/R/gridpattern/">https://trevorldavis.com/R/gridpattern/</a>,
<a href="https://github.com/trevorld/gridpattern">https://github.com/trevorld/gridpattern</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/trevorld/gridpattern/issues">https://github.com/trevorld/gridpattern/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>glue, grDevices, grid, memoise, png, rlang, sf, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ambient, ggplot2 (&ge; 3.5.0), knitr, magick (&ge; 2.7.4), ragg
(&ge; 1.2.0), rmarkdown, scales, svglite (&ge; 2.1.0), testthat,
vdiffr (&ge; 1.0.6)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-06-02 19:42:35 UTC; trevorld</td>
</tr>
<tr>
<td>Author:</td>
<td>Trevor L. Davis <a href="https://orcid.org/0000-0001-6341-4639"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Mike FC [aut] (Code/docs adapted from ggpattern),
  ggplot2 authors [ctb] (some utility functions copied from ggplot2)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Trevor L. Davis &lt;trevor.l.davis@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-06-03 04:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='gridpattern-package'>gridpattern: 'grid' Pattern Grobs</h2><span id='topic+gridpattern'></span><span id='topic+gridpattern-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Provides 'grid' grobs that fill in a user-defined area with various patterns. Includes enhanced versions of the geometric and image-based patterns originally contained in the 'ggpattern' package as well as original 'pch', 'polygon_tiling', 'regular_polygon', 'rose', 'text', 'wave', and 'weave' patterns plus support for custom user-defined patterns.
</p>


<h3>Package options</h3>

<p>The following <code>gridpattern</code> options may be set globally via <code><a href="base.html#topic+options">base::options()</a></code>:
</p>

<dl>
<dt>ggpattern_array_funcs</dt><dd><p>Set custom &ldquo;array&rdquo; pattern functions.</p>
</dd>
<dt>ggpattern_geometry_funcs</dt><dd><p>Set custom &ldquo;geometry&rdquo; pattern functions.</p>
</dd>
<dt>ggpattern_res</dt><dd><p>Set custom raster image resolution (pixels per inch) for certain patterns.</p>
</dd>
<dt>ggpattern_use_R4.1_clipping</dt><dd><p>If <code>TRUE</code> use the grid clipping path feature introduced in R v4.1.0.
If <code>FALSE</code> do a <code>rasterGrob</code> approximation of the clipped pattern.
If <code>NULL</code> try to guess an appropriate choice.</p>
</dd>
<dt>ggpattern_use_R4.1_features</dt><dd><p>If <code>TRUE</code> sets the default for all the other
<code style="white-space: pre;">&#8288;ggpattern_use_R4.1_*&#8288;</code> options arguments to <code>TRUE</code>.
If <code>FALSE</code> sets them to <code>FALSE</code>.</p>
</dd>
<dt>ggpattern_use_R4.1_gradients</dt><dd><p>If <code>TRUE</code> use the grid gradient feature introduced in R v4.1.0.
If <code>FALSE</code> do a <code>rasterGrob</code> approximation of the gradient pattern.
If <code>NULL</code> try to guess an appropriate choice.</p>
</dd>
<dt>ggpattern_use_R4.1_masks</dt><dd><p>If <code>TRUE</code> use the grid mask feature introduced in R v4.1.0.
If <code>FALSE</code> do a <code>rasterGrob</code> approximation of the masked pattern.
If <code>NULL</code> try to guess an appropriate choice.</p>
</dd>
<dt>ggpattern_use_R4.1_patterns</dt><dd><p>If <code>TRUE</code> use the grid pattern feature introduced in R v4.1.0.
Currently only used by a couple of examples.</p>
</dd>
</dl>

<p>Note to use the R v4.1.0 features one needs R be (at least) version 4.1 and not all graphic devices
support any/all these features.  See <a href="https://www.stat.auckland.ac.nz/~paul/Reports/GraphicsEngine/definitions/definitions.html">https://www.stat.auckland.ac.nz/~paul/Reports/GraphicsEngine/definitions/definitions.html</a> for more information on these features.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Trevor L. Davis <a href="mailto:trevor.l.davis@gmail.com">trevor.l.davis@gmail.com</a> (<a href="https://orcid.org/0000-0001-6341-4639">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Mike FC (Code/docs adapted from ggpattern)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> ggplot2 authors (some utility functions copied from ggplot2) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://trevorldavis.com/R/gridpattern/">https://trevorldavis.com/R/gridpattern/</a>
</p>
</li>
<li> <p><a href="https://github.com/trevorld/gridpattern">https://github.com/trevorld/gridpattern</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/trevorld/gridpattern/issues">https://github.com/trevorld/gridpattern/issues</a>
</p>
</li></ul>


<hr>
<h2 id='alphaMaskGrob'>Mask grob using another grob to specify the (alpha) mask</h2><span id='topic+alphaMaskGrob'></span>

<h3>Description</h3>

<p><code>alphaMaskGrob()</code> masks a grob using another grob to specify the (alpha) mask.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alphaMaskGrob(
  maskee,
  masker,
  use_R4.1_masks = getOption("ggpattern_use_R4.1_masks",
    getOption("ggpattern_use_R4.1_features")),
  png_device = NULL,
  res = getOption("ggpattern_res", 72),
  name = NULL,
  gp = gpar(),
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alphaMaskGrob_+3A_maskee">maskee</code></td>
<td>
<p>Grob to be masked</p>
</td></tr>
<tr><td><code id="alphaMaskGrob_+3A_masker">masker</code></td>
<td>
<p>Grob that defines masking region</p>
</td></tr>
<tr><td><code id="alphaMaskGrob_+3A_use_r4.1_masks">use_R4.1_masks</code></td>
<td>
<p>If <code>TRUE</code> use the grid mask feature introduced in R v4.1.0.
If <code>FALSE</code> do a <code>rasterGrob</code> approximation.
If <code>NULL</code> try to guess an appropriate choice.
Note not all graphic devices support the grid mask feature.</p>
</td></tr>
<tr><td><code id="alphaMaskGrob_+3A_png_device">png_device</code></td>
<td>
<p>&ldquo;png&rdquo; graphics device to save intermediate raster data with if <code>use_R4.1_masks</code> is <code>FALSE</code>.
If <code>NULL</code> and suggested package <code>ragg</code> is available
and versions are high enough we directly capture masked raster via <code><a href="ragg.html#topic+agg_capture">ragg::agg_capture()</a></code>.
Otherwise we will use <code>png_device</code>
(default <code><a href="ragg.html#topic+agg_png">ragg::agg_png()</a></code> if available else <code><a href="grDevices.html#topic+png">grDevices::png()</a></code>) and <code><a href="png.html#topic+readPNG">png::readPNG()</a></code>
to manually compute a masked raster.</p>
</td></tr>
<tr><td><code id="alphaMaskGrob_+3A_res">res</code></td>
<td>
<p>Resolution of desired <code>rasterGrob</code> in pixels per inch if <code>use_R4.1_masks</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="alphaMaskGrob_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="alphaMaskGrob_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="alphaMaskGrob_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>grid</code> grob
</p>


<h3>Examples</h3>

<pre><code class='language-R'>   # Once took more &gt;10s on a CRAN autocheck
  if (capabilities("png") &amp;&amp; require("grid")) {
    maskee &lt;- patternGrob("circle", gp = gpar(col = "black", fill = "yellow"),
                           spacing = 0.1, density = 0.5)
    angle &lt;- seq(2 * pi / 4, by = 2 * pi / 6, length.out = 7)
    x_hex_outer &lt;- 0.5 + 0.5 * cos(angle)
    y_hex_outer &lt;- 0.5 + 0.5 * sin(angle)
    x_hex_inner &lt;- 0.5 + 0.25 * cos(rev(angle))
    y_hex_inner &lt;- 0.5 + 0.25 * sin(rev(angle))
    gp &lt;- gpar(lwd = 0, col = NA, fill = "white")
    masker &lt;- grid::pathGrob(x = c(x_hex_outer, x_hex_inner),
                             y = c(y_hex_outer, y_hex_inner),
                             id = rep(1:2, each = 7),
                             rule = "evenodd", gp = gp)
    masked &lt;- alphaMaskGrob(maskee, masker, use_R4.1_masks = FALSE)
    grid.draw(masked)
  }
  if (capabilities("png") &amp;&amp; require("grid")) {
    maskee_transparent &lt;- rectGrob(gp = gpar(col = NA, fill = "blue"))
    gp &lt;- gpar(lwd = 20, col = "black", fill = grDevices::rgb(0, 0, 0, 0.5))
    masker_transparent &lt;- editGrob(masker, gp = gp)
    masked_transparent &lt;- alphaMaskGrob(maskee_transparent,
                                        masker_transparent,
                                        use_R4.1_masks = FALSE)
    grid.newpage()
    grid.draw(masked_transparent)
  }
  
</code></pre>

<hr>
<h2 id='clippingPathGrob'>Clip grob using another grob to specify the clipping path</h2><span id='topic+clippingPathGrob'></span>

<h3>Description</h3>

<p><code>clippingPathGrob()</code> clips a grob using another grob to specify the clipping path
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clippingPathGrob(
  clippee,
  clipper,
  use_R4.1_clipping = getOption("ggpattern_use_R4.1_clipping",
    getOption("ggpattern_use_R4.1_features")),
  png_device = NULL,
  res = getOption("ggpattern_res", 72),
  name = NULL,
  gp = gpar(),
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clippingPathGrob_+3A_clippee">clippee</code></td>
<td>
<p>Grob to be clipped</p>
</td></tr>
<tr><td><code id="clippingPathGrob_+3A_clipper">clipper</code></td>
<td>
<p>Grob that defines clipping region</p>
</td></tr>
<tr><td><code id="clippingPathGrob_+3A_use_r4.1_clipping">use_R4.1_clipping</code></td>
<td>
<p>If <code>TRUE</code> use the grid clipping path feature introduced in R v4.1.0.
If <code>FALSE</code> do a <code>rasterGrob</code> approximation.
If <code>NULL</code> try to guess an appropriate choice.
Note not all graphic devices support the grid clipping path feature
and the grid clipping path feature does not nest.</p>
</td></tr>
<tr><td><code id="clippingPathGrob_+3A_png_device">png_device</code></td>
<td>
<p>&ldquo;png&rdquo; graphics device to save intermediate raster data with if <code>use_R4.1_clipping</code> is <code>FALSE</code>.
If <code>NULL</code> and suggested package <code>ragg</code> is available
and versions are high enough we directly capture clipped raster via <code><a href="ragg.html#topic+agg_capture">ragg::agg_capture()</a></code>.
Otherwise we will use <code>png_device</code>
(default <code><a href="ragg.html#topic+agg_png">ragg::agg_png()</a></code> if available else <code><a href="grDevices.html#topic+png">grDevices::png()</a></code>) and <code><a href="png.html#topic+readPNG">png::readPNG()</a></code>
to manually compute a clipped raster.</p>
</td></tr>
<tr><td><code id="clippingPathGrob_+3A_res">res</code></td>
<td>
<p>Resolution of desired <code>rasterGrob</code> in pixels per inch if <code>use_R4.1_clipping</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="clippingPathGrob_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="clippingPathGrob_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="clippingPathGrob_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>grid</code> grob
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if (capabilities("png") &amp;&amp; require("grid")) {
    clippee &lt;- patternGrob("circle", gp = gpar(col = "black", fill = "yellow"),
                           spacing = 0.1, density = 0.5)
    angle &lt;- seq(2 * pi / 4, by = 2 * pi / 6, length.out = 7)
    x_hex_outer &lt;- 0.5 + 0.5 * cos(angle)
    y_hex_outer &lt;- 0.5 + 0.5 * sin(angle)
    x_hex_inner &lt;- 0.5 + 0.25 * cos(rev(angle))
    y_hex_inner &lt;- 0.5 + 0.25 * sin(rev(angle))
    clipper &lt;- grid::pathGrob(x = c(x_hex_outer, x_hex_inner),
                              y = c(y_hex_outer, y_hex_inner),
                              id = rep(1:2, each = 7),
                              rule = "evenodd")
    clipped &lt;- clippingPathGrob(clippee, clipper, use_R4.1_clipping = FALSE)
    grid.newpage()
    grid.draw(clipped)
  }
</code></pre>

<hr>
<h2 id='grid.pattern'>Create patterned grobs by pattern name</h2><span id='topic+grid.pattern'></span><span id='topic+names_pattern'></span><span id='topic+patternGrob'></span>

<h3>Description</h3>

<p><code>grid.pattern()</code> draws patterned shapes onto the graphic device.
<code>patternGrob()</code> returns the grid grob objects.
<code>names_pattern</code> is a character vector of builtin patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern(
  pattern = "stripe",
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  legend = FALSE,
  prefix = "pattern_",
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)

names_pattern

patternGrob(
  pattern = "stripe",
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  legend = FALSE,
  prefix = "pattern_",
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_+3A_pattern">pattern</code></td>
<td>
<p>Name of pattern.  See Details section for a list of supported patterns.</p>
</td></tr>
<tr><td><code id="grid.pattern_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_+3A_...">...</code></td>
<td>
<p>Pattern parameters.</p>
</td></tr>
<tr><td><code id="grid.pattern_+3A_legend">legend</code></td>
<td>
<p>Whether this is intended to be drawn in a legend or not.</p>
</td></tr>
<tr><td><code id="grid.pattern_+3A_prefix">prefix</code></td>
<td>
<p>Prefix to prepend to the name of each of the pattern parameters in <code>...</code>.
For compatibility with <code>ggpattern</code> most underlying functions assume parameters beginning with <code>pattern_</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 18.
</p>


<h3>Details</h3>

<p>Here is a list of the various patterns supported:
</p>

<dl>
<dt>ambient</dt><dd><p>Noise array patterns onto the graphic device powered by the <code>ambient</code> package.
See <code><a href="#topic+grid.pattern_ambient">grid.pattern_ambient()</a></code> for more information.</p>
</dd>
<dt>circle</dt><dd><p>Circle geometry patterns.
See <code><a href="#topic+grid.pattern_circle">grid.pattern_circle()</a></code> for more information.</p>
</dd>
<dt>crosshatch</dt><dd><p>Crosshatch geometry patterns.
See <code><a href="#topic+grid.pattern_crosshatch">grid.pattern_crosshatch()</a></code> for more information.</p>
</dd>
<dt>gradient</dt><dd><p>Gradient array/geometry patterns.
See <code><a href="#topic+grid.pattern_gradient">grid.pattern_gradient()</a></code> for more information.</p>
</dd>
<dt>image</dt><dd><p>Image array patterns.
See <code><a href="#topic+grid.pattern_image">grid.pattern_image()</a></code> for more information.</p>
</dd>
<dt>magick</dt><dd><p><code>imagemagick</code> array patterns.
See <code><a href="#topic+grid.pattern_magick">grid.pattern_magick()</a></code> for more information.</p>
</dd>
<dt>none</dt><dd><p>Does nothing.
See <code><a href="grid.html#topic+grid.null">grid::grid.null()</a></code> for more information.</p>
</dd>
<dt>pch</dt><dd><p>Plotting character geometry patterns.
See <code><a href="#topic+grid.pattern_pch">grid.pattern_pch()</a></code> for more information.</p>
</dd>
<dt>placeholder</dt><dd><p>Placeholder image array patterns.
See <code><a href="#topic+grid.pattern_placeholder">grid.pattern_placeholder()</a></code> for more information.</p>
</dd>
<dt>plasma</dt><dd><p>Plasma array patterns.
See <code><a href="#topic+grid.pattern_plasma">grid.pattern_plasma()</a></code> for more information.</p>
</dd>
<dt>polygon_tiling</dt><dd><p>Polygon tiling patterns.
See <code><a href="#topic+grid.pattern_polygon_tiling">grid.pattern_polygon_tiling()</a></code> for more information.</p>
</dd>
<dt>regular_polygon</dt><dd><p>Regular polygon patterns.
See <code><a href="#topic+grid.pattern_regular_polygon">grid.pattern_regular_polygon()</a></code> for more information.</p>
</dd>
<dt>rose</dt><dd><p>Rose array/geometry patterns.
See <code><a href="#topic+grid.pattern_rose">grid.pattern_rose()</a></code> for more information.</p>
</dd>
<dt>stripe</dt><dd><p>Stripe geometry patterns.
See <code><a href="#topic+grid.pattern_stripe">grid.pattern_stripe()</a></code> for more information.</p>
</dd>
<dt>text</dt><dd><p>Text array/geometry patterns.
See <code><a href="#topic+grid.pattern_text">grid.pattern_text()</a></code> for more information.</p>
</dd>
<dt>wave</dt><dd><p>Wave geometry patterns.
See <code><a href="#topic+grid.pattern_wave">grid.pattern_wave()</a></code> for more information.</p>
</dd>
<dt>weave</dt><dd><p>Weave geometry patterns.
See <code><a href="#topic+grid.pattern_weave">grid.pattern_weave()</a></code> for more information.</p>
</dd>
<dt>Custom geometry-based patterns</dt><dd><p>See <a href="https://trevorldavis.com/R/gridpattern/dev/articles/developing-patterns.html">https://trevorldavis.com/R/gridpattern/dev/articles/developing-patterns.html</a> for more information.</p>
</dd>
<dt>Custom array-based patterns</dt><dd><p>See <a href="https://trevorldavis.com/R/gridpattern/dev/articles/developing-patterns.html">https://trevorldavis.com/R/gridpattern/dev/articles/developing-patterns.html</a> for more information.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A grid grob object (invisibly in the case of <code>grid.pattern()</code>).
If <code>draw</code> is <code>TRUE</code> then <code>grid.pattern()</code> also draws to the graphic device as a side effect.
</p>


<h3>See Also</h3>

<p><a href="https://coolbutuseless.github.io/package/ggpattern/index.html">https://coolbutuseless.github.io/package/ggpattern/index.html</a>
for more details on the <code>ggpattern</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> print(names_pattern)
  # Once took more &gt;10s on a CRAN autocheck
 x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
 y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))

 # geometry-based patterns
 # 'stripe' pattern
 grid::grid.newpage()
 grid.pattern("stripe", x_hex, y_hex,
              colour="black", fill=c("yellow", "blue"), density = 0.5)

 # Can alternatively use "gpar()" to specify colour and line attributes
 grid::grid.newpage()
 grid.pattern("stripe", x_hex, y_hex, 
              gp = grid::gpar(col="blue", fill="red", lwd=2))

 # 'weave' pattern
 grid::grid.newpage()
 grid.pattern("weave", x_hex, y_hex, type = "satin",
              colour = "black", fill = "lightblue", fill2 =  "yellow",
              density = 0.3)

 # 'regular_polygon' pattern
 grid::grid.newpage()
 grid.pattern_regular_polygon(x_hex, y_hex, colour = "black",
                              fill = c("blue", "yellow", "red"),
                              shape = c("convex4", "star8", "circle"),
                              density = c(0.45, 0.42, 0.4),
                              spacing = 0.08, angle = 0)

 # can be used to achieve a variety of 'tiling' effects
 grid::grid.newpage()
 grid.pattern_regular_polygon(x_hex, y_hex, color = "transparent",
                              fill = c("white", "grey", "black"),
                              density = 1.0, spacing = 0.1,
                              shape = "convex6", grid = "hex")
 if (suppressPackageStartupMessages(requireNamespace("magick", quietly = TRUE))) {
   # array-based patterns
   # 'image' pattern
   logo_filename &lt;- system.file("img", "Rlogo.png" , package="png")
   grid::grid.newpage()
   grid.pattern("image", x_hex, y_hex, filename=logo_filename, type="fit")
 }
 if (suppressPackageStartupMessages(requireNamespace("magick", quietly = TRUE))) {
   # 'plasma' pattern
   grid::grid.newpage()
   grid.pattern("plasma", x_hex, y_hex, fill="green")
 }
 
</code></pre>

<hr>
<h2 id='grid.pattern_ambient'>Ambient patterned grobs</h2><span id='topic+grid.pattern_ambient'></span>

<h3>Description</h3>

<p><code>grid.pattern_ambient()</code> draws noise patterns onto the graphic device powered by the <code>ambient</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_ambient(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  type = "simplex",
  fill = gp$fill %||% "grey80",
  fill2 = "#4169E1",
  frequency = 0.01,
  interpolator = "quintic",
  fractal = switch(type, worley = "none", "fbm"),
  octaves = 3,
  lacunarity = 2,
  gain = 0.5,
  pertubation = "none",
  pertubation_amplitude = 1,
  value = "cell",
  distance_ind = c(1, 2),
  jitter = 0.45,
  res = getOption("ggpattern_res", 72),
  alpha = NA_real_,
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_ambient_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_type">type</code></td>
<td>
<p>Either cubic, perlin, simplex, value, white, or worley</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_fill">fill</code></td>
<td>
<p>Colour.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_fill2">fill2</code></td>
<td>
<p>Second colour.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_frequency">frequency</code></td>
<td>
<p>Determines the granularity of the features in the noise.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_interpolator">interpolator</code></td>
<td>
<p>How should values between sampled points be calculated?
Either <code>'linear'</code>, <code>'hermite'</code>, or <code>'quintic'</code> (default), ranging from lowest
to highest quality.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_fractal">fractal</code></td>
<td>
<p>The fractal type to use. Either <code>'none'</code>, <code>'fbm'</code> (default),
<code>'billow'</code>, or <code>'rigid-multi'</code>. It is suggested that you experiment with the
different types to get a feel for how they behaves.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_octaves">octaves</code></td>
<td>
<p>The number of noise layers used to create the fractal noise.
Ignored if <code>fractal = 'none'</code>. Defaults to <code>3</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_lacunarity">lacunarity</code></td>
<td>
<p>The frequency multiplier between successive noise layers
when building fractal noise. Ignored if <code>fractal = 'none'</code>. Defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_gain">gain</code></td>
<td>
<p>The relative strength between successive noise layers when
building fractal noise. Ignored if <code>fractal = 'none'</code>. Defaults to <code>0.5</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_pertubation">pertubation</code></td>
<td>
<p>The pertubation to use. Either <code>'none'</code> (default),
<code>'normal'</code>, or <code>'fractal'</code>. Defines the displacement (warping) of the noise,
with <code>'normal'</code> giving a smooth warping and <code>'fractal'</code> giving a more eratic
warping.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_pertubation_amplitude">pertubation_amplitude</code></td>
<td>
<p>The maximal pertubation distance from the
origin. Ignored if <code>pertubation = 'none'</code>. Defaults to <code>1</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_value">value</code></td>
<td>
<p>The noise value to return. Either
</p>

<ul>
<li> <p><code>'value'</code> (default) A random value associated with the closest point
</p>
</li>
<li> <p><code>'distance'</code> The distance to the closest point
</p>
</li>
<li> <p><code>'distance2'</code> The distance to the nth closest point (n given by
<code>distance_ind[1]</code>)
</p>
</li>
<li> <p><code>'distance2add'</code> Addition of the distance to the nth and mth closest point given in <code>distance_ind</code>
</p>
</li>
<li> <p><code>'distance2sub'</code> Substraction of the distance to the nth and mth closest point given in <code>distance_ind</code>
</p>
</li>
<li> <p><code>'distance2mul'</code> Multiplication of the distance to the nth and mth closest point given in <code>distance_ind</code>
</p>
</li>
<li> <p><code>'distance2div'</code> Division of the distance to the nth and mth closest point given in <code>distance_ind</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_distance_ind">distance_ind</code></td>
<td>
<p>Reference to the nth and mth closest points that should
be used when calculating <code>value</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_jitter">jitter</code></td>
<td>
<p>The maximum distance a point can move from its start position
during sampling of cell points.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_res">res</code></td>
<td>
<p>Assumed resolution (in pixels per graphic device inch) to use when creating array pattern.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (between 0 and 1) or <code>NA</code> (default, preserves colors' alpha value).</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_ambient_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>See Also</h3>

<p>For more information about the noise types please see the relevant <code>ambient</code> documentation:
<code><a href="ambient.html#topic+noise_cubic">ambient::noise_cubic()</a></code>, <code><a href="ambient.html#topic+noise_perlin">ambient::noise_perlin()</a></code>, <code><a href="ambient.html#topic+noise_simplex">ambient::noise_simplex()</a></code>,
<code><a href="ambient.html#topic+noise_value">ambient::noise_value()</a></code>, <code><a href="ambient.html#topic+noise_white">ambient::noise_white()</a></code>, and <code><a href="ambient.html#topic+noise_worley">ambient::noise_worley()</a></code>.
<code><a href="#topic+grid.pattern_plasma">grid.pattern_plasma()</a></code> provides an alternative noise pattern that depends on <code>magick</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> if (requireNamespace("ambient", quietly = TRUE)) {
   x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
   y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
   grid.pattern_ambient(x_hex, y_hex, fill = "green", fill2 = "blue")
 }
 if (requireNamespace("ambient")) {
   grid::grid.newpage()
   grid.pattern_ambient(x_hex, y_hex, fill = "green", fill2 = "blue", type = "cubic")
 }
</code></pre>

<hr>
<h2 id='grid.pattern_circle'>Circle patterned grobs</h2><span id='topic+grid.pattern_circle'></span>

<h3>Description</h3>

<p><code>grid.pattern_circle()</code> draws a circle pattern onto the graphic device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_circle(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  colour = gp$col %||% "grey20",
  fill = gp$fill %||% "grey80",
  angle = 30,
  density = 0.2,
  spacing = 0.05,
  xoffset = 0,
  yoffset = 0,
  units = "snpc",
  alpha = gp$alpha %||% NA_real_,
  linetype = gp$lty %||% 1,
  linewidth = size %||% gp$lwd %||% 1,
  size = NULL,
  grid = "square",
  type = NULL,
  subtype = NULL,
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_circle_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_colour">colour</code></td>
<td>
<p>Stroke colour(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_fill">fill</code></td>
<td>
<p>Fill colour(s) or <code><a href="grid.html#topic+patterns">grid::pattern()</a></code> / gradient object(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_angle">angle</code></td>
<td>
<p>Rotation angle in degrees.</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_density">density</code></td>
<td>
<p>Approx. fraction of area the pattern fills.</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_spacing">spacing</code></td>
<td>
<p>Spacing between repetitions of pattern (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_xoffset">xoffset</code></td>
<td>
<p>Shift pattern along x axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_yoffset">yoffset</code></td>
<td>
<p>Shift pattern along y axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_units">units</code></td>
<td>
<p><code><a href="grid.html#topic+unit">grid::unit()</a></code> units for <code>spacing</code>, <code>xoffset</code>, and <code>yoffset</code> parameters.</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (between 0 and 1) or <code>NA</code> (default, preserves colors' alpha value).</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_linetype">linetype</code></td>
<td>
<p>Stroke linetype.</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_linewidth">linewidth</code></td>
<td>
<p>Stroke linewidth.</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_size">size</code></td>
<td>
<p>For backwards compatibility can be used to set <code>linewidth</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_grid">grid</code></td>
<td>
<p>Adjusts placement and density of certain graphical elements.
<code>"square"</code> (default) is a square grid.
<code>"hex"</code> is a hexagonal grid suitable for hexagonal and triangular tiling.
<code>"hex_circle"</code> is a hexagonal grid suitable for circle packing.
<code>"elongated_triangle"</code> is a grid used for the &quot;elongated triangle&quot; tiling.</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_type">type</code></td>
<td>
<p>Adjusts the repeating of certain aesthetics such as color.
Can use any type in <code>names_hex</code>, <code>names_square</code>, or <code>names_weave</code>.
See for <code><a href="#topic+pattern_hex">pattern_hex()</a></code>, <code><a href="#topic+pattern_square">pattern_square()</a></code>, and <code><a href="#topic+pattern_weave">pattern_weave()</a></code> for
more information about supported <code>type</code> arguments.</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_subtype">subtype</code></td>
<td>
<p>See for <code><a href="#topic+pattern_hex">pattern_hex()</a></code>, <code><a href="#topic+pattern_square">pattern_square()</a></code>, and <code><a href="#topic+pattern_weave">pattern_weave()</a></code> for
more information about supported <code>subtype</code> arguments.</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_circle_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>See Also</h3>

<p>See <code><a href="#topic+grid.pattern_regular_polygon">grid.pattern_regular_polygon()</a></code> for a more general case of this pattern.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
grid.pattern_circle(x_hex, y_hex, fill = c("blue", "yellow"), density = 0.5)
grid::grid.newpage()
grid.pattern_circle(x_hex, y_hex, density = 0.8, grid = "hex_circle",
                    gp = grid::gpar(fill = c("blue", "yellow", "red")))
grid::grid.newpage()
grid.pattern_circle(x_hex, y_hex, density = 1.2, grid = "hex_circle",
                    gp = grid::gpar(fill = c("blue", "yellow", "red")))
# using a "twill_zigzag" 'weave' pattern
grid::grid.newpage()
grid.pattern_circle(x_hex, y_hex, fill = "blue", density = 0.5, type = "twill_zigzag")
</code></pre>

<hr>
<h2 id='grid.pattern_crosshatch'>Crosshatch patterned grobs</h2><span id='topic+grid.pattern_crosshatch'></span>

<h3>Description</h3>

<p><code>grid.pattern_crosshatch()</code> draws a crosshatch pattern onto the graphic device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_crosshatch(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  colour = gp$col %||% "grey20",
  fill = gp$fill %||% "grey80",
  fill2 = fill,
  angle = 30,
  density = 0.2,
  spacing = 0.05,
  xoffset = 0,
  yoffset = 0,
  units = "snpc",
  alpha = gp$alpha %||% NA_real_,
  linetype = gp$lty %||% 1,
  linewidth = size %||% gp$lwd %||% 1,
  size = NULL,
  grid = "square",
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_crosshatch_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_colour">colour</code></td>
<td>
<p>Stroke colour(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_fill">fill</code></td>
<td>
<p>Fill colour(s) or <code><a href="grid.html#topic+patterns">grid::pattern()</a></code> / gradient object(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_fill2">fill2</code></td>
<td>
<p>The fill colour for the &ldquo;top&rdquo; crosshatch lines.</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_angle">angle</code></td>
<td>
<p>Rotation angle in degrees.</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_density">density</code></td>
<td>
<p>Approx. fraction of area the pattern fills.</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_spacing">spacing</code></td>
<td>
<p>Spacing between repetitions of pattern (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_xoffset">xoffset</code></td>
<td>
<p>Shift pattern along x axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_yoffset">yoffset</code></td>
<td>
<p>Shift pattern along y axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_units">units</code></td>
<td>
<p><code><a href="grid.html#topic+unit">grid::unit()</a></code> units for <code>spacing</code>, <code>xoffset</code>, and <code>yoffset</code> parameters.</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (between 0 and 1) or <code>NA</code> (default, preserves colors' alpha value).</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_linetype">linetype</code></td>
<td>
<p>Stroke linetype.</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_linewidth">linewidth</code></td>
<td>
<p>Stroke linewidth.</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_size">size</code></td>
<td>
<p>For backwards compatibility can be used to set <code>linewidth</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_grid">grid</code></td>
<td>
<p>Adjusts placement and density of certain graphical elements.
<code>"square"</code> (default) is a square grid.
<code>"hex"</code> is a hexagonal grid suitable for hexagonal and triangular tiling.
<code>"hex_circle"</code> is a hexagonal grid suitable for circle packing.
<code>"elongated_triangle"</code> is a grid used for the &quot;elongated triangle&quot; tiling.</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_crosshatch_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.pattern_weave">grid.pattern_weave()</a></code> which interweaves two sets of lines.
For a single set of lines use <code><a href="#topic+grid.pattern_stripe">grid.pattern_stripe()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
grid.pattern_crosshatch(x_hex, y_hex, colour = "black", fill = "blue",
                        fill2 = "yellow", density = 0.5)
grid::grid.newpage()
grid.pattern_crosshatch(x_hex, y_hex, density = 0.3,
                        gp = grid::gpar(col = "blue", fill = "yellow"))
</code></pre>

<hr>
<h2 id='grid.pattern_fill'>Grobs with a simple fill pattern</h2><span id='topic+grid.pattern_fill'></span>

<h3>Description</h3>

<p><code>grid.pattern_fill()</code> draws a simple fill pattern onto the graphics device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_fill(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  fill = gp$fill %||% "grey80",
  alpha = gp$alpha %||% NA_real_,
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_fill_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_fill_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_fill_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_fill_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
<tr><td><code id="grid.pattern_fill_+3A_fill">fill</code></td>
<td>
<p>Fill colour(s) or <code><a href="grid.html#topic+patterns">grid::pattern()</a></code> / gradient object(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_fill_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (between 0 and 1) or <code>NA</code> (default, preserves colors' alpha value).</p>
</td></tr>
<tr><td><code id="grid.pattern_fill_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_fill_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_fill_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_fill_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_fill_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>See Also</h3>

<p><code><a href="grid.html#topic+grid.polygon">grid::grid.polygon()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
grid.pattern_fill(x_hex, y_hex, fill = "blue")

if (guess_has_R4.1_features("patterns")) {
  grid::grid.newpage()
  stripe_fill &lt;- patternFill("stripe", fill = c("red", "blue"))
  grid.pattern_fill(x_hex, y_hex, fill = stripe_fill)
}
</code></pre>

<hr>
<h2 id='grid.pattern_gradient'>Gradient patterned grobs</h2><span id='topic+grid.pattern_gradient'></span>

<h3>Description</h3>

<p><code>grid.pattern_gradient()</code> draws a gradient pattern onto the graphic device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_gradient(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  fill = gp$fill %||% "grey80",
  fill2 = "#4169E1",
  orientation = "vertical",
  alpha = gp$alpha %||% NA_real_,
  use_R4.1_gradients = getOption("ggpattern_use_R4.1_gradients",
    getOption("ggpattern_use_R4.1_features")),
  aspect_ratio = 1,
  key_scale_factor = 1,
  res = getOption("ggpattern_res", 72),
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_gradient_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_gradient_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_gradient_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_gradient_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="grid.pattern_gradient_+3A_fill">fill</code></td>
<td>
<p>Colour.</p>
</td></tr>
<tr><td><code id="grid.pattern_gradient_+3A_fill2">fill2</code></td>
<td>
<p>Second colour.</p>
</td></tr>
<tr><td><code id="grid.pattern_gradient_+3A_orientation">orientation</code></td>
<td>
<p>vertical, horizontal, or radial.</p>
</td></tr>
<tr><td><code id="grid.pattern_gradient_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (between 0 and 1) or <code>NA</code> (default, preserves colors' alpha value).</p>
</td></tr>
<tr><td><code id="grid.pattern_gradient_+3A_use_r4.1_gradients">use_R4.1_gradients</code></td>
<td>
<p>Whether to use the gradient feature introduced in R v4.1
or use a <code>rasterGrob</code> approximation.
Note not all graphic devices support the grid gradient feature.</p>
</td></tr>
<tr><td><code id="grid.pattern_gradient_+3A_aspect_ratio">aspect_ratio</code></td>
<td>
<p>Override aspect ratio.</p>
</td></tr>
<tr><td><code id="grid.pattern_gradient_+3A_key_scale_factor">key_scale_factor</code></td>
<td>
<p>Additional scale factor for legend.</p>
</td></tr>
<tr><td><code id="grid.pattern_gradient_+3A_res">res</code></td>
<td>
<p>Assumed resolution (in pixels per graphic device inch) to use when creating array pattern.</p>
</td></tr>
<tr><td><code id="grid.pattern_gradient_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_gradient_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_gradient_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_gradient_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_gradient_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> if (requireNamespace("magick") &amp;&amp; capabilities("png")) {
   x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
   y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
   grid.pattern_gradient(x_hex, y_hex, fill = "green")
 }
 if (requireNamespace("magick") &amp;&amp; capabilities("png")) {
   grid::grid.newpage()
   grid.pattern_gradient(x_hex, y_hex, fill = "green", orientation = "radial")
 }
</code></pre>

<hr>
<h2 id='grid.pattern_image'>Image patterned grobs</h2><span id='topic+grid.pattern_image'></span>

<h3>Description</h3>

<p><code>grid.pattern_image()</code> draws an image pattern onto the graphic device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_image(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  filename = "",
  type = "fit",
  scale = 1,
  gravity = switch(type, tile = "southwest", "center"),
  filter = "lanczos",
  alpha = gp$alpha %||% NA_real_,
  aspect_ratio = 1,
  key_scale_factor = 1,
  res = getOption("ggpattern_res", 72),
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_image_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_image_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_image_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_image_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="grid.pattern_image_+3A_filename">filename</code></td>
<td>
<p>Image of filename or URL</p>
</td></tr>
<tr><td><code id="grid.pattern_image_+3A_type">type</code></td>
<td>
<p>Image scaling type</p>
</td></tr>
<tr><td><code id="grid.pattern_image_+3A_scale">scale</code></td>
<td>
<p>Extra scaling</p>
</td></tr>
<tr><td><code id="grid.pattern_image_+3A_gravity">gravity</code></td>
<td>
<p>Position of image within area.  <code>magick::gravity_types()</code> returns a vector of supported values.</p>
</td></tr>
<tr><td><code id="grid.pattern_image_+3A_filter">filter</code></td>
<td>
<p>Filter to use when scaling. <code>magick::filter_types()</code> returns a vector of supported values.</p>
</td></tr>
<tr><td><code id="grid.pattern_image_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (between 0 and 1) or <code>NA</code> (default, preserves colors' alpha value).</p>
</td></tr>
<tr><td><code id="grid.pattern_image_+3A_aspect_ratio">aspect_ratio</code></td>
<td>
<p>Override aspect ratio.</p>
</td></tr>
<tr><td><code id="grid.pattern_image_+3A_key_scale_factor">key_scale_factor</code></td>
<td>
<p>Additional scale factor for legend.</p>
</td></tr>
<tr><td><code id="grid.pattern_image_+3A_res">res</code></td>
<td>
<p>Assumed resolution (in pixels per graphic device inch) to use when creating array pattern.</p>
</td></tr>
<tr><td><code id="grid.pattern_image_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_image_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_image_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_image_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_image_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here is a description of the <code>type</code> arguments:
</p>

<dl>
<dt>expand</dt><dd><p>Scale the image beyond the bounding box and crop it such that
the image fully covers the width and the height of the region.</p>
</dd>
<dt>fit</dt><dd><p>Scale the image such that either the width or the height of the image fits in the bounding box.
Affected by <code>gravity</code></p>
</dd>
<dt>none</dt><dd><p>Position a single image in the region without attempting to scale to the bounding box size.
Affected by <code>scale</code> and <code>gravity</code>.</p>
</dd>
<dt>squish</dt><dd><p>Distort the image to cover the bounding box of the region.</p>
</dd>
<dt>tile</dt><dd><p>Repeat the image to cover the bounding box.  Affected by <code>tile</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.pattern_placeholder">grid.pattern_placeholder()</a></code> is an image pattern that uses images
downloaded from the internet.
<code><a href="#topic+reset_image_cache">reset_image_cache()</a></code> resets the image cache used by <code>grid.pattern_image()</code>
and <code><a href="#topic+grid.pattern_placeholder">grid.pattern_placeholder()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # May emit a "CPU time &gt; 2.5 times elapsed time" NOTE in a CRAN check
  if (requireNamespace("magick")) {
    x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
    y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
    logo_filename &lt;- system.file("img", "Rlogo.png" , package = "png")
    grid.pattern_image(x_hex, y_hex, filename = logo_filename, type = "fit")
  }
  if (requireNamespace("magick")) {
    # "tile" `type` image pattern depends on `magick` functionality
    # which is not reliable across platforms
    grid::grid.newpage()
    try(grid.pattern_image(x_hex, y_hex, filename = logo_filename,
                           type = "tile"))
  }
  
</code></pre>

<hr>
<h2 id='grid.pattern_magick'>Magick patterned grobs</h2><span id='topic+grid.pattern_magick'></span><span id='topic+names_magick'></span><span id='topic+names_magick_intensity'></span><span id='topic+names_magick_stripe'></span>

<h3>Description</h3>

<p><code>grid.pattern_magick()</code> draws a <code>imagemagick</code> pattern onto the graphic device.
<code>names_magick</code>, <code>names_magick_intensity</code>, and
<code>names_magick_stripe</code> are character vectors of supported <code>type</code> values
plus subsets for shaded intensity and stripes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_magick(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  type = "hexagons",
  fill = "grey20",
  scale = 1,
  filter = "box",
  alpha = gp$alpha %||% NA_real_,
  aspect_ratio = 1,
  key_scale_factor = 1,
  res = getOption("ggpattern_res", 72),
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)

names_magick

names_magick_intensity

names_magick_stripe
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_magick_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_magick_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_magick_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_magick_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="grid.pattern_magick_+3A_type">type</code></td>
<td>
<p>Magick pattern types.  <code>names_magick</code>, <code>names_magick_intensity</code>, and
<code>names_magick_stripe</code> are character vectors of supported <code>type</code> values
plus subsets for shaded intensity and stripes.</p>
</td></tr>
<tr><td><code id="grid.pattern_magick_+3A_fill">fill</code></td>
<td>
<p>Fill colour</p>
</td></tr>
<tr><td><code id="grid.pattern_magick_+3A_scale">scale</code></td>
<td>
<p>Extra scaling</p>
</td></tr>
<tr><td><code id="grid.pattern_magick_+3A_filter">filter</code></td>
<td>
<p>Filter to use when scaling. <code>magick::filter_types()</code> returns a vector of supported values.</p>
</td></tr>
<tr><td><code id="grid.pattern_magick_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (between 0 and 1) or <code>NA</code> (default, preserves colors' alpha value).</p>
</td></tr>
<tr><td><code id="grid.pattern_magick_+3A_aspect_ratio">aspect_ratio</code></td>
<td>
<p>Override aspect ratio.</p>
</td></tr>
<tr><td><code id="grid.pattern_magick_+3A_key_scale_factor">key_scale_factor</code></td>
<td>
<p>Additional scale factor for legend.</p>
</td></tr>
<tr><td><code id="grid.pattern_magick_+3A_res">res</code></td>
<td>
<p>Assumed resolution (in pixels per graphic device inch) to use when creating array pattern.</p>
</td></tr>
<tr><td><code id="grid.pattern_magick_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_magick_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_magick_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_magick_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_magick_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 54.
</p>
<p>An object of class <code>character</code> of length 21.
</p>
<p>An object of class <code>character</code> of length 19.
</p>


<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>See Also</h3>

<p>The <code>imagemagick</code> documentation <a href="http://www.imagemagick.org/script/formats.php">http://www.imagemagick.org/script/formats.php</a> for more information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if (requireNamespace("magick")) {
    x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
    y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
    grid.pattern_magick(x_hex, y_hex, type="octagons", fill="blue", scale=2)
  }

  # supported magick pattern names
  print(names_magick)
</code></pre>

<hr>
<h2 id='grid.pattern_none'>Grobs without any pattern</h2><span id='topic+grid.pattern_none'></span>

<h3>Description</h3>

<p><code>grid.pattern_none()</code> draws nothing onto the graphic device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_none(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_none_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_none_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_none_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_none_+3A_...">...</code></td>
<td>
<p>Currently ignored</p>
</td></tr>
<tr><td><code id="grid.pattern_none_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_none_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_none_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_none_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_none_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>See Also</h3>

<p><code><a href="grid.html#topic+grid.null">grid::grid.null()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
grid.pattern_none(x_hex, y_hex)
</code></pre>

<hr>
<h2 id='grid.pattern_pch'>Plotting character patterned grobs</h2><span id='topic+grid.pattern_pch'></span>

<h3>Description</h3>

<p><code>grid.pattern_pch()</code> draws a plotting character pattern onto the graphic device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_pch(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  colour = gp$col %||% "grey20",
  fill = gp$fill %||% "grey80",
  angle = 30,
  density = 0.2,
  spacing = 0.05,
  xoffset = 0,
  yoffset = 0,
  units = "snpc",
  scale = 0.5,
  shape = 1L,
  grid = "square",
  type = NULL,
  subtype = NULL,
  rot = 0,
  alpha = gp$alpha %||% NA_real_,
  linetype = gp$lty %||% 1,
  linewidth = size %||% gp$lwd %||% 1,
  size = NULL,
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_pch_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_colour">colour</code></td>
<td>
<p>Stroke colour(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_fill">fill</code></td>
<td>
<p>Fill colour(s) or <code><a href="grid.html#topic+patterns">grid::pattern()</a></code> / gradient object(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_angle">angle</code></td>
<td>
<p>Rotation angle in degrees.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_density">density</code></td>
<td>
<p>Approx. fraction of area the pattern fills.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_spacing">spacing</code></td>
<td>
<p>Spacing between repetitions of pattern (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_xoffset">xoffset</code></td>
<td>
<p>Shift pattern along x axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_yoffset">yoffset</code></td>
<td>
<p>Shift pattern along y axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_units">units</code></td>
<td>
<p><code><a href="grid.html#topic+unit">grid::unit()</a></code> units for <code>spacing</code>, <code>xoffset</code>, and <code>yoffset</code> parameters.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_scale">scale</code></td>
<td>
<p>For star polygons, multiplier (between 0 and 1)
applied to exterior radius to get interior radius.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_shape">shape</code></td>
<td>
<p>An integer from <code>0</code> to <code>25</code> or <code>NA</code>.
See <code><a href="graphics.html#topic+points">graphics::points()</a></code> for more details.
Note we only support these shapes and do not
support arbitrary ASCII / Unicode characters.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_grid">grid</code></td>
<td>
<p>Adjusts placement and density of certain graphical elements.
<code>"square"</code> (default) is a square grid.
<code>"hex"</code> is a hexagonal grid suitable for hexagonal and triangular tiling.
<code>"hex_circle"</code> is a hexagonal grid suitable for circle packing.
<code>"elongated_triangle"</code> is a grid used for the &quot;elongated triangle&quot; tiling.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_type">type</code></td>
<td>
<p>Adjusts the repeating of certain aesthetics such as color.
Can use any type in <code>names_hex</code>, <code>names_square</code>, or <code>names_weave</code>.
See for <code><a href="#topic+pattern_hex">pattern_hex()</a></code>, <code><a href="#topic+pattern_square">pattern_square()</a></code>, and <code><a href="#topic+pattern_weave">pattern_weave()</a></code> for
more information about supported <code>type</code> arguments.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_subtype">subtype</code></td>
<td>
<p>See for <code><a href="#topic+pattern_hex">pattern_hex()</a></code>, <code><a href="#topic+pattern_square">pattern_square()</a></code>, and <code><a href="#topic+pattern_weave">pattern_weave()</a></code> for
more information about supported <code>subtype</code> arguments.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_rot">rot</code></td>
<td>
<p>Angle to rotate regular polygon (degrees, counter-clockwise).</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (between 0 and 1) or <code>NA</code> (default, preserves colors' alpha value).</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_linetype">linetype</code></td>
<td>
<p>Stroke linetype.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_linewidth">linewidth</code></td>
<td>
<p>Stroke linewidth.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_size">size</code></td>
<td>
<p>For backwards compatibility can be used to set <code>linewidth</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_pch_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.pattern_regular_polygon">grid.pattern_regular_polygon()</a></code> which is used to implement this pattern.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
gp &lt;- grid::gpar(col = "black", fill = "lightblue")

if (capabilities("png") || guess_has_R4.1_features("masks")) {
  # pch 0-6 are simple shapes with no fill
  grid.pattern_pch(x_hex, y_hex, shape = 0:6, gp = gp,
                   spacing = 0.1, density = 0.4, angle = 0)
}
if (capabilities("png") || guess_has_R4.1_features("masks")) {
  # pch 7-14 are compound shapes with no fill
  grid::grid.newpage()
  grid.pattern_pch(x_hex, y_hex, shape = 7:14, gp = gp,
                   spacing = 0.1, density = 0.4, angle = 0)
}
if (capabilities("png") || guess_has_R4.1_features("masks")) {
  # pch 15-20 are filled with 'col'
  grid::grid.newpage()
  grid.pattern_pch(x_hex, y_hex, shape = 15:20, gp = gp,
                   spacing = 0.1, density = 0.4, angle = 0)
}
if (capabilities("png") || guess_has_R4.1_features("masks")) {
  # pch 21-25 are filled with 'fill'
  grid::grid.newpage()
  grid.pattern_pch(x_hex, y_hex, shape = 21:25, gp = gp,
                   spacing = 0.1, density = 0.4, angle = 0)
}
if (capabilities("png") || guess_has_R4.1_features("masks")) {
  # using a 'basket' weave `type` with two shapes
  grid::grid.newpage()
  grid.pattern_pch(x_hex, y_hex, shape = c(1,4), gp = gp,
                   type = "basket",
                   spacing = 0.1, density = 0.4, angle = 0)
}
</code></pre>

<hr>
<h2 id='grid.pattern_placeholder'>Placeholder image patterned grobs</h2><span id='topic+grid.pattern_placeholder'></span><span id='topic+names_placeholder'></span>

<h3>Description</h3>

<p><code>grid.pattern_placeholder()</code> draws a placeholder image pattern onto the graphic device.
<code>names_placeholder</code> are character vectors of supported placeholder types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_placeholder(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  type = "bear",
  alpha = gp$alpha %||% NA_real_,
  aspect_ratio = 1,
  key_scale_factor = 1,
  res = getOption("ggpattern_res", 72),
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)

names_placeholder
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_placeholder_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_placeholder_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_placeholder_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_placeholder_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="grid.pattern_placeholder_+3A_type">type</code></td>
<td>
<p>Image source.  <code>names_placeholder</code> is a vector of supported values.
If you would like only greyscale images append <code>bw</code> to the name.</p>
</td></tr>
<tr><td><code id="grid.pattern_placeholder_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (between 0 and 1) or <code>NA</code> (default, preserves colors' alpha value).</p>
</td></tr>
<tr><td><code id="grid.pattern_placeholder_+3A_aspect_ratio">aspect_ratio</code></td>
<td>
<p>Override aspect ratio.</p>
</td></tr>
<tr><td><code id="grid.pattern_placeholder_+3A_key_scale_factor">key_scale_factor</code></td>
<td>
<p>Additional scale factor for legend.</p>
</td></tr>
<tr><td><code id="grid.pattern_placeholder_+3A_res">res</code></td>
<td>
<p>Assumed resolution (in pixels per graphic device inch) to use when creating array pattern.</p>
</td></tr>
<tr><td><code id="grid.pattern_placeholder_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_placeholder_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_placeholder_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_placeholder_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_placeholder_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 22.
</p>


<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+reset_image_cache">reset_image_cache()</a></code> resets the image cache used by <code><a href="#topic+grid.pattern_image">grid.pattern_image()</a></code> and <code>grid.pattern_placeholder()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if (requireNamespace("magick")) {
    x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
    y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
    # requires internet connection to download from placeholder image websites
    try(grid.pattern_placeholder(x_hex, y_hex, type="bear"))
  }

  print(names_placeholder)
</code></pre>

<hr>
<h2 id='grid.pattern_plasma'>Plasma patterned grobs</h2><span id='topic+grid.pattern_plasma'></span>

<h3>Description</h3>

<p><code>grid.pattern_plasma()</code> draws a plasma pattern onto the graphic device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_plasma(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  fill = gp$fill %||% "grey80",
  scale = 1,
  alpha = gp$alpha %||% NA_real_,
  aspect_ratio = 1,
  key_scale_factor = 1,
  res = getOption("ggpattern_res", 72),
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_plasma_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_plasma_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_plasma_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_plasma_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="grid.pattern_plasma_+3A_fill">fill</code></td>
<td>
<p>Colour.</p>
</td></tr>
<tr><td><code id="grid.pattern_plasma_+3A_scale">scale</code></td>
<td>
<p>Extra scaling</p>
</td></tr>
<tr><td><code id="grid.pattern_plasma_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (between 0 and 1) or <code>NA</code> (default, preserves colors' alpha value).</p>
</td></tr>
<tr><td><code id="grid.pattern_plasma_+3A_aspect_ratio">aspect_ratio</code></td>
<td>
<p>Override aspect ratio.</p>
</td></tr>
<tr><td><code id="grid.pattern_plasma_+3A_key_scale_factor">key_scale_factor</code></td>
<td>
<p>Additional scale factor for legend.</p>
</td></tr>
<tr><td><code id="grid.pattern_plasma_+3A_res">res</code></td>
<td>
<p>Assumed resolution (in pixels per graphic device inch) to use when creating array pattern.</p>
</td></tr>
<tr><td><code id="grid.pattern_plasma_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_plasma_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_plasma_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_plasma_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_plasma_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.pattern_ambient">grid.pattern_ambient()</a></code> provides a noise pattern using the <code>ambient</code> package.
Pseudorandom seeds for the plasma pattern may be set via <code><a href="magick.html#topic+config">magick::magick_set_seed()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if (requireNamespace("magick")) {
    x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
    y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
    grid.pattern_plasma(x_hex, y_hex, fill = "green")
  }
</code></pre>

<hr>
<h2 id='grid.pattern_polygon_tiling'>Polygon tiling patterned grobs</h2><span id='topic+grid.pattern_polygon_tiling'></span><span id='topic+names_polygon_tiling'></span>

<h3>Description</h3>

<p><code>grid.pattern_polygon_tiling()</code> draws a specified polygon tiling pattern onto the graphic device.
<code>names_polygon_tiling</code> lists all supported types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_polygon_tiling(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  colour = gp$col %||% "grey20",
  fill = gp$fill %||% "grey80",
  angle = 30,
  spacing = 0.05,
  xoffset = 0,
  yoffset = 0,
  units = "snpc",
  type = "square",
  alpha = gp$alpha %||% NA_real_,
  linetype = gp$lty %||% 1,
  linewidth = size %||% gp$lwd %||% 1,
  size = NULL,
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)

names_polygon_tiling
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_colour">colour</code></td>
<td>
<p>Stroke colour(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_fill">fill</code></td>
<td>
<p>Fill colour(s) or <code><a href="grid.html#topic+patterns">grid::pattern()</a></code> / gradient object(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_angle">angle</code></td>
<td>
<p>Rotation angle in degrees.</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_spacing">spacing</code></td>
<td>
<p>Spacing between repetitions of pattern (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_xoffset">xoffset</code></td>
<td>
<p>Shift pattern along x axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_yoffset">yoffset</code></td>
<td>
<p>Shift pattern along y axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_units">units</code></td>
<td>
<p><code><a href="grid.html#topic+unit">grid::unit()</a></code> units for <code>spacing</code>, <code>xoffset</code>, and <code>yoffset</code> parameters.</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_type">type</code></td>
<td>
<p>Name of polygon tiling to draw.  See Details.</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (between 0 and 1) or <code>NA</code> (default, preserves colors' alpha value).
Not supported for all polygon tiling <code>type</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_linetype">linetype</code></td>
<td>
<p>Stroke linetype.</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_linewidth">linewidth</code></td>
<td>
<p>Stroke linewidth.</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_size">size</code></td>
<td>
<p>For backwards compatibility can be used to set <code>linewidth</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_polygon_tiling_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 36.
</p>


<h3>Details</h3>

<p><code>grid.pattern_polygon_tiling()</code> supports 1, 2, or 3 <code>fill</code> colors with the first colors (weakly)
covering a larger area.  Size of the pattern is controlled by <code>spacing</code>.
We support the following polygon tiling <code>type</code>s:
</p>

<dl>
<dt><code>elongated_triangular</code></dt><dd><p>Creates an elongated triangular tiling made of squares and triangles.</p>
</dd>
<dt><code>herringbone</code></dt><dd><p>Creates a herringbone tiling made of rectangles.</p>
</dd>
<dt><code>hexagonal</code></dt><dd><p>Creates a hexagonal tiling made of hexagons.</p>
</dd>
<dt><code>pythagorean</code></dt><dd><p>Creates a Pythagorean tiling made of squares of two different sizes.</p>
</dd>
<dt><code>rhombille</code></dt><dd><p>Creates a rhombille tiling made of rhombi.</p>
</dd>
<dt><code>rhombitrihexagonal</code></dt><dd><p>Creates a rhombitrihexagonal tiling made out of
dodecagons, hexagons, and squares.</p>
</dd>
<dt><code>snub_square</code></dt><dd><p>Creates a snub square tiling made of squares and triangles.</p>
</dd>
<dt><code>snub_trihexagonal</code></dt><dd><p>Creates a snub trihexagonal tiling made of hexagons and triangles.</p>
</dd>
<dt><code>square</code></dt><dd><p>Creates a square tiling made of squares.</p>
</dd>
<dt><code>tetrakis_square</code></dt><dd><p>Creates a tetrakis square tiling made of isosceles right triangles.</p>
</dd>
<dt><code>triangular</code></dt><dd><p>Creates a triangular tiling made of equilateral triangles.</p>
</dd>
<dt><code>trihexagonal</code></dt><dd><p>Creates a trihexagonal tiling made of hexagons and triangles.</p>
</dd>
<dt><code>truncated_square</code></dt><dd><p>Creates a truncated square tiling made of octagons and squares.</p>
</dd>
<dt><code>truncated_hexagonal</code></dt><dd><p>Creates a truncated hexagonal tiling made of dodecagons and triangles.</p>
</dd>
<dt><code>truncated_trihexagonal</code></dt><dd><p>Creates a truncated trihexagonal tiling made of hexagons, squares, and triangles.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;2*.2**.2*.2**&#8288;</code></dt><dd><p>Creates a polygon tiling made of rhombi.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;2**.3**.12*&#8288;</code></dt><dd><p>Creates a polygon tiling made of rhombi, triangles, and twelve-pointed stars.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;3.3.3.3**&#8288;</code></dt><dd><p>Creates a polygon tiling made of triangles.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;3.3*.3.3**&#8288;</code></dt><dd><p>Creates a regular (star) polygon tiling made of triangles and three-pointed stars.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;3.3.3.12*.3.3.12*&#8288;</code></dt><dd><p>Creates a regular (star) polygon tiling made of triangles and twelve-pointed stars.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;3.3.8*.3.4.3.8*&#8288;</code></dt><dd><p>Creates a regular (star) polygon tiling made of triangles, squares, and eight-pointed stars.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;3.3.8*.4**.8*&#8288;</code></dt><dd><p>Creates a regular (star) polygon tiling made of triangles, four-pointed stars, and eight-pointed stars.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;3.4.6.3.12*&#8288;</code></dt><dd><p>Creates a regular (star) polygon tiling made of triangles, squares, hexagons, and twelve-pointed stars.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;3.4.8.3.8*&#8288;</code></dt><dd><p>Creates a regular (star) polygon tiling made of triangles, squares, octagons, and eight-pointed stars.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;3.6*.6**&#8288;</code></dt><dd><p>Creates a regular (star) polygon tiling made of triangles and six-pointed stars.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;4.2*.4.2**&#8288;</code></dt><dd><p>Creates a polygon tiling made of squares and rhombi.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;4.4*.4**&#8288;</code></dt><dd><p>Creates a regular (star) polygon tiling made of squares and four-pointed stars.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;4.6.4*.6&#8288;</code></dt><dd><p>Creates a regular (star) polygon tiling made of squares, hexagons, and four-pointed stars.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;4.6*.4.6*.4.6*&#8288;</code></dt><dd><p>Creates a regular (star) polygon tiling made of squares and six-pointed stars.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;4.8*.4**.8*&#8288;</code></dt><dd><p>Creates a polygon tiling of squares and eight-pointed stars.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;6.6*.6.6*&#8288;</code></dt><dd><p>Creates a regular (star) polygon tiling made of hexagons and six-pointed stars.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;8.4*.8.4*&#8288;</code></dt><dd><p>Creates a regular (star) polygon tiling made of octagons and four-pointed stars.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;9.3.9.3*&#8288;</code></dt><dd><p>Creates a regular (star) polygon tiling made of triangles, nonagons, and three-pointed stars.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;12.3*.12.3*&#8288;</code></dt><dd><p>Creates a regular (star) polygon tiling made of dodecagons and three-pointed stars.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;12.12.4*&#8288;</code></dt><dd><p>Creates a regular (star) polygon tiling made of dodecagons and four-pointed stars.</p>
</dd>
<dt><code style="white-space: pre;">&#8288;18.18.3*&#8288;</code></dt><dd><p>Creates a regular (star) polygon tiling made of eighteen-sided polygons and three-pointed stars.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>See Also</h3>

<p>The tiling vignette <code>vignette("tiling", package = "gridpattern")</code> for more
information about these tilings as well as more
examples of polygon tiling using the <code><a href="#topic+grid.pattern_regular_polygon">grid.pattern_regular_polygon()</a></code> function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(names_polygon_tiling)

x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
gp1 &lt;- grid::gpar(fill = "yellow", col = "black")
gp2 &lt;- grid::gpar(fill = c("yellow", "red"), col = "black")
gp3 &lt;- grid::gpar(fill = c("yellow", "red", "blue"), col = "black")

grid.pattern_polygon_tiling(x_hex, y_hex, type = "herringbone", gp = gp1)

grid::grid.newpage()
grid.pattern_polygon_tiling(x_hex, y_hex, type = "hexagonal",
                            spacing = 0.2, gp = gp3)

grid::grid.newpage()
grid.pattern_polygon_tiling(x_hex, y_hex, type = "pythagorean",
                            spacing = 0.2, gp = gp2)

grid::grid.newpage()
grid.pattern_polygon_tiling(x_hex, y_hex, type = "snub_trihexagonal",
                            spacing = 0.2, gp = gp3)

grid::grid.newpage()
grid.pattern_polygon_tiling(x_hex, y_hex, type = "rhombille",
                              spacing = 0.2, gp = gp3)
</code></pre>

<hr>
<h2 id='grid.pattern_regular_polygon'>Regular polygon patterned grobs</h2><span id='topic+grid.pattern_regular_polygon'></span>

<h3>Description</h3>

<p><code>grid.pattern_regular_polygon()</code> draws a regular polygon pattern onto the graphic device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_regular_polygon(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  colour = gp$col %||% "grey20",
  fill = gp$fill %||% "grey80",
  angle = 30,
  density = 0.2,
  spacing = 0.05,
  xoffset = 0,
  yoffset = 0,
  units = "snpc",
  scale = 0.5,
  shape = "convex4",
  grid = "square",
  type = NULL,
  subtype = NULL,
  rot = 0,
  alpha = gp$alpha %||% NA_real_,
  linetype = gp$lty %||% 1,
  linewidth = size %||% gp$lwd %||% 1,
  size = NULL,
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_regular_polygon_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_colour">colour</code></td>
<td>
<p>Stroke colour(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_fill">fill</code></td>
<td>
<p>Fill colour(s) or <code><a href="grid.html#topic+patterns">grid::pattern()</a></code> / gradient object(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_angle">angle</code></td>
<td>
<p>Rotation angle in degrees.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_density">density</code></td>
<td>
<p>Approx. fraction of area the pattern fills.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_spacing">spacing</code></td>
<td>
<p>Spacing between repetitions of pattern (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_xoffset">xoffset</code></td>
<td>
<p>Shift pattern along x axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_yoffset">yoffset</code></td>
<td>
<p>Shift pattern along y axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_units">units</code></td>
<td>
<p><code><a href="grid.html#topic+unit">grid::unit()</a></code> units for <code>spacing</code>, <code>xoffset</code>, and <code>yoffset</code> parameters.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_scale">scale</code></td>
<td>
<p>For star polygons, multiplier (between 0 and 1)
applied to exterior radius to get interior radius.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_shape">shape</code></td>
<td>
<p>Either &quot;convex&quot; or &quot;star&quot; followed by the number of exterior vertices
or alternatively &quot;circle&quot;, &quot;square&quot;, &quot;null&quot;, &quot;rhombille_rhombus&quot;,
&quot;tetrakis_left&quot;, or &quot;tetrakis_right&quot;.
For example &quot;convex5&quot; corresponds to a pentagon
and &quot;star6&quot; corresponds to a six-pointed star.
The &quot;square&quot; shape is larger than the &quot;convex4&quot; shape and is rotated an extra 45 degrees,
it can be used to generate a multi-colored &ldquo;checkers&rdquo; effect when density is 1.
The &quot;null&quot; shape is not drawn, it can be used to create holes within multiple-element patterns.
The &quot;rhombille_rhombus&quot; shape draws a rhombus while the
&quot;tetrakis_left&quot; or &quot;tetrakis_right&quot; shapes draw an isosceles right triangle.
These latter three non-regular-polygon shapes are
intended to help generate rhombille and tetrakis square tilings.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_grid">grid</code></td>
<td>
<p>Adjusts placement and density of certain graphical elements.
<code>"square"</code> (default) is a square grid.
<code>"hex"</code> is a hexagonal grid suitable for hexagonal and triangular tiling.
<code>"hex_circle"</code> is a hexagonal grid suitable for circle packing.
<code>"elongated_triangle"</code> is a grid used for the &quot;elongated triangle&quot; tiling.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_type">type</code></td>
<td>
<p>Adjusts the repeating of certain aesthetics such as color.
Can use any type in <code>names_hex</code>, <code>names_square</code>, or <code>names_weave</code>.
See for <code><a href="#topic+pattern_hex">pattern_hex()</a></code>, <code><a href="#topic+pattern_square">pattern_square()</a></code>, and <code><a href="#topic+pattern_weave">pattern_weave()</a></code> for
more information about supported <code>type</code> arguments.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_subtype">subtype</code></td>
<td>
<p>See for <code><a href="#topic+pattern_hex">pattern_hex()</a></code>, <code><a href="#topic+pattern_square">pattern_square()</a></code>, and <code><a href="#topic+pattern_weave">pattern_weave()</a></code> for
more information about supported <code>subtype</code> arguments.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_rot">rot</code></td>
<td>
<p>Angle to rotate regular polygon (degrees, counter-clockwise).</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (between 0 and 1) or <code>NA</code> (default, preserves colors' alpha value).</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_linetype">linetype</code></td>
<td>
<p>Stroke linetype.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_linewidth">linewidth</code></td>
<td>
<p>Stroke linewidth.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_size">size</code></td>
<td>
<p>For backwards compatibility can be used to set <code>linewidth</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_regular_polygon_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.pattern_circle">grid.pattern_circle()</a></code> for a special case of this pattern.
The tiling vignette features more examples of regular polygon tiling using
this function <code>vignette("tiling", package = "gridpattern")</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))

# 'density', 'rot', and 'shape' are vectorized
grid.pattern_regular_polygon(x_hex, y_hex, colour = "black",
                             fill = c("blue", "yellow", "red"),
                             shape = c("convex4", "star8", "circle"),
                             density = c(0.45, 0.42, 0.4),
                             spacing = 0.08, angle = 0)

# checker pattern using "square" shape
grid::grid.newpage()
grid.pattern_regular_polygon(x_hex, y_hex, shape = "square",
                             colour = "transparent",
                             fill = c("black", "red", "blue", "yellow"),
                             angle = 0, density = 1.0, spacing = 0.2)

# checker pattern using the default "convex4" shape
grid::grid.newpage()
grid.pattern_regular_polygon(x_hex, y_hex, density = 1.0,
                             colour = "black", fill = "blue")

# using a "twill_zigzag" 'weave' pattern
grid::grid.newpage()
grid.pattern_regular_polygon(x_hex, y_hex, fill = c("blue", "yellow"),
                             shape = c("circle", "star8"),
                             density = c(0.5, 0.6), type = "twill_zigzag")

# hexagon tiling
grid::grid.newpage()
grid.pattern_regular_polygon(x_hex, y_hex, color = "transparent",
                             fill = c("white", "grey", "black"),
                             density = 1.0, spacing = 0.1,
                             shape = "convex6", grid = "hex")

# triangle tiling
grid::grid.newpage()
grid.pattern_regular_polygon(x_hex, y_hex, fill = "green",
                             density = 1.0, spacing = 0.1,
                             shape = "convex3", grid = "hex")
</code></pre>

<hr>
<h2 id='grid.pattern_rose'>Rose curve patterned grobs</h2><span id='topic+grid.pattern_rose'></span>

<h3>Description</h3>

<p><code>grid.pattern_rose()</code> draws a rose curve pattern onto the graphic device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_rose(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  colour = gp$col %||% "grey20",
  fill = gp$fill %||% "grey80",
  angle = 30,
  density = 0.2,
  spacing = 0.05,
  xoffset = 0,
  yoffset = 0,
  units = "snpc",
  frequency = 0.1,
  grid = "square",
  type = NULL,
  subtype = NULL,
  rot = 0,
  alpha = gp$alpha %||% NA_real_,
  linetype = gp$lty %||% 1,
  linewidth = size %||% gp$lwd %||% 1,
  size = NULL,
  use_R4.1_masks = getOption("ggpattern_use_R4.1_masks",
    getOption("ggpattern_use_R4.1_features")),
  png_device = NULL,
  res = getOption("ggpattern_res", 72),
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_rose_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_colour">colour</code></td>
<td>
<p>Stroke colour(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_fill">fill</code></td>
<td>
<p>Fill colour(s) or <code><a href="grid.html#topic+patterns">grid::pattern()</a></code> / gradient object(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_angle">angle</code></td>
<td>
<p>Rotation angle in degrees.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_density">density</code></td>
<td>
<p>Approx. fraction of area the pattern fills.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_spacing">spacing</code></td>
<td>
<p>Spacing between repetitions of pattern (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_xoffset">xoffset</code></td>
<td>
<p>Shift pattern along x axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_yoffset">yoffset</code></td>
<td>
<p>Shift pattern along y axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_units">units</code></td>
<td>
<p><code><a href="grid.html#topic+unit">grid::unit()</a></code> units for <code>spacing</code>, <code>xoffset</code>, and <code>yoffset</code> parameters.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_frequency">frequency</code></td>
<td>
<p>The &ldquo;angular frequency&rdquo; parameter of the rose pattern.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_grid">grid</code></td>
<td>
<p>Adjusts placement and density of certain graphical elements.
<code>"square"</code> (default) is a square grid.
<code>"hex"</code> is a hexagonal grid suitable for hexagonal and triangular tiling.
<code>"hex_circle"</code> is a hexagonal grid suitable for circle packing.
<code>"elongated_triangle"</code> is a grid used for the &quot;elongated triangle&quot; tiling.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_type">type</code></td>
<td>
<p>Adjusts the repeating of certain aesthetics such as color.
Can use any type in <code>names_hex</code>, <code>names_square</code>, or <code>names_weave</code>.
See for <code><a href="#topic+pattern_hex">pattern_hex()</a></code>, <code><a href="#topic+pattern_square">pattern_square()</a></code>, and <code><a href="#topic+pattern_weave">pattern_weave()</a></code> for
more information about supported <code>type</code> arguments.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_subtype">subtype</code></td>
<td>
<p>See for <code><a href="#topic+pattern_hex">pattern_hex()</a></code>, <code><a href="#topic+pattern_square">pattern_square()</a></code>, and <code><a href="#topic+pattern_weave">pattern_weave()</a></code> for
more information about supported <code>subtype</code> arguments.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_rot">rot</code></td>
<td>
<p>Angle to rotate rose (degrees, counter-clockwise).</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (between 0 and 1) or <code>NA</code> (default, preserves colors' alpha value).</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_linetype">linetype</code></td>
<td>
<p>Stroke linetype.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_linewidth">linewidth</code></td>
<td>
<p>Stroke linewidth.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_size">size</code></td>
<td>
<p>For backwards compatibility can be used to set <code>linewidth</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_use_r4.1_masks">use_R4.1_masks</code></td>
<td>
<p>If <code>TRUE</code> use the grid mask feature introduced in R v4.1.0.
If <code>FALSE</code> do a <code>rasterGrob</code> approximation.
If <code>NULL</code> try to guess an appropriate choice.
Note not all graphic devices support the grid mask feature.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_png_device">png_device</code></td>
<td>
<p>&ldquo;png&rdquo; graphics device to save intermediate raster data with if <code>use_R4.1_masks</code> is <code>FALSE</code>.
If <code>NULL</code> and suggested package <code>ragg</code> is available
and versions are high enough we directly capture masked raster via <code><a href="ragg.html#topic+agg_capture">ragg::agg_capture()</a></code>.
Otherwise we will use <code>png_device</code>
(default <code><a href="ragg.html#topic+agg_png">ragg::agg_png()</a></code> if available else <code><a href="grDevices.html#topic+png">grDevices::png()</a></code>) and <code><a href="png.html#topic+readPNG">png::readPNG()</a></code>
to manually compute a masked raster.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_res">res</code></td>
<td>
<p>Resolution of desired <code>rasterGrob</code> in pixels per inch if <code>use_R4.1_masks</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_rose_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>See Also</h3>

<p>See <a href="https://en.wikipedia.org/wiki/Rose_(mathematics)">https://en.wikipedia.org/wiki/Rose_(mathematics)</a> for more information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  if (capabilities("png") || guess_has_R4.1_features("masks")) {
    x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
    y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
    gp &lt;- grid::gpar(fill = c("blue", "red", "yellow", "green"), col = "black")
    grid.pattern_rose(x_hex, y_hex,
                      spacing = 0.15, density = 0.5, angle = 0,
                      frequency = 1:4, gp = gp)
  }
  if (capabilities("png") || guess_has_R4.1_features("masks")) {
    grid::grid.newpage()
    grid.pattern_rose(x_hex, y_hex,
                      spacing = 0.15, density = 0.5, angle = 0,
                      frequency = 1/1:4, gp = gp)
  }
  if (capabilities("png") || guess_has_R4.1_features("masks")) {
    grid::grid.newpage()
    grid.pattern_rose(x_hex, y_hex,
                      spacing = 0.18, density = 0.5, angle = 0,
                      frequency = c(3/2, 7/3, 5/4, 3/7), gp = gp)
  }
</code></pre>

<hr>
<h2 id='grid.pattern_stripe'>Stripe patterned grobs</h2><span id='topic+grid.pattern_stripe'></span>

<h3>Description</h3>

<p><code>grid.pattern_stripe()</code> draws a stripe pattern onto the graphic device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_stripe(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  colour = gp$col %||% "grey20",
  fill = gp$fill %||% "grey80",
  angle = 30,
  density = 0.2,
  spacing = 0.05,
  xoffset = 0,
  yoffset = 0,
  units = "snpc",
  alpha = gp$alpha %||% NA_real_,
  linetype = gp$lty %||% 1,
  linewidth = size %||% gp$lwd %||% 1,
  size = NULL,
  grid = "square",
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_stripe_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_colour">colour</code></td>
<td>
<p>Stroke colour(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_fill">fill</code></td>
<td>
<p>Fill colour(s) or <code><a href="grid.html#topic+patterns">grid::pattern()</a></code> / gradient object(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_angle">angle</code></td>
<td>
<p>Rotation angle in degrees.</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_density">density</code></td>
<td>
<p>Approx. fraction of area the pattern fills.</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_spacing">spacing</code></td>
<td>
<p>Spacing between repetitions of pattern (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_xoffset">xoffset</code></td>
<td>
<p>Shift pattern along x axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_yoffset">yoffset</code></td>
<td>
<p>Shift pattern along y axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_units">units</code></td>
<td>
<p><code><a href="grid.html#topic+unit">grid::unit()</a></code> units for <code>spacing</code>, <code>xoffset</code>, and <code>yoffset</code> parameters.</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (between 0 and 1) or <code>NA</code> (default, preserves colors' alpha value).</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_linetype">linetype</code></td>
<td>
<p>Stroke linetype.</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_linewidth">linewidth</code></td>
<td>
<p>Stroke linewidth.</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_size">size</code></td>
<td>
<p>For backwards compatibility can be used to set <code>linewidth</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_grid">grid</code></td>
<td>
<p>Adjusts placement and density of certain graphical elements.
<code>"square"</code> (default) is a square grid.
<code>"hex"</code> is a hexagonal grid suitable for hexagonal and triangular tiling.
<code>"hex_circle"</code> is a hexagonal grid suitable for circle packing.
<code>"elongated_triangle"</code> is a grid used for the &quot;elongated triangle&quot; tiling.</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_stripe_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>See Also</h3>

<p><code style="white-space: pre;">&#8288;[grid.pattern_crosshatch()]&#8288;</code> and <code style="white-space: pre;">&#8288;[grid.pattern_weave()]&#8288;</code> for overlaying stripes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
grid.pattern_stripe(x_hex, y_hex, colour = "black",
                    fill = c("red", "blue"), density = 0.4)

# Can alternatively use "gpar()" to specify colour and line attributes
grid::grid.newpage()
grid.pattern_stripe(x_hex, y_hex, density = 0.3,
                    gp = grid::gpar(col = "blue", fill = "yellow"))
</code></pre>

<hr>
<h2 id='grid.pattern_text'>Text character patterned grobs</h2><span id='topic+grid.pattern_text'></span>

<h3>Description</h3>

<p><code>grid.pattern_text()</code> draws a text character pattern onto the graphic device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_text(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  colour = gp$col %||% "grey20",
  angle = 30,
  spacing = 0.05,
  xoffset = 0,
  yoffset = 0,
  units = "snpc",
  scale = 0.5,
  shape = "X",
  grid = "square",
  type = NULL,
  subtype = NULL,
  rot = 0,
  alpha = gp$alpha %||% NA_real_,
  size = gp$fontsize %||% 12,
  fontfamily = gp$fontfamily %||% "sans",
  fontface = gp$fontface %||% "plain",
  use_R4.1_masks = getOption("ggpattern_use_R4.1_masks",
    getOption("ggpattern_use_R4.1_features")),
  png_device = NULL,
  res = getOption("ggpattern_res", 72),
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_text_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_colour">colour</code></td>
<td>
<p>Stroke colour(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_angle">angle</code></td>
<td>
<p>Rotation angle in degrees.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_spacing">spacing</code></td>
<td>
<p>Spacing between repetitions of pattern (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_xoffset">xoffset</code></td>
<td>
<p>Shift pattern along x axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_yoffset">yoffset</code></td>
<td>
<p>Shift pattern along y axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_units">units</code></td>
<td>
<p><code><a href="grid.html#topic+unit">grid::unit()</a></code> units for <code>spacing</code>, <code>xoffset</code>, and <code>yoffset</code> parameters.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_scale">scale</code></td>
<td>
<p>For star polygons, multiplier (between 0 and 1)
applied to exterior radius to get interior radius.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_shape">shape</code></td>
<td>
<p>A character or expression vector.
See <code>label</code> argument of <code><a href="grid.html#topic+grid.text">grid::textGrob()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_grid">grid</code></td>
<td>
<p>Adjusts placement and density of certain graphical elements.
<code>"square"</code> (default) is a square grid.
<code>"hex"</code> is a hexagonal grid suitable for hexagonal and triangular tiling.
<code>"hex_circle"</code> is a hexagonal grid suitable for circle packing.
<code>"elongated_triangle"</code> is a grid used for the &quot;elongated triangle&quot; tiling.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_type">type</code></td>
<td>
<p>Adjusts the repeating of certain aesthetics such as color.
Can use any type in <code>names_hex</code>, <code>names_square</code>, or <code>names_weave</code>.
See for <code><a href="#topic+pattern_hex">pattern_hex()</a></code>, <code><a href="#topic+pattern_square">pattern_square()</a></code>, and <code><a href="#topic+pattern_weave">pattern_weave()</a></code> for
more information about supported <code>type</code> arguments.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_subtype">subtype</code></td>
<td>
<p>See for <code><a href="#topic+pattern_hex">pattern_hex()</a></code>, <code><a href="#topic+pattern_square">pattern_square()</a></code>, and <code><a href="#topic+pattern_weave">pattern_weave()</a></code> for
more information about supported <code>subtype</code> arguments.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_rot">rot</code></td>
<td>
<p>Angle to rotate regular polygon (degrees, counter-clockwise).</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (between 0 and 1) or <code>NA</code> (default, preserves colors' alpha value).</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_size">size</code></td>
<td>
<p>Fontsize</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_fontfamily">fontfamily</code></td>
<td>
<p>The font family.  See <code><a href="grid.html#topic+gpar">grid::gpar()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_fontface">fontface</code></td>
<td>
<p>The font face.  See <code><a href="grid.html#topic+gpar">grid::gpar()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_use_r4.1_masks">use_R4.1_masks</code></td>
<td>
<p>If <code>TRUE</code> use the grid mask feature introduced in R v4.1.0.
If <code>FALSE</code> do a <code>rasterGrob</code> approximation.
If <code>NULL</code> try to guess an appropriate choice.
Note not all graphic devices support the grid mask feature.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_png_device">png_device</code></td>
<td>
<p>&ldquo;png&rdquo; graphics device to save intermediate raster data with if <code>use_R4.1_masks</code> is <code>FALSE</code>.
If <code>NULL</code> and suggested package <code>ragg</code> is available
and versions are high enough we directly capture masked raster via <code><a href="ragg.html#topic+agg_capture">ragg::agg_capture()</a></code>.
Otherwise we will use <code>png_device</code>
(default <code><a href="ragg.html#topic+agg_png">ragg::agg_png()</a></code> if available else <code><a href="grDevices.html#topic+png">grDevices::png()</a></code>) and <code><a href="png.html#topic+readPNG">png::readPNG()</a></code>
to manually compute a masked raster.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_res">res</code></td>
<td>
<p>Resolution of desired <code>rasterGrob</code> in pixels per inch if <code>use_R4.1_masks</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_text_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (capabilities("png") &amp;&amp;
    gridpattern:::device_supports_unicode()) {
  x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
  y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))

  playing_card_symbols &lt;- c("\u2660", "\u2665", "\u2666", "\u2663")
  grid.pattern_text(x_hex, y_hex,
                   shape = playing_card_symbols,
                   colour = c("black", "red", "red", "black"),
                   size = 18, spacing = 0.1, angle = 0)
}
</code></pre>

<hr>
<h2 id='grid.pattern_wave'>Wave patterned grobs</h2><span id='topic+grid.pattern_wave'></span>

<h3>Description</h3>

<p><code>grid.pattern_wave()</code> draws a wave pattern onto the graphic device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_wave(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  colour = gp$col %||% "grey20",
  fill = gp$fill %||% "grey80",
  angle = 30,
  density = 0.2,
  spacing = 0.05,
  xoffset = 0,
  yoffset = 0,
  units = "snpc",
  amplitude = 0.5 * spacing,
  frequency = 1/spacing,
  alpha = gp$alpha %||% NA_real_,
  linetype = gp$lty %||% 1,
  linewidth = size %||% gp$lwd %||% 1,
  size = NULL,
  grid = "square",
  type = "triangle",
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_wave_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_colour">colour</code></td>
<td>
<p>Stroke colour(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_fill">fill</code></td>
<td>
<p>Fill colour(s) or <code><a href="grid.html#topic+patterns">grid::pattern()</a></code> / gradient object(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_angle">angle</code></td>
<td>
<p>Rotation angle in degrees.</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_density">density</code></td>
<td>
<p>Approx. fraction of area the pattern fills.</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_spacing">spacing</code></td>
<td>
<p>Spacing between repetitions of pattern (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_xoffset">xoffset</code></td>
<td>
<p>Shift pattern along x axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_yoffset">yoffset</code></td>
<td>
<p>Shift pattern along y axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_units">units</code></td>
<td>
<p><code><a href="grid.html#topic+unit">grid::unit()</a></code> units for <code>amplitude</code>, <code>frequency</code>, <code>spacing</code>, <code>xoffset</code>, and <code>yoffset</code> parameters.</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_amplitude">amplitude</code></td>
<td>
<p>Wave amplitude (in <code>units</code> units)</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_frequency">frequency</code></td>
<td>
<p>Linear frequency (in inverse <code>units</code> units)</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (between 0 and 1) or <code>NA</code> (default, preserves colors' alpha value).</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_linetype">linetype</code></td>
<td>
<p>Stroke linetype.</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_linewidth">linewidth</code></td>
<td>
<p>Stroke linewidth.</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_size">size</code></td>
<td>
<p>For backwards compatibility can be used to set <code>linewidth</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_grid">grid</code></td>
<td>
<p>Adjusts placement and density of certain graphical elements.
<code>"square"</code> (default) is a square grid.
<code>"hex"</code> is a hexagonal grid suitable for hexagonal and triangular tiling.
<code>"hex_circle"</code> is a hexagonal grid suitable for circle packing.
<code>"elongated_triangle"</code> is a grid used for the &quot;elongated triangle&quot; tiling.</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_type">type</code></td>
<td>
<p>Either &ldquo;sine&rdquo; or &ldquo;triangle&rdquo; (default).</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_wave_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>See Also</h3>

<p>Use <code><a href="#topic+grid.pattern_stripe">grid.pattern_stripe()</a></code> for straight lines instead of waves.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
grid::grid.newpage()
grid.pattern_wave(x_hex, y_hex, colour = "black", type = "sine",
                  fill = c("red", "blue"), density = 0.4,
                  spacing = 0.15, angle = 0,
                  amplitude = 0.05, frequency = 1 / 0.20)

# zig-zag pattern is a wave of `type` "triangle"
grid::grid.newpage()
grid.pattern_wave(x_hex, y_hex, colour = "black", type = "triangle",
                    fill = c("red", "blue"), density = 0.4,
                    spacing = 0.15, angle = 0, amplitude = 0.075)
</code></pre>

<hr>
<h2 id='grid.pattern_weave'>Weave patterned grobs</h2><span id='topic+grid.pattern_weave'></span>

<h3>Description</h3>

<p><code>grid.pattern_weave()</code> draws a weave pattern onto the graphic device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid.pattern_weave(
  x = c(0, 0, 1, 1),
  y = c(1, 0, 0, 1),
  id = 1L,
  ...,
  colour = gp$col %||% "grey20",
  fill = gp$fill %||% "grey80",
  fill2 = fill,
  angle = 30,
  density = 0.2,
  spacing = 0.05,
  xoffset = 0,
  yoffset = 0,
  units = "snpc",
  alpha = gp$alpha %||% NA_real_,
  linetype = gp$lty %||% 1,
  linewidth = size %||% gp$lwd %||% 1,
  size = NULL,
  grid = "square",
  type = "plain",
  subtype = NA,
  default.units = "npc",
  name = NULL,
  gp = gpar(),
  draw = TRUE,
  vp = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid.pattern_weave_+3A_x">x</code></td>
<td>
<p>A numeric vector or unit object specifying x-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_y">y</code></td>
<td>
<p>A numeric vector or unit object specifying y-locations of the pattern boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_id">id</code></td>
<td>
<p>A numeric vector used to separate locations in x, y into multiple boundaries.
All locations within the same <code>id</code> belong to the same boundary.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_...">...</code></td>
<td>
<p>Currently ignored.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_colour">colour</code></td>
<td>
<p>Stroke colour(s).</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_fill">fill</code></td>
<td>
<p>The fill colour for the horizontal &quot;weft&quot; lines.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_fill2">fill2</code></td>
<td>
<p>The fill colour for the vertical &quot;warp&quot; lines.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_angle">angle</code></td>
<td>
<p>Rotation angle in degrees.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_density">density</code></td>
<td>
<p>Approx. fraction of area the pattern fills.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_spacing">spacing</code></td>
<td>
<p>Spacing between repetitions of pattern (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_xoffset">xoffset</code></td>
<td>
<p>Shift pattern along x axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_yoffset">yoffset</code></td>
<td>
<p>Shift pattern along y axis (in <code>units</code> units).</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_units">units</code></td>
<td>
<p><code><a href="grid.html#topic+unit">grid::unit()</a></code> units for <code>spacing</code>, <code>xoffset</code>, and <code>yoffset</code> parameters.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_alpha">alpha</code></td>
<td>
<p>Alpha (between 0 and 1) or <code>NA</code> (default, preserves colors' alpha value).</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_linetype">linetype</code></td>
<td>
<p>Stroke linetype.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_linewidth">linewidth</code></td>
<td>
<p>Stroke linewidth.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_size">size</code></td>
<td>
<p>For backwards compatibility can be used to set <code>linewidth</code>.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_grid">grid</code></td>
<td>
<p>Adjusts placement and density of certain graphical elements.
<code>"square"</code> (default) is a square grid.
<code>"hex"</code> is a hexagonal grid suitable for hexagonal and triangular tiling.
<code>"hex_circle"</code> is a hexagonal grid suitable for circle packing.
<code>"elongated_triangle"</code> is a grid used for the &quot;elongated triangle&quot; tiling.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_type">type</code></td>
<td>
<p>The weave type.  See <code><a href="#topic+pattern_weave">pattern_weave()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_subtype">subtype</code></td>
<td>
<p>The weave subtype.  See <code><a href="#topic+pattern_weave">pattern_weave()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_default.units">default.units</code></td>
<td>
<p>A string indicating the default units to use if <code>x</code> or <code>y</code>
are only given as numeric vectors.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_name">name</code></td>
<td>
<p> A character identifier. </p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_gp">gp</code></td>
<td>
<p>An object of class <code>"gpar"</code>, typically the output
from a call to the function <code><a href="grid.html#topic+gpar">gpar</a></code>.  This is basically
a list of graphical parameter settings.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_draw">draw</code></td>
<td>
<p>A logical value indicating whether graphics output
should be produced.</p>
</td></tr>
<tr><td><code id="grid.pattern_weave_+3A_vp">vp</code></td>
<td>
<p>A Grid viewport object (or NULL).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A grid grob object invisibly.  If <code>draw</code> is <code>TRUE</code> then also draws to the graphic device as a side effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pattern_weave">pattern_weave()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x_hex &lt;- 0.5 + 0.5 * cos(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
y_hex &lt;- 0.5 + 0.5 * sin(seq(2 * pi / 4, by = 2 * pi / 6, length.out = 6))
gp &lt;- grid::gpar(colour = "black", fill = "lightblue", lwd=0.5)

# Plain weave (default weave)
grid.pattern_weave(x_hex, y_hex, fill2 = "yellow",
                   gp = gp, spacing = 0.1, density = 0.3)

# Irregular matt weave
grid::grid.newpage()
grid.pattern_weave(x_hex, y_hex,  type = "matt_irregular",
                   fill2 = "yellow", gp = gp, spacing = 0.1, density = 0.3)

# Twill weave
grid::grid.newpage()
grid.pattern_weave(x_hex, y_hex, type = "twill",
                   fill2 = "yellow", gp = gp, spacing = 0.1, density = 0.3)

# Zig-zag twill
grid::grid.newpage()
grid.pattern_weave(x_hex, y_hex, type = "twill_zigzag",
                   fill2 = "yellow", gp = gp, spacing = 0.05, density = 0.7)

# Herringbone twill with density 1
grid::grid.newpage()
gp$col &lt;- NA
grid.pattern_weave(x_hex, y_hex, type = "twill_herringbone",
                   fill2 = "yellow", gp = gp, spacing = 0.05, density = 1.0)
</code></pre>

<hr>
<h2 id='guess_has_R4.1_features'>Guess whether &quot;active&quot; graphics device supports
the grid graphics features introduced in R v4.1.</h2><span id='topic+guess_has_R4.1_features'></span>

<h3>Description</h3>

<p><code>guess_has_R4.1_features()</code> guesses whether &quot;active&quot; graphics device supports
the grid graphics features introduced in R v4.1.  If it guesses it does
it returns <code>TRUE</code> else <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_has_R4.1_features(
  features = c("clippingPaths", "gradients", "masks", "patterns")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_has_R4.1_features_+3A_features">features</code></td>
<td>
<p>Character vector of features to guess support for.
Will return <code>TRUE</code> only if guesses support for all requested features.</p>

<dl>
<dt>&quot;clippingPaths&quot;</dt><dd><p>Supports clipping path feature</p>
</dd>
<dt>&quot;gradients&quot;</dt><dd><p>Supports (both linear and radial) gradient feature</p>
</dd>
<dt>&quot;masks&quot;</dt><dd><p>Supports (alpha) mask feature</p>
</dd>
<dt>&quot;patterns&quot;</dt><dd><p>Supports (tiling) pattern feature</p>
</dd>
</dl>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if we guess all <code>features</code> are supported else <code>FALSE</code>
</p>


<h3>Usage in other packages</h3>

<p>To avoid taking a dependency on <code>gridpattern</code> you may copy the source of <code>guess_has_R4.1_features()</code>
into your own package under the permissive MIT No Attribution (MIT-0) license.  Either use
<code>usethis::use_standalone("trevorld/gridpattern", "standalone-guess_has_R4.1_features.R")</code>
or copy the file <code>standalone-guess_has_R4.1_features.R</code> into your <code>R</code> directory and
add <code>grDevices</code> and <code>utils</code> to the <code>Imports</code> of your <code>DESCRIPTION</code> file.
</p>


<h3>See Also</h3>

<p><a href="https://www.stat.auckland.ac.nz/~paul/Reports/GraphicsEngine/definitions/definitions.html">https://www.stat.auckland.ac.nz/~paul/Reports/GraphicsEngine/definitions/definitions.html</a> for more info about the new grid graphics
features introduced in R v4.1.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # If R version (weakly) greater than 4.1 should be TRUE
  pdf(tempfile(fileext = ".pdf"))
  print(guess_has_R4.1_features())
  invisible(dev.off())

  # Should be FALSE
  postscript(tempfile(fileext = ".ps"))
  print(guess_has_R4.1_features())
  invisible(dev.off())

</code></pre>

<hr>
<h2 id='mean_col'>Compute average color</h2><span id='topic+mean_col'></span>

<h3>Description</h3>

<p><code>mean_col()</code> computes an average color.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_col(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_col_+3A_...">...</code></td>
<td>
<p>Colors to average</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We currently compute an average color
by using the quadratic mean of the colors' RGBA values.
</p>


<h3>Value</h3>

<p>A color string of 9 characters: <code>"#"</code> followed by the
red, blue, green, and alpha values in hexadecimal.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> mean_col("black", "white")
 mean_col(c("black", "white"))
 mean_col("red", "blue")
</code></pre>

<hr>
<h2 id='pattern_hex'>Hex pattern matrix</h2><span id='topic+pattern_hex'></span><span id='topic+names_hex'></span>

<h3>Description</h3>

<p><code>pattern_hex()</code> returns an integer matrix indicating where each
color (or other graphical element) should be drawn on a (horizontal) hex grid
for a specified hex pattern type and subtype.
<code>names_hex</code> lists the currently supported hex <code>type</code>s.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pattern_hex(type = "hex", subtype = NULL, nrow = 5L, ncol = 5L)

names_hex
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pattern_hex_+3A_type">type</code></td>
<td>
<p>Currently just supports &quot;hex&quot;.</p>
</td></tr>
<tr><td><code id="pattern_hex_+3A_subtype">subtype</code></td>
<td>
<p>An integer indicating number of colors (or other graphical elements).</p>
</td></tr>
<tr><td><code id="pattern_hex_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows (height).</p>
</td></tr>
<tr><td><code id="pattern_hex_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns (width).</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 5.
</p>


<h3>Details</h3>


<dl>
<dt>&quot;hex&quot;</dt><dd><p>Attempts to use a uniform coloring if it exists.
For subtype <code>1L</code>, <code>2L</code>, and <code>3L</code> we use the &quot;hex1&quot; pattern.
For subtype <code>4L</code> we use the &quot;hex2&quot; pattern.
For subtype <code>7L</code> we use the &quot;hex3&quot; pattern.
Else a uniform coloring does not exist and we use the &quot;hex_skew&quot; pattern.</p>
</dd>
<dt>&quot;hex1&quot;</dt><dd><p>Provides the 1-uniform colorings of a hexagonal tiling.  Only exists for <code>subtype</code> <code>1L</code>, <code>2L</code>, or <code>3L</code>.</p>
</dd>
<dt>&quot;hex2&quot;</dt><dd><p>Provides the 2-uniform colorings of a hexagonal tiling.  Only exists for <code>subtype</code> <code>2L</code> or <code>4L</code>.</p>
</dd>
<dt>&quot;hex3&quot;</dt><dd><p>Provides the 3-uniform colorings of a hexagonal tiling.  Only exists for <code>subtype</code> <code>2L</code> or <code>7L</code>.</p>
</dd>
<dt>&quot;hex_skew&quot;</dt><dd><p>For the &quot;hex_skew&quot; <code>type</code> we cycle through <code>subtype</code> elements on the horizontal line and &quot;main&quot; diagonal line.
For some <code>subtype</code> numbers this may lead to noticeable color repeats on the &quot;skew&quot; diagonal line.
If <code>subtype</code> is strictly greater than <code>2L</code> then a hexagon should never touch another hexagon of the same color.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A matrix of integer values indicating where the each color
or other graphical elements should be drawn on a horizontal hex grid
(i.e. hexagons are assumed to be pointy side up).
Indices <code style="white-space: pre;">&#8288;[1,1]&#8288;</code> of the matrix corresponds to the bottom-left of the grid
while indices <code style="white-space: pre;">&#8288;[1,ncol]&#8288;</code> corresponds to the bottom-right of the grid.
The even rows are assumed to be on the <strong>left</strong> of the ones on the odd rows
(for those in the same column in the matrix).
This matrix has a &quot;pattern_hex&quot; subclass which supports a special <code>print()</code> method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.pattern_regular_polygon">grid.pattern_regular_polygon()</a></code> for drawing to a graphics device
hexagons, triangles, circles, etc. in hexagon patterns.
The tiling vignette features several examples of regular polygon tiling using
this both the &quot;hex&quot; and &quot;hex_circle&quot; types <code>vignette("tiling", package = "gridpattern")</code>.
For more information on uniform colorings of a hexagonal tiling see
<a href="https://en.wikipedia.org/wiki/Hexagonal_tiling#Uniform_colorings">https://en.wikipedia.org/wiki/Hexagonal_tiling#Uniform_colorings</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # supported hex names
 print(names_hex)

 # 1-uniform 3-color
 hex_3color &lt;- pattern_hex("hex1", 3L, nrow = 7L, ncol = 9L)
 print(hex_3color)

 # 2-uniform 4-color
 hex_4color &lt;- pattern_hex("hex2", 4L, nrow = 7L, ncol = 9L)
 print(hex_4color)

</code></pre>

<hr>
<h2 id='pattern_square'>Square pattern matrix</h2><span id='topic+pattern_square'></span><span id='topic+names_square'></span>

<h3>Description</h3>

<p><code>pattern_square()</code> returns an integer matrix indicating where each
color (or other graphical element) should be drawn on a rectangular grid
for a specified square pattern type and subtype.
<code>names_square</code> lists the currently supported square <code>type</code>s (excluding those in <code>names_weave</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pattern_square(type = "diagonal", subtype = NULL, nrow = 5L, ncol = 5L)

names_square
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pattern_square_+3A_type">type</code></td>
<td>
<p>Either &quot;diagonal&quot; (default), &quot;diagonal_skew&quot;, &quot;horizontal&quot;, &quot;vertical&quot;,
or any <code>type</code> in <code>names_weave</code>.  See Details.</p>
</td></tr>
<tr><td><code id="pattern_square_+3A_subtype">subtype</code></td>
<td>
<p>See Details.  For &quot;diagonal&quot;, &quot;diagonal_skew&quot;, &quot;horizontal&quot;, or &quot;vertical&quot;
an integer of the desired number of colors (or other graphical elements).</p>
</td></tr>
<tr><td><code id="pattern_square_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows (height).</p>
</td></tr>
<tr><td><code id="pattern_square_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns (width).</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 6.
</p>


<h3>Details</h3>


<dl>
<dt>&quot;horizontal&quot;, &quot;vertical&quot;</dt><dd><p>&quot;horizontal&quot; and &quot;vertical&quot; simply cycle through the colors
either horizontally or vertically.
Use <code>subtype</code> to indicate the (integer) number of colors (or other graphical elements).
&quot;horizontal&quot; will produce horizontal stripes of color whereas &quot;vertical&quot; will produce vertical stripes.</p>
</dd>
<dt>&quot;diagonal&quot;, &quot;diagonal_skew&quot;</dt><dd><p>&quot;diagonal&quot; and &quot;diagonal_skew&quot; simply cycle through the colors
both horizontally and vertically.
Use <code>subtype</code> to indicate the (integer) number of colors (or other graphical elements).
If two colors are requested this provides the standard two-color checkerboard pattern.
If there are more than three colors than &quot;diagonal&quot; will have colored diagonals
going from top left to bottom right while &quot;diagonal_skew&quot; will have them
going form bottom left to top right.</p>
</dd>
<dt>&quot;square&quot;</dt><dd><p>&quot;square&quot; attempts a uniform coloring using &quot;square_tiling&quot; before falling
falling back on &quot;diagonal&quot;.  If <code>subtype</code> is <code>1L</code>, <code>2L</code>, <code>3L</code>, or <code>4L</code> uses &quot;square_tiling&quot;
else uses &quot;diagonal&quot;.</p>
</dd>
<dt>&quot;square_tiling&quot;</dt><dd><p>&quot;square_tiling&quot; supports
uniform coloring for (non-staggered) square tilings.
Use <code>subtype</code> to either indicate the (integer) number of colors
or a string with four integers such as <code>"1231"</code>
(will fill in a 2x2 matrix by row which will then be tiled).
Supports up to a max of four colors.</p>
</dd>
<dt>any pattern from <code>names_weave</code></dt><dd>
<p>We simply convert the logical matrix returned by <code><a href="#topic+pattern_weave">pattern_weave()</a></code> into an
integer matrix by having any <code>TRUE</code> set to <code>1L</code> and <code>FALSE</code> set to <code>2L</code>.
Hence the various weave patterns only support (up to) two-color patterns.
See <code><a href="#topic+pattern_weave">pattern_weave()</a></code> for more details about supported <code>type</code> and <code>subtype</code>.</p>
</dd>
</dl>



<h3>Value</h3>

<p>A matrix of integer values indicating where the each color
(or other graphical element) should be drawn on a rectangular grid.
Indices <code style="white-space: pre;">&#8288;[1,1]&#8288;</code> of the matrix corresponds to the bottom-left of the grid
while indices <code style="white-space: pre;">&#8288;[1,ncol]&#8288;</code> corresponds to the bottom-right of the grid.
This matrix has a &quot;pattern_square&quot; subclass which supports a special <code>print()</code> method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.pattern_regular_polygon">grid.pattern_regular_polygon()</a></code> for drawing to a graphics device
polygons in multiple color/size/shape patterns.
<code><a href="#topic+pattern_weave">pattern_weave()</a></code> for more information on &quot;weave&quot; patterns.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # supported square names
 print(names_square)

 # (main) diagonal has colors going from top left to bottom right
 diagonal &lt;- pattern_square("diagonal", 4L, nrow = 7L, ncol = 9L)
 print(diagonal)

 # skew diagonal has colors going from bottom left to top right
 skew &lt;- pattern_square("diagonal_skew", 4L, nrow = 7L, ncol = 9L)
 print(skew)

 horizontal &lt;- pattern_square("horizontal", 4L, nrow = 8L, ncol = 8L)
 print(horizontal)

 vertical &lt;- pattern_square("vertical", 4L, nrow = 8L, ncol = 8L)
 print(vertical)

 # uniform coloring using 4 colors
 color4 &lt;- pattern_square("square_tiling", 4L, nrow = 7L, ncol = 9L)
 print(color4)

 # uniform coloring using 3 colors
 color3 &lt;- pattern_square("square_tiling", 3L, nrow = 7L, ncol = 9L)
 print(color3)

 # also supports the various 'weave' patterns
 zigzag &lt;- pattern_square("twill_zigzag", nrow = 15L, ncol = 9L)
 print(zigzag)

</code></pre>

<hr>
<h2 id='pattern_weave'>Weave pattern matrix</h2><span id='topic+pattern_weave'></span><span id='topic+names_weave'></span>

<h3>Description</h3>

<p><code>pattern_weave()</code> returns a logical matrix indicating where the warp lines should
be &quot;up&quot; for a specified weave pattern type and subtype.
<code>names_weave</code> is a character vector listing supported weave pattern types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pattern_weave(type = "plain", subtype = NULL, nrow = 5L, ncol = 5L)

names_weave
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pattern_weave_+3A_type">type</code></td>
<td>
<p>Type of weave.  See Details.</p>
</td></tr>
<tr><td><code id="pattern_weave_+3A_subtype">subtype</code></td>
<td>
<p>Subtype of weave.  See Details.</p>
</td></tr>
<tr><td><code id="pattern_weave_+3A_nrow">nrow</code></td>
<td>
<p>Number of rows (length of warp).</p>
</td></tr>
<tr><td><code id="pattern_weave_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns (length of weft).</p>
</td></tr>
</table>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 10.
</p>


<h3>Details</h3>

<p>Here is a list of the various weave <code>type</code>s supported:
</p>

<dl>
<dt>basket</dt><dd><p>A simple criss-cross pattern using two threads at a time.
Same as the &quot;matt_irregular&quot; weave but with a default <code>subtype</code> of <code>2L</code>.</p>
</dd>
<dt>matt</dt><dd><p>A simple criss-cross pattern using 3 (or more) threads at a time.
Same as the &quot;matt_irregular&quot; weave but with a default <code>subtype</code> of <code>3L</code>.</p>
</dd>
<dt>matt_irregular</dt><dd><p>A generalization of the &quot;plain&quot; weave.
A character <code>subtype</code> <code>"U/D(L+R)"</code> is a standard matt weave specification:
<code>U</code> indicates number warp up, <code>D</code> indicates number warp down,
<code>L</code> indicates number of warp up in repeat, and
<code>R</code> indicates number of warp down in repeat.
An integer <code>subtype</code> <code>N</code> will be interpreted as a <code>"N/N(N+N)"</code> irregular matt weave.
A character <code>subtype</code> <code>"U/D"</code> will be interpreted as a <code>"U/D(U+D)"</code> irregular matt weave.
Has a default <code>subtype</code> of <code>"3/2(4+2)"</code>.</p>
</dd>
<dt>plain</dt><dd><p>A simple criss-cross pattern.
Same as the &quot;matt_irregular&quot; weave but with a default <code>subtype</code> of <code>1L</code>.</p>
</dd>
<dt>rib_warp</dt><dd><p>A plain weave variation that emphasizes vertical lines.
An integer <code>subtype</code> <code>N</code> will be interpreted as a &quot;matt_irregular&quot; <code>"N/N(1+1)"</code> weave.
A character <code>subtype</code> <code>"U/D"</code> will be interpreted as a &quot;matt_irregular&quot; <code>"U/D(1+1)"</code> weave.
Default <code>subtype</code> of <code>2L</code>.</p>
</dd>
<dt>satin</dt><dd><p>A &quot;regular&quot; satin weave is a special type of the elongated twill weave
with a move number carefully chosen so no twill line is distinguishable.
Same as the &quot;twill_elongated&quot; weave but with a default <code>subtype</code> of <code>5L</code>.</p>
</dd>
<dt>twill</dt><dd><p>A simple diagonal pattern.
Same as the &quot;twill_elongated&quot; weave but with a default <code>subtype</code> of <code>"2/1"</code>.</p>
</dd>
<dt>twill_elongated</dt><dd><p>A generalization of the &quot;twill&quot; weave.
A character <code>subtype</code> <code>"U/D(M)"</code> is a standard twill weave specification:
<code>U</code> indicates number warp up, <code>D</code> indicates number warp down,
and <code>M</code> indicates the &quot;move&quot; number.
A character <code>subtype</code> <code>"U/D"</code> will be interpreted as a <code>"U/D(1)"</code> elongated twill weave.
An integer <code>subtype</code> <code>N</code> will provide a <code>"{N-1}/1(1)"</code> elongated twill weave
if <code>N</code> is less than 5, 6, or greater than 14 otherwise it will
provide a <code>"{N-1}/1(M)"</code> weave where <code>M</code> is the largest
possible regular &quot;satin&quot; move number.
Default <code>subtype</code> of <code>"4/3(2)"</code>.</p>
</dd>
<dt>twill_herringbone</dt><dd><p>Adds a (vertical) &quot;herringbone&quot; effect to
the specified &quot;twill_elongated&quot; weave.
Default <code>subtype</code> of <code>"4/3(2)"</code>.</p>
</dd>
<dt>twill_zigzag</dt><dd><p>Adds a (vertical) &quot;zig-zag&quot; effect to the specified &quot;twill_elongated&quot; weave.
Default <code>subtype</code> of <code>"4/3(2)"</code>.</p>
</dd>
</dl>

<p>For both &quot;matt&quot; and &quot;twill&quot; weaves the <code>U/D</code> part of the subtype can be further extended
to <code>U1/D1*U2/D2</code>, <code>U1/D1*U2/D2*U3/D3</code>, etc.
For the &quot;matt&quot; weave the &quot;(L+R)&quot; part of the subtype can be further extended
to <code>(L1+R1+L2+R2)</code>, <code>(L1+R1+L2+R2+L3+R3)</code>, etc.
</p>


<h3>Value</h3>

<p>A matrix of logical values indicating where the &quot;warp&quot;
is &quot;up&quot; (if <code>TRUE</code>) or &quot;down&quot; (if <code>FALSE</code>).
Indices <code style="white-space: pre;">&#8288;[1,1]&#8288;</code> of the matrix corresponds to the bottom-left of the weave
while indices <code style="white-space: pre;">&#8288;[1,ncol]&#8288;</code> corresponds to the bottom-right of the weave.
This matrix has a &quot;pattern_weave&quot; subclass which supports a special <code>print()</code> method.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+grid.pattern_weave">grid.pattern_weave()</a></code> for drawing weaves onto a graphics device.
See <a href="https://textilestudycenter.com/derivatives-of-plain-weave/">https://textilestudycenter.com/derivatives-of-plain-weave/</a>
for further information on the &quot;matt&quot; family of weaves,
<a href="https://textilelearner.net/twill-weave-features-classification-derivatives-and-uses/">https://textilelearner.net/twill-weave-features-classification-derivatives-and-uses/</a>
for further information on the &quot;twill&quot; family of weaves, and
<a href="https://texwiz101.blogspot.com/2012/03/features-and-classification-of-satin.html">https://texwiz101.blogspot.com/2012/03/features-and-classification-of-satin.html</a>
for further information on &quot;satin&quot; weaves.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # supported weave names
 print(names_weave)

 plain &lt;- pattern_weave("plain", nrow = 7, ncol = 9)
 print(plain)

 matt_irregular &lt;- pattern_weave("matt_irregular", nrow = 9, ncol = 11)
 print(matt_irregular)

 satin &lt;- pattern_weave("satin", nrow = 9, ncol = 11)
 print(satin)

 twill &lt;- pattern_weave("twill", nrow = 9, ncol = 11)
 print(twill)

 twill_zigzag &lt;- pattern_weave("twill_zigzag", nrow = 18, ncol = 11)
 print(twill_zigzag)

</code></pre>

<hr>
<h2 id='patternFill'>Create patterned fills by pattern name</h2><span id='topic+patternFill'></span>

<h3>Description</h3>

<p><code>patternFill()</code> returns <code><a href="grid.html#topic+patterns">grid::pattern()</a></code> fill objects.
It is a wrapper around <code><a href="#topic+patternGrob">patternGrob()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>patternFill(
  ...,
  x = 0.5,
  y = 0.5,
  width = 1,
  height = 1,
  default.units = "npc",
  just = "centre",
  hjust = NULL,
  vjust = NULL,
  group = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="patternFill_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="#topic+patternGrob">patternGrob()</a></code>.</p>
</td></tr>
<tr><td><code id="patternFill_+3A_x">x</code>, <code id="patternFill_+3A_y">y</code>, <code id="patternFill_+3A_width">width</code>, <code id="patternFill_+3A_height">height</code></td>
<td>
<p>The size of the <code><a href="grid.html#topic+patterns">grid::pattern()</a></code> tile.</p>
</td></tr>
<tr><td><code id="patternFill_+3A_default.units">default.units</code></td>
<td>
<p>The default <code><a href="grid.html#topic+unit">grid::unit()</a></code> unit to use for <code>x</code>, <code>y</code>, <code>width</code>, and <code>height</code>.</p>
</td></tr>
<tr><td><code id="patternFill_+3A_just">just</code>, <code id="patternFill_+3A_hjust">hjust</code>, <code id="patternFill_+3A_vjust">vjust</code></td>
<td>
<p>The justification of the tile relative to its location.</p>
</td></tr>
<tr><td><code id="patternFill_+3A_group">group</code></td>
<td>
<p>A logical indicating whether the pattern is relative to the bounding box of the grob or whether it is relative to individual shapes within the grob.  Ignored if R is less than version 4.2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="grid.html#topic+patterns">grid::pattern()</a></code> fill object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (guess_has_R4.1_features("patterns") &amp;&amp;
    require("grid", quietly = TRUE)) {
  grid.newpage()
  stripe_fill &lt;- patternFill("stripe", fill = c("red", "blue"))
  grid.circle(gp = gpar(fill = stripe_fill))
}
 
if (guess_has_R4.1_features("patterns") &amp;&amp; 
    require("ggplot2", quietly = TRUE) &amp;&amp;
    (getRversion() &gt;= "4.2")) {
  grid.newpage()
  weave_fill &lt;- patternFill("weave", fill = "red", fill2 = "blue", 
                            colour = "transparent")
  hex_fill &lt;- patternFill("polygon_tiling", type = "hexagonal", 
                          fill = c("black", "white", "grey"),
                          colour = "transparent")
  df &lt;- data.frame(trt = c("a", "b"), outcome = c(1.9, 3.2))
  gg &lt;- ggplot(df, aes(trt, outcome)) +
    geom_col(fill = list(weave_fill, hex_fill))
  plot(gg)
}
</code></pre>

<hr>
<h2 id='reset_image_cache'>Reset 'gridpattern' image cache</h2><span id='topic+reset_image_cache'></span>

<h3>Description</h3>

<p><code><a href="#topic+grid.pattern_image">grid.pattern_image()</a></code> and <code><a href="#topic+grid.pattern_placeholder">grid.pattern_placeholder()</a></code> store images in a cache
(so we won't download image URLs over and over).
<code>reset_image_cache()</code> resets this cache.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reset_image_cache()
</code></pre>

<hr>
<h2 id='star_scale'>Compute regular star polygon scale or angles</h2><span id='topic+star_scale'></span><span id='topic+star_angle'></span>

<h3>Description</h3>

<p><code>star_scale()</code> computes star <code>scale</code> value given
an internal or external angle.  <code>star_angle()</code> computes
star angle (internal or external) given a <code>scale</code> value.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>star_scale(n_vertices, angle, external = FALSE)

star_angle(n_vertices, scale, external = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="star_scale_+3A_n_vertices">n_vertices</code></td>
<td>
<p>Number of exterior vertices.</p>
</td></tr>
<tr><td><code id="star_scale_+3A_angle">angle</code></td>
<td>
<p>Angle in degrees.</p>
</td></tr>
<tr><td><code id="star_scale_+3A_external">external</code></td>
<td>
<p>If <code>TRUE</code> angle should be considered an external angle.</p>
</td></tr>
<tr><td><code id="star_scale_+3A_scale">scale</code></td>
<td>
<p>Scale from 0 to 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+grid.pattern_regular_polygon">grid.pattern_regular_polygon()</a></code> parameterizes regular star polygons
with the number of its external vertices and a <code>scale</code> that equals the
fraction of the radius of the circle that circumscribes the interior vertices
divided by the radius of the circle that circumscribes the exterior vertices.
These helper functions help convert between that parameterization
and either the internal or external angle of the regular star polygon.
</p>


<h3>Value</h3>

<p><code>star_scale()</code> returns a numeric value between 0 and 1 intended
for use as the <code>scale</code> argument in <code><a href="#topic+grid.pattern_regular_polygon">grid.pattern_regular_polygon()</a></code>.
<code>star_angle()</code> returns a numeric value between 0 and 360 (degrees).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # |8/3| star has internal angle 45 degrees and external angle 90 degrees
  scale &lt;- star_scale(8, 45)
  scale2 &lt;- star_scale(8, 90, external = TRUE)
  all.equal(scale, scale2)
  star_angle(8, scale)
  star_angle(8, scale, external = TRUE)

  grid.pattern_regular_polygon(shape = "star8", scale = scale, angle = 0,
                               spacing = 0.2, density = 0.8)
</code></pre>

<hr>
<h2 id='update_alpha'>Update colour and/or pattern transparency</h2><span id='topic+update_alpha'></span>

<h3>Description</h3>

<p><code>update_alpha()</code> modifies the transparency of colours and/or patterns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_alpha(fill, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_alpha_+3A_fill">fill</code></td>
<td>
<p>A fill colour given as a <code>character</code> or <code>integer</code> vector, or as a
(list of) <code style="white-space: pre;">&#8288;&lt;GridPattern&gt;&#8288;</code> object(s) and/or colour(s).</p>
</td></tr>
<tr><td><code id="update_alpha_+3A_alpha">alpha</code></td>
<td>
<p>A transparency value between 0 (transparent) and 1 (opaque),
parallel to <code>fill</code>.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> This is a fork of pattern utilities mainly added to <code>{ggplot2}</code> by Teun van den Brand.
</p>
</li>
<li> <p><code>update_alpha()</code> does not depend on <code>{ggplot2}</code> or <code>{scales}</code>.
</p>
</li>
<li><p> Like <code><a href="ggplot2.html#topic+fill_alpha">ggplot2::fill_alpha()</a></code> but unlike <code><a href="scales.html#topic+alpha">scales::alpha()</a></code> it also attempts
to set the transparency of <code style="white-space: pre;">&#8288;&lt;GridPattern&gt;&#8288;</code> objects.
</p>
</li>
<li><p> Unlike <code><a href="ggplot2.html#topic+fill_alpha">ggplot2::fill_alpha()</a></code> it will work on a list of length one
containing a vector of color strings.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>character</code> vector of colours or list of <code style="white-space: pre;">&#8288;&lt;GridPattern&gt;&#8288;</code> objects.
</p>


<h3>Usage in other packages</h3>

<p>To avoid taking a dependency on <code>gridpattern</code> you may copy the source of <code>update_alpha()</code>
into your own package under the permissive MIT license.  Either use
<code>usethis::use_standalone("trevorld/gridpattern", "standalone-update_alpha.R")</code>
or copy the file <code>update_alpha.R</code> into your <code>R</code> directory and
add <code>grDevices</code>, <code>grid</code>, and <code>rlang</code> to the <code>Imports</code> of your <code>DESCRIPTION</code> file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Typical color input
update_alpha("red", 0.5)

# Pattern input
if (getRversion() &gt;= "4.2" &amp;&amp; requireNamespace("grid", quietly = TRUE)) {
  update_alpha(list(grid::linearGradient()), 0.5)
}
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
