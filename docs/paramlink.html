<!DOCTYPE html><html><head><title>Help for package paramlink</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {paramlink}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#paramlink-package'><p>paramlink: Parametric Linkage and Other Pedigree Analysis in R</p></a></li>
<li><a href='#allGenotypes'><p>Genotype combinations</p></a></li>
<li><a href='#as.data.frame.linkdat'><p>linkdat to data.frame conversion</p></a></li>
<li><a href='#as.matrix.linkdat'><p>linkdat to matrix conversion</p></a></li>
<li><a href='#dominant'><p>Example pedigree for linkage analysis</p></a></li>
<li><a href='#examineKinships'><p>Check pedigree for relationship errors</p></a></li>
<li><a href='#exclusionPower'><p>Power of exclusion</p></a></li>
<li><a href='#Familias2linkdat'><p>Convert 'Familias' output to linkdat objects</p></a></li>
<li><a href='#hasCA'><p>Pairwise common ancestors</p></a></li>
<li><a href='#IBDestimate'><p>Relatedness estimation</p></a></li>
<li><a href='#IBDtriangle'><p>IBD triangle plot</p></a></li>
<li><a href='#is.linkdat'><p>Is an object a linkdat object?</p></a></li>
<li><a href='#likelihood'><p>Pedigree likelihood</p></a></li>
<li><a href='#linkage.power'><p>Power of a linkage study</p></a></li>
<li><a href='#linkageSim'><p>Simulate markers linked to a disease locus.</p></a></li>
<li><a href='#linkdat'><p>Linkdat objects</p></a></li>
<li><a href='#linkres'><p>S3 methods for class 'linkres'.</p></a></li>
<li><a href='#lod'><p>Two-point LOD score</p></a></li>
<li><a href='#lod.peaks'><p>LOD score peaks</p></a></li>
<li><a href='#LR'><p>Likelihood ratios of pedigree hypotheses</p></a></li>
<li><a href='#markers'><p>Marker functions</p></a></li>
<li><a href='#markerSim'><p>Marker simulation</p></a></li>
<li><a href='#mendelianCheck'><p>Check for Mendelian errors</p></a></li>
<li><a href='#mergePed'><p>Merge two pedigrees</p></a></li>
<li><a href='#merlin'><p>MERLIN wrappers</p></a></li>
<li><a href='#oneMarkerDistribution'><p>Genotype probability distribution</p></a></li>
<li><a href='#pedCreate'><p>Create simple pedigrees</p></a></li>
<li><a href='#pedigreeLoops'><p>Pedigree loops</p></a></li>
<li><a href='#pedModify'><p>Modify the pedigree of 'linkdat' objects</p></a></li>
<li><a href='#pedParts'><p>Pedigree subsets</p></a></li>
<li><a href='#plot.linkdat'><p>Plot pedigrees with genotypes</p></a></li>
<li><a href='#plotPedList'><p>Plot a list of pedigrees.</p></a></li>
<li><a href='#randomPed'><p>Random pedigree</p></a></li>
<li><a href='#readDatfile'><p>Read dat file in LINKAGE format</p></a></li>
<li><a href='#relatednessCoeff'><p>Relatedness coefficients</p></a></li>
<li><a href='#relationLR'><p>Relationship Likelihood Ratio</p></a></li>
<li><a href='#setAvailable'><p>Functions for modifying availability vectors</p></a></li>
<li><a href='#setModel'><p>Set, change or display the model parameters for 'linkdat' objects</p></a></li>
<li><a href='#setPlotLabels'><p>Attach plot labels to a linkdat object</p></a></li>
<li><a href='#showInTriangle'><p>Add points to the IBD triangle</p></a></li>
<li><a href='#simpleSim'><p>Unconditional marker simulation</p></a></li>
<li><a href='#toyped'><p>Toy pedigree for linkage analysis</p></a></li>
<li><a href='#transferMarkerdata'><p>Transfer marker data</p></a></li>
<li><a href='#twoloops'><p>A consanguineous pedigree</p></a></li>
<li><a href='#twoMarkerDistribution'><p>Genotype probability distribution</p></a></li>
<li><a href='#Xped'><p>Example pedigree with X-linked disease pattern.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Parametric Linkage and Other Pedigree Analysis in R</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1-5</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Magnus Dehli Vigeland &lt;m.d.vigeland@medisin.uio.no&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>NOTE: 'PARAMLINK' HAS BEEN SUPERSEDED BY THE 'PED SUITE'
    PACKAGES (<a href="https://magnusdv.github.io/pedsuite/">https://magnusdv.github.io/pedsuite/</a>). 'PARAMLINK' IS
    MAINTAINED ONLY FOR LEGACY PURPOSES AND SHOULD NOT BE USED IN NEW
    PROJECTS. A suite of tools for analysing pedigrees with marker data,
    including parametric linkage analysis, forensic computations,
    relatedness analysis and marker simulations. The core of the package
    is an implementation of the Elston-Stewart algorithm for pedigree
    likelihoods, extended to allow mutations as well as complex
    inbreeding. Features for linkage analysis include singlepoint LOD
    scores, power analysis, and multipoint analysis (the latter through a
    wrapper to the 'MERLIN' software). Forensic applications include
    exclusion probabilities, genotype distributions and conditional
    simulations. Data from the 'Familias' software can be imported and
    analysed in 'paramlink'. Finally, 'paramlink' offers many utility
    functions for creating, manipulating and plotting pedigrees with or
    without marker data (the actual plotting is done by the 'kinship2'
    package).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/magnusdv/paramlink">https://github.com/magnusdv/paramlink</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/magnusdv/paramlink/issues">https://github.com/magnusdv/paramlink/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, graphics, kinship2, maxLik, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>igraph</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>LazyData:</td>
<td>Yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>For multipoint linkage analysis, 'MERLIN'
(http://csg.sph.umich.edu/abecasis/merlin/index.html).</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-04-15 07:41:31 UTC; magnusdv</td>
</tr>
<tr>
<td>Author:</td>
<td>Magnus Dehli Vigeland [aut, cre],
  Thore Egeland [ctb],
  Guro Doerum [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-04-15 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='paramlink-package'>paramlink: Parametric Linkage and Other Pedigree Analysis in R</h2><span id='topic+paramlink'></span><span id='topic+paramlink-package'></span>

<h3>Description</h3>

<p>NOTE: 'PARAMLINK' HAS BEEN SUPERSEDED BY THE 'PED SUITE' PACKAGES (&lt;https://magnusdv.github.io/pedsuite/&gt;). 'PARAMLINK' IS MAINTAINED ONLY FOR LEGACY PURPOSES AND SHOULD NOT BE USED IN NEW PROJECTS. A suite of tools for analysing pedigrees with marker data, including parametric linkage analysis, forensic computations, relatedness analysis and marker simulations. The core of the package is an implementation of the Elston-Stewart algorithm for pedigree likelihoods, extended to allow mutations as well as complex inbreeding. Features for linkage analysis include singlepoint LOD scores, power analysis, and multipoint analysis (the latter through a wrapper to the 'MERLIN' software). Forensic applications include exclusion probabilities, genotype distributions and conditional simulations. Data from the 'Familias' software can be imported and analysed in 'paramlink'. Finally, 'paramlink' offers many utility functions for creating, manipulating and plotting pedigrees with or without marker data (the actual plotting is done by the 'kinship2' package).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Magnus Dehli Vigeland <a href="mailto:m.d.vigeland@medisin.uio.no">m.d.vigeland@medisin.uio.no</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Thore Egeland [contributor]
</p>
</li>
<li><p> Guro Doerum [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/magnusdv/paramlink">https://github.com/magnusdv/paramlink</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/magnusdv/paramlink/issues">https://github.com/magnusdv/paramlink/issues</a>
</p>
</li></ul>


<hr>
<h2 id='allGenotypes'>Genotype combinations</h2><span id='topic+allGenotypes'></span><span id='topic+fast.grid'></span><span id='topic+geno.grid.subset'></span>

<h3>Description</h3>

<p>Auxiliary functions computing possible genotype combinations in a pedigree.
These are not normally intended for end users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allGenotypes(n)

fast.grid(argslist, as.list = FALSE)

geno.grid.subset(x, partialmarker, ids, chrom, make.grid = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="allGenotypes_+3A_n">n</code></td>
<td>
<p>a positive integer.</p>
</td></tr>
<tr><td><code id="allGenotypes_+3A_argslist">argslist</code></td>
<td>
<p>a list of vectors.</p>
</td></tr>
<tr><td><code id="allGenotypes_+3A_as.list">as.list</code></td>
<td>
<p>if TRUE, the output is a list, otherwise a matrix.</p>
</td></tr>
<tr><td><code id="allGenotypes_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object.</p>
</td></tr>
<tr><td><code id="allGenotypes_+3A_partialmarker">partialmarker</code></td>
<td>
<p>a <code><a href="#topic+marker">marker</a></code> object compatible with <code>x</code>.</p>
</td></tr>
<tr><td><code id="allGenotypes_+3A_ids">ids</code></td>
<td>
<p>a numeric with ID labels of one or more pedigree members.</p>
</td></tr>
<tr><td><code id="allGenotypes_+3A_chrom">chrom</code></td>
<td>
<p>a character, either 'X' or 'AUTOSOMAL'. If missing, the 'chrom'
attribute of <code>partialmarker</code> is used. If this is also missing, then
'AUTOSOMAL' is taken as the default value.</p>
</td></tr>
<tr><td><code id="allGenotypes_+3A_make.grid">make.grid</code></td>
<td>
<p>a logical. If FALSE, a list is returned, otherwise
<code>fast.grid</code> is applied to the list before returning it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>allGenotypes</code> returns a matrix with 2 columns and <code>n +
  n*n(n-1)/2</code> rows containing all possible (unordered) genotypes at a
biallelic locus with alleles <code>1,2,...{},n</code>. <code>fast.grid</code> is
basically a stripped down version of <code><a href="base.html#topic+expand.grid">expand.grid</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
m = allGenotypes(2)
stopifnot(m == rbind(c(1,1), c(2,2), 1:2))

</code></pre>

<hr>
<h2 id='as.data.frame.linkdat'>linkdat to data.frame conversion</h2><span id='topic+as.data.frame.linkdat'></span>

<h3>Description</h3>

<p>Convert a linkdat object to data.frame for pretty printing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linkdat'
as.data.frame(
  x,
  ...,
  famid = F,
  markers = seq_len(x$nMark),
  alleles = NULL,
  missing = NULL,
  singleCol = FALSE,
  sep = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.linkdat_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object.</p>
</td></tr>
<tr><td><code id="as.data.frame.linkdat_+3A_...">...</code></td>
<td>
<p>further arguments (not used).</p>
</td></tr>
<tr><td><code id="as.data.frame.linkdat_+3A_famid">famid</code></td>
<td>
<p>a logical indicating if the family identifier should be included
as the first column.</p>
</td></tr>
<tr><td><code id="as.data.frame.linkdat_+3A_markers">markers</code></td>
<td>
<p>a numeric indicating which markers should be included/printed.</p>
</td></tr>
<tr><td><code id="as.data.frame.linkdat_+3A_alleles">alleles</code></td>
<td>
<p>a character containing allele names, e.g.
<code>alleles=c('A','B')</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.linkdat_+3A_missing">missing</code></td>
<td>
<p>the character (of length 1) used for missing alleles. Defaults
to '0'.</p>
</td></tr>
<tr><td><code id="as.data.frame.linkdat_+3A_singlecol">singleCol</code></td>
<td>
<p>a logical: Should the two alleles for each marker be pasted
into one column or kept in separate columns?</p>
</td></tr>
<tr><td><code id="as.data.frame.linkdat_+3A_sep">sep</code></td>
<td>
<p>a single character to be used as allele separator if
<code>singleCol=TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is mainly intended for pretty-printing <code>linkdat</code> objects
(for instance it is called by <code>print.linkdat</code>). For direct manipulation
of the pedigree and/or marker matrices, it is better to use
<code><a href="#topic+as.matrix.linkdat">as.matrix.linkdat</a></code>.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+as.matrix.linkdat">as.matrix.linkdat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = linkdat(toyped)
x

# Printing x as above is equivalent to:
as.data.frame(x, sep = '/', missing = '-', singleCol = TRUE)

</code></pre>

<hr>
<h2 id='as.matrix.linkdat'>linkdat to matrix conversion</h2><span id='topic+as.matrix.linkdat'></span><span id='topic+restore_linkdat'></span>

<h3>Description</h3>

<p>Converts a <code>linkdat</code> object to a matrix (basically following a
pre-makeped LINKAGE format), with marker annotations and other info attached
as attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linkdat'
as.matrix(x, include.attrs = TRUE, ...)

restore_linkdat(x, attrs = NULL, checkped = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.linkdat_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object. In <code>restore_linkdat</code>: A
numerical matrix in LINKAGE format.</p>
</td></tr>
<tr><td><code id="as.matrix.linkdat_+3A_include.attrs">include.attrs</code></td>
<td>
<p>a logical indicating if marker annotations and other
info should be attached as attributes. See value.</p>
</td></tr>
<tr><td><code id="as.matrix.linkdat_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
<tr><td><code id="as.matrix.linkdat_+3A_attrs">attrs</code></td>
<td>
<p>a list containing marker annotations and other <code>linkdat</code>
info compatible with <code>x</code>, in the format produced by <code>as.matrix</code>.
If NULL, the attributes of <code>x</code> itself are used.</p>
</td></tr>
<tr><td><code id="as.matrix.linkdat_+3A_checkped">checkped</code></td>
<td>
<p>a logical, forwarded to <code><a href="#topic+linkdat">linkdat</a></code>. If FALSE, no
checks for pedigree errors are performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>restore_linkdat</code> is the reverse of <code>as.matrix</code>.
</p>
<p>The way <code><a href="#topic+linkdat">linkdat</a></code> objects are created in paramlink, marker data
are stored as a list of <code>marker</code> objects. Each of these is essentially a
matrix with various attributes like allele frequencies, map info a.s.o.. This
format works well for marker-by-marker operations (e.g. likelihoods and LOD
scores), but makes it somewhat awkward to operate 'horizontally', i.e.
individual-by-individual, for instance if one wants to delete all genotypes
of a certain individual, or rearrange the pedigree in some way.
</p>
<p>It is therefore recommended to convert the <code>linkdat</code> object to a matrix
first, do the necessary manipulations on the matrix, and finally use
<code>restore_linkdat</code>. Attributes are often deleted during matrix
manipulation, so it may be necessary to store them in a variable and feed
them manually to <code>restore_linkdat</code> using the <code>attrs</code> argument.
</p>
<p>With default parameters, <code>restore_linkdat(as.matrix(x))</code> should
reproduce <code>x</code> exactly.
</p>


<h3>Value</h3>

<p>For <code>as.matrix</code>: A matrix with <code>x$nInd</code> rows and <code>6 +
  2*x$nMark</code> columns.  The 6 first columns describe the pedigree in LINKAGE
format, and the remaining columns contain marker alleles, using the
internal (numerical) allele coding and 0 for missing alleles. If
<code>include.attrs = TRUE</code> the matrix has the following attributes:
</p>
 <ul>
<li> <p><code>markerattr</code> (a list of marker annotations) </p>
</li>
<li>
<p><code>available</code> (the availability vector) </p>
</li>
<li> <p><code>model</code> (the disease
model, if present) </p>
</li>
<li> <p><code>plot.labels</code> (plot labels, if present) </p>
</li>
<li>
<p><code>orig.ids</code> (original individual IDs) </p>
</li></ul>

<p>For <code>restore_linkdat</code>: A <code>linkdat</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linkdat">linkdat</a></code>, <code><a href="#topic+as.data.frame.linkdat">as.data.frame.linkdat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = linkdat(toyped, model=1)
y = restore_linkdat(as.matrix(x))
stopifnot(all.equal(x,y))

# If attributes are lost during matrix manipulation: Use the 'attrs' argument.
xmatr = as.matrix(x)
newmatr = xmatr[-4, ] # NB: attributes are lost here
z = restore_linkdat(newmatr, attrs = attributes(xmatr))

# Should be the same as:
z2 = removeIndividuals(x, 4)
stopifnot(all.equal(z, z2))

</code></pre>

<hr>
<h2 id='dominant'>Example pedigree for linkage analysis</h2><span id='topic+dominant'></span>

<h3>Description</h3>

<p>Medical pedigree with 23 individuals of which 15 are genotyped with 650 SNP
markers. Eleven family members are affected by a disease, showing an
autosomal dominant inheritance pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dominant
</code></pre>


<h3>Format</h3>

<p>A data frame with 23 rows and 1306 columns, describing the pedigree and
marker data in pre-makeped format. The first 6 columns contain the pedigree
structure and affection status, while the final 1300 columns hold the marker alleles.
</p>

<ul>
<li><p> FAMID. Family ID
</p>
</li>
<li><p> ID. Individual ID
</p>
</li>
<li><p> FID. Father ID
</p>
</li>
<li><p> MID. Mother ID
</p>
</li>
<li><p> SEX. Gender (male=1, female=2)
</p>
</li>
<li><p> AFF. Affection status (unaffected=1, affected=2, unknown=0)
</p>
</li>
<li><p> M1_1. First allele of marker 1
</p>
</li>
<li><p> M1_2. Second allele of marker 1
</p>
</li>
<li><p> ...
</p>
</li>
<li><p> M650_1. First allele of marker 650
</p>
</li>
<li><p> M650_2. Second allele of marker 650
</p>
</li></ul>

<p>All markers are SNPs, whose alleles are written as 1 and 2.
Missing alleles are denoted by 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = linkdat(dominant)
summary(x)

</code></pre>

<hr>
<h2 id='examineKinships'>Check pedigree for relationship errors</h2><span id='topic+examineKinships'></span>

<h3>Description</h3>

<p>This function provides a convenient way to check for pedigree errors in a
linkage project or other situations where marker data is available for
several members. The function calls <code><a href="#topic+IBDestimate">IBDestimate</a></code> to estimate IBD
coefficients for all indicated pairs of pedigree members and produces a
colour-coded plot where wrong relationships are easy to spot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>examineKinships(
  x,
  who = "all",
  interfam = c("founders", "none", "all"),
  makeplot = T,
  pch = 4,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="examineKinships_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+linkdat">linkdat</a></code> object, or a list of such.</p>
</td></tr>
<tr><td><code id="examineKinships_+3A_who">who</code></td>
<td>
<p>A character vector of one or more of the words 'parents',
'siblings', 'hugs' (= halfsibs/uncles/grandparents), 'cousins' and
'unrelated'. Two additional single-word values are possible: 'all' (all of
the above, plus 'other') and 'close' (= 'parents', 'siblings', 'hugs',
'cousins').</p>
</td></tr>
<tr><td><code id="examineKinships_+3A_interfam">interfam</code></td>
<td>
<p>A character; either 'founders', 'none' or 'all', indicating
which interfamiliar pairs of individuals should be included. Only relevant
if <code>x</code> is a list of several <code>linkdat</code> objects.</p>
</td></tr>
<tr><td><code id="examineKinships_+3A_makeplot">makeplot</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="examineKinships_+3A_pch">pch</code></td>
<td>
<p>Plotting symbol (default: cross).</p>
</td></tr>
<tr><td><code id="examineKinships_+3A_...">...</code></td>
<td>
<p>Other plot arguments passed on to <code><a href="#topic+showInTriangle">showInTriangle</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of data.frames (one for each relation category) with IBD
estimates.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IBDestimate">IBDestimate</a></code>, <code><a href="#topic+IBDtriangle">IBDtriangle</a></code>,
<code><a href="#topic+showInTriangle">showInTriangle</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = cousinsPed(1)
x = simpleSim(x, 500, alleles=1:2)
examineKinships(x)

# Pretend we didn't know the brothers (3 and 6) were related
x1 = branch(x, 3)
x2 = branch(x, 6)
x2$famid = 2

# Notice the error: An 'unrelated' dot close to the sibling point
examineKinships(list(x1, x2))

</code></pre>

<hr>
<h2 id='exclusionPower'>Power of exclusion</h2><span id='topic+exclusionPower'></span>

<h3>Description</h3>

<p>Computes the power (of a single marker) of excluding a claimed relationship,
given the true relationship.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exclusionPower(
  ped_claim,
  ped_true,
  ids,
  markerindex = NULL,
  alleles = NULL,
  afreq = NULL,
  known_genotypes = list(),
  Xchrom = FALSE,
  plot = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exclusionPower_+3A_ped_claim">ped_claim</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object, or a list of several linkdat
and/or singleton objects, describing the claimed relationship. If a list,
the sets of ID labels must be disjoint, that is, all ID labels must be
unique.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_ped_true">ped_true</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object, or a list of several linkdat
and/or singleton objects, describing the true relationship. ID labels must
be consistent with <code>ped_claim</code>.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_ids">ids</code></td>
<td>
<p>individuals available for genotyping.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_markerindex">markerindex</code></td>
<td>
<p>NULL, or a single numeric indicating the index of a marker
of <code>ped_claim</code> from which <code>alleles</code>, <code>afreq</code> and
<code>known_genotypes</code> will be extracted.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_alleles">alleles</code></td>
<td>
<p>a numeric or character vector containing marker alleles names.
Ignored if <code>markerindex</code> is non-NULL.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_afreq">afreq</code></td>
<td>
<p>a numerical vector with allele frequencies. An error is given if
they don't sum to 1 (rounded to 3 decimals). Ignored if <code>markerindex</code>
is non-NULL.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_known_genotypes">known_genotypes</code></td>
<td>
<p>list of triplets <code>(a, b, c)</code>, indicating that
individual <code>a</code> has genotype <code>b/c</code>. Must be NULL if
<code>markerindex</code> is non-NULL.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_xchrom">Xchrom</code></td>
<td>
<p>a logical: Is the marker on the X chromosome? Ignored if
<code>markerindex</code> is non-NULL.</p>
</td></tr>
<tr><td><code id="exclusionPower_+3A_plot">plot</code></td>
<td>
<p>either a logical or the character 'plot_only', controlling if a
plot should be produced. If 'plot_only', a plot is drawn, but no further
computations are done.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the 'Power of exclusion', as defined and discussed in
(Egeland et al., 2014).
</p>


<h3>Value</h3>

<p>A single numeric value. If <code>plot='plot_only'</code>, the function
returns NULL after producing the plot.
</p>


<h3>References</h3>

<p>T. Egeland, N. Pinto and M. D. Vigeland, <em>A general approach
to power calculation for relationship testing.</em> Forensic Science
International: Genetics 9 (2014): 186-190. DOI:10.1016/j.fsigen.2013.05.001
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
############################################
### A standard case paternity case:
### Compute the power of exclusion when the claimed father is in fact unrelated to the child.
############################################

claim = nuclearPed(noffs=1, sex=2)     # Specifies individual 1 as the father of 3
true = list(singleton(id=1,sex=1), singleton(id=3, sex=2))     # Specifies 1 and 3 as unrelated
available = c(1, 3)     # Individuals 1 and 3 are available for genotyping

# Equifrequent autosomal SNP:
PE1 = exclusionPower(claim, true, available, alleles = 2, afreq=c(0.5,0.5))

# If the child is known to have genotype 1/1:
PE2 = exclusionPower(claim, true, available, alleles = 2, afreq=c(0.5,0.5),
                     known_genotypes=list(c(3,1,1)))

# Equifrequent SNP on the X chromosome:
PE3 = exclusionPower(claim, true, available, alleles = 2, afreq=c(0.5,0.5), Xchrom=TRUE)

stopifnot(PE1==0.125, PE2==0.25, PE3==0.25)

############################################
### Example from Egeland et al. (2012):
### Two females claim to be mother and daughter. Below we compute the power of various
### markers to reject this claim if they in reality are sisters.
############################################

mother_daughter = nuclearPed(1, sex = 2)
sisters = relabel(nuclearPed(2, sex = c(2, 2)), c(101, 102, 2, 3))

# Equifrequent SNP:
PE1 = exclusionPower(ped_claim = mother_daughter, ped_true = sisters, ids = c(2, 3),
                     alleles = 2)

# SNP with MAF = 0.1:
PE2 = exclusionPower(ped_claim = mother_daughter, ped_true = sisters, ids = c(2, 3),
                     alleles = 2, afreq=c(0.9, 0.1))

# Equifrequent tetra-allelic marker:
PE3 = exclusionPower(ped_claim = mother_daughter, ped_true = sisters, ids = c(2, 3),
                     alleles = 4)

# Tetra-allelic marker with one major allele:
PE4 = exclusionPower(ped_claim = mother_daughter, ped_true = sisters, ids = c(2, 3),
                     alleles = 4, afreq=c(0.7, 0.1, 0.1, 0.1))

stopifnot(round(c(PE1,PE2,PE3,PE4), 5) == c(0.03125, 0.00405, 0.08203, 0.03090))

####### How does the power change if the true pedigree is inbred?
sisters_LOOP = addParents(sisters, 101, father = 201, mother = 202)
sisters_LOOP = addParents(sisters_LOOP, 102, father = 201, mother = 203)

# Equifrequent SNP:
PE5 = exclusionPower(ped_claim = mother_daughter, ped_true = sisters_LOOP,
                     ids = c(2, 3), alleles = 2)

# SNP with MAF = 0.1:
PE6 = exclusionPower(ped_claim = mother_daughter, ped_true = sisters_LOOP,
                     ids = c(2, 3), alleles = 2, afreq=c(0.9, 0.1))

stopifnot(round(c(PE5,PE6), 5) == c(0.03125, 0.00765))

## Not run: 
# Equifrequent tetra-allelic marker:
PE7 = exclusionPower(ped_claim = mother_daughter, ped_true = sisters_LOOP,
                     ids = c(2, 3), alleles = 4)

# Tetra-allelic marker with one major allele:
PE8 = exclusionPower(ped_claim = mother_daughter, ped_true = sisters_LOOP,
                     ids = c(2, 3), alleles = 4, afreq=c(0.7, 0.1, 0.1, 0.1))

stopifnot(round(c(PE7,PE8), 5) == c(0.07617, 0.03457))

## End(Not run)

</code></pre>

<hr>
<h2 id='Familias2linkdat'>Convert 'Familias' output to linkdat objects</h2><span id='topic+Familias2linkdat'></span><span id='topic+readFamiliasLoci'></span><span id='topic+connectedComponents'></span>

<h3>Description</h3>

<p>Familias is a widely used program for computations in forensic genetics. The
function documented here facilitates the use of <code>paramlink</code> for
specialized computations which are not implemented in Familias, e.g.
conditional simulations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Familias2linkdat(familiasped, datamatrix, loci)

readFamiliasLoci(loci)

connectedComponents(ID, FID, MID)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Familias2linkdat_+3A_familiasped">familiasped</code></td>
<td>
<p>A <code>FamiliasPedigree</code> object or a
list of such.</p>
</td></tr>
<tr><td><code id="Familias2linkdat_+3A_datamatrix">datamatrix</code></td>
<td>
<p>A data frame with two columns per marker (one for each
allele) and one row per individual.</p>
</td></tr>
<tr><td><code id="Familias2linkdat_+3A_loci">loci</code></td>
<td>
<p>A <code>FamiliasLocus</code> object or a list of such.</p>
</td></tr>
<tr><td><code id="Familias2linkdat_+3A_id">ID</code></td>
<td>
<p>An integer vector: Individual ID.</p>
</td></tr>
<tr><td><code id="Familias2linkdat_+3A_fid">FID</code></td>
<td>
<p>An integer vector: ID of father.</p>
</td></tr>
<tr><td><code id="Familias2linkdat_+3A_mid">MID</code></td>
<td>
<p>An integer vector: ID of mother.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Familias program represents pedigrees and marker data in a way that
differs from <code>paramlink</code> in several ways, mostly because of
<code>paramlink</code>'s stricter definition of a 'pedigree'. In <code>paramlink</code>,
a pedigree must be connected, have numerical IDs, and each member must have
either 0 or 2 parents present in the pedigree. None of this is required by
<code>FamiliasPedigree</code> objects. The conversion function
<code>Familias2linkdat</code> takes care of all of these potential differences: It
converts each <code>FamiliasPedigree</code> into a list of connected linkdat objects,
additional parents are added where needed, and non-numerical ID labels are
stored in the <code>plot.labels</code> slot of the linkdat object(s).
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+linkdat">linkdat</a></code> object, or a list of such.
</p>


<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland, Thore Egeland
</p>


<h3>References</h3>

<p>Windows Familias is freely available from
<a href="https://familias.name">https://familias.name</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = nuclearPed(1)

</code></pre>

<hr>
<h2 id='hasCA'>Pairwise common ancestors</h2><span id='topic+hasCA'></span>

<h3>Description</h3>

<p>Computes a matrix A whose entry A[i,j] is TRUE if pedigree members i and j have a common ancestor, and FALSE otherwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasCA(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasCA_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
x = fullSibMating(3)
A = hasCA(x)
stopifnot(A[1,1], !A[1,2], all(A[3:8, 3:8]))

</code></pre>

<hr>
<h2 id='IBDestimate'>Relatedness estimation</h2><span id='topic+IBDestimate'></span>

<h3>Description</h3>

<p>Estimate the pairwise IBD coefficients <code class="reqn">(\kappa_0, \kappa_1, \kappa_2)</code> for
specified pairs of pedigree members, using maximum likelihood methods.
The optimization machinery is imported from the <code>maxLik</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBDestimate(x, ids, markers = NULL, start = c(0.99, 0.001), tol = 1e-07)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IBDestimate_+3A_x">x</code></td>
<td>
<p>A single <code>linkdat</code> object or a list of <code>linkdat</code> and/or
<code>singleton</code> objects.</p>
</td></tr>
<tr><td><code id="IBDestimate_+3A_ids">ids</code></td>
<td>
<p>Either a vector of length 2, or a matrix with two columns, indicating the
the pair(s) of individuals for which IBD estimates should be computed. If a matrix,
each row corresponds to a pair. The entries can be either characters (matching the
<code>plot.labels</code> of the linkdat object(s)) or integers (matching the <code>orig.ids</code>
identifiers of the linkdat object(s)).</p>
</td></tr>
<tr><td><code id="IBDestimate_+3A_markers">markers</code></td>
<td>
<p>A numeric indicating which marker(s) to include. If NULL (default),
all markers are used.</p>
</td></tr>
<tr><td><code id="IBDestimate_+3A_start">start</code></td>
<td>
<p>Numeric of length 2, indicating the initial value of <code class="reqn">(\kappa_0, \kappa_2)</code>
in the optimisation (passed on to <code>maxLik</code>).</p>
</td></tr>
<tr><td><code id="IBDestimate_+3A_tol">tol</code></td>
<td>
<p>A single numeric: the optimising tolerance value; passed on to <code>maxLik</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function optimises the log-likelihood function first described in (Thompson, 1975).
Optimisation is done in the <code class="reqn">(\kappa_0, \kappa_2)</code>-plane and restricted to the
probability triangle defined by <code class="reqn">\kappa_0 \ge 0, \kappa_2 \ge 0, \kappa_0 + \kappa_2 \le 1</code>.
</p>


<h3>Value</h3>

<p>A data.frame with 8 columns: ID1, ID2 (numeric IDs), Name1, Name2 (plot labels, if present), N
(#markers with no missing alleles), <code class="reqn">\kappa_0</code>, <code class="reqn">\kappa_1</code>, <code class="reqn">\kappa_2</code>.
</p>


<h3>References</h3>

<p>E. A. Thompson (2000). <em>Statistical Inferences from Genetic Data
on Pedigrees.</em> NSF-CBMS Regional Conference Series in Probability and
Statistics. Volume 6.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+examineKinships">examineKinships</a></code>,
<code><a href="#topic+IBDtriangle">IBDtriangle</a></code>, <code><a href="maxLik.html#topic+maxLik">maxLik</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("maxLik", quietly = TRUE)) {

# Simulate marker data for two siblings
x = nuclearPed(2)
x = setPlotLabels(x, c("Sib1", "Sib2"), c(3,4))
x = simpleSim(x, 200, 1:2) # 200 equifrequent SNPs

# Estimate the IBD coefficients for the siblings
est1 = IBDestimate(x, ids=c(3,4))

# Estimate should be the same if pedigree structure is unknown
xlist = list(branch(x, 3), branch(x, 4))
est2 = IBDestimate(xlist, ids=c(3,4))
stopifnot(identical(est1, est2))

# If the pedigree has plot.labels, they can be used as IDs
est3 = IBDestimate(x, ids=c("Sib1", "Sib2"))
stopifnot(identical(est1, est3))

}

</code></pre>

<hr>
<h2 id='IBDtriangle'>IBD triangle plot</h2><span id='topic+IBDtriangle'></span>

<h3>Description</h3>

<p>The IBD triangle is typically used to visualize the pairwise relatedness of
non-inbred individuals.  Various annotations are available, including points
marking the most common relationships, contour lines for the kinship
coefficients, and shading of the unattainable region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBDtriangle(
  relationships = c("UN", "PO", "MZ", "S", "H,U,G", "FC", "SC", "DFC", "Q"),
  kinship.lines = numeric(),
  shading = "lightgray",
  pch = 16,
  cex_points = 1.2,
  cex_text = 1,
  axes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IBDtriangle_+3A_relationships">relationships</code></td>
<td>
<p>A character vector indicating relationships points to be
included in the plot. By default all of the following are included:
UN=unrelated; PO=parent/offspring; MZ=monozygotic twins; S=full siblings;
H=half siblings; U=uncle/niece and similar; G=grandparent/grandchild;
FC=first cousins; SC=second cousins; DFC=double first cousins; Q=quadruple
first half cousins.</p>
</td></tr>
<tr><td><code id="IBDtriangle_+3A_kinship.lines">kinship.lines</code></td>
<td>
<p>A numeric vector. (See Details.)</p>
</td></tr>
<tr><td><code id="IBDtriangle_+3A_shading">shading</code></td>
<td>
<p>The shading colour for the unattainable region.</p>
</td></tr>
<tr><td><code id="IBDtriangle_+3A_pch">pch</code></td>
<td>
<p>Symbol used for the relationship points (see <code><a href="graphics.html#topic+par">par</a></code>).</p>
</td></tr>
<tr><td><code id="IBDtriangle_+3A_cex_points">cex_points</code></td>
<td>
<p>A single numeric controlling the symbol size for the
relationship points.</p>
</td></tr>
<tr><td><code id="IBDtriangle_+3A_cex_text">cex_text</code></td>
<td>
<p>A single numeric controlling the font size for the
relationship labels.</p>
</td></tr>
<tr><td><code id="IBDtriangle_+3A_axes">axes</code></td>
<td>
<p>Draw surrounding axis box?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For any pair of non-inbred individuals A and B, their genetic relationship
can be summarized by the IBD coefficients <code class="reqn">(\kappa_0, \kappa_1,
\kappa_2)</code>, where </p>
<p style="text-align: center;"><code class="reqn">\kappa_i = P(A and B share i alleles IBD at random
autosomal locus).</code>
</p>
<p> Since <code class="reqn">\kappa_0+\kappa_1+\kappa_2=1</code>, any relationship
corresponds to a point in the triangle in the <code class="reqn">(\kappa_0,
\kappa_2)</code>-plane defined by <code class="reqn">\kappa_0 \ge 0, \kappa_2 \ge 0, \kappa_0 +
\kappa_2 \le 1</code>. The choice of <code class="reqn">\kappa_0</code> and <code class="reqn">\kappa_2</code> as the axis
variables is done for reasons of symmetry and is not significant (other
authors have used different views of the triangle).
</p>
<p>As shown in (Thompson, 1976) points in the subset of the triangle defined by
<code class="reqn">4\kappa_0\kappa_2 &gt; \kappa_1^2</code> is unattainable for pairwise
relationships.  By default this region in shaded in a 'lightgray' colour.
</p>
<p>The IBD coefficients are linearly related to the kinship coefficient
<code class="reqn">\phi</code> by the formula </p>
<p style="text-align: center;"><code class="reqn">\phi = 0.25\kappa_1 + 0.5\kappa_2.</code>
</p>
<p> By
indicating values for <code class="reqn">\phi</code> in the <code>kinship.lines</code> argument, the
corresponding contour lines are shown as dashed lines in the triangle plot.
</p>


<h3>References</h3>

<p>E. A. Thompson (1975). <em>The estimation of pairwise
relationships.</em> Annals of Human Genetics 39.
</p>
<p>E. A. Thompson (1976). <em>A restriction on the space of genetic
relationships.</em> Annals of Human Genetics 40.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+examineKinships">examineKinships</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
IBDtriangle()
IBDtriangle(kinship=c(0.25, 0.125), shading=NULL, cex_text=0.8)

</code></pre>

<hr>
<h2 id='is.linkdat'>Is an object a linkdat object?</h2><span id='topic+is.linkdat'></span><span id='topic+is.singleton'></span><span id='topic+is.linkdat.list'></span>

<h3>Description</h3>

<p>Functions for checking whether an object is a <code><a href="#topic+linkdat">linkdat</a></code> object, a
<code><a href="#topic+singleton">singleton</a></code> or a list of such.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.linkdat(x)

is.singleton(x)

is.linkdat.list(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.linkdat_+3A_x">x</code></td>
<td>
<p>Any <code>R</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that the <code>singleton</code> class inherits from <code>linkdat</code>, so if
<code>x</code> is a singleton, <code>is.linkdat(x)</code> returns TRUE.
</p>


<h3>Value</h3>

<p>For <code>is.linkdat</code>: TRUE if <code>x</code> is a linkdat (or singleton)
object, and FALSE otherwise.<br /> For <code>is.singleton</code>: TRUE if <code>x</code>
is a singleton object, and FALSE otherwise.<br /> For <code>is.linkdat.list</code>:
TRUE if <code>x</code> is a list of linkdat/singleton objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linkdat">linkdat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x1 = nuclearPed(1)
x2 = singleton(1)
stopifnot(is.linkdat(x1), !is.singleton(x1),
          is.linkdat(x2), is.singleton(x2),
          is.linkdat.list(list(x1,x2)))

</code></pre>

<hr>
<h2 id='likelihood'>Pedigree likelihood</h2><span id='topic+likelihood'></span><span id='topic+likelihood.linkdat'></span><span id='topic+likelihood.singleton'></span><span id='topic+likelihood.list'></span><span id='topic+likelihood_LINKAGE'></span>

<h3>Description</h3>

<p>Calculates various forms of pedigree likelihoods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>likelihood(x, ...)

## S3 method for class 'linkdat'
likelihood(
  x,
  locus1,
  locus2 = NULL,
  theta = NULL,
  startdata = NULL,
  eliminate = 0,
  logbase = NULL,
  loop_breakers = NULL,
  ...
)

## S3 method for class 'singleton'
likelihood(x, locus1, logbase = NULL, ...)

## S3 method for class 'list'
likelihood(x, locus1, locus2 = NULL, ..., returnprod = TRUE)

likelihood_LINKAGE(
  x,
  marker,
  theta = NULL,
  afreq = NULL,
  logbase = NULL,
  TR.MATR = NULL,
  initialCalc = NULL,
  singleNum.geno = NULL,
  loop_breakers = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="likelihood_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object, a <code><a href="#topic+singleton">singleton</a></code> object, or
a list of such objects. In <code>likelihood_LINKAGE</code>, <code>x</code> must be a
<code>linkdat</code> object, with <code>x$model</code> different from NULL.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_locus1">locus1</code></td>
<td>
<p>a <code><a href="#topic+marker">marker</a></code> object compatible with <code>x</code>. If
<code>x</code> is a list, then <code>locus1</code> must be a list of corresponding
<code>marker</code> objects.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_locus2">locus2</code></td>
<td>
<p>either NULL, the character 'disease', or a <code><a href="#topic+marker">marker</a></code>
object compatible with <code>x</code>. See Details.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_theta">theta</code></td>
<td>
<p>the recombination rate between locus1 and locus2 (in
<code>likelihood_LINKAGE</code>: between the marker and the disease locus).  To
make biological sense theta should be between 0 and 0.5.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_startdata">startdata</code></td>
<td>
<p>for internal use.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_eliminate">eliminate</code></td>
<td>
<p>mostly for internal use: a non-negative integer indicating
the number of iterations in the internal genotype-compatibility algorithm.
Positive values can save time if <code>partialmarker</code> is non-empty and the
number of alleles is large.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_logbase">logbase</code></td>
<td>
<p>a numeric, or NULL. If numeric the log-likelihood is returned,
with <code>logbase</code> as basis for the logarithm.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_loop_breakers">loop_breakers</code></td>
<td>
<p>a numeric containing IDs of individuals to be used as
loop breakers. If NULL, automatic selection of loop breakers will be
performed. See <code><a href="#topic+breakLoops">breakLoops</a></code>.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_returnprod">returnprod</code></td>
<td>
<p>a logical; if TRUE, the product of the likelihoods is
returned, otherwise a vector with the likelihoods for each pedigree in the
list.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_marker">marker</code></td>
<td>
<p>an integer between 0 and <code>x$nMark</code>, indicating which
marker to use in the calculation.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_afreq">afreq</code></td>
<td>
<p>a numeric containing the marker allele frequencies.</p>
</td></tr>
<tr><td><code id="likelihood_+3A_tr.matr">TR.MATR</code>, <code id="likelihood_+3A_initialcalc">initialCalc</code>, <code id="likelihood_+3A_singlenum.geno">singleNum.geno</code></td>
<td>
<p>for internal use, speeding up
linkage computations with few-allelic markers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All likelihoods are calculated using the Elston-Stewart algorithm.
</p>
<p>If <code>locus2 = NULL</code>, the result is simply the likelihood of the genotypes
observed at the marker in locus1.
</p>
<p>If <code>locus2 = 'disease'</code>, the result is the likelihood of the marker
genotypes in locus1, given the affection statuses of the pedigree members,
the disease model and the recombination rate <code>theta</code> between the marker
and disease loci.  The main use of this is for computation of LOD scores in
parametric linkage analysis.
</p>
<p>If <code>locus2</code> is a marker object, the result is the likelihood of the
genotypes at the two markers, given the recombination rate theta between
them.
</p>
<p>The function <code>likelihood_LINKAGE</code> is a fast version of
<code>likelihood.linkdat</code> in the case where <code>locus2 = 'disease'</code> and the
marker in locus1 has less than 5 alleles.
</p>


<h3>Value</h3>

<p>The likelihood of the data. If the parameter <code>logbase</code> is a
positive number, the output is <code>log(likelihood, logbase)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+lod">lod</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = linkdat(toyped, model=1) #dominant model

lod1 = likelihood_LINKAGE(x, marker=1, theta=0, logbase=10) -
       likelihood_LINKAGE(x, marker=1, theta=0.5, logbase=10)
lod2 = lod(x, markers=1, theta=0)

# these should be the same:
stopifnot(identical(lod1, as.numeric(lod2)), round(lod1, 2)==0.3)

# likelihood of inbred pedigree (grandfather/granddaughter incest)
y = addOffspring(addDaughter(nuclearPed(1, sex=2), 3), father=1, mother=5, 1)
m = marker(y, 1, 1, 6, 1:2)
l1 = likelihood(y, m)
l2 = likelihood(y, m, loop_breaker=5) # manual specification of loop_breaker
stopifnot(l1==0.09375, l2==l1)

</code></pre>

<hr>
<h2 id='linkage.power'>Power of a linkage study</h2><span id='topic+linkage.power'></span><span id='topic+summary.powres'></span>

<h3>Description</h3>

<p>Power analysis of parametric linkage studies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkage.power(
  x,
  N = 100,
  available = x$available,
  afreq = c(0.5, 0.5),
  loop_breakers = NULL,
  threshold = NULL,
  seed = NULL,
  verbose = FALSE
)

## S3 method for class 'powres'
summary(object, threshold = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkage.power_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object with a valid <code>model</code>. (See
<code><a href="#topic+setModel">setModel</a></code>.)</p>
</td></tr>
<tr><td><code id="linkage.power_+3A_n">N</code></td>
<td>
<p>an integer; the number of markers to simulate.</p>
</td></tr>
<tr><td><code id="linkage.power_+3A_available">available</code></td>
<td>
<p>a vector containing IDs of the available individuals, i.e.
those whose genotypes should be simulated.</p>
</td></tr>
<tr><td><code id="linkage.power_+3A_afreq">afreq</code></td>
<td>
<p>a numerical vector with sum 1; the population frequencies for
the marker alleles.</p>
</td></tr>
<tr><td><code id="linkage.power_+3A_loop_breakers">loop_breakers</code></td>
<td>
<p>a numeric containing IDs of individuals to be used as
loop breakers. Relevant only if the pedigree has loops. See
<code><a href="#topic+breakLoops">breakLoops</a></code>.</p>
</td></tr>
<tr><td><code id="linkage.power_+3A_threshold">threshold</code></td>
<td>
<p>NULL, or a single numeric. If numeric, the output includes
the percentage of simulated markers having LOD larger than
<code>threshold</code>.</p>
</td></tr>
<tr><td><code id="linkage.power_+3A_seed">seed</code></td>
<td>
<p>NULL, or a numeric seed for the random number generator.</p>
</td></tr>
<tr><td><code id="linkage.power_+3A_verbose">verbose</code></td>
<td>
<p>a logical passed on to <code>linkageSim</code>. If <code>TRUE</code>, some
details are shown during the marker simulation.</p>
</td></tr>
<tr><td><code id="linkage.power_+3A_object">object</code></td>
<td>
<p>a <code>powres</code> object, normally produced by
<code>linkage.power</code>.</p>
</td></tr>
<tr><td><code id="linkage.power_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function prints a summary and returns invisibly a <code>powres</code>
object, which is a list with the following entries: </p>
<table>
<tr><td><code>sim</code></td>
<td>
<p>A
<code>linkdat</code> object with the simulated markers</p>
</td></tr> <tr><td><code>lod</code></td>
<td>
<p>The LOD scores
(computed with recombination fraction theta=0) of the simulated markers</p>
</td></tr>
<tr><td><code>maxlod</code></td>
<td>
<p>The highest LOD score of the simulated markers</p>
</td></tr>
<tr><td><code>elod</code></td>
<td>
<p>The average LOD score for the simulated markers</p>
</td></tr>

</table>
<p>returns the maximum LOD score for each element of <code>values</code>.
</p>


<h3>References</h3>

<p>Marker simulation is inspired by the SLINK algorithm:
<a href="https://www.jurgott.org/linkage/SLINK.htm">https://www.jurgott.org/linkage/SLINK.htm</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linkdat">linkdat</a></code>, <code><a href="#topic+linkageSim">linkageSim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Note: In the examples below N is set very low in order to reduce time consumption.
# Increase N to get more interesting results.

x = nuclearPed(3)
x = swapAff(x, c(1,3,4))
x = setModel(x, 1) # Autosomal dominant
linkage.power(x, N=1)

# X-linked recessive example:
y = linkdat(Xped, model=4)
linkage.power(y, N=1)

# Power of homozygosity mapping:
z = addOffspring(cousinPed(1), father=7, mother=8, noffs=1, aff=2)
z = setModel(z, 2) # Autosomal recessive model
pow = linkage.power(z, N=1, loop_breaker=7, seed=123)
stopifnot(round(pow$maxlod, 1) == 1.2)

</code></pre>

<hr>
<h2 id='linkageSim'>Simulate markers linked to a disease locus.</h2><span id='topic+linkageSim'></span>

<h3>Description</h3>

<p>Simulates markers (with up to 4 alleles) conditional on the pedigree
structure, affection statuses and disease model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkageSim(
  x,
  N = 1,
  available = x$available,
  afreq = NULL,
  partialmarker = NULL,
  loop_breakers = NULL,
  unique = FALSE,
  seed = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkageSim_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object</p>
</td></tr>
<tr><td><code id="linkageSim_+3A_n">N</code></td>
<td>
<p>a positive integer: the number of markers to be simulated</p>
</td></tr>
<tr><td><code id="linkageSim_+3A_available">available</code></td>
<td>
<p>a vector containing IDs of the available individuals, i.e.
those whose genotypes should be simulated.</p>
</td></tr>
<tr><td><code id="linkageSim_+3A_afreq">afreq</code></td>
<td>
<p>a vector of length &lt; 5 containing the population frequencies for
the marker alleles.</p>
</td></tr>
<tr><td><code id="linkageSim_+3A_partialmarker">partialmarker</code></td>
<td>
<p>Either NULL (indicating no given marker data), or a
<code>marker</code> object.</p>
</td></tr>
<tr><td><code id="linkageSim_+3A_loop_breakers">loop_breakers</code></td>
<td>
<p>a numeric containing IDs of individuals to be used as
loop breakers. Relevant only if the pedigree has loops. See
<code><a href="#topic+breakLoops">breakLoops</a></code>.</p>
</td></tr>
<tr><td><code id="linkageSim_+3A_unique">unique</code></td>
<td>
<p>a logical indicating if duplicates among the simulated markers
should be removed.</p>
</td></tr>
<tr><td><code id="linkageSim_+3A_seed">seed</code></td>
<td>
<p>NULL, or a numeric seed for the random number generator.</p>
</td></tr>
<tr><td><code id="linkageSim_+3A_verbose">verbose</code></td>
<td>
<p>a logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All markers are simulated under the condition that the recombination fraction
between the marker and the disease locus is 0.  This is an implementation of
the algorithm used in SLINK of the LINKAGE/FASTLINK suite.
</p>


<h3>Value</h3>

<p>a <code>linkdat</code> object equal to <code>x</code> except its
<code>markerdata</code> entry, which consists of the <code>N</code> simulated markers.
</p>


<h3>References</h3>

<p>G. M. Lathrop, J.-M. Lalouel, C. Julier, and J. Ott (1984).
<em>Strategies for Multilocus Analysis in Humans</em>, PNAS 81, pp.
3443-3446.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linkage.power">linkage.power</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = linkdat(toyped, model=1)
y = linkageSim(x, N=10, afreq=c(0.5, 0.5))
stopifnot(length(mendelianCheck(y))==0)

z = addOffspring(cousinPed(1), father=7, mother=8, noffs=1, aff=2)
z = setModel(z, 2)
linkageSim(z, N=1, afreq = c(0.1, 0.2, 0.7))

</code></pre>

<hr>
<h2 id='linkdat'>Linkdat objects</h2><span id='topic+linkdat'></span><span id='topic+singleton'></span><span id='topic+print.linkdat'></span><span id='topic+summary.linkdat'></span><span id='topic+write.linkdat'></span><span id='topic+subset.linkdat'></span>

<h3>Description</h3>

<p>Functions to create and display 'linkdat' objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkdat(
  ped,
  model = NULL,
  map = NULL,
  dat = NULL,
  freq = NULL,
  annotations = NULL,
  missing = 0,
  header = FALSE,
  checkped = TRUE,
  verbose = TRUE,
  ...
)

singleton(id, sex = 1, famid = 1, verbose = FALSE, ...)

## S3 method for class 'linkdat'
print(x, ..., markers)

## S3 method for class 'linkdat'
summary(object, ...)

write.linkdat(
  x,
  prefix = "",
  what = c("ped", "map", "dat", "freq", "model"),
  merlin = FALSE
)

## S3 method for class 'linkdat'
subset(x, subset = x$orig.ids, ..., markers = seq_len(x$nMark))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkdat_+3A_ped">ped</code></td>
<td>
<p>a matrix, data.frame or a character with the path to a pedigree
file in standard LINKAGE format. (See details)</p>
</td></tr>
<tr><td><code id="linkdat_+3A_model">model</code></td>
<td>
<p>either a <code>linkdat.model</code> object (typically <code>y$model</code>
for some linkdat object <code>y</code>), or a single integer with the following
meaning: 1 = autosomal dominant; 2 = autosomal recessive; 3 = X-linked
dominant; 4 = X-linked recessive. In each of these cases, the disease is
assumed fully penetrant and the disease allele frequency is set to 0.00001.
If <code>model=NULL</code>, no model is set.</p>
</td></tr>
<tr><td><code id="linkdat_+3A_map">map</code></td>
<td>
<p>a character with the path to a map file in MERLIN format, or NULL.
If non-NULL, a dat file must also be given (next item).</p>
</td></tr>
<tr><td><code id="linkdat_+3A_dat">dat</code></td>
<td>
<p>a character with the path to a dat file in MERLIN format, or NULL.
(Only needed if <code>map</code> is non-NULL.)</p>
</td></tr>
<tr><td><code id="linkdat_+3A_freq">freq</code></td>
<td>
<p>a character with the path to a allele frequency file in MERLIN
(short) format, or NULL. If NULL, all markers are interpreted as
equifrequent.</p>
</td></tr>
<tr><td><code id="linkdat_+3A_annotations">annotations</code></td>
<td>
<p>a list (of the same length and in the same order as the
marker columns in <code>x</code>) of marker annotations. If this is non-NULL,
then all of <code>map, dat, freq</code> should be NULL.</p>
</td></tr>
<tr><td><code id="linkdat_+3A_missing">missing</code></td>
<td>
<p>the character (of length 1) used for missing alleles. Defaults
to '0'.</p>
</td></tr>
<tr><td><code id="linkdat_+3A_header">header</code></td>
<td>
<p>a logical, relevant only if <code>ped</code> points to a ped file: If
TRUE, the first line of the ped file is skipped.</p>
</td></tr>
<tr><td><code id="linkdat_+3A_checkped">checkped</code></td>
<td>
<p>a logical. If FALSE, no checks for pedigree errors are
performed.</p>
</td></tr>
<tr><td><code id="linkdat_+3A_verbose">verbose</code></td>
<td>
<p>a logical: verbose output or not.</p>
</td></tr>
<tr><td><code id="linkdat_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
<tr><td><code id="linkdat_+3A_id">id</code>, <code id="linkdat_+3A_sex">sex</code></td>
<td>
<p>single numerics describing the individual ID and gender of the
singleton.</p>
</td></tr>
<tr><td><code id="linkdat_+3A_famid">famid</code></td>
<td>
<p>a numeric: the family ID of the singleton.</p>
</td></tr>
<tr><td><code id="linkdat_+3A_x">x</code>, <code id="linkdat_+3A_object">object</code></td>
<td>
<p>a <code>linkdat</code> object.</p>
</td></tr>
<tr><td><code id="linkdat_+3A_markers">markers</code></td>
<td>
<p>a numeric indicating which markers should be included/printed.</p>
</td></tr>
<tr><td><code id="linkdat_+3A_prefix">prefix</code></td>
<td>
<p>a character string giving the prefix of the files. For
instance, if <code>prefix='fam1'</code> and <code>what=c('ped', 'map')</code>, the
files 'fam1.ped' and 'fam1.map' will be created.</p>
</td></tr>
<tr><td><code id="linkdat_+3A_what">what</code></td>
<td>
<p>a character vector forming a subset of c('ped', 'map', 'dat',
'freq', 'model'), indicating which files should be created. All files are
written in MERLIN style (but see the next item!)</p>
</td></tr>
<tr><td><code id="linkdat_+3A_merlin">merlin</code></td>
<td>
<p>a logical. If TRUE, the marker alleles are relabeled to
1,2,..., making sure that the generated files are readable by MERLIN (which
does not accept non-numerical allele labels in the frequency file.) If
FALSE (the default) the allele labels are unchanged. In this case, <code>x</code>
should be exactly reproducible from the files. (See examples.)</p>
</td></tr>
<tr><td><code id="linkdat_+3A_subset">subset</code></td>
<td>
<p>a numeric containing the individuals in the sub-pedigree to be
extracted. NB: No pedigree checking is done here, so make sure the subset
form a meaningful, closed pedigree.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The file (or matrix or data.frame) <code>ped</code> must describe one or several
pedigrees in standard LINKAGE format, i.e. with the following columns in
correct order:
</p>
<p>1 Family id (optional) (FAMID)
</p>
<p>2 Individual id (ID),
</p>
<p>3 Father id (FID),
</p>
<p>4 Mother id (MID),
</p>
<p>5 Gender (SEX): 1 = male, 2 = female,
</p>
<p>6 Affection status (AFF): 1 = unaffected, 2 = affected, 0 = unknown,
</p>
<p>7 First allele of first marker,
</p>
<p>8 Second allele of first marker,
</p>
<p>9 First allele of second marker,
</p>
<p>a.s.o.
</p>
<p>Only columns 2-6 are mandatory. The first column is automatically interpreted
as family id if it has repeated elements.
</p>
<p>Internally the individuals are relabeled as 1,2,..., but this should rarely
be of concern to the end user. Some pedigree checking is done, but it is
recommended to plot the pedigree before doing any analysis.
</p>
<p>Details on the formats of map, dat and frequency files can be found in the
online MERLIN tutorial: <a href="http://csg.sph.umich.edu/abecasis/Merlin/">http://csg.sph.umich.edu/abecasis/Merlin/</a>
</p>
<p>A singleton is a special <code>linkdat</code> object whose pedigree contains 1
individual. The class attribute of a singleton is <code>c('singleton',
'linkdat')</code>
</p>


<h3>Value</h3>

<p>A <code>linkdat</code> object, or a list of <code>linkdat</code> objects. A
linkdat object is essentially a list with the following entries, some of
which can be NULL.  </p>
<table>
<tr><td><code>pedigree</code></td>
<td>
<p><code>data.frame</code> with 5 columns (ID,
FID, MID, SEX, AFF) describing the pedigree in linkage format. (NB:
Internal labeling used.)</p>
</td></tr> <tr><td><code>orig.ids</code></td>
<td>
<p>the original individual id
labels.</p>
</td></tr> <tr><td><code>nInd</code></td>
<td>
<p>the number of individuals in the pedigree.</p>
</td></tr>
<tr><td><code>founders</code></td>
<td>
<p>vector of the founder individuals. (NB: Internal labeling
used.)</p>
</td></tr> <tr><td><code>nonfounders</code></td>
<td>
<p>vector of the nonfounder individuals (NB:
Internal labeling used.)</p>
</td></tr> <tr><td><code>hasLoops</code></td>
<td>
<p>a logical: TRUE if the pedigree
is inbred.</p>
</td></tr> <tr><td><code>subnucs</code></td>
<td>
<p>list containing all (maximal) nuclear families
in the pedigree. Each nuclear family is given as a vector of the form
c(pivot, father, mother, child1, ...), where the pivot is either the id of
the individual linking the nuclear family to the rest of the pedigree, or 0
if there are none. (NB: Internal labeling used.)</p>
</td></tr> <tr><td><code>markerdata</code></td>
<td>
<p>a list
of <code><a href="#topic+marker">marker</a></code> objects.</p>
</td></tr> <tr><td><code>nMark</code></td>
<td>
<p>the number of markers.</p>
</td></tr>
<tr><td><code>available</code></td>
<td>
<p>a numeric vector containing IDs of available individuals.
Used for simulations and plots.</p>
</td></tr> <tr><td><code>model</code></td>
<td>
<p>a <code>linkdat.model</code>
object, essentially a list containing the model parameters. See
<code><a href="#topic+setModel">setModel</a></code> for details.</p>
</td></tr> <tr><td><code>loop_breakers</code></td>
<td>
<p>a matrix with
original loop breaker ID's in the first column and their duplicates in the
second column. This is set by <code><a href="#topic+breakLoops">breakLoops</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+pedCreate">pedCreate</a></code>, <code><a href="#topic+pedModify">pedModify</a></code>,
<code><a href="#topic+pedParts">pedParts</a></code>, <code><a href="#topic+setModel">setModel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = linkdat(toyped, model=1)
x
summary(x)

#### test read/write:
x = modifyMarker(x, 1, alleles=c('B','C'), afreq=c(.9, .1), chrom=2, name='SNP1', pos=123)
write.linkdat(x, prefix='toy')
y = linkdat('toy.ped', map='toy.map', dat='toy.dat', freq='toy.freq', model=1)
unlink(c('toy.ped', 'toy.map', 'toy.dat', 'toy.freq', 'toy.model'))
stopifnot(isTRUE(all.equal(x,y)))

#### test singletons:
w = singleton(id=3, sex=2)
T1 = all.equal(w, linkdat(ped=rbind(c(3,0,0,2,1))))
w = markerSim(w, N=5, alleles=2, afreq=c(0.1,.9))
T2 = all.equal(w, relabel(relabel(w, 10), 3))
T3 = all.equal(w, swapSex(swapSex(w, 3), 3))
T4 = all.equal(w, swapAff(swapAff(w, 3), 3))
stopifnot(T1, T2, T3, T4)

#### several ways of creating the same linkdat object:
alleles = c(157,160,163)
afreq = c(0.3, 0.3, 0.4)
gt10 = c(160, 160)
gt14 = c(160, 163)

z1 = relabel(addOffspring(nuclearPed(1), father=3, noffs=1, aff=2), 10:14)
z1 = addMarker(z1, marker(z1, 10, gt10, 14, gt14, alleles=alleles, afreq=afreq))
z1 = setModel(z1, 2)

z2 = addParents(relabel(nuclearPed(1), 12:14), 12, father=10, mother=11)
z2 = addMarker(z2, rbind(gt10, 0, 0, 0, gt14), alleles=alleles, afreq=afreq)
z2 = setModel(swapAff(z2, 14), 2)

z3 = linkdat(data.frame(ID=10:14, FID=c(0,0,10,0,12), MID=c(0,0,11,0,13),
             SEX=c(1,2,1,2,1), AFF=c(1,1,1,1,2),
             M=c('160/160', '0/0', '0/0', '0/0', '160/163')), model=2)
z3 = modifyMarker(z3, 1, alleles=alleles, afreq=afreq)

write.linkdat(z1, prefix='test')
z4 = linkdat('test.ped', map='test.map', dat='test.dat', freq='test.freq',
             model=2)
z4 = modifyMarker(z4, 1, alleles=alleles, chrom=NA, pos=NA, name=NA)

write.linkdat(z1, prefix='test', merlin=TRUE)
z5 = linkdat('test.ped', map='test.map', dat='test.dat', freq='test.freq',
             model=2)
z5 = modifyMarker(z5, 1, alleles=alleles, chrom=NA, pos=NA, name=NA)

stopifnot(isTRUE(all.equal(z1,z2)), isTRUE(all.equal(z1,z3)),
          isTRUE(all.equal(z1,z4)), isTRUE(all.equal(z1,z5)))
unlink(c('test.ped', 'test.map', 'test.dat', 'test.freq', 'test.model'))

</code></pre>

<hr>
<h2 id='linkres'>S3 methods for class 'linkres'.</h2><span id='topic+linkres'></span><span id='topic+print.linkres'></span><span id='topic+summary.linkres'></span><span id='topic+as.data.frame.linkres'></span><span id='topic+peakSummary'></span><span id='topic+plot.linkres'></span>

<h3>Description</h3>

<p>Functions for printing, summarizing and plotting the results of a linkage
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linkres'
print(x, ...)

## S3 method for class 'linkres'
summary(object, ...)

## S3 method for class 'linkres'
as.data.frame(x, ..., sort = TRUE)

peakSummary(x, threshold, width = 1, physmap = NULL)

## S3 method for class 'linkres'
plot(x, chrom = NULL, ylim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkres_+3A_x">x</code>, <code id="linkres_+3A_object">object</code></td>
<td>
<p>a <code>linkres</code> object (normally produced by
<code><a href="#topic+lod">lod</a></code> or <code><a href="#topic+merlin">merlin</a></code>).</p>
</td></tr>
<tr><td><code id="linkres_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
<tr><td><code id="linkres_+3A_sort">sort</code></td>
<td>
<p>a logical, indicating if the data frame should be sorted
according to map position.</p>
</td></tr>
<tr><td><code id="linkres_+3A_threshold">threshold</code></td>
<td>
<p>a single numeric. A peak is defined as a regions of at least
<code>width</code> consecutive markers LOD score above <code>threshold</code>.</p>
</td></tr>
<tr><td><code id="linkres_+3A_width">width</code></td>
<td>
<p>a single numeric.</p>
</td></tr>
<tr><td><code id="linkres_+3A_physmap">physmap</code></td>
<td>
<p>a matrix or data frame with three columns: Marker name,
chromosome and physical position. This argument is optional.</p>
</td></tr>
<tr><td><code id="linkres_+3A_chrom">chrom</code></td>
<td>
<p>NULL, or a numeric containing chromosome numbers. In the latter
case only results for the markers on the indicated chromosomes will be
plotted.</p>
</td></tr>
<tr><td><code id="linkres_+3A_ylim">ylim</code></td>
<td>
<p>NULL, or a numeric of length 2: to be passed on to plot.default.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+lod">lod</a></code>, <code><a href="#topic+merlin">merlin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = linkdat(toyped, model=1)
lods = lod(x, theta='max')
summary(lods)
as.data.frame(lods)

</code></pre>

<hr>
<h2 id='lod'>Two-point LOD score</h2><span id='topic+lod'></span>

<h3>Description</h3>

<p>Calculates the two-point LOD scores of a pedigree for the specified markers.
The recombination ratio between the disease and marker loci can be either
fixed at specific values, or optimized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lod(
  x,
  markers = seq_len(x$nMark),
  theta = 0,
  loop_breakers = NULL,
  max.only = FALSE,
  verbose = FALSE,
  tol = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lod_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object.</p>
</td></tr>
<tr><td><code id="lod_+3A_markers">markers</code></td>
<td>
<p>an integer vector denoting which markers to use.</p>
</td></tr>
<tr><td><code id="lod_+3A_theta">theta</code></td>
<td>
<p>either a numeric containing specific recombination ratio(s), or
the word 'max', indicating that the recombination ratio should be optimized
by the program.</p>
</td></tr>
<tr><td><code id="lod_+3A_loop_breakers">loop_breakers</code></td>
<td>
<p>a numeric containing IDs of individuals to be used as
loop breakers. Relevant only if the pedigree has loops. See
<code><a href="#topic+breakLoops">breakLoops</a></code>.</p>
</td></tr>
<tr><td><code id="lod_+3A_max.only">max.only</code></td>
<td>
<p>a logical indicating whether only the maximum LOD score
should be returned.</p>
</td></tr>
<tr><td><code id="lod_+3A_verbose">verbose</code></td>
<td>
<p>a logical: verbose output or not.</p>
</td></tr>
<tr><td><code id="lod_+3A_tol">tol</code></td>
<td>
<p>a numeric passed on to <code><a href="stats.html#topic+optimize">optimize</a></code> as its tolerance
parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The LOD score of a marker is defined as </p>
<p style="text-align: center;"><code class="reqn">LOD(\theta) =
\log[10]\frac{L(\theta)}{L(0.5)}</code>
</p>
<p> where <code class="reqn">L(\theta)</code> denotes the
likelihood of the observed marker genotypes given a recombination ratio
<code class="reqn">\theta</code> between the marker and the disease locus.
</p>


<h3>Value</h3>

<p>If <code>max.only=TRUE</code>, the highest computed LOD score is returned,
as a single number.
</p>
<p>Otherwise a <code>linkres</code> object, which is essentially a matrix containing
the LOD scores. The details depend on the other parameters:
</p>
<p>If <code>theta</code> is numeric, the matrix has dimensions <code>length(theta) *
  length(markers)</code>, and the entry in row <code>t</code>, column <code>m</code> is the lod
score of the pedigree for marker <code>m</code> assuming a recombination rate of
<code>t</code>.
</p>
<p>If <code>theta='max'</code>, the <code>linkres</code> matrix has one column per marker
and two rows: The first containing the LOD score and the second the optimal
recombination ratio for each marker.
</p>
<p>If a marker has incompatible values (i.e. if a child of homozygous 1/1
parents has a 2 allele), the corresponding output entries are <code>NaN</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+likelihood">likelihood</a></code>, <code><a href="stats.html#topic+optimize">optimize</a></code>,
<code><a href="#topic+breakLoops">breakLoops</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = linkdat(toyped, model=1)
res = lod(x)
res_theta = lod(x, theta=c(0, 0.1, 0.2, 0.5))
res_max = lod(x, theta='max')
stopifnot(all(0.3 == round(c(res, res_theta['0',], res_max['LOD',]), 1)))

# bigger pedigree with several markers
y = linkdat(dominant)
y = setModel(y, model=1, penetrances=c(.001, .9, .99))
lod(y, markers=305:310)
lod(y, markers=305:310, theta='max')

# Example with pedigree with loops:
z = linkdat(twoloops, model=2) # fully penetrant autosomal recessive model.

# add SNP for which individuals 15 and 16 are homozygous for the rare allele.
m = marker(z, 15:16, c(1,1), alleles=1:2, afreq=c(0.001, 0.999))
z = addMarker(z, m)
res1 = lod(z)
# manual specification of loop breakers gives same result
res2 = lod(z, loop_breakers=c(8,12))

# making the marker triallelic and adding some genotypes.
z = modifyMarker(z, marker=1, ids=c(7,9,11,13), genotype=3, alleles=1:3, afreq=c(0.001, 0.499, 0.5))
plot(z, 1)
res3 = lod(z)

z = modifyMarker(z, marker=1, alleles=1:4, afreq=c(0.001, 0.499, 0.25, 0.25))
res4 = lod(z)

stopifnot(all(3 == round(c(res1, res2, res3, res4), 1)))

</code></pre>

<hr>
<h2 id='lod.peaks'>LOD score peaks</h2><span id='topic+lod.peaks'></span>

<h3>Description</h3>

<p>Identify LOD score peaks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lod.peaks(x, threshold, width = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lod.peaks_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkres">linkres</a></code> object</p>
</td></tr>
<tr><td><code id="lod.peaks_+3A_threshold">threshold</code></td>
<td>
<p>a single numeric</p>
</td></tr>
<tr><td><code id="lod.peaks_+3A_width">width</code></td>
<td>
<p>a positive integer</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function first transforms <code>x</code> to a data frame (using
<code><a href="#topic+as.data.frame.linkres">as.data.frame.linkres</a></code> with <code>sort=T</code>. A peak is defined a
run of at least <code>width</code> consecutive markers with LOD score above or
equal to <code>threshold</code>. If possible, one flanking marker is included on
each side of the peak.
</p>


<h3>Value</h3>

<p>A list of data frames.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linkres">linkres</a></code>, <code><a href="#topic+lod">lod</a></code>, <code><a href="#topic+merlin">merlin</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## minimal example
x = linkdat(toyped, model=1)
res = lod(x)
peak1 = lod.peaks(res, threshold=0)
peak2 = lod.peaks(res, threshold=0, width=2)
peak3 = lod.peaks(res, threshold=1)
stopifnot(length(peak1)==1, nrow(peak1[[1]])==1, length(peak2)==0, length(peak3)==0)

</code></pre>

<hr>
<h2 id='LR'>Likelihood ratios of pedigree hypotheses</h2><span id='topic+LR'></span>

<h3>Description</h3>

<p>This function computes likelihood ratios for a given a list of pedigrees
(linkdat/singletons objects), one of which is the 'reference', with genotype
data from the same set of markers. Data exported from the 'Familias' software
can be analysed by using <code><a href="#topic+Familias2linkdat">Familias2linkdat</a></code> prior to calling this
function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LR(x, ref, markers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LR_+3A_x">x</code></td>
<td>
<p>A list of pedigrees. Each pedigree is either a single
linkdat/singleton object, or a list of such objects (the latter is
necessary if the pedigree is disconnected).</p>
</td></tr>
<tr><td><code id="LR_+3A_ref">ref</code></td>
<td>
<p>A single integer, indicating the index of the reference pedigree.
This is used in the denominator of each LR.</p>
</td></tr>
<tr><td><code id="LR_+3A_markers">markers</code></td>
<td>
<p>A vector of integers, indexing which markers should be
included. If NULL (the default) all markers are used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with entries </p>
<table>
<tr><td><code>LR</code></td>
<td>
<p>Likelihood ratios</p>
</td></tr>
<tr><td><code>LRperMarker</code></td>
<td>
<p>Likelihood ratios for each marker</p>
</td></tr>
<tr><td><code>likelihoodsPerSystem</code></td>
<td>
<p>Likelihoods for each marker</p>
</td></tr> <tr><td><code>time</code></td>
<td>
<p>user,
system and elapsed time</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland and Thore Egeland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IBDtriangle">IBDtriangle</a></code>, <code><a href="#topic+examineKinships">examineKinships</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate genotypes for 5 tetraallelic markers for a pair of full sibs
set.seed(123)
sibs = simpleSim(nuclearPed(2), N=5, alleles=1:4, available=3:4)

# Create two alternative hypotheses and transfer the simulated genotypes to them
halfsibs = addOffspring(nuclearPed(1),father=1,noffs=1,id=4)
halfsibs = transferMarkerdata(sibs, halfsibs)

unrel = list(singleton(3), singleton(4))
unrel = transferMarkerdata(sibs, unrel)

# Compute LR with 'unrelated' as reference
LR(list(sibs, halfsibs, unrel), ref=3)

</code></pre>

<hr>
<h2 id='markers'>Marker functions</h2><span id='topic+markers'></span><span id='topic+marker'></span><span id='topic+addMarker'></span><span id='topic+setMarkers'></span><span id='topic+modifyMarker'></span><span id='topic+getMarkers'></span><span id='topic+removeMarkers'></span><span id='topic+swapGenotypes'></span><span id='topic+modifyMarkerMatrix'></span>

<h3>Description</h3>

<p>Functions for setting and manipulating marker genotypes for 'linkdat'
objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marker(
  x,
  ...,
  allelematrix,
  alleles = NULL,
  afreq = NULL,
  missing = 0,
  chrom = NA,
  pos = NA,
  name = NA,
  mutmat = NULL
)

addMarker(x, m, ...)

setMarkers(x, m, annotations = NULL, missing = 0)

modifyMarker(x, marker, ids, genotype, alleles, afreq, chrom, name, pos)

getMarkers(x, markernames = NULL, chroms = NULL, fromPos = NULL, toPos = NULL)

removeMarkers(
  x,
  markers = NULL,
  markernames = NULL,
  chroms = NULL,
  fromPos = NULL,
  toPos = NULL
)

swapGenotypes(x, ids)

modifyMarkerMatrix(x, ids, new.alleles)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markers_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object</p>
</td></tr>
<tr><td><code id="markers_+3A_...">...</code></td>
<td>
<p>an even number of vectors, indicating individuals and their
genotypes. See examples.</p>
</td></tr>
<tr><td><code id="markers_+3A_allelematrix">allelematrix</code></td>
<td>
<p>a matrix with one row per pedigree member and two columns
per marker, containing the alleles for a single marker.</p>
</td></tr>
<tr><td><code id="markers_+3A_alleles">alleles</code></td>
<td>
<p>a numeric or character vector containing allele names.</p>
</td></tr>
<tr><td><code id="markers_+3A_afreq">afreq</code></td>
<td>
<p>a numerical vector with allele frequencies. An error is given if
they don't sum to 1 (rounded to 3 decimals).</p>
</td></tr>
<tr><td><code id="markers_+3A_missing">missing</code></td>
<td>
<p>a numeric - or character - of length 1, indicating the code
for missing alleles.</p>
</td></tr>
<tr><td><code id="markers_+3A_chrom">chrom</code></td>
<td>
<p>NA or an integer (the chromosome number of the marker).</p>
</td></tr>
<tr><td><code id="markers_+3A_pos">pos</code></td>
<td>
<p>NA or a non-negative real number indicating the genetic position
(in cM) of the marker.</p>
</td></tr>
<tr><td><code id="markers_+3A_name">name</code></td>
<td>
<p>NA or a character (the name of the marker).</p>
</td></tr>
<tr><td><code id="markers_+3A_mutmat">mutmat</code></td>
<td>
<p>a mutation matrix, or a list of two such matrices named
'female' and 'male'. The matrix/matrices must be square, with the allele
labels as dimnames, and each row must sum to 1 (after rounding to 3
decimals).</p>
</td></tr>
<tr><td><code id="markers_+3A_m">m</code></td>
<td>
<p>a <code>marker</code> object or a matrix with alleles. (In
<code>setMarkers</code> this matrix can contain data of several markers.)</p>
</td></tr>
<tr><td><code id="markers_+3A_annotations">annotations</code></td>
<td>
<p>a list of marker annotations.</p>
</td></tr>
<tr><td><code id="markers_+3A_marker">marker</code>, <code id="markers_+3A_markers">markers</code></td>
<td>
<p>a numeric indicating which marker(s) to use/modify.</p>
</td></tr>
<tr><td><code id="markers_+3A_ids">ids</code></td>
<td>
<p>a numeric indicating individual(s) to be modified. In
<code>swapGenotypes</code> this must have length 2.</p>
</td></tr>
<tr><td><code id="markers_+3A_genotype">genotype</code></td>
<td>
<p>a vector of length 1 or 2, containing the genotype to be
given the <code>ids</code> individuals. See examples.</p>
</td></tr>
<tr><td><code id="markers_+3A_markernames">markernames</code></td>
<td>
<p>NULL or a character vector.</p>
</td></tr>
<tr><td><code id="markers_+3A_chroms">chroms</code></td>
<td>
<p>NULL or a numeric vector of chromosome numbers.</p>
</td></tr>
<tr><td><code id="markers_+3A_frompos">fromPos</code>, <code id="markers_+3A_topos">toPos</code></td>
<td>
<p>NULL or a single numeric.</p>
</td></tr>
<tr><td><code id="markers_+3A_new.alleles">new.alleles</code></td>
<td>
<p>a numerical matrix of dimensions <code>length(ids),
2*x$nMark</code>. Entries refer to the internal allele numbering.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>marker</code> function returns an object of class <code>marker</code>:
This is a numerical 2-column matrix with one row per individual, and
attributes 'alleles' (a character vector with allele names), 'nalleles'
(the number of alleles) and 'missing' (the input symbol for missing marker
alleles), 'chrom' (chromosome number), 'name' (marker identifier), 'pos'
(chromosome position in cM).
</p>
<p>For <code>addMarker</code>, <code>setMarkers</code>, <code>removeMarkers</code>,
<code>modifyMarker</code>, <code>modifyMarkerMatrix</code> and <code>swapGenotypes</code>, a
<code>linkdat</code> object is returned, whose <code>markerdata</code> element has been
set/modified.
</p>
<p>For <code>getMarkers</code> a numeric vector containing marker numbers (i.e.
their indices in <code>x$markerdata</code>) for the markers whose 'name'
attribute is contained in <code>markernames</code>, 'chrom' attribute is
contained in <code>chroms</code>, and 'pos' attribute is between <code>from</code> and
<code>to</code>. NULL arguments are skipped, so <code>getMarkers(x)</code> will return
<code>seq_len(x$nMark)</code> (i.e. all markers).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linkdat">linkdat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = linkdat(toyped)
x = removeMarkers(x, 1) # removing the only marker.
x

# Creating and adding a SNP marker with alleles 'a' and 'b', for which
# individual 1 is heterozygous, individuals 2 and 4 are homozygous for the
# 'b' allele, and individual 3 has a missing genotype.
m1 = marker(x, 1, c('a','b'), c(2,4), c('b','b'))
x = addMarker(x, m1)

# A rare SNP for which both children are heterozygous.
# The 'alleles' argument can be skipped, but is recommended to ensure
# correct order of the frequencies.
m2 = marker(x, 3:4, 1:2, alleles=1:2, afreq=c(0.99, 0.01))
x = addMarker(x, m2)

# Modifying the second marker:
# Making it triallelic, and adding a genotype to the father.
x = modifyMarker(x, marker=2, alleles=1:3, ids=1, genotype=2:3)

# Adding an empty SNP (all genotypes are missing):
x = addMarker(x, 0, alleles=c('A', 'B'))

# Similar shortcut for creating a marker for which all
# pedigree members are homozygous for an allele (say 'b'):
x = addMarker(x, 'b')
# Alternative: m = marker(x, 'b'); addMarker(x, m)


</code></pre>

<hr>
<h2 id='markerSim'>Marker simulation</h2><span id='topic+markerSim'></span>

<h3>Description</h3>

<p>Simulates marker genotypes conditional on the pedigree structure, affection
statuses and disease model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>markerSim(
  x,
  N = 1,
  available = NULL,
  alleles = NULL,
  afreq = NULL,
  partialmarker = NULL,
  loop_breakers = NULL,
  eliminate = 0,
  seed = NULL,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="markerSim_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object</p>
</td></tr>
<tr><td><code id="markerSim_+3A_n">N</code></td>
<td>
<p>a positive integer: the number of markers to be simulated</p>
</td></tr>
<tr><td><code id="markerSim_+3A_available">available</code></td>
<td>
<p>a vector containing IDs of the available individuals, i.e.
those whose genotypes should be simulated. By default, all individuals are
included.</p>
</td></tr>
<tr><td><code id="markerSim_+3A_alleles">alleles</code></td>
<td>
<p>a vector containing the alleles for the marker to be
simulation. If a single integer is given, this is interpreted as the number
of alleles, and the actual alleles as <code>1:alleles</code>. Must be NULL if
<code>partialmarker</code> is non-NULL.</p>
</td></tr>
<tr><td><code id="markerSim_+3A_afreq">afreq</code></td>
<td>
<p>a vector of length 2 containing the population frequencies for
the marker alleles. Must be NULL if <code>partialmarker</code> is non-NULL.</p>
</td></tr>
<tr><td><code id="markerSim_+3A_partialmarker">partialmarker</code></td>
<td>
<p>Either NULL (resulting in unconditional simulation), a
marker object (on which the simulation should be conditioned) or the index
of an existing marker of <code>x</code>.</p>
</td></tr>
<tr><td><code id="markerSim_+3A_loop_breakers">loop_breakers</code></td>
<td>
<p>a numeric containing IDs of individuals to be used as
loop breakers. Relevant only if the pedigree has loops, and only if
<code>partialmarker</code> is non-NULL. See <code><a href="#topic+breakLoops">breakLoops</a></code>.</p>
</td></tr>
<tr><td><code id="markerSim_+3A_eliminate">eliminate</code></td>
<td>
<p>A non-negative integer, indicating the number of iterations
in the internal genotype-compatibility algorithm. Positive values can save
time if <code>partialmarker</code> is non-NULL and the number of alleles is
large.</p>
</td></tr>
<tr><td><code id="markerSim_+3A_seed">seed</code></td>
<td>
<p>NULL, or a numeric seed for the random number generator.</p>
</td></tr>
<tr><td><code id="markerSim_+3A_verbose">verbose</code></td>
<td>
<p>a logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This implements (with various time savers) the algorithm used in SLINK of the
LINKAGE/FASTLINK suite. If <code>partialmarker</code> is NULL, genotypes are
simulated by simple gene dropping, using <code><a href="#topic+simpleSim">simpleSim</a></code>.
</p>


<h3>Value</h3>

<p>a <code>linkdat</code> object equal to <code>x</code> except its
<code>markerdata</code> entry, which consists of the <code>N</code> simulated markers.
</p>


<h3>References</h3>

<p>G. M. Lathrop, J.-M. Lalouel, C. Julier, and J. Ott,
<em>Strategies for Multilocus Analysis in Humans</em>, PNAS 81(1984), pp.
3443-3446.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simpleSim">simpleSim</a></code>, <code><a href="#topic+linkage.power">linkage.power</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = nuclearPed(2)
partial = marker(x, 3, 1, alleles=1:3)
markerSim(x, N=1, alleles=1:3)
markerSim(x, N=1, partialmarker=partial)
markerSim(x, N=1, partialmarker=partial)
markerSim(x, N=1, available=4, partialmarker=partial)

</code></pre>

<hr>
<h2 id='mendelianCheck'>Check for Mendelian errors</h2><span id='topic+mendelianCheck'></span>

<h3>Description</h3>

<p>Check marker data for Mendelian inconsistencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mendelianCheck(x, remove = FALSE, verbose = !remove)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mendelianCheck_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object</p>
</td></tr>
<tr><td><code id="mendelianCheck_+3A_remove">remove</code></td>
<td>
<p>a logical. If FALSE, the function returns the indices of
markers found to incorrect.  If TRUE, a new <code>linkdat</code> object is
returned, where the incorrect markers have been deleted.</p>
</td></tr>
<tr><td><code id="mendelianCheck_+3A_verbose">verbose</code></td>
<td>
<p>a logical. If TRUE, details of the markers failing the tests
are shown.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric containing the indices of the markers that did not pass the
tests, or (if <code>remove=TRUE</code>) a new <code>linkdat</code> object where the
failing markers are removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = nuclearPed(3)

# Adding a SNP with a mendelian error:
# Individual 3 has an allele 'c' not carried by either parents
m1 = marker(x, 1, c('a','a'), 2, c('a','b'), 3, c('a','c'))

# Another erroneous marker: The siblings carry more than 4 different alleles.
m2 = marker(x, 3, c(1,2), 4, c(3,4), 5, c(1,5))

# Another marker with incosistent genotypes among the siblings:
m3 = marker(x, 3, c(1,1), 4, c(2,2), 5, c(3,3))

# Another marker with incosistent genotypes among the siblings:
m4 = marker(x, 3, c(1,1), 4, c(2,3), 5, c(1,4))

# A correct marker (all homozygous for allele 'A')
m5 = marker(x, 1:5, 'A')

# An empty marker
m6 = marker(x)

x = setMarkers(x, list(m1,m2,m3,m4,m5,m6))

# Finding the errors
err_index = mendelianCheck(x, remove=FALSE)
stopifnot(all.equal(err_index, 1:4))

x_remove = mendelianCheck(x, remove=TRUE)
stopifnot(x_remove$nMark == 2)

</code></pre>

<hr>
<h2 id='mergePed'>Merge two pedigrees</h2><span id='topic+mergePed'></span>

<h3>Description</h3>

<p>This function merges two linkdat objects, joining them at the individuals
with equal ID labels. This is especially useful for building 'top-heavy'
pedigrees. Only linkdat objects without marker data are supported.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergePed(x, y, quick = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergePed_+3A_x">x</code>, <code id="mergePed_+3A_y">y</code></td>
<td>
<p><code><a href="#topic+linkdat">linkdat</a></code> objects</p>
</td></tr>
<tr><td><code id="mergePed_+3A_quick">quick</code></td>
<td>
<p>a single logical. If TRUE, no pedigree checks are performed, and
the individual ordering may be unfortunate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>linkdat</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Creating a trio where each parent have first cousin parents.
# (Alternatively, this could be built using many calls to addParents().)

x = cousinPed(1)
x = addOffspring(x, father=7, mother=8, noffs=1, id=9)
x = addOffspring(x, father=9, mother=10, noffs=1, id=11)

y = relabel(cousinPed(1), 101:108)
y = addOffspring(y, father=107, mother=108, noffs=1, sex=2, id=10)
y = addOffspring(y, father=9, mother=10, noffs=1, id=11)

# Joining x and y at the common individuals 9,10,11:
z = mergePed(x,y)

# plot all three pedigrees
op = par(mfrow = c(1,3))
plot(x); plot(y); plot(z)
par(op)

</code></pre>

<hr>
<h2 id='merlin'>MERLIN wrappers</h2><span id='topic+merlin'></span><span id='topic+merlinUnlikely'></span>

<h3>Description</h3>

<p>Wrappers for the MERLIN software, providing multipoint LOD scores and other
computations on pedigrees with marker data. These functions require MERLIN to
be installed and correctly pointed to in the PATH environment variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merlin(
  x,
  markers = seq_len(x$nMark),
  model = TRUE,
  theta = NULL,
  options = "",
  verbose = FALSE,
  generate.files = TRUE,
  cleanup = generate.files,
  logfile = ""
)

merlinUnlikely(x, remove = FALSE, verbose = !remove)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merlin_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object</p>
</td></tr>
<tr><td><code id="merlin_+3A_markers">markers</code></td>
<td>
<p>an integer vector indicating which markers to use (default:
all).</p>
</td></tr>
<tr><td><code id="merlin_+3A_model">model</code></td>
<td>
<p>a logical: If TRUE (and x$model is not NULL), the file
'merlin.model' is created and '&ndash;model merlin.model' is included to the
MERLIN command.</p>
</td></tr>
<tr><td><code id="merlin_+3A_theta">theta</code></td>
<td>
<p>a numeric with values between 0 and 0.5: The recombination
value(s) for which the LOD score is computed.  The values of <code>theta</code>
are converted to centiMorgan positions using the Haldane map function and
included in the MERLIN command using the <code>--position</code> parameter. Works
only for single markers (i.e. <code>markers</code> must consist of a single
integer).</p>
</td></tr>
<tr><td><code id="merlin_+3A_options">options</code></td>
<td>
<p>a character with additional options to the MERLIN command. See
details.</p>
</td></tr>
<tr><td><code id="merlin_+3A_verbose">verbose</code></td>
<td>
<p>a logical: Show MERLIN output and other information, or not.</p>
</td></tr>
<tr><td><code id="merlin_+3A_generate.files">generate.files</code></td>
<td>
<p>a logical. If TRUE, the files 'merlin.ped',
'merlin.dat', 'merlin.map', 'merlin.freq' and (if <code>model=TRUE</code>)
'merlin.model' are created in the working directory.</p>
</td></tr>
<tr><td><code id="merlin_+3A_cleanup">cleanup</code></td>
<td>
<p>a logical: Should the MERLIN files be deleted automatically?</p>
</td></tr>
<tr><td><code id="merlin_+3A_logfile">logfile</code></td>
<td>
<p>a character. If this is given, the MERLIN screen output will
be written to a file with this name.</p>
</td></tr>
<tr><td><code id="merlin_+3A_remove">remove</code></td>
<td>
<p>a logical. If FALSE, the function returns the indices of
markers found to unlikely.  If TRUE, a new <code>linkdat</code> object is
returned, where the unlikely markers have been deleted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For these functions to work, MERLIN must be installed and the path to
merlin.exe included in the PATH variable. The <code>merlin</code> function is first
and foremost a wrapper to the parametric linkage functionality of MERLIN.
</p>
<p>By default the following MERLIN command is run (via a call to
<code><a href="base.html#topic+system">system</a></code>) after creating appropriate files in the current working
directory:
</p>
<pre>
_merlin.freq --model _merlin.model --tabulate --markerNames --quiet</pre>
<p>The resulting multipoint LOD scores are extracted from the output and
returned in R as a <code><a href="#topic+linkres">linkres</a></code> object.
</p>
<p>Additional command parameters can be passed on using the <code>options</code>
argument (this is simply pasted onto the MERLIN command, so dashes must be
included). For example, to obtain singlepoint LOD scores instead of
multipoint, set <code>options='--singlepoint'</code>. (The singlepoint scores
should agree with the results of <code>lod(x)</code>, except in cases where some
individuals have partial genotypes (see Examples).)
</p>
<p>If <code>model=FALSE</code> the <code>--model merlin.model</code> part is removed from
the MERLIN command above. This is necessary for some calculations, e.g.
likelihoods (see Examples).
</p>
<p>The <code>merlinUnlikely</code> function is a wrapper for MERLIN's '&ndash;error'
command. The syntax is similar to that of <code><a href="#topic+mendelianCheck">mendelianCheck</a></code>.
</p>


<h3>Value</h3>

<p>If <code>model=TRUE</code>, a <code><a href="#topic+linkres">linkres</a></code> object. Otherwise a
character containing the complete MERLIN output.
</p>
<p>For <code>merlinUnlikely</code>, a numeric containing the indices of the
unlikely, or (if <code>remove=TRUE</code>) a new <code>linkdat</code> object where the
unlikely markers are removed.
</p>


<h3>References</h3>

<p><a href="http://csg.sph.umich.edu/abecasis/Merlin/">http://csg.sph.umich.edu/abecasis/Merlin/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
x = linkdat(toyped, model=1)
x

# MERLIN treats partial genotypes (i.e. one known and one unknown allele) as missing:
lod_merlin = merlin(x)
lod_partial = lod(x)
x = modifyMarker(x, marker=1, ids=1, genotype=0)
lod_missing = lod(x)
stopifnot(lod_merlin == round(lod_missing, 4))

# Likelihood computation by MERLIN:
merlin(x, model=F, options='--lik')

## End(Not run)

</code></pre>

<hr>
<h2 id='oneMarkerDistribution'>Genotype probability distribution</h2><span id='topic+oneMarkerDistribution'></span>

<h3>Description</h3>

<p>Computes the (joint) genotype probability distribution of one or several
pedigree members, possibly conditional on partial marker data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>oneMarkerDistribution(
  x,
  ids,
  partialmarker,
  theta = NULL,
  grid.subset = NULL,
  loop_breakers = NULL,
  eliminate = 0,
  ignore.affection.status = FALSE,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="oneMarkerDistribution_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+linkdat">linkdat</a></code> object.</p>
</td></tr>
<tr><td><code id="oneMarkerDistribution_+3A_ids">ids</code></td>
<td>
<p>A numeric with ID labels of one or more pedigree members.</p>
</td></tr>
<tr><td><code id="oneMarkerDistribution_+3A_partialmarker">partialmarker</code></td>
<td>
<p>Either a <code><a href="#topic+marker">marker</a></code> object compatible with
<code>x</code>, or the index (a single integer) of an existing marker of
<code>x</code>.</p>
</td></tr>
<tr><td><code id="oneMarkerDistribution_+3A_theta">theta</code></td>
<td>
<p>The recombination fraction between marker and disease locus.
Only relevant if at least one individual is affected by disease. In that
case an error is raised if <code>theta</code> is NULL, and if <code>x</code> does not
have a disease model.</p>
</td></tr>
<tr><td><code id="oneMarkerDistribution_+3A_grid.subset">grid.subset</code></td>
<td>
<p>(Not relevant for most end users.) A numeric matrix
describing a subset of all marker genotype combinations for the <code>ids</code>
individuals. The matrix should have one column for each of the <code>ids</code>
individuals, and one row for each combination: The genotypes are described
in terms of the matrix <code>M = allGenotypes(n)</code>, where <code>n</code> is the
number of alleles for the marker. If the entry in column <code>j</code> is the
integer <code>k</code>, this means that the genotype of individual <code>ids[j]</code>
is row <code>k</code> of <code>M</code>.</p>
</td></tr>
<tr><td><code id="oneMarkerDistribution_+3A_loop_breakers">loop_breakers</code></td>
<td>
<p>A numeric containing IDs of individuals to be used as
loop breakers. Relevant only if the pedigree has loops. See
<code><a href="#topic+breakLoops">breakLoops</a></code>.</p>
</td></tr>
<tr><td><code id="oneMarkerDistribution_+3A_eliminate">eliminate</code></td>
<td>
<p>A non-negative integer, indicating the number of iterations
in the internal genotype-compatibility algorithm. Positive values can save
time if <code>partialmarker</code> is non-empty and the number of alleles is
large.</p>
</td></tr>
<tr><td><code id="oneMarkerDistribution_+3A_ignore.affection.status">ignore.affection.status</code></td>
<td>
<p>A logical indicating if the 'AFF' column
should be ignored (only relevant if some family members are marked as
affected).</p>
</td></tr>
<tr><td><code id="oneMarkerDistribution_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named array (of dimension <code>length(ids)</code>) giving the joint
marker genotype distribution for the <code>ids</code> individuals, conditional on
1) the marker allele frequencies given in <code>partialmarker</code>, 2)
non-missing alleles in <code>partialmarker</code>, and 3) the disease model of
<code>x</code> (if the pedigree is affected).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+twoMarkerDistribution">twoMarkerDistribution</a></code>, <code><a href="#topic+allGenotypes">allGenotypes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = nuclearPed(2)
x_aff = swapAff(x, c(1,3))
x_aff = setModel(x_aff, model=1) # dominant model

snp = marker(x, 1, c(1,1), 2, c(1,0), alleles=1:2, afreq=c(0.1, 0.9))
res1 = oneMarkerDistribution(x, ids=3:4, partialmarker=snp)
res2 = oneMarkerDistribution(x_aff, ids=3:4, partialmarker=snp, theta=0.5)

# should give same result, since theta=0.5 implies that marker is independent of disease.
stopifnot(all.equal(res1, res2))

#### Different example for the same pedigree. A marker with 4 alleles:
m2 = marker(x, 3:4, c('C','D'), alleles=LETTERS[1:4])
oneMarkerDistribution(x, ids=1, partialmarker=m2)

# Same as above, but computing only the cases where individual 1 is heterozygous.
# (The numbers 5:10 refer to the 6 last rows of allGenotypes(4),
# which contain the heterozygous genotypes.)
oneMarkerDistribution(x, ids=1, partialmarker=m2, grid.subset=matrix(5:10, ncol=1))

#### Expanding on the previous example:
# Joint genotype probabilities of the parents, but including only the combinations
# where the father is heterozygous and the mother is homozygous:
grid = expand.grid(5:10, 1:4)
oneMarkerDistribution(x, ids=1:2, partialmarker=m2, grid.subset=grid)

#### Something else:
# The genotype distribution of an individual whose half cousin is homozygous
# for a rare allele.
y = halfCousinPed(degree=1)
snp = marker(y, 9, c('a','a'), alleles=c('a', 'b'), afreq=c(0.01, 0.99))
oneMarkerDistribution(y, ids=8, partialmarker=snp)

#### X-linked example:
z = linkdat(Xped, model=4) # X-linked recessive model
z2 = swapAff(z, 1:z$nInd, 1) # disease free version of the same pedigree

snpX = marker(z, c(5,15), c('A','A'), alleles=c('A', 'B'), chrom=23)

r1 = oneMarkerDistribution(z, ids=13, partialmarker=snpX, theta=0.5) # results: A - 0.8; B - 0.2
r2 = oneMarkerDistribution(z2, ids=13, partialmarker=snpX)          # should be same as above
r3 = oneMarkerDistribution(z, ids=13, partialmarker=snpX, theta=0) # results: A - 0.67; B - 0.33

stopifnot(all.equal(r1,r2), round(r1[1], 2)==0.8, round(r3[1], 2) == 0.67)

</code></pre>

<hr>
<h2 id='pedCreate'>Create simple pedigrees</h2><span id='topic+pedCreate'></span><span id='topic+nuclearPed'></span><span id='topic+cousinsPed'></span><span id='topic+halfCousinsPed'></span><span id='topic+doubleCousins'></span><span id='topic+doubleFirstCousins'></span><span id='topic+quadHalfFirstCousins'></span><span id='topic+fullSibMating'></span><span id='topic+halfSibStack'></span><span id='topic+cousinPed'></span><span id='topic+halfCousinPed'></span>

<h3>Description</h3>

<p>These are utility functions for creating some common pedigree structures as
<code>linkdat</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nuclearPed(noffs, sex)

cousinsPed(degree, removal = 0, degree2 = NULL, child = FALSE)

halfCousinsPed(degree, removal = 0, degree2 = NULL, child = FALSE)

doubleCousins(degree1, degree2, removal1 = 0, removal2 = 0, child = FALSE)

doubleFirstCousins()

quadHalfFirstCousins()

fullSibMating(generations)

halfSibStack(generations)

cousinPed(degree)

halfCousinPed(degree)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedCreate_+3A_noffs">noffs</code></td>
<td>
<p>A positive integer, the number of offspring in the nuclear
family.</p>
</td></tr>
<tr><td><code id="pedCreate_+3A_sex">sex</code></td>
<td>
<p>A vector of length <code>noffs</code>; indicating the genders (1=male,
2=female) of the offspring. If missing, all offspring are taken to be
males.</p>
</td></tr>
<tr><td><code id="pedCreate_+3A_degree">degree</code>, <code id="pedCreate_+3A_degree1">degree1</code>, <code id="pedCreate_+3A_degree2">degree2</code></td>
<td>
<p>Non-negative integers, indicating the degree of
cousin-like relationships: 0=siblings, 1=first cousins; 2=second cousins,
a.s.o. See Details and Examples.</p>
</td></tr>
<tr><td><code id="pedCreate_+3A_removal">removal</code>, <code id="pedCreate_+3A_removal1">removal1</code>, <code id="pedCreate_+3A_removal2">removal2</code></td>
<td>
<p>Non-negative integers, indicating removals
of cousin-like relationships. See Details and Examples.</p>
</td></tr>
<tr><td><code id="pedCreate_+3A_child">child</code></td>
<td>
<p>A logical: Should an inbred child be added to the two cousins?</p>
</td></tr>
<tr><td><code id="pedCreate_+3A_generations">generations</code></td>
<td>
<p>A positive integer indicating the number of crossings.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All individuals are created as unaffected. Use <code><a href="#topic+swapAff">swapAff</a></code> to edit
this (see Examples). Use <code><a href="#topic+swapSex">swapSex</a></code> to change gender of pedigree
members.
</p>
<p>The call <code>cousinsPed(degree=n, removal=k)</code> creates a pedigree with two
n'th cousins, k times removed. By default, removals are added on the right
side. To override this, the parameter <code>degree2</code> can be used to indicate
explicitly the number of generations on the right side of the pedigree. When
<code>degree2</code> is given <code>removal</code> is ignored. (Similarly for
<code>halfCousinsPed</code>.)
</p>
<p>The function <code>doubleCousins</code> creates two individuals whose fathers are
cousins (<code>degree1</code>, <code>removal1</code>) as well as their mothers
(<code>degree2</code>, <code>removal2</code>). For simplicity, a wrapper
<code>doubleFirstCousins</code> is provided for the most common case, double first
cousins. Finally <code>quadHalfFirstCousins</code> produces a pedigree with
quadruple half first cousins.
</p>
<p><code>fullSibMating</code> crosses full sibs continuously for the indicated number
of generations.
</p>
<p><code>halfSibStack</code> produces a breeding scheme where the two individuals in
the final generation are simultaneously half siblings and half n'th cousins,
where <code>n=1,...,generations</code>.
</p>
<p><code>cousinPed</code> and <code>halfCousinPed</code> (written without the 's') are
depreciated functions kept for backwards compatibility. They create cousin
pedigrees, but without possibility for removals, and with a different
ordering than their replacements <code>cousinsPed</code> and <code>halfCousinsPed</code>.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+linkdat">linkdat</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+swapAff">swapAff</a></code>, <code><a href="#topic+swapSex">swapSex</a></code>,
<code><a href="#topic+removeIndividuals">removeIndividuals</a></code>, <code><a href="#topic+addOffspring">addOffspring</a></code>,
<code><a href="#topic+relabel">relabel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A nuclear family with 2 boys and 3 girls,
# where the father and the two boys are affected.
x = nuclearPed(noffs=5, sex=c(1,1,2,2,2))
x = swapAff(x, ids=c(1,3,4))

# Half sibs:
halfCousinsPed(degree=0)

# Grand aunt:
cousinsPed(degree=0, removal=2)

# Second cousins once removed.
cousinsPed(degree=2, removal=1)

# Again second cousins once removed,
# but with the 'removal' on the left side.
cousinsPed(degree=3, degree2=2)

# A child of first cousin parents.
cousinsPed(degree=1, child=TRUE)

# Consecutive brother-sister matings.
fullSibMating(3)

# Simultaneous half siblings and half first cousins
halfSibStack(2)

# Double first cousins
doubleFirstCousins()

# Quadruple half first cousins
# Weird plotting behaviour for this pedigree.
x = quadHalfFirstCousins()
#plot(x)

</code></pre>

<hr>
<h2 id='pedigreeLoops'>Pedigree loops</h2><span id='topic+pedigreeLoops'></span><span id='topic+breakLoops'></span><span id='topic+tieLoops'></span><span id='topic+findLoopBreakers'></span><span id='topic+findLoopBreakers2'></span>

<h3>Description</h3>

<p>Functions for identifying, breaking and restoring loops in pedigrees.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pedigreeLoops(x)

breakLoops(x, loop_breakers = NULL, verbose = TRUE)

tieLoops(x)

findLoopBreakers(x)

findLoopBreakers2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedigreeLoops_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object.</p>
</td></tr>
<tr><td><code id="pedigreeLoops_+3A_loop_breakers">loop_breakers</code></td>
<td>
<p>either NULL (resulting in automatic selection of loop
breakers) or a numeric containing IDs of individuals to be used as loop
breakers.</p>
</td></tr>
<tr><td><code id="pedigreeLoops_+3A_verbose">verbose</code></td>
<td>
<p>a logical: Verbose output or not?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most of paramlink's handling of pedigree loops is done under the hood - using
the functions described here - without need for explicit action from end
users. When a linkdat object <code>x</code> is created, an internal routine detects
if the pedigree contains loops, in which case <code>x$hasLoops</code> is set to
TRUE. In analyses of <code>x</code> where loops must be broken (e.g. lod score
computation or marker simulation), this is done automatically by calling
<code>breakLoops</code>.
</p>
<p>In some cases with complex inbreeding, it can be instructive to plot the
pedigree after breaking the loops. Duplicated individuals are plotted with
appropriate labels (see examples).
</p>
<p>The function <code>findLoopBreakers</code> identifies a set of individuals breaking
all inbreeding loops, but not marriage loops. These require more machinery
for efficient detection, and paramlink does this is a separate function,
<code>findLoopBreakers2</code>, utilizing methods from the <code>igraph</code> package.
Since this is rarely needed for most users, <code>igraph</code> is not imported
when loading paramlink, only when <code>findLoopBreakers2</code> is called.
</p>
<p>In practice, <code>breakLoops</code> first calls <code>findLoopBreakers</code> and breaks
at the returned individuals. If the resulting linkdat object still has loops,
<code>findLoopBreakers2</code> is called to break any marriage loops.
</p>


<h3>Value</h3>

<p>For <code>breakLoops</code>, a <code>linkdat</code> object in which the indicated
loop breakers are duplicated. The returned object will also have a non-null
<code>loop_breakers</code> entry, namely a matrix with the IDs of the original
loop breakers in the first column and the duplicates in the second.
</p>
<p>For <code>tieLoops</code>, a <code>linkdat</code> object in which any duplicated
individuals (as given in the <code>x$loop_breakers</code> entry) are merged. For
any linkdat object <code>x</code>, the call <code>tieLoops(breakLoops(x))</code> should
return <code>x</code>.
</p>
<p>For <code>pedigreeLoops</code>, a list containing all inbreeding loops (not
marriage loops) found in the pedigree. Each loop is represented as a list
with elements 'top', a 'bottom' individual, 'pathA' (individuals forming a
path from top to bottom) and 'pathB' (creating a different path from top to
bottom, with no individuals in common with pathA). Note that the number of
loops reported here counts all closed paths in the pedigree and will in
general be larger than the genus of the underlying graph.
</p>
<p>For <code>findLoopBreakers</code> and <code>findLoopBreakers2</code>, a numeric vector
of individual ID's.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = cousinsPed(1, child=TRUE)

# Make the child affected, and homozygous for rare allele.
x = swapAff(x, 9)
x = setMarkers(x, marker(x, 9, c(2,2), alleles=1:2, afreq=c(0.99, 0.01)))

# Compute the LOD score under a recessive model. Loops are automatically broken in lod().
x = setModel(x, 2)
LOD1 = lod(x, theta=0.1)
stopifnot(round(LOD1, 2) == 0.88)

# Or we can break the loop manually before computing the LOD:
loopfree = breakLoops(x, loop_breaker=8)
plot(loopfree)
LOD2 = lod(loopfree, theta=0.1)
stopifnot(all.equal(x, tieLoops(loopfree)))
stopifnot(all.equal(LOD1, LOD2))

# Pedigree with marriage loop: Double first cousins
if(requireNamespace("igraph", quietly = TRUE)) {
    y = doubleCousins(1, 1, child=TRUE)
    findLoopBreakers(y) # --&gt; 9
    findLoopBreakers2(y) # --&gt; 9 and 4
    breakLoops(y) # uses both 9 and 4
}

</code></pre>

<hr>
<h2 id='pedModify'>Modify the pedigree of 'linkdat' objects</h2><span id='topic+pedModify'></span><span id='topic+swapSex'></span><span id='topic+swapAff'></span><span id='topic+addOffspring'></span><span id='topic+addSon'></span><span id='topic+addDaughter'></span><span id='topic+addParents'></span><span id='topic+removeIndividuals'></span><span id='topic+branch'></span><span id='topic+trim'></span><span id='topic+relabel'></span>

<h3>Description</h3>

<p>Functions to modify the pedigree of a 'linkdat' object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swapSex(x, ids, verbose = TRUE)

swapAff(x, ids, newval = NULL)

addOffspring(
  x,
  father,
  mother,
  noffs,
  ids = NULL,
  sex = 1,
  aff = 1,
  verbose = TRUE
)

addSon(x, parent, id = NULL, aff = 1, verbose = TRUE)

addDaughter(x, parent, id = NULL, aff = 1, verbose = TRUE)

addParents(x, id, father, mother, verbose = TRUE)

removeIndividuals(x, ids, verbose = TRUE)

branch(x, id)

trim(x, keep = c("available", "affected"), return.ids = FALSE, verbose = TRUE)

relabel(x, new, old)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedModify_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+linkdat">linkdat</a></code> object</p>
</td></tr>
<tr><td><code id="pedModify_+3A_verbose">verbose</code></td>
<td>
<p>A logical: Verbose output or not.</p>
</td></tr>
<tr><td><code id="pedModify_+3A_newval">newval</code></td>
<td>
<p>A numeric, indicating affection status values for the
<code>ids</code> individuals: 1=unaffected, 2=affected, 0=unknown. If NULL, the
affection statuses are swapped 1 &lt;-&gt; 2, hence the main use of the
<code>newval</code> argument is to assign 0's.</p>
</td></tr>
<tr><td><code id="pedModify_+3A_father">father</code>, <code id="pedModify_+3A_mother">mother</code></td>
<td>
<p>Integers indicating the IDs of parents. If missing, a
new founder individual is created (whose ID will be 1+the largest ID
already in the pedigree).</p>
</td></tr>
<tr><td><code id="pedModify_+3A_noffs">noffs</code></td>
<td>
<p>A single integer indicating the number of offspring to be
created.</p>
</td></tr>
<tr><td><code id="pedModify_+3A_sex">sex</code>, <code id="pedModify_+3A_aff">aff</code></td>
<td>
<p>Integer vectors indicating the gender and affection statuses
of the offspring to be created (recycled if less than <code>noffs</code>
elements).</p>
</td></tr>
<tr><td><code id="pedModify_+3A_parent">parent</code></td>
<td>
<p>Integer ID of any pedigree member, which will be the father or
mother (depending on its gender) of the new child.</p>
</td></tr>
<tr><td><code id="pedModify_+3A_id">id</code>, <code id="pedModify_+3A_ids">ids</code></td>
<td>
<p>Individual ID label(s). In <code>addOffspring</code> the (optional)
<code>ids</code> argument is used to specify ID labels for the offspring to be
created.</p>
</td></tr>
<tr><td><code id="pedModify_+3A_keep">keep</code></td>
<td>
<p>A character, either 'available' (trimming the pedigree for
unavailable members) or 'affected' (trimming for unaffected members).</p>
</td></tr>
<tr><td><code id="pedModify_+3A_return.ids">return.ids</code></td>
<td>
<p>A logical. If FALSE, the trimmed pedigree is returned as a
new <code>linkdat</code> object. If TRUE, a vector containing the IDs of
'removable' individuals is returned</p>
</td></tr>
<tr><td><code id="pedModify_+3A_new">new</code></td>
<td>
<p>a numeric containing new labels to replace those in <code>old</code>.</p>
</td></tr>
<tr><td><code id="pedModify_+3A_old">old</code></td>
<td>
<p>a numeric containing ID labels to be replaced by those in
<code>new</code>. If missing, <code>old</code> is set to <code>x$orig.ids</code>, i.e. all
members in their original order.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When removing an individual, all descendants are also removed as well as
founders remaining without offspring.
</p>
<p>The <code>branch()</code> function extracts the pedigree subset consisting of all
descendants of <code>id</code>, including <code>id</code> itself and all relevant
spouses.
</p>


<h3>Value</h3>

<p>The modified <code>linkdat</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linkdat">linkdat</a></code>, <code><a href="#topic+nuclearPed">nuclearPed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = linkdat(toyped)

# To see the effect of each command below, use plot(x) in between.
x = addParents(x, id=2, father=5, mother=6)

x = swapSex(x, c(1,5))
x = swapSex(x, c(2,6))

x = addOffspring(x, mother=6, noffs=2, id=c(7,10))
x = removeIndividuals(x, 3)
x = swapAff(x, c(4,10))

stopifnot(setequal(x$orig.ids, c(1,2,4,5,6,7,10,11)))

# Trimming a pedigree
x = linkdat(dominant)
x_affectedOnly = trim(x, keep='affected')

unavail = trim(x, keep='available', return.ids=TRUE)
nonaff = trim(x, keep='affected', return.ids=TRUE)
stopifnot(setequal(unavail, c(5, 19:23)), setequal(nonaff, c(6:7, 12:13, 19:23)))

</code></pre>

<hr>
<h2 id='pedParts'>Pedigree subsets</h2><span id='topic+pedParts'></span><span id='topic+offspring'></span><span id='topic+spouses'></span><span id='topic+related.pairs'></span><span id='topic+unrelated'></span><span id='topic+leaves'></span><span id='topic+parents'></span><span id='topic+grandparents'></span><span id='topic+siblings'></span><span id='topic+cousins'></span><span id='topic+nephews_nieces'></span><span id='topic+ancestors'></span><span id='topic+descendants'></span>

<h3>Description</h3>

<p>Utility functions for 'linkdat' objects, mainly for extracting various
pedigree information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>offspring(x, id, original.id = TRUE)

spouses(x, id, original.id = TRUE)

related.pairs(
  x,
  relation = c("parents", "siblings", "grandparents", "nephews_nieces", "cousins",
    "spouses", "unrelated"),
  available = F,
  interfam = c("none", "founders", "all"),
  ...
)

unrelated(x, id, original.id = TRUE)

leaves(x)

parents(x, id, original.id = TRUE)

grandparents(x, id, degree = 2, original.id = TRUE)

siblings(x, id, half = NA, original.id = TRUE)

cousins(x, id, degree = 1, removal = 0, half = NA, original.id = TRUE)

nephews_nieces(x, id, removal = 1, half = NA, original.id = TRUE)

ancestors(x, id)

descendants(x, id, original.id = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pedParts_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object. In <code>related.pairs</code> possibly a
list of <code>linkdat</code> objects.</p>
</td></tr>
<tr><td><code id="pedParts_+3A_id">id</code></td>
<td>
<p>a numerical ID label.</p>
</td></tr>
<tr><td><code id="pedParts_+3A_original.id">original.id</code></td>
<td>
<p>a logical indicating whether 'id' refers to the original
ID label or the internal labeling.</p>
</td></tr>
<tr><td><code id="pedParts_+3A_relation">relation</code></td>
<td>
<p>one of the words (possibly truncated) <code>parents</code>,
<code>siblings</code>, <code>grandparents</code>, <code>nephews_nieces</code>,
<code>cousins</code>, <code>spouses</code>, <code>unrelated</code>.</p>
</td></tr>
<tr><td><code id="pedParts_+3A_available">available</code></td>
<td>
<p>a logical, if TRUE only pairs of available individuals are
returned.</p>
</td></tr>
<tr><td><code id="pedParts_+3A_interfam">interfam</code></td>
<td>
<p>one of the words (possibly truncated) <code>none</code>,
<code>founders</code> or <code>all</code>, specifying which interfamiliar pairs should
be included as unrelated in the case where <code>x</code> is a list of several
pedigrees. If <code>none</code>, only intrafamiliar pairs are considered; if
<code>founders</code> all interfamiliar pairs of (available) founders are
included; if <code>all</code>, all interfamiliar (available) pairs are included.</p>
</td></tr>
<tr><td><code id="pedParts_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
<tr><td><code id="pedParts_+3A_degree">degree</code></td>
<td>
<p>a non-negative integer.</p>
</td></tr>
<tr><td><code id="pedParts_+3A_half">half</code></td>
<td>
<p>a logical or NA. If TRUE (resp FALSE), only half (resp. full)
siblings/cousins/nephews/nieces are returned. If NA, both categories are
included.</p>
</td></tr>
<tr><td><code id="pedParts_+3A_removal">removal</code></td>
<td>
<p>a non-negative integer</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>ancestors(x,id)</code>, a vector containing the ID's of all
ancestors of the individual <code>id</code>.  For <code>descendants(x,id)</code>, a
vector containing the ID's of all descendants (i.e. children,
grandchildren, a.s.o.) of individual <code>id</code>.
</p>
<p>The functions <code>cousins</code>, <code>grandparents</code>, <code>nephews_nieces</code>,
<code>offspring</code>, <code>parents</code>, <code>siblings</code>, <code>spouses</code>,
<code>unrelated</code>, each returns an integer vector containing the ID's of all
pedigree members having the specified relationship with <code>id</code>.
</p>
<p>For <code>related.pairs</code> a matrix with two columns. Each row gives of a
pair of pedigree members with the specified relation. If the input is a
list of multiple pedigrees, the matrix entries are characters of the form
'X-Y' where X is the family ID and Y the individual ID of the person.
</p>
<p>For <code>leaves</code>, a vector of IDs containing all pedigree members without
children.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
p = cbind(ID=2:9, FID=c(0,0,2,0,4,4,0,2), MID=c(0,0,3,0,5,5,0,8),
        SEX=c(1,2,1,2,1,2,2,2), AFF=c(2,1,2,1,2,1,1,2))
x = linkdat(p)
stopifnot(setequal(spouses(x, 2), c(3,8)),
          setequal(offspring(x, 2), c(4,9)),
          setequal(descendants(x, 2), c(4,6,7,9)),
          setequal(leaves(x), c(6,7,9)))

# Creating a loop and detecting it with 'pedigreeLoops'
# (note that we get two loops, one for each inbred child):
loopx = addOffspring(x, father=4, mother=9, noffs=2)
lps = pedigreeLoops(loopx)
stopifnot(lps[[1]]$top == 2, setequal(sapply(lps, '[[', 'bottom'), 10:11))

# We add genotypes for a single SNP marker and compute a LOD score under a dominant model.
loopx = setMarkers(loopx, cbind(1,c(2,1,2,1,2,1,1,2,1,1)))
loopx = setModel(loopx, 1)

# Loops are automatically broken in lod():
LOD1 = lod(loopx, theta=0.1)
stopifnot(round(LOD1, 3) == 1.746)

# Or we can break the loop manually before computing the LOD:
loopfree = breakLoops(loopx, loop_breaker=4)
LOD2 = lod(loopfree, theta=0.1)
stopifnot(all.equal(loopx, tieLoops(loopfree)))
stopifnot(all.equal(LOD1, LOD2))

</code></pre>

<hr>
<h2 id='plot.linkdat'>Plot pedigrees with genotypes</h2><span id='topic+plot.linkdat'></span><span id='topic+plot.singleton'></span>

<h3>Description</h3>

<p>This is the main function for pedigree plotting, with many options for
controlling the appearance of pedigree symbols, labels and marker genotypes.
Most of the work is done by the plotting functionality in the 'kinship2'
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'linkdat'
plot(
  x,
  marker = NULL,
  alleles = NULL,
  sep = "/",
  missing = "-",
  skip.empty.genotypes = FALSE,
  id.labels = NULL,
  title = NULL,
  available = FALSE,
  col = 1,
  deceased = numeric(0),
  starred = numeric(0),
  aff2 = NULL,
  margins = c(0.6, 1, 4.1, 1),
  ...
)

## S3 method for class 'singleton'
plot(
  x,
  marker = NULL,
  alleles = NULL,
  sep = "/",
  missing = "-",
  skip.empty.genotypes = FALSE,
  id.labels = NULL,
  title = NULL,
  available = FALSE,
  col = 1,
  deceased = numeric(0),
  starred = numeric(0),
  aff2 = NULL,
  margins = c(8, 0, 0, 0),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.linkdat_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object.</p>
</td></tr>
<tr><td><code id="plot.linkdat_+3A_marker">marker</code></td>
<td>
<p>either NULL, a vector of positive integers, a
<code><a href="#topic+marker">marker</a></code> object, or a list of <code>marker</code> objects. If NULL,
no genotypes are plotted.  If a <code>marker</code> object (or a list of such),
the genotypes are written below each individual in the pedigree, in the
format determined by <code>alleles</code>, <code>sep</code> and <code>missing</code>. If a
vector of integers is given, the corresponding marker objects are extracted
from <code>x$markerdata</code>.</p>
</td></tr>
<tr><td><code id="plot.linkdat_+3A_alleles">alleles</code></td>
<td>
<p>a character vector with allele names.</p>
</td></tr>
<tr><td><code id="plot.linkdat_+3A_sep">sep</code></td>
<td>
<p>a character of length 1 separating alleles for diploid markers.</p>
</td></tr>
<tr><td><code id="plot.linkdat_+3A_missing">missing</code></td>
<td>
<p>the symbol (integer or character) for missing alleles.</p>
</td></tr>
<tr><td><code id="plot.linkdat_+3A_skip.empty.genotypes">skip.empty.genotypes</code></td>
<td>
<p>a logical. If TRUE, and <code>marker</code> is
non-NULL, empty genotypes (which by default looks like '-/-') are not
printed.</p>
</td></tr>
<tr><td><code id="plot.linkdat_+3A_id.labels">id.labels</code></td>
<td>
<p>a vector with labels for each pedigree member. This defaults
to <code>x$plot.labels</code> is this is set (see <code><a href="#topic+setPlotLabels">setPlotLabels</a></code>),
otherwise to <code>as.character(x$orig.ids)</code>.</p>
</td></tr>
<tr><td><code id="plot.linkdat_+3A_title">title</code></td>
<td>
<p>the plot title. If NULL or &rdquo;, no title is added to the plot.</p>
</td></tr>
<tr><td><code id="plot.linkdat_+3A_available">available</code></td>
<td>
<p>either a logical, a colour name, or the word 'shaded'. If a
colour name is given, the available individuals (as defined by
<code>x$available</code>) are plotted in this colour.  If <code>available=F</code> no
colouring is used, while (for backwards compatibility) <code>available=T</code>
is equivalent to <code>available='red'</code>. The 'shaded' option results in
diagonal shading.</p>
</td></tr>
<tr><td><code id="plot.linkdat_+3A_col">col</code></td>
<td>
<p>a vector with colour indicators for the pedigree members. Recycled
if necessary. By default everyone is drawn black.</p>
</td></tr>
<tr><td><code id="plot.linkdat_+3A_deceased">deceased</code></td>
<td>
<p>a numeric containing ID's of deceased pedigree members.</p>
</td></tr>
<tr><td><code id="plot.linkdat_+3A_starred">starred</code></td>
<td>
<p>a numeric containing ID's of pedigree members that should be
marked with a star in the pedigree plot.</p>
</td></tr>
<tr><td><code id="plot.linkdat_+3A_aff2">aff2</code></td>
<td>
<p>NULL, or a numeric with affection statuses (2=affected,
1=unaffected, 0=unknown) for a second trait.</p>
</td></tr>
<tr><td><code id="plot.linkdat_+3A_margins">margins</code></td>
<td>
<p>a numeric of length 4 indicating the plot margins. For
singletons only the first element (the 'bottom' margin) is used.</p>
</td></tr>
<tr><td><code id="plot.linkdat_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code>plot.pedigree</code> in the
<code>kinship2</code> package. In particular <code>symbolsize</code> and <code>cex</code> can
be useful.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot.linkdat</code> is in essence a wrapper for <code>plot.pedigree</code> in the
<code>kinship2</code> package.
</p>


<h3>Author(s)</h3>

<p>Magnus Dehli Vigeland, Guro Doerum
</p>


<h3>See Also</h3>

<p><code><a href="kinship2.html#topic+plot.pedigree">plot.pedigree</a></code>, <code><a href="#topic+setPlotLabels">setPlotLabels</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(toyped)
x = linkdat(toyped)
plot(x, marker=1, alleles=c('a1','a2'), sep=' | ', deceased=2)

y = singleton(id=1)
m = marker(y, 1, c('A',0), alleles=c('A','B'))
plot(y, marker=m, id='indiv 1', title='Singleton', available=TRUE)

</code></pre>

<hr>
<h2 id='plotPedList'>Plot a list of pedigrees.</h2><span id='topic+plotPedList'></span>

<h3>Description</h3>

<p>This function creates a row of pedigree plots, each created by
<code><a href="#topic+plot.linkdat">plot.linkdat</a></code>.  Each parameter accepted by
<code><a href="#topic+plot.linkdat">plot.linkdat</a></code> can be applied here.  Some effort is made to guess
a reasonable window size and margins, but in general the user must be
prepared to do manual resizing of the plot window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPedList(
  plot.arg.list,
  widths = NA,
  frames = TRUE,
  frametitles = NULL,
  fmar = NA,
  newdev = FALSE,
  dev.height = NA,
  dev.width = NA,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPedList_+3A_plot.arg.list">plot.arg.list</code></td>
<td>
<p>A list of lists. Each element of <code>plot.arg.list</code> is
a list, where the first element is the <code><a href="#topic+linkdat">linkdat</a></code> object to be
plotted, and the remaining elements are passed on to <code>plot.linkdat</code>.
These elements must be correctly named. See examples below.</p>
</td></tr>
<tr><td><code id="plotPedList_+3A_widths">widths</code></td>
<td>
<p>A numeric vector of relative widths of the subplots. Recycled
to <code>length(plot.arg.list)</code> if necessary, before passed on to
<code><a href="graphics.html#topic+layout">layout</a></code>. Note that the vector does not need to sum to 1.</p>
</td></tr>
<tr><td><code id="plotPedList_+3A_frames">frames</code></td>
<td>
<p>Either a single logical (FALSE = no frames; TRUE = automatic
framing) or a list of numeric vectors: Each vector must consist of
consecutive integers, indicating subplots to be framed together. By default
the framing follows the list structure of <code>plot.arg.list</code>.</p>
</td></tr>
<tr><td><code id="plotPedList_+3A_frametitles">frametitles</code></td>
<td>
<p>A character vector of titles for each frame. If this is
non-NULL, titles for individuals subplots are ignored.</p>
</td></tr>
<tr><td><code id="plotPedList_+3A_fmar">fmar</code></td>
<td>
<p>A single number in the interval [0,0.5) controlling the position
of the frames.</p>
</td></tr>
<tr><td><code id="plotPedList_+3A_newdev">newdev</code></td>
<td>
<p>A logical, indicating if a new plot window should be opened.</p>
</td></tr>
<tr><td><code id="plotPedList_+3A_dev.height">dev.height</code>, <code id="plotPedList_+3A_dev.width">dev.width</code></td>
<td>
<p>The dimensions of the new device (only relevant
if newdev is TRUE). If these are NA suitable values are guessed from the
pedigree sizes.</p>
</td></tr>
<tr><td><code id="plotPedList_+3A_...">...</code></td>
<td>
<p>Further arguments passed on to each call to
<code><a href="#topic+plot.linkdat">plot.linkdat</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See various examples in the Examples section below.
</p>
<p>Note that for tweaking dev.height and dev.width the function
<code><a href="grDevices.html#topic+dev.size">dev.size</a></code> is useful to determine the size of the active device.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.linkdat">plot.linkdat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Simplest use: Just give a list of linkdat objects.
# To guess suitable plot window dimensions, use 'newdev=T'
peds = list(nuclearPed(3),cousinPed(2), singleton(12), halfCousinsPed(0))
plotPedList(peds) # try with newdev=TRUE

## Not run: 
# Modify the relative widths (which are not guessed)
widths = c(2, 3, 1, 2)
plotPedList(peds, widths=widths)

# In most cases the guessed dimensions are not perfect.
# Resize plot window manually, and then plot again with newdev=F (default)
# plotPedList(peds, widths=widths)

## Remove frames
plotPedList(peds, widths=widths, frames=F)

# Non-default frames
frames = list(1, 2:3)
plotPedList(peds, widths=widths, frames=frames, frametitles=c('First', 'Second'))

# To give *the same* parameter to all plots, it can just be added at the end:
margins=c(2,4,2,4)
title='Same title'
id.labels=''
symbolsize=1.5 # note: doesn't work as expected for singletons
plotPedList(peds, widths=widths, frames=frames, margins=margins, title=title,
            id.labels=id.labels, symbolsize=symbolsize)

# For more control of individual plots, each plot and all its parameters
# can be specified in its own list:
x1 = nuclearPed(3)
x1$available = 3:5
m1 = marker(x1, 3, 1:2)
marg1 = c(5,4,5,4)
plot1 = list(x1, marker=m1, margins=marg1, title='Plot 1', deceased=1:2)

x2 = cousinsPed(2)
x2$available = leaves(x2)
m2 = marker(x2, leaves(x2), 'A')
marg2 = c(3,4,2,4)
plot2 = list(x2, marker=m2, margins=marg2, title='Plot 2', symbolsize=1.2,
             skip.empty.genotypes=T)

x3 = singleton(12)
x3 = setAvailable(x3, 12)
marg3 = c(10,0,0,0)
plot3 = list(x3, margins=marg3, title='Plot 3', available='shaded', symbolsize=2)

x4 = halfCousinsPed(0)
names4 = c(Father=1, Brother=3, Sister=5)
marg4 = marg1
plot4 = list(x4, margins=marg4, title='Plot 4', id.labels=names4)

plotPedList(list(plot1, plot2, plot3, plot4), widths=c(2,3,1,2),
            frames=list(1,2:3,4), available=T, newdev=T)

# Different example:
plotPedList(list(halfCousinPed(4), cousinsPed(7)), title='Many generations',
    new=T, dev.height=9, dev.width=9)

## End(Not run)

</code></pre>

<hr>
<h2 id='randomPed'>Random pedigree</h2><span id='topic+randomPed'></span>

<h3>Description</h3>

<p>Creates a random medical pedigree with specified number of generations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>randomPed(
  gen,
  lambda = 2,
  penetrances = c(0, 1, 1),
  naff = "last.gen",
  founder.mut = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomPed_+3A_gen">gen</code></td>
<td>
<p>an integer in the interval <code>[2,5]</code> indicating the number of
generations.</p>
</td></tr>
<tr><td><code id="randomPed_+3A_lambda">lambda</code></td>
<td>
<p>a positive numeric. For each descendant of the first
generation, the number of offspring is sampled from a Poisson distribution
with parameter <code>lambda</code>.</p>
</td></tr>
<tr><td><code id="randomPed_+3A_penetrances">penetrances</code></td>
<td>
<p>a numeric of length 3, as in <code><a href="#topic+setModel">setModel</a></code>.</p>
</td></tr>
<tr><td><code id="randomPed_+3A_naff">naff</code></td>
<td>
<p>an integer specifying a lower bound on the number of affected
individuals, or the character 'last.gen'. The latter produce a pedigree
where at least one in the youngest generation is affected.</p>
</td></tr>
<tr><td><code id="randomPed_+3A_founder.mut">founder.mut</code></td>
<td>
<p>an integer, the number of disease alleles to be
distributed among the founders.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function produces a random simple pedigree. Each founder is given at most
one disease allele. At least one of the two top founders carries a disease
allele.
</p>


<h3>Value</h3>

<p>A <code>linkdat</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linkdat">linkdat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(randomPed(3))

# gives error message: Not enough founder mutations
## Not run: 
randomPed(gen=4, penetrances=c(0,0,1), naff=2, founder.mut=1)

## End(Not run)

</code></pre>

<hr>
<h2 id='readDatfile'>Read dat file in LINKAGE format</h2><span id='topic+readDatfile'></span>

<h3>Description</h3>

<p>Converts dat files in LINKAGE format to dat/map/freq files in MERLIN format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readDatfile(datfile, chrom, comment_string = "&lt;&lt;", write_to = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readDatfile_+3A_datfile">datfile</code></td>
<td>
<p>character. The path to the dat file.</p>
</td></tr>
<tr><td><code id="readDatfile_+3A_chrom">chrom</code></td>
<td>
<p>integer chromosome number (needed to create the MERLIN map).</p>
</td></tr>
<tr><td><code id="readDatfile_+3A_comment_string">comment_string</code></td>
<td>
<p>character indicating comments (which are removed before
processing).</p>
</td></tr>
<tr><td><code id="readDatfile_+3A_write_to">write_to</code></td>
<td>
<p>a character prefix used for naming the output files, or NULL
if no files should be written.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>write_to</code> is NULL, a list of data.frames named <code>dat</code>,
<code>map</code> and <code>freq</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# No example given.

</code></pre>

<hr>
<h2 id='relatednessCoeff'>Relatedness coefficients</h2><span id='topic+relatednessCoeff'></span><span id='topic+inbreeding'></span><span id='topic+kinship_coefs'></span><span id='topic+jacquard'></span><span id='topic+jacquard2'></span>

<h3>Description</h3>

<p>Computes inbreeding coefficients for all pedigree members, and Jacquard's
condensed identity coefficients for any pair of members. These are simple
wrappers for functions in other packages or external programs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inbreeding(x)

kinship_coefs(x, ids = NULL)

jacquard(x, ids)

jacquard2(x, ids, verbose = FALSE, cleanup = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relatednessCoeff_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object.</p>
</td></tr>
<tr><td><code id="relatednessCoeff_+3A_ids">ids</code></td>
<td>
<p>a integer vector of length 2.</p>
</td></tr>
<tr><td><code id="relatednessCoeff_+3A_verbose">verbose</code></td>
<td>
<p>a logical, indicating if messages from IdCoefs should be
printed.</p>
</td></tr>
<tr><td><code id="relatednessCoeff_+3A_cleanup">cleanup</code></td>
<td>
<p>a logical: If TRUE, the pedfile and sample file created for
the IdCoefs run are deleted automatically.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Both <code>inbreeding</code> and <code>kinship_coefs</code> are thin wrappers of
<code><a href="kinship2.html#topic+kinship">kinship</a></code>. <code>jacquard2</code>, executes an external
call to the C program <code>IdCoefs</code> (Abney, 2009). For this to
function, <code>IdCoefs</code> must be installed on the computer (see link in the
References section below) and the executable placed in a folder included in
the PATH variable. The <code>jacquard2</code> wrapper works by writing the
necessary files to disk and calling <code>IdCoefs</code> via <code><a href="base.html#topic+system">system</a></code>.
</p>


<h3>Value</h3>

<p>For <code>inbreeding</code>, a numerical vector with the inbreeding
coefficients, with names according to the ID labels <code>x$orig.ids</code>.<br />
For <code>kinship_coefs</code>, either a single numeric (if <code>ids</code> is a pair
of pedigree members) or the whole kinship matrix, with <code>x$orig.ids</code> as
dimnames.<br /> For <code>jaquard</code> and <code>jaquard2</code>, a numerical vector of
length 9 (in the standard order of Jacquard's condensed identity
coefficients).
</p>


<h3>References</h3>

<p>The <code>IdCoefs</code> program: Abney, Mark (2009). A graphical
algorithm for fast computation of identity coefficients and generalized
kinship coefficients. Bioinformatics, 25, 1561-1563.
<a href="http://home.uchicago.edu/~abney/abney_web/Software.html">http://home.uchicago.edu/~abney/abney_web/Software.html</a>
</p>


<h3>See Also</h3>

<p><code><a href="kinship2.html#topic+kinship">kinship</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Offspring of first cousins
x = cousinsPed(1, child=TRUE)
inb = inbreeding(x)
stopifnot(inb[9] == 1/16)

# if ID labels are not 1:9, care must be taken in extracting correct elements.
set.seed(1357)
y = relabel(x, sample(1:9))
child = leaves(y)
inbreeding(y)[child] #wrong
inb = inbreeding(y)[as.character(child)] #correct
inb
# the inbreeding coeff of the child equals the kinship coeff of parents
kin = kinship_coefs(y, parents(y, child))
stopifnot(inb==kin, inb==1/16)

</code></pre>

<hr>
<h2 id='relationLR'>Relationship Likelihood Ratio</h2><span id='topic+relationLR'></span>

<h3>Description</h3>

<p>Computes likelihood for two pedigrees and their ratio, the likelihood ratio
(LR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relationLR(
  ped_numerator,
  ped_denominator,
  ids,
  alleles,
  afreq = NULL,
  known_genotypes = list(),
  loop_breakers = NULL,
  Xchrom = FALSE,
  plot = TRUE,
  title1 = "",
  title2 = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relationLR_+3A_ped_numerator">ped_numerator</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object, or a list of several
linkdat and/or singleton objects, describing the relationship corresponding
to the hypothesis H1 (numerator).  If a list, the sets of ID labels must be
disjoint, that is, all ID labels must be unique.</p>
</td></tr>
<tr><td><code id="relationLR_+3A_ped_denominator">ped_denominator</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object, or a list of several
linkdat and/or singleton objects, describing the relationship corresponding
to the hypothesis H2 (denominator). ID labels must be consistent with
<code>ped_claim</code>.</p>
</td></tr>
<tr><td><code id="relationLR_+3A_ids">ids</code></td>
<td>
<p>genotyped individuals.</p>
</td></tr>
<tr><td><code id="relationLR_+3A_alleles">alleles</code></td>
<td>
<p>a numeric or character vector containing marker alleles names</p>
</td></tr>
<tr><td><code id="relationLR_+3A_afreq">afreq</code></td>
<td>
<p>a numerical vector with allele frequencies. An error is given if
they don't sum to 1 (rounded to 3 decimals).</p>
</td></tr>
<tr><td><code id="relationLR_+3A_known_genotypes">known_genotypes</code></td>
<td>
<p>list of triplets <code>(a, b, c)</code>, indicating that
individual <code>a</code> has genotype <code>b/c</code>. Missing value is 0.</p>
</td></tr>
<tr><td><code id="relationLR_+3A_loop_breakers">loop_breakers</code></td>
<td>
<p>Not yet implemented, only default value NULL currently
handled</p>
</td></tr>
<tr><td><code id="relationLR_+3A_xchrom">Xchrom</code></td>
<td>
<p>a logical: Is the marker on the X chromosome?</p>
</td></tr>
<tr><td><code id="relationLR_+3A_plot">plot</code></td>
<td>
<p>either a logical or the character 'plot_only', controlling if a
plot should be produced. If 'plot_only', a plot is drawn, but no further
computations are done.</p>
</td></tr>
<tr><td><code id="relationLR_+3A_title1">title1</code></td>
<td>
<p>a character, title of leftmost plot.</p>
</td></tr>
<tr><td><code id="relationLR_+3A_title2">title2</code></td>
<td>
<p>a character, title of rightmost plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function computes the likelihood of two pedigrees (each corresponding to
a hypothesis describing a family relationship).  The likelihood ratio is also
reported. Unlike other implementations we are aware of, partial DNA profiles
are allowed here. For instance, if the genotype of a person is reported as
1/0 (0 is 'missing') for a triallelic marker with uniform allele frequencies,
the possible ordered genotypes (1,1), (2,1), (1,2), (1,3) and (3,1) are
treated as equally likely. (For general allele frequencies, genotype
probabilities are obtained by assuming Hardy-Weinberg equilibrium.) A
reasonable future extension would be to allow the user to weigh these
genotypes; typically (1,1) may be more likely than the others.  If
<code>plot='plot_only'</code>, the function returns NULL after producing the plot.
</p>


<h3>Value</h3>

<table>
<tr><td><code>lik.numerator</code></td>
<td>
<p>likelihood of data given ped_numerator</p>
</td></tr>
<tr><td><code>lik.denominator</code></td>
<td>
<p>likelihood of data given ped_denominator</p>
</td></tr>
<tr><td><code>LR</code></td>
<td>
<p>likelihood ratio lik.numerator/lik.denominator</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Thore Egeland, Magnus Dehli Vigeland
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exclusionPower">exclusionPower</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
############################################
# A partial DNA profile is obtained from the person
# denoted 4 in the figure produced below
# There are two possibilities:
# H1: 4 is the missing relative of 3 and 6 (as shown to the left) or
# H2: 4 is unrelated to 3 and 6.
############################################
p = c(0.2, 0.8)
alleles = 1:length(p)
g3 = c(1,1); g4 = c(1,0); g6 = c(2,2)
x1 = nuclearPed(2)
x1 = addOffspring(x1, father = 4, sex = 1, noff = 1)
m = marker(x1, 3, g3, 4, g4, 6, g6, alleles = alleles, afreq = p)
x1 = addMarker(x1, m)
x2 = nuclearPed(2)
x2 = addOffspring(x2, father = 4, sex = 1, noff = 1)
m = marker(x2, 3, g3, 6, g6, alleles = alleles, afreq = p)
x2 = addMarker(x2, m)
missing = singleton(4, sex = 1)
m.miss = marker(missing, g4, alleles = alleles, afreq = p)
missing = addMarker(missing, m.miss)
x2 = relabel(x2, c(1:3, 99, 5:6), 1:6)
known = list(c(3, g3), c(4,g4), c(6, g6))
LR = relationLR(x1, list(x2, missing), ids = c(3,4,6),
                alleles = alleles, afreq = p, known = known,
                title1 = 'H1: Missing person 4 related',
                title2 = 'H2:Missing person 4 unrelated')$LR
# Formula:
p = p[1]
LR.a = (1+p)/(2*p*(2-p))
stopifnot(abs(LR - LR.a) &lt; 1e-10)

</code></pre>

<hr>
<h2 id='setAvailable'>Functions for modifying availability vectors</h2><span id='topic+setAvailable'></span><span id='topic+swapAvailable'></span>

<h3>Description</h3>

<p>Functions to set and modify the availability vector of a 'linkdat' object.
This vector is used in 'linkage.power' and 'linkageSim', indicating for whom
genotypes should be simulated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setAvailable(x, available)

swapAvailable(x, ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setAvailable_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object</p>
</td></tr>
<tr><td><code id="setAvailable_+3A_available">available</code></td>
<td>
<p>a numeric containing the IDs of available individuals.</p>
</td></tr>
<tr><td><code id="setAvailable_+3A_ids">ids</code></td>
<td>
<p>the individual(s) whose availability status should be swapped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The modified <code>linkdat</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.linkdat">plot.linkdat</a></code>, <code><a href="#topic+linkage.power">linkage.power</a></code>,
<code><a href="#topic+linkageSim">linkageSim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(toyped)
x = linkdat(toyped)
x = setAvailable(x, 3:4)
x = swapAvailable(x, 2:3)
x$available

</code></pre>

<hr>
<h2 id='setModel'>Set, change or display the model parameters for 'linkdat' objects</h2><span id='topic+setModel'></span><span id='topic+print.linkdat.model'></span>

<h3>Description</h3>

<p>Functions to set, change and display model parameters involved in parametric
linkage analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setModel(x, model = NULL, chrom = NULL, penetrances = NULL, dfreq = NULL)

## S3 method for class 'linkdat.model'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setModel_+3A_x">x</code></td>
<td>
<p>in <code>setModel</code>: a <code><a href="#topic+linkdat">linkdat</a></code> object. In
<code>print.linkdat.model</code>: a <code>linkdat.model</code> object.</p>
</td></tr>
<tr><td><code id="setModel_+3A_model">model</code></td>
<td>
<p>NULL, or an object of class <code>linkdat.model</code>, namely a list
with elements <code>chrom</code>, <code>penetrances</code> and <code>dfreq</code>.  In the
<code>setModel</code> function, the <code>model</code> argument can be one of the
integers 1-4, with the following meanings:
</p>
<p>1 = autosomal dominant; fully penetrant, dfreq=1e-5
</p>
<p>2 = autosomal recessive; fully penetrant, dfreq=1e-5
</p>
<p>3 = X-linked dominant; fully penetrant, dfreq=1e-5
</p>
<p>4 = X-linked recessive; fully penetrant, dfreq=1e-5</p>
</td></tr>
<tr><td><code id="setModel_+3A_chrom">chrom</code></td>
<td>
<p>a character, either 'AUTOSOMAL' or 'X'. Lower case versions are
allowed and will be converted automatically.</p>
</td></tr>
<tr><td><code id="setModel_+3A_penetrances">penetrances</code></td>
<td>
<p>if <code>chrom=='AUTOSOMAL'</code>: a numeric of length 3 -
<code>(f0, f1, f2)</code> - where <code>fi</code> is the probability of being affected
given <code>i</code> disease alleles.
</p>
<p>If <code>chrom=='X'</code>: a list of two vectors, containing the penetrances for
each sex: <code>penetrances = list(male=c(f0, f1), female=c(f0, f1, f2))</code>.</p>
</td></tr>
<tr><td><code id="setModel_+3A_dfreq">dfreq</code></td>
<td>
<p>the population frequency of the disease allele.</p>
</td></tr>
<tr><td><code id="setModel_+3A_...">...</code></td>
<td>
<p>further parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>setModel</code> returns a new <code>linkdat</code> object, whose
<code>model</code> entry is a <code>linkdat.model</code> object: A list containing the
given <code>chrom</code>, <code>penetrances</code> and <code>dfreq</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linkdat">linkdat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(toyped)
x = linkdat(toyped)
x1 = setModel(x, model=1)
summary(x1)

# The shortcut 'model=1' above is equivalent to
x2 = setModel(x, chrom='AUTOSOMAL', penetrances=c(0,1,1), dfreq=1e-5)
stopifnot(all.equal(x1, x2))

# X-linked recessive model:
y1 = setModel(x, model=4, dfreq=0.01)
summary(y1)

# Long version of the above:
y2 = setModel(x, chrom='X', penetrances=list(male=c(0,1), female=c(0,0,1)),
              dfreq=0.01)
stopifnot(all.equal(y1, y2))

stopifnot(all.equal(y1, setModel(x, y1$model)))

</code></pre>

<hr>
<h2 id='setPlotLabels'>Attach plot labels to a linkdat object</h2><span id='topic+setPlotLabels'></span>

<h3>Description</h3>

<p>This function attaches (or modifies) a character vector of plotting labels
for the pedigree members of a linkdat object. This is useful since only
numerical ID's are allowed in defining pedigrees in paramlink.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPlotLabels(x, labels, ids = x$orig.ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPlotLabels_+3A_x">x</code></td>
<td>
<p>A linkdat object.</p>
</td></tr>
<tr><td><code id="setPlotLabels_+3A_labels">labels</code></td>
<td>
<p>A character vector of the same length as <code>ids</code>.</p>
</td></tr>
<tr><td><code id="setPlotLabels_+3A_ids">ids</code></td>
<td>
<p>A numeric vector of numerical IDs. Must be a subset of
<code>x$orig.ids</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new linkdat object, differing from <code>x</code> only in
<code>x$plot.labels</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.linkdat">plot.linkdat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = nuclearPed(1)
x = setPlotLabels(x, labels=c('Father', 'Mother', 'Son'))
plot(x)

</code></pre>

<hr>
<h2 id='showInTriangle'>Add points to the IBD triangle</h2><span id='topic+showInTriangle'></span>

<h3>Description</h3>

<p>Utility function for plotting points in the IBD triangle.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>showInTriangle(
  k0,
  k2 = NULL,
  new = T,
  col = "blue",
  cex = 1,
  pch = 4,
  lwd = 2,
  labels = NULL,
  col_labels = col,
  cex_labels = 0.8,
  pos = 1,
  adj = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showInTriangle_+3A_k0">k0</code>, <code id="showInTriangle_+3A_k2">k2</code></td>
<td>
<p>Numerical vectors giving coordinates for points to be plotted in
the IBDtriangle.</p>
</td></tr>
<tr><td><code id="showInTriangle_+3A_new">new</code></td>
<td>
<p>Logical indicating if a new IBDtriangle should be drawn.</p>
</td></tr>
<tr><td><code id="showInTriangle_+3A_col">col</code>, <code id="showInTriangle_+3A_cex">cex</code>, <code id="showInTriangle_+3A_pch">pch</code>, <code id="showInTriangle_+3A_lwd">lwd</code></td>
<td>
<p>Parameters passed onto <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="showInTriangle_+3A_labels">labels</code></td>
<td>
<p>A character of same length as <code>k0</code>, or NULL.</p>
</td></tr>
<tr><td><code id="showInTriangle_+3A_col_labels">col_labels</code>, <code id="showInTriangle_+3A_cex_labels">cex_labels</code>, <code id="showInTriangle_+3A_pos">pos</code>, <code id="showInTriangle_+3A_adj">adj</code></td>
<td>
<p>Parameters passed onto
<code><a href="graphics.html#topic+text">text</a></code> (if <code>labels</code> is non-NULL).</p>
</td></tr>
<tr><td><code id="showInTriangle_+3A_...">...</code></td>
<td>
<p>Plot arguments passed on to <code>IBDtriangle</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+IBDtriangle">IBDtriangle</a></code>, <code><a href="#topic+examineKinships">examineKinships</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
showInTriangle(k0=3/8, k2=1/8, label="3/4 siblings", pos=1)

</code></pre>

<hr>
<h2 id='simpleSim'>Unconditional marker simulation</h2><span id='topic+simpleSim'></span>

<h3>Description</h3>

<p>Unconditional simulation of unlinked markers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simpleSim(
  x,
  N,
  alleles,
  afreq,
  available,
  Xchrom = FALSE,
  mutmat = NULL,
  seed = NULL,
  verbose = T
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simpleSim_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> object</p>
</td></tr>
<tr><td><code id="simpleSim_+3A_n">N</code></td>
<td>
<p>a positive integer: the number of markers to be simulated</p>
</td></tr>
<tr><td><code id="simpleSim_+3A_alleles">alleles</code></td>
<td>
<p>a vector containing the allele names. If missing, the alleles
are taken to be <code>seq_along(afreq)</code>.</p>
</td></tr>
<tr><td><code id="simpleSim_+3A_afreq">afreq</code></td>
<td>
<p>a vector of length 2 containing the population frequencies for
the alleles. If missing, the alleles are assumed equifrequent.</p>
</td></tr>
<tr><td><code id="simpleSim_+3A_available">available</code></td>
<td>
<p>a vector containing IDs of the available individuals, i.e.
those whose genotypes should be simulated.</p>
</td></tr>
<tr><td><code id="simpleSim_+3A_xchrom">Xchrom</code></td>
<td>
<p>a logical: X linked markers or not?</p>
</td></tr>
<tr><td><code id="simpleSim_+3A_mutmat">mutmat</code></td>
<td>
<p>a mutation matrix, or a list of two such matrices named
'female' and 'male'. The matrix/matrices must be square, with the allele
labels as dimnames, and each row must sum to 1 (after rounding to 3
decimals).</p>
</td></tr>
<tr><td><code id="simpleSim_+3A_seed">seed</code></td>
<td>
<p>NULL, or a numeric seed for the random number generator.</p>
</td></tr>
<tr><td><code id="simpleSim_+3A_verbose">verbose</code></td>
<td>
<p>a logical.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This simulation is done by distributing alleles randomly to all founders,
followed by unconditional gene dropping down throughout the pedigree (i.e.
for each non-founder a random allele is selected from each of the parents).
Finally the genotypes of any individuals not included in <code>available</code> are
removed.
</p>


<h3>Value</h3>

<p>a <code>linkdat</code> object equal to <code>x</code> in all respects except its
<code>markerdata</code> entry, which consists of the <code>N</code> simulated markers.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+markerSim">markerSim</a></code>, <code><a href="#topic+linkageSim">linkageSim</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = nuclearPed(1)
simpleSim(x, N=3, afreq=c(0.5, 0.5))

y = addOffspring(cousinPed(1), father=7, mother=8, noffs=1)
simpleSim(y, N=3, alleles=LETTERS[1:10])

</code></pre>

<hr>
<h2 id='toyped'>Toy pedigree for linkage analysis</h2><span id='topic+toyped'></span>

<h3>Description</h3>

<p>Toy pedigree with 4 individuals typed at a single SNP marker. Individual 1 is
missing one allele.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toyped
</code></pre>


<h3>Format</h3>

<p>A data frame with 4 rows and 8 columns
</p>


<h3>Details</h3>

<p>The format is standard LINKAGE (pre-makeped) format, with columns as follows:
</p>

<ul>
<li><p> FAMID. Family ID
</p>
</li>
<li><p> ID. Individual ID
</p>
</li>
<li><p> FID. Father ID
</p>
</li>
<li><p> MID. Mother ID
</p>
</li>
<li><p> SEX. Gender (male=1, female=2)
</p>
</li>
<li><p> AFF. Affection status (unaffected=1, affected=2, unknown=0)
</p>
</li>
<li><p> M_A1. First allele of marker 1
</p>
</li>
<li><p> M_A2. Second allele of marker 1
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
toyped
linkdat(toyped)

</code></pre>

<hr>
<h2 id='transferMarkerdata'>Transfer marker data</h2><span id='topic+transferMarkerdata'></span>

<h3>Description</h3>

<p>Transfer marker data between pedigrees (in the form of <code><a href="#topic+linkdat">linkdat</a></code>
objects). Both the source and target can be lists of linkdat and/or singleton
objects (these must have disjoint ID sets). Any previous marker data of the
target is overwritten.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transferMarkerdata(from, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transferMarkerdata_+3A_from">from</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> or <code><a href="#topic+singleton">singleton</a></code> object, or a
list of such objects.</p>
</td></tr>
<tr><td><code id="transferMarkerdata_+3A_to">to</code></td>
<td>
<p>a <code><a href="#topic+linkdat">linkdat</a></code> or <code><a href="#topic+singleton">singleton</a></code> object, or a
list of such objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>linkdat</code> object (or a list of such) similar to <code>to</code>, but
where all individuals also present in <code>from</code> have marker genotypes
copied over.  Any previous marker data is erased.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linkdat">linkdat</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = list(singleton(id=5), nuclearPed(noffs=2))
x = markerSim(x, N=5, alleles=1:5, verbose=FALSE, available=4:5)
y = nuclearPed(noffs=3)
y = transferMarkerdata(x, y)
stopifnot(all.equal(x[[1]], branch(y,5)))
stopifnot(all.equal(x[[2]], subset(y,1:4)))

</code></pre>

<hr>
<h2 id='twoloops'>A consanguineous pedigree</h2><span id='topic+twoloops'></span>

<h3>Description</h3>

<p>A consanguineous pedigree with two inbreeding loops.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoloops
</code></pre>


<h3>Format</h3>

<p>A data frame with 17 rows and 6 columns.
See <code><a href="#topic+toyped">toyped</a></code> for details about the format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = linkdat(twoloops)
plot(x)

</code></pre>

<hr>
<h2 id='twoMarkerDistribution'>Genotype probability distribution</h2><span id='topic+twoMarkerDistribution'></span>

<h3>Description</h3>

<p>Computes the joint genotype distribution of two markers for a specified
pedigree member, conditional on existing genotypes and pedigree information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoMarkerDistribution(
  x,
  id,
  partialmarker1,
  partialmarker2,
  theta,
  loop_breakers = NULL,
  eliminate = 99,
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="twoMarkerDistribution_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+linkdat">linkdat</a></code> object.</p>
</td></tr>
<tr><td><code id="twoMarkerDistribution_+3A_id">id</code></td>
<td>
<p>The individual in question.</p>
</td></tr>
<tr><td><code id="twoMarkerDistribution_+3A_partialmarker1">partialmarker1</code>, <code id="twoMarkerDistribution_+3A_partialmarker2">partialmarker2</code></td>
<td>
<p>Either a single integer indicating the
number of one of <code>x</code>'s existing markers, or a <code>marker</code> object.</p>
</td></tr>
<tr><td><code id="twoMarkerDistribution_+3A_theta">theta</code></td>
<td>
<p>A single numeric in the interval [0, 0.5] - the recombination
fraction between the two markers.</p>
</td></tr>
<tr><td><code id="twoMarkerDistribution_+3A_loop_breakers">loop_breakers</code></td>
<td>
<p>A numeric containing IDs of individuals to be used as
loop breakers. Relevant only if the pedigree has loops. See
<code><a href="#topic+breakLoops">breakLoops</a></code>.</p>
</td></tr>
<tr><td><code id="twoMarkerDistribution_+3A_eliminate">eliminate</code></td>
<td>
<p>A non-negative integer, indicating the number of iterations
in the internal genotype-compatibility algorithm. Positive values can save
time if <code>partialmarker</code> is non-empty and the number of alleles is
large.</p>
</td></tr>
<tr><td><code id="twoMarkerDistribution_+3A_verbose">verbose</code></td>
<td>
<p>A logical.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named matrix giving the joint genotype distribution.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+oneMarkerDistribution">oneMarkerDistribution</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x = nuclearPed(2)
emptySNP = marker(x, alleles=c('a','b'))
SNP1 = marker(x, 1, c(1,1), 2, c(1,0), alleles=1:2, afreq=c(0.1, 0.9))
twoMarkerDistribution(x, id=2, emptySNP, SNP1, theta=0)
twoMarkerDistribution(x, id=2, emptySNP, SNP1, theta=0.5)
twoMarkerDistribution(x, id=3, emptySNP, SNP1, theta=0.5)

# X-linked example
SNPX_1 = marker(x, 2, c('a','b'), 3, 'b', alleles=c('a','b'), chrom=23)
SNPX_2 = marker(x, 2, c('a','b'), 3, 'b', alleles=c('a','b'), chrom=23)
r1 = twoMarkerDistribution(x, id=4, SNPX_1, SNPX_2, theta=0)
r2 = twoMarkerDistribution(x, id=4, SNPX_1, SNPX_2, theta=0.5)
stopifnot(all(r1==c(.5,0,0,.5)), all(r2==c(.25,.25,.25,.25)))

</code></pre>

<hr>
<h2 id='Xped'>Example pedigree with X-linked disease pattern.</h2><span id='topic+Xped'></span>

<h3>Description</h3>

<p>A complex pedigree with an X-linked recessive disease pattern
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Xped
</code></pre>


<h3>Format</h3>

<p>A data frame with 15 rows and 6 columns. See <code><a href="#topic+toyped">toyped</a></code> for
details about the format.
</p>


<h3>Details</h3>

<p>The format is standard LINKAGE (pre-makeped) format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Xped

# Convert to a 'linkdat' object and set a recessive X-linked model:
x = linkdat(Xped, model=4)
summary(x)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
